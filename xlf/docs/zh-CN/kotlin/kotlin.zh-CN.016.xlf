<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="c57e5e1c183d06345fa4f91784753426d2cd7cbe" translate="yes" xml:space="preserve">
          <source>If a class has a &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;companion object&lt;/a&gt; defined, you can also define extension functions and properties for the companion object. Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">如果类定义了&lt;a href=&quot;object-declarations#companion-objects&quot;&gt;伴随对象&lt;/a&gt;，则还可以定义伴随对象的扩展功能和属性。就像伴随对象的常规成员一样，可以仅使用类名作为限定符来调用它们：</target>
        </trans-unit>
        <trans-unit id="a60ec0b587e0996e818004264195b3afcc09cec1" translate="yes" xml:space="preserve">
          <source>If a class has a &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;companion object&lt;/a&gt; defined, you can also define extension functions and properties for the companion object:</source>
          <target state="translated">如果类定义了&lt;a href=&quot;object-declarations#companion-objects&quot;&gt;伴随对象&lt;/a&gt;，则还可以定义伴随对象的扩展功能和属性：</target>
        </trans-unit>
        <trans-unit id="4764e437b4a8e0194f97255ccbb034043a390f71" translate="yes" xml:space="preserve">
          <source>If a class has a member function, and an extension function is defined which has the same receiver type, the same name is applicable to given arguments, the &lt;strong&gt;member always wins&lt;/strong&gt;. For example:</source>
          <target state="translated">如果一个类具有成员函数，并且定义了具有相同接收者类型的扩展函数，则相同名称适用于给定参数，则该&lt;strong&gt;成员始终为win&lt;/strong&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="9198c3448fff5eb29091025ac1cdca923057a3b0" translate="yes" xml:space="preserve">
          <source>If a class has a member function, and an extension function is defined which has the same receiver type, the same name, and is applicable to given arguments, the &lt;strong&gt;member always wins&lt;/strong&gt;. For example:</source>
          <target state="translated">如果一个类具有成员函数，并且定义了一个扩展函数，该函数具有相同的接收者类型，相同的名称并且适用于给定的参数，则该&lt;strong&gt;成员始终为win&lt;/strong&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="b0751c2dcab880d762e9ac5f2b150da0f43d1aeb" translate="yes" xml:space="preserve">
          <source>If a class has two properties which are conceptually the same but one is part of a public API and another is an implementation detail, use an underscore as the prefix for the name of the private property:</source>
          <target state="translated">如果一个类有两个概念上相同的属性,但一个是公共API的一部分,另一个是实现细节,则使用下划线作为私有属性名称的前缀。</target>
        </trans-unit>
        <trans-unit id="62aeef1d35409f9d2a0e16b783bc032764ff6cdc" translate="yes" xml:space="preserve">
          <source>If a class or a function from a library is marked by its author as experimental, using it in your code will produce warnings or compilation errors unless you explicitly accept their experimental status. There are several ways to accept the experimental status of API elements; all of them are applicable without technical limitations. You are free to choose the way that you find best for your situation.</source>
          <target state="translated">如果一个类或一个库中的函数被其作者标记为实验性的,那么在你的代码中使用它就会产生警告或编译错误,除非你明确接受它们的实验性状态。有几种方法可以接受API元素的实验状态;所有这些方法都是适用的,没有技术限制。你可以自由选择你认为最适合你情况的方式。</target>
        </trans-unit>
        <trans-unit id="b68424f5ba6a2078bd8f39139d9b1b4eecca3f3f" translate="yes" xml:space="preserve">
          <source>If a component of the destructured parameter is unused, you can replace it with the underscore to avoid inventing its name:</source>
          <target state="translated">如果解构参数的某个组件未被使用,可以用下划线代替,以避免发明其名称。</target>
        </trans-unit>
        <trans-unit id="69396f6988ae56a2b749974b16702f3935d83bf9" translate="yes" xml:space="preserve">
          <source>If a coroutine encounters an exception other than &lt;code&gt;CancellationException&lt;/code&gt;, it cancels its parent with that exception. This behaviour cannot be overridden and is used to provide stable coroutines hierarchies for &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/composing-suspending-functions.md#structured-concurrency-with-async&quot;&gt;structured concurrency&lt;/a&gt;. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; implementation is not used for child coroutines.</source>
          <target state="translated">如果协程遇到 &lt;code&gt;CancellationException&lt;/code&gt; 以外的其他异常，它将取消带有该异常的父对象。此行为不能被覆盖，并且用于为&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/composing-suspending-functions.md#structured-concurrency-with-async&quot;&gt;结构化并发&lt;/a&gt;提供稳定的协程层次结构。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;实现不用于子协程。</target>
        </trans-unit>
        <trans-unit id="c6f280ee1c596a483e44dc5cd919a56f36a6fc8d" translate="yes" xml:space="preserve">
          <source>If a coroutine encounters exception other than &lt;code&gt;CancellationException&lt;/code&gt;, it cancels its parent with that exception. This behaviour cannot be overridden and is used to provide stable coroutines hierarchies for &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/composing-suspending-functions.md#structured-concurrency-with-async&quot;&gt;structured concurrency&lt;/a&gt; which do not depend on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; implementation. The original exception is handled by the parent when all its children terminate.</source>
          <target state="translated">如果协程遇到 &lt;code&gt;CancellationException&lt;/code&gt; 以外的异常，它将取消带有该异常的父对象。此行为不能被覆盖，并且用于为不依赖于&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;实现的&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/composing-suspending-functions.md#structured-concurrency-with-async&quot;&gt;结构化并发&lt;/a&gt;提供稳定的协程层次结构。当父级的所有子级终止时，父级将处理原始异常。</target>
        </trans-unit>
        <trans-unit id="d2d462cd8e9ba3b7d699994700c496f2c560b29d" translate="yes" xml:space="preserve">
          <source>If a declaration has multiple modifiers, always put them in the following order:</source>
          <target state="translated">如果一个声明有多个修饰符,总是按以下顺序排列。</target>
        </trans-unit>
        <trans-unit id="1c324efe9f900ec5ab9502805d87c655d837da4d" translate="yes" xml:space="preserve">
          <source>If a default parameter precedes a parameter with no default value, the default value can only be used by calling the function with &lt;a href=&quot;#named-arguments&quot;&gt;named arguments&lt;/a&gt;:</source>
          <target state="translated">如果默认参数在没有默认值的参数之前，则只能通过调用带有&lt;a href=&quot;#named-arguments&quot;&gt;命名参数&lt;/a&gt;的函数来使用默认值：</target>
        </trans-unit>
        <trans-unit id="c5fa62c81704299df516dd7c041a8d480c196b9b" translate="yes" xml:space="preserve">
          <source>If a default type qualifier uses a type qualifier nickname and they are both &lt;code&gt;@UnderMigration&lt;/code&gt;, the status from the default type qualifier is used.</source>
          <target state="translated">如果默认类型限定符使用类型限定符昵称并且它们都为 &lt;code&gt;@UnderMigration&lt;/code&gt; ，则使用默认类型限定符的状态。</target>
        </trans-unit>
        <trans-unit id="8fb1b7879228c51bc49251497614be1617615253" translate="yes" xml:space="preserve">
          <source>If a file doesn't declare a package, it belongs to the nameless &lt;em&gt;default package&lt;/em&gt;. This should be avoided, as it will make it hard to reference the symbols from that file in case of naming conflicts (you can't explicitly import the empty package).</source>
          <target state="translated">如果文件未声明包，则它属于无名&lt;em&gt;默认包&lt;/em&gt;。应该避免这种情况，因为在命名冲突的情况下，它将很难从该文件中引用符号（您不能显式导入空包）。</target>
        </trans-unit>
        <trans-unit id="f5fbea4c3aea4496e7e7b00414d2fcaa5869dd61" translate="yes" xml:space="preserve">
          <source>If a function does not return any useful value, its return type is &lt;code&gt;Unit&lt;/code&gt;. &lt;code&gt;Unit&lt;/code&gt; is a type with only one value - &lt;code&gt;Unit&lt;/code&gt;. This value does not have to be returned explicitly:</source>
          <target state="translated">如果函数不返回任何有用的值，则其返回类型为 &lt;code&gt;Unit&lt;/code&gt; 。 &lt;code&gt;Unit&lt;/code&gt; 是只有一个值的类型- &lt;code&gt;Unit&lt;/code&gt; 。此值不必显式返回：</target>
        </trans-unit>
        <trans-unit id="586ae5a6f0a2e9992a680dbe096f9f0a203405b4" translate="yes" xml:space="preserve">
          <source>If a function returns Unit, the return type should be omitted:</source>
          <target state="translated">如果函数返回Unit,则应省略返回类型。</target>
        </trans-unit>
        <trans-unit id="26ffbbf2f8c7a69e516fd6f5e5fb01c4807e2577" translate="yes" xml:space="preserve">
          <source>If a generic type has several type parameters each of them can be projected independently. For example, if the type is declared as &lt;code&gt;interface Function&amp;lt;in T, out U&amp;gt;&lt;/code&gt; we can imagine the following star-projections:</source>
          <target state="translated">如果泛型类型具有多个类型参数，则每个参数都可以独立投影。例如，如果将类型声明为 &lt;code&gt;interface Function&amp;lt;in T, out U&amp;gt;&lt;/code&gt; 我们可以想象以下星形投影：</target>
        </trans-unit>
        <trans-unit id="70975e077538a847ffe5a0e5b87f2c6b9c2f7e0c" translate="yes" xml:space="preserve">
          <source>If a library author marks a declaration from a library's API as &lt;a href=&quot;#requiring-opt-in-for-api&quot;&gt;&lt;em&gt;requiring opt-in&lt;/em&gt;&lt;/a&gt;, you should give an explicit consent for using it in your code. There are several ways to opt in to such APIs, all applicable without technical limitations. You are free to choose the way that you find best for your situation.</source>
          <target state="translated">如果图书馆作者将图书馆API的声明标记为&lt;a href=&quot;#requiring-opt-in-for-api&quot;&gt;&lt;em&gt;要求加入&lt;/em&gt;&lt;/a&gt;，则您应明确同意在代码中使用它。可以采用多种方式选择加入此类API，所有方法均不受技术限制。您可以自由选择最适合自己情况的方式。</target>
        </trans-unit>
        <trans-unit id="c54bed7a1e50c0cec37b385196df44d20ab05f40" translate="yes" xml:space="preserve">
          <source>If a library consumer defines variants that are missing in the library, they need to provide matching fallbacks. For example, if a library does not have or does not publish a staging build type, the library consumer must provide a fallback for the consumers who have such a build type, specifying at least one of the build types that the library publishes:</source>
          <target state="translated">如果一个库消费者定义了库中缺少的变体,他们需要提供匹配的后备。例如,如果一个库没有或没有发布暂存构建类型,库消费者必须为有这种构建类型的消费者提供后备,指定至少一种库发布的构建类型。</target>
        </trans-unit>
        <trans-unit id="de5d80fa791bb5a89bb7999f43e44154d9f7a1b7" translate="yes" xml:space="preserve">
          <source>If a library has a 'root' publication, the consumer may specify a single dependency on the library as a whole in a common source set, and a corresponding platform-specific variant will be chosen, if available, for each of the compilations that include this dependency. Consider a &lt;code&gt;sample-lib&lt;/code&gt; library built for the JVM and JS and published with a 'root' publication:</source>
          <target state="translated">如果某个库具有&amp;ldquo;根&amp;rdquo;发布，则使用者可以在一个公共源集中指定对整个库的单个依赖项，并且将为包括以下内容的每个编译选择一个对应的特定于平台的变体（如果有）。这种依赖性。考虑为JVM和JS构建的 &lt;code&gt;sample-lib&lt;/code&gt; 库，并以&amp;ldquo; root&amp;rdquo;出版物发布：</target>
        </trans-unit>
        <trans-unit id="2b6d1027059f87a94c39781325c4a38d3fd36ee6" translate="yes" xml:space="preserve">
          <source>If a member function or property is declared as &lt;code&gt;open&lt;/code&gt;, subclasses may &lt;em&gt;override&lt;/em&gt; it by providing a new implementation. Let's say that &lt;code&gt;MotorVehicle&lt;/code&gt; declares this function:</source>
          <target state="translated">如果成员函数或属性被声明为 &lt;code&gt;open&lt;/code&gt; ，则子类可以通过提供新的实现来&lt;em&gt;覆盖&lt;/em&gt;它。假设 &lt;code&gt;MotorVehicle&lt;/code&gt; 声明了此函数：</target>
        </trans-unit>
        <trans-unit id="3b05658c0676c78c2f6ecac73f01698365f225fb" translate="yes" xml:space="preserve">
          <source>If a method has N parameters and M of which have default values, M overloads are generated: the first one takes N-1 parameters (all but the last one that takes a default value), the second takes N-2 parameters, and so on.</source>
          <target state="translated">如果一个方法有N个参数,其中M个参数有缺省值,就会产生M个重载:第一个重载取N-1个参数(除了最后一个取缺省值的参数外,其他都是),第二个重载取N-2个参数,以此类推。</target>
        </trans-unit>
        <trans-unit id="a6a3dbe7a3c930fff25db8be2ac42bb4869e7083" translate="yes" xml:space="preserve">
          <source>If a module is an endpoint application which is not published, use &lt;code&gt;implementation&lt;/code&gt; dependencies instead of &lt;code&gt;api&lt;/code&gt; dependencies.</source>
          <target state="translated">如果模块是未发布的终结点应用程序，请使用 &lt;code&gt;implementation&lt;/code&gt; 依赖关系而不是 &lt;code&gt;api&lt;/code&gt; 依赖关系。</target>
        </trans-unit>
        <trans-unit id="187f8c5b91bd6882618c5a62bdf223a239fa7e78" translate="yes" xml:space="preserve">
          <source>If a non-abstract class does not declare any constructors (primary or secondary), it will have a generated primary constructor with no arguments. The visibility of the constructor will be public. If you do not want your class to have a public constructor, you need to declare an empty primary constructor with non-default visibility:</source>
          <target state="translated">如果一个非抽象类没有声明任何构造函数(primary或secondary),它将有一个生成的主构造函数,没有参数。构造函数的可见性将是公共的。如果你不希望你的类有一个公共的构造函数,你需要声明一个非默认可见性的空主构造函数。</target>
        </trans-unit>
        <trans-unit id="29905ed43abbefe9d905d1bc7ab8a797a47bb7d9" translate="yes" xml:space="preserve">
          <source>If a project consists of both Kotlin and Java source code, while it is possible to use &lt;em&gt;kotlinc&lt;/em&gt;, to avoid repetition of task parameters, it is recommended to use &lt;em&gt;withKotlin&lt;/em&gt; task:</source>
          <target state="translated">如果项目同时包含Kotlin和Java源代码，则可以使用&lt;em&gt;kotlinc&lt;/em&gt;，以避免重复任务参数，但建议使用&lt;em&gt;withKotlin&lt;/em&gt;任务：</target>
        </trans-unit>
        <trans-unit id="609654c2fad938d0263a48e6bf332c23223482ab" translate="yes" xml:space="preserve">
          <source>If a project consists of multiple source roots, use &lt;em&gt;src&lt;/em&gt; as elements to define paths:</source>
          <target state="translated">如果项目包含多个源根，请使用&lt;em&gt;src&lt;/em&gt;作为元素来定义路径：</target>
        </trans-unit>
        <trans-unit id="6ed938136219853ee5b7c06664d635c5b5eff6f0" translate="yes" xml:space="preserve">
          <source>If a sequence operation returns another sequence, which is produced lazily, it's called &lt;em&gt;intermediate&lt;/em&gt;. Otherwise, the operation is &lt;em&gt;terminal&lt;/em&gt;. Examples of terminal operations are &lt;a href=&quot;constructing-collections#copying&quot;&gt;&lt;code&gt;toList()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;collection-aggregate&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt;. Sequence elements can be retrieved only with terminal operations.</source>
          <target state="translated">如果序列操作返回延迟生成的另一个序列，则称为&amp;ldquo; &lt;em&gt;中间&amp;rdquo;&lt;/em&gt;。否则，操作为&lt;em&gt;terminal&lt;/em&gt;。终端操作的示例是&lt;a href=&quot;constructing-collections#copying&quot;&gt; &lt;code&gt;toList()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;collection-aggregate&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt;。只能通过终端操作才能检索顺序元素。</target>
        </trans-unit>
        <trans-unit id="30e6ccb06323d447af741e2670a8825971c56bf1" translate="yes" xml:space="preserve">
          <source>If a supertype has a constructor, appropriate constructor parameters must be passed to it. Many supertypes may be specified as a comma-separated list after the colon:</source>
          <target state="translated">如果一个超类型有一个构造函数,那么必须向它传递适当的构造函数参数。许多超类型可以在冒号后以逗号分隔的列表形式指定。</target>
        </trans-unit>
        <trans-unit id="71ee75455c68258fcc7798b0e5a90d8dadcef5cd" translate="yes" xml:space="preserve">
          <source>If a supertype has the &lt;code&gt;componentN()&lt;/code&gt; functions that are &lt;em&gt;open&lt;/em&gt; and return compatible types, the corresponding functions are generated for the data class and override those of the supertype. If the functions of the supertype cannot be overridden due to incompatible signatures or being final, an error is reported;</source>
          <target state="translated">如果超类型具有&lt;em&gt;打开&lt;/em&gt;并返回兼容类型的 &lt;code&gt;componentN()&lt;/code&gt; 函数，则将为数据类生成相应的函数，并覆盖超类型的那些函数。如果由于不兼容的签名或终结而无法覆盖超类型的功能，则会报告错误；否则，将报告错误。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28f4bb4cbd876a2710b0efbbf4b0592357748708" translate="yes" xml:space="preserve">
          <source>If a top-level declaration is marked &lt;em&gt;private&lt;/em&gt;, it is private to the file it's declared in (see &lt;a href=&quot;visibility-modifiers&quot;&gt;Visibility Modifiers&lt;/a&gt;).</source>
          <target state="translated">如果顶级声明被标记为&lt;em&gt;private&lt;/em&gt;，则它对于在其中声明的文件是私有的（请参见&lt;a href=&quot;visibility-modifiers&quot;&gt;Visibility Modifiers&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8f9335847e2c530d21bcd3080b073f4d1f543f5f" translate="yes" xml:space="preserve">
          <source>If all you want to do with a constructor parameter value is to assign it to a property with the same name, you can declare the property in the primary constructor parameter list (the oneliner below is sufficient for both declaring the properties, declaring the constructor parameters, and initializing the properties with the parameters):</source>
          <target state="translated">如果你只想把一个构造函数参数值分配给一个同名的属性,你可以在主构造函数参数列表中声明该属性(下面的oneliner既可以声明属性,也可以声明构造函数参数,还可以用参数初始化属性)。</target>
        </trans-unit>
        <trans-unit id="286a0bf4d2cc8a5a12f2292b0ceccc9207bc4770" translate="yes" xml:space="preserve">
          <source>If an annotation is used as a parameter of another annotation, its name is not prefixed with the @ character:</source>
          <target state="translated">如果一个注解被用作另一个注解的参数,那么它的名称前不加@字符。</target>
        </trans-unit>
        <trans-unit id="10147e3b40c783598d2bd9a60f764d64051cd74f" translate="yes" xml:space="preserve">
          <source>If an annotation type is annotated with both &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/meta/TypeQualifierNickname.html&quot;&gt;&lt;code&gt;@TypeQualifierNickname&lt;/code&gt;&lt;/a&gt; and JSR-305 &lt;code&gt;@Nonnull&lt;/code&gt; (or its another nickname, such as &lt;code&gt;@CheckForNull&lt;/code&gt;), then the annotation type is itself used for retrieving precise nullability and has the same meaning as that nullability annotation:</source>
          <target state="translated">如果注释类型同时用&lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/meta/TypeQualifierNickname.html&quot;&gt; &lt;code&gt;@TypeQualifierNickname&lt;/code&gt; &lt;/a&gt;和JSR-305 &lt;code&gt;@Nonnull&lt;/code&gt; （或它的另一个昵称，例如 &lt;code&gt;@CheckForNull&lt;/code&gt; ）进行注释，则注释类型本身将用于检索精确的可空性，并且与该可空性注释具有相同的含义：</target>
        </trans-unit>
        <trans-unit id="f981f8a8e6f98948229b86561835f71dd548b23d" translate="yes" xml:space="preserve">
          <source>If an extension is declared outside its receiver type, such an extension cannot access the receiver's &lt;code&gt;private&lt;/code&gt; members.</source>
          <target state="translated">如果扩展名在其接收者类型之外声明，则该扩展不能访问接收者的 &lt;code&gt;private&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="61dcbc44eee3bab1f0e103c1b87baa369fec0f94" translate="yes" xml:space="preserve">
          <source>If an external build system is used for configuring the project, and it's been decided not to share &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, Kotlin Coding Conventions can be forced with an additional property:</source>
          <target state="translated">如果使用外部构建系统配置项目，并且已决定不共享 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 文件夹，则可以通过附加属性强制使用Kotlin编码约定：</target>
        </trans-unit>
        <trans-unit id="d93cee5a226e1db8584fc451a3062eec2e7267d3" translate="yes" xml:space="preserve">
          <source>If an object is frozen it can be checked with an extension property &lt;code&gt;isFrozen&lt;/code&gt;, and if it is, object sharing is allowed. Currently, Kotlin/Native runtime only freezes the enum objects after creation, although additional autofreezing of certain provably immutable objects could be implemented in the future.</source>
          <target state="translated">如果对象被冻结，则可以使用扩展属性 &lt;code&gt;isFrozen&lt;/code&gt; 进行检查，如果是，则允许对象共享。目前，Kotlin / Native运行时仅在创建后冻结枚举对象，尽管将来可能会对某些可证明不可变的对象进行额外的自动冻结。</target>
        </trans-unit>
        <trans-unit id="d745839ade06f63274de839883364751868e1c68" translate="yes" xml:space="preserve">
          <source>If an object is transferred in &lt;code&gt;UNSAFE&lt;/code&gt; mode and is still accessible from multiple concurrent executors, program will likely crash unexpectedly, so consider that last resort in optimizing, not a general purpose mechanism.</source>
          <target state="translated">如果以 &lt;code&gt;UNSAFE&lt;/code&gt; 模式传输对象，并且仍然可以从多个并发执行器访问该对象，则程序可能会意外崩溃，因此请考虑在优化中采取最后手段，而不是通用机制。</target>
        </trans-unit>
        <trans-unit id="2fbb13db366dcb9336c03ff5dd678511b1b8d160" translate="yes" xml:space="preserve">
          <source>If any errors occur during the copying, then further actions will depend on the result of the call to &lt;code&gt;onError(File, IOException)&lt;/code&gt; function, that will be called with arguments, specifying the file that caused the error and the exception itself. By default this function rethrows exceptions.</source>
          <target state="translated">如果在复制过程中发生任何错误，则进一步的操作将取决于对 &lt;code&gt;onError(File, IOException)&lt;/code&gt; 函数的调用结果，该函数将使用参数进行调用，并指定导致错误的文件和异常本身。默认情况下，此函数引发异常。</target>
        </trans-unit>
        <trans-unit id="aad3cd8dfcbdf7511572b2939855bed2ac55b99b" translate="yes" xml:space="preserve">
          <source>If any of arrays contains itself on any nesting level that reference is rendered as &lt;code&gt;&quot;[...]&quot;&lt;/code&gt; to prevent recursion.</source>
          <target state="translated">如果任何数组在任何嵌套级别上都包含自身，则该引用将呈现为 &lt;code&gt;&quot;[...]&quot;&lt;/code&gt; 以防止递归。</target>
        </trans-unit>
        <trans-unit id="e3f9db9bf25bbec3f31f98164a22576425cc669b" translate="yes" xml:space="preserve">
          <source>If any of arrays contains itself on any nesting level the behavior is undefined.</source>
          <target state="translated">如果数组中的任何一个数组在任何嵌套层上包含了自己,那么这个行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="9c5d9097483a5bb9ad684d81ab29afc4db54e1ed" translate="yes" xml:space="preserve">
          <source>If any of elements is &lt;code&gt;NaN&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果任何元素为 &lt;code&gt;NaN&lt;/code&gt; ,则返回 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97176cd6bad6dda53932f8ad2eae19bbc9012e41" translate="yes" xml:space="preserve">
          <source>If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">如果两对中的任何一对有相同的密钥,最后一对会被添加到地图中。</target>
        </trans-unit>
        <trans-unit id="6fdd79609c8f85fa31ce635ac8b9cd8b21fe6cf8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.Array((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.Array((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd1a69eb514868f3014ac9ebddc5f5d735edf89e" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Iterable((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Iterable((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e189e501066f4ac42ca51a4be243a3ad0abadf5" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Map((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Map((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96b36a40f387f4c8df6c324c6dc2b703f21da3c2" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.sequences%24maxOf(kotlin.sequences.Sequence((kotlin.sequences.maxOf.T)),%20kotlin.Function1((kotlin.sequences.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of#kotlin.sequences%24maxOf(kotlin.sequences.Sequence((kotlin.sequences.maxOf.T)),%20kotlin.Function1((kotlin.sequences.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b32c87f07f448e5c852864c4c07255913a33f154" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.text%24maxOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of#kotlin.text%24maxOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="973ed91938d379c81da13b3ca48e010cd6c1309f" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.Array((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.Array((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2466fddfdfd68288ce0227609640affb7f9beb8c" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Iterable((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Iterable((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30f52c50e23a311e6818d0613ec256f55699413d" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Map((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Map((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccf1c9aefb939e391c556149e3b88356bdd369b8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.sequences%24maxOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.maxOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of-or-null#kotlin.sequences%24maxOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.maxOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c39e75bf5be9b08a47160d2b17149dae147dbe4d" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.text%24maxOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;max-of-or-null#kotlin.text%24maxOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3801e7c556a007fa15fa5fdf086b701342f4493" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.Array((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.Array((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f54dcaf8c15a4fde48f9f8e9fd9ddcdcff34c0f" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Iterable((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Iterable((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59f702b5ac5ebb0f583e7b36eff4014222ccd52b" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Map((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Map((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36401114fbe626769f0b61474ddddd4a4ed62ae5" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.sequences%24minOf(kotlin.sequences.Sequence((kotlin.sequences.minOf.T)),%20kotlin.Function1((kotlin.sequences.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of#kotlin.sequences%24minOf(kotlin.sequences.Sequence((kotlin.sequences.minOf.T)),%20kotlin.Function1((kotlin.sequences.minOf.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5171cee310607ada547cb3abbac9f3369902a249" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.text%24minOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of#kotlin.text%24minOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b49ed92744163e0134f5a22997e4ff3f21ace05b" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.Array((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.Array((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9e966ce954bca5aa6b1bada8a82e7e213dd4409" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Iterable((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Iterable((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="365af754bf462620905ac7411eb64305bc2de60a" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Map((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Map((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27e14e82baa65c311737fe2d312029df3d459372" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.sequences%24minOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.minOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of-or-null#kotlin.sequences%24minOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.minOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bf89b40a8581dc5e193197a15170ae1446fe0c8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.text%24minOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;min-of-or-null#kotlin.text%24minOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;选择器&lt;/a&gt;函数产生的任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回的结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79cd9f8134bc36e93ee0b5b0096e84d02bfcaf30" translate="yes" xml:space="preserve">
          <source>If any two characters are equal, the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符相同,最后一个字符将被添加到地图上。</target>
        </trans-unit>
        <trans-unit id="c0c6357923841ba1ceaab6f1a6e9f84f8606ef1c" translate="yes" xml:space="preserve">
          <source>If any two characters are equal, the last one overwrites the former value in the map.</source>
          <target state="translated">如果任何两个字符相等,最后一个字符会覆盖地图中的前一个值。</target>
        </trans-unit>
        <trans-unit id="2f26706708ad295a2d4220fcac5447f101089a9f" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符具有由&lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个字符将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="5497c944eda344c5ee4cce041575eba3fa47949a" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符具有由&lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个字符将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="7367590726f3c52d91d710c14fe80d9003935516" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符具有由&lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个字符将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="f4bfe6665fd01c25b2660723aa26cfcba03b745a" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符具有由&lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个字符将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="00f0b6493f2eb1f51451a75f987e59fc400e809f" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符具有由&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个字符将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="e75792e6117ae62d34357ae99163b28e3ae87d39" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符具有由&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个字符将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="6c92aff3ac1f8cdea6651367e77533f526cbf74d" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符具有由&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个字符将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="d21785fb11026ac029e1cf094d66a51ca1f63f36" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个字符具有由&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个字符将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="4222526855776d5fea3d288e6bf28ef40486cfda" translate="yes" xml:space="preserve">
          <source>If any two elements are equal, the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素相等,最后一个元素会被添加到地图中。</target>
        </trans-unit>
        <trans-unit id="52ae8f33e4fce4d2bff00b2205f42a03dc6b6dc5" translate="yes" xml:space="preserve">
          <source>If any two elements are equal, the last one overwrites the former value in the map.</source>
          <target state="translated">如果任何两个元素相等,最后一个元素会覆盖地图中的前一个值。</target>
        </trans-unit>
        <trans-unit id="b0b36918b10e47a460b56e912f87552132811b0f" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="e4f7e861149810b95e4b66a62c5652d10a7c2b34" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="346c57febb657aa512596a792a1d6c53c4a5c173" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="3287da59db6cb14700469a6de2aad1297af6a1ee" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="2c619123b46fe6a76412a4dab4a539323c02514b" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="2babce65c3c6822f47e0eae410ad672aa2260fa3" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="00d01f2707a1118799d1a79e26193669d53741bc" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="aec1ca56633469f54f0e46f095a2dbcb21ce1243" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="00e86e26effea5e2019fdb8f013dd65c8b5af777" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="aa4e0bb8aab998beb153e618c68711e8ed1f5b4f" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="cb5d5aa23c9cfd8ca4685ccfe7640b8caaa4a65d" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="76aca80e5881d814494f769e4c11ea9e94782b66" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="c3d37381e9e97d902481d1677ee619ffffeec57b" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="8a54ba887f98592eb00ea24f27934531d1671f80" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="ab1f15270d6a111ddaa8968f8a8f226b8f79ddf4" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="d0f68c68a34d4b5715504c8f74b425b62b183fef" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="8b2386ebd4075f829eb97b39509e81199143026c" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="a5bda745e6086dfd43e37448ecd0f17912a83dae" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="b8b9cc802fea2f7d48329645a48c226c92d43891" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="069e0778324065ee5d06336752a03ef494d33fe8" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="7fef979d1100c793011b653d677a5f4789c9ce5c" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="0f4cd25d85f79262f8b0d5f4a453055241040829" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="65555fa738d49de3541dbc9b7c338a18ba8e97bd" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="96ed486305c1c1d3ee98ba620ab2f351eaa38c63" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)),%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">如果任何两个元素具有由&lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)),%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt;返回的相同键，则最后一个元素将添加到地图中。</target>
        </trans-unit>
        <trans-unit id="110a007329fb036d6903df69176601b85d25191e" translate="yes" xml:space="preserve">
          <source>If any type from a dependency is used in the public API of the current module, use an &lt;code&gt;api&lt;/code&gt; dependency.</source>
          <target state="translated">如果当前模块的公共API中使用了依赖关系中的任何类型，请使用 &lt;code&gt;api&lt;/code&gt; 依赖关系。</target>
        </trans-unit>
        <trans-unit id="eca190cfc6a29e9601e43afc0d741e161268772e" translate="yes" xml:space="preserve">
          <source>If any value is &lt;code&gt;NaN&lt;/code&gt;, returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果任何值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15a7c9b40dd906acf8613adf81beb5022ec43a6e" translate="yes" xml:space="preserve">
          <source>If assigning a label for a lambda, do not put a space between the label and the opening curly brace:</source>
          <target state="translated">如果为lambda分配标签,不要在标签和开头的大括号之间留有空格。</target>
        </trans-unit>
        <trans-unit id="a820210cdda09e6106a20c2689836d5711b2d033" translate="yes" xml:space="preserve">
          <source>If atomic reference value is attempted to be set to non-frozen value runtime exception is thrown.</source>
          <target state="translated">如果试图将原子引用值设置为非冻结值,将抛出运行时异常。</target>
        </trans-unit>
        <trans-unit id="f6340b7de91bcf9810532c03cd005ea252c107ff" translate="yes" xml:space="preserve">
          <source>If binary was compiled in debug mode.</source>
          <target state="translated">如果二进制文件是在调试模式下编译的。</target>
        </trans-unit>
        <trans-unit id="2d8589cc3e699ddd4e97fa2ba29db1785486ed75" translate="yes" xml:space="preserve">
          <source>If either value is &lt;code&gt;NaN&lt;/code&gt;, returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果任一值为 &lt;code&gt;NaN&lt;/code&gt; ，则返回 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a91c0067bcc4bc2dc899d9a2f5799f4eb73c4ee3" translate="yes" xml:space="preserve">
          <source>If either value is &lt;code&gt;NaN&lt;/code&gt;, then the result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果任一值为 &lt;code&gt;NaN&lt;/code&gt; ，则结果为 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f3e1f12baf2d25f74fb62aefb55ff3c7223ad4c" translate="yes" xml:space="preserve">
          <source>If everything went well, you'll see the result in the &lt;strong&gt;Console&lt;/strong&gt; window.</source>
          <target state="translated">如果一切顺利，您将在&amp;ldquo; &lt;strong&gt;控制台&amp;rdquo;&lt;/strong&gt;窗口中看到结果。</target>
        </trans-unit>
        <trans-unit id="b99457c74d09db32d851769270d759bf6b0bed1e" translate="yes" xml:space="preserve">
          <source>If everything went well, you'll see the result in the &lt;strong&gt;Run&lt;/strong&gt; tool window.</source>
          <target state="translated">如果一切顺利，您将在&amp;ldquo; &lt;strong&gt;运行&amp;rdquo;&lt;/strong&gt;工具窗口中看到结果。</target>
        </trans-unit>
        <trans-unit id="f44e8e73afacbc926ee5ae8b0a40c2caa8a431c0" translate="yes" xml:space="preserve">
          <source>If for some reason you want to store a different value in the backing field than the value that is being assigned to the property, you're free to do that, but then you will probably want a getter to give the calling code back what they expect: if you say &lt;code&gt;field = value * 2&lt;/code&gt; in the setter and &lt;code&gt;this.age = age * 2&lt;/code&gt; in the initializer block, you should also have &lt;code&gt;get() = field / 2&lt;/code&gt;.</source>
          <target state="translated">如果由于某种原因您想要在后备字段中存储与分配给该属性的值不同的值，则可以自由地这样做，但是您可能希望让getter将调用代码返回给他们期望：如果您在设置器中说 &lt;code&gt;field = value * 2&lt;/code&gt; ，而在初始化程序块中说 &lt;code&gt;this.age = age * 2&lt;/code&gt; ，则还应该具有 &lt;code&gt;get() = field / 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4edefded820cd80aae935341ea1dcb1006c317d1" translate="yes" xml:space="preserve">
          <source>If many cases should be handled in the same way, the branch conditions may be combined with a comma:</source>
          <target state="translated">如果很多情况应该用同样的方法处理,分支条件可以用逗号组合。</target>
        </trans-unit>
        <trans-unit id="fce48d9ac76717b44d2ca9ae647c75c587720e7e" translate="yes" xml:space="preserve">
          <source>If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.</source>
          <target state="translated">如果多个对子有相同的键,生成的映射将包含这些对子中最后一个的值。</target>
        </trans-unit>
        <trans-unit id="f2ea3319b4e276d7c3ea13314c77acc34629c044" translate="yes" xml:space="preserve">
          <source>If necessary, specify dependencies between modules:</source>
          <target state="translated">如有必要,可指定模块之间的依赖关系。</target>
        </trans-unit>
        <trans-unit id="c2f6abafe51dcf05f7cf659caae54fb0bbb624da" translate="yes" xml:space="preserve">
          <source>If no elements match the predicate, both functions throw exceptions. To avoid them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first-or-null&quot;&gt;&lt;code&gt;firstOrNull()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-or-null&quot;&gt;&lt;code&gt;lastOrNull()&lt;/code&gt;&lt;/a&gt; instead: they return &lt;code&gt;null&lt;/code&gt; if no matching elements are found.</source>
          <target state="translated">如果没有元素与谓词匹配，则两个函数都将引发异常。为了避免它们，请改用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first-or-null&quot;&gt; &lt;code&gt;firstOrNull()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-or-null&quot;&gt; &lt;code&gt;lastOrNull()&lt;/code&gt; &lt;/a&gt;：如果找不到匹配的元素，它们将返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ce45b90b7ed5e84a37f6079dd50b9e40c3acc1b" translate="yes" xml:space="preserve">
          <source>If not null and else shorthand</source>
          <target state="translated">如果不为空,则为简写</target>
        </trans-unit>
        <trans-unit id="c3119c5c318b3c1bb9ef4c81af371e666f2e1406" translate="yes" xml:space="preserve">
          <source>If not null shorthand</source>
          <target state="translated">如果不为空,则为速记</target>
        </trans-unit>
        <trans-unit id="f0a31ecbf625068fa2a79a659389ab370dd6f36e" translate="yes" xml:space="preserve">
          <source>If present, specifies a code fragment which should be used as a replacement for the deprecated API usage.</source>
          <target state="translated">如果存在,则指定一个代码片段,该片段应被用来替代被废弃的API用法。</target>
        </trans-unit>
        <trans-unit id="9664a874b8c0300219353ed51ac375519b83e9fe" translate="yes" xml:space="preserve">
          <source>If rebuilding is performed on App Store side, then &lt;code&gt;.dSYM&lt;/code&gt; of rebuilt &lt;em&gt;dynamic&lt;/em&gt; framework seems discarded and not downloadable from App Store Connect. So in this case it may be required to make the framework static, e.g. with</source>
          <target state="translated">如果在App Store端执行重建，则重建的&lt;em&gt;动态&lt;/em&gt;框架的 &lt;code&gt;.dSYM&lt;/code&gt; 似乎已被丢弃，无法从App Store Connect下载。因此，在这种情况下，可能需要使框架保持静态，例如&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5b87a1191a07e9f1f10d2d86fbeef8f4c6e6b20" translate="yes" xml:space="preserve">
          <source>If some directories on a way to the &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; are missing, then they will be created. If the &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; file already exists, this function will fail unless &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果缺少通往&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;目标&lt;/a&gt;的路径中的某些目录，则将创建它们。如果&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;目标&lt;/a&gt;文件已经存在，则除非&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;覆盖&lt;/a&gt;参数设置为 &lt;code&gt;true&lt;/code&gt; ,否则此函数将失败。</target>
        </trans-unit>
        <trans-unit id="f01a59b3c6eaf0fa829c89cc9cc51b75a98bb1df" translate="yes" xml:space="preserve">
          <source>If some directories on a way to the &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; are missing, then they will be created. If the &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; file already exists, this function will fail unless &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果缺少通往&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;目标&lt;/a&gt;的路径中的某些目录，则将创建它们。如果&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;目标&lt;/a&gt;文件已经存在，则该函数将失败，除非将&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt;参数设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69564edb6644d0771a0b53f00a1f0ee73a8d9530" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo%28kotlin.collections.Grouping%28%28kotlin.collections.aggregateTo.T%2C+kotlin.collections.aggregateTo.K%29%29%2C+kotlin.collections.aggregateTo.M%2C+kotlin.Function4%28%28kotlin.collections.aggregateTo.K%2C+kotlin.collections.aggregateTo.R%2C+kotlin.collections.aggregateTo.T%2C+kotlin.Boolean%2C+kotlin.collections.aggregateTo.R%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, then the elements being aggregated for that key are never considered as &lt;code&gt;first&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo%28kotlin.collections.Grouping%28%28kotlin.collections.aggregateTo.T%2C+kotlin.collections.aggregateTo.K%29%29%2C+kotlin.collections.aggregateTo.M%2C+kotlin.Function4%28%28kotlin.collections.aggregateTo.K%2C+kotlin.collections.aggregateTo.R%2C+kotlin.collections.aggregateTo.T%2C+kotlin.Boolean%2C+kotlin.collections.aggregateTo.R%29%29%29%2Fdestination&quot;&gt;目标&lt;/a&gt;映射已经具有对应于某个键的值，则针对该键聚合的元素永远不会被视为 &lt;code&gt;first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b97d2cb76e358bd05b416fac37404ef523495356" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo(kotlin.collections.Grouping((kotlin.collections.aggregateTo.T,%20kotlin.collections.aggregateTo.K)),%20kotlin.collections.aggregateTo.M,%20kotlin.Function4((kotlin.collections.aggregateTo.K,%20kotlin.collections.aggregateTo.R?,%20kotlin.collections.aggregateTo.T,%20kotlin.Boolean,%20kotlin.collections.aggregateTo.R)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, then the elements being aggregated for that key are never considered as &lt;code&gt;first&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo(kotlin.collections.Grouping((kotlin.collections.aggregateTo.T,%20kotlin.collections.aggregateTo.K)),%20kotlin.collections.aggregateTo.M,%20kotlin.Function4((kotlin.collections.aggregateTo.K,%20kotlin.collections.aggregateTo.R?,%20kotlin.collections.aggregateTo.T,%20kotlin.Boolean,%20kotlin.collections.aggregateTo.R)))/destination&quot;&gt;目标&lt;/a&gt;映射已经具有对应于某个键的值，则针对该键聚合的元素永远不会被视为 &lt;code&gt;first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0b6595d56ce18db4a67782306e25689cafd4cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt; already exists, it will be deleted before copying when the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; parameter permits so.</source>
          <target state="translated">如果&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;目标&lt;/a&gt;已经存在，则在&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Foverwrite&quot;&gt;覆盖&lt;/a&gt;参数允许的情况下，将在复制之前将其删除。</target>
        </trans-unit>
        <trans-unit id="72642c2dc2e392596a7e9e14969c3eba6a9b65c7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt; already exists, it will be deleted before copying when the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/overwrite&quot;&gt;overwrite&lt;/a&gt; parameter permits so.</source>
          <target state="translated">如果&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;目标&lt;/a&gt;已经存在，则在&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/overwrite&quot;&gt;覆盖&lt;/a&gt;参数允许的情况下，将在复制之前将其删除。</target>
        </trans-unit>
        <trans-unit id="9f9b5e8d1feceda52168174d03a6fd1853068274" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo%28kotlin.collections.Grouping%28%28kotlin.collections.eachCountTo.T%2C+kotlin.collections.eachCountTo.K%29%29%2C+kotlin.collections.eachCountTo.M%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the counter for that group.</source>
          <target state="translated">如果&lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo%28kotlin.collections.Grouping%28%28kotlin.collections.eachCountTo.T%2C+kotlin.collections.eachCountTo.K%29%29%2C+kotlin.collections.eachCountTo.M%29%2Fdestination&quot;&gt;目标&lt;/a&gt;映射已经具有与某个组的键相对应的值，则该值将用作该组的计数器的初始值。</target>
        </trans-unit>
        <trans-unit id="294cca51ae0758313aa7d288e6e1a35754d699c1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo(kotlin.collections.Grouping((kotlin.collections.eachCountTo.T,%20kotlin.collections.eachCountTo.K)),%20kotlin.collections.eachCountTo.M)/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the counter for that group.</source>
          <target state="translated">如果&lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo(kotlin.collections.Grouping((kotlin.collections.eachCountTo.T,%20kotlin.collections.eachCountTo.K)),%20kotlin.collections.eachCountTo.M)/destination&quot;&gt;目标&lt;/a&gt;映射已经具有与某个组的键相对应的值，则该值将用作该组的计数器的初始值。</target>
        </trans-unit>
        <trans-unit id="8e5524567ae268875bd1ad8d3089898977c657ab" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, that value is used as an initial value of the accumulator for that group and the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2FinitialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt; function is not called for that group.</source>
          <target state="translated">如果&lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;目标&lt;/a&gt;映射已经具有对应于某个键的值，则将该值用作该组的累加器的初始值，并且不对该组调用&lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2FinitialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="c2e00bc5fd9ad4886018856e815daa5b47301e4d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.collections.foldTo.R%2C+kotlin.Function2%28%28kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group.</source>
          <target state="translated">如果&lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.collections.foldTo.R%2C+kotlin.Function2%28%28kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;目标&lt;/a&gt;映射已经具有与某个组的键相对应的值，则该值将用作该组的累加器的初始值。</target>
        </trans-unit>
        <trans-unit id="92a0a868acf0fdba94e948380117659b082b2d8a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, that value is used as an initial value of the accumulator for that group and the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/initialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt; function is not called for that group.</source>
          <target state="translated">如果&lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;目标&lt;/a&gt;映射已经具有对应于某个键的值，则将该值用作该组的累加器的初始值，并且不对该组调用&lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/initialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="61fb3080e7ad416c3c4c97afdd9493927e20f8d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.collections.foldTo.R,%20kotlin.Function2((kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group.</source>
          <target state="translated">如果&lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.collections.foldTo.R,%20kotlin.Function2((kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;目标&lt;/a&gt;映射已经具有与某个组的键相对应的值，则该值将用作该组的累加器的初始值。</target>
        </trans-unit>
        <trans-unit id="a5e416dc2da9d5eff4e49855727e16479b47d6e8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a66362906cf4418648a9a5554323ed383b8c8eea" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="659f4cba1d89d61c23bd0ba52a22f40e8ccd83db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="8871905aa80191cdc602c425bf96156ef25f5e60" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e297805d5d494bda3a0385ad18c3569e75f14c7d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c007633067610794e36b0b3cc51865ca8352f19" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6039a3964776e721bd806c0a81307a0abf13a4c0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="fc5816f698f9795e7dd6086d1ef8ccfaae63b27a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef7d2330d71db6f764d35eea14e9ab73aac72b9c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b70a8c2ba34131364e28b2512d35483af00f19a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44768c507a4b76808d52b98c0254864df2b87ee5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="f43d6c6804b42a2af7611d19f88a2487e6000d7d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2c1eabbbf7b712271d653fdcbd433c34590b4d2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87b690a93b6a351a33df7161fb636a57f37c003d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="241fbd990a613b4ddb1929a451c61d8c2e0d5edd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="b8b15067f57d32d666005f69272a8002614e5c40" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9330d9da57aef0aed8c13aee6dc337fbeb829bff" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c4f88ba4389bfc9a900b68407e80b12b5ae9b02" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10f0cc22e805af048a8e1811a9b67195fd374456" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="4dfbdf3e234c922a5068cafdfeeced9cce315c84" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4839668bfa4ee00994900630081eeb5714f95752" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e047d5c3d28e4eb74b19b8706f2359f4a496d1c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36ed57a482212b43296278a3f740dad9f4d581db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="00d6097085f2efeb6f60d64620ecac34ef7d8a30" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33490febae2a178f4655be7a154612da34a0c4a5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d2ed5d24fc59700154e317864d8c0e6739505a7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c696e216e6286ada0cb5195502952a789b32f98a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="292f4907701770c13a3d993a8fbab1351a08f93b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5f087deed2fca1a1e09b14c363914201ae8d71a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="256c8bdcf7db878fc6b6b13f96f3eeecab8e97a4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a243908860038c9462a433c221a21a1025d24e0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="78cc83cee81cdb56f83d5139ff270e833535dfdf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="999680793def1bf95ce65d25a967348c34b8ed9d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="343f876e9f1eb0b0c40cd9f7901fcfe6d86bd975" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f013fc6e90baae75eb837993cde762ea2af5800" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="58754cd9e0e7d7a8702d78a5c9ba2d2f0156bea9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e96f00fc82613fc72e45bd901e49fdbd42b006e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出了此字符串的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="121146c1773ced51b85c510f0c9a740fcee4401a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此字符串的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f767176ab77d40deae0e60f62a498403a05d542" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出了此字符串的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="46f07635940947a7d146432e3e2c1f7467a6f5db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此字符串的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9b4a8848b9c8e64b348afb59840b8348887cc19" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.UByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e7b8e174e484d14d4beffbac84f58ae1fb244d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.UByteArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="c42b44be3aa2af1c6b520077f8536d89266d3575" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UIntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.UIntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e0b0214b72fe8c7cf14b755a41ea870bd89d740" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UIntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.UIntArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="9aa63b031868d224c7a7f44af55292bbb50b21f2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ULongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ULongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9de9e44f5252019b83cabd1b363c2f8b0aa829b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ULongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.ULongArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="5f0b48aa5778c165df7d576ad84fb99a045c6acc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.UShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75d4175ea3cfca94ca7e47438e4bdab18fab5198" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;get#kotlin.UShortArray%24get(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="3832840323d1968de06c86d1668de66bc5395923" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt; the directory is not entered and neither it nor its files are visited.</source>
          <target state="translated">如果&lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;函数&lt;/a&gt;返回 &lt;code&gt;false&lt;/code&gt; ，则不会输入目录，也不会访问目录及其文件。</target>
        </trans-unit>
        <trans-unit id="76181a81bd674f99c87a97a3e1468fb754d1fc87" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter(kotlin.Function1((java.io.File,%20kotlin.Boolean)))/function&quot;&gt;function&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt; the directory is not entered and neither it nor its files are visited.</source>
          <target state="translated">如果&lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter(kotlin.Function1((java.io.File,%20kotlin.Boolean)))/function&quot;&gt;函数&lt;/a&gt;返回 &lt;code&gt;false&lt;/code&gt; ，则不会输入目录，也不会访问目录及其文件。</target>
        </trans-unit>
        <trans-unit id="0a2285dd49856fe4825e17e694cf3fa18696091c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group and the first element of that group is also subjected to the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Fdestination&quot;&gt;目标&lt;/a&gt;映射已经具有与某个组的键相对应的值，则将该值用作该组的累加器的初始值，并且该组的第一个元素也要进行&lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Foperation&quot;&gt;运算&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aaabd446cf116a2750ab94bb32f8d62327631fb7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group and the first element of that group is also subjected to the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/operation&quot;&gt;operation&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/destination&quot;&gt;目标&lt;/a&gt;映射已经具有与某个组的键相对应的值，则将该值用作该组的累加器的初始值，并且该组的第一个元素也要进行&lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/operation&quot;&gt;运算&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c1cf29eaa37e1a848f362e9496c70a7361cc3c0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4795422de28a107d2b93ad77a19fea520c69382" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3500c6a3ccdfdd558e70d61568491d24a57dba35" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="07848e5d2cb6b751154cf49081d01d01ad9a0467" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad0c6c091ccda18739aa6f3577cd89dd09841078" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="835319d043a0f65a5eee60807011570250691591" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b50c553e7ac61ad18a55fb2deb2fd76235f23fd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="07ab11928fd8cb50782aa576d57f34d36dac144c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="527f471fdf4e268be1d4b9f1ebfd516bc71f229b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42963185cae43f2e758e143f41ae72d95b5c4100" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cdf2a2f9fb25aa14921ec99b9c2441f2f3aa607b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="e63aef66dc4f176a6824753a6cdeb0ca0faba262" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8618ed56cd06c8c291f923aab1b1a054f5002b8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="16b81d70965f40eb90b072a5e9edb009e7b41db0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff5ba893f49fd7a741281bd097b53c6298362fcd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="3e60264d0d2c56881b96bac79b4666814c5f9bc5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="684c4e170a424d705f9e13c5cda4d575a1e09f13" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f733c2a99de30ff7689107b0fce91469fa4b4623" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3adc428d0247ef8e64e3b606fc8678debad6823" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="1f1fe770f48c4c991ab6ba93f5448bca6a109d8e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09664e73fde927f6d22f3ea9f4070e59236e924f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dde11a436e59034272f619d39049718d3c4685e2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab4dcb980391ca205a536de0ce8e05a3c6d15d9b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="d5712029ee942822232df2cd5dbe660126d19048" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1000d31cc93809459dc4dbcc455954d9ddc757d2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab2984691cfff299ebe407e2aee780db1db59dff" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3d5f8f3a49afff92d2de250d1c268d9641231e3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="b0d669004672e2a64c3a7a12296c03199c121a94" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f173e322ccd56addf649214d8ae7803d5dfa5b94" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f409e29966bb054dfd47826d8dd2e870d206d24a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fba4254a8fc486709d4c8d0c1ff6c237b4ac68e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="64c2d595bfbfd6b07a001299c27dab6257d421de" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a8044147072cea61ae2e90888654fdcbbe920ee" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="382bd7e3336be8af1102464e37fa8b63b568ca7c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1175979092412882336d28661ca4a85fdaf319b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="e23f36b4d54bf9c3c45bcbc7bf634715deb9f3f1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb1e18b251850707f84797db758d97e17b714305" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adbaf189ba58957d0a7656eeb77ad6d9cf651830" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UByteArray%24set(kotlin.Int,%20kotlin.UByte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.UByteArray%24set(kotlin.Int,%20kotlin.UByte)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="2b01aefe6d05f741cac19ebae49684d8f27b7c15" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f924e8f004a96424c06cbbda49ed1c933ecc51d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UIntArray%24set(kotlin.Int,%20kotlin.UInt)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.UIntArray%24set(kotlin.Int,%20kotlin.UInt)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="e0298f72be4df89660cb3cbfa8ca0b544a87436d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e62a1584079789f235cbabd8612798e3939dc325" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ULongArray%24set(kotlin.Int,%20kotlin.ULong)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.ULongArray%24set(kotlin.Int,%20kotlin.ULong)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="c204bddc743f17a6a83f3273732caa9abcce98a1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出Koblin / JS中未指定行为的&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fe9e7ed96bb0f5a9326e0294c5697a26a4745c9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UShortArray%24set(kotlin.Int,%20kotlin.UShort)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果&lt;a href=&quot;set#kotlin.UShortArray%24set(kotlin.Int,%20kotlin.UShort)/index&quot;&gt;索引&lt;/a&gt;超出此数组的范围，则抛出&lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="fd938f2e10e2d0fb410305f424f6360cc9c56338" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt; is less than the current length, it is changed to the specified &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;. Otherwise, null characters '\u0000' are appended to this string builder until its length is less than the &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;小于当前长度，则将其更改为指定的&lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;。否则，将空字符'\ u0000'附加到此字符串生成器，直到其长度小于&lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;为止。</target>
        </trans-unit>
        <trans-unit id="fd0d3eb59459a0737a168b08758efee370cf55de" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; shall be invoked at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">如果该&lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;块&lt;/a&gt;返回特殊的&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt;值，则意味着暂停函数确实暂停了执行，并且不会立即返回任何结果。在这种情况下，当结果可用于恢复计算时，应在将来的某个时刻调用提供给该&lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;块&lt;/a&gt;的&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/index&quot;&gt;Continuation&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05d3b99631a5ed6456bedf676a61766834d5fac4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; shall be resumed by invoking &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">如果该&lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;块&lt;/a&gt;返回特殊的&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt;值，则意味着暂停函数确实暂停了执行，并且不会立即返回任何结果。在这种情况下，提供给该&lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;块&lt;/a&gt;的&lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt;必须在将来某个时候（当结果变得可用于恢复计算时）调用&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt;来恢复。</target>
        </trans-unit>
        <trans-unit id="ef7f7d6c898b2802fb6d15ca777d3c99d22a1440" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;block&lt;/a&gt; shall be resumed by invoking &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">如果该&lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;块&lt;/a&gt;返回特殊的&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt;值，则意味着暂停函数确实暂停了执行，并且不会立即返回任何结果。在这种情况下，提供给该&lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;块&lt;/a&gt;的&lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt;应该在将来某个时刻（当结果变得可用于恢复计算时）通过调用&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt;来恢复。</target>
        </trans-unit>
        <trans-unit id="8c3e8a5ebbcd7a703e634eecad27bcd0557ad20c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;until#kotlin.ranges%24until%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt; value is less than or equal to &lt;code&gt;this&lt;/code&gt; value, then the returned range is empty.</source>
          <target state="translated">如果&lt;a href=&quot;until#kotlin.ranges%24until%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt;值小于或等 &lt;code&gt;this&lt;/code&gt; 值，则返回的范围为空。</target>
        </trans-unit>
        <trans-unit id="fc10efd6ed805281fe18f00e48398e62a4bc01b4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;until#kotlin.ranges%24until(kotlin.Int,%20kotlin.Byte)/to&quot;&gt;to&lt;/a&gt; value is less than or equal to &lt;code&gt;this&lt;/code&gt; value, then the returned range is empty.</source>
          <target state="translated">如果&lt;a href=&quot;until#kotlin.ranges%24until(kotlin.Int,%20kotlin.Byte)/to&quot;&gt;to&lt;/a&gt;值小于或等 &lt;code&gt;this&lt;/code&gt; 值，则返回的范围为空。</target>
        </trans-unit>
        <trans-unit id="5345ec6188f99db607179fac5ae96cec3bb7c52f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@Nonnull(when = ...)&lt;/code&gt; value is &lt;code&gt;When.ALWAYS&lt;/code&gt;, the annotated type is treated as non-null; &lt;code&gt;When.MAYBE&lt;/code&gt; and &lt;code&gt;When.NEVER&lt;/code&gt; denote a nullable type; and &lt;code&gt;When.UNKNOWN&lt;/code&gt; forces the type to be &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform one&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;@Nonnull(when = ...)&lt;/code&gt; 值是 &lt;code&gt;When.ALWAYS&lt;/code&gt; ，则带注释的类型将被视为非空； &lt;code&gt;When.MAYBE&lt;/code&gt; 和 &lt;code&gt;When.NEVER&lt;/code&gt; 表示可为空的类型；和 &lt;code&gt;When.UNKNOWN&lt;/code&gt; 强制类型为&lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;平台一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45b12756de222f5e29c382cd94f13f3b7d5d58e7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text%24deleteAt(java.lang.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">如果指定&lt;a href=&quot;delete-at#kotlin.text%24deleteAt(java.lang.StringBuilder,%20kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;处的 &lt;code&gt;Char&lt;/code&gt; 是补充代码点的一部分，则此方法不会删除整个补充字符。</target>
        </trans-unit>
        <trans-unit id="688090999735051d0000ff7dba5c2c4568402fb2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text%24deleteAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">如果指定&lt;a href=&quot;delete-at#kotlin.text%24deleteAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;处的 &lt;code&gt;Char&lt;/code&gt; 是补充代码点的一部分，则此方法不会删除整个补充字符。</target>
        </trans-unit>
        <trans-unit id="19c4aa235fc87bd1ef34ff709c6ee8e008a72969" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text.StringBuilder%24deleteAt(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">如果指定&lt;a href=&quot;delete-at#kotlin.text.StringBuilder%24deleteAt(kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;处的 &lt;code&gt;Char&lt;/code&gt; 是补充代码点的一部分，则此方法不会删除整个补充字符。</target>
        </trans-unit>
        <trans-unit id="64b90c92ca7b8330c526871505c4db9b681716bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-char-at#kotlin.text%24deleteCharAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">如果指定&lt;a href=&quot;delete-char-at#kotlin.text%24deleteCharAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;索引&lt;/a&gt;处的 &lt;code&gt;Char&lt;/code&gt; 是补充代码点的一部分，则此方法不会删除整个补充字符。</target>
        </trans-unit>
        <trans-unit id="1ab41cb28f87df4bf85af33067d923e82cb67834" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; argument in Java has an array type, it becomes a &lt;code&gt;vararg&lt;/code&gt; parameter in Kotlin:</source>
          <target state="translated">如果Java中的 &lt;code&gt;value&lt;/code&gt; 参数具有数组类型，则它在Kotlin中将成为 &lt;code&gt;vararg&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="c6ef38c717fdd1e4d50094959ff3c7a5a376b3eb" translate="yes" xml:space="preserve">
          <source>If the Java class has multiple methods taking functional interfaces, you can choose the one you need to call by using an adapter function that converts a lambda to a specific SAM type. Those adapter functions are also generated by the compiler when needed:</source>
          <target state="translated">如果Java类有多个方法采用函数接口,你可以通过使用一个适配器函数将lambda转换为特定的SAM类型来选择你需要调用的方法。这些适配器函数也会在需要时由编译器生成。</target>
        </trans-unit>
        <trans-unit id="ced4c8b1c0812e2f37b8f765b9bf671545680b65" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+java.util.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果数组包含等于指定&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+java.util.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;元素的&lt;/a&gt;多个元素，则不能保证将找到哪一个。</target>
        </trans-unit>
        <trans-unit id="6466c3976ded360fb3b54d0482a0da85fa3ffd46" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果数组包含等于指定&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;元素的&lt;/a&gt;多个元素，则不能保证将找到哪一个。</target>
        </trans-unit>
        <trans-unit id="d5cf73d9390119493522582bc92cc73759f93e8a" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20java.util.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果数组包含等于指定&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20java.util.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;元素的&lt;/a&gt;多个元素，则不能保证将找到哪一个。</target>
        </trans-unit>
        <trans-unit id="2bd4827f31d12e8989eabcece2a2e85f2897dbd2" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果数组包含等于指定&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;元素的&lt;/a&gt;多个元素，则不能保证将找到哪一个。</target>
        </trans-unit>
        <trans-unit id="857a406fa492096552a539094a05e74a8ae0e4fe" translate="yes" xml:space="preserve">
          <source>If the backing storage of this string builder is larger than necessary to hold its current contents, then it may be resized to become more space efficient. Calling this method may, but is not required to, affect the value of the &lt;a href=&quot;capacity#kotlin.text.StringBuilder%24capacity()&quot;&gt;capacity&lt;/a&gt; property.</source>
          <target state="translated">如果此字符串生成器的后备存储空间大于保留其当前内容所必需的存储空间，则可以调整其大小以提高空间效率。调用此方法可能会但不一定会影响&lt;a href=&quot;capacity#kotlin.text.StringBuilder%24capacity()&quot;&gt;Capacity&lt;/a&gt;属性的值。</target>
        </trans-unit>
        <trans-unit id="fa8581b13c8fdd01f13e98c50d4e7d29550396fc" translate="yes" xml:space="preserve">
          <source>If the behavior for a certain platform needs to be modified, you can use a format like &lt;code&gt;compilerOpts.osx&lt;/code&gt; or &lt;code&gt;compilerOpts.linux&lt;/code&gt; to provide platform-specific values to the options.</source>
          <target state="translated">如果需要修改特定平台的行为，则可以使用像 &lt;code&gt;compilerOpts.osx&lt;/code&gt; 或 &lt;code&gt;compilerOpts.linux&lt;/code&gt; 类的格式为选项提供特定于平台的值。</target>
        </trans-unit>
        <trans-unit id="996cca3563bf26540aaf4288dff8af8f84e60dcc" translate="yes" xml:space="preserve">
          <source>If the callback doesn't run in the main thread, it is mandatory to init the &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime by calling &lt;code&gt;kotlin.native.initRuntimeIfNeeded()&lt;/code&gt;.</source>
          <target state="translated">如果回调未在主线程中运行，则必须通过调用 &lt;code&gt;kotlin.native.initRuntimeIfNeeded()&lt;/code&gt; 来初始化&lt;em&gt;Kotlin / Native&lt;/em&gt;运行时。</target>
        </trans-unit>
        <trans-unit id="71e01fbddfaf8e865fcef95f03a855f99eabb469" translate="yes" xml:space="preserve">
          <source>If the class (or any of its superclasses) is annotated with &lt;code&gt;com.my.Annotation&lt;/code&gt;, the class itself and all its members will become open.</source>
          <target state="translated">如果使用 &lt;code&gt;com.my.Annotation&lt;/code&gt; 注释了该类（或其任何超类），则该类本身及其所有成员将变为打开状态。</target>
        </trans-unit>
        <trans-unit id="1d6fb5abda1df282cf7b793af04d339e6c8b07ca" translate="yes" xml:space="preserve">
          <source>If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class is done using the &lt;em&gt;this&lt;/em&gt; keyword:</source>
          <target state="translated">如果该类具有主要构造函数，则每个次要构造函数都需要直接或间接通过另一个次要构造函数委托给主要构造函数。使用&lt;em&gt;this&lt;/em&gt;关键字可以委派给同一类的另一个构造函数：</target>
        </trans-unit>
        <trans-unit id="1becbc997c1b9834ca68a14f7454678bc5ce31a3" translate="yes" xml:space="preserve">
          <source>If the classes represent &lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;Array&lt;/a&gt;, then &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Class&lt;/a&gt; objects of their element types are equal.</source>
          <target state="translated">如果类表示&lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;Array&lt;/a&gt;，则其元素类型的&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Class&lt;/a&gt;对象相等。</target>
        </trans-unit>
        <trans-unit id="77b2beaaa166a8ca8a0f2117bf08b50328d632d2" translate="yes" xml:space="preserve">
          <source>If the classes represent &lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;Array&lt;/a&gt;, then &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Class&lt;/a&gt; objects of their element types are equal.</source>
          <target state="translated">如果这些类表示&lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;Array&lt;/a&gt;，则其元素类型的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Class&lt;/a&gt;对象是相等的。</target>
        </trans-unit>
        <trans-unit id="944291945314272d9d50e4311dd336ba21bad448" translate="yes" xml:space="preserve">
          <source>If the classes represent Array, then Class objects of their element types are equal.</source>
          <target state="translated">如果类代表Array,那么它们元素类型的Class对象是相等的。</target>
        </trans-unit>
        <trans-unit id="79031f7fd8baac9875032a654d3a81aa8ce76daf" translate="yes" xml:space="preserve">
          <source>If the code block contains a single function with &lt;code&gt;it&lt;/code&gt; as an argument, you can use the method reference (&lt;code&gt;::&lt;/code&gt;) instead of the lambda:</source>
          <target state="translated">如果代码块包含与单个功能 &lt;code&gt;it&lt;/code&gt; 作为一个参数，则可以使用该方法的参考（ &lt;code&gt;::&lt;/code&gt; ）代替拉姆达：</target>
        </trans-unit>
        <trans-unit id="d97d691977b15199380af830d5ad236bbf75524c" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">如果集合可能很大，则可以指定&lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;的非负值，在这种情况下，将仅附加第一个&lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;元素，后跟&lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;截断的&lt;/a&gt;字符串（默认为&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="e8468dd252fe0ffd6b4a3af71f464889fa3a1a39" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">如果集合可能很大，则可以指定&lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;的非负值，在这种情况下，将仅附加第一个&lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;元素，后跟&lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;截断的&lt;/a&gt;字符串（默认为&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="8f5b1dc0c41182773d56507020b349e5e7ed653a" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">如果集合可能很大，则可以指定&lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;的非负值，在这种情况下，将仅附加第一个&lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;元素，后跟&lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;截断的&lt;/a&gt;字符串（默认为&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="08d4d8884be2c52559e13b59134a10b3b85cf098" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">如果集合可能很大，则可以指定&lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;的非负值，在这种情况下，将仅附加第一个&lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;元素，后跟&lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;截断的&lt;/a&gt;字符串（默认为&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9cb18d53f708d0c262ed97ec04392d87077ad40e" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">如果集合可能很大，则可以指定&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;的非负值，在这种情况下，将仅附加第一个&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;元素，后跟&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;截断的&lt;/a&gt;字符串（默认为&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="1d93c35f86678bc28fc865390dd8cf2eb747038c" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">如果集合可能很大，则可以指定&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;的非负值，在这种情况下，将仅附加第一个&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;元素，后跟&lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;截断的&lt;/a&gt;字符串（默认为&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="bbf01993f693a43b2b5c8b4e4105a26cb7dc269a" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">如果集合可能很大，则可以指定&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;的非负值，在这种情况下，将仅附加第一个&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;元素，后跟&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;截断的&lt;/a&gt;字符串（默认为&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9854e1b0b2258416f93294b380cf1572214c823f" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">如果集合可能很大，则可以指定&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;的非负值，在这种情况下，将仅附加第一个&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;元素，后跟&lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;截断的&lt;/a&gt;字符串（默认为&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="da05b4ffa7db8223c058fb5dd70605340f6d4abf" translate="yes" xml:space="preserve">
          <source>If the compiler can figure the signature out itself, it is allowed not to declare the only parameter and omit &lt;code&gt;-&amp;gt;&lt;/code&gt;. The parameter will be implicitly declared under the name &lt;code&gt;it&lt;/code&gt;:</source>
          <target state="translated">如果编译器可以自己找出签名，则可以不声明唯一的参数，而忽略 &lt;code&gt;-&amp;gt;&lt;/code&gt; 。该参数将 &lt;code&gt;it&lt;/code&gt; 名称隐式声明：</target>
        </trans-unit>
        <trans-unit id="599643b28c2249744c642d762df9eef25c3f1489" translate="yes" xml:space="preserve">
          <source>If the condition of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;when&lt;/code&gt; statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by 4 spaces relative to statement begin. Put the closing parentheses of the condition together with the opening curly brace on a separate line:</source>
          <target state="translated">如果 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;when&lt;/code&gt; 语句的条件是多行，请始终在语句主体周围使用花括号。相对于语句开始，将条件的每一行缩进4个空格。将条件的右括号和左花括号放在单独的行上：</target>
        </trans-unit>
        <trans-unit id="98f9b69afd4c5b26ac6e15a0b936fff143ad40e0" translate="yes" xml:space="preserve">
          <source>If the condition of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;when&lt;/code&gt; statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by four spaces relative to statement begin. Put the closing parentheses of the condition together with the opening curly brace on a separate line:</source>
          <target state="translated">如果 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;when&lt;/code&gt; 语句的条件是多行，请始终在语句主体周围使用花括号。相对于语句开始，将条件的每一行缩进四个空格。将条件的右括号和左花括号放在单独的一行上：</target>
        </trans-unit>
        <trans-unit id="2257c88010b27895c6524d9c1e2196bb7e536709" translate="yes" xml:space="preserve">
          <source>If the constructor has annotations or visibility modifiers, the &lt;em&gt;constructor&lt;/em&gt; keyword is required, and the modifiers go before it:</source>
          <target state="translated">如果构造函数具有注释或可见性修饰符，则必须使用&lt;em&gt;constructor&lt;/em&gt;关键字，且修饰符位于其之前：</target>
        </trans-unit>
        <trans-unit id="8e6824b3ec6e98e5575247ecc8ff5b7a4046e476" translate="yes" xml:space="preserve">
          <source>If the corresponding binary function (i.e. &lt;code&gt;plus()&lt;/code&gt; for &lt;code&gt;plusAssign()&lt;/code&gt;) is available too, report error (ambiguity),</source>
          <target state="translated">如果相应的二元函数（即 &lt;code&gt;plus()&lt;/code&gt; 为 &lt;code&gt;plusAssign()&lt;/code&gt; ）可得，报告错误（不确定性），</target>
        </trans-unit>
        <trans-unit id="750feaab46d025f60b60595fd5b6464a238bc26d" translate="yes" xml:space="preserve">
          <source>If the current capacity is less than the &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, a new backing storage is allocated with greater capacity. Otherwise, this method takes no action and simply returns.</source>
          <target state="translated">如果当前容量小于&lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;，则会分配具有更大容量的新后备存储。否则，此方法不执行任何操作，而只是返回。</target>
        </trans-unit>
        <trans-unit id="3beb3ca0f76030c28cffd99a1ef390c7748ebe7c" translate="yes" xml:space="preserve">
          <source>If the derived class has a primary constructor, the base class can (and must) be initialized right there, using the parameters of the primary constructor.</source>
          <target state="translated">如果派生类有一个主构造函数,那么基类可以(而且必须)在那里使用主构造函数的参数进行初始化。</target>
        </trans-unit>
        <trans-unit id="81ea87c7c846a5bc82b765d82616bbeeb4342e98" translate="yes" xml:space="preserve">
          <source>If the derived class has no primary constructor, then each secondary constructor has to initialize the base type using the &lt;em&gt;super&lt;/em&gt; keyword, or to delegate to another constructor which does that. Note that in this case different secondary constructors can call different constructors of the base type:</source>
          <target state="translated">如果派生类没有主构造函数，则每个辅助构造函数都必须使用&lt;em&gt;super&lt;/em&gt;关键字初始化基本类型，或委派给执行此操作的另一个构造函数。请注意，在这种情况下，不同的辅助构造函数可以调用基本类型的不同构造函数：</target>
        </trans-unit>
        <trans-unit id="4bdcd3a2cd6234626ea8fd7aebd3dff5dd746817" translate="yes" xml:space="preserve">
          <source>If the enum class defines any members, separate the enum constant definitions from the member definitions with a semicolon.</source>
          <target state="translated">如果枚举类定义了任何成员,请用分号将枚举常量定义与成员定义分开。</target>
        </trans-unit>
        <trans-unit id="4f83e9cb6ca713b30ca5975229637ad37ddf0b2e" translate="yes" xml:space="preserve">
          <source>If the expression to the left of &lt;code&gt;?:&lt;/code&gt; is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note that the right-hand side expression is evaluated only if the left-hand side is null.</source>
          <target state="translated">如果 &lt;code&gt;?:&lt;/code&gt; 左侧的表达式不为null，则elvis运算符将其返回，否则它将返回右侧的表达式。注意，仅当左侧为null时，才对右侧表达式求值。</target>
        </trans-unit>
        <trans-unit id="435bd7ef9c1ca0e75781f37812da8cdd0434ce4a" translate="yes" xml:space="preserve">
          <source>If the file path given is just a file, walker iterates only it. If the file path given does not exist, walker iterates nothing, i.e. it's equivalent to an empty sequence.</source>
          <target state="translated">如果给定的文件路径只是一个文件,Walker只对它进行迭代。如果给定的文件路径不存在,则Walker不进行任何迭代,即相当于一个空序列。</target>
        </trans-unit>
        <trans-unit id="950981d3a093a2bbe4e3f81e6b27e0b947e8539d" translate="yes" xml:space="preserve">
          <source>If the files reside in locations different from the current directory, use relative paths.</source>
          <target state="translated">如果文件所在的位置与当前目录不同,请使用相对路径。</target>
        </trans-unit>
        <trans-unit id="341f4361aea5609d460e0b76db7e4ec05c60a0bb" translate="yes" xml:space="preserve">
          <source>If the function from the right column is available</source>
          <target state="translated">如果右栏的函数可用</target>
        </trans-unit>
        <trans-unit id="baaa08a62689c9d8bfb298957d5ecaaa332cecf1" translate="yes" xml:space="preserve">
          <source>If the function has an expression body that doesn't fit in the same line as the declaration, put the &lt;code&gt;=&lt;/code&gt; sign on the first line. Indent the expression body by 4 spaces.</source>
          <target state="translated">如果函数的表达式主体与声明所在的行不同，则将 &lt;code&gt;=&lt;/code&gt; 符号放在第一行。将表达式主体缩进4个空格。</target>
        </trans-unit>
        <trans-unit id="70135d84f18dddfdfe73a753ae1ea55edda69b5b" translate="yes" xml:space="preserve">
          <source>If the function has an expression body that doesn't fit in the same line as the declaration, put the &lt;code&gt;=&lt;/code&gt; sign on the first line. Indent the expression body by four spaces.</source>
          <target state="translated">如果函数的表达式主体与声明所在的行不同，则在第一行添加 &lt;code&gt;=&lt;/code&gt; 符号。将表达式主体缩进四个空格。</target>
        </trans-unit>
        <trans-unit id="29229e1e579d9295bd8f3ae80b55b98deb32a290" translate="yes" xml:space="preserve">
          <source>If the function is absent or ambiguous, it is a compilation error;</source>
          <target state="translated">如果函数不存在或含糊不清,则是编译错误。</target>
        </trans-unit>
        <trans-unit id="6df6274a785959a141d5be93cbbade7433fe3f26" translate="yes" xml:space="preserve">
          <source>If the function is present and its return type is &lt;code&gt;R&lt;/code&gt;, the expression &lt;code&gt;+a&lt;/code&gt; has type &lt;code&gt;R&lt;/code&gt;;</source>
          <target state="translated">如果存在该函数且其返回类型为 &lt;code&gt;R&lt;/code&gt; ，则表达式 &lt;code&gt;+a&lt;/code&gt; 的类型为 &lt;code&gt;R&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="0e5095d3d7b34d609b680d7fa5506874cf55c9e5" translate="yes" xml:space="preserve">
          <source>If the function signature doesn't fit on a single line, use the following syntax:</source>
          <target state="translated">如果函数签名不适合放在一行,请使用以下语法。</target>
        </trans-unit>
        <trans-unit id="da5a14c8b54552ea732a4d4e6142a3943b4cd96d" translate="yes" xml:space="preserve">
          <source>If the group in the regular expression is optional and there were no match captured by that group, corresponding component value is an empty string.</source>
          <target state="translated">如果正则表达式中的组是可选的,并且该组没有捕获到任何匹配,则对应的组件值是一个空字符串。</target>
        </trans-unit>
        <trans-unit id="d430ff9c1ba01bf9a8c783998530df052f55721e" translate="yes" xml:space="preserve">
          <source>If the group in the regular expression is optional and there were no match captured by that group, corresponding item in &lt;a href=&quot;group-values&quot;&gt;groupValues&lt;/a&gt; is an empty string.</source>
          <target state="translated">如果正则表达式中的组是可选的，并且该组未捕获任何匹配项，则&lt;a href=&quot;group-values&quot;&gt;groupValues&lt;/a&gt;中的对应项为空字符串。</target>
        </trans-unit>
        <trans-unit id="2c92efac4e6ff6397d8d9d74602f3a7f95aa695d" translate="yes" xml:space="preserve">
          <source>If the hours component absolute value of this duration is greater than &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, it is replaced with &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, so the infinite duration is formatted as `&quot;PT2147483647H&quot;.</source>
          <target state="translated">如果此持续时间的小时分量绝对值大于&lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;，则将其替换为&lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;，因此无限持续时间的格式为&amp;ldquo; PT2147483647H&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="643fa02b9a8df93d52958425162d28c0e98f33e6" translate="yes" xml:space="preserve">
          <source>If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.</source>
          <target state="translated">如果一个值的初始化抛出异常,它将在下次访问时尝试重新初始化该值。</target>
        </trans-unit>
        <trans-unit id="70f53db00bc0a33bccdcb28704c5331a818e66f8" translate="yes" xml:space="preserve">
          <source>If the innermost applied &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; has &lt;code&gt;suppress=true&lt;/code&gt;, the type is generated without wildcards. If the innermost applied &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; has &lt;code&gt;suppress=false&lt;/code&gt;, the type is generated with wildcards.</source>
          <target state="translated">如果最内层应用的 &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; 具有prevent &lt;code&gt;suppress=true&lt;/code&gt; ，则生成类型时不使用通配符。如果最内层应用的 &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; 具有prevent &lt;code&gt;suppress=false&lt;/code&gt; ，则使用通配符生成该类型。</target>
        </trans-unit>
        <trans-unit id="eee51b4527104383bc254754abf4668fd83fd300" translate="yes" xml:space="preserve">
          <source>If the lambda is the only argument to that call, the parentheses can be omitted entirely:</source>
          <target state="translated">如果lambda是该调用的唯一参数,可以完全省略括号。</target>
        </trans-unit>
        <trans-unit id="1de53ed9727d06b3c7bd0607d6d4643e9b89c9f3" translate="yes" xml:space="preserve">
          <source>If the lambda parameter is unused, you can place an underscore instead of its name:</source>
          <target state="translated">如果lambda参数未被使用,可以用下划线代替其名称。</target>
        </trans-unit>
        <trans-unit id="a9c6142f7e98803bfddded146b81383e4a0f40e4" translate="yes" xml:space="preserve">
          <source>If the last argument after default parameters is a &lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt;, it can be passed in either as a named argument or &lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;outside the parentheses&lt;/a&gt;:</source>
          <target state="translated">如果默认参数之后的最后一个参数是&lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt;，则可以将其作为命名参数或&lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;括号外&lt;/a&gt;传递：</target>
        </trans-unit>
        <trans-unit id="228e14748a5781e0c8dfea5c0e0f424d49c4dd7a" translate="yes" xml:space="preserve">
          <source>If the last argument after default parameters is a &lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt;, you can pass it either as a named argument or &lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;outside the parentheses&lt;/a&gt;:</source>
          <target state="translated">如果默认参数之后的最后一个参数是&lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt;，则可以将其作为命名参数或&lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;在括号之外&lt;/a&gt;传递：</target>
        </trans-unit>
        <trans-unit id="b64359d957702bc4133d8dddc95300b39134cda9" translate="yes" xml:space="preserve">
          <source>If the library you are adding has dependencies on &lt;a href=&quot;#npm-dependencies&quot;&gt;packages from npm&lt;/a&gt;, Gradle will automatically resolve these transitive dependencies as well.</source>
          <target state="translated">如果您要添加的库对&lt;a href=&quot;#npm-dependencies&quot;&gt;npm中的软件包&lt;/a&gt;具有依赖关系，则Gradle也会自动解决这些传递性依赖关系。</target>
        </trans-unit>
        <trans-unit id="bc94874fad8d6a3f9e943d1975b7337b73e5e96a" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果列表包含等于指定&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;元素的&lt;/a&gt;多个元素，则不能保证将找到哪一个。</target>
        </trans-unit>
        <trans-unit id="283094cd40b3e90a305fdcb2b91ad3b0c2c41453" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果列表包含等于指定&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;元素的&lt;/a&gt;多个元素，则不能保证将找到哪一个。</target>
        </trans-unit>
        <trans-unit id="791c40d36929cc71b9e4bc35ccf6279a3a20c0ac" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果列表包含等于指定&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;元素的&lt;/a&gt;多个元素，则不能保证将找到哪一个。</target>
        </trans-unit>
        <trans-unit id="44a57d6c0b8b204d89d02d382bc44b25184c5e7e" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T?)),%20kotlin.collections.binarySearch.T?,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果列表包含等于指定&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T?)),%20kotlin.collections.binarySearch.T?,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;元素的&lt;/a&gt;多个元素，则不能保证将找到哪一个。</target>
        </trans-unit>
        <trans-unit id="79a654f17dffc6680bd32da28acb61ad45511a3b" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements for which &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearch.T%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; returns zero, there is no guarantee which one will be found.</source>
          <target state="translated">如果列表包含多个元素，&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearch.T%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较结果&lt;/a&gt;将返回零，则不能保证找到哪个元素。</target>
        </trans-unit>
        <trans-unit id="196e625da9b2a4c97eb60bc8e8aa4a4acff994c2" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements for which &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;comparison&lt;/a&gt; returns zero, there is no guarantee which one will be found.</source>
          <target state="translated">如果列表包含多个元素，&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;比较结果&lt;/a&gt;将返回零，则不能保证找到哪一个。</target>
        </trans-unit>
        <trans-unit id="3c27e8d39625b1f210692fb3e472e2e70d219112" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements with the specified &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy%28kotlin.collections.List%28%28kotlin.collections.binarySearchBy.T%29%29%2C+kotlin.collections.binarySearchBy.K%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearchBy.T%2C+kotlin.collections.binarySearchBy.K%29%29%29%2Fkey&quot;&gt;key&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果列表包含具有指定&lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy%28kotlin.collections.List%28%28kotlin.collections.binarySearchBy.T%29%29%2C+kotlin.collections.binarySearchBy.K%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearchBy.T%2C+kotlin.collections.binarySearchBy.K%29%29%29%2Fkey&quot;&gt;键的&lt;/a&gt;多个元素，则不能保证将找到哪个元素。</target>
        </trans-unit>
        <trans-unit id="954563aad1a60c6b8d078907859e9fc7093c613a" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements with the specified &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy(kotlin.collections.List((kotlin.collections.binarySearchBy.T)),%20kotlin.collections.binarySearchBy.K?,%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearchBy.T,%20kotlin.collections.binarySearchBy.K?)))/key&quot;&gt;key&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">如果列表包含具有指定&lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy(kotlin.collections.List((kotlin.collections.binarySearchBy.T)),%20kotlin.collections.binarySearchBy.K?,%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearchBy.T,%20kotlin.collections.binarySearchBy.K?)))/key&quot;&gt;键的&lt;/a&gt;多个元素，则不能保证将找到哪个元素。</target>
        </trans-unit>
        <trans-unit id="faaba4525f66a7ceffb2e5046c2260e6c103509f" translate="yes" xml:space="preserve">
          <source>If the list size is less than the specified index, an exception is thrown. There are two other functions that help you avoid such exceptions:</source>
          <target state="translated">如果列表大小小于指定的索引,就会抛出一个异常。还有两个函数可以帮助你避免这种异常。</target>
        </trans-unit>
        <trans-unit id="eb9933a4cb9e8666aba0e0d81ce03883cc01e6a2" translate="yes" xml:space="preserve">
          <source>If the map was created by &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;, resorts to its &lt;code&gt;defaultValue&lt;/code&gt; provider function instead of throwing an exception.</source>
          <target state="translated">如果映射是通过&lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;创建的，则诉诸于其 &lt;code&gt;defaultValue&lt;/code&gt; 提供程序功能，而不是引发异常。</target>
        </trans-unit>
        <trans-unit id="b065f87a2aa4168218c6dc371595cc4dd1e98fe7" translate="yes" xml:space="preserve">
          <source>If the memory leak checker is activated, by default &lt;code&gt;true&lt;/code&gt; in debug mode, &lt;code&gt;false&lt;/code&gt; in release. When memory leak checker is activated, and leak is detected during last Kotlin context deinitialization process - error message with leak information is printed and application execution is aborted.</source>
          <target state="translated">如果内存泄漏检查器已激活，则默认情况下在调试模式下为 &lt;code&gt;true&lt;/code&gt; ，在释放模式下为 &lt;code&gt;false&lt;/code&gt; 。激活内存泄漏检查器后，在最后一次Kotlin上下文取消初始化过程中检测到泄漏-带有泄漏信息的错误消息被打印，应用程序执行被中止。</target>
        </trans-unit>
        <trans-unit id="c1f1e713ff8c23832b76dce0f833606cef70aca6" translate="yes" xml:space="preserve">
          <source>If the name of the property starts with &lt;code&gt;is&lt;/code&gt;, a different name mapping rule is used: the name of the getter will be the same as the property name, and the name of the setter will be obtained by replacing &lt;code&gt;is&lt;/code&gt; with &lt;code&gt;set&lt;/code&gt;. For example, for a property &lt;code&gt;isOpen&lt;/code&gt;, the getter will be called &lt;code&gt;isOpen()&lt;/code&gt; and the setter will be called &lt;code&gt;setOpen()&lt;/code&gt;. This rule applies for properties of any type, not just &lt;code&gt;Boolean&lt;/code&gt;.</source>
          <target state="translated">如果该属性的名称开头 &lt;code&gt;is&lt;/code&gt; ，不同的名称的映射规则用于：吸气剂的名称将是相同的属性名称，以及设置器的名称将通过替换获得 &lt;code&gt;is&lt;/code&gt; 与 &lt;code&gt;set&lt;/code&gt; 。例如，对于属性 &lt;code&gt;isOpen&lt;/code&gt; ，将将getter称为 &lt;code&gt;isOpen()&lt;/code&gt; ,而将setter称为 &lt;code&gt;setOpen()&lt;/code&gt; 。该规则适用于任何类型的属性，而不仅仅是 &lt;code&gt;Boolean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3332fa3bdec15301400b043f38b9641d591bc5f4" translate="yes" xml:space="preserve">
          <source>If the object is an instance of a functional Java interface (i.e. a Java interface with a single abstract method), you can create it using a lambda expression prefixed with the type of the interface:</source>
          <target state="translated">如果对象是一个功能性Java接口的实例(即一个具有单个抽象方法的Java接口),你可以使用一个以接口类型为前缀的lambda表达式来创建它。</target>
        </trans-unit>
        <trans-unit id="079d14d9fa4b11b9fed1da4e6938934fb59ac4b3" translate="yes" xml:space="preserve">
          <source>If the original list is mutable, all its changes reflect in its reversed views and vice versa.</source>
          <target state="translated">如果原始列表是可变的,那么它的所有变化都会反映在它的反面视图中,反之亦然。</target>
        </trans-unit>
        <trans-unit id="f199eb80255475df9da84da09551f8bd23017106" translate="yes" xml:space="preserve">
          <source>If the package is not specified, the contents of such a file belong to &quot;default&quot; package that has no name.</source>
          <target state="translated">如果没有指定包,这种文件的内容属于没有名字的 &quot;默认 &quot;包。</target>
        </trans-unit>
        <trans-unit id="607e0590c98b31f775522f050ca8e1b54f20a06e" translate="yes" xml:space="preserve">
          <source>If the package is not specified, the contents of such a file belong to the default package that has no name.</source>
          <target state="translated">如果没有指定包,则该文件的内容属于没有名称的默认包。</target>
        </trans-unit>
        <trans-unit id="e2bbcc7a5d6ec12b113958618724012f588f92a6" translate="yes" xml:space="preserve">
          <source>If the parameter list is too long to fit on a line, put the arrow on a separate line:</source>
          <target state="translated">如果参数列表太长,无法在一条线上显示,请将箭头放在另一条线上。</target>
        </trans-unit>
        <trans-unit id="65d840640485aeb56113ca2dcd5f195cfe9368f9" translate="yes" xml:space="preserve">
          <source>If the parameters or return types of the members of a variant type are themselves variant, it gets a bit complicated. Function types in parameters and return types make it even more challenging. If you're wondering whether it's safe to use a variant type parameter &lt;code&gt;T&lt;/code&gt; in a particular position, ask yourself:</source>
          <target state="translated">如果变量类型的成员的参数或返回类型本身就是变量，则将变得有些复杂。参数中的函数类型和返回类型使其更具挑战性。如果您想在特定位置使用变体类型参数 &lt;code&gt;T&lt;/code&gt; 是否安全，请问自己：</target>
        </trans-unit>
        <trans-unit id="a18d633a4ebf37f8c95ff8f80627508e8e6e0a0d" translate="yes" xml:space="preserve">
          <source>If the primary constructor does not have any annotations or visibility modifiers, the &lt;em&gt;constructor&lt;/em&gt; keyword can be omitted:</source>
          <target state="translated">如果主构造没有任何注释或能见度改性剂，该&lt;em&gt;构造&lt;/em&gt;可以省略关键字：</target>
        </trans-unit>
        <trans-unit id="a6331b4a5547ad93c58b05b7df58bb3cc81e3498" translate="yes" xml:space="preserve">
          <source>If the repository of the dependency you wish to use does not provide TypeScript definitions, you can also use types provided via the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; repository. In this case, make sure you add &lt;code&gt;npm&lt;/code&gt; dependencies for both &lt;code&gt;your-package&lt;/code&gt; and &lt;code&gt;@types/your-package&lt;/code&gt; (with &lt;code&gt;generateExternals = true&lt;/code&gt;).</source>
          <target state="translated">如果您希望使用的依赖项存储库不提供TypeScript定义，则还可以使用通过&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;存储库提供的类型。在这种情况下，请确保为 &lt;code&gt;your-package&lt;/code&gt; 和 &lt;code&gt;@types/your-package&lt;/code&gt; 都添加了 &lt;code&gt;npm&lt;/code&gt; 依赖项（使用 &lt;code&gt;generateExternals = true&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="47e17a53862f3b306373aab1293af010a48f2c36" translate="yes" xml:space="preserve">
          <source>If the same kind of ambiguity arises when a dependency is added to a custom configuration rather than one of the configurations created by the plugin, you can add the attributes to the configuration in the same way:</source>
          <target state="translated">如果将依赖关系添加到自定义配置而不是插件创建的配置之一时,也会产生同样的歧义,你可以用同样的方式将属性添加到配置中。</target>
        </trans-unit>
        <trans-unit id="c2003e3c2a4c342bc0df488d2992403b24e0a68f" translate="yes" xml:space="preserve">
          <source>If the second-to-last line compiled, it would allow us to put a pear into what is ostensibly a bowl of only apples, and your code would explode when it tried to extract the &quot;apple&quot; from the bowl. However, it's frequently useful to be able to let the type hierarchy of a generic type parameter &quot;flow&quot; to the generic class. As we saw above, though, some care must be taken - the solution is to restrict the direction in which you can move data in and out of the generic object.</source>
          <target state="translated">如果第二行到最后一行编译,它将允许我们把一个梨放入表面上只有苹果的碗中,当你的代码试图从碗中提取 &quot;苹果 &quot;时,它将爆炸。然而,能够让一个通用类型参数的类型层次结构 &quot;流 &quot;到通用类中去是经常有用的。不过正如我们在上面看到的那样,必须采取一些谨慎的态度--解决方案是限制你可以将数据移入和移出通用对象的方向。</target>
        </trans-unit>
        <trans-unit id="5e1d01b7eb886e9322c190422643ee87c94b9cb3" translate="yes" xml:space="preserve">
          <source>If the sequence operation returns another sequence, which is produced lazily, it's called &lt;em&gt;intermediate&lt;/em&gt;, and otherwise the operation is &lt;em&gt;terminal&lt;/em&gt;. Examples of terminal operations are &lt;a href=&quot;to-list&quot;&gt;kotlin.sequences.Sequence.toList&lt;/a&gt;, kotlin.sequences.Sequence.max.</source>
          <target state="translated">如果序列操作返回延迟生成的另一个序列，则称为&amp;ldquo; &lt;em&gt;中间&amp;rdquo;&lt;/em&gt;，否则该操作为&amp;ldquo; &lt;em&gt;终端&amp;rdquo;&lt;/em&gt;。终端操作的示例是&lt;a href=&quot;to-list&quot;&gt;kotlin.sequences.Sequence.toList&lt;/a&gt;，kotlin.sequences.Sequence.max。</target>
        </trans-unit>
        <trans-unit id="44fdc9a07256ffbf20d393bac49e51adf9b4b7af" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 1, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果此数组的大小小于1，则抛出&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="2773fd03bef38a23b5651a21ca7d831595d79640" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 2, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果此数组的大小小于2，则抛出&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="0a0294e2f74afcb56591a07671514765850b0c72" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 3, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果此数组的大小小于3，则在未指定行为的Kotlin / JS中，抛出&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da2e1fd0a51d8f47f0a64c24600fb4365faadd98" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 4, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果此数组的大小小于4，则将抛出&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="9b9ee92ddb8bbb5a34fed19ad7463f35b65299f8" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 5, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">如果此数组的大小小于5，则抛出&lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException，&lt;/a&gt;但Kotlin / JS中未指定行为的除外。</target>
        </trans-unit>
        <trans-unit id="2f129a501ea48f8a97397e0402d32e22a0e66393" translate="yes" xml:space="preserve">
          <source>If the source set &lt;code&gt;jvmMain&lt;/code&gt; depends on a source set &lt;code&gt;commonMain&lt;/code&gt; then:</source>
          <target state="translated">如果源集 &lt;code&gt;jvmMain&lt;/code&gt; 依赖于源集 &lt;code&gt;commonMain&lt;/code&gt; ,则：</target>
        </trans-unit>
        <trans-unit id="aea8a32a75a7deb90bc9b2784a7bca89130df6d4" translate="yes" xml:space="preserve">
          <source>If the supertype has a constructor, it must be invoked with parentheses after the supertype name. You can specify multiple supertypes if need be (but as usual, at most one superclass).</source>
          <target state="translated">如果超类型有构造函数,必须在超类型名称后加括号调用。如果需要,你可以指定多个超类型(但一样平常最多只能指定一个超类)。</target>
        </trans-unit>
        <trans-unit id="f754e813201e3d3c1d7a4229841ecfb54eadad53" translate="yes" xml:space="preserve">
          <source>If the target meta-annotation is not present on an annotation declaration, the annotation is applicable to the following elements: &lt;a href=&quot;../-annotation-target/-c-l-a-s-s#kotlin.annotation.AnnotationTarget.CLASS&quot;&gt;CLASS&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y#kotlin.annotation.AnnotationTarget.PROPERTY&quot;&gt;PROPERTY&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-f-i-e-l-d#kotlin.annotation.AnnotationTarget.FIELD&quot;&gt;FIELD&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE&quot;&gt;LOCAL_VARIABLE&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER&quot;&gt;VALUE_PARAMETER&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-c-o-n-s-t-r-u-c-t-o-r#kotlin.annotation.AnnotationTarget.CONSTRUCTOR&quot;&gt;CONSTRUCTOR&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-f-u-n-c-t-i-o-n#kotlin.annotation.AnnotationTarget.FUNCTION&quot;&gt;FUNCTION&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER&quot;&gt;PROPERTY_GETTER&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER&quot;&gt;PROPERTY_SETTER&lt;/a&gt;.</source>
          <target state="translated">如果注释声明中不存在目标元注释，则注释适用于以下元素：&lt;a href=&quot;../-annotation-target/-c-l-a-s-s#kotlin.annotation.AnnotationTarget.CLASS&quot;&gt;CLASS&lt;/a&gt;，&lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y#kotlin.annotation.AnnotationTarget.PROPERTY&quot;&gt;PROPERTY&lt;/a&gt;，&lt;a href=&quot;../-annotation-target/-f-i-e-l-d#kotlin.annotation.AnnotationTarget.FIELD&quot;&gt;FIELD&lt;/a&gt;，&lt;a href=&quot;../-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE&quot;&gt;LOCAL_VARIABLE&lt;/a&gt;，&lt;a href=&quot;../-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER&quot;&gt;VALUE_PARAMETER&lt;/a&gt;，&lt;a href=&quot;../-annotation-target/-c-o-n-s-t-r-u-c-t-o-r#kotlin.annotation.AnnotationTarget.CONSTRUCTOR&quot;&gt;CONSTRUCTOR&lt;/a&gt;，&lt;a href=&quot;../-annotation-target/-f-u-n-c-t-i-o-n#kotlin.annotation.AnnotationTarget.FUNCTION&quot;&gt;FUNCTION&lt;/a&gt;，&lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER&quot;&gt;PROPERTY_GETTER&lt;/a&gt;，&lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER&quot;&gt;PROPERTY_SETTER&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a35d20b281a1e85d8a06fc803c1646e572b36e8" translate="yes" xml:space="preserve">
          <source>If the transformation produces &lt;code&gt;null&lt;/code&gt; on certain elements, you can filter out the &lt;code&gt;null&lt;/code&gt;s from the result collection by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-not-null&quot;&gt;&lt;code&gt;mapNotNull()&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;map()&lt;/code&gt;, or &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed-not-null&quot;&gt;&lt;code&gt;mapIndexedNotNull()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;mapIndexed()&lt;/code&gt;.</source>
          <target state="translated">如果转换产生 &lt;code&gt;null&lt;/code&gt; 的某些元素，您可以过滤掉 &lt;code&gt;null&lt;/code&gt; 调用从结果系列S &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-not-null&quot;&gt; &lt;code&gt;mapNotNull()&lt;/code&gt; &lt;/a&gt;函数，而不是 &lt;code&gt;map()&lt;/code&gt; ，或&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed-not-null&quot;&gt; &lt;code&gt;mapIndexedNotNull()&lt;/code&gt; &lt;/a&gt;代替 &lt;code&gt;mapIndexed()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9296b27a4d8120036a7decf816cb92c4373c8a8" translate="yes" xml:space="preserve">
          <source>If the type of the last parameter to a function is a function type and you want to supply a lambda expression, you can place the lambda expression &lt;em&gt;outside&lt;/em&gt; of the parameter parentheses. If the lambda expression is the only parameter, you can omit the parentheses entirely. This is very useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;constructing DSLs&lt;/a&gt;.</source>
          <target state="translated">如果函数的最后一个参数的类型是函数类型，并且您想提供一个lambda表达式，则可以将lambda表达式&lt;em&gt;放在&lt;/em&gt;参数括号之外。如果lambda表达式是唯一的参数，则可以完全省略括号。这对于&lt;a href=&quot;functional-programming#receivers&quot;&gt;构建DSL&lt;/a&gt;非常有用。</target>
        </trans-unit>
        <trans-unit id="a6b8f4ffb4740b781007cf6d0bbe0282c0376673" translate="yes" xml:space="preserve">
          <source>If the value doesn't fit in the range of &lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; type, it is coerced into that range, see the conversion &lt;a href=&quot;../../kotlin/-double/to-int#kotlin.Double%24toInt()&quot;&gt;Double.toInt&lt;/a&gt; for details.</source>
          <target state="translated">如果该值不适合&lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt;类型的范围，则将其强制为该范围，有关详细信息，请参见转换&lt;a href=&quot;../../kotlin/-double/to-int#kotlin.Double%24toInt()&quot;&gt;Double.toInt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e29d1de77f34d3695193f07bd125bf5fcf617a87" translate="yes" xml:space="preserve">
          <source>If the value doesn't fit in the range of &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; type, it is coerced into that range, see the conversion &lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;Double.toLong&lt;/a&gt; for details.</source>
          <target state="translated">如果该值不在&lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt;类型范围内，则将其强制为该范围，有关详细信息，请参见转换&lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;Double.toLong&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d77bf30b739c2514d63ed87849b1332700a2c8b6" translate="yes" xml:space="preserve">
          <source>If the value has a receiver type, the receiver object should be passed as the first argument. Another way to invoke a value of a function type with receiver is to prepend it with the receiver object, as if the value were an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt;: &lt;code&gt;1.foo(2)&lt;/code&gt;,</source>
          <target state="translated">如果该值具有接收器类型，则应将接收器对象作为第一个参数传递。用接收器调用函数类型的值的另一种方法是在接收器对象之前添加它，就好像该值是&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt;： &lt;code&gt;1.foo(2)&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="08b10da0a2b6c0dae39cbc760c047dc614066a39" translate="yes" xml:space="preserve">
          <source>If the value of a read-only property is known at the compile time, mark it as a &lt;em&gt;compile time constant&lt;/em&gt; using the &lt;em&gt;const&lt;/em&gt; modifier. Such properties need to fulfil the following requirements:</source>
          <target state="translated">如果在编译时知道只读属性的值，则使用&lt;em&gt;const&lt;/em&gt;修饰符将其标记为&lt;em&gt;编译时常数&lt;/em&gt;。这些属性需要满足以下要求：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec8c7f7b7e4402c0d35a4121dd40caffc8d7c935" translate="yes" xml:space="preserve">
          <source>If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html#initialValue()&quot;&gt;ThreadLocal.initialValue&lt;/a&gt; method. Then if it is still &lt;code&gt;null&lt;/code&gt;, the provided &lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet%28java.lang.ThreadLocal%28%28kotlin.concurrent.getOrSet.T%29%29%2C+kotlin.Function0%28%28kotlin.concurrent.getOrSet.T%29%29%29%2Fdefault&quot;&gt;default&lt;/a&gt; function is called and its result is stored for the current thread and then returned.</source>
          <target state="translated">如果该变量没有当前线程的值，则首先将其初始化为通过调用&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html#initialValue()&quot;&gt;ThreadLocal.initialValue&lt;/a&gt;方法返回的值。然后，如果它仍然为 &lt;code&gt;null&lt;/code&gt; ，则调用提供的&lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet%28java.lang.ThreadLocal%28%28kotlin.concurrent.getOrSet.T%29%29%2C+kotlin.Function0%28%28kotlin.concurrent.getOrSet.T%29%29%29%2Fdefault&quot;&gt;默认&lt;/a&gt;函数，并将其结果存储在当前线程中，然后返回。</target>
        </trans-unit>
        <trans-unit id="55d02f7ccfe9e99651ab411f3283f4f1c75cff68" translate="yes" xml:space="preserve">
          <source>If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the ThreadLocal.initialValue method. Then if it is still &lt;code&gt;null&lt;/code&gt;, the provided &lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet(java.lang.ThreadLocal((kotlin.concurrent.getOrSet.T)),%20kotlin.Function0((kotlin.concurrent.getOrSet.T)))/default&quot;&gt;default&lt;/a&gt; function is called and its result is stored for the current thread and then returned.</source>
          <target state="translated">如果变量没有当前线程的值，则首先将其初始化为通过调用ThreadLocal.initialValue方法返回的值。然后，如果它仍然为 &lt;code&gt;null&lt;/code&gt; ，则调用提供的&lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet(java.lang.ThreadLocal((kotlin.concurrent.getOrSet.T)),%20kotlin.Function0((kotlin.concurrent.getOrSet.T)))/default&quot;&gt;默认&lt;/a&gt;函数，并将其结果存储在当前线程中，然后返回。</target>
        </trans-unit>
        <trans-unit id="3f98dbe730a8c5b27f6e85f63d1bb117f2681dde" translate="yes" xml:space="preserve">
          <source>If there are clients that use your Kotlin interfaces compiled without the new &lt;code&gt;-Xjvm-default=all&lt;/code&gt; option, then they can be incompatible with the same code compiled with this option.</source>
          <target state="translated">如果有些客户端使用的Kotlin接口编译时没有新的 &lt;code&gt;-Xjvm-default=all&lt;/code&gt; 选项，则它们可能与使用此选项编译的相同代码不兼容。</target>
        </trans-unit>
        <trans-unit id="dcc77a995f63cb6e01033f3a55686b845948a61a" translate="yes" xml:space="preserve">
          <source>If there are explicit implementations of &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; or &lt;code&gt;toString()&lt;/code&gt; in the data class body or &lt;em&gt;final&lt;/em&gt; implementations in a superclass, then these functions are not generated, and the existing implementations are used;</source>
          <target state="translated">如果数据类主体中有 &lt;code&gt;equals()&lt;/code&gt; ， &lt;code&gt;hashCode()&lt;/code&gt; 或 &lt;code&gt;toString()&lt;/code&gt; 的显式实现或超类中的&lt;em&gt;最终&lt;/em&gt;实现，则不生成这些函数，而使用现有的实现；</target>
        </trans-unit>
        <trans-unit id="706d1394b60969b44602412d2be62295a909c4ef" translate="yes" xml:space="preserve">
          <source>If there are multiple equal maximal values, returns the first of them.</source>
          <target state="translated">如果有多个相等的最大值,返回其中的第一个。</target>
        </trans-unit>
        <trans-unit id="ca6054fd048270c35ac42f250ec06387cb65b331" translate="yes" xml:space="preserve">
          <source>If there are multiple equal minimal values, returns the first of them.</source>
          <target state="translated">如果有多个相等的最小值,返回其中的第一个。</target>
        </trans-unit>
        <trans-unit id="a22fd4a7c09aa2ff0cda3088cc25dcaf533edd1f" translate="yes" xml:space="preserve">
          <source>If there are no errors during compilation, we should see the result of the execution of our program, which on execution should output the contents of the site &lt;code&gt;http://example.com&lt;/code&gt;</source>
          <target state="translated">如果在编译过程中没有错误，我们应该看到程序执行的结果，执行后该结果应该输出站点 &lt;code&gt;http://example.com&lt;/code&gt; 的内容</target>
        </trans-unit>
        <trans-unit id="9edcba1fdea56091b72b70d9544284be2a9b118c" translate="yes" xml:space="preserve">
          <source>If there is a name clash, we can disambiguate by using &lt;em&gt;as&lt;/em&gt; keyword to locally rename the clashing entity:</source>
          <target state="translated">如果存在名称冲突，我们可以使用&lt;em&gt;as&lt;/em&gt;关键字在本地重命名冲突实体来消除歧义：</target>
        </trans-unit>
        <trans-unit id="b4b2b7e97af6db9e9aed9e5719f03ea30bf0227c" translate="yes" xml:space="preserve">
          <source>If there is a naming conflict, you should usually import just one of the symbols and fully qualify the usages of the other. If both are heavily used, you can rename the symbol at import time:</source>
          <target state="translated">如果有命名冲突,通常应该只导入其中一个符号,并充分限定另一个符号的用途。如果两个符号都被大量使用,可以在导入时重新命名该符号。</target>
        </trans-unit>
        <trans-unit id="a65b66d3772f31ab93bac26e3026245f1a24b319" translate="yes" xml:space="preserve">
          <source>If there's no nice way around it, and you need to take special actions based on what type something is or to access functions/properties that only exist on some classes, you can use &lt;code&gt;is&lt;/code&gt; to check if the real type of an object is a particular class or a subclass thereof (or an implementor of an interface). When this is used as the condition in an &lt;code&gt;if&lt;/code&gt;, the compiler will let you perform type-specific operations on the object inside the &lt;code&gt;if&lt;/code&gt; body:</source>
          <target state="translated">如果有周围没有很好的方法，你需要基于什么类型的东西要采取特别的行动是或访问功能/特性只能在某些阶级存在，你可以使用 &lt;code&gt;is&lt;/code&gt; ，以检查是否真正的类型的对象是特定的类或其子类（或接口的实现者）。如果将此条件用作 &lt;code&gt;if&lt;/code&gt; 的条件，则编译器将允许您对 &lt;code&gt;if&lt;/code&gt; 体内的对象执行特定于类型的操作：</target>
        </trans-unit>
        <trans-unit id="c2cd9a7ecd8b049bc616a7923c1daf215620a583" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;depth&lt;/code&gt; function is called for a &lt;code&gt;deepTree&lt;/code&gt; it produces StackOverflowError because of deep recursion. However, the &lt;code&gt;depth&lt;/code&gt; function can be rewritten using &lt;code&gt;DeepRecursiveFunction&lt;/code&gt; in the following way, and then it successfully computes &lt;a href=&quot;../invoke&quot;&gt;&lt;code&gt;depth(deepTree)&lt;/code&gt;&lt;/a&gt; expression:</source>
          <target state="translated">如果为 &lt;code&gt;deepTree&lt;/code&gt; 调用此 &lt;code&gt;depth&lt;/code&gt; 函数，则会由于深度递归而产生StackOverflowError。但是，可以通过以下方式使用 &lt;code&gt;DeepRecursiveFunction&lt;/code&gt; 重写 &lt;code&gt;depth&lt;/code&gt; 函数，然后它可以成功计算&lt;a href=&quot;../invoke&quot;&gt; &lt;code&gt;depth(deepTree)&lt;/code&gt; &lt;/a&gt;表达式：</target>
        </trans-unit>
        <trans-unit id="83d0b5382998741d7aeea7ea3925f51e48120ef6" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回删除了后缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="2980e3e7312daa7fe514fbd075be82c6980d9ab3" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回删除后缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="1f68e5f9283a11982ac4d9ee4f72f23e35be2e15" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回删除了后缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="a30b2abbbd6e4e6955f1d30edef72f53b5797930" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回删除后缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="f1d9aa147865687623fa05e3a2703d76d90d9924" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回删除了后缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="066696f2f807a663e1d7eba4412c839322bfaa9e" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回删除后缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="393978ca2e4989e43b2a725707449d745979c2c2" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;开头，则返回一个已删除前缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="fbd91d26d2ddcfad42a009559f504981281599d6" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;开头，则返回一个已删除前缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="c4551b66808b7a93bcbea0cb98dbc6cf03713996" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;开头，则返回一个已删除前缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="e1cdbb98160c7143e8a1010edb16577923755a13" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;开头，则返回一个已删除前缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="e5eb3f5440c96a359b2e662128e4b4a2fe2e0c6d" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;开头，则返回一个已删除前缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="18964490a2097748cf26c9bc99dc2e1219bd1083" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">如果此char序列以给定的&lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;开头，则返回一个已删除前缀的新char序列。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="e50b89219e8ed48483bbf130e9adaab263424db1" translate="yes" xml:space="preserve">
          <source>If this file is a directory, it is copied without its content, i.e. an empty &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; directory is created. If you want to copy directory including its contents, use &lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively&lt;/a&gt;.</source>
          <target state="translated">如果此文件是目录，则复制时不包含其内容，即创建一个空的&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;目标&lt;/a&gt;目录。如果要复制包含目录内容的目录，请使用&lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="794fbb14ba44c0a10efb47ff1391acfc97fac0ad" translate="yes" xml:space="preserve">
          <source>If this file is a directory, it is copied without its content, i.e. an empty &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; directory is created. If you want to copy directory including its contents, use &lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively&lt;/a&gt;.</source>
          <target state="translated">如果此文件是目录，则复制时不包含其内容，即创建一个空的&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;目标&lt;/a&gt;目录。如果要复制包含目录内容的目录，请使用&lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="696bc35b6b7c9124fdae8a289c38873049e01372" translate="yes" xml:space="preserve">
          <source>If this file path points to a single file, then it will be copied to a file with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;. If this file path points to a directory, then its children will be copied to a directory with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">如果此文件路径指向单个文件，则它将被复制到路径为&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;的文件中。如果此文件路径指向目录，则其子级将被复制到路径为&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;的目录中。</target>
        </trans-unit>
        <trans-unit id="f19f7f0e9647874289c7ec01aa0daf1c28a6e17f" translate="yes" xml:space="preserve">
          <source>If this file path points to a single file, then it will be copied to a file with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt;. If this file path points to a directory, then its children will be copied to a directory with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">如果此文件路径指向单个文件，则它将被复制到路径为&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt;的文件中。如果此文件路径指向目录，则其子级将被复制到路径为&lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt;的目录中。</target>
        </trans-unit>
        <trans-unit id="822fa875865380bffd3780f735dc7821bbfbc1dd" translate="yes" xml:space="preserve">
          <source>If this function is invoked on other &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; instances it returns &lt;code&gt;this&lt;/code&gt; continuation unchanged.</source>
          <target state="translated">如果在其他&lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用此函数，则它将不变地返回 &lt;code&gt;this&lt;/code&gt; 延续。</target>
        </trans-unit>
        <trans-unit id="000d49e516219b57649db3a4add8aedc933ac12a" translate="yes" xml:space="preserve">
          <source>If this is the first time you're adding a Kotlin file to this project, IntelliJ IDEA will prompt you to add the required Kotlin runtime. For a Java project, configure the Kotlin runtime as a &lt;strong&gt;Kotlin Java Module&lt;/strong&gt;.</source>
          <target state="translated">如果这是您第一次向该项目添加Kotlin文件，则IntelliJ IDEA会提示您添加所需的Kotlin运行时。对于Java项目，将Kotlin运行时配置为&lt;strong&gt;Kotlin Java模块&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5452ff7f47b8e841bbf674d6743480276ef5195d" translate="yes" xml:space="preserve">
          <source>If this list doesn&amp;rsquo;t cover your needs, you can find more options in the &lt;a href=&quot;https://github.com/thomasnield/kotlin-data-science-resources&quot;&gt;&lt;strong&gt;Kotlin Data Science Resources&lt;/strong&gt;&lt;/a&gt; digest from Thomas Nield.</source>
          <target state="translated">如果此列表不能满足您的需求，您可以在Thomas Nield的&lt;a href=&quot;https://github.com/thomasnield/kotlin-data-science-resources&quot;&gt;&lt;strong&gt;Kotlin数据科学资源&lt;/strong&gt;&lt;/a&gt;摘要中找到更多选项。</target>
        </trans-unit>
        <trans-unit id="8ef8c14fd9985248743a7603b2080574686a18ae" translate="yes" xml:space="preserve">
          <source>If this reference is &lt;a href=&quot;../-c-pointer/index&quot;&gt;CPointer&lt;/a&gt;, returns this pointer, otherwise allocate storage value in the scope and return it.</source>
          <target state="translated">如果此引用为&lt;a href=&quot;../-c-pointer/index&quot;&gt;CPointer&lt;/a&gt;，则返回此指针，否则在范围内分配存储值并返回它。</target>
        </trans-unit>
        <trans-unit id="b3b7f842b5ea81c3f4b90a34bcfe922201e07ced" translate="yes" xml:space="preserve">
          <source>If this reference is &lt;a href=&quot;index&quot;&gt;CPointer&lt;/a&gt;, returns this pointer, otherwise allocate storage value in the scope and return it.</source>
          <target state="translated">如果此引用为&lt;a href=&quot;index&quot;&gt;CPointer&lt;/a&gt;，则返回此指针，否则在范围内分配存储值并返回它。</target>
        </trans-unit>
        <trans-unit id="daa765d4ed09a47719a46eaa22921d3d6383a5b1" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">如果此字符串以给定的&lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回此字符串的后缀删除的副本。否则，返回此字符串。</target>
        </trans-unit>
        <trans-unit id="d7dc1cbcb6a32aa88b8d844adc9e841c43d6e6b8" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">如果此字符串以给定的&lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回此字符串的后缀已删除的副本。否则，返回此字符串。</target>
        </trans-unit>
        <trans-unit id="fe146357dbe5d233f80385c4622bdabdf282c2ff" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">如果此字符串以给定的&lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回此字符串的后缀删除的副本。否则，返回此字符串。</target>
        </trans-unit>
        <trans-unit id="709bfa613cc84c58d0e77dbf11164343f90ebae6" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">如果此字符串以给定的&lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;结尾，则返回此字符串的后缀已删除的副本。否则，返回此字符串。</target>
        </trans-unit>
        <trans-unit id="eef5abc7cbd0224a64b4e2e54624e8e1396be8a5" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">如果此字符串以给定的&lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;前缀&lt;/a&gt;开头，则返回此字符串的副本，其中删除了前缀。否则，返回此字符串。</target>
        </trans-unit>
        <trans-unit id="92c6be29a5671e41239ef25ada1ea6fe1003a0b7" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">如果此字符串以给定的&lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;前缀&lt;/a&gt;开头，则返回此字符串的副本，其中前缀已删除。否则，返回此字符串。</target>
        </trans-unit>
        <trans-unit id="9adf224f013e9757a5b20a24dd0cebbc9d578cc5" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">如果此字符串以给定的&lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;前缀&lt;/a&gt;开头，则返回此字符串的副本，其中删除了前缀。否则，返回此字符串。</target>
        </trans-unit>
        <trans-unit id="1e98d4d193636df70b1b850a20d5da773ecb938f" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">如果此字符串以给定的&lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;前缀&lt;/a&gt;开头，则返回此字符串的副本，其中前缀已删除。否则，返回此字符串。</target>
        </trans-unit>
        <trans-unit id="eaa08b32eac3b33ecf492f621bff941ea4a9fcd4" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">如果此值在&lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE中&lt;/a&gt;，则所得的 &lt;code&gt;Byte&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="fc02da33b8b0ff318b09d189a23b770163982e91" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">如果此值在&lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE中&lt;/a&gt;，则所得的 &lt;code&gt;Byte&lt;/code&gt; 值表示与此 &lt;code&gt;Long&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="490305470096f372ac8119db4e004b84e91a7481" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">如果此值在&lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE中&lt;/a&gt;，则所得的 &lt;code&gt;Byte&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f92846150c40dce3860615a8d63e6d463453288e" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">如果此值位于&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE中&lt;/a&gt;，则所得的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;Long&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="6a741800a8dda50919fa61b7fa403325e77f2e0d" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">如果此值位于&lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE中&lt;/a&gt;，则所得的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="005b91e001ae975c4aa32f3aea7b1ec2812c965b" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">如果此值位于&lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE中&lt;/a&gt;，则所得的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;Long&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="db0284f249225c9c93443ff06ef1c4250bc05e17" translate="yes" xml:space="preserve">
          <source>If this value is in the range of &lt;code&gt;Char&lt;/code&gt; codes &lt;code&gt;Char.MIN_VALUE..Char.MAX_VALUE&lt;/code&gt;, the resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value.</source>
          <target state="translated">如果此值在 &lt;code&gt;Char&lt;/code&gt; 代码 &lt;code&gt;Char.MIN_VALUE..Char.MAX_VALUE&lt;/code&gt; 的范围内，则所得的 &lt;code&gt;Char&lt;/code&gt; 代码等于此值。</target>
        </trans-unit>
        <trans-unit id="ba8d6d461e9008017be587a9202d1b43cf4ff54e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Byte&lt;/code&gt; 值表示与此 &lt;code&gt;UByte&lt;/code&gt; 相同的数值。否则结果为负。</target>
        </trans-unit>
        <trans-unit id="df39050abae12f0e8e01436504cfef55ec387e2d" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Byte&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="4978f90a7ed1a79fd218cf1590a5d83b0509d961" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Byte&lt;/code&gt; 值表示与此 &lt;code&gt;ULong&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="6ca047505e5da8d6c0e87f024f03aaab76397dfc" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Byte&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="e4c48fdf984577c7db86ab572e1f6df4cdbfd866" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。否则结果为负。</target>
        </trans-unit>
        <trans-unit id="558a6d1dd84324e1f32448d5639a910b9702fe85" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Int&lt;/code&gt; 值表示与此 &lt;code&gt;ULong&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="d5c7b7a5156a004ef779605c60b74b3e30f938ab" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Long&lt;/code&gt; 值表示与此 &lt;code&gt;ULong&lt;/code&gt; 相同的数值。否则结果为负。</target>
        </trans-unit>
        <trans-unit id="4d043b90606414b70c2e38bef9430e4d147c520b" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="30cf5a989061d05ea8b8590b44fff20c1be5f179" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;ULong&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="1a549db6113eee376be4eec1673b56713351397d" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;Short&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。否则结果为负。</target>
        </trans-unit>
        <trans-unit id="7879809b5daf67a980acd328829f4454ce83b90e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UByte&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="bcead8032199b4164256add596a32cf9db97266e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UByte&lt;/code&gt; 值表示与此 &lt;code&gt;ULong&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="1121ef81db7e8693e07be091631a7082321f06c6" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UByte&lt;/code&gt; 值表示与此 &lt;code&gt;UShort&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="81dc4365e9ac822eeb6e28d60dee107cd6132748" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;，则所得 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;ULong&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="3c9c01de18ce638bd129bff08018567a3e4127c6" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;UInt&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a6f6b5210b89a3892e478e42ca97672805905a83" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">如果此值小于或等于&lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;ULong&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="b503698fc5df8a655c9e1e6ad1697e72a8fc230d" translate="yes" xml:space="preserve">
          <source>If this value is non-negative, the resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value.</source>
          <target state="translated">如果此值是非负值，则所得的 &lt;code&gt;Char&lt;/code&gt; 码等于该值。</target>
        </trans-unit>
        <trans-unit id="2db0fef9187625217d9cbad099e4b7a81b501888" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">如果此值为正且小于或等于&lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UByte&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="92dfb012b562ce6d901306be8ab16c8954d89a73" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">如果此值为正且小于或等于&lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UByte&lt;/code&gt; 值表示与此 &lt;code&gt;Long&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="953da8b824c2844b89e1295212fa13c1e2d80e5e" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">如果此值为正且小于或等于&lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UByte&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="9fa06c56030e25a9536cc3f63946d539809dea9f" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">如果此值为正且小于或等于&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;，则所得 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;Long&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="50d4512f22b639993dc1259c1108fdebd639d406" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">如果此值为正且小于或等于&lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="8dadb1990a07a6ce6e741d4f630eb1d46e9ed4a3" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">如果此值为正且小于或等于&lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;，则所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;Long&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f89685f072ef956cdc798c29edd60c19b535cdfe" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则所得的 &lt;code&gt;UByte&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="509d2f430404b1731ac6b4aaf8d343dae3f0754b" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则所得 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="273aa3ecdd133965b3ad433946ad9ef5ed7f4eee" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则所得 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="2607741fe174b50565a03e15e9436cf3b0a3f525" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则所得 &lt;code&gt;UInt&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="0f095f5bb49dc6a53286dbebb4a62e97505f3fa8" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则所得的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="c42bf5546a05357422f652dbab02ab2c5562b1b9" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;Int&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="1c908d0ebe8742d6be314405ace34fa252b6ec7d" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则所得的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;Long&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="b851c29ac8506df58c238a4d6e63ef0a6ce3bf18" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则得到的 &lt;code&gt;ULong&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="a4186277a2fae421e55cc11af12fc473065dce40" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;Byte&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="f91f720debed186fe9dc1691606e3420ca01e262" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">如果该值为正，则所得的 &lt;code&gt;UShort&lt;/code&gt; 值表示与此 &lt;code&gt;Short&lt;/code&gt; 相同的数值。</target>
        </trans-unit>
        <trans-unit id="b92f3912f030b245b906c1d0285095411d239059" translate="yes" xml:space="preserve">
          <source>If two corresponding elements are nested arrays, they are also compared deeply. If any of arrays contains itself on any nesting level the behavior is undefined.</source>
          <target state="translated">如果两个对应的元素是嵌套的数组,它们也会进行深度比较。如果任何一个数组在任何一个嵌套层次上都包含了自己,那么行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="5c426df69b29a4f2a8f05ed102d4c7c508452b26" translate="yes" xml:space="preserve">
          <source>If two objects are equal according to the &lt;code&gt;equals()&lt;/code&gt; method, then calling the &lt;code&gt;hashCode&lt;/code&gt; method on each of the two objects must produce the same integer result.</source>
          <target state="translated">如果根据 &lt;code&gt;equals()&lt;/code&gt; 方法，两个对象相等，则在两个对象中的每个对象上调用 &lt;code&gt;hashCode&lt;/code&gt; 方法必须产生相同的整数结果。</target>
        </trans-unit>
        <trans-unit id="848bd4767d40a5b040578d4b4acc3831b4a5c116" translate="yes" xml:space="preserve">
          <source>If using Android Studio, the following needs to be added under android:</source>
          <target state="translated">如果使用Android Studio,需要在android下添加以下内容。</target>
        </trans-unit>
        <trans-unit id="835af367bcaa35713fbb44c63e3433507604b4f9" translate="yes" xml:space="preserve">
          <source>If using Ant or Maven, the same configuration applies. The only difference being that the Runner Type would be Ant or Maven respectively.</source>
          <target state="translated">如果使用Ant或Maven,同样的配置也适用。唯一的区别是Runner类型分别是Ant或Maven。</target>
        </trans-unit>
        <trans-unit id="00e086822c4cc4c3d86e846ccfc2b1c6bbc7e5e5" translate="yes" xml:space="preserve">
          <source>If using Ant, Maven or Gradle, the setup process is straightforward. All that is needed is to define the Build Step. In our case, if using Gradle we'd simply define the required parameters such as the Step Name and Gradle tasks that need executing for the Runner Type.</source>
          <target state="translated">如果使用Ant、Maven或Gradle,设置过程很简单。需要做的就是定义Build Step。在我们的例子中,如果使用Gradle,我们只需定义所需的参数,如Step Name和Runner类型需要执行的Gradle任务。</target>
        </trans-unit>
        <trans-unit id="6d1aa0dbbc7faa5d8c75c6b538e6bd8ea6617548" translate="yes" xml:space="preserve">
          <source>If using IntelliJ IDEA build system with TeamCity, we need to make sure that the version of Kotlin being used by IntelliJ IDEA is the same as that that TeamCity runs. This would mean that we need to download the specific version of the Kotlin plugin and install it on TeamCity.</source>
          <target state="translated">如果使用IntelliJ IDEA与TeamCity构建系统,我们需要确保IntelliJ IDEA使用的Kotlin版本与TeamCity运行的版本相同。这意味着我们需要下载特定版本的Kotlin插件,并将其安装在TeamCity上。</target>
        </trans-unit>
        <trans-unit id="1ff8b36dc1a6a3cc57b717edeaeb3788168f606b" translate="yes" xml:space="preserve">
          <source>If using Maven or Gradle, we can also configure the module output format. For more information see &lt;a href=&quot;http://kotlinlang.org/docs/reference/js-modules.html&quot;&gt;JavaScript Modules&lt;/a&gt;.</source>
          <target state="translated">如果使用Maven或Gradle，我们还可以配置模块输出格式。有关更多信息，请参见&lt;a href=&quot;http://kotlinlang.org/docs/reference/js-modules.html&quot;&gt;JavaScript模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5a4dc0ed9963550c2c79f4e04423d9486f9f6cf" translate="yes" xml:space="preserve">
          <source>If using a Continuous Integration tool different to TeamCity, as long as it supports any of the build tools, or calling command line tools, compiling Kotlin and automating things as part of a CI process should be possible.</source>
          <target state="translated">如果使用不同于TeamCity的持续集成工具,只要它支持任何一个构建工具,或者调用命令行工具,编译Kotlin并将其作为CI过程的一部分进行自动化,应该是可以的。</target>
        </trans-unit>
        <trans-unit id="6bd5591695bc9bb315e16734b0ff743bacc22bbf" translate="yes" xml:space="preserve">
          <source>If using a previous version, refer to the &lt;a href=&quot;https://confluence.jetbrains.com/display/TCD9/Working+with+Meta-Runner&quot;&gt;documentation on how to add meta-runners&lt;/a&gt;.</source>
          <target state="translated">如果使用以前的版本，请参阅&lt;a href=&quot;https://confluence.jetbrains.com/display/TCD9/Working+with+Meta-Runner&quot;&gt;如何添加元亚军文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="449042335ccaad499545704799876f951b9d4d55" translate="yes" xml:space="preserve">
          <source>If values are equal, returns the first one.</source>
          <target state="translated">如果值相等,则返回第一个值。</target>
        </trans-unit>
        <trans-unit id="f746ae601b0ca7798611e8dc917365449e6e394e" translate="yes" xml:space="preserve">
          <source>If we are computing the numbers with some CPU-consuming blocking code (each computation taking 100ms), then we can represent the numbers using a &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/index&quot;&gt;Sequence&lt;/a&gt;:</source>
          <target state="translated">如果我们使用一些占用CPU的阻塞代码来计算数字（每次计算需要100毫秒），那么我们可以使用&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/index&quot;&gt;Sequence&lt;/a&gt;来表示数字：</target>
        </trans-unit>
        <trans-unit id="5b672336c863c791a792cf43720020da0742ad23" translate="yes" xml:space="preserve">
          <source>If we are using IntelliJ IDEA as our development environment, we can find the &lt;code&gt;run&lt;/code&gt; action in the Gradle tool window:</source>
          <target state="translated">如果我们将IntelliJ IDEA用作开发环境，则可以在Gradle工具窗口中找到 &lt;code&gt;run&lt;/code&gt; 操作：</target>
        </trans-unit>
        <trans-unit id="f5d0a72271531597b020177163056bb930e197fe" translate="yes" xml:space="preserve">
          <source>If we are using the set of example tests shown in the snippet above, one test passes, and one test breaks, which gives us the resulting total of 50% successful tests. To get more information about individual test cases, we can navigate via the provided hyperlinks:</source>
          <target state="translated">如果我们使用上面片段中显示的一组示例测试,一个测试通过,一个测试中断,这样我们就得到了50%的成功测试总数。要获得更多关于单个测试用例的信息,我们可以通过提供的超链接进行导航。</target>
        </trans-unit>
        <trans-unit id="6bba64879e65ddd90a5f852a3b397bb4e81ce686" translate="yes" xml:space="preserve">
          <source>If we are working from inside IntelliJ IDEA, we can pass the same flag via the &lt;em&gt;run configuration&lt;/em&gt;. After running the Gradle &lt;code&gt;run&lt;/code&gt; task for the first time from the IDE, IntelliJ IDEA automatically generates a run configuration for it, which we can edit:</source>
          <target state="translated">如果我们在IntelliJ IDEA内部进行工作，则可以通过&lt;em&gt;运行配置&lt;/em&gt;传递相同的标志。从IDE首次运行Gradle &lt;code&gt;run&lt;/code&gt; 任务之后，IntelliJ IDEA会自动为其生成运行配置，我们可以对其进行编辑：</target>
        </trans-unit>
        <trans-unit id="83ff93c719c3677a5febd54d97d72cdccbce6a99" translate="yes" xml:space="preserve">
          <source>If we call &lt;code&gt;c.foo()&lt;/code&gt; of any &lt;code&gt;c&lt;/code&gt; of type &lt;code&gt;C&lt;/code&gt;, it will print &quot;member&quot;, not &quot;extension&quot;.</source>
          <target state="translated">如果我们调用 &lt;code&gt;c.foo()&lt;/code&gt; 任何 &lt;code&gt;c&lt;/code&gt; 类型的 &lt;code&gt;C&lt;/code&gt; ，它会打印&amp;ldquo;成员&amp;rdquo;，而不是&amp;ldquo;延伸&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="379283767448c54e1e97c1028507253f860becb5" translate="yes" xml:space="preserve">
          <source>If we choose a non-null type, the compiler will emit an assertion upon assignment. This prevents Kotlin's non-null variables from holding nulls. Assertions are also emitted when we pass platform values to Kotlin functions expecting non-null values etc. Overall, the compiler does its best to prevent nulls from propagating far through the program (although sometimes this is impossible to eliminate entirely, because of generics).</source>
          <target state="translated">如果我们选择一个非空类型,编译器会在赋值时发出一个断言。这样可以防止Kotlin的非空变量持有空值。当我们将平台值传递给Kotlin函数期望非空值等时,也会发出断言。总的来说,编译器会尽最大努力防止空值在程序中传播得更远(尽管有时由于属相的原因,这是不可能完全消除的)。</target>
        </trans-unit>
        <trans-unit id="bdbae50858519197b3fe083596ba04b9db8edf5b" translate="yes" xml:space="preserve">
          <source>If we define a custom setter, it will be called every time we assign a value to the property. A custom setter looks like this:</source>
          <target state="translated">如果我们定义了一个自定义设置器,那么每次我们给属性赋值时都会调用它。自定义设置器看起来像这样。</target>
        </trans-unit>
        <trans-unit id="d5788a5cd4b3c40d8ba64eb6708ad2b0a9b603bc" translate="yes" xml:space="preserve">
          <source>If we didn't specify the &lt;code&gt;@JsName&lt;/code&gt; annotation, the name of the corresponding function would contain a suffix calculated from the function signature, for example &lt;code&gt;hello_61zpoe$&lt;/code&gt;.</source>
          <target state="translated">如果未指定 &lt;code&gt;@JsName&lt;/code&gt; 批注，则相应函数的名称将包含根据函数签名计算出的后缀，例如 &lt;code&gt;hello_61zpoe$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="966f788e727a4b595780377e8042611cc0480c54" translate="yes" xml:space="preserve">
          <source>If we had wanted to express the same thing in Python, it would have looked like this, and we would be hamstrung by the fact that lambda functions can only contain one expression, so we need explicit function definitions for everything but the oneliners:</source>
          <target state="translated">如果我们想用 Python 来表达同样的东西,它就会是这样的,而且我们会受制于 lambda 函数只能包含一个表达式的事实,所以除了 onliners 之外,我们需要为所有的东西提供显式函数定义。</target>
        </trans-unit>
        <trans-unit id="dc0fca0f296a8cb428a1796bfc197561c1551e47" translate="yes" xml:space="preserve">
          <source>If we leave all the optional annotations out, what's left looks like this:</source>
          <target state="translated">如果我们把所有的可选注释都去掉,剩下的就是这样了。</target>
        </trans-unit>
        <trans-unit id="7f0622f86bfe1754250cfd5960f42eb9787c1baa" translate="yes" xml:space="preserve">
          <source>If we need to use a member of a class, or an extension function, it needs to be qualified, e.g. &lt;code&gt;String::toCharArray&lt;/code&gt;.</source>
          <target state="translated">如果我们需要使用类的成员或扩展函数，则需要对其进行限定，例如 &lt;code&gt;String::toCharArray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06f2f1ba4877a89d728de7b4cb1810c2c9646349" translate="yes" xml:space="preserve">
          <source>If we need wildcards where they are not generated by default, we can use the &lt;code&gt;@JvmWildcard&lt;/code&gt; annotation:</source>
          <target state="translated">如果需要在默认情况下不生成通配符的通配符，则可以使用 &lt;code&gt;@JvmWildcard&lt;/code&gt; 批注：</target>
        </trans-unit>
        <trans-unit id="8622531a5c0429cfdda336ff31f83fe890fe02ca" translate="yes" xml:space="preserve">
          <source>If we try to use the same non-blocking &lt;code&gt;delay()&lt;/code&gt; function directly inside &lt;code&gt;main()&lt;/code&gt;, we'll get a compiler error:</source>
          <target state="translated">如果我们尝试直接在 &lt;code&gt;main()&lt;/code&gt; 内部使用相同的非阻塞 &lt;code&gt;delay()&lt;/code&gt; 函数，则会出现编译器错误：</target>
        </trans-unit>
        <trans-unit id="40479a99caad7c4a33dc795543afa14441ffca7a" translate="yes" xml:space="preserve">
          <source>If we use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; terminal operator after &lt;code&gt;onEach&lt;/code&gt;, then the code after it will wait until the flow is collected:</source>
          <target state="translated">如果我们在 &lt;code&gt;onEach&lt;/code&gt; 之后使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt;终端运算符，那么它之后的代码将等待直到流程被收集：</target>
        </trans-unit>
        <trans-unit id="eec42d7483409e40f6e340d8a3d88fe567b92801" translate="yes" xml:space="preserve">
          <source>If we want to call the synthetic properties on &lt;code&gt;View&lt;/code&gt;, we should also import &lt;code&gt;kotlinx.android.synthetic.main.activity_main.view.*&lt;/code&gt;.</source>
          <target state="translated">如果要在 &lt;code&gt;View&lt;/code&gt; 上调用综合属性，则还应导入 &lt;code&gt;kotlinx.android.synthetic.main.activity_main.view.*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b22d5f997bc9d10a51a59c8d992a6139a9878201" translate="yes" xml:space="preserve">
          <source>If we want, we can add tests to a specific platform, then it will be executed only as part of these platform tests.</source>
          <target state="translated">如果我们愿意,我们可以将测试添加到特定的平台上,那么它将只作为这些平台测试的一部分来执行。</target>
        </trans-unit>
        <trans-unit id="df31a64d374ba97c421367b3cdcce507cbe75299" translate="yes" xml:space="preserve">
          <source>If we want, we can add tests to a specific platform, then it will be executed only as part of these platform tests. For example, we can add UTF-16 tests on JVM. Just follow the same steps as before, but create file in &lt;code&gt;jvmTest/kotlin/jetbrains/base64&lt;/code&gt;:</source>
          <target state="translated">如果需要，可以将测试添加到特定平台，然后仅将其作为这些平台测试的一部分执行。例如，我们可以在JVM上添加UTF-16测试。只需执行与之前相同的步骤，但是在 &lt;code&gt;jvmTest/kotlin/jetbrains/base64&lt;/code&gt; 中创建文件：</target>
        </trans-unit>
        <trans-unit id="ba8fe72a36f3192d28c0b1bb2a6adebf2c73a672" translate="yes" xml:space="preserve">
          <source>If we were to introduce another class &lt;code&gt;Bicycle&lt;/code&gt;, which should be neither a subclass nor a superclass of &lt;code&gt;MotorVehicle&lt;/code&gt;, we could still make it implement &lt;code&gt;Driveable&lt;/code&gt;, as long as we declare &lt;code&gt;maxSpeed&lt;/code&gt; and &lt;code&gt;drive&lt;/code&gt; in &lt;code&gt;Bicycle&lt;/code&gt;.</source>
          <target state="translated">如果我们要引入另一类 &lt;code&gt;Bicycle&lt;/code&gt; ，它既不应是 &lt;code&gt;MotorVehicle&lt;/code&gt; 的子类，也不应该是MotorVehicle的超类，那么只要我们在 &lt;code&gt;Bicycle&lt;/code&gt; 中声明 &lt;code&gt;maxSpeed&lt;/code&gt; 和 &lt;code&gt;drive&lt;/code&gt; ，我们仍然可以使其实现 &lt;code&gt;Driveable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84ed0f9beb7f91564144926831adc67accd41344" translate="yes" xml:space="preserve">
          <source>If we're not using IntelliJ IDEA, we can configure the &lt;code&gt;pom.xml&lt;/code&gt; file manually to target JavaScript, by adding the following entries</source>
          <target state="translated">如果我们不使用IntelliJ IDEA，则可以通过添加以下条目来手动配置 &lt;code&gt;pom.xml&lt;/code&gt; 文件以定位JavaScript。</target>
        </trans-unit>
        <trans-unit id="f4acfe17479a9d138aec02a2b5400d83b9dbad62" translate="yes" xml:space="preserve">
          <source>If what the overriding function wants to do is an extension of what the overridden function did, you can call the overridden function via &lt;code&gt;super&lt;/code&gt; (either before, after, or between other code):</source>
          <target state="translated">如果重写函数想要做的是重写函数所做的扩展，则可以通过 &lt;code&gt;super&lt;/code&gt; （在其他代码之前，之后或之间）调用重写函数：</target>
        </trans-unit>
        <trans-unit id="4e616deeae977bea1b9ac2aaff006d6b429ca59f" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;https://developer.android.com/jetpack/compose/setup?hl=en&quot;&gt;enable Jetpack Compose&lt;/a&gt;, you will automatically be opted in to the new JVM backend without needing to specify the compiler option in &lt;code&gt;kotlinOptions&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;https://developer.android.com/jetpack/compose/setup?hl=en&quot;&gt;启用Jetpack Compose&lt;/a&gt;，您将自动选择加入新的JVM后端，而无需在 &lt;code&gt;kotlinOptions&lt;/code&gt; 中指定编译器选项。</target>
        </trans-unit>
        <trans-unit id="d45490f38e7e6ac42b22f89099d8ed55b7cb4a46" translate="yes" xml:space="preserve">
          <source>If you agree, it will run migration code inspections that will check your code and suggest corrections for anything that doesn't work or that is not recommended in 1.4.0.</source>
          <target state="translated">如果你同意,它将运行迁移代码检查,检查你的代码,并建议修正任何不能工作或在1.4.0中不推荐的代码。</target>
        </trans-unit>
        <trans-unit id="859a34cc0f1bc449ccdc83a5bb060605e6dcaa25" translate="yes" xml:space="preserve">
          <source>If you already &lt;strong&gt;have a Java project&lt;/strong&gt;, you can:</source>
          <target state="translated">如果您已经&lt;strong&gt;有一个Java项目&lt;/strong&gt;，则可以：</target>
        </trans-unit>
        <trans-unit id="c93cd73e42edadff5832f929c0b9aee1adf9c114" translate="yes" xml:space="preserve">
          <source>If you already have an &lt;code&gt;Iterable&lt;/code&gt; object (such as a &lt;code&gt;List&lt;/code&gt; or a &lt;code&gt;Set&lt;/code&gt;), you can create a sequence from it by calling &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/as-sequence&quot;&gt;&lt;code&gt;asSequence()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您已经有一个 &lt;code&gt;Iterable&lt;/code&gt; 对象（例如 &lt;code&gt;List&lt;/code&gt; 或 &lt;code&gt;Set&lt;/code&gt; ），则可以通过调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/as-sequence&quot;&gt; &lt;code&gt;asSequence()&lt;/code&gt; &lt;/a&gt;从中创建一个序列。</target>
        </trans-unit>
        <trans-unit id="fc29b28eefcc5ecff8f112f0914c7751c0121584" translate="yes" xml:space="preserve">
          <source>If you already have the Java classes, you can just copy them to the project directories.</source>
          <target state="translated">如果你已经有了Java类,你可以把它们复制到项目目录中。</target>
        </trans-unit>
        <trans-unit id="6b839b9469fa700514c4a020dc91dfcc6a1e8d21" translate="yes" xml:space="preserve">
          <source>If you are creating a library that will be consumed from JavaScript or a Node.js file, and want to use a different module system, the instructions are slightly different.</source>
          <target state="translated">如果你正在创建一个将从JavaScript或Node.js文件中消耗的库,并希望使用不同的模块系统,说明略有不同。</target>
        </trans-unit>
        <trans-unit id="4e80a816776f6d15384568dae346e099a9c4bc29" translate="yes" xml:space="preserve">
          <source>If you are new to the JVM and Java, check out the &lt;a href=&quot;http://hadihariri.com/2013/12/29/jvm-minimal-survival-guide-for-the-dotnet-developer/&quot;&gt;JVM Minimal Survival Guide&lt;/a&gt;. If you are new to IntelliJ IDEA, check out the &lt;a href=&quot;http://hadihariri.com/2014/01/06/intellij-idea-minimal-survival-guide/&quot;&gt;The IntelliJ IDEA Minimal Survival Guide&lt;/a&gt;.</source>
          <target state="translated">如果您不熟悉JVM和Java，请查阅《&lt;a href=&quot;http://hadihariri.com/2013/12/29/jvm-minimal-survival-guide-for-the-dotnet-developer/&quot;&gt;JVM最小生存指南》&lt;/a&gt;。如果您不熟悉IntelliJ IDEA，请查阅&lt;a href=&quot;http://hadihariri.com/2014/01/06/intellij-idea-minimal-survival-guide/&quot;&gt;《 IntelliJ IDEA最低生存指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a098b59cc7c828b6cf7a7a722a6433f92888a1c" translate="yes" xml:space="preserve">
          <source>If you are using IntelliJ IDEA, start with &lt;a href=&quot;getting-started&quot;&gt;Getting Started&lt;/a&gt; and then work your way through the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是IntelliJ IDEA，请从&amp;ldquo; &lt;a href=&quot;getting-started&quot;&gt;入门&amp;rdquo;开始&lt;/a&gt;，然后&lt;a href=&quot;koans&quot;&gt;逐步&lt;/a&gt;完成Kotlin Koans。</target>
        </trans-unit>
        <trans-unit id="92c9f5001a0b1041d30c375e3f64079f5f4024cf" translate="yes" xml:space="preserve">
          <source>If you are using IntelliJ IDEA, start with &lt;a href=&quot;getting-started&quot;&gt;Getting Started&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是IntelliJ IDEA，请从&amp;ldquo;&lt;a href=&quot;getting-started&quot;&gt;入门&amp;rdquo;开始&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="288920b3c9422f077df54c1f4e25ceb3fa6051e0" translate="yes" xml:space="preserve">
          <source>If you are using the command line compiler, start with &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt; and then work your way through the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;;</source>
          <target state="translated">如果您使用的是命令行编译器，请先使用命令行编译&lt;a href=&quot;command-line&quot;&gt;器&lt;/a&gt;，然后&lt;a href=&quot;koans&quot;&gt;逐步&lt;/a&gt;完成Kotlin Koans的工作；</target>
        </trans-unit>
        <trans-unit id="30938b7e8379a33204d1fef78a0ab9d4d4d9e21f" translate="yes" xml:space="preserve">
          <source>If you are writing an external declaration for a JavaScript function which has an optional parameter, use &lt;code&gt;definedExternally&lt;/code&gt;. This delegates the generation of the default values to the JavaScript function itself:</source>
          <target state="translated">如果要为具有可选参数的JavaScript函数编写外部声明，请使用 &lt;code&gt;definedExternally&lt;/code&gt; 。这将默认值的生成委托给JavaScript函数本身：</target>
        </trans-unit>
        <trans-unit id="f2a50c48e84ca80688cd2b0e1b9297326e7b2f1d" translate="yes" xml:space="preserve">
          <source>If you build your module with Gradle, you can add arguments like this:</source>
          <target state="translated">如果你用Gradle构建模块,你可以添加这样的参数。</target>
        </trans-unit>
        <trans-unit id="cd3aa7d69244f58e95e8689b9c6402ed443bb559" translate="yes" xml:space="preserve">
          <source>If you consider all the APIs of your module experimental, you can mark the entire module as such with the compiler argument &lt;code&gt;-Xexperimental&lt;/code&gt; as described in &lt;a href=&quot;#module-wide-use&quot;&gt;Module-wide use&lt;/a&gt;.</source>
          <target state="translated">如果您认为模块的所有API都是实验性的，则可以&lt;a href=&quot;#module-wide-use&quot;&gt;使用&amp;ldquo;模块范围使用&amp;rdquo;中&lt;/a&gt;所述的编译器参数 &lt;code&gt;-Xexperimental&lt;/code&gt; 标记整个模块。</target>
        </trans-unit>
        <trans-unit id="e700eece24a382c6a466861314d880f1c63adba4" translate="yes" xml:space="preserve">
          <source>If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class.</source>
          <target state="translated">如果你为一个类声明了一个工厂函数,避免给它一个和类本身相同的名字。最好使用一个独特的名字,使其明确为什么工厂函数的行为是特殊的。只有在真的没有特殊语义的情况下,才可以使用与类相同的名称。</target>
        </trans-unit>
        <trans-unit id="e1ed8ae699e2f0e0c43725a76e755048bb606787" translate="yes" xml:space="preserve">
          <source>If you declare a standard library dependency explicitly (for example, if you need a different version), the Kotlin Gradle plugin won&amp;rsquo;t override it or add a second standard library.</source>
          <target state="translated">如果您明确声明标准库依赖项（例如，如果需要其他版本），则Kotlin Gradle插件不会覆盖它或添加第二个标准库。</target>
        </trans-unit>
        <trans-unit id="a09dc2e7a857fda68536a28e258f8622ea168f72" translate="yes" xml:space="preserve">
          <source>If you declare your Kotlin code in a package, &lt;code&gt;main&lt;/code&gt; would be followed by a package definition part. For example, this goes after the &lt;code&gt;main&lt;/code&gt; declaration if you put your &lt;code&gt;main&lt;/code&gt; function in the &lt;code&gt;org.example.hellojs&lt;/code&gt; package:</source>
          <target state="translated">如果在包中声明Kotlin代码，则 &lt;code&gt;main&lt;/code&gt; 后面将是包定义部分。例如，如果将 &lt;code&gt;main&lt;/code&gt; 函数放在 &lt;code&gt;org.example.hellojs&lt;/code&gt; 包中，则该声明位于 &lt;code&gt;main&lt;/code&gt; 声明之后：</target>
        </trans-unit>
        <trans-unit id="9bc82014d1e005bd252c8fd44c4f86ea4b0260b5" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t use the Project Wizard to create your project, you can &lt;a href=&quot;using-gradle#set-dependencies-on-test-libraries&quot;&gt;add the dependencies manually&lt;/a&gt;.</source>
          <target state="translated">如果您没有使用项目向导来创建项目，则可以&lt;a href=&quot;using-gradle#set-dependencies-on-test-libraries&quot;&gt;手动添加依赖项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9f4c0d0e98edca70ce37e016401b88c44c12e52" translate="yes" xml:space="preserve">
          <source>If you do not need a standard library at all, you can add the opt-out flag to the &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="translated">如果您根本不需要标准库，则可以在 &lt;code&gt;gradle.properties&lt;/code&gt; 中添加opt-out标志：</target>
        </trans-unit>
        <trans-unit id="2d0c772b88930f846f25631788c26caf89a248c8" translate="yes" xml:space="preserve">
          <source>If you do not specify any visibility modifier, &lt;code&gt;public&lt;/code&gt; is used by default, which means that your declarations will be visible everywhere;</source>
          <target state="translated">如果您未指定任何可见性修饰符，则默认情况下使用 &lt;code&gt;public&lt;/code&gt; ，这意味着您的声明将在所有位置可见。</target>
        </trans-unit>
        <trans-unit id="cadfb46ca63577b7ac5a59ea3e20f042f8a1e23b" translate="yes" xml:space="preserve">
          <source>If you don't care about the return value from the function, but you want to make one or more calls involving something that might be null and then keep on using that value, try &lt;code&gt;apply()&lt;/code&gt;, which returns the value it's called on. This is particularly useful if you want to work with many members of the object in question:</source>
          <target state="translated">如果您不关心该函数的返回值，但是想要进行一个或多个涉及可能为空的东西的调用，然后继续使用该值，请尝试 &lt;code&gt;apply()&lt;/code&gt; ，它返回被调用的值。如果您要使用所讨论对象的许多成员，这特别有用：</target>
        </trans-unit>
        <trans-unit id="25be6af74cab7ee5d3f6a46048e18b2c9c41852a" translate="yes" xml:space="preserve">
          <source>If you don't care about the return value, you don't need to assign it to anything.</source>
          <target state="translated">如果你不关心返回值,你不需要把它分配给任何东西。</target>
        </trans-unit>
        <trans-unit id="b5e43077cfafc57268582f5f13c46e3f8aaffa0e" translate="yes" xml:space="preserve">
          <source>If you don't have an instance of the class, you can get the class metadata with &lt;code&gt;String::class.java&lt;/code&gt; (but you can't invoke any of its members until you have an instance).</source>
          <target state="translated">如果没有该类的实例，则可以使用 &lt;code&gt;String::class.java&lt;/code&gt; 获取该类的元数据（但只有拥有一个实例，才能调用其任何成员）。</target>
        </trans-unit>
        <trans-unit id="ef8266bd47e097890ef64d7166bd8dd100eb20ff" translate="yes" xml:space="preserve">
          <source>If you don't have any idea (or don't care) what the generic type might be, you can use a &lt;em&gt;star-projection&lt;/em&gt;:</source>
          <target state="translated">如果您不知道（或不在乎）泛型可能是什么，可以使用&lt;em&gt;star-projection&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="3e3d1700eb36e84d61d0cc0f83792e108ac15508" translate="yes" xml:space="preserve">
          <source>If you don't need a variable in the destructuring declaration, you can place an underscore instead of its name:</source>
          <target state="translated">如果你在解构声明中不需要变量,你可以用下划线代替它的名字。</target>
        </trans-unit>
        <trans-unit id="22b00c7537a626ef39f32b96fa84adefd77db83f" translate="yes" xml:space="preserve">
          <source>If you don't specify a use-site target, the target is chosen according to the &lt;code&gt;@Target&lt;/code&gt; annotation of the annotation being used. If there are multiple applicable targets, the first applicable target from the following list is used:</source>
          <target state="translated">如果未指定使用场所目标，则根据所使用注释的 &lt;code&gt;@Target&lt;/code&gt; 注释选择目标。如果有多个适用目标，则使用以下列表中的第一个适用目标：</target>
        </trans-unit>
        <trans-unit id="311d02e910900437e250a96c50bd0e61d68e28d2" translate="yes" xml:space="preserve">
          <source>If you don't specify the minimum target version and a dependency Pod requires a higher deployment target, you may get an error.</source>
          <target state="translated">如果你没有指定最小目标版本,而依赖的Pod需要更高的部署目标,你可能会得到一个错误。</target>
        </trans-unit>
        <trans-unit id="91ea08ad1a525edd6dec0bb4e202636f7932a646" translate="yes" xml:space="preserve">
          <source>If you don't use Gradle or Maven, make sure you have &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; in the classpath of your project. In other supported cases (IntelliJ IDEA projects, using command-line compiler or Ant), it is added by default. In command-line compiler and Ant, you can use &lt;code&gt;-no-reflect&lt;/code&gt; compiler option to exclude &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; from the classpath.</source>
          <target state="translated">如果您不使用Gradle或Maven，请确保在项目的类路径中有 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 。在其他受支持的情况下（IntelliJ IDEA项目，使用命令行编译器或Ant），默认情况下将其添加。在命令行编译器和Ant中，可以使用 &lt;code&gt;-no-reflect&lt;/code&gt; 编译器选项从类路径中排除 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="508516363f92e5f2f533651260b76217ec5964d8" translate="yes" xml:space="preserve">
          <source>If you don't use a SAM conversion, you will need to write code like this:</source>
          <target state="translated">如果你不使用SAM转换,你将需要写这样的代码。</target>
        </trans-unit>
        <trans-unit id="3774ed57fc20d87b5d40f08286d6544810927195" translate="yes" xml:space="preserve">
          <source>If you don't want to annotate every usage of APIs that require opt-in, you can opt in to them for your whole module. To opt in to using an API in a module, compile it with the argument &lt;code&gt;-Xopt-in&lt;/code&gt;, specifying the fully qualified name of the opt-in requirement annotation of the API you use: &lt;code&gt;-Xopt-in=org.mylibrary.OptInAnnotation&lt;/code&gt;. Compiling with this argument has the same effect as if every declaration in the module had the annotation&lt;code&gt;@OptIn(OptInAnnotation::class)&lt;/code&gt;.</source>
          <target state="translated">如果您不想注释需要选择加入的API的每种用法，则可以为整个模块选择加入它们。要选择在模块中使用API​​，请使用参数 &lt;code&gt;-Xopt-in&lt;/code&gt; 对其进行编译，并指定您使用的API的选择加入要求注释的全限定名称： &lt;code&gt;-Xopt-in=org.mylibrary.OptInAnnotation&lt;/code&gt; 。使用此参数进行编译的效果与模块中的每个声明都具有注释 &lt;code&gt;@OptIn(OptInAnnotation::class)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fedc784120817cc87cdecd3df22bdeb6a5e4e0c" translate="yes" xml:space="preserve">
          <source>If you don't want to annotate every usage of experimental APIs in your code, you can accept the experimental status for your whole module. Module-wide use of experimental APIs can be propagating and non-propagating as well:</source>
          <target state="translated">如果你不想在代码中注释实验性API的每一次使用,你可以接受整个模块的实验性状态。整个模块对实验性API的使用也可以是传播性的,也可以是非传播性的。</target>
        </trans-unit>
        <trans-unit id="43a0c51574e240459eda5d6b9335be253ee68042" translate="yes" xml:space="preserve">
          <source>If you find that an interface that you want a class to implement is already implemented by one of the properties of the class, you can &lt;em&gt;delegate&lt;/em&gt; the implementation of that interface to that property with &lt;code&gt;by&lt;/code&gt;:</source>
          <target state="translated">如果发现要实现一类是已经由类的属性之一实现的接口，可以&lt;em&gt;委托&lt;/em&gt;该接口的实施，该属性与 &lt;code&gt;by&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8261f1da9a2137ff384a6fcdb0fdc9e9eb256bac" translate="yes" xml:space="preserve">
          <source>If you find the &lt;code&gt;this&lt;/code&gt; syntax to be confusing, you can use &lt;code&gt;also&lt;/code&gt; instead, which takes ordinary lambdas:</source>
          <target state="translated">如果你发现 &lt;code&gt;this&lt;/code&gt; 语法是混乱，你可以使用 &lt;code&gt;also&lt;/code&gt; 替代，这需要普通lambda表达式：</target>
        </trans-unit>
        <trans-unit id="6fec69f93ca0bc139456ed1755b8b6f4c32f1863" translate="yes" xml:space="preserve">
          <source>If you have a backend written in Kotlin, you can &lt;strong&gt;share common code&lt;/strong&gt; such as data models or validation logic with a frontend written in Kotlin/JS, allowing you to &lt;strong&gt;write and maintain full-stack web applications&lt;/strong&gt;.</source>
          <target state="translated">如果您有用Kotlin编写的后端，则可以与用Kotlin / JS编写的前端&lt;strong&gt;共享通用代码，&lt;/strong&gt;例如数据模型或验证逻辑，从而允许您&lt;strong&gt;编写和维护全栈Web应用程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b72e9d9abf32110dc1b1cda54fc1754195041c56" translate="yes" xml:space="preserve">
          <source>If you have a collection of elements of a nullable type and want to filter non-null elements, you can do so by using &lt;code&gt;filterNotNull&lt;/code&gt;:</source>
          <target state="translated">如果您具有可为null的类型的元素的集合，并且想要过滤非null的元素，则可以使用 &lt;code&gt;filterNotNull&lt;/code&gt; 进行过滤：</target>
        </trans-unit>
        <trans-unit id="3854a89fb1eb0d55d0045c79155df3bda3823777" translate="yes" xml:space="preserve">
          <source>If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it:</source>
          <target state="translated">如果你有一个功能类型或带有类型参数的类型,在一个代码库中多次使用,最好为它定义一个类型别名。</target>
        </trans-unit>
        <trans-unit id="160be5812cd4b3879f4656323f6abb0ca91c7f96" translate="yes" xml:space="preserve">
          <source>If you have a platform-specific library that you want to use in common code while providing your own implementation for another platform, you can provide a typealias to an existing class as the actual declaration:</source>
          <target state="translated">如果你有一个特定平台的库,你想在通用代码中使用,同时为另一个平台提供自己的实现,你可以向一个现有的类提供一个typealias作为实际的声明。</target>
        </trans-unit>
        <trans-unit id="322a5539762befa5e3e19013d91d7e3d04d9849f" translate="yes" xml:space="preserve">
          <source>If you have a platform-specific library that you want to use in shared code while providing your own implementation for another platform, you can provide a &lt;code&gt;typealias&lt;/code&gt; to an existing class as the actual declaration:</source>
          <target state="translated">如果您要在共享代码中使用特定于平台的库，同时为另一个平台提供自己的实现，则可 &lt;code&gt;typealias&lt;/code&gt; 现有类提供类型别名作为实际的声明：</target>
        </trans-unit>
        <trans-unit id="c6e93137d89d2551a056f737e4db196d1978cfc3" translate="yes" xml:space="preserve">
          <source>If you have a value that is truly constant, and the value is a string or a primitive type (see below) that is known at compile-time, you can declare an actual constant instead. You can only do this at the top level of a file or inside an &lt;a href=&quot;objects-and-companion-objects#object-declarations&quot;&gt;object declaration&lt;/a&gt; (but not inside a class declaration):</source>
          <target state="translated">如果您有一个真正常量的值，并且该值是在编译时已知的字符串或原始类型（请参见下文），则可以声明一个实际常量。您只能在文件的顶层或&lt;a href=&quot;objects-and-companion-objects#object-declarations&quot;&gt;对象声明内&lt;/a&gt;（但不能在类声明内）执行此操作：</target>
        </trans-unit>
        <trans-unit id="b3734595028b6b703699f95d53623d869e9b5b43" translate="yes" xml:space="preserve">
          <source>If you have an account on &lt;a href=&quot;https://stepik.org/&quot;&gt;Stepik&lt;/a&gt;, you can easily upload your course there, update it anytime you need, and &lt;a href=&quot;https://blog.jetbrains.com/pycharm/2017/06/integration-with-stepik-for-educators/&quot;&gt;share publicly or privately&lt;/a&gt;.</source>
          <target state="translated">如果您在&lt;a href=&quot;https://stepik.org/&quot;&gt;Stepik&lt;/a&gt;上拥有帐户，则可以轻松地在此处上传您的课程，随时进行更新，以及&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2017/06/integration-with-stepik-for-educators/&quot;&gt;公开或私下共享&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07988c0863287cce070542583bc572c93b997f2d" translate="yes" xml:space="preserve">
          <source>If you have an archive &lt;code&gt;sample-library.jar&lt;/code&gt;, which contains &lt;code&gt;sample-library.js&lt;/code&gt; and &lt;code&gt;sample-library.meta.js&lt;/code&gt;, you can use the following command</source>
          <target state="translated">如果您有一个存档 &lt;code&gt;sample-library.jar&lt;/code&gt; ，其中包含 &lt;code&gt;sample-library.js&lt;/code&gt; 和 &lt;code&gt;sample-library.meta.js&lt;/code&gt; ，则可以使用以下命令</target>
        </trans-unit>
        <trans-unit id="8ca8fa744fdcf13cab8a2d83ad8ba290dd0853cd" translate="yes" xml:space="preserve">
          <source>If you have an instance of &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt;, and you want to refer to it as a &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt;, you can safely &lt;em&gt;get&lt;/em&gt; instances of the generic type parameter from it - these will truly be instances of &lt;code&gt;Subtype&lt;/code&gt; (because they come from an instance of &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt;), but they will appear to you as instances of &lt;code&gt;Supertype&lt;/code&gt; (because you've told the compiler that you have a &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt;). This is safe; it is called &lt;em&gt;covariance&lt;/em&gt;, and Kotlin lets you do &lt;em&gt;declaration-site covariance&lt;/em&gt; by putting &lt;code&gt;out&lt;/code&gt; in front of the generic type parameter. If you do, you may only use that type parameter as a return type, not as a parameter type. Here is the simplest useful covariant interface:</source>
          <target state="translated">如果您有 &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt; 的实例，并且想将其称为 &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt; ，则可以从中安全地&lt;em&gt;获取&lt;/em&gt;泛型类型参数的实例-这些将真正是 &lt;code&gt;Subtype&lt;/code&gt; 的实例（因为它们来自 &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt; 的实例），但它们在您看来将是 &lt;code&gt;Supertype&lt;/code&gt; 的实例（因为您已经告诉编译器您具有 &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt; ）。这很安全；它被称为&lt;em&gt;协方差&lt;/em&gt;，以及科特林让你做&lt;em&gt;报关现场协&lt;/em&gt;通过将 &lt;code&gt;out&lt;/code&gt; 在泛型类型参数前面。如果这样做，则只能将该类型参数用作返回类型，而不能用作参数类型。这是最简单的有用的协变接口：</target>
        </trans-unit>
        <trans-unit id="76b81d78f8b362115f861d43270c94c40851a654" translate="yes" xml:space="preserve">
          <source>If you have an object with multiple overloaded constructors that don't call different superclass constructors and can't be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with factory functions.</source>
          <target state="translated">如果你的对象有多个重载构造函数,而这些重载构造函数并没有调用不同的超类构造函数,也不能简化为一个带有默认参数值的构造函数,最好用工厂函数替换重载构造函数。</target>
        </trans-unit>
        <trans-unit id="70df85ffca23dcd7199954503a1af44f76e8932e" translate="yes" xml:space="preserve">
          <source>If you have business logic that is common for all platforms, you don&amp;rsquo;t need to write the same code for each platform &amp;ndash; just share it in the common source set.</source>
          <target state="translated">如果您具有所有平台都通用的业务逻辑，则无需为每个平台编写相同的代码&amp;ndash;只需在通用源集中共享即可。</target>
        </trans-unit>
        <trans-unit id="639c565d65e0763691e2c7a9e8d90030330f0cc8" translate="yes" xml:space="preserve">
          <source>If you have explicitly set your module kind to be &lt;code&gt;plain&lt;/code&gt;, Kotlin creates an object that contains all Kotlin declarations from the current module. This is done to prevent spoiling the global object. This means that for a module &lt;code&gt;myModule&lt;/code&gt;, all declarations are available to JavaScript via the &lt;code&gt;myModule&lt;/code&gt; object. For example:</source>
          <target state="translated">如果您已将模块种类明确设置为 &lt;code&gt;plain&lt;/code&gt; ，则Kotlin将创建一个对象，其中包含当前模块中的所有Kotlin声明。这样做是为了防止破坏全局对象。这意味着对于模块 &lt;code&gt;myModule&lt;/code&gt; ，所有声明均可通过 &lt;code&gt;myModule&lt;/code&gt; 对象提供给JavaScript 。例如：</target>
        </trans-unit>
        <trans-unit id="c8853dee9818f39e3759ffe7b639b9f7bc068972" translate="yes" xml:space="preserve">
          <source>If you have multiple annotations with the same target, you can avoid repeating the target by adding brackets after the target and putting all the annotations inside the brackets:</source>
          <target state="translated">如果你有多个注释有相同的目标,你可以通过在目标后面添加括号,并将所有注释放在括号内,避免重复目标。</target>
        </trans-unit>
        <trans-unit id="f4458460acc96ecaa2c9621b4261e57a18ecc54c" translate="yes" xml:space="preserve">
          <source>If you insist on using a plain editor and the command line, see &lt;a href=&quot;../command-line&quot;&gt;these instructions instead&lt;/a&gt;. In short, you need to &lt;em&gt;compile&lt;/em&gt; your Kotlin code before running it. Assuming that your Kotlin file is called &lt;code&gt;program.kt&lt;/code&gt;:</source>
          <target state="translated">如果您坚持使用普通编辑器和命令行，请&lt;a href=&quot;../command-line&quot;&gt;改为&lt;/a&gt;参阅这些说明。总之，你需要&lt;em&gt;编译&lt;/em&gt;运行它之前，你的科特林代码。假设您的Kotlin文件名为 &lt;code&gt;program.kt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ef2b7c0495898685e9252662cc7dfb4430876f43" translate="yes" xml:space="preserve">
          <source>If you intend to use the APIs from the 1.1 Standard Library, or language features that depend on those APIs, you should upgrade the dependency to the version 1.1.</source>
          <target state="translated">如果你打算使用1.1标准库中的API,或者依赖这些API的语言功能,你应该将依赖关系升级到1.1版本。</target>
        </trans-unit>
        <trans-unit id="9dac576da363f8811fb3df384398b7619989e0f8" translate="yes" xml:space="preserve">
          <source>If you like a &amp;ldquo;hands-on&amp;rdquo; learning, try &lt;a href=&quot;https://play.kotlinlang.org/koans&quot;&gt;Kotlin Koans online&lt;/a&gt; to get familiar with Kotlin;</source>
          <target state="translated">如果您喜欢&amp;ldquo;动手学习&amp;rdquo;，&lt;a href=&quot;https://play.kotlinlang.org/koans&quot;&gt;请在线&lt;/a&gt;尝试Kotlin Koans来熟悉Kotlin。</target>
        </trans-unit>
        <trans-unit id="d82ca3a290ad528cc2bae1e2cb08d2ecdafea630" translate="yes" xml:space="preserve">
          <source>If you mark a declaration &lt;code&gt;private&lt;/code&gt;, it will only be visible inside the file containing the declaration;</source>
          <target state="translated">如果将声明标记为 &lt;code&gt;private&lt;/code&gt; ，则仅在包含该声明的文件内部可见；</target>
        </trans-unit>
        <trans-unit id="1b38ef20d54a5b26492d65004e55d4d4d8807d1f" translate="yes" xml:space="preserve">
          <source>If you mark it &lt;code&gt;internal&lt;/code&gt;, it is visible everywhere in the same &lt;a href=&quot;#modules&quot;&gt;module&lt;/a&gt;;</source>
          <target state="translated">如果将其标记为 &lt;code&gt;internal&lt;/code&gt; ，则在同一&lt;a href=&quot;#modules&quot;&gt;模块的&lt;/a&gt;任何位置都可以看到它；</target>
        </trans-unit>
        <trans-unit id="23d6510bb7782c43d563dd375dee713e5d305e0b" translate="yes" xml:space="preserve">
          <source>If you need a &lt;em&gt;singleton&lt;/em&gt; - a class that only has got one instance - you can declare the class in the usual way, but use the &lt;code&gt;object&lt;/code&gt; keyword instead of &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">如果您需要一个&lt;em&gt;单例&lt;/em&gt;（一个只有一个实例的类），则可以按照通常的方式声明该类，但可以使用 &lt;code&gt;object&lt;/code&gt; 关键字而不是 &lt;code&gt;class&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a043b2872924b750f016ebe9ba4d0f3aca66ca85" translate="yes" xml:space="preserve">
          <source>If you need a dependency only for a specific platform, you can still use platform-specific variants of standard and kotlinx libraries with such suffixes as &lt;code&gt;-jvm&lt;/code&gt; or&lt;code&gt; -js&lt;/code&gt;, for example &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;.</source>
          <target state="translated">如果只需要特定平台的依赖项，则仍可以使用平台后缀的标准库和kotlinx库，这些库的后缀为 &lt;code&gt;-jvm&lt;/code&gt; 或 &lt;code&gt; -js&lt;/code&gt; ，例如 &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc8467398b87bfa40771e50f53a8a177a25657b1" translate="yes" xml:space="preserve">
          <source>If you need a fancier way of reading or writing file data, you have access to the full Java suite of I/O classes - in particular, &lt;code&gt;Scanner&lt;/code&gt;, which can parse numbers and other data types from files or other streams, and &lt;code&gt;BufferedReader&lt;/code&gt; (which is good for efficient reading of large amounts of data), which you can obtain by calling &lt;code&gt;bufferedReader()&lt;/code&gt; on a file or stream. See any Java tutorial for how to use these.</source>
          <target state="translated">如果您需要一种更简单的读取或写入文件数据的方式，则可以访问完整的Java I / O类套件-特别是 &lt;code&gt;Scanner&lt;/code&gt; ，它可以解析文件或其他流中的数字和其他数据类型，以及 &lt;code&gt;BufferedReader&lt;/code&gt; （可以有效地读取大量数据），您可以通过在文件或流上调用 &lt;code&gt;bufferedReader()&lt;/code&gt; 获得该数据。请参阅任何Java教程以了解如何使用它们。</target>
        </trans-unit>
        <trans-unit id="6f682f64379a16ca3dc7552b97dee19da35ecf1f" translate="yes" xml:space="preserve">
          <source>If you need a full report containing the state of each coroutine and its stack, right-click inside the &lt;strong&gt;Coroutines&lt;/strong&gt; tab, and then click &lt;strong&gt;Get Coroutines Dump&lt;/strong&gt;. Currently, the coroutines dump is rather simple, but we&amp;rsquo;re going to make it more readable and helpful in future versions of Kotlin.</source>
          <target state="translated">如果你需要一个包含每个协程和它的堆栈的状态的完整报告，里面右键单击&lt;strong&gt;协同程序&lt;/strong&gt;选项卡，然后单击&lt;strong&gt;获取协同程序转储&lt;/strong&gt;。目前，协程转储非常简单，但是我们将使其在以后的Kotlin版本中更具可读性和帮助。</target>
        </trans-unit>
        <trans-unit id="54e87845252769ababaaab1c06f5bd872659abd6" translate="yes" xml:space="preserve">
          <source>If you need a function or a property to be tied to a class rather than to instances of it (similar to &lt;code&gt;@staticmethod&lt;/code&gt; in Python), you can declare it inside a &lt;em&gt;companion object&lt;/em&gt;:</source>
          <target state="translated">如果需要将函数或属性绑定到类而不是实例（类似于Python中的 &lt;code&gt;@staticmethod&lt;/code&gt; ），则可以在&lt;em&gt;同伴对象中&lt;/em&gt;声明它：</target>
        </trans-unit>
        <trans-unit id="8de1431e2a233483ba705c03102c9221f4f2f632" translate="yes" xml:space="preserve">
          <source>If you need multiple ways to initialize a class, you can create &lt;em&gt;secondary constructors&lt;/em&gt;, each of which looks like a function whose name is &lt;code&gt;constructor&lt;/code&gt;. Every secondary constructor must invoke another (primary or secondary) constructor by using the &lt;code&gt;this&lt;/code&gt; keyword as if it were a function (so that every instance construction eventually calls the primary constructor).</source>
          <target state="translated">如果您需要多种方法来初始化类，则可以创建&lt;em&gt;辅助构造函数&lt;/em&gt;，每个&lt;em&gt;构造&lt;/em&gt;函数看起来都像一个函数，名称为 &lt;code&gt;constructor&lt;/code&gt; 。每个辅助构造函数都必须使用 &lt;code&gt;this&lt;/code&gt; 关键字调用另一个（主要或辅助）构造函数，就好像它是一个函数一样（这样，每个实例构造最终都会调用该主要构造函数）。</target>
        </trans-unit>
        <trans-unit id="e23221640befe2f0b60d6c58ea9b02d7e3a97b07" translate="yes" xml:space="preserve">
          <source>If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin declaration using the &lt;code&gt;external&lt;/code&gt; modifier. (In Kotlin 1.0, the &lt;code&gt;@native&lt;/code&gt; annotation was used instead.) Unlike the JVM target, the JS one permits to use external modifier with classes and properties. For example, here's how you can declare the DOM &lt;code&gt;Node&lt;/code&gt; class:</source>
          <target state="translated">如果您需要以类型安全的方式从Kotlin访问用JavaScript实现的类，则可以使用 &lt;code&gt;external&lt;/code&gt; 修饰符编写Kotlin声明。（在Kotlin 1.0中，使用 &lt;code&gt;@native&lt;/code&gt; 注释代替。）与JVM目标不同，JS允许使用带有类和属性的外部修饰符。例如，下面是如何声明DOM &lt;code&gt;Node&lt;/code&gt; 类的方法：</target>
        </trans-unit>
        <trans-unit id="88668422727a4a9adc62e3d3eeac4b8edf7e7d30" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from a shared native source set, IntelliJ IDEA will help you detect common declarations that you can use in the shared native code. For other cases, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="translated">如果您需要从共享的本机源集中访问特定于平台的API，则IntelliJ IDEA将帮助您检测可在共享的本机代码中使用的通用声明。对于其他情况，请使用Kotlin机制的&lt;a href=&quot;mpp-connect-to-apis&quot;&gt;预期和实际声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f99443af480d55217c4ce0d28159d54e4f7cf72b" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from the shared code, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="translated">如果您需要从共享代码访问特定于平台的API，请使用Kotlin机制的&lt;a href=&quot;mpp-connect-to-apis&quot;&gt;预期和实际声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4e8082dbfdacd1170b034e190a7f81841b9039b" translate="yes" xml:space="preserve">
          <source>If you need to annotate the primary constructor of a class, you need to add the &lt;em&gt;constructor&lt;/em&gt; keyword to the constructor declaration, and add the annotations before it:</source>
          <target state="translated">如果需要对类的主要构造函数进行注释，则需要将&lt;em&gt;Constructor&lt;/em&gt;关键字添加到&lt;em&gt;构造&lt;/em&gt;函数声明中，并在其之前添加注释：</target>
        </trans-unit>
        <trans-unit id="e462275c07255513e75672de08e598bdce5e271f" translate="yes" xml:space="preserve">
          <source>If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:</source>
          <target state="translated">如果你需要改变一个访问器的可见性或注释它,但不需要改变默认的实现,你可以定义访问器而不定义它的主体。</target>
        </trans-unit>
        <trans-unit id="3059f730cef9912ce6c198f14d3446e4eb2b9509" translate="yes" xml:space="preserve">
          <source>If you need to compile something other than production code and unit tests, for example, integration or performance tests, create a custom compilation.</source>
          <target state="translated">如果你需要编译除生产代码和单元测试以外的东西,例如,集成或性能测试,创建一个自定义编译。</target>
        </trans-unit>
        <trans-unit id="a9bce9b39aad7abcf18408f893ff0de2f69a4bc8" translate="yes" xml:space="preserve">
          <source>If you need to compile something other than production code and unit tests, for example, integration or performance tests, you can &lt;a href=&quot;#create-a-custom-compilation&quot;&gt;create a custom compilation&lt;/a&gt;.</source>
          <target state="translated">如果您需要编译生产代码和单元测试以外的其他东西（例如，集成测试或性能测试），则可以&lt;a href=&quot;#create-a-custom-compilation&quot;&gt;创建自定义编译&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4613a8244834c0ecb89ce0d825ca742a6fa51707" translate="yes" xml:space="preserve">
          <source>If you need to expose a Kotlin property as a field in Java, annotate it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt;&lt;code&gt;@JvmField&lt;/code&gt;&lt;/a&gt; annotation. The field will have the same visibility as the underlying property. You can annotate a property with &lt;code&gt;@JvmField&lt;/code&gt; if it has a backing field, is not private, does not have &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;override&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; modifiers, and is not a delegated property.</source>
          <target state="translated">如果您需要将Kotlin属性公开为Java中的字段，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt; &lt;code&gt;@JvmField&lt;/code&gt; &lt;/a&gt;注释对其进行注释。该字段将具有与基础属性相同的可见性。如果属性具有后备字段，不是私有属性，没有 &lt;code&gt;open&lt;/code&gt; ， &lt;code&gt;override&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 修饰符且不是委派属性，则可以使用 &lt;code&gt;@JvmField&lt;/code&gt; 对其进行注释。</target>
        </trans-unit>
        <trans-unit id="b3648463615f31d33dec14dff446661a5d42afc8" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating over something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">如果在迭代时需要了解当前元素的索引，可以使用 &lt;code&gt;withIndex()&lt;/code&gt; ，它对应于 &lt;code&gt;enumerate()&lt;/code&gt; 。它产生一个对象序列，该对象序列具有两个属性（索引和值）以及两个名为 &lt;code&gt;component1()&lt;/code&gt; 和 &lt;code&gt;component2()&lt;/code&gt; 的特殊访问器函数；Kotlin让您将这样的对象分解为一个声明：</target>
        </trans-unit>
        <trans-unit id="89e90e48358e19dcdf7d70c38acd3455ecae2039" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating through something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">如果您需要在迭代过程中了解当前元素的索引，则可以使用 &lt;code&gt;withIndex()&lt;/code&gt; ，它对应于 &lt;code&gt;enumerate()&lt;/code&gt; 。它产生一系列具有两个属性（索引和值）以及两个特殊命名的访问器函数的对象序列，分别称为 &lt;code&gt;component1()&lt;/code&gt; 和 &lt;code&gt;component2()&lt;/code&gt; ；Kotlin让您将这样的对象分解为声明：</target>
        </trans-unit>
        <trans-unit id="4c304182ad4dffb827b2cd5041835d4a1290ba5c" translate="yes" xml:space="preserve">
          <source>If you need to look up the class dynamically as well, you can use &lt;code&gt;Class.forName()&lt;/code&gt; and supply the fully-qualified name of the class.</source>
          <target state="translated">如果还需要动态查找该类，则可以使用 &lt;code&gt;Class.forName()&lt;/code&gt; 并提供该类的完全限定名称。</target>
        </trans-unit>
        <trans-unit id="fb05e76a6c128f62bf211b270ee1f300cbc3d9aa" translate="yes" xml:space="preserve">
          <source>If you need to retrieve an arbitrary element of a collection, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; function. You can call it without arguments or with a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; object as a source of the randomness.</source>
          <target state="translated">如果需要检索集合的任意元素，请调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt;函数。您可以不带参数或使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt;对象作为随机性的源来调用它。</target>
        </trans-unit>
        <trans-unit id="2c6c6ff6a76abad65e2d1d67dae2bda5a0418cb0" translate="yes" xml:space="preserve">
          <source>If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;&lt;code&gt;joinToString()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt;&lt;code&gt;joinTo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您需要以可读格式检索集合内容，请使用将集合转换为字符串的函数：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt; &lt;code&gt;joinToString()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt; &lt;code&gt;joinTo()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27633af274eff8d8c59fb2e4a25231c59018307c" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code can access the annotations and arguments normally.</source>
          <target state="translated">如果需要将类指定为注释的参数，请使用Kotlin类（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;）。Kotlin编译器会自动将其转换为Java类，以便Java代码可以正常访问批注和参数。</target>
        </trans-unit>
        <trans-unit id="993106f4a5b27e1d574e1151066452d4ad416447" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code will be able to see the annotations and arguments normally.</source>
          <target state="translated">如果需要将类指定为注释的参数，请使用Kotlin类（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;）。Kotlin编译器会自动将其转换为Java类，以便Java代码将能够正常查看注释和参数。</target>
        </trans-unit>
        <trans-unit id="7448bb25e266494ddde684c5929327a96a8fb964" translate="yes" xml:space="preserve">
          <source>If you need to use a nullable &lt;code&gt;Boolean&lt;/code&gt; in a conditional statement, use &lt;code&gt;if (value == true)&lt;/code&gt; or &lt;code&gt;if (value == false)&lt;/code&gt; checks.</source>
          <target state="translated">如果需要在条件语句中使用可为空的 &lt;code&gt;Boolean&lt;/code&gt; ，请使用 &lt;code&gt;if (value == true)&lt;/code&gt; 或 &lt;code&gt;if (value == false)&lt;/code&gt; 检查。</target>
        </trans-unit>
        <trans-unit id="2c201a6c8803ec9d0564e44a48fc6ef8489585c2" translate="yes" xml:space="preserve">
          <source>If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an &lt;a href=&quot;object-declarations&quot;&gt;object declaration&lt;/a&gt; inside that class.</source>
          <target state="translated">如果您需要编写一个可以在没有类实例的情况下调用但又需要访问类内部的函数（例如，工厂方法），则可以将该函数编写为该类内部&lt;a href=&quot;object-declarations&quot;&gt;对象声明&lt;/a&gt;的成员。</target>
        </trans-unit>
        <trans-unit id="5f584df433485780683ca571ae5a89e659948c6b" translate="yes" xml:space="preserve">
          <source>If you only want to call the function and don't care about the metadata, use a function type, e.g. &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; for an ordinary function reference or a bound member function reference, or &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; for an unbound member function reference on &lt;code&gt;A&lt;/code&gt;. Note that &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; and its subinterfaces are only available for declared functions (obtained either by explicitly referencing it in the code, or through reflection, as shown later) - only function types are available for function literals (lambda expressions or anonymous functions).</source>
          <target state="translated">如果只想调用函数而不关心元数据，请使用函数类型，例如 &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; 作为普通函数引用或绑定成员函数引用，或者使用 &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; 表示 &lt;code&gt;A&lt;/code&gt; 上的未绑定成员函数引用。请注意， &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; 及其子接口仅可用于已声明的函数（通过在代码中显式引用它或通过反射来获得，如稍后所示）-仅函数类型可用于函数文字（lambda表达式或匿名函数） 。</target>
        </trans-unit>
        <trans-unit id="8014e84399844604d4127e5bfb102e3054b9b7f6" translate="yes" xml:space="preserve">
          <source>If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful.</source>
          <target state="translated">如果你操作嵌套的集合,你可能会发现提供对嵌套集合元素的平面访问的标准库函数很有用。</target>
        </trans-unit>
        <trans-unit id="aa8d397c2c2050d55c50d82eec1a501b49617481" translate="yes" xml:space="preserve">
          <source>If you override a &lt;code&gt;protected&lt;/code&gt; member and do not specify the visibility explicitly, the overriding member will also have &lt;code&gt;protected&lt;/code&gt; visibility.</source>
          <target state="translated">如果您覆盖 &lt;code&gt;protected&lt;/code&gt; 成员并且未明确指定可见性，则该覆盖的成员还将具有 &lt;code&gt;protected&lt;/code&gt; 可见性。</target>
        </trans-unit>
        <trans-unit id="bd8f947a24ab8c99f576a413b868a14fd70348dc" translate="yes" xml:space="preserve">
          <source>If you previously used the &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android support&lt;/a&gt; for annotation processors, replace usages of the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration with &lt;code&gt;kapt&lt;/code&gt;. If your project contains Java classes, &lt;code&gt;kapt&lt;/code&gt; will also take care of them.</source>
          <target state="translated">如果您以前使用&lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;的Android支持&lt;/a&gt;标注处理，更换的用法 &lt;code&gt;annotationProcessor&lt;/code&gt; 与配置 &lt;code&gt;kapt&lt;/code&gt; 。如果您的项目包含Java类，则 &lt;code&gt;kapt&lt;/code&gt; 还将处理它们。</target>
        </trans-unit>
        <trans-unit id="94aa78de26a564fc468e55c702b46b061a65c43e" translate="yes" xml:space="preserve">
          <source>If you publish multiple independent features that require opt-in, declare an annotation for each. This makes the use of API safer for your clients: they can use only the features that they explicitly accept. This also lets you remove the opt-in requirements from the features independently.</source>
          <target state="translated">如果你发布了多个需要选择加入的独立功能,请为每个功能声明一个注解。这样可以让你的客户更安全地使用API:他们只能使用他们明确接受的功能。这也让你可以独立地删除功能中的选择加入要求。</target>
        </trans-unit>
        <trans-unit id="3126f475d393c0188e7088d866ab3c517a722979" translate="yes" xml:space="preserve">
          <source>If you publish several features in the experimental state, declare a marker for each. Separate markers make the use of experimental features safer for your clients: they'll be able to use only the features that they explicitly accept. This also lets you graduate the features to stable independently.</source>
          <target state="translated">如果您在实验状态下发布了多个功能,请为每个功能声明一个标记。单独的标记可以让你的客户更安全地使用实验性功能:他们将只能使用他们明确接受的功能。这也让你可以独立地将功能升级到稳定状态。</target>
        </trans-unit>
        <trans-unit id="df8a586d7260c254feebf62ecf6abe57e497a3fe" translate="yes" xml:space="preserve">
          <source>If you really really need a mixed-type collection, you can use the element type &lt;code&gt;Any&lt;/code&gt; - but you'll need typecasting to get the elements back to their proper type again, so if what you want is a multiple-value return from a function, please use the per-element-typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Triple&lt;/code&gt; instead. If you need four or more elements, consider making a &lt;a href=&quot;classes#data-classes&quot;&gt;data class&lt;/a&gt; for the return type instead (which you should ideally do for two or three elements as well, especially if it's a public function, since it gives you proper names for the elements) - it's very easy and usually a oneliner.</source>
          <target state="translated">如果您确实确实需要混合类型集合，则可以使用元素类型 &lt;code&gt;Any&lt;/code&gt; ，但是您需要进行类型转换以使元素再次返回其正确类型，因此，如果要的是从函数返回多值，请改用按元素类型输入的 &lt;code&gt;Pair&lt;/code&gt; 或 &lt;code&gt;Triple&lt;/code&gt; 。如果您需要四个或更多元素，请考虑为返回类型创建一个&lt;a href=&quot;classes#data-classes&quot;&gt;数据类&lt;/a&gt;（理想情况下，您也应该对两个或三个元素进行此处理，尤其是在使用public函数的情况下，因为它会为元素提供正确的名称）-这很简单，通常是一个单线。</target>
        </trans-unit>
        <trans-unit id="cbc8324a9f6502600707b1d372c5b0e01758d5e6" translate="yes" xml:space="preserve">
          <source>If you really want to, you can both initialize and specify the type on the same line. This is mostly useful if you're dealing with a class hierarchy (more on that later) and you want the variable type to be a base type of the value's class:</source>
          <target state="translated">如果你真的想这样做,你可以在同一行中同时初始化和指定类型。如果你正在处理一个类的层次结构(稍后会有更多的介绍),并且你希望变量类型是值的类的基础类型,那么这就很有用。</target>
        </trans-unit>
        <trans-unit id="c6599b66c1550e4e193ba560f565b728a822797c" translate="yes" xml:space="preserve">
          <source>If you run a command-line compiler, add the compiler arguments directly to the utility call or write them into an &lt;a href=&quot;#argfile&quot;&gt;argfile&lt;/a&gt;. For example:</source>
          <target state="translated">如果运行命令行编译器，则将编译器参数直接添加到实用程序调用中，或将其写入&lt;a href=&quot;#argfile&quot;&gt;argfile中&lt;/a&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="13648197906f478e28c0bcf3383cb817c3e322b6" translate="yes" xml:space="preserve">
          <source>If you run the above code you'll see that it does not always print zero, though it may depend on the timings of your machine you may need to tweak timeouts in this example to actually see non-zero values.</source>
          <target state="translated">如果你运行上面的代码,你会发现它并不总是打印零,尽管它可能取决于你的机器的定时,你可能需要在这个例子中调整超时以实际看到非零值。</target>
        </trans-unit>
        <trans-unit id="dd3a00df64d22ebf69e57bb704a9d62539a93298" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; by &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">如果您通过更换启动 &lt;code&gt;GlobalScope.launch&lt;/code&gt; 由 &lt;code&gt;thread&lt;/code&gt; ，编译器产生以下错误：</target>
        </trans-unit>
        <trans-unit id="1244c242be7001db0fa42d5a34807cd464a4c723" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; with &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">如果首先将 &lt;code&gt;GlobalScope.launch&lt;/code&gt; 替换为 &lt;code&gt;thread&lt;/code&gt; ，则编译器将产生以下错误：</target>
        </trans-unit>
        <trans-unit id="589b4c81823f6922542c45e2902c148531d2b494" translate="yes" xml:space="preserve">
          <source>If you target JavaScript, use the &lt;code&gt;stdlib-js&lt;/code&gt; dependency.</source>
          <target state="translated">如果您以JavaScript为目标，请使用 &lt;code&gt;stdlib-js&lt;/code&gt; 依赖项。</target>
        </trans-unit>
        <trans-unit id="bf587872264afbd1369b320aaae73dd1b3673d1b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;enable caching for them manually&lt;/a&gt;.</source>
          <target state="translated">如果使用&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;，请注意，默认情况下不会缓存kapt批注处理任务。但是，您可以&lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;手动为它们启用缓存&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39efa722c74de834ad1bd8a4e4c201bd7dac494b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can enable caching for them manually. See the &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt page&lt;/a&gt; for details.</source>
          <target state="translated">如果使用&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;，请注意，默认情况下不会缓存kapt批注处理任务。但是，您可以为其手动启用缓存。有关详细信息，请参见&lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a73c7aeee6bdc5c7806d3e53e9294fc8ac4610bf" translate="yes" xml:space="preserve">
          <source>If you use Spring, you can enable the &lt;em&gt;kotlin-spring&lt;/em&gt; compiler plugin instead of specifying Spring annotations manually. The kotlin-spring is a wrapper on top of all-open, and it behaves exactly the same way.</source>
          <target state="translated">如果您使用Spring，则可以启用&lt;em&gt;kotlin-spring&lt;/em&gt;编译器插件，而不用手动指定Spring注释。Kotlin弹簧是全开式包装的包装，其行为完全相同。</target>
        </trans-unit>
        <trans-unit id="611d8f619bf7a7948c981fe9d16f096526d50981" translate="yes" xml:space="preserve">
          <source>If you use a kotlinx library and need a platform-specific dependency, you can use platform-specific variants of libraries with suffixes such as &lt;code&gt;-jvm&lt;/code&gt; or &lt;code&gt;-js&lt;/code&gt;, for example, &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;. You can also use the library base artifact name instead &amp;ndash; &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt;.</source>
          <target state="translated">如果您使用kotlinx库并且需要特定于平台的依赖项，则可以使用带有后缀的库特定于平台的变体，例如 &lt;code&gt;-jvm&lt;/code&gt; 或 &lt;code&gt;-js&lt;/code&gt; ，例如 &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt; 。您也可以改用库的基本工件名称&amp;ndash; &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7efa55746211a1f8112a9a60777f3c462da2efbd" translate="yes" xml:space="preserve">
          <source>If you use a multiplatform library and need to depend on the shared code, set the dependency only once in the shared source set. Use the library base artifact name, such as &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; or &lt;code&gt;ktor-client-core&lt;/code&gt;.</source>
          <target state="translated">如果您使用多平台库并且需要依赖共享代码，则在共享源集中仅设置一次依赖关系。使用库的基本工件名称，例如 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 或 &lt;code&gt;ktor-client-core&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bce77e8c93a7ca161789d86b2fef454e9ed0e0f" translate="yes" xml:space="preserve">
          <source>If you use annotation processors for your &lt;code&gt;androidTest&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; sources, the respective &lt;code&gt;kapt&lt;/code&gt; configurations are named &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt;. Note that &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt; extends &lt;code&gt;kapt&lt;/code&gt;, so you can just provide the &lt;code&gt;kapt&lt;/code&gt; dependency and it will be available both for production sources and tests.</source>
          <target state="translated">如果您将注释处理器用于 &lt;code&gt;androidTest&lt;/code&gt; 或 &lt;code&gt;test&lt;/code&gt; 源，则相应的 &lt;code&gt;kapt&lt;/code&gt; 配置将命名为 &lt;code&gt;kaptAndroidTest&lt;/code&gt; 和 &lt;code&gt;kaptTest&lt;/code&gt; 。请注意， &lt;code&gt;kaptAndroidTest&lt;/code&gt; 和 &lt;code&gt;kaptTest&lt;/code&gt; 扩展了 &lt;code&gt;kapt&lt;/code&gt; ，因此您只需提供 &lt;code&gt;kapt&lt;/code&gt; 依赖项，即可将其用于生产源和测试。</target>
        </trans-unit>
        <trans-unit id="e98efb35675e1c9619917853c6319e94bee5daa4" translate="yes" xml:space="preserve">
          <source>If you use libraries published with metadata, you only have to specify dependencies on them only once in the shared source set, as opposed to specifying dependencies on different variants of the same library in the shared and platform-specific source sets prior to 1.4.0.</source>
          <target state="translated">如果您使用带元数据发布的库,您只需要在共享源集中指定一次对它们的依赖,而不是在1.4.0之前的共享和特定平台的源集中指定对同一库的不同变体的依赖。</target>
        </trans-unit>
        <trans-unit id="33f8dde1a7f866c06f2a153c28219ec09cc0d77e" translate="yes" xml:space="preserve">
          <source>If you use opt-in requirements for features that are not stable yet, carefully handle the API graduation to avoid breaking the client code.</source>
          <target state="translated">如果你对还不稳定的功能使用选入需求,请谨慎处理API毕业,避免破坏客户端代码。</target>
        </trans-unit>
        <trans-unit id="8e5fa9bba802b4996dceed857e221c7dc79c3552" translate="yes" xml:space="preserve">
          <source>If you use the NV Kotlin compiler and have the OV standard library or the OV reflection library in the classpath, it can be a sign that the project is misconfigured. To prevent unexpected problems during compilation or at runtime, we suggest either updating the dependencies to NV, or specifying the API version / language version arguments explicitly. Otherwise the compiler detects that something can go wrong and reports a warning.</source>
          <target state="translated">如果你使用NV Kotlin编译器,并且在classpath中有OV标准库或OV反射库,这可能是项目配置错误的迹象。为了防止在编译过程中或运行时出现意外问题,我们建议更新依赖关系到NV,或者明确指定API版本/语言版本参数。否则编译器会检测到一些可能出错的地方并报告一个警告。</target>
        </trans-unit>
        <trans-unit id="f69388ccfa9be1025c7351e156b510d0110f1b95" translate="yes" xml:space="preserve">
          <source>If you want a literal &lt;code&gt;$&lt;/code&gt;, you need to escape it: &lt;code&gt;\$&lt;/code&gt;. Escaping generally works the same way as in Python, with a similar set of standard escape sequences.</source>
          <target state="translated">如果要使用文字 &lt;code&gt;$&lt;/code&gt; ，则需要对其进行转义： &lt;code&gt;\$&lt;/code&gt; 。转义通常与Python中的工作方式相同，但具有一组类似的标准转义序列。</target>
        </trans-unit>
        <trans-unit id="542e15c450e9d7499e5b8e3fd1eff9a8b7386f93" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;start from scratch&lt;/strong&gt;, you can &lt;a href=&quot;jvm-get-started&quot;&gt;create a basic Kotlin application&lt;/a&gt;. Once you&amp;rsquo;ve created the application, you can dive deeper into Kotlin syntax:</source>
          <target state="translated">如果您想&lt;strong&gt;从头开始&lt;/strong&gt;，则可以&lt;a href=&quot;jvm-get-started&quot;&gt;创建一个基本的Kotlin应用程序&lt;/a&gt;。创建应用程序后，您可以更深入地了解Kotlin语法：</target>
        </trans-unit>
        <trans-unit id="dcc75b83f1a6aedb14b4da0cf0332f54ec31285c" translate="yes" xml:space="preserve">
          <source>If you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the &lt;code&gt;@Throws&lt;/code&gt; annotation. Read more about using this annotation &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;for Java&lt;/a&gt; as well as &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;for Swift and Objective-C&lt;/a&gt;.</source>
          <target state="translated">如果要在从Java，Swift或Objective-C调用Kotlin代码时提醒调用者可能的异常，可以使用 &lt;code&gt;@Throws&lt;/code&gt; 批注。阅读有关使用此注释&lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;用于Java&lt;/a&gt;以及&lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;Swift和Objective-C的更多信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aeb2cd1321a6da714d1670aa5db99ba2841082d1" translate="yes" xml:space="preserve">
          <source>If you want to be able to intercept an assignment and &quot;veto&quot; it, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">如果您希望能够拦截分配并&amp;ldquo;否决&amp;rdquo;分配，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; &lt;/a&gt;而不是 &lt;code&gt;observable()&lt;/code&gt; 。在执行新属性值的分配&lt;em&gt;之前，&lt;/em&gt;将调用传递给 &lt;code&gt;vetoable&lt;/code&gt; 的处理程序。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bfcb549b385e785251e8b67f2103cc999018679b" translate="yes" xml:space="preserve">
          <source>If you want to be more explicit about the fact that you're creating a function, you can make an &lt;em&gt;anonymous function&lt;/em&gt;, which is still an expression rather than a declaration:</source>
          <target state="translated">如果您想更清楚地了解创建函数的事实，可以创建一个&lt;em&gt;匿名函数&lt;/em&gt;，该&lt;em&gt;函数&lt;/em&gt;仍然是表达式而不是声明：</target>
        </trans-unit>
        <trans-unit id="696e4536ad6464f41098a1506dbe37ed6e039609" translate="yes" xml:space="preserve">
          <source>If you want to check for &lt;em&gt;not&lt;/em&gt; being an instance of a type, use &lt;code&gt;!is&lt;/code&gt;. Note that &lt;code&gt;null&lt;/code&gt; is never an instance of any non-nullable type, but it is always an &quot;instance&quot; of any nullable type (even though it technically isn't an instance, but an absence of any instance).</source>
          <target state="translated">如果要检查&lt;em&gt;不是&lt;/em&gt;某个类型的实例，请使用 &lt;code&gt;!is&lt;/code&gt; 。请注意， &lt;code&gt;null&lt;/code&gt; 绝不是任何非空类型的实例，但它始终是任何可空类型的&amp;ldquo;实例&amp;rdquo;（即使从技术上讲它不是实例，但是没有任何实例）。</target>
        </trans-unit>
        <trans-unit id="da257f8128fc0a8ca8d706e6f33a71205b6846f0" translate="yes" xml:space="preserve">
          <source>If you want to customize your builds or run configuration, refer to the Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">如果要自定义构建或运行配置，请参阅Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6811d9ac7923673de93e7c6cb86e0dcf12f4b539" translate="yes" xml:space="preserve">
          <source>If you want to declare your module's API as experimental, create an annotation class to use as its &lt;em&gt;experimental marker&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;:</source>
          <target state="translated">如果要将模块的API声明为实验性API，请创建一个注释类以用作其&lt;em&gt;实验性标记&lt;/em&gt;。此类必须使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;进行注释：</target>
        </trans-unit>
        <trans-unit id="03930681c826a10c017d1c305e0dfdcd631eb099" translate="yes" xml:space="preserve">
          <source>If you want to do something that does not fit into this &quot;implicit backing field&quot; scheme, you can always fall back to having a &lt;em&gt;backing property&lt;/em&gt;:</source>
          <target state="translated">如果您想做一些不适合这种&amp;ldquo;隐式后备字段&amp;rdquo;方案的事情，那么您总是可以退回到拥有&lt;em&gt;后备属性的位置&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="469cbead1816f95552e8fb9afc4584e38910eba1" translate="yes" xml:space="preserve">
          <source>If you want to exclude the last value, use &lt;code&gt;until&lt;/code&gt;:</source>
          <target state="translated">如果要排除最后一个值，请使用 &lt;code&gt;until&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="21db5d6173e4569eae43123218189b3a3fd619bd" translate="yes" xml:space="preserve">
          <source>If you want to group elements and then apply an operation to all groups at one time, use the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt;&lt;code&gt;groupingBy()&lt;/code&gt;&lt;/a&gt;. It returns an instance of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt;&lt;code&gt;Grouping&lt;/code&gt;&lt;/a&gt; type. The &lt;code&gt;Grouping&lt;/code&gt; instance lets you apply operations to all groups in a lazy manner: the groups are actually built right before the operation execution.</source>
          <target state="translated">如果要对元素进行分组，然后一次将操作应用于所有分组，请使用函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt; &lt;code&gt;groupingBy()&lt;/code&gt; &lt;/a&gt;。它返回一个&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt; &lt;code&gt;Grouping&lt;/code&gt; &lt;/a&gt;类型的实例。通过 &lt;code&gt;Grouping&lt;/code&gt; 实例，您可以以一种惰性的方式将操作应用于所有组：这些组实际上是在执行操作之前构建的。</target>
        </trans-unit>
        <trans-unit id="03cd0cd3cc1cb5ea27db0072e091a1e185cd704d" translate="yes" xml:space="preserve">
          <source>If you want to have full control over the declarations generated by Dukat, want to apply manual adjustments, or if you're running into trouble with the auto-generated externals, you can also trigger the creation of the declarations for all your npm dependencies manually via the Gradle task &lt;code&gt;generateExternals&lt;/code&gt;. This will generate declarations in a directory titled &lt;code&gt;externals&lt;/code&gt; in your project root. Here, you can review the generated code and copy any parts you would like to use to your source directories.</source>
          <target state="translated">如果您想完全控制Dukat生成的声明，想要应用手动调整，或者遇到自动生成的外部组件的麻烦，您还可以手动触发所有npm依赖项的声明的创建通过Gradle任务 &lt;code&gt;generateExternals&lt;/code&gt; 。这将在项目根目录中名为&amp;ldquo; &lt;code&gt;externals&lt;/code&gt; &amp;rdquo;的目录中生成声明。在这里，您可以查看生成的代码，并将想要使用的任何部分复制到源目录中。</target>
        </trans-unit>
        <trans-unit id="28c8357f8e591acaadaa35ef0312974da5893976" translate="yes" xml:space="preserve">
          <source>If you want to impose additional constraints, you must use a separate &lt;code&gt;where&lt;/code&gt; clause, in which case the type parameter must be a subclass of the given class (if you specify a class, and you can specify at most one) &lt;em&gt;and&lt;/em&gt; implement all the given interfaces. You may then access all the public members of all the given types whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">如果要施加其他约束，则必须使用单独的 &lt;code&gt;where&lt;/code&gt; 子句，在这种情况下，type参数必须是给定类的子类（如果指定了一个类，并且最多可以指定一个），&lt;em&gt;并&lt;/em&gt;实现所有给定的接口。然后，只要您拥有类型 &lt;code&gt;T&lt;/code&gt; 的值，就可以访问所有给定类型的所有公共成员：</target>
        </trans-unit>
        <trans-unit id="1e91febbc6ec64c3a83c00953396a7246b3b6ef2" translate="yes" xml:space="preserve">
          <source>If you want to intercept assignments and &quot;veto&quot; them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">如果要拦截分配并&amp;ldquo;否决&amp;rdquo;分配，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; &lt;/a&gt;而不是 &lt;code&gt;observable()&lt;/code&gt; 。在执行新属性值的分配&lt;em&gt;之前，&lt;/em&gt;将调用传递给 &lt;code&gt;vetoable&lt;/code&gt; 的处理程序。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad4ce20803bf2d9ea3efb4e51b2111ecb76db405" translate="yes" xml:space="preserve">
          <source>If you want to iterate through an array or a list with an index, you can do it this way:</source>
          <target state="translated">如果你想在一个数组或带索引的列表中进行迭代,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="125c434fa84549730a675353dd139689f7b256f9" translate="yes" xml:space="preserve">
          <source>If you want to keep a whole package or module from elimination, you can use its fully qualified name as it appears in the generated JavaScript code.</source>
          <target state="translated">如果你想让整个包或模块不被淘汰,你可以使用它在生成的JavaScript代码中出现的全称。</target>
        </trans-unit>
        <trans-unit id="c6675875ca0e15a9e0e94e4e62bcc35aa2271753" translate="yes" xml:space="preserve">
          <source>If you want to keep your code compatible with the 1.0 standard library, you can pass &lt;code&gt;-api-version 1.0&lt;/code&gt;.</source>
          <target state="translated">如果要使代码与1.0标准库兼容，则可以传递 &lt;code&gt;-api-version 1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a90f40cf003c1ca63835c4f5252dade99a0b6302" translate="yes" xml:space="preserve">
          <source>If you want to learn different Kotlin features, try &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">如果您想了解Kotlin的其他功能，请尝试&lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00db4d51336388a60b35cfdb52f35a642fd46d81" translate="yes" xml:space="preserve">
          <source>If you want to look at the metadata of a function (e.g. its name), use &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; or one of its subinterfaces, where &lt;code&gt;V&lt;/code&gt; is the function's return type. Here's a basic example:</source>
          <target state="translated">如果要查看函数的元数据（例如，函数名称），请使用 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; 或其子接口之一，其中 &lt;code&gt;V&lt;/code&gt; 是函数的返回类型。这是一个基本示例：</target>
        </trans-unit>
        <trans-unit id="5b301496262ace39d5d4ef8977ee4d6171448d2c" translate="yes" xml:space="preserve">
          <source>If you want to make further adjustments to the webpack configuration, place your additional configuration files inside a directory called &lt;code&gt;webpack.config.d&lt;/code&gt; in the root of your project. When building your project, all &lt;code&gt;.js&lt;/code&gt; configuration files will automatically be merged into the &lt;code&gt;build/js/packages/projectName/webpack.config.js&lt;/code&gt; file. To add a new &lt;a href=&quot;https://webpack.js.org/loaders/&quot;&gt;webpack loader&lt;/a&gt;, for example, add the following to a &lt;code&gt;.js&lt;/code&gt; file inside the &lt;code&gt;webpack.config.d&lt;/code&gt;:</source>
          <target state="translated">如果要进一步调整webpack配置，请将其他配置文件放在项目根目录中名为 &lt;code&gt;webpack.config.d&lt;/code&gt; 的目录中。在构建项目时，所有 &lt;code&gt;.js&lt;/code&gt; 配置文件都会自动合并到 &lt;code&gt;build/js/packages/projectName/webpack.config.js&lt;/code&gt; 文件中。例如，要添加新的&lt;a href=&quot;https://webpack.js.org/loaders/&quot;&gt;webpack加载器&lt;/a&gt;，请将以下内容添加到 &lt;code&gt;webpack.config.d&lt;/code&gt; 内的 &lt;code&gt;.js&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="49c6ac403c1f5c69a934ea0d8c7e8d3612d277ad" translate="yes" xml:space="preserve">
          <source>If you want to require explicit consent to using your module's API, create an annotation class to use as an &lt;em&gt;opt-in requirement annotation&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-requires-opt-in/index&quot;&gt;@RequiresOptIn&lt;/a&gt;:</source>
          <target state="translated">如果您需要获得使用模块的API的明确同意，请创建一个注释类，以用作&lt;em&gt;加入要求注释&lt;/em&gt;。此类必须使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-requires-opt-in/index&quot;&gt;@RequiresOptIn&lt;/a&gt;进行注释：</target>
        </trans-unit>
        <trans-unit id="1d1730df83789869c0eec8797d86c76b973936cd" translate="yes" xml:space="preserve">
          <source>If you want to restrict the set of subclasses of a base class, you can declare the base class to be &lt;code&gt;sealed&lt;/code&gt; (which also makes it abstract), in which case you can only declare subclasses in the same file. The compiler then knows the complete set of possible subclasses, which will let you do exhaustive &lt;code&gt;when&lt;/code&gt; expression for all the possible subtypes without the need for an &lt;code&gt;else&lt;/code&gt; clause (and if you add another subclass in the future and forget to update the &lt;code&gt;when&lt;/code&gt;, the compiler will let you know).</source>
          <target state="translated">如果要限制基类的子类集，则可以声明要 &lt;code&gt;sealed&lt;/code&gt; 的基类（这也使其抽象化），在这种情况下，只能在同一文件中声明子类。然后，编译器知道了所有可能的子类的完整集合，这将使您在无需使用 &lt;code&gt;else&lt;/code&gt; 子句的情况下对所有可能的子类型进行详尽的 &lt;code&gt;when&lt;/code&gt; 表达式（如果将来添加另一个子类而忘记更新 &lt;code&gt;when&lt;/code&gt; ，则编译器会让你知道）。</target>
        </trans-unit>
        <trans-unit id="24aa907f13ca700b9ceeaa1262123234a9393fc1" translate="yes" xml:space="preserve">
          <source>If you want to see all available options run</source>
          <target state="translated">如果你想查看所有可用的选项,运行</target>
        </trans-unit>
        <trans-unit id="2d21aa936de4e7ff46724ca50ee4a418c4b5e521" translate="yes" xml:space="preserve">
          <source>If you want to see how your task will be look to the learner, right-click the &lt;code&gt;Task.kt&lt;/code&gt; file in the &lt;strong&gt;Project&lt;/strong&gt; tool window, and choose &lt;strong&gt;Course Creator -&amp;gt; Show Preview&lt;/strong&gt;:</source>
          <target state="translated">如果要查看学习者的任务外观，请在&amp;ldquo; &lt;strong&gt;项目&amp;rdquo;&lt;/strong&gt;工具窗口中右键单击 &lt;code&gt;Task.kt&lt;/code&gt; 文件，然后选择&amp;ldquo; &lt;strong&gt;课程创建者&amp;rdquo;-&amp;gt;&amp;ldquo;显示预览&amp;rdquo;&lt;/strong&gt;：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a25bc71220d18fbd536e1d59a05a1130584e1bb" translate="yes" xml:space="preserve">
          <source>If you want to skip tests, add the line &lt;code&gt;enabled = false&lt;/code&gt; to the &lt;code&gt;testTask&lt;/code&gt;.</source>
          <target state="translated">如果要跳过测试，请在 &lt;code&gt;testTask&lt;/code&gt; 上添加 &lt;code&gt;enabled = false&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="81dec7b57d1ae160cc859398f6b261d2b3f48fa4" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom label for the link, use the Markdown reference-style syntax:</source>
          <target state="translated">如果你想为链接指定一个自定义标签,请使用Markdown引用式语法。</target>
        </trans-unit>
        <trans-unit id="e8b98cb29aff85793ce838953d8ec8871fe09a05" translate="yes" xml:space="preserve">
          <source>If you want to start from scratch with the task, use the &lt;strong&gt;Reset&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel:</source>
          <target state="translated">如果要从头开始执行任务，请使用&amp;ldquo; &lt;strong&gt;任务描述&amp;rdquo;&lt;/strong&gt;面板顶部的&amp;ldquo; &lt;strong&gt;重置&amp;rdquo;&lt;/strong&gt;图标：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377ee38e06516840389b0006f62da827c729d93" translate="yes" xml:space="preserve">
          <source>If you want to start using Kotlin for Android development, read &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Google&amp;rsquo;s recommendation for getting started with Kotlin on Android&lt;/a&gt;.</source>
          <target state="translated">如果您想开始使用Kotlin进行Android开发，请阅读&lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Google关于在Android上使用Kotlin入门的建议&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef089a53351dae0337ca675a4a633d10abb6eccf" translate="yes" xml:space="preserve">
          <source>If you want to use a value only if it satisfies a certain condition, try &lt;code&gt;takeIf()&lt;/code&gt;, which returns the value it's called on if it satisfies the given predicate, and null otherwise. There's also &lt;code&gt;takeUnless()&lt;/code&gt;, which inverts the logic. You can follow this with a &lt;code&gt;?.&lt;/code&gt; to perform an operation on the value only if it satisfies the predicate. Below, we compute the square of some expression, but only if the expression value is at least 42:</source>
          <target state="translated">如果仅在满足特定条件时才使用值，请尝试 &lt;code&gt;takeIf()&lt;/code&gt; ，如果它满足给定谓词，则返回它被调用的值，否则返回null。还有 &lt;code&gt;takeUnless()&lt;/code&gt; ，它会反转逻辑。您可以在后面加上 &lt;code&gt;?.&lt;/code&gt; 仅在满足谓词的情况下对值执行运算。下面，我们计算某些表达式的平方，但前提是表达式的值至少为42：</target>
        </trans-unit>
        <trans-unit id="39803479c2452982a2bf2e4068e689f82660ee9c" translate="yes" xml:space="preserve">
          <source>If you want to use dependencies on local pods from Kotlin code, import the corresponding packages.</source>
          <target state="translated">如果你想从Kotlin代码中使用本地pods的依赖,请导入相应的包。</target>
        </trans-unit>
        <trans-unit id="be96354e6d849f99091812f51218336ab205ca9c" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;Teaching Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">如果您想使用EduTools插件进行教学，请阅读&lt;a href=&quot;edu-tools-educator&quot;&gt;使用EduTools插件教Kotlin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67fb2febabe66895070c2641c4d6f978cdb57747" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin to learn Kotlin, read &lt;a href=&quot;edu-tools-learner&quot;&gt;Learning Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">如果要使用EduTools插件学习Kotlin，请阅读&lt;a href=&quot;edu-tools-learner&quot;&gt;使用EduTools插件学习Kotlin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4008289e8be7206e3604bd36b66d2e732e4dca59" translate="yes" xml:space="preserve">
          <source>If you want to use the IR compiler backend for your project, you need to &lt;strong&gt;update all Kotlin dependencies to versions that support this new backend&lt;/strong&gt;. Libraries published by JetBrains for Kotlin 1.4+ targeting Kotlin/JS already contain all artifacts required for usage with the new IR compiler backend.</source>
          <target state="translated">如果要为项目使用IR编译器后端，则需要将&lt;strong&gt;所有Kotlin依赖项更新为支持该新后端的版本&lt;/strong&gt;。由JetBrains针对Kotlin / JS发布的针对Kotlin 1.4+的库已经包含了与新的IR编译器后端一起使用所需的所有工件。</target>
        </trans-unit>
        <trans-unit id="87bc643ce85513f6868cb2e9de9823d1f4369259" translate="yes" xml:space="preserve">
          <source>If you want to write strings gradually, you need to create an &lt;code&gt;OutputStreamWriter&lt;/code&gt; by calling &lt;code&gt;writer()&lt;/code&gt; on the file object. You can write binary data to a file by calling &lt;code&gt;outputStream()&lt;/code&gt; on a file object and use the resulting &lt;code&gt;OutputStream&lt;/code&gt; to write bytes.</source>
          <target state="translated">如果要逐渐编写字符串，则需要通过在文件对象上调用 &lt;code&gt;writer()&lt;/code&gt; 创建一个 &lt;code&gt;OutputStreamWriter&lt;/code&gt; 。您可以通过在文件对象上调用 &lt;code&gt;outputStream()&lt;/code&gt; 将二进制数据写入文件，然后使用生成的 &lt;code&gt;OutputStream&lt;/code&gt; 写入字节。</target>
        </trans-unit>
        <trans-unit id="a41befb145b42cbf8131f21728e484a8a91115d2" translate="yes" xml:space="preserve">
          <source>If you write the same without &lt;code&gt;let&lt;/code&gt;, you'll have to introduce a new variable and repeat its name whenever you use it.</source>
          <target state="translated">如果不使用 &lt;code&gt;let&lt;/code&gt; 编写相同的代码，则必须引入一个新变量，并在每次使用它时重复其名称。</target>
        </trans-unit>
        <trans-unit id="3ea1c290d713b3b54603ea5a070a3770513b0c88" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re developing a multiplatform application that needs to access platform-specific APIs that implement the required functionality, use the Kotlin mechanism of &lt;em&gt;expected and actual declarations&lt;/em&gt;.</source>
          <target state="translated">如果您要开发一个多平台应用程序，需要访问实现所需功能的特定于平台的API，请使用Kotlin&lt;em&gt;预期和实际声明&lt;/em&gt;机制。</target>
        </trans-unit>
        <trans-unit id="0a3aaf1f9dd9fea6023de83a437602a5eadebf5e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 16.04 or later, you can install the compiler from the command line:</source>
          <target state="translated">如果您使用的是Ubuntu 16.04或更高版本，则可以从命令行安装编译器：</target>
        </trans-unit>
        <trans-unit id="4ef3b492d472d99a86a122fa8edba6106fbe3c08" translate="yes" xml:space="preserve">
          <source>If you'd rather do &lt;code&gt;x.unsigned&lt;/code&gt;, you can define an extension property:</source>
          <target state="translated">如果愿意使用 &lt;code&gt;x.unsigned&lt;/code&gt; ，则可以定义一个扩展属性：</target>
        </trans-unit>
        <trans-unit id="07dd95cbbfcdccfc3f0d530d8306040139f15ae7" translate="yes" xml:space="preserve">
          <source>If you're a &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; user, you can install the compiler with:</source>
          <target state="translated">如果您是&lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt;用户，则可以使用以下方法安装编译器：</target>
        </trans-unit>
        <trans-unit id="d4d4dba6c4489bae4eb7e70ee6038d13984170c1" translate="yes" xml:space="preserve">
          <source>If you're a library maintainer who is looking to provide compatibility with the default backend as well as the new IR compiler backend, a setting for the compiler selection is available that allows you to create artifacts for both backends, allowing you to keep compatibility for your existing users while providing support for the next generation of Kotlin compiler. This so-called &lt;code&gt;both&lt;/code&gt;-mode can be turned on using the &lt;code&gt;kotlin.js.compiler=both&lt;/code&gt; setting in your &lt;code&gt;gradle.properties&lt;/code&gt; file, or can be set as one of the project-specific options inside your &lt;code&gt;js&lt;/code&gt; block inside the &lt;code&gt;build.gradle(.kts)&lt;/code&gt; file:</source>
          <target state="translated">如果您是图书馆维护者，希望提供与默认后端以及新的IR编译器后端的兼容性，那么可以使用编译器选择的设置，该设置可让您为两个后端创建构件，从而保持与以下版本的兼容性。您现有的用户，同时为下一代Kotlin编译器提供支持。这种所谓的 &lt;code&gt;both&lt;/code&gt; -模式可以在使用开启 &lt;code&gt;kotlin.js.compiler=both&lt;/code&gt; 在您的设置 &lt;code&gt;gradle.properties&lt;/code&gt; 文件，或作为您的内部项目特定的选项之一，可设置 &lt;code&gt;js&lt;/code&gt; 阻止内部 &lt;code&gt;build.gradle(.kts)&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="0509d81eee59f0e681a0c3f0c84d5a54a79b4f26" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can build the &lt;em&gt;.jar&lt;/em&gt; file without including the Kotlin runtime into it.</source>
          <target state="translated">如果要开发供其他Kotlin应用程序使用的库，则可以构建&lt;em&gt;.jar&lt;/em&gt;文件而无需将Kotlin运行时包含在其中。</target>
        </trans-unit>
        <trans-unit id="368782cf6eaff197b952127bcc0c0565b3479378" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can produce the .jar file without including the Kotlin runtime into it.</source>
          <target state="translated">如果你正在开发一个供其他Kotlin应用程序使用的库,你可以在不包含Kotlin运行时的情况下生成.jar文件。</target>
        </trans-unit>
        <trans-unit id="9da5d517a7b5384e2a44811f79965cdbfc0afba2" translate="yes" xml:space="preserve">
          <source>If you're new to Android and want to learn to create applications with Kotlin, check out &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;this Udacity course&lt;/a&gt;.</source>
          <target state="translated">如果您不熟悉Android，并且想学习使用Kotlin创建应用程序，请查看&lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;此Udacity课程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f128e1fe8c8eb81ea54217b5ba66f82b1c59b061" translate="yes" xml:space="preserve">
          <source>If you're new to Kotlin, a good first step would be to familiarise yourself with the &lt;a href=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/a&gt; of the language.</source>
          <target state="translated">如果您不熟悉Kotlin，那么最好的第一步是使自己熟悉该语言的&lt;a href=&quot;basic-syntax&quot;&gt;基本语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="766f702953f8980e6bc50e185cc1d656f34dfbc1" translate="yes" xml:space="preserve">
          <source>If you're targeting JDK 7 or JDK 8, you can use extended versions of the Kotlin standard library which contain additional extension functions for APIs added in new JDK versions. Instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;, use &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; or &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, depending on your JDK version (for Kotlin 1.1.x use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; as the &lt;code&gt;jdk&lt;/code&gt; counterparts were introduced in 1.2.0).</source>
          <target state="translated">如果您以JDK 7或JDK 8为目标，则可以使用Kotlin标准库的扩展版本，其中包含针对新JDK版本中添加的API的其他扩展功能。代替 &lt;code&gt;kotlin-stdlib&lt;/code&gt; ，请使用 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 或 &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; ，具体取决于您的JDK版本（对于Kotlin 1.1.x，请使用 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; ,因为在1.2中引入了 &lt;code&gt;jdk&lt;/code&gt; 对应版本.0）。</target>
        </trans-unit>
        <trans-unit id="b775395194955c271aef49dac84498fbe90d7450" translate="yes" xml:space="preserve">
          <source>If you're targeting the JVM platform, you can also use Java's reflection system directly. In this example, we grab a function reference from an object's class by specifying the function's name as a string (if the function takes parameters, you also need to specify their types), and then we call it. Note that we didn't mention &lt;code&gt;String&lt;/code&gt; anywhere - this technique works without knowing what the object's class is, but it will raise an exception if the object's class doesn't have the requested function. However, Java-style function references do not have type information, so you won't get verification of the parameter types, and you must cast the return value:</source>
          <target state="translated">如果您以JVM平台为目标，则还可以直接使用Java的反射系统。在此示例中，我们通过将函数名称指定为字符串来从对象的类中获取函数引用（如果函数带有参数，则还需要指定其类型），然后调用它。请注意，我们在任何地方都没有提到 &lt;code&gt;String&lt;/code&gt; －这种技术在不知道对象的类是什么的情况下起作用，但是如果对象的类没有所请求的功能，它将引发异常。但是，Java样式的函数引用没有类型信息，因此您将无法验证参数类型，并且必须强制转换返回值：</target>
        </trans-unit>
        <trans-unit id="3a761f12674bd3c30efe00ec7ea6eb2be1927a55" translate="yes" xml:space="preserve">
          <source>If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the &lt;code&gt;webpackTask&lt;/code&gt; configuration block. For example, to switch to CommonJS, use:</source>
          <target state="translated">如果您以浏览器为目标并且要使用与UMD不同的模块系统，则可以在 &lt;code&gt;webpackTask&lt;/code&gt; 配置块中指定所需的模块类型。例如，要切换到CommonJS，请使用：</target>
        </trans-unit>
        <trans-unit id="5d2933676dc2f7e28b956599b006e00954f9395f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;em&gt;if&lt;/em&gt; as an expression rather than a statement (for example, returning its value or assigning it to a variable), the expression is required to have an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">如果您将&lt;em&gt;if&lt;/em&gt;用作表达式而不是语句（例如，将其值返回或将其分配给变量），则该表达式必须具有 &lt;code&gt;else&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="54106dba9eedca9003087d15e44d20a53dd58c38" translate="yes" xml:space="preserve">
          <source>If you're using Gradle, specify the compiler arguments in the &lt;code&gt;kotlinOptions&lt;/code&gt; property of the Kotlin compilation task. For details, see &lt;a href=&quot;using-gradle#compiler-options&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">如果您使用的是Gradle，请在Kotlin编译任务的 &lt;code&gt;kotlinOptions&lt;/code&gt; 属性中指定编译器参数。有关详细信息，请参见《&lt;a href=&quot;using-gradle#compiler-options&quot;&gt;使用Gradle》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7e4c1b85a590c2220f5ee4ee7e8642ea497c364" translate="yes" xml:space="preserve">
          <source>If you're using Maven, specify the compiler arguments in the &lt;code&gt;&amp;lt;configuration&amp;gt;&lt;/code&gt; element of the Maven plugin node. For details, see &lt;a href=&quot;using-maven#specifying-compiler-options&quot;&gt;Using Maven&lt;/a&gt;.</source>
          <target state="translated">如果使用的是Maven，请在Maven插件节点的 &lt;code&gt;&amp;lt;configuration&amp;gt;&lt;/code&gt; 元素中指定编译器参数。有关详细信息，请参见《&lt;a href=&quot;using-maven#specifying-compiler-options&quot;&gt;使用Maven》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51fc2cadbf8df70dee87fb5d749d2ee884d218b0" translate="yes" xml:space="preserve">
          <source>If you're using a generic class whose type parameters haven't been declared in a variant way (either because its authors didn't think of it, or because the type parameters can't have either variance kind because they are used both as parameter types and return types), you can still use it in a variant way thanks to &lt;em&gt;type projection&lt;/em&gt;. The term &quot;projection&quot; refers to the fact that when you do this, you might restrict yourself to using only some of its members - so you're in a sense only seeing a partial, or &quot;projected&quot; version of the class. Let's look again at our &lt;code&gt;Bowl&lt;/code&gt; class, but without the variant interfaces this time:</source>
          <target state="translated">如果您使用的泛型类的类型参数没有以变体的方式声明（要么是因为其作者没有想到它，要么是因为类型参数不能具有任何一种变异类型，因为它们都被用作参数类型和返回类型），由于&lt;em&gt;类型为projection&lt;/em&gt;，您仍然可以以其他方式使用它。术语&amp;ldquo;投影&amp;rdquo;是指这样的事实：执行此操作时，您可能会限制自己仅使用其某些成员-因此，从某种意义上讲，您只能看到类的部分或&amp;ldquo;投影&amp;rdquo;版本。让我们再次看一下 &lt;code&gt;Bowl&lt;/code&gt; 类，但是这次没有变型接口：</target>
        </trans-unit>
        <trans-unit id="f6e51da97890d2ae9ab3d189065498b378cc4fb2" translate="yes" xml:space="preserve">
          <source>If you've got one string that you want to write to a file, overwriting the existing contents if the file already exists, do this (again, UTF-8 is the default encoding):</source>
          <target state="translated">如果你有一个字符串想写入一个文件,如果文件已经存在,就覆盖现有的内容,这样做(同样,UTF-8是默认编码)。</target>
        </trans-unit>
        <trans-unit id="d91079d5275bf77f335cf6cb84c315d0b54d9ee8" translate="yes" xml:space="preserve">
          <source>If you've just upgraded to Kotlin 1.1 but can not use new language features yet (e.g. because some of your teammates may not have upgraded), you can pass &lt;code&gt;-language-version 1.0&lt;/code&gt;, which will restrict all APIs and language features to 1.0.</source>
          <target state="translated">如果您刚刚升级到Kotlin 1.1，但仍不能使用新的语言功能（例如，由于您的某些队友可能尚未升级），则可以传递 &lt;code&gt;-language-version 1.0&lt;/code&gt; ，它将所有API和语言功能限制为1.0。</target>
        </trans-unit>
        <trans-unit id="0bb0fce206872389875749705970d5e6f4cde62d" translate="yes" xml:space="preserve">
          <source>If your Gradle module is a multiplatform module, use the &lt;code&gt;useExperimentalAnnotation&lt;/code&gt; method:</source>
          <target state="translated">如果您的Gradle模块是多平台模块，请使用 &lt;code&gt;useExperimentalAnnotation&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="6a4d49a0aa58db91f5538f1484a110d84d269171" translate="yes" xml:space="preserve">
          <source>If your application already uses DBFlow, you can safely introduce Kotlin into your project. You can gradually convert existing code to Kotlin (ensuring that everything compiles along the way). The converted code doesn't differ much from Java. For instance, declaring a table looks similar to Java with the small difference that default values for properties must be specified explicitly:</source>
          <target state="translated">如果您的应用程序已经使用DBFlow,您可以安全地将Kotlin引入到您的项目中。你可以逐步将现有的代码转换为Kotlin(确保所有的东西都能顺着编译)。转换后的代码与Java没有太大区别。例如,声明一个表看起来与Java相似,但有一点不同,即必须明确指定属性的默认值。</target>
        </trans-unit>
        <trans-unit id="f63962aa6cf85ec6f47c280bebab4a954c284cd2" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, write it inside a companion class:</source>
          <target state="translated">如果你的类需要更高级的序列化逻辑,就把它写在一个同伴类里面。</target>
        </trans-unit>
        <trans-unit id="3503de21b9cb0b7cba965dc4634f2918727f903d" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, you can write it inside a companion class:</source>
          <target state="translated">如果你的类需要更高级的序列化逻辑,你可以把它写在一个同伴类里面。</target>
        </trans-unit>
        <trans-unit id="eacc53066a886e6486df3248d96a52d89fd95863" translate="yes" xml:space="preserve">
          <source>If your code is too clever for the compiler, and you know without the help of &lt;code&gt;is&lt;/code&gt; that &lt;code&gt;x&lt;/code&gt; is an instance of &lt;code&gt;Person&lt;/code&gt; but the compiler doesn't, you can &lt;em&gt;cast&lt;/em&gt; your value with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">如果您的代码对于编译器来说太聪明了，并且您没有 &lt;code&gt;x&lt;/code&gt; 的帮助 &lt;code&gt;is&lt;/code&gt; 知道x是 &lt;code&gt;Person&lt;/code&gt; 的实例，但是编译器却不是，则可以使用 &lt;code&gt;as&lt;/code&gt; &lt;em&gt;强制转换&lt;/em&gt;值：</target>
        </trans-unit>
        <trans-unit id="2ecf8bd14ee3aa94f5fa13c2b5cd616c3b320e5a" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well. The artifact IDs are &lt;code&gt;kotlin-reflect&lt;/code&gt; for the reflection library, and &lt;code&gt;kotlin-test&lt;/code&gt; and &lt;code&gt;kotlin-test-junit&lt;/code&gt; for the testing libraries.</source>
          <target state="translated">如果您的项目使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin反射&lt;/a&gt;或测试工具，则还需要添加相应的依赖项。工件ID 对于反射库是 &lt;code&gt;kotlin-reflect&lt;/code&gt; ,对于 &lt;code&gt;kotlin-test&lt;/code&gt; 库是kotlin-test和 &lt;code&gt;kotlin-test-junit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaffb39c3271a99cd3c6b1dcd26285bb7f6d4133" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well:</source>
          <target state="translated">如果您的项目使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin反射&lt;/a&gt;或测试工具，则还需要添加相应的依赖项：</target>
        </trans-unit>
        <trans-unit id="ff4ecabd35e3e545f9518b5b102d6fa77c32607a" translate="yes" xml:space="preserve">
          <source>If, by any chance, we need &quot;just an object&quot;, with no nontrivial supertypes, we can simply say:</source>
          <target state="translated">如果偶然,我们需要 &quot;只是一个对象&quot;,没有非同寻常的超类型,我们可以简单地说。</target>
        </trans-unit>
        <trans-unit id="f78ba0d5d02014df85f65107c7688ad5093fc4b0" translate="yes" xml:space="preserve">
          <source>If, upon updating from one version to another, some code that used to work doesn't work any more, it is an &lt;em&gt;incompatible change&lt;/em&gt; in the language (sometimes referred to as &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work any more&quot; means precisely in some cases, but it definitely includes the following:</source>
          <target state="translated">如果从一个版本更新到另一个版本后，某些可以正常工作的代码不再起作用，则表示该语言存在&lt;em&gt;不兼容的更改&lt;/em&gt;（有时称为&amp;ldquo;重大更改&amp;rdquo;）。在某些情况下，关于&amp;ldquo;不再有用&amp;rdquo;的确切含义可能存在争议，但肯定包括以下内容：</target>
        </trans-unit>
        <trans-unit id="ea0b39c7ffc510626fe28212437d8a57285e5a4c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException</source>
          <target state="translated">IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="906f0c92cf03edbafe4a5d12e37d92701ba25962" translate="yes" xml:space="preserve">
          <source>IllegalCallableAccessException</source>
          <target state="translated">IllegalCallableAccessException</target>
        </trans-unit>
        <trans-unit id="6bfee05d69b5aa826fde5d373d8ebea121200b58" translate="yes" xml:space="preserve">
          <source>IllegalCharacterConversionException</source>
          <target state="translated">IllegalCharacterConversionException</target>
        </trans-unit>
        <trans-unit id="6d13e3edbafba5c6ba6e57ae6bc8267296d1bf66" translate="yes" xml:space="preserve">
          <source>IllegalPropertyDelegateAccessException</source>
          <target state="translated">IllegalPropertyDelegateAccessException</target>
        </trans-unit>
        <trans-unit id="63b3abc14a5b2c9db143083b94887cb72910c4de" translate="yes" xml:space="preserve">
          <source>IllegalStateException</source>
          <target state="translated">IllegalStateException</target>
        </trans-unit>
        <trans-unit id="0ef9de975cdef9d9d9b896b68103ad59db30e33a" translate="yes" xml:space="preserve">
          <source>ImageBitmap</source>
          <target state="translated">ImageBitmap</target>
        </trans-unit>
        <trans-unit id="33f05a29887232f2adef5f1b64b04d6cf8bd78f2" translate="yes" xml:space="preserve">
          <source>ImageBitmapOptions</source>
          <target state="translated">ImageBitmapOptions</target>
        </trans-unit>
        <trans-unit id="91a39bdc5a33f203d5c2f138f0da931369fac84f" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext</source>
          <target state="translated">ImageBitmapRenderingContext</target>
        </trans-unit>
        <trans-unit id="1a722437bfbd0c07b7f837b5b4332fd5d966ead2" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContextSettings</source>
          <target state="translated">ImageBitmapRenderingContextSettings</target>
        </trans-unit>
        <trans-unit id="b28af413c72a2e03556905d9b27766a80ae5dd7b" translate="yes" xml:space="preserve">
          <source>ImageBitmapSource</source>
          <target state="translated">ImageBitmapSource</target>
        </trans-unit>
        <trans-unit id="682b65e19d67a5e783299b757e21bec2832c6fb5" translate="yes" xml:space="preserve">
          <source>ImageData</source>
          <target state="translated">ImageData</target>
        </trans-unit>
        <trans-unit id="2217055c382ca08984df9c834dee428b5ed7c541" translate="yes" xml:space="preserve">
          <source>ImageOrientation</source>
          <target state="translated">ImageOrientation</target>
        </trans-unit>
        <trans-unit id="3394b71415cd8bd55fc9255b5d6beaf734d6f770" translate="yes" xml:space="preserve">
          <source>ImageSmoothingQuality</source>
          <target state="translated">ImageSmoothingQuality</target>
        </trans-unit>
        <trans-unit id="f98fd49f8f974a3886c42cb3693e5ffdf40539ee" translate="yes" xml:space="preserve">
          <source>Immediate superclasses of this class, in the order they are listed in the source code. Includes superclasses and superinterfaces of the class, but does not include the class itself.</source>
          <target state="translated">该类的直属超类,按照源代码中的顺序排列。包括该类的超类和超接口,但不包括该类本身。</target>
        </trans-unit>
        <trans-unit id="70af22099196223b8485c95684bbf8824a9afa2b" translate="yes" xml:space="preserve">
          <source>Immutability</source>
          <target state="translated">Immutability</target>
        </trans-unit>
        <trans-unit id="bb86d1b762a23d9068f4510901eeff7d18242638" translate="yes" xml:space="preserve">
          <source>Immutability in Kotlin/Native</source>
          <target state="translated">Kotlin/Native中的不可更改性</target>
        </trans-unit>
        <trans-unit id="7f8782e7a667262dd5095f5ff184ddd709f4772b" translate="yes" xml:space="preserve">
          <source>Immutability is a runtime property in Kotlin/Native, and can be applied to an arbitrary object subgraph using the &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; function. It makes all the objects reachable from the given one immutable, such a transition is a one-way operation (i.e., objects cannot be unfrozen later). Some naturally immutable objects such as &lt;code&gt;kotlin.String&lt;/code&gt;, &lt;code&gt;kotlin.Int&lt;/code&gt;, and other primitive types, along with &lt;code&gt;AtomicInt&lt;/code&gt; and &lt;code&gt;AtomicReference&lt;/code&gt; are frozen by default. If a mutating operation is applied to a frozen object, an &lt;code&gt;InvalidMutabilityException&lt;/code&gt; is thrown.</source>
          <target state="translated">不可变性是Kotlin / Native中的运行时属性，可以使用 &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; 函数将其应用于任意对象子图。它使所有对象都可以从给定的一个对象变为不可变的对象，这样的转换是单向操作（即，以后不能解冻对象）。默认情况下会冻结一些自然不可变的对象，例如 &lt;code&gt;kotlin.String&lt;/code&gt; ， &lt;code&gt;kotlin.Int&lt;/code&gt; 和其他原始类型，以及 &lt;code&gt;AtomicInt&lt;/code&gt; 和 &lt;code&gt;AtomicReference&lt;/code&gt; 。如果对冻结对象执行了变异操作， &lt;code&gt;InvalidMutabilityException&lt;/code&gt; 抛出InvalidMutabilityException。</target>
        </trans-unit>
        <trans-unit id="ed22a68de3c3f3cb15e1268df39db4a167fd746d" translate="yes" xml:space="preserve">
          <source>ImmutableBlob</source>
          <target state="translated">ImmutableBlob</target>
        </trans-unit>
        <trans-unit id="575d550105355ba3be5a6608f83817426c2bd97c" translate="yes" xml:space="preserve">
          <source>Imperative finally block</source>
          <target state="translated">势在必行</target>
        </trans-unit>
        <trans-unit id="56a6489b53e94ff44d4b5586ba1f1332d73844a1" translate="yes" xml:space="preserve">
          <source>Imperative versus declarative</source>
          <target state="translated">祈使式与陈述式</target>
        </trans-unit>
        <trans-unit id="ee7341a728a58d68c7532bf18aeb0fac4452b6b5" translate="yes" xml:space="preserve">
          <source>Implementation by Delegation</source>
          <target state="translated">授权实施</target>
        </trans-unit>
        <trans-unit id="c0f0a132ab68a72286213758ce660b7e042cb87b" translate="yes" xml:space="preserve">
          <source>Implementation note: the current reading value is stored as a &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number of nanoseconds, thus it's capable to represent a time range of approximately &amp;plusmn;292 years. Should the reading value overflow as the result of &lt;a href=&quot;plus-assign&quot;&gt;plusAssign&lt;/a&gt; operation, an &lt;a href=&quot;../../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; is thrown.</source>
          <target state="translated">实施注意事项：当前读数值存储为&lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;长&lt;/a&gt;数纳秒，因此它可以表示大约&amp;plusmn;292年的时间范围。如果&lt;a href=&quot;plus-assign&quot;&gt;plusAssign&lt;/a&gt;操作导致读取值溢出，则抛出&lt;a href=&quot;../../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc1735ad8ce42355f885445d5ba551e409b9c86b" translate="yes" xml:space="preserve">
          <source>Implementations of the interface can override default methods.</source>
          <target state="translated">接口的实现可以覆盖默认方法。</target>
        </trans-unit>
        <trans-unit id="00d5f96768fee4f4899fb4ea94381d1c87db0a66" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces</source>
          <target state="translated">实现接口</target>
        </trans-unit>
        <trans-unit id="d640e1d5eb2b7a283f3bc3070dd151afc512fb6c" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces in Enum Classes</source>
          <target state="translated">在Enum类中实现接口</target>
        </trans-unit>
        <trans-unit id="b2153d6fa67762548da1f8fe28f3d481ede48834" translate="yes" xml:space="preserve">
          <source>Implements the core logic of a property delegate for a read/write property that calls callback functions when changed.</source>
          <target state="translated">实现了读/写属性委托的核心逻辑,当属性改变时调用回调函数。</target>
        </trans-unit>
        <trans-unit id="b1af49118602d4ab9bd26831d35fc303f95ea13f" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">隐含 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="febd7a841f47bb67cef7b18f13ac806c637192b6" translate="yes" xml:space="preserve">
          <source>Important: files marked with &lt;code&gt;@file:JsModule&lt;/code&gt; annotation can't declare non-external members. The example below produces compile-time error:</source>
          <target state="translated">重要：标有 &lt;code&gt;@file:JsModule&lt;/code&gt; 批注的文件不能声明非外部成员。下面的示例产生编译时错误：</target>
        </trans-unit>
        <trans-unit id="e45479a7a7959d4875b5ea4acddae533ace5e782" translate="yes" xml:space="preserve">
          <source>Importing deeper package hierarchies</source>
          <target state="translated">导入更深层次的包层次结构</target>
        </trans-unit>
        <trans-unit id="a932c1ce87f097109d85ae710ba5975b2888a20e" translate="yes" xml:space="preserve">
          <source>Importing synthetic properties</source>
          <target state="translated">导入合成属性</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="3b7090ba2b2cc222b6a645f1eb051b20d9654d8e" translate="yes" xml:space="preserve">
          <source>Improved *.gradle.kts support in the IDE</source>
          <target state="translated">改进了IDE中对*.gradle.kts的支持。</target>
        </trans-unit>
        <trans-unit id="513df22c9887b1f085e00ef3b729d3f007cfd9d9" translate="yes" xml:space="preserve">
          <source>Improved import handling</source>
          <target state="translated">改进的导入处理</target>
        </trans-unit>
        <trans-unit id="315a432d3c7693ed151796f4c20766973b95d237" translate="yes" xml:space="preserve">
          <source>Improved management for npm dependencies, with mandatory version numbers or &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;semver&lt;/a&gt; version ranges, as well as support for &lt;em&gt;development&lt;/em&gt;, &lt;em&gt;peer&lt;/em&gt;, and &lt;em&gt;optional&lt;/em&gt; npm dependencies using &lt;code&gt;devNpm&lt;/code&gt;, &lt;code&gt;optionalNpm&lt;/code&gt; and &lt;code&gt;peerNpm&lt;/code&gt;. Read more about dependency management for npm packages directly from Gradle &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">改进了对npm依赖项的管理，具有必需的版本号或&lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;semver&lt;/a&gt;版本范围，并使用 &lt;code&gt;devNpm&lt;/code&gt; ， &lt;code&gt;optionalNpm&lt;/code&gt; 和 &lt;code&gt;peerNpm&lt;/code&gt; 支持&lt;em&gt;开发&lt;/em&gt;，&lt;em&gt;peer&lt;/em&gt;和&lt;em&gt;可选的&lt;/em&gt;npm依赖项。了解更多关于依赖管理直接从摇篮NPM包&lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;在这里&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd53d3f3315c4c0f3364235c04212b30cd118e2f" translate="yes" xml:space="preserve">
          <source>Improved support for Kotlin Gradle DSL in the IDE</source>
          <target state="translated">改进了IDE中对Kotlin Gradle DSL的支持。</target>
        </trans-unit>
        <trans-unit id="d8972a1f28a588591d73ee09ddd836428eaca222" translate="yes" xml:space="preserve">
          <source>Improving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:</source>
          <target state="translated">通过声明函数的调用结果和传递的参数值之间的关系,改进智能广播分析。</target>
        </trans-unit>
        <trans-unit id="c202358d520e5f37257d179570305668ee990cdc" translate="yes" xml:space="preserve">
          <source>Improving the existing API</source>
          <target state="translated">改进现有的API</target>
        </trans-unit>
        <trans-unit id="3ea84fc4dca92bbd95cba0393e768bc0dbac665a" translate="yes" xml:space="preserve">
          <source>Improving the variable initialization analysis in the presence of high-order functions:</source>
          <target state="translated">改进高阶函数存在下的变量初始化分析。</target>
        </trans-unit>
        <trans-unit id="1a9aa64fd2cf728e6a54a37ad269e224c4406ae7" translate="yes" xml:space="preserve">
          <source>In &quot;clever words&quot; they say that the class &lt;code&gt;C&lt;/code&gt; is &lt;strong&gt;covariant&lt;/strong&gt; in the parameter &lt;code&gt;T&lt;/code&gt;, or that &lt;code&gt;T&lt;/code&gt; is a &lt;strong&gt;covariant&lt;/strong&gt; type parameter. You can think of &lt;code&gt;C&lt;/code&gt; as being a &lt;strong&gt;producer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s, and NOT a &lt;strong&gt;consumer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s.</source>
          <target state="translated">在&amp;ldquo;灵巧的词&amp;rdquo;中，他们说类别 &lt;code&gt;C&lt;/code&gt; 在参数 &lt;code&gt;T&lt;/code&gt; 中是&lt;strong&gt;协变&lt;/strong&gt;的，或者 &lt;code&gt;T&lt;/code&gt; 是&lt;strong&gt;协变&lt;/strong&gt;类型参数。你可以认为 &lt;code&gt;C&lt;/code&gt; 作为一个&lt;strong&gt;制片人&lt;/strong&gt;的 &lt;code&gt;T&lt;/code&gt; 的，而不是一个&lt;strong&gt;消费者&lt;/strong&gt;的 &lt;code&gt;T&lt;/code&gt; 的。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6019b82a793e669523c1435271b5d51f4ccb4ffc" translate="yes" xml:space="preserve">
          <source>In 1.3 we reworked the entire multiplatform model. The &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;new DSL&lt;/a&gt; we have for describing multiplatform Gradle projects is much more flexible, and we'll keep working on it to make project configuration straightforward.</source>
          <target state="translated">在1.3中，我们重新设计了整个多平台模型。我们用于描述多平台Gradle项目的&lt;a href=&quot;building-mpp-with-gradle&quot;&gt;新DSL&lt;/a&gt;更加灵活，我们将继续致力于使项目配置变得简单明了。</target>
        </trans-unit>
        <trans-unit id="08f9bdd95bef61c2c357a6e138e1e9a913682812" translate="yes" xml:space="preserve">
          <source>In 1.3, we've completely reworked the model of multiplatform projects in order to improve expressiveness and flexibility, and to make sharing common code easier. Also, Kotlin/Native is now supported as one of the targets!</source>
          <target state="translated">在1.3版本中,我们对多平台项目的模型进行了彻底的重构,以提高表现力和灵活性,并使共享通用代码变得更加容易。另外,现在Kotlin/Native也被支持为目标之一了!</target>
        </trans-unit>
        <trans-unit id="213381945926ceb74a0743ef803e1aae21bbb519" translate="yes" xml:space="preserve">
          <source>In 1.3.70 we introduced two new features for improving the performance of Kotlin/Native compilation: &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native&quot;&gt;caching project dependencies and running the compiler from the Gradle daemon&lt;/a&gt;. Since that time, we&amp;rsquo;ve managed to fix numerous issues and improve the overall stability of these features.</source>
          <target state="translated">在1.3.70中，我们引入了两个新功能来提高Kotlin / Native编译的性能：&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native&quot;&gt;缓存项目依赖项和从Gradle守护程序运行编译器&lt;/a&gt;。自那时以来，我们设法解决了许多问题并提高了这些功能的整体稳定性。</target>
        </trans-unit>
        <trans-unit id="f8879cf64a06b7b628772713a32dffa84200aa1c" translate="yes" xml:space="preserve">
          <source>In 1.4.0, Kotlin/Native got a significant number of new features and improvements, including:</source>
          <target state="translated">在1.4.0中,Kotlin/Native得到了大量的新特性和改进,包括。</target>
        </trans-unit>
        <trans-unit id="a15eb3cdff900df751ecc01f9df494a4b1d439fc" translate="yes" xml:space="preserve">
          <source>In 1.4.0, scripting in Kotlin benefits from a number of functional and performance improvements along with other updates. Here are some of the key changes:</source>
          <target state="translated">在1.4.0中,Kotlin中的脚本得益于一系列功能和性能的改进以及其他更新。以下是一些关键的变化。</target>
        </trans-unit>
        <trans-unit id="2f9c2fe76d2a17f7c4f9ec731f1abfee212c135b" translate="yes" xml:space="preserve">
          <source>In 1.4.0, the standard library includes a number of useful functions for working with &lt;strong&gt;collections&lt;/strong&gt;:</source>
          <target state="translated">在1.4.0版中，标准库包含许多有用的用于处理&lt;strong&gt;集合的&lt;/strong&gt;函数：</target>
        </trans-unit>
        <trans-unit id="033b388a365ea25e3654d39784a4aac0e59b6a41" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we add the basic support for suspending functions in Swift and Objective-C. Now, when you compile a Kotlin module into an Apple framework, suspending functions are available in it as functions with callbacks (&lt;code&gt;completionHandler&lt;/code&gt; in the Swift/Objective-C terminology). When you have such functions in the generated framework&amp;rsquo;s header, you can call them from your Swift or Objective-C code and even override them.</source>
          <target state="translated">在1.4.0中，我们添加了对Swift和Objective-C中的挂起函数的基本支持。现在，当你编译科特林模块放入苹果的框架，悬挂功能是它可以作为与回调函数（ &lt;code&gt;completionHandler&lt;/code&gt; 在斯威夫特/ Objective-C的术语）。当在生成的框架的标头中具有此类函数时，可以从您的Swift或Objective-C代码中调用它们，甚至覆盖它们。</target>
        </trans-unit>
        <trans-unit id="4a6df711b0b9f7fdf8c3bc58b1703c03d295ebc7" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we continued improving the IDE support for Gradle Kotlin DSL scripts (&lt;code&gt;*.gradle.kts&lt;/code&gt; files). Here is what the new version brings:</source>
          <target state="translated">在1.4.0中，我们继续改进对Gradle Kotlin DSL脚本（ &lt;code&gt;*.gradle.kts&lt;/code&gt; 文件）的IDE支持。这是新版本带来的：</target>
        </trans-unit>
        <trans-unit id="eac832f0ecfb5c80421d8f75ff875507a4728bfb" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we have added new features to improve your experience with delegated properties in Kotlin:</source>
          <target state="translated">在1.4.0中,我们增加了新的功能,以改善您在Kotlin中使用委托属性的体验。</target>
        </trans-unit>
        <trans-unit id="3d296b88303d152ba0a9aadb06847e0102aa46ad" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we slightly change the Swift API generated from Kotlin with respect to the way exceptions are translated. There is a fundamental difference in error handling between Kotlin and Swift. All Kotlin exceptions are unchecked, while Swift has only checked errors. Thus, to make Swift code aware of expected exceptions, Kotlin functions should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of potential exception classes.</source>
          <target state="translated">在1.4.0中，相对于异常的转换方式，我们略微更改了Kotlin生成的Swift API。 Kotlin和Swift之间在错误处理方面有根本的区别。所有Kotlin异常均未选中，而Swift仅检查了错误。因此，为了使Swift代码了解预期的异常，应该用 &lt;code&gt;@Throws&lt;/code&gt; 批注标记Kotlin函数，该批注指定潜在异常类的列表。</target>
        </trans-unit>
        <trans-unit id="939973482b04c9dfe37b17beb6dea441e65e3874" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we&amp;rsquo;ve introduced a new API for resolving external dependencies (such as Maven artifacts), along with implementations for it. This API is published in the new artifacts &lt;code&gt;kotlin-scripting-dependencies&lt;/code&gt; and &lt;code&gt;kotlin-scripting-dependencies-maven&lt;/code&gt;. The previous dependency resolution functionality in &lt;code&gt;kotlin-script-util&lt;/code&gt; library is now deprecated.</source>
          <target state="translated">在1.4.0中，我们引入了一个新的API来解决外部依赖关系（例如Maven工件）及其实现。该API已发布在新的工件 &lt;code&gt;kotlin-scripting-dependencies&lt;/code&gt; 和 &lt;code&gt;kotlin-scripting-dependencies-maven&lt;/code&gt; 中。 &lt;code&gt;kotlin-script-util&lt;/code&gt; 库中以前的依赖关系解析功能现已弃用。</target>
        </trans-unit>
        <trans-unit id="2fe67da7ef7bd9edb03b06fd394c5b605f7d8102" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we've added a new mode for generating default methods: &lt;code&gt;-Xjvm-default=all&lt;/code&gt; compiles &lt;em&gt;all&lt;/em&gt; non-abstract methods of Kotlin interfaces to &lt;code&gt;default&lt;/code&gt; Java methods. For compatibility with the code that uses the interfaces compiled without &lt;code&gt;default&lt;/code&gt;, we also added &lt;code&gt;all-compatibility&lt;/code&gt; mode.</source>
          <target state="translated">在1.4.0中，我们添加了一种用于生成默认方法的新模式： &lt;code&gt;-Xjvm-default=all&lt;/code&gt; 将Kotlin接口的&lt;em&gt;所有&lt;/em&gt;非抽象方法编译为 &lt;code&gt;default&lt;/code&gt; Java方法。为了与使用未经 &lt;code&gt;default&lt;/code&gt; 编译的接口的代码兼容，我们还添加了 &lt;code&gt;all-compatibility&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="5745802255877abfa046b72cbccdadc8221d5622" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering&lt;/a&gt;, we describe operations that retrieve collection elements in specific orders. For mutable lists, the standard library offers similar extension functions that perform the same ordering operations in place. When you apply such an operation to a list instance, it changes the order of elements in that exact instance.</source>
          <target state="translated">在&lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering中&lt;/a&gt;，我们描述了按特定顺序检索集合元素的操作。对于可变列表，标准库提供了类似的扩展功能，这些扩展功能可以执行相同的排序操作。当您将此类操作应用于列表实例时，它将更改该确切实例中元素的顺序。</target>
        </trans-unit>
        <trans-unit id="be8a31aea4fdca8e3b9bdedb1958918e98cae1d2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collections-overview#map&quot;&gt;maps&lt;/a&gt;, types of both keys and values are user-defined. Key-based access to map entries enables various map-specific processing capabilities from getting a value by key to separate filtering of keys and values. On this page, we provide descriptions of the map processing functions from the standard library.</source>
          <target state="translated">在&lt;a href=&quot;collections-overview#map&quot;&gt;map中&lt;/a&gt;，键和值的类型都是用户定义的。对地图条目的基于键的访问启用了各种特定于地图的处理功能，从按键获取值到对键和值进行单独过滤。在此页面上，我们提供了来自标准库的地图处理功能的描述。</target>
        </trans-unit>
        <trans-unit id="7454358e40f9eaf26ccc7cd55f4c30f555918de5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;the previous tutorial&lt;/a&gt; we created a &lt;code&gt;lib.h&lt;/code&gt; file. This time, we are going to include those declarations directly into the &lt;code&gt;interop.def&lt;/code&gt; file, after the &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">在&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;上一个教程中，&lt;/a&gt;我们创建了一个 &lt;code&gt;lib.h&lt;/code&gt; 文件。这次，我们将在 &lt;code&gt;---&lt;/code&gt; 分隔符行之后将这些声明直接包含在 &lt;code&gt;interop.def&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="f0454a21172602b262219293f4778fc730c2daf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;build.gradle.kts&lt;/code&gt; (or &lt;code&gt;build.gradle&lt;/code&gt;) of your IDEA project, apply the CocoaPods plugin as well as the Kotlin Multiplatform plugin.</source>
          <target state="translated">在您的IDEA项目的 &lt;code&gt;build.gradle.kts&lt;/code&gt; （或 &lt;code&gt;build.gradle&lt;/code&gt; ）中，应用CocoaPods插件以及Kotlin Multiplatform插件。</target>
        </trans-unit>
        <trans-unit id="4f2d8d96fc34753484a87526254e4a4f003f9c05" translate="yes" xml:space="preserve">
          <source>In Android projects, additional Kotlin source sets are created for each &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android source set&lt;/a&gt;. If the Android target has a name &lt;code&gt;foo&lt;/code&gt;, the Android source set &lt;code&gt;bar&lt;/code&gt; gets a Kotlin source set counterpart &lt;code&gt;fooBar&lt;/code&gt;. The Kotlin compilations, however, are able to consume Kotlin sources from all of the directories &lt;code&gt;src/bar/java&lt;/code&gt;, &lt;code&gt;src/bar/kotlin&lt;/code&gt;, and &lt;code&gt;src/fooBar/kotlin&lt;/code&gt;. Java sources are only read from the first of these directories.</source>
          <target state="translated">在Android项目中，会为每个&lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android源集&lt;/a&gt;创建其他Kotlin源集。如果Android目标的名称为 &lt;code&gt;foo&lt;/code&gt; ，则Android源代码集 &lt;code&gt;bar&lt;/code&gt; 将获取Kotlin源集合对应项 &lt;code&gt;fooBar&lt;/code&gt; 。但是，Kotlin编译能够使用所有目录 &lt;code&gt;src/bar/java&lt;/code&gt; ， &lt;code&gt;src/bar/kotlin&lt;/code&gt; 和 &lt;code&gt;src/fooBar/kotlin&lt;/code&gt; 的 Kotlin源。仅从这些目录中的第一个读取Java源。</target>
        </trans-unit>
        <trans-unit id="257732c8dc478843fa9cbb50bd51c9bd28228b70" translate="yes" xml:space="preserve">
          <source>In Android, make sure you use the Android Gradle plugin version 3.2 or higher, which can correctly process jar files with module-info.</source>
          <target state="translated">在安卓系统中,请确保使用安卓Gradle插件3.2或更高版本,它可以正确处理带有module-info的jar文件。</target>
        </trans-unit>
        <trans-unit id="33342ff8fe9e060731185ad7c136d99b9461055f" translate="yes" xml:space="preserve">
          <source>In Gradle</source>
          <target state="translated">在Gradle中</target>
        </trans-unit>
        <trans-unit id="9ffad76a20436e6770075c18f7fc5a623588a28f" translate="yes" xml:space="preserve">
          <source>In Gradle 5.3 and above, the module metadata is always used during dependency resolution, but publications don't include any module metadata by default. To enable module metadata publishing, add &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; to the root project's &lt;code&gt;settings.gradle&lt;/code&gt; file. With older Gradle versions, this is also required for module metadata consumption.</source>
          <target state="translated">在Gradle 5.3及更高版本中，模块元数据始终在依赖关系解析期间使用，但默认情况下发布不包含任何模块元数据。要启用模块元数据发布，请将 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 到根项目的 &lt;code&gt;settings.gradle&lt;/code&gt; 文件中。对于较旧的Gradle版本，模块元数据消耗也需要此功能。</target>
        </trans-unit>
        <trans-unit id="689d572315ca41a5147e4a6e26331b2145e72a29" translate="yes" xml:space="preserve">
          <source>In Gradle 6.0 and above, you can explicitly apply changes by clicking &lt;strong&gt;Load Gradle Changes&lt;/strong&gt; or by reimporting the Gradle project.</source>
          <target state="translated">在Gradle 6.0及更高版本中，您可以通过单击&amp;ldquo;&lt;strong&gt;加载Gradle更改&amp;rdquo;&lt;/strong&gt;或重新导入Gradle项目来显式应用更改。</target>
        </trans-unit>
        <trans-unit id="db8d93f584f6cd9be9c19cceb09290c42348f8b6" translate="yes" xml:space="preserve">
          <source>In Gradle command line parameters: add the parameter &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; or &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; with the boolean value reflecting the usage of incremental compilation. Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">在Gradle命令行参数中：添加参数 &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; 或 &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; ，其布尔值反映增量编译的用法。请注意，在这种情况下，应将参数添加到每个后续构建中，并且任何禁用了增量编译的构建都会使增量缓存无效。</target>
        </trans-unit>
        <trans-unit id="d95af6982c4662ae34dc8dfd04c6f3d77bb71544" translate="yes" xml:space="preserve">
          <source>In Gradle configuration files: add the line &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JVM or &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JS projects either to &lt;code&gt;gradle.properties&lt;/code&gt; or to &lt;code&gt;local.properties&lt;/code&gt; file. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is a boolean value reflecting the usage of incremental compilation.</source>
          <target state="translated">在摇篮配置文件：添加行 &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; 为科特林/ JVM或 &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; 为科特林/ JS项目要么 &lt;code&gt;gradle.properties&lt;/code&gt; 或 &lt;code&gt;local.properties&lt;/code&gt; 文件。 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 是一个布尔值，反映了增量编译的用法。</target>
        </trans-unit>
        <trans-unit id="1f0dee881e670d1f97f2d917d6284d13c20aff3f" translate="yes" xml:space="preserve">
          <source>In Gradle versions earlier than 6.0, you need to manually load the script configuration by clicking &lt;strong&gt;Load Configuration&lt;/strong&gt; in the editor.</source>
          <target state="translated">在低于6.0的Gradle版本中，您需要通过在编辑器中单击&amp;ldquo;&lt;strong&gt;加载配置&amp;rdquo;&lt;/strong&gt;来手动加载脚本配置。</target>
        </trans-unit>
        <trans-unit id="537c1a3af537507e4b627b3261006ddbdae522fd" translate="yes" xml:space="preserve">
          <source>In Gradle:</source>
          <target state="translated">在Gradle。</target>
        </trans-unit>
        <trans-unit id="d2d1d0c783432497ec07d157b951c4e78d7cc0b8" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt; and check the &lt;em&gt;Create from archetype&lt;/em&gt; box:</source>
          <target state="translated">在IntelliJ IDEA中，转到&lt;em&gt;File-&amp;gt; New&amp;gt; Project&amp;hellip;，&lt;/em&gt;然后选中&lt;em&gt;Create from archetype&lt;/em&gt;框：</target>
        </trans-unit>
        <trans-unit id="4d485a76c7a3760895d18fab529fc51f77b28063" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt;:</source>
          <target state="translated">在IntelliJ IDEA中，转到&lt;em&gt;File-&amp;gt; New&amp;gt; Project&amp;hellip;&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="1602732a6a8d6badfddfb46b91b51e47005a6da3" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA, select &lt;strong&gt;File&lt;/strong&gt; | &lt;strong&gt;New&lt;/strong&gt; | &lt;strong&gt;Project&lt;/strong&gt;.</source>
          <target state="translated">在IntelliJ IDEA中，选择&lt;strong&gt;File&lt;/strong&gt; | &lt;strong&gt;File&lt;/strong&gt;。&lt;strong&gt;新增&lt;/strong&gt;| &lt;strong&gt;项目&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c5abe7664486d0a3820c82f8b82f8f0d75b700ae" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA, write in the compiler arguments in the &lt;strong&gt;Additional command-line parameters&lt;/strong&gt; text box in &lt;strong&gt;Settings | Build, Execution, Deployment | Compilers | Kotlin Compiler&lt;/strong&gt;</source>
          <target state="translated">在IntelliJ IDEA中，在&lt;strong&gt;&amp;ldquo;设置&amp;rdquo; |&amp;ldquo;设置&amp;rdquo; |&lt;/strong&gt; &amp;ldquo;&lt;strong&gt;附加命令行参数&amp;rdquo;&lt;/strong&gt;文本框中输入编译器参数。&lt;strong&gt;构建，执行，部署| 编译器| Kotlin编译器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cc14db5a6e801d7da035df405c7d7827fc53b41" translate="yes" xml:space="preserve">
          <source>In JVM platform code:</source>
          <target state="translated">在JVM平台代码中。</target>
        </trans-unit>
        <trans-unit id="513ad5f28a98a53d38c2cd4b1ebf3e53ba78a0e9" translate="yes" xml:space="preserve">
          <source>In Java you specify &lt;code&gt;Dagger&lt;/code&gt; as &lt;code&gt;annotationProcessor&lt;/code&gt; (or &lt;code&gt;apt&lt;/code&gt;) dependency:</source>
          <target state="translated">在Java中，您将 &lt;code&gt;Dagger&lt;/code&gt; 指定为 &lt;code&gt;annotationProcessor&lt;/code&gt; （或 &lt;code&gt;apt&lt;/code&gt; ）依赖项：</target>
        </trans-unit>
        <trans-unit id="e76e330054ec3492dbde5d95b20d3d1c9ac12e6f" translate="yes" xml:space="preserve">
          <source>In Java, we are used to classes named &quot;*Utils&quot;: &lt;code&gt;FileUtils&lt;/code&gt;, &lt;code&gt;StringUtils&lt;/code&gt; and so on. The famous &lt;code&gt;java.util.Collections&lt;/code&gt; belongs to the same breed. And the unpleasant part about these Utils-classes is that the code that uses them looks like this:</source>
          <target state="translated">在Java中，我们习惯于使用名为&amp;ldquo; * Utils&amp;rdquo;的类： &lt;code&gt;FileUtils&lt;/code&gt; ， &lt;code&gt;StringUtils&lt;/code&gt; 等。著名的 &lt;code&gt;java.util.Collections&lt;/code&gt; 属于同一品种。关于这些Utils类的不愉快的部分是使用它们的代码看起来像这样：</target>
        </trans-unit>
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">在Java中。</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">在JavaScript中,你可以在原型或类本身定义成员。即..:</target>
        </trans-unit>
        <trans-unit id="592ce5c07c0fe6dc9a4e0ec16760d4af84a287b3" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself:</source>
          <target state="translated">在JavaScript中,你可以在原型或类本身定义成员。</target>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在Kotlin 1.0中，传递给 &lt;code&gt;td&lt;/code&gt; 的lambda中的代码可以访问三个隐式接收器：一个传递给 &lt;code&gt;table&lt;/code&gt; ， &lt;code&gt;tr&lt;/code&gt; 和 &lt;code&gt;td&lt;/code&gt; 。这使您可以调用在上下文中没有意义的方法，例如，在 &lt;code&gt;td&lt;/code&gt; 内部调用 &lt;code&gt;tr&lt;/code&gt; ，从而在 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 中放置 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">在Kotlin 1.1中，您可以对此进行限制，以便在传递给 &lt;code&gt;td&lt;/code&gt; 的lambda内只有在 &lt;code&gt;td&lt;/code&gt; 的隐式接收器上定义的方法才可用。为此，您可以定义带有 &lt;code&gt;@DslMarker&lt;/code&gt; 元注释的注释，并将其应用于标签类的基类。</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">在Kotlin 1.1.x中，请改用 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">在Kotlin 1.3中,注释可以有嵌套的类、接口、对象和同伴。</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">在Kotlin 1.3中，现在可以将 &lt;code&gt;when&lt;/code&gt; 主题捕获为变量：</target>
        </trans-unit>
        <trans-unit id="5f37a85c51fbb026184df241508ddfb560773d59" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, the last expression inside a lambda wasn&amp;rsquo;t smart cast unless you specified the expected type. Thus, in the following example, Kotlin 1.3 infers &lt;code&gt;String?&lt;/code&gt; as the type of the &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">在Kotlin 1.3中，除非您指定期望的类型，否则lambda内的最后一个表达式不是明智的强制转换。因此，在以下示例中，Kotlin 1.3推断 &lt;code&gt;String?&lt;/code&gt; 作为 &lt;code&gt;result&lt;/code&gt; 变量的类型：</target>
        </trans-unit>
        <trans-unit id="22e077400784df8fb4e1901ad7292c2554138fbc" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, when you called a function with &lt;a href=&quot;functions#named-arguments&quot;&gt;named arguments&lt;/a&gt;, you had to place all the arguments without names (positional arguments) before the first named argument. For example, you could call &lt;code&gt;f(1, y = 2)&lt;/code&gt;, but you couldn't call &lt;code&gt;f(x = 1, 2)&lt;/code&gt;.</source>
          <target state="translated">在Kotlin 1.3中，当您调用带有&lt;a href=&quot;functions#named-arguments&quot;&gt;命名实&lt;/a&gt;参的函数时，必须将所有不带名称的实参（位置实参）放在第一个命名实参之前。例如，您可以调用 &lt;code&gt;f(1, y = 2)&lt;/code&gt; ，但不能调用 &lt;code&gt;f(x = 1, 2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a475b20752c24d40f5224875251af51b65720545" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you could not use unqualified &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; inside &lt;code&gt;when&lt;/code&gt; expressions included in loops. The reason was that these keywords were reserved for possible &lt;a href=&quot;https://en.wikipedia.org/wiki/Switch_statement#Fallthrough&quot;&gt;fall-through behavior&lt;/a&gt; in &lt;code&gt;when&lt;/code&gt; expressions.</source>
          <target state="translated">在Kotlin 1.3中， &lt;code&gt;when&lt;/code&gt; 表达式包含在循环中时，您不能使用不合格的 &lt;code&gt;break&lt;/code&gt; 并在内部 &lt;code&gt;continue&lt;/code&gt; 。其原因是，这些关键字都留给了可能&lt;a href=&quot;https://en.wikipedia.org/wiki/Switch_statement#Fallthrough&quot;&gt;落空行为&lt;/a&gt;的 &lt;code&gt;when&lt;/code&gt; 表情。</target>
        </trans-unit>
        <trans-unit id="b974ce10e6832a604b02d997fda0b13d1262981d" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you couldn&amp;rsquo;t access a member reference of a smart cast type. Now in Kotlin 1.4 you can:</source>
          <target state="translated">在Kotlin 1.3中，您无法访问智能类型转换的成员引用。现在在Kotlin 1.4中，您可以：</target>
        </trans-unit>
        <trans-unit id="59a10d530fe4140dc151e0b8f7cbd865add4eedd" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you needed to introduce an explicit lambda parameter or replace &lt;code&gt;to&lt;/code&gt; with a &lt;code&gt;Pair&lt;/code&gt; constructor with explicit generic arguments to make it work.</source>
          <target state="translated">在Kotlin 1.3中，您需要引入一个显式的lambda参数或将其替换 &lt;code&gt;to&lt;/code&gt; 具有显式的通用参数的 &lt;code&gt;Pair&lt;/code&gt; 构造函数，以使其起作用。</target>
        </trans-unit>
        <trans-unit id="459625eab3e8c1c93d88f051a772819b50973feb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you often needed to add explicit casts (either &lt;code&gt;!!&lt;/code&gt; or type casts like &lt;code&gt;as String&lt;/code&gt;) to make such cases work, and now these casts have become unnecessary.</source>
          <target state="translated">在Kotlin 1.3中，您经常需要添加显式强制转换（ &lt;code&gt;!!&lt;/code&gt; 或键入诸如 &lt;code&gt;as String&lt;/code&gt; 类的强制转换）以使这种情况起作用，现在这些强制转换已不再需要。</target>
        </trans-unit>
        <trans-unit id="b1e46759775714e2bcf79ff28b8ed72dd56567d1" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you would have had to declare the function &lt;code&gt;foo&lt;/code&gt; above in Java code to perform a SAM conversion.</source>
          <target state="translated">在Kotlin 1.3中，您必须在Java代码中声明上面的函数 &lt;code&gt;foo&lt;/code&gt; 才能执行SAM转换。</target>
        </trans-unit>
        <trans-unit id="4780e01f08d257fbc2b0ac706bfcbbb52154825a" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, debugging coroutines is now much more convenient with the new functionality shipped with the Kotlin plugin.</source>
          <target state="translated">在Kotlin 1.4中,通过Kotlin插件提供的新功能,调试coroutine变得更加方便。</target>
        </trans-unit>
        <trans-unit id="c83ca71d5cf2a3ede274dccc4461018d08bea733" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, thanks to the new inference algorithm, the last expression inside a lambda gets smart cast, and this new, more precise type is used to infer the resulting lambda type. Thus, the type of the &lt;code&gt;result&lt;/code&gt; variable becomes &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">在Kotlin 1.4中，由于使用了新的推理算法，lambda中的最后一个表达式得到了智能转换，并且此新的，更精确的类型用于推断所得的lambda类型。因此， &lt;code&gt;result&lt;/code&gt; 变量的类型变为 &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c138e260059efc2e42dd28d292a8e504c0bd71f8" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, there is no such limitation &amp;ndash; you can now specify a name for an argument in the middle of a set of positional arguments. Moreover, you can mix positional and named arguments any way you like, as long as they remain in the correct order.</source>
          <target state="translated">在Kotlin 1.4中，没有这种限制-您现在可以在一组位置参数的中间为参数指定名称。此外，您可以按自己喜欢的方式混合使用位置参数和命名参数，只要它们保持正确的顺序即可。</target>
        </trans-unit>
        <trans-unit id="17850e337195432d24d049a8cddcfff57e5bda7d" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; without labels inside &lt;code&gt;when&lt;/code&gt; expressions included in loops. They behave as expected by terminating the nearest enclosing loop or proceeding to its next step.</source>
          <target state="translated">在Kotlin 1.4中， &lt;code&gt;when&lt;/code&gt; 表达式包含在循环中时，您可以使用 &lt;code&gt;break&lt;/code&gt; 并 &lt;code&gt;continue&lt;/code&gt; 而无需在内部添加标签。它们通过终止最近的封闭循环或进行下一步来达到预期的效果。</target>
        </trans-unit>
        <trans-unit id="a91dfb7becc799d0a4c9f2c3750f3bb6f56f95da" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use Java SAM interfaces in Kotlin and apply SAM conversions to them.</source>
          <target state="translated">在Kotlin 1.4中,您可以在Kotlin中使用Java SAM接口,并将SAM转换应用于它们。</target>
        </trans-unit>
        <trans-unit id="3bcf048388e07b049f121a6138fdee8bc3c8bbd0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use callable references to functions returning any type in &lt;code&gt;Unit&lt;/code&gt;-returning functions. Before Kotlin 1.4, you could only use lambda arguments in this case. Now you can use both lambda arguments and callable references.</source>
          <target state="translated">在Kotlin 1.4中，您可以将可调用引用用于在 &lt;code&gt;Unit&lt;/code&gt; 返回函数中返回任何类型的函数。在Kotlin 1.4之前，您只能在这种情况下使用lambda参数。现在，您可以同时使用lambda参数和可调用引用。</target>
        </trans-unit>
        <trans-unit id="4d6cbd7b692f016e4b1961c027250fe1af453741" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4.0, we ship a number of improvements in all of its components, with the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/&quot;&gt;focus on quality and performance&lt;/a&gt;. Below you will find the list of the most important changes in Kotlin 1.4.0.</source>
          <target state="translated">在Kotlin 1.4.0中，我们在其所有组件中进行了许多改进，&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/&quot;&gt;重点是质量和性能&lt;/a&gt;。您可以在下面找到Kotlin 1.4.0中最重要的更改列表。</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">在Kotlin中,函数可以在文件中进行顶层声明,这意味着你不需要创建一个类来容纳一个函数,而在Java、C#或Scala等语言中则需要这样做。除了顶层函数外,Kotlin函数还可以作为成员函数和扩展函数进行本地声明。</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">在Kotlin中,有两种类型的平等。</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">在Kotlin中，可以使用以下语句使用整数列表中的&lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;解构声明&lt;/a&gt;来简洁地解析此行：</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">在Kotlin中,你可以为一个通用类型提供上界。Objective-C也支持这样做,但在更复杂的情况下,这种支持是不可用的,而且目前Kotlin-Objective-C互操作中也不支持。这里的例外是一个非空的上界将使Objective-C方法/属性非空。</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">在Kotlin中，您不能直接使用字段，而只能使用&lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;。您注释属性：</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">在Kotlin中，您必须添加 &lt;code&gt;kotlin-kapt&lt;/code&gt; 插件以启用 &lt;code&gt;kapt&lt;/code&gt; ，然后用 &lt;code&gt;kapt&lt;/code&gt; 替换 &lt;code&gt;annotationProcessor&lt;/code&gt; 处理程序：</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">在科特林您使用指定一个类似于Java的方式依赖&lt;a href=&quot;../reference/kapt&quot;&gt;科特林注释处理工具&lt;/a&gt;（ &lt;code&gt;kapt&lt;/code&gt; 代替） &lt;code&gt;annotationProcessor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">在Kotlin中，为集合定义了&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;+&lt;/code&gt; ）和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;-&lt;/code&gt; ）。他们将集合作为第一个操作数。第二个操作数可以是一个元素或另一个集合。返回值是一个新的只读集合：</target>
        </trans-unit>
        <trans-unit id="78f4990d53a6e7c8067b2fe1adea30492b815286" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; can also be used as an expression:</source>
          <target state="translated">在Kotlin中，&lt;em&gt;if&lt;/em&gt;也可以用作表达式：</target>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">在Kotlin中，&lt;em&gt;if&lt;/em&gt;是一个表达式，即它返回一个值。因此，没有三元运算符（条件？then：else），因为普通&lt;em&gt;if&lt;/em&gt;在此角色下工作良好。</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">在Kotlin中,所有的异常都是未检查的,这意味着编译器不会强迫你捕获任何异常。因此,当你调用一个声明了检查异常的Java方法时,Kotlin不会强迫你做任何事情。</target>
        </trans-unit>
        <trans-unit id="c1bf5763a1f21717d603f8b9877cdae5c9f323e3" translate="yes" xml:space="preserve">
          <source>In Kotlin, data serialization tools are available in a separate component, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;&lt;em&gt;kotlinx.serialization&lt;/em&gt;&lt;/a&gt;. It consists of two main parts: the Gradle plugin &amp;ndash;&lt;code&gt;org.jetbrains.kotlin.plugin.serialization&lt;/code&gt; and the runtime libraries.</source>
          <target state="translated">在Kotlin中，数据序列化工具可在单独的组件&lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;&lt;em&gt;kotlinx.serialization中使用&lt;/em&gt;&lt;/a&gt;。它由两个主要部分组成：Gradle插件&amp;ndash; &lt;code&gt;org.jetbrains.kotlin.plugin.serialization&lt;/code&gt; 和运行时库。</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">在Kotlin中,所有的东西都是一个对象,我们可以在任何变量上调用成员函数和属性。有些类型可以有特殊的内部表示--例如,数字、字符和booleans可以在运行时表示为基元值--但对用户来说,它们看起来就像普通的类。在本节中,我们将描述Kotlin中使用的基本类型:数字、字符、booleans、数组和字符串。</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">在Kotlin中，功能类型表示为具有不同数量参数的泛型类： &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; ， &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; ， &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; &amp;hellip;&amp;hellip;&amp;hellip;这种方法的问题在于此列表是有限的，当前以 &lt;code&gt;Function22&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在Kotlin中，实现继承受以下规则支配：如果一个类从其直接超类继承了同一成员的许多实现，则它必须重写此成员并提供自己的实现（也许使用继承的一个）。来表示从该继承执行取超型，我们使用&lt;em&gt;超级&lt;/em&gt;尖括号合格由超类型名称，例如 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e8de20bd90cf59ff062bcee3a6b6475fd0af4bb" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits multiple implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在Kotlin中，实现继承受以下规则支配：如果一个类从其直接超类继承同一个成员的多个实现，则它必须重写此成员并提供自己的实现（也许使用继承的一个）。来表示从该继承执行取超型，我们使用&lt;em&gt;超级&lt;/em&gt;尖括号合格由超类型名称，例如 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">在Kotlin中，导入是一个编译时概念-导入内容实际上不会导致任何代码运行（与Python不同，Python中文件中的所有顶级语句都在导入时执行）。因此，允许循环导入，但是它们可能会在您的代码中提示设计问题。但是，在执行期间，将在首次引用类（或其任何属性或函数）时加载类，并且类加载会导致初始化&lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;伴随对象&lt;/a&gt; -如果您具有循环依赖项，则可能导致运行时异常。</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">在Kotlin中，多态性是通过类层次结构来实现的，这样就不可能碰到缺少属性或功能的情况。基本规则是，当且仅当 &lt;code&gt;B&lt;/code&gt; 是 &lt;code&gt;A&lt;/code&gt; 的子类型时，声明类型为 &lt;code&gt;A&lt;/code&gt; 的变量/属性/参数才可以引用 &lt;code&gt;B&lt;/code&gt; 类的实例。这意味着，要么 &lt;code&gt;A&lt;/code&gt; 必须是一个类，而 &lt;code&gt;B&lt;/code&gt; 必须是 &lt;code&gt;A&lt;/code&gt; 的子类，要么 &lt;code&gt;A&lt;/code&gt; 必须是一个接口，而 &lt;code&gt;B&lt;/code&gt; 必须是实现该接口的类，或者是该类的子类。使用上一部分中的类和接口，我们可以定义以下功能：</target>
        </trans-unit>
        <trans-unit id="0ea4efcee086c70a1dc18d5edfeb999729e27f06" translate="yes" xml:space="preserve">
          <source>In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</source>
          <target state="translated">在Kotlin中,分号是可选的,因此换行符是重要的。语言设计假定使用Java风格的大括号,如果你试图使用不同的格式化风格,你可能会遇到令人惊讶的行为。</target>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">在Kotlin中， &lt;code&gt;List&lt;/code&gt; 的默认实现是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt;，您可以将其视为可调整大小的数组。</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">在Kotlin中,每次调用函数时都会对默认值的表达式进行评估。因此,只要使用每次评估都会产生一个新列表的表达式,就可以避免上述陷阱。</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">在Kotlin中,对象的顺序可以用几种方式来定义。</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">在Kotlin中，类型系统区分可以保存&lt;em&gt;null的&lt;/em&gt;引用（可为空的引用）和不能保存的引用（非null引用）。例如， &lt;code&gt;String&lt;/code&gt; 类型的常规变量不能包含&lt;em&gt;null&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">在Kotlin中,有一个惯例:如果一个函数的最后一个参数是函数,那么作为相应参数传递的lambda表达式可以放在括号外。</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">在Kotlin中，有一种方法可以向编译器解释这种情况。这称为&lt;strong&gt;声明位置方差&lt;/strong&gt;：我们可以对Source 的&lt;strong&gt;类型参数&lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; 进行注释，以确保仅从 &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; 成员&lt;strong&gt;返回&lt;/strong&gt;（产生）该&lt;strong&gt;参数&lt;/strong&gt;，而从不使用它。为此，我们提供&lt;strong&gt;out&lt;/strong&gt;修饰符：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">在Kotlin中,与Java或C#不同,类没有静态方法。在大多数情况下,建议使用包级函数来代替。</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">在Kotlin中，我们只能使用普通的不合格 &lt;code&gt;return&lt;/code&gt; 来退出命名函数或匿名函数。这意味着要退出lambda，我们必须使用&lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;，并且lambda内禁止裸 &lt;code&gt;return&lt;/code&gt; ，因为lambda无法使封闭函数返回：</target>
        </trans-unit>
        <trans-unit id="d39c4582a1b13add9eb003022ccb3a007508d4c5" translate="yes" xml:space="preserve">
          <source>In Kotlin, we have three backends that generate executables: Kotlin/JVM, Kotlin/JS, and Kotlin/Native. Kotlin/JVM and Kotlin/JS don't share much code since they were developed independently of each other. Kotlin/Native is based on a new infrastructure built around an intermediate representation (IR) for Kotlin code.</source>
          <target state="translated">在Kotlin中,我们有三个生成可执行文件的后端。Kotlin/JVM、Kotlin/JS和Kotlin/Native。Kotlin/JVM和Kotlin/JS并没有共享太多的代码,因为它们是相互独立开发的。Kotlin/Native是基于围绕Kotlin代码的中间表示(IR)建立的新的基础设施。</target>
        </trans-unit>
        <trans-unit id="0bc591251b1866272d3defd4ab24986b180f3e99" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.</source>
          <target state="translated">在Kotlin/JS实现的StringBuilder中,初始容量对操作的进一步性能没有影响。</target>
        </trans-unit>
        <trans-unit id="3d25d5f146a0d36095ac2d2fbada4dfa30e5c1b3" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</source>
          <target state="translated">在Kotlin/JS实现的StringBuilder中,后盾存储的大小总是等于字符串构建器的长度。</target>
        </trans-unit>
        <trans-unit id="9c5a4446d1a6bca7a876f80da83f707725750c3e" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</source>
          <target state="translated">在StringBuilder的Kotlin / JS实现中，后备存储的大小未扩展为符合给定的&lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;，因此调用此方法对操作的进一步性能没有影响。</target>
        </trans-unit>
        <trans-unit id="be7a0e0448f643a881b7fca70d06192aeb1ec087" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.</source>
          <target state="translated">在Kotlin/JS实现的StringBuilder中,从该方法返回的值可能并不表明备份存储的实际大小。</target>
        </trans-unit>
        <trans-unit id="07d924e5bfc344bb39ea0863e63e91640453cecc" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS projects, all dependencies can be managed through the Gradle plugin. This includes Kotlin/Multiplatform libraries such as &lt;code&gt;kotlinx.coroutines&lt;/code&gt;, &lt;code&gt;kotlinx.serialization&lt;/code&gt;, or &lt;code&gt;ktor-client&lt;/code&gt;.</source>
          <target state="translated">在Kotlin / JS项目中，可以通过Gradle插件管理所有依赖项。这包括Kotlin / Multiplatform库，例如 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; ， &lt;code&gt;kotlinx.serialization&lt;/code&gt; 或 &lt;code&gt;ktor-client&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">在Maven中</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">在Maven中，启用 &lt;code&gt;jpa&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">在Maven中，启用 &lt;code&gt;spring&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="14be0db4481edc4ab423c4343db7ab0c7cfdc4a9" translate="yes" xml:space="preserve">
          <source>In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</source>
          <target state="translated">在Maven中， &lt;code&gt;spring&lt;/code&gt; 插件由 &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; 插件依赖项提供，因此要启用它：</target>
        </trans-unit>
        <trans-unit id="2fde5916b654de021cf5316e7c8446b2d071c3b3" translate="yes" xml:space="preserve">
          <source>In Maven:</source>
          <target state="translated">在Maven。</target>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">在Python中，函数名称在模块或类中必须唯一。在Kotlin中，我们可以&lt;em&gt;重载&lt;/em&gt;函数：可以有多个具有相同名称的函数声明。重载的函数必须通过它们的参数列表相互区分。（参数列表的类型与返回类型一起被称为函数的&lt;em&gt;签名&lt;/em&gt;，但是返回类型不能用于消除重载函数的歧义。）例如，我们可以在同一个文件中同时拥有这两个函数：</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">在Python中，默认值的表达式在函数定义时被评估一次。这导致了这种经典的陷阱，开发人员希望每次调用该函数时都获得一个新的空列表，而没有 &lt;code&gt;numbers&lt;/code&gt; 的值，但是每次都使用相同的列表：</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句中，如果分支多于一行，请考虑使用空行将其与相邻的case块分开：</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">在长时间运行的应用程序中，您可能需要对后台协程进行细粒度的控制。例如，用户可能已经关闭了启动协程的页面，现在不再需要其结果并且可以取消其操作。在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;推出&lt;/a&gt;函数返回一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;作业&lt;/a&gt;，可用于取消运行协程：</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">在&lt;a href=&quot;classes#inheritance&quot;&gt;类&lt;/a&gt;的成员中，&lt;em&gt;这&lt;/em&gt;是指该类的当前对象。</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">简而言之，您可以在Kotlin项目中使用&lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt;或&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding之类的&lt;/a&gt;库。</target>
        </trans-unit>
        <trans-unit id="93e3893822831ac714d40df8280535305e6147f7" translate="yes" xml:space="preserve">
          <source>In a similar way to the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html&quot;&gt;collectLatest&lt;/a&gt; operator, that was shown in &lt;a href=&quot;#processing-the-latest-value&quot;&gt;&quot;Processing the latest value&quot;&lt;/a&gt; section, there is the corresponding &quot;Latest&quot; flattening mode where a collection of the previous flow is cancelled as soon as new flow is emitted. It is implemented by the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html&quot;&gt;flatMapLatest&lt;/a&gt; operator.</source>
          <target state="translated">以类似于&lt;a href=&quot;#processing-the-latest-value&quot;&gt;&amp;ldquo;处理最新值&amp;rdquo;&lt;/a&gt;一节中所示的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html&quot;&gt;collectLatest&lt;/a&gt;运算符的方式，存在相应的&amp;ldquo;最新&amp;rdquo;展平模式，在该模式下，一旦发出新流，则取消先前流的集合。它由&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html&quot;&gt;flatMapLatest&lt;/a&gt;运算符实现。</target>
        </trans-unit>
        <trans-unit id="15ca24684023d67ef7c14fca042f392a78539627" translate="yes" xml:space="preserve">
          <source>In a typical multiplatform project with two iOS-related targets &amp;ndash; &lt;code&gt;iosArm64&lt;/code&gt; and &lt;code&gt;iosX64&lt;/code&gt;, the hierarchical structure includes an intermediate source set (&lt;code&gt;iosMain&lt;/code&gt;), which is used by the platform-specific source sets.</source>
          <target state="translated">在具有两个与iOS相关的目标 &lt;code&gt;iosArm64&lt;/code&gt; 和 &lt;code&gt;iosX64&lt;/code&gt; 的典型多平台项目中，层次结构包含一个中间源集（ &lt;code&gt;iosMain&lt;/code&gt; ），该特定源集由平台特定的源集使用。</target>
        </trans-unit>
        <trans-unit id="bc60b5f1d9e8600ceb6b31da789280579a4f556c" translate="yes" xml:space="preserve">
          <source>In actual applications a scope will come from an entity with a limited lifetime. As soon as the lifetime of this entity is terminated the corresponding scope is cancelled, cancelling the collection of the corresponding flow. This way the pair of &lt;code&gt;onEach { ... }.launchIn(scope)&lt;/code&gt; works like the &lt;code&gt;addEventListener&lt;/code&gt;. However, there is no need for the corresponding &lt;code&gt;removeEventListener&lt;/code&gt; function, as cancellation and structured concurrency serve this purpose.</source>
          <target state="translated">在实际应用中，范围将来自寿命有限的实体。一旦此实体的生存期终止，则将取消相应的作用域，从而取消相应流的收集。这样，一对 &lt;code&gt;onEach { ... }.launchIn(scope)&lt;/code&gt; 就像 &lt;code&gt;addEventListener&lt;/code&gt; 一样工作。但是，由于取消和结构化并发达到了此目的，因此不需要相应的 &lt;code&gt;removeEventListener&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="6b7464c5f857646c373051a91afcc2339f5f7b93" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#common-target-configuration&quot;&gt;common target configuration&lt;/a&gt;, &lt;code&gt;jvm&lt;/code&gt; targets have a specific function:</source>
          <target state="translated">除了&lt;a href=&quot;#common-target-configuration&quot;&gt;通用目标配置外&lt;/a&gt;， &lt;code&gt;jvm&lt;/code&gt; 目标还具有特定功能：</target>
        </trans-unit>
        <trans-unit id="b9d98c12799fcb8ef0ae80c451d81a3c8245f3f0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, a collector can also use a &lt;code&gt;finally&lt;/code&gt; block to execute an action upon &lt;code&gt;collect&lt;/code&gt; completion.</source>
          <target state="translated">除了 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 之外，收集器还可以使用 &lt;code&gt;finally&lt;/code&gt; 块在 &lt;code&gt;collect&lt;/code&gt; 完成后执行操作。</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">除了&lt;strong&gt;out之外&lt;/strong&gt;，Kotlin还提供了补充的方差注释：&lt;strong&gt;in&lt;/strong&gt;。它使类型参数&lt;strong&gt;互变&lt;/strong&gt;：它只能被使用而不能产生。可变类型的一个很好的例子是 &lt;code&gt;Comparable&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">除了用于&lt;a href=&quot;collection-parts&quot;&gt;检索集合零件的&lt;/a&gt;常用操作之外，列表还提供&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt;函数，该函数将指定元素范围的视图作为列表返回。因此，如果原始集合的元素发生变化，则它在先前创建的子列表中也会发生变化，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f8a12fad9d12380d0581bf388509c212413ee01b" translate="yes" xml:space="preserve">
          <source>In addition to predefined compilations, you can create your own custom compilations. To create a custom compilation, add a new item into the &lt;code&gt;compilations&lt;/code&gt; collection. If using Kotlin Gradle DSL, mark custom compilations &lt;code&gt;by creating&lt;/code&gt;.</source>
          <target state="translated">除了预定义的编译，您还可以创建自己的自定义编译。要创建自定义汇编，请将新项目添加到 &lt;code&gt;compilations&lt;/code&gt; 集合中。如果使用Kotlin Gradle DSL，请 &lt;code&gt;by creating&lt;/code&gt; 标记自定义编译。</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">除了删除元素，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt;还可以在迭代列表时插入和替换元素。</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">除范围函数外，标准库还包含函数 &lt;code&gt;takeIf&lt;/code&gt; 和 &lt;code&gt;takeUnless&lt;/code&gt; 。这些功能使您可以将对对象状态的检查嵌入到调用链中。</target>
        </trans-unit>
        <trans-unit id="f1257110cb9cb8a007e2fdc06c4e2227ea7a3c26" translate="yes" xml:space="preserve">
          <source>In addition to suspend conversion on lambdas, Kotlin now supports suspend conversion on callable references starting from version 1.4.0.</source>
          <target state="translated">除了在lambdas上暂停转换外,Kotlin从1.4.0版本开始支持在可调用引用上暂停转换。</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">除此之外，您还可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt;访问与&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;该类&lt;/a&gt;相对应的JsClass实例。该 &lt;code&gt;JsClass&lt;/code&gt; 实例本身的构造函数的引用。这可用于与期望引用构造函数的JS函数进行互操作。</target>
        </trans-unit>
        <trans-unit id="e90b7801c53c4e41da0228b0d27c84622a6be4c2" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/JS compiler has the options listed below.</source>
          <target state="translated">除了&lt;a href=&quot;#common-options&quot;&gt;常用选项外&lt;/a&gt;，Kotlin / JS编译器还具有以下列出的选项。</target>
        </trans-unit>
        <trans-unit id="858ccef9738a93100e88ac347adf42b1aff3915a" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/JVM compiler has the options listed below.</source>
          <target state="translated">除了&lt;a href=&quot;#common-options&quot;&gt;常用选项外&lt;/a&gt;，Kotlin / JVM编译器还具有以下列出的选项。</target>
        </trans-unit>
        <trans-unit id="0c87fecf2d35b4b8f103d9e391aeb9f3722b8880" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/Native compiler has the options listed below.</source>
          <target state="translated">除了&lt;a href=&quot;#common-options&quot;&gt;常用选项外&lt;/a&gt;，Kotlin / Native编译器还具有以下列出的选项。</target>
        </trans-unit>
        <trans-unit id="36b7ccec26bcb88294baf54023cc9ae72ecaa90f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt;&lt;code&gt;as&lt;/code&gt;, which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt;&lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt;, &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</source>
          <target state="translated">除了&lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&amp;ldquo; unsafe&amp;rdquo;&lt;/a&gt;&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt; &lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;运算符 &lt;code&gt;as&lt;/code&gt; 之外，如果无法进行强制转换，该运算符会抛出 &lt;code&gt;ClassCastException&lt;/code&gt; ，此外Kotlin / JS还提供了unsafeCast &amp;lt;T&amp;gt;（）。使用 &lt;code&gt;unsafeCast&lt;/code&gt; 时，在运行时&lt;em&gt;完全不进行类型检查&lt;/em&gt;。例如，考虑以下两种方法：</target>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">除了上面显示的 &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 依赖项之外，您还需要添加对Kotlin标准库的依赖项：</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">除了构建任务之外，Gradle构建还包括一些有用的任务，这些任务可通过 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; 和 &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; 直接运行应用程序。</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">除了&amp;ldquo;收集&lt;a href=&quot;collection-write&quot;&gt;写&lt;/a&gt;操作&amp;rdquo;中描述的收集修改操作之外，&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可变&lt;/a&gt;列表还支持特定的写操作。这样的操作使用索引来访问元素以扩展列表修改功能。</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">除了命令行编译器和IntelliJ IDEA,你还可以用Ant、Maven和Gradle构建Kotlin项目。</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">除了不同构建器提供的协程作用域之外，还可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;构建器声明自己的作用域。它创建一个协程范围，并且直到所有启动的子级都完成后才完成。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;之间的主要区别在于，后者在等待所有子级完成时不会阻塞当前线程。</target>
        </trans-unit>
        <trans-unit id="e5077ac7f8cceff0957d255db71b0d1a0a24a0ba" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</source>
          <target state="translated">除了不同构建器提供的协程作用域之外，还可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;构建器声明自己的作用域。它创建一个协程范围，直到所有启动的子级都完成后才完成。</target>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">除了输出的JavaScript文件之外，该插件默认情况下还会创建一个带有二进制描述符的附加JS文件。如果您要构建其他Kotlin模块可以依赖的可重用库，则此文件是必需的，并且应与转换结果一起分发。生成由 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; 选项控制：</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">此外,Rx确实引入了一种更好的错误处理方法。</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">此外，每个 &lt;code&gt;{file}.meta.js&lt;/code&gt; 还具有一个对应的{file} .meta.js元文件，该文件将用于反射和其他功能。</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">在所有的情况下,C字符串都应该被编码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">在所有方面,这与Java中的做法是一样的,因为通过默认的getters和setters对私有属性的访问是经过优化的,所以不会引入函数调用的开销。</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">在&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt;或&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;带有接收器&lt;/a&gt;的函数文字中，&lt;em&gt;这&lt;/em&gt;表示在点的左侧传递的&lt;em&gt;接收器&lt;/em&gt;参数。</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">&lt;code&gt;noinline&lt;/code&gt; 联函数定义中，可以在任何函数类型的参数前面使用noinline，以防止内联将传递给它的lambda。</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">在任何列表中，您都可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt;函数找到元素的位置。它们返回与列表中给定参数相等的元素的第一个和最后一个位置。如果没有这样的元素，则两个函数都将返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28ad7357688ca2a3f1fc903df2a6eb9517f15794" translate="yes" xml:space="preserve">
          <source>In any target block, you can use the following declarations:</source>
          <target state="translated">在任何目标块中,你可以使用以下声明。</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">在方法上,它和Futures很相似,但我们可以把Future看作是返回一个离散元素,而Rx则返回一个流。然而,与前者类似,它也为我们的编程模型引入了一种全新的思维方式,著名的说法为</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">如果任何两个条目被映射到等键上,后一个条目的值将覆盖与前一个条目相关联的值。</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">如果由于在&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block中&lt;/a&gt;发生异常而关闭资源，并且关闭也因异常而失败，则将后者添加到前者的&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;抑制&lt;/a&gt;异常中。</target>
        </trans-unit>
        <trans-unit id="753affb3f26053a8d6fe6a50898f37935f2da6a8" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</source>
          <target state="translated">如果由于在&lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block中&lt;/a&gt;发生异常而关闭资源，并且关闭也因异常而失败，则将后者添加到前者的抑制异常中。</target>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">如果有非空行,没有前导空格字符(完全没有缩进),那么普通缩进为0,因此这个函数不会改变缩进。</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">如果在派发接收方和扩展接收方的成员之间发生名称冲突，则以扩展接收方为准。要引用调度接收器的成员，可以使用&lt;a href=&quot;this-expressions#qualified&quot;&gt;限定的 &lt;code&gt;this&lt;/code&gt; 语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">如果是类中的扩展属性,应先传递类的实例,后传递扩展接收器的实例。</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">如果此类型基于内部类，则返回的列表将首先包含为最内部类提供的类型参数，然后是为其外部类提供的参数，依此类推。例如，在类型 &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; ，返回的列表为 &lt;code&gt;[C, D, A, B]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">如果只希望传递给内联函数的某些lambda进行内联，则可以使用 &lt;code&gt;noinline&lt;/code&gt; 修饰符标记一些函数参数：</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">如果您想知道 &lt;code&gt;use&lt;/code&gt; 是一个功能，如何在其后加上类似的代码块，请参阅&lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL支持&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">在通用代码中:</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">从本质上讲,这允许以下代码。</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">事实上,对于从主构造函数中声明属性和初始化属性,Kotlin有一个简洁的语法。</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">在接下来的章节中,将对这些概念以及在项目中配置它们的DSL进行更详细的描述。</target>
        </trans-unit>
        <trans-unit id="b8f977357563759de0c40c521cc75a6bcef24abd" translate="yes" xml:space="preserve">
          <source>In future versions, the hierarchical project structure will become default for Kotlin multiplatform project, so we strongly encourage you to start using it now.</source>
          <target state="translated">在未来的版本中,层次化的项目结构将成为Kotlin多平台项目的默认结构,所以我们强烈建议你现在就开始使用它。</target>
        </trans-unit>
        <trans-unit id="7ca8fe04f8968119833a10d8a0204e9737ceb843" translate="yes" xml:space="preserve">
          <source>In future versions, the hierarchical project structure with the usage of platform-dependent libraries in shared source sets will be the default in multiplatform projects. So the sooner you support it, the sooner users will be able to migrate. We&amp;rsquo;ll also be very grateful if you report any bugs you find to our &lt;a href=&quot;http://kotl.in/issue&quot;&gt;issue tracker.&lt;/a&gt;</source>
          <target state="translated">在将来的版本中，在多平台项目中将默认使用在共享源集中使用依赖于平台的库的分层项目结构。因此，您越早支持它，用户就越能够迁移。如果您向我们的&lt;a href=&quot;http://kotl.in/issue&quot;&gt;问题跟踪器&lt;/a&gt;报告发现的任何错误，我们也将不胜感激。</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">一般来说,对于小型项目,我们建议一次性转换所有文件。</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">通常，标识符可以由字母，数字和下划线组成，并且不能以数字开头。但是，如果您编写的代码（例如，基于标识符自动生成JSON）并且希望JSON密钥是不符合这些规则或与关键字冲突的字符串，则可以将其括在反引号中： &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; 是有效的标识符。</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">一般来说,如果Kotlin中的某个语法结构是可选的,并且被IDE高亮显示为多余的,你应该在代码中省略它。不要为了 &quot;清晰 &quot;而在代码中留下不必要的语法元素。</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">一般来说,要创建这样一个类的实例,我们需要提供类型参数。</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">在生成的代码中，Kotlin编译&lt;em&gt;器&lt;/em&gt;为每个内联类保留一个&lt;em&gt;包装器&lt;/em&gt;。内联类实例可以在运行时表示为包装器或基础类型。这类似于如何 &lt;code&gt;Int&lt;/code&gt; 可以&lt;a href=&quot;basic-types#representation&quot;&gt;表示&lt;/a&gt;或者作为原始 &lt;code&gt;int&lt;/code&gt; 或作为包装 &lt;code&gt;Integer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">在lambda表达式中,应该在大括号周围使用空格,以及在分隔参数和正文的箭头周围使用空格。如果一个调用只使用一个lambda,则应尽可能在括号外传递。</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">在较短且未嵌套的lambda中，建议使用 &lt;code&gt;it&lt;/code&gt; 约定而不是显式声明参数。在带有参数的嵌套lambda中，应始终明确声明参数。</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">在较长的参数列表中,在开头的括号后加一个换行符。缩进4个空格的参数。将多个密切相关的参数归为同一行。</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">在许多情况下，不需要在Kotlin中使用显&lt;a href=&quot;#unsafe-cast-operator&quot;&gt;式强制转换&lt;/a&gt;运算符，因为编译器会跟踪 &lt;code&gt;is&lt;/code&gt; - checks和显式强制转换以获取不可变值，并在需要时自动插入（安全）强制转换：</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">在混合语言项目中,Kotlin源文件应与Java源文件驻留在同一个源根中,并遵循相同的目录结构(每个文件应存放在每个包声明对应的目录中)。</target>
        </trans-unit>
        <trans-unit id="75f610c8e81d1558fc92e1b43e9b512e7f4028a1" translate="yes" xml:space="preserve">
          <source>In modules that don't expose their own API, such as applications, you can opt in to using APIs without propagating the opt-in requirement to your code. In this case, mark your declaration with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-opt-in/index&quot;&gt;@OptIn&lt;/a&gt; passing the opt-in requirement annotation as its argument:</source>
          <target state="translated">在不公开自己的API的模块（例如应用程序）中，您可以选择使用API​​，而无需将选择加入要求传播到代码中。在这种情况下，用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-opt-in/index&quot;&gt;@OptIn&lt;/a&gt;标记您的声明，并以opt-in要求注释作为参数：</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">在不提供自己的API的模块（例如应用程序模块）中，您可以使用实验性API，而无需将实验状态传播到代码中。在这种情况下，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental（Marker :: class）&lt;/a&gt;批注标记代码，并指定实验性API的标记批注：</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">在大多数情况下,Kotlin遵循Java编码惯例。</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">在多行模式下，表达式 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 分别在行终止符或输入序列的结尾之后或之前匹配。</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">为了组装应用程序，我们还需要包括Kotlin标准库（即作为依赖项包含的 &lt;code&gt;kotlin.js&lt;/code&gt; )和其他库（如果有）。</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">为了避免在Xcode构建期间出现兼容性问题，该插件需要使用&lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle包装器&lt;/a&gt;。要在执行 &lt;code&gt;podspec&lt;/code&gt; 任务期间自动生成包装器，请使用参数 &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; 对其运行。</target>
        </trans-unit>
        <trans-unit id="c80bd17bf7329417ed7785f5f956f7d5c5ca2880" translate="yes" xml:space="preserve">
          <source>In order to avoid confusion about artifact names, we&amp;rsquo;ve renamed &lt;code&gt;kotlin-scripting-jsr223-embeddable&lt;/code&gt; and &lt;code&gt;kotlin-scripting-jvm-host-embeddable&lt;/code&gt; to just &lt;code&gt;kotlin-scripting-jsr223&lt;/code&gt; and &lt;code&gt;kotlin-scripting-jvm-host&lt;/code&gt;. These artifacts depend on the &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; artifact, which shades the bundled third-party libraries to avoid usage conflicts. With this renaming, we&amp;rsquo;re making the usage of &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; (which is safer in general) the default for scripting artifacts. If, for some reason, you need artifacts that depend on the unshaded &lt;code&gt;kotlin-compiler&lt;/code&gt;, use the artifact versions with the &lt;code&gt;-unshaded&lt;/code&gt; suffix, such as &lt;code&gt;kotlin-scripting-jsr223-unshaded&lt;/code&gt;. Note that this renaming affects only the scripting artifacts that are supposed to be used directly; names of other artifacts remain unchanged.</source>
          <target state="translated">为了避免混淆工件名称，我们将 &lt;code&gt;kotlin-scripting-jsr223-embeddable&lt;/code&gt; 和 &lt;code&gt;kotlin-scripting-jvm-host-embeddable&lt;/code&gt; 重 &lt;code&gt;kotlin-scripting-jsr223&lt;/code&gt; 为kotlin-scripting-jsr223和 &lt;code&gt;kotlin-scripting-jvm-host&lt;/code&gt; 。这些工件取决于 &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; 工件，该工件会遮盖捆绑的第三方库以避免使用冲突。通过这种重命名，我们将使用 &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; （通常更安全）作为脚本工件的默认设置。如果出于某种原因，您需要依赖于未 &lt;code&gt;kotlin-compiler&lt;/code&gt; 的工件，请使用带有 &lt;code&gt;-unshaded&lt;/code&gt; 后缀的工件版本，例如 &lt;code&gt;kotlin-scripting-jsr223-unshaded&lt;/code&gt; 。请注意，此重命名仅影响应该直接使用的脚本工件。其他工件的名称保持不变。</target>
        </trans-unit>
        <trans-unit id="320ea67fc7a407c39652cf848b66d1bac7958814" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</source>
          <target state="translated">为了使用Gradle构建Kotlin项目，您应该&lt;a href=&quot;#plugin-and-versions&quot;&gt;将Kotlin Gradle插件应用于您的项目&lt;/a&gt;并&lt;a href=&quot;#configuring-dependencies&quot;&gt;配置Dependencies&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">为了使用Gradle构建Kotlin项目，您应该&lt;a href=&quot;#plugin-and-versions&quot;&gt;设置&lt;em&gt;kotlin-gradle&lt;/em&gt;插件&lt;/a&gt;，&lt;a href=&quot;#targeting-the-jvm&quot;&gt;将其应用&lt;/a&gt;到项目中并&lt;a href=&quot;#configuring-dependencies&quot;&gt;添加&lt;em&gt;kotlin-stdlib&lt;/em&gt;依赖项&lt;/a&gt;。通过调用&amp;ldquo; &lt;strong&gt;工具&amp;rdquo;，&lt;/strong&gt;这些动作也可以在IntelliJ IDEA中自动执行&lt;strong&gt;。&lt;/strong&gt;&lt;strong&gt;科特林| &lt;/strong&gt;在&amp;ldquo; &lt;strong&gt;项目&amp;rdquo;&lt;/strong&gt;操作中&lt;strong&gt;配置Kotlin&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">为了编译JavaScript代码，您需要使用 &lt;code&gt;js&lt;/code&gt; 和 &lt;code&gt;test-js&lt;/code&gt; 目标进行 &lt;code&gt;compile&lt;/code&gt; 执行：</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">为了使用IntelliJ IDEA调试应用程序,我们需要执行两个步骤。</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">为了生成这些绑定，我们需要创建一个库定义 &lt;code&gt;.def&lt;/code&gt; 文件，其中包含一些有关我们需要生成的标头的信息。在我们的例子中，我们想使用著名的 &lt;code&gt;libcurl&lt;/code&gt; 库进行一些HTTP调用，因此我们将创建一个名为 &lt;code&gt;libcurl.def&lt;/code&gt; 的文件,其中包含以下内容</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">为了运行，我们需要相应的WAR进行部署。我们可以使用Gradle中的&lt;em&gt;war&lt;/em&gt;任务生成这些任务，该任务可以通过IntelliJ IDEA中的Gradle工具窗口轻松执行。</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">为了在项目开发人员的 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 文件夹中共享更改，必须将其提交给VCS。另外，&lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;obsolete&lt;/strong&gt;可以用于配置了Gradle或Maven的项目。</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">为了向所有项目开发人员共享这些更改，必须将 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 文件夹提交给VCS。</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">为了指定模块的种类,我们可以为我们的插件添加一个配置,如下所示</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">为了支持可能为空的类型，Objc标头需要使用可为空的返回值定义 &lt;code&gt;myVal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de88f4d0de61705bae1956451c94335904114bb9" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">为了支持可能为空的类型，Objective-C标头需要使用可为空的返回值定义 &lt;code&gt;myVal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">为了使用Gradle定位JavaScript，我们需要使用 &lt;code&gt;kotlin2js&lt;/code&gt; 插件，而不是 &lt;code&gt;kotlin&lt;/code&gt; 插件。</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">为了在node.js中使用Kotlin,我们需要将编译器选项设置为使用CommonJS。一旦我们这样做,应用程序的输出应该可以使用node模块系统访问。</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">为了使用协程并遵循本指南中的示例，您需要添加对 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 模块的依赖项，如&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;项目README中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc71e5241592939229f3aa2e6f5ed18f17024e17" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">为了使用协程并遵循本指南中的示例，您需要&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;按照项目README中的&lt;/a&gt;说明添加对 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 模块的依赖项。</target>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">为了使用包中的东西,只要在使用符号的地方使用包名来完全限定符号的名称即可。</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">为了使用它，我们还需要在我们的应用程序中包括Kotlin标准库，即 &lt;code&gt;kotlin.js&lt;/code&gt; ，它作为依赖项包含在内。默认情况下，Maven不会在构建过程中扩展JAR，因此我们需要在构建中添加一个额外的步骤。</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">换句话说，内联类引入了一种真正的&lt;em&gt;新&lt;/em&gt;类型，这与类型别名相反，后者仅为现有类型引入了替代名称（别名）：</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">在我们的DSL中，所有标签类都扩展相同的超类 &lt;code&gt;Tag&lt;/code&gt; 。仅用 &lt;code&gt;@HtmlTagMarker&lt;/code&gt; 注释超类就足够了，然后Kotlin编译器会将所有继承的类视为已注释：</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">在我们的示例中，我们具有使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;协程构建器将其转换为协程的 &lt;code&gt;main&lt;/code&gt; 功能。每个协 &lt;code&gt;runBlocking&lt;/code&gt; 器，包括runBlocking，&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;都会&lt;/a&gt;在其代码块范围内添加一个CoroutineScope实例。我们可以在此范围内启动协程，而不必显式地 &lt;code&gt;join&lt;/code&gt; 它们，因为外部协程（在我们的示例中为 &lt;code&gt;runBlocking&lt;/code&gt; ）直到在其范围内启动的所有协程完成后才完成。因此，我们可以使示例更简单：</target>
        </trans-unit>
        <trans-unit id="a2b76b0743b9831752920932ff5a5625568afac3" translate="yes" xml:space="preserve">
          <source>In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">在我们的示例中，我们有一个 &lt;code&gt;main&lt;/code&gt; 功能，可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;协程生成器将其转换为协程。每个协 &lt;code&gt;runBlocking&lt;/code&gt; 器，包括runBlocking，&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;都会&lt;/a&gt;在其代码块范围内添加一个CoroutineScope实例。我们可以在此范围内启动协程，而不必显式地 &lt;code&gt;join&lt;/code&gt; 它们，因为外部协程（在我们的示例中为 &lt;code&gt;runBlocking&lt;/code&gt; ）直到在其作用域内启动的所有协程完成后才完成。因此，我们可以使示例更简单：</target>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">在我们的主要函数中，我们创建活动，调用测试 &lt;code&gt;doSomething&lt;/code&gt; 函数，并在500毫秒后销毁活动。这会取消所有已启动的协程，如果等待，我们可以通过注意到它不再打印在屏幕上来确认这一点：</target>
        </trans-unit>
        <trans-unit id="8567ecf52dbb46832894d62cc3534eccec93e924" translate="yes" xml:space="preserve">
          <source>In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt;. We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</source>
          <target state="translated">在我们的主要函数中，我们创建活动，调用测试 &lt;code&gt;doSomething&lt;/code&gt; 函数，并在500毫秒后销毁该活动。这将取消从 &lt;code&gt;doSomething&lt;/code&gt; 启动的所有协程。我们可以看到，因为在活动销毁后，即使等待了更长的时间，也不会再打印任何消息。</target>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">特别是,当为一个类定义对这个类的所有客户端都有意义的扩展函数时,把它们放在定义该类本身的同一个文件中。当定义那些只对特定客户端有意义的扩展函数时,把它们放在该客户端的代码旁边。不要为了存放 &quot;Foo的所有扩展函数 &quot;而创建文件。</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">在实践中,有些变化无法在编译时准确地检测到,所以不能报告警告,但至少会通过A版本的Release notes通知用户,B版本将有变化。</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">在实践中,有不少代码受到影响,所以这可以说是一次重大的代码风格更新。</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">在实际工作中,线程限制是以大块的方式进行的,比如大块的状态更新业务逻辑就限制在单线程中。下面的例子就是这样做的,首先在单线程上下文中运行每个coroutine。</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">在渐进模式下,语言语义的一些修正可以立即到达。所有这些修正都有两个重要的特性。</target>
        </trans-unit>
        <trans-unit id="fe450a289b0de3b7d5e96c5607691481e36cec05" translate="yes" xml:space="preserve">
          <source>In projects created from IntelliJ IDEA or AppCode templates these &lt;code&gt;.dSYM&lt;/code&gt; bundles are then discovered by Xcode automatically.</source>
          <target state="translated">然后，在从IntelliJ IDEA或AppCode模板创建的项目中，这些 &lt;code&gt;.dSYM&lt;/code&gt; 包将由Xcode自动发现。</target>
        </trans-unit>
        <trans-unit id="eff40107a95c01dec77eae6fb0ec0b96a075ea6f" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</source>
          <target state="translated">在纯Kotlin项目中，建议的目录结构遵循包结构，省略了公共根包。例如，如果项目中的所有代码都在 &lt;code&gt;org.example.kotlin&lt;/code&gt; 包及其子包中，则带有 &lt;code&gt;org.example.kotlin&lt;/code&gt; 包的文件应直接放在源根目录下，并将文件放在 &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; 应该位于源根目录的 &lt;code&gt;network/socket&lt;/code&gt; 子目录中。</target>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">在纯Kotlin项目中,推荐的目录结构是遵循包的结构,而省略常用的根包(例如,如果项目中所有的代码都在 &quot;org.example.kotlin &quot;包及其子包中,那么 &quot;org.example.kotlin &quot;包中的文件应该直接放在源根目录下,而 &quot;org.example.kotlin.foo.bar &quot;中的文件应该放在源根目录的 &quot;foo/bar &quot;子目录下)。</target>
        </trans-unit>
        <trans-unit id="c30c378469f41e6f1d1072007ebada7e490b3451" translate="yes" xml:space="preserve">
          <source>In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">在草稿和工作表中，您可以编写任何有效的Kotlin代码。语法高亮显示，自动完成和其他IntelliJ IDEA代码编辑功能也都受支持。请注意，无需声明 &lt;code&gt;main&lt;/code&gt; 函数：您编写的所有代码都将像在 &lt;code&gt;main&lt;/code&gt; 主体中那样执行。</target>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">简而言之：&lt;em&gt;仔细考虑您的整数声明，并绝对确保该值永远不必大于该类型的限制！&lt;/em&gt;如果需要不限大小的整数，请使用非原始类型 &lt;code&gt;BigInteger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">在这种情况下，我们可以使用 &lt;code&gt;dynamic&lt;/code&gt; 类型，该动态类型允许我们在定位JavaScript时使用动态类型。以下变量被声明为 &lt;code&gt;dynamic&lt;/code&gt; 变量，这意味着我们对其进行的调用均不会导致编译时错误：</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">在某些情况下（例如，为了支持重载），Kotlin编译器会破坏JavaScript代码中生成的函数和属性的名称。要控制生成的名称，可以使用 &lt;code&gt;@JsName&lt;/code&gt; 批注：</target>
        </trans-unit>
        <trans-unit id="f1f62f22b0a379feb738d1ada9b061745859834e" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">在某些情况下（例如，为了支持重载），Kotlin编译器会破坏JavaScript代码中生成的函数和属性的名称。要控制生成的名称，可以使用 &lt;code&gt;@JsName&lt;/code&gt; 批注：</target>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">在某些情况下,没有参数的函数可以和只读属性互换。虽然语义相似,但在什么情况下,有一些风格上的约定。</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">在某些方面，这更易于阅读，因为操作是按照它们应用于值的顺序指定的。结果将是一个不变的 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是您使用的转换产生的任何类型（在这种情况下为 &lt;code&gt;String&lt;/code&gt; ）。如果需要可变列表，请在最后调用 &lt;code&gt;toMutableList()&lt;/code&gt; 。如果需要集合，请在最后调用 &lt;code&gt;toSet()&lt;/code&gt; 或 &lt;code&gt;toMutableSet()&lt;/code&gt; 。如果要将集合转换为地图，请调用 &lt;code&gt;associateBy()&lt;/code&gt; ，它需要两个lambda来指定如何从每个元素中提取键和值： &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; （如果希望整个元素作为值，则可以省略第二个lambda；如果希望结果可变，则可以在最后调用 &lt;code&gt;toMutableMap()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">尽管使用了 &lt;code&gt;object&lt;/code&gt; 关键字，但是每当计算对象表达式时，都会创建一个匿名类的新实例。</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">尽管语法上很方便，但伴随对象本身就是一个合适的对象，并且可以具有自己的超类型-您可以将其分配给变量并传递给它。如果要与Java代码集成，并且需要一个真正的 &lt;code&gt;static&lt;/code&gt; 成员，则可以使用 &lt;code&gt;@JvmStatic&lt;/code&gt; 在同伴对象内&lt;a href=&quot;annotations&quot;&gt;注释&lt;/a&gt;一个成员。</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">在后续的教程中,我们将展示如何影响生成的文件,例如,改变位置、前缀和后缀,以及如何使用模块。</target>
        </trans-unit>
        <trans-unit id="bc19aea0692b9f67e799748ba127b1fc2dfa9708" translate="yes" xml:space="preserve">
          <source>In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">在测试中（并且&lt;strong&gt;仅&lt;/strong&gt;在测试中），可以在反引号中使用带有空格的方法名称。（请注意，Android运行时当前不支持此类方法名称。）测试代码中也允许在方法名称中使用下划线。</target>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">在测试中(也只有在测试中),使用带空格的方法名是可以接受的。(注意,Android运行时目前不支持这样的方法名。)在测试代码中也允许在方法名中使用下划线。</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">在这种情况下，您需要使用传播运算符 &lt;code&gt;*&lt;/code&gt; 来传递 &lt;code&gt;IntArray&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a1e90ae09efa8b0693d6eb0e54489eb2ffa5613b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</source>
          <target state="translated">在&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;调试模式下&lt;/a&gt;，它输出如下内容：</target>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">在&lt;a href=&quot;#enabling-experimental-features&quot;&gt;实验模式下&lt;/a&gt;，您可以指定任何变体名称（不仅是flavor），例如 &lt;code&gt;freeDebug&lt;/code&gt; 或 &lt;code&gt;freeRelease&lt;/code&gt; 也可以使用。</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">在 &lt;code&gt;libnative_api.h&lt;/code&gt; 中，我们将找到以下代码。我们将分部分讨论代码，以使其更易于理解。</target>
        </trans-unit>
        <trans-unit id="6da10c50e0a522e1434416a4209979f6b0add877" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;Coroutines&lt;/strong&gt; tab, you can see that there are two coroutines running concurrently. The flow collector and emitter run in separate coroutines because of the &lt;code&gt;buffer()&lt;/code&gt; function. The &lt;code&gt;buffer()&lt;/code&gt; function buffers emitted values from the flow. The emitter coroutine has the &lt;strong&gt;RUNNING&lt;/strong&gt; status, and the collector coroutine has the &lt;strong&gt;SUSPENDED&lt;/strong&gt; status.</source>
          <target state="translated">在&lt;strong&gt;协同程序&lt;/strong&gt;选项卡，可以看到有同时运行两个协同程序。由于 &lt;code&gt;buffer()&lt;/code&gt; 函数，流收集器和发射器在单独的协程中运行。的 &lt;code&gt;buffer()&lt;/code&gt; 函数缓冲器从流发射的值。发射器协程的状态为&lt;strong&gt;RUNNING&lt;/strong&gt;，而收集器协程的状态为&lt;strong&gt;SUSPENDED&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">在Gradle依赖项中，您使用添加 &lt;code&gt;kotlin-kapt&lt;/code&gt; 插件，并用 &lt;code&gt;kapt&lt;/code&gt; 替换 &lt;code&gt;annotationProcessor&lt;/code&gt; 处理程序：</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">在JavaScript的世界里,有一套完全不同的API可以使用,所以我们可以实现对控制台的日志记录。</target>
        </trans-unit>
        <trans-unit id="028c1035d4940563c6ebb4f5acb53d3747a67767" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, the most common way to manage dependencies is &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;. It offers the biggest public repository of JavaScript modules.</source>
          <target state="translated">在JavaScript世界中，最常见的依赖管理方法是&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;。它提供了最大的JavaScript模块公共存储库。</target>
        </trans-unit>
        <trans-unit id="cc47ebd8b09857b2d92aa6e80c268cb28a620e3a" translate="yes" xml:space="preserve">
          <source>In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</source>
          <target state="translated">在Kotlin Gradle DSL中,还有一个设置CommonJS模块种类的快捷方式。</target>
        </trans-unit>
        <trans-unit id="f4819cf70d4fd8479a3ad5972f4f49ad73e7b787" translate="yes" xml:space="preserve">
          <source>In the build script of an existing project.</source>
          <target state="translated">在现有项目的构建脚本中。</target>
        </trans-unit>
        <trans-unit id="f33ac82cc0a362095e9dc9d1c2c9f6a2f067dea1" translate="yes" xml:space="preserve">
          <source>In the case where you have a busy loop with coroutines you must explicitly check for cancellation. You can add &lt;code&gt;.onEach { currentCoroutineContext().ensureActive() }&lt;/code&gt;, but there is a ready-to-use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html&quot;&gt;cancellable&lt;/a&gt; operator provided to do that:</source>
          <target state="translated">如果协程繁忙，则必须显式检查取消。您可以添加 &lt;code&gt;.onEach { currentCoroutineContext().ensureActive() }&lt;/code&gt; ，但是提供了一个现成的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html&quot;&gt;可取消&lt;/a&gt;操作符来执行此操作：</target>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">在上面的代码中，参数 &lt;code&gt;combine&lt;/code&gt; 具有&lt;a href=&quot;#function-types&quot;&gt;函数类型&lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; ，因此它接受一个函数，该函数接受 &lt;code&gt;R&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 类型的两个参数并返回 &lt;code&gt;R&lt;/code&gt; 类型的值。在&lt;em&gt;for&lt;/em&gt;循环内&lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;调用&lt;/a&gt;它，然后将返回值分配给 &lt;code&gt;accumulator&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">在上面的示例中，JVM目标的生产源通过其 &lt;code&gt;main&lt;/code&gt; 编译进行编译，因此包括来自源集 &lt;code&gt;jvmMain&lt;/code&gt; 和 &lt;code&gt;commonMain&lt;/code&gt; 的源和依赖项（由于&lt;em&gt;取决于&lt;/em&gt;关系）：</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">在下面的示例中，我们假设有一个 &lt;code&gt;DbModel&lt;/code&gt; 基类，并且每个子类都有一个无参数的主构造函数。在内联函数中，对 &lt;code&gt;T&lt;/code&gt; 进行了归一化，因此我们可以获得类元数据。我们将此传递给执行与数据库对话的实际工作的函数。</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">在该示例中，我们采用了最流行的方式来传递或接收C语言中的字符串。我们应该小心地返回 &lt;code&gt;return_string&lt;/code&gt; 。通常，最好确保我们使用正确的函数通过正确的 &lt;code&gt;free(..)&lt;/code&gt; 函数调用来处理返回的 &lt;code&gt;char*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c4a8189e026c3c979db7e1d0680469a7fc5819f" translate="yes" xml:space="preserve">
          <source>In the file &lt;code&gt;build.gradle&lt;/code&gt;(&lt;code&gt;.kts&lt;/code&gt;), it creates the &lt;code&gt;kotlin&lt;/code&gt; extension at the top level, which includes configuration for &lt;a href=&quot;#targets&quot;&gt;targets&lt;/a&gt;, &lt;a href=&quot;#source-sets&quot;&gt;source sets&lt;/a&gt;, and dependencies.</source>
          <target state="translated">在文件 &lt;code&gt;build.gradle&lt;/code&gt; （ &lt;code&gt;.kts&lt;/code&gt; ）中，它在顶层创建 &lt;code&gt;kotlin&lt;/code&gt; 扩展名，其中包括对&lt;a href=&quot;#targets&quot;&gt;target&lt;/a&gt;，&lt;a href=&quot;#source-sets&quot;&gt;源集&lt;/a&gt;和依赖项的配置。</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">在下面的示例中， &lt;code&gt;findViewById()&lt;/code&gt; 仅被调用一次：</target>
        </trans-unit>
        <trans-unit id="85d9d8db073dbd0210787c9cf3ee16c0de44fcc4" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;@Foo&lt;/code&gt; annotation on the &lt;code&gt;String&lt;/code&gt; type can be emitted to the bytecode and then used by the library code:</source>
          <target state="translated">在下面的示例中，可以将 &lt;code&gt;String&lt;/code&gt; 类型的 &lt;code&gt;@Foo&lt;/code&gt; 注释发送到字节码，然后由库代码使用：</target>
        </trans-unit>
        <trans-unit id="b6112ecb85c5a211c4961aa021f824a1d2e0e8f5" translate="yes" xml:space="preserve">
          <source>In the future, we are going to make the Kotlin Project Wizard even more flexible by adding more configuration options and templates.</source>
          <target state="translated">未来,我们将通过增加更多的配置选项和模板,使Kotlin项目向导更加灵活。</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">在生成的Kotlin声明中，我们看到 &lt;code&gt;str&lt;/code&gt; 表示为 &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; 。该类型是可为空的，我们可以简单地将Kotlin &lt;code&gt;null&lt;/code&gt; 作为参数值传递。</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">在生成的代码中，调用 &lt;code&gt;provideDelegate&lt;/code&gt; 方法以初始化辅助 &lt;code&gt;prop$delegate&lt;/code&gt; 属性。比较属性声明 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 的生成代码：使用MyDelegate（）键入&lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;上面&lt;/a&gt;的生成代码（当不提供 &lt;code&gt;provideDelegate&lt;/code&gt; 方法时）：</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">在最后一行，使用&lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android扩展&lt;/a&gt;插件通过 &lt;code&gt;id&lt;/code&gt; 引用了 &lt;code&gt;button&lt;/code&gt; 。考虑使用此插件作为替代方案，它使您可以将绑定逻辑保留在代码中，并同时具有简洁的语法。</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">在最后一行，有一个隐式的 &lt;code&gt;this.&lt;/code&gt; 在 &lt;code&gt;memberFunction()&lt;/code&gt; 和 &lt;code&gt;memberProperty&lt;/code&gt; 前面（如果它们存在于 &lt;code&gt;someExpression&lt;/code&gt; 类型上）。返回值是最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">在下一个对话框中,提供项目细节。</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">在旧模型中，需要将通用代码和特定于平台的代码放置在单独的模块中，并按 &lt;code&gt;expectedBy&lt;/code&gt; 依赖关系进行链接。现在，通用代码和特定于平台的代码被放置在同一模块的不同源根目录中，从而使项目更易于配置。</target>
        </trans-unit>
        <trans-unit id="f4616b5b5607f26fa0ff8085e2e0b28efc427ec9" translate="yes" xml:space="preserve">
          <source>In the panel on the left, select &lt;strong&gt;Kotlin&lt;/strong&gt;.</source>
          <target state="translated">在左侧面板中，选择&lt;strong&gt;Kotlin&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">在存在 &lt;code&gt;maven-publish&lt;/code&gt; 插件的情况下，将创建所有已构建二进制文件的发布。该插件使用Gradle元数据发布构件，因此必须启用此功能（请参阅&lt;a href=&quot;#dependencies&quot;&gt;依赖项&lt;/a&gt;部分）。</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">在前面的示例中，JavaScript模块导出单个包。但是，某些JavaScript库从模块内部导出多个包。Kotlin也支持这种情况，尽管您必须为导入的每个包声明一个新的 &lt;code&gt;.kt&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="2335f133bdfdd7a364b034cd26ff1377b715b5ad" translate="yes" xml:space="preserve">
          <source>In the progressive mode, deprecations and bug fixes for unstable code take effect immediately, instead of going through a graceful migration cycle. Code written in the progressive mode is backwards compatible; however, code written in a non-progressive mode may cause compilation errors in the progressive mode.</source>
          <target state="translated">在渐进模式下,不稳定代码的弃用和错误修复会立即生效,而不是经过一个优雅的迁移周期。在渐进模式下编写的代码是向后兼容的;但是,在非渐进模式下编写的代码可能会在渐进模式下导致编译错误。</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">在教程中我们将学习。</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">在本教程中,我们。</target>
        </trans-unit>
        <trans-unit id="91d34ec07b8ea3ab8718a88b953168add8f0c256" translate="yes" xml:space="preserve">
          <source>In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">在这些示例中，&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;始终安装到在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope中&lt;/a&gt;创建的协程中。将异常处理程序安装到在主&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;范围内启动的协程中没有意义，因为尽管已安装了处理程序，但当其子级异常完成时，主协程将始终被取消。</target>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">在这种情况下,编译器将不会被插件下载。</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">在这种情况下，JQuery将作为名为 &lt;code&gt;jquery&lt;/code&gt; 的模块导入。另外，它可以用作$对象，具体取决于Kotlin编译器配置使用的模块系统。</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">在这种情况下，我们已将编译的输出设置为 &lt;code&gt;scripts&lt;/code&gt; 文件夹。在运行应用程序时，我们应该看到以下输出：</target>
        </trans-unit>
        <trans-unit id="b5a6a88d0b58461497da6e47e4eb3bdd5fbf2b22" translate="yes" xml:space="preserve">
          <source>In this case, you can share code across native targets in your project using the hierarchical structure.</source>
          <target state="translated">在这种情况下,你可以在你的项目中使用层次结构在本地目标之间共享代码。</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">在这个密集的代码中，除了集合转换之外，您还可以看到便利的Kotlin功能（例如局部函数和&lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis运算符&lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 可以表达简洁明了的&lt;a href=&quot;../reference/idioms&quot;&gt;习惯用法，&lt;/a&gt;例如&amp;ldquo;取正则取值，否则使用长度&amp;rdquo;。可读的表达式，例如 &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; ，但是对于Kotlin来说，创建其他可变变量并以命令式方式表示相同的代码也很好。</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">在本文档中,我们有时会不必要地指定类型,以突出表达式产生的是什么类型。(另外,一个好的IDE将能够向你展示产生的类型。)</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">在本文档中,我们介绍了几种兼容性。</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">在此示例中，仅最近的隐式接收者 &lt;code&gt;this@head&lt;/code&gt; 必须可用； &lt;code&gt;head()&lt;/code&gt; 是外部接收者 &lt;code&gt;this@html&lt;/code&gt; 的成员，因此调用它必须是非法的。</target>
        </trans-unit>
        <trans-unit id="9c36d65c210f75f6cba412252945fedc98c222bc" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">在此示例中，我们使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;在后台线程池中启动了一个新协程，因此它在与线程池不同的线程上工作，但是它仍然具有我们使用 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; ，无论协程在哪个线程上执行。因此，输出（带有&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;）为：</target>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">在此示例中，我们使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;在后台线程池中启动了一个新协程，因此它可以在与线程池不同的线程上工作，但是它仍然具有我们使用 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; 指定的线程局部变量的值。（value =&amp;ldquo; launch&amp;rdquo;），无论协程执行在哪个线程上。因此，输出（带有&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;）为：</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">在此示例中，所有传递给C API &lt;code&gt;new_menu()&lt;/code&gt; 的值都具有其所属的最内部 &lt;code&gt;memScope&lt;/code&gt; 的生存期。一旦控制流离开 &lt;code&gt;memScoped&lt;/code&gt; 范围，则C指针将变为无效。</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">在这个例子中,构造函数取一个地图。</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">在这个例子中,序列处理需要18步,而不是对列表进行同样的处理需要23步。</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">在此示例中，使用上一节中的 &lt;code&gt;Person&lt;/code&gt; 和 &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; ，我们按名称查找成员函数引用并对其进行调用：</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">在此函数中，&lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt;和&lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt;可以在运行暂停功能的同一堆栈帧中同步使用，也可以稍后在同一线程或不同执行线程中异步使用。重复调用任何恢复函数都会产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">在此函数中，&lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt;和&lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt;可以在运行暂停函数的同一堆栈帧中同步使用，也可以稍后在同一线程或不同执行线程中异步使用。随后调用任何resume函数将产生一个&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">在本节中，显示了注释的DSL。另请参见使用此插件的示例项目，例如&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;，&lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http客户端&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">在本教程中,我们将学习如何。</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">但是，在本教程中，我们将看到如何使用某些特定的库，例如 &lt;code&gt;libcurl&lt;/code&gt; 。我们将学习</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">在本教程中,我们有。</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">在本教程中,我们将看到如何在Kotlin/Native中处理C字符串。我们将学习如何</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">在本教程中,我们将利用Kotlin的代码共享功能,创建一个iOS和Android应用程序。对于Android,我们将使用Kotlin/JVM,而对于iOS,将使用Kotlin/Native。</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">在本教程中,我们将看到如何做到</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">在本教程中,我们将介绍使用Kotlin Android Extensions插件所需的步骤,提升Android开发的体验。</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将逐步完成所需的步骤。有关Spring Boot和Kotlin的更详尽说明，请参阅&lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;使用Spring Boot和Kotlin构建Web应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">在本教程中,我们将。</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将使用IntelliJ IDEA。有关如何使用命令行编译器编译和执行Kotlin应用程序的说明，请参阅&lt;a href=&quot;command-line&quot;&gt;使用命令行编译器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">在本教程中,我们已经看到了如何创建一个以JavaScript为目标的Kotlin应用程序,调试它以及设置编译器选项。在其他教程中,我们将涉及更深入的主题,如与DOM的交互等。</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">在本教程中,我们将学习哪些C数据类型在Kotlin/Native中可见,反之亦然。我们将</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">在本教程中，我们将研究如何从现有的本机应用程序或库中使用Kotlin / Native代码。为此，我们需要将Kotlin代码编译为动态库 &lt;code&gt;.so&lt;/code&gt; ， &lt;code&gt;.dylib&lt;/code&gt; 和 &lt;code&gt;.dll&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0865fef18032d86f743ee83bf90f480e5f932289" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native.</source>
          <target state="translated">在本教程中,我们将从JVM、JS和Native的世界中构建一个可用的小库。</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">在本教程中,我们将建立一个可从JVM、JS和Native世界中获得的小库。你将逐步学习如何创建一个多平台库,它可以从任何其他通用代码(例如,一个与Android和iOS共享的代码),以及如何编写将在所有平台上执行的测试,并使用具体平台提供的有效实现。</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">在本教程中,我们将探讨如何在macOS和iOS上使用Objective-C和Swift应用程序的Kotlin/Native代码。我们将从Kotlin代码构建一个框架。</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">在本教程中,我们将。</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">在本教程中,我们将看一看如何进行以下操作</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将使用Gradle，但是可以使用IntelliJ IDEA项目结构或Maven来实现相同的目的。有关设置Gradle与Kotlin一起&lt;a href=&quot;../reference/using-gradle&quot;&gt;使用的&lt;/a&gt;详细信息，请参阅《使用Gradle》。</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">在本教程中，我们将使用Gradle，但是可以使用IntelliJ IDEA项目结构或Maven来实现相同的目的。有关设置Gradle与Kotlin一起&lt;a href=&quot;../reference/using-gradle&quot;&gt;使用的&lt;/a&gt;详细信息，请参阅《使用Gradle》。使用HTTP servlet所需的主要依赖关系是JavaEE API：</target>
        </trans-unit>
        <trans-unit id="40ab0f9121b36c46d899b6425de4821ece3db190" translate="yes" xml:space="preserve">
          <source>In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</source>
          <target state="translated">在这段视频中,Kotlin开发者倡导者Sebastian Aigner将向你解释Kotlin/JS的主要好处,分享一些技巧和用例,还将告诉你Kotlin/JS的计划和即将推出的功能。</target>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">反过来， &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;also&lt;/code&gt; 将上下文对象作为lambda参数。如果未指定参数名称，则使用隐式默认名称 &lt;code&gt;it&lt;/code&gt; 来访问对象。 &lt;code&gt;it&lt;/code&gt; 比 &lt;code&gt;this&lt;/code&gt; 短，并且带有 &lt;code&gt;it&lt;/code&gt; 表达式通常更易于阅读。但是，在调用对象函数或属性时，您没有像 &lt;code&gt;this&lt;/code&gt; 隐式可用的对象。因此，具有的上下文对象作为 &lt;code&gt;it&lt;/code&gt; 是更好当对象被主要用作在函数调用的参数。 &lt;code&gt;it&lt;/code&gt; 也更好，如果你在代码块中使用多个变量。</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">反过来，可变集合不是协变的。否则，将导致运行时失败。如果 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 是 &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; 的子类型，则可以在其中插入其他 &lt;code&gt;Shape&lt;/code&gt; 继承者（例如 &lt;code&gt;Circle&lt;/code&gt; ），从而违反其 &lt;code&gt;Rectangle&lt;/code&gt; 类型参数。</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">反过来，set并不是&lt;a href=&quot;collections-overview&quot;&gt;定义&lt;/a&gt;为有序集合。但是，Kotlin &lt;code&gt;Set&lt;/code&gt; 按某些顺序存储元素。这些可以是插入顺序（在 &lt;code&gt;LinkedHashSet&lt;/code&gt; 中），自然排序顺序（在 &lt;code&gt;SortedSet&lt;/code&gt; 中）或其他顺序。一组元素的顺序也可以是未知的。在这种情况下，元素仍然会以某种方式排序，因此依赖元素位置的函数仍会返回其结果。但是，除非调用者知道所使用 &lt;code&gt;Set&lt;/code&gt; 的特定实现，否则它们对调用者是不可预测的。</target>
        </trans-unit>
        <trans-unit id="26d300702c75a3b26e8ba1f4228f68dc28aca421" translate="yes" xml:space="preserve">
          <source>In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</source>
          <target state="translated">而工作表则是项目文件:它们存储在项目目录中,并与项目模块绑定。工作表对于编写代码部分很有用,这些代码部分实际上并不构成一个软件单元,但仍然应该一起存储在一个项目中。例如,您可以将工作表用于教育或演示材料。</target>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">在您的scratch中,您可以编写任何有效的Kotlin代码,包括新的函数和类。在scratches中支持IntelliJ IDEA的语法高亮、自动完成和其他代码编辑功能。</target>
        </trans-unit>
        <trans-unit id="5ab1113b4018a56db06428b02b9d9a142cf8f11e" translate="yes" xml:space="preserve">
          <source>Include Java sources in JVM compilations</source>
          <target state="translated">在JVM编译中包含Java源码。</target>
        </trans-unit>
        <trans-unit id="3348bba79393338a33249573a6e3c773462946f1" translate="yes" xml:space="preserve">
          <source>Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</source>
          <target state="translated">在classpath中包含指定位置的自定义JDK,而不是默认的JAVA_HOME。</target>
        </trans-unit>
        <trans-unit id="a9e17f8d5ea37546d212a719c404957805afefc8" translate="yes" xml:space="preserve">
          <source>Include the Kotlin runtime into the resulting JAR file. Makes the resulting archive runnable on any Java-enabled environment.</source>
          <target state="translated">在生成的JAR文件中包含Kotlin运行时。使得生成的存档可以在任何Java环境下运行。</target>
        </trans-unit>
        <trans-unit id="bcb9fe75af30595cd7b7cb634e1bb8d624522edb" translate="yes" xml:space="preserve">
          <source>Include the native bitcode library.</source>
          <target state="translated">包括原生位码库。</target>
        </trans-unit>
        <trans-unit id="e2d58567583dee9bd57b8d9341149118d1dbe174" translate="yes" xml:space="preserve">
          <source>Includes Java sources into the JVM target&amp;rsquo;s compilations.</source>
          <target state="translated">将Java源代码包含在JVM目标的编译中。</target>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">在你的klib中加入静态库</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">不兼容的变化</target>
        </trans-unit>
        <trans-unit id="c39322316343eb0abd4a312f2f7bc80b85919258" translate="yes" xml:space="preserve">
          <source>Inconsistent behavior of floating-point number comparisons</source>
          <target state="translated">浮点数比较的行为不一致</target>
        </trans-unit>
        <trans-unit id="972d0a464d55eb6f53d336a20851a05ba6148f80" translate="yes" xml:space="preserve">
          <source>Incorrect generic signature in annotations when KClass is used as a generic parameter</source>
          <target state="translated">当使用KClass作为通用参数时,注释中的通用签名不正确。</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">递增式编译</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">增量注解处理(自1.3.30起)。</target>
        </trans-unit>
        <trans-unit id="29106d30f82b4fbf8a046db084591a963e0208cc" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">从版本1.3.50开始默认启用增量注释处理。要禁用增量注释处理，请将此行添加到 &lt;code&gt;gradle.properties&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">递增式汇编</target>
        </trans-unit>
        <trans-unit id="3bb3cfba326a2bdc90f381639a6d53003c8fb9e7" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</source>
          <target state="translated">Kotlin/JVM和Kotlin/JS项目支持增量编译。</target>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">Kotlin/JVM和Kotlin/JS项目支持增量编译。自Kotlin 1.1.1(Kotlin/JVM)和1.3.20(Kotlin/JS)以来,它是默认启用的。</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">递增版本带来了工具的更新(通常包括功能)、性能的改进和错误的修复。我们尽量保持这些版本之间的兼容性,所以对编译器的修改主要是优化和警告的添加/删除。当然,实验性功能可能会在任何时候被添加、删除或更改。</target>
        </trans-unit>
        <trans-unit id="36431db4a12e3c14e9de849f36b5befe35ed62b5" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">递增版本带来了工具的更新(通常包括功能)、性能的改进和错误的修复。我们试图让这些版本相互兼容,所以对编译器的改变主要是优化和警告的添加/删除。当然,预稳定的特性可能会在任何时候被添加、删除或更改。</target>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">递增和递减</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">将值增加&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt;并返回新值。</target>
        </trans-unit>
        <trans-unit id="b0f32b37b99e84f7a892589880d018ef9b908ef9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">将值增加&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt;并返回新值。</target>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">将值增加&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt;并返回新值。</target>
        </trans-unit>
        <trans-unit id="166f962aa69e44913e0b39e6fa68583a02fd3a79" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">将值增加&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt;并返回新值。</target>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">增加该值。</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">将数值增加1。</target>
        </trans-unit>
        <trans-unit id="e3d31147233f60ba2779d580d821b70c26574217" translate="yes" xml:space="preserve">
          <source>Indeed, its design was inspired by Reactive Streams and its various implementations. But Flow main goal is to have as simple design as possible, be Kotlin and suspension friendly and respect structured concurrency. Achieving this goal would be impossible without reactive pioneers and their tremendous work. You can read the complete story in &lt;a href=&quot;https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4&quot;&gt;Reactive Streams and Kotlin Flows&lt;/a&gt; article.</source>
          <target state="translated">确实，它的设计受到了Reactive Streams及其各种实现的启发。但是Flow的主要目标是拥有尽可能简单的设计，是Kotlin和悬浮友好且尊重结构化的并发。没有积极的开拓者和他们的巨大努力，实现这一目标将是不可能的。您可以在&lt;a href=&quot;https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4&quot;&gt;Reactive Streams和Kotlin Flows&lt;/a&gt;文章中阅读完整故事。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">索引访问操作者</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="2606e49e237c315e21ba9ad3205e46744904acbb" translate="yes" xml:space="preserve">
          <source>Indexing suffix</source>
          <target state="translated">索引后缀</target>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">表示是否有其他对象 &quot;等于 &quot;这个对象。执行时必须满足以下要求:</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">指示正则表达式是否可以在指定的&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;输入中&lt;/a&gt;找到至少一个匹配项。</target>
        </trans-unit>
        <trans-unit id="51429e87bd819bb2f3942329861eee4721f512b8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">指示正则表达式是否可以在指定的&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;输入中&lt;/a&gt;找到至少一个匹配项。</target>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">指示正则表达式是否与整个&lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;输入&lt;/a&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="b98c0b71834f5e2d5a0d8cf79e50cdeebb2945aa" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">指示正则表达式是否与整个&lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;输入&lt;/a&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">命名函数的Infix调用</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">Infix函数调用的优先级低于算术运算符，类型强制转换和 &lt;code&gt;rangeTo&lt;/code&gt; 运算符。以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">填充功能</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">下位法</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">来自显式浇铸的信息被用于类型推理。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">从Java类继承</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">导致 &lt;code&gt;copy&lt;/code&gt; 冲突的继承已在Kotlin 1.2中被警告弃用，在Kotlin 1.3中将是错误。</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">继承的功能</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">继承属性</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">继承的内置功能</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">用 &lt;code&gt;String&lt;/code&gt; 类型或原始类型的值初始化</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">在并发访问未初始化的&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例值时，可以多次调用Initializer函数，但是只有第一个返回的值将用作&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例的值。</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">列表的初始化函数</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">如果尚未初始化,则初始化当前线程的Kotlin运行时。</target>
        </trans-unit>
        <trans-unit id="4bf76bf156ef56b953245fb5da4ea73be4ae4d91" translate="yes" xml:space="preserve">
          <source>Initiates a call to this deep recursive function, forming a root of the call tree.</source>
          <target state="translated">启动对这个深层递归函数的调用,形成调用树的根。</target>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">可以内联Lambda表达式只能被称为内联函数中或可以内联参数传递，但 &lt;code&gt;noinline&lt;/code&gt; 始终们可以在任何我们喜欢的方式来处理：在存储领域，围绕等通过</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">内联JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">内联标记</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">内联类</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">内联类允许从接口继承。</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">内联类仅自Kotlin 1.3起可用，目前仍处于&lt;em&gt;实验阶段&lt;/em&gt;。请参阅&lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;下面的&lt;/a&gt;详细信息</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">内联类仅自Kotlin 1.3起可用，目前仍处于&lt;em&gt;实验阶段&lt;/em&gt;。看到细节&lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;的参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fe109e560117398094720f2c3a634950943781d" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">内联类仅自Kotlin 1.3起可用，并且当前处于&lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha中&lt;/a&gt;。看到细节&lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;的参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ad02ddc63db8ea1a5da350db44423e72064462a" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">内联类仅自Kotlin 1.3起可用，并且当前位于&lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha中&lt;/a&gt;。请参阅&lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;下面的&lt;/a&gt;详细信息</target>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">内联类支持常规类的一些功能。特别是,它们被允许声明属性和函数。</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">内联类与类型别名</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">在平台类型的null值上调用的内联扩展函数没有检查接收器是否为null,因此会允许null逃逸到其他代码中。Kotlin 1.2在调用站点强制进行这种检查,如果接收器为空,则抛出异常。</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">内联函数在&lt;a href=&quot;inline-functions&quot;&gt;此处&lt;/a&gt;进行说明。</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">内联函数现在允许为其内联函数参数设置默认值。</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">带有经过&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;修饰的类型参数的&lt;/a&gt;内联函数在每个调用站点上都会内联其实际的类型参数，这使 &lt;code&gt;arg is T&lt;/code&gt; 检查类型参数，但是如果 &lt;code&gt;arg&lt;/code&gt; 是泛型类型本身的实例，则&lt;em&gt;其&lt;/em&gt;类型参数仍会被擦除。例：</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">带有默认功能参数的内联函数</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">内联属性(从1.1开始</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">内联属性访问器</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">内联可能会导致生成的代码增长;然而,如果我们以合理的方式进行内联(即避免内联大型函数),它将在性能上得到回报,特别是在循环内的 &quot;巨变形 &quot;调用点。</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">内部班级</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">继承 &lt;code&gt;Throwable&lt;/code&gt; 的内部类从外部类捕获通用参数</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">从 &lt;code&gt;Throwable&lt;/code&gt; 继承的泛型类型的内部类在抛出捕获场景中可能会违反类型安全性，因此已被弃用，在Kotlin 1.2中发出警告，在Kotlin 1.3中出现错误。</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将指定集合&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素的&lt;/a&gt;所有元素插入此列表中的指定&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="005fc2603487998262e6a4431116600f620b75a0" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将指定集合&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;元素的&lt;/a&gt;所有元素插入此列表中的指定&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将指定集合&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素的&lt;/a&gt;所有元素插入此列表中的指定&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="602fbcd913879c3c9b700203739e32c4a9b2050d" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将指定集合&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;元素的&lt;/a&gt;所有元素插入此列表中的指定&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="043751f897f4eb9dc49253608d3dad5a3c113e89" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中的指定&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc5d1b50a39baeed86e36617a548438e3f127155" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中的指定&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e37de1820797a87c23300e79e4b0ed919d09e2a" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中的指定&lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27480ec1869e9733f33a48ab29f659fcb2a460a3" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符数组&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;值&lt;/a&gt;的子数组中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
