<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="0751e96b7b08da95e20ff3bc7df0567c20077897" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符数组&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;值&lt;/a&gt;的子数组中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="3e04a0c39fa9e9ba6f8f7b53f66419ea35f91587" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符数组&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;值&lt;/a&gt;的子数组中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="990caaef55fa9369abe10fe21e08b659ee5241e9" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符序列&lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq的子&lt;/a&gt;序列中的字符插入到此字符串构建器中的指定&lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="56381b6576df78ab7498f4c21ed74ffb38fce356" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符序列&lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq的子&lt;/a&gt;序列中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="13ca00255e68344adaf9baf7d5fd54a64418b339" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符序列&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;值的子&lt;/a&gt;序列中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="f16ec6bfc81f5c607f3cb9b48f5e7a410c32c025" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符序列&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;值的子&lt;/a&gt;序列中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="b15a142e3f1c0e94cad906174d3311d39fef798f" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符序列&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;值的子&lt;/a&gt;序列中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="98e8ddbbdefb8f6d9c8e1f1a1ec159981fb75050" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符数组&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;值&lt;/a&gt;中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="8bd299382c17ed7be741a94000ce27e3cb569545" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定字符序列&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;值&lt;/a&gt;中的字符插入到此字符串构建器中的指定&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="c10488d941ff5f739e50f3ed8d100fc28145f09c" translate="yes" xml:space="preserve">
          <source>Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定的字符&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;值&lt;/a&gt;插入到此字符串生成器中的指定&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="ad678e17f874b23d4231a5cb1e5b3edfa0684922" translate="yes" xml:space="preserve">
          <source>Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将字符串&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;值&lt;/a&gt;插入到此字符串生成器中的指定&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="cb5279ca89113fa744f9ed912c21f45c93146fab" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定布尔&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;值&lt;/a&gt;的字符串表示形式插入此字符串生成器中的指定&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="b8ce5257d0d44bc8ee828b4f0aa168d27143f4fc" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">将指定对象&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;值&lt;/a&gt;的字符串表示形式插入此字符串生成器中的指定&lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;索引处，&lt;/a&gt;并返回此实例。</target>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">在一个类中，您可以声明另一个类的扩展。在这种扩展内部，有多个&lt;em&gt;隐式接收器&lt;/em&gt; -无需限定符即可访问其对象的成员。声明扩展的类的实例称为&lt;em&gt;调度接收器&lt;/em&gt;，扩展方法的接收器类型的实例称为&lt;em&gt;扩展接收器&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">内的功能的 &lt;code&gt;vararg&lt;/code&gt; 类型的-parameter &lt;code&gt;T&lt;/code&gt; 是可见的阵列 &lt;code&gt;T&lt;/code&gt; ，即， &lt;code&gt;ts&lt;/code&gt; 在例如上述可变型具有 &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">在带有接收器的lambda表达式中，您可以使用 &lt;code&gt;this&lt;/code&gt; 来引用接收器对象（在本例中为 &lt;code&gt;car&lt;/code&gt; ）。像往常一样，如果没有命名冲突，则可以忽略 &lt;code&gt;this&lt;/code&gt; ，这就是为什么我们可以简单地说 &lt;code&gt;$horsepowers&lt;/code&gt; &lt;code&gt;${this.horsepowers}&lt;/code&gt; 而不是$ {this.horsepowers}的原因。请注意，在Kotlin中， &lt;code&gt;this&lt;/code&gt; 取决于上下文可能具有不同的含义：如果在带有接收器的lambda表达式内部（可能是嵌套的）中使用，它指的是带有接收器的最内层lambda表达式的接收器对象。如果您需要&amp;ldquo;突破&amp;rdquo;函数文字并获得&amp;ldquo;原始&amp;rdquo;字样， &lt;code&gt;this&lt;/code&gt; （您正在执行的内部成员函数的实例），请在 &lt;code&gt;this@&lt;/code&gt; 之后提及包含的类名-因此，如果您位于Car的成员函数内部的带有接收者的函数文字中，请使用 &lt;code&gt;this@Car&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">在内部类内部，访问外部类的超类是通过使用外部类名称为 &lt;code&gt;super@Outer&lt;/code&gt; 限定的&lt;em&gt;super&lt;/em&gt;关键字完成的：</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">由于初始化逻辑中的问题，在枚举条目内部定义了不是 &lt;code&gt;inner class&lt;/code&gt; 的嵌套类型已被弃用。这会在Kotlin 1.2中引起警告，并在Kotlin 1.3中成为错误。</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">里面的 &lt;code&gt;apply&lt;/code&gt; 模块， &lt;code&gt;this&lt;/code&gt; 是指 &lt;code&gt;maybeNull&lt;/code&gt; 。这里有一个隐含的 &lt;code&gt;this&lt;/code&gt; 前面 &lt;code&gt;memberPropertyA&lt;/code&gt; ， &lt;code&gt;memberPropertyB&lt;/code&gt; 和 &lt;code&gt;memberFunctionA&lt;/code&gt; （除非这些根本不存在的 &lt;code&gt;maybeNull&lt;/code&gt; ，在这种情况下，他们将会在包含范围来寻找）。之后，还会在 &lt;code&gt;maybeNull&lt;/code&gt; 上调用 &lt;code&gt;memberFunctionB()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="201f7c7f50eead5096b8205dfcee81a61ab42986" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;kotlin&lt;/code&gt; section, you can manage the following aspects:</source>
          <target state="translated">在 &lt;code&gt;kotlin&lt;/code&gt; 部分中，您可以管理以下方面：</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">在函数文字的主体内部，传递给调用的接收者对象将成为&lt;em&gt;隐式&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;，因此您可以在没有任何其他限定符的情况下访问该接收者对象的成员，或者使用&lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 表达式&lt;/a&gt;访问接收者对象。</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">在声明lateinit属性的类里面,你可以检查它是否已经被初始化。</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">在文件内部，相应的第一级标题介绍了整个模块和单个软件包的文档。标题文本对于模块必须是&amp;ldquo;模块 &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; &amp;rdquo;，对于包必须是&amp;ldquo; 包 &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">在作用域函数的lambda中，可以通过短引用而不是其实际名称来使用上下文对象。每个范围函数使用两种访问上下文对象的方式之一：作为lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;接收器&lt;/a&gt;（ &lt;code&gt;this&lt;/code&gt; ）或作为lambda参数（ &lt;code&gt;it&lt;/code&gt; ）。两者都提供相同的功能，因此我们将描述每种情况在每种情况下的利弊，并提供有关其用法的建议。</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">检查从C库中生成的Kotlin API。</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">检查发行版的 &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; 的详细信息。</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">为C库检查生成的Kotlin APIs</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">安装自定义的未处理异常钩子。返回旧的钩子,如果没有指定钩子,则返回null。每当有未捕获的异常到达Kotlin世界的边界时,例如顶级的main(),或者当Objective-C对Kotlin的调用没有用@Throws标记时,就会调用Hook。钩子必须是一个冻结的lambda,这样它就可以从任何线程/工作站调用。钩子只被调用一次,之后会被清除,所以即使是自定义的异常钩子,内存泄漏检测也能如期进行。</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">安装 libgit2 并为 git 库准备存根。</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">安装&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome扩展程序&lt;/a&gt;，该扩展程序允许通过Chrome在IntelliJ IDEA内部进行调试。这对于使用IntelliJ IDEA开发的任何类型的Web应用程序都是有用的，而不仅仅是Kotlin。</target>
        </trans-unit>
        <trans-unit id="cba3ec3086c29abcbfa73fe1ec7eb10077b3664f" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</source>
          <target state="translated">安装&lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods依赖性管理器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7237a8f52f82477e8aca289f73e7feebfb253754" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt;&lt;code&gt;cocoapods-generate&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="translated">安装&lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt; &lt;code&gt;cocoapods-generate&lt;/code&gt; &lt;/a&gt;插件。</target>
        </trans-unit>
        <trans-unit id="d91d23355e44b9f891a149ed27d5dd594ef16726" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</source>
          <target state="translated">安装IDEA的&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools插件&lt;/a&gt;，并完成&lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans课程的&lt;/a&gt;练习</target>
        </trans-unit>
        <trans-unit id="a6c9c342f22b1bebf06cebee1a33f0bf01b82e59" translate="yes" xml:space="preserve">
          <source>Install the CocoaPods dependency manager and plugin</source>
          <target state="translated">安装CocoaPods依赖管理器和插件。</target>
        </trans-unit>
        <trans-unit id="1a87099d120ccde681dac7b4563f2ddd1e2d4aca" translate="yes" xml:space="preserve">
          <source>Install the Kotlin Plugin 1.4.x or higher in the IDE. You can check the Kotlin version in &lt;strong&gt;Tools&lt;/strong&gt; | &lt;strong&gt;Kotlin&lt;/strong&gt; | &lt;strong&gt;Configure Plugin Updates&lt;/strong&gt;.</source>
          <target state="translated">在IDE中安装Kotlin插件1.4.x或更高版本。您可以在&amp;ldquo;&lt;strong&gt;工具&amp;rdquo;&lt;/strong&gt; |&amp;ldquo;&lt;strong&gt;工具&amp;rdquo;中&lt;/strong&gt;查看Kotlin版本。&lt;strong&gt;科特林&lt;/strong&gt;| &lt;strong&gt;配置插件更新&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">安装EduTools插件</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">实例检查</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">实例领域</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">对成员进行调用所需的实例,或对内类构造函数进行外类实例。</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">实例化一个函数类型</target>
        </trans-unit>
        <trans-unit id="323fad682a062c4a52dfeb27dd2280fe7981b362" translate="yes" xml:space="preserve">
          <source>Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</source>
          <target state="translated">代替&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;，我们可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt;来实现&lt;em&gt;范围内的&lt;/em&gt;并发。它仅在一个方向上传播取消，并且仅在失败后才取消所有子项。就像&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;一样，它也等待所有孩子完成任务。</target>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">我们没有直接调用方法 &lt;code&gt;matches&lt;/code&gt; ，而是存储了对其的引用。这样的引用绑定到它的接收者。可以直接调用它（如上面的示例中一样），或者在需要函数类型的表达式时使用它：</target>
        </trans-unit>
        <trans-unit id="aad6314ddaef7ba86c76eaf3164d0bca4da5fc5d" translate="yes" xml:space="preserve">
          <source>Instead of creating a class that implements a functional interface manually, you can use a lambda expression. With a SAM conversion, Kotlin can convert any lambda expression whose signature matches the signature of the interface's single method into an instance of a class that implements the interface.</source>
          <target state="translated">与其手动创建一个实现功能接口的类,不如使用lambda表达式。通过SAM转换,Kotlin可以将任何签名与接口的单个方法签名相匹配的lambda表达式转换为实现该接口的类的实例。</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">编译器可以不为参数创建一个函数对象并生成一个调用,而是发出以下代码。</target>
        </trans-unit>
        <trans-unit id="07b156a4a7a7d22439a598737b46c70a6ec2b640" translate="yes" xml:space="preserve">
          <source>Instead of doing this, you can create a hierarchical structure with &lt;a href=&quot;mpp-share-on-platforms#use-target-shortcuts&quot;&gt;target shortcuts&lt;/a&gt; available for typical multi-target scenarios, or you can manually declare and connect the source sets. For example, you can create two iOS targets and a shared source set with the &lt;code&gt;ios()&lt;/code&gt; shortcut:</source>
          <target state="translated">代替执行此操作，您可以创建具有适用于典型多目标方案的&lt;a href=&quot;mpp-share-on-platforms#use-target-shortcuts&quot;&gt;目标快捷方式&lt;/a&gt;的层次结构，也可以手动声明并连接源集。例如，您可以使用 &lt;code&gt;ios()&lt;/code&gt; 快捷方式创建两个iOS目标和一个共享源集：</target>
        </trans-unit>
        <trans-unit id="db904fe60f6fc13954beaf8c6781a1e474eddead" translate="yes" xml:space="preserve">
          <source>Instead of manually compiling and executing our Kotlin/JS project every time we want to see the changes we made, we can make use of the &lt;em&gt;continuous compilation&lt;/em&gt; mode. Instead of using the regular &lt;code&gt;run&lt;/code&gt; command, we instead invoke the Gradle wrapper in &lt;em&gt;continuous&lt;/em&gt; mode:</source>
          <target state="translated">无需每次希望看到所做的更改时都手动编译并执行我们的Kotlin / JS项目，而是可以使用&lt;em&gt;连续编译&lt;/em&gt;模式。代替使用常规的 &lt;code&gt;run&lt;/code&gt; 命令，我们改为以&lt;em&gt;连续&lt;/em&gt;模式调用Gradle包装器：</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native运行时代替线程来提供工作程序的概念：同时执行的控制流和关联的请求队列。工人与&amp;ldquo;演员模型&amp;rdquo;中的演员非常相似。一个工作人员可以与另一个工作人员交换Kotlin对象，以便任何时候每个可变对象都由一个工作人员拥有，但是所有权可以转移。请参阅&lt;a href=&quot;#transfer&quot;&gt;对象传输和冻结部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">指示编译器为带有声明位置差异的参数对应的类型实参生成或忽略通配符，例如 &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; 具有。</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">指示编译器为注释类型参数生成通配符,这些参数对应于具有声明点差异的参数。</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">指示Kotlin编译器不要为这个属性生成getters/setters,而是将其作为一个字段公开。</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">指示Kotlin编译器为该函数生成替代默认参数值的重载。</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">指示Kotlin编译器将注释的Java类视为给定Kotlin接口的纯实现。&quot;Pure &quot;是指类的每个类型参数都成为该接口的非平台类型参数。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">与Python中任意大的整数相反，Kotlin中的整数类型的&lt;em&gt;大小有限&lt;/em&gt;。该限制取决于类型，该类型决定了该数字在内存中占据多少位：</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">整体式范围（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt;）有一个额外的功能：它们可以遍历。这些范围也是相应整数类型的&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;级数&lt;/a&gt;。这样的范围一般用于在迭代 &lt;code&gt;for&lt;/code&gt; 环路。</target>
        </trans-unit>
        <trans-unit id="13f8bf35d86cdecdc30977f1b4bf82da0dde4e54" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEA还可以自动生成 &lt;code&gt;@Suppress&lt;/code&gt; 批注。通过灯泡图标或Alt-Enter打开意向菜单，然后单击&amp;ldquo;更改类型参数&amp;rdquo;快速修复旁边的小箭头。在这里，您可以选择抑制作用域，您的IDE会相应地将注释添加到文件中。</target>
        </trans-unit>
        <trans-unit id="2bee37b0cdd0528c3a6b459962cdaf6bec045292" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEA还可以自动生成 &lt;code&gt;@Suppress&lt;/code&gt; 批注。通过灯泡图标或Alt-Enter打开意图菜单，然后单击&amp;ldquo;未经检查的投射到外部接口&amp;rdquo;检查旁边的小箭头。在这里，您可以选择抑制作用域，您的IDE会相应地将注释添加到文件中。</target>
        </trans-unit>
        <trans-unit id="10bb7deeea7ab770c8cc611de5a7e9bd46c52593" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA可以从头开始和从工作表中自动运行代码。要在停止输入时获得执行结果，请打开&amp;ldquo;&lt;strong&gt;交互&amp;rdquo;模式&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA可以自动刮擦。要在短时间内停止键入后获得执行结果，请打开&amp;ldquo; &lt;strong&gt;交互&amp;rdquo;模式&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="918971018a2752255f900c2cf2e714f49b6e48a7" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA opens the &lt;strong&gt;Run&lt;/strong&gt; tab and shows the output.</source>
          <target state="translated">IntelliJ IDEA打开&amp;ldquo;&lt;strong&gt;运行&amp;rdquo;&lt;/strong&gt;选项卡并显示输出。</target>
        </trans-unit>
        <trans-unit id="412b9a62ef1aac11c1728c644747bfbcd40b3ae6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA opens the &lt;strong&gt;Run&lt;/strong&gt; tab and shows the output:</source>
          <target state="translated">IntelliJ IDEA打开&amp;ldquo;&lt;strong&gt;运行&amp;rdquo;&lt;/strong&gt;选项卡并显示输出：</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA将在&lt;a href=&quot;#maven-configuration&quot;&gt;Maven配置中&lt;/a&gt;为我们添加相应的条目。</target>
        </trans-unit>
        <trans-unit id="eff2bf29e6c4ca5eac858ebfb9f2e0be07577de6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</source>
          <target state="translated">IntelliJ IDEA的kotlin插件了解 &lt;code&gt;TODO()&lt;/code&gt; 的语义，并自动在TODO工具窗口中添加代码指针。</target>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">与DOM互动</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">与DOM的交互</target>
        </trans-unit>
        <trans-unit id="4ee5033c0dc3e88efff33103b78dd8f7118a9355" translate="yes" xml:space="preserve">
          <source>Interactive editors</source>
          <target state="translated">互动式编辑</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">互动模式</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor进行&lt;/a&gt;拦截截取。</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor进行&lt;/a&gt;拦截截取。</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">拦截委托属性绑定</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">用&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;拦截此继续。</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">接口实现布局</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">表示在悬浮点之后的延续的接口，该延续返回类型 &lt;code&gt;T&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">接口中的悬浮液点后表示的延续这种类型的回报值 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">接口&lt;em&gt;A&lt;/em&gt;和&lt;em&gt;B&lt;/em&gt;都声明了函数&lt;em&gt;foo（）&lt;/em&gt;和&lt;em&gt;bar（）&lt;/em&gt;。它们都实现&lt;em&gt;foo（）&lt;/em&gt;，但是只有&lt;em&gt;B&lt;/em&gt;实现&lt;em&gt;bar（）&lt;/em&gt;（&lt;em&gt;A中&lt;/em&gt;没有将&lt;em&gt;bar（）&lt;/em&gt;标记为abstract ，因为如果函数没有主体，这是接口的默认值）。现在，如果我们从&lt;em&gt;A&lt;/em&gt;派生出具体的类&lt;em&gt;C&lt;/em&gt;，显然，我们必须重写&lt;em&gt;bar（）&lt;/em&gt;并提供一个实现。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">接口 继承</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin中的接口与Java 8非常相似。它们可以包含抽象方法的声明,以及方法实现。它们与抽象类的不同之处在于,接口不能存储状态,它们可以有属性,但这些属性需要是抽象的,或者提供访问器实现。它们可以有属性,但这些属性需要是抽象的,或者提供访问器实现。</target>
        </trans-unit>
        <trans-unit id="3dc6f1c623405f44dfc6225166b717008c4b39d3" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin中的接口可以包含抽象方法的声明,以及方法实现。它们与抽象类的不同之处在于,接口不能存储状态,它们可以有属性,但这些属性需要是抽象的,或者提供访问器实现。它们可以有属性,但这些属性需要是抽象的,或者提供访问器实现。</target>
        </trans-unit>
        <trans-unit id="6f2e69a2381964d98d7dca2d48b42c9749b41571" translate="yes" xml:space="preserve">
          <source>Intermediate flow operators</source>
          <target state="translated">中间流动操作者</target>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">与Java的互操作</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">与Java反射的互操作性</target>
        </trans-unit>
        <trans-unit id="2a2e730dccd30c2b052062769d22631b368b3446" translate="yes" xml:space="preserve">
          <source>Interoperability with Java reflection</source>
          <target state="translated">与Java反射的互操作性</target>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">还提供了与Swift / Objective-C的互操作性，并在单独的文档&lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="fc3ed9f2e2ef0d7ff8b99c31c5f5dfba491948e8" translate="yes" xml:space="preserve">
          <source>Introduce a local variable &lt;code&gt;name&lt;/code&gt; with the keyword &lt;code&gt;val&lt;/code&gt;. It will get its value from an input where you will enter your name &amp;ndash; &lt;code&gt;readLine()&lt;/code&gt;.</source>
          <target state="translated">用关键字 &lt;code&gt;val&lt;/code&gt; 引入一个局部变量 &lt;code&gt;name&lt;/code&gt; 。它将从输入中获取其值的地方输入名称&amp;ndash; &lt;code&gt;readLine()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">将表达式引入为局部作用域中的变量： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">Kotlin简介(俄语)</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">Kotlin编程介绍</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="f4afeb75d0f49bdd06579dbdb4f04043561414aa" translate="yes" xml:space="preserve">
          <source>Invariant projections of type arguments, such as &lt;code&gt;Smth&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt;, &lt;code&gt;Array&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">类型参数的不变投影，例如 &lt;code&gt;Smth&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt; ， &lt;code&gt;Array&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">将此值的位数反转。</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">将该值中包括符号位在内的位进行反转。</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">的调用&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt;直接在调用者的线程恢复协程无需经过去&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;可能存在的协程的&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。调用者有责任确保建立正确的调用上下文。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt;可用于获取截获的连续性。</target>
        </trans-unit>
        <trans-unit id="12923fefc07e48286763b781976e0602cda671d5" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">的调用&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt;直接在调用者的线程恢复协程无需经过去&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;可能存在的协程的&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。调用者有责任确保建立适当的调用上下文。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt;可用于获取截获的连续性。</target>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">调用操作员</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">当原始延续完成且不再使用时，为&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;返回的延续实例调用。仅当&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;返回的调用实例不同于其调用实例时，才调用此函数。</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">在函数对象上调用 &lt;code&gt;call()&lt;/code&gt; 将调用该函数。如果它是成员函数，则第一个参数必须是&lt;em&gt;接收者&lt;/em&gt;（要在其上调用函数的对象，在这种情况下为 &lt;code&gt;person&lt;/code&gt; ），而其余参数必须是普通的函数参数（在这种情况下为 &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ） 。</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">调用 &lt;code&gt;findViewById()&lt;/code&gt; 可能会很慢，尤其是在视图层次结构庞大的情况下，因此Android扩展会尝试通过在容器中缓存视图来最小化 &lt;code&gt;findViewById()&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">调用函数类型实例</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">在其他集合上调用函数</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">Kotlin是一种面向对象的语言还是一种功能型语言?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">Kotlin与Java编程语言兼容吗?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">Kotlin是免费的吗?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">Kotlin难吗?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">Kotlin在社交媒体上吗?</target>
        </trans-unit>
        <trans-unit id="4e2b800e686ee55bbeca8de0e7c4e9007eb7822f" translate="yes" xml:space="preserve">
          <source>Is Kotlin on social media?</source>
          <target state="translated">Kotlin在社交媒体上吗?</target>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">是扩展功能</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">有Kotlin会议吗?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">这不是我们一开始就想要的吗?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">在一个单独的JavaScript对象中隔离声明。</target>
        </trans-unit>
        <trans-unit id="d439914b4bf445ecb5fcbbcfd0b7501a29e97254" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</source>
          <target state="translated">以 &lt;code&gt;plain&lt;/code&gt; 模式隔离单独的JavaScript对象中的声明</target>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">它还可以与元注释一起使用。</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">可以通过一个在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中创建协程的简单示例来证明这一点：</target>
        </trans-unit>
        <trans-unit id="fafe915e21eb48d949ca0df5819ea5714df59866" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">一个简单的例子可以证明这一点，该例子使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;创建根协程：</target>
        </trans-unit>
        <trans-unit id="b2cb6066b03e8d078e05b9934f5a0885eb7115c7" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by the following example:</source>
          <target state="translated">可以通过下面的例子来证明。</target>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">当然，它可以作为单个表达式完成： &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">它演示了几种新技术。一种是在具有明确指定的上下文的情况下使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;，另一种是使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;函数更改协程的上下文，同时仍保持在同一协程中，如下面的输出所示：</target>
        </trans-unit>
        <trans-unit id="407d919d76eb160a2f5dfd9e474e1e25b6f6932e" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</source>
          <target state="translated">它演示了几种新技术。一种是在具有明确指定的上下文的情况下使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;，另一种是使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;函数更改协程的上下文，同时仍保留在同一协程中，如下面的输出所示：</target>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">actor本身在什么上下文中执行并不重要(为了正确性)。一个actor是一个coroutine,而一个coroutine是按顺序执行的,所以将状态限制在特定的coroutine中可以作为共享可变状态问题的一个解决方案。事实上,actor可以修改自己的私有状态,但只能通过消息来影响对方(避免任何锁的需要)。</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">它期望目标为 &lt;code&gt;writeLogMessage&lt;/code&gt; 提供特定于平台的实现，并且通用代码现在可以使用此声明，而无需考虑如何实现。</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">当你有一个可调用的引用而不是lambda时,使用它也很方便。</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">也可以在项目中配置所有的Kotlin编译任务。</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">也可以使用标准的Chrome调试器来调试Kotlin应用程序。只要确保你能生成源码图。</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">也可以通过任意步长（不一定为1）迭代数字。这是通过&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt;功能完成的。</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">一次性导入特定布局的所有widget属性,非常方便。</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">它是通过将 &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 函数附加到元素源来创建的。要获得&lt;a href=&quot;index&quot;&gt;分组&lt;/a&gt;的实例，请使用 &lt;code&gt;groupingBy&lt;/code&gt; 扩展功能之一：</target>
        </trans-unit>
        <trans-unit id="6148f03cfc2015e2c10414350a23c5c6eccbddac" translate="yes" xml:space="preserve">
          <source>It is currently prohibited to export the following kinds of declarations:</source>
          <target state="translated">目前禁止出口以下种类的申报:</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">很容易用行动来证明。</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">将编译的Kotlin代码包含到以C，C ++，Swift，Objective-C和其他语言编写的现有项目中很容易。使用现有的本机代码，静态或动态&lt;a href=&quot;native/c_interop&quot;&gt;C库&lt;/a&gt;，Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;框架&lt;/a&gt;，图形引擎以及直接来自Kotlin / Native的其他任何工具也很容易。</target>
        </trans-unit>
        <trans-unit id="a1e4c80fa63f2c717618535a583de6ba5b964535" translate="yes" xml:space="preserve">
          <source>It is easy to use flows to represent asynchronous events that are coming from some source. In this case, we need an analogue of the &lt;code&gt;addEventListener&lt;/code&gt; function that registers a piece of code with a reaction for incoming events and continues further work. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; operator can serve this role. However, &lt;code&gt;onEach&lt;/code&gt; is an intermediate operator. We also need a terminal operator to collect the flow. Otherwise, just calling &lt;code&gt;onEach&lt;/code&gt; has no effect.</source>
          <target state="translated">使用流来表示来自某个源的异步事件很容易。在这种情况下，我们需要一个 &lt;code&gt;addEventListener&lt;/code&gt; 函数的类似物，该函数可以注册一段代码以对传入事件做出反应，并继续进行进一步的工作。该&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt;操作可以起到这一作用。但是， &lt;code&gt;onEach&lt;/code&gt; 是中间运算符。我们还需要终端操作员来收集流。否则，仅调用 &lt;code&gt;onEach&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">对于Kotlin的C &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 类型，可以轻松使用生成的包装器类。由于生成了属性，因此在Kotlin代码中使用它们很自然。到目前为止，唯一的问题是我们如何在这些类上创建一个新实例。从 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 的声明中可以看到，它们的构造函数需要 &lt;code&gt;NativePtr&lt;/code&gt; 。当然，我们不愿意手动处理指针。相反，我们可以使用Kotlin API为我们实例化那些对象。</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">它相当于这段Java代码。</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">禁止内联类参与类层次结构。这意味着内联类不能扩展其他类，并且必须是&lt;em&gt;final&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">重要的是要注意，某些&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin / Native目标&lt;/a&gt;只能使用适当的主机构建：</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">重要的是要理解，就像在 &lt;code&gt;callAnything()&lt;/code&gt; 的情况下一样， &lt;code&gt;dataTable()&lt;/code&gt; 函数必须在运行时存在。在我们的情况下，我们需要确保包含插件的相应脚本文件：</target>
        </trans-unit>
        <trans-unit id="12337a359954227bfe96e37274de5fc654fa35be" translate="yes" xml:space="preserve">
          <source>It is not recommended that you publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">不建议您发布按产品风味分组的变体,以防它们有不同的依赖关系,因为这些依赖关系将被合并到一个依赖关系列表中。</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">不建议发布按产品风味分组的变体,以防它们有不同的依赖关系,因为这些变体会被合并到一个依赖关系列表中。</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">它不需要匹配目录和包:源文件可以任意放在文件系统中。</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">现在可以用一种通用的方式来枚举一个枚举类的值。</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">它是独立于平台的。无论我们是针对JVM、JavaScript还是其他平台,我们写的代码都是一样的。在掩护之下,编译器会负责让它适应每个平台。</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">类有可能像执行接口一样实现函数类型。然后，它必须提供带有给定签名的称为 &lt;code&gt;invoke&lt;/code&gt; 的运算符函数，然后可以将该类的实例分配给该函数类型的变量：</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">可以对通用类型的类型参数进行注解,以便为它们提供空性信息。例如,考虑一下Java声明中的这些注释。</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">可以一次性配置所有源集的语言设置。</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">可以使用 &lt;code&gt;memScoped { ... }&lt;/code&gt; 下的 &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 扩展属性创建 &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 实例的C表示形式的作用域稳定的指针。它允许使用需要C指针且生命周期绑定到某个 &lt;code&gt;MemScope&lt;/code&gt; 的API。例如：</target>
        </trans-unit>
        <trans-unit id="a1c523500d91947ee9765a964b978e521350e87f" translate="yes" xml:space="preserve">
          <source>It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt;. The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</source>
          <target state="translated">可以自定义将&lt;strong&gt;未捕获的&lt;/strong&gt;异常打印到控制台的默认行为。&lt;em&gt;根&lt;/em&gt;协程上的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt;上下文元素可用作该根协程及其可能进行自定义异常处理的所有子级的通用 &lt;code&gt;catch&lt;/code&gt; 块。它类似于&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt; &lt;/a&gt;。您无法从 &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; 中的异常中恢复。当调用处理程序时，协程已经完成，并带有相应的异常。通常，处理程序用于记录异常，显示某种错误消息，终止和/或重新启动应用程序。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">可以为您自己的函数声明合同，但是此功能是&lt;strong&gt;实验性的，&lt;/strong&gt;因为当前语法处于早期原型状态，并且很可能会更改。另外，请注意，当前Kotlin编译器不验证合同，因此编写正确和合理的合同是程序员的责任。</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">可以按全局过滤标题。 &lt;code&gt;.def&lt;/code&gt; 文件中的 &lt;code&gt;headerFilter&lt;/code&gt; 属性值被视为以空格分隔的glob列表。如果包含的标头与任何glob匹配，则来自此标头的声明将包含在绑定中。</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">在一个多平台库中,一个平台可以有多个目标。例如,这些目标可以提供相同的API,但在运行时与之合作的库不同,如测试框架或日志解决方案。</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">可以指定哪些构建类型将被用于创建二进制文件,哪些不会。在下面的例子中,只创建调试可执行文件。</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">拥有键列表并希望通过将这些键中的每个键与某个值相关联来构建映射是一种很常见的情况。以前可以通过 &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 函数来做到这一点，但是现在我们引入了一种更有效，更容易探索的替代方法： &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5af6059bcf4a05b2b995079d84a33266eddebc57" translate="yes" xml:space="preserve">
          <source>It is recommended to only provide external declarations manually in your source folder &lt;em&gt;or&lt;/em&gt; enabling the generation of external declarations at build time for any single dependency. Doing both can result in resolution issues.</source>
          <target state="translated">建议仅在源文件夹中手动提供外部声明，&lt;em&gt;或&lt;/em&gt;在构建时为任何单个依赖项启用外部声明的生成。两者都可能导致分辨率问题。</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 视为 &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; 是安全的-然后，您只能在其中添加 &lt;code&gt;Apple&lt;/code&gt; 实例，但这没关系，因为它可以接收任何 &lt;code&gt;Fruit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; 视为 &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 是安全的-它只会生产 &lt;code&gt;Apple&lt;/code&gt; 实例，但这没关系，因为 &lt;code&gt;Apple&lt;/code&gt; 是 &lt;code&gt;Fruit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">它与&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;条目&lt;/a&gt;集的hashCode相同。</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">现在该尝试从我们的Kotlin程序中使用C函数了。让我们调用 &lt;code&gt;accept_fun&lt;/code&gt; 函数并将C函数指针传递给Kotlin lambda：</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">这是声明类型参数T作为非常方便的&lt;em&gt;进行&lt;/em&gt;并避免麻烦子类型上使用的网站，但有些类&lt;strong&gt;不能&lt;/strong&gt;实际上只限于返回 &lt;code&gt;T&lt;/code&gt; 的！一个很好的例子是数组：</target>
        </trans-unit>
        <trans-unit id="776fdced037b223c21ef26795ae5fc999fa0ee3e" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</source>
          <target state="translated">它启动100K个coroutine,5秒后,每个coroutine打印一个点。</target>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">它启动了100K个coroutine,一秒钟后,每个coroutine打印一个点。现在,用线程试试。会发生什么?(很可能你的代码会产生某种内存外的错误)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">这就导致了在Kotlin中看到的以下签名。</target>
        </trans-unit>
        <trans-unit id="31157cfdb7da2c923cc250df2cdef99f52021252" translate="yes" xml:space="preserve">
          <source>It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</source>
          <target state="translated">它使添加和重新排序元素变得容易-如果您操作元素，则无需添加或删除逗号。</target>
        </trans-unit>
        <trans-unit id="17169e22fd37b9c0c61060b6531c5a37b04dbe03" translate="yes" xml:space="preserve">
          <source>It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</source>
          <target state="translated">它使版本控制差异更加清晰，因为所有焦点都集中在更改后的值上。</target>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">只有在没有通配符的情况下,在Java中声明似乎不方便使用时,它才会有帮助。</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">只有在Java中声明似乎不方便使用时,它才会有帮助。</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">通过切换IntelliJ IDEA中的默认值并使格式化与Kotlin编码约定保持一致来消除这种模糊性,这似乎是一个合乎逻辑的下一步。但这将意味着所有现有的Kotlin项目在安装Kotlin插件的那一刻就会启用新的代码风格。这其实并不是插件更新的预期结果吧?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">这意味着，在执行基类构造函数时，尚未初始化在派生类中声明或覆盖的属性。如果在基类初始化逻辑中使用了这些属性中的任何一个（直接或间接地通过另一个重写的&lt;em&gt;开放&lt;/em&gt;成员实现），则可能导致错误的行为或运行时失败。因此，在设计基类时，应避免在构造函数，属性初始化程序和&lt;em&gt;init&lt;/em&gt;块中使用&lt;em&gt;开放&lt;/em&gt;成员。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">可能会尝试使用JVM的 &lt;code&gt;java.util.Scanner&lt;/code&gt; 类来解析结构化程度较低的输入格式。Kotlin旨在与JVM库良好地互操作，因此在Kotlin中使用它们非常自然。但是，请注意 &lt;code&gt;java.util.Scanner&lt;/code&gt; 非常慢。实际上，它是如此之慢，以至于用它解析10 &lt;sup&gt;5个&lt;/sup&gt;或更多整数可能不适合典型的2秒时限，这是简单的Kotlin的 &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; 可以处理的。</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">它使用容量为&lt;em&gt;4&lt;/em&gt;的缓冲通道打印&amp;ldquo;发送&amp;rdquo; &lt;em&gt;五次&lt;/em&gt;：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">它打印的行数如下:</target>
        </trans-unit>
        <trans-unit id="4fc49613736421c5526df5f47051346dc40ed425" translate="yes" xml:space="preserve">
          <source>It prints:</source>
          <target state="translated">它的打印。</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;调试模式下&lt;/a&gt;运行时，它会产生类似的结果：</target>
        </trans-unit>
        <trans-unit id="937e4c5bd1079031a2dfad58d8e0700ddac7f05b" translate="yes" xml:space="preserve">
          <source>It produces something like this, with the whole collection taking around 1200 ms (three numbers, 400 ms for each):</source>
          <target state="translated">它产生的效果是这样的,整个采集过程大约需要1200毫秒(三个数字,每个数字需要400毫秒)。</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">它产生的东西是这样的。</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">它产生以下输出(可能顺序不同)。</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">它产生以下输出:</target>
        </trans-unit>
        <trans-unit id="020338510019284e271656ee98c10ee9502fa284" translate="yes" xml:space="preserve">
          <source>It produces the following three lines, each line appearing after each second:</source>
          <target state="translated">它产生以下三行,每行出现在每一秒钟之后。</target>
        </trans-unit>
        <trans-unit id="6b842d5f86ada273da6149c65d3d77df472ae9b5" translate="yes" xml:space="preserve">
          <source>It produces the same numbers just faster, as we have effectively created a processing pipeline, having to only wait 100 ms for the first number and then spending only 300 ms to process each number. This way it takes around 1000 ms to run:</source>
          <target state="translated">它产生同样的数字,只是速度更快,因为我们有效地创建了一个处理管道,只需等待100毫秒的第一个数字,然后只需花费300毫秒来处理每个数字。这样一来,它的运行时间约为1000毫秒。</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">它返回传递给它的两个函数的组合： &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; 。现在，您可以将其应用于可调用引用：</target>
        </trans-unit>
        <trans-unit id="ed5dfacacd6fed6df8733c434a43165786f1b136" translate="yes" xml:space="preserve">
          <source>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</source>
          <target state="translated">它简化了代码的生成,例如,对象初始化器。最后一个元素也可以有一个逗号。</target>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">它带有两个 &lt;code&gt;Int&lt;/code&gt; 参数并返回 &lt;code&gt;Double&lt;/code&gt; ，因此其类型为 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 。我们可以通过在函数名称前加上 &lt;code&gt;::&lt;/code&gt; 来引用函数本身，并且可以将其分配给变量（通常会推断出其类型，但我们将演示类型签名）：</target>
        </trans-unit>
        <trans-unit id="2543e91e8c67adc1567e54c9ccc67fdf2ca3724a" translate="yes" xml:space="preserve">
          <source>It was really annoying when all the arguments were in their correct positions but you wanted to specify a name for one argument in the middle. It was especially helpful for making absolutely clear which attribute a boolean or &lt;code&gt;null&lt;/code&gt; value belongs to.</source>
          <target state="translated">当所有参数都位于正确的位置时，这确实很烦人，但是您想为中间的一个参数指定一个名称。这对于明确弄清布尔值或 &lt;code&gt;null&lt;/code&gt; 值属于哪个属性特别有用。</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">它将产生特定于平台的共享对象（在Linux上为.so，在macOS上为.dylib，在Windows目标上为.dll）和C语言标头，从而允许使用C /中Kotlin / Native程序中可用的所有公共API。 C ++代码。有关使用此类共享库在Python和Kotlin / Native之间架起桥梁的示例，请参见 &lt;code&gt;samples/python_extension&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">它将产生一个平台特定的静态对象(.a库格式)和一个C语言头,允许你从C/C++代码中使用Kotlin/Native程序中所有可用的公共API。</target>
        </trans-unit>
        <trans-unit id="7c5675ec989f2dc249c2ff33b781d2949c2f52a5" translate="yes" xml:space="preserve">
          <source>It works only for interop libraries shipped with Kotlin/Native.</source>
          <target state="translated">它只适用于Kotlin/Native的interop库。</target>
        </trans-unit>
        <trans-unit id="c77b95136e56addaaf94d730513b3a8bef6e57a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s almost done, user feedback is especially important now.</source>
          <target state="translated">差不多完成了，用户反馈现在尤为重要。</target>
        </trans-unit>
        <trans-unit id="039acb422f298b9e2dda428662093ea454940860" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</source>
          <target state="translated">完成。我们将根据我们严格的&lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;向后兼容规则对其进行改进&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3d38eb85ce2f60386c4898b42f31b426d1bea2f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</source>
          <target state="translated">使用集成在&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA中&lt;/a&gt;的Kotlin插件可以很容易地开始使用Kotlin 。受益于代码突出显示，代码完成，重构，调试和Kotlin可用的其他功能。</target>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">开始使用Kotlin进行Android开发非常容易。在本教程中，我们将遵循Android Studio的预热过程。如果您在Android上使用Intellij IDEA，则过程几乎相同。</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">允许在&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;目标中&lt;/a&gt;传递相同的数组，甚至可以指定子范围，使其与目标范围重叠。</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">允许在&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;目标中&lt;/a&gt;传递相同的数组，甚至可以指定子范围，使其与目标范围重叠。</target>
        </trans-unit>
        <trans-unit id="c547761ff928eabb85ae6f68b2a8d06acf2434c8" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">允许在&lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;目标中&lt;/a&gt;传递相同的数组，甚至可以指定子范围，使其与目标范围重叠。</target>
        </trans-unit>
        <trans-unit id="0234d9c081afa271a5761a94d33278199b8154d0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">允许在&lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;目标中&lt;/a&gt;传递相同的数组，甚至可以指定子范围，使其与目标范围重叠。</target>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">始终可以将IntelliJ IDEA代码样式显式设置为项目的正确代码样式。为此，请在 &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; &lt;em&gt;&amp;ldquo; Kotlin&amp;rdquo;&lt;/em&gt;中切换到&amp;ldquo; &lt;em&gt;项目&amp;rdquo;&lt;/em&gt;方案，&lt;em&gt;然后&lt;/em&gt;在&lt;em&gt;&amp;ldquo; &lt;/em&gt;&lt;em&gt;加载&amp;rdquo;&lt;/em&gt;选项卡上的&lt;em&gt;&amp;ldquo;使用默认来源：&amp;rdquo;中&lt;/em&gt;选择&lt;em&gt;&amp;ldquo; Kotlin过时的IntelliJ IDEA &lt;/em&gt;代码样式&lt;em&gt;&amp;rdquo;&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">当前无法将&lt;em&gt;null&lt;/em&gt;传递给声明为varargs的方法。</target>
        </trans-unit>
        <trans-unit id="114b9bcaf449cf9b870e05fba48add6ecc248f08" translate="yes" xml:space="preserve">
          <source>It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">忘记设置相应的上下文元素很容易。如果运行协程的线程不同，则从协程访问的线程局部变量可能会具有意外值。为避免此类情况，建议使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;surePresent&lt;/a&gt;方法，并在使用不当时进行快速失败。</target>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">从 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 继承都可以，并且 &lt;code&gt;a()&lt;/code&gt; 和 &lt;code&gt;b()&lt;/code&gt; 没有问题，因为 &lt;code&gt;C&lt;/code&gt; 仅继承了每个函数的一个实现。但是对于 &lt;code&gt;f()&lt;/code&gt; 我们有两个 &lt;code&gt;C&lt;/code&gt; 继承的实现，因此我们必须在 &lt;code&gt;C&lt;/code&gt; 中重写 &lt;code&gt;f()&lt;/code&gt; 并提供我们自己的实现以消除歧义。</target>
        </trans-unit>
        <trans-unit id="04f1d0f6695973692315398bd64dee5cfdd7323c" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt;, but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt;, so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</source>
          <target state="translated">从 &lt;code&gt;Rectangle&lt;/code&gt; 和 &lt;code&gt;Polygon&lt;/code&gt; 都可以继承，但是它们都具有 &lt;code&gt;draw()&lt;/code&gt; 的实现，因此我们必须在 &lt;code&gt;Square&lt;/code&gt; 中重写 &lt;code&gt;draw()&lt;/code&gt; 并提供其自己的实现以消除歧义。</target>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">当你完成一个流时,关闭它是很重要的;否则,你的程序会泄漏一个文件句柄。请参阅下一节,了解如何很好地做到这一点。</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">确保选中&amp;ldquo; &lt;em&gt;包括Kotlin支持&amp;rdquo;&lt;/em&gt;复选框很重要。现在，我们可以在向导的下一步中保留默认设置。然后，我们继续选择&lt;em&gt;清空活动&lt;/em&gt;选项，然后单击&lt;em&gt;下一步&lt;/em&gt;，最后按&lt;em&gt;完成&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">重要的是要明白,现在这是一个本地应用程序,不需要运行时或虚拟机。我们现在可以从控制台运行编译后的二进制文件。</target>
        </trans-unit>
        <trans-unit id="841256700fec240b48d1a1475f562513e2734121" translate="yes" xml:space="preserve">
          <source>It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</source>
          <target state="translated">不建议您将Grat Kotlin DSL中的Apply与Kotlin插件一起 &lt;code&gt;apply&lt;/code&gt; -&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;请参阅原因&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">它不建议与申请科特林插件 &lt;code&gt;apply&lt;/code&gt; 于摇篮科特林DSL。&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;下面&lt;/a&gt;提供了详细信息。</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">通常，我们需要复制一个对象以更改其&lt;em&gt;某些&lt;/em&gt;属性，但保持其余部分不变。这就是生成 &lt;code&gt;copy()&lt;/code&gt; 函数的目的。对于上面的 &lt;code&gt;User&lt;/code&gt; 类，其实现如下：</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">可以为一个组件声明一个cinterop依赖关系。</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">可能依赖于先前在Maven存储库中发布的Kotlin / Native库。该插件依赖Gradle的&lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;元数据&lt;/a&gt;支持，因此必须启用相应的功能。在 &lt;code&gt;settings.gradle&lt;/code&gt; 中添加以下行：</target>
        </trans-unit>
        <trans-unit id="c597ff748c96d1169a0e3b1f389a9e5bf8a14509" translate="yes" xml:space="preserve">
          <source>It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</source>
          <target state="translated">建议您使用Android Studio创建Android应用程序。&lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;了解如何使用Android Gradle插件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">建议用这个注解将实验状态传播到依赖于无符号类型的API上。</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">你可以决定你的客户是否必须明确地选择使用你的API,但是请记住,无符号类型是一个实验性的功能,所以使用它们的API可能会因为语言的变化而突然中断。</target>
        </trans-unit>
        <trans-unit id="da8e68f5b23a3014c6d8de49b6e15eb047b18c62" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</source>
          <target state="translated">由你决定你的客户是否必须明确地选择使用你的API,但请记住,无符号类型不是一个稳定的功能,所以使用它们的API可能会因为语言的变化而被破坏。</target>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">缩短长的通用类型是很有用的。例如,我们经常想缩短集合类型。</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">一个lambda表达式只有一个参数是很常见的。</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">遍历此读取器的每一行，为读取的每一行调用&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;操作&lt;/a&gt;，并在&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;读取器&lt;/a&gt;完成时关闭它。</target>
        </trans-unit>
        <trans-unit id="a23c7a347a61820ec903389403c010444ab83c86" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">遍历此读取器的每一行，为读取的每一行调用&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;操作&lt;/a&gt;，并在&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;读取器&lt;/a&gt;完成时关闭它。</target>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">在一个集合上迭代。</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">在一个范围内迭代。</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">字符序列的迭代器。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">可以通过调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt;函数来为&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;接口的继承者（包括 &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;List&lt;/code&gt; ）获取迭代器。获得迭代器后，它指向集合的第一个元素；调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;函数将返回此元素，并将迭代器位置移动到以下元素（如果存在）。一旦迭代器通过了最后一个元素，它就不能再用于检索元素。也无法将其重置到任何以前的位置。要再次遍历集合，请创建一个新的迭代器。</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">来自 &lt;code&gt;androidMain&lt;/code&gt; 源集的Android项目的JAR文件</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA支持</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="18acc06f648ff3dfaa92d38568a89dcb1c336e71" translate="yes" xml:space="preserve">
          <source>JS + Native</source>
          <target state="translated">JS+Native</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305（ &lt;code&gt;javax.annotation&lt;/code&gt; ，更多详细信息在下面）</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305支持</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="ba55f5a90bf0d3ce9f1b0f807b6ef302c9ac96c9" translate="yes" xml:space="preserve">
          <source>JVM + Android targets</source>
          <target state="translated">JVM+Android目标</target>
        </trans-unit>
        <trans-unit id="d91c8eab1c7dd4c61791a6e6cea54a63f44fc1bc" translate="yes" xml:space="preserve">
          <source>JVM + JS</source>
          <target state="translated">JVM+JS</target>
        </trans-unit>
        <trans-unit id="6c072fe1de9573a0b46a9ce0b06fdf1d4adc47cb" translate="yes" xml:space="preserve">
          <source>JVM + JS + Native</source>
          <target state="translated">JVM+JS+Native</target>
        </trans-unit>
        <trans-unit id="0b9d77993a56f0043f2307875f7d47573f436cff" translate="yes" xml:space="preserve">
          <source>JVM + Native</source>
          <target state="translated">JVM+Native</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVM后端</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVM后端</target>
        </trans-unit>
        <trans-unit id="e314b08890e867b0e66c9aacb3731e2c760fd4e5" translate="yes" xml:space="preserve">
          <source>JVM dependency</source>
          <target state="translated">JVM依赖性</target>
        </trans-unit>
        <trans-unit id="458cadbdc19f7b0625a6ae9eae43cf7d180c87dd" translate="yes" xml:space="preserve">
          <source>JVM modules</source>
          <target state="translated">JVM模块</target>
        </trans-unit>
        <trans-unit id="7843626ea3524e7d3635490a634ced48fdacaeb5" translate="yes" xml:space="preserve">
          <source>JVM targets</source>
          <target state="translated">JVM目标</target>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">Jar文件</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">Java 7对资源的尝试</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">支持Java 8字节码</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">支持Java 8标准库</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">Java注释</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">Java数组</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Http servlets可以从Kotlin中使用,就像其他Java库或框架一样。我们将看到如何制作一个简单的控制器,返回 &quot;Hello,World!&quot;。</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">Java互操作性</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">Java 反射</target>
        </trans-unit>
        <trans-unit id="2fbdce03c9470f1b2722c2ee692684eb6163442c" translate="yes" xml:space="preserve">
          <source>Java SAM interfaces in Kotlin</source>
          <target state="translated">Kotlin中的Java SAM接口</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVM目标中的Java支持</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">Java Varargs</target>
        </trans-unit>
        <trans-unit id="83c71cd47e81bcbb82cda5a763f3b5d7be5fba22" translate="yes" xml:space="preserve">
          <source>Java Virtual Machine</source>
          <target state="translated">Java虚拟机</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">Java注释与Kotlin 100%兼容。</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Java类有时会使用一个方法声明来表示具有可变参数数(varargs)的索引。</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">Java编译器选项</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">Kotlin中的Java泛型</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">Java互操作。</target>
        </trans-unit>
        <trans-unit id="05bbb6e796992dd8a4fef0cfa9a4d27c4b673a12" translate="yes" xml:space="preserve">
          <source>Java libraries</source>
          <target state="translated">Java库</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Java在几年前才开始支持函数类型和lambda表达式。此前,Java通过使用一个接口来定义函数签名,并允许内联、匿名定义一个实现该接口的类来解决这个问题。这在Kotlin中也是可用的,部分原因是为了与Java库兼容,部分原因是它可以方便地指定事件处理程序(特别是当有多个事件类型必须由同一个监听器对象监听时)。考虑一个接口或一个(可能是抽象的)类,以及一个接受它的实例的函数。</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">Java反射适用于Kotlin类，反之亦然。如上所述，您可以使用 &lt;code&gt;instance::class.java&lt;/code&gt; ， &lt;code&gt;ClassName::class.java&lt;/code&gt; 或 &lt;code&gt;instance.javaClass&lt;/code&gt; 通过 &lt;code&gt;java.lang.Class&lt;/code&gt; 输入Java反射。</target>
        </trans-unit>
        <trans-unit id="ef56a24f4d8f2d665c8315a53a8f2125506c9068" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;. You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</source>
          <target state="translated">Java反射适用于Kotlin类，反之亦然。如上所述，您可以使用 &lt;code&gt;instance::class.java&lt;/code&gt; ， &lt;code&gt;ClassName::class.java&lt;/code&gt; 或 &lt;code&gt;instance.javaClass&lt;/code&gt; 通过 &lt;code&gt;java.lang.Class&lt;/code&gt; 输入Java反射。您也可以使用 &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; 获取原始类型包装器。</target>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">具有可空性注解的Java类型不是作为平台类型来表示,而是作为实际的可空或非空的Kotlin类型来表示。编译器支持几种类型的可空性注解,包括:</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Java的数组映射为提到&lt;a href=&quot;java-interop#java-arrays&quot;&gt;如下&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Java的盒式基元类型被映射为可空的Kotlin类型。</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Java的原始类型被转换为星形投影。</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Java的通配符被转换为类型投影。</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">Java默认方法调用</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">Java风格的反射</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">Java2Kotlin转换器</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">JavaScript后端</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">JavaScript DCE</target>
        </trans-unit>
        <trans-unit id="1731268deeec6a5538ea96e67d2bad77e86644c6" translate="yes" xml:space="preserve">
          <source>JavaScript Dead Code Elimination (DCE)</source>
          <target state="translated">消除JavaScript死码(DCE)</target>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">JavaScript模块</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">JavaScript反思</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">JavaScript后端</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">现在JavaScript后台生成的代码更多的是可静态检查的,这对JS代码处理工具更友好,如minifiers、优化器、linters等。</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScript没有包（命名空间）的概念。它们通常由嵌套对象模拟。编译器将对 &lt;code&gt;external&lt;/code&gt; 声明的引用转换为纯无前缀名称（如果使用&lt;em&gt;纯&lt;/em&gt;模块）或纯导入。但是，如果JavaScript库在包中提供其声明，您将不会对此感到满意。您可以使用 &lt;code&gt;@JsQualifier(...)&lt;/code&gt; 批注告诉编译器在引用 &lt;code&gt;external&lt;/code&gt; 声明之前生成其他前缀。</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScript没有接口的概念。当函数期望其参数支持 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 方法时，只需传递实际具有这些方法的对象即可。您可以使用接口将其表示为静态类型的Kotlin，例如：</target>
        </trans-unit>
        <trans-unit id="db533d2ccc039c3271e49d0037285a95132804d3" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, you would just pass in an object that actually has these methods.</source>
          <target state="translated">JavaScript没有接口的概念。当一个函数期望其参数支持两个方法 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 时，您只需传入实际上具有这些方法的对象即可。</target>
        </trans-unit>
        <trans-unit id="5b5802824529ccfad8f8c81c90d94e61f99e64f2" translate="yes" xml:space="preserve">
          <source>JavaScript targets</source>
          <target state="translated">JavaScript目标</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains开发和维护了几个专门用于React社区的工具：&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React绑定&lt;/a&gt;以及&lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;。后者可以帮助您开始使用没有构建配置的Kotlin构建React应用。</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">工作的背景</target>
        </trans-unit>
        <trans-unit id="06c75c90e1e9379a2cdd628513a60c328e9a2837" translate="yes" xml:space="preserve">
          <source>Join the Kotlin/JS community</source>
          <target state="translated">加入Kotlin/JS社区</target>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">和我们一起在相关教程中继续探索C语言类型及其在Kotlin/Native中的表示。</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">参加课程</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">约书亚&amp;middot;布洛克称这些对象，你只能&lt;strong&gt;读&lt;/strong&gt;从&lt;strong&gt;生产者&lt;/strong&gt;，而那些只&lt;strong&gt;写&lt;/strong&gt;到&lt;strong&gt;消费者&lt;/strong&gt;。他建议：&amp;ldquo; &lt;em&gt;为了获得最大的灵活性，请在代表生产者或消费者的输入参数上使用通配符类型&lt;/em&gt; &amp;rdquo;，并提出以下助记符：</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="829d41f036e4b83f97d9207ff01e19270a103dc5" translate="yes" xml:space="preserve">
          <source>JsExport</source>
          <target state="translated">JsExport</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">线程之间的跳转</target>
        </trans-unit>
        <trans-unit id="c4dd39bfc503df3e7ae8d48062e97ce8c118b15c" translate="yes" xml:space="preserve">
          <source>Jupyter Kotlin kernel</source>
          <target state="translated">Jupyter Kotlin内核</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">只要将插件JAR文件添加到编译器插件classpath中,并指定sam-with-receiver注释列表即可。</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">就像在Java 8中一样,Kotlin现在允许在数字文字中使用下划线来分隔数字组。</target>
        </trans-unit>
        <trans-unit id="884734e755cc6d6bbd1b938aff073932b22e3094" translate="yes" xml:space="preserve">
          <source>Just change the Kotlin version to &lt;code&gt;1.4.0&lt;/code&gt; and re-import your Gradle or Maven project. The IDE will then ask you about migration.</source>
          <target state="translated">只需将Kotlin版本更改为 &lt;code&gt;1.4.0&lt;/code&gt; ,然后重新导入Gradle或Maven项目即可。然后，IDE将询问您有关迁移的信息。</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">就像Java 8一样,Kotlin支持SAM转换。这意味着,只要接口方法的参数类型与Kotlin函数的参数类型相匹配,Kotlin函数字面值就可以通过一个非默认方法自动转换为Java接口的实现。</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">就像Java和JavaScript一样,Kotlin支持行结束和块注释。</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">就像Java的匿名内类一样,对象表达式中的代码可以从包围的作用域中访问变量。与Java不同的是,这并不限于final或有效的final变量)。</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">就像Java中一样， &lt;code&gt;value&lt;/code&gt; 参数是一个特例。可以不使用显式名称来指定其值：</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">就像Java中一样，Kotlin中的枚举类具有综合方法，可以列出定义的枚举常量并通过其名称获取枚举常量。这些方法的签名如下（假设枚举类的名称为 &lt;code&gt;EnumClass&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="087fe94dcb6ae8bf0df1e1981129ddf1a93236a7" translate="yes" xml:space="preserve">
          <source>Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</source>
          <target state="translated">就像大多数现代语言一样，Kotlin支持单行（或行&lt;em&gt;尾&lt;/em&gt;）注释和多行（&lt;em&gt;块&lt;/em&gt;）注释。</target>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">就像companion对象的普通成员一样,它们可以只用类名作为限定符被调用。</target>
        </trans-unit>
        <trans-unit id="27573ad44b2952298adae482665b1d05330c84b0" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/zip&quot;&gt;Sequence.zip&lt;/a&gt; extension function in the Kotlin standard library, flows have a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html&quot;&gt;zip&lt;/a&gt; operator that combines the corresponding values of two flows:</source>
          <target state="translated">就像Kotlin标准库中的&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/zip&quot;&gt;Sequence.zip&lt;/a&gt;扩展功能一样，流具有一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html&quot;&gt;zip&lt;/a&gt;运算符，该运算符结合了两个流的相应值：</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">就像JavaDoc一样，KDoc注释以 &lt;code&gt;/**&lt;/code&gt; 开头，以 &lt;code&gt;*/&lt;/code&gt; 结尾。注释的每一行都可以以星号开头，该星号不被视为注释内容的一部分。</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="8d8475b40c0c838717c002d3eb803f88fd28b448" translate="yes" xml:space="preserve">
          <source>JvmDefaultWithoutCompatibility</source>
          <target state="translated">JvmDefaultWithoutCompatibility</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="7d24ba100f0e49fea8997c1580577eea18ef483a" translate="yes" xml:space="preserve">
          <source>KAPT: Names of synthetic &lt;code&gt;$annotations()&lt;/code&gt; methods for properties have changed</source>
          <target state="translated">KAPT：用于属性的合成 &lt;code&gt;$annotations()&lt;/code&gt; 方法的名称已更改</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc语法</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDoc目前支持以下区块标签。</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDoc不支持 &lt;code&gt;@deprecated&lt;/code&gt; 标记。相反，请使用 &lt;code&gt;@Deprecated&lt;/code&gt; 批注。</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc语法</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="ed5e1b52600600ea74e498fffdc8c815085f7d28" translate="yes" xml:space="preserve">
          <source>KLib binaries</source>
          <target state="translated">KLib二进制文件</target>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">Kapt可以生成Kotlin源。只需将生成的Kotlin源文件写入到 &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; 指定的目录中，这些文件就会与主要源文件一起编译。</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt编译器插件可以在Kotlin编译器的二进制发行版中使用。</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kapt使用Java编译器来运行注释处理器。</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">请记住，这只是语法糖-您实际上并没有在修改类或其实例。因此，您必须在要使用扩展功能/属性的任何地方导入它（因为扩展功能/属性不会随类的实例一起提供）。出于同样的原因，您不能覆盖扩展成员-您可以为子类型重新实现扩展成员，但是解决方案是在编译时根据调用它的表达式的静态类型进行的。因此，如果您为 &lt;code&gt;Vehicle&lt;/code&gt; 声明了一个扩展函数，并且为其子类 &lt;code&gt;Car&lt;/code&gt; 声明了一个具有相同名称和签名的扩展函数，然后执行以下操作，那么即使 &lt;code&gt;v&lt;/code&gt; 确实是 &lt;code&gt;Car&lt;/code&gt; ，也将调用 &lt;code&gt;Vehicle&lt;/code&gt; 的扩展函数：</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">多年来,保持语言的现代化。</target>
        </trans-unit>
        <trans-unit id="07ccea1c92ddb53422b1f7f7120a95adacb8fcf2" translate="yes" xml:space="preserve">
          <source>Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</source>
          <target state="translated">保持整个包或模块不被淘汰,会使DCE无法删除许多未使用的声明。正因为如此,最好是逐一选择应该从DCE中排除的单个声明。</target>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">Keepsafe的App Lock应用也已&lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;转换为100％Kotlin&lt;/a&gt;，从而使源代码行计数减少了30％，方法计数减少了10％。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;元素的键。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;是具有此键的元素的类型。</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;元素的键。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;是具有此键的元素的类型。&lt;em&gt;通过引用&lt;/em&gt;比较上下文中的键。</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">关键词和操作者</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">一种由编译器生成的模块</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">样的这个参数。</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">Kind表示参数声明在源代码中的特定位置,如实例、扩展接收器参数或值参数。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1引入了协程，这是一种编写异步，非阻塞代码（以及更多）的新方法。在本教程中，我们将在 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 库的帮助下，了解使用Kotlin协程的一些基础知识，该库是现有Java库的帮助程序和包装程序的集合。</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1删除了Kotlin 1.0中对密封类和数据类的一些限制。现在你可以在同一个文件中定义顶层密封类的子类,而不仅仅是作为密封类的嵌套类。数据类现在可以扩展其他类。这可以用来很好地、干净地定义表达式类的层次结构。</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2引入了一组用于 &lt;code&gt;BigInteger&lt;/code&gt; 和 &lt;code&gt;BigDecimal&lt;/code&gt; 并从其他数字类型创建它们的函数。这些是：</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3继续发展和改进脚本API,引入了一些实验性的脚本定制支持,如添加外部属性、提供静态或动态依赖等。</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3继续改进和完善了Native目标。有关详细信息，请参见&lt;a href=&quot;native-overview&quot;&gt;Kotlin / Native概述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3引入了一种更简单的 &lt;code&gt;main&lt;/code&gt; 形式，该形式不带参数。现在，科特林的&amp;ldquo; Hello，World&amp;rdquo;要短19个字符！</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3引入了一种新的声明&amp;mdash; &lt;code&gt;inline class&lt;/code&gt; 。可以将内联类视为普通类的受限版本，特别是，内联类必须具有唯一的一个属性：</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3在Reflection API中引入了悬浮函数的可调用引用和对Coroutines的支持。</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3引入了对可运行Kotlin &lt;em&gt;暂存文件的&lt;/em&gt;支持。&lt;em&gt;Scratch文件&lt;/em&gt;是带有.kts扩展名的kotlin脚本文件，您可以直接在编辑器中运行并获取评估结果。</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3引入了对IDE中&lt;a href=&quot;coding-conventions&quot;&gt;推荐代码风格的&lt;/a&gt;支持。请查看&lt;a href=&quot;code-style-migration-guide&quot;&gt;此页面&lt;/a&gt;以获取迁移指南。</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3引入了无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3 放宽了这一限制,并增加了对大数子函数的支持。</target>
        </trans-unit>
        <trans-unit id="066cd750e197b01a81e98cd924fadfe8604b9df8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4 supports more cases for using callable references:</source>
          <target state="translated">Kotlin 1.4支持更多使用可调用引用的情况。</target>
        </trans-unit>
        <trans-unit id="5350f6595e85d319ae1e0cc79c4bfec4d9dbf0c3" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4 uses a new, more powerful type inference algorithm. This new algorithm was already available to try in Kotlin 1.3 by specifying a compiler option, and now it&amp;rsquo;s used by default. You can find the full list of issues fixed in the new algorithm in &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT?q=Tag:%20fixed-in-new-inference%20&quot;&gt;YouTrack&lt;/a&gt;. Here you can find some of the most noticeable improvements:</source>
          <target state="translated">Kotlin 1.4使用了一种新的，功能更强大的类型推断算法。通过指定编译器选项，可以在Kotlin 1.3中尝试使用这种新算法，现在默认使用它。您可以在&lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT?q=Tag:%20fixed-in-new-inference%20&quot;&gt;YouTrack中&lt;/a&gt;找到新算法中已解决的问题的完整列表。在这里，您可以找到一些最明显的改进：</target>
        </trans-unit>
        <trans-unit id="2bc80b855b0a3b819dba3841d64e1cfc7470a8c4" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 adds &lt;code&gt;module-info.java&lt;/code&gt; module information to default standard library artifacts. This lets you use them with &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/tools/jlink.html&quot;&gt;&lt;strong&gt;jlink&lt;/strong&gt; tool&lt;/a&gt;, which generates custom Java runtime images containing only the platform modules that are required for your app. You could already use jlink with Kotlin standard library artifacts, but you had to use separate artifacts to do so &amp;ndash; the ones with the &amp;ldquo;modular&amp;rdquo; classifier &amp;ndash; and the whole setup wasn&amp;rsquo;t straightforward.</source>
          <target state="translated">Kotlin 1.4.0将 &lt;code&gt;module-info.java&lt;/code&gt; 模块信息添加到默认的标准库工件中。这使您可以将它们与&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/tools/jlink.html&quot;&gt;&lt;strong&gt;jlink&lt;/strong&gt;工具&lt;/a&gt;一起使用，该工具将生成自定义Java运行时映像，该映像仅包含应用程序所需的平台模块。您已经可以将jlink与Kotlin标准库构件一起使用，但是您必须使用单独的构件（带有&amp;ldquo;模块化&amp;rdquo;分类器的构件）来进行操作，并且整个设置并非一帆风顺。</target>
        </trans-unit>
        <trans-unit id="0378da784d7afe2b6f5df83cd22d948f8f205d9b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 comes with a variety of different language features and improvements. They include:</source>
          <target state="translated">Kotlin 1.4.0带来了各种不同的语言特性和改进。这些改进包括:</target>
        </trans-unit>
        <trans-unit id="95c73be7140ebf78f98979e2eca4cd593ef933ad" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 comes with lots of features and improvements in the tooling for multiplatform programming. Some of them just work out of the box on existing projects, and some require additional configuration steps. This guide will help you migrate your multiplatform projects to 1.4.0 and get the benefits of all its new features.</source>
          <target state="translated">Kotlin 1.4.0在多平台编程的工具中加入了很多功能和改进。其中有些功能在现有的项目上可以直接使用,有些则需要额外的配置步骤。本指南将帮助您将您的多平台项目迁移到1.4.0,并获得其所有新功能的好处。</target>
        </trans-unit>
        <trans-unit id="9e7a073ad0548ea1abeb025f0d02a8940c8b2833" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 does not provide a public API for such extensions yet, but we are working closely with our partners, including &lt;a href=&quot;https://developer.android.com/jetpack/compose&quot;&gt;Jetpack Compose&lt;/a&gt;, who are already building their compiler plugins using our new backend.</source>
          <target state="translated">Kotlin 1.4.0尚未提供用于此类扩展的公共API，但我们正在与合作伙伴密切合作，包括&lt;a href=&quot;https://developer.android.com/jetpack/compose&quot;&gt;Jetpack Compose&lt;/a&gt;，他们已经在使用我们的新后端构建其编译器插件。</target>
        </trans-unit>
        <trans-unit id="119bb4e318a0a5c97768f9b15754a1c8be59df76" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 includes a number of JVM-specific improvements, such as:</source>
          <target state="translated">Kotlin 1.4.0包含了许多针对JVM的改进,比如:。</target>
        </trans-unit>
        <trans-unit id="56b88cbfefbff762c9e5fd3f41575d2d7448be9e" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 introduces the Alpha IR compiler for Kotlin/JS. For more detailed information about the Kotlin/JS IR compiler&amp;rsquo;s backend and how to configure it, consult the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">Kotlin 1.4.0引入了针对Kotlin / JS的Alpha IR编译器。有关Kotlin / JS IR编译器的后端以及如何配置它的更多详细信息，请参阅&lt;a href=&quot;js-ir-compiler&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fab6809ce8d845633ec216cd46b20c0f5a989761" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;Any&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="1e0b4419e56e01f176b70724da2be7f1570af7d9" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;String&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;String&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="e0c3f493c89be1b94503fdc3f47d5c69cab752c8" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;inline&lt;/code&gt; classes</source>
          <target state="translated">Kotlin &lt;code&gt;inline&lt;/code&gt; 课程</target>
        </trans-unit>
        <trans-unit id="c6f908927df8b995d9d09ec9bb214acf154074cf" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;interface&lt;/code&gt; types</source>
          <target state="translated">Kotlin &lt;code&gt;interface&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; 可以作为 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; 访问。还有就是 &lt;code&gt;_instance&lt;/code&gt; 函数来获取对象的唯一实例。</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">Kotlin Android扩展</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">Kotlin 编码约定和 IntelliJ IDEA 格式器</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">Kotlin Collections概述</target>
        </trans-unit>
        <trans-unit id="2e918bca9080c65d49a41d94237060bf519ea8e7" translate="yes" xml:space="preserve">
          <source>Kotlin Compiler Options</source>
          <target state="translated">Kotlin编译器选项</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">Kotlin定义</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">Kotlin教育插件</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">Kotlin的进化</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">Kotlin示例</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradle插件1.3.41适用于Android Gradle Plugin 3.0及以上版本。</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">Kotlin JavaScript概述</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C提取API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C文件API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;导航Timing API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">用于DOM API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">用于DOM CSS API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">用于DOM SVG API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">用于DOM URL API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">用于DOM事件API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">用于DOM解析API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">用于WebGL API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">Kotlin Koans</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans是一系列让你熟悉Kotlin语法的练习。每个练习都被创建为一个失败的单元测试,而你的工作就是让它通过。你可以通过以下两种方式来使用Kotlin Koans。</target>
        </trans-unit>
        <trans-unit id="409a3dab696a4f7e601ab24128dac2f50d01d468" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform</source>
          <target state="translated">Kotlin多平台</target>
        </trans-unit>
        <trans-unit id="8c495a5c1562a573edd3b920fba276a2422fbf84" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Gradle DSL Reference</source>
          <target state="translated">Kotlin多平台Gradle DSL参考文献</target>
        </trans-unit>
        <trans-unit id="02527323fc74019fbf781a55d67bc6708fd5c80b" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile documentation</source>
          <target state="translated">Kotlin多平台移动文档</target>
        </trans-unit>
        <trans-unit id="79d51b4bb6a5d02df45fa0b0d8769519481f6142" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile samples</source>
          <target state="translated">Kotlin多平台移动样本</target>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin多平台项目需要Gradle 4.7及以上版本,不支持旧版Gradle。</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">Kotlin Multiplatform项目通过提供 &lt;code&gt;android&lt;/code&gt; 预设来支持Android平台。创建Android目标需要手动将一个Android Gradle插件（例如 &lt;code&gt;com.android.application&lt;/code&gt; 或 &lt;code&gt;com.android.library&lt;/code&gt; ）应用于项目。每个Gradle子项目只能创建一个Android目标：</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">Kotlin数字和NSNumber</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">Kotlin编程。大书呆子牧场指南</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">Kotlin脚本API</target>
        </trans-unit>
        <trans-unit id="faea4ae8da7ddba5c8fa58aae401857d2734ca04" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs and custom hosts</source>
          <target state="translated">Kotlin脚本API和自定义主机。</target>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">Kotlin Scripts (*.kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">Kotlin标准库</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin允许我们为类型上的一组预定义操作符提供实现。这些运算符具有固定的符号表示形式（如 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; ）和固定的&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;优先级&lt;/a&gt;。为了实现运算符，我们为相应的类型提供了具有固定名称的&lt;a href=&quot;functions#member-functions&quot;&gt;成员函数&lt;/a&gt;或&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt;，即对于二进制运算而言是左侧类型，对于一元运算符而言是参数类型。重载运算符的功能需要使用 &lt;code&gt;operator&lt;/code&gt; 修饰符进行标记。</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlin允许你将你的Kotlin项目编译成JavaScript模块,用于流行的模块系统。下面是可用选项的列表。</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlin允许您通过&lt;em&gt;可见性修饰符&lt;/em&gt;来强制符号可见性（Python仅通过下划线约定来实现），可以将其放置在符号声明上。如果不提供可见性修改器，则会获得默认的可见性级别，即&lt;em&gt;public&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlin还具有专门的类来表示原始类型的数组，而无需装箱： &lt;code&gt;ByteArray&lt;/code&gt; ， &lt;code&gt;ShortArray&lt;/code&gt; ， &lt;code&gt;IntArray&lt;/code&gt; 等。这些类与 &lt;code&gt;Array&lt;/code&gt; 类没有继承关系，但是它们具有相同的方法和属性集。它们每个都具有对应的工厂功能：</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlin还支持浮点数的传统符号。</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin和TeamCity的持续集成</target>
        </trans-unit>
        <trans-unit id="a29301ac26900a11e482b9b5b30d720163c72b02" translate="yes" xml:space="preserve">
          <source>Kotlin and Java sources</source>
          <target state="translated">Kotlin和Java源代码</target>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">Kotlin和OSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin和Swift都将nullability定义为类型规范的一部分,而Objc则在类型的方法和属性上定义了nullability。因此,以下。</target>
        </trans-unit>
        <trans-unit id="de39894b7ea202f08e960c5e82b74ef66fdd95ec" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin和Swift都将nullability定义为类型规范的一部分,而Objective-C则在类型的方法和属性上定义了nullability。因此,以下。</target>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlin应用可以部署到任何支持Java Web应用的主机中,包括Amazon Web Services、Google Cloud Platform等。</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">Kotlin作为一种静态类型的编程语言,在编写Gradle构建脚本时发挥了很好的作用。得益于静态类型推理,Kotlin编译器可以更早地发现错误,并显示重要的编译错误信息和警告。IDE和编译器都可以使用类型信息来推断给定作用域中的可用函数和属性。</target>
        </trans-unit>
        <trans-unit id="2c6b22009eb8eb5969f5ded032f4849774e1cf34" translate="yes" xml:space="preserve">
          <source>Kotlin by Example</source>
          <target state="translated">Kotlin的例子</target>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin也可以作为一种脚本语言使用。脚本是一个包含顶级可执行代码的Kotlin源文件(.kts)。</target>
        </trans-unit>
        <trans-unit id="89f1b06f3d13062a764afffd52c7537a00883d5c" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (&lt;em&gt;.kts&lt;/em&gt;) with top level executable code.</source>
          <target state="translated">Kotlin也可以用作脚本语言。脚本是具有顶级可执行代码的Kotlin源文件（&lt;em&gt;.kts&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlin可以被编译到几个不同的平台上。在本文档中,我们假设目标平台是Java虚拟机,这赋予了一些额外的功能--特别是,您的代码将被编译成Java字节码,因此将与Java库的大型生态系统互操作。</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlin可以用于任何类型的开发,无论是服务器端、客户端的Web和Android。目前,Kotlin/Native正在开发中,对其他平台的支持也即将到来,如嵌入式系统、macOS和iOS。人们正在将Kotlin用于移动和服务器端应用,客户端与JavaScript或JavaFX,以及数据科学,这只是一些可能性。</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlin可以与现有的第三方库和框架（例如jQuery或React）一起使用。要使用强类型API访问第三方框架，您可以使用&lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt;工具将TypeScript定义从&amp;ldquo; &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;绝对类型&amp;rdquo;&lt;/a&gt;类型定义存储库转换为Kotlin 。或者，您可以使用&lt;a href=&quot;dynamic-type&quot;&gt;动态类型&lt;/a&gt;来访问任何框架，而无需强类型化。</target>
        </trans-unit>
        <trans-unit id="8ac487e3599218d513d99cbe95341abd1004db54" translate="yes" xml:space="preserve">
          <source>Kotlin can build a &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;source set hierarchy&lt;/a&gt; with the &lt;code&gt;dependsOn&lt;/code&gt; relation.</source>
          <target state="translated">Kotlin可以使用 &lt;code&gt;dependsOn&lt;/code&gt; 关系建立&lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;源集层次结构&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlin可以非常接近Python的 &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 理解的紧凑性。假设 &lt;code&gt;people&lt;/code&gt; 是具有 &lt;code&gt;name&lt;/code&gt; 属性的 &lt;code&gt;Person&lt;/code&gt; 对象的集合：</target>
        </trans-unit>
        <trans-unit id="1a109a14558842e44146557931b4bc933ed0c8e4" translate="yes" xml:space="preserve">
          <source>Kotlin can now generate type annotations in the JVM bytecode (target version 1.8+), so that they become available in Java reflection at runtime. To emit the type annotation in the bytecode, follow these steps:</source>
          <target state="translated">Kotlin现在可以在JVM字节码中生成类型注释(目标版本1.8+),这样它们就可以在运行时的Java反射中使用。要在字节码中发出类型注解,请按照以下步骤进行。</target>
        </trans-unit>
        <trans-unit id="01363668f0c8a96c308b85201388c8e9019873f8" translate="yes" xml:space="preserve">
          <source>Kotlin can use only Swift declarations marked with the &lt;code&gt;@objc&lt;/code&gt; attribute.</source>
          <target state="translated">Kotlin只能使用标有 &lt;code&gt;@objc&lt;/code&gt; 属性的Swift声明。</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlin在运行时无法区分数字类型（ &lt;code&gt;kotlin.Long&lt;/code&gt; 除外），即以下代码有效：</target>
        </trans-unit>
        <trans-unit id="f14b3e6c2a42d2b616f9f3f45afd4a5a6fa4ccb2" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), so the following code works:</source>
          <target state="translated">Kotlin在运行时无法区分数字类型（ &lt;code&gt;kotlin.Long&lt;/code&gt; 除外），因此以下代码适用：</target>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlin非常在意代码的稳定性和向后兼容性。Kotlin的兼容性政策规定,只有在主要版本(1.2、1.3等)中才能引入 &quot;中断性改动&quot;(例如,使过去可以正常编译的代码不再编译的改动)。</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">Kotlin类和接口可以被Swift/Objective-C类和协议子类化。</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">Kotlin类在Objective-C中有一个 &lt;code&gt;KotlinBase&lt;/code&gt; 基类，该类在那里扩展了 &lt;code&gt;NSObject&lt;/code&gt; 类。我们也有用于集合和异常的包装器。大部分收集类型从另一端映射到相似的收集类型：</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">Kotlin代码可以轻松地从Java中调用。例如,Kotlin类的实例可以在Java方法中无缝创建和操作。然而,在将Kotlin代码集成到Java中时,需要注意Java和Kotlin之间的某些差异。在本页中,我们将介绍如何调整Kotlin代码与其Java客户端的互操作。</target>
        </trans-unit>
        <trans-unit id="9fd6821c54cf8552d62d9de4efae79ccdf8ce19d" translate="yes" xml:space="preserve">
          <source>Kotlin collection types and subtypes</source>
          <target state="translated">Kotlin集合类型和子类型</target>
        </trans-unit>
        <trans-unit id="315f6541c31d964f7f6872786a71a0ab54434ee9" translate="yes" xml:space="preserve">
          <source>Kotlin collections (&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin集合（ &lt;code&gt;List&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; 等）未映射到任何特定的JavaScript类型。</target>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin集合（即 &lt;code&gt;List&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; 等）未映射到任何特定的JavaScript类型。</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">如上表所述，将Kotlin集合转换为Swift / Objective-C集合。 Swift / Objective-C集合以相同的方式映射到Kotlin，除了 &lt;code&gt;NSMutableSet&lt;/code&gt; 和 &lt;code&gt;NSMutableDictionary&lt;/code&gt; 。 &lt;code&gt;NSMutableSet&lt;/code&gt; 不会转换为Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 。要为Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 传递对象，您可以显式地创建此类Kotlin集合，方法是使用例如 &lt;code&gt;mutableSetOf()&lt;/code&gt; 在Kotlin中创建它，或者在Swift中使用 &lt;code&gt;KotlinMutableSet&lt;/code&gt; 类（或在Objective-C中使用 &lt;code&gt;${prefix}MutableSet&lt;/code&gt; ，其中有 &lt;code&gt;prefix&lt;/code&gt; 是框架名称前缀）。 &lt;code&gt;MutableMap&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlin集合包含用于常用&lt;em&gt;聚合操作的&lt;/em&gt;函数，这些函数基于集合内容返回单个值。其中大多数是众所周知的，并且以与其他语言相同的方式工作：</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin集合提供了一组用于从集合中检索单个元素的函数。本页描述的函数既适用于列表,也适用于集合。</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">Kotlin社区是开放的,乐于助人的,欢迎大家加入。不要犹豫,加入并在任何你喜欢的平台上询问。</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlin编译器可以从JavaScript代码中生成正常的JavaScript类、函数和属性,你可以自由使用。然而,有一些微妙的事情你应该记住。</target>
        </trans-unit>
        <trans-unit id="e2af437257c982ea32c02d4a42942eceaf188caa" translate="yes" xml:space="preserve">
          <source>Kotlin compiler offers &lt;em&gt;explicit API mode&lt;/em&gt; for library authors. In this mode, the compiler performs additional checks that help make the library&amp;rsquo;s API clearer and more consistent. It adds the following requirements for declarations exposed to the library&amp;rsquo;s public API:</source>
          <target state="translated">Kotlin编译器为库作者提供了&lt;em&gt;显式的API模式&lt;/em&gt;。在这种模式下，编译器将执行其他检查，以帮助使库的API更清晰，更一致。它为暴露给库的公共API的声明增加了以下要求：</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlin编译器产生的是字节码,因此Kotlin应用程序与Java编写的应用程序在外观和感觉上确实没有区别。</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">Kotlin编译器细节</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin编译器将产生以下输出</target>
        </trans-unit>
        <trans-unit id="f142a3debb6f5ab93f8769b5839aca7d9de9a318" translate="yes" xml:space="preserve">
          <source>Kotlin compilers have a number of options for tailoring the compiling process. Compiler options for different targets are listed on this page together with a description of each one.</source>
          <target state="translated">Kotlin 编译器有许多选项来调整编译过程。本页列出了针对不同目标的编译器选项以及每个选项的描述。</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlin构造函数作为初始化器被导入到Swift/Objective-C中。</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin文档是一个很好的开始,请查看这些链接来让你的脚步湿润。</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">Kotlin没有Python的&lt;em&gt;资源管理器&lt;/em&gt;或Java的&lt;em&gt;try-with-resources&lt;/em&gt;，但是由于具有扩展功能，因此可以 &lt;code&gt;use&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">Kotlin没有检查的&lt;a href=&quot;exceptions&quot;&gt;异常&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">Kotlin没有检查异常。这有很多原因,但我们将提供一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">Kotlin在JavaScript中没有实现顶层属性的懒惰初始化。</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlin确保在编译时涉及&lt;a href=&quot;generics&quot;&gt;泛型&lt;/a&gt;的操作的类型安全，而在运行时，泛型类型的实例不保存有关其实际类型参数的信息。例如，将 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; 删除为 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 。通常，无法在运行时检查实例是否属于具有某些类型参数的泛型类型。</target>
        </trans-unit>
        <trans-unit id="e3093475043dd707a8b9c1069aead086bf16cf6d" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin将它的包结构暴露给JavaScript,所以除非你在根包中定义你的声明,否则你必须在JavaScript中使用完全限定名。比如说</target>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin将其包结构暴露给JavaScript,所以除非你在根包中定义你的声明,否则你必须在JavaScript中使用完全限定的名称。比如说</target>
        </trans-unit>
        <trans-unit id="7be04058c2375c4141e803b8f5f5c3ef0ebe450b" translate="yes" xml:space="preserve">
          <source>Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;top-level declarations&lt;/a&gt; with an additional receiver parameter. These types include:</source>
          <target state="translated">&amp;ldquo;常规&amp;rdquo; Kotlin类的Kotlin扩展分别作为扩展和类别成员导入到Swift和Objective-C。Kotlin对其他类型的扩展被视为带有附加接收器参数的&lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;顶级声明&lt;/a&gt;。这些类型包括：</target>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin修复了Java存在的一系列问题。</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">Kotlin遵循Java的命名惯例。特别是:</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Kotlin for Android案例研究</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">Kotlin for Android Developers</target>
        </trans-unit>
        <trans-unit id="697d1de6e7cb2c06571dc421613de269a61dd215" translate="yes" xml:space="preserve">
          <source>Kotlin for Data Science</source>
          <target state="translated">数据科学的Kotlin</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Kotlin for Java Developers</target>
        </trans-unit>
        <trans-unit id="e6f31bf50fe73009407bd97cfc46c1659646cb16" translate="yes" xml:space="preserve">
          <source>Kotlin function types and subtypes</source>
          <target state="translated">Kotlin函数类型和子类型</target>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin函数类型的对象（例如lambda）将转换为Swift函数/ Objective-C块。但是，在转换函数和函数类型时如何映射参数类型和返回值是有区别的。在后一种情况下，原始类型被映射到其盒装表示形式。 Kotlin &lt;code&gt;Unit&lt;/code&gt; 返回值在Swift / Objective-C中表示为对应的 &lt;code&gt;Unit&lt;/code&gt; 单例。可以使用与其他任何Kotlin &lt;code&gt;object&lt;/code&gt; 相同的方式来检索此单例的值（请参阅上表中的单例）。总结一下：</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin函数是&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;一流的&lt;/em&gt;&lt;/a&gt;，这意味着它们可以存储在变量和数据结构中，作为参数传递给其他&lt;a href=&quot;#higher-order-functions&quot;&gt;高阶函数或&lt;/a&gt;从其他高阶函数返回。您可以通过其他非函数值可能使用的任何方式来使用函数。</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlin生成与异步模块定义(AMD)、CommonJS和通用模型定义(UMD)兼容的JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">Kotlin处理数字的方式与Java接近,但不完全相同。例如,数字没有隐式的加宽转换,而且在某些情况下,字形也略有不同。</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlin有一个相当小的运行时文件大小:该库约为964KB(截至1.3.41)。这意味着Kotlin只增加了一点.apk文件大小。</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlin有一个广泛的标准库,可以在您的应用程序中使用。在 pom 文件中配置以下依赖关系。</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlin已经被各大公司成功采用,其中有几家公司分享了他们的经验。</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlin具有面向对象和功能构造。您可以在OO和FP样式中使用它，或将两者的元素混合使用。凭借对高阶函数，函数类型和lambda等功能的一流支持，如果您正在或正在探索函数式编程，则Kotlin是一个不错的选择。</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlin 默认具有类及其成员 &lt;code&gt;final&lt;/code&gt; ，这使得使用要求类是 &lt;code&gt;open&lt;/code&gt; 框架和库（例如Spring AOP）变得不便。在&lt;em&gt;所有开放式&lt;/em&gt;编译器插件适应科特林到这些框架的要求，并与特定的注解类及其成员没有明确的开 &lt;code&gt;open&lt;/code&gt; 的关键字。</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlin有自己的反射库（您的构建中必须包含 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; ）。以JVM为目标时，您也可以使用Java反射工具。请注意，Kotlin反射功能还不够完善-特别是，您不能使用它来检查诸如 &lt;code&gt;String&lt;/code&gt; 之类的内置类。</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlin继承了Java的烦躁（但非常灵活）的I / O方式，但是简化了一些附加功能。我们不会在这里介绍所有内容，因此对于初学者来说，这是遍历文件的所有行的方式（您需要 &lt;code&gt;import java.io.File&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">Kotlin继承了Java的烦躁数组系统，因此原始类型具有自己的数组类型和转换函数，而其他任何类型都使用通用 &lt;code&gt;Array&lt;/code&gt; 类型，可以使用 &lt;code&gt;.toTypedArray()&lt;/code&gt; 转换为该类型。</target>
        </trans-unit>
        <trans-unit id="99a77fa93b5373d975ec4157225559f8cd6c6cb3" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of &quot;expected&quot; exception classes.</source>
          <target state="translated">Kotlin没有检查异常的概念，所有Kotlin异常都是未检查的。Swift仅检查了错误。因此，如果Swift或Objective-C代码调用引发异常进行处理的Kotlin方法，则应该使用 &lt;code&gt;@Throws&lt;/code&gt; 批注标记Kotlin方法，该批注指定&amp;ldquo;期望的&amp;rdquo;异常类的列表。</target>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlin没有检查异常的概念，所有Kotlin异常都是未检查的。 Swift仅检查了错误。因此，如果Swift或Objective-C代码调用了抛出异常进行处理的Kotlin方法，则Kotlin方法应使用 &lt;code&gt;@Throws&lt;/code&gt; 批注进行标记。在这种情况下，所有Kotlin异常（ &lt;code&gt;Error&lt;/code&gt; ， &lt;code&gt;RuntimeException&lt;/code&gt; 和子类的实例除外）都转换为Swift错误/ &lt;code&gt;NSError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlin现在可以选择生成Java 8字节码（ &lt;code&gt;-jvm-target 1.8&lt;/code&gt; 命令行选项或Ant / Maven / Gradle中的相应选项）。目前，这不会改变字节码的语义（特别是，接口和lambda中的默认方法的生成与Kotlin 1.0中的完全相同），但是我们计划稍后再使用它。</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">与Java的SAM转换相反，Kotlin具有适当的&lt;a href=&quot;lambdas#function-types&quot;&gt;函数类型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0bf97cc3e62a44a9f204f95382694f7ebe3c3d2c" translate="yes" xml:space="preserve">
          <source>Kotlin has supported SAM conversions for Java interfaces from the beginning, but there was one case that wasn&amp;rsquo;t supported, which was sometimes annoying when working with existing Java libraries. If you called a Java method that took two SAM interfaces as parameters, both arguments needed to be either lambdas or regular objects. You couldn't pass one argument as a lambda and another as an object.</source>
          <target state="translated">Kotlin从一开始就支持Java接口的SAM转换，但是有一种情况不受支持，使用现有Java库有时会很烦人。如果调用以两个SAM接口作为参数的Java方法，则两个参数都必须是lambda或常规对象。您不能将一个参数作为lambda传递，将另一个参数作为对象传递。</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">Kotlin有三种结构跳转表达方式。</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlin有两种类型的字符串字元:可能包含转义字符的转义字符串和可以包含换行符和任意文本的原始字符串。转义字符串很像Java字符串。</target>
        </trans-unit>
        <trans-unit id="88377cf789dc237868418b003f1376d4a4fb9cfb" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:</source>
          <target state="translated">Kotlin有两种类型的字符串字元:可能包含转义字符的转义字符串和可以包含换行符和任意文本的原始字符串。下面是一个转义字符串的例子。</target>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">Kotlin在行动</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlin为无符号整数引入了以下类型。</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">Kotlin 是一门编译过的静态类型语言,这可能会给习惯了解释型、动态类型 Python 的人带来一些初始障碍。本文档旨在解释Kotlin的语法和概念中的相当一部分与Python中相应概念的比较。</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">Kotlin非常适合开发Android应用,它将现代语言的所有优点带到了Android平台,而不会引入任何新的限制。</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlin非常适合开发服务器端应用程序,它允许你编写简洁而富有表现力的代码,同时保持与现有的基于Java的技术栈的完全兼容,并保持平滑的学习曲线。</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">Kotlin是一种实用且不受质疑的语言，支持命令式和函数式编程风格，而不会迫使开发人员选择任何一种。我们可以使用&lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;尾部递归&lt;/a&gt;等Kotlin功能以函数形式实现函数 &lt;code&gt;f&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c0d8f4fd81a58ee08fc7afcc5cfdb0b02c31ab79" translate="yes" xml:space="preserve">
          <source>Kotlin is a statically typed language, which makes it different from the dynamically typed JavaScript. In order to facilitate interoperation with JavaScript code, Kotlin/JS offers the &lt;code&gt;dynamic&lt;/code&gt; type:</source>
          <target state="translated">Kotlin是一种静态类型的语言，使其不同于动态类型的JavaScript。为了促进与JavaScript代码的互操作，Kotlin / JS提供了 &lt;code&gt;dynamic&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin是OSS静态类型的编程语言，主要针对JVM，Android，JavaScript和Native。它由&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains开发&lt;/a&gt;。该项目于2010年开始，从一开始就是开源的。第一个官方1.0版本于2016年2月发布。</target>
        </trans-unit>
        <trans-unit id="654d332c5c16069d8e33851920e04af4ba1633e6" translate="yes" xml:space="preserve">
          <source>Kotlin is an open-source statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin是面向JVM，Android，JavaScript和Native的开源静态类型编程语言。它由&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains开发&lt;/a&gt;。该项目于2010年开始，从一开始就是开源的。第一个正式的1.0版本于2016年2月发布。</target>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">Kotlin与CommonJS，AMD和UMD兼容，&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;从而使与不同&lt;/a&gt;模块系统的交互变得简单。</target>
        </trans-unit>
        <trans-unit id="60bc1c7729db3b60c6d62ba20f7492d0f9556d43" translate="yes" xml:space="preserve">
          <source>Kotlin is concise, readable and easy to learn.</source>
          <target state="translated">Kotlin简洁、易读、易学。</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlin被设计为程序员的实用性工具。在语言进化方面,它的实用性由以下原则来体现。</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlin的设计使已经熟悉Java的人易于学习。&lt;a href=&quot;../reference/comparison-to-java&quot;&gt;官方比较页面&lt;/a&gt;上提供了差异的快速概述。简短的介绍科特林的面向软件开发人员的基本语法可以直接在网站上从开始的参考部分找到&lt;a href=&quot;../reference/basic-syntax&quot;&gt;基本语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">Kotlin在设计时就考虑到了Java的互操作性,现有的Java代码可以很自然地从Kotlin中调用,而Kotlin代码也可以很顺利地从Java中使用。现有的Java代码可以很自然地从Kotlin中调用,Kotlin代码也可以很顺利地从Java中使用。在本节中,我们将介绍一些关于从Kotlin调用Java代码的细节。</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlin与 &lt;code&gt;kotlin.js&lt;/code&gt; 标准库一起作为单个文件分发，该文件本身已编译为UMD模块，因此您可以将其与上述任何模块系统一起使用。也可以在NPM上以&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; 软件包形式购买&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0a18e9cef9fc2a234c1d159c10281aea5af17fa" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on &lt;code&gt;kotlin-stdlib-js&lt;/code&gt;, it is also available on NPM as the &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">Kotlin / Kotlin / JS标准库将Kotlin作为单个文件分发，该文件本身已编译为UMD模块，因此您可以将其与上述任何模块系统一起使用。虽然对于大多数Kotlin / JS使用案例，建议对 &lt;code&gt;kotlin-stdlib-js&lt;/code&gt; 使用Gradle依赖项，但它在NPM上也可以作为&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt;软件包使用。</target>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlin的灵感来自于现有的语言,如Java、C#、JavaScript、Scala和Groovy。我们试图确保Kotlin易于学习,因此人们可以很容易地跳上船,在几天内阅读和编写Kotlin。学习习惯性的Kotlin和使用它的一些更高级的功能可能需要更长的时间,但总的来说它并不是一门复杂的语言。</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">Kotlin更简洁。粗略估计表明代码行数减少了约40％。它还具有更好的类型安全性，例如，对非空类型的支持使应用程序不易使用NPE。其他功能包括智能强制转换，高阶功能，扩展功能和带有接收器的Lambda，这些功能可以编写表达性代码并促进DSL的创建。</target>
        </trans-unit>
        <trans-unit id="57ebc857aaa4fe4ee76557729aedd97eb250b716" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 100+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin主要由JetBrains的工程师团队开发（当前团队规模为100+）。首席语言设计师是&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;安德烈&amp;middot;布雷斯拉夫&lt;/a&gt;（Andrey Breslav）。除了核心团队，GitHub上还有250多个外部贡献者。</target>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin主要由JetBrains的工程师团队开发（目前的团队规模为50+）。首席语言设计师是&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;。除了核心团队，GitHub上还有250多个外部贡献者。</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">所有主要的Java IDE（包括&lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;，&lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;，&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;和&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans）&lt;/a&gt;都支持Kotlin 。此外，还提供了&lt;a href=&quot;../tutorials/command-line&quot;&gt;命令行编译器&lt;/a&gt;，它为编译和运行应用程序提供了直接的支持。</target>
        </trans-unit>
        <trans-unit id="8b9c46bf1ad2fe2fbc414ecfb85cf4b65bec1ff6" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">所有主要的Java IDE（包括&lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;，&lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;，&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;和&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans）&lt;/a&gt;都支持Kotlin 。此外，还提供了&lt;a href=&quot;../tutorials/command-line&quot;&gt;命令行编译器&lt;/a&gt;，它为编译和运行应用程序提供了直接的支持。</target>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlin在在线课程中的覆盖率很高,在这里查看推荐课程。</target>
        </trans-unit>
        <trans-unit id="f6275eeb32172070d309b650be85e7156b1c7dc9" translate="yes" xml:space="preserve">
          <source>Kotlin lets you choose the version of JVM for execution. By default, the Kotlin/JVM compiler produces Java 6 compatible bytecode. If you want to make use of optimizations available in newer versions of Java, you can explicitly specify the target Java version from 8 to 13. Note that in this case the resulting bytecode might not run on lower versions.</source>
          <target state="translated">Kotlin让你选择执行的JVM版本。默认情况下,Kotlin/JVM编译器产生与Java 6兼容的字节码。如果您想使用较新版本的Java中的优化,您可以明确指定目标Java版本,从8到13。请注意,在这种情况下,生成的字节码可能无法在较低版本上运行。</target>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">科特林让您轻松创建使用值的范围&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt;从功能 &lt;code&gt;kotlin.ranges&lt;/code&gt; 包及其操作的形式 &lt;code&gt;..&lt;/code&gt; 。通常， &lt;code&gt;rangeTo()&lt;/code&gt; 由 &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;!in&lt;/code&gt; 函数补充。</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlin使您可以独立于存储在其中的对象的确切类型来操作集合。换句话说，你添加一个 &lt;code&gt;String&lt;/code&gt; 到列表 &lt;code&gt;String&lt;/code&gt; S中的同样的方式，你会用做 &lt;code&gt;Int&lt;/code&gt; S或用户定义的类。因此，Kotlin标准库提供了用于创建，填充和管理任何类型的集合的通用接口，类和函数。</target>
        </trans-unit>
        <trans-unit id="a804893fba1e9dc304662ad5aa9e7244e8ba7e41" translate="yes" xml:space="preserve">
          <source>Kotlin libraries</source>
          <target state="translated">Kotlin库</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">Kotlin元数据</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">如果将Kotlin模块编译成框架，则可以在Swift / Objective-C代码中使用（请参阅&lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle插件文档中的&lt;/a&gt; &amp;ldquo;目标和输出种类&amp;rdquo;部分）。有关&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;示例&lt;/a&gt;，请参见计算器示例。</target>
        </trans-unit>
        <trans-unit id="5f16158d7bd59887136035c889e332065c93a9e3" translate="yes" xml:space="preserve">
          <source>Kotlin multiplatform projects use compilations for producing artifacts. Each target can have one or more compilations, for example, for production and test purposes.</source>
          <target state="translated">Kotlin多平台项目使用编译来生产工件。每个目标可以有一个或多个编译,例如,用于生产和测试目的。</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlin现在与&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt;（JSR-223）集成。该API允许在运行时评估代码段：</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlin现在支持将参数名称存储在字节码中。可以使用 &lt;code&gt;-java-parameters&lt;/code&gt; 命令行选项启用它。</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">除 &lt;code&gt;kotlin.Long&lt;/code&gt; 以外的Kotlin数字类型映射到JavaScript Number。</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin对象可以被钉住,即保证其在内存中的位置稳定,直到取消钉住,这种对象内部数据的指针可以传递给C函数。例如</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">应该在IDE中安装Kotlin插件1.3.21或更高版本。可以通过&lt;em&gt;语言和框架&lt;/em&gt;进行验证&lt;em&gt;。&lt;/em&gt;IDE 的&lt;em&gt;&amp;ldquo;设置&amp;rdquo;&lt;/em&gt;（或&lt;em&gt;&amp;ldquo;首选项&amp;rdquo;&lt;/em&gt;）中的&lt;em&gt;&amp;ldquo; &lt;/em&gt;&lt;em&gt;Kotlin更新&amp;rdquo;&lt;/em&gt;部分。</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEA的Kotlin插件支持&lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;抓痕&lt;/a&gt;。Scratches使您可以在与项目相同的IDE窗口中创建代码草稿，并即时运行它们。从头开始与项目无关；您可以从操作系统上的任何IntelliJ IDEA窗口访问并运行所有暂存器。</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin保留了JavaScript中的懒惰对象初始化。</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlin保留了 &lt;code&gt;kotlin.Int&lt;/code&gt; ， &lt;code&gt;kotlin.Byte&lt;/code&gt; ， &lt;code&gt;kotlin.Short&lt;/code&gt; ， &lt;code&gt;kotlin.Char&lt;/code&gt; 和 &lt;code&gt;kotlin.Long&lt;/code&gt; 的溢出语义。</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlin基本类型框被映射到特殊的Swift / Objective-C类。例如， &lt;code&gt;kotlin.Int&lt;/code&gt; 框表示为Swift中的 &lt;code&gt;KotlinInt&lt;/code&gt; 类实例（或Objective-C中的 &lt;code&gt;${prefix}Int&lt;/code&gt; 实例，其中 &lt;code&gt;prefix&lt;/code&gt; 是框架名称的前缀）。这些类是从 &lt;code&gt;NSNumber&lt;/code&gt; 派生的，因此实例是支持所有相应操作的正确 &lt;code&gt;NSNumber&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7ceca5755070f2e75db1f8f41e2c1a411bf045a" translate="yes" xml:space="preserve">
          <source>Kotlin primitive types</source>
          <target state="translated">Kotlin基本类型</target>
        </trans-unit>
        <trans-unit id="231e51698e1b22447348936da3858b45208fbb94" translate="yes" xml:space="preserve">
          <source>Kotlin projects require a recent version of Gradle</source>
          <target state="translated">Kotlin项目需要最新版本的Gradle。</target>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">在命名对象或同伴对象中声明的Kotlin属性将在该命名对象或包含同伴对象的类中具有静态支持字段。</target>
        </trans-unit>
        <trans-unit id="b0f8122e9d8ea69357864a2385801f06d58ec608" translate="yes" xml:space="preserve">
          <source>Kotlin provides &lt;a href=&quot;native/c_interop&quot;&gt;interoperability with native languages&lt;/a&gt; and DSL to configure this for a specific compilation.</source>
          <target state="translated">Kotlin提供了&lt;a href=&quot;native/c_interop&quot;&gt;与本机语言&lt;/a&gt;和DSL的互操作性，可针对特定的编译配置此功能。</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlin提供了一系列编译器选项,在IntelliJ IDEA中也可以使用。除了我们刚才看到的用于生成源码图的选项外,我们还可以设置</target>
        </trans-unit>
        <trans-unit id="e2142c523bbfdb03dd37f333a0ce0922e05e00a3" translate="yes" xml:space="preserve">
          <source>Kotlin provides a set of built-in types that represent numbers.</source>
          <target state="translated">Kotlin提供了一组表示数字的内置类型。</target>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">Kotlin提供了多种功能来在给定对象的上下文中执行代码块： &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;run&lt;/code&gt; ， &lt;code&gt;with&lt;/code&gt; ， &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;also&lt;/code&gt; 。有关为您的案例选择正确的示波器功能的指南，请参阅&amp;ldquo; &lt;a href=&quot;scope-functions&quot;&gt;示波器功能&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlin 为此提供了所谓的&lt;strong&gt;星形投影&lt;/strong&gt;语法：</target>
        </trans-unit>
        <trans-unit id="a7357de7d14d7d6aa1f1f673c4bd660028007794" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called &lt;em&gt;extension functions&lt;/em&gt;. There are also &lt;em&gt;extension properties&lt;/em&gt; that let you define new properties for existing classes.</source>
          <target state="translated">Kotlin提供了使用新功能扩展类的能力，而无需继承该类或使用诸如Decorator之类的设计模式。这是通过称为&lt;em&gt;extensions的&lt;/em&gt;特殊声明完成的。例如，您可以为无法修改的第三方库中的类编写新函数。这些函数可以按常规方式调用，就好像它们是原始类的方法一样。这种机制称为&lt;em&gt;扩展功能&lt;/em&gt;。也有&lt;em&gt;扩展属性&lt;/em&gt;，可让您为现有类定义新属性。</target>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin提供了针对JavaScript的能力。它通过将Kotlin移植到JavaScript中来实现。目前的实现以ECMAScript 5.1为目标,但计划最终也以ECMAScript 2015为目标。</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlin提供了以下代表数字的内置类型(这与Java很接近)。</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">Kotlin为Ant提供了三个任务。</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlin要求在实例构建过程中初始化每个成员属性。有时，类的使用方式应使构造函数没有足够的信息来初始化所有属性（例如，制作构建器类或使用基于属性的依赖注入时）。为了不必使这些属性可为空，可以使用&lt;em&gt;后期初始化的属性&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; 文件中的Kotlin脚本</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">Kotlin单例（使用 &lt;code&gt;object&lt;/code&gt; 声明（包括 &lt;code&gt;companion object&lt;/code&gt; ）制成）作为具有单个实例的类导入到Swift / Objective-C中。该实例可通过工厂方法使用，例如，Objective-C中的 &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; 和Swift中的 &lt;code&gt;MySingleton()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">Kotlin单子</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">要编译的Kotlin源文件或目录</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlin源集可能与&lt;em&gt;&amp;ldquo;取决于&amp;rdquo;&lt;/em&gt;关系相关联，因此，如果源集 &lt;code&gt;foo&lt;/code&gt; 取决于源集 &lt;code&gt;bar&lt;/code&gt; 则：</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin源码可以和Java源码混合在同一个文件夹中,也可以放在不同的文件夹中。默认的惯例是使用不同的文件夹。</target>
        </trans-unit>
        <trans-unit id="8dda6be52af63434ddc539d85c3f07ae2c8c8de5" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be stored with Java sources in the same folder, or placed to different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin源码可以和Java源码存储在同一个文件夹中,也可以放在不同的文件夹中。默认的惯例是使用不同的文件夹。</target>
        </trans-unit>
        <trans-unit id="448431d8ccbcd8c407715ad54cff923c4f538ad6" translate="yes" xml:space="preserve">
          <source>Kotlin standard libraries</source>
          <target state="translated">Kotlin标准库</target>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin标准库构件和拆分包。</target>
        </trans-unit>
        <trans-unit id="77cb00a3ce7a3cdab1c1c157be47f7632c70f806" translate="yes" xml:space="preserve">
          <source>Kotlin subclasses of Objective-C classes</source>
          <target state="translated">Objective-C类的Kotlin子类</target>
        </trans-unit>
        <trans-unit id="2607bec52d42f747a5225384e349fc0ccef2ced7" translate="yes" xml:space="preserve">
          <source>Kotlin supports SAM conversions for both Java and &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin interfaces&lt;/a&gt;. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Kotlin支持Java和&lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin接口的&lt;/a&gt;SAM转换。对Java的支持意味着，只要接口方法的参数类型与Kotlin函数的参数类型匹配，就可以使用单个非默认方法将Kotlin函数文字自动转换为Java接口的实现。</target>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin支持一种称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;尾递归&lt;/a&gt;的函数式编程。这允许某些通常使用循环编写的算法改为使用递归函数编写，但是没有堆栈溢出的风险。当一个函数用 &lt;code&gt;tailrec&lt;/code&gt; 修饰符标记并符合所需形式时，编译器会优化递归，而留下一个快速，高效的基于循环的版本：</target>
        </trans-unit>
        <trans-unit id="a2baed6c5430ce0572e2f1a5bae6b4631f0f1c73" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin支持一种称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;尾递归&lt;/a&gt;的函数式编程。这允许某些通常使用循环编写的算法改为使用递归函数编写，但是没有堆栈溢出的风险。当一个函数用 &lt;code&gt;tailrec&lt;/code&gt; 修饰符标记并符合所需形式时，编译器会优化递归，而留下一个快速，高效的基于循环的版本：</target>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlin通过&lt;em&gt;Kotlin注释处理工具&lt;/em&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）支持&lt;em&gt;注释处理&lt;/em&gt;。&lt;a href=&quot;kapt&quot;&gt;kapt页面&lt;/a&gt;上介绍了kapt与Gradle的用法。</target>
        </trans-unit>
        <trans-unit id="13f5d747f019181c1a771753e56710d47a2bbad6" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the Kotlin annotation processing tool &lt;a href=&quot;kapt&quot;&gt;&lt;code&gt;kapt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Kotlin通过Kotlin注释处理工具&lt;a href=&quot;kapt&quot;&gt; &lt;code&gt;kapt&lt;/code&gt; &lt;/a&gt;支持注释处理。</target>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin支持本地函数,即一个函数在另一个函数里面。</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlin支持单父类继承-因此，每个类（根类 &lt;code&gt;Any&lt;/code&gt; 除外）都只有一个父类，称为&lt;em&gt;超类&lt;/em&gt;。 Kotlin希望您仔细考虑类的设计，以确保对其进行&lt;em&gt;子类化&lt;/em&gt;实际上是安全的，因此，默认情况下类是&lt;em&gt;关闭&lt;/em&gt;的，除非您明确声明该类为&lt;em&gt;open&lt;/em&gt;或&lt;em&gt;abstract&lt;/em&gt;，否则不能继承。然后，您可以通过声明一个新类来从该类中子类化，该新类在冒号后提及其父类：</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlin支持以下运算符和特殊符号。</target>
        </trans-unit>
        <trans-unit id="a681ed989bc5949117e886914d64403b1862e6f9" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following platforms and provides target presets for each platform. See how to &lt;a href=&quot;mpp-set-up-targets&quot;&gt;use a target preset&lt;/a&gt;.</source>
          <target state="translated">Kotlin支持以下平台，并为每个平台提供目标预设。了解如何&lt;a href=&quot;mpp-set-up-targets&quot;&gt;使用目标预设&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9f65c39eaf4fcfb17c2f522f10687c0e4404fdb" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers (&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;), which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin支持数字（ &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; ）上的标准算术运算集，这些算术运算被声明为适当类的成员（但编译器会优化对相应指令的调用）。请参阅&lt;a href=&quot;operator-overloading&quot;&gt;运算符重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin支持数字上的标准算术运算集，这些算术运算被声明为适当类的成员（但编译器会优化对相应指令的调用）。请参阅&lt;a href=&quot;operator-overloading&quot;&gt;运算符重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">Kotlin支持传统的&lt;em&gt;break&lt;/em&gt;和循环&lt;em&gt;继续&lt;/em&gt;操作符。请参阅&lt;a href=&quot;returns&quot;&gt;返回和跳转&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d07ef64d55abdae6d6a123db33be555df8316b4" translate="yes" xml:space="preserve">
          <source>Kotlin supports trailing commas in the following cases:</source>
          <target state="translated">Kotlin支持在以下情况下使用尾部逗号。</target>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlin面向广泛的Java版本，包括Java 6和Java 7，其中不允许接口中使用默认方法。为方便起见，Kotlin编译器可解决该限制，但该解决方法与Java 8中引入的 &lt;code&gt;default&lt;/code&gt; 方法不兼容。</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">Kotlin to JavaScript</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlin特别对待某些Java类型。此类类型不是从Java 照原样加载的，而是&lt;em&gt;映射&lt;/em&gt;到相应的Kotlin类型。映射仅在编译时起作用，运行时表示形式保持不变。Java的原始类型映射到相应的Kotlin类型（请记住&lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;平台类型&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlin将函数指针返回类型转换为可为空的 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; 对象。有必要先明确检查 &lt;code&gt;null&lt;/code&gt; 。为此，我们使用&lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis运算符&lt;/a&gt;。该 &lt;code&gt;cinterop&lt;/code&gt; 工具可以帮助我们把C函数指针指向一个简单的调用对象科特林。这就是我们在最后一行所做的。</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">科特林使用函数类型，如家族 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; 的声明该处理功能： &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlin将 &lt;code&gt;libnative_&lt;/code&gt; 前缀用于所创建的 &lt;code&gt;libnative_api.h&lt;/code&gt; 文件中的所有声明。让我们以一种更具可读性的方式呈现类型的映射：</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlin旨在与Java平台轻松互操作。它将Java类视为Kotlin类，而Java将Kotlin类视为Java类。但是，JavaScript是一种动态类型的语言，这意味着它不会在编译时检查类型。您可以通过&lt;a href=&quot;dynamic-type&quot;&gt;动态&lt;/a&gt;类型从Kotlin中自由地与JavaScript对话，但是如果您想要Kotlin类型系统的全部功能，则可以为JavaScript库创建Kotlin标头。</target>
        </trans-unit>
        <trans-unit id="e4c0f3a3782b90edcee0e70de97ebb0b28520a70" translate="yes" xml:space="preserve">
          <source>Kotlin was first designed for easy interoperation with the Java platform: it sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes.</source>
          <target state="translated">Kotlin的设计初衷是为了方便与Java平台的互操作:它把Java类看作是Kotlin类,而Java把Kotlin类看作是Java类。</target>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlin允许您声明该属性而无需初始化它，并且您可以在构造后的某个时候（直接或通过函数）设置属性值。类本身及其用户都有责任注意在设置属性之前不要读取该属性，并且Kotlin允许您编写读取 &lt;code&gt;name&lt;/code&gt; 的代码，就像它是普通的，不可为空的属性一样。但是，编译器是无法强制执行正确的使用方法，因此，如果属性是读已设置之前，一个 &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; 将在运行时抛出。</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlin使用Spring Boot可以非常顺畅地工作，并且Kotlin可以完全遵循&lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring指南&lt;/a&gt;中创建RESTful服务的许多步骤。但是，在定义Gradle配置和项目布局结构以及初始化代码方面存在一些细微差异。</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlin使用不同的&lt;a href=&quot;build-tools&quot;&gt;构建工具&lt;/a&gt;，因此，如果我们使用的是Ant，Maven或Gradle之类的标准工具，则Kotlin项目的设置过程与与这些工具集成的任何其他语言或库没有什么不同。在使用JBS时，有一些小的要求和不同之处，这是IntelliJ IDEA使用的内部构建系统，TeamCity也支持该系统。</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlin处理异步代码的方法是使用coroutines,也就是可暂停计算的思想,即一个函数可以在某个时刻暂停执行,以后再恢复。</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlin的文档生成工具称为&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;。有关用法说明，请参阅《&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt;》。</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlin的文档语法称为&lt;em&gt;KDoc&lt;/em&gt;。 KDoc块放置在它描述的结构上方，并以 &lt;code&gt;/**&lt;/code&gt; 开头，并以 &lt;code&gt;*/&lt;/code&gt; 结束（可能在一行上；如果没有，则每个中间行应以对齐的星号开头）。文本的第一块是摘要。然后，您可以使用&lt;em&gt;块标记&lt;/em&gt;提供有关构造的特定部分的信息。某些块标记是 &lt;code&gt;@param&lt;/code&gt; (用于函数参数和泛型类型参数），以及 &lt;code&gt;@return&lt;/code&gt; (用于返回值）。您可以链接到方括号内的标识符。链接和块标记名称之外的所有文本均为Markdown格式。</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlin的泛型与Java的&lt;a href=&quot;generics&quot;&gt;泛型&lt;/a&gt;有些不同（请参阅Generics）。将Java类型导入Kotlin时，我们会执行一些转换：</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">Kotlin的循环类似于Python的循环。 &lt;code&gt;for&lt;/code&gt; 迭代任何&lt;em&gt;可迭代的&lt;/em&gt;事物（任何具有提供 &lt;code&gt;Iterator&lt;/code&gt; 对象的 &lt;code&gt;iterator()&lt;/code&gt; 函数的事物）或本身就是迭代器的事物：</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">Kotlin的对象模型与Python的对象模型有很大的不同。最重要的是，类&lt;em&gt;不能&lt;/em&gt;在运行时动态修改！ （有一些有限的例外，但你一般不应该这样做然而，。&lt;em&gt;是&lt;/em&gt;可以动态地&lt;em&gt;检查&lt;/em&gt;类和在运行时用一个功能叫做物体&lt;em&gt;反射&lt;/em&gt; -这可能是有用的，但应谨慎使用）所有必须直接在类主体中声明或作为&lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;扩展函数&lt;/em&gt;&lt;/a&gt;声明类中可能需要的属性（属性）和函数，因此您应该在类设计时仔细考虑。</target>
        </trans-unit>
        <trans-unit id="d2a59f6487d643d44ccac72e26090969f3853d89" translate="yes" xml:space="preserve">
          <source>Kotlin's standard library has a &lt;code&gt;TODO()&lt;/code&gt; function that will always throw a &lt;code&gt;NotImplementedError&lt;/code&gt;. Its return type is &lt;code&gt;Nothing&lt;/code&gt; so it can be used regardless of expected type. There's also an overload that accepts a reason parameter:</source>
          <target state="translated">Kotlin的标准库具有 &lt;code&gt;TODO()&lt;/code&gt; 函数，该函数将始终抛出 &lt;code&gt;NotImplementedError&lt;/code&gt; 。它的返回类型为 &lt;code&gt;Nothing&lt;/code&gt; ,因此无论期望的类型如何都可以使用它。还有一个接受了reason参数的重载：</target>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin的类型系统旨在消除代码中空引用的危险，也称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;&amp;ldquo;十亿美元的错误&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b3b3c2fce26ced6c3f89e4969b12ebc4e57fb47" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin的类型系统旨在消除代码中空引用的危险，也称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlin的类型系统旨在从我们的代码中消除 &lt;code&gt;NullPointerException&lt;/code&gt; 。NPE的唯一可能原因可能是：</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlin作为一种语言，在其标准库中仅提供最少的低级API，以使其他各种库都可以使用协程。与许多其他具有类似功能的语言不同， &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 不是Kotlin中的关键字，甚至都不是其标准库的一部分。此外，与期货和承诺相比，Kotlin的&lt;em&gt;暂停功能&lt;/em&gt;概念为异步操作提供了更安全，更不易出错的抽象。</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">与C＃和Gosu相似，Kotlin提供了使用新功能扩展类的功能，而不必继承该类或使用任何类型的设计模式（例如Decorator）。这通过称为&lt;em&gt;扩展的&lt;/em&gt;特殊声明来完成。Kotlin支持&lt;em&gt;扩展功能&lt;/em&gt;和&lt;em&gt;扩展属性&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="b4529ea374c3a4cde07a41aa987a9b048c623d50" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (Classic back-end)</source>
          <target state="translated">Kotlin/JS (经典后端)</target>
        </trans-unit>
        <trans-unit id="4c111df440b988d7ac0f881b0ae8eeed10bb5e43" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (IR-based)</source>
          <target state="translated">Kotlin/JS (基于IR)</target>
        </trans-unit>
        <trans-unit id="3409f54fa5231194c2d7cb0f9009c3222e1a2109" translate="yes" xml:space="preserve">
          <source>Kotlin/JS Overview</source>
          <target state="translated">Kotlin/JS概述</target>
        </trans-unit>
        <trans-unit id="5579b6ef038f8f8ca2fe985b676250979f056cbe" translate="yes" xml:space="preserve">
          <source>Kotlin/JS allows you to &lt;strong&gt;leverage powerful browser and web APIs&lt;/strong&gt; in a type-safe fashion. Create, modify and interact with elements in the Document Object Model (DOM), use Kotlin code to control the rendering of &lt;code&gt;canvas&lt;/code&gt; or WebGL components, and enjoy access to many more of the features supported in modern browsers.</source>
          <target state="translated">Kotlin / JS允许您以类型安全的方式&lt;strong&gt;利用功能强大的浏览器和Web API&lt;/strong&gt;。创建，修改文档对象模型（DOM）中的元素并与之交互，使用Kotlin代码来控制 &lt;code&gt;canvas&lt;/code&gt; 或WebGL组件的呈现，并享受对现代浏览器支持的更多功能的访问。</target>
        </trans-unit>
        <trans-unit id="c551ceb4f789ea0a28725793cbf50b7fde3239c9" translate="yes" xml:space="preserve">
          <source>Kotlin/JS compiler options</source>
          <target state="translated">Kotlin/JS编译器选项</target>
        </trans-unit>
        <trans-unit id="bc555107bc3ab29b699e3ac57e1fb75bce2155ce" translate="yes" xml:space="preserve">
          <source>Kotlin/JS is also compatible with the most common module systems: UMD, CommonJS, and AMD. Being able to &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;produce and consume modules&lt;/a&gt; means that you can interact with the JavaScript ecosystem in a structured manner.</source>
          <target state="translated">Kotlin / JS还与最常见的模块系统兼容：UMD，CommonJS和AMD。能够&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;生产和使用模块&lt;/a&gt;意味着您可以以结构化的方式与JavaScript生态系统进行交互。</target>
        </trans-unit>
        <trans-unit id="6c71e5ac2d4139fc0df7bb50e9a0d7dcc0b261db" translate="yes" xml:space="preserve">
          <source>Kotlin/JS projects can target two different execution environments:</source>
          <target state="translated">Kotlin/JS项目可以针对两种不同的执行环境。</target>
        </trans-unit>
        <trans-unit id="2dd41eae9565ad317afb86080bea814ec06af110" translate="yes" xml:space="preserve">
          <source>Kotlin/JS projects use Gradle as a build system. To let developers easily manage their Kotlin/JS projects, we offer the &lt;code&gt;kotlin.js&lt;/code&gt; Gradle plugin that provides project configuration tools together with helper tasks for automating routines typical for JavaScript development. For example, the plugin downloads the &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; package manager for managing &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; dependencies in background and can build a JavaScript bundle from a Kotlin project using &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;. Dependency management and configuration adjustments can be done to a large part directly from the Gradle build file, with the option to override automatically generated configurations for full control.</source>
          <target state="translated">Kotlin / JS项目使用Gradle作为构建系统。为了让开发人员轻松管理其Kotlin / JS项目，我们提供了 &lt;code&gt;kotlin.js&lt;/code&gt; Gradle插件，该插件提供项目配置工具以及帮助程序任务，以自动执行JavaScript开发中常用的例程。例如，该插件下载&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;软件包管理器以在后台管理&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;依赖关系，并可以使用&lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;从Kotlin项目构建JavaScript捆绑包。可以直接从Gradle构建文件中对依赖项管理和配置进行很大程度的调整，并可以选择覆盖自动生成的配置以进行完全控制。</target>
        </trans-unit>
        <trans-unit id="73e221948b2977f48bf5440d552a61a97802b3f2" translate="yes" xml:space="preserve">
          <source>Kotlin/JS provides the ability to transpile your Kotlin code, the Kotlin standard library, and any compatible dependencies to JavaScript. The current implementation of Kotlin/JS targets &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5&lt;/a&gt;.</source>
          <target state="translated">Kotlin / JS提供了转换您的Kotlin代码，Kotlin标准库以及对JavaScript的任何兼容依赖项的能力。Kotlin / JS的当前实现以&lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5为&lt;/a&gt;目标。</target>
        </trans-unit>
        <trans-unit id="e161bf22c4b5c5951be23fef6f0ff257426ebe17" translate="yes" xml:space="preserve">
          <source>Kotlin/JS, Today and Tomorrow</source>
          <target state="translated">Kotlin/JS,今天和明天</target>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="629649c3a6fde50e4105c70afe705d63afa55224" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM (IR-based)</source>
          <target state="translated">Kotlin/JVM(基于IR)</target>
        </trans-unit>
        <trans-unit id="101afe89559b0f2b0c4257af7917cfec768ae3d7" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM compiler options</source>
          <target state="translated">Kotlin/JVM编译器选项</target>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin / Native &lt;a href=&quot;native/platform_libs&quot;&gt;库&lt;/a&gt;有助于在项目之间共享Kotlin代码。预先导入POSIX，gzip，OpenGL，Metal，Foundation和许多其他流行的库和Apple框架，并将它们作为Kotlin / Native库包含在编译器软件包中。</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Kotlin/Native Gradle插件</target>
        </trans-unit>
        <trans-unit id="c83dbff85c7c1cfb09790c18b941a770c8cb6d04" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime</source>
          <target state="translated">Kotlin/Native Runtime</target>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">Kotlin/Native Runtime声明</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / Native还与Apple技术紧密集成。&lt;a href=&quot;apple-framework&quot;&gt;作为苹果框架&lt;/a&gt;的Kotlin / Native教程说明了如何将Kotlin代码编译为Swift和Objective-C的框架。</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native还与Objective-C和Swift紧密集成。&lt;a href=&quot;apple-framework&quot;&gt;作为苹果框架&lt;/a&gt;教程，在Kotlin / Native中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">作为动态库的Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">作为苹果框架的Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native可用于许多&lt;a href=&quot;basic-kotlin-native-app&quot;&gt;目标&lt;/a&gt;和应用程序，包括但不限于macOS，Windows，Linux和&lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native附带了 &lt;code&gt;cinterop&lt;/code&gt; 工具，该工具在C语言和Kotlin之间生成绑定。它使用 &lt;code&gt;.def&lt;/code&gt; 文件指定要导入的C库。&amp;ldquo; &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&amp;rdquo;&lt;/a&gt;教程中讨论了更多详细信息。</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native带有 &lt;code&gt;cinterop&lt;/code&gt; 工具。该工具在C语言和Kotlin之间生成绑定。它使用 &lt;code&gt;.def&lt;/code&gt; 文件指定要导入的C库。有关此问题的更多详细信息，请参见《&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries》&lt;/a&gt;教程。</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Native带有 &lt;code&gt;cinterop&lt;/code&gt; 工具。该工具在C语言和Kotlin之间生成绑定。它使用 &lt;code&gt;.def&lt;/code&gt; 文件指定要导入的C库。有关此问题的更多详细信息，请参见《&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries》&lt;/a&gt;教程。尝试C API映射的最快的方法是在所有的C声明 &lt;code&gt;interop.def&lt;/code&gt; 文件，而不会产生任何 &lt;code&gt;.h&lt;/code&gt; 的 &lt;code&gt;.c&lt;/code&gt; 的所有文件。然后将C声明放在特殊的 &lt;code&gt;---&lt;/code&gt; 分隔线之后的 &lt;code&gt;interop.def&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Kotlin / Native编译器可以从我们拥有的Kotlin代码中生成一个动态库。动态库通常带有一个头文件（ &lt;code&gt;.h&lt;/code&gt; 文件），我们将使用它从C调用编译后的代码。</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Kotlin/Native编译器可以用Kotlin代码生成一个适用于macOS和iOS的框架。所创建的框架包含了使用Objective-C和Swift所需的所有声明和二进制文件。理解这些技术的最好方法是自己尝试。让我们先创建一个小小的Kotlin库,并从一个Objective-C程序中使用它。</target>
        </trans-unit>
        <trans-unit id="b715f52434e20442ebb46ac504b8f84bf0548313" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler compiles Kotlin source files into native binaries for the &lt;a href=&quot;native-overview#target-platforms&quot;&gt;supported platforms&lt;/a&gt;. The command-line tool for Kotlin/Native compilation is &lt;code&gt;kotlinc-native&lt;/code&gt;.</source>
          <target state="translated">Kotlin / Native编译器将Kotlin源文件编译为&lt;a href=&quot;native-overview#target-platforms&quot;&gt;支持平台的&lt;/a&gt;本机二进制文件。用于Kotlin / Native编译的命令行工具是 &lt;code&gt;kotlinc-native&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72370bde43174b087fc25e3ae6d822902a3834d6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler options</source>
          <target state="translated">Kotlin/Native编译器选项</target>
        </trans-unit>
        <trans-unit id="c0c8b720dae4415d29464c12eeee3db3497f57a4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native doesn't support Maven and IntelliJ IDEA native builder.</source>
          <target state="translated">Kotlin/Native不支持Maven和IntelliJ IDEA native builder。</target>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">Kotlin/Native for Native</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Native具有与Objective-C和Swift语言的双向互操作。Kotlin对象与Objective-C / Swift参考计数集成在一起。未使用的Kotlin对象将自动删除。在&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C的互操作性&lt;/a&gt;文章包含有关互操作性的实施细则的更多信息。当然，可以导入现有框架并从Kotlin使用它。Kotlin / Native带有一整套预导入的系统框架。</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native具有垃圾回收，但是它不能帮助我们处理C语言中的Kotlin对象。Kotlin / Native与Objective-C和Swift互操作，并与它们的参考计数器集成。在&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C的互操作性&lt;/a&gt;文档文章包含有关它的更多细节。另外，还有教程&lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native作为Apple Framework&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd3fb305a0493b588bb98fac3fd02dfc049654c2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has received a number of performance improvements that speed up both the development process and execution. Here are some examples:</source>
          <target state="translated">Kotlin/Native在性能上得到了一些改进,加快了开发过程和执行速度。下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Native执行严格的可变性检查，以确保重要的不变性，即该对象在该时刻是不变的或可以从单个线程访问（ &lt;code&gt;mutable XOR global&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;文档&lt;/a&gt;文章涵盖了与Swift和Objective-C的Kotlin / Native互操作。另外，&lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native作为Apple Framework&lt;/a&gt;教程涵盖了相同的主题。</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">Kotlin/Native互操作性</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Kotlin/Native与Swift/Objective-C的互操作性。</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Native是一种将Kotlin代码编译为本地二进制文件的技术，该二进制文件无需虚拟机即可运行。它是Kotlin编译器和Kotlin标准库的本机实现的基于&lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt;的后端。</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native目前正在开发&lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;中&lt;/a&gt;。它将Kotlin编译为无需VM即可运行的本机代码。已发布了技术预览版，但尚未投入生产，并且尚未针对我们计划支持1.0的所有平台。有关更多信息，请查看&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;发布Kotlin / Native&lt;/a&gt;的博客文章。</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Native的主要目的是允许对不需要或不可能使用&lt;em&gt;虚拟机的&lt;/em&gt;平台进行编译，例如嵌入式设备或iOS。它解决了开发人员需要生成不需要额外运行时或虚拟机的自包含程序的情况。</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">Kotlin/Native库</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin/Native库是包含预定义目录结构的zip文件,其布局如下。</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">科特林/本地插件需要摇篮的新版本，让我们在补丁 &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; 并使用以下 &lt;code&gt;distrubutionUrl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Native提供了与Objective-C / Swift的双向互操作性。可以在Kotlin代码中使用Objective-C框架和库。Kotlin模块也可以在Swift / Objective-C代码中使用。除此之外，Kotlin / Native具有&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;。还有&lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native作为动态库的&lt;/a&gt;教程，以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Native提供与Objective-C的双向互操作性。如果正确导入到构建中，则可以在Kotlin代码中使用Objective-C框架和库（默认情况下会导入系统框架）。请参阅例如&lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle插件文档中的&lt;/a&gt; &amp;ldquo;使用cinterop&amp;rdquo; 。如果Swift库的API已通过 &lt;code&gt;@objc&lt;/code&gt; 导出到Objective-C，则可以在Kotlin代码中使用它。尚不支持Pure Swift模块。</target>
        </trans-unit>
        <trans-unit id="70a326aefb047308c0a09cf46a7be9e9cca8e58e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides integration with the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;. You can add dependencies on Pod libraries stored in the CocoaPods repository or locally as well as use a multiplatform project with native targets as a CocoaPods dependency (Kotlin Pod).</source>
          <target state="translated">Kotlin / Native提供与&lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods依赖项管理器的&lt;/a&gt;集成。您可以添加对CocoaPods存储库中或本地存储的Pod库的依赖关系，也可以将具有本机目标的多平台项目用作CocoaPods依赖关系（Kotlin Pod）。</target>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Native为我们提供了使用标准C库的能力，从而开放了一个完整的功能生态系统，该功能生态系统几乎可以满足我们所需的所有需求。实际上，Kotlin / Native已经附带了一组预构建的&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;平台库&lt;/a&gt;，这些库提供了标准库所提供的一些其他通用功能。</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin/Native运行时并不鼓励采用经典的面向线程的并发模型,该模型具有相互排斥的代码块和条件变量,因为这种模型众所周知容易出错且不可靠。相反,我们建议了一系列替代方法,允许你使用硬件并发并实现阻塞IO。这些方法如下,将在后面的章节中详细介绍。</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">Kotlin/本地资源和例子</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Kotlin/Native sources and examples (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Kotlin/Native sources and examples (.zip)</target>
        </trans-unit>
        <trans-unit id="5729c05577d9982b3fa36c76507104ea69c51357" translate="yes" xml:space="preserve">
          <source>Kotlin/Native standard library provides primitives for safe working with concurrently mutable data, namely &lt;code&gt;AtomicInt&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt;, &lt;code&gt;AtomicNativePtr&lt;/code&gt;, &lt;code&gt;AtomicReference&lt;/code&gt; and &lt;code&gt;FreezableAtomicReference&lt;/code&gt; in the package &lt;code&gt;kotlin.native.concurrent&lt;/code&gt;. Atomic primitives allows concurrency-safe update operations, such as increment, decrement and compare-and-swap, along with value setters and getters. Atomic primitives are considered always frozen by the runtime, and while their fields can be updated with the regular &lt;code&gt;field.value += 1&lt;/code&gt;, it is not concurrency safe. Value must be be changed using dedicated operations, so it is possible to perform concurrent-safe global counters and similar data structures.</source>
          <target state="translated">Kotlin / Native标准库在包 &lt;code&gt;kotlin.native.concurrent&lt;/code&gt; 中提供了用于安全地处理并发可变数据的原语，这些数据是 &lt;code&gt;AtomicInt&lt;/code&gt; ， &lt;code&gt;AtomicLong&lt;/code&gt; ， &lt;code&gt;AtomicNativePtr&lt;/code&gt; ， &lt;code&gt;AtomicReference&lt;/code&gt; 和 &lt;code&gt;FreezableAtomicReference&lt;/code&gt; 。原子原语允许并发安全的更新操作，例如增量，减量和比较和交换，以及值设置器和获取器。原子原语始终被运行时冻结，并且它们的字段可以用常规字段更新。 &lt;code&gt;field.value += 1&lt;/code&gt; ，这不是并发安全的。必须使用专用操作来更改值，以便可以执行并发安全的全局计数器和类似的数据结构。</target>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / Native也支持C互操作。查看有关&lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native作为动态库的&lt;/a&gt;教程，或者查看&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt;文档文章</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin/Native支持以下平台。</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin/Native支持与Native世界的双向互通。一方面,编译器创建。</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">Kotlin /本机目标预设（请参阅以下&lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;注释&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Kotlin / Native目标不需要其他测试依赖项，并且内置了 &lt;code&gt;kotlin.test&lt;/code&gt; API实现。</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Native 通过&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件使用&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;构建系统。我们将在下面查看如何配置Gradle构建。对于某些极端情况，仍然可以从&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;GitHub上&lt;/a&gt;的Kotlin版本页面手动（不推荐）获得Kotlin / Native编译器。在本教程中，我们专注于使用Gradle构建。</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">KotlinConf Spinner应用</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">KotlinConf应用程序</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">Lambda表达式和匿名函数</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">Lambda表达式语法</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">Lambda表达式和匿名函数都是 &quot;函数字面&quot;,即没有声明,而是作为表达式立即传递的函数。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">Lambda表达式和匿名函数统称为&lt;em&gt;函数文字&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">当可以从上下文推断接收器类型时，Lambda表达式可用作接收器的函数文字。&lt;a href=&quot;type-safe-builders&quot;&gt;类型安全的构建器&lt;/a&gt;是最重要的用法之一：</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">兰姆达格式化</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">兰姆达参数</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">Lambda结果</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="92af1ed3cd8ff99b216bc082c8daaf4fcc54a009" translate="yes" xml:space="preserve">
          <source>Lambdas returning &lt;code&gt;kotlin.Result&lt;/code&gt; now return boxed value instead of unboxed</source>
          <target state="translated">&lt;code&gt;kotlin.Result&lt;/code&gt; 返回kotlin.Result现在返回装箱的值而不是未装箱的值</target>
        </trans-unit>
        <trans-unit id="5a9f9099a35efc6c2d9f032d57efb49b93a9221c" translate="yes" xml:space="preserve">
          <source>Language and stdlib</source>
          <target state="translated">语言和stdlib</target>
        </trans-unit>
        <trans-unit id="fa3f4623762408896074b73a50b22e0a64f2aec4" translate="yes" xml:space="preserve">
          <source>Language features and improvements</source>
          <target state="translated">语文特点和改进</target>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">语言设置</target>
        </trans-unit>
        <trans-unit id="a69a0d9ceb988516811878ad5b3baf535d6a8d16" translate="yes" xml:space="preserve">
          <source>Language settings are checked for consistency in the following ways:</source>
          <target state="translated">通过以下方式检查语言设置的一致性。</target>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">源集的语言设置会影响IDE中对源的分析。由于目前的限制,在Gradle构建中,只使用编译的默认源集的语言设置,并应用于所有参与编译的源。</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">后期初始化属性和变量</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Lateinit顶层属性和局部变量</target>
        </trans-unit>
        <trans-unit id="8958c019aa5a02d51718ce29ef1d34ac94e1a924" translate="yes" xml:space="preserve">
          <source>Launching flow</source>
          <target state="translated">发射流程</target>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">懒惰地启动异步</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">懒惰财产</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="88e85262e00274cab89a641da3cb45b95f5a2ce2" translate="yes" xml:space="preserve">
          <source>Learn &lt;a href=&quot;native/cocoapods&quot;&gt;how to add dependencies&lt;/a&gt;.</source>
          <target state="translated">了解&lt;a href=&quot;native/cocoapods&quot;&gt;如何添加依赖项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">学习盆地</target>
        </trans-unit>
        <trans-unit id="e3737ad5066ff8c2efc62a80380f6fc54741a2ea" translate="yes" xml:space="preserve">
          <source>Learn about &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;multiplatform projects&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;多平台项目的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2474d64d95d6b15d329e41bab7ed01766c506ac9" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-configure-compilations&quot;&gt;configure compilations&lt;/a&gt;.</source>
          <target state="translated">了解如何&lt;a href=&quot;mpp-configure-compilations&quot;&gt;配置编译&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bcd0abba8e732ce3f464292f0728067fe8360ff" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-set-up-targets&quot;&gt;set up targets manually&lt;/a&gt;.</source>
          <target state="translated">了解如何&lt;a href=&quot;mpp-set-up-targets&quot;&gt;手动设置目标&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20953bfc9862dd27c555f29879ffef5ff21fa3c3" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;build the hierarchy of source sets&lt;/a&gt;.</source>
          <target state="translated">了解如何&lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;构建源集的层次结构&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2ca28cd12d1bd44a1297fd960c1eedef1b345b3" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;using-gradle#dependency-on-the-standard-library&quot;&gt;change the default behavior&lt;/a&gt;.</source>
          <target state="translated">了解如何&lt;a href=&quot;using-gradle#dependency-on-the-standard-library&quot;&gt;更改默认行为&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64487eb003a10dbcb473f2557c19c16b00054e2a" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;#share-code-in-libraries&quot;&gt;sharing code in libraries&lt;/a&gt; and &lt;a href=&quot;#use-native-libraries-in-the-hierarchical-structure&quot;&gt;using Native libraries in the hierarchical structure&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;#share-code-in-libraries&quot;&gt;在库中共享代码&lt;/a&gt;以及&lt;a href=&quot;#use-native-libraries-in-the-hierarchical-structure&quot;&gt;在分层结构中使用本机库的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="ed58d30a4c6366747487c1ab11dfdb8bd165900e" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin functional interfaces and SAM conversions&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin功能接口和SAM转换的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="e3a266a26503caec98e47c6ba6a7a5accc48d540" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;js-project-setup&quot;&gt;configuring Kotlin/JS projects&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;js-project-setup&quot;&gt;配置Kotlin / JS项目的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="68ece8a8530cbd084c4191e879166f55575d6c48" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-build-native-binaries&quot;&gt;building native binaries&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;mpp-build-native-binaries&quot;&gt;构建本机二进制文件的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="a7794648f1ef065710c83db4bd3fd00ce935fd99" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-configure-compilations&quot;&gt;configuring compilations&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;mpp-configure-compilations&quot;&gt;配置编译的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="35eb7e7ef591eb8121626725e4cbc15aad464688" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-configure-compilations#compilation-for-android&quot;&gt;compilation for Android&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;mpp-configure-compilations#compilation-for-android&quot;&gt;Android编译的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="b82dbe77a2cb72a3eed96435795f26fc5fd861ab" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-discover-project#source-sets&quot;&gt;source sets&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;mpp-discover-project#source-sets&quot;&gt;源集的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="8403f45e73c3fa76d6076b7f5f4ef79b474eabc9" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-dsl-reference#common-target-configuration&quot;&gt;additional settings for targets&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;mpp-dsl-reference#common-target-configuration&quot;&gt;目标的其他设置的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="2f4ffd267ae3e789bf0bdbf84175cab85c2a10c6" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-share-on-platforms#use-native-libraries-in-the-hierarchical-structure&quot;&gt;usage of platform-dependent libraries&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;mpp-share-on-platforms#use-native-libraries-in-the-hierarchical-structure&quot;&gt;平台依赖库用法的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="10bdd6e03dcdfbfdc0a865fbc438364cc7870614" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;using-gradle#configuring-dependencies&quot;&gt;configuring dependencies&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;using-gradle#configuring-dependencies&quot;&gt;配置依赖项的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="802c13534d20e4859719f8999764811676dc2ecd" translate="yes" xml:space="preserve">
          <source>Learn more about coroutines debugging in the &lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;教程中&lt;/a&gt;了解有关协程调试的更多信息。</target>
        </trans-unit>
        <trans-unit id="f0f6b2049ff0f8271b4ef5ecd9ffeb77c34f8ee0" translate="yes" xml:space="preserve">
          <source>Learn more about creating a &lt;a href=&quot;mpp-configure-compilations#create-a-custom-compilation&quot;&gt;custom compilation&lt;/a&gt;.</source>
          <target state="translated">了解有关创建&lt;a href=&quot;mpp-configure-compilations#create-a-custom-compilation&quot;&gt;自定义编译的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="e871fbb0e4ca02f35986ac2bcdf867ebcc67c62b" translate="yes" xml:space="preserve">
          <source>Learn more about debugging coroutines in &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/&quot;&gt;this blog post&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/help/idea/debug-kotlin-coroutines.html&quot;&gt;IntelliJ IDEA documentation&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/&quot;&gt;此博客文章&lt;/a&gt;和&lt;a href=&quot;https://www.jetbrains.com/help/idea/debug-kotlin-coroutines.html&quot;&gt;IntelliJ IDEA文档中&lt;/a&gt;了解有关调试协程的更多信息。</target>
        </trans-unit>
        <trans-unit id="c350bcedee9353ee1217f26074d552b05f99da2b" translate="yes" xml:space="preserve">
          <source>Learn more about the &lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/1.4.0/native/commonizer/README.md&quot;&gt;technical details&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/1.4.0/native/commonizer/README.md&quot;&gt;技术细节的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="382bc2b5420e5bc5b00d6eff83fe5cc43062a688" translate="yes" xml:space="preserve">
          <source>Learn more about the available features in the Kotlin/JS IR compiler backend in the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;js-ir-compiler&quot;&gt;文档中&lt;/a&gt;了解有关Kotlin / JS IR编译器后端中可用功能的更多信息。</target>
        </trans-unit>
        <trans-unit id="65a7c9acfbc9796eb30e7c60b60f1b0ce15271c8" translate="yes" xml:space="preserve">
          <source>Learn more how to &lt;a href=&quot;mpp-configure-compilations#configure-interop-with-native-languages&quot;&gt;configure interop with native languages&lt;/a&gt;.</source>
          <target state="translated">了解更多有关如何&lt;a href=&quot;mpp-configure-compilations#configure-interop-with-native-languages&quot;&gt;使用本地语言配置互操作的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fc982a7f5ebfb278a6eac9d43da3ac1981ee500" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;js-project-setup#choosing-execution-environment&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;js-project-setup#choosing-execution-environment&quot;&gt;设置Kotlin / JS项目中&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">学习Kotlin</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">用EduTools插件学习Kotlin。</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">将其他选项保留为默认值，然后单击&amp;ldquo; &lt;strong&gt;完成&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">让我们有两个字符串生成器： &lt;code&gt;fizz&lt;/code&gt; 和 &lt;code&gt;buzz&lt;/code&gt; 。该 &lt;code&gt;fizz&lt;/code&gt; 产生的&amp;ldquo;嘶嘶声&amp;rdquo;串每300毫秒：</target>
        </trans-unit>
        <trans-unit id="d5d7818bcabda3185325fd62a8d08d65a192e5b3" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action a thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">让我们启动一百个coroutine,所有的coroutine都做一千次同样的动作。我们还将测量它们的完成时间,以便进一步比较。</target>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">让我们启动一百个coroutine,所有的coroutine都做同样的动作一千次。我们还将测量它们的完成时间,以便进一步比较。</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">让我们将有关环境，孩子和工作的知识放在一起。假设我们的应用程序有一个具有生命周期的对象，但是该对象不是协程。例如，我们正在编写一个Android应用程序，并在Android活动的上下文中启动各种协程，以执行异步操作以获取和更新数据，制作动画等。在销毁活动时必须取消所有这些协程，以避免内存泄漏。当然，我们可以手动操作上下文和作业来绑定活动和协同程序的生命周期，但是 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 提供了一个抽象，该抽象封装了以下内容：&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;。您应该已经熟悉协程范围，因为所有协程构建器都声明为它的扩展。</target>
        </trans-unit>
        <trans-unit id="0f1725d0b230accb8eeb7b1ecce985617d4f3a5c" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction encapsulating that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">让我们将有关环境，儿童和工作的知识放到一起。假设我们的应用程序有一个具有生命周期的对象，但是该对象不是协程。例如，我们正在编写一个Android应用程序，并在一个Android活动的上下文中启动各种协程，以执行异步操作来获取和更新数据，制作动画等。在销毁该活动时，必须取消所有这些协程以避免内存泄漏。当然，我们可以手动操作上下文和作业以绑定活动及其协程的生命周期，但是 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 提供了一个封装以下&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;内容&lt;/a&gt;的抽象：CoroutineScope。您应该已经熟悉了协程范围，因为所有协程构建器都被声明为它的扩展。</target>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">让我们把它都跑七遍。</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">我们先来一打,随机延迟。</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">让我们以&lt;a href=&quot;#concurrent-using-async&quot;&gt;异步&lt;/a&gt;示例为例，并提取一个函数，该函数同时执行 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 和 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 并返回其结果的总和。由于&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;协&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;程生成&lt;/a&gt;器定义为在CoroutineScope上的扩展，因此我们需要将其包含在范围内，这就是&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;函数提供的功能：</target>
        </trans-unit>
        <trans-unit id="bcdef397c512533845238594a2c065ab9f9b9332" translate="yes" xml:space="preserve">
          <source>Let us take the &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder is defined as an extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;, we need to have it in the scope and that is what the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">让我们以&lt;a href=&quot;#concurrent-using-async&quot;&gt;异步&lt;/a&gt;示例为例，并提取一个函数，该函数同时执行 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 和 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 并返回其结果的总和。因为&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;协&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;程生成&lt;/a&gt;器定义为CoroutineScope的扩展，所以我们需要将其包含在范围内，这就是&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;函数提供的功能：</target>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">让我们编写一个使用通道生成器的函数，该函数使用一个延迟字符串值的通道，等待每个接收到的延迟值，但仅等到下一个延迟值结束或关闭通道为止。此示例将&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt;子句放在同一 &lt;code&gt;select&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">让我们写一个整数生成器的例子，当主通道上的使用者无法跟上它的值时，它将其值发送到 &lt;code&gt;side&lt;/code&gt; 通道：</target>
        </trans-unit>
        <trans-unit id="2a09d0572f014b56fede8ceb5d706fa8418ec701" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at how to serialize Kotlin objects into JSON.</source>
          <target state="translated">让我们看一下如何将Kotlin对象序列化为JSON。</target>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">我们还要确保协程实际上是并行运行的。如果我们为每个 &lt;code&gt;async&lt;/code&gt; 添加一个1秒的 &lt;code&gt;delay()&lt;/code&gt; ，则生成的程序将不会运行1'000'000秒（超过11,5天）：</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">让我们假设上面的代码中 &lt;code&gt;preparePost&lt;/code&gt; 是一个长期运行的过程，因此将阻塞用户界面。我们可以做的是在一个单独的线程中启动它。然后，这将使我们避免UI阻塞。这是一种非常常见的技术，但是有一系列缺点：</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">让我们从Objective-C调用框架。为此，我们创建具有以下内容的 &lt;code&gt;main.m&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">让我们来看看我们Kotlin库的C API.`。</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">让我们单击&amp;ldquo; &lt;code&gt;App&lt;/code&gt; 运行&amp;rdquo;配置，以使我们的项目在真实的Android设备或仿真器上运行。</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">让我们单击Xcode中的&lt;em&gt;Run&lt;/em&gt;按钮，我们将看到我们的应用程序正在运行</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">让我们用以下内容创建一个 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 存根文件，以了解如何从Kotlin中看到C基本类型声明：</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">让我们创建一个 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 存根文件，其中包含以下内容，以了解如何从Kotlin中看到我们的C声明：</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">让我们再次创建一百万个协程，保留其 &lt;code&gt;Deferred&lt;/code&gt; 对象。现在不再需要原子计数器，因为我们可以返回要从协程中添加的数字：</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">让我们在 &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; 文件夹中创建 &lt;code&gt;Base64Test&lt;/code&gt; 类，并编写Base64的基本测试。</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">让我们用这样的方式来表示一个函数f(x):我们将1加到x上,然后,当所得数中至少有一个尾数为零时,我们去掉这个零。</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">让我们深入了解它的含义。协程的最大优点是它们可以&lt;em&gt;挂起&lt;/em&gt;而不会阻塞线程。编译器必须发出一些特殊的代码才能使其实现，因此我们必须标记&lt;em&gt;可能&lt;/em&gt;在代码中显式&lt;em&gt;挂起的&lt;/em&gt;函数。我们使用 &lt;code&gt;suspend&lt;/code&gt; 修饰符：</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">让我们将 &lt;code&gt;launch { ... }&lt;/code&gt; 的代码块提取到一个单独的函数中。在此代码上执行&amp;ldquo;提取函数&amp;rdquo;重构时，您将获得带有 &lt;code&gt;suspend&lt;/code&gt; 修饰符的新函数。那是您的第一个&lt;em&gt;暂停功能&lt;/em&gt;。暂停函数可以像常规函数一样在协程内部使用，但是它们的附加功能是它们可以依次使用其他暂停函数（如本例中的 &lt;code&gt;delay&lt;/code&gt; )来&lt;em&gt;暂停&lt;/em&gt;协程的执行。</target>
        </trans-unit>
        <trans-unit id="61bad05f01a2e90a1664c7ea21ea22130405aa4e" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code, you get a new function with the &lt;code&gt;suspend&lt;/code&gt; modifier. This is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions (like &lt;code&gt;delay&lt;/code&gt; in this example) to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">让我们将 &lt;code&gt;launch { ... }&lt;/code&gt; 的代码块提取到一个单独的函数中。在此代码上执行&amp;ldquo;提取函数&amp;rdquo;重构时，您将获得带有 &lt;code&gt;suspend&lt;/code&gt; 修饰符的新函数。这是您的第一个&lt;em&gt;暂停功能&lt;/em&gt;。暂停函数可以像常规函数一样在协程内部使用，但是它们的附加功能是它们可以依次使用其他暂停函数（例如本示例中的 &lt;code&gt;delay&lt;/code&gt; ）来&lt;em&gt;暂停&lt;/em&gt;协程的执行。</target>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">首先让我们创建一个项目文件夹。本教程中的所有路径都是相对于这个文件夹的。有时,在添加新文件之前,必须先创建缺少的目录。</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">让我们直接讲一点，将其输入扩展名为 &lt;code&gt;.kt&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">让我们包括从 &lt;code&gt;SharedCode&lt;/code&gt; 项目到Android项目的依赖关系。我们需要修补 &lt;code&gt;app/build.gradle&lt;/code&gt; 文件，并将以下行添加到 &lt;code&gt;dependencies { .. }&lt;/code&gt; 块中：</target>
        </trans-unit>
        <trans-unit id="b82b4fa1803ecc5b171c4989f538f93a5e12eeda" translate="yes" xml:space="preserve">
          <source>Let's just check everything is right with the project so far, the project structure should be:</source>
          <target state="translated">我们就检查一下目前项目的一切情况,项目结构应该是这样的。</target>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">让我们看一下在外部库&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines中&lt;/a&gt;实现的 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">让我们看一个使用 &lt;code&gt;launch&lt;/code&gt; 的完整程序：</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">让我们来看看它,发现有什么变化。在Java中,你对字段进行了注释,将其与相应的视图进行了绑定。</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">让我们确保可以在iPhone模拟器或设备上运行应用程序。</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">让我们将源文件移动到项目下的 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 文件夹中。这是使用&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件时源所在的默认路径。我们使用以下块来指示配置项目以为我们生成动态或共享库：</target>
        </trans-unit>
        <trans-unit id="254d91019bfe0a24fa67828566bb23aeecf078e8" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">让我们将源文件移动到项目下的 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 文件夹中。这是使用&lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件时源所在的默认路径。我们使用以下块来指示配置项目以为我们生成动态或共享库：</target>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">让我们将源文件移动到项目下的 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 文件夹中。这是使用&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件时源所在位置的默认路径。我们使用以下块来指导和配置项目以为我们生成动态或共享库：</target>
        </trans-unit>
        <trans-unit id="034d9c3c346b06a98e0db9b883376985d9d3fdc3" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">让我们将源文件移动到项目下的 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 文件夹中。这是使用&lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件时源所在位置的默认路径。我们使用以下块来指导和配置项目以为我们生成动态库或共享库：</target>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">让我们用以下内容替换 &lt;code&gt;testSolution()&lt;/code&gt; 函数的内容：</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">我们多跑几趟吧</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">让我们运行 &lt;code&gt;linkNative&lt;/code&gt; Gradle任务以&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;在IDE中&lt;/a&gt;或通过调用以下控制台命令来构建库：</target>
        </trans-unit>
        <trans-unit id="106249141867c6b57bd6484ccdc821cb560f7f5d" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">让我们运行 &lt;code&gt;linkNative&lt;/code&gt; Gradle任务以&lt;a href=&quot;using-intellij-idea&quot;&gt;在IDE中&lt;/a&gt;或通过调用以下控制台命令来构建库：</target>
        </trans-unit>
        <trans-unit id="0027507ed05fb5770a6709f41c759d4f8b675c55" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library in the IDE or by calling the following console command:</source>
          <target state="translated">让我们运行 &lt;code&gt;linkNative&lt;/code&gt; Gradle任务以在IDE中或通过调用以下控制台命令来构建库：</target>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">假设您正在编写一个简单的ORM。您的数据库库将一行表示为 &lt;code&gt;Entity&lt;/code&gt; 类的实例，并具有诸如 &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; 和 &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; 类的函数，用于从给定列中获取键入的值。我们可以创建一个类型化的包装类，如下所示：</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">假设我们需要从一个函数返回两件事。例如，结果对象和某种状态。在Kotlin中执行此操作的一种紧凑方法是声明一个&lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;数据类&lt;/em&gt;&lt;/a&gt;并返回其实例：</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">让我们看看如何将 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;object&lt;/code&gt; 映射到Objective-C和Swift。生成的 &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 文件包含有关 &lt;code&gt;Class&lt;/code&gt; ， &lt;code&gt;Interface&lt;/code&gt; 和 &lt;code&gt;Object&lt;/code&gt; 的确切定义：</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">让我们现在看 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 首先转向一个指针：</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">我们来总结一下表中的内容。</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">让我们切换回Android Studio，并从&lt;em&gt;Gradle&lt;/em&gt;工具窗口执行 &lt;code&gt;SharedCode&lt;/code&gt; 项目的 &lt;code&gt;build&lt;/code&gt; 目标。该任务将查找Xcode构建设置的环境变量，并将框架的正确变体复制到 &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; 文件夹中。然后，我们将该文件夹中的框架包含到构建中&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">我们先来看看Kotlin运行时的声明。</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">我们来看一个具体的例子。</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">让我们看一下 &lt;code&gt;kotlin.root.example&lt;/code&gt; 字段，它使用kotlin.root模拟我们的Kotlin代码的包结构 &lt;code&gt;kotlin.root.&lt;/code&gt; 字首。</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">让我们看一个示例，了解 &lt;code&gt;Iterable&lt;/code&gt; 和 &lt;code&gt;Sequence&lt;/code&gt; 之间的区别。</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">让我们看一下以 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 作为参数的生成函数。我们看到按值参数表示为 &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; 。对于类型化的指针参数，我们看到 &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 。Kotlin为我们提供了一个API，可以轻松处理这两种类型，让我们尝试一下。</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">让我们用一个使用coroutine流水线生成素数的例子,把流水线发挥到极致。我们从一个无限的数字序列开始。</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">让我们试试同样的coroutines。</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">让我们尝试使用Kotlin的API。让我们先调用 &lt;code&gt;pass_string&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">现在让我们更新Gradle脚本来实现,并配置我们的IDE。</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">让我们用它来与通道 &lt;code&gt;a&lt;/code&gt; 产生&amp;ldquo;你好&amp;rdquo;字符串四次，通道 &lt;code&gt;b&lt;/code&gt; 产生的&amp;ldquo;世界&amp;rdquo;四次：</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">让我们来看看这些接口和它们的实现。</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">让我们逐步了解一下在Kotlin中实现类型安全构建器的机制。首先，我们需要定义要构建的模型，在这种情况下，我们需要对HTML标签建模。通过一堆类很容易做到。例如， &lt;code&gt;HTML&lt;/code&gt; 是描述 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 标记的类，即，它定义了诸如 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 之类的子代。 （请参阅&lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;下面&lt;/a&gt;的声明。）</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="72a321ab062693e53bbb407257b25f97ff6f7e3d" translate="yes" xml:space="preserve">
          <source>Leveraging native libs in the hierarchical structure</source>
          <target state="translated">在分层结构中利用原生类库</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="944db4e3c24472be792b2084d0de67b6c3f7f699" translate="yes" xml:space="preserve">
          <source>Libraries published with the hierarchical project structure are compatible with all kinds of projects, both with and without the hierarchical project structure. However, libraries published without the hierarchical project structure can&amp;rsquo;t be used in a shared native source set. So, for example, users with &lt;code&gt;ios()&lt;/code&gt; shortcuts in their &lt;code&gt;gradle.build&lt;/code&gt; files won&amp;rsquo;t be able to use your library in their iOS-shared code.</source>
          <target state="translated">以分层项目结构发布的库与所有项目都兼容，无论是否具有分层项目结构。但是，在没有分层项目结构的情况下发布的库不能在共享的本机源集中使用。因此，例如，在 &lt;code&gt;gradle.build&lt;/code&gt; 文件中具有 &lt;code&gt;ios()&lt;/code&gt; 快捷方式的用户将无法在其iOS共享代码中使用您的库。</target>
        </trans-unit>
        <trans-unit id="00f72e56b5ae78fda32dcd4978d25a113af870e2" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">库作者可以使用@Deprecated和&lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt;批注来控制其API表面的演变。请注意，即使对于从API中删除的声明，也可以使用@Deprecated（level = HIDDEN）保留二进制兼容性。</target>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">库作者可以使用 @Deprecated 和 @Experimental 注解来控制他们的 API 表面的演变。请注意,@Deprecated(level=HIDDEN)可以用来保持二进制的兼容性,即使是从API中删除的声明。</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">库代码应该始终明确指定公共/保护函数和属性的返回类型,从而永远不依赖公共API的类型推理。类型推理中的细微变化可能会导致返回类型在无意中改变,从而导致二进制兼容性问题。</target>
        </trans-unit>
        <trans-unit id="c7267839499feac3cd8daacca298c9e65946505b" translate="yes" xml:space="preserve">
          <source>Library search path. For more information, see &lt;a href=&quot;native/libraries#library-search-sequence&quot;&gt;Library search sequence&lt;/a&gt;.</source>
          <target state="translated">库搜索路径。有关更多信息，请参见&lt;a href=&quot;native/libraries#library-search-sequence&quot;&gt;库搜索顺序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">图书馆搜索序列</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">对Kotlin注释设施的库支持。</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">根据Apache许可证,2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">像Java一样，Kotlin的泛型在运行时不会保留，即对象不携带传递给其构造函数的有关实际类型参数的信息，即 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; 与 &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; 是无法区分的。这使得无法进行&lt;em&gt;是&lt;/em&gt;该采取泛型考虑-checks。Kotlin仅允许&lt;em&gt;is&lt;/em&gt; -checks进行星型投影的泛型类型：</target>
        </trans-unit>
        <trans-unit id="d1e9786250417dc0913291ad74e3ec7573630368" translate="yes" xml:space="preserve">
          <source>Like any other Gradle projects, Kotlin/JS projects support traditional Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/declaring_dependencies.html&quot;&gt;dependency declarations&lt;/a&gt; in the &lt;code&gt;dependencies&lt;/code&gt; section of the build script.</source>
          <target state="translated">与其他任何Gradle项目一样，Kotlin / JS项目在构建脚本的 &lt;code&gt;dependencies&lt;/code&gt; 部分中支持传统的Gradle&lt;a href=&quot;https://docs.gradle.org/current/userguide/declaring_dependencies.html&quot;&gt;依赖项声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">像Python中一样，Kotlin中的函数是一等值-它们可以分配给变量并作为参数传递。&lt;em&gt;函数的类型&lt;/em&gt;是&lt;em&gt;函数类型&lt;/em&gt;，用括号括起来的参数类型列表和返回类型的箭头指示。考虑以下功能：</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">像在Python中一样，语句可以用分号终止，但不建议使用。没有换行符；相反，如果这是使代码正确解析的唯一方法，则该行会自动与一个或多个后续行合并在一起。在实践中，这意味着如果我们在开放括号内（如在Python中），或者该行以&amp;ldquo;悬挂运算符&amp;rdquo;结尾（与Python不同），则语句在下一行继续执行解析，除非它与上一个连接（也不同于Python）。请注意，这几乎&lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;与JavaScript相反&lt;/a&gt;，后者通常会保持连接行，只要结果代码仍可解析。因此，以下是Kotlin和Python中的两个表达式（因为 &lt;code&gt;+&lt;/code&gt; 可以是一元的，因此第二行自行解析），但是在JavaScript中是：</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">像在Python中一样，您可以编写&lt;em&gt;lambda表达式&lt;/em&gt;：具有非常紧凑的语法的未命名函数声明，其结果可调用函数对象。在Kotlin中，lambda可以包含多个语句，这使得它们比Python的单表达式lambda &lt;a href=&quot;functional-programming#receivers&quot;&gt;更为&lt;/a&gt;有用。最后一条语句必须是一个表达式，其结果将成为lambda的返回值（除非 &lt;code&gt;Unit&lt;/code&gt; 是为lambda表达式指定的变量/参数的返回类型，在这种情况下，lambda没有返回值）。Lambda表达式用花​​括号括起来，并从列出其参数名称以及可能的类型开始（除非可以从上下文中推断类型）：</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">和数字一样,当需要可空引用时,字符会被装箱。框选操作不保留身份。</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">同样，如果以实验性&lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle元数据发布模式&lt;/a&gt;发布多平台库，并且该项目也设置为使用元数据，则对于公共源集仅指定一次依赖项就足够了。否则，除了公共模块外，每个平台特定的源集还应提供库的相应平台模块，如上所示。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">线性搜索</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">将库链接到应用程序中</target>
        </trans-unit>
        <trans-unit id="51115a9035c7b2d5f77a89ba3f71882db009bed6" translate="yes" xml:space="preserve">
          <source>Link with the library. To learn about using libraries in Kotlin/native projects, see &lt;a href=&quot;native/libraries&quot;&gt;Kotlin/Native libraries&lt;/a&gt;.</source>
          <target state="translated">与库链接。要了解有关在Kotlin / native项目中使用库的信息，请参阅&lt;a href=&quot;native/libraries&quot;&gt;Kotlin / Native库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">链接到元素</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64,arm32,MIPS,MIPS little endian,Raspberry Pi)</target>
        </trans-unit>
        <trans-unit id="c8306ed1ec95ef01523eab6c3a95dbeb9f6511fb" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</source>
          <target state="translated">Linux (x86_64,arm32,arm64,MIPS,MIPS little endian)</target>
        </trans-unit>
        <trans-unit id="967dea98ac299ce02d355a430918fd09ccd9ae77" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host.</source>
          <target state="translated">Linux MIPS目标（ &lt;code&gt;linuxMips32&lt;/code&gt; 和 &lt;code&gt;linuxMipsel32&lt;/code&gt; ）需要Linux主机。</target>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Linux MIPS目标（ &lt;code&gt;linuxMips32&lt;/code&gt; 和 &lt;code&gt;linuxMipsel32&lt;/code&gt; ）需要Linux主机。可以在任何受支持的主机上构建其他Linux目标。</target>
        </trans-unit>
        <trans-unit id="11304ba6aa97ab18544ed05fda48e987cfe71d39" translate="yes" xml:space="preserve">
          <source>Linux on ARM64 platforms, for example, Raspberry Pi</source>
          <target state="translated">ARM64平台上的Linux,例如Raspberry Pi。</target>
        </trans-unit>
        <trans-unit id="013bd415b99b4bdfce6cddaafa69bba3220fa741" translate="yes" xml:space="preserve">
          <source>Linux on MIPS platforms</source>
          <target state="translated">MIPS平台上的Linux</target>
        </trans-unit>
        <trans-unit id="94ff9f10883bcb28fb147e475a8a0df8cd56c6a9" translate="yes" xml:space="preserve">
          <source>Linux on hard-float ARM (ARM32) platforms</source>
          <target state="translated">硬浮动ARM(ARM32)平台上的Linux。</target>
        </trans-unit>
        <trans-unit id="0c99b7625097db16217dc289034a1cae4cfdd98e" translate="yes" xml:space="preserve">
          <source>Linux on little-endian MIPS (mipsel) platforms</source>
          <target state="translated">Linux在小迭代MIPS(mipsel)平台上的应用。</target>
        </trans-unit>
        <trans-unit id="d6493240830afc488468d930ec91963f82322598" translate="yes" xml:space="preserve">
          <source>Linux on x86_64 platforms</source>
          <target state="translated">x86_64平台的Linux</target>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux： &lt;code&gt;libnative_api.h&lt;/code&gt; 和 &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">列出具体操作</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">列表元素（包括null）可以重复：列表可以包含任意数量的相等对象或单个对象的出现。如果两个列表的大小相同且元素在相同位置上的&lt;a href=&quot;equality#structural-equality&quot;&gt;结构相同，&lt;/a&gt;则认为两个列表相等。</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">列表迭代器</target>
        </trans-unit>
        <trans-unit id="b7bfa71d045baf9d165ce17f80e019c5294d5073" translate="yes" xml:space="preserve">
          <source>List the available hardware targets.</source>
          <target state="translated">列出可用的硬件目标。</target>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">列表写操作</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">列表还提供了替换给定位置的元素的功能-set &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt;及其操作符形式 &lt;code&gt;[]&lt;/code&gt; 。 &lt;code&gt;set()&lt;/code&gt; 不会更改其他元素的索引。</target>
        </trans-unit>
        <trans-unit id="d5a0dae9f70ca77cfff82765784d806c80043676" translate="yes" xml:space="preserve">
          <source>Lists and maps also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">列表和映射还提供了用于更新元素的操作。它们在&lt;a href=&quot;list-operations&quot;&gt;&amp;ldquo;特定&lt;/a&gt;于列表的操作&amp;rdquo;和&amp;ldquo;&lt;a href=&quot;map-operations&quot;&gt;特定&lt;/a&gt;于映射的操作&amp;rdquo;中进行了描述。对于集合，更新没有意义，因为它实际上是在删除一个元素并添加另一个元素。</target>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">列表和集合还提供用于更新元素的操作。它们在&amp;ldquo; &lt;a href=&quot;list-operations&quot;&gt;列表特定操作&amp;rdquo;&lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;map-operations&quot;&gt;地图特定操作&amp;rdquo;中&lt;/a&gt;进行了描述。对于集合，更新是没有意义的，因为它实际上是在删除一个元素并添加另一个元素。</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">列表支持元素检索的所有常用操作： &lt;code&gt;elementAt()&lt;/code&gt; ， &lt;code&gt;first()&lt;/code&gt; ， &lt;code&gt;last()&lt;/code&gt; 以及&amp;ldquo; &lt;a href=&quot;collection-elements&quot;&gt;检索单个元素&amp;rdquo;中&lt;/a&gt;列出的其他操作。列表特有的是对元素的索引访问，因此读取元素的最简单方法是按索引检索它。这是通过使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;函数以及在参数或速记 &lt;code&gt;[index]&lt;/code&gt; 语法中传递的索引来完成的。</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">字面常数</target>
        </trans-unit>
        <trans-unit id="4da0019bff16f0b757af8c7d691632f05ab7ce73" translate="yes" xml:space="preserve">
          <source>Literal constants</source>
          <target state="translated">字面常数</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">本地委派属性(从1.1开始)。</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">本地功能</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">本地注释类</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">当地声明</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">本地委托属性</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">局部函数可以访问外部函数（即闭包）的局部变量，因此在上述情况下，被&lt;em&gt;访问对象&lt;/em&gt;可以是局部变量：</target>
        </trans-unit>
        <trans-unit id="c81d1a5213298e456992ce397aa51ab435e7f9b2" translate="yes" xml:space="preserve">
          <source>Local functions</source>
          <target state="translated">当地职能</target>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">本地变量</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">局部变量通常是在同一时间声明和初始化的，在这种情况下，可以将变量的类型&lt;em&gt;推断&lt;/em&gt;为您使用其初始化的表达式的类型：</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">局部变量、函数和类不能有可见性修饰符。</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="d42ac4c4f265835ce678f6a048de877eecd3678f" translate="yes" xml:space="preserve">
          <source>Location of Kotlin source files inside the source set directory.</source>
          <target state="translated">Kotlin源文件在源集目录内的位置。</target>
        </trans-unit>
        <trans-unit id="178313af6182f9b545c1f11580b0d5590fb118f3" translate="yes" xml:space="preserve">
          <source>Location of resources inside the source set directory.</source>
          <target state="translated">源集目录内资源的位置。</target>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">锁用于确保只有一个线程可以初始化&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">对数： &lt;code&gt;log&lt;/code&gt; ， &lt;code&gt;log2&lt;/code&gt; ， &lt;code&gt;log10&lt;/code&gt; ， &lt;code&gt;ln&lt;/code&gt; ， &lt;code&gt;ln1p&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">徽标可以在&lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;此处&lt;/a&gt;下载。使用徽标时，请遵循存档中的 &lt;code&gt;guidelines.pdf&lt;/code&gt; 和&lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin品牌使用指南&lt;/a&gt;中的简单规则。</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">龙目岛（ &lt;code&gt;lombok.NonNull&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">多头以大写 &lt;code&gt;L&lt;/code&gt; 标记： &lt;code&gt;123L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">寻找更多API？创建一个&lt;a href=&quot;../multiplatform-library&quot;&gt;多平台库&lt;/a&gt;并共享它很容易！</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">查找具有 &lt;code&gt;operator&lt;/code&gt; 修饰符且没有参数的函数 &lt;code&gt;inc()&lt;/code&gt; ，适用于 &lt;code&gt;T&lt;/code&gt; 类型的接收器；</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">&lt;code&gt;unaryPlus()&lt;/code&gt; 带有 &lt;code&gt;operator&lt;/code&gt; 修饰符且没有用于接收方 &lt;code&gt;T&lt;/code&gt; 的参数的函数unaryPlus（），即成员函数或扩展函数；</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">循环的范围</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">提供基于coroutine的API的库的低级构件。</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">幸运的是，Kotlin得到了改进的&lt;em&gt;类型参数&lt;/em&gt;，从而减轻了其中的一些问题。通过在通用类型参数前面编写 &lt;code&gt;reified&lt;/code&gt; ，它在运行时确实可以使用，您将可以编写 &lt;code&gt;T::class&lt;/code&gt; 来获取&lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;类元数据&lt;/a&gt;。你只能做到这一点的内联函数（因为inline函数会被编译成它的调用点，其中类型信息&lt;em&gt;是&lt;/em&gt;可以在运行时），但它仍然很长的路要走。例如，您可以为具有不太雅致的签名的大型函数制作一个内联包装函数。</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="784a46c14fea9ff3fb4d5c790913e2db7292c56e" translate="yes" xml:space="preserve">
          <source>MICROSECONDS</source>
          <target state="translated">MICROSECONDS</target>
        </trans-unit>
        <trans-unit id="370c3ba851aaa71b93e5d791ecaddbf60722fede" translate="yes" xml:space="preserve">
          <source>MILLISECONDS</source>
          <target state="translated">MILLISECONDS</target>
        </trans-unit>
        <trans-unit id="9c200cc936c861cebaa3fc9dbe92407a4a2f6d99" translate="yes" xml:space="preserve">
          <source>MINUTES</source>
          <target state="translated">MINUTES</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">MacOS (x86_64)</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="9c574760a1e8c967bc35e78752b8950efd331477" translate="yes" xml:space="preserve">
          <source>Make frameworks static when using rebuild from bitcode</source>
          <target state="translated">当使用从比特码重建时,使框架静态化。</target>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">确保其返回类型为 &lt;code&gt;Unit&lt;/code&gt; ，否则报告错误，</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">确保已&lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;安装&lt;/a&gt; CocoaPods 。我们建议使用CocoaPods 1.6.1或更高版本。</target>
        </trans-unit>
        <trans-unit id="4666c5046e05de3ced6688314c5b8b2fdc5e809d" translate="yes" xml:space="preserve">
          <source>Make sure that you import the &lt;code&gt;react.dom.*&lt;/code&gt; and &lt;code&gt;styled.*&lt;/code&gt; packages.</source>
          <target state="translated">确保您导入 &lt;code&gt;react.dom.*&lt;/code&gt; 和style &lt;code&gt;styled.*&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="c46d38a6352744d726ba87d5e2a3fe0550a5b018" translate="yes" xml:space="preserve">
          <source>Make sure that you import the package &lt;code&gt;kotlinx.html.js.*&lt;/code&gt;.</source>
          <target state="translated">确保导入包 &lt;code&gt;kotlinx.html.js.*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">确保首先加载 &lt;code&gt;kotlin.js&lt;/code&gt; 运行时，然后加载您的应用程序。</target>
        </trans-unit>
        <trans-unit id="5aa48b84880f06c505b8b4e3340f284931cef8e6" translate="yes" xml:space="preserve">
          <source>Make sure that your declared annotation has a proper annotation target (Java&amp;rsquo;s &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; or Kotlin&amp;rsquo;s &lt;code&gt;AnnotationTarget.TYPE&lt;/code&gt;) and retention (&lt;code&gt;AnnotationRetention.RUNTIME&lt;/code&gt;).</source>
          <target state="translated">确保声明的注释具有正确的注释目标（Java的 &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; 或Kotlin的 &lt;code&gt;AnnotationTarget.TYPE&lt;/code&gt; ）和保留对象（ &lt;code&gt;AnnotationRetention.RUNTIME&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">让用户舒适地更新到新版本。</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">使得Objective-C类中的Kotlin方法可以通过Objective-C dispatch访问,作为UIKit或AppKit中的控件发送的动作使用。</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">使得Objective-C类中的Kotlin属性可以通过Objective-C dispatch来设置,作为IB出口使用。</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">在调用Kotlin &lt;code&gt;main&lt;/code&gt; 函数后，使Objective-C类的Kotlin子类可见，以便在运行时查找。</target>
        </trans-unit>
        <trans-unit id="f35a32ffaf96633b14ae608748f888d188401daf" translate="yes" xml:space="preserve">
          <source>Makes call to the specified &lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt; function putting the call activation frame on the heap, as opposed to the actual call stack that is used by a regular call.</source>
          <target state="translated">调用指定的&lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt;函数，将调用激活帧放置在堆上，而不是常规调用使用的实际调用堆栈。</target>
        </trans-unit>
        <trans-unit id="380302710c7a9c26b7742a1058f704b9bb0ef0a3" translate="yes" xml:space="preserve">
          <source>Makes recursive call to this &lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt; function putting the call activation frame on the heap, as opposed to the actual call stack that is used by a regular recursive call.</source>
          <target state="translated">对此&lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt;函数进行递归调用，将调用激活帧放在堆上，而不是常规递归调用使用的实际调用堆栈。</target>
        </trans-unit>
        <trans-unit id="34b5071a9847a34a44b37d8ab94597a0b604b867" translate="yes" xml:space="preserve">
          <source>Makes the annotated annotation class an associated object key.</source>
          <target state="translated">使注解的注解类成为关联的对象键。</target>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">使得C/C++代码中给定名称的顶级函数可用。</target>
        </trans-unit>
        <trans-unit id="33733bb607beb4f5ed38e06a91a784c426296320" translate="yes" xml:space="preserve">
          <source>Making busy flow cancellable</source>
          <target state="translated">使繁忙的流量可以取消</target>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">使计算代码可以取消</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">频繁地进行null检查是很烦人的,所以如果你必须允许null的可能性,Kotlin中有几个非常有用的操作符来方便处理可能是null的值,如下所述。</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">格式不正确的字节序列由替换char &lt;code&gt;\uFFFD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">管理依赖性</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">管理来源</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">管理目标</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">手动配置</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">手动安装</target>
        </trans-unit>
        <trans-unit id="4892a25af3b45967112eda593c6c4ff560c25b52" translate="yes" xml:space="preserve">
          <source>Manually apply an Android Gradle plugin &amp;ndash; &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt;.</source>
          <target state="translated">手动应用Android Gradle插件&amp;ndash; &lt;code&gt;com.android.application&lt;/code&gt; 或 &lt;code&gt;com.android.library&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a6d42d1875648e1f154683fe273a941e93a43bb" translate="yes" xml:space="preserve">
          <source>Manually generating external declarations via Gradle task</source>
          <target state="translated">通过Gradle任务手动生成外部声明。</target>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">许多现代IDE都支持Kotlin,并帮助编写习惯性的Kotlin代码。</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">许多选项也可以通过属性进行配置。</target>
        </trans-unit>
        <trans-unit id="e10c89b0b0ca5be3c7b04daef4c60db7fc1b6f90" translate="yes" xml:space="preserve">
          <source>Many people already use &lt;a href=&quot;coroutines/coroutines-guide&quot;&gt;coroutines&lt;/a&gt; for asynchronous programming. But when it came to debugging, working with coroutines before Kotlin 1.4, could be a real pain. Since coroutines jumped between threads, it was difficult to understand what a specific coroutine was doing and check its context. In some cases, tracking steps over breakpoints simply didn&amp;rsquo;t work. As a result, you had to rely on logging or mental effort to debug code that used coroutines.</source>
          <target state="translated">许多人已经使用&lt;a href=&quot;coroutines/coroutines-guide&quot;&gt;协程&lt;/a&gt;进行异步编程。但是，当涉及调试时，在Kotlin 1.4之前使用协程可能是一个真正的痛苦。由于协程在线程之间跳转，因此很难了解特定协程在做什么并检查其上下文。在某些情况下，跟踪断点上的步骤根本行不通。结果，您必须依靠日志记录或精力来调试使用协程的代码。</target>
        </trans-unit>
        <trans-unit id="fe81b734a40201fad1b163bd75e5e8866ba447fc" translate="yes" xml:space="preserve">
          <source>Many startups and Fortune 500 companies have already developed Android applications using Kotlin &amp;ndash; see the list at &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;the Google website for Kotlin developers&lt;/a&gt;.</source>
          <target state="translated">许多创业公司和《财富》 500强公司已经使用Kotlin开发了Android应用程序-&lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;有关Kotlin开发人员的信息，&lt;/a&gt;请参阅Google网站上的列表。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">地图具体操作</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">如果不是空值,则映射空值</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">地图写入操作</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap()和Map.toMutableMap()</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">映射类型</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">从C语言映射函数指针类型</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">从C语言映射函数指针</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">从C语言映射原始数据类型</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">从C语言映射字符串</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">映射结构和联盟C类型</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">从C语言映射结构和联合类型</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">标记接口，指示&lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;实现支持快速索引访问。</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">标记接口，指示&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;实现支持快速索引访问。</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">标记API元素</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">标记实验性API</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">标记规则:如果一个隐含的接收器被认为是用@Ann标记的,如果</target>
        </trans-unit>
        <trans-unit id="86bad6d0089ea3bb1c0a2e322f9709163fa38969" translate="yes" xml:space="preserve">
          <source>Marks a point in time on this time source.</source>
          <target state="translated">标志着这个时间源上的一个时间点。</target>
        </trans-unit>
        <trans-unit id="d4db1b9cfb765a0420560d33f4c49a590513a4d0" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field as immutable. It is possible to share the value of such property between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">将一个带有支持字段的顶层属性标记为不可更改。可以在多个线程之间共享这种属性的值,但它会被深度冻结,所以不能改变它的状态或它所引用的对象的状态。</target>
        </trans-unit>
        <trans-unit id="a224cc22214be0edab83e29fa79b9dd2dd10f50f" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">将一个带有支持字段的顶层属性或对象标记为线程本地。该对象仍然是可变的,并且可以改变它的状态,但每个线程都有一个不同的对象副本,所以一个线程的变化不会反映在另一个线程中。</target>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">将一个带有支持字段的顶层变量或对象标记为不可更改。可以在多个线程之间共享这样的对象,但它会被深度冻结,所以不能改变它的状态或它所引用的对象的状态。</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">将一个带有支持字段的顶层变量或对象标记为线程本地。该对象仍然是可变的,并且可以改变它的状态,但是每个线程都有一个不同的对象副本,所以一个线程的变化不会反映在另一个线程中。</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">标志着一个预期的注解类,它不需要在所有的平台上都有实际的对应物。</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">标记拦截协程连续的协程上下文元素。协程框架使用&lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;来检索拦截器，并使用&lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;调用来拦截所有协程连续。</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">标记拦截协程连续的协程上下文元素。协程框架使用&lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;来检索拦截器，并使用&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;调用来拦截所有协程连续。</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">标记拦截协程连续的协程上下文元素。协程框架使用&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;来检索拦截器，并使用&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;调用来拦截所有协程连续。</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">标记拦截协程连续的协程上下文元素。协程框架使用&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;来检索拦截器，并使用&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;调用来拦截所有协程连续。</target>
        </trans-unit>
        <trans-unit id="e74d580f7febe5c2f5fce47ebee5f4b2a5e537e3" translate="yes" xml:space="preserve">
          <source>Marks experimental JS export annotations.</source>
          <target state="translated">标记实验性的JS导出注释。</target>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">标志着依赖于实验性无符号类型的API,包括这些类型本身。</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">将带注释的属性的JVM支持字段标记为 &lt;code&gt;transient&lt;/code&gt; ，这意味着它不是对象的默认序列化形式的一部分。</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">将带注释的属性的JVM支持字段标记为 &lt;code&gt;volatile&lt;/code&gt; ，这意味着对该字段的写入将立即变为对其他线程可见。</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">将从带注释的函数生成的JVM方法标记为 &lt;code&gt;strictfp&lt;/code&gt; ，这意味着需要限制在该方法内部执行的浮点操作的精度，以实现更好的可移植性。</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">将从带注释的函数生成的JVM方法标记为 &lt;code&gt;synchronized&lt;/code&gt; ，这意味着将通过定义该方法的实例（对于静态方法，为类）的监视器来防止该方法被多个线程并发执行。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
