<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="4c32ac23bf57e6bef05946a26b1a0eabf8256266" translate="yes" xml:space="preserve">
          <source>Select expression (experimental)</source>
          <target state="translated">选择表达方式(实验)</target>
        </trans-unit>
        <trans-unit id="48956f92abeebca2ff71b62a0891686768c01f08" translate="yes" xml:space="preserve">
          <source>Select expression has &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/on-send.html&quot;&gt;onSend&lt;/a&gt; clause that can be used for a great good in combination with a biased nature of selection.</source>
          <target state="translated">Select表达式具有&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/on-send.html&quot;&gt;onSend&lt;/a&gt;子句，可以与选择的偏向性质结合使用，以达到极大的效果。</target>
        </trans-unit>
        <trans-unit id="b520be71b3c104ce563b6c593fde42be010adf49" translate="yes" xml:space="preserve">
          <source>Select expression makes it possible to await multiple suspending functions simultaneously and &lt;em&gt;select&lt;/em&gt; the first one that becomes available.</source>
          <target state="translated">通过选择表达式，可以同时等待多个挂起函数并&lt;em&gt;选择&lt;/em&gt;第一个可用的函数。</target>
        </trans-unit>
        <trans-unit id="8175e32b759e37e1a5d84ee3e91065f0c422b7eb" translate="yes" xml:space="preserve">
          <source>Select expressions are an experimental feature of &lt;code&gt;kotlinx.coroutines&lt;/code&gt;. Their API is expected to evolve in the upcoming updates of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library with potentially breaking changes.</source>
          <target state="translated">选择表达式是 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 的实验功能。他们的API预计会在 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 库的即将进行的更新中发展，并且可能会有重大更改。</target>
        </trans-unit>
        <trans-unit id="42302b9a2abf4e35a9075aa892e7301f57141bf5" translate="yes" xml:space="preserve">
          <source>Selected documentation pages:</source>
          <target state="translated">部分文件页:</target>
        </trans-unit>
        <trans-unit id="02edbb0885c1f54bd5c812f1f6c21dd73b7b7752" translate="yes" xml:space="preserve">
          <source>Selecting deferred values</source>
          <target state="translated">选择递延值</target>
        </trans-unit>
        <trans-unit id="47d00ff46b20191dc1fea60073556feeb9737b6b" translate="yes" xml:space="preserve">
          <source>Selecting from channels</source>
          <target state="translated">从频道中选择</target>
        </trans-unit>
        <trans-unit id="aab3b9d16e09699ff2d802b15b20b5ecc4f06393" translate="yes" xml:space="preserve">
          <source>Selecting library headers</source>
          <target state="translated">选择库头</target>
        </trans-unit>
        <trans-unit id="fe050710fc31fb212b9d58e03ffb5ddf9227ff92" translate="yes" xml:space="preserve">
          <source>Selecting on close</source>
          <target state="translated">关闭时选择</target>
        </trans-unit>
        <trans-unit id="c21c0093c98c3f86a84809d41128aa9f9d516de1" translate="yes" xml:space="preserve">
          <source>Selecting to send</source>
          <target state="translated">选择发送</target>
        </trans-unit>
        <trans-unit id="c5d699ecb491cd74b07cd5d34e15b6457dcd4d77" translate="yes" xml:space="preserve">
          <source>SelectionMode</source>
          <target state="translated">SelectionMode</target>
        </trans-unit>
        <trans-unit id="e224d8a043bad355e811a889ebdd19946f0af63a" translate="yes" xml:space="preserve">
          <source>Self-contained Jar file</source>
          <target state="translated">自带的 Jar 文件</target>
        </trans-unit>
        <trans-unit id="deaa9959eee189b886b9fe0c02af7f02ee90f04a" translate="yes" xml:space="preserve">
          <source>Semantic difference between object expressions and declarations</source>
          <target state="translated">对象表达式和声明之间的语义区别</target>
        </trans-unit>
        <trans-unit id="1158dc6391ca1c282b0274da233e5b47974ab44c" translate="yes" xml:space="preserve">
          <source>Semicolons</source>
          <target state="translated">Semicolons</target>
        </trans-unit>
        <trans-unit id="5782c9162c716def6df9bf7e94748ad8c4334b5a" translate="yes" xml:space="preserve">
          <source>Send and receive operations to channels are &lt;em&gt;fair&lt;/em&gt; with respect to the order of their invocation from multiple coroutines. They are served in first-in first-out order, e.g. the first coroutine to invoke &lt;code&gt;receive&lt;/code&gt; gets the element. In the following example two coroutines &quot;ping&quot; and &quot;pong&quot; are receiving the &quot;ball&quot; object from the shared &quot;table&quot; channel.</source>
          <target state="translated">就从多个协程调用它们的顺序而言，对通道的发送和接收操作是&lt;em&gt;公平的&lt;/em&gt;。它们以先进先出的顺序提供，例如，调用 &lt;code&gt;receive&lt;/code&gt; 的第一个协程获取元素。在下面的示例中，两个协程&amp;ldquo; ping&amp;rdquo;和&amp;ldquo; pong&amp;rdquo;从共享的&amp;ldquo; table&amp;rdquo;通道接收&amp;ldquo; ball&amp;rdquo;对象。</target>
        </trans-unit>
        <trans-unit id="e54a83f10e5af4bee27d8c0ebfe4ed0592366f8d" translate="yes" xml:space="preserve">
          <source>Separate interfaces for read-only and mutable collections</source>
          <target state="translated">为只读和可更改的集合提供单独的接口。</target>
        </trans-unit>
        <trans-unit id="5c8f4e0e1a2281faf562976c2410f76c3d8fbc95" translate="yes" xml:space="preserve">
          <source>Sequence</source>
          <target state="translated">Sequence</target>
        </trans-unit>
        <trans-unit id="e5883c1a54bb1e68289417fbad3062b1a700027a" translate="yes" xml:space="preserve">
          <source>Sequence operations</source>
          <target state="translated">顺序操作</target>
        </trans-unit>
        <trans-unit id="c48d275d17f30d5b803ff437ae7b3ef803c29872" translate="yes" xml:space="preserve">
          <source>Sequence operations, like &lt;a href=&quot;../map&quot;&gt;Sequence.map&lt;/a&gt;, &lt;a href=&quot;../filter&quot;&gt;Sequence.filter&lt;/a&gt; etc, generally preserve that property of a sequence, and again it's documented for an operation if it doesn't.</source>
          <target state="translated">序列操作（例如&lt;a href=&quot;../map&quot;&gt;Sequence.map&lt;/a&gt;，&lt;a href=&quot;../filter&quot;&gt;Sequence.filter&lt;/a&gt;等）通常会保留序列的该属性，如果没有，则再次记录该序列的操作。</target>
        </trans-unit>
        <trans-unit id="64e6557fa694e5bc4d5214113f8e64a03eff042b" translate="yes" xml:space="preserve">
          <source>Sequence processing example</source>
          <target state="translated">序列处理示例</target>
        </trans-unit>
        <trans-unit id="17d31f0a79810867402ac04dc581a512a3e7b8e1" translate="yes" xml:space="preserve">
          <source>Sequence.groupingBy</source>
          <target state="translated">Sequence.groupingBy</target>
        </trans-unit>
        <trans-unit id="01f90824cbb43798e728c150fb0e61a7bc14e304" translate="yes" xml:space="preserve">
          <source>SequenceBuilder</source>
          <target state="translated">SequenceBuilder</target>
        </trans-unit>
        <trans-unit id="1ba425c731fb567f4a419699f797f9b17fbee2da" translate="yes" xml:space="preserve">
          <source>SequenceScope</source>
          <target state="translated">SequenceScope</target>
        </trans-unit>
        <trans-unit id="b5fb636023abb67d347041d398442118f79ea091" translate="yes" xml:space="preserve">
          <source>Sequences</source>
          <target state="translated">Sequences</target>
        </trans-unit>
        <trans-unit id="dd81a16031599be93f6dd81ca5d6238d53a6744e" translate="yes" xml:space="preserve">
          <source>Sequences can be iterated multiple times, however some sequence implementations might constrain themselves to be iterated only once. That is mentioned specifically in their documentation (e.g. &lt;a href=&quot;../generate-sequence&quot;&gt;generateSequence&lt;/a&gt; overload). The latter sequences throw an exception on an attempt to iterate them the second time.</source>
          <target state="translated">序列可以被迭代多次，但是某些序列实现可能会约束自己仅被迭代一次。他们的文档中特别提到了这一点（例如，&lt;a href=&quot;../generate-sequence&quot;&gt;generateSequence&lt;/a&gt;重载）。后面的序列在尝试第二次迭代时抛出异常。</target>
        </trans-unit>
        <trans-unit id="324bddccf0babf837f3e319e5e20b79516c0238f" translate="yes" xml:space="preserve">
          <source>Sequences can be iterated multiple times, however some sequence implementations might constrain themselves to be iterated only once. That is mentioned specifically in their documentation (e.g. &lt;a href=&quot;generate-sequence&quot;&gt;kotlin.sequences.generateSequence&lt;/a&gt; overload). The latter sequences throw an exception on an attempt to iterate them the second time.</source>
          <target state="translated">序列可以被迭代多次，但是某些序列实现可能会约束自己仅被迭代一次。他们的文档中特别提到了这一点（例如&lt;a href=&quot;generate-sequence&quot;&gt;kotlin.sequences.generateSequence&lt;/a&gt;重载）。后面的序列在尝试第二次迭代时抛出异常。</target>
        </trans-unit>
        <trans-unit id="7d6e9c12f8fb2b461fa680aec22b49a6b437317d" translate="yes" xml:space="preserve">
          <source>Sequences can be iterated multiple times; however some sequence implementations might constrain themselves to be iterated only once. That is mentioned specifically in their documentation.</source>
          <target state="translated">序列可以被多次迭代;但是一些序列实现可能会限制自己只被迭代一次。这在他们的文档中特别提到。</target>
        </trans-unit>
        <trans-unit id="633b854023bf60ecd3352dd58f1b60cddc507889" translate="yes" xml:space="preserve">
          <source>Sequential by default</source>
          <target state="translated">默认为顺序式</target>
        </trans-unit>
        <trans-unit id="89282363da677473acdbf45f0831bde9f4d3b6c4" translate="yes" xml:space="preserve">
          <source>Serialization</source>
          <target state="translated">Serialization</target>
        </trans-unit>
        <trans-unit id="f1f612371c661be3166a24f9dc10446222583cd3" translate="yes" xml:space="preserve">
          <source>Serialization plugin</source>
          <target state="translated">序列化插件</target>
        </trans-unit>
        <trans-unit id="8271ef44e36a997c2ae658d1924bd9cf6db40226" translate="yes" xml:space="preserve">
          <source>ServiceWorkerMessageEventInit</source>
          <target state="translated">ServiceWorkerMessageEventInit</target>
        </trans-unit>
        <trans-unit id="4413f0ab2dcf4624fe4b65b9e4d2332c78716f39" translate="yes" xml:space="preserve">
          <source>ServiceWorkerState</source>
          <target state="translated">ServiceWorkerState</target>
        </trans-unit>
        <trans-unit id="448ab73ba1c21e671e218fb91f2644c834f0c16f" translate="yes" xml:space="preserve">
          <source>Set</source>
          <target state="translated">Set</target>
        </trans-unit>
        <trans-unit id="40113801b18ce319e5c44850e1e658e055ba2004" translate="yes" xml:space="preserve">
          <source>Set Specific Operations</source>
          <target state="translated">设置具体操作</target>
        </trans-unit>
        <trans-unit id="43fa638b38fa3057dbf85563525061705d9f06b0" translate="yes" xml:space="preserve">
          <source>Set a callback &lt;a href=&quot;on-fail#kotlin.io.FileTreeWalk%24onFail%28kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.Unit%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt;, that is called on a directory when it's impossible to get its file list.</source>
          <target state="translated">设置一个回调&lt;a href=&quot;on-fail#kotlin.io.FileTreeWalk%24onFail%28kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.Unit%29%29%29%2Ffunction&quot;&gt;函数&lt;/a&gt;，在无法获取其文件列表时在目录上调用该函数。</target>
        </trans-unit>
        <trans-unit id="b061e7ff7dc8605bd1d5a2dec3d93d192c52d826" translate="yes" xml:space="preserve">
          <source>Set the bit specified to the specified value.</source>
          <target state="translated">设置指定的位到指定的值。</target>
        </trans-unit>
        <trans-unit id="38b610e97dc4a86ed3152f5aad53acad8003c57f" translate="yes" xml:space="preserve">
          <source>Set up an IDE</source>
          <target state="translated">设置一个IDE</target>
        </trans-unit>
        <trans-unit id="9090f4dac9398caea18d500c177ae5d9eaaf87eb" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-char/index#kotlin.Char&quot;&gt;Char&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-char-at#kotlin.native%24setCharAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;../-char/index#kotlin.Char&quot;&gt;Char&lt;/a&gt;设置为指定索引&lt;a href=&quot;../../kotlin.native/set-char-at#kotlin.native%24setCharAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区</target>
        </trans-unit>
        <trans-unit id="edcc200bc12273c6272fafd06f2a5c60428e5419" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-double-at#kotlin.native%24setDoubleAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">在指定索引&lt;a href=&quot;../../kotlin.native/set-double-at#kotlin.native%24setDoubleAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt;的&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中设置&lt;a href=&quot;../-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da515a45bf6a7b48f76d31bfdfc07e81c5e5b397" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-float-at#kotlin.native%24setFloatAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;../-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt;设置为在指定索引&lt;a href=&quot;../../kotlin.native/set-float-at#kotlin.native%24setFloatAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区之外</target>
        </trans-unit>
        <trans-unit id="6243aa097ace2f119715a9e02308e904fd46fa09" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-int-at#kotlin.native%24setIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">在指定索引&lt;a href=&quot;../../kotlin.native/set-int-at#kotlin.native%24setIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt;的&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中设置&lt;a href=&quot;../-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e9fead8a733ff6e2f7c6229ab156b0be3c7aad8" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-long-at#kotlin.native%24setLongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中的&lt;a href=&quot;../-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt;设置为指定索引&lt;a href=&quot;../../kotlin.native/set-long-at#kotlin.native%24setLongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd6198304f168018790866f8d5de90bd850068be" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-short-at#kotlin.native%24setShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中的&lt;a href=&quot;../-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt;设置为指定索引&lt;a href=&quot;../../kotlin.native/set-short-at#kotlin.native%24setShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="043a131ab8bde8809b5efb8cc71bececd6f0b920" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-char/index#kotlin.Char&quot;&gt;Char&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-char-at#kotlin.native%24setCharAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;../kotlin/-char/index#kotlin.Char&quot;&gt;Char&lt;/a&gt;设置为指定索引&lt;a href=&quot;set-char-at#kotlin.native%24setCharAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区</target>
        </trans-unit>
        <trans-unit id="165ab1c79e9f7280a7ff5a7178cd42f19ee49e12" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-double-at#kotlin.native%24setDoubleAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">在指定索引&lt;a href=&quot;set-double-at#kotlin.native%24setDoubleAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt;的&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中设置&lt;a href=&quot;../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="66b277295ea869aa45f112638839d6a36ddd88a7" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-float-at#kotlin.native%24setFloatAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;../kotlin/-float/index#kotlin.Float&quot;&gt;Float&lt;/a&gt;设置为在指定索引&lt;a href=&quot;set-float-at#kotlin.native%24setFloatAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区之外</target>
        </trans-unit>
        <trans-unit id="eeddfac7038244af25d78ade965c0d83befca8e5" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-int-at#kotlin.native%24setIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">在指定索引&lt;a href=&quot;set-int-at#kotlin.native%24setIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt;的&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中设置&lt;a href=&quot;../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a5595b9f2b46318a666585b89bac1d7a504ef30" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-long-at#kotlin.native%24setLongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中的&lt;a href=&quot;../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt;设置为指定索引&lt;a href=&quot;set-long-at#kotlin.native%24setLongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61468958fc1d048054f7da161eb41f9a095e74ff" translate="yes" xml:space="preserve">
          <source>Sets &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-short-at#kotlin.native%24setShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中的&lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt;设置为指定索引&lt;a href=&quot;set-short-at#kotlin.native%24setShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1af430d4c7c33f49b906ac16225b3535913e1cd" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;ACC_SYNTHETIC&lt;/code&gt; flag on the annotated target in the Java bytecode.</source>
          <target state="translated">在Java字节码中带注释的目标上设置 &lt;code&gt;ACC_SYNTHETIC&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="d34e821a8392e5cf541ba4b173e3093815cd886a" translate="yes" xml:space="preserve">
          <source>Sets UByte out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-u-byte-at#kotlin.native%24setUByteAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将UByte设置为指定索引&lt;a href=&quot;set-u-byte-at#kotlin.native%24setUByteAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区</target>
        </trans-unit>
        <trans-unit id="4a5da7cc264882bdd0383657b09985b2b48c35af" translate="yes" xml:space="preserve">
          <source>Sets UByte out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-u-byte-at#kotlin.native%24setUByteAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将UByte设置为指定索引&lt;a href=&quot;../../kotlin.native/set-u-byte-at#kotlin.native%24setUByteAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区</target>
        </trans-unit>
        <trans-unit id="5752ba22649c586941889dd2a62fae9914f91863" translate="yes" xml:space="preserve">
          <source>Sets UInt out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-u-int-at#kotlin.native%24setUIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将UInt设置为指定索引&lt;a href=&quot;set-u-int-at#kotlin.native%24setUIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区</target>
        </trans-unit>
        <trans-unit id="3cdc755ff5323ee1cc48907c601573c3854d5185" translate="yes" xml:space="preserve">
          <source>Sets UInt out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-u-int-at#kotlin.native%24setUIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将UInt设置为指定索引&lt;a href=&quot;../../kotlin.native/set-u-int-at#kotlin.native%24setUIntAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区</target>
        </trans-unit>
        <trans-unit id="75425820919865f6e0a6f27b614d44e86b6f6faf" translate="yes" xml:space="preserve">
          <source>Sets ULong out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-u-long-at#kotlin.native%24setULongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将ULong设置为指定索引&lt;a href=&quot;set-u-long-at#kotlin.native%24setULongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区</target>
        </trans-unit>
        <trans-unit id="bb90a94951e0937badd2c5a974e39954d8e1c0fa" translate="yes" xml:space="preserve">
          <source>Sets ULong out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-u-long-at#kotlin.native%24setULongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将ULong设置为指定索引&lt;a href=&quot;../../kotlin.native/set-u-long-at#kotlin.native%24setULongAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt;处的&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区</target>
        </trans-unit>
        <trans-unit id="7f67e637b58367e0b58957c4447941673cd92e71" translate="yes" xml:space="preserve">
          <source>Sets UShort out of the &lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;set-u-short-at#kotlin.native%24setUShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将UShort从指定索引&lt;a href=&quot;set-u-short-at#kotlin.native%24setUShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt;的&lt;a href=&quot;../kotlin/-byte-array/index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中移出</target>
        </trans-unit>
        <trans-unit id="728922f760b44c69e0b00d27282cd57c2b6e1fca" translate="yes" xml:space="preserve">
          <source>Sets UShort out of the &lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt; byte buffer at specified index &lt;a href=&quot;../../kotlin.native/set-u-short-at#kotlin.native%24setUShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt;</source>
          <target state="translated">将UShort从指定索引&lt;a href=&quot;../../kotlin.native/set-u-short-at#kotlin.native%24setUShortAt%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt;的&lt;a href=&quot;index#kotlin.ByteArray&quot;&gt;ByteArray&lt;/a&gt;字节缓冲区中移出</target>
        </trans-unit>
        <trans-unit id="2900fbda2209cd97da96efa3c37d34a717e8828a" translate="yes" xml:space="preserve">
          <source>Sets a callback &lt;a href=&quot;on-leave#kotlin.io.FileTreeWalk%24onLeave%28kotlin.Function1%28%28java.io.File%2C+kotlin.Unit%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt;, that is called on any left directory after its files are visited and after it is visited itself.</source>
          <target state="translated">设置一个回调&lt;a href=&quot;on-leave#kotlin.io.FileTreeWalk%24onLeave%28kotlin.Function1%28%28java.io.File%2C+kotlin.Unit%29%29%29%2Ffunction&quot;&gt;函数&lt;/a&gt;，该函数在访问其文件之后以及在其自身访问之后在任何左目录中调用。</target>
        </trans-unit>
        <trans-unit id="b4931c0365ff304a815c6963d0bd7edb11b7c94c" translate="yes" xml:space="preserve">
          <source>Sets a predicate &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt;, that is called on any entered directory before its files are visited and before it is visited itself.</source>
          <target state="translated">设置谓词&lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;函数&lt;/a&gt;，在访问任何文件及其自身之前，在任何输入的目录上都会调用它。</target>
        </trans-unit>
        <trans-unit id="307c3b08228d209c4b76f0067076574f4a4d01fe" translate="yes" xml:space="preserve">
          <source>Sets all bits in the BitSet to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将BitSet中的所有位设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18c1c389ab129422cb72a224859d0ea272965e3c" translate="yes" xml:space="preserve">
          <source>Sets the array element at the specified &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;index&lt;/a&gt; to the specified &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将指定&lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;索引&lt;/a&gt;处的数组元素设置为指定&lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="9d82a173af7eab575c81214cafeae19267b32c70" translate="yes" xml:space="preserve">
          <source>Sets the bits from the range specified to the specified value.</source>
          <target state="translated">将指定范围的位设置为指定的值。</target>
        </trans-unit>
        <trans-unit id="9899dc3d49007fa7979991a572ef97990d1ed640" translate="yes" xml:space="preserve">
          <source>Sets the bits with indices between &lt;a href=&quot;set#kotlin.native.BitSet%24set%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Ffrom&quot;&gt;from&lt;/a&gt; (inclusive) and &lt;a href=&quot;set#kotlin.native.BitSet%24set%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fto&quot;&gt;to&lt;/a&gt; (exclusive) to the specified value.</source>
          <target state="translated">将索引&lt;a href=&quot;set#kotlin.native.BitSet%24set%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Ffrom&quot;&gt;从&lt;/a&gt;（包含）&lt;a href=&quot;set#kotlin.native.BitSet%24set%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fto&quot;&gt;到&lt;/a&gt;（至）之间的位设置为指定值。</target>
        </trans-unit>
        <trans-unit id="29eedbac3d423a05f8d6c883690bdaab95095996" translate="yes" xml:space="preserve">
          <source>Sets the character at the specified &lt;a href=&quot;../set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; to the specified &lt;a href=&quot;../set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;value&lt;/a&gt;.</source>
          <target state="translated">将指定&lt;a href=&quot;../set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;索引&lt;/a&gt;处的字符设置为指定&lt;a href=&quot;../set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb0b8fa0b347b9b16fd63e06b5bd3a87260d83b6" translate="yes" xml:space="preserve">
          <source>Sets the character at the specified &lt;a href=&quot;set#kotlin.text%24set%28java.lang.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; to the specified &lt;a href=&quot;set#kotlin.text%24set%28java.lang.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;value&lt;/a&gt;.</source>
          <target state="translated">将指定&lt;a href=&quot;set#kotlin.text%24set%28java.lang.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;索引&lt;/a&gt;处的字符设置为指定&lt;a href=&quot;set#kotlin.text%24set%28java.lang.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80c69316a95fe7e772cb32ac7444e561620116af" translate="yes" xml:space="preserve">
          <source>Sets the character at the specified &lt;a href=&quot;set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; to the specified &lt;a href=&quot;set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;value&lt;/a&gt;.</source>
          <target state="translated">将指定&lt;a href=&quot;set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;索引&lt;/a&gt;处的字符设置为指定&lt;a href=&quot;set#kotlin.text%24set%28kotlin.text.StringBuilder%2C+kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="185823a70e02396c0095a3ef140632cd0481c79c" translate="yes" xml:space="preserve">
          <source>Sets the content of this file as &lt;a href=&quot;write-text#kotlin.io%24writeText%28java.io.File%2C+kotlin.String%2C+java.nio.charset.Charset%29%2Ftext&quot;&gt;text&lt;/a&gt; encoded using UTF-8 or specified &lt;a href=&quot;write-text#kotlin.io%24writeText%28java.io.File%2C+kotlin.String%2C+java.nio.charset.Charset%29%2Fcharset&quot;&gt;charset&lt;/a&gt;. If this file exists, it becomes overwritten.</source>
          <target state="translated">将此文件的内容设置为使用UTF-8或指定的&lt;a href=&quot;write-text#kotlin.io%24writeText%28java.io.File%2C+kotlin.String%2C+java.nio.charset.Charset%29%2Fcharset&quot;&gt;charset&lt;/a&gt;编码的&lt;a href=&quot;write-text#kotlin.io%24writeText%28java.io.File%2C+kotlin.String%2C+java.nio.charset.Charset%29%2Ftext&quot;&gt;文本&lt;/a&gt;。如果该文件存在，它将被覆盖。</target>
        </trans-unit>
        <trans-unit id="9941f1f77af3ee35fb2ffb4e3a7bcfed1b02697f" translate="yes" xml:space="preserve">
          <source>Sets the content of this file as an &lt;a href=&quot;write-bytes#kotlin.io%24writeBytes%28java.io.File%2C+kotlin.ByteArray%29%2Farray&quot;&gt;array&lt;/a&gt; of bytes. If this file already exists, it becomes overwritten.</source>
          <target state="translated">将此文件的内容设置为字节&lt;a href=&quot;write-bytes#kotlin.io%24writeBytes%28java.io.File%2C+kotlin.ByteArray%29%2Farray&quot;&gt;数组&lt;/a&gt;。如果该文件已经存在，它将被覆盖。</target>
        </trans-unit>
        <trans-unit id="77e69f5b00ef9d6b815b0ece296a85d9aa969669" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="4baf2dc9994143edc877b925018d335cd4836753" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="4f10456289ed125c34024c96a9f3fced96e1084a" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="9061b224d8142ce983f37941237124f97fb7de8c" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="ec29a002b4c8ae3cba11729f4f8d9d60c8ea931e" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="6e8d5814f499c6b4da621128bc725e00fe86459f" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="54f288bc8477e9a77bca52d3a82f8f513baf826b" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="bba404ae951c063d7104d314046303877f1e90e3" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="2276370231d8bc10f6cfe6b1e5980d4b15dde8de" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="242acce212e00f9853c222dc79085c2d4bf25a88" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="9c8d086faad98cba0d4d2474417843e8c2654c33" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="83d722d43b55121439e406624afd6b4f5e5e2bf2" translate="yes" xml:space="preserve">
          <source>Sets the element at the given &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt; to the given &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Fvalue&quot;&gt;value&lt;/a&gt;. This method can be called using the index operator.</source>
          <target state="translated">将给定&lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;索引&lt;/a&gt;处的元素设置为给定&lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Fvalue&quot;&gt;值&lt;/a&gt;。可以使用索引运算符调用此方法。</target>
        </trans-unit>
        <trans-unit id="cdbfa1a2b3fcbca7289df75f3d9da6a49af783aa" translate="yes" xml:space="preserve">
          <source>Sets the maximum &lt;a href=&quot;max-depth#kotlin.io.FileTreeWalk%24maxDepth%28kotlin.Int%29%2Fdepth&quot;&gt;depth&lt;/a&gt; of a directory tree to traverse. By default there is no limit.</source>
          <target state="translated">设置要遍历的目录树的最大&lt;a href=&quot;max-depth#kotlin.io.FileTreeWalk%24maxDepth%28kotlin.Int%29%2Fdepth&quot;&gt;深度&lt;/a&gt;。默认情况下没有限制。</target>
        </trans-unit>
        <trans-unit id="7f557c804ed296d322f4a5e5bfe00660a8f6e3a4" translate="yes" xml:space="preserve">
          <source>Sets the next value in the iteration, called from the &lt;a href=&quot;compute-next&quot;&gt;computeNext&lt;/a&gt; function</source>
          <target state="translated">设置迭代中的下一个值，从&lt;a href=&quot;compute-next&quot;&gt;computeNext&lt;/a&gt;函数调用</target>
        </trans-unit>
        <trans-unit id="4250580fbd524d1fd8d6ec08be759b582c4fb702" translate="yes" xml:space="preserve">
          <source>Sets the state to done so that the iteration terminates.</source>
          <target state="translated">将状态设置为 done,这样迭代就结束了。</target>
        </trans-unit>
        <trans-unit id="612c0835d62f2410d2f8de6e6d5fc77a9b31d932" translate="yes" xml:space="preserve">
          <source>Sets the value of the property for the given object.</source>
          <target state="translated">设置给定对象的属性值。</target>
        </trans-unit>
        <trans-unit id="9c35e499a0854cb5e1b033a2aea56399d4cfd894" translate="yes" xml:space="preserve">
          <source>Setter</source>
          <target state="translated">Setter</target>
        </trans-unit>
        <trans-unit id="da16c3cc3bfdcae6d86bd6879d30abd5784e4921" translate="yes" xml:space="preserve">
          <source>Setter of the property is a &lt;code&gt;set&lt;/code&gt; method declared alongside the property.</source>
          <target state="translated">属性的Setter是在属性旁边声明的 &lt;code&gt;set&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="795e6d53d5731fd7b921da0b1d365fac3636f285" translate="yes" xml:space="preserve">
          <source>Setters and getters</source>
          <target state="translated">设置器和获取器</target>
        </trans-unit>
        <trans-unit id="d099d87160d087f60ade9cb21fa5440ff2125280" translate="yes" xml:space="preserve">
          <source>Setting Up the Local Environment</source>
          <target state="translated">设置本地环境</target>
        </trans-unit>
        <trans-unit id="c44f26d2bfdb853b861ef2282603dadd2c943781" translate="yes" xml:space="preserve">
          <source>Setting this in a Gradle DSL:</source>
          <target state="translated">在Gradle DSL中设置这个。</target>
        </trans-unit>
        <trans-unit id="1d9561629ffffcf08f870d78c8cba9699aaf1728" translate="yes" xml:space="preserve">
          <source>Setting up Framework Dependency in Xcode</source>
          <target state="translated">在Xcode中设置框架依赖性</target>
        </trans-unit>
        <trans-unit id="601eff2654656e13db208f79616084dab833fb1f" translate="yes" xml:space="preserve">
          <source>Setting up Targets</source>
          <target state="translated">设置目标</target>
        </trans-unit>
        <trans-unit id="f27242b25e228df6b15975fcf5c1aed13839ea95" translate="yes" xml:space="preserve">
          <source>Setting up Xcode</source>
          <target state="translated">设置Xcode</target>
        </trans-unit>
        <trans-unit id="729b164a15e1528ee04709ca227eb8126e79e0e9" translate="yes" xml:space="preserve">
          <source>Setting up a Multiplatform Project</source>
          <target state="translated">建立一个多平台项目</target>
        </trans-unit>
        <trans-unit id="4b75b737e7019beac88da840b9c4fa621cc15e9b" translate="yes" xml:space="preserve">
          <source>Setting up a project</source>
          <target state="translated">建立一个项目</target>
        </trans-unit>
        <trans-unit id="dfe5b993bb5b873cf296bfd1dec95400d302bb2f" translate="yes" xml:space="preserve">
          <source>Setting up the environment</source>
          <target state="translated">设置环境</target>
        </trans-unit>
        <trans-unit id="c676a8afec5bd640eea3d16f369b18ff86f79446" translate="yes" xml:space="preserve">
          <source>Setting up the local environment</source>
          <target state="translated">设置本地环境</target>
        </trans-unit>
        <trans-unit id="c7f73bb54d928922c3838bb789ee9fb8a5b1eb37" translate="yes" xml:space="preserve">
          <source>Settings</source>
          <target state="translated">Settings</target>
        </trans-unit>
        <trans-unit id="89a5ab56adeb4ad20f46a74711635d7a3b3c6f17" translate="yes" xml:space="preserve">
          <source>Setup Kotlin Compilation Step</source>
          <target state="translated">设置Kotlin编译步骤</target>
        </trans-unit>
        <trans-unit id="f7fd968c0a5ce680afda4eb915e615fd82b3a5d5" translate="yes" xml:space="preserve">
          <source>Setup Kotlin Compiler Fetching Step</source>
          <target state="translated">设置Kotlin编译器获取步骤</target>
        </trans-unit>
        <trans-unit id="1cd15bb14bf553822a7d00ea242fd63abf35e644" translate="yes" xml:space="preserve">
          <source>Setup for the whole project: Open File -&amp;gt; Settings, select &quot;Build, Execution, Deployment&quot; -&amp;gt; &quot;Compiler&quot; -&amp;gt; &quot;Kotlin compiler&quot;. Choose appropriate module system in &quot;Module kind&quot; field.</source>
          <target state="translated">整个项目的设置：打开文件-&amp;gt;设置，选择&amp;ldquo;构建，执行，部署&amp;rdquo;-&amp;gt;&amp;ldquo;编译器&amp;rdquo;-&amp;gt;&amp;ldquo; Kotlin编译器&amp;rdquo;。在&amp;ldquo;模块种类&amp;rdquo;字段中选择适当的模块系统。</target>
        </trans-unit>
        <trans-unit id="f0f08df8a582b1b5aaacc0eb420e8df1267b5d20" translate="yes" xml:space="preserve">
          <source>Setup per module: Open File -&amp;gt; Project Structure&amp;hellip;, find your module in Modules and select &quot;Kotlin&quot; facet under it. Choose appropriate module system in &quot;Module kind&quot; field.</source>
          <target state="translated">每个模块的设置：打开文件-&amp;gt;项目结构&amp;hellip;，在模块中找到您的模块，然后选择其下的&amp;ldquo; Kotlin&amp;rdquo;构面。在&amp;ldquo;模块种类&amp;rdquo;字段中选择适当的模块系统。</target>
        </trans-unit>
        <trans-unit id="e85ac6caafc3dc694f3d37ae03f6e0e397a05a87" translate="yes" xml:space="preserve">
          <source>Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</source>
          <target state="translated">七位ASCII,也就是ISO646-US,也就是Unicode字符集的基本拉丁文块。</target>
        </trans-unit>
        <trans-unit id="7b29b4dba7f56bc1e20beeabf8e2e4afde6e1578" translate="yes" xml:space="preserve">
          <source>Several examples</source>
          <target state="translated">几个例子</target>
        </trans-unit>
        <trans-unit id="6b48a6c117f5beb6359de584b0c0262c2f5ac127" translate="yes" xml:space="preserve">
          <source>Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">最后几个列表的元素可能少于给定的&lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3dc2911d06598db01df02e69e45148f8fafc2630" translate="yes" xml:space="preserve">
          <source>Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">最后几个列表的元素可能少于给定的&lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6876468af6c5e87e9f6d208540b74e1e7a8befa7" translate="yes" xml:space="preserve">
          <source>Several last strings may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">最后几个字符串的字符数可能少于给定的&lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebb92729220424707666ea7db0750140ac89ed3f" translate="yes" xml:space="preserve">
          <source>Several last strings may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">最后几个字符串的字符数可能少于给定的&lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="813a34b3a59a3ac492c103196888e0f76e842e38" translate="yes" xml:space="preserve">
          <source>Severity of the diagnostic that should be reported on usages of experimental API which did not explicitly accept the experimental aspect of that API either by using &lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; or by being annotated with the corresponding marker annotation.</source>
          <target state="translated">诊断的严重性，应针对使用实验API的使用情况进行报告，该诊断未通过使用&lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt;或通过相应的标记注释进行注释而未明确接受该API的实验方面。</target>
        </trans-unit>
        <trans-unit id="d1099b140c2cdd7a815583675ff5a73a0c8b9ec7" translate="yes" xml:space="preserve">
          <source>Severity of the diagnostic that should be reported on usages of experimental API which did not explicitly accept the experimental aspect of that API either by using &lt;a href=&quot;../../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; or by being annotated with the corresponding marker annotation.</source>
          <target state="translated">诊断的严重性，应针对使用实验API的使用情况进行报告，该诊断未通过使用&lt;a href=&quot;../../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt;或通过相应的标记注释进行注释而未明确接受该API的实验方面。</target>
        </trans-unit>
        <trans-unit id="836b05c7633a1e30ae532de9ebb894d7f73b61c8" translate="yes" xml:space="preserve">
          <source>ShadowAnimation</source>
          <target state="translated">ShadowAnimation</target>
        </trans-unit>
        <trans-unit id="c52b8fac4d1546004d36036314634bdacdd53b08" translate="yes" xml:space="preserve">
          <source>ShadowRootInit</source>
          <target state="translated">ShadowRootInit</target>
        </trans-unit>
        <trans-unit id="a309f22f502741e5b5409272ba7d0d45e894ec55" translate="yes" xml:space="preserve">
          <source>ShadowRootMode</source>
          <target state="translated">ShadowRootMode</target>
        </trans-unit>
        <trans-unit id="db79c07cf0a0cefafe30ccd1fc8c954e9f3aad6e" translate="yes" xml:space="preserve">
          <source>Shared Mutable State and Concurrency</source>
          <target state="translated">共享可互换状态和并发性</target>
        </trans-unit>
        <trans-unit id="5aa53b857601ecf23027dcc72fd5e23b6e4d90ca" translate="yes" xml:space="preserve">
          <source>Shared mutable state and concurrency</source>
          <target state="translated">共享的可变状态和并发性</target>
        </trans-unit>
        <trans-unit id="5ef7f5e4f7f5fcb21c29e25a4231957e0c1d6ca3" translate="yes" xml:space="preserve">
          <source>SharedImmutable</source>
          <target state="translated">SharedImmutable</target>
        </trans-unit>
        <trans-unit id="c7977120bf6bcc880df4fe01f7ce83934ed43158" translate="yes" xml:space="preserve">
          <source>Sharing Code between Platforms</source>
          <target state="translated">平台间共享代码</target>
        </trans-unit>
        <trans-unit id="dbe8ea8f6f902897a352043f04fbfba2b7660deb" translate="yes" xml:space="preserve">
          <source>Sharing Kotlin code between iOS and Android</source>
          <target state="translated">在iOS和Android之间共享Kotlin代码</target>
        </trans-unit>
        <trans-unit id="3f04d40398ebd1f6a2cabd19b6ba50ea2f6b3801" translate="yes" xml:space="preserve">
          <source>Sharing Kotlin library between JVM, JS and Native worlds</source>
          <target state="translated">在JVM、JS和Native世界之间共享Kotlin库。</target>
        </trans-unit>
        <trans-unit id="297325326f8f9abbd333d90d941d1753331ba09a" translate="yes" xml:space="preserve">
          <source>Sharing code between mobile platforms is one of the major Kotlin Multiplatform use cases, and it is now possible to build mobile applications with parts of the code, such as business logic, connectivity, and more, shared between Android and iOS.</source>
          <target state="translated">在移动平台之间共享代码是Kotlin多平台的主要用例之一,现在可以在Android和iOS之间共享部分代码,如业务逻辑、连接性等,构建移动应用。</target>
        </trans-unit>
        <trans-unit id="051c4d62ebae6a7b7b80ef891d89eb1bf6a2550d" translate="yes" xml:space="preserve">
          <source>Sharing code between platforms is a powerful technique, but it may be hard to accomplish without rich APIs that we have in Android, JVM, or iOS platforms. Multiplatform libraries can be used to fix that. They bring rich APIs directly in the common Kotlin code. There are several examples of such libraries:</source>
          <target state="translated">平台间的代码共享是一种强大的技术,但如果没有丰富的API,我们在Android、JVM或iOS平台上可能很难实现。多平台库可以用来解决这个问题。它们直接在普通的Kotlin代码中带来丰富的API。这种库有几个例子。</target>
        </trans-unit>
        <trans-unit id="1de7f8359460e124966f478d8ff0b1101ad84358" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin%24shl%28java.math.BigInteger%2C+kotlin.Int%29%2Fn&quot;&gt;n&lt;/a&gt; number of bits.</source>
          <target state="translated">将此值左移&lt;a href=&quot;shl#kotlin%24shl%28java.math.BigInteger%2C+kotlin.Int%29%2Fn&quot;&gt;n&lt;/a&gt;位。</target>
        </trans-unit>
        <trans-unit id="fa89bbf50fa31925246bd02a77f7c8660177c18c" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin.Int%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits.</source>
          <target state="translated">将此值左移&lt;a href=&quot;shl#kotlin.Int%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数。</target>
        </trans-unit>
        <trans-unit id="91a11dfe9061ef195b8867f7a99bdfcb07185b19" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin.Long%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits.</source>
          <target state="translated">将此值左移&lt;a href=&quot;shl#kotlin.Long%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数。</target>
        </trans-unit>
        <trans-unit id="55ad8fceb560e16ef264e86683f6269f57215026" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin.UInt%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits.</source>
          <target state="translated">将此值左移&lt;a href=&quot;shl#kotlin.UInt%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数。</target>
        </trans-unit>
        <trans-unit id="c5f970689157bbb4098e02ad8befbb51472db7a6" translate="yes" xml:space="preserve">
          <source>Shifts this value left by the &lt;a href=&quot;shl#kotlin.ULong%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits.</source>
          <target state="translated">将此值左移&lt;a href=&quot;shl#kotlin.ULong%24shl%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数。</target>
        </trans-unit>
        <trans-unit id="561765590bf462448174dfa2c676fabfb9613e7b" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin%24shr%28java.math.BigInteger%2C+kotlin.Int%29%2Fn&quot;&gt;n&lt;/a&gt; number of bits, filling the leftmost bits with copies of the sign bit.</source>
          <target state="translated">向右移动此值&lt;a href=&quot;shr#kotlin%24shr%28java.math.BigInteger%2C+kotlin.Int%29%2Fn&quot;&gt;n&lt;/a&gt;个位数，用符号位的副本填充最左边的位。</target>
        </trans-unit>
        <trans-unit id="cc68bba5cb4fdf70f538ef2cd32e3d9ca3a6f230" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin.Int%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with copies of the sign bit.</source>
          <target state="translated">将这个值右移&lt;a href=&quot;shr#kotlin.Int%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数，用符号位的副本填充最左边的位。</target>
        </trans-unit>
        <trans-unit id="a3c9d6c2dfd7c1b329f5c2e52f9e86c783409844" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin.Long%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with copies of the sign bit.</source>
          <target state="translated">将这个值右移&lt;a href=&quot;shr#kotlin.Long%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数，用符号位的副本填充最左边的位。</target>
        </trans-unit>
        <trans-unit id="205604884176d4ce45ddfadcf924ca5e75925d36" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin.UInt%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with zeros.</source>
          <target state="translated">将该值右移&lt;a href=&quot;shr#kotlin.UInt%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数，用零填充最左边的位。</target>
        </trans-unit>
        <trans-unit id="975363933f601796162b5dcd9c49eefffe3d4646" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;shr#kotlin.ULong%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with zeros.</source>
          <target state="translated">将该值右移&lt;a href=&quot;shr#kotlin.ULong%24shr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数，用零填充最左边的位。</target>
        </trans-unit>
        <trans-unit id="1320613fcb4e3ad05b5a1fb529d5aa02782a35b6" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;ushr#kotlin.Int%24ushr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with zeros.</source>
          <target state="translated">将该值右移&lt;a href=&quot;ushr#kotlin.Int%24ushr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数，用零填充最左边的位。</target>
        </trans-unit>
        <trans-unit id="de121cd2bd1ef2196f936dbff0fb5367f384adab" translate="yes" xml:space="preserve">
          <source>Shifts this value right by the &lt;a href=&quot;ushr#kotlin.Long%24ushr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt; number of bits, filling the leftmost bits with zeros.</source>
          <target state="translated">将该值右移&lt;a href=&quot;ushr#kotlin.Long%24ushr%28kotlin.Int%29%2FbitCount&quot;&gt;bitCount&lt;/a&gt;个位数，用零填充最左边的位。</target>
        </trans-unit>
        <trans-unit id="0fe7d82f25a3015040a206e54f9c1d3a9717c4c4" translate="yes" xml:space="preserve">
          <source>Short</source>
          <target state="translated">Short</target>
        </trans-unit>
        <trans-unit id="f1be0a77e24659d844b1d829e319473c64b3d92c" translate="yes" xml:space="preserve">
          <source>Short comments can be placed on a single line:</source>
          <target state="translated">简短的注释可以放在单行上。</target>
        </trans-unit>
        <trans-unit id="bb95645acf79d381a75848afbb852798210eb222" translate="yes" xml:space="preserve">
          <source>ShortArray</source>
          <target state="translated">ShortArray</target>
        </trans-unit>
        <trans-unit id="6908df3352349f003ba7c1e2bdfd0ab1d663f541" translate="yes" xml:space="preserve">
          <source>ShortIterator</source>
          <target state="translated">ShortIterator</target>
        </trans-unit>
        <trans-unit id="daaa8e58fde19c5641d9f419edefbe96acf6a0fc" translate="yes" xml:space="preserve">
          <source>ShortVar</source>
          <target state="translated">ShortVar</target>
        </trans-unit>
        <trans-unit id="a18072aa811b8ffe818664ff6ba45b9d51d7c523" translate="yes" xml:space="preserve">
          <source>ShortVarOf</source>
          <target state="translated">ShortVarOf</target>
        </trans-unit>
        <trans-unit id="240898f9447d350a1c2443d35798203546e2999e" translate="yes" xml:space="preserve">
          <source>Shorter syntax for properties</source>
          <target state="translated">更短的属性语法</target>
        </trans-unit>
        <trans-unit id="af61674ca511f597dfdc94a24bcd892cf0f59c64" translate="yes" xml:space="preserve">
          <source>Should compiler generated code call the main function</source>
          <target state="translated">编译器生成的代码是否应该调用主函数</target>
        </trans-unit>
        <trans-unit id="ad81adfa3e182e6e5c1f09169b9e8963d98edb1b" translate="yes" xml:space="preserve">
          <source>Sign and absolute value:</source>
          <target state="translated">符号和绝对值。</target>
        </trans-unit>
        <trans-unit id="9902ec5a921b75c5ce68e37cd519601a31d13da9" translate="yes" xml:space="preserve">
          <source>Signals that the annotated annotation class is a marker of an experimental API.</source>
          <target state="translated">标志着注解的注解类是一个实验性API的标记。</target>
        </trans-unit>
        <trans-unit id="a0215479e9dd9a267a38a1be46680da42a198173" translate="yes" xml:space="preserve">
          <source>Signed, unsigned integral, and floating point types are mapped to their Kotlin counterpart with the same width.</source>
          <target state="translated">有符号、无符号积分和浮点类型被映射到它们的Kotlin对应类型上,宽度相同。</target>
        </trans-unit>
        <trans-unit id="9fe5273a06659605c10cb83e488938ef900a3591" translate="yes" xml:space="preserve">
          <source>Signifies that the annotated functional type represents an extension function.</source>
          <target state="translated">表示注释的功能类型代表一个扩展功能。</target>
        </trans-unit>
        <trans-unit id="9fcc4d0c21be05b877e2736e1dd7b56ceaaa4a1d" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;code&gt;Array&lt;/code&gt; constructor, there are now functions that create &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;MutableList&lt;/code&gt; instances and initialize each element by calling a lambda:</source>
          <target state="translated">与 &lt;code&gt;Array&lt;/code&gt; 构造函数类似，现在有一些函数可以创建 &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;MutableList&lt;/code&gt; 实例，并通过调用lambda来初始化每个元素：</target>
        </trans-unit>
        <trans-unit id="b696a41cbfc5d18be8eef6a404f46e79ece8b58f" translate="yes" xml:space="preserve">
          <source>Similar to when we're using &lt;a href=&quot;../getting-started-idea/getting-started-with-intellij-idea&quot;&gt;IntelliJ IDEA build system&lt;/a&gt; or the command line, we can have the compiler output JavaScript to comply with a specific module system such as AMD, CommonJS or UMD.</source>
          <target state="translated">与使用&lt;a href=&quot;../getting-started-idea/getting-started-with-intellij-idea&quot;&gt;IntelliJ IDEA构建系统&lt;/a&gt;或命令行时类似，我们可以使编译器输出JavaScript以符合特定的模块系统，例如AMD，CommonJS或UMD。</target>
        </trans-unit>
        <trans-unit id="c343ad89de5e3d2bda211b8f922e99f913bab352" translate="yes" xml:space="preserve">
          <source>Similarly to functions, Kotlin supports extension properties:</source>
          <target state="translated">与函数类似,Kotlin也支持扩展属性。</target>
        </trans-unit>
        <trans-unit id="4167cd56e3b5dcc5788a4fd7f543f645c15d01ed" translate="yes" xml:space="preserve">
          <source>Similarly, a library consumer may need to provide matching fallbacks for custom product flavors if some are missing in the library publications.</source>
          <target state="translated">同样,如果图书馆出版物中缺少某些产品口味,图书馆消费者可能需要为定制产品口味提供匹配的后备。</target>
        </trans-unit>
        <trans-unit id="f536b6acdc9043c4a42d4d23229b44e979722a18" translate="yes" xml:space="preserve">
          <source>Similarly, when we assign to &lt;code&gt;p&lt;/code&gt;, the &lt;code&gt;setValue()&lt;/code&gt; function is called. The first two parameters are the same, and the third holds the value being assigned:</source>
          <target state="translated">同样，当我们分配给 &lt;code&gt;p&lt;/code&gt; 时，将调用 &lt;code&gt;setValue()&lt;/code&gt; 函数。前两个参数相同，第三个参数保存分配的值：</target>
        </trans-unit>
        <trans-unit id="3b895209bc0a4e4dfafeeb7fada6b857d595d852" translate="yes" xml:space="preserve">
          <source>Similarly, when you already have the type arguments of an instance checked statically (at compile time), you can make an &lt;em&gt;is&lt;/em&gt;-check or a cast that involves the non-generic part of the type. Note that angle brackets are omitted in this case:</source>
          <target state="translated">类似地，当已经（在编译时）静态检查了实例的类型参数时，可以进行&lt;em&gt;is&lt;/em&gt; -check或涉及类型的非泛型部分的强制转换。请注意在这种情况下省略了尖括号：</target>
        </trans-unit>
        <trans-unit id="373dea533a0d49a9c6fb1be2d9e503372df28cc1" translate="yes" xml:space="preserve">
          <source>Simple example</source>
          <target state="translated">简单的例子</target>
        </trans-unit>
        <trans-unit id="9fe6625e7fa70a75f441e66f48bbb12c8a2bda69" translate="yes" xml:space="preserve">
          <source>Simple example: Reachable Numbers problem</source>
          <target state="translated">简单的例子。可达到的数字问题</target>
        </trans-unit>
        <trans-unit id="460e0cbdf7f85b57fb0b9092f75f48e34791ec3e" translate="yes" xml:space="preserve">
          <source>Simple type</source>
          <target state="translated">简单型</target>
        </trans-unit>
        <trans-unit id="bf9fd8196e53917d432912e26e9c5f145f971f1d" translate="yes" xml:space="preserve">
          <source>SimpleEffect</source>
          <target state="translated">SimpleEffect</target>
        </trans-unit>
        <trans-unit id="1f88a84a3c3cc88b9e388323628cb3bfb002e0ea" translate="yes" xml:space="preserve">
          <source>Since 1.1, data classes may extend other classes (see &lt;a href=&quot;sealed-classes&quot;&gt;Sealed classes&lt;/a&gt; for examples).</source>
          <target state="translated">从1.1开始，数据类可以扩展其他类（有关示例，请参见&lt;a href=&quot;sealed-classes&quot;&gt;密封类&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c45af68c04ba0b57547d05c578aa8eba167797e0" translate="yes" xml:space="preserve">
          <source>Since 1.3.0 Kotlin has an experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on. Customizations are defined by so-called &lt;em&gt;Script definitions&lt;/em&gt; - annotated kotlin classes with appropriate support code. The script filename extension is used to select appropriate definition.</source>
          <target state="translated">从1.3.0版本开始，Kotlin对脚本自定义提供了实验性支持，例如添加外部属性，提供静态或动态依赖关系等。定制由所谓的&lt;em&gt;脚本定义&lt;/em&gt;（带有适当支持代码的带注释的kotlin类）&lt;em&gt;定义&lt;/em&gt;。脚本文件扩展名用于选择适当的定义。</target>
        </trans-unit>
        <trans-unit id="ae33bc2ca6c920991b37acb69fe39030237d1fda" translate="yes" xml:space="preserve">
          <source>Since 1.3.40, a separate Gradle plugin for Kotlin/Native is deprecated in favor of the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin. This plugin provides an IDE support along with support of the new multiplatform project model introduced in Kotlin 1.3.0. Below you can find a short list of differences between &lt;code&gt;kotlin-platform-native&lt;/code&gt; and &lt;code&gt;kotlin-muliplatform&lt;/code&gt; plugins. For more information see the &lt;code&gt;kotlin-muliplatform&lt;/code&gt;&lt;a href=&quot;../building-mpp-with-gradle&quot;&gt;documentation page&lt;/a&gt;. For &lt;code&gt;kotlin-platform-native&lt;/code&gt; reference see the &lt;a href=&quot;#kotlin-platform-native-reference&quot;&gt;corresponding section&lt;/a&gt;.</source>
          <target state="translated">从1.3.40开始，不推荐使用单独的Kotlin / Native Gradle插件，而推荐使用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件。该插件提供了对IDE的支持以及对Kotlin 1.3.0中引入的新的多平台项目模型的支持。您可以在下面找到 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 和 &lt;code&gt;kotlin-muliplatform&lt;/code&gt; 插件之间的区别的简短列表。有关更多信息，请参阅 &lt;code&gt;kotlin-muliplatform&lt;/code&gt; &lt;a href=&quot;../building-mpp-with-gradle&quot;&gt;文档页面&lt;/a&gt;。有关 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 参考，请参见&lt;a href=&quot;#kotlin-platform-native-reference&quot;&gt;相应部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f3503e86bffe0abaebb38725b3349da076c53cf" translate="yes" xml:space="preserve">
          <source>Since 1.3.40, test executables are represented by a separate binary type and have their own getter. To access the default test binary, use:</source>
          <target state="translated">从1.3.40开始,测试可执行文件由一个单独的二进制类型表示,并有自己的getter。要访问默认的测试二进制文件,请使用:</target>
        </trans-unit>
        <trans-unit id="74d2423e1b8ad654b09fa01e578cbe247dd6909a" translate="yes" xml:space="preserve">
          <source>Since Java has no way of marking methods for which it makes sense to use the operator syntax, Kotlin allows using any Java methods with the right name and signature as operator overloads and other conventions (&lt;code&gt;invoke()&lt;/code&gt; etc.) Calling Java methods using the infix call syntax is not allowed.</source>
          <target state="translated">由于Java无法标记使用操作符语法有意义的方法，因此Kotlin允许使用名称和签名正确的Java方法作为操作符重载和其他约定（ &lt;code&gt;invoke()&lt;/code&gt; 等）。使用infix调用Java方法不允许使用调用语法。</target>
        </trans-unit>
        <trans-unit id="b8398b1189e7866368709036da6ebf170a442288" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.1, it's possible to access the constants in an enum class in a generic way, using the &lt;code&gt;enumValues&amp;lt;T&amp;gt;()&lt;/code&gt; and &lt;code&gt;enumValueOf&amp;lt;T&amp;gt;()&lt;/code&gt; functions:</source>
          <target state="translated">从Kotlin 1.1开始，可以使用 &lt;code&gt;enumValues&amp;lt;T&amp;gt;()&lt;/code&gt; 和 &lt;code&gt;enumValueOf&amp;lt;T&amp;gt;()&lt;/code&gt; 函数以通用方式访问enum类中的常量：</target>
        </trans-unit>
        <trans-unit id="330983e4399baf0a2c9af16e30f769877d9bd0ed" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.1, you can omit the property type if it can be inferred from the getter:</source>
          <target state="translated">从Kotlin 1.1开始,如果可以从getter中推断出属性类型,可以省略。</target>
        </trans-unit>
        <trans-unit id="da701a88d5b6b6cb5f3f3cc5c091da6b746b52c6" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.1.50, &lt;a href=&quot;https://github.com/Kotlin/KEEP/blob/41091f1cc7045142181d8c89645059f4a15cc91a/proposals/jsr-305-custom-nullability-qualifiers.md&quot;&gt;custom nullability qualifiers (KEEP-79)&lt;/a&gt; are also supported (see below).</source>
          <target state="translated">从Kotlin 1.1.50开始，还支持&lt;a href=&quot;https://github.com/Kotlin/KEEP/blob/41091f1cc7045142181d8c89645059f4a15cc91a/proposals/jsr-305-custom-nullability-qualifiers.md&quot;&gt;自定义可空性限定符（KEEP-79）&lt;/a&gt;（请参阅下文）。</target>
        </trans-unit>
        <trans-unit id="9ae7b7121257ecc4190400d88c65896582898044" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.2, explicitly specifying &lt;code&gt;this&lt;/code&gt; as the receiver is not necessary: &lt;code&gt;this::foo&lt;/code&gt; and &lt;code&gt;::foo&lt;/code&gt; are equivalent.</source>
          <target state="translated">由于科特林1.2，明确指定 &lt;code&gt;this&lt;/code&gt; 作为接收机是没有必要的： &lt;code&gt;this::foo&lt;/code&gt; 和 &lt;code&gt;::foo&lt;/code&gt; 的是等效的。</target>
        </trans-unit>
        <trans-unit id="8c4391f4af9d2a0c13ee2de02e3def8882dce4b0" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.3 use &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/index&quot;&gt;kotlin.sequences.SequenceScope&lt;/a&gt; instead.</source>
          <target state="translated">自Kotlin 1.3起，请改用&lt;a href=&quot;../../kotlin.sequences/-sequence-scope/index&quot;&gt;kotlin.sequences.SequenceScope&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e80b0e98aee610d55a5c374cdbbf839bc8868cd2" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.3 use &lt;a href=&quot;../kotlin.sequences/iterator&quot;&gt;kotlin.sequences.iterator&lt;/a&gt; instead.</source>
          <target state="translated">从Kotlin 1.3开始，请改用&lt;a href=&quot;../kotlin.sequences/iterator&quot;&gt;kotlin.sequences.iterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88ab4850745a2ab5ce313b43d12c199319889b1c" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.3 use &lt;a href=&quot;../kotlin.sequences/sequence&quot;&gt;kotlin.sequences.sequence&lt;/a&gt; instead.</source>
          <target state="translated">从Kotlin 1.3开始，请改用&lt;a href=&quot;../kotlin.sequences/sequence&quot;&gt;kotlin.sequences.sequence&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="405b74df55c0598869424e3cb858793a687c40ea" translate="yes" xml:space="preserve">
          <source>Since Kotlin 1.3, it is possible to capture &lt;em&gt;when&lt;/em&gt; subject in a variable using following syntax:</source>
          <target state="translated">由于科特林1.3，能够捕获&lt;em&gt;时&lt;/em&gt;使用以下语法对象在一个变量中：</target>
        </trans-unit>
        <trans-unit id="efcc6bedd3b914eb31e0f75f655ecbdfda75ad9b" translate="yes" xml:space="preserve">
          <source>Since Kotlin/Native provides &lt;a href=&quot;native/c_interop&quot;&gt;interoperability with native languages&lt;/a&gt;, there is a DSL allowing one to configure this feature for a specific compilation.</source>
          <target state="translated">由于Kotlin / Native提供了&lt;a href=&quot;native/c_interop&quot;&gt;与本地语言的互操作性&lt;/a&gt;，因此存在一种DSL，允许人们为特定的编译配置此功能。</target>
        </trans-unit>
        <trans-unit id="8a7b2ebad239fb7a910fd79eab4f3372b29c79ee" translate="yes" xml:space="preserve">
          <source>Since all the dependencies required for Kotlin are defined in the Gradle file, nothing else needs to be configured specifically for Kotlin to run correctly.</source>
          <target state="translated">由于Kotlin所需的所有依赖关系都在Gradle文件中定义了,所以不需要为Kotlin的正确运行专门配置其他的东西。</target>
        </trans-unit>
        <trans-unit id="8de791302c96952201846f400a6083331bbe72a8" translate="yes" xml:space="preserve">
          <source>Since an anonymous class has no name, it can't be used as a return type - if you do return an anonymous object, the function's return type must be &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">由于匿名类没有名称，因此不能将其用作返回类型-如果您确实返回了匿名对象，则该函数的返回类型必须为 &lt;code&gt;Any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d293ea0c045033de8d8bd3af73aa0ea0b91a963" translate="yes" xml:space="preserve">
          <source>Since binaries compiled this way depend on the Kotlin runtime you should make sure the latter is present in the classpath whenever your compiled library is used.</source>
          <target state="translated">由于以这种方式编译的二进制文件依赖于Kotlin运行时,你应该确保后者在使用你的编译库时存在于classpath中。</target>
        </trans-unit>
        <trans-unit id="622c73b5fb8d14a132011c0334d390f1a510313f" translate="yes" xml:space="preserve">
          <source>Since cancellation is just an exception, all resources are closed in the usual way. You can wrap the code with timeout in a &lt;code&gt;try {...} catch (e: TimeoutCancellationException) {...}&lt;/code&gt; block if you need to do some additional action specifically on any kind of timeout or use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html&quot;&gt;withTimeoutOrNull&lt;/a&gt; function that is similar to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; but returns &lt;code&gt;null&lt;/code&gt; on timeout instead of throwing an exception:</source>
          <target state="translated">由于取消只是一个例外，因此所有资源都以通常的方式关闭。如果您需要专门针对任何类型的超时采取一些其他措施，或者使用类似于以下内容的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html&quot;&gt;withTimeoutOrNull&lt;/a&gt;函数，则可以将带有超时的代码包装在 &lt;code&gt;try {...} catch (e: TimeoutCancellationException) {...}&lt;/code&gt; 块中&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout，&lt;/a&gt;但在超时时返回 &lt;code&gt;null&lt;/code&gt; 而不是引发异常：</target>
        </trans-unit>
        <trans-unit id="4e125d582c3c9f675a15d0038927e92dc5fb9b46" translate="yes" xml:space="preserve">
          <source>Since data classes automatically declare &lt;code&gt;componentN()&lt;/code&gt; functions, destructuring declarations work here.</source>
          <target state="translated">由于数据类会自动声明 &lt;code&gt;componentN()&lt;/code&gt; 函数，因此在这里可以使用解构声明。</target>
        </trans-unit>
        <trans-unit id="ab91ad24a43e16b80819fa3c7ccb13e2c89d3927" translate="yes" xml:space="preserve">
          <source>Since each enum is an instance of the enum class, they can be initialized as:</source>
          <target state="translated">由于每个枚举都是枚举类的一个实例,所以可以将它们初始化为。</target>
        </trans-unit>
        <trans-unit id="fccccbd7e91cba8ebb5a9e0230afa4e091b0cd00" translate="yes" xml:space="preserve">
          <source>Since inline classes are compiled to their underlying type, it may lead to various obscure errors, for example unexpected platform signature clashes:</source>
          <target state="translated">由于内联类是编译到其底层类型的,所以可能会导致各种不明显的错误,例如意外的平台签名冲突。</target>
        </trans-unit>
        <trans-unit id="90493c5a0e006c2eb80d1e75cd9d689e0f1392ea" translate="yes" xml:space="preserve">
          <source>Since the arrays are also mapped to &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt;, it supports the &lt;code&gt;[]&lt;/code&gt; operator for accessing values by index:</source>
          <target state="translated">由于数组也映射到 &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; ，因此它支持 &lt;code&gt;[]&lt;/code&gt; 运算符，用于按索引访问值：</target>
        </trans-unit>
        <trans-unit id="4d7b853892431a18d65c0d328c4b6e037836cf2e" translate="yes" xml:space="preserve">
          <source>Since the available operators are hardcoded into the formal Kotlin syntax, you can not invent new operators, and overriding an operator does not affect its &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#precedence&quot;&gt;precedence&lt;/a&gt;.</source>
          <target state="translated">由于可用的运算符被硬编码为正式的Kotlin语法，因此您无法发明新的运算符，并且覆盖运算符不会影响其&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#precedence&quot;&gt;优先级&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd0b229f654576b966a8840a049ffa6b928881c9" translate="yes" xml:space="preserve">
          <source>Since the entire anonymous function is self-executing, it will execute as soon as the code is loaded. Its argument will be the object &lt;code&gt;kotlin&lt;/code&gt; from &lt;code&gt;kotlin.js&lt;/code&gt;.</source>
          <target state="translated">由于整个匿名函数都是自执行的，因此它将在代码加载后立即执行。它的参数将成为对象 &lt;code&gt;kotlin&lt;/code&gt; 从 &lt;code&gt;kotlin.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99fc39de8ebf0847b1a608d5ecfdb8c433717d90" translate="yes" xml:space="preserve">
          <source>Since the order of parameters for an annotation written in Java is not defined, you can't use a regular function call syntax for passing the arguments. Instead, you need to use the named argument syntax:</source>
          <target state="translated">由于用Java编写的注解的参数顺序没有定义,所以不能使用常规函数调用语法来传递参数。相反,您需要使用命名参数语法。</target>
        </trans-unit>
        <trans-unit id="1d3e6156826d803abef978e9ca301cc858a7854d" translate="yes" xml:space="preserve">
          <source>Since the parameter types are not encoded as generic type parameters in &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt;, you won't get compile-time type validation of the parameters you pass. In order to encode the parameter types, use one of the subinterfaces &lt;code&gt;KFunction1&amp;lt;A, V&amp;gt;&lt;/code&gt;, &lt;code&gt;KFunction2&amp;lt;A, B, V&amp;gt;&lt;/code&gt;, &lt;code&gt;KFunction3&amp;lt;A, B, C, V&amp;gt;&lt;/code&gt;, and so on, depending on how many parameters the function has got. Keep in mind that if you are referencing a member function, the first generic type parameter is the receiver type. For example, &lt;code&gt;KFunction3&amp;lt;A, B, C, V&amp;gt;&lt;/code&gt; may reference either an ordinary function that takes &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; as parameters and returns &lt;code&gt;V&lt;/code&gt;, or it may reference a member function on &lt;code&gt;A&lt;/code&gt; that takes &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; as parameters and returns &lt;code&gt;V&lt;/code&gt;. When you use any of these types, you can call the function through its reference as if the reference were a function, e.g. &lt;code&gt;function(a, b)&lt;/code&gt;, and this call will be type-safe.</source>
          <target state="translated">由于参数类型未在 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; 编码为通用类型参数，因此您将无法对传递的参数进行编译时类型验证。为了对参数类型进行编码，请使用子接口 &lt;code&gt;KFunction1&amp;lt;A, V&amp;gt;&lt;/code&gt; ， &lt;code&gt;KFunction2&amp;lt;A, B, V&amp;gt;&lt;/code&gt; ， &lt;code&gt;KFunction3&amp;lt;A, B, C, V&amp;gt;&lt;/code&gt; 等之一，具体取决于子接口的参数数量。功能已经得到。请记住，如果要引用成员函数，则第一个通用类型参数是接收器类型。例如， &lt;code&gt;KFunction3&amp;lt;A, B, C, V&amp;gt;&lt;/code&gt; 可以引用以 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 为参数并返回 &lt;code&gt;V&lt;/code&gt; 的普通函数。，或者它可以参考上的成员函数 &lt;code&gt;A&lt;/code&gt; 那取 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 作为参数并返回 &lt;code&gt;V&lt;/code&gt; 。使用这些类型中的任何一种时，都可以通过其引用来调用该函数，就像该引用是一个函数一样，例如 &lt;code&gt;function(a, b)&lt;/code&gt; ，此调用将是类型安全的。</target>
        </trans-unit>
        <trans-unit id="c8d2c0eaa40e46a8c6ea31321656b62533073742" translate="yes" xml:space="preserve">
          <source>Since version 1.1.4, Kotlin/JS includes a dead code elimination (DCE) tool. This tool allows to strip out unused properties, functions and classes from the generated JS. There are several ways you get unused declarations:</source>
          <target state="translated">从1.1.4版本开始,Kotlin/JS包含了一个消除死代码(DCE)工具。该工具允许从生成的JS中剥离出未使用的属性、函数和类。有几种方法可以获得未使用的声明。</target>
        </trans-unit>
        <trans-unit id="eb32719a3bf81b439295cec580621456d2ecbd8a" translate="yes" xml:space="preserve">
          <source>Since we'll be using the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;&lt;code&gt;kotlinx.coroutines&lt;/code&gt;&lt;/a&gt;, let's add its recent version to our dependencies:</source>
          <target state="translated">由于我们将使用&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt; &lt;code&gt;kotlinx.coroutines&lt;/code&gt; &lt;/a&gt;，因此我们将其最新版本添加到我们的依赖项中：</target>
        </trans-unit>
        <trans-unit id="1a9dce84a0725c0b6c49a8e9dd94e932d53babd3" translate="yes" xml:space="preserve">
          <source>Since you can't modify built-in or third-party classes, you can't directly add functions or properties to them. If you can achieve what you want by only using the public members of a class, you can of course just write a function that takes an instance of the class as a parameter - but sometimes, you'd really like to be able to say &lt;code&gt;x.foo(y)&lt;/code&gt; instead of &lt;code&gt;foo(x, y)&lt;/code&gt;, especially if you want to make a chain of such calls or property lookups: &lt;code&gt;x.foo(y).bar().baz&lt;/code&gt; instead of &lt;code&gt;getBaz(bar(foo(x, y)))&lt;/code&gt;.</source>
          <target state="translated">由于您无法修改内置或第三方类，因此无法直接向其添加函数或属性。如果您仅通过使用类的公共成员就可以实现所需的功能，那么您当然可以编写一个将类的实例作为参数的函数-但有时，您真的想说 &lt;code&gt;x.foo(y)&lt;/code&gt; 而不是 &lt;code&gt;foo(x, y)&lt;/code&gt; ，尤其是当您要进行这样的调用或属性查找的链时： &lt;code&gt;x.foo(y).bar().baz&lt;/code&gt; 而不是 &lt;code&gt;getBaz(bar(foo(x, y)))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06def0138f09b8c0f949f07f4920634afdd6f7fb" translate="yes" xml:space="preserve">
          <source>SinceKotlin</source>
          <target state="translated">SinceKotlin</target>
        </trans-unit>
        <trans-unit id="c2499363e6a7b206721dbe6071ddba0631ff7592" translate="yes" xml:space="preserve">
          <source>Single-Expression functions</source>
          <target state="translated">单一表达式功能</target>
        </trans-unit>
        <trans-unit id="948bf8711c54b33e1c9d4a741ca29c920e235551" translate="yes" xml:space="preserve">
          <source>Single-expression functions</source>
          <target state="translated">单一表达式函数</target>
        </trans-unit>
        <trans-unit id="f4952f106d9d3b4bccd6d238d2f11b71e55ecb4c" translate="yes" xml:space="preserve">
          <source>Singletons</source>
          <target state="translated">Singletons</target>
        </trans-unit>
        <trans-unit id="ee6a091ca276835c16a3bfeac72a4361f88e2bf7" translate="yes" xml:space="preserve">
          <source>Sixteen-bit UCS Transformation Format, big-endian byte order.</source>
          <target state="translated">16位UCS转换格式,大二烯字节顺序。</target>
        </trans-unit>
        <trans-unit id="ee23d2f192966423edfb5a719af0092090fdca64" translate="yes" xml:space="preserve">
          <source>Sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order mark.</source>
          <target state="translated">16位UCS转换格式,字节顺序由一个可选的字节顺序标记确定。</target>
        </trans-unit>
        <trans-unit id="ecc2e39f3a6f9988d872a59c8d23128ff9edbcfe" translate="yes" xml:space="preserve">
          <source>Sixteen-bit UCS Transformation Format, little-endian byte order.</source>
          <target state="translated">十六位UCS转换格式,小安迪字节顺序。</target>
        </trans-unit>
        <trans-unit id="f85dd4da6fcf55c2051ab8017fddbb6a18773e03" translate="yes" xml:space="preserve">
          <source>Skip reachibility check, can lead to mysterious crashes in an application. USE UNSAFE MODE ONLY IF ABSOLUTELY SURE WHAT YOU'RE DOING!!!</source>
          <target state="translated">跳过可达性检查,可能导致应用程序的神秘崩溃。只有在绝对确定你在做什么的情况下才使用UNSAFE模式!!!</target>
        </trans-unit>
        <trans-unit id="71b8e40a5867a69e273ec4b85f91eb799854cf9c" translate="yes" xml:space="preserve">
          <source>Skip this file and go to the next.</source>
          <target state="translated">跳过这个文件,进入下一个文件。</target>
        </trans-unit>
        <trans-unit id="430b38bf6daa7f9164b164b2ffd540b5a3afe2fd" translate="yes" xml:space="preserve">
          <source>Slack</source>
          <target state="translated">Slack</target>
        </trans-unit>
        <trans-unit id="0c8525a31f225d6db84222cdc68f43cb8c6c18bf" translate="yes" xml:space="preserve">
          <source>Slice</source>
          <target state="translated">Slice</target>
        </trans-unit>
        <trans-unit id="d4ba32e18a522523616ead4e04bba098b836f870" translate="yes" xml:space="preserve">
          <source>Slotable</source>
          <target state="translated">Slotable</target>
        </trans-unit>
        <trans-unit id="10fbb462857c0cba8ce2d0a30fb30be71bb9c668" translate="yes" xml:space="preserve">
          <source>Smaller changes</source>
          <target state="translated">较小的变化</target>
        </trans-unit>
        <trans-unit id="1962b7c27bd3945eb2943949ba4b088ed50789a2" translate="yes" xml:space="preserve">
          <source>Smart Casts</source>
          <target state="translated">智能铸件</target>
        </trans-unit>
        <trans-unit id="5d5e5c19860062429de60b61bb54ca023fa3667c" translate="yes" xml:space="preserve">
          <source>Smart cast improvements</source>
          <target state="translated">智能铸造的改进</target>
        </trans-unit>
        <trans-unit id="bcb3cbb48cb2ad564dda01b8a4d33886b1b4cae4" translate="yes" xml:space="preserve">
          <source>Smart casts</source>
          <target state="translated">智能铸件</target>
        </trans-unit>
        <trans-unit id="31522d97ace96f0c56defc6bbe0845e755f1d98b" translate="yes" xml:space="preserve">
          <source>Smartcasts on local delegated properties</source>
          <target state="translated">本地委托属性的智能广播</target>
        </trans-unit>
        <trans-unit id="a633eaa449ddacea57394a3e6ff86e18a93dfbee" translate="yes" xml:space="preserve">
          <source>So basically, we just put a string inside a tag body, but there is this little &lt;code&gt;+&lt;/code&gt; in front of it, so it is a function call that invokes a prefix &lt;code&gt;unaryPlus()&lt;/code&gt; operation. That operation is actually defined by an extension function &lt;code&gt;unaryPlus()&lt;/code&gt; that is a member of the &lt;code&gt;TagWithText&lt;/code&gt; abstract class (a parent of &lt;code&gt;Title&lt;/code&gt;):</source>
          <target state="translated">因此，基本上，我们只是将一个字符串放在标签主体内，但是它前面有这个小 &lt;code&gt;+&lt;/code&gt; ，因此它是一个调用前缀 &lt;code&gt;unaryPlus()&lt;/code&gt; 操作的函数调用。该操作实际上是由扩展函数 &lt;code&gt;unaryPlus()&lt;/code&gt; 定义的，该扩展函数是 &lt;code&gt;TagWithText&lt;/code&gt; 抽象类（ &lt;code&gt;Title&lt;/code&gt; 的父类）的成员：</target>
        </trans-unit>
        <trans-unit id="932e80ae659a0de90bc0dc75a6b10c120ab6dbb8" translate="yes" xml:space="preserve">
          <source>So equality would have been lost silently all over the place, not to mention identity.</source>
          <target state="translated">所以,平等本来就已经悄无声息地全军覆没了,更不用说身份了。</target>
        </trans-unit>
        <trans-unit id="e96dd13ef1773945f266699aea438682e7ab3594" translate="yes" xml:space="preserve">
          <source>So in combination with the top level variable declared above, it can allow looking at the same memory from different threads and building traditional concurrent structures with platform-specific synchronization primitives.</source>
          <target state="translated">所以结合上面声明的顶层变量,它可以允许从不同的线程中查看同一内存,并使用平台特有的同步基元构建传统的并发结构。</target>
        </trans-unit>
        <trans-unit id="bc0acbaacdf27c7a450d9d610b6d7359119efc69" translate="yes" xml:space="preserve">
          <source>So is the following. The difference between &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; is that &lt;code&gt;+&lt;/code&gt; can be a unary operator, but &lt;code&gt;.&lt;/code&gt; can't, so the only way to get the second line to parse is to join it with the preceding line:</source>
          <target state="translated">以下是。 &lt;code&gt;+&lt;/code&gt; 和的区别 &lt;code&gt;.&lt;/code&gt; 是 &lt;code&gt;+&lt;/code&gt; 可以是一元运算符，但是 &lt;code&gt;.&lt;/code&gt; 不能，因此要解析第二行的唯一方法是将其与上一行连接：</target>
        </trans-unit>
        <trans-unit id="4f0ac44318d35bdb0434bf4bda34bcf67e8a08bc" translate="yes" xml:space="preserve">
          <source>So let us see what happens:</source>
          <target state="translated">那就让我们拭目以待吧。</target>
        </trans-unit>
        <trans-unit id="b40f56bc16e78af71c3cc44cb5713393fe2d93cd" translate="yes" xml:space="preserve">
          <source>So you can freely use destructuring declarations in &lt;em&gt;for&lt;/em&gt;-loops with maps (as well as collections of data class instances etc).</source>
          <target state="translated">因此，您可以在带有地图的&lt;em&gt;for&lt;/em&gt;循环中自由使用解构声明（以及数据类实例的集合等）。</target>
        </trans-unit>
        <trans-unit id="a8703e28503d05aec067966bd9d7e146f04d7ce9" translate="yes" xml:space="preserve">
          <source>So you can import all synthetic properties for the &lt;code&gt;free/res/layout/activity_free.xml&lt;/code&gt; layout by adding this import:</source>
          <target state="translated">因此，您可以通过添加以下导入来导入 &lt;code&gt;free/res/layout/activity_free.xml&lt;/code&gt; 布局的所有综合属性：</target>
        </trans-unit>
        <trans-unit id="c3cd48eda4cfceda7505a2a71bde8fd157927016" translate="yes" xml:space="preserve">
          <source>So you can solve tasks:</source>
          <target state="translated">所以你可以解决任务。</target>
        </trans-unit>
        <trans-unit id="2048afe6ef578a9b8c02d8c1f2dc71ba4cc5e26a" translate="yes" xml:space="preserve">
          <source>So, Java prohibits such things in order to guarantee run-time safety. But this has some implications. For example, consider the &lt;code&gt;addAll()&lt;/code&gt; method from &lt;code&gt;Collection&lt;/code&gt; interface. What's the signature of this method? Intuitively, we'd put it this way:</source>
          <target state="translated">因此，Java禁止此类事情以保证运行时安全。但这有一些含义。例如，考虑 &lt;code&gt;Collection&lt;/code&gt; 接口中的 &lt;code&gt;addAll()&lt;/code&gt; 方法。这种方法的签名是什么？直观地讲，我们这样说：</target>
        </trans-unit>
        <trans-unit id="a5ea33aab863f2ed16d025b58cd153fccbe69f68" translate="yes" xml:space="preserve">
          <source>So, first the resulting program prints &lt;code&gt;Start&lt;/code&gt;, then it runs a coroutine through &lt;code&gt;launch {}&lt;/code&gt;, then it runs another one through &lt;code&gt;runBlocking {}&lt;/code&gt; and blocks until it's done, then prints &lt;code&gt;Stop&lt;/code&gt;. Meanwhile the first coroutine completes and prints &lt;code&gt;Hello&lt;/code&gt;. Just like threads, we told you :)</source>
          <target state="translated">因此，首先生成的程序输出 &lt;code&gt;Start&lt;/code&gt; ，然后通过 &lt;code&gt;launch {}&lt;/code&gt; 运行一个协程，然后通过 &lt;code&gt;runBlocking {}&lt;/code&gt; 运行另一个协程并阻塞直到完成，然后输出 &lt;code&gt;Stop&lt;/code&gt; 。同时，第一个协程完成并打印 &lt;code&gt;Hello&lt;/code&gt; 。就像线程一样，我们告诉过您:)</target>
        </trans-unit>
        <trans-unit id="4790cb680e369e2465f78a22145ef3881f0b2cc4" translate="yes" xml:space="preserve">
          <source>So, here the two coroutines are defined but not executed as in the previous example, but the control is given to the programmer on when exactly to start the execution by calling &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt;. We first start &lt;code&gt;one&lt;/code&gt;, then start &lt;code&gt;two&lt;/code&gt;, and then await for the individual coroutines to finish.</source>
          <target state="translated">因此，这里定义了两个协程，但是没有像上一个示例中那样执行，而是通过调用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt;将控制权交给程序员何时确切开始执行。我们首先开始 &lt;code&gt;one&lt;/code&gt; ，然后开始 &lt;code&gt;two&lt;/code&gt; ，然后等待各个协程完成。</target>
        </trans-unit>
        <trans-unit id="f87bb15bb23744f645dc6cdce384f45a5dda4f5f" translate="yes" xml:space="preserve">
          <source>So, how do we start a coroutine? Let's use the &lt;code&gt;launch {}&lt;/code&gt; function:</source>
          <target state="translated">那么，我们如何启动协程？让我们使用 &lt;code&gt;launch {}&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="4e4f67678565baec8708cd041dbe11b31af3f570" translate="yes" xml:space="preserve">
          <source>So, now our functions are very simple:</source>
          <target state="translated">所以,现在我们的功能非常简单。</target>
        </trans-unit>
        <trans-unit id="5e798efb8bbb72d38198a7facef7f3b574f4636e" translate="yes" xml:space="preserve">
          <source>So, the coroutine that had inherited context of &lt;code&gt;runBlocking {...}&lt;/code&gt; continues to execute in the &lt;code&gt;main&lt;/code&gt; thread, while the unconfined one had resumed in the default executor thread that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt; function is using.</source>
          <target state="translated">因此，继承了 &lt;code&gt;runBlocking {...}&lt;/code&gt; 上下文的协程将继续在 &lt;code&gt;main&lt;/code&gt; 线程中执行，而无约束的协程将在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;延迟&lt;/a&gt;函数正在使用的默认执行程序线程中恢复。</target>
        </trans-unit>
        <trans-unit id="7d211dfac10e36035423c9708a4f5505bb9c9ba2" translate="yes" xml:space="preserve">
          <source>So, the sequences let you avoid building results of intermediate steps, therefore improving the performance of the whole collection processing chain. However, the lazy nature of sequences adds some overhead which may be significant when processing smaller collections or doing simpler computations. Hence, you should consider both &lt;code&gt;Sequence&lt;/code&gt; and &lt;code&gt;Iterable&lt;/code&gt; and decide which one is better for your case.</source>
          <target state="translated">因此，这些序列可避免生成中间步骤的结果，从而提高了整个收集处理链的性能。但是，序列的延迟性质增加了一些开销，这些开销在处理较小的集合或进行更简单的计算时可能很重要。因此，您应该同时考虑 &lt;code&gt;Sequence&lt;/code&gt; 和可 &lt;code&gt;Iterable&lt;/code&gt; 并确定哪种情况更适合您的情况。</target>
        </trans-unit>
        <trans-unit id="d916356003ce204bc3a393ee9e159e33d7cd9b65" translate="yes" xml:space="preserve">
          <source>So, what does this call do? Let's look at the body of &lt;code&gt;html&lt;/code&gt; function as defined above. It creates a new instance of &lt;code&gt;HTML&lt;/code&gt;, then it initializes it by calling the function that is passed as an argument (in our example this boils down to calling &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; on the &lt;code&gt;HTML&lt;/code&gt; instance), and then it returns this instance. This is exactly what a builder should do.</source>
          <target state="translated">那么，这个电话做什么？让我们看一下上面定义的 &lt;code&gt;html&lt;/code&gt; 函数的主体。它创建一个新的 &lt;code&gt;HTML&lt;/code&gt; 实例，然后通过调用作为参数传递的函数对其进行初始化（在我们的示例中，该过程归结为在 &lt;code&gt;HTML&lt;/code&gt; 实例上调用 &lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;body&lt;/code&gt; ），然后返回该实例。这正是建造者应该做的。</target>
        </trans-unit>
        <trans-unit id="52f3768098539882e0119dbb283e6497243cf386" translate="yes" xml:space="preserve">
          <source>So, what the prefix &lt;code&gt;+&lt;/code&gt; does here is wrapping a string into an instance of &lt;code&gt;TextElement&lt;/code&gt; and adding it to the &lt;code&gt;children&lt;/code&gt; collection, so that it becomes a proper part of the tag tree.</source>
          <target state="translated">因此，前缀 &lt;code&gt;+&lt;/code&gt; 在这里所做的就是将字符串包装到 &lt;code&gt;TextElement&lt;/code&gt; 的实例中并将其添加到 &lt;code&gt;children&lt;/code&gt; 集合中，从而使其成为标签树的适当部分。</target>
        </trans-unit>
        <trans-unit id="12b3ed6e021fd91320b5ceebbd0e6bd9c0002703" translate="yes" xml:space="preserve">
          <source>Soft Keywords</source>
          <target state="translated">软关键词</target>
        </trans-unit>
        <trans-unit id="718385fd0c419503c70f82a093c83a84b1b25a04" translate="yes" xml:space="preserve">
          <source>Some Java issues addressed in Kotlin</source>
          <target state="translated">Kotlin中解决的一些Java问题</target>
        </trans-unit>
        <trans-unit id="1ee1ea35caa4a9087e54f63c24f82f4afae23440" translate="yes" xml:space="preserve">
          <source>Some JavaScript libraries export packages (namespaces) instead of functions and classes. In terms of JavaScript, it's an object that has members that &lt;em&gt;are&lt;/em&gt; classes, functions and properties. Importing these packages as Kotlin objects often looks unnatural. The compiler allows to map imported JavaScript packages to Kotlin packages, using the following notation:</source>
          <target state="translated">一些JavaScript库导出包（命名空间）而不是函数和类。就JavaScript而言，它是一个对象，其成员&lt;em&gt;包括&lt;/em&gt;类，函数和属性。将这些包作为Kotlin对象导入通常看起来很不自然。编译器允许使用以下表示法将导入的JavaScript程序包映射到Kotlin程序包：</target>
        </trans-unit>
        <trans-unit id="b8c228912efad39ab27850e7078c0b0220142ce8" translate="yes" xml:space="preserve">
          <source>Some annotation processors (such as &lt;code&gt;AutoFactory&lt;/code&gt;) rely on precise types in declaration signatures. By default, Kapt replaces every unknown type (including types for the generated classes) to &lt;code&gt;NonExistentClass&lt;/code&gt;, but you can change this behavior. Add the additional flag to the &lt;code&gt;build.gradle&lt;/code&gt; file to enable error type inferring in stubs:</source>
          <target state="translated">一些注释处理器（例如 &lt;code&gt;AutoFactory&lt;/code&gt; ）依赖于声明签名中的精确类型。默认情况下，Kapt将所有未知类型（包括所生成类的类型）替换为 &lt;code&gt;NonExistentClass&lt;/code&gt; ，但是您可以更改此行为。将附加标志添加到 &lt;code&gt;build.gradle&lt;/code&gt; 文件中以在存根中启用错误类型推断：</target>
        </trans-unit>
        <trans-unit id="e9b0112a5ded4d6fc76de7c8757792375d1ef8b3" translate="yes" xml:space="preserve">
          <source>Some data inconsistency with regard to initialization, such as when:</source>
          <target state="translated">在初始化方面,有些数据不一致,比如当。</target>
        </trans-unit>
        <trans-unit id="2ec82937de14be8e97ca0c1e28319cd1f629f0ec" translate="yes" xml:space="preserve">
          <source>Some examples of what definitely isn't an incompatible change include</source>
          <target state="translated">一些绝对不是不兼容变化的例子包括</target>
        </trans-unit>
        <trans-unit id="cb68483f5d41b2d8412528579f8201778d125468" translate="yes" xml:space="preserve">
          <source>Some libraries have proper &lt;code&gt;module.modulemap&lt;/code&gt; or &lt;code&gt;module.map&lt;/code&gt; files in its headers. For example, macOS and iOS system libraries and frameworks do. The &lt;a href=&quot;https://clang.llvm.org/docs/Modules.html#module-map-language&quot;&gt;module map file&lt;/a&gt; describes the correspondence between header files and modules. When the module maps are available, the headers from the modules that are not included directly can be filtered out using the experimental &lt;code&gt;excludeDependentModules&lt;/code&gt; option of the &lt;code&gt;.def&lt;/code&gt; file:</source>
          <target state="translated">一些库的标头中包含正确的 &lt;code&gt;module.modulemap&lt;/code&gt; 或 &lt;code&gt;module.map&lt;/code&gt; 文件。例如，macOS和iOS系统库和框架都可以。的&lt;a href=&quot;https://clang.llvm.org/docs/Modules.html#module-map-language&quot;&gt;模块映射文件&lt;/a&gt;描述的头文件和模块之间的对应关系。当模块映射可用时，可以使用 &lt;code&gt;.def&lt;/code&gt; 文件的实验 &lt;code&gt;excludeDependentModules&lt;/code&gt; 选项过滤掉未直接包含的模块头：</target>
        </trans-unit>
        <trans-unit id="ecbe5afd16b78f70120a5b12f258298956ff8d44" translate="yes" xml:space="preserve">
          <source>Some non-primitive built-in classes are also mapped:</source>
          <target state="translated">一些非原生的内置类也会被映射。</target>
        </trans-unit>
        <trans-unit id="8dee9b7120e2be75fc0bee01d923884834726ceb" translate="yes" xml:space="preserve">
          <source>Some of the Gradle built-in dependencies, like &lt;code&gt;gradleApi()&lt;/code&gt;, &lt;code&gt;localGroovy()&lt;/code&gt;, or &lt;code&gt;gradleTestKit()&lt;/code&gt; are not available in the source sets dependency DSL. You can, however, add them within the top-level dependency block, as shown above.</source>
          <target state="translated">源集合依赖项DSL中不提供某些Gradle内置依赖项，例如 &lt;code&gt;gradleApi()&lt;/code&gt; ， &lt;code&gt;localGroovy()&lt;/code&gt; 或 &lt;code&gt;gradleTestKit()&lt;/code&gt; 。但是，您可以将它们添加到顶级依赖项块中，如上所示。</target>
        </trans-unit>
        <trans-unit id="ca33e1fd8c377d86f53c24cb8d991d157f4d2294" translate="yes" xml:space="preserve">
          <source>Some of the Kotlin keywords are valid identifiers in Java: &lt;em&gt;in&lt;/em&gt;, &lt;em&gt;object&lt;/em&gt;, &lt;em&gt;is&lt;/em&gt;, etc. If a Java library uses a Kotlin keyword for a method, you can still call the method escaping it with the backtick (`) character:</source>
          <target state="translated">某些Kotlin关键字在Java中是有效的标识符：&lt;em&gt;in&lt;/em&gt;，&lt;em&gt;object&lt;/em&gt;，&lt;em&gt;is&lt;/em&gt;等。如果Java库将Kotlin关键字用作方法，您仍然可以调用该方法，并使用反引号（`）字符对其进行转义：</target>
        </trans-unit>
        <trans-unit id="6cec025139e5801ae5f90249c852e460ef019361" translate="yes" xml:space="preserve">
          <source>Some source sets are created and configured by default: &lt;code&gt;commonMain&lt;/code&gt;, &lt;code&gt;commonTest&lt;/code&gt;, and the default source sets for the compilations. See &lt;a href=&quot;#default-project-layout&quot;&gt;Default Project Layout&lt;/a&gt;.</source>
          <target state="translated">默认情况下会创建和配置一些源集： &lt;code&gt;commonMain&lt;/code&gt; ， &lt;code&gt;commonTest&lt;/code&gt; 和编译的默认源集。请参阅&lt;a href=&quot;#default-project-layout&quot;&gt;默认项目布局&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46849402d48ce8fa8cf59b2eca7dbd26570c373a" translate="yes" xml:space="preserve">
          <source>Some superclasses are very useful as a grouping mechanism for related classes and for providing shared functions, but are so general that they're not useful on their own. &lt;code&gt;MotorVehicle&lt;/code&gt; seems to fit this description. Such a class should be declared &lt;em&gt;abstract&lt;/em&gt;, which will prevent the class from being instantiated directly:</source>
          <target state="translated">某些超类作为相关类的分组机制和提供共享功能非常有用，但是它们是如此笼统，以至于它们本身并没有用。 &lt;code&gt;MotorVehicle&lt;/code&gt; 似乎符合此描述。这样的类应声明为&lt;em&gt;abstract&lt;/em&gt;，这将防止直接实例化该类：</target>
        </trans-unit>
        <trans-unit id="a997931671767da7af31a971af570dea73db8ed8" translate="yes" xml:space="preserve">
          <source>Some targets may require additional configuration. For Android and iOS examples, see the &lt;a href=&quot;../tutorials/native/mpp-ios-android&quot;&gt;Multiplatform Project: iOS and Android&lt;/a&gt; tutorial.</source>
          <target state="translated">一些目标可能需要其他配置。有关Android和iOS的示例，请参见&lt;a href=&quot;../tutorials/native/mpp-ios-android&quot;&gt;Multiplatform Project：iOS和Android&lt;/a&gt;教程。</target>
        </trans-unit>
        <trans-unit id="63a9fbfe36ca16d1efe57c704a5a06f039c3e063" translate="yes" xml:space="preserve">
          <source>Sometimes it is beneficial to use &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt;, which provide flexible control flow, for higher-order functions.</source>
          <target state="translated">对于高阶&lt;a href=&quot;inline-functions&quot;&gt;函数&lt;/a&gt;，有时使用内联函数是有益的，它们可以提供灵活的控制流。</target>
        </trans-unit>
        <trans-unit id="b3c9f6d381eb6e20cbdde2643da759944b133d98" translate="yes" xml:space="preserve">
          <source>Sometimes it is convenient to &lt;em&gt;destructure&lt;/em&gt; an object into a number of variables, for example:</source>
          <target state="translated">有时是很方便的&lt;em&gt;解构&lt;/em&gt;对象插入许多变量，例如：</target>
        </trans-unit>
        <trans-unit id="302d682a26f0a7a9291ca67783bee5bced9328f3" translate="yes" xml:space="preserve">
          <source>Sometimes it is convenient to have an ability to pass some thread-local data, but, for coroutines, which are not bound to any particular thread, it is hard to achieve it manually without writing a lot of boilerplate.</source>
          <target state="translated">有的时候,如果能有传递一些线程本地数据的能力是很方便的,但是,对于那些不与任何特定线程绑定的coroutine来说,如果不写大量的模板,很难手动实现。</target>
        </trans-unit>
        <trans-unit id="043a7ce5b4e61465c0bfadb7f717902673e4e6dd" translate="yes" xml:space="preserve">
          <source>Sometimes it is more convenient to ship a static library with your product, rather than assume it is available within the user's environment. To include a static library into &lt;code&gt;.klib&lt;/code&gt; use &lt;code&gt;staticLibrary&lt;/code&gt; and &lt;code&gt;libraryPaths&lt;/code&gt; clauses. For example:</source>
          <target state="translated">有时，随产品一起提供静态库会更方便，而不是假定它在用户环境中可用。要将静态库包含到 &lt;code&gt;.klib&lt;/code&gt; 中,请使用 &lt;code&gt;staticLibrary&lt;/code&gt; 和 &lt;code&gt;libraryPaths&lt;/code&gt; 子句。例如：</target>
        </trans-unit>
        <trans-unit id="bda56f559bfdf285376cfe98c118c1fc0d45e476" translate="yes" xml:space="preserve">
          <source>Sometimes it is necessary for business logic to create a wrapper around some type. However, it introduces runtime overhead due to additional heap allocations. Moreover, if the wrapped type is primitive, the performance hit is terrible, because primitive types are usually heavily optimized by the runtime, while their wrappers don't get any special treatment.</source>
          <target state="translated">有时,业务逻辑有必要围绕某个类型创建一个封装器。然而,由于额外的堆分配,它会引入运行时开销。此外,如果被封装的类型是基元类型,那么对性能的打击是可怕的,因为基元类型通常会被运行时大量优化,而它们的封装器却没有得到任何特殊的处理。</target>
        </trans-unit>
        <trans-unit id="a1c252c20c0ca0a66522a4f37c8be9e2e7e0683f" translate="yes" xml:space="preserve">
          <source>Sometimes it is required to add custom C declarations to the library before generating bindings (e.g., for &lt;a href=&quot;#macros&quot;&gt;macros&lt;/a&gt;). Instead of creating an additional header file with these declarations, you can include them directly to the end of the &lt;code&gt;.def&lt;/code&gt; file, after a separating line, containing only the separator sequence &lt;code&gt;---&lt;/code&gt;:</source>
          <target state="translated">有时需要在生成绑定之前将自定义C声明添加到库中（例如，对于&lt;a href=&quot;#macros&quot;&gt;宏&lt;/a&gt;）。除了使用这些声明创建其他头文件之外，您还可以将它们直接包含在 &lt;code&gt;.def&lt;/code&gt; 文件的末尾，在分隔线之后，仅包含分隔符序列 &lt;code&gt;---&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56ecfc8da440116471986a5f61a75f0ea7b94e9a" translate="yes" xml:space="preserve">
          <source>Sometimes it is required to override initializers, e.g. when subclassing &lt;code&gt;UIViewController&lt;/code&gt;. Initializers imported as Kotlin constructors can be overridden by Kotlin constructors marked with the &lt;code&gt;@OverrideInit&lt;/code&gt; annotation:</source>
          <target state="translated">有时需要重写初始化器，例如，在对 &lt;code&gt;UIViewController&lt;/code&gt; 进行子类化时。导入为Kotlin构造函数的初始化程序可以被标有 &lt;code&gt;@OverrideInit&lt;/code&gt; 批注的Kotlin构造函数覆盖：</target>
        </trans-unit>
        <trans-unit id="efdaae37e7bf4722447db8e7626c18f363241541" translate="yes" xml:space="preserve">
          <source>Sometimes the C libraries have function parameters or struct fields of a platform-dependent type, e.g. &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;size_t&lt;/code&gt;. Kotlin itself doesn't provide neither implicit integer casts nor C-style integer casts (e.g. &lt;code&gt;(size_t) intValue&lt;/code&gt;), so to make writing portable code in such cases easier, the &lt;code&gt;convert&lt;/code&gt; method is provided:</source>
          <target state="translated">有时，C库具有函数参数或平台相关类型的struct字段，例如 &lt;code&gt;long&lt;/code&gt; 或 &lt;code&gt;size_t&lt;/code&gt; 。Kotlin本身既不提供隐式整数转换也不提供C风格的整数转换（例如 &lt;code&gt;(size_t) intValue&lt;/code&gt; ），因此为了使在这种情况下编写可移植代码更容易，提供了 &lt;code&gt;convert&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="c6d7d45f9a4bb2f105945868e1e4262dd631e65e" translate="yes" xml:space="preserve">
          <source>Sometimes we have a named function in Kotlin, for which we need a different JVM name in the byte code. The most prominent example happens due to &lt;em&gt;type erasure&lt;/em&gt;:</source>
          <target state="translated">有时，我们在Kotlin中有一个命名函数，为此，我们需要在字节码中使用另一个JVM名称。最明显的例子是由于&lt;em&gt;类型擦除&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="57bc7ebf1e9198008144108c9c1119ef8c7efcd8" translate="yes" xml:space="preserve">
          <source>Sometimes we need to access a type passed to us as a parameter:</source>
          <target state="translated">有时我们需要访问一个作为参数传递给我们的类型。</target>
        </trans-unit>
        <trans-unit id="d5900485f21e94ff8c4ddb23a5e9d44345914137" translate="yes" xml:space="preserve">
          <source>Sometimes we need to create an object of a slight modification of some class, without explicitly declaring a new subclass for it. Java handles this case with &lt;em&gt;anonymous inner classes&lt;/em&gt;. Kotlin slightly generalizes this concept with &lt;em&gt;object expressions&lt;/em&gt; and &lt;em&gt;object declarations&lt;/em&gt;.</source>
          <target state="translated">有时我们需要创建一个对某些类稍加修改的对象，而无需为其显式声明一个新的子类。Java用&lt;em&gt;匿名内部类&lt;/em&gt;处理这种情况。Kotlin用&lt;em&gt;对象表达式&lt;/em&gt;和&lt;em&gt;对象声明&lt;/em&gt;稍微概括了这个概念。</target>
        </trans-unit>
        <trans-unit id="c43bb60fb115adf5865cb0fa15a4f5e0748287e9" translate="yes" xml:space="preserve">
          <source>Sometimes we need to define multiple elements for coroutine context. We can use &lt;code&gt;+&lt;/code&gt; operator for that. For example, we can launch a coroutine with an explicitly specified dispatcher and an explicitly specified name at the same time:</source>
          <target state="translated">有时我们需要为协程上下文定义多个元素。我们可以使用 &lt;code&gt;+&lt;/code&gt; 运算符。例如，我们可以同时使用明确指定的调度程序和明确指定的名称启动协程：</target>
        </trans-unit>
        <trans-unit id="1310e09600b521eea851206fd94e82f8d190d5a5" translate="yes" xml:space="preserve">
          <source>Sometimes you are going to use a Kotlin declaration directly from JavaScript, and it's being stripped out by DCE. You may want to keep this declaration. To do so, you can use the following syntax in &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">有时您将直接从JavaScript使用Kotlin声明，而DCE会将其剥离。您可能需要保留此声明。为此，可以在 &lt;code&gt;build.gradle&lt;/code&gt; 中使用以下语法：</target>
        </trans-unit>
        <trans-unit id="701d6ffd47aa414cf9e4b9070e6ac69d9f907851" translate="yes" xml:space="preserve">
          <source>Sometimes you may need to quickly write and execute some code outside of a project or an application. This may be useful, for example, when learning Kotlin or evaluating expressions. Let's have a look through two handy ways to quickly run Kotlin code:</source>
          <target state="translated">有时,您可能需要在项目或应用程序之外快速编写和执行一些代码。例如,在学习Kotlin或评估表达式时,这可能很有用。让我们来看看快速运行Kotlin代码的两种便捷方法。</target>
        </trans-unit>
        <trans-unit id="b4425ac713740daf889b7cc088cbeb587776a728" translate="yes" xml:space="preserve">
          <source>Sometimes you need to call a Kotlin method with a parameter of type &lt;code&gt;KClass&lt;/code&gt;. There is no automatic conversion from &lt;code&gt;Class&lt;/code&gt; to &lt;code&gt;KClass&lt;/code&gt;, so you have to do it manually by invoking the equivalent of the &lt;code&gt;Class&amp;lt;T&amp;gt;.kotlin&lt;/code&gt; extension property:</source>
          <target state="translated">有时您需要使用类型为 &lt;code&gt;KClass&lt;/code&gt; 的参数调用Kotlin方法。没有从 &lt;code&gt;Class&lt;/code&gt; 到 &lt;code&gt;KClass&lt;/code&gt; 的自动转换，因此您必须通过调用等价的 &lt;code&gt;Class&amp;lt;T&amp;gt;.kotlin&lt;/code&gt; 扩展属性来手动进行转换：</target>
        </trans-unit>
        <trans-unit id="f7c6d9e07fb190279efd213b27af8a596256a8b2" translate="yes" xml:space="preserve">
          <source>Sometimes you want to say that you know nothing about the type argument, but still want to use it in a safe way. The safe way here is to define such a projection of the generic type, that every concrete instantiation of that generic type would be a subtype of that projection.</source>
          <target state="translated">有时你想说,你对类型参数一无所知,但还是想以一种安全的方式使用它。这里的安全方式是定义这样一个泛型的投影,该泛型的每一个具体实例都将是该投影的一个子类型。</target>
        </trans-unit>
        <trans-unit id="46f170a2459c0e42a18d65de64835d7772e9f851" translate="yes" xml:space="preserve">
          <source>Sometimes, you're in a situation where you have a value &lt;code&gt;x&lt;/code&gt; that you know is not null, but the compiler doesn't realize it. This can legitimately happen when you're interacting with Java code, but if it happens because your code's logic is more complicated than the compiler's ability to reason about it, you should probably restructure your code. If you can't convince the compiler, you can resort to saying &lt;code&gt;x!!&lt;/code&gt; to form an expression that produces the value of &lt;code&gt;x&lt;/code&gt;, but whose type is non-nullable:</source>
          <target state="translated">有时，您处于一个您知道不为null 的值 &lt;code&gt;x&lt;/code&gt; 的情况下，但是编译器没有意识到这一点。当您与Java代码进行交互时，这可以合法地发生，但是如果发生这种情况是因为代码的逻辑比编译器的推理能力更复杂，则您可能应该重组代码。如果您无法说服编译器，则可以诉诸 &lt;code&gt;x!!&lt;/code&gt; 形成一个表达式，该表达式产生 &lt;code&gt;x&lt;/code&gt; 的值，但其类型不可为空：</target>
        </trans-unit>
        <trans-unit id="378e9e163b7eecefadb4415cae533096e336c4ab" translate="yes" xml:space="preserve">
          <source>Sorting</source>
          <target state="translated">Sorting</target>
        </trans-unit>
        <trans-unit id="921e7c9357933042c013290bc34dab79354742a1" translate="yes" xml:space="preserve">
          <source>Sorts a range in the array in-place with the given &lt;a href=&quot;../../kotlin.collections/sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">使用给定的&lt;a href=&quot;../../kotlin.collections/sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;比较器&lt;/a&gt;在数组中对范围进行排序。</target>
        </trans-unit>
        <trans-unit id="7a20d1597d8301c3cc3bcec0a63b03857c779e81" translate="yes" xml:space="preserve">
          <source>Sorts a range in the array in-place with the given &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">使用给定的&lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;比较器&lt;/a&gt;在数组中对范围进行排序。</target>
        </trans-unit>
        <trans-unit id="1d1e6b1aadd9cf85696a8efae6efd2f282221c3e" translate="yes" xml:space="preserve">
          <source>Sorts a range in the array in-place.</source>
          <target state="translated">对数组中的一个范围进行原地排序。</target>
        </trans-unit>
        <trans-unit id="10a2c137539a5db660667fa6576c28cd26e36ac6" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place according to natural sort order of the value returned by specified &lt;a href=&quot;../../kotlin.collections/sort-by#kotlin.collections%24sortBy%28kotlin.Array%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">根据指定&lt;a href=&quot;../../kotlin.collections/sort-by#kotlin.collections%24sortBy%28kotlin.Array%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;选择器&lt;/a&gt;函数返回的值的自然排序顺序对数组中的元素进行排序。</target>
        </trans-unit>
        <trans-unit id="07efbdad7d4d4a2414ba73adc668adade052ada0" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place according to natural sort order of the value returned by specified &lt;a href=&quot;sort-by#kotlin.collections%24sortBy%28kotlin.Array%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">根据指定&lt;a href=&quot;sort-by#kotlin.collections%24sortBy%28kotlin.Array%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;选择器&lt;/a&gt;函数返回的值的自然排序顺序对数组中的元素进行排序。</target>
        </trans-unit>
        <trans-unit id="bf0d525765ea180a93133271ef548eaa25ac7135" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place descending according to natural sort order of the value returned by specified &lt;a href=&quot;../../kotlin.collections/sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.Array%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">根据指定&lt;a href=&quot;../../kotlin.collections/sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.Array%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;选择器&lt;/a&gt;函数返回的值的自然排序顺序对数组中的元素进行降序排序。</target>
        </trans-unit>
        <trans-unit id="fa27ec6d7341fe4cf77ef645e820323c332516f4" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place descending according to natural sort order of the value returned by specified &lt;a href=&quot;sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.Array%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">根据指定&lt;a href=&quot;sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.Array%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;选择器&lt;/a&gt;函数返回的值的自然排序顺序对数组中的元素进行降序排序。</target>
        </trans-unit>
        <trans-unit id="80685ba332e950eb83904d1f4115777122edba8d" translate="yes" xml:space="preserve">
          <source>Sorts elements in the array in-place descending according to their natural sort order.</source>
          <target state="translated">根据数组中元素的自然排序顺序进行降序排序。</target>
        </trans-unit>
        <trans-unit id="3fa32beeb828e11e44487567ba158313d97575ec" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to natural sort order of the value returned by specified &lt;a href=&quot;../sort-by#kotlin.collections%24sortBy%28kotlin.collections.MutableList%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">根据指定&lt;a href=&quot;../sort-by#kotlin.collections%24sortBy%28kotlin.collections.MutableList%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;选择器&lt;/a&gt;函数返回的值的自然排序顺序对列表中的元素进行就地排序。</target>
        </trans-unit>
        <trans-unit id="a6a7a1bbadcee0fdc07b873d422460bcfcf63439" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to natural sort order of the value returned by specified &lt;a href=&quot;sort-by#kotlin.collections%24sortBy%28kotlin.collections.MutableList%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">根据指定&lt;a href=&quot;sort-by#kotlin.collections%24sortBy%28kotlin.collections.MutableList%28%28kotlin.collections.sortBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortBy.T%2C+kotlin.collections.sortBy.R%29%29%29%2Fselector&quot;&gt;选择器&lt;/a&gt;函数返回的值的自然排序顺序对列表中的元素进行就地排序。</target>
        </trans-unit>
        <trans-unit id="016acc76aaf4b67ee4196bd0e6dd698c603f8a7f" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to the order specified with &lt;a href=&quot;../sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;../sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;比较器&lt;/a&gt;指定的顺序就地对列表中的元素进行排序。</target>
        </trans-unit>
        <trans-unit id="3bd3e4d90292d259ee01f75c87c74c625704e409" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to the order specified with &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;比较器&lt;/a&gt;指定的顺序就地对列表中的元素进行排序。</target>
        </trans-unit>
        <trans-unit id="a27a30d98060067ccc92da7c7b7abd9184f7e85d" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to the order specified with &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.collections.MutableList%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;比较器&lt;/a&gt;指定的顺序就地对列表中的元素进行排序。</target>
        </trans-unit>
        <trans-unit id="08c50e4dcb5f1e790b3908c92dfd681b51af4fd6" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place according to their natural sort order.</source>
          <target state="translated">按照自然排序顺序对列表中的元素进行就地排序。</target>
        </trans-unit>
        <trans-unit id="518d2bf6df28c01bc5ce865b286b09bcb6bd8f57" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place descending according to natural sort order of the value returned by specified &lt;a href=&quot;../sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.collections.MutableList%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">根据指定&lt;a href=&quot;../sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.collections.MutableList%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;选择器&lt;/a&gt;函数返回的值的自然排序顺序对列表中的元素进行降序排序。</target>
        </trans-unit>
        <trans-unit id="a90b16f5917d7428e33805718ad4902f7d836c1f" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place descending according to natural sort order of the value returned by specified &lt;a href=&quot;sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.collections.MutableList%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;selector&lt;/a&gt; function.</source>
          <target state="translated">根据指定&lt;a href=&quot;sort-by-descending#kotlin.collections%24sortByDescending%28kotlin.collections.MutableList%28%28kotlin.collections.sortByDescending.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.sortByDescending.T%2C+kotlin.collections.sortByDescending.R%29%29%29%2Fselector&quot;&gt;选择器&lt;/a&gt;函数返回的值的自然排序顺序对列表中的元素进行降序排序。</target>
        </trans-unit>
        <trans-unit id="8d80c7611560449691efd4fd1165c90dfada93cf" translate="yes" xml:space="preserve">
          <source>Sorts elements in the list in-place descending according to their natural sort order.</source>
          <target state="translated">按照自然排序顺序对列表中的元素进行降序排序。</target>
        </trans-unit>
        <trans-unit id="286952b1c23000c7e96cb265d1597ee4be034d09" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the natural order of its elements.</source>
          <target state="translated">根据元素的自然顺序对数组进行就地排序。</target>
        </trans-unit>
        <trans-unit id="d8747f2faabc6c9d8057fc49ebee4065869ad5f8" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.Array%28%28kotlin.collections.sort.T%29%29%2C+kotlin.Function2%28%28kotlin.collections.sort.T%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.Array%28%28kotlin.collections.sort.T%29%29%2C+kotlin.Function2%28%28kotlin.collections.sort.T%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="d1839449662e167b67669a9432e7e5b8cda47aee" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Byte%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Byte%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="7d1ba7dd62c04c8e2b5a71936a2028b1fc09c095" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.CharArray%2C+kotlin.Function2%28%28kotlin.Char%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.CharArray%2C+kotlin.Function2%28%28kotlin.Char%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="0768dfe6e47561708ff3dcc3e7544aaeba456f69" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.DoubleArray%2C+kotlin.Function2%28%28kotlin.Double%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.DoubleArray%2C+kotlin.Function2%28%28kotlin.Double%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="c50febead4efd17d0d1e1a05393ce1b4d81939d6" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.FloatArray%2C+kotlin.Function2%28%28kotlin.Float%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.FloatArray%2C+kotlin.Function2%28%28kotlin.Float%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="614045354e7f88dacd9beea842f592073eab2474" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.IntArray%2C+kotlin.Function2%28%28kotlin.Int%2C+%2C+%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.IntArray%2C+kotlin.Function2%28%28kotlin.Int%2C+%2C+%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="92757cae315a994755e0f14f54db5ba3c6d0198c" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.LongArray%2C+kotlin.Function2%28%28kotlin.Long%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.LongArray%2C+kotlin.Function2%28%28kotlin.Long%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="66732bd072b25ed9a6c879f731965bd5869d1d8e" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.ShortArray%2C+kotlin.Function2%28%28kotlin.Short%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort#kotlin.collections%24sort%28kotlin.ShortArray%2C+kotlin.Function2%28%28kotlin.Short%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="026d2b0c0155084b25c8a6103dc14e9f42617ceb" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;../../kotlin.collections/sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">根据给定&lt;a href=&quot;../../kotlin.collections/sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;比较器&lt;/a&gt;指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="6ceaa28ff8b5e20a64c1dd76210809e53340579a" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;sort#kotlin.collections%24sort%28kotlin.Array%28%28kotlin.collections.sort.T%29%29%2C+kotlin.Function2%28%28kotlin.collections.sort.T%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;sort#kotlin.collections%24sort%28kotlin.Array%28%28kotlin.collections.sort.T%29%29%2C+kotlin.Function2%28%28kotlin.collections.sort.T%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="dbb39b6e7209d703010d1dea803d9e9f184dfb3a" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;sort#kotlin.collections%24sort%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Byte%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; function.</source>
          <target state="translated">根据给定&lt;a href=&quot;sort#kotlin.collections%24sort%28kotlin.ByteArray%2C+kotlin.Function2%28%28kotlin.Byte%2C+%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;比较&lt;/a&gt;函数指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="0fa5aed9839230cbb9bbcaa97445de61b613d5ee" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">根据给定&lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+java.util.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;比较器&lt;/a&gt;指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="ae101b411aaa730dbbdac995beae34b884882ebe" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place according to the order specified by the given &lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">根据给定&lt;a href=&quot;sort-with#kotlin.collections%24sortWith%28kotlin.Array%28%28kotlin.collections.sortWith.T%29%29%2C+kotlin.Comparator%28%28kotlin.collections.sortWith.T%29%29%29%2Fcomparator&quot;&gt;比较器&lt;/a&gt;指定的顺序对数组进行原位排序。</target>
        </trans-unit>
        <trans-unit id="4770f48b5aef319d4b83ff34a0f71504fb9289b9" translate="yes" xml:space="preserve">
          <source>Sorts the array in-place.</source>
          <target state="translated">对数组进行就地排序。</target>
        </trans-unit>
        <trans-unit id="7ca4493ee7745c260d2545e5a7bcb290392c92d7" translate="yes" xml:space="preserve">
          <source>Source and binary compatibility may have different modes for the same component, e.g. the source language can reach full stability before the binary format stabilizes, or vice versa.</source>
          <target state="translated">源语言和二进制兼容性对同一组件可能有不同的模式,例如源语言可以在二进制格式稳定之前达到完全稳定,反之亦然。</target>
        </trans-unit>
        <trans-unit id="2dcfc2bd4a05ff58d81210efcb67bf27a9d1018d" translate="yes" xml:space="preserve">
          <source>Source code organization</source>
          <target state="translated">源代码组织</target>
        </trans-unit>
        <trans-unit id="91b779a28949d8daf60f28816366c445cff3b975" translate="yes" xml:space="preserve">
          <source>Source file names</source>
          <target state="translated">源文件名</target>
        </trans-unit>
        <trans-unit id="b8b646a7bd4b1ccfe7716e24991769415bb7ad29" translate="yes" xml:space="preserve">
          <source>Source file organization</source>
          <target state="translated">源文件组织</target>
        </trans-unit>
        <trans-unit id="ba5b3110bc5e4b2e8ea36f406acb0d11147c336c" translate="yes" xml:space="preserve">
          <source>Source management</source>
          <target state="translated">源头管理</target>
        </trans-unit>
        <trans-unit id="83330f3a77279d034f4be00739a614f19c8cd41b" translate="yes" xml:space="preserve">
          <source>Source management in the &lt;code&gt;kotlin.platform.native&lt;/code&gt; plugin is uniform with other Kotlin plugins and is based on source sets. A source set is a group of Kotlin/Native source which may contain both common and platform-specific code. The plugin provides a top-level script block &lt;code&gt;sourceSets&lt;/code&gt; allowing you to configure source sets. Also it creates the default source sets &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; (for production and test code respectively).</source>
          <target state="translated">&lt;code&gt;kotlin.platform.native&lt;/code&gt; 插件中的源代码管理与其他Kotlin插件相同，并且基于源集。来源集是一组Kotlin / Native来源，可能包含通用和特定于平台的代码。该插件提供了一个顶级脚本块 &lt;code&gt;sourceSets&lt;/code&gt; ,使您可以配置源集。它还会创建默认的源集 &lt;code&gt;main&lt;/code&gt; 和 &lt;code&gt;test&lt;/code&gt; （分别用于生产和测试代码）。</target>
        </trans-unit>
        <trans-unit id="708a466fe6dad98c570f231d1548d606e08ba67c" translate="yes" xml:space="preserve">
          <source>Source sets can now be shared between an arbitrary subset of platforms (for example, in a module that targets JS, Android and iOS, you can have a source set that is shared only between Android and iOS).</source>
          <target state="translated">源集现在可以在任意的平台子集之间共享(例如,在针对JS、Android和iOS的模块中,你可以拥有一个只在Android和iOS之间共享的源集)。</target>
        </trans-unit>
        <trans-unit id="2feb63b3ff19c42a8edc6ffc039220ef18a5c33f" translate="yes" xml:space="preserve">
          <source>Source: source-incompatible change stops code that used to compile fine (without errors or warnings) from compiling anymore</source>
          <target state="translated">源码:源码不兼容的改变使过去能正常编译的代码不再编译(没有错误或警告)。</target>
        </trans-unit>
        <trans-unit id="44f1fc4c183f95acabbc53da2abac4d4f1206e1e" translate="yes" xml:space="preserve">
          <source>Special Cases:</source>
          <target state="translated">特殊情况:</target>
        </trans-unit>
        <trans-unit id="3e47d59ad303a035e3cd65578d432eefaa1b80ed" translate="yes" xml:space="preserve">
          <source>Special Identifiers</source>
          <target state="translated">特殊标识符</target>
        </trans-unit>
        <trans-unit id="da9712bd56acfa78d3913a233d114cc9c2158cd7" translate="yes" xml:space="preserve">
          <source>Special case:</source>
          <target state="translated">特殊情况。</target>
        </trans-unit>
        <trans-unit id="56064f3962c04c365c47471ff7513622d3ab0964" translate="yes" xml:space="preserve">
          <source>Special cases:</source>
          <target state="translated">特殊情况:</target>
        </trans-unit>
        <trans-unit id="c50a4829b036375e75f919f98b4f3fb6147ea678" translate="yes" xml:space="preserve">
          <source>Special cases: - &lt;code&gt;acos(x)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;, when &lt;code&gt;abs(x) &amp;gt; 1&lt;/code&gt; or x is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">特殊情况： &lt;code&gt;acos(x)&lt;/code&gt; 为 &lt;code&gt;NaN&lt;/code&gt; ，当 &lt;code&gt;abs(x) &amp;gt; 1&lt;/code&gt; 或x为 &lt;code&gt;NaN&lt;/code&gt; 时</target>
        </trans-unit>
        <trans-unit id="87ab084bbfabe196612e1b63be02ed62abd6f7a4" translate="yes" xml:space="preserve">
          <source>Special cases: - &lt;code&gt;asin(x)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;, when &lt;code&gt;abs(x) &amp;gt; 1&lt;/code&gt; or x is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">特殊情况： - &lt;code&gt;asin(x)&lt;/code&gt; 是 &lt;code&gt;NaN&lt;/code&gt; 的，当 &lt;code&gt;abs(x) &amp;gt; 1&lt;/code&gt; 或x为 &lt;code&gt;NaN&lt;/code&gt; 的</target>
        </trans-unit>
        <trans-unit id="80224f054ccac92a6dba14551f00788e44fb6cea" translate="yes" xml:space="preserve">
          <source>Special cases: - &lt;code&gt;x.IEEErem(y)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;, when &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+Inf|-Inf&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is zero. - &lt;code&gt;x.IEEErem(y) == x&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; is finite and &lt;code&gt;y&lt;/code&gt; is infinite.</source>
          <target state="translated">特殊情况： &lt;code&gt;x.IEEErem(y)&lt;/code&gt; 为 &lt;code&gt;NaN&lt;/code&gt; ，当 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 为 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;+Inf|-Inf&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 为零时。- &lt;code&gt;x.IEEErem(y) == x&lt;/code&gt; 时 &lt;code&gt;x&lt;/code&gt; 是有限的，并且 &lt;code&gt;y&lt;/code&gt; 是无限的。</target>
        </trans-unit>
        <trans-unit id="396f015dcc0a4c9a33dfce58b73cb0338669c047" translate="yes" xml:space="preserve">
          <source>Specialized classes</source>
          <target state="translated">专科班</target>
        </trans-unit>
        <trans-unit id="80214f6fe7568d1fe2eee4a6a25be91492189547" translate="yes" xml:space="preserve">
          <source>Specific return type. The return type moves away from the actual data that we need and instead returns a new type &lt;code&gt;Promise&lt;/code&gt; which has to be introspected.</source>
          <target state="translated">特定的返回类型。返回类型远离我们所需的实际数据，而是返回必须自省的新类型 &lt;code&gt;Promise&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10be766e1422f005154bcf107bfdb65683d40144" translate="yes" xml:space="preserve">
          <source>Specifies a code fragment that can be used to replace a deprecated function, property or class. Tools such as IDEs can automatically apply the replacements specified through this annotation.</source>
          <target state="translated">指定一个代码片段,可以用来替换一个废弃的函数、属性或类。IDE等工具可以自动应用通过此注解指定的替换。</target>
        </trans-unit>
        <trans-unit id="f6bde6daa244f6b004cb3386a82fc9dfe647f4b6" translate="yes" xml:space="preserve">
          <source>Specifies how a &lt;a href=&quot;-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance synchronizes initialization among multiple threads.</source>
          <target state="translated">指定&lt;a href=&quot;-lazy/index&quot;&gt;惰性&lt;/a&gt;实例如何在多个线程之间同步初始化。</target>
        </trans-unit>
        <trans-unit id="7a34891c3f008a377113c6728bb426ade078566a" translate="yes" xml:space="preserve">
          <source>Specifies how a &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance synchronizes initialization among multiple threads.</source>
          <target state="translated">指定&lt;a href=&quot;../-lazy/index&quot;&gt;惰性&lt;/a&gt;实例如何在多个线程之间同步初始化。</target>
        </trans-unit>
        <trans-unit id="c4f0b89f9b2bcd589a457d848fb7af8fa36d078a" translate="yes" xml:space="preserve">
          <source>Specifies how many times a function invokes its function parameter in place.</source>
          <target state="translated">指定一个函数在原地调用其函数参数的次数。</target>
        </trans-unit>
        <trans-unit id="e23535d6faf71a1a72da5d8b0c47cb4ff5c68bd4" translate="yes" xml:space="preserve">
          <source>Specifies how the deprecated element usages are reported in code. See the &lt;a href=&quot;../-deprecation-level/index#kotlin.DeprecationLevel&quot;&gt;DeprecationLevel&lt;/a&gt; enum for the possible values.</source>
          <target state="translated">指定如何在代码中报告已弃用的元素用法。有关可能的值，请参见&lt;a href=&quot;../-deprecation-level/index#kotlin.DeprecationLevel&quot;&gt;DeprecationLevel&lt;/a&gt;枚举。</target>
        </trans-unit>
        <trans-unit id="1273973520fb373ff0923e2955fc0a8aa51d89ca" translate="yes" xml:space="preserve">
          <source>Specifies that a JVM default method should be generated for non-abstract Kotlin interface member.</source>
          <target state="translated">指定应该为非抽象的Kotlin接口成员生成一个JVM默认方法。</target>
        </trans-unit>
        <trans-unit id="1b608a06a3ef3e2f1977895180f9d7cd6dab326f" translate="yes" xml:space="preserve">
          <source>Specifies that a warning should be reported on incorrect usages of this experimental API.</source>
          <target state="translated">指定在不正确使用这个实验性API时应该报告一个警告。</target>
        </trans-unit>
        <trans-unit id="9ad2d2ca6b5a6cc26f2cb4f5defb3fa422218068" translate="yes" xml:space="preserve">
          <source>Specifies that an additional static method needs to be generated from this element if it's a function. If this element is a property, additional static getter/setter methods should be generated.</source>
          <target state="translated">指定如果这个元素是函数,需要从这个元素中生成额外的静态方法。如果这个元素是一个属性,则需要生成额外的静态getter/setter方法。</target>
        </trans-unit>
        <trans-unit id="41dca1654db714e11bbcbe786e5e6118d5a8481b" translate="yes" xml:space="preserve">
          <source>Specifies that an error should be reported on incorrect usages of this experimental API.</source>
          <target state="translated">指定在不正确使用该实验性API时应报告的错误。</target>
        </trans-unit>
        <trans-unit id="b8fb6a1c5d45c4db1467991d5c234e6ab817a1e3" translate="yes" xml:space="preserve">
          <source>Specifies that the function parameter &lt;a href=&quot;calls-in-place#kotlin.contracts.ContractBuilder%24callsInPlace%28kotlin.Function%28%28kotlin.contracts.ContractBuilder.callsInPlace.R%29%29%2C+kotlin.contracts.InvocationKind%29%2Flambda&quot;&gt;lambda&lt;/a&gt; is invoked in place.</source>
          <target state="translated">指定在适当位置调用函数参数&lt;a href=&quot;calls-in-place#kotlin.contracts.ContractBuilder%24callsInPlace%28kotlin.Function%28%28kotlin.contracts.ContractBuilder.callsInPlace.R%29%29%2C+kotlin.contracts.InvocationKind%29%2Flambda&quot;&gt;lambda&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dbed9849f2069fc0d07922505e1643863d85c42" translate="yes" xml:space="preserve">
          <source>Specifies that this effect, when observed, guarantees &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; to be true.</source>
          <target state="translated">指定当观察到此效果时，保证&lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt;为true。</target>
        </trans-unit>
        <trans-unit id="d54eb0bc950c7ef72bd2aa203d75cecf873009a2" translate="yes" xml:space="preserve">
          <source>Specifies the author of the element being documented.</source>
          <target state="translated">指定被记录的元素的作者。</target>
        </trans-unit>
        <trans-unit id="7439a2699ea30bac21819e499a0c348bf4db5a53" translate="yes" xml:space="preserve">
          <source>Specifies the contract of a function.</source>
          <target state="translated">指定函数的合同。</target>
        </trans-unit>
        <trans-unit id="668aabdaa85311d5948645d77876f75a16affd74" translate="yes" xml:space="preserve">
          <source>Specifies the first version of Kotlin where a declaration has appeared. Using the declaration and specifying an older API version (via the &lt;code&gt;-api-version&lt;/code&gt; command line option) will result in an error.</source>
          <target state="translated">指定出现声明的Kotlin的第一个版本。使用该声明并指定较旧的API版本（通过 &lt;code&gt;-api-version&lt;/code&gt; 命令行选项）将导致错误。</target>
        </trans-unit>
        <trans-unit id="2e19852d4c7f63b915b4f0748c65b97fb769383f" translate="yes" xml:space="preserve">
          <source>Specifies the name for the Java class or method which is generated from this element.</source>
          <target state="translated">指定从该元素生成的Java类或方法的名称。</target>
        </trans-unit>
        <trans-unit id="a687435bfccbdd96f3fa9d60bae94e072182829e" translate="yes" xml:space="preserve">
          <source>Specifies the version of the software in which the element being documented was introduced.</source>
          <target state="translated">指定引入被记录元素的软件版本。</target>
        </trans-unit>
        <trans-unit id="2ecfae74b60c500bf98eff24ffe25a09c3d987a3" translate="yes" xml:space="preserve">
          <source>Specifying compiler options</source>
          <target state="translated">指定编译器选项</target>
        </trans-unit>
        <trans-unit id="b480fdbc738e688b220525f44187624b8dee5660" translate="yes" xml:space="preserve">
          <source>Specifying the type explicitly</source>
          <target state="translated">明确指定类型</target>
        </trans-unit>
        <trans-unit id="746ebe7b30c04844a0a6acb84ceeeab7bfb3222b" translate="yes" xml:space="preserve">
          <source>Splits the &lt;a href=&quot;split#kotlin.text.Regex%24split%28kotlin.CharSequence%2C+kotlin.Int%29%2Finput&quot;&gt;input&lt;/a&gt; CharSequence around matches of this regular expression.</source>
          <target state="translated">将&lt;a href=&quot;split#kotlin.text.Regex%24split%28kotlin.CharSequence%2C+kotlin.Int%29%2Finput&quot;&gt;输入&lt;/a&gt; CharSequence 拆分为此正则表达式的匹配项。</target>
        </trans-unit>
        <trans-unit id="889fa2d0788d1531abe076f806167d469446a8f8" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="f8c682ed4a61277f6e6fef2ed839395919a64a6f" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.BooleanArray%2C+kotlin.Function1%28%28kotlin.Boolean%2C+%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="6057dd4ee229b6bb485f8071e494d337b4c9c199" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ByteArray%2C+kotlin.Function1%28%28kotlin.Byte%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="36e78b5dbb516213087cd4a2cc82f8f5c89f375e" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.CharArray%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="188c266d70ce2d849ff0de3b5932cdf9da587e53" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.DoubleArray%2C+kotlin.Function1%28%28kotlin.Double%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="2ff97334e8cd4ed34e1a92b3b104f2b5bdaf4fbb" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.FloatArray%2C+kotlin.Function1%28%28kotlin.Float%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="33204572ae494c8da3e3225aed2c1e38da7a21ec" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.IntArray%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="79b98ebd0576ac1d5b9a0ddfe5682da001dd4f39" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.LongArray%2C+kotlin.Function1%28%28kotlin.Long%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="d84eb1d37eef2994f2317dd6d168249568c0d6e4" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.ShortArray%2C+kotlin.Function1%28%28kotlin.Short%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="b8083df548af87e3622d6abccfa8e78274a64c6f" translate="yes" xml:space="preserve">
          <source>Splits the original array into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始数组拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.Array%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="d546386d2e87332d743bd4386df842ed3abe71a8" translate="yes" xml:space="preserve">
          <source>Splits the original char sequence into pair of char sequences, where &lt;em&gt;first&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始char序列拆分为char序列对，其中&lt;em&gt;第一个&lt;/em&gt; char序列包含其&lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的字符，而&lt;em&gt;第二个&lt;/em&gt; char序列包含其&lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的字符。</target>
        </trans-unit>
        <trans-unit id="3f2108aa3476d1886c05784b517af0f46f65dcce" translate="yes" xml:space="preserve">
          <source>Splits the original char sequence into pair of char sequences, where &lt;em&gt;first&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;../partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;../partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始char序列拆分为char序列对，其中&lt;em&gt;第一个&lt;/em&gt; char序列包含其&lt;a href=&quot;../partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的字符，而&lt;em&gt;第二个&lt;/em&gt; char序列包含其&lt;a href=&quot;../partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的字符。</target>
        </trans-unit>
        <trans-unit id="98cb77a4188cc584dfebb3134ca9b48a2ac72713" translate="yes" xml:space="preserve">
          <source>Splits the original char sequence into pair of char sequences, where &lt;em&gt;first&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; char sequence contains characters for which &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始char序列拆分为char序列对，其中&lt;em&gt;第一个&lt;/em&gt; char序列包含其&lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的字符，而&lt;em&gt;第二个&lt;/em&gt; char序列包含其&lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的字符。</target>
        </trans-unit>
        <trans-unit id="abff32a9b2f4672bf7a49c903911bd3c805f10b9" translate="yes" xml:space="preserve">
          <source>Splits the original collection into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始集合拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../../kotlin.collections/partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="51351b50d1163f62c3cb23f2fcefe72a33c2e006" translate="yes" xml:space="preserve">
          <source>Splits the original collection into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始集合拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="a6229b291af2d23e4a0f09e0825f18914ab656ef" translate="yes" xml:space="preserve">
          <source>Splits the original collection into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始集合拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;partition#kotlin.collections%24partition%28kotlin.collections.Iterable%28%28kotlin.collections.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="eff78228133d9c510fcf60618ab7fbbe96384888" translate="yes" xml:space="preserve">
          <source>Splits the original sequence into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;../partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;../partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始序列拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;../partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;../partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="144bf3c5a2bc721c001b10a1ad55b094fadbc884" translate="yes" xml:space="preserve">
          <source>Splits the original sequence into pair of lists, where &lt;em&gt;first&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; list contains elements for which &lt;a href=&quot;partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始序列拆分为成对的列表，其中&lt;em&gt;第一个&lt;/em&gt;列表包含其&lt;a href=&quot;partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的元素，而&lt;em&gt;第二个&lt;/em&gt;列表包含其&lt;a href=&quot;partition#kotlin.sequences%24partition%28kotlin.sequences.Sequence%28%28kotlin.sequences.partition.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.partition.T%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="fc5ba51f56d3586a3ac3ee5a06dad5c2ce9a8a65" translate="yes" xml:space="preserve">
          <source>Splits the original string into pair of strings, where &lt;em&gt;first&lt;/em&gt; string contains characters for which &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; string contains characters for which &lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始字符串拆分为成对的字符串，其中&lt;em&gt;第一个&lt;/em&gt;字符串包含其&lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的字符，而&lt;em&gt;第二个&lt;/em&gt;字符串包含其&lt;a href=&quot;../../kotlin.text/partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的字符。</target>
        </trans-unit>
        <trans-unit id="46b23954fe998387aff666df8efc6520995fc7cc" translate="yes" xml:space="preserve">
          <source>Splits the original string into pair of strings, where &lt;em&gt;first&lt;/em&gt; string contains characters for which &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;true&lt;/code&gt;, while &lt;em&gt;second&lt;/em&gt; string contains characters for which &lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;predicate&lt;/a&gt; yielded &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将原始字符串拆分为成对的字符串，其中&lt;em&gt;第一个&lt;/em&gt;字符串包含其&lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;true&lt;/code&gt; 的字符，而&lt;em&gt;第二个&lt;/em&gt;字符串包含其&lt;a href=&quot;partition#kotlin.text%24partition%28kotlin.String%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.Boolean%29%29%29%2Fpredicate&quot;&gt;谓词&lt;/a&gt;产生 &lt;code&gt;false&lt;/code&gt; 的字符。</target>
        </trans-unit>
        <trans-unit id="a9a50e34ca1a18e2bc366dc8b4f692ad42af93fc" translate="yes" xml:space="preserve">
          <source>Splits this char sequence around matches of the given regular expression.</source>
          <target state="translated">围绕给定的正则表达式的匹配项来分割这个字符串序列。</target>
        </trans-unit>
        <trans-unit id="9e611a3628d04640a979ef6c5b5e2ecc7f66cbfa" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a list of strings each not exceeding the given &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为字符串列表，每个字符串不超过给定的&lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee551ba6b2c606bb6ab83b1a64bb7f625cc07a5b" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a list of strings each not exceeding the given &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为字符串列表，每个字符串不超过给定的&lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb121cc6174dd89d8c08cf61906842c082aba3c6" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a list of strings each not exceeding the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为字符串列表，每个字符串不超过给定的&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="264b34f24f1a06b392a80cbea51e94a0fdc3938d" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a sequence of strings each not exceeding the given &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为字符串序列，每个字符串不超过给定的&lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6da35fa6eec6e876ca4586b221b0baab3b5636c" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a sequence of strings each not exceeding the given &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为字符串序列，每个字符串不超过给定的&lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5ecdbe41629430b5e5cfb82fc1b4ad0586b6b35" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into a sequence of strings each not exceeding the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为字符串序列，每个字符串不超过给定的&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f7147b8b3ec6b68d6bd51082e0faaca2998e51d" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此char序列分成几个char序列，每个char序列不超过给定的&lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;../../kotlin.text/chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个char序列。</target>
        </trans-unit>
        <trans-unit id="63e385077425eafb77e9a40a51539c2d80eb2f51" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此char序列分成几个char序列，每个char序列不超过给定的&lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;../../kotlin.text/chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个char序列。</target>
        </trans-unit>
        <trans-unit id="581a009720af973c365e2ace4d33cf5076877aca" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此char序列分成几个char序列，每个char序列不超过给定的&lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;../chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个char序列。</target>
        </trans-unit>
        <trans-unit id="d717f98666285a1e90ad8965f8f7418dcc8ed232" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此char序列分成几个char序列，每个char序列不超过给定的&lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;../chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个char序列。</target>
        </trans-unit>
        <trans-unit id="85e376173d9c9d8eeff5141b7586fa74005ee16a" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此char序列分成几个char序列，每个char序列不超过给定的&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个char序列。</target>
        </trans-unit>
        <trans-unit id="99d50e657fbe43a3b68f5a6eb982003c115c6f08" translate="yes" xml:space="preserve">
          <source>Splits this char sequence into several char sequences each not exceeding the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此char序列分成几个char序列，每个char序列不超过给定的&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个char序列。</target>
        </trans-unit>
        <trans-unit id="f66500e7f768a0de7bc52b6beeddc83d7cdc8834" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.</source>
          <target state="translated">将这个字符序列分割成一个列表,用以下任何一个字符序列来分隔行。CRLF,LF 或 CR.</target>
        </trans-unit>
        <trans-unit id="3d5a1c5b6b30c321992d76335fa3e703f787af61" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of strings around occurrences of the specified &lt;a href=&quot;../../kotlin.text/split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为围绕指定&lt;a href=&quot;../../kotlin.text/split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符&lt;/a&gt;出现的字符串列表。</target>
        </trans-unit>
        <trans-unit id="8197b9ef14d350d1f531e4c5e5be27c3d5429cd4" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of strings around occurrences of the specified &lt;a href=&quot;../split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为围绕指定&lt;a href=&quot;../split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符&lt;/a&gt;出现的字符串列表。</target>
        </trans-unit>
        <trans-unit id="5e5d0b62ab16eee4e98080c541c6045d782f0598" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of strings around occurrences of the specified &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为围绕指定&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符&lt;/a&gt;出现的字符串列表。</target>
        </trans-unit>
        <trans-unit id="12d10ed5fb25d750ebed3fb28bbf6b83bd2c0019" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a list of strings around occurrences of the specified &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">将此char序列拆分为围绕指定&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符&lt;/a&gt;出现的字符串列表。</target>
        </trans-unit>
        <trans-unit id="3a6716d508015c660a59f20c19d214d94cfd85f3" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.</source>
          <target state="translated">将该字符序列分割成由以下任何一个字符序列分隔的行数序列。CRLF,LF 或 CR.</target>
        </trans-unit>
        <trans-unit id="e3e94c6787d54178064018c52c37bc40d4047b92" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of strings around occurrences of the specified &lt;a href=&quot;../../kotlin.text/split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">围绕指定&lt;a href=&quot;../../kotlin.text/split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符的&lt;/a&gt;出现，将此char序列拆分为字符串序列。</target>
        </trans-unit>
        <trans-unit id="1dc6355bd5dcf88cb7012eadeab20169c9c6450f" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of strings around occurrences of the specified &lt;a href=&quot;../split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">围绕指定&lt;a href=&quot;../split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符的&lt;/a&gt;出现，将此char序列拆分为字符串序列。</target>
        </trans-unit>
        <trans-unit id="2a3dd7ecd8e5aad7ae43ecd7e15b94ace9d83f6c" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of strings around occurrences of the specified &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">围绕指定&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符的&lt;/a&gt;出现，将此char序列拆分为字符串序列。</target>
        </trans-unit>
        <trans-unit id="7ffebadc04bba02e4e49a6327f15a6ca200c75ff" translate="yes" xml:space="preserve">
          <source>Splits this char sequence to a sequence of strings around occurrences of the specified &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt;.</source>
          <target state="translated">围绕指定&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;定界符的&lt;/a&gt;出现，将此char序列拆分为字符串序列。</target>
        </trans-unit>
        <trans-unit id="4894892135b3d855d1f0f6d3001b4e1d6e322c67" translate="yes" xml:space="preserve">
          <source>Splits this collection into a list of lists each not exceeding the given &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此集合拆分为列表列表，每个列表不超过给定&lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8109cdc99c9d3ce75b0e6a735d1a16b951be7072" translate="yes" xml:space="preserve">
          <source>Splits this collection into a list of lists each not exceeding the given &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此集合拆分为列表列表，每个列表不超过给定&lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0f2e0bbfd89fcd5462f6ead2b682ba787dadd8e" translate="yes" xml:space="preserve">
          <source>Splits this collection into a list of lists each not exceeding the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此集合拆分为列表列表，每个列表不超过给定&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e21d3492a25178c7b849a9e5acc322cb20b39aca" translate="yes" xml:space="preserve">
          <source>Splits this collection into several lists each not exceeding the given &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此集合分为几个列表，每个列表不超过给定的&lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;../../kotlin.collections/chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个列表。</target>
        </trans-unit>
        <trans-unit id="a48428391f4651acfd24fee9fa33c87080c6e779" translate="yes" xml:space="preserve">
          <source>Splits this collection into several lists each not exceeding the given &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此集合分为几个列表，每个列表不超过给定的&lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;../chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个列表。</target>
        </trans-unit>
        <trans-unit id="517737e782c5357ab242922fc5304b40e3826245" translate="yes" xml:space="preserve">
          <source>Splits this collection into several lists each not exceeding the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此集合分为几个列表，每个列表不超过给定的&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个列表。</target>
        </trans-unit>
        <trans-unit id="024d988a38905cd8d713b5b971dfe3778cfdc3d8" translate="yes" xml:space="preserve">
          <source>Splits this sequence into a sequence of lists each not exceeding the given &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此序列分为一系列列表，每个列表不超过给定的&lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2782bc20294974e7a1e43c016491b6c91648db8f" translate="yes" xml:space="preserve">
          <source>Splits this sequence into a sequence of lists each not exceeding the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">将此序列分为一系列列表，每个列表不超过给定的&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;大小&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d437291eabeca701471089c6dfa0b2b88f511909" translate="yes" xml:space="preserve">
          <source>Splits this sequence into several lists each not exceeding the given &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此序列拆分为几个列表，每个列表不超过给定的&lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;../chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个列表。</target>
        </trans-unit>
        <trans-unit id="42d99abb4dad1bd5f52d7374981881da327ee184" translate="yes" xml:space="preserve">
          <source>Splits this sequence into several lists each not exceeding the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt; and applies the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function to an each.</source>
          <target state="translated">将此序列拆分为几个列表，每个列表不超过给定的&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;大小&lt;/a&gt;，并将给定的&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;转换&lt;/a&gt;函数应用于每个列表。</target>
        </trans-unit>
        <trans-unit id="7c51d044b0775b9dff2cfa78b3da8cb8049bb2ff" translate="yes" xml:space="preserve">
          <source>Spring support</source>
          <target state="translated">弹簧支撑</target>
        </trans-unit>
        <trans-unit id="4d471041d7df92549d73db2c13c586ee2b0cec2e" translate="yes" xml:space="preserve">
          <source>Square brackets are translated to calls to &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; with appropriate numbers of arguments.</source>
          <target state="translated">方括号会转换为调用以 &lt;code&gt;get&lt;/code&gt; 并 &lt;code&gt;set&lt;/code&gt; 适当数量的参数。</target>
        </trans-unit>
        <trans-unit id="00ffdccd32ed64d431bf831e7b8e2169d330f1f8" translate="yes" xml:space="preserve">
          <source>Stability of Different Components</source>
          <target state="translated">不同成分的稳定性</target>
        </trans-unit>
        <trans-unit id="d1536eaeef57c8fe7e38a044d153592707538ced" translate="yes" xml:space="preserve">
          <source>Stable releases with versions 1.2, 1.3, etc. are usually considered to be &lt;em&gt;feature releases&lt;/em&gt; bringing major changes in the language. Normally, we publish &lt;em&gt;incremental releases&lt;/em&gt;, numbered 1.2.20, 1.2.30, etc, in between feature releases.</source>
          <target state="translated">带有1.2、1.3等版本的稳定版本通常被认为是对语言进行重大更改的&lt;em&gt;功能版本&lt;/em&gt;。通常，我们&lt;em&gt;会&lt;/em&gt;在两个功能版本之间发布编号为1.2.20、1.2.30等的&lt;em&gt;增量&lt;/em&gt;版本。</target>
        </trans-unit>
        <trans-unit id="c2b6f531a85effb53654c20ee953d94aca8bd93f" translate="yes" xml:space="preserve">
          <source>StableObjPtr</source>
          <target state="translated">StableObjPtr</target>
        </trans-unit>
        <trans-unit id="d5695f0dc6545fa97fef8f5d8d98f8ea9529cc21" translate="yes" xml:space="preserve">
          <source>StableRef</source>
          <target state="translated">StableRef</target>
        </trans-unit>
        <trans-unit id="cd6c8d56f6241b414217edc699eb83c63b345d74" translate="yes" xml:space="preserve">
          <source>Stack overflow</source>
          <target state="translated">堆栈溢出</target>
        </trans-unit>
        <trans-unit id="ed0e3d47052276129876bad97c5d9695f1d4c1e7" translate="yes" xml:space="preserve">
          <source>Standard Data Classes</source>
          <target state="translated">标准数据类</target>
        </trans-unit>
        <trans-unit id="9905d2303d697763e7c368a3fc398e3a629682f8" translate="yes" xml:space="preserve">
          <source>Standard Delegates</source>
          <target state="translated">标准代表</target>
        </trans-unit>
        <trans-unit id="eba63c181dd248d4b5bba8f0065bbb50178505fc" translate="yes" xml:space="preserve">
          <source>Standard Library</source>
          <target state="translated">标准图书馆</target>
        </trans-unit>
        <trans-unit id="fbdf47a84aa524486f1f19bc8f2b7696fa1c4c48" translate="yes" xml:space="preserve">
          <source>Standard implementations of delegates for &lt;a href=&quot;../../../../../docs/reference/delegated-properties&quot;&gt;delegated properties&lt;/a&gt; and helper functions for implementing custom delegates.</source>
          <target state="translated">&lt;a href=&quot;../../../../../docs/reference/delegated-properties&quot;&gt;委托属性&lt;/a&gt;的委托的标准实现以及实现自定义委托的帮助器功能。</target>
        </trans-unit>
        <trans-unit id="b31b91de60e88c68f139ba0e04804a05ebd424b2" translate="yes" xml:space="preserve">
          <source>Standard implementations of delegates for &lt;a href=&quot;docs/reference/delegated-properties&quot;&gt;delegated properties&lt;/a&gt; and helper functions for implementing custom delegates.</source>
          <target state="translated">&lt;a href=&quot;docs/reference/delegated-properties&quot;&gt;委托属性&lt;/a&gt;的委托的标准实现以及实现自定义委托的帮助器功能。</target>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="translated">标准库</target>
        </trans-unit>
        <trans-unit id="ad16d6480ea3a42fd35ae681f27222eeb06b2257" translate="yes" xml:space="preserve">
          <source>Standard property delegates.</source>
          <target state="translated">标准财产委托。</target>
        </trans-unit>
        <trans-unit id="f22646c78134d6ac39afe0c5ee5f9ae0df7f3bbd" translate="yes" xml:space="preserve">
          <source>Star projection, denoted by the &lt;code&gt;*&lt;/code&gt; character. For example, in the type &lt;code&gt;KClass&amp;lt;*&amp;gt;&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; is the star projection. See the &lt;a href=&quot;../../../../../../docs/reference/generics#star-projections&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">星形投影，用 &lt;code&gt;*&lt;/code&gt; 字符表示。例如，在类型 &lt;code&gt;KClass&amp;lt;*&amp;gt;&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 是星形投影。有关更多信息，请参阅&lt;a href=&quot;../../../../../../docs/reference/generics#star-projections&quot;&gt;Kotlin语言文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a77f904c776f120da6135a5ca2b0fb989dcaa559" translate="yes" xml:space="preserve">
          <source>Star-projections</source>
          <target state="translated">Star-projections</target>
        </trans-unit>
        <trans-unit id="6e5590764483cbb03fdaa9e24fc59d1a85c1288e" translate="yes" xml:space="preserve">
          <source>Start new scheduling primitive, such as thread, to accept new tasks via &lt;code&gt;execute&lt;/code&gt; interface. Typically new worker may be needed for computations offload to another core, for IO it may be better to use non-blocking IO combined with more lightweight coroutines.</source>
          <target state="translated">启动新的调度原语（例如线程）以通过 &lt;code&gt;execute&lt;/code&gt; 接口接受新任务。通常，可能需要新的工作人员将计算任务卸载到另一个内核，对于IO而言，最好将非阻塞IO与更轻量的协程结合使用。</target>
        </trans-unit>
        <trans-unit id="a0279a8f5111591a71ef0ea505d164e207decfa7" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#running-the-android-application&quot;&gt;Android application&lt;/a&gt;</source>
          <target state="translated">启动&lt;a href=&quot;#running-the-android-application&quot;&gt;Android应用程序&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ffec450a13497055a66c40a0f95ad2095c4fa937" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#running-the-ios-application&quot;&gt;iOS application&lt;/a&gt;</source>
          <target state="translated">启动&lt;a href=&quot;#running-the-ios-application&quot;&gt;iOS应用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e0f646bfc4efa2110bf6449cf37709d3558db49" translate="yes" xml:space="preserve">
          <source>Starting from JDK 1.8, interfaces in Java can contain &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html&quot;&gt;default methods&lt;/a&gt;. You can declare a non-abstract member of a Kotlin interface as default for the Java classes implementing it. To make a member default, mark it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;&lt;code&gt;@JvmDefault&lt;/code&gt;&lt;/a&gt; annotation. Here is an example of a Kotlin interface with a default method:</source>
          <target state="translated">从JDK 1.8开始，Java中的接口可以包含&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html&quot;&gt;默认方法&lt;/a&gt;。您可以将Kotlin接口的非抽象成员声明为实现它的Java类的默认成员。要使成员成为默认成员，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt; &lt;code&gt;@JvmDefault&lt;/code&gt; &lt;/a&gt;批注对其进行标记。这是带有默认方法的Kotlin界面示例：</target>
        </trans-unit>
        <trans-unit id="cd2a24b509ce811a3267e32e8920ed8b3ac2112a" translate="yes" xml:space="preserve">
          <source>Starting from Kotlin 1.3, &lt;code&gt;@JvmStatic&lt;/code&gt; applies to functions defined in companion objects of interfaces as well. Such functions compile to static methods in interfaces. Note that static method in interfaces were introduced in Java 1.8, so be sure to use the corresponding targets.</source>
          <target state="translated">从Kotlin 1.3开始， &lt;code&gt;@JvmStatic&lt;/code&gt; 也适用于在接口的伴随对象中定义的函数。此类函数可编译为接口中的静态方法。请注意，接口中的静态方法是Java 1.8中引入的，因此请确保使用相应的目标。</target>
        </trans-unit>
        <trans-unit id="f2ef314e1060cb19059b7679202c90dd5f779df0" translate="yes" xml:space="preserve">
          <source>Starting from version 1.3.30, kapt supports incremental annotation processing as an experimental feature. Currently, annotation processing can be incremental only if all annotation processors being used are incremental.</source>
          <target state="translated">从1.3.30版本开始,kapt支持增量式注解处理作为一个实验性功能。目前,只有当所有被使用的注解处理器都是增量的时,注解处理才能是增量的。</target>
        </trans-unit>
        <trans-unit id="1620971e5e7fb81960f0323359f6dc556dc282b3" translate="yes" xml:space="preserve">
          <source>Starting with 1.3.30, an experimental integration with &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods&lt;/a&gt; is added to Kotlin/Native. This feature allows you to represent a Kotlin/Native Gradle-project as a CocoaPods dependency. Such a representation provides the following advantages:</source>
          <target state="translated">从1.3.30开始，将与&lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods&lt;/a&gt;的实验集成添加到Kotlin / Native。此功能使您可以将Kotlin / Native Gradle项目表示为CocoaPods依赖项。这样的表示具有以下优点：</target>
        </trans-unit>
        <trans-unit id="843f77eb473690d7aad6e0682c17b7993f79cc2f" translate="yes" xml:space="preserve">
          <source>Starting with Kotlin 1.1, the JavaScript target is no longer considered experimental. All language features are supported, and there are many new tools for integration with the front-end development environment. See &lt;a href=&quot;#javascript-backend&quot;&gt;below&lt;/a&gt; for a more detailed list of changes.</source>
          <target state="translated">从Kotlin 1.1开始，不再将JavaScript目标视为实验性目标。支持所有语言功能，并且有许多新工具可与前端开发环境集成。请参阅&lt;a href=&quot;#javascript-backend&quot;&gt;下面&lt;/a&gt;的更详细的更改列表。</target>
        </trans-unit>
        <trans-unit id="41f73c0acfd31a8c403654851fe6cd652c2e3650" translate="yes" xml:space="preserve">
          <source>Starting with Kotlin 1.1.2, the dependencies with group &lt;code&gt;org.jetbrains.kotlin&lt;/code&gt; are by default resolved with the version taken from the applied plugin. You can provide the version manually using the full dependency notation:</source>
          <target state="translated">从Kotlin 1.1.2开始，默认情况下，组 &lt;code&gt;org.jetbrains.kotlin&lt;/code&gt; 的依赖项使用从应用的插件获取的版本进行解析。您可以使用完整的依赖项表示法手动提供版本：</target>
        </trans-unit>
        <trans-unit id="07b8457eb5cdf91e3e7cbfadbb3eebb80e30d3ff" translate="yes" xml:space="preserve">
          <source>Starting with Kotlin 1.2, array arguments for annotations can be passed with the new array literal syntax instead of the &lt;code&gt;arrayOf&lt;/code&gt; function:</source>
          <target state="translated">从Kotlin 1.2开始，注释的数组参数可以使用新的数组文字语法而不是 &lt;code&gt;arrayOf&lt;/code&gt; 函数传递：</target>
        </trans-unit>
        <trans-unit id="12a86828fbb44a7006158c4f6ac9be7d98219035" translate="yes" xml:space="preserve">
          <source>Starting with version 1.1.50 primitive array translation utilizes JavaScript TypedArray:</source>
          <target state="translated">从1.1.50版本开始,基元数组翻译使用JavaScript TypedArray。</target>
        </trans-unit>
        <trans-unit id="dd4c7c6c2fa2a107f57737194dfcb51c6b3fd326" translate="yes" xml:space="preserve">
          <source>Starts a coroutine with receiver type &lt;a href=&quot;start-coroutine#R&quot;&gt;R&lt;/a&gt; and result type &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;. This function creates and starts a new, fresh instance of suspendable computation every time it is invoked. The &lt;a href=&quot;start-coroutine#kotlin.coroutines%24startCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.startCoroutine.R%2C+kotlin.coroutines.startCoroutine.T%29%29%2C+kotlin.coroutines.startCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception.</source>
          <target state="translated">使用接收器类型&lt;a href=&quot;start-coroutine#R&quot;&gt;R&lt;/a&gt;和结果类型&lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;启动协程。每次调用此函数时，都会创建并启动一个新的可暂停计算的新实例。在&lt;a href=&quot;start-coroutine#kotlin.coroutines%24startCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.startCoroutine.R%2C+kotlin.coroutines.startCoroutine.T%29%29%2C+kotlin.coroutines.startCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;当协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="14c38709fc453b41bd452218007cb35f2d68079b" translate="yes" xml:space="preserve">
          <source>Starts a coroutine without a receiver and with result type &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;. This function creates and starts a new, fresh instance of suspendable computation every time it is invoked. The &lt;a href=&quot;start-coroutine#kotlin.coroutines%24startCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.startCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception.</source>
          <target state="translated">在没有接收器且结果类型为&lt;a href=&quot;start-coroutine#T&quot;&gt;T的&lt;/a&gt;情况下启动协程。每次调用此函数时，都会创建并启动一个新的可暂停计算的新实例。在&lt;a href=&quot;start-coroutine#kotlin.coroutines%24startCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.startCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;当协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="5ad5c461ffacb6e08120b54a5c5c09dc010d10cb" translate="yes" xml:space="preserve">
          <source>Starts an unintercepted coroutine with receiver type &lt;a href=&quot;start-coroutine-unintercepted-or-return#R&quot;&gt;R&lt;/a&gt; and result type &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and executes it until its first suspension. Returns the result of the coroutine or throws its exception if it does not suspend or &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; if it suspends. In the latter case, the &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception.</source>
          <target state="translated">用接收器类型&lt;a href=&quot;start-coroutine-unintercepted-or-return#R&quot;&gt;R&lt;/a&gt;和结果类型&lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt;启动不受拦截的协程，并执行直到其第一次暂停。返回协程的结果，如果不暂停，则抛出异常，如果暂停，则&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;抛出COROUTINE_SUSPENDED&lt;/a&gt;。在后一种情况下，当协程以结果或异常结束时，将调用&lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;继续。</target>
        </trans-unit>
        <trans-unit id="334ec1f5ed05ab3e3f9b3bc457a00d70430e2e22" translate="yes" xml:space="preserve">
          <source>Starts an unintercepted coroutine without a receiver and with result type &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and executes it until its first suspension. Returns the result of the coroutine or throws its exception if it does not suspend or &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; if it suspends. In the latter case, the &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception.</source>
          <target state="translated">在没有接收器且结果类型为&lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T的&lt;/a&gt;情况下启动不受拦截的协程，并执行该协程直到第一次暂停。返回协程的结果，如果协程不挂起，则抛出异常；如果协程不挂起，则&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;抛出COROUTINE_SUSPENDED&lt;/a&gt;。在后一种情况下，当协程以结果或异常结束时，将调用&lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;继续。</target>
        </trans-unit>
        <trans-unit id="3ddb5f3024adc4fc2cb11955f22b8f2de6b0e3b1" translate="yes" xml:space="preserve">
          <source>Starts coroutine with receiver type &lt;a href=&quot;start-coroutine#R&quot;&gt;R&lt;/a&gt; and result type &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;. This function creates and start a new, fresh instance of suspendable computation every time it is invoked. The &lt;a href=&quot;start-coroutine#kotlin.coroutines.experimental%24startCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.startCoroutine.R%2C+kotlin.coroutines.experimental.startCoroutine.T%29%29%2C+kotlin.coroutines.experimental.startCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">以接收器类型&lt;a href=&quot;start-coroutine#R&quot;&gt;R&lt;/a&gt;和结果类型&lt;a href=&quot;start-coroutine#T&quot;&gt;T来&lt;/a&gt;启动协程。每次调用此函数时，都会创建并启动一个新的可暂停计算的新实例。在&lt;a href=&quot;start-coroutine#kotlin.coroutines.experimental%24startCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.startCoroutine.R%2C+kotlin.coroutines.experimental.startCoroutine.T%29%29%2C+kotlin.coroutines.experimental.startCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="926abb8b1e85620405b11eda69dc96cfcc1f565d" translate="yes" xml:space="preserve">
          <source>Starts coroutine without receiver and with result type &lt;a href=&quot;start-coroutine#T&quot;&gt;T&lt;/a&gt;. This function creates and start a new, fresh instance of suspendable computation every time it is invoked. The &lt;a href=&quot;start-coroutine#kotlin.coroutines.experimental%24startCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">在没有接收器且结果类型为&lt;a href=&quot;start-coroutine#T&quot;&gt;T的&lt;/a&gt;情况下启动协程。每次调用此函数时，都会创建并启动一个新的可暂停计算的新实例。在&lt;a href=&quot;start-coroutine#kotlin.coroutines.experimental%24startCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.startCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="2e41ff62360a7519652b277899448ef726bd6a59" translate="yes" xml:space="preserve">
          <source>Starts unintercepted coroutine with receiver type &lt;a href=&quot;start-coroutine-unintercepted-or-return#R&quot;&gt;R&lt;/a&gt; and result type &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and executes it until its first suspension. Returns the result of the coroutine or throws its exception if it does not suspend or &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; if it suspends. In the latter case, the &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.experimental.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; to resume the execution of a suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">从接收器类型&lt;a href=&quot;start-coroutine-unintercepted-or-return#R&quot;&gt;R&lt;/a&gt;和结果类型&lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt;开始不受拦截的协程，并执行直到第一次暂停。返回协程的结果，如果不暂停，则抛出异常，如果暂停，则&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;抛出COROUTINE_SUSPENDED&lt;/a&gt;。在后一种情况下，当协程以结果或异常完成时，将调用&lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.experimental.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;继续。该函数被设计为从&lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;内部使用，以通过使用对suspend函数的引用来恢复暂停的协程的执行。</target>
        </trans-unit>
        <trans-unit id="2788b8cd3b5da900d1f6ab2449049c41a16ae34e" translate="yes" xml:space="preserve">
          <source>Starts unintercepted coroutine without receiver and with result type &lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T&lt;/a&gt; and executes it until its first suspension. Returns the result of the coroutine or throws its exception if it does not suspend or &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; if it suspends. In the latter case, the &lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.experimental.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; to resume the execution of a suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">在没有接收器且结果类型为&lt;a href=&quot;start-coroutine-unintercepted-or-return#T&quot;&gt;T的&lt;/a&gt;情况下启动不受拦截的协程，并执行直到其第一次暂停。返回协程的结果，如果协程不挂起，则抛出异常；如果协程不挂起，则&lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;抛出COROUTINE_SUSPENDED&lt;/a&gt;。在后一种情况下，当协程以结果或异常完成时，将调用&lt;a href=&quot;start-coroutine-unintercepted-or-return#kotlin.coroutines.experimental.intrinsics%24startCoroutineUninterceptedOrReturn%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.startCoroutineUninterceptedOrReturn.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;继续。该函数被设计为从&lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;内部使用，以通过使用对suspend函数的引用来恢复暂停的协程的执行。</target>
        </trans-unit>
        <trans-unit id="a33cea1b6a9bd48cd9741eb556f78b336e49b52e" translate="yes" xml:space="preserve">
          <source>State of the future object.</source>
          <target state="translated">未来对象的状态。</target>
        </trans-unit>
        <trans-unit id="600b8907db339cd22478c83d4a16dd85a73015b0" translate="yes" xml:space="preserve">
          <source>Static fields</source>
          <target state="translated">静态领域</target>
        </trans-unit>
        <trans-unit id="d15bec36fb146b0a59873196f4b808af2a0c58d9" translate="yes" xml:space="preserve">
          <source>Static members</source>
          <target state="translated">静态成员</target>
        </trans-unit>
        <trans-unit id="3367f809c842440e588af1b9c4ce823b40a614e7" translate="yes" xml:space="preserve">
          <source>Static members of Java classes form &quot;companion objects&quot; for these classes. We cannot pass such a &quot;companion object&quot; around as a value, but can access the members explicitly, for example:</source>
          <target state="translated">Java类的静态成员构成了这些类的 &quot;同伴对象&quot;。我们不能把这样的 &quot;同伴对象 &quot;作为一个值传来传去,但可以显式地访问成员,例如。</target>
        </trans-unit>
        <trans-unit id="749a016bf10749d6bbdfc0717392432e9f0401f6" translate="yes" xml:space="preserve">
          <source>Static methods</source>
          <target state="translated">静态方法</target>
        </trans-unit>
        <trans-unit id="352274d59d59b1511e7ddd7438d2c2b359144fe5" translate="yes" xml:space="preserve">
          <source>Status of different components</source>
          <target state="translated">不同组成部分的状况</target>
        </trans-unit>
        <trans-unit id="f3807792854b99f68c6be94a83962b160d23fe45" translate="yes" xml:space="preserve">
          <source>Stay in the constant feedback loop with the users.</source>
          <target state="translated">与用户保持不断的反馈循环。</target>
        </trans-unit>
        <trans-unit id="f94f58f50f4cb02a7cf2e081505d0705933f148e" translate="yes" xml:space="preserve">
          <source>Stepping</source>
          <target state="translated">Stepping</target>
        </trans-unit>
        <trans-unit id="2d96e356b3dfea348019e9d1d257295bebd82c9a" translate="yes" xml:space="preserve">
          <source>Stepping functions works mostly the same way as for C/C++ programs</source>
          <target state="translated">步进函数的工作方式与C/C++程序的工作方式基本相同。</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="248e9b3aa308183a170c36806544acb1d393c459" translate="yes" xml:space="preserve">
          <source>StorageEventInit</source>
          <target state="translated">StorageEventInit</target>
        </trans-unit>
        <trans-unit id="d976f838e65f2db3d7f099767b0928393c1ede54" translate="yes" xml:space="preserve">
          <source>Store old code style in project</source>
          <target state="translated">在项目中存储旧的代码风格</target>
        </trans-unit>
        <trans-unit id="6afbacec45c0da97dff5ccf3dbf2645d5876c3c5" translate="yes" xml:space="preserve">
          <source>Store the initial value of &lt;code&gt;a&lt;/code&gt; to a temporary storage &lt;code&gt;a0&lt;/code&gt;;</source>
          <target state="translated">将 &lt;code&gt;a&lt;/code&gt; 的初始值存储到临时存储 &lt;code&gt;a0&lt;/code&gt; 中；</target>
        </trans-unit>
        <trans-unit id="1c3904cdae80dc0a8fc8d311b3ceb604faa99393" translate="yes" xml:space="preserve">
          <source>Stores the value of the property for the given object in this mutable map.</source>
          <target state="translated">将给定对象的属性值存储在这个可变映射中。</target>
        </trans-unit>
        <trans-unit id="063a13497de8628ed966341d4c8998e048faac77" translate="yes" xml:space="preserve">
          <source>Storing Properties in a Map</source>
          <target state="translated">在地图中存储属性</target>
        </trans-unit>
        <trans-unit id="cc60d9a373cacd1f7b4d2be35acf2bfd9970e460" translate="yes" xml:space="preserve">
          <source>Strictfp</source>
          <target state="translated">Strictfp</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="dcadc5a0cb117211f9dc789c191b1d6c306ecd43" translate="yes" xml:space="preserve">
          <source>String Interpolation</source>
          <target state="translated">字符串插值</target>
        </trans-unit>
        <trans-unit id="18c909570fe3d2f04f7e3e21101c4ef09a029b7b" translate="yes" xml:space="preserve">
          <source>String Literals</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="3ad53eca410dfbc39bc16b33326f447092d15b4c" translate="yes" xml:space="preserve">
          <source>String Templates</source>
          <target state="translated">字符串模板</target>
        </trans-unit>
        <trans-unit id="26999992a443711764128a5ebde38ee89dae6779" translate="yes" xml:space="preserve">
          <source>String literals may contain template expressions, i.e. pieces of code that are evaluated and whose results are concatenated into the string. A template expression starts with a dollar sign ($) and consists of either a simple name:</source>
          <target state="translated">字符串可以包含模板表达式,也就是一些代码,这些代码经过评估后,其结果会被连接到字符串中。模板表达式以美元符号($)开头,由一个简单的名称组成。</target>
        </trans-unit>
        <trans-unit id="8de7744f81c5ea96546b7ddeba1d815a5f60f342" translate="yes" xml:space="preserve">
          <source>String representation</source>
          <target state="translated">字符串表示法</target>
        </trans-unit>
        <trans-unit id="4f85bffe8cf536bd27d4c8a65ebe070b04592d3f" translate="yes" xml:space="preserve">
          <source>String templates</source>
          <target state="translated">字符串模板</target>
        </trans-unit>
        <trans-unit id="7436274167a247aa32b0eb69c8fa150ce90cf60e" translate="yes" xml:space="preserve">
          <source>String to number conversions</source>
          <target state="translated">字符串到数字的转换</target>
        </trans-unit>
        <trans-unit id="d8722e7c9e74dd4282c8ddb6aafb6678ffcf1c49" translate="yes" xml:space="preserve">
          <source>StringBuilder</source>
          <target state="translated">StringBuilder</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="376d2dc017ddcafe576a8bb45c3839697d243c0f" translate="yes" xml:space="preserve">
          <source>Strings are represented by the type &lt;code&gt;String&lt;/code&gt;. Strings are immutable. Elements of a string are characters that can be accessed by the indexing operation: &lt;code&gt;s[i]&lt;/code&gt;. A string can be iterated over with a &lt;em&gt;for&lt;/em&gt;-loop:</source>
          <target state="translated">字符串由 &lt;code&gt;String&lt;/code&gt; 类型表示。字符串是不可变的。字符串的元素是可以通过索引操作 &lt;code&gt;s[i]&lt;/code&gt; 访问的字符。可以使用&lt;em&gt;for&lt;/em&gt; -loop 遍历字符串：</target>
        </trans-unit>
        <trans-unit id="6f7691f2e802476360e0176ca90e2968711fe093" translate="yes" xml:space="preserve">
          <source>Strings from C and how they look in Kotlin/Native</source>
          <target state="translated">来自C语言的字符串以及它们在Kotlin/Native中的表现。</target>
        </trans-unit>
        <trans-unit id="2684320b57a782ce0439d9845b025f4167f73160" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;AL&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的强双向字符类型 &quot;AL&quot;。</target>
        </trans-unit>
        <trans-unit id="8af8df666f0e8eca9822d09b9b728f2790d43a77" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;L&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的强双向字符类型 &quot;L&quot;。</target>
        </trans-unit>
        <trans-unit id="277bd06a9fb3591003f711495ac46fc89282f28e" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;LRE&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的强双向字符类型 &quot;LRE&quot;。</target>
        </trans-unit>
        <trans-unit id="f0a8c58716e90117a1fa5949bd4edff7bafc489d" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;LRO&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的强双向字符类型 &quot;LRO&quot;。</target>
        </trans-unit>
        <trans-unit id="5c434a125001d98e3d65585f819ed8840b4f8897" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;R&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的强双向字符类型 &quot;R&quot;。</target>
        </trans-unit>
        <trans-unit id="64ad0d6aedac34d34b627e0784d46dea64c2ff5a" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;RLE&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的强双向字符类型 &quot;RLE&quot;。</target>
        </trans-unit>
        <trans-unit id="1665148f18e9a39912a6a12baccd3148269f2320" translate="yes" xml:space="preserve">
          <source>Strong bidirectional character type &quot;RLO&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的强双向字符类型 &quot;RLO&quot;。</target>
        </trans-unit>
        <trans-unit id="f21f357479481b3172a23f12385bf19995dd2f48" translate="yes" xml:space="preserve">
          <source>Struct and Union types from C and how they look in Kotlin/Native</source>
          <target state="translated">来自C语言的Struct和Union类型,以及它们在Kotlin/Native中的表现。</target>
        </trans-unit>
        <trans-unit id="af5b40acf56f32ead50b7b4376e35475ae8821af" translate="yes" xml:space="preserve">
          <source>Structs / unions are mapped to types having fields available via the dot notation, i.e. &lt;code&gt;someStructInstance.field1&lt;/code&gt;.</source>
          <target state="translated">结构/联合被映射到具有可通过点表示法使用的字段（即 &lt;code&gt;someStructInstance.field1&lt;/code&gt; )的类型。</target>
        </trans-unit>
        <trans-unit id="024b6c74302356ab4e71438eaaf0b40da91567fc" translate="yes" xml:space="preserve">
          <source>Structural changes in the base list make the behavior of the view undefined.</source>
          <target state="translated">基础列表中的结构变化使得视图的行为无法定义。</target>
        </trans-unit>
        <trans-unit id="72d92fad333f84fb34170c273e339309112411ea" translate="yes" xml:space="preserve">
          <source>Structural equality</source>
          <target state="translated">结构性平等</target>
        </trans-unit>
        <trans-unit id="7d27109df9078a59c52f1f92f6addfe6d10368ae" translate="yes" xml:space="preserve">
          <source>Structural equality (a check for &lt;code&gt;equals()&lt;/code&gt;).</source>
          <target state="translated">结构相等（检查 &lt;code&gt;equals()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ece356b48420c60af23fc6b7ecae7a03ec149030" translate="yes" xml:space="preserve">
          <source>Structural equality comparisons are done with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, like in Python, but it's up to each class to define what that means, by &lt;a href=&quot;inheritance#overriding&quot;&gt;overriding&lt;/a&gt;&lt;a href=&quot;classes#inherited-built-in-functions&quot;&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/a&gt; (which will be called on the left operand with the right operand as the parameter) and &lt;code&gt;hashCode()&lt;/code&gt;. Most built-in collection types implement deep equality checks for these operators and functions. Reference comparisons - checking if two variables refer to the same object (the same as &lt;code&gt;is&lt;/code&gt; in Python) - are done with &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;.</source>
          <target state="translated">结构相等性比较是使用 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 完成的，就像在Python中一样，但是每个类都可以通过&lt;a href=&quot;inheritance#overriding&quot;&gt;覆盖&lt;/a&gt;&lt;a href=&quot;classes#inherited-built-in-functions&quot;&gt; &lt;code&gt;equals()&lt;/code&gt; &lt;/a&gt;来定义含义（由在左侧操作数上调用，以右侧操作数为参数）。和 &lt;code&gt;hashCode()&lt;/code&gt; 。大多数内置集合类型对这些运算符和函数执行深度相等检查。参考比较-检查，如果两个变量指向同一个对象（如同样 &lt;code&gt;is&lt;/code&gt; 在Python） -用完成 &lt;code&gt;===&lt;/code&gt; 和 &lt;code&gt;!==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b70b639ef5cff3c53b813230fbda1e132ca3cce" translate="yes" xml:space="preserve">
          <source>Structural equality has nothing to do with comparison defined by the &lt;code&gt;Comparable&amp;lt;...&amp;gt;&lt;/code&gt; interface, so only a custom &lt;code&gt;equals(Any?)&lt;/code&gt; implementation may affect the behavior of the operator.</source>
          <target state="translated">结构相等与 &lt;code&gt;Comparable&amp;lt;...&amp;gt;&lt;/code&gt; 接口定义的比较无关，因此仅自定义的 &lt;code&gt;equals(Any?)&lt;/code&gt; 实现可能会影响运算符的行为。</target>
        </trans-unit>
        <trans-unit id="b976e0b583b0412204edf019c0b11bd8b81727df" translate="yes" xml:space="preserve">
          <source>Structural equality is checked by the &lt;code&gt;==&lt;/code&gt; operation (and its negated counterpart &lt;code&gt;!=&lt;/code&gt;). By convention, an expression like &lt;code&gt;a == b&lt;/code&gt; is translated to:</source>
          <target state="translated">结构相等性由 &lt;code&gt;==&lt;/code&gt; 操作（及其否定的 &lt;code&gt;!=&lt;/code&gt; ）检查。按照约定，像 &lt;code&gt;a == b&lt;/code&gt; 这样的表达式将转换为：</target>
        </trans-unit>
        <trans-unit id="660ca66913fdaa764b314de4f4d616cb2af27fc3" translate="yes" xml:space="preserve">
          <source>Structured concurrency</source>
          <target state="translated">结构化并发</target>
        </trans-unit>
        <trans-unit id="688fd1f0d4f70b417561f286a2459a51d7a9bf8d" translate="yes" xml:space="preserve">
          <source>Structured concurrency with async</source>
          <target state="translated">结构化并发与异步</target>
        </trans-unit>
        <trans-unit id="ce867a84f68c1d0cd7e5d2e0a575c394cc078c03" translate="yes" xml:space="preserve">
          <source>StyleSheet</source>
          <target state="translated">StyleSheet</target>
        </trans-unit>
        <trans-unit id="105633f7a20c3c4e6cfe2fcb5bc3777e06065699" translate="yes" xml:space="preserve">
          <source>StyleSheetList</source>
          <target state="translated">StyleSheetList</target>
        </trans-unit>
        <trans-unit id="4eb481e8f0e6186576b990d8a8ee65c0bcaf3bd9" translate="yes" xml:space="preserve">
          <source>Subclasses of a class that implements an interface (in this case, &lt;code&gt;Car&lt;/code&gt;) are also considered to be implementing the interface.</source>
          <target state="translated">实现接口的类的子类（在本例中为 &lt;code&gt;Car&lt;/code&gt; ）也被视为正在实现接口。</target>
        </trans-unit>
        <trans-unit id="82494d5df2327066831b19fcbdbc11f57f406da0" translate="yes" xml:space="preserve">
          <source>Subclassing</source>
          <target state="translated">Subclassing</target>
        </trans-unit>
        <trans-unit id="5aa09d55ccae6bc284a9aaa4b931ff34243aae33" translate="yes" xml:space="preserve">
          <source>Subclassing Kotlin classes and interfaces from Swift/Objective-C</source>
          <target state="translated">从Swift/Objective-C中subclassing Kotlin类和接口。</target>
        </trans-unit>
        <trans-unit id="4c8bffd68e11c1e09416b7275b40472abdd31b0e" translate="yes" xml:space="preserve">
          <source>Subclassing Swift/Objective-C classes and protocols from Kotlin</source>
          <target state="translated">从Kotlin中子类化Swift/Objective-C类和协议。</target>
        </trans-unit>
        <trans-unit id="d8cfc0d2ff946e39f440d5850a833061ce441784" translate="yes" xml:space="preserve">
          <source>Subtracts the other Char value from this value resulting an Int.</source>
          <target state="translated">从这个值中减去其他Char值,得到一个Int值。</target>
        </trans-unit>
        <trans-unit id="f8fc787359f50113256ce34acd74e7ad27c2b7de" translate="yes" xml:space="preserve">
          <source>Subtracts the other Int value from this value resulting a Char.</source>
          <target state="translated">从这个值减去另一个Int值,得到一个Char。</target>
        </trans-unit>
        <trans-unit id="cd1dd0acae6df690f4f408b7810c6a68a77d2c65" translate="yes" xml:space="preserve">
          <source>Subtracts the other value from this value.</source>
          <target state="translated">从这个值中减去另一个值。</target>
        </trans-unit>
        <trans-unit id="d6b1220988da8e4820eca8338c62f95c8d54d502" translate="yes" xml:space="preserve">
          <source>Such &lt;em&gt;smart casts&lt;/em&gt; work for &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;em&gt;when&lt;/em&gt;-expressions&lt;/a&gt; and &lt;a href=&quot;control-flow#while-loops&quot;&gt;&lt;em&gt;while&lt;/em&gt;-loops&lt;/a&gt; as well:</source>
          <target state="translated">这样的&lt;em&gt;智能类型转换&lt;/em&gt;工作&lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;em&gt;时&lt;/em&gt; -expressions&lt;/a&gt;并&lt;a href=&quot;control-flow#while-loops&quot;&gt;&lt;em&gt;同时&lt;/em&gt; -loops&lt;/a&gt;还有：</target>
        </trans-unit>
        <trans-unit id="a6ca684a14efd3b57eb8a5d3ba3348ea50581bab" translate="yes" xml:space="preserve">
          <source>Such a chain returns &lt;em&gt;null&lt;/em&gt; if any of the properties in it is null.</source>
          <target state="translated">这样的链返回&lt;em&gt;空&lt;/em&gt;如果任何在它的属性是空的。</target>
        </trans-unit>
        <trans-unit id="7f52975c732e28d7449a1d2bd849f22d7254ffe5" translate="yes" xml:space="preserve">
          <source>Such a dependency can be included in a Podfile of an Xcode project and automatically built (and rebuilt) along with this project. As a result, importing to Xcode is simplified since there is no need to write corresponding Gradle tasks and Xcode build steps manually.</source>
          <target state="translated">这样的依赖关系可以被包含在Xcode项目的Podfile中,并与这个项目一起自动构建(和重建)。因此,导入到Xcode中的过程被简化了,因为不需要手动编写相应的Gradle任务和Xcode构建步骤。</target>
        </trans-unit>
        <trans-unit id="275498570896fad34600eda0578ce2760eeaa8db" translate="yes" xml:space="preserve">
          <source>Such annotation type should itself be annotated with both &lt;code&gt;@Nonnull&lt;/code&gt; (or its nickname) and &lt;code&gt;@TypeQualifierDefault(...)&lt;/code&gt; with one or more &lt;code&gt;ElementType&lt;/code&gt; values:</source>
          <target state="translated">此类注释类型本身应同时使用具有一个或多个 &lt;code&gt;ElementType&lt;/code&gt; 值的 &lt;code&gt;@Nonnull&lt;/code&gt; （或其昵称）和 &lt;code&gt;@TypeQualifierDefault(...)&lt;/code&gt; 进行注释：</target>
        </trans-unit>
        <trans-unit id="54a890751d7cb69dc2bb8082fffc6f90e74cda3e" translate="yes" xml:space="preserve">
          <source>Such common behaviours can be implemented as libraries using &lt;a href=&quot;delegated-properties&quot;&gt;&lt;em&gt;delegated properties&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;delegated-properties&quot;&gt;&lt;em&gt;委托属性&lt;/em&gt;&lt;/a&gt;将此类常见行为实现为库。</target>
        </trans-unit>
        <trans-unit id="71a7fa20221b612c2534c0cd56321d47af321a0e" translate="yes" xml:space="preserve">
          <source>Such objects can have supertypes:</source>
          <target state="translated">这种对象可以有超类型。</target>
        </trans-unit>
        <trans-unit id="70d2b2ed000c8ab8416a2925902564c1eda90b74" translate="yes" xml:space="preserve">
          <source>Such properties can be used in annotations:</source>
          <target state="translated">这种属性可以用在注释中。</target>
        </trans-unit>
        <trans-unit id="c1071ef3c60cf8dd3c256721ed0bebfd0d5200f8" translate="yes" xml:space="preserve">
          <source>Such returns (located in a lambda, but exiting the enclosing function) are called &lt;em&gt;non-local&lt;/em&gt; returns. We are used to this sort of construct in loops, which inline functions often enclose:</source>
          <target state="translated">这样的返回（位于lambda中，但退出封闭函数）称为&lt;em&gt;非本地&lt;/em&gt;返回。我们习惯于循环中的这种构造，内联函数通常包含以下内容：</target>
        </trans-unit>
        <trans-unit id="10e6aa90785a792cb60500d5818fa4c115ff47c4" translate="yes" xml:space="preserve">
          <source>Such syntax is also known as &lt;em&gt;trailing lambda&lt;/em&gt;.</source>
          <target state="translated">这种语法也称为&lt;em&gt;尾随lambda&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c8895d425ddb898eb0386c82032007c2c016e5af" translate="yes" xml:space="preserve">
          <source>Suffix to use for generated JavaScript files</source>
          <target state="translated">用于生成JavaScript文件的后缀</target>
        </trans-unit>
        <trans-unit id="f20596f60d75184baac457dd39dfe5dbb7c92170" translate="yes" xml:space="preserve">
          <source>Suggested documentation pages:</source>
          <target state="translated">建议的文件页:</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="efddb0d943663d3990ff15feb5144465e26709a1" translate="yes" xml:space="preserve">
          <source>Superclass for all platform classes representing numeric values.</source>
          <target state="translated">所有代表数值的平台类的超级类。</target>
        </trans-unit>
        <trans-unit id="d57120c39b452641752cec548eba58dfe0d997dc" translate="yes" xml:space="preserve">
          <source>Supervision</source>
          <target state="translated">Supervision</target>
        </trans-unit>
        <trans-unit id="e8ca95dbcc7178511d7c5a9727cb4e64cd2491c0" translate="yes" xml:space="preserve">
          <source>Supervision job</source>
          <target state="translated">监督工作</target>
        </trans-unit>
        <trans-unit id="b540bbae2b6598d9471d4e821a9a3c9f224811ce" translate="yes" xml:space="preserve">
          <source>Supervision scope</source>
          <target state="translated">监督范围</target>
        </trans-unit>
        <trans-unit id="44228bb9b805267096502663a9f60eebe9337369" translate="yes" xml:space="preserve">
          <source>Support for ::foo as a shorthand for this::foo</source>
          <target state="translated">支持将::foo作为this::foo的简写。</target>
        </trans-unit>
        <trans-unit id="34c6c2ddc426343eed559ce47d4c777df69eba0c" translate="yes" xml:space="preserve">
          <source>Supported platforms</source>
          <target state="translated">支持的平台</target>
        </trans-unit>
        <trans-unit id="9794d24ec85271049a86498f820c37d015564882" translate="yes" xml:space="preserve">
          <source>Supported types</source>
          <target state="translated">支持的类型</target>
        </trans-unit>
        <trans-unit id="93c79b3f7d0d1a76067ccba45bb58d73cfe3316b" translate="yes" xml:space="preserve">
          <source>Suppose there is a Java method that accepts an int array of indices:</source>
          <target state="translated">假设有一个Java方法可以接受一个int数组的索引。</target>
        </trans-unit>
        <trans-unit id="0ca1c820ac8164eb818371a319e5876b522328ee" translate="yes" xml:space="preserve">
          <source>Suppose we have a generic interface &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; that does not have any methods that take &lt;code&gt;T&lt;/code&gt; as a parameter, only methods that return &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">假设我们有一个通用接口 &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; ，它没有任何将 &lt;code&gt;T&lt;/code&gt; 作为参数的方法，只有返回 &lt;code&gt;T&lt;/code&gt; 的方法：</target>
        </trans-unit>
        <trans-unit id="d81855372fef77a8319ba3320877e631faefc705" translate="yes" xml:space="preserve">
          <source>Suppress</source>
          <target state="translated">Suppress</target>
        </trans-unit>
        <trans-unit id="f4bf603e39de5fe14652ee5e4d5bffe13ebca851" translate="yes" xml:space="preserve">
          <source>Suppresses all compilation warnings</source>
          <target state="translated">抑制所有的编译警告</target>
        </trans-unit>
        <trans-unit id="c08ada99a3ce33d336392fa9e2fcc77dd914f220" translate="yes" xml:space="preserve">
          <source>Suppresses errors about variance conflict</source>
          <target state="translated">抑制关于方差冲突的错误</target>
        </trans-unit>
        <trans-unit id="826a3782b77dd21352e84fb444cfe49b2d3d41ba" translate="yes" xml:space="preserve">
          <source>Suppresses the given compilation warnings in the annotated element.</source>
          <target state="translated">抑制注释元素中的编译警告。</target>
        </trans-unit>
        <trans-unit id="52d7c5ec374713f5f37d91138c052ccbb60ec732" translate="yes" xml:space="preserve">
          <source>Suspend functions are only allowed to be called from a coroutine or another suspend function</source>
          <target state="translated">暂停函数只允许从一个coroutine或另一个暂停函数中调用。</target>
        </trans-unit>
        <trans-unit id="ac8b279c6a3c1f3871f1125cc1498ab1f6a88def" translate="yes" xml:space="preserve">
          <source>SuspendFunction</source>
          <target state="translated">SuspendFunction</target>
        </trans-unit>
        <trans-unit id="ec4005f130005e7ee3fe9eb28e0b27154a02ee0d" translate="yes" xml:space="preserve">
          <source>Suspending functions</source>
          <target state="translated">暂停职能</target>
        </trans-unit>
        <trans-unit id="d52d9b4f1f762df95c3f2692f128dbd79352b8e8" translate="yes" xml:space="preserve">
          <source>Svetlana Isakova</source>
          <target state="translated">Svetlana Isakova</target>
        </trans-unit>
        <trans-unit id="e1b1187bdbb9c730f8014294b12fac3d0e7be01a" translate="yes" xml:space="preserve">
          <source>Swapping two variables</source>
          <target state="translated">交换两个变量</target>
        </trans-unit>
        <trans-unit id="112ab020698e5fc0f4baecd7821a512d8c419a69" translate="yes" xml:space="preserve">
          <source>Swift</source>
          <target state="translated">Swift</target>
        </trans-unit>
        <trans-unit id="11e426a93e6bdc30eee83310a54fe55623d59394" translate="yes" xml:space="preserve">
          <source>Swift/Objective-C classes and protocols can be subclassed with a Kotlin &lt;code&gt;final&lt;/code&gt; class. Non-&lt;code&gt;final&lt;/code&gt; Kotlin classes inheriting Swift/Objective-C types aren't supported yet, so it is not possible to declare a complex class hierarchy inheriting Swift/Objective-C types.</source>
          <target state="translated">Swift / Objective-C类和协议可以用Kotlin &lt;code&gt;final&lt;/code&gt; 类继承。目前尚不支持继承Swift / Objective-C类型的非 &lt;code&gt;final&lt;/code&gt; Kotlin类，因此无法声明继承Swift / Objective-C类型的复杂类层次结构。</target>
        </trans-unit>
        <trans-unit id="f62b613e64a0b39b8f91de500961ddd372e2c85a" translate="yes" xml:space="preserve">
          <source>Swift/Objective-C initializers are imported to Kotlin as constructors and factory methods named &lt;code&gt;create&lt;/code&gt;. The latter happens with initializers declared in the Objective-C category or as a Swift extension, because Kotlin has no concept of extension constructors.</source>
          <target state="translated">Swift / Objective-C初始化程序作为构造函数和名为 &lt;code&gt;create&lt;/code&gt; 的工厂方法导入Kotlin 。后者发生在Objective-C类别中声明的初始化程序或Swift扩展中，因为Kotlin没有扩展构造函数的概念。</target>
        </trans-unit>
        <trans-unit id="9d575759176a53333f2c52896d12c38987eec991" translate="yes" xml:space="preserve">
          <source>Swift/Objective-C interop</source>
          <target state="translated">Swift/Objective-C互操作</target>
        </trans-unit>
        <trans-unit id="99720ddc441c1bfb4d0affa1772914ca5ac04545" translate="yes" xml:space="preserve">
          <source>Switch over a channel of deferred values</source>
          <target state="translated">切换一个递延值的通道</target>
        </trans-unit>
        <trans-unit id="13fd4750b81466d157a12fc10d9a852e2caf99fa" translate="yes" xml:space="preserve">
          <source>Switch to the default formatting and make it consistent with Kotlin Coding Conventions in Kotlin 1.4</source>
          <target state="translated">切换到默认格式,并使其与Kotlin 1.4中的Kotlin编码约定一致。</target>
        </trans-unit>
        <trans-unit id="61aa80a32f7f719d3326e90ee95ac7477fe0603f" translate="yes" xml:space="preserve">
          <source>Switching to the Kotlin Coding Conventions code style can be done in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; dialog. Switch scheme to &lt;em&gt;Project&lt;/em&gt; and activate &lt;code&gt;Set from... &amp;rarr; Predefined Style &amp;rarr; Kotlin Style Guide&lt;/code&gt;.</source>
          <target state="translated">可以在 &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; 对话框中切换到Kotlin编码约定代码样式。将方案切换到&lt;em&gt;Project&lt;/em&gt;并 &lt;code&gt;Set from... &amp;rarr; Predefined Style &amp;rarr; Kotlin Style Guide&lt;/code&gt; 激活Set&amp;rarr;预定义样式&amp;rarr;Kotlin样式指南。</target>
        </trans-unit>
        <trans-unit id="ce89d26b5b915bdbefeba3e3c1002ad16cf04461" translate="yes" xml:space="preserve">
          <source>SymbolName</source>
          <target state="translated">SymbolName</target>
        </trans-unit>
        <trans-unit id="1c380083ceced1c7e8bbc5bd15ca13f7adc39f96" translate="yes" xml:space="preserve">
          <source>Symmetric: for any non-null values &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;x.equals(y)&lt;/code&gt; should return true if and only if &lt;code&gt;y.equals(x)&lt;/code&gt; returns true.</source>
          <target state="translated">对称：对于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的任何非空值，当且仅当 &lt;code&gt;y.equals(x)&lt;/code&gt; 返回true时， &lt;code&gt;x.equals(y)&lt;/code&gt; 才返回true。</target>
        </trans-unit>
        <trans-unit id="c195e4374c85d74cc43f4f08a33d51e3c51b4cfd" translate="yes" xml:space="preserve">
          <source>Synchronized</source>
          <target state="translated">Synchronized</target>
        </trans-unit>
        <trans-unit id="60526f7fe57071fddf6bf31004eca244e13fd625" translate="yes" xml:space="preserve">
          <source>Synthetic targets become inaccessible for Java sources at compile time while still being accessible for Kotlin sources. Marking target as synthetic is a binary compatible change, already compiled Java code will be able to access such target.</source>
          <target state="translated">合成目标在编译时对Java源无法访问,但对Kotlin源仍可访问。将目标标记为合成目标是一个二进制兼容的变化,已经编译的Java代码将能够访问这样的目标。</target>
        </trans-unit>
        <trans-unit id="8426ac9483ef9329287d13cda6dbc5c5b8457b87" translate="yes" xml:space="preserve">
          <source>System-related utility functions.</source>
          <target state="translated">系统相关的实用功能。</target>
        </trans-unit>
        <trans-unit id="7acd3724fef694b5c77a8242b8933516bfe3f06a" translate="yes" xml:space="preserve">
          <source>TERMINATE</source>
          <target state="translated">TERMINATE</target>
        </trans-unit>
        <trans-unit id="c2024afdc51720a7b9f26bd798eeb6515dee141f" translate="yes" xml:space="preserve">
          <source>THROWN</source>
          <target state="translated">THROWN</target>
        </trans-unit>
        <trans-unit id="aec59fbfc2f6181875490fd78c020230f3b1b1f7" translate="yes" xml:space="preserve">
          <source>TITLECASE_LETTER</source>
          <target state="translated">TITLECASE_LETTER</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="3a36be7757d53df34ffbc16215cd6f9cfdd93b80" translate="yes" xml:space="preserve">
          <source>TODO: changing symbol name breaks the binary compatibility, so it should probably be allowed on &lt;code&gt;internal&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; functions only.</source>
          <target state="translated">TODO：更改符号名称会破坏二进制兼容性，因此可能只应在 &lt;code&gt;internal&lt;/code&gt; 函数和 &lt;code&gt;private&lt;/code&gt; 函数上允许它。</target>
        </trans-unit>
        <trans-unit id="f3830d7277fcff42c992ea836b9ff28598687e08" translate="yes" xml:space="preserve">
          <source>TODO: consider providing an adapter instead of subtyping &lt;a href=&quot;../-c-values/index&quot;&gt;CValues&lt;/a&gt;.</source>
          <target state="translated">待办事项：考虑提供适配器而不是对&lt;a href=&quot;../-c-values/index&quot;&gt;CValues&lt;/a&gt;进行子类型化。</target>
        </trans-unit>
        <trans-unit id="40b96366fe4fb7eb04dbdc7b2c5d704e03c38057" translate="yes" xml:space="preserve">
          <source>TODO: the behavior of &lt;a href=&quot;../../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;, &lt;a href=&quot;../../kotlin/-any/hash-code#kotlin.Any%24hashCode%28%29&quot;&gt;hashCode&lt;/a&gt; and &lt;a href=&quot;../../kotlin/-any/to-string#kotlin.Any%24toString%28%29&quot;&gt;toString&lt;/a&gt; differs on Native and JVM backends.</source>
          <target state="translated">TODO：&lt;a href=&quot;../../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;，&lt;a href=&quot;../../kotlin/-any/hash-code#kotlin.Any%24hashCode%28%29&quot;&gt;hashCode&lt;/a&gt;和&lt;a href=&quot;../../kotlin/-any/to-string#kotlin.Any%24toString%28%29&quot;&gt;toString&lt;/a&gt;的行为在本机和JVM后端上有所不同。</target>
        </trans-unit>
        <trans-unit id="aa57ca5da1542535d6e595c72a1049dfaa72214c" translate="yes" xml:space="preserve">
          <source>TOP_DOWN</source>
          <target state="translated">TOP_DOWN</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="4f8e3ef2be07081eed30f4f241b8f6079253452d" translate="yes" xml:space="preserve">
          <source>TYPEALIAS</source>
          <target state="translated">TYPEALIAS</target>
        </trans-unit>
        <trans-unit id="74c2ff3e02a8146aa670c1188095f748d0498a87" translate="yes" xml:space="preserve">
          <source>TYPE_PARAMETER</source>
          <target state="translated">TYPE_PARAMETER</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="321de0ab2873c1406451b4e621fed413b6b2ab1e" translate="yes" xml:space="preserve">
          <source>Tail recursive functions</source>
          <target state="translated">尾部递归函数</target>
        </trans-unit>
        <trans-unit id="20fa48deb639df41368610d6983f2e95bc62d9b3" translate="yes" xml:space="preserve">
          <source>Take a look at the behavior of the following code:</source>
          <target state="translated">看看以下代码的行为。</target>
        </trans-unit>
        <trans-unit id="a34ab8557ec6518d7eec439be4e5bcf534a63994" translate="yes" xml:space="preserve">
          <source>Take and drop</source>
          <target state="translated">取放</target>
        </trans-unit>
        <trans-unit id="1bbdcf12e57848561b81b3650e41362a19702c6a" translate="yes" xml:space="preserve">
          <source>Take for instance the following code</source>
          <target state="translated">以下面的代码为例</target>
        </trans-unit>
        <trans-unit id="ffc4d467faa7814fe0541133e507fd8deafa41f3" translate="yes" xml:space="preserve">
          <source>Taking the above into account, given the following code (module name is &lt;code&gt;ConsoleOutput&lt;/code&gt;)</source>
          <target state="translated">考虑到上述情况，给出以下代码（模块名称为 &lt;code&gt;ConsoleOutput&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="e9c2cc44a1648fab93dfd7f8478951978cee81a6" translate="yes" xml:space="preserve">
          <source>Target Platforms</source>
          <target state="translated">目标平台</target>
        </trans-unit>
        <trans-unit id="2c6651b7aa08a8550dea113571107b0c864ada23" translate="yes" xml:space="preserve">
          <source>Target platform/device</source>
          <target state="translated">目标平台/设备</target>
        </trans-unit>
        <trans-unit id="77c4c4b87221968bd3a3894fe9c81710e28b33b7" translate="yes" xml:space="preserve">
          <source>Target version of the generated JVM bytecode</source>
          <target state="translated">生成的JVM字节码的目标版本。</target>
        </trans-unit>
        <trans-unit id="b55ed86e9766080d6e500a070b6fef6b1986cd3f" translate="yes" xml:space="preserve">
          <source>Target version of the generated JVM bytecode (1.6, 1.8, 9, 10, 11 or 12), default is 1.6</source>
          <target state="translated">生成的JVM字节码的目标版本(1.6、1.8、9、10、11或12),默认为1.6。</target>
        </trans-unit>
        <trans-unit id="b9f79302140e02579ecf20feab5f4ed0599b5178" translate="yes" xml:space="preserve">
          <source>Target-specific options, only applicable to the certain target can be specified as well, such as</source>
          <target state="translated">也可以指定特定目标的选项,只适用于特定目标,如</target>
        </trans-unit>
        <trans-unit id="fbb726beab60fbd5d494b96dfab27818ba4ef792" translate="yes" xml:space="preserve">
          <source>Targeting Android</source>
          <target state="translated">针对Android</target>
        </trans-unit>
        <trans-unit id="61435c5519fdf6e83f5be2de5ba7d3189d1e59db" translate="yes" xml:space="preserve">
          <source>Targeting JVM with Kotlin and Java source</source>
          <target state="translated">用Kotlin和Java源码瞄准JVM。</target>
        </trans-unit>
        <trans-unit id="eed4cc7b25a381102c782f5eee23b1557b5da0f0" translate="yes" xml:space="preserve">
          <source>Targeting JVM with Kotlin-only source</source>
          <target state="translated">用仅有Kotlin的源码瞄准JVM</target>
        </trans-unit>
        <trans-unit id="6be3f820f9efacb8a325c313968a6aa3ca133310" translate="yes" xml:space="preserve">
          <source>Targeting JVM with Kotlin-only source and multiple roots</source>
          <target state="translated">针对只使用Kotlin的源码和多个根的JVM。</target>
        </trans-unit>
        <trans-unit id="2426095a82998267d53648372ee8cb2c93e603c9" translate="yes" xml:space="preserve">
          <source>Targeting JavaScript</source>
          <target state="translated">针对JavaScript</target>
        </trans-unit>
        <trans-unit id="7e517a21f1ce2b40c420e67981cb82c90d901d12" translate="yes" xml:space="preserve">
          <source>Targeting JavaScript with Prefix, PostFix and sourcemap options</source>
          <target state="translated">使用前缀、后缀和源码图选项来定位JavaScript。</target>
        </trans-unit>
        <trans-unit id="af5e0c13bd0213a07d67ab13adf84941ec88763a" translate="yes" xml:space="preserve">
          <source>Targeting JavaScript with single source folder</source>
          <target state="translated">以单一源文件夹为目标的JavaScript</target>
        </trans-unit>
        <trans-unit id="f36e6891c319487c20f8187b941dcf72379e553c" translate="yes" xml:space="preserve">
          <source>Targeting JavaScript with single source folder and metaInfo option</source>
          <target state="translated">使用单一源文件夹和metaInfo选项锁定JavaScript。</target>
        </trans-unit>
        <trans-unit id="9057192fad6052cc02e53869d22c36d08b376824" translate="yes" xml:space="preserve">
          <source>Targeting the JVM</source>
          <target state="translated">针对JVM</target>
        </trans-unit>
        <trans-unit id="52408046d668e5c8da292f381cd0a5534e2e8a07" translate="yes" xml:space="preserve">
          <source>Targets (e.g. Linux/x64 or iOS/arm64 etc)</source>
          <target state="translated">目标(如Linux/x64或iOS/arm64等)</target>
        </trans-unit>
        <trans-unit id="837e53257b3eec566bea2e67012cd4dadfb5bb32" translate="yes" xml:space="preserve">
          <source>Targets and output kinds</source>
          <target state="translated">目标和产出种类</target>
        </trans-unit>
        <trans-unit id="816c9fefceb8b2eba75d842698c8c325c361d2dc" translate="yes" xml:space="preserve">
          <source>Targets can be specified by setting a corresponding component property:</source>
          <target state="translated">可以通过设置相应的组件属性来指定目标。</target>
        </trans-unit>
        <trans-unit id="ccd64eb3b2ae68576bc374a9f76f6dafc19a16b7" translate="yes" xml:space="preserve">
          <source>Teaching Kotlin with EduTools plugin</source>
          <target state="translated">使用EduTools插件教学Kotlin。</target>
        </trans-unit>
        <trans-unit id="107721a9ab514d4563cc6535734a7356bb7e6b23" translate="yes" xml:space="preserve">
          <source>Technically, there is no difference between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types on the Kotlin side. We should note, that &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; properties of &lt;code&gt;MyUnion&lt;/code&gt; class in Kotlin use the same memory location to read/write their value just like &lt;code&gt;union&lt;/code&gt; does in C language.</source>
          <target state="translated">从技术上讲，在Kotlin方面， &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 类型之间没有区别。我们应该注意，Kotlin 中 &lt;code&gt;MyUnion&lt;/code&gt; 类的 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 属性使用相同的内存位置来读取/写入它们的值，就像 &lt;code&gt;union&lt;/code&gt; 在C语言中一样。</target>
        </trans-unit>
        <trans-unit id="1d53818b29193f314641d3739f638d9be2e9e5f4" translate="yes" xml:space="preserve">
          <source>Templates are supported both inside raw strings and inside escaped strings. If you need to represent a literal &lt;code&gt;$&lt;/code&gt; character in a raw string (which doesn't support backslash escaping), you can use the following syntax:</source>
          <target state="translated">原始字符串和转义字符串中均支持模板。如果需要在原始字符串中表示原义的 &lt;code&gt;$&lt;/code&gt; 字符（不支持反斜杠转义），则可以使用以下语法：</target>
        </trans-unit>
        <trans-unit id="8761082f68b3e6705f4c38bb348056fcdd9cb6dd" translate="yes" xml:space="preserve">
          <source>Terminate the evaluation of the function.</source>
          <target state="translated">终止函数的评估。</target>
        </trans-unit>
        <trans-unit id="bd3961165a74d22116abf8cd7dfd89e1e128faab" translate="yes" xml:space="preserve">
          <source>Terminates the currently running process.</source>
          <target state="translated">终止当前正在运行的进程。</target>
        </trans-unit>
        <trans-unit id="4640b3677ae305cdd783f2fb2cb28eef6cd34e00" translate="yes" xml:space="preserve">
          <source>Ternary-operator &lt;code&gt;a ? b : c&lt;/code&gt;</source>
          <target state="translated">三元运算符 &lt;code&gt;a ? b : c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="d3b8064c2d7f14d3be517a2dd8d759b095d75329" translate="yes" xml:space="preserve">
          <source>Testing predicates</source>
          <target state="translated">测试谓词</target>
        </trans-unit>
        <trans-unit id="082fdf5c87614574580fe601c26048e8b6285351" translate="yes" xml:space="preserve">
          <source>TexImageSource</source>
          <target state="translated">TexImageSource</target>
        </trans-unit>
        <trans-unit id="06d4a26dfeb6fe515c1bd30f6921c66e729ad5b4" translate="yes" xml:space="preserve">
          <source>TextMetrics</source>
          <target state="translated">TextMetrics</target>
        </trans-unit>
        <trans-unit id="0c0a3e3c79ed645faf27df5d40c7372e38f10e27" translate="yes" xml:space="preserve">
          <source>TextTrackCueList</source>
          <target state="translated">TextTrackCueList</target>
        </trans-unit>
        <trans-unit id="86fb1c4a335a80c40bdf3e5b1a2aadd5059a2ca7" translate="yes" xml:space="preserve">
          <source>TextTrackKind</source>
          <target state="translated">TextTrackKind</target>
        </trans-unit>
        <trans-unit id="12de6f114f3e1a86a095e86dfa5c8b68ba37ba4b" translate="yes" xml:space="preserve">
          <source>TextTrackMode</source>
          <target state="translated">TextTrackMode</target>
        </trans-unit>
        <trans-unit id="7878af5e1d970e3132e8a0a88487c501b01c97e2" translate="yes" xml:space="preserve">
          <source>That gives you a way to express queries via C#-like LINQ syntax, use lambdas to write much simpler code for asynchronous computations, and more. Read all the details &lt;a href=&quot;https://agrosner.gitbooks.io/dbflow/content/KotlinSupport.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">这为您提供了一种通过类似于C＃的LINQ语法表达查询，使用lambda编写用于异步计算的简单得多的代码等方法。在&lt;a href=&quot;https://agrosner.gitbooks.io/dbflow/content/KotlinSupport.html&quot;&gt;这里&lt;/a&gt;阅读所有详细信息。</target>
        </trans-unit>
        <trans-unit id="0edd9421fb5e5aa8cfee7f829a8302f1e02b82ec" translate="yes" xml:space="preserve">
          <source>That is because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt; is a special &lt;em&gt;suspending function&lt;/em&gt; that does not block a thread, but &lt;em&gt;suspends&lt;/em&gt; coroutine and it can be only used from a coroutine.</source>
          <target state="translated">那是因为&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;是一个特殊的&lt;em&gt;挂起函数&lt;/em&gt;，它不会阻塞线程，而是&lt;em&gt;挂起&lt;/em&gt;协程，并且只能在协程中使用。</target>
        </trans-unit>
        <trans-unit id="5f1552ede00e5eac7ce32f87adbb1ebbd118c506" translate="yes" xml:space="preserve">
          <source>That is the common part. The code to generate the final message. It &lt;code&gt;expect&lt;/code&gt;s the platform to provide the platform name from the &lt;code&gt;expect fun platformName(): String&lt;/code&gt; function. We will use the &lt;code&gt;createApplicationScreenMessage&lt;/code&gt; from both Android and iOS applications.</source>
          <target state="translated">那是普通的部分。生成最终消息的代码。它 &lt;code&gt;expect&lt;/code&gt; 平台从 &lt;code&gt;expect fun platformName(): String&lt;/code&gt; 的平台名称（）：String函数提供平台名称。我们将同时使用Android和iOS应用程序中的 &lt;code&gt;createApplicationScreenMessage&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bc4829125d0242560af4ed1db4d6bbd3c58404a" translate="yes" xml:space="preserve">
          <source>That was easy, but maybe we'd want to do lazy-loading so that we won't spend time on extracting the fields that won't be used (especially if some of them contain a lot of data in a format that it is time-consuming to parse), and maybe we'd like support for default values. While we could implement that logic in a &lt;code&gt;get()&lt;/code&gt; block, it would need to be duplicated in every property. Alternatively, we could implement the logic in a separate &lt;code&gt;StringProperty&lt;/code&gt; class (note that this simple example is not thread-safe):</source>
          <target state="translated">这很容易，但是也许我们想进行延迟加载，这样我们就不会花时间来提取不会使用的字段（特别是如果其中一些包含很多数据的格式是解析非常耗时），也许我们希望支持默认值。尽管我们可以在 &lt;code&gt;get()&lt;/code&gt; 块中实现该逻辑，但需要在每个属性中复制该逻辑。另外，我们可以在单独的 &lt;code&gt;StringProperty&lt;/code&gt; 类中实现逻辑（请注意，此简单示例不是线程安全的）：</target>
        </trans-unit>
        <trans-unit id="7c754aa21a3405ebaf37834b83155abdf27ac763" translate="yes" xml:space="preserve">
          <source>That will force the Objc header to mark &lt;code&gt;myVal&lt;/code&gt; as non-null.</source>
          <target state="translated">这将强制Objc标头将 &lt;code&gt;myVal&lt;/code&gt; 标记为非null。</target>
        </trans-unit>
        <trans-unit id="0f4622a697b62b60beae07bb6cb2be3136a91e3c" translate="yes" xml:space="preserve">
          <source>That's all! Note that &lt;code&gt;kapt&lt;/code&gt; takes care of your Java files as well, so you don't need to keep the &lt;code&gt;annotationProcessor&lt;/code&gt; dependency.</source>
          <target state="translated">就这样！请注意， &lt;code&gt;kapt&lt;/code&gt; 还可以处理您的Java文件，因此您无需保留 &lt;code&gt;annotationProcessor&lt;/code&gt; 处理器依赖项。</target>
        </trans-unit>
        <trans-unit id="24349cf6cc7cf7f9b384531cea8b8f5b11489c77" translate="yes" xml:space="preserve">
          <source>That's how you add the plugin in Gradle:</source>
          <target state="translated">这就是你在Gradle中添加插件的方法。</target>
        </trans-unit>
        <trans-unit id="736d96c876d3629aa01920322b964b507fdb9a3c" translate="yes" xml:space="preserve">
          <source>That's it, we are good to go and write code under &lt;code&gt;src/main/kotlin&lt;/code&gt;.</source>
          <target state="translated">就是这样，我们很高兴在 &lt;code&gt;src/main/kotlin&lt;/code&gt; 下编写代码。</target>
        </trans-unit>
        <trans-unit id="b79f3592a2bc46aa2f1d8a2fe0f2f1a3ad0a665d" translate="yes" xml:space="preserve">
          <source>That's why the actual signature of &lt;code&gt;addAll()&lt;/code&gt; is the following:</source>
          <target state="translated">这就是为什么 &lt;code&gt;addAll()&lt;/code&gt; 的实际签名如下：</target>
        </trans-unit>
        <trans-unit id="5cebaf2e4c811fba9f733598c7e0ab2cbbdabb01" translate="yes" xml:space="preserve">
          <source>That's why we have the following migration plan instead:</source>
          <target state="translated">所以我们有以下的迁移计划代替。</target>
        </trans-unit>
        <trans-unit id="ed972239c05a1ce2160c2bcfca2e4a8ef0e2db12" translate="yes" xml:space="preserve">
          <source>The &quot;ping&quot; coroutine is started first, so it is the first one to receive the ball. Even though &quot;ping&quot; coroutine immediately starts receiving the ball again after sending it back to the table, the ball gets received by the &quot;pong&quot; coroutine, because it was already waiting for it:</source>
          <target state="translated">ping &quot;coroutine首先被启动,所以它是第一个接收球的。尽管 &quot;ping &quot;程序在将球送回桌面后又立即开始接收球,但由于 &quot;pong &quot;程序已经在等待,所以球被 &quot;pong &quot;程序接收。</target>
        </trans-unit>
        <trans-unit id="c7440a8c30ab97822c9d77fe495203fe0ef8e721" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;manual&amp;rdquo; workaround is to store the values of sub-expressions with control flow in variables, instead of evaluating them directly inside the call arguments. It&amp;rsquo;s similar to &lt;code&gt;-Xnormalize-constructor-calls=enable&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo;手动&amp;rdquo;解决方法是将具有控制流的子表达式的值存储在变量中，而不是直接在调用参数中对其求值。它类似于 &lt;code&gt;-Xnormalize-constructor-calls=enable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2dac38fb13b33ed15d5a221ea9b31acee5a3f83" translate="yes" xml:space="preserve">
          <source>The (complete) C data type.</source>
          <target state="translated">(完整的)C数据类型。</target>
        </trans-unit>
        <trans-unit id="d40e2aa06e1f3081a9ba55e866548f768b24f0de" translate="yes" xml:space="preserve">
          <source>The (possibly empty) sequence of immutable C values. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">不可变的C值序列(可能是空的)。它是自足的,不依赖于本地内存。</target>
        </trans-unit>
        <trans-unit id="7b6a69c655f68801070a7ea7a1009ee4bf0a261f" translate="yes" xml:space="preserve">
          <source>The 64-bit Android Native target require a Linux or macOS host. The 32-bit Android Native target can be built on any supported host.</source>
          <target state="translated">64位Android Native目标需要Linux或macOS主机。32位Android Native目标可以在任何支持的主机上构建。</target>
        </trans-unit>
        <trans-unit id="025e0471d3315a226930949e631a17bb911bf9c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#configuring-source-sets&quot;&gt;source sets&lt;/a&gt; and their &lt;a href=&quot;#adding-dependencies&quot;&gt;dependencies&lt;/a&gt; are then configured as follows:</source>
          <target state="translated">在&lt;a href=&quot;#configuring-source-sets&quot;&gt;源集&lt;/a&gt;和它们的&lt;a href=&quot;#adding-dependencies&quot;&gt;依赖关系&lt;/a&gt;，然后配置如下：</target>
        </trans-unit>
        <trans-unit id="587688423378c35c59750f8053e3e7120acd7a77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;-c-pointed/index&quot;&gt;CPointed&lt;/a&gt; without any specified interpretation.</source>
          <target state="translated">没有指定解释的&lt;a href=&quot;-c-pointed/index&quot;&gt;CPointed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6d7555b1e73df12c61cc2d2ea015a73f43aed2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../-c-pointed/index&quot;&gt;CPointed&lt;/a&gt; without any specified interpretation.</source>
          <target state="translated">没有指定解释的&lt;a href=&quot;../-c-pointed/index&quot;&gt;CPointed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e54545b48334a1124feb75af3b7057b37b313a69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus-assign&quot;&gt;&lt;code&gt;minusAssign&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-=&lt;/code&gt;) operator is also available for mutable maps.</source>
          <target state="translated">该&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus-assign&quot;&gt; &lt;code&gt;minusAssign&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;-=&lt;/code&gt; ）运算符也可用于可变地图。</target>
        </trans-unit>
        <trans-unit id="4ff365b4410b0b6619038682a29eefb850097313" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-dsl-marker/index&quot;&gt;&lt;code&gt;@DslMarker&lt;/code&gt;&lt;/a&gt; annotation allows to restrict the use of receivers from outer scopes in a DSL context. Consider the canonical &lt;a href=&quot;type-safe-builders&quot;&gt;HTML builder example&lt;/a&gt;:</source>
          <target state="translated">所述&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-dsl-marker/index&quot;&gt; &lt;code&gt;@DslMarker&lt;/code&gt; &lt;/a&gt;注释允许限制在DSL背景下使用的接收器从外部范围。考虑规范的&lt;a href=&quot;type-safe-builders&quot;&gt;HTML构建器示例&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0ed846a235f919618387ac6874100bd335e7cf20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop documentation&lt;/a&gt; documentation covers more advanced scenarios of the interop.</source>
          <target state="translated">该&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;&amp;ccedil;互操作性文档&lt;/a&gt;文件覆盖互操作的更高级的情景。</target>
        </trans-unit>
        <trans-unit id="1b6d8c3337d9451276257f3dd3c6b569bd207944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../tutorials/httpservlets&quot;&gt;Creating Web Applications with Http Servlets&lt;/a&gt; and &lt;a href=&quot;../tutorials/spring-boot-restful&quot;&gt;Creating a RESTful Web Service with Spring Boot&lt;/a&gt; tutorials show you how you can build and run very small Web applications in Kotlin.</source>
          <target state="translated">在&lt;a href=&quot;../tutorials/httpservlets&quot;&gt;创建Web应用程序使用HTTP Servlet的&lt;/a&gt;，并&lt;a href=&quot;../tutorials/spring-boot-restful&quot;&gt;与Spring启动创建一个RESTful Web服务&lt;/a&gt;教程向您展示如何构建和运行科特林非常小的Web应用程序。</target>
        </trans-unit>
        <trans-unit id="370b9ddcfe0daa7a4e64218bc3548eec2e892b70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;building-mpp-with-gradle#adding-dependencies&quot;&gt;dependencies configuration&lt;/a&gt; has been changed; dependencies are now specified separately for each source root.</source>
          <target state="translated">的&lt;a href=&quot;building-mpp-with-gradle#adding-dependencies&quot;&gt;依赖关系的配置&lt;/a&gt;已经被改变; 现在分别为每个源根指定依赖项。</target>
        </trans-unit>
        <trans-unit id="269230aa3731ce52c181b4cdd4ea09cfe0397b67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;down-to#kotlin.ranges%24downTo%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt; value should be less than or equal to &lt;code&gt;this&lt;/code&gt; value. If the &lt;a href=&quot;down-to#kotlin.ranges%24downTo%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt; value is greater than &lt;code&gt;this&lt;/code&gt; value the returned progression is empty.</source>
          <target state="translated">的&lt;a href=&quot;down-to#kotlin.ranges%24downTo%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;到&lt;/a&gt;的值应小于或等于 &lt;code&gt;this&lt;/code&gt; 值。如果&lt;a href=&quot;down-to#kotlin.ranges%24downTo%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt;值大 &lt;code&gt;this&lt;/code&gt; 值，则返回的进度为空。</target>
        </trans-unit>
        <trans-unit id="742e049bae3776c4fe6fe85ca2d3d815ec2c3864" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;group-by-to#kotlin.sequences%24groupByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.groupByTo.T%29%29%2C+kotlin.sequences.groupByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">该&lt;a href=&quot;group-by-to#kotlin.sequences%24groupByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.groupByTo.T%29%29%2C+kotlin.sequences.groupByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.K%29%29%29%2Fdestination&quot;&gt;目的地&lt;/a&gt;的地图。</target>
        </trans-unit>
        <trans-unit id="c384276c1494f8a4d389142695a22613ee5962a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;group-by-to#kotlin.sequences%24groupByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.groupByTo.T%29%29%2C+kotlin.sequences.groupByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">该&lt;a href=&quot;group-by-to#kotlin.sequences%24groupByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.groupByTo.T%29%29%2C+kotlin.sequences.groupByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.groupByTo.T%2C+kotlin.sequences.groupByTo.V%29%29%29%2Fdestination&quot;&gt;目的地&lt;/a&gt;的地图。</target>
        </trans-unit>
        <trans-unit id="c60c5bfb4e99d5eeb15d99db1ac41367610d72e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.github.com/kotlin/kotlinx.html&quot;&gt;kotlinx.html library&lt;/a&gt; provides the ability to generate DOM using statically typed HTML builders. The library is available when targeting the JVM as well as JavaScript. To use the library we need to include the corresponding dependency. In the case of Gradle this would be</source>
          <target state="translated">该&lt;a href=&quot;http://www.github.com/kotlin/kotlinx.html&quot;&gt;kotlinx.html库&lt;/a&gt;提供了使用静态类型的HTML建设者产生DOM的能力。针对JVM和JavaScript时，该库可用。要使用该库，我们需要包括相应的依赖项。在Gradle的情况下，这将是</target>
        </trans-unit>
        <trans-unit id="11ff0e8cd4fdb0fd27629f6a7e687a0b18080e1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt;&lt;code&gt;@Nonnull&lt;/code&gt;&lt;/a&gt; annotation defined in &lt;a href=&quot;https://jcp.org/en/jsr/detail?id=305&quot;&gt;JSR-305&lt;/a&gt; is supported for denoting nullability of Java types.</source>
          <target state="translated">支持&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=305&quot;&gt;JSR-305中&lt;/a&gt;定义的&lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt; &lt;code&gt;@Nonnull&lt;/code&gt; &lt;/a&gt;批注，以表示Java类型的可空性。</target>
        </trans-unit>
        <trans-unit id="a931a42af218b74ddfa5646228c068094e9e0035" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding Library&lt;/a&gt; allows you to bind your application data to the layouts in a concise way.</source>
          <target state="translated">将&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;数据绑定库&lt;/a&gt;允许您将应用程序数据绑定到一个简洁的方式布局。</target>
        </trans-unit>
        <trans-unit id="a2b7c849d9b50965b814a88b2bb1cbbfb44ead82" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Delegation_pattern&quot;&gt;Delegation pattern&lt;/a&gt; has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code. A class &lt;code&gt;Derived&lt;/code&gt; can implement an interface &lt;code&gt;Base&lt;/code&gt; by delegating all of its public members to a specified object:</source>
          <target state="translated">该&lt;a href=&quot;https://en.wikipedia.org/wiki/Delegation_pattern&quot;&gt;代表团模式&lt;/a&gt;已被证明是一个很好的选择，以实现继承，而科特林支持它本身不需要进行任何样板代码。 &lt;code&gt;Derived&lt;/code&gt; 类可以通过将其所有公共成员委托给指定的对象来实现 &lt;code&gt;Base&lt;/code&gt; 接口：</target>
        </trans-unit>
        <trans-unit id="89d682e482c895868a37ff624bc3eb18d04bf269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop documentation&lt;/a&gt; documentation covers more advanced scenarios of the interop</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;&amp;ccedil;互操作性文档&lt;/a&gt;文件覆盖互操作的更高级的方案</target>
        </trans-unit>
        <trans-unit id="1238852d879c2d710110f6784edd1cb93433787e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop documentation&lt;/a&gt; documentation covers more advanced scenarios of the interop.</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;&amp;ccedil;互操作性文档&lt;/a&gt;文件覆盖互操作的更高级的情景。</target>
        </trans-unit>
        <trans-unit id="ed3b8b8f640f1bc7c5c2be4b375d8acbd62a9be8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; clause in &lt;code&gt;select&lt;/code&gt; fails when the channel is closed causing the corresponding &lt;code&gt;select&lt;/code&gt; to throw an exception. We can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; clause to perform a specific action when the channel is closed. The following example also shows that &lt;code&gt;select&lt;/code&gt; is an expression that returns the result of its selected clause:</source>
          <target state="translated">当通道关闭时， &lt;code&gt;select&lt;/code&gt; 中的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt;子句失败，导致相应的 &lt;code&gt;select&lt;/code&gt; 引发异常。当通道关闭时，我们可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;子句执行特定的操作。以下示例还显示 &lt;code&gt;select&lt;/code&gt; 是一个返回其selected子句结果的表达式：</target>
        </trans-unit>
        <trans-unit id="567140fae1a9d885e6f93737a3b69b522b5149e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html&quot;&gt;Dispatchers.Unconfined&lt;/a&gt; coroutine dispatcher starts coroutine in the caller thread, but only until the first suspension point. After suspension it resumes in the thread that is fully determined by the suspending function that was invoked. Unconfined dispatcher is appropriate when coroutine does not consume CPU time nor updates any shared data (like UI) that is confined to a specific thread.</source>
          <target state="translated">该&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html&quot;&gt;Dispatchers.Unconfined&lt;/a&gt;协程调度员开始协程在调用线程，但直到第一个悬挂点。挂起后，它会在由调用的挂起函数完全确定的线程中恢复。当协程既不占用CPU时间也不更新限于特定线程的任何共享数据（如UI）时，无限制调度程序是合适的。</target>
        </trans-unit>
        <trans-unit id="97cb445124dce985503ca787c74149658f56ba41" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://kotlinlang.org/api/latest/kotlin.test/index.html&quot;&gt;&lt;code&gt;kotlin.test&lt;/code&gt; API&lt;/a&gt; is availble for multiplatform tests. Add the &lt;code&gt;kotlin-test-common&lt;/code&gt; and &lt;code&gt;kotlin-test-annotations-common&lt;/code&gt; dependencies to &lt;code&gt;commonTest&lt;/code&gt; to use the assertion functions like &lt;code&gt;kotlin.test.assertTrue(...)&lt;/code&gt;</source>
          <target state="translated">该&lt;a href=&quot;https://kotlinlang.org/api/latest/kotlin.test/index.html&quot;&gt; &lt;code&gt;kotlin.test&lt;/code&gt; API&lt;/a&gt;是availble的多平台测试。将 &lt;code&gt;kotlin-test-common&lt;/code&gt; 和 &lt;code&gt;kotlin-test-annotations-common&lt;/code&gt; 依赖项添加到 &lt;code&gt;commonTest&lt;/code&gt; 以使用诸如 &lt;code&gt;kotlin.test.assertTrue(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf9a347ca7004344d61319e9e4d5bb8c2e75274c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://ktor.io/&quot;&gt;Ktor framework&lt;/a&gt; is suitable for building asynchronous servers and clients in connected systems.</source>
          <target state="translated">所述&lt;a href=&quot;https://ktor.io/&quot;&gt;Ktor框架&lt;/a&gt;是适用于连接系统构建异步服务器和客户端。</target>
        </trans-unit>
        <trans-unit id="0194a3aa4b12c9468ece4f08b6ba21815b0e08f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;CPointed&lt;/a&gt; without any specified interpretation.</source>
          <target state="translated">没有指定解释的&lt;a href=&quot;index&quot;&gt;CPointed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1f6321a990fb305c59adcbabf8e3830cf1b87ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; parameter is ignored.</source>
          <target state="translated">该&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;锁&lt;/a&gt;参数被忽略。</target>
        </trans-unit>
        <trans-unit id="ad29d28adce666b3b0aa95e3d086ef2150c731fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.LazyThreadSafetyMode%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Fmode&quot;&gt;mode&lt;/a&gt; parameter is ignored.</source>
          <target state="translated">该&lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.LazyThreadSafetyMode%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Fmode&quot;&gt;模式&lt;/a&gt;参数被忽略。</target>
        </trans-unit>
        <trans-unit id="65f4a08157a599a0434e41b121c5f82c757d8345" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.Array%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; array may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">该&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.Array%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;阵列可以被转换为一个&lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet的&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="e24be1e2b6e9366f0d91d73c1522fb4cc61453ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">所述&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;集合可被转换成&lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;的HashSet&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="88eac69a24417f0a5acd408bdb0ac168d5ab84f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">所述&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;序列可以被转换为一个&lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet的&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="4fdc1e3b9cc58343e5c4eb08ebf24ea334f18ce1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.Array%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; array may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">该&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.Array%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;阵列可以被转换为一个&lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet的&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="00e3673225dc7616b276e346639c286afc0812ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">所述&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;集合可被转换成&lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;的HashSet&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="9bfb6c345d49b612f19ff9859dc63476feb3110d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence may be converted to a &lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">所述&lt;a href=&quot;minus#kotlin.collections%24minus%28kotlin.collections.Set%28%28kotlin.collections.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.collections.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;序列可以被转换为一个&lt;a href=&quot;-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet的&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="150ad09de77efcf5d7cfbcf006b9f6b89c68e678" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.Array%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; array may be converted to a &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">该&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.Array%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;阵列可以被转换为一个&lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet的&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="16822a8d7e6589a06d4a74f594278b5199a4c0ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection may be converted to a &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">所述&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;集合可被转换成&lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;的HashSet&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="7730285cb3f44afdb3b127e9800e2d48488fce25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence may be converted to a &lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet&lt;/a&gt; to speed up the operation, thus the elements are required to have a correct and stable implementation of &lt;code&gt;hashCode()&lt;/code&gt; that doesn't change between successive invocations.</source>
          <target state="translated">所述&lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;元件&lt;/a&gt;序列可以被转换为一个&lt;a href=&quot;../kotlin.collections/-hash-set/index#kotlin.collections.HashSet&quot;&gt;HashSet的&lt;/a&gt;加快操作，从而这些元件需要具有正确和稳定执行 &lt;code&gt;hashCode()&lt;/code&gt; 不连续调用之间发生变化。</target>
        </trans-unit>
        <trans-unit id="6783ca375fba676e08fc3ee05e0ed3a5ef692c42" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;range#kotlin.text.MatchGroup%24range&quot;&gt;range&lt;/a&gt; property is available on JVM only.</source>
          <target state="translated">该&lt;a href=&quot;range#kotlin.text.MatchGroup%24range&quot;&gt;范围&lt;/a&gt;属性可用只JVM。</target>
        </trans-unit>
        <trans-unit id="42745a5a4bae1983528b804b1ebebed6b02c4c55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;replace#kotlin.text%24replace%28kotlin.CharSequence%2C+kotlin.text.Regex%2C+kotlin.String%29%2Freplacement&quot;&gt;replacement&lt;/a&gt; can consist of any combination of literal text and $-substitutions. To treat the replacement string literally escape it with the &lt;a href=&quot;-regex/escape-replacement#kotlin.text.Regex.Companion%24escapeReplacement%28kotlin.String%29&quot;&gt;kotlin.text.Regex.Companion.escapeReplacement&lt;/a&gt; method.</source>
          <target state="translated">该&lt;a href=&quot;replace#kotlin.text%24replace%28kotlin.CharSequence%2C+kotlin.text.Regex%2C+kotlin.String%29%2Freplacement&quot;&gt;置换&lt;/a&gt;可以由文字文本和$ -substitutions的任意组合。要处理替换字符串，请使用&lt;a href=&quot;-regex/escape-replacement#kotlin.text.Regex.Companion%24escapeReplacement%28kotlin.String%29&quot;&gt;kotlin.text.Regex.Companion.escapeReplacement&lt;/a&gt;方法从字面上对其进行转义。</target>
        </trans-unit>
        <trans-unit id="95e9b2afeb8d6a526b5a01ab6cb37a3b2fbd3c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; Operator</source>
          <target state="translated">该 &lt;code&gt;!!&lt;/code&gt; 操作员</target>
        </trans-unit>
        <trans-unit id="22f7ccf0243674cea2ac7171ac3600509d7e8e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-d&lt;/code&gt; option indicates what we want the output of the compiler to be called and may be either a directory name for class files or a &lt;em&gt;.jar&lt;/em&gt; file name. The &lt;code&gt;-include-runtime&lt;/code&gt; option makes the resulting &lt;em&gt;.jar&lt;/em&gt; file self-contained and runnable by including the Kotlin runtime library in it. If you want to see all available options run</source>
          <target state="translated">该 &lt;code&gt;-d&lt;/code&gt; 选项指示我们想要的编译器的输出被调用，可以是类文件目录名或&lt;em&gt;的.jar&lt;/em&gt;文件名。该 &lt;code&gt;-include-runtime&lt;/code&gt; 选项会使产生&lt;em&gt;的.jar&lt;/em&gt;文件自包含的，通过在它的科特林运行时库运行的。如果要查看所有可用选项的运行</target>
        </trans-unit>
        <trans-unit id="c711aceaf8b8e464d66e1fd318914f03bac4786f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-meta-info&lt;/code&gt; option indicates that an additional JS file with binary meta-information about compiled kotlin code will be created.</source>
          <target state="translated">该 &lt;code&gt;-meta-info&lt;/code&gt; 选项表示与有关编译科特林代码的二进制元信息附加JS文件将被创建。</target>
        </trans-unit>
        <trans-unit id="dc6b8236cb90f6f8fe4324f1a0dc0ef9b906294c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.def&lt;/code&gt; file supports several options for adjusting the generated bindings.</source>
          <target state="translated">该 &lt;code&gt;.def&lt;/code&gt; 文件支持，用于调整产生的绑定几个选项。</target>
        </trans-unit>
        <trans-unit id="73f8a4adb6a430053e582f21a1ecd992b4948729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.pointed&lt;/code&gt; property for &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; returns the lvalue of type &lt;code&gt;T&lt;/code&gt;, pointed by this pointer. The reverse operation is &lt;code&gt;.ptr&lt;/code&gt;: it takes the lvalue and returns the pointer to it.</source>
          <target state="translated">&lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 的 &lt;code&gt;.pointed&lt;/code&gt; 属性返回此指针指向的 &lt;code&gt;T&lt;/code&gt; 类型的左值。反向操作是 &lt;code&gt;.ptr&lt;/code&gt; ：它接受左值并返回指向它的指针。</target>
        </trans-unit>
        <trans-unit id="6d8b85d101ff4f2f1b24686adcfb710c9930ca1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operation is special: it is translated to a complex expression that screens for &lt;code&gt;null&lt;/code&gt;'s. &lt;code&gt;null == null&lt;/code&gt; is always true, and &lt;code&gt;x == null&lt;/code&gt; for a non-null &lt;code&gt;x&lt;/code&gt; is always false and won't invoke &lt;code&gt;x.equals()&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;==&lt;/code&gt; 操作是特殊的：它被翻译成一个复杂的表达式，对屏幕 &lt;code&gt;null&lt;/code&gt; 的。 &lt;code&gt;null == null&lt;/code&gt; 始终是真实的，和 &lt;code&gt;x == null&lt;/code&gt; 的非空 &lt;code&gt;x&lt;/code&gt; 永远是假的，不会调用 &lt;code&gt;x.equals()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bbc4d74ec596791bf71057157cc072f9f40333d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@BindView&lt;/code&gt; annotation is defined to be applied to the fields only, but the Kotlin compiler understands that and annotates the corresponding field under the hood when you apply the annotation to the whole property.</source>
          <target state="translated">该 &lt;code&gt;@BindView&lt;/code&gt; 注释被定义为仅应用于领域，但科特林编译器明白，当你应用注释到整个财产引擎盖下标注相应的领域。</target>
        </trans-unit>
        <trans-unit id="1df3c0a179e9e6af77acfff08df64cc5248d7f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@JvmDefault&lt;/code&gt; annotation is experimental in Kotlin 1.3. Its name and behavior may change, leading to future incompatibility.</source>
          <target state="translated">该 &lt;code&gt;@JvmDefault&lt;/code&gt; 注释是在科特林1.3实验。它的名称和行为可能会更改，导致将来不兼容。</target>
        </trans-unit>
        <trans-unit id="23f0d6b7e361daa5f829cff80c17a1080ce0221f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@UnderMigration&lt;/code&gt; annotation (provided in a separate artifact &lt;code&gt;kotlin-annotations-jvm&lt;/code&gt;) can be used by library maintainers to define the migration status for the nullability type qualifiers.</source>
          <target state="translated">所述 &lt;code&gt;@UnderMigration&lt;/code&gt; 注释（在一个单独的工件提供 &lt;code&gt;kotlin-annotations-jvm&lt;/code&gt; ）可通过库的维护者可以用来定义为空性类型限定的迁移状态。</target>
        </trans-unit>
        <trans-unit id="bb1328f13d2922d7a316403f81e7c018a9247b4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; representation of pointer parameters is designed to support C array literals without explicit native memory allocation. To construct the immutable self-contained sequence of C values, the following methods are provided:</source>
          <target state="translated">指针参数的 &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 表示旨在支持C数组文字，而无需显式的本机内存分配。为了构造C值的不变自包含序列，提供了以下方法：</target>
        </trans-unit>
        <trans-unit id="a1a03d0c25bc5cefc6e2a073c0dfa2fd3a424a42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Closeable.use&lt;/code&gt; function calls &lt;code&gt;Throwable.addSuppressed&lt;/code&gt; when an exception is thrown during closing the resource after some other exception.</source>
          <target state="translated">当在其他一些异常之后关闭资源的过程中引发异常时， &lt;code&gt;Closeable.use&lt;/code&gt; 函数将调用 &lt;code&gt;Throwable.addSuppressed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0327626fcb95882f9434dd6a1485603acf809a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; classes have the pointer to the native memory underneath. The memory will be released when a &lt;code&gt;memScoped&lt;/code&gt; function ends, which is equal to the end of its &lt;code&gt;block&lt;/code&gt;. Be careful to make sure that a pointer is not used outside of the &lt;code&gt;memScoped&lt;/code&gt; call. We may use &lt;code&gt;Arena()&lt;/code&gt; or &lt;code&gt;nativeHeap&lt;/code&gt; for pointers that should be available longer, or are cached inside a C library.</source>
          <target state="translated">该 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 类具有指向本机内存下方。当 &lt;code&gt;memScoped&lt;/code&gt; 函数结束（等于其 &lt;code&gt;block&lt;/code&gt; 的结束）时，将释放内存。注意确保在 &lt;code&gt;memScoped&lt;/code&gt; 调用之外未使用指针。我们可能使用 &lt;code&gt;Arena()&lt;/code&gt; 或 &lt;code&gt;nativeHeap&lt;/code&gt; 来指定应该更长或更长时间使用的指针，或者将其缓存在C库中。</target>
        </trans-unit>
        <trans-unit id="e1e663158ad35ab7b0074a2786efe149637f58ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; file uses the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to implement what we need. In the file, we define several targets &lt;code&gt;common&lt;/code&gt;, &lt;code&gt;android&lt;/code&gt;, and &lt;code&gt;iOS&lt;/code&gt;. Each target has its own platform. The &lt;code&gt;common&lt;/code&gt; target contains the Kotlin common code which is included into every platform compilation. It is allowed to have &lt;code&gt;expect&lt;/code&gt; declarations. Other targets provide &lt;code&gt;actual&lt;/code&gt; implementations for all &lt;code&gt;expect&lt;/code&gt;-actions from the &lt;code&gt;common&lt;/code&gt; target. The more detailed explanation of the multiplatform projects can be found on the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;Multiplatform Projects&lt;/a&gt; documentation page.</source>
          <target state="translated">该 &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; 文件使用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 的插件来实现我们所需要的。在文件中，我们定义了几个目标 &lt;code&gt;common&lt;/code&gt; ， &lt;code&gt;android&lt;/code&gt; 和 &lt;code&gt;iOS&lt;/code&gt; 。每个目标都有其自己的平台。该 &lt;code&gt;common&lt;/code&gt; 目标包含其中包括到每一个平台编译的科特林通用代码。允许有 &lt;code&gt;expect&lt;/code&gt; 声明。其他目标为 &lt;code&gt;common&lt;/code&gt; 目标中的所有 &lt;code&gt;expect&lt;/code&gt; 操作提供了 &lt;code&gt;actual&lt;/code&gt; 实现。可以在&amp;ldquo; &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;多平台项目&amp;rdquo;&lt;/a&gt;文档页面上找到有关多平台项目的更详细的说明。</target>
        </trans-unit>
        <trans-unit id="ef805264d2ba0e69f1525612b2097c56c9b79a21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SharedCode&lt;/code&gt; build generates iOS frameworks for use with the Xcode project. All frameworks are in the &lt;code&gt;SharedCode/build/bin&lt;/code&gt; folder. It creates a &lt;em&gt;debug&lt;/em&gt; and &lt;em&gt;release&lt;/em&gt; version for every framework target. The frameworks are in the following paths:</source>
          <target state="translated">该 &lt;code&gt;SharedCode&lt;/code&gt; 构建生成与Xcode项目使用的iOS框架。所有框架都位于 &lt;code&gt;SharedCode/build/bin&lt;/code&gt; 文件夹中。它为每个框架目标创建一个&lt;em&gt;调试&lt;/em&gt;和&lt;em&gt;发布&lt;/em&gt;版本。这些框架的路径如下：</target>
        </trans-unit>
        <trans-unit id="49918eac55ef5c9d9df4be1f8508374502fa5919" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SharedCode&lt;/code&gt; sub-project should generate several artifacts for us:</source>
          <target state="translated">该 &lt;code&gt;SharedCode&lt;/code&gt; 分项目应该为我们生成多个工件：</target>
        </trans-unit>
        <trans-unit id="738861947c8af30bd4668ff2083f0544a8963e87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; class represents character strings. All string literals in Kotlin programs, such as &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, are implemented as instances of this class.</source>
          <target state="translated">该 &lt;code&gt;String&lt;/code&gt; 类代表字符串。Kotlin程序中的所有字符串文字（例如 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; ）都实现为此类的实例。</target>
        </trans-unit>
        <trans-unit id="1109231b443cf6e05eb0d002d1e6b58cba8574e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TimeoutCancellationException&lt;/code&gt; that is thrown by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; is a subclass of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt;. We have not seen its stack trace printed on the console before. That is because inside a cancelled coroutine &lt;code&gt;CancellationException&lt;/code&gt; is considered to be a normal reason for coroutine completion. However, in this example we have used &lt;code&gt;withTimeout&lt;/code&gt; right inside the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;TimeoutCancellationException&lt;/code&gt; 由抛出&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt;是的子类&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt;。我们之前从未在控制台上看到过它的堆栈跟踪记录。那是因为在一个被取消的协程中， &lt;code&gt;CancellationException&lt;/code&gt; 被认为是协程完成的正常原因。但是，在此示例中，我们在 &lt;code&gt;main&lt;/code&gt; 函数内部使用了 &lt;code&gt;withTimeout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="678b280d532baa9bcd8fba06428fcb263e6a4bcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Unit&lt;/code&gt; return type declaration is also optional. The above code is equivalent to:</source>
          <target state="translated">该 &lt;code&gt;Unit&lt;/code&gt; 返回类型声明也是可选的。上面的代码等效于：</target>
        </trans-unit>
        <trans-unit id="bb48ced54ff1266406f8ddf62204246a87b046d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array.copyInto(targetArray, targetOffset, startIndex, endIndex)&lt;/code&gt; functions for the existing array types, including the unsigned arrays, make it easier to implement array-based containers in pure Kotlin.</source>
          <target state="translated">现有数组类型（包括无符号数组 &lt;code&gt;array.copyInto(targetArray, targetOffset, startIndex, endIndex)&lt;/code&gt; 的array.copyInto（targetArray，targetOffset，startIndex，endIndex）函数使在纯Kotlin中实现基于数组的容器更加容易。</target>
        </trans-unit>
        <trans-unit id="a6d3c63b724a00a7b22c190a90ba3fb846402424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; blocks are tried in order until an exception type is found that matches the thrown exception (it doesn't need to be an exact match; the thrown exception's class can be a subclass of the declared one), and at most one &lt;code&gt;catch&lt;/code&gt; block will be executed. If no match is found, the exception bubbles out of the &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;catch&lt;/code&gt; 块依次尝试，直到一个异常类型中找到了相匹配的抛出异常（它并不需要精确匹配;抛出的异常的类可以是的一个子类声明的一个），并且最多一个 &lt;code&gt;catch&lt;/code&gt; 块将被执行。如果找不到匹配项，则异常从 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 冒泡。</target>
        </trans-unit>
        <trans-unit id="c0fef9a879817509a3ced8499c0b86da8348957d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt; functions are another example of the &lt;em&gt;principle of conventions&lt;/em&gt; widely used in Kotlin (see operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, &lt;em&gt;for&lt;/em&gt;-loops etc.). Anything can be on the right-hand side of a destructuring declaration, as long as the required number of component functions can be called on it. And, of course, there can be &lt;code&gt;component3()&lt;/code&gt; and &lt;code&gt;component4()&lt;/code&gt; and so on.</source>
          <target state="translated">所述 &lt;code&gt;component1()&lt;/code&gt; 和 &lt;code&gt;component2()&lt;/code&gt; 函数是的另一示例&lt;em&gt;约定的原则&lt;/em&gt;（参见等运营商广泛应用于科特林 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; ，&lt;em&gt;为&lt;/em&gt; -loops等）。只要可以在其上调用所需数量的组件函数，任何内容都可以在解构声明的右侧。而且，当然可以有 &lt;code&gt;component3()&lt;/code&gt; 和 &lt;code&gt;component4()&lt;/code&gt; 等等。</target>
        </trans-unit>
        <trans-unit id="c908c6361f3f878795986cf1aacec3df19a47af2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;componentN()&lt;/code&gt; operator functions are not called for the components that are skipped in this way.</source>
          <target state="translated">对于以这种方式跳过的组件，不会调用 &lt;code&gt;componentN()&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="7d4ca598e9322020fabb7ed0f0cf080beed5a640" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynamic&lt;/code&gt; type basically turns off Kotlin's type checker:</source>
          <target state="translated">该 &lt;code&gt;dynamic&lt;/code&gt; 类型基本上关闭科特林的类型检查：</target>
        </trans-unit>
        <trans-unit id="51e19e38be808ad0fddd91d78f8820fc196fada7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;external&lt;/code&gt; modifier</source>
          <target state="translated">在 &lt;code&gt;external&lt;/code&gt; 修改</target>
        </trans-unit>
        <trans-unit id="6672d0616428f2de367eecabae3ac9b311e7f971" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;external&lt;/code&gt; modifier is only allowed on package-level declarations. You can't declare an &lt;code&gt;external&lt;/code&gt; member of a non-&lt;code&gt;external&lt;/code&gt; class.</source>
          <target state="translated">仅在包级声明中才允许使用 &lt;code&gt;external&lt;/code&gt; 修饰符。您不能声明非 &lt;code&gt;external&lt;/code&gt; 类的 &lt;code&gt;external&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="3b6dae5981e61870a0a711096ca1cc69db0e7e4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;field&lt;/code&gt; identifier can only be used in the accessors of the property.</source>
          <target state="translated">该 &lt;code&gt;field&lt;/code&gt; 识别符只能在属性的访问中使用。</target>
        </trans-unit>
        <trans-unit id="a8755ff22ac11729e9e1bb025cf0c2f08d13b24b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finally&lt;/code&gt; block (if any) is executed at the end, no matter what the outcome is: either after the try block completes successfully, or after a catch block is executed (even if another exception is thrown by the catch block), or if no matching catch is found.</source>
          <target state="translated">在 &lt;code&gt;finally&lt;/code&gt; 块（如果有的话），结束时执行，不管结局是什么：要么成功try块完成后，或在catch块被执行（即使另一个异常是由catch块抛出），或者如果找不到匹配的捕获。</target>
        </trans-unit>
        <trans-unit id="6e147b02bdfa0081a311ca1a27d8c44534b54856" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; functions in the &lt;code&gt;HTML&lt;/code&gt; class are defined similarly to &lt;code&gt;html&lt;/code&gt;. The only difference is that they add the built instances to the &lt;code&gt;children&lt;/code&gt; collection of the enclosing &lt;code&gt;HTML&lt;/code&gt; instance:</source>
          <target state="translated">&lt;code&gt;HTML&lt;/code&gt; 类中的 &lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;body&lt;/code&gt; 函数的定义类似于 &lt;code&gt;html&lt;/code&gt; 。唯一的区别是，它们将构建的实例添加到封闭的 &lt;code&gt;HTML&lt;/code&gt; 实例的 &lt;code&gt;children&lt;/code&gt; 集合中：</target>
        </trans-unit>
        <trans-unit id="770f5ab17d8a9531f1b79df0e83aa540310bf343" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; keyword is not restricted to importing classes; you can also use it to import other declarations:</source>
          <target state="translated">该 &lt;code&gt;import&lt;/code&gt; 关键词不限于进口类; 您还可以使用它导入其他声明：</target>
        </trans-unit>
        <trans-unit id="41a9e375e0ec0d5188379910e6d4cc759d4c0ed4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inc()&lt;/code&gt; and &lt;code&gt;dec()&lt;/code&gt; functions must return a value, which will be assigned to the variable on which the &lt;code&gt;++&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; operation was used. They shouldn't mutate the object on which the &lt;code&gt;inc&lt;/code&gt; or &lt;code&gt;dec&lt;/code&gt; was invoked.</source>
          <target state="translated">在 &lt;code&gt;inc()&lt;/code&gt; 和 &lt;code&gt;dec()&lt;/code&gt; 函数必须返回一个值，该值将被分配到其上的可变 &lt;code&gt;++&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 使用操作。他们不应该对调用 &lt;code&gt;inc&lt;/code&gt; 或 &lt;code&gt;dec&lt;/code&gt; 的对象进行突变。</target>
        </trans-unit>
        <trans-unit id="2a8bc7470da685195a735f122f1c7a64a5a63c8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; modifier affects both the function itself and the lambdas passed to it: all of those will be inlined into the call site.</source>
          <target state="translated">该 &lt;code&gt;inline&lt;/code&gt; 修改会影响本身的功能，并传递给它的lambda表达式：所有这些都将被联到调用点。</target>
        </trans-unit>
        <trans-unit id="4c1794e25137b28059a2347a21857b9a05912426" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; modifier can be used on accessors of properties that don't have a backing field. You can annotate individual property accessors:</source>
          <target state="translated">该 &lt;code&gt;inline&lt;/code&gt; 修改可以在不具有支持字段属性访问器使用。您可以注释单个属性访问器：</target>
        </trans-unit>
        <trans-unit id="2e8761b1965ac33697b654aacb6b2483099da851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;internal&lt;/code&gt; visibility modifier means that the member is visible within the same module. More specifically, a module is a set of Kotlin files compiled together:</source>
          <target state="translated">的 &lt;code&gt;internal&lt;/code&gt; 可见性改性剂的装置，该构件是在同一模块内可见。更具体地说，模块是一起编译的一组Kotlin文件：</target>
        </trans-unit>
        <trans-unit id="5524830c2792b87628c40ec57ff6cb705892ec15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;interop.def&lt;/code&gt; file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; and run it.</source>
          <target state="translated">该 &lt;code&gt;interop.def&lt;/code&gt; 文件足以编译和运行应用程序或在IDE中打开它。现在是时候创建项目文件，在&lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA中&lt;/a&gt;打开项目并运行它了。</target>
        </trans-unit>
        <trans-unit id="44ba6fd4ed404417523557c04ecd859c9b045fe5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin also uses configurations under the hood but it also provides a &lt;code&gt;dependencies&lt;/code&gt; block for each source set allowing configuring dependencies of this sources set:</source>
          <target state="translated">所述 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件还使用配置引擎盖下，但它也提供了一种 &lt;code&gt;dependencies&lt;/code&gt; 块为每个源组允许这个源设置的配置的依赖关系：</target>
        </trans-unit>
        <trans-unit id="adb02342d7ce602f18e1bc8edea76f179234a358" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kotlin.js&lt;/code&gt; file should be referenced first as it is used by our application</source>
          <target state="translated">该 &lt;code&gt;kotlin.js&lt;/code&gt; 因为它是使用我们的应用程序文件，应首先引用</target>
        </trans-unit>
        <trans-unit id="d33f6d3213f1661b13836e07ebfe17d21d08c317" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kotlin.text.Regex&lt;/code&gt; class has become &lt;code&gt;Serializable&lt;/code&gt; and can now be used in serializable hierarchies.</source>
          <target state="translated">该 &lt;code&gt;kotlin.text.Regex&lt;/code&gt; 类成为 &lt;code&gt;Serializable&lt;/code&gt; 现在可以在序列化的层次结构中使用。</target>
        </trans-unit>
        <trans-unit id="3bdd0dba3711de41e882257acdc9d6c6d0be76b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lateinit&lt;/code&gt; modifier can now be used on top-level properties and local variables. The latter can be used, for example, when a lambda passed as a constructor argument to one object refers to another object which has to be defined later:</source>
          <target state="translated">该 &lt;code&gt;lateinit&lt;/code&gt; 修饰符现在可以在顶级性能和使用的局部变量。例如，当作为构造函数参数传递给一个对象的lambda引用另一个必须稍后定义的对象时，可以使用后者：</target>
        </trans-unit>
        <trans-unit id="43331c82f7829c2da5f8833182cec47167e9b99d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;libnative&lt;/code&gt; is used as the library name, the generated header file name prefix. It is also prefixes all declarations in the header file.</source>
          <target state="translated">所述 &lt;code&gt;libnative&lt;/code&gt; 用作库名，生成的头文件名称前缀。它也是头文件中所有声明的前缀。</target>
        </trans-unit>
        <trans-unit id="bbfbe4356895f41e445e2fe6cf1eee9c6b52bcaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure contains several helper functions:</source>
          <target state="translated">该 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 结构包含几个辅助函数：</target>
        </trans-unit>
        <trans-unit id="31fcc81919bad97de24dff6463d9620cad90a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;log&lt;/code&gt; function prints the name of the thread in square brackets and you can see, that it is the &lt;code&gt;main&lt;/code&gt; thread, but the identifier of the currently executing coroutine is appended to it. This identifier is consecutively assigned to all created coroutines when debugging mode is turned on.</source>
          <target state="translated">该 &lt;code&gt;log&lt;/code&gt; 函数打印在方括号中的线程的名称，你可以看到，它是 &lt;code&gt;main&lt;/code&gt; 线程，但当前正在执行的协同程序的标识追加到它。打开调试模式后，会将该标识符连续分配给所有创建的协程。</target>
        </trans-unit>
        <trans-unit id="3230b15e19fadbbe8582fc37fac536f21d903134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memoizedFoo&lt;/code&gt; variable will be computed on the first access only. If &lt;code&gt;someCondition&lt;/code&gt; fails, the variable won't be computed at all.</source>
          <target state="translated">该 &lt;code&gt;memoizedFoo&lt;/code&gt; 变量将只在第一次访问来计算。如果 &lt;code&gt;someCondition&lt;/code&gt; 失败，则根本不会计算该变量。</target>
        </trans-unit>
        <trans-unit id="33d6683731510016eab36ef3fe8c81b5c054cb1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;metaInfo&lt;/code&gt; option is useful, if you want to distribute the result of translation as a Kotlin/JavaScript library. If &lt;code&gt;metaInfo&lt;/code&gt; was set to &lt;code&gt;true&lt;/code&gt;, then during compilation additional JS file with binary metadata will be created. This file should be distributed together with the result of translation:</source>
          <target state="translated">该 &lt;code&gt;metaInfo&lt;/code&gt; 选项是有用的，如果你要分发翻译为科特林/ JavaScript库的结果。如果 &lt;code&gt;metaInfo&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，那么在编译期间将创建带有二进制元数据的附加JS文件。该文件应与翻译结果一起分发：</target>
        </trans-unit>
        <trans-unit id="ef6518091f136fea33cc33006301200c71352567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mod&lt;/code&gt; operator is now deprecated, and &lt;code&gt;rem&lt;/code&gt; is used instead. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-14650&quot;&gt;this issue&lt;/a&gt; for motivation.</source>
          <target state="translated">该 &lt;code&gt;mod&lt;/code&gt; 运营商现在已经过时，而 &lt;code&gt;rem&lt;/code&gt; 来代替。看到&lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-14650&quot;&gt;这个问题&lt;/a&gt;的动机。</target>
        </trans-unit>
        <trans-unit id="8110b7b8d3687de9aeddaa2e0ee4cc0fcd8589ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provideDelegate&lt;/code&gt; method is called for each property during the creation of the &lt;code&gt;MyUI&lt;/code&gt; instance, and it performs the necessary validation right away.</source>
          <target state="translated">该 &lt;code&gt;provideDelegate&lt;/code&gt; 方法被调用为创作过程中每个属性 &lt;code&gt;MyUI&lt;/code&gt; 实例中，并执行必要的验证的时候了。</target>
        </trans-unit>
        <trans-unit id="553371a8f2ee3223a5555190c34ffafc9965ea1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provideDelegate&lt;/code&gt; method will be called for each property during the creation of a &lt;code&gt;MyUI&lt;/code&gt; instance, and it can perform the necessary validation right away.</source>
          <target state="translated">该 &lt;code&gt;provideDelegate&lt;/code&gt; 方法将被调用为创建的过程中每个属性 &lt;code&gt;MyUI&lt;/code&gt; 实例，它可以执行必要的验证的时候了。</target>
        </trans-unit>
        <trans-unit id="3ced8435cd27ad8472273c2b70edbb4e6fae0033" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; and &lt;code&gt;ignore&lt;/code&gt; values have the same meaning as those of &lt;code&gt;MigrationStatus&lt;/code&gt;, and only the &lt;code&gt;strict&lt;/code&gt; mode affects the types in the annotated declarations as they are seen in Kotlin.</source>
          <target state="translated">在 &lt;code&gt;strict&lt;/code&gt; ， &lt;code&gt;warn&lt;/code&gt; 和 &lt;code&gt;ignore&lt;/code&gt; 值的意思是那些相同的 &lt;code&gt;MigrationStatus&lt;/code&gt; ，只有 &lt;code&gt;strict&lt;/code&gt; 模式影响了注释声明的类型，因为他们在科特林被看见。</target>
        </trans-unit>
        <trans-unit id="b73370969f5202ffabe72c59e5b9b17674a895a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toast&lt;/code&gt; function is defined in the &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; library.</source>
          <target state="translated">该 &lt;code&gt;toast&lt;/code&gt; 功能在定义&lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;安口&lt;/a&gt;库。</target>
        </trans-unit>
        <trans-unit id="28d1165f482266ce4727ebc682f071fdd99069b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typedef struct { .. } TYPE_NAME&lt;/code&gt; syntax is used in C language to declare a structure. &lt;a href=&quot;https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions&quot;&gt;The thread&lt;/a&gt; provides more explanations of that pattern.</source>
          <target state="translated">的 &lt;code&gt;typedef struct { .. } TYPE_NAME&lt;/code&gt; 语法在C语言用于声明的结构。&lt;a href=&quot;https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions&quot;&gt;该线程&lt;/a&gt;提供了对该模式的更多解释。</target>
        </trans-unit>
        <trans-unit id="98db59501bac8408cab0fac3a9f3341579e6d212" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;valueOf()&lt;/code&gt; method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the specified name does not match any of the enum constants defined in the class.</source>
          <target state="translated">所述 &lt;code&gt;valueOf()&lt;/code&gt; 方法抛出 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 如果指定的名称不匹配任何在该类中定义的枚举常数。</target>
        </trans-unit>
        <trans-unit id="3e338c07817ae57fb7dbab7add74e2021cf2d7f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version&lt;/code&gt; should be literal in this block, and it cannot be applied from another build script.</source>
          <target state="translated">该 &lt;code&gt;version&lt;/code&gt; 在此块中应为原义，并且不能从其他构建脚本中应用。</target>
        </trans-unit>
        <trans-unit id="271e23dc79ae024533b3813b505d0f8c07b0807d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop is similar to Python (but keep in mind that the condition must be an actual boolean expression, as there's no concept of truthy or falsy values).</source>
          <target state="translated">的 &lt;code&gt;while&lt;/code&gt; 循环类似于Python的（但请记住，条件必须是实际的布尔表达式，因为没有truthy或falsy值的概念）。</target>
        </trans-unit>
        <trans-unit id="223ff8adc648a88f8fddcdbfcf941801bfcdb1cf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;New Project&lt;/em&gt; wizard in IntelliJ IDEA can be used to start a new Kotlin/Native project with just one click. Check out the &lt;em&gt;Kotlin&lt;/em&gt; section and select the &lt;em&gt;Native | Gradle&lt;/em&gt; option to generate the project. For a better understanding and to explain what's happening, in this tutorial we'll create the project manually.</source>
          <target state="translated">IntelliJ IDEA中的&amp;ldquo; &lt;em&gt;新建项目&amp;rdquo;&lt;/em&gt;向导可用于一键启动新的Kotlin / Native项目。&lt;em&gt;签&lt;/em&gt;出&lt;em&gt;Kotlin&lt;/em&gt;部分，然后选择&lt;em&gt;Native | Gradle&lt;/em&gt;选项生成项目。为了更好地理解和解释正在发生的事情，在本教程中，我们将手动创建项目。</target>
        </trans-unit>
        <trans-unit id="7d53f956418818285247311dbf9f12e622bd802b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;by&lt;/em&gt;-clause in the supertype list for &lt;code&gt;Derived&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; will be stored internally in objects of &lt;code&gt;Derived&lt;/code&gt; and the compiler will generate all the methods of &lt;code&gt;Base&lt;/code&gt; that forward to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">在&lt;em&gt;通过&lt;/em&gt;在超类列表-clause &lt;code&gt;Derived&lt;/code&gt; 表明， &lt;code&gt;b&lt;/code&gt; 将在内部在对象存储 &lt;code&gt;Derived&lt;/code&gt; ，编译器将生成所有的方法 &lt;code&gt;Base&lt;/code&gt; 是期待 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="213b555bea1db5677fa1e760ddedf7cc9bc757bb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;else&lt;/em&gt; branch is evaluated if none of the other branch conditions are satisfied. If &lt;em&gt;when&lt;/em&gt; is used as an expression, the &lt;em&gt;else&lt;/em&gt; branch is mandatory, unless the compiler can prove that all possible cases are covered with branch conditions (as, for example, with &lt;a href=&quot;enum-classes&quot;&gt;&lt;em&gt;enum&lt;/em&gt; class&lt;/a&gt; entries and &lt;a href=&quot;sealed-classes&quot;&gt;&lt;em&gt;sealed&lt;/em&gt; class&lt;/a&gt; subtypes).</source>
          <target state="translated">在&lt;em&gt;别人&lt;/em&gt;如果没有其他满足分支条件分支评估。如果将&lt;em&gt;when&lt;/em&gt;用作表达式，则&lt;em&gt;else&lt;/em&gt;分支是必需的，除非编译器可以证明所有可能的情况都被分支条件覆盖（例如，&lt;a href=&quot;enum-classes&quot;&gt;&lt;em&gt;枚举&lt;/em&gt;类&lt;/a&gt;条目和&lt;a href=&quot;sealed-classes&quot;&gt;&lt;em&gt;密封&lt;/em&gt;类&lt;/a&gt;子类型）。</target>
        </trans-unit>
        <trans-unit id="61bf16ef28ea6d5682c3a6e4f7b1d1fca409774d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;is&lt;/em&gt; operator checks if an expression is an instance of a type. If an immutable local variable or property is checked for a specific type, there's no need to cast it explicitly:</source>
          <target state="translated">的&lt;em&gt;是&lt;/em&gt;操作者检查是否一个表达式是一个类型的一个实例。如果检查了不可变的局部变量或属性是否具有特定类型，则无需显式进行强制转换：</target>
        </trans-unit>
        <trans-unit id="f6350fa23a8337c14451639e9dda41ba02fbc154" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;kotlin-maven-plugin&lt;/em&gt; compiles Kotlin sources and modules. Currently only Maven v3 is supported.</source>
          <target state="translated">所述&lt;em&gt;科特林-行家-插件&lt;/em&gt;编译科特林源和模块。当前仅支持Maven v3。</target>
        </trans-unit>
        <trans-unit id="ac3430431502d340786bc5ac5f5a79619bd1b1b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mapping&lt;/em&gt; transformation creates a collection from the results of a function on the elements of another collection. The basic mapping function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt;. It applies the given lambda function to each subsequent element and returns the list of the lambda results. The order of results is the same as the original order of elements. To apply a transformation that additionally uses the element index as an argument, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt;&lt;code&gt;mapIndexed()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的&lt;em&gt;映射&lt;/em&gt;转换创建从在另一集合中的元素的函数的结果的集合。基本的映射函数是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;。它将给定的lambda函数应用于每个后续元素，并返回lambda结果的列表。结果的顺序与元素的原始顺序相同。要应用额外使用元素索引作为参数的转换，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt; &lt;code&gt;mapIndexed()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f10d769163cad6919d11542a05d27b21373fb57" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;no-arg&lt;/em&gt; compiler plugin generates an additional zero-argument constructor for classes with a specific annotation.</source>
          <target state="translated">在&lt;em&gt;无参数&lt;/em&gt;编译器插件生成用于与特定注解类的附加无参数构造。</target>
        </trans-unit>
        <trans-unit id="c23eadbd5827ce2bda3043305cafb8fee54b97d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Derived.v()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Base.nv()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="translated">对于 &lt;code&gt;Derived.v()&lt;/code&gt; ,必须使用&lt;em&gt;override&lt;/em&gt;修饰符。如果丢失，编译器会抱怨。如果在诸如 &lt;code&gt;Base.nv()&lt;/code&gt; 之类的函数上没有&lt;em&gt;open&lt;/em&gt;修饰符，则在子类中声明具有相同签名的方法是非法的，无论是否&lt;em&gt;重写&lt;/em&gt;。当将&lt;em&gt;open&lt;/em&gt;修饰符添加到最终类的成员（即，没有&lt;em&gt;open&lt;/em&gt;修饰符的类）的成员上时，则无效。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a6efa4e40ec720cdbba584f5f17332e3c02e6f0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive data types&lt;/em&gt; are the most fundamental types in Kotlin; all other types are built up of these types and arrays thereof. Their representation is very efficient (both in terms of memory and CPU time), as they map to small byte groups that are directly manipulatable by the CPU.</source>
          <target state="translated">在&lt;em&gt;基本数据类型&lt;/em&gt;都在科特林最根本的类型; 所有其他类型均由这些类型及其数组组成。它们的表示非常有效（在内存和CPU时间方面），因为它们映射到可由CPU直接操作的小字节组。</target>
        </trans-unit>
        <trans-unit id="487cd135e968638b95e9f2832e5094575fc75a4e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;return&lt;/em&gt;-expression returns from the nearest enclosing function, i.e. &lt;code&gt;foo&lt;/code&gt;. (Note that such non-local returns are supported only for lambda expressions passed to &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt;.) If we need to return from a lambda expression, we have to label it and qualify the &lt;em&gt;return&lt;/em&gt;:</source>
          <target state="translated">在&lt;em&gt;返回&lt;/em&gt;从最近的封闭功能-expression的回报，即 &lt;code&gt;foo&lt;/code&gt; 。（请注意，只有传递给&lt;a href=&quot;inline-functions&quot;&gt;内联函数的&lt;/a&gt; lambda表达式才支持此类非本地返回。）如果需要从lambda表达式返回，则必须对其进行标记并限定&lt;em&gt;返回值&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="cafe8afb40f89fdcda59dc51de02a6061deac76b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sam-with-receiver&lt;/em&gt; compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM constructors (see the &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;documentation&lt;/a&gt; for more details).</source>
          <target state="translated">所述&lt;em&gt;SAM-与接收器&lt;/em&gt;编译器插件使得注释的Java&amp;ldquo;一个抽象方法&amp;rdquo;（SAM）接口方法的第一个参数在科特林的接收器。仅当SAM适配器和SAM构造函数将SAM接口作为Kotlin lambda传递时，此转换才有效（请参阅&lt;a href=&quot;java-interop#sam-conversions&quot;&gt;文档&lt;/a&gt;以获取更多详细信息）。</target>
        </trans-unit>
        <trans-unit id="2b5aab8f26eb6a59834e5185db5f935d540467ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). Now, we can call such a function on any &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">扩展函数中的&lt;em&gt;this&lt;/em&gt;关键字对应于接收器对象（在点之前传递的对象）。现在，我们可以在任何 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; 上调用这样的函数：</target>
        </trans-unit>
        <trans-unit id="64ff96f8d5986618b0177325f56f06db0b6ef27e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cinterop&lt;/strong&gt; tool produces &lt;code&gt;.klib&lt;/code&gt; wrappers for native libraries as its main output. For example, using the simple &lt;code&gt;libgit2.def&lt;/code&gt; native library definition file provided in your Kotlin/Native distribution</source>
          <target state="translated">该&lt;strong&gt;cinterop&lt;/strong&gt;工具产生 &lt;code&gt;.klib&lt;/code&gt; 的本地库作为其主输出包装。例如，使用Kotlin / Native发行版中提供的简单 &lt;code&gt;libgit2.def&lt;/code&gt; 本机库定义文件</target>
        </trans-unit>
        <trans-unit id="3afe66cbf747b6ceb2175d27e523f7de3f8680c5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;klib&lt;/strong&gt; library management utility allows you to inspect and install the libraries.</source>
          <target state="translated">该&lt;strong&gt;klib&lt;/strong&gt;库管理工具允许你检查和安装库。</target>
        </trans-unit>
        <trans-unit id="4754f312fedbc815f86ed89afbc9edf502f5ba2a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;out&lt;/strong&gt; modifier is called a &lt;strong&gt;variance annotation&lt;/strong&gt;, and since it is provided at the type parameter declaration site, we talk about &lt;strong&gt;declaration-site variance&lt;/strong&gt;. This is in contrast with Java's &lt;strong&gt;use-site variance&lt;/strong&gt; where wildcards in the type usages make the types covariant.</source>
          <target state="translated">该&lt;strong&gt;出&lt;/strong&gt;修饰符被称为&lt;strong&gt;方差注释&lt;/strong&gt;，并且由于它是在类型参数声明的网站提供的，我们谈论&lt;strong&gt;的声明站点变化&lt;/strong&gt;。这与Java的&lt;strong&gt;使用站点差异&lt;/strong&gt;相反，在Java中，&lt;strong&gt;使用&lt;/strong&gt;类型中的通配符使类型成为协变。</target>
        </trans-unit>
        <trans-unit id="e4cdeee14d0ede31e2c00aaa982268d6ad103b09" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;wildcard type argument&lt;/strong&gt;&lt;code&gt;? extends E&lt;/code&gt; indicates that this method accepts a collection of objects of &lt;code&gt;E&lt;/code&gt;&lt;em&gt;or some subtype of&lt;/em&gt;&lt;code&gt;E&lt;/code&gt;, not just &lt;code&gt;E&lt;/code&gt; itself. This means that we can safely &lt;strong&gt;read&lt;/strong&gt;&lt;code&gt;E&lt;/code&gt;'s from items (elements of this collection are instances of a subclass of E), but &lt;strong&gt;cannot write&lt;/strong&gt; to it since we do not know what objects comply to that unknown subtype of &lt;code&gt;E&lt;/code&gt;. In return for this limitation, we have the desired behaviour: &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a subtype of &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt;. In &quot;clever words&quot;, the wildcard with an &lt;strong&gt;extends&lt;/strong&gt;-bound (&lt;strong&gt;upper&lt;/strong&gt; bound) makes the type &lt;strong&gt;covariant&lt;/strong&gt;.</source>
          <target state="translated">该&lt;strong&gt;通配符类型参数&lt;/strong&gt; &lt;code&gt;? extends E&lt;/code&gt; 表明，该方法接受对象的集合 &lt;code&gt;E&lt;/code&gt; &lt;em&gt;或某些亚型&lt;/em&gt; &lt;code&gt;E&lt;/code&gt; ，不只是 &lt;code&gt;E&lt;/code&gt; 本身。这意味着我们可以从项目中安全地&lt;strong&gt;读取&lt;/strong&gt; &lt;code&gt;E&lt;/code&gt; （此集合的元素是E的子类的实例），但是由于我们不知道哪些对象符合该 &lt;code&gt;E&lt;/code&gt; 的未知子类型，&lt;strong&gt;因此无法对其进行写入&lt;/strong&gt;。作为此限制的回报，我们具有所需的行为： &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;是&lt;/em&gt; &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 的子类型。扩展Object&amp;gt;。在&amp;ldquo;聪明话&amp;rdquo;，用一个通配符&lt;strong&gt;延伸&lt;/strong&gt;结合的（&lt;strong&gt;上&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;bound）使类型为&lt;strong&gt;covariant&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="1a90eeb87b3e982cfd1ef4a4b65cfd6c27586462" translate="yes" xml:space="preserve">
          <source>The Android world has many popular frameworks simplifying development. You can use the same frameworks if you develop in Kotlin, often as easily as you'd do that in Java. This tutorial provides examples and highlights the differences in settings.</source>
          <target state="translated">Android世界有许多流行的框架简化了开发。如果你用Kotlin开发,可以使用同样的框架,往往就像在Java中开发一样简单。本教程提供了一些例子,并强调了设置的差异。</target>
        </trans-unit>
        <trans-unit id="d41ba3261445c389f8874772f5879ab48af811af" translate="yes" xml:space="preserve">
          <source>The C data variable containing the pointer to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">包含指向 &lt;code&gt;T&lt;/code&gt; 的指针的C数据变量。</target>
        </trans-unit>
        <trans-unit id="05360f394dd3e60e07e614be2588088eb89e3b72" translate="yes" xml:space="preserve">
          <source>The C data variable located in memory.</source>
          <target state="translated">位于内存中的C数据变量。</target>
        </trans-unit>
        <trans-unit id="cf919179eecf4647d490ce563cdd6bff132af96d" translate="yes" xml:space="preserve">
          <source>The C function.</source>
          <target state="translated">C功能。</target>
        </trans-unit>
        <trans-unit id="d36502dcbc1bebedd6773776218e3117a26820bc" translate="yes" xml:space="preserve">
          <source>The C primitive-typed variable located in memory.</source>
          <target state="translated">位于内存中的C基元类型的变量。</target>
        </trans-unit>
        <trans-unit id="639b72b8a51545cc688d8100df8871c5e14d7a1a" translate="yes" xml:space="preserve">
          <source>The C struct-typed variable located in memory.</source>
          <target state="translated">位于内存中的C结构类型的变量。</target>
        </trans-unit>
        <trans-unit id="c4b0fbfe88d7c41e706fcbcc447e39c33c492192" translate="yes" xml:space="preserve">
          <source>The CocoaPods plugin also allows using CocoaPods libraries without manual configuring cinterop parameters (see the &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;corresponding section&lt;/a&gt; of the multiplatform plugin documentation). The &lt;code&gt;cocoapods { ... }&lt;/code&gt; code block allows you to add dependencies on CocoaPods libraries.</source>
          <target state="translated">CocoaPods插件还允许使用CocoaPods库，而无需手动配置cinterop参数（请参阅多平台插件文档的&lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;相应部分&lt;/a&gt;）。该 &lt;code&gt;cocoapods { ... }&lt;/code&gt; 代码块可以让你在的CocoaPods库添加依赖。</target>
        </trans-unit>
        <trans-unit id="8779fd3a2cac48558378b86549bbda66333c4276" translate="yes" xml:space="preserve">
          <source>The CocoaPods support is implemented in a separate Gradle plugin: &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt;.</source>
          <target state="translated">CocoaPods支持在单独的Gradle插件中实现： &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24a56079ca4afabfa7a909e10193add3dd7a492a" translate="yes" xml:space="preserve">
          <source>The DOM also provides us a way to retrieve a specific element by ID, name, class name, tag name and so on. All returned elements are of type &lt;code&gt;NodeList&lt;/code&gt;, and to access members we need to cast them to the specific type of element. The code below shows how we could access an input element on the page:</source>
          <target state="translated">DOM还为我们提供了一种通过ID，名称，类名称，标签名称等检索特定元素的方法。返回的所有元素均为 &lt;code&gt;NodeList&lt;/code&gt; 类型，要访问成员，我们需要将其强制转换为特定类型的元素。下面的代码显示了如何访问页面上的输入元素：</target>
        </trans-unit>
        <trans-unit id="325910eae4ee7077ed16505d94cb7161a53ff4ff" translate="yes" xml:space="preserve">
          <source>The Entry Point</source>
          <target state="translated">进入点</target>
        </trans-unit>
        <trans-unit id="c1f2de3caa83760aa037581086bf37c054caebbb" translate="yes" xml:space="preserve">
          <source>The Gradle file is pretty much standard for Spring Boot. The only differences are the structure layout for source folders for Kotlin, the required Kotlin dependencies and the &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle plugin (CGLIB proxies used for example for &lt;code&gt;@Configuration&lt;/code&gt; and &lt;code&gt;@Bean&lt;/code&gt; processing require &lt;code&gt;open&lt;/code&gt; classes).</source>
          <target state="translated">对于Spring Boot，Gradle文件几乎是标准的。唯一的区别是Kotlin的源文件夹的结构布局，所需的Kotlin依赖关系和&lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle插件（用于 &lt;code&gt;@Configuration&lt;/code&gt; 和 &lt;code&gt;@Bean&lt;/code&gt; 处理的CGLIB代理需要 &lt;code&gt;open&lt;/code&gt; 类）。</target>
        </trans-unit>
        <trans-unit id="af4ea41e06d67df72de18198c84923c5e721e071" translate="yes" xml:space="preserve">
          <source>The Gradle plugin provides a separate task that creates a universal framework for iOS targets from several regular ones. The example below shows how to use this task. Note that the fat framework must have the same base name as the initial frameworks.</source>
          <target state="translated">Gradle插件提供了一个单独的任务,它可以从几个常规的目标创建一个iOS目标的通用框架。下面的例子展示了如何使用这个任务。需要注意的是,胖子框架必须与初始框架的基名相同。</target>
        </trans-unit>
        <trans-unit id="c9686505fe7f54579b832493ec5b1983b12000c6" translate="yes" xml:space="preserve">
          <source>The JS typed arrays support that translates Kotlin primitive arrays, such as &lt;code&gt;IntArray&lt;/code&gt;, &lt;code&gt;DoubleArray&lt;/code&gt;, into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript typed arrays&lt;/a&gt;, that was previously an opt-in feature, has been enabled by default.</source>
          <target state="translated">JS类型的数组支持可将Kotlin基本数组（例如 &lt;code&gt;IntArray&lt;/code&gt; ， &lt;code&gt;DoubleArray&lt;/code&gt; ）转换为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript类型的数组&lt;/a&gt;（以前是选择加入功能），默认情况下已启用。</target>
        </trans-unit>
        <trans-unit id="37ed5aeb9956cf68199e058567f26ab71cd7268f" translate="yes" xml:space="preserve">
          <source>The JSR-305 checks can be configured by adding the &lt;code&gt;-Xjsr305&lt;/code&gt; compiler flag with the following options (and their combination):</source>
          <target state="translated">可以通过添加 &lt;code&gt;-Xjsr305&lt;/code&gt; 编译器标志以及以下选项（及其组合）来配置JSR-305检查：</target>
        </trans-unit>
        <trans-unit id="8614662835decc941fb88cef784012c8f902a438" translate="yes" xml:space="preserve">
          <source>The Kotlin Android Extensions plugin allows us to obtain the same experience we have with some of these libraries, without having to add any extra code.</source>
          <target state="translated">Kotlin Android Extensions插件可以让我们获得与其中一些库相同的体验,而无需添加任何额外的代码。</target>
        </trans-unit>
        <trans-unit id="b801cd7f041e6d90c21e7238c859980046339a8a" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin supports incremental compilation. Incremental compilation tracks changes of source files between builds so only files affected by these changes would be compiled.</source>
          <target state="translated">Kotlin Gradle插件支持增量编译。增量编译可以跟踪两次构建之间源文件的变化,因此只有受这些变化影响的文件才会被编译。</target>
        </trans-unit>
        <trans-unit id="11818c172874b525f41c4774ffd3a8d06183ee2a" translate="yes" xml:space="preserve">
          <source>The Kotlin Maven Plugin needs to be referenced to compile the sources:</source>
          <target state="translated">需要引用Kotlin Maven插件来编译源代码。</target>
        </trans-unit>
        <trans-unit id="e701f1b663fc8e1d541e7d7bed4b022ef1cd48e3" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides a comprehensive set of tools for managing &lt;em&gt;collections&lt;/em&gt; &amp;ndash; groups of a variable number of items (possibly zero) that share significance to the problem being solved and are operated upon commonly.</source>
          <target state="translated">Kotlin标准库提供了一套全面的工具来管理&lt;em&gt;馆藏&lt;/em&gt; -数量可变的项目组（可能为零），这些项目对已解决的问题具有重要意义并可以共同操作。</target>
        </trans-unit>
        <trans-unit id="8a031299bd7c193b637e92a822d8538f69af9b3a" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps. A pair of interfaces represent each collection type:</source>
          <target state="translated">Kotlin标准库提供了基本集合类型的实现:集合、列表和地图。一对接口代表了每种集合类型。</target>
        </trans-unit>
        <trans-unit id="3f614163c9f0e1a9b558eccd140b5d89bbaff4cb" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides living essentials for everyday work with Kotlin. These include:</source>
          <target state="translated">Kotlin标准库提供了使用Kotlin进行日常工作的生活必需品。其中包括:</target>
        </trans-unit>
        <trans-unit id="33a29a3734d935aaab60c852c81fd82eccf705fa" translate="yes" xml:space="preserve">
          <source>The Kotlin code is turned into very similar looking code in Swift. There are some small differences, though. In Kotlin any &lt;code&gt;object&lt;/code&gt; has only one instance. Kotlin &lt;code&gt;object Object&lt;/code&gt; now has a constructor in Swift, and we use the &lt;code&gt;Object()&lt;/code&gt; syntax to access the only instance of it. The instance is always the same in Swift, so that &lt;code&gt;Object() === Object()&lt;/code&gt; is true. Methods and property names are translated as-is. Kotlin &lt;code&gt;String&lt;/code&gt; is turned into Swift &lt;code&gt;String&lt;/code&gt; too. Swift hides &lt;code&gt;NSNumber*&lt;/code&gt; boxing from us too. We pass Swift closure to Kotlin and call a Kotlin lambda function from Swift too.</source>
          <target state="translated">在Swift中，Kotlin代码变成了非常相似的代码。不过，还是有一些细微的差别。在Kotlin中，任何 &lt;code&gt;object&lt;/code&gt; 只有一个实例。 Kotlin &lt;code&gt;object Object&lt;/code&gt; 现在在Swift中具有一个构造函数，我们使用 &lt;code&gt;Object()&lt;/code&gt; 语法访问它的唯一实例。实例在Swift中始终是相同的，因此 &lt;code&gt;Object() === Object()&lt;/code&gt; 为true。方法和属性名称按原样翻译。 Kotlin &lt;code&gt;String&lt;/code&gt; 也变成了Swift &lt;code&gt;String&lt;/code&gt; 。 Swift 也向我们隐藏了 &lt;code&gt;NSNumber*&lt;/code&gt; 拳击。我们将Swift闭包传递给Kotlin，也从Swift调用Kotlin lambda函数。</target>
        </trans-unit>
        <trans-unit id="a82d7ab28c8dc762af0699f165239106b9d7ca89" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package contains extension functions for popular operations on sets: finding intersections, merging, or subtracting collections from each other.</source>
          <target state="translated">Kotlin集合包包含了对集合的常用操作的扩展函数:寻找交集、合并或相互减去集合。</target>
        </trans-unit>
        <trans-unit id="5352e834912895fb7e864dc749c6a67a63a5c1bd" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package provides functions for sorting collections in natural, custom, and even random orders. On this page, we'll describe sorting functions that apply to &lt;a href=&quot;collections-overview#collection-types&quot;&gt;read-only&lt;/a&gt; collections. These functions return their result as a new collection containing the elements of the original collection in the requested order. To learn about functions for sorting &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; collections in place, see the &lt;a href=&quot;list-operations#sorting&quot;&gt;List Specific Operations&lt;/a&gt;.</source>
          <target state="translated">Kotlin集合包提供了用于以自然，自定义甚至随机顺序对集合进行排序的功能。在此页面上，我们将描述适用于&lt;a href=&quot;collections-overview#collection-types&quot;&gt;只读&lt;/a&gt;集合的排序功能。这些函数将其结果作为一个新集合返回，该新集合按请求的顺序包含原始集合的元素。要了解就地对&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可变&lt;/a&gt;集合进行排序的功能，请参阅&amp;ldquo; &lt;a href=&quot;list-operations#sorting&quot;&gt;特定&lt;/a&gt;于列表的操作&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="606ec4093466ccf8ac7dfb28ac45fda128eb6073" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler can now use information from type casts in type inference. If you&amp;rsquo;re calling a generic method that returns a type parameter &lt;code&gt;T&lt;/code&gt; and casting the return value to a specific type &lt;code&gt;Foo&lt;/code&gt;, the compiler now understands that &lt;code&gt;T&lt;/code&gt; for this call needs to be bound to the type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Kotlin编译器现在可以在类型推断中使用来自类型转换的信息。如果您正在调用一个返回类型参数 &lt;code&gt;T&lt;/code&gt; 的泛型方法，并将返回值转换为特定的 &lt;code&gt;Foo&lt;/code&gt; 类型，则编译器现在可以理解，此调用的 &lt;code&gt;T&lt;/code&gt; 必须绑定到 &lt;code&gt;Foo&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="3ccc8c3cdb40fba2c36169a3fed32ce41fa13cee" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler does extensive static analysis to provide warnings and reduce boilerplate. One of the most notable features is smartcasts &amp;mdash; with the ability to perform a cast automatically based on the performed type checks:</source>
          <target state="translated">Kotlin编译器会进行大量的静态分析，以提供警告并减少样板。最著名的功能之一是智能广播-具有根据执行的类型检查自动执行强制转换的功能：</target>
        </trans-unit>
        <trans-unit id="9b9028d4b3725e4248715dfa8cff6060191e14fa" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler provides all the necessary information about &lt;code&gt;prop&lt;/code&gt; in the arguments: the first argument &lt;code&gt;this&lt;/code&gt; refers to an instance of the outer class &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;this::prop&lt;/code&gt; is a reflection object of the &lt;code&gt;KProperty&lt;/code&gt; type describing &lt;code&gt;prop&lt;/code&gt; itself.</source>
          <target state="translated">所述编译器科特林提供了有关所有必要的信息 &lt;code&gt;prop&lt;/code&gt; 中的参数：第一个参数 &lt;code&gt;this&lt;/code&gt; 指外类的一个实例 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;this::prop&lt;/code&gt; 是的反射对象 &lt;code&gt;KProperty&lt;/code&gt; 类型描述 &lt;code&gt;prop&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="d8f9b6bf737be7b0aa49748489bb11aedc0ed8e0" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler tries to comply with the following goals:</source>
          <target state="translated">Kotlin编译器试图遵守以下目标。</target>
        </trans-unit>
        <trans-unit id="84694c64245d13b803ebc2f9a85d6bc26cef8561" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will prefer using underlying types instead of wrappers to produce the most performant and optimized code. However, sometimes it is necessary to keep wrappers around. As a rule of thumb, inline classes are boxed whenever they are used as another type.</source>
          <target state="translated">Kotlin编译器会更倾向于使用底层类型而不是包装器,以产生性能最强、最优化的代码。然而,有时有必要保留包装器。作为一个经验法则,只要内联类被用作另一种类型,就会被装箱。</target>
        </trans-unit>
        <trans-unit id="b1defae0fa9dbdfd545ce26ab8cc2b793d3d11fe" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will use this restriction to aggressively optimize runtime representation of inline classes and substitute their instances with the value of the underlying property where possible removing constructor calls, GC pressure, and enabling other optimizations:</source>
          <target state="translated">Kotlin编译器将利用这一限制来积极优化内联类的运行时表示,并在可能的情况下用底层属性的值来替代它们的实例,消除构造函数调用、GC压力,并实现其他优化。</target>
        </trans-unit>
        <trans-unit id="421148b46361ca016988f110ea6a768864eebc2b" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin also bundles a Java to Kotlin converter (&lt;em&gt;J2K&lt;/em&gt;) that automatically converts Java files to Kotlin. To use J2K on a file, click &lt;strong&gt;Convert Java File to Kotlin File&lt;/strong&gt; in its context menu or in the &lt;strong&gt;Code&lt;/strong&gt; menu of IntelliJ IDEA.</source>
          <target state="translated">Kotlin插件还捆绑了Java到Kotlin转换器（&lt;em&gt;J2K&lt;/em&gt;），该转换器可自动将Java文件转换为Kotlin。要在文件上使用J2K，请在其上下文菜单或IntelliJ IDEA 的&lt;strong&gt;&amp;ldquo;代码&amp;rdquo;&lt;/strong&gt;菜单中单击&amp;ldquo; &lt;strong&gt;将Java文件转换为Kotlin文件&lt;/strong&gt;&lt;strong&gt;&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8d656f515ef009525fec5de5fd6f927dce6dbed0" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt; (Gradle version 4.3 and above is required; caching is disabled with lower versions).</source>
          <target state="translated">Kotlin插件支持&lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt;（需要版本4.3及更高版本；缓存在较低版本中被禁用）。</target>
        </trans-unit>
        <trans-unit id="4e886321a88f27f1211fc7e6327218f1b649f0a9" translate="yes" xml:space="preserve">
          <source>The Kotlin sources are arranged into &lt;a href=&quot;#configuring-source-sets&quot;&gt;source sets&lt;/a&gt;. In addition to Kotlin source files and resources, each source set may have its own dependencies. Source sets form a hierarchy that is built with the &lt;em&gt;&quot;depends on&quot;&lt;/em&gt; relation. A source set by itself is platform agnostic, but it may contain platform-specific code and dependencies if it's only compiled for a single platform.</source>
          <target state="translated">Kotlin源被整理成&lt;a href=&quot;#configuring-source-sets&quot;&gt;源集&lt;/a&gt;。除了Kotlin源文件和资源外，每个源集可能都有其自己的依赖性。源集形成使用&lt;em&gt;&amp;ldquo;依赖&amp;rdquo;&lt;/em&gt;关系构建的层次结构。源集本身与平台无关，但如果仅针对单个平台进行编译，则它可能包含特定于平台的代码和依赖项。</target>
        </trans-unit>
        <trans-unit id="16279f302f8a88f25bf841c70c273ae22857462c" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library &lt;code&gt;kotlin-stdlib&lt;/code&gt; targets Java 6 and above. There are extended versions of the standard library that add support for some of the features of JDK 7 and JDK 8. To use these versions, add one of the following dependencies instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;:</source>
          <target state="translated">Kotlin标准库 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 针对Java 6及更高版本。标准库的扩展版本增加了对JDK 7和JDK 8某些功能的支持。要使用这些版本，请添加以下依赖项之一而不是 &lt;code&gt;kotlin-stdlib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e19faba3d18413b5a548d796d002602d1f6b7b0d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains extension functions for retrieving parts of a collection. These functions provide a variety of ways to select elements for the result collection: listing their positions explicitly, specifying the result size, and others.</source>
          <target state="translated">Kotlin标准库中包含了用于检索集合的部分内容的扩展函数,这些函数提供了为结果集合选择元素的各种方法:明确列出位置,指定结果大小等。这些函数提供了为结果集合选择元素的多种方法:显式列出它们的位置、指定结果大小等。</target>
        </trans-unit>
        <trans-unit id="aee8a9e1bcfd6364e58b2c53a697014bcd222ec2" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a &lt;a href=&quot;lambdas&quot;&gt;lambda expression&lt;/a&gt; provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called &lt;em&gt;scope functions&lt;/em&gt;. There are five of them: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;.</source>
          <target state="translated">Kotlin标准库包含几个函数，其唯一目的是在对象的上下文中执行代码块。当您在提供了&lt;a href=&quot;lambdas&quot;&gt;lambda表达式&lt;/a&gt;的对象上调用此类函数时，它将形成一个临时作用域。在此作用域中，您可以访问没有其名称的对象。这种功能称为&lt;em&gt;范围功能&lt;/em&gt;。其中有五个： &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;run&lt;/code&gt; ， &lt;code&gt;with&lt;/code&gt; ， &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;also&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41ab82952f2d2fb6d715a1d54dee47f369b23a5d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is available on &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and we can simply include it in our &lt;code&gt;package.json&lt;/code&gt; as a dependency.</source>
          <target state="translated">Kotlin标准库在&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;上可用，我们可以简单地将其作为依赖项包含在 &lt;code&gt;package.json&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="aa008c18e28c0e852d10e5f6a39e59c2d9ab879a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is now fully compatible with the Java 9 module system, which forbids split packages (multiple jar files declaring classes in the same package). In order to support that, new artifacts &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; are introduced, which replace the old &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt;.</source>
          <target state="translated">Kotlin标准库现在与Java 9模块系统完全兼容，该系统禁止拆分软件包（多个jar文件在同一软件包中声明类）。为了支持这一点， &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 新的工件kotlin-stdlib-jdk7和 &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; ，它们替代了旧的 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="870dd777a08235fb630e1002ab11ba8d4d93e900" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library offers a broad variety of functions for performing operations on collections. This includes simple operations, such as getting or adding elements, as well as more complex ones including search, sorting, filtering, transformations, and so on.</source>
          <target state="translated">Kotlin标准库提供了各种各样的函数,用于对集合进行操作。这包括简单的操作,如获取或添加元素,以及更复杂的操作,包括搜索、排序、过滤、转换等。</target>
        </trans-unit>
        <trans-unit id="7504a2da20208970eadd23d20d879fda0292513a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a series of wrappers around the JavaScript API for interacting with documents. The main component we'd usually access is the variable &lt;code&gt;document&lt;/code&gt;. Given we have access to this, we can simply read and write to the corresponding properties. For instance, to set the background of the page we can do</source>
          <target state="translated">Kotlin标准库围绕JavaScript API提供了一系列包装器，用于与文档进行交互。我们通常访问的主要组件是变量 &lt;code&gt;document&lt;/code&gt; 。有了我们可以访问的权限，我们可以简单地读取和写入相应的属性。例如，要设置页面背景，我们可以</target>
        </trans-unit>
        <trans-unit id="d4672fe3591cd8e490f322d7264f5d7b48dbb930" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a set of extension functions for collection &lt;em&gt;transformations&lt;/em&gt;. These functions build new collections from existing ones based on the transformation rules provided. In this page, we'll give an overview of the available collection transformation functions.</source>
          <target state="translated">Kotlin标准库提供了一组用于集合&lt;em&gt;转换&lt;/em&gt;的扩展功能。这些函数根据提供的转换规则从现有集合中构建新集合。在此页面中，我们将概述可用的集合转换功能。</target>
        </trans-unit>
        <trans-unit id="0d403b1b6b6cec3fc85d2c8444ad4595fd15211b" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides developers with a mechanism for creating and using &lt;em&gt;experimental&lt;/em&gt; APIs. This mechanism lets library authors inform users that certain components of their API, such as classes or functions, are unstable and are likely to change in the future. Such changes may require rewriting and recompiling the client code. To prevent potential compatibility issues, the compiler warns users of the experimental status of such APIs and may require them to give their explicit consent to use the API.</source>
          <target state="translated">Kotlin标准库为开发人员提供了创建和使用&lt;em&gt;实验性&lt;/em&gt; API 的机制。通过这种机制，库作者可以通知用户其API的某些组件（例如类或函数）是不稳定的，并且将来可能会更改。此类更改可能需要重写并重新编译客户端代码。为避免潜在的兼容性问题，编译器会警告用户此类API的实验状态，并可能要求他们明确表示同意使用该API。</target>
        </trans-unit>
        <trans-unit id="25b12f54730219e6bd01543d34c7f6d86941696e" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides extension functions for grouping collection elements. The basic function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt;&lt;code&gt;groupBy()&lt;/code&gt;&lt;/a&gt; takes a lambda function and returns a &lt;code&gt;Map&lt;/code&gt;. In this map, each key is the lambda result and the corresponding value is the &lt;code&gt;List&lt;/code&gt; of elements on which this result is returned. This function can be used, for example, to group a list of &lt;code&gt;String&lt;/code&gt;s by their first letter.</source>
          <target state="translated">Kotlin标准库提供了用于对集合元素进行分组的扩展功能。基本函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt; &lt;code&gt;groupBy()&lt;/code&gt; &lt;/a&gt;使用lambda函数并返回 &lt;code&gt;Map&lt;/code&gt; 。在此映射中，每个键都是lambda结果，而对应的值是返回此结果的元素 &lt;code&gt;List&lt;/code&gt; 。例如，可以使用此函数将 &lt;code&gt;String&lt;/code&gt; 列表按首字母分组。</target>
        </trans-unit>
        <trans-unit id="d49763e3623bb841ba6b661af00bff69df48a815" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides factory methods for several useful kinds of delegates.</source>
          <target state="translated">Kotlin标准库为几种有用的代表提供了工厂方法。</target>
        </trans-unit>
        <trans-unit id="d4752902cbbab973b31545d271408bf4e6b55c29" translate="yes" xml:space="preserve">
          <source>The Kotlin team offers a set of tools for Android development that goes beyond the standard language features:</source>
          <target state="translated">Kotlin团队为Android开发提供了一套超越标准语言功能的工具。</target>
        </trans-unit>
        <trans-unit id="3835dcf5cfa983896474e2202e8aad1e87118beb" translate="yes" xml:space="preserve">
          <source>The Kotlin visibilities are mapped to Java in the following way:</source>
          <target state="translated">Kotlin的可视性以如下方式映射到Java。</target>
        </trans-unit>
        <trans-unit id="6d899757cb2398280c10acb19695bbcab979ce63" translate="yes" xml:space="preserve">
          <source>The Kotlin/Native compiler is available for macOS, Linux, and Windows. It supports different targets including iOS (arm32, arm64, simulator x86_64), Windows (mingw32 and x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM. For the full list of targets we can refer to the &lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt;. While cross-platform compilation is possible (i.e., using one platform to compile for another), in this first tutorial we are only compiling for the operating system we're running on.</source>
          <target state="translated">Kotlin / Native编译器可用于macOS，Linux和Windows。它支持不同的目标，包括iOS（arm32，arm64，模拟器x86_64），Windows（mingw32和x86_64），Linux（x86_64，arm64，MIPS），macOS（x86_64），Raspberry PI，SMT32，WASM。有关目标的完整列表，请参阅&lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin / Native概述&lt;/a&gt;。尽管可以进行跨平台编译（即，使用一个平台编译另一个平台），但在本教程的第一个教程中，我们仅针对正在运行的操作系统进行编译。</target>
        </trans-unit>
        <trans-unit id="81130cfc1e83adbcab9e6da86955c53516b100d6" translate="yes" xml:space="preserve">
          <source>The Language Committee makes final decisions on what incompatible changes will be made and what exact measures should be taken to make user updates comfortable. In doing so, it relies on a set of guidelines available &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">语言委员会对将进行哪些不兼容的更改以及应采取什么确切的措施使用户感到满意做出最终决定。为此，它依赖于&lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;此处&lt;/a&gt;提供的一组准则。</target>
        </trans-unit>
        <trans-unit id="ef80e6d685a55893a99e950f4ed7fce2a86a1387" translate="yes" xml:space="preserve">
          <source>The Maven coordinates can be altered and additional artifact files may be added to the publications within the &lt;code&gt;targets { ... }&lt;/code&gt; block or the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL:</source>
          <target state="translated">可以更改Maven坐标，并且可以将其他工件文件添加到 &lt;code&gt;targets { ... }&lt;/code&gt; 块或 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL内的发布中：</target>
        </trans-unit>
        <trans-unit id="cc27fb0be25fb775df8eea4ef2ba6465502161d0" translate="yes" xml:space="preserve">
          <source>The Nothing type</source>
          <target state="translated">虚无型</target>
        </trans-unit>
        <trans-unit id="8cc0334fa925283a3687c8c8309944d9801a3bf7" translate="yes" xml:space="preserve">
          <source>The REPL command line interface opens. You can enter any valid Kotlin code and see the result. Results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="translated">REPL命令行界面打开。您可以输入任何有效的Kotlin代码并查看结果。结果将打印为具有自动生成的名称（如 &lt;code&gt;res*&lt;/code&gt; 变量。您以后可以在REPL中运行的代码中使用此类变量。</target>
        </trans-unit>
        <trans-unit id="2b7ee6e00ac4369b5da7230befe3c113bdc4222a" translate="yes" xml:space="preserve">
          <source>The above code compiles. However, it will produce a runtime error if the object is not properly initialised before use or if &lt;code&gt;callAnything()&lt;/code&gt; is not defined at runtime.</source>
          <target state="translated">上面的代码进行编译。但是，如果在使用前未正确初始化对象或在运行时未定义 &lt;code&gt;callAnything()&lt;/code&gt; ，它将产生运行时错误。</target>
        </trans-unit>
        <trans-unit id="f67cd69d25bde43de96336b3847aa293b8518b9e" translate="yes" xml:space="preserve">
          <source>The above code indicates that the function is defined externally. The &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; annotation allows us to map the name at runtime to &lt;code&gt;$&lt;/code&gt;. For more details on external declarations, please refer to the &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop documentation&lt;/a&gt;.</source>
          <target state="translated">上面的代码表明该函数是在外部定义的。该 &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; 注释可以让我们的名字在运行时映射 &lt;code&gt;$&lt;/code&gt; 。有关外部声明的更多详细信息，请参考&lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5749a0f0fe8aac855f406af86fe841d365cd7cde" translate="yes" xml:space="preserve">
          <source>The above could also be a oneliner - and note that the compiler knows that because the &lt;code&gt;throw&lt;/code&gt; will prevent &lt;code&gt;y&lt;/code&gt; from coming into existence if &lt;code&gt;x&lt;/code&gt; is null, &lt;code&gt;y&lt;/code&gt; must be non-null if we reach the line below. Contrast this with &lt;code&gt;x?.importantFunction()&lt;/code&gt;, which is a no-op if &lt;code&gt;x&lt;/code&gt; is null.</source>
          <target state="translated">上面的内容也可能是一个单行代码-并且请注意，编译器知道，因为如果 &lt;code&gt;x&lt;/code&gt; 为null，则 &lt;code&gt;throw&lt;/code&gt; 将阻止 &lt;code&gt;y&lt;/code&gt; 的存在，因此，如果我们到达下面的行，则 &lt;code&gt;y&lt;/code&gt; 必须为非null。将此与 &lt;code&gt;x?.importantFunction()&lt;/code&gt; 进行对比，如果 &lt;code&gt;x&lt;/code&gt; 为null，则为空。</target>
        </trans-unit>
        <trans-unit id="a87217033eafba44229106ab25d3816102c24f78" translate="yes" xml:space="preserve">
          <source>The above is preferable to:</source>
          <target state="translated">以上是优于。</target>
        </trans-unit>
        <trans-unit id="83d32caa4c432fbb23e6f884577d8ac97faf56a2" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;contravariant&lt;/em&gt;. Denoted by the &lt;code&gt;in&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">受影响的类型参数或类型是&lt;em&gt;反变的&lt;/em&gt;。由源代码中的 &lt;code&gt;in&lt;/code&gt; 修饰符表示。</target>
        </trans-unit>
        <trans-unit id="c340d256f4b2e039e4cb98547a639c6b4f11b7ba" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;covariant&lt;/em&gt;. Denoted by the &lt;code&gt;out&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">受影响的类型参数或类型为&lt;em&gt;covariant&lt;/em&gt;。在源代码中由 &lt;code&gt;out&lt;/code&gt; 修饰符表示。</target>
        </trans-unit>
        <trans-unit id="dff58c2fdf74d3cdbb35c54ab0e0155e83797493" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;invariant&lt;/em&gt;, which means it has no variance applied to it.</source>
          <target state="translated">受影响的类型参数或类型是&lt;em&gt;invariant&lt;/em&gt;，这意味着它没有应用任何变化。</target>
        </trans-unit>
        <trans-unit id="e638916d7acda84432e87e4a36d2e48c0c286bc5" translate="yes" xml:space="preserve">
          <source>The annotation also works for constructors, static methods, and so on. It can't be used on abstract methods, including methods defined in interfaces.</source>
          <target state="translated">该注解也适用于构造函数、静态方法等。它不能用于抽象方法,包括定义在接口中的方法。</target>
        </trans-unit>
        <trans-unit id="718f26b180ad67d2a1e20d6b7d4406049d2961a3" translate="yes" xml:space="preserve">
          <source>The annotation can be used on top-level external declarations (classes, properties, functions) and files. In case of file (which can't be &lt;code&gt;external&lt;/code&gt;) the following rule applies: all the declarations in the file must be &lt;code&gt;external&lt;/code&gt;. By applying &lt;code&gt;@JsModule(...)&lt;/code&gt; on a file you tell the compiler to import a JavaScript object that contain all the declarations from the file.</source>
          <target state="translated">注释可以用于顶级外部声明（类，属性，函数）和文件。如果是file（不能是 &lt;code&gt;external&lt;/code&gt; ），则遵循以下规则：文件中的所有声明都必须是 &lt;code&gt;external&lt;/code&gt; 。通过在文件上应用 &lt;code&gt;@JsModule(...)&lt;/code&gt; ，您可以告诉编译器导入一个JavaScript对象，该对象包含文件中的所有声明。</target>
        </trans-unit>
        <trans-unit id="993a0bc9861bdf8ea351a5eb1dd7c588f24a97de" translate="yes" xml:space="preserve">
          <source>The annotations for marking and using experimental APIs (&lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;@UseExperimental&lt;/code&gt;) are &lt;em&gt;experimental&lt;/em&gt; in Kotlin 1.3. See details &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">标记和使用实验性API的注释（ &lt;code&gt;@Experimental&lt;/code&gt; 和 &lt;code&gt;@UseExperimental&lt;/code&gt; ）在Kotlin 1.3中是&lt;em&gt;实验性的&lt;/em&gt;。请参阅&lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;下面的&lt;/a&gt;详细信息。</target>
        </trans-unit>
        <trans-unit id="ecb7079c4ed4f36ab04fb8b963913758bd291799" translate="yes" xml:space="preserve">
          <source>The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and to use it later.</source>
          <target state="translated">匿名函数语法允许你直接指定一个函数文字的接收器类型。如果你需要声明一个带有接收器的函数类型的变量,并在以后使用它,这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="e99a96b83211ab5edf0514b0e8d206e232457fc5" translate="yes" xml:space="preserve">
          <source>The application we're going to create will simply show &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; on Android and &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; on iOS. The idea is to share the code that generates this message.</source>
          <target state="translated">我们将要创建的应用程序将仅 &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 上的Android 上显示Kotlin Rocks， &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; 上仅显示Kotlin Rocks。想法是共享生成此消息的代码。</target>
        </trans-unit>
        <trans-unit id="c116b8d3b85f1f036748497d93f617762a69f1eb" translate="yes" xml:space="preserve">
          <source>The array literal syntax is constrained to annotation arguments.</source>
          <target state="translated">数组文字语法受制于注释参数。</target>
        </trans-unit>
        <trans-unit id="e6585b22e37432101f079b3e68122b140a6c8d0b" translate="yes" xml:space="preserve">
          <source>The arrow notation is right-associative, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; is equivalent to the previous example, but not to &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt;.</source>
          <target state="translated">箭头表示法是右关联的， &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; 等效于前面的示例，但不等于 &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eff75fbb6c3dbfe907753b9474216f02d469cd66" translate="yes" xml:space="preserve">
          <source>The author strongly recommends that you use an IDE with Kotlin support, as the static typing allows an IDE to do reliable navigation and code completion. I recommend &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, which is built by the same company that created Kotlin. The Community Edition is free; see &lt;a href=&quot;../getting-started&quot;&gt;instructions for getting started&lt;/a&gt; (it comes bundled with Kotlin, and you can run your program from the IDE).</source>
          <target state="translated">作者强烈建议您使用具有Kotlin支持的IDE，因为静态类型可以使IDE进行可靠的导航和代码完成。我推荐&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;，它是由创建Kotlin的同一家公司构建的。社区版是免费的；请参阅&lt;a href=&quot;../getting-started&quot;&gt;入门说明&lt;/a&gt;（它与Kotlin捆绑在一起，您可以从IDE中运行程序）。</target>
        </trans-unit>
        <trans-unit id="031b37e00f6cc7d0005e366d6305ce9ae5158eb7" translate="yes" xml:space="preserve">
          <source>The available options for persistence include direct JDBC access, JPA, as well as using NoSQL databases through their Java drivers. For JPA, the &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa compiler plugin&lt;/a&gt; adapts Kotlin-compiled classes to the requirements of the framework.</source>
          <target state="translated">持久性的可用选项包括直接JDBC访问，JPA以及通过其Java驱动程序使用NoSQL数据库。对于JPA，&lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa编译器插件使&lt;/a&gt; Kotlin编译的类适应框架的要求。</target>
        </trans-unit>
        <trans-unit id="f64d03b5ac4e40dff196fed46f6ad483b559e0ca" translate="yes" xml:space="preserve">
          <source>The base class for all errors and exceptions. Only instances of this class can be thrown or caught.</source>
          <target state="translated">所有错误和异常的基类。只有该类的实例可以被抛出或捕获。</target>
        </trans-unit>
        <trans-unit id="9567e5bd74f98cde043ce2604d36c00a7448fbca" translate="yes" xml:space="preserve">
          <source>The base exception class is &lt;code&gt;Throwable&lt;/code&gt; (but it is more common to extend its subclass &lt;code&gt;Exception&lt;/code&gt;), and there are a ton of built-in exception classes. If you don't find one that match your needs, you can create your own by inheriting from an existing exception class.</source>
          <target state="translated">基本异常类是 &lt;code&gt;Throwable&lt;/code&gt; （但更常见的是扩展其子类 &lt;code&gt;Exception&lt;/code&gt; ），并且有大量的内置异常类。如果找不到满足您需求的类，则可以通过从现有异常类继承来创建自己的类。</target>
        </trans-unit>
        <trans-unit id="d9ecc0f2cf4982d26aff3dd399995b9e266ca38f" translate="yes" xml:space="preserve">
          <source>The basic association function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt;&lt;code&gt;associateWith()&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Map&lt;/code&gt; in which the elements of the original collection are keys, and values are produced from them by the given transformation function. If two elements are equal, only the last one remains in the map.</source>
          <target state="translated">基本的关联函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt; &lt;code&gt;associateWith()&lt;/code&gt; &lt;/a&gt;创建一个 &lt;code&gt;Map&lt;/code&gt; ，其中原始集合的元素是键，并通过给定的转换函数从中产生值。如果两个元素相等，则仅最后一个保留在地图中。</target>
        </trans-unit>
        <trans-unit id="8747487378c0fd48a48984cf8a26dd2308ffac09" translate="yes" xml:space="preserve">
          <source>The basic filtering function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;. When called with a predicate, &lt;code&gt;filter()&lt;/code&gt; returns the collection elements that match it. For both &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;, the resulting collection is a &lt;code&gt;List&lt;/code&gt;, for &lt;code&gt;Map&lt;/code&gt; it's a &lt;code&gt;Map&lt;/code&gt; as well.</source>
          <target state="translated">基本的过滤功能是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt;。使用谓词调用时， &lt;code&gt;filter()&lt;/code&gt; 返回与其匹配的集合元素。对于 &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt; ，结果集合都是 &lt;code&gt;List&lt;/code&gt; ，对于 &lt;code&gt;Map&lt;/code&gt; 来说，它也是 &lt;code&gt;Map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="699437afba4c1eb6f2aa1a305318c9d9571a4fe8" translate="yes" xml:space="preserve">
          <source>The basic functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt;&lt;code&gt;sortedDescending()&lt;/code&gt;&lt;/a&gt; return elements of a collection sorted into ascending and descending sequence according to their natural order. These functions apply to collections of &lt;code&gt;Comparable&lt;/code&gt; elements.</source>
          <target state="translated">基本函数&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt; &lt;code&gt;sortedDescending()&lt;/code&gt; &lt;/a&gt;返回集合的元素，这些元素根据其自然顺序按升序和降序排序。这些功能适用于可 &lt;code&gt;Comparable&lt;/code&gt; 元素的集合。</target>
        </trans-unit>
        <trans-unit id="176655605bee6eae4892bd4ec703e94408b0c3f3" translate="yes" xml:space="preserve">
          <source>The best place to start is &lt;a href=&quot;https://kotlinlang.org&quot;&gt;this website&lt;/a&gt;. From there you can download the compiler, &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;try it online&lt;/a&gt; as well as get access to resources, &lt;a href=&quot;index&quot;&gt;reference documentation&lt;/a&gt; and &lt;a href=&quot;../tutorials/index&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">最好的起点是&lt;a href=&quot;https://kotlinlang.org&quot;&gt;这个网站&lt;/a&gt;。您可以从那里下载编译器，&lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;在线试用它&lt;/a&gt;，还可以访问资源，&lt;a href=&quot;index&quot;&gt;参考文档&lt;/a&gt;和&lt;a href=&quot;../tutorials/index&quot;&gt;教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a00b10508469a6652d6e476b8749625b68deb8ad" translate="yes" xml:space="preserve">
          <source>The best way to see what C data types are visible in Kotlin is to try it</source>
          <target state="translated">查看Kotlin中可见的C数据类型的最好方法是尝试一下</target>
        </trans-unit>
        <trans-unit id="8cccc62dffea928c706df5dfd73f9995b0b8212a" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between C and Kotlin languages is to try it out on a small example. We will create a small library headers for that. First, we need to create a &lt;code&gt;lib.h&lt;/code&gt; file with the following declaration of functions that deal with the C strings:</source>
          <target state="translated">理解C语言和Kotlin语言之间映射的最好方法是在一个小例子中尝试一下。我们将为此创建一个小的库头。首先，我们需要创建一个 &lt;code&gt;lib.h&lt;/code&gt; 文件，其中包含以下处理C字符串的函数声明：</target>
        </trans-unit>
        <trans-unit id="ffd6c6681f86404c6d10fd90b4e30255a8c338ed" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.</source>
          <target state="translated">理解Kotlin和C语言之间的映射的最好方法是尝试一个小小的例子。我们声明一个接受函数指针作为参数的函数和另一个返回函数指针的函数。</target>
        </trans-unit>
        <trans-unit id="6537550691113ba29bcd420ea4633f14458a70b1" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.</source>
          <target state="translated">理解Kotlin和C语言之间映射的最好方法是尝试一个小小的例子。我们将在C语言中声明一个结构和一个联合体,看看它们是如何映射到Kotlin中的。</target>
        </trans-unit>
        <trans-unit id="4232ac266b4561b99b9bc10fa2be9171a24a3226" translate="yes" xml:space="preserve">
          <source>The best way to understand these techniques is to try them out. Let's create a first tiny Kotlin library and use it from a C program.</source>
          <target state="translated">理解这些技术的最好方法就是尝试一下。让我们创建第一个小小的Kotlin库,并从C程序中使用它。</target>
        </trans-unit>
        <trans-unit id="eaa47ef7640a883ac2445b67958ca2668d316a2e" translate="yes" xml:space="preserve">
          <source>The best way to use the Kotlin/Native compiler is with a build system. It helps by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, and running the compiler and tests. It caches the compilation results too. A build system can also be used by an IDE to understand the project layout.</source>
          <target state="translated">使用Kotlin/Native编译器的最佳方式是使用构建系统。它通过下载和缓存 Kotlin/Native 编译器的二进制文件和具有过渡性依赖关系的库,并运行编译器和测试来提供帮助。它也会缓存编译结果。集成开发环境也可以使用构建系统来了解项目布局。</target>
        </trans-unit>
        <trans-unit id="9af9e08ad353ac6ed57e0041c23dca829fbff7c4" translate="yes" xml:space="preserve">
          <source>The binaries DSL allows not only creating binaries but also accessing already created ones to configure them or get their properties (e.g. path to an output file). The &lt;code&gt;binaries&lt;/code&gt; collection implements the &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt;&lt;code&gt;DomainObjectSet&lt;/code&gt;&lt;/a&gt; interface and provides methods like &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;matching&lt;/code&gt; allowing configuring groups of elements.</source>
          <target state="translated">二进制DSL不仅允许创建二进制文件，还可以访问已创建的二进制文件以配置它们或获取其属性（例如，输出文件的路径）。所述 &lt;code&gt;binaries&lt;/code&gt; 集合实现的&lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt; &lt;code&gt;DomainObjectSet&lt;/code&gt; &lt;/a&gt;接口，并提供类似的方法 &lt;code&gt;all&lt;/code&gt; 或 &lt;code&gt;matching&lt;/code&gt; 允许配置一组元素。</target>
        </trans-unit>
        <trans-unit id="bc8bcc38381183bfcc94707aa9b37df0e52f23b1" translate="yes" xml:space="preserve">
          <source>The binary files are created in the &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; or &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; folders respectively. The file has a &lt;code&gt;.kexe&lt;/code&gt; extension on Linux and macOS and an &lt;code&gt;.exe&lt;/code&gt; extension on Windows. Use the following command to instruct the build to produce binaries:</source>
          <target state="translated">二进制文件分别在 &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; 或 &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; 文件夹中创建。该文件在Linux和macOS上具有 &lt;code&gt;.kexe&lt;/code&gt; 扩展名，在Windows上具有 &lt;code&gt;.exe&lt;/code&gt; 扩展名。使用以下命令来指导生成二进制文件：</target>
        </trans-unit>
        <trans-unit id="54650137fcf92a797ec9822a89e0e51a3d74473c" translate="yes" xml:space="preserve">
          <source>The block after &lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; is the first function literal with receiver, which will be passed to &lt;code&gt;tree()&lt;/code&gt; as the &lt;code&gt;initialize&lt;/code&gt; parameter. According to the parameter list of &lt;code&gt;tree()&lt;/code&gt;, the receiver is of type &lt;code&gt;TreeNode&lt;/code&gt;, and therefore, &lt;code&gt;tree()&lt;/code&gt; can call &lt;code&gt;initialize()&lt;/code&gt; on &lt;code&gt;root&lt;/code&gt;. &lt;code&gt;root&lt;/code&gt; then becomes &lt;code&gt;this&lt;/code&gt; inside the scope of that lambda expression, so when we call &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt;, it implicitly says &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt;, where &lt;code&gt;this&lt;/code&gt; refers to the same &lt;code&gt;TreeNode&lt;/code&gt; as &lt;code&gt;root&lt;/code&gt;. The next block is passed to &lt;code&gt;TreeNode.node()&lt;/code&gt;, and is invoked on the first child of the &lt;code&gt;root&lt;/code&gt; node, namely &lt;code&gt;math&lt;/code&gt;, and inside it, &lt;code&gt;this&lt;/code&gt; will refer to &lt;code&gt;math&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; 之后的块是具有接收器的第一个函数文字，它将作为 &lt;code&gt;initialize&lt;/code&gt; 参数传递给 &lt;code&gt;tree()&lt;/code&gt; 。根据 &lt;code&gt;tree()&lt;/code&gt; 的参数列表，接收方的类型为 &lt;code&gt;TreeNode&lt;/code&gt; ，因此 &lt;code&gt;tree()&lt;/code&gt; 可以在 &lt;code&gt;root&lt;/code&gt; 上调用 &lt;code&gt;initialize()&lt;/code&gt; 。 &lt;code&gt;root&lt;/code&gt; 然后变成 &lt;code&gt;this&lt;/code&gt; 该lambda表达式的范围内，因此，当我们称之为 &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt; ，它隐含说 &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt; ，其中， &lt;code&gt;this&lt;/code&gt; 指的是相同的 &lt;code&gt;TreeNode&lt;/code&gt; 为 &lt;code&gt;root&lt;/code&gt; 。下一个块传递给 &lt;code&gt;TreeNode.node()&lt;/code&gt; ，并在 &lt;code&gt;root&lt;/code&gt; 的第一个子节点 &lt;code&gt;math&lt;/code&gt; 上调用，在其内部， &lt;code&gt;this&lt;/code&gt; 将引用 &lt;code&gt;math&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="299004dba6c7ef441e08541633a7bed7d65922cd" translate="yes" xml:space="preserve">
          <source>The body can be a block.</source>
          <target state="translated">身体可以是块。</target>
        </trans-unit>
        <trans-unit id="d17dad4981064bd9e13820de989411c6afec8c62" translate="yes" xml:space="preserve">
          <source>The body of an object expression may access, and possibly modify, the local variables of the containing scope.</source>
          <target state="translated">对象表达式的主体可以访问并可能修改包含作用域的局部变量。</target>
        </trans-unit>
        <trans-unit id="6eb082a62156761cbe45120602d0be4ff5a5d1b2" translate="yes" xml:space="preserve">
          <source>The box classes used for capturing mutable closure variables in lambdas no longer have volatile fields. This change improves performance, but can lead to new race conditions in some rare usage scenarios. If you're affected by this, you need to provide your own synchronization for accessing the variables.</source>
          <target state="translated">用于捕获lambdas中的可突变闭合变量的盒子类不再具有易失性字段。这一变化提高了性能,但在一些罕见的使用场景中会导致新的竞赛条件。如果你受此影响,你需要提供自己的同步来访问变量。</target>
        </trans-unit>
        <trans-unit id="0bb1979f4fa500a54eb079957dc97f38da2dd0fd" translate="yes" xml:space="preserve">
          <source>The build generates the following files under the &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; folder, depending on the host OS:</source>
          <target state="translated">根据主机操作系统，内部 &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; 在build / bin / native / debugShared文件夹下生成以下文件：</target>
        </trans-unit>
        <trans-unit id="8d7f1cfca83f4be43b98d7bc6f3dc13e77358eda" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;C().foo(1)&lt;/code&gt; will print &quot;extension&quot;.</source>
          <target state="translated">对 &lt;code&gt;C().foo(1)&lt;/code&gt; 的调用将显示&amp;ldquo;扩展名&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5986952e4227de9affa4abe69a35c446c0bfc14d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;execute&lt;/code&gt; uses a function passed as its second parameter to produce an object subgraph (i.e. set of mutually referring objects) which is then passed as a whole to that worker, it is then no longer available to the thread that initiated the request. This property is checked if the first parameter is &lt;code&gt;TransferMode.SAFE&lt;/code&gt; by graph traversal and is just assumed to be true, if it is &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt;. The last parameter to &lt;code&gt;execute&lt;/code&gt; is a special Kotlin lambda, which is not allowed to capture any state, and is actually invoked in the target worker's context. Once processed, the result is transferred to whatever consumes it in the future, and it is attached to the object graph of that worker/thread.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 调用使用作为其第二个参数传递的函数来生成对象子图（即相互引用的对象集），然后将该对象子图作为一个整体传递给该工作程序，然后该线程不再可用于发起请求的线程。如果通过图形遍历检查第一个参数是否为 &lt;code&gt;TransferMode.SAFE&lt;/code&gt; ，并且如果它为 &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt; ，则假定该属性为true 。要 &lt;code&gt;execute&lt;/code&gt; 的最后一个参数是特殊的Kotlin lambda，它不允许捕获任何状态，并且实际上是在目标工作程序的上下文中调用的。处理后，结果将转移到将来消耗它的任何对象，并将其附加到该工作程序/线程的对象图。</target>
        </trans-unit>
        <trans-unit id="cf4d64ccc981a36348dc5e3486734b7a527c1cd6" translate="yes" xml:space="preserve">
          <source>The callback which is called after the change of the property is made. The value of the property has already been changed when this callback is invoked.</source>
          <target state="translated">属性改变后调用的回调。当这个回调被调用时,属性的值已经被改变。</target>
        </trans-unit>
        <trans-unit id="f46a88a879fdbb85f0bd5182483f8be3f20e50d2" translate="yes" xml:space="preserve">
          <source>The callback which is called before a change to the property value is attempted. The value of the property hasn't been changed yet, when this callback is invoked. If the callback returns &lt;code&gt;true&lt;/code&gt; the value of the property is being set to the new value, and if the callback returns &lt;code&gt;false&lt;/code&gt; the new value is discarded and the property remains its old value.</source>
          <target state="translated">尝试更改属性值之前调用的回调。调用此回调时，属性的值尚未更改。如果回调返回 &lt;code&gt;true&lt;/code&gt; ，则将属性的值设置为新值，如果回调返回 &lt;code&gt;false&lt;/code&gt; ，则丢弃新值，并且该属性保留其旧值。</target>
        </trans-unit>
        <trans-unit id="e3032cd7941afef1fb6a2120a573d1232d288d72" translate="yes" xml:space="preserve">
          <source>The calls that affect inference are either members of the receiver type of an annotated function parameter or extensions for that type. The extensions must be themselves annotated with &lt;code&gt;@BuilderInference&lt;/code&gt;.</source>
          <target state="translated">影响推理的调用是带注释的函数参数的接收器类型的成员或该类型的扩展。扩展本身必须使用 &lt;code&gt;@BuilderInference&lt;/code&gt; 进行注释。</target>
        </trans-unit>
        <trans-unit id="5833c1f716afd68e76f6ee63506f61a1ac4d8150" translate="yes" xml:space="preserve">
          <source>The changes in dependencies are &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; compatible. For example, the only changes are in method bodies.</source>
          <target state="translated">依赖项的更改与&lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt;兼容。例如，唯一的变化是方法主体。</target>
        </trans-unit>
        <trans-unit id="ca6d3d47c03bc25dbb852207c0d849513ed5fbaf" translate="yes" xml:space="preserve">
          <source>The channels shown so far had no buffer. Unbuffered channels transfer elements when sender and receiver meet each other (aka rendezvous). If send is invoked first, then it is suspended until receive is invoked, if receive is invoked first, it is suspended until send is invoked.</source>
          <target state="translated">目前显示的信道没有缓冲区。无缓冲的通道在发送方和接收方相遇(也就是会合)时传输元素。如果先调用send,则暂停直至调用receive,如果先调用receive,则暂停直至调用send。</target>
        </trans-unit>
        <trans-unit id="fa768c5c4432c77d50de790cda1c8c687dccf1cc" translate="yes" xml:space="preserve">
          <source>The character &quot; &amp;ndash; quotation mark</source>
          <target state="translated">字符&amp;ldquo; &amp;ndash;引号</target>
        </trans-unit>
        <trans-unit id="10c860623b3bfd4256ce034a4fa10ecca2e8d17c" translate="yes" xml:space="preserve">
          <source>The character $ &amp;ndash; dollar sign</source>
          <target state="translated">字符$ &amp;ndash;美元符号</target>
        </trans-unit>
        <trans-unit id="bb0b9f77aa3a2b1b235948227a9bb6e95724f73c" translate="yes" xml:space="preserve">
          <source>The character &amp;Dagger;</source>
          <target state="translated">人物 &amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="97d065e0957f914068e24066c8bc53313cb9196a" translate="yes" xml:space="preserve">
          <source>The character &amp;Prime;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="697b0963155a10d5f080f157c0e1d9c9aacc9b21" translate="yes" xml:space="preserve">
          <source>The character &amp;amp; &amp;ndash; ampersand</source>
          <target state="translated">字符＆&amp;ndash;和号</target>
        </trans-unit>
        <trans-unit id="094872d2798a25e27adaff380803676c236be373" translate="yes" xml:space="preserve">
          <source>The character &amp;asymp;</source>
          <target state="translated">字符&amp;asymp;</target>
        </trans-unit>
        <trans-unit id="41d60c0526caa8463741bd966759bf19026cb739" translate="yes" xml:space="preserve">
          <source>The character &amp;bdquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="fff1f1e9d607e97e90b4bc028bb0cc7f10c48e01" translate="yes" xml:space="preserve">
          <source>The character &amp;bull;</source>
          <target state="translated">人物 &amp;bull;</target>
        </trans-unit>
        <trans-unit id="143c3fcec665ebddc83c2753db67d88e2fbaf38a" translate="yes" xml:space="preserve">
          <source>The character &amp;cent;</source>
          <target state="translated">字符&amp;cent;</target>
        </trans-unit>
        <trans-unit id="ee171eaf967121aa215c85e62d2ec509ebb04257" translate="yes" xml:space="preserve">
          <source>The character &amp;copy;</source>
          <target state="translated">字符&amp;copy;</target>
        </trans-unit>
        <trans-unit id="314c38bf0716b200771c1a885fab69a9b65b99c6" translate="yes" xml:space="preserve">
          <source>The character &amp;dagger;</source>
          <target state="translated">人物 &amp;dagger;</target>
        </trans-unit>
        <trans-unit id="6f9bd3084db43833f63880cca5d946309a97ca39" translate="yes" xml:space="preserve">
          <source>The character &amp;deg;</source>
          <target state="translated">字符&amp;deg;</target>
        </trans-unit>
        <trans-unit id="0e423b28ce34d3cf18fda3a07cf0dfa515d8890e" translate="yes" xml:space="preserve">
          <source>The character &amp;euro;</source>
          <target state="translated">角色&amp;euro;</target>
        </trans-unit>
        <trans-unit id="b1449855c21d4fd06c0d5e74b5a2a7a14edf968a" translate="yes" xml:space="preserve">
          <source>The character &amp;frac12;</source>
          <target state="translated">字符&amp;frac12;</target>
        </trans-unit>
        <trans-unit id="1fa4a09afc8d4c4f53c306db471f300c4497957c" translate="yes" xml:space="preserve">
          <source>The character &amp;ge;</source>
          <target state="translated">字符&amp;ge;</target>
        </trans-unit>
        <trans-unit id="3dfbeeaef1c98d8a22709ebef333428072939a42" translate="yes" xml:space="preserve">
          <source>The character &amp;gt; &amp;ndash; greater-than sign</source>
          <target state="translated">字符&amp;gt; &amp;ndash;大于号</target>
        </trans-unit>
        <trans-unit id="6eb5e1e14a002081da7d716b380be22cde00b939" translate="yes" xml:space="preserve">
          <source>The character &amp;hellip;</source>
          <target state="translated">人物 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a01873a887462b6593c2f5f42a550b38052e578a" translate="yes" xml:space="preserve">
          <source>The character &amp;laquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e667dca130564a78a41110f6cbd1264a713d8dd2" translate="yes" xml:space="preserve">
          <source>The character &amp;ldquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="950de0de2afce4fa96ad4f62ca4dab286d3d82a8" translate="yes" xml:space="preserve">
          <source>The character &amp;le;</source>
          <target state="translated">字符&amp;le;</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">人物 '</target>
        </trans-unit>
        <trans-unit id="e9f2776cd83195ab61d81c705eb53d1d3649fd0e" translate="yes" xml:space="preserve">
          <source>The character &amp;lt; &amp;ndash; less-than sign</source>
          <target state="translated">字符&amp;lt;&amp;ndash;小于号</target>
        </trans-unit>
        <trans-unit id="7e613a75a280526a06a5c3a8cccd7722979dfc79" translate="yes" xml:space="preserve">
          <source>The character &amp;mdash;</source>
          <target state="translated">人物 -</target>
        </trans-unit>
        <trans-unit id="257dd2718c3d554488c288a2e9f88456100a73ef" translate="yes" xml:space="preserve">
          <source>The character &amp;middot;</source>
          <target state="translated">人物 &amp;middot;</target>
        </trans-unit>
        <trans-unit id="b00154ce5f2758f6abb5e4356e419ba3e2aed105" translate="yes" xml:space="preserve">
          <source>The character &amp;ndash;</source>
          <target state="translated">人物 -</target>
        </trans-unit>
        <trans-unit id="aad571a2b53620d99840a4d55bce3f5907371d75" translate="yes" xml:space="preserve">
          <source>The character &amp;ne;</source>
          <target state="translated">字符&amp;ne;</target>
        </trans-unit>
        <trans-unit id="a360453c2e244288bd242eeb7641ad601e593f75" translate="yes" xml:space="preserve">
          <source>The character &amp;para;</source>
          <target state="translated">人物 &amp;para;</target>
        </trans-unit>
        <trans-unit id="1c97c4311adda721fa170a84ab8496cb5535afa3" translate="yes" xml:space="preserve">
          <source>The character &amp;plusmn;</source>
          <target state="translated">字符&amp;plusmn;</target>
        </trans-unit>
        <trans-unit id="55144636deb97ada56b2d29a7bb655a9f22ea932" translate="yes" xml:space="preserve">
          <source>The character &amp;pound;</source>
          <target state="translated">角色&amp;pound;</target>
        </trans-unit>
        <trans-unit id="09c581b6f45120a7ecac89f6de96696cea52b01c" translate="yes" xml:space="preserve">
          <source>The character &amp;prime;</source>
          <target state="translated">人物 '</target>
        </trans-unit>
        <trans-unit id="c49eacef46814486b9678b461b5fad7053d65453" translate="yes" xml:space="preserve">
          <source>The character &amp;raquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b94a5614ad8379d659840f63e74a095d51d6a7c0" translate="yes" xml:space="preserve">
          <source>The character &amp;rdquo;</source>
          <target state="translated">人物 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="be87e8e3080722678155d4e087ea1bf466788605" translate="yes" xml:space="preserve">
          <source>The character &amp;reg;</source>
          <target state="translated">人物&amp;reg;</target>
        </trans-unit>
        <trans-unit id="e6daa833ce04c765a61d1650a1e4e3d75924ca44" translate="yes" xml:space="preserve">
          <source>The character &amp;rsquo;</source>
          <target state="translated">人物 '</target>
        </trans-unit>
        <trans-unit id="43ad6d82b90d71d375e73e1b9402ca5934e45166" translate="yes" xml:space="preserve">
          <source>The character &amp;sbquo;</source>
          <target state="translated">人物 ，</target>
        </trans-unit>
        <trans-unit id="4139cb770ca9a15c26a42368989f1dc39e1910da" translate="yes" xml:space="preserve">
          <source>The character &amp;sect;</source>
          <target state="translated">人物 &amp;sect;</target>
        </trans-unit>
        <trans-unit id="98e7fc24f032b2c1437d0f55811d67ee1de7b88e" translate="yes" xml:space="preserve">
          <source>The character &amp;times;</source>
          <target state="translated">角色&amp;times;</target>
        </trans-unit>
        <trans-unit id="f6467d07a9719c1073ddb29614f3d2a5ac72dfb3" translate="yes" xml:space="preserve">
          <source>The character &amp;trade;</source>
          <target state="translated">人物&amp;trade;</target>
        </trans-unit>
        <trans-unit id="1789ee1227acc918fbc63737b2058bf75be81287" translate="yes" xml:space="preserve">
          <source>The class can also declare &lt;strong&gt;secondary constructors&lt;/strong&gt;, which are prefixed with &lt;em&gt;constructor&lt;/em&gt;:</source>
          <target state="translated">该类还可以声明&lt;strong&gt;辅助构造函数&lt;/strong&gt;，它们以&lt;em&gt;构造函数&lt;/em&gt;为前缀：</target>
        </trans-unit>
        <trans-unit id="bc78b13ff48b9fc50475495610ff41f558bf6256" translate="yes" xml:space="preserve">
          <source>The class declaration consists of the class name, the class header (specifying its type parameters, the primary constructor etc.) and the class body, surrounded by curly braces. Both the header and the body are optional; if the class has no body, curly braces can be omitted.</source>
          <target state="translated">类声明由类名、类头(指定类型参数、主要构造函数等)和类主体组成,用大括号包围。头和主体都是可选的;如果类没有主体,大括号可以省略。</target>
        </trans-unit>
        <trans-unit id="20fb66c6dd38ed7ad8f3ab7df8f07a3ccc7c3a1d" translate="yes" xml:space="preserve">
          <source>The class file with a kind not listed here is treated as a non-Kotlin file.</source>
          <target state="translated">这里没有列出的类文件将作为非Kotlin文件处理。</target>
        </trans-unit>
        <trans-unit id="8d923d6e9fe47217a8cbe28cd4bc0054618db9f2" translate="yes" xml:space="preserve">
          <source>The code above uses a &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;bound class reference&lt;/a&gt;, which is supported since Kotlin 1.1. You can also use the &lt;code&gt;javaClass&lt;/code&gt; extension property:</source>
          <target state="translated">上面的代码使用了&lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;绑定类引用&lt;/a&gt;，从Kotlin 1.1开始就支持该引用。您还可以使用 &lt;code&gt;javaClass&lt;/code&gt; 扩展属性：</target>
        </trans-unit>
        <trans-unit id="2a037143482eba48d7a06126430f1e3e039ee172" translate="yes" xml:space="preserve">
          <source>The code in question is from the &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;simple&lt;/a&gt; example (comments removed for brevity)</source>
          <target state="translated">有问题的代码来自&lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;简单的&lt;/a&gt;示例（为简洁起见删除了注释）</target>
        </trans-unit>
        <trans-unit id="02b7f3091db5cc1f6df8785c890e5a0df1e43276" translate="yes" xml:space="preserve">
          <source>The code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 文件中的代码可能如下所示：</target>
        </trans-unit>
        <trans-unit id="8051836ca1f9bfcf8f55044dce46370d2274f4e3" translate="yes" xml:space="preserve">
          <source>The code in the final &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">最终的 &lt;code&gt;hello.kt&lt;/code&gt; 文件中的代码可能如下所示：</target>
        </trans-unit>
        <trans-unit id="53a9cf6b4f40ef47e2031c236bc499f1385bb27e" translate="yes" xml:space="preserve">
          <source>The code is full of Objective-C attributes, which are intended to help the use of the framework from both Objective-C and Swift languages. &lt;code&gt;DemoClazz&lt;/code&gt;, &lt;code&gt;DemoInterface&lt;/code&gt;, and &lt;code&gt;DemoObject&lt;/code&gt; are created for &lt;code&gt;Clazz&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt; respectively. The &lt;code&gt;Interface&lt;/code&gt; is turned into &lt;code&gt;@protocol&lt;/code&gt;, both a &lt;code&gt;class&lt;/code&gt; and an &lt;code&gt;object&lt;/code&gt; are represented as &lt;code&gt;@interface&lt;/code&gt;. The &lt;code&gt;Demo&lt;/code&gt; prefix comes from the &lt;code&gt;-output&lt;/code&gt; parameter of the &lt;code&gt;kotlinc-native&lt;/code&gt; compiler and the framework name. We see here that the nullable return type &lt;code&gt;ULong?&lt;/code&gt; is turned into &lt;code&gt;DemoLong*&lt;/code&gt; in Objective-C.</source>
          <target state="translated">该代码充满了Objective-C属性，旨在帮助使用Objective-C和Swift语言的框架。 &lt;code&gt;DemoClazz&lt;/code&gt; ， &lt;code&gt;DemoInterface&lt;/code&gt; 和 &lt;code&gt;DemoObject&lt;/code&gt; 的是为创建 &lt;code&gt;Clazz&lt;/code&gt; ， &lt;code&gt;Interface&lt;/code&gt; ，和 &lt;code&gt;Object&lt;/code&gt; 分别。的 &lt;code&gt;Interface&lt;/code&gt; 变成 &lt;code&gt;@protocol&lt;/code&gt; ，既是一个 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;object&lt;/code&gt; 被表示为 &lt;code&gt;@interface&lt;/code&gt; 。该 &lt;code&gt;Demo&lt;/code&gt; 前缀来自 &lt;code&gt;-output&lt;/code&gt; 的参数 &lt;code&gt;kotlinc-native&lt;/code&gt; 编译器和框架的名字。我们在这里看到可以为null的返回类型 &lt;code&gt;ULong?&lt;/code&gt; 在Objective-C中变成了 &lt;code&gt;DemoLong*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb3f232ccbe55c8a64749007e2a52df82753b753" translate="yes" xml:space="preserve">
          <source>The code is still written as if we were writing synchronous code, top-down, without the need of any special syntax, beyond the use of a function called &lt;code&gt;launch&lt;/code&gt; which essentially kicks-off the coroutine (covered in other tutorials).</source>
          <target state="translated">仍然使用自上而下的方式编写代码，而不需要任何特殊的语法，除了使用称为 &lt;code&gt;launch&lt;/code&gt; 的函数之外，该函数实质上启动了协程（在其他教程中已发现）。</target>
        </trans-unit>
        <trans-unit id="a467b8b9b7ee4d493e257af4cbf437bbbbde6f1c" translate="yes" xml:space="preserve">
          <source>The code or data pointed by the value of this variable.</source>
          <target state="translated">该变量的值所指向的代码或数据。</target>
        </trans-unit>
        <trans-unit id="02020b547b7971154705decbe3b4487f3a320a20" translate="yes" xml:space="preserve">
          <source>The code reads as follows. We have the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure, which defines all the functions that Kotlin/Native and our library provides us. It uses nested anonymous structures heavily to mimic packages. The &lt;code&gt;libnative_&lt;/code&gt; prefix comes from the library name.</source>
          <target state="translated">代码如下。我们具有 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 结构，该结构定义Kotlin / Native和我们的库为我们提供的所有功能。它大量使用嵌套的匿名结构来模仿程序包。该 &lt;code&gt;libnative_&lt;/code&gt; 前缀来自库名。</target>
        </trans-unit>
        <trans-unit id="38d106af82f35f678ad2690b0baa41429ea7b73f" translate="yes" xml:space="preserve">
          <source>The code uses anonymous structure declarations. The code &lt;code&gt;struct { .. } foo&lt;/code&gt; declares a field in the outer struct of that anonymous structure type, the type with no name.</source>
          <target state="translated">该代码使用匿名结构声明。代码 &lt;code&gt;struct { .. } foo&lt;/code&gt; 在该匿名结构类型（没有名称的类型）的外部结构中声明了一个字段。</target>
        </trans-unit>
        <trans-unit id="5a75d5c9d164b0af6fa981261ed056bb33166b99" translate="yes" xml:space="preserve">
          <source>The collection interfaces and related functions are located in the kotlin.collections package. Let's get an overview of its contents.</source>
          <target state="translated">集合接口和相关函数位于kotlin.collection包中。我们先来了解一下它的内容。</target>
        </trans-unit>
        <trans-unit id="8eb00e1a99072f02da7c9734f0160d0f6d88090d" translate="yes" xml:space="preserve">
          <source>The command produces the &lt;code&gt;main.exe&lt;/code&gt; file, which we can run.</source>
          <target state="translated">该命令将生成 &lt;code&gt;main.exe&lt;/code&gt; 文件，我们可以运行该文件。</target>
        </trans-unit>
        <trans-unit id="c3c76c63d39731dfbcdc20b108a998ffa2cab356" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">所有枚举类的公共基类。有关枚举类的更多信息，请参见&lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin语言文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0aedfb3fef921fc9d29c01593b4d03896cda204" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">所有枚举类的公共基类。有关枚举类的更多信息，请参见&lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin语言文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81167d80c8bd1494ae8b5c6e43cfe5f3d98e0f63" translate="yes" xml:space="preserve">
          <source>The common code is &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt;, where &lt;code&gt;platformName()&lt;/code&gt; is a function that is declared using the &lt;code&gt;expect&lt;/code&gt; keyword. The &lt;code&gt;actual&lt;/code&gt; implementation will be specific to the platform.</source>
          <target state="translated">通用代码是 &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt; ，其中 &lt;code&gt;platformName()&lt;/code&gt; 是使用 &lt;code&gt;expect&lt;/code&gt; 关键字声明的函数。在 &lt;code&gt;actual&lt;/code&gt; 实施将是特定于平台。</target>
        </trans-unit>
        <trans-unit id="26e2504fa6bfc493ea02066bb2b03d45d4bc4811" translate="yes" xml:space="preserve">
          <source>The common source sets cannot include Java sources.</source>
          <target state="translated">通用源集不能包含Java源。</target>
        </trans-unit>
        <trans-unit id="95ec79a350a2b7276da32a4ea5b29db260f72d85" translate="yes" xml:space="preserve">
          <source>The common supertype for all callable references is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt;&lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;R&lt;/code&gt; is the return value type, which is the property type for properties, and the constructed type for constructors.</source>
          <target state="translated">所有可调用引用的通用超类型是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt; &lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;R&lt;/code&gt; 是返回值类型，它是属性的属性类型，而构造函数是构造类型。</target>
        </trans-unit>
        <trans-unit id="b490df5b9d3260a0f0b5037a5c6848fe5e1088c0" translate="yes" xml:space="preserve">
          <source>The companion object &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; is the default instance of &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;.</source>
          <target state="translated">伴随对象&lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt;是&lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;的默认实例。</target>
        </trans-unit>
        <trans-unit id="d53a914136005ae6f435321f1dcd61b723a192c1" translate="yes" xml:space="preserve">
          <source>The companion object is a singleton, and its members can be accessed directly via the name of the containing class (although you can also insert the name of the companion object if you want to be explicit about accessing the companion object):</source>
          <target state="translated">同伴对象是一个单子,它的成员可以直接通过包含类的名称来访问(不过如果你想明确访问同伴对象,也可以插入同伴对象的名称)。</target>
        </trans-unit>
        <trans-unit id="1e2216eb9ae725f1d6c56e917607f0c9488b74a1" translate="yes" xml:space="preserve">
          <source>The compiler automatically derives the following members from all properties declared in the primary constructor:</source>
          <target state="translated">编译器会自动从主构造函数中声明的所有属性中导出以下成员。</target>
        </trans-unit>
        <trans-unit id="6577ea37c1117c7a1d89eaf0755007d75c98ca87" translate="yes" xml:space="preserve">
          <source>The compiler can infer the function types for variables if there is enough information:</source>
          <target state="translated">如果有足够的信息,编译器可以推断出变量的函数类型。</target>
        </trans-unit>
        <trans-unit id="6c9d4888e9777e469bf8f8415875e00d70265bbb" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every expected declaration has actual declarations in all platform modules that implement the corresponding common module, and reports an error if any actual declarations are missing. The IDE provides tools that help you create the missing actual declarations.</source>
          <target state="translated">编译器确保每个预期的声明在所有实现相应通用模块的平台模块中都有实际的声明,如果缺少任何实际声明,编译器会报错。集成开发环境提供的工具可以帮助你创建缺失的实际声明。</target>
        </trans-unit>
        <trans-unit id="1bc9fa0ea96f6adbeae3b32244221538e36f7db6" translate="yes" xml:space="preserve">
          <source>The compiler generates an executable called &lt;code&gt;a.out&lt;/code&gt;. We need to run it to see in action the Kotlin code being executed from C library. On Linux, we'll need to include &lt;code&gt;.&lt;/code&gt; into the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; to let the application know to load the &lt;code&gt;libnative.so&lt;/code&gt; library from the current folder.</source>
          <target state="translated">编译器生成一个称为 &lt;code&gt;a.out&lt;/code&gt; 的可执行文件。我们需要运行它以查看从C库执行的Kotlin代码的作用。在Linux上，我们需要包含 &lt;code&gt;.&lt;/code&gt; 进入 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; ，让应用程序知道从当前文件夹中加载 &lt;code&gt;libnative.so&lt;/code&gt; 库。</target>
        </trans-unit>
        <trans-unit id="9c32f1ebf038bdf8cbaba8702b89e98ca18e811a" translate="yes" xml:space="preserve">
          <source>The compiler is smart enough to know a cast to be safe if a negative check leads to a return:</source>
          <target state="translated">编译器很聪明,它知道如果负检查导致返回,那么投掷是安全的。</target>
        </trans-unit>
        <trans-unit id="6c760f17f753a0cd7195aa08e67eb2dc50e9752a" translate="yes" xml:space="preserve">
          <source>The compiler now inlines values of &lt;code&gt;const val&lt;/code&gt; properties into the locations where they are used.</source>
          <target state="translated">现在，编译器将 &lt;code&gt;const val&lt;/code&gt; 属性的值内联到使用它们的位置。</target>
        </trans-unit>
        <trans-unit id="4ba2b709c858d08263f181dafb3aabf655fd192d" translate="yes" xml:space="preserve">
          <source>The compiler now provides an option to treat all warnings as errors. Use &lt;code&gt;-Werror&lt;/code&gt; on the command line, or the following Gradle snippet:</source>
          <target state="translated">编译器现在提供了将所有警告视为错误的选项。在命令行上或以下Gradle片段中使用 &lt;code&gt;-Werror&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71411ab1eb04e1e2a8b1556ddf262cc1922d7424" translate="yes" xml:space="preserve">
          <source>The compiler performs the following steps for resolution of an operator in the &lt;em&gt;postfix&lt;/em&gt; form, e.g. &lt;code&gt;a++&lt;/code&gt;:</source>
          <target state="translated">编译器执行以下步骤来解析&lt;em&gt;后缀&lt;/em&gt;形式的运算符，例如 &lt;code&gt;a++&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ade270e63280116ba329a9222cd68e987a0137a2" translate="yes" xml:space="preserve">
          <source>The compiler produces a warning for the cast in the last line. The cast cannot be fully checked at runtime and provides no guarantee that the values in the map are &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">编译器在最后一行为转换产生警告。在运行时无法完全检查强制类型转换，也不保证映射中的值为 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c187f47b8c07f5d91c0556c45f360de519c42c3f" translate="yes" xml:space="preserve">
          <source>The compiler produces the code relevant for the target module system, for example, in case of CommonJS, it will import the declaration via the &lt;code&gt;require(...)&lt;/code&gt; function.</source>
          <target state="translated">编译器生成与目标模块系统相关的代码，例如，对于CommonJS，它将通过 &lt;code&gt;require(...)&lt;/code&gt; 函数导入声明。</target>
        </trans-unit>
        <trans-unit id="8552578d258f1326cbba27a9248961d718afcda8" translate="yes" xml:space="preserve">
          <source>The compiler tracks the information about the check you performed, and allows the call to &lt;code&gt;length&lt;/code&gt; inside the &lt;em&gt;if&lt;/em&gt;. More complex conditions are supported as well:</source>
          <target state="translated">编译器跟踪有关您执行的检查的信息，并允许在&lt;em&gt;if&lt;/em&gt;内调用 &lt;code&gt;length&lt;/code&gt; 。还支持更复杂的条件：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9778744271ecf22c5df54071242110d274ebb382" translate="yes" xml:space="preserve">
          <source>The compiler will allow this function to be called as e.g. &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt;, but not as &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(null, null)&lt;/code&gt;. Calling &lt;code&gt;test(a, b)&lt;/code&gt; is only allowed if the compiler can prove that &lt;code&gt;a&lt;/code&gt; cannot possibly be null. Inside of &lt;code&gt;test&lt;/code&gt;, the compiler will not allow you to do anything with &lt;code&gt;b&lt;/code&gt; that would result in an exception if &lt;code&gt;b&lt;/code&gt; should happen to be null - so you can do &lt;code&gt;a.length&lt;/code&gt;, but not &lt;code&gt;b.length&lt;/code&gt;. However, once you're inside a conditional where you have checked that &lt;code&gt;b&lt;/code&gt; is not null, you can do it:</source>
          <target state="translated">编译器将允许将此函数调用为例如 &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; 或 &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt; ，而不是称为 &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; 或 &lt;code&gt;test(null, null)&lt;/code&gt; 。仅当编译器可以证明 &lt;code&gt;a&lt;/code&gt; 不可能为null时，才允许调用 &lt;code&gt;test(a, b)&lt;/code&gt; 。在 &lt;code&gt;test&lt;/code&gt; ，如果 &lt;code&gt;b&lt;/code&gt; 恰好为null ，则编译器将不允许您对 &lt;code&gt;b&lt;/code&gt; 进行任何操作，否则会导致异常-因此您可以执行 &lt;code&gt;a.length&lt;/code&gt; ，但不能执行 &lt;code&gt;b.length&lt;/code&gt; 。但是，一旦您处于检查 &lt;code&gt;b&lt;/code&gt; 不为null的条件内，就可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="d2b29d9a02116dffd597657f45323e8d260b605c" translate="yes" xml:space="preserve">
          <source>The compiler will generate something like this (except that &lt;code&gt;start&lt;/code&gt; won't collide with any other identifiers with the same name):</source>
          <target state="translated">编译器将生成类似以下内容的代码（除了 &lt;code&gt;start&lt;/code&gt; 不会与任何其他同名标识符冲突）：</target>
        </trans-unit>
        <trans-unit id="93c0badc9698bd83e21fa61741e490ba8801596d" translate="yes" xml:space="preserve">
          <source>The compiler will not let you perform checks that can't possibly succeed because the declared type of the variable is a class that is on an unrelated branch of the class hierarchy from the class you're checking against - if the declared type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;MotorVehicle&lt;/code&gt;, you can't check if &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;. If the right-hand side of &lt;code&gt;is&lt;/code&gt; is an interface, Kotlin will allow the type of the left-hand side to be any interface or open class, because it could be that some subclass thereof implements the interface.</source>
          <target state="translated">编译器不会让您执行无法成功执行的检查，因为变量的声明类型是要检查的类的类层次结构的不相关分支上的类-如果 &lt;code&gt;x&lt;/code&gt; 的声明类型为 &lt;code&gt;MotorVehicle&lt;/code&gt; ，您不能检查 &lt;code&gt;x&lt;/code&gt; 是否是 &lt;code&gt;Person&lt;/code&gt; 。如果的右边 &lt;code&gt;is&lt;/code&gt; 是一个接口，科特林将使左侧的类型是任何接口或公开课，因为它可能是一些子类及其实现的接口。</target>
        </trans-unit>
        <trans-unit id="945c10a176528faf419fb001b8765fc6d7f48809" translate="yes" xml:space="preserve">
          <source>The complete list of options for the Gradle tasks is the following:</source>
          <target state="translated">Gradle任务的完整选项列表如下。</target>
        </trans-unit>
        <trans-unit id="cbc4e4912fffd8b8c15a7f1685ee311f7de94af5" translate="yes" xml:space="preserve">
          <source>The consumer may only need to add the attribute to a single target where the ambiguity arises.</source>
          <target state="translated">消费者可能只需要将属性添加到一个出现歧义的目标上。</target>
        </trans-unit>
        <trans-unit id="2fa143f534ac2f4a54ee1e8593acf92219a64686" translate="yes" xml:space="preserve">
          <source>The contents of our &lt;code&gt;main.js&lt;/code&gt; would be:</source>
          <target state="translated">我们的 &lt;code&gt;main.js&lt;/code&gt; 的内容为：</target>
        </trans-unit>
        <trans-unit id="ccc1b0f9d51d769d3aac8a2e95f9b22ce641f370" translate="yes" xml:space="preserve">
          <source>The context of the coroutine that corresponds to this continuation.</source>
          <target state="translated">与该延续对应的coroutine的上下文。</target>
        </trans-unit>
        <trans-unit id="347bd2f03e4af765cba7e04d72d0cecc9c6bb8cc" translate="yes" xml:space="preserve">
          <source>The contract description must be at the beginning of a function and have at least one effect.</source>
          <target state="translated">合同说明必须在一个功能的开头,并且至少有一个效果。</target>
        </trans-unit>
        <trans-unit id="4954ad3fce80d9310d9ce43541aaf17e0123a4ea" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter of a function-typed return type (the user will call the returned function with something that can consume any &lt;code&gt;Fruit&lt;/code&gt;, so it's okay to return a function that expects to receive something that can handle &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型返回类型的参数的变量类型参数（用户将使用可能消耗任何 &lt;code&gt;Fruit&lt;/code&gt; 的东西来调用返回的函数，因此可以返回希望接收到可以处理 &lt;code&gt;Apple&lt;/code&gt; 的函数的函数是可以的）</target>
        </trans-unit>
        <trans-unit id="fc9281a07f7c7bacfae7f8c712a66286fa4aa11c" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter type (the user is passing a consumer that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">参数类型的反类型参数（用户正在传递可以处理任何 &lt;code&gt;Fruit&lt;/code&gt; 的使用者，并且它将获得 &lt;code&gt;Apple&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3b2df0437d1139299375d04a6b3d749596fe34b3" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of the return type of a function-typed parameter (the user is passing a function that will return a consumer of any &lt;code&gt;Fruit&lt;/code&gt;, and the returned consumer will be given &lt;code&gt;Apple&lt;/code&gt; instances)</source>
          <target state="translated">函数类型参数的返回类型的反类型参数（用户传递的函数将返回任何 &lt;code&gt;Fruit&lt;/code&gt; 的使用者，并且将为返回的使用者提供 &lt;code&gt;Apple&lt;/code&gt; 实例）</target>
        </trans-unit>
        <trans-unit id="3ed87fa7f81c4d406e21bd5206fb7068af42bc61" translate="yes" xml:space="preserve">
          <source>The convention that is followed is that each library gets its own definition file, usually named the same as the library. For more information on all the options available to &lt;code&gt;cinterop&lt;/code&gt;, see &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;the Interop documentation&lt;/a&gt;</source>
          <target state="translated">遵循的约定是，每个库都有其自己的定义文件，通常与该库命名相同。有关 &lt;code&gt;cinterop&lt;/code&gt; 所有可用选项的更多信息，请参见&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop文档。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d4ce8b1f45a5d6806ad09e59cc85adf7dc80106f" translate="yes" xml:space="preserve">
          <source>The coroutine context is a set of various elements. The main elements are the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the coroutine, which we've seen before, and its dispatcher, which is covered in this section.</source>
          <target state="translated">协程上下文是一组各种元素。主要元素是协同程序的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;工作&lt;/a&gt;（我们之前已经看到过）及其派遣程序，本节将对此进行介绍。</target>
        </trans-unit>
        <trans-unit id="09d67675b7aec2c1bf9665203e1b50714b4ffefe" translate="yes" xml:space="preserve">
          <source>The coroutine is started directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the completion's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established.</source>
          <target state="translated">协程直接在调用者的线程中启动，而无需经过&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;，而ContinuationInterceptor可能存在于完成的&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext中&lt;/a&gt;。调用者有责任确保建立正确的调用上下文。</target>
        </trans-unit>
        <trans-unit id="3db3fa62931fade33326b38aff7867fe578bfdd9" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context. The coroutine can retrieve it from its own context using &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="translated">协程的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;工作&lt;/a&gt;是其背景的一部分。协程可以使用 &lt;code&gt;coroutineContext[Job]&lt;/code&gt; 表达式从自己的上下文中检索它：</target>
        </trans-unit>
        <trans-unit id="e1d461218111d234968b7db694b9b764401c60b6" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;em&gt;sourceSets&lt;/em&gt; property should be updated if not using the default convention:</source>
          <target state="translated">如果不使用默认约定，则应更新相应的&lt;em&gt;sourceSets&lt;/em&gt;属性：</target>
        </trans-unit>
        <trans-unit id="16c7a1a50f1d32fc204564f81e6d0304f7356ed7" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a read-only property type (the user is expecting a producer of &lt;code&gt;Fruit&lt;/code&gt;, and gets a producer of &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">只读属性类型的协变量类型参数（用户期望得到 &lt;code&gt;Fruit&lt;/code&gt; 的生产者，而得到 &lt;code&gt;Apple&lt;/code&gt; 的生产者）</target>
        </trans-unit>
        <trans-unit id="7d1a94c8808bc3894d49e0ec4259312cbb359362" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a return type (the user is expecting that the returned value will produce a &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">返回类型的协变量类型参数（用户期望返回的值将产生 &lt;code&gt;Fruit&lt;/code&gt; ，因此，如果它确实产生 &lt;code&gt;Apple&lt;/code&gt; 没关系）</target>
        </trans-unit>
        <trans-unit id="ec6f1c24b0cd8b11d61e4f25576ab198b6bece55" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt; producer, and it will be given an &lt;code&gt;Apple&lt;/code&gt; producer)</source>
          <target state="translated">函数类型参数的参数类型的协变类型参数（用户正在传递可以处理任何 &lt;code&gt;Fruit&lt;/code&gt; 生产者的函数，并且它将获得 &lt;code&gt;Apple&lt;/code&gt; 生产者）</target>
        </trans-unit>
        <trans-unit id="bc2c5c3395341afe0bbd48554537d9a1ac25a9db" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the return type of a function-typed return type (the user expects the returned function to return something that produces &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">函数类型的返回类型的返回类型的协变量类型参数（用户希望返回的函数返回产生 &lt;code&gt;Fruit&lt;/code&gt; 的东西，因此，如果它确实产生 &lt;code&gt;Apple&lt;/code&gt; 是可以的）</target>
        </trans-unit>
        <trans-unit id="a39f5e4ad2c9626d5a5f458b4068b5771d3c11f9" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;StableRef&lt;/code&gt; should eventually be manually disposed using the &lt;code&gt;.dispose()&lt;/code&gt; method to prevent memory leaks:</source>
          <target state="translated">最终应使用 &lt;code&gt;.dispose()&lt;/code&gt; 方法手动处理创建的 &lt;code&gt;StableRef&lt;/code&gt; ,以防止内存泄漏：</target>
        </trans-unit>
        <trans-unit id="7dc376ddde1c64329f76a2fdf0f77fd2f42853b6" translate="yes" xml:space="preserve">
          <source>The created iOS application is ready to run on the iOS emulator or on the iOS device. The device run may require an Apple developer account and to issue a developer certificate. Xcode does its best to guide us through the process.</source>
          <target state="translated">创建的iOS应用已经准备好在iOS模拟器或iOS设备上运行。设备运行可能需要一个Apple开发者账号,并且要颁发开发者证书。Xcode会尽力引导我们完成这个过程。</target>
        </trans-unit>
        <trans-unit id="e20d095cd0f1efef77b1627ffafe7b1dfa3d28bf" translate="yes" xml:space="preserve">
          <source>The curly braces around a body can be omitted if the body is a oneliner. This is discouraged unless the body goes on the same line as the condition, because it makes it easy to make this mistake, especially when one is used to Python:</source>
          <target state="translated">如果 body 是 oneliner,可以省略 body 周围的大括号。除非主体与条件在同一条线上,否则不鼓励这样做,因为这很容易犯这个错误,特别是当人们习惯于使用 Python 时。</target>
        </trans-unit>
        <trans-unit id="dcfce21884a60ba71ce3d59d9e2af53e74e2e10c" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.3.41, published on July 4, 2019.</source>
          <target state="translated">目前发布的版本为1.3.41,发布时间为2019年7月4日。</target>
        </trans-unit>
        <trans-unit id="99a5ae4aba1310a5ec2c1c1ea8e6bbd89807b2b1" translate="yes" xml:space="preserve">
          <source>The declaration of the classifier used in this type. For example, in the type &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; the classifier would be the &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt; instance for &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;.</source>
          <target state="translated">此类型中使用的分类器的声明。例如，在类型 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; ，分类器将是&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;的&lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="e4cb77989b70ae7af02cc584cc3eb602ad306980" translate="yes" xml:space="preserve">
          <source>The declarations in the new artifacts are visible under the same package names from the Kotlin point of view, but have different package names for Java. Therefore, switching to the new artifacts will not require any changes to your source code.</source>
          <target state="translated">从Kotlin的角度来看,新工件中的声明在相同的包名下是可见的,但对于Java来说,包名不同。因此,切换到新的工件将不需要对您的源代码进行任何更改。</target>
        </trans-unit>
        <trans-unit id="38a82a6bd4d8bda70773fac15ae91a2110030d1c" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;encoding&lt;/a&gt; is UTF-8, but you can specify it if you need something else:</source>
          <target state="translated">默认&lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;编码&lt;/a&gt;为UTF-8，但如果需要其他内容，则可以指定它：</target>
        </trans-unit>
        <trans-unit id="7643db7f540eca7261e951018ad1bc000680e9fc" translate="yes" xml:space="preserve">
          <source>The default artifact IDs follow the pattern &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt;, for example &lt;code&gt;sample-lib-nodejs&lt;/code&gt; for a target named &lt;code&gt;nodeJs&lt;/code&gt; in a project &lt;code&gt;sample-lib&lt;/code&gt;.</source>
          <target state="translated">默认工件ID遵循 &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt; 模式，例如，对于project &lt;code&gt;sample-lib&lt;/code&gt; 中名为 &lt;code&gt;nodeJs&lt;/code&gt; 的目标，使用 &lt;code&gt;sample-lib-nodejs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b76c41789282ed3ab00f219e4dbda9192589571a" translate="yes" xml:space="preserve">
          <source>The default dispatcher, that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="translated">默认调度程序是在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default中&lt;/a&gt;表示的，它是在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中启动协程时使用的，并使用共享的后台线程池，因此 &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; 与 &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt; 使用相同的调度程序。 ..}。</target>
        </trans-unit>
        <trans-unit id="034812e12bafb58c2506d45936895dac0de7b559" translate="yes" xml:space="preserve">
          <source>The default implementation is available for Java classes implementing the interface.</source>
          <target state="translated">实现该接口的Java类可以使用默认实现。</target>
        </trans-unit>
        <trans-unit id="eae7fdc4a8ba33e2f9213a2722bb2903c080bbc0" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Map&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion when iterating the map. In turn, an alternative implementation &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; says nothing about the elements order.</source>
          <target state="translated">默认的实现 &lt;code&gt;Map&lt;/code&gt; - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; 的&lt;/a&gt; -保留元素插入时迭代地图的顺序。反过来，另一个实现&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;则没有说明元素顺序。</target>
        </trans-unit>
        <trans-unit id="1d4f4ecafdd233f07d5e3f6afd06222be0312077" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion. Hence, the functions that rely on the order, such as &lt;code&gt;first()&lt;/code&gt; or &lt;code&gt;last()&lt;/code&gt;, return predictable results on such sets.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; 的默认实现&amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt; &lt;code&gt;LinkedHashSet&lt;/code&gt; &lt;/a&gt; &amp;ndash;保留元素插入的顺序。因此，依赖顺序的函数 &lt;code&gt;first()&lt;/code&gt; 例如first（）或 &lt;code&gt;last()&lt;/code&gt; )在此类集合上返回可预测的结果。</target>
        </trans-unit>
        <trans-unit id="bed0e18ec00404266f1579a08902984894034905" translate="yes" xml:space="preserve">
          <source>The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is determined by the innermost enclosing element annotated with a type qualifier default annotation with the &lt;code&gt;ElementType&lt;/code&gt; matching the type usage.</source>
          <target state="translated">当类型本身未由可空性注释注释时，将使用默认可空性，并且默认值是由最里面的封闭元素确定的，该元素由类型限定符默认注释进行注释，且 &lt;code&gt;ElementType&lt;/code&gt; 与类型用法匹配。</target>
        </trans-unit>
        <trans-unit id="9d69906046e2ddf59f421f52ac090513e9b9f2a3" translate="yes" xml:space="preserve">
          <source>The default random number generator.</source>
          <target state="translated">默认的随机数发生器。</target>
        </trans-unit>
        <trans-unit id="f9ef35e4ea1c850fbe5f46bb280445cc0cd754fc" translate="yes" xml:space="preserve">
          <source>The default source set &lt;code&gt;commonMain&lt;/code&gt; is added to each production (application or library) variant's compilation. The &lt;code&gt;commonTest&lt;/code&gt; source set is, similarly, added to the compilations of unit test and instrumented test variants.</source>
          <target state="translated">默认的源集 &lt;code&gt;commonMain&lt;/code&gt; 被添加到每个生产（应用程序或库）变体的编译中。同样，将 &lt;code&gt;commonTest&lt;/code&gt; 源集添加到单元测试和检测测试变量的编译中。</target>
        </trans-unit>
        <trans-unit id="c561b55e89597682ebf08bcc014c20773fedb83e" translate="yes" xml:space="preserve">
          <source>The default upper bound (if none specified) is &lt;code&gt;Any?&lt;/code&gt;. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate &lt;strong&gt;where&lt;/strong&gt;-clause:</source>
          <target state="translated">默认上限（如果未指定）是 &lt;code&gt;Any?&lt;/code&gt; 。尖括号内只能指定一个上限。如果相同类型的参数需要一个以上的上限，则需要在&lt;strong&gt;其中使用&lt;/strong&gt; -clause：</target>
        </trans-unit>
        <trans-unit id="7b5f3fac0dd293e61c74032e957e6e608fec3b05" translate="yes" xml:space="preserve">
          <source>The default value is provided at the declaration of this parameter.</source>
          <target state="translated">默认值在该参数声明时提供。</target>
        </trans-unit>
        <trans-unit id="44653ab72c57ae2dec40031a1386b4afc98b3166" translate="yes" xml:space="preserve">
          <source>The definitions part shows how Kotlin primitive types map into C primitive types. We discussed reverse mapping in the &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt; tutorial.</source>
          <target state="translated">定义部分显示Kotlin基本类型如何映射为C基本类型。我们在&lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C语言&lt;/a&gt;教程的&amp;ldquo; 映射原始数据类型&amp;rdquo;中讨论了反向映射。</target>
        </trans-unit>
        <trans-unit id="7879370b21d5da1f44f128551f264e026a0fb9ed" translate="yes" xml:space="preserve">
          <source>The delegate class may implement one of the interfaces &lt;code&gt;ReadOnlyProperty&lt;/code&gt; and &lt;code&gt;ReadWriteProperty&lt;/code&gt; containing the required &lt;code&gt;operator&lt;/code&gt; methods. These interfaces are declared in the Kotlin standard library:</source>
          <target state="translated">委托类可以实现包含所需 &lt;code&gt;operator&lt;/code&gt; 方法的接口 &lt;code&gt;ReadOnlyProperty&lt;/code&gt; 和 &lt;code&gt;ReadWriteProperty&lt;/code&gt; 之一。这些接口在Kotlin标准库中声明：</target>
        </trans-unit>
        <trans-unit id="42bebb3adac2ab3e00fbad0af368d0931c57bd77" translate="yes" xml:space="preserve">
          <source>The delegated property can be used like this to declare a property in &lt;code&gt;Person&lt;/code&gt; - note the use of &lt;code&gt;by&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">可以像这样使用委派的属性在 &lt;code&gt;Person&lt;/code&gt; 中声明一个属性-注意使用 &lt;code&gt;by&lt;/code&gt; 代替 &lt;code&gt;=&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="973f16e5337bff9eb9481252b3daeac2f25a5f4f" translate="yes" xml:space="preserve">
          <source>The dependencies declared in this way are added in the podspec file and downloaded during the execution of &lt;code&gt;pod install&lt;/code&gt;.</source>
          <target state="translated">以这种方式声明的依赖项将添加到podspec文件中，并在执行 &lt;code&gt;pod install&lt;/code&gt; 期间下载。</target>
        </trans-unit>
        <trans-unit id="8e289438644482986fe5eb08aaf9b0616f49cac1" translate="yes" xml:space="preserve">
          <source>The described mechanism for marking and using experimental APIs is itself experimental in Kotlin 1.3. This means that in future releases it may be changed in ways that make it incompatible. To make the users of annotations &lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;UseExperimental&lt;/code&gt; aware of their experimental status, the compiler raises warnings when compiling the code with these annotations:</source>
          <target state="translated">标记和使用实验性API的机制本身在Kotlin 1.3中是实验性的。这意味着在将来的版本中，可能会以使其不兼容的方式进行更改。为了使注释 &lt;code&gt;@Experimental&lt;/code&gt; 和 &lt;code&gt;UseExperimental&lt;/code&gt; 的用户了解他们的实验状态，编译器在使用这些注释编译代码时会发出警告：</target>
        </trans-unit>
        <trans-unit id="cf37d613f63880e424569836a2ab82c0f6bbbfbf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is experimental, meaning that this feature is &lt;em&gt;moving fast&lt;/em&gt; and no compatibility guarantees are given. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature is experimental.</source>
          <target state="translated">内联类的设计是实验性的，这意味着此功能&lt;em&gt;正在快速发展，&lt;/em&gt;并且不提供兼容性保证。在Kotlin 1.3+中使用内联类时，将报告警告，表明此功能是实验性的。</target>
        </trans-unit>
        <trans-unit id="b65859994bf9d4a7fb5d934baaf88e39c3f04558" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is experimental, meaning that this feature is moving fast and no compatibility guarantees are given. When using unsigned arithmetics in Kotlin 1.3+, warning will be reported, indicating that this feature is experimental. To remove warning, you have to opt-in for experimental usage of unsigned types.</source>
          <target state="translated">无符号类型的设计是实验性的,这意味着这个功能正在快速发展,而且不保证兼容性。当在Kotlin 1.3+中使用无符号算术时,会报告警告,表明这个功能是实验性的。要删除警告,你必须选择加入无符号类型的实验性使用。</target>
        </trans-unit>
        <trans-unit id="a0d2b5a6b59247ce3c2ac4eba75f43c56acf4c3d" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is that &lt;code&gt;fold()&lt;/code&gt; takes an initial value and uses it as the accumulated value on the first step, whereas the first step of &lt;code&gt;reduce()&lt;/code&gt; uses the first and the second elements as operation arguments on the first step.</source>
          <target state="translated">这两个函数的区别在于， &lt;code&gt;fold()&lt;/code&gt; 取一个初始值并将其用作第一步的累加值，而 &lt;code&gt;reduce()&lt;/code&gt; 的第一步则将第一和第二个元素用作第一步的操作参数。</target>
        </trans-unit>
        <trans-unit id="16d1b90dc650643e776a4004ab589d677449c331" translate="yes" xml:space="preserve">
          <source>The directories containing the source files to compile</source>
          <target state="translated">包含要编译的源文件的目录。</target>
        </trans-unit>
        <trans-unit id="f28bb53a04db0fb8fa17ba4aa3c143de9bce62e3" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM</source>
          <target state="translated">在以JVM为目标的代码中不支持动态类型。</target>
        </trans-unit>
        <trans-unit id="c1e94b86df57391ab40db234f4362544f610c993" translate="yes" xml:space="preserve">
          <source>The easiest way to create a new application targeting JavaScript with Maven is to allow IntelliJ IDEA to configure the Maven project for us. Simply create a new Maven project in IntelliJ IDEA and once the project is created, add a new folder to host the Kotlin source code, removing the default Java one. The project should end up with the following structure</source>
          <target state="translated">用Maven创建一个针对JavaScript的新应用,最简单的方法就是让IntelliJ IDEA为我们配置Maven项目。只需在IntelliJ IDEA中创建一个新的Maven项目,项目创建完成后,添加一个新的文件夹来存放Kotlin源代码,删除默认的Java文件夹。项目最终应该是如下结构</target>
        </trans-unit>
        <trans-unit id="171e3cf4fb89f709d12d970ce788f0d3a1e1b68e" translate="yes" xml:space="preserve">
          <source>The effect of computing the expression is:</source>
          <target state="translated">计算表达的效果是:。</target>
        </trans-unit>
        <trans-unit id="0a6537bfaccb8cddd8c481ef1fab76499f34a316" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">元素使用指定的&lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt;函数初始化。</target>
        </trans-unit>
        <trans-unit id="3c970d5af5c7c3d91e3eb72687259d2ce93c168c" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">元素使用指定的&lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt;函数初始化。</target>
        </trans-unit>
        <trans-unit id="4479436b9b0ce8aa0beac7c43130aa60627f658c" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">元素以它们在&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素&lt;/a&gt;集合中出现的顺序追加。</target>
        </trans-unit>
        <trans-unit id="23022bf4214f0845c5b1a370815de8e19dc6515a" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">元素以它们在&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素&lt;/a&gt;集合中出现的顺序追加。</target>
        </trans-unit>
        <trans-unit id="daa9aa5d9ebd8b42b1bcdf3100554fd92ca03d09" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">将元素与&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;函数进行相等性比较。对于浮点数，这意味着 &lt;code&gt;NaN&lt;/code&gt; 等于其自身，并且 &lt;code&gt;-0.0&lt;/code&gt; 不等于 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7d4f10d9d6ff53cf3cb02a56dcf3900dc9233c7" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source array.</source>
          <target state="translated">结果列表中的元素与源数组中的元素顺序相同。</target>
        </trans-unit>
        <trans-unit id="4758b35da216c6ed38b8e3b01e9232e835ffdf62" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source collection.</source>
          <target state="translated">结果列表中的元素与源集合中的顺序相同。</target>
        </trans-unit>
        <trans-unit id="925245d7080579f68b367dc0eefbb0c6350a2c59" translate="yes" xml:space="preserve">
          <source>The elements in the resulting sequence are in the same order as they were in the source sequence.</source>
          <target state="translated">结果序列中的元素与源序列中的元素顺序相同。</target>
        </trans-unit>
        <trans-unit id="62f13d9c86bbfcad668fdecca43def6919a28064" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">将其他类型的元素与&lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt;函数进行相等性比较。对于浮点数，这意味着 &lt;code&gt;NaN&lt;/code&gt; 等于其自身，并且 &lt;code&gt;-0.0&lt;/code&gt; 不等于 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb685b2c6e5acf402eac7fe67da99cd138309729" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">该&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;范围&lt;/a&gt;的结束索引包含在已删除的部分中。</target>
        </trans-unit>
        <trans-unit id="11df9d3925f0418a6e38aed874d509daf4025048" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">该&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;范围&lt;/a&gt;的结束索引包含在已删除的部分中。</target>
        </trans-unit>
        <trans-unit id="88ef0ef1c8adfc13f79b17d279153b4deca66c2a" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;范围&lt;/a&gt;的结束索引包含在要替换的零件中。</target>
        </trans-unit>
        <trans-unit id="110043ac6542bd5ea84cfa58a2ba979b14417af8" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;范围&lt;/a&gt;的结束索引包含在要替换的零件中。</target>
        </trans-unit>
        <trans-unit id="d2bb3fe28b22f0be53eb5ccfae4478026ce71334" translate="yes" xml:space="preserve">
          <source>The entity which has an associated native pointer. Subtypes are supposed to represent interpretations of the pointed data or code.</source>
          <target state="translated">有关联的本机指针的实体。子类型应该代表对指向的数据或代码的解释。</target>
        </trans-unit>
        <trans-unit id="2c6bd81b6f529ef522b5222f238d9ced96f1bfdb" translate="yes" xml:space="preserve">
          <source>The enum constants also implement the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; interface, with the natural order being the order in which they are defined in the enum class.</source>
          <target state="translated">枚举常量还实现&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt;接口，自然顺序是在enum类中定义它们的顺序。</target>
        </trans-unit>
        <trans-unit id="1f86188b4a8b45564220a022aed934fe72f40d6e" translate="yes" xml:space="preserve">
          <source>The example above shows the difference: &lt;code&gt;fold()&lt;/code&gt; is used for calculating the sum of doubled elements. If you pass the same function to &lt;code&gt;reduce()&lt;/code&gt;, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</source>
          <target state="translated">上面的示例显示了区别： &lt;code&gt;fold()&lt;/code&gt; 用于计算加倍元素的总和。如果将相同的函数传递给 &lt;code&gt;reduce()&lt;/code&gt; ，它将返回另一个结果，因为在第一步中它将列表的第一个和第二个元素用作参数，因此第一个元素不会被加倍。</target>
        </trans-unit>
        <trans-unit id="b596f3f6b2203ee7818d443ce1a3eb3a2049daee" translate="yes" xml:space="preserve">
          <source>The example above will work for Android libraries with no product flavors. For a library with product flavors, the variant names also contain the flavors, like &lt;code&gt;fooBarDebug&lt;/code&gt; or &lt;code&gt;fooBazRelease&lt;/code&gt;.</source>
          <target state="translated">上面的示例适用于没有产品口味的Android库。对于具有产品 &lt;code&gt;fooBarDebug&lt;/code&gt; 的库，变量名称也包含样式，例如fooBarDebug或 &lt;code&gt;fooBazRelease&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2034baca1648e38acba659c7ed9ab52779def3a9" translate="yes" xml:space="preserve">
          <source>The example of using &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;convert&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="18829b154c907ba2a13646994ee9e04f0d08452d" translate="yes" xml:space="preserve">
          <source>The exception thrown when a character encoding or decoding error occurs.</source>
          <target state="translated">发生字符编码或解码错误时产生的异常。</target>
        </trans-unit>
        <trans-unit id="6d95121d07b3626cf990aefa17a36910bfcf4f29" translate="yes" xml:space="preserve">
          <source>The experimental marker for type inference augmenting annotations.</source>
          <target state="translated">类型推理增强注释的实验标记。</target>
        </trans-unit>
        <trans-unit id="deb8aac7cf53fe1202db4a3293685d56f19ee1b3" translate="yes" xml:space="preserve">
          <source>The experimental multiplatform support API marker.</source>
          <target state="translated">实验性的多平台支持API标记。</target>
        </trans-unit>
        <trans-unit id="0428313ba384ac9c0b8833c120ad8f95ce4ede3d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;::x&lt;/code&gt; evaluates to a property object of type &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt;, which allows us to read its value using &lt;code&gt;get()&lt;/code&gt; or retrieve the property name using the &lt;code&gt;name&lt;/code&gt; property. For more information, please refer to the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;docs on the &lt;code&gt;KProperty&lt;/code&gt; class&lt;/a&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;::x&lt;/code&gt; 的计算结果为 &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt; 类型的属性对象，该属性对象使我们可以使用 &lt;code&gt;get()&lt;/code&gt; 读取其值或使用 &lt;code&gt;name&lt;/code&gt; 属性检索属性名称。有关更多信息，请参考&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt; &lt;code&gt;KProperty&lt;/code&gt; &lt;/a&gt;类上的文档。</target>
        </trans-unit>
        <trans-unit id="788ff064b8ecef1f248204a84772fdfe4508eee7" translate="yes" xml:space="preserve">
          <source>The file is missing the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, which is not needed for our example, but may be necessary if we use C++ and overloaded functions. The &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C++ compatibility&lt;/a&gt; thread contains more details on this.</source>
          <target state="translated">该文件缺少 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 块，这对于我们的示例不是必需的，但是如果我们使用C ++和重载函数，则可能是必需的。在&lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C ++的兼容性&lt;/a&gt;线包含更多细节。</target>
        </trans-unit>
        <trans-unit id="2828031dfb85b70cc7191c0b9ade03e3586cc60a" translate="yes" xml:space="preserve">
          <source>The file system locations for the Java sources are different from the &lt;code&gt;java&lt;/code&gt; plugin's defaults. The Java source files need to be placed in the sibling directories of the Kotlin source roots. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are:</source>
          <target state="translated">对于Java源文件系统中的位置是从不同 &lt;code&gt;java&lt;/code&gt; 插件的默认设置。Java源文件需要放置在Kotlin源根目录的同级目录中。例如，如果JVM目标具有默认名称 &lt;code&gt;jvm&lt;/code&gt; ，则路径为：</target>
        </trans-unit>
        <trans-unit id="a63cb5acdae60d6976d603a52addbcfa0b41167c" translate="yes" xml:space="preserve">
          <source>The file we're mostly interested in is &lt;code&gt;ConsoleOutput.js&lt;/code&gt;</source>
          <target state="translated">我们最感兴趣的文件是 &lt;code&gt;ConsoleOutput.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2c228ca59fbecd7257e251a141cb2c1718c2ba0" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like that:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 文件中的最终代码如下所示：</target>
        </trans-unit>
        <trans-unit id="994c32d45d717275b8093d1a6c05a756a3faeb93" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 文件中的最终代码如下所示：</target>
        </trans-unit>
        <trans-unit id="845eeef01520a4662cdfbe660097ba30ecf3f4fb" translate="yes" xml:space="preserve">
          <source>The final step is to define the actual compilation of the project, which uses the standard IntelliJ IDEA Runner Type</source>
          <target state="translated">最后一步是定义项目的实际编译,它使用标准的IntelliJ IDEA Runner Type</target>
        </trans-unit>
        <trans-unit id="64ebebb6a3a3dfec1d013df86e5fccb457a8633c" translate="yes" xml:space="preserve">
          <source>The final step is to make Xcode call our Gradle build to prepare the &lt;code&gt;SharedCode&lt;/code&gt; framework before each run. We open the &lt;em&gt;Build Phases&lt;/em&gt; tab and click &lt;code&gt;+&lt;/code&gt; to add the &lt;em&gt;New Run Script Phase&lt;/em&gt; and add the following code into it:</source>
          <target state="translated">最后一步是使Xcode调用我们的Gradle构建，以在每次运行之前准备 &lt;code&gt;SharedCode&lt;/code&gt; 框架。我们打开&lt;em&gt;Build Phases&lt;/em&gt;选项卡，然后单击 &lt;code&gt;+&lt;/code&gt; 添加&lt;em&gt;New Run Script Phase&lt;/em&gt;并将以下代码添加到其中：</target>
        </trans-unit>
        <trans-unit id="18cac2860812daece2680c18729b8285d0c95c2d" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;, the second one refers to the result of &lt;code&gt;firstFunction()&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt; will be the result of &lt;code&gt;secondFunction()&lt;/code&gt; (or null if &lt;code&gt;maybeNull&lt;/code&gt; or any of the intermediate results were null).</source>
          <target state="translated">第一 &lt;code&gt;this&lt;/code&gt; 是指 &lt;code&gt;maybeNull&lt;/code&gt; ，第二个指的结果 &lt;code&gt;firstFunction()&lt;/code&gt; ，并且 &lt;code&gt;result&lt;/code&gt; 将是的结果 &lt;code&gt;secondFunction()&lt;/code&gt; (或空如果 &lt;code&gt;maybeNull&lt;/code&gt; 或任何中间结果均为零）。</target>
        </trans-unit>
        <trans-unit id="4fdd8b62987d88f8c4db3a2a41e10fc4d1887b5c" translate="yes" xml:space="preserve">
          <source>The first argument in this example allows one to set a name prefix for the created binaries which is used to access them in the buildscript (see the &lt;a href=&quot;#accessing-binaries&quot;&gt;&quot;Accessing binaries&quot;&lt;/a&gt; section). Also this prefix is used as a default name for the binary file. For example on Windows the sample above produces files &lt;code&gt;foo.exe&lt;/code&gt; and &lt;code&gt;bar.exe&lt;/code&gt;.</source>
          <target state="translated">在此示例中，第一个参数允许为已创建的二进制文件设置名称前缀，该名称前缀用于在构建脚本中访问它们（请参见&lt;a href=&quot;#accessing-binaries&quot;&gt;&amp;ldquo;访问二进制文件&amp;rdquo;&lt;/a&gt;部分）。此前缀也用作二进制文件的默认名称。例如，在Windows上，以上示例生成文件 &lt;code&gt;foo.exe&lt;/code&gt; 和 &lt;code&gt;bar.exe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fc302c51d198c918ae55a3c30c065988889b3c8" translate="yes" xml:space="preserve">
          <source>The first call in the chain usually should have a line break before it, but it's OK to omit it if the code makes more sense that way.</source>
          <target state="translated">链中的第一个调用通常应该在它之前有一个换行符,但如果这样代码更合理,省略它也是可以的。</target>
        </trans-unit>
        <trans-unit id="b4e33fae8e821602ad4182a2f8cd98570f5752fb" translate="yes" xml:space="preserve">
          <source>The first element in the progression.</source>
          <target state="translated">进阶的第一个要素。</target>
        </trans-unit>
        <trans-unit id="f74c962485a9f3f35870c553a197b5ef319d5a35" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="translated">第一个示例在同一代码中混合了&lt;em&gt;非阻塞&lt;/em&gt; &lt;code&gt;delay(...)&lt;/code&gt; 和&lt;em&gt;阻塞&lt;/em&gt; &lt;code&gt;Thread.sleep(...)&lt;/code&gt; 。很容易忘记哪个阻塞了，哪个没有阻塞。让我们明确地使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;协程生成器进行阻止：</target>
        </trans-unit>
        <trans-unit id="b2d66cf460f6f78061ad6d5f7262d3436e850f41" translate="yes" xml:space="preserve">
          <source>The first extension takes a &lt;code&gt;char *&lt;/code&gt; as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.</source>
          <target state="translated">The first extension takes a &lt;code&gt;char *&lt;/code&gt; as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.</target>
        </trans-unit>
        <trans-unit id="60455f009d759b3a711a0c86694ca0f8e3417539" translate="yes" xml:space="preserve">
          <source>The first four elements are added to the buffer and the sender suspends when trying to send the fifth one.</source>
          <target state="translated">前四个元素被添加到缓冲区,当试图发送第五个元素时,发送方暂停。</target>
        </trans-unit>
        <trans-unit id="ab32e32b6495f8ef1ecac2deb728551ecd768355" translate="yes" xml:space="preserve">
          <source>The first function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt;. You can call it on a collection of collections, for example, a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt;s. The function returns a single &lt;code&gt;List&lt;/code&gt; of all the elements of the nested collections.</source>
          <target state="translated">第一个函数是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt;。你可以把它在集合的集合，例如，一个 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;Set&lt;/code&gt; 秒。该函数返回嵌套集合的所有元素的单个 &lt;code&gt;List&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb9b81609c647210d6aacd108c4c1230b4870b5f" translate="yes" xml:space="preserve">
          <source>The first line of the input contains two integers &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;</source>
          <target state="translated">输入的第一行包含两个整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a973365d252e2f2156e9bff5ffce49da12fd36a5" translate="yes" xml:space="preserve">
          <source>The first list contains the first elements of each &lt;code&gt;Pair&lt;/code&gt; in the original list.</source>
          <target state="translated">第一个列表包含原始列表中每个 &lt;code&gt;Pair&lt;/code&gt; 的第一个元素。</target>
        </trans-unit>
        <trans-unit id="79bda60284dc4aa80a7917505f3968fd9009f668" translate="yes" xml:space="preserve">
          <source>The first step of using an actor is to define a class of messages that an actor is going to process. Kotlin's &lt;a href=&quot;../sealed-classes&quot;&gt;sealed classes&lt;/a&gt; are well suited for that purpose. We define &lt;code&gt;CounterMsg&lt;/code&gt; sealed class with &lt;code&gt;IncCounter&lt;/code&gt; message to increment a counter and &lt;code&gt;GetCounter&lt;/code&gt; message to get its value. The later needs to send a response. A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt; communication primitive, that represents a single value that will be known (communicated) in the future, is used here for that purpose.</source>
          <target state="translated">使用actor的第一步是定义actor将要处理的一类消息。Kotlin的&lt;a href=&quot;../sealed-classes&quot;&gt;密封课程&lt;/a&gt;非常适合该目的。我们定义 &lt;code&gt;CounterMsg&lt;/code&gt; 密封类 &lt;code&gt;IncCounter&lt;/code&gt; 消息，计数器加 &lt;code&gt;GetCounter&lt;/code&gt; 消息得到其价值。稍后需要发送响应。甲&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt;通信原码，即表示将在将来已知的（传送）一个单一的值，在这里用于该目的。</target>
        </trans-unit>
        <trans-unit id="38481ec6d5c41bf35d07d09bc7535247f80dee43" translate="yes" xml:space="preserve">
          <source>The first thing we'll need is a Kotlin file called &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; with the &lt;code&gt;main&lt;/code&gt; function defined in it and then proceed to translate each line</source>
          <target state="translated">我们需要的第一件事是一个名为 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 的Kotlin文件，其中定义了 &lt;code&gt;main&lt;/code&gt; 函数，然后继续翻译每一行</target>
        </trans-unit>
        <trans-unit id="6f6aa8f820f0284bd28697b0207de3b2578af79f" translate="yes" xml:space="preserve">
          <source>The following attributes are supported:</source>
          <target state="translated">支持以下属性:</target>
        </trans-unit>
        <trans-unit id="d555f20ea9bbf2028964527e2711757cec45ebd4" translate="yes" xml:space="preserve">
          <source>The following code launches a long-running coroutine in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; that prints &quot;I'm sleeping&quot; twice a second and then returns from the main function after some delay:</source>
          <target state="translated">下面的代码在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中启动一个长时间运行的协程，该协程每秒显示两次&amp;ldquo;我在睡觉&amp;rdquo;，然后在延迟一段时间后从主函数返回：</target>
        </trans-unit>
        <trans-unit id="ead88ea1dd6b3e545d54d2d74bc4d103e0cfff51" translate="yes" xml:space="preserve">
          <source>The following commands are available.</source>
          <target state="translated">可使用以下命令:</target>
        </trans-unit>
        <trans-unit id="55be4cb42f91b956f18957a0a075265fb24672f6" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this concept:</source>
          <target state="translated">下面的例子说明了这个概念。</target>
        </trans-unit>
        <trans-unit id="40d8cb89ac87b573a486f4f8fe49663dde1297b2" translate="yes" xml:space="preserve">
          <source>The following example prints the first ten prime numbers, running the whole pipeline in the context of the main thread. Since all the coroutines are launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine we don't have to keep an explicit list of all the coroutines we have started. We use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt; extension function to cancel all the children coroutines after we have printed the first ten prime numbers.</source>
          <target state="translated">下面的示例显示前十个质数，并在主线程的上下文中运行整个管道。由于所有协程都是在主&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;协程的范围内启动的，因此我们不必保留已启动的所有协程的明确列表。在打印前十个质数后，我们使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt;扩展功能来取消所有子协程。</target>
        </trans-unit>
        <trans-unit id="9f818012b8152abe166a094d93ab2ca0ec79eab1" translate="yes" xml:space="preserve">
          <source>The following example shows how to use these settings.</source>
          <target state="translated">下面的例子显示了如何使用这些设置。</target>
        </trans-unit>
        <trans-unit id="29c80399d536894a6ec94c527a731166260c49c2" translate="yes" xml:space="preserve">
          <source>The following example shows their use outside of coroutine:</source>
          <target state="translated">下面的例子显示了它们在coroutine之外的使用。</target>
        </trans-unit>
        <trans-unit id="b39c4c0b095563ff59ef483ec27836f8b662f2fa" translate="yes" xml:space="preserve">
          <source>The following examples show different possibilities of configuring the Gradle plugin:</source>
          <target state="translated">下面的例子展示了配置Gradle插件的不同可能性。</target>
        </trans-unit>
        <trans-unit id="e712d7790d39e907b7ee7e8cb60e61e0c86b31e2" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined by the compiler in specific contexts and can be used as regular identifiers in other contexts:</source>
          <target state="translated">以下标识符由编译器在特定上下文中定义,并可在其他上下文中作为常规标识符使用。</target>
        </trans-unit>
        <trans-unit id="bf95dedf99c3841e1d5196a0ba2d969912347f7d" translate="yes" xml:space="preserve">
          <source>The following is an example interface of the JDK implemented by &lt;code&gt;StringBuilder&lt;/code&gt; class:</source>
          <target state="translated">以下是 &lt;code&gt;StringBuilder&lt;/code&gt; 类实现的JDK的示例接口：</target>
        </trans-unit>
        <trans-unit id="8e29598dc88ea6b0ec70ab50aa2a4cfa741c6e7f" translate="yes" xml:space="preserve">
          <source>The following pipeline stage filters an incoming stream of numbers, removing all the numbers that are divisible by the given prime number:</source>
          <target state="translated">下面的流水线阶段过滤输入的数字流,去除所有被给定质数除以的数字。</target>
        </trans-unit>
        <trans-unit id="29b7ef083a5e449cb9ecea68dfa0ae64024fefca" translate="yes" xml:space="preserve">
          <source>The following podspec fields are required by CocoaPods:</source>
          <target state="translated">CocoaPods需要以下podspec字段。</target>
        </trans-unit>
        <trans-unit id="21b0584d86535ffda98821a37bb76687f7207959" translate="yes" xml:space="preserve">
          <source>The following sections explain in more detail the concepts mentioned so far.</source>
          <target state="translated">以下各节将更详细地解释迄今为止所提到的概念。</target>
        </trans-unit>
        <trans-unit id="5472a88e6462dc9e30567cf6b7a816998c79c200" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in modifier lists of declarations and can be used as identifiers in other contexts:</source>
          <target state="translated">以下标记在声明的修饰列表中充当关键字,并可在其他情况下作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="c62886b027ba800287b4be18a333a156fdeb309b" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in the context when they are applicable and can be used as identifiers in other contexts:</source>
          <target state="translated">以下标记在适用时作为上下文中的关键词,在其他上下文中可作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="71c4c5ec356525034ad2f877a92ba2dfdfffc609" translate="yes" xml:space="preserve">
          <source>The following tokens are always interpreted as keywords and cannot be used as identifiers:</source>
          <target state="translated">以下标记总是被解释为关键字,不能作为标识符使用。</target>
        </trans-unit>
        <trans-unit id="0493d41eaaff9f9930d4990e582a0014dff8b09e" translate="yes" xml:space="preserve">
          <source>The following workflow is expected when interacting with the native library.</source>
          <target state="translated">在与本地库交互时,预计会有以下工作流程。</target>
        </trans-unit>
        <trans-unit id="46d230bab2ec3e41d052e1e397afc7cc1e96642c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。返回零，如果这 &lt;code&gt;Double&lt;/code&gt; 价值 &lt;code&gt;NaN&lt;/code&gt; ，&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt;如果是小于 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; ，&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;int.MAX_VALUE的&lt;/a&gt;，如果它比大 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7c04cb487d62c119eaf78735ad59d58fbbea7f7" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。返回零，如果这 &lt;code&gt;Double&lt;/code&gt; 价值 &lt;code&gt;NaN&lt;/code&gt; ，&lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt;，如果是小于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; ，&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;如果它比大 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="986d603361e48796a38eb31b882249f0e0fb1907" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。如果此 &lt;code&gt;Double&lt;/code&gt; 值是负数或 &lt;code&gt;NaN&lt;/code&gt; ，则返回零；如果&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;大于 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; ，则返回零。</target>
        </trans-unit>
        <trans-unit id="db89446a546caa08c045751959e85b9b42af6661" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。如果此 &lt;code&gt;Double&lt;/code&gt; 值是负数或 &lt;code&gt;NaN&lt;/code&gt; ，则返回零&lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;；&lt;/a&gt;如果它大于 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; ，则返回ULong.MAX_VALUE。</target>
        </trans-unit>
        <trans-unit id="6c0d7df43097a38a432b999c674eaa178ec96a50" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。返回零，如果这个 &lt;code&gt;Float&lt;/code&gt; 值为 &lt;code&gt;NaN&lt;/code&gt; 的，&lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt;如果是小于 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; ，&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;int.MAX_VALUE的&lt;/a&gt;，如果它比大 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="234cddb40ea7edc20ba16f302fd45e435a6a6dbf" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。返回零，如果这个 &lt;code&gt;Float&lt;/code&gt; 值为 &lt;code&gt;NaN&lt;/code&gt; 的，&lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt;，如果是小于 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; ，&lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;如果它比大 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a1bb43be34e6fb6de623932b67b670ae0006852" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。如果此 &lt;code&gt;Float&lt;/code&gt; 值为负或 &lt;code&gt;NaN&lt;/code&gt; ，则返回零&lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;；&lt;/a&gt;如果它大于 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; ，则返回UInt.MAX_VALUE。</target>
        </trans-unit>
        <trans-unit id="1fdd0d739f0100ce802b95ab4a4c9b2532feeff0" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">小数部分（如果有）四舍五入。如果此 &lt;code&gt;Float&lt;/code&gt; 值为负或 &lt;code&gt;NaN&lt;/code&gt; ，则返回零&lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;；&lt;/a&gt;如果其大于 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; ，则返回ULong.MAX_VALUE。</target>
        </trans-unit>
        <trans-unit id="ea6eb6722ce134e1e96c66df47559354876af311" translate="yes" xml:space="preserve">
          <source>The framework that we compiled with Kotlin/Native has helper attributes to make it easier to use with Swift. Let's convert the previous Objective-C example into Swift. As a result, we'll have the following code in &lt;code&gt;main.swift&lt;/code&gt;:</source>
          <target state="translated">我们使用Kotlin / Native编译的框架具有helper属性，可以更轻松地与Swift一起使用。让我们将之前的Objective-C示例转换为Swift。结果，我们将在 &lt;code&gt;main.swift&lt;/code&gt; 中包含以下代码：</target>
        </trans-unit>
        <trans-unit id="229775820ba0ca0053d7b140e68dd9b3ed428ae4" translate="yes" xml:space="preserve">
          <source>The full build script for the sample project can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;here&lt;/a&gt;. You can also look at the converted code for &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;the Android sample&lt;/a&gt;.</source>
          <target state="translated">示例项目的完整构建脚本可以在&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;此处&lt;/a&gt;找到。您还可以查看&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;Android示例&lt;/a&gt;的转换后代码。</target>
        </trans-unit>
        <trans-unit id="e62bc4cb51ca1d1cddfe4e1d3d510caa93dee388" translate="yes" xml:space="preserve">
          <source>The full list of arguments that can be used is shown when you run &lt;code&gt;kotlinc -help&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;kotlinc -help&lt;/code&gt; 时会显示可以使用的参数的完整列表。</target>
        </trans-unit>
        <trans-unit id="02b69f589be9184eaa6e08d9fb77b12e7b2d6da2" translate="yes" xml:space="preserve">
          <source>The full list of supported use-site targets is:</source>
          <target state="translated">支持的使用网站目标的完整清单是:</target>
        </trans-unit>
        <trans-unit id="58018a7c2f7cccce2f2841705c78d55576a7e56f" translate="yes" xml:space="preserve">
          <source>The full syntactic form of lambda expressions is as follows:</source>
          <target state="translated">lambda表达式的完整语法形式如下。</target>
        </trans-unit>
        <trans-unit id="1347221f9ac10fa3f9465e07c5ca87cc27e8a8e6" translate="yes" xml:space="preserve">
          <source>The full syntax for declaring a property is</source>
          <target state="translated">声明一个属性的完整语法是</target>
        </trans-unit>
        <trans-unit id="905c760b34a0beb7b5d4d319c2f007dd8ebd0fd3" translate="yes" xml:space="preserve">
          <source>The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with &lt;code&gt;val&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; and does not allow a setter:</source>
          <target state="translated">只读属性声明的完整语法在两个方面不同于可变的声明：它以 &lt;code&gt;val&lt;/code&gt; 而不是 &lt;code&gt;var&lt;/code&gt; 开头，并且不允许使用setter：</target>
        </trans-unit>
        <trans-unit id="0ee52f844a0963f3db9f0478ccd20b13916c48b9" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or it is an anonymous object literal.</source>
          <target state="translated">类的完全限定的点名分隔 &lt;code&gt;null&lt;/code&gt; 如果类是本地类，或者它是一个匿名对象文字，则为null。</target>
        </trans-unit>
        <trans-unit id="39a40c87789f813fc496dc5468cc91805583814e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;libnative_symbols&lt;/code&gt; allows us to open the way from the native code to the Kotlin/Native library. This is the entry point we use. The library name is used as a prefix for the function name.</source>
          <target state="translated">函数 &lt;code&gt;libnative_symbols&lt;/code&gt; 允许我们打开从本机代码到Kotlin / Native库的方式。这是我们使用的切入点。库名称用作函数名称的前缀。</target>
        </trans-unit>
        <trans-unit id="ecf68a80d3d421d1a3dac0bf6a7b99795040c5e0" translate="yes" xml:space="preserve">
          <source>The function body is delimited by curly braces - indentation is generally not significant in Kotlin, but you should of course indent your code properly for the benefit of human readers.</source>
          <target state="translated">函数体以大括号为界--在Kotlin中,缩进一般并不重要,但为了人类读者的利益,你当然应该适当缩进你的代码。</target>
        </trans-unit>
        <trans-unit id="892b57cbc7486be03e2291de2837204f537e592b" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="translated">如果需要，该函数会从读取锁定升级到写入锁定，但是此升级不是原子升级，因为&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;不支持这种升级。为了进行此类升级，此功能首先释放该线程持有的所有读取锁定，然后获取写入锁定，释放后再返回获取读取锁定。</target>
        </trans-unit>
        <trans-unit id="47e9d14611b3a1f9114880a2ff853190d9e97c10" translate="yes" xml:space="preserve">
          <source>The function signature remains exactly the same. The only difference is &lt;code&gt;suspend&lt;/code&gt; being added to it. The return type however is the type we want to be returned.</source>
          <target state="translated">功能签名保持完全相同。唯一的区别是将 &lt;code&gt;suspend&lt;/code&gt; 添加到其中。但是，返回类型是我们要返回的类型。</target>
        </trans-unit>
        <trans-unit id="f6772ad37911fb29515e5ecad2f466bed6bdb7cd" translate="yes" xml:space="preserve">
          <source>The function type notation can optionally include names for the function parameters: &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt;. These names can be used for documenting the meaning of the parameters.</source>
          <target state="translated">函数类型表示法可以选择包含函数参数的名称： &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt; 。这些名称可用于记录参数的含义。</target>
        </trans-unit>
        <trans-unit id="5f62a960bb01edb991f086fcecfa3233b3994fce" translate="yes" xml:space="preserve">
          <source>The functions include trigonometric, hyperbolic, exponentiation and power, logarithmic, rounding, sign and absolute value.</source>
          <target state="translated">函数包括三角函数、双曲函数、指数和幂函数、对数函数、四舍五入函数、符号函数和绝对值函数。</target>
        </trans-unit>
        <trans-unit id="332c4fb906dbcda140f018d0de201e8c1ce3d30d" translate="yes" xml:space="preserve">
          <source>The general rule is: when a type parameter &lt;code&gt;T&lt;/code&gt; of a class &lt;code&gt;C&lt;/code&gt; is declared &lt;strong&gt;out&lt;/strong&gt;, it may occur only in &lt;strong&gt;out&lt;/strong&gt;-position in the members of &lt;code&gt;C&lt;/code&gt;, but in return &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; can safely be a supertype of &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">一般规则是：当声明类 &lt;code&gt;C&lt;/code&gt; 的类型参数 &lt;code&gt;T&lt;/code&gt; &lt;strong&gt;时&lt;/strong&gt;，它只能出现在 &lt;code&gt;C&lt;/code&gt; 成员的&lt;strong&gt;外部&lt;/strong&gt;位置，但作为回报， &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; 可以安全地成为 &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt; 的超类型。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47a803852f9a44b2a9ede00ebab7d2f5f19ab5c5" translate="yes" xml:space="preserve">
          <source>The general rule:</source>
          <target state="translated">一般规则:</target>
        </trans-unit>
        <trans-unit id="39d2229c00faf1c133ef862b873c7364c63bd099" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessarily synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="translated">适用于线程和协程的通用解决方案是使用线程安全（又名同步，线性化或原子）数据结构，该结构为需要在共享状态下执行的相应操作提供所有必需的同步。在简单计数器的情况下，我们可以使用 &lt;code&gt;AtomicInteger&lt;/code&gt; 类，该类具有原子的 &lt;code&gt;incrementAndGet&lt;/code&gt; 操作：</target>
        </trans-unit>
        <trans-unit id="fe194a34c4e181902ef2477861ca1a56a0c14e72" translate="yes" xml:space="preserve">
          <source>The generated constructor is synthetic so it can&amp;rsquo;t be directly called from Java or Kotlin, but it can be called using reflection.</source>
          <target state="translated">生成的构造函数是合成的，因此无法直接从Java或Kotlin调用，但可以使用反射调用。</target>
        </trans-unit>
        <trans-unit id="c09ea74ea1b03fd685bbe5f94354a8374db022b3" translate="yes" xml:space="preserve">
          <source>The getter of this property, used to obtain the value of the property.</source>
          <target state="translated">该属性的获取者,用于获取该属性的价值。</target>
        </trans-unit>
        <trans-unit id="5599725590a9016e21ca4310f17eb7b2b01a0483" translate="yes" xml:space="preserve">
          <source>The globs are applied to the header paths relative to the appropriate include path elements, e.g. &lt;code&gt;time.h&lt;/code&gt; or &lt;code&gt;curl/curl.h&lt;/code&gt;. So if the library is usually included with &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt;, then it would probably be correct to filter headers with</source>
          <target state="translated">相对于适当的包含路径元素（例如 &lt;code&gt;time.h&lt;/code&gt; 或 &lt;code&gt;curl/curl.h&lt;/code&gt; )，将这些小球应用于标头路径。因此，如果该库通常包含在 &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt; 中，则使用以下方法过滤标头可能是正确的</target>
        </trans-unit>
        <trans-unit id="a57ffec5971f7b3f89d004ca095f66feb86eb296" translate="yes" xml:space="preserve">
          <source>The goal of the tutorial is to demonstrate Kotlin code re-use between Android and iOS. Let's start by manually creating the &lt;code&gt;SharedCode&lt;/code&gt; sub-project in our Gradle project. The source code from the &lt;code&gt;SharedCode&lt;/code&gt; project will be shared between platforms. We will create several new files in our project to implement that.</source>
          <target state="translated">本教程的目的是演示Android和iOS之间Kotlin代码的重用。让我们从在Gradle项目中手动创建 &lt;code&gt;SharedCode&lt;/code&gt; 子项目开始。 &lt;code&gt;SharedCode&lt;/code&gt; 项目的源代码将在平台之间共享。我们将在项目中创建几个新文件来实现该目的。</target>
        </trans-unit>
        <trans-unit id="068a964193217c327091688b8b7de38e4eb4f3e1" translate="yes" xml:space="preserve">
          <source>The header files merely contain function declarations for functionality that is defined at runtime. For instance, we could define a &lt;code&gt;jQuery&lt;/code&gt; function like so</source>
          <target state="translated">头文件仅包含在运行时定义的功能的功能声明。例如，我们可以像这样定义一个 &lt;code&gt;jQuery&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="6ce2e166fe215303244aa3044be29e2844cbf2bc" translate="yes" xml:space="preserve">
          <source>The iOS simulator requires a framework compiled for the &lt;code&gt;ios_x64&lt;/code&gt; target, the &lt;code&gt;iOS_sim&lt;/code&gt; folder in our case.</source>
          <target state="translated">iOS模拟器需要为 &lt;code&gt;ios_x64&lt;/code&gt; 目标（在本例中为 &lt;code&gt;iOS_sim&lt;/code&gt; 文件夹）编译的框架。</target>
        </trans-unit>
        <trans-unit id="31859b6cbcfb9892316b62d967e1f5ae2235d5ef" translate="yes" xml:space="preserve">
          <source>The idea behind Rx is to move towards what's called &lt;code&gt;observable streams&lt;/code&gt; where by we now think of data as streams (infinite amounts of data) and these streams can be observed. In practical terms, Rx is simply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer Pattern&lt;/a&gt; with a series of extensions which allow us to operate on the data.</source>
          <target state="translated">Rx背后的想法是朝着所谓的 &lt;code&gt;observable streams&lt;/code&gt; 移动，在这里我们现在将数据视为流（无限量的数据），并且可以观察到这些流。实际上，Rx只是&lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;观察者模式&lt;/a&gt;，具有一系列扩展，可让我们对数据进行操作。</target>
        </trans-unit>
        <trans-unit id="a752acd40500d4af1aa6897c4527c1276e603455" translate="yes" xml:space="preserve">
          <source>The idea behind futures or promises (there are also other terms these can be referred to depending on language/platform), is that when we make a call, we're promised that at some point it will return with an object called a Promise, which can then be operated on.</source>
          <target state="translated">期货或承诺(根据语言/平台的不同,也有其他的术语)背后的想法是,当我们进行调用时,我们被承诺在某一时刻它将返回一个称为承诺的对象,然后可以对其进行操作。</target>
        </trans-unit>
        <trans-unit id="0ec5a5ec78c5bbba1d9a9593b45aa36ac04ad75c" translate="yes" xml:space="preserve">
          <source>The idea is to make every platform show similar text: &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; and &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt;, depending on the platform. We will reuse the way we generate the message. Let's create the file (and missing directories) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; with the following contents under the project root directory</source>
          <target state="translated">我们的想法是让每一个平台显示出类似的文字： &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 和 &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt; ，根据不同的平台上。我们将重用我们生成消息的方式。让我们在项目根目录下 &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; 具有以下内容的文件（和缺少目录）SharedCode / src / commonMain / kotlin / common.kt</target>
        </trans-unit>
        <trans-unit id="82fd6cd237e491604315526b684dbfedf391a053" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;实例支持的&lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="6ba732549bab36d600a33b057cb1445e14d3cdfc" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;实例支持的&lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="e80ec37934bbec50821c43bd38cce1238a634038" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;实例支持的&lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="9ab2ec2a4f2966a3555f9fce9c9ee7c196c5adc8" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;实例支持的&lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="41ae2cd6b24e4bafa0efb17c582aa2f3dbd61174" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;实例支持的&lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="b29deea1bb921913df3a5fadba5cd74a8f4acd5e" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;实例支持的&lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="a6579034caa6bf530c44ba48e1557ccf3e4b94a3" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt;实例支持的&lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="a009a3a444f03e70f059b3c04a3a49cc825d720d" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">由&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt;实例支持的&lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="fa50aaadf0215e23e542746cdfa2658460833341" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; property, which should return read-only set of map entries.</source>
          <target state="translated">实现者需要实现&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entrys&lt;/a&gt;属性，该属性应返回映射条目的只读集。</target>
        </trans-unit>
        <trans-unit id="0d9844010488cdb05175b5fbda28866913c16552" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">需要实现者实现&lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entrys&lt;/a&gt;属性，该属性应返回可变的映射条目集，并&lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;放置put&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="b072b8461d749216f126589f253d2136dcee5a49" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">需要实现者实现&lt;a href=&quot;entries&quot;&gt;entrys&lt;/a&gt;属性，该属性应返回可变的映射条目集，并&lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;放置put&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="b4d84ada0a069eb9728359000c31d5443cb7fe8c" translate="yes" xml:space="preserve">
          <source>The in-place sorting functions have similar names to the functions that apply to read-only lists, but without the &lt;code&gt;ed/d&lt;/code&gt; suffix:</source>
          <target state="translated">就地排序功能与应用于只读列表的功能具有相似的名称，但没有 &lt;code&gt;ed/d&lt;/code&gt; 后缀：</target>
        </trans-unit>
        <trans-unit id="ad88781015ab91e944a6d24ed6740d21e1a613c0" translate="yes" xml:space="preserve">
          <source>The indentation in front of the accessors is due to convention; like elsewhere in Kotlin, it has no syntactic significance. The compiler can tell which accessors belong to which properties because the only legal place for an accessor is immediately after the property declaration (and there can be at most one getter and one setter) - so you can't split the property declaration and the accessor declarations. However, the order of the accessors doesn't matter.</source>
          <target state="translated">访问器前面的缩进是由于惯例,就像 Kotlin 的其他地方一样,它没有语法意义。编译器可以知道哪些访问器属于哪些属性,因为访问器的唯一合法位置是紧接在属性声明之后(最多只能有一个getter和一个setter)--所以你不能把属性声明和访问器声明分开。然而,访问器的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="a438c4c204700f052b62784ad094f3d42692c3e5" translate="yes" xml:space="preserve">
          <source>The inheritors are used in &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; to describe the contract of a function.</source>
          <target state="translated">在&lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder中&lt;/a&gt;，继承程序用于描述函数的约定。</target>
        </trans-unit>
        <trans-unit id="927c0a69730a98787dc84c53359365aef174d24b" translate="yes" xml:space="preserve">
          <source>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer (or from the getter return type, as shown below).</source>
          <target state="translated">初始化器、getter和setter是可选的。如果可以从初始化器中推断出属性类型(或从getter返回类型中推断出属性类型,如下图所示),则属性类型是可选的。</target>
        </trans-unit>
        <trans-unit id="73ab217fa7b8d452fbb508f24860b5983aed819b" translate="yes" xml:space="preserve">
          <source>The insertion order is preserved by maintaining a doubly-linked list of all of its entries.</source>
          <target state="translated">通过对其所有条目保持一个双链接的列表来保留插入顺序。</target>
        </trans-unit>
        <trans-unit id="d2ac540734122ad9d9f148278a049a69e4049649" translate="yes" xml:space="preserve">
          <source>The instance of the object declaration, or &lt;code&gt;null&lt;/code&gt; if this class is not an object declaration.</source>
          <target state="translated">对象声明的实例；如果此类不是对象声明，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e1a88c47519272f4d061661530035978afeff04" translate="yes" xml:space="preserve">
          <source>The interoperability tool analyses C headers and produces a &quot;natural&quot; mapping of the types, functions, and constants into the Kotlin world. The generated stubs can be imported into an IDE for the purpose of code completion and navigation.</source>
          <target state="translated">互操作性工具分析C头文件,并生成类型、函数和常量到Kotlin世界的 &quot;自然 &quot;映射。生成的存根可以导入到IDE中,用于完成代码和导航。</target>
        </trans-unit>
        <trans-unit id="0c34ac28f0b47dc2a95569e5a72bbe09867d14d5" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are not &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. Annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. To enable caching for kapt anyway, add the following lines to the build script:</source>
          <target state="translated">默认情况下，kapt注释处理任务不会&lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;缓存在Gradle中&lt;/a&gt;。注释处理器运行任意代码，这些代码不一定会将任务输入转换为输出，可能会访问和修改Gradle等未跟踪的文件。无论如何要为kapt启用缓存，请在构建脚本中添加以下几行：</target>
        </trans-unit>
        <trans-unit id="0d265db62daefe24281a53daa642fa0260c64977" translate="yes" xml:space="preserve">
          <source>The key benefit of using sealed classes comes into play when you use them in a &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt;. If it's possible to verify that the statement covers all cases, you don't need to add an &lt;code&gt;else&lt;/code&gt; clause to the statement. However, this works only if you use &lt;code&gt;when&lt;/code&gt; as an expression (using the result) and not as a statement.</source>
          <target state="translated">当在&lt;a href=&quot;control-flow#when-expression&quot;&gt; &lt;code&gt;when&lt;/code&gt; 表达式&lt;/a&gt;中使用密封类时，使用密封类的主要好处就发挥了作用。如果可以验证该语句是否涵盖所有情况，则无需在该语句中添加 &lt;code&gt;else&lt;/code&gt; 子句。但是，仅当您将 &lt;code&gt;when&lt;/code&gt; 用作表达式（使用结果）而不用作语句时，此方法才有效。</target>
        </trans-unit>
        <trans-unit id="60878e19d1626a7113513294279d9306ebdfd3af" translate="yes" xml:space="preserve">
          <source>The key differences to the old model are:</source>
          <target state="translated">与老款的主要区别是:</target>
        </trans-unit>
        <trans-unit id="ba83743a7b4886ce5d922ef71ed4bc654a53eba4" translate="yes" xml:space="preserve">
          <source>The key for each element is provided by the &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; function.</source>
          <target state="translated">每个元素的键由&lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt;函数提供。</target>
        </trans-unit>
        <trans-unit id="c7780b4923a988af8ea0601856ae08a944187203" translate="yes" xml:space="preserve">
          <source>The key new feature in Kotlin 1.1 is &lt;em&gt;coroutines&lt;/em&gt;, bringing the support of &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt; and similar programming patterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries, not the language, so you aren't bound to any specific programming paradigm or concurrency library.</source>
          <target state="translated">Kotlin 1.1中的关键新功能是&lt;em&gt;协程&lt;/em&gt;，带来了对 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; ， &lt;code&gt;yield&lt;/code&gt; 和类似编程模式的支持。Kotlin设计的关键特征是协程执行的实现是库的一部分，而不是语言的一部分，因此您不必受限于任何特定的编程范例或并发库。</target>
        </trans-unit>
        <trans-unit id="255ddce16ff2d3386fde18744e92b0919a0c3dcd" translate="yes" xml:space="preserve">
          <source>The key that defines &lt;em&gt;the&lt;/em&gt; context interceptor.</source>
          <target state="translated">定义键&lt;em&gt;的&lt;/em&gt;情况下拦截。</target>
        </trans-unit>
        <trans-unit id="f78236335bddfda90f254cf18135e3e283c652aa" translate="yes" xml:space="preserve">
          <source>The key to understanding why this trick works is rather simple: if you can only &lt;strong&gt;take&lt;/strong&gt; items from a collection, then using a collection of &lt;code&gt;String&lt;/code&gt;s and reading &lt;code&gt;Object&lt;/code&gt;s from it is fine. Conversely, if you can only &lt;em&gt;put&lt;/em&gt; items into the collection, it's OK to take a collection of &lt;code&gt;Object&lt;/code&gt;s and put &lt;code&gt;String&lt;/code&gt;s into it: in Java we have &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; a &lt;strong&gt;supertype&lt;/strong&gt; of &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">理解此技巧为何有效的关键非常简单：如果您只能从一个集合中&lt;strong&gt;获取&lt;/strong&gt;项目，则可以使用 &lt;code&gt;String&lt;/code&gt; 的集合并从中读取 &lt;code&gt;Object&lt;/code&gt; 。相反，如果您只能&lt;em&gt;将&lt;/em&gt;项目放入集合，则可以将 &lt;code&gt;Object&lt;/code&gt; 的集合放入 &lt;code&gt;String&lt;/code&gt; ：在Java中，我们具有 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; 一个&lt;strong&gt;超类型&lt;/strong&gt;的 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d05fefa144a9bfaff0069cb495aef5fbbe9dc415" translate="yes" xml:space="preserve">
          <source>The language settings are checked for consistency between source sets depending on each other. Namely, if &lt;code&gt;foo&lt;/code&gt; depends on &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">检查语言设置是否相互依赖，以确保源集之间的一致性。即，如果 &lt;code&gt;foo&lt;/code&gt; 取决于 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7ae80735e57bee13b52032eac31a1a1787272a8f" translate="yes" xml:space="preserve">
          <source>The language settings for a source set can be specified as follows:</source>
          <target state="translated">源集的语言设置可指定如下。</target>
        </trans-unit>
        <trans-unit id="fbaea25f697b924abdcdee8361823761cf7fe6eb" translate="yes" xml:space="preserve">
          <source>The language used to document Kotlin code (the equivalent of Java's JavaDoc) is called &lt;strong&gt;KDoc&lt;/strong&gt;. In its essence, KDoc combines JavaDoc's syntax for block tags (extended to support Kotlin's specific constructs) and Markdown for inline markup.</source>
          <target state="translated">用于记录Kotlin代码的语言（与Java的JavaDoc等效）称为&lt;strong&gt;KDoc&lt;/strong&gt;。本质上，KDoc结合了JavaDoc的块标记语法（扩展以支持Kotlin的特定构造）和Markdown的内联标记。</target>
        </trans-unit>
        <trans-unit id="6bd524ff724eae23548f42d94d576b7a82d79f24" translate="yes" xml:space="preserve">
          <source>The last element in the progression.</source>
          <target state="translated">进展中的最后一个元素。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
