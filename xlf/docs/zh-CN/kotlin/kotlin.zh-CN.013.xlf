<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">在Java中。</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">在JavaScript中,你可以在原型或类本身定义成员。即..:</target>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在Kotlin 1.0中，传递给 &lt;code&gt;td&lt;/code&gt; 的lambda中的代码可以访问三个隐式接收器：一个传递给 &lt;code&gt;table&lt;/code&gt; ， &lt;code&gt;tr&lt;/code&gt; 和 &lt;code&gt;td&lt;/code&gt; 。这使您可以调用在上下文中没有意义的方法，例如，在 &lt;code&gt;td&lt;/code&gt; 内部调用 &lt;code&gt;tr&lt;/code&gt; ，从而在 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 中放置 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">在Kotlin 1.1中，您可以对此进行限制，以便在传递给 &lt;code&gt;td&lt;/code&gt; 的lambda内只有在 &lt;code&gt;td&lt;/code&gt; 的隐式接收器上定义的方法才可用。为此，您可以定义带有 &lt;code&gt;@DslMarker&lt;/code&gt; 元注释的注释，并将其应用于标签类的基类。</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">在Kotlin 1.1.x中，请改用 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 和 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">在Kotlin 1.3中,注释可以有嵌套的类、接口、对象和同伴。</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">在Kotlin 1.3中，现在可以将 &lt;code&gt;when&lt;/code&gt; 主题捕获为变量：</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">在Kotlin中,函数可以在文件中进行顶层声明,这意味着你不需要创建一个类来容纳一个函数,而在Java、C#或Scala等语言中则需要这样做。除了顶层函数外,Kotlin函数还可以作为成员函数和扩展函数进行本地声明。</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">在Kotlin中,有两种类型的平等。</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">在Kotlin中，可以使用以下语句使用整数列表中的&lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;解构声明&lt;/a&gt;来简洁地解析此行：</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">在Kotlin中,你可以为一个通用类型提供上界。Objective-C也支持这样做,但在更复杂的情况下,这种支持是不可用的,而且目前Kotlin-Objective-C互操作中也不支持。这里的例外是一个非空的上界将使Objective-C方法/属性非空。</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">在Kotlin中，您不能直接使用字段，而只能使用&lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;。您注释属性：</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">在Kotlin中，您必须添加 &lt;code&gt;kotlin-kapt&lt;/code&gt; 插件以启用 &lt;code&gt;kapt&lt;/code&gt; ，然后用 &lt;code&gt;kapt&lt;/code&gt; 替换 &lt;code&gt;annotationProcessor&lt;/code&gt; 处理程序：</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">在科特林您使用指定一个类似于Java的方式依赖&lt;a href=&quot;../reference/kapt&quot;&gt;科特林注释处理工具&lt;/a&gt;（ &lt;code&gt;kapt&lt;/code&gt; 代替） &lt;code&gt;annotationProcessor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">在Kotlin中，为集合定义了&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;+&lt;/code&gt; ）和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;-&lt;/code&gt; ）。他们将集合作为第一个操作数。第二个操作数可以是一个元素或另一个集合。返回值是一个新的只读集合：</target>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">在Kotlin中，&lt;em&gt;if&lt;/em&gt;是一个表达式，即它返回一个值。因此，没有三元运算符（条件？then：else），因为普通&lt;em&gt;if&lt;/em&gt;在此角色下工作良好。</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">在Kotlin中,所有的异常都是未检查的,这意味着编译器不会强迫你捕获任何异常。因此,当你调用一个声明了检查异常的Java方法时,Kotlin不会强迫你做任何事情。</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">在Kotlin中,所有的东西都是一个对象,我们可以在任何变量上调用成员函数和属性。有些类型可以有特殊的内部表示--例如,数字、字符和booleans可以在运行时表示为基元值--但对用户来说,它们看起来就像普通的类。在本节中,我们将描述Kotlin中使用的基本类型:数字、字符、booleans、数组和字符串。</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">在Kotlin中，功能类型表示为具有不同数量参数的泛型类： &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; ， &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; ， &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; &amp;hellip;&amp;hellip;&amp;hellip;这种方法的问题在于此列表是有限的，当前以 &lt;code&gt;Function22&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在Kotlin中，实现继承受以下规则支配：如果一个类从其直接超类继承了同一成员的许多实现，则它必须重写此成员并提供自己的实现（也许使用继承的一个）。来表示从该继承执行取超型，我们使用&lt;em&gt;超级&lt;/em&gt;尖括号合格由超类型名称，例如 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">在Kotlin中，导入是一个编译时概念-导入内容实际上不会导致任何代码运行（与Python不同，Python中文件中的所有顶级语句都在导入时执行）。因此，允许循环导入，但是它们可能会在您的代码中提示设计问题。但是，在执行期间，将在首次引用类（或其任何属性或函数）时加载类，并且类加载会导致初始化&lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;伴随对象&lt;/a&gt; -如果您具有循环依赖项，则可能导致运行时异常。</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">在Kotlin中，多态性是通过类层次结构来实现的，这样就不可能碰到缺少属性或功能的情况。基本规则是，当且仅当 &lt;code&gt;B&lt;/code&gt; 是 &lt;code&gt;A&lt;/code&gt; 的子类型时，声明类型为 &lt;code&gt;A&lt;/code&gt; 的变量/属性/参数才可以引用 &lt;code&gt;B&lt;/code&gt; 类的实例。这意味着，要么 &lt;code&gt;A&lt;/code&gt; 必须是一个类，而 &lt;code&gt;B&lt;/code&gt; 必须是 &lt;code&gt;A&lt;/code&gt; 的子类，要么 &lt;code&gt;A&lt;/code&gt; 必须是一个接口，而 &lt;code&gt;B&lt;/code&gt; 必须是实现该接口的类，或者是该类的子类。使用上一部分中的类和接口，我们可以定义以下功能：</target>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">在Kotlin中， &lt;code&gt;List&lt;/code&gt; 的默认实现是&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt;，您可以将其视为可调整大小的数组。</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">在Kotlin中,每次调用函数时都会对默认值的表达式进行评估。因此,只要使用每次评估都会产生一个新列表的表达式,就可以避免上述陷阱。</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">在Kotlin中,对象的顺序可以用几种方式来定义。</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">在Kotlin中，类型系统区分可以保存&lt;em&gt;null的&lt;/em&gt;引用（可为空的引用）和不能保存的引用（非null引用）。例如， &lt;code&gt;String&lt;/code&gt; 类型的常规变量不能包含&lt;em&gt;null&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">在Kotlin中,有一个惯例:如果一个函数的最后一个参数是函数,那么作为相应参数传递的lambda表达式可以放在括号外。</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">在Kotlin中，有一种方法可以向编译器解释这种情况。这称为&lt;strong&gt;声明位置方差&lt;/strong&gt;：我们可以对Source 的&lt;strong&gt;类型参数&lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; 进行注释，以确保仅从 &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; 成员&lt;strong&gt;返回&lt;/strong&gt;（产生）该&lt;strong&gt;参数&lt;/strong&gt;，而从不使用它。为此，我们提供&lt;strong&gt;out&lt;/strong&gt;修饰符：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">在Kotlin中,与Java或C#不同,类没有静态方法。在大多数情况下,建议使用包级函数来代替。</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">在Kotlin中，我们只能使用普通的不合格 &lt;code&gt;return&lt;/code&gt; 来退出命名函数或匿名函数。这意味着要退出lambda，我们必须使用&lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;，并且lambda内禁止裸 &lt;code&gt;return&lt;/code&gt; ，因为lambda无法使封闭函数返回：</target>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">在Maven中</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">在Maven中，启用 &lt;code&gt;jpa&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">在Maven中，启用 &lt;code&gt;spring&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">在Python中，函数名称在模块或类中必须唯一。在Kotlin中，我们可以&lt;em&gt;重载&lt;/em&gt;函数：可以有多个具有相同名称的函数声明。重载的函数必须通过它们的参数列表相互区分。（参数列表的类型与返回类型一起被称为函数的&lt;em&gt;签名&lt;/em&gt;，但是返回类型不能用于消除重载函数的歧义。）例如，我们可以在同一个文件中同时拥有这两个函数：</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">在Python中，默认值的表达式在函数定义时被评估一次。这导致了这种经典的陷阱，开发人员希望每次调用该函数时都获得一个新的空列表，而没有 &lt;code&gt;numbers&lt;/code&gt; 的值，但是每次都使用相同的列表：</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">在 &lt;code&gt;when&lt;/code&gt; 语句中，如果分支多于一行，请考虑使用空行将其与相邻的case块分开：</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">在长时间运行的应用程序中，您可能需要对后台协程进行细粒度的控制。例如，用户可能已经关闭了启动协程的页面，现在不再需要其结果并且可以取消其操作。在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;推出&lt;/a&gt;函数返回一个&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;作业&lt;/a&gt;，可用于取消运行协程：</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">在&lt;a href=&quot;classes#inheritance&quot;&gt;类&lt;/a&gt;的成员中，&lt;em&gt;这&lt;/em&gt;是指该类的当前对象。</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">简而言之，您可以在Kotlin项目中使用&lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt;或&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding之类的&lt;/a&gt;库。</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">除了&lt;strong&gt;out之外&lt;/strong&gt;，Kotlin还提供了补充的方差注释：&lt;strong&gt;in&lt;/strong&gt;。它使类型参数&lt;strong&gt;互变&lt;/strong&gt;：它只能被使用而不能产生。可变类型的一个很好的例子是 &lt;code&gt;Comparable&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">除了用于&lt;a href=&quot;collection-parts&quot;&gt;检索集合零件的&lt;/a&gt;常用操作之外，列表还提供&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt;函数，该函数将指定元素范围的视图作为列表返回。因此，如果原始集合的元素发生变化，则它在先前创建的子列表中也会发生变化，反之亦然。</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">除了删除元素，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt;还可以在迭代列表时插入和替换元素。</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">除范围函数外，标准库还包含函数 &lt;code&gt;takeIf&lt;/code&gt; 和 &lt;code&gt;takeUnless&lt;/code&gt; 。这些功能使您可以将对对象状态的检查嵌入到调用链中。</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">除此之外，您还可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt;访问与&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;该类&lt;/a&gt;相对应的JsClass实例。该 &lt;code&gt;JsClass&lt;/code&gt; 实例本身的构造函数的引用。这可用于与期望引用构造函数的JS函数进行互操作。</target>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">除了上面显示的 &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 依赖项之外，您还需要添加对Kotlin标准库的依赖项：</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">除了构建任务之外，Gradle构建还包括一些有用的任务，这些任务可通过 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; 和 &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; 直接运行应用程序。</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">除了&amp;ldquo;收集&lt;a href=&quot;collection-write&quot;&gt;写&lt;/a&gt;操作&amp;rdquo;中描述的收集修改操作之外，&lt;a href=&quot;collections-overview#collection-types&quot;&gt;可变&lt;/a&gt;列表还支持特定的写操作。这样的操作使用索引来访问元素以扩展列表修改功能。</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">除了命令行编译器和IntelliJ IDEA,你还可以用Ant、Maven和Gradle构建Kotlin项目。</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">除了不同构建器提供的协程作用域之外，还可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;构建器声明自己的作用域。它创建一个协程范围，并且直到所有启动的子级都完成后才完成。&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;之间的主要区别在于，后者在等待所有子级完成时不会阻塞当前线程。</target>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">除了输出的JavaScript文件之外，该插件默认情况下还会创建一个带有二进制描述符的附加JS文件。如果您要构建其他Kotlin模块可以依赖的可重用库，则此文件是必需的，并且应与转换结果一起分发。生成由 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; 选项控制：</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">此外,Rx确实引入了一种更好的错误处理方法。</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">此外，每个 &lt;code&gt;{file}.meta.js&lt;/code&gt; 还具有一个对应的{file} .meta.js元文件，该文件将用于反射和其他功能。</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">在所有的情况下,C字符串都应该被编码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">在所有方面,这与Java中的做法是一样的,因为通过默认的getters和setters对私有属性的访问是经过优化的,所以不会引入函数调用的开销。</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">在&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt;或&lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;带有接收器&lt;/a&gt;的函数文字中，&lt;em&gt;这&lt;/em&gt;表示在点的左侧传递的&lt;em&gt;接收器&lt;/em&gt;参数。</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">&lt;code&gt;noinline&lt;/code&gt; 联函数定义中，可以在任何函数类型的参数前面使用noinline，以防止内联将传递给它的lambda。</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">在任何列表中，您都可以使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt;函数找到元素的位置。它们返回与列表中给定参数相等的元素的第一个和最后一个位置。如果没有这样的元素，则两个函数都将返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">在方法上,它和Futures很相似,但我们可以把Future看作是返回一个离散元素,而Rx则返回一个流。然而,与前者类似,它也为我们的编程模型引入了一种全新的思维方式,著名的说法为</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">如果任何两个条目被映射到等键上,后一个条目的值将覆盖与前一个条目相关联的值。</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">如果由于在&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block中&lt;/a&gt;发生异常而关闭资源，并且关闭也因异常而失败，则将后者添加到前者的&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;抑制&lt;/a&gt;异常中。</target>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">如果有非空行,没有前导空格字符(完全没有缩进),那么普通缩进为0,因此这个函数不会改变缩进。</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">如果在派发接收方和扩展接收方的成员之间发生名称冲突，则以扩展接收方为准。要引用调度接收器的成员，可以使用&lt;a href=&quot;this-expressions#qualified&quot;&gt;限定的 &lt;code&gt;this&lt;/code&gt; 语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">如果是类中的扩展属性,应先传递类的实例,后传递扩展接收器的实例。</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">如果此类型基于内部类，则返回的列表将首先包含为最内部类提供的类型参数，然后是为其外部类提供的参数，依此类推。例如，在类型 &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; ，返回的列表为 &lt;code&gt;[C, D, A, B]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">如果只希望传递给内联函数的某些lambda进行内联，则可以使用 &lt;code&gt;noinline&lt;/code&gt; 修饰符标记一些函数参数：</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">如果您想知道 &lt;code&gt;use&lt;/code&gt; 是一个功能，如何在其后加上类似的代码块，请参阅&lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL支持&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">在通用代码中:</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">从本质上讲,这允许以下代码。</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">事实上,对于从主构造函数中声明属性和初始化属性,Kotlin有一个简洁的语法。</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">在接下来的章节中,将对这些概念以及在项目中配置它们的DSL进行更详细的描述。</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">一般来说,对于小型项目,我们建议一次性转换所有文件。</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">通常，标识符可以由字母，数字和下划线组成，并且不能以数字开头。但是，如果您编写的代码（例如，基于标识符自动生成JSON）并且希望JSON密钥是不符合这些规则或与关键字冲突的字符串，则可以将其括在反引号中： &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; 是有效的标识符。</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">一般来说,如果Kotlin中的某个语法结构是可选的,并且被IDE高亮显示为多余的,你应该在代码中省略它。不要为了 &quot;清晰 &quot;而在代码中留下不必要的语法元素。</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">一般来说,要创建这样一个类的实例,我们需要提供类型参数。</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">在生成的代码中，Kotlin编译&lt;em&gt;器&lt;/em&gt;为每个内联类保留一个&lt;em&gt;包装器&lt;/em&gt;。内联类实例可以在运行时表示为包装器或基础类型。这类似于如何 &lt;code&gt;Int&lt;/code&gt; 可以&lt;a href=&quot;basic-types#representation&quot;&gt;表示&lt;/a&gt;或者作为原始 &lt;code&gt;int&lt;/code&gt; 或作为包装 &lt;code&gt;Integer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">在lambda表达式中,应该在大括号周围使用空格,以及在分隔参数和正文的箭头周围使用空格。如果一个调用只使用一个lambda,则应尽可能在括号外传递。</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">在较短且未嵌套的lambda中，建议使用 &lt;code&gt;it&lt;/code&gt; 约定而不是显式声明参数。在带有参数的嵌套lambda中，应始终明确声明参数。</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">在较长的参数列表中,在开头的括号后加一个换行符。缩进4个空格的参数。将多个密切相关的参数归为同一行。</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">在许多情况下，不需要在Kotlin中使用显&lt;a href=&quot;#unsafe-cast-operator&quot;&gt;式强制转换&lt;/a&gt;运算符，因为编译器会跟踪 &lt;code&gt;is&lt;/code&gt; - checks和显式强制转换以获取不可变值，并在需要时自动插入（安全）强制转换：</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">在混合语言项目中,Kotlin源文件应与Java源文件驻留在同一个源根中,并遵循相同的目录结构(每个文件应存放在每个包声明对应的目录中)。</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">在不提供自己的API的模块（例如应用程序模块）中，您可以使用实验性API，而无需将实验状态传播到代码中。在这种情况下，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental（Marker :: class）&lt;/a&gt;批注标记代码，并指定实验性API的标记批注：</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">在大多数情况下,Kotlin遵循Java编码惯例。</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">在多行模式下，表达式 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 分别在行终止符或输入序列的结尾之后或之前匹配。</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">为了组装应用程序，我们还需要包括Kotlin标准库（即作为依赖项包含的 &lt;code&gt;kotlin.js&lt;/code&gt; )和其他库（如果有）。</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">为了避免在Xcode构建期间出现兼容性问题，该插件需要使用&lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle包装器&lt;/a&gt;。要在执行 &lt;code&gt;podspec&lt;/code&gt; 任务期间自动生成包装器，请使用参数 &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; 对其运行。</target>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">为了使用Gradle构建Kotlin项目，您应该&lt;a href=&quot;#plugin-and-versions&quot;&gt;设置&lt;em&gt;kotlin-gradle&lt;/em&gt;插件&lt;/a&gt;，&lt;a href=&quot;#targeting-the-jvm&quot;&gt;将其应用&lt;/a&gt;到项目中并&lt;a href=&quot;#configuring-dependencies&quot;&gt;添加&lt;em&gt;kotlin-stdlib&lt;/em&gt;依赖项&lt;/a&gt;。通过调用&amp;ldquo; &lt;strong&gt;工具&amp;rdquo;，&lt;/strong&gt;这些动作也可以在IntelliJ IDEA中自动执行&lt;strong&gt;。&lt;/strong&gt;&lt;strong&gt;科特林| &lt;/strong&gt;在&amp;ldquo; &lt;strong&gt;项目&amp;rdquo;&lt;/strong&gt;操作中&lt;strong&gt;配置Kotlin&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">为了编译JavaScript代码，您需要使用 &lt;code&gt;js&lt;/code&gt; 和 &lt;code&gt;test-js&lt;/code&gt; 目标进行 &lt;code&gt;compile&lt;/code&gt; 执行：</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">为了使用IntelliJ IDEA调试应用程序,我们需要执行两个步骤。</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">为了生成这些绑定，我们需要创建一个库定义 &lt;code&gt;.def&lt;/code&gt; 文件，其中包含一些有关我们需要生成的标头的信息。在我们的例子中，我们想使用著名的 &lt;code&gt;libcurl&lt;/code&gt; 库进行一些HTTP调用，因此我们将创建一个名为 &lt;code&gt;libcurl.def&lt;/code&gt; 的文件,其中包含以下内容</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">为了运行，我们需要相应的WAR进行部署。我们可以使用Gradle中的&lt;em&gt;war&lt;/em&gt;任务生成这些任务，该任务可以通过IntelliJ IDEA中的Gradle工具窗口轻松执行。</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">为了在项目开发人员的 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 文件夹中共享更改，必须将其提交给VCS。另外，&lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;obsolete&lt;/strong&gt;可以用于配置了Gradle或Maven的项目。</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">为了向所有项目开发人员共享这些更改，必须将 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 文件夹提交给VCS。</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">为了指定模块的种类,我们可以为我们的插件添加一个配置,如下所示</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">为了支持可能为空的类型，Objc标头需要使用可为空的返回值定义 &lt;code&gt;myVal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">为了使用Gradle定位JavaScript，我们需要使用 &lt;code&gt;kotlin2js&lt;/code&gt; 插件，而不是 &lt;code&gt;kotlin&lt;/code&gt; 插件。</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">为了在node.js中使用Kotlin,我们需要将编译器选项设置为使用CommonJS。一旦我们这样做,应用程序的输出应该可以使用node模块系统访问。</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">为了使用协程并遵循本指南中的示例，您需要添加对 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 模块的依赖项，如&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;项目README中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">为了使用包中的东西,只要在使用符号的地方使用包名来完全限定符号的名称即可。</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">为了使用它，我们还需要在我们的应用程序中包括Kotlin标准库，即 &lt;code&gt;kotlin.js&lt;/code&gt; ，它作为依赖项包含在内。默认情况下，Maven不会在构建过程中扩展JAR，因此我们需要在构建中添加一个额外的步骤。</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">换句话说，内联类引入了一种真正的&lt;em&gt;新&lt;/em&gt;类型，这与类型别名相反，后者仅为现有类型引入了替代名称（别名）：</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">在我们的DSL中，所有标签类都扩展相同的超类 &lt;code&gt;Tag&lt;/code&gt; 。仅用 &lt;code&gt;@HtmlTagMarker&lt;/code&gt; 注释超类就足够了，然后Kotlin编译器会将所有继承的类视为已注释：</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">在我们的示例中，我们具有使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;协程构建器将其转换为协程的 &lt;code&gt;main&lt;/code&gt; 功能。每个协 &lt;code&gt;runBlocking&lt;/code&gt; 器，包括runBlocking，&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;都会&lt;/a&gt;在其代码块范围内添加一个CoroutineScope实例。我们可以在此范围内启动协程，而不必显式地 &lt;code&gt;join&lt;/code&gt; 它们，因为外部协程（在我们的示例中为 &lt;code&gt;runBlocking&lt;/code&gt; ）直到在其范围内启动的所有协程完成后才完成。因此，我们可以使示例更简单：</target>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">在我们的主要函数中，我们创建活动，调用测试 &lt;code&gt;doSomething&lt;/code&gt; 函数，并在500毫秒后销毁活动。这会取消所有已启动的协程，如果等待，我们可以通过注意到它不再打印在屏幕上来确认这一点：</target>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">特别是,当为一个类定义对这个类的所有客户端都有意义的扩展函数时,把它们放在定义该类本身的同一个文件中。当定义那些只对特定客户端有意义的扩展函数时,把它们放在该客户端的代码旁边。不要为了存放 &quot;Foo的所有扩展函数 &quot;而创建文件。</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">在实践中,有些变化无法在编译时准确地检测到,所以不能报告警告,但至少会通过A版本的Release notes通知用户,B版本将有变化。</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">在实践中,有不少代码受到影响,所以这可以说是一次重大的代码风格更新。</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">在实际工作中,线程限制是以大块的方式进行的,比如大块的状态更新业务逻辑就限制在单线程中。下面的例子就是这样做的,首先在单线程上下文中运行每个coroutine。</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">在渐进模式下,语言语义的一些修正可以立即到达。所有这些修正都有两个重要的特性。</target>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">在纯Kotlin项目中,推荐的目录结构是遵循包的结构,而省略常用的根包(例如,如果项目中所有的代码都在 &quot;org.example.kotlin &quot;包及其子包中,那么 &quot;org.example.kotlin &quot;包中的文件应该直接放在源根目录下,而 &quot;org.example.kotlin.foo.bar &quot;中的文件应该放在源根目录的 &quot;foo/bar &quot;子目录下)。</target>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">简而言之：&lt;em&gt;仔细考虑您的整数声明，并绝对确保该值永远不必大于该类型的限制！&lt;/em&gt;如果需要不限大小的整数，请使用非原始类型 &lt;code&gt;BigInteger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">在这种情况下，我们可以使用 &lt;code&gt;dynamic&lt;/code&gt; 类型，该动态类型允许我们在定位JavaScript时使用动态类型。以下变量被声明为 &lt;code&gt;dynamic&lt;/code&gt; 变量，这意味着我们对其进行的调用均不会导致编译时错误：</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">在某些情况下（例如，为了支持重载），Kotlin编译器会破坏JavaScript代码中生成的函数和属性的名称。要控制生成的名称，可以使用 &lt;code&gt;@JsName&lt;/code&gt; 批注：</target>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">在某些情况下,没有参数的函数可以和只读属性互换。虽然语义相似,但在什么情况下,有一些风格上的约定。</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">在某些方面，这更易于阅读，因为操作是按照它们应用于值的顺序指定的。结果将是一个不变的 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是您使用的转换产生的任何类型（在这种情况下为 &lt;code&gt;String&lt;/code&gt; ）。如果需要可变列表，请在最后调用 &lt;code&gt;toMutableList()&lt;/code&gt; 。如果需要集合，请在最后调用 &lt;code&gt;toSet()&lt;/code&gt; 或 &lt;code&gt;toMutableSet()&lt;/code&gt; 。如果要将集合转换为地图，请调用 &lt;code&gt;associateBy()&lt;/code&gt; ，它需要两个lambda来指定如何从每个元素中提取键和值： &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; （如果希望整个元素作为值，则可以省略第二个lambda；如果希望结果可变，则可以在最后调用 &lt;code&gt;toMutableMap()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">尽管使用了 &lt;code&gt;object&lt;/code&gt; 关键字，但是每当计算对象表达式时，都会创建一个匿名类的新实例。</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">尽管语法上很方便，但伴随对象本身就是一个合适的对象，并且可以具有自己的超类型-您可以将其分配给变量并传递给它。如果要与Java代码集成，并且需要一个真正的 &lt;code&gt;static&lt;/code&gt; 成员，则可以使用 &lt;code&gt;@JvmStatic&lt;/code&gt; 在同伴对象内&lt;a href=&quot;annotations&quot;&gt;注释&lt;/a&gt;一个成员。</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">在后续的教程中,我们将展示如何影响生成的文件,例如,改变位置、前缀和后缀,以及如何使用模块。</target>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">在测试中(也只有在测试中),使用带空格的方法名是可以接受的。(注意,Android运行时目前不支持这样的方法名。)在测试代码中也允许在方法名中使用下划线。</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">在这种情况下，您需要使用传播运算符 &lt;code&gt;*&lt;/code&gt; 来传递 &lt;code&gt;IntArray&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">在&lt;a href=&quot;#enabling-experimental-features&quot;&gt;实验模式下&lt;/a&gt;，您可以指定任何变体名称（不仅是flavor），例如 &lt;code&gt;freeDebug&lt;/code&gt; 或 &lt;code&gt;freeRelease&lt;/code&gt; 也可以使用。</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">在 &lt;code&gt;libnative_api.h&lt;/code&gt; 中，我们将找到以下代码。我们将分部分讨论代码，以使其更易于理解。</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">在Gradle依赖项中，您使用添加 &lt;code&gt;kotlin-kapt&lt;/code&gt; 插件，并用 &lt;code&gt;kapt&lt;/code&gt; 替换 &lt;code&gt;annotationProcessor&lt;/code&gt; 处理程序：</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">在JavaScript的世界里,有一套完全不同的API可以使用,所以我们可以实现对控制台的日志记录。</target>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">在上面的代码中，参数 &lt;code&gt;combine&lt;/code&gt; 具有&lt;a href=&quot;#function-types&quot;&gt;函数类型&lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; ，因此它接受一个函数，该函数接受 &lt;code&gt;R&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 类型的两个参数并返回 &lt;code&gt;R&lt;/code&gt; 类型的值。在&lt;em&gt;for&lt;/em&gt;循环内&lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;调用&lt;/a&gt;它，然后将返回值分配给 &lt;code&gt;accumulator&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">在上面的示例中，JVM目标的生产源通过其 &lt;code&gt;main&lt;/code&gt; 编译进行编译，因此包括来自源集 &lt;code&gt;jvmMain&lt;/code&gt; 和 &lt;code&gt;commonMain&lt;/code&gt; 的源和依赖项（由于&lt;em&gt;取决于&lt;/em&gt;关系）：</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">在下面的示例中，我们假设有一个 &lt;code&gt;DbModel&lt;/code&gt; 基类，并且每个子类都有一个无参数的主构造函数。在内联函数中，对 &lt;code&gt;T&lt;/code&gt; 进行了归一化，因此我们可以获得类元数据。我们将此传递给执行与数据库对话的实际工作的函数。</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">在该示例中，我们采用了最流行的方式来传递或接收C语言中的字符串。我们应该小心地返回 &lt;code&gt;return_string&lt;/code&gt; 。通常，最好确保我们使用正确的函数通过正确的 &lt;code&gt;free(..)&lt;/code&gt; 函数调用来处理返回的 &lt;code&gt;char*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">在下面的示例中， &lt;code&gt;findViewById()&lt;/code&gt; 仅被调用一次：</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">在生成的Kotlin声明中，我们看到 &lt;code&gt;str&lt;/code&gt; 表示为 &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; 。该类型是可为空的，我们可以简单地将Kotlin &lt;code&gt;null&lt;/code&gt; 作为参数值传递。</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">在生成的代码中，调用 &lt;code&gt;provideDelegate&lt;/code&gt; 方法以初始化辅助 &lt;code&gt;prop$delegate&lt;/code&gt; 属性。比较属性声明 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 的生成代码：使用MyDelegate（）键入&lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;上面&lt;/a&gt;的生成代码（当不提供 &lt;code&gt;provideDelegate&lt;/code&gt; 方法时）：</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">在最后一行，使用&lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android扩展&lt;/a&gt;插件通过 &lt;code&gt;id&lt;/code&gt; 引用了 &lt;code&gt;button&lt;/code&gt; 。考虑使用此插件作为替代方案，它使您可以将绑定逻辑保留在代码中，并同时具有简洁的语法。</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">在最后一行，有一个隐式的 &lt;code&gt;this.&lt;/code&gt; 在 &lt;code&gt;memberFunction()&lt;/code&gt; 和 &lt;code&gt;memberProperty&lt;/code&gt; 前面（如果它们存在于 &lt;code&gt;someExpression&lt;/code&gt; 类型上）。返回值是最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">在下一个对话框中,提供项目细节。</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">在旧模型中，需要将通用代码和特定于平台的代码放置在单独的模块中，并按 &lt;code&gt;expectedBy&lt;/code&gt; 依赖关系进行链接。现在，通用代码和特定于平台的代码被放置在同一模块的不同源根目录中，从而使项目更易于配置。</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">在存在 &lt;code&gt;maven-publish&lt;/code&gt; 插件的情况下，将创建所有已构建二进制文件的发布。该插件使用Gradle元数据发布构件，因此必须启用此功能（请参阅&lt;a href=&quot;#dependencies&quot;&gt;依赖项&lt;/a&gt;部分）。</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">在前面的示例中，JavaScript模块导出单个包。但是，某些JavaScript库从模块内部导出多个包。Kotlin也支持这种情况，尽管您必须为导入的每个包声明一个新的 &lt;code&gt;.kt&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">在教程中我们将学习。</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">在本教程中,我们。</target>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">在这种情况下,编译器将不会被插件下载。</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">在这种情况下，JQuery将作为名为 &lt;code&gt;jquery&lt;/code&gt; 的模块导入。另外，它可以用作$对象，具体取决于Kotlin编译器配置使用的模块系统。</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">在这种情况下，我们已将编译的输出设置为 &lt;code&gt;scripts&lt;/code&gt; 文件夹。在运行应用程序时，我们应该看到以下输出：</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">在这个密集的代码中，除了集合转换之外，您还可以看到便利的Kotlin功能（例如局部函数和&lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis运算符&lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 可以表达简洁明了的&lt;a href=&quot;../reference/idioms&quot;&gt;习惯用法，&lt;/a&gt;例如&amp;ldquo;取正则取值，否则使用长度&amp;rdquo;。可读的表达式，例如 &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; ，但是对于Kotlin来说，创建其他可变变量并以命令式方式表示相同的代码也很好。</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">在本文档中,我们有时会不必要地指定类型,以突出表达式产生的是什么类型。(另外,一个好的IDE将能够向你展示产生的类型。)</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">在本文档中,我们介绍了几种兼容性。</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">在此示例中，仅最近的隐式接收者 &lt;code&gt;this@head&lt;/code&gt; 必须可用； &lt;code&gt;head()&lt;/code&gt; 是外部接收者 &lt;code&gt;this@html&lt;/code&gt; 的成员，因此调用它必须是非法的。</target>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">在此示例中，我们使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;在后台线程池中启动了一个新协程，因此它可以在与线程池不同的线程上工作，但是它仍然具有我们使用 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; 指定的线程局部变量的值。（value =&amp;ldquo; launch&amp;rdquo;），无论协程执行在哪个线程上。因此，输出（带有&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;）为：</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">在此示例中，所有传递给C API &lt;code&gt;new_menu()&lt;/code&gt; 的值都具有其所属的最内部 &lt;code&gt;memScope&lt;/code&gt; 的生存期。一旦控制流离开 &lt;code&gt;memScoped&lt;/code&gt; 范围，则C指针将变为无效。</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">在这个例子中,构造函数取一个地图。</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">在这个例子中,序列处理需要18步,而不是对列表进行同样的处理需要23步。</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">在此示例中，使用上一节中的 &lt;code&gt;Person&lt;/code&gt; 和 &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; ，我们按名称查找成员函数引用并对其进行调用：</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">在此函数中，&lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt;和&lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt;可以在运行暂停功能的同一堆栈帧中同步使用，也可以稍后在同一线程或不同执行线程中异步使用。重复调用任何恢复函数都会产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">在此函数中，&lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt;和&lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt;可以在运行暂停函数的同一堆栈帧中同步使用，也可以稍后在同一线程或不同执行线程中异步使用。随后调用任何resume函数将产生一个&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">在本节中，显示了注释的DSL。另请参见使用此插件的示例项目，例如&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;，&lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http客户端&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">在本教程中,我们将学习如何。</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">但是，在本教程中，我们将看到如何使用某些特定的库，例如 &lt;code&gt;libcurl&lt;/code&gt; 。我们将学习</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">在本教程中,我们有。</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">在本教程中,我们将看到如何在Kotlin/Native中处理C字符串。我们将学习如何</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">在本教程中,我们将利用Kotlin的代码共享功能,创建一个iOS和Android应用程序。对于Android,我们将使用Kotlin/JVM,而对于iOS,将使用Kotlin/Native。</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">在本教程中,我们将看到如何做到</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">在本教程中,我们将介绍使用Kotlin Android Extensions插件所需的步骤,提升Android开发的体验。</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将逐步完成所需的步骤。有关Spring Boot和Kotlin的更详尽说明，请参阅&lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;使用Spring Boot和Kotlin构建Web应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">在本教程中,我们将。</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将使用IntelliJ IDEA。有关如何使用命令行编译器编译和执行Kotlin应用程序的说明，请参阅&lt;a href=&quot;command-line&quot;&gt;使用命令行编译器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">在本教程中,我们已经看到了如何创建一个以JavaScript为目标的Kotlin应用程序,调试它以及设置编译器选项。在其他教程中,我们将涉及更深入的主题,如与DOM的交互等。</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">在本教程中,我们将学习哪些C数据类型在Kotlin/Native中可见,反之亦然。我们将</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">在本教程中，我们将研究如何从现有的本机应用程序或库中使用Kotlin / Native代码。为此，我们需要将Kotlin代码编译为动态库 &lt;code&gt;.so&lt;/code&gt; ， &lt;code&gt;.dylib&lt;/code&gt; 和 &lt;code&gt;.dll&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">在本教程中,我们将建立一个可从JVM、JS和Native世界中获得的小库。你将逐步学习如何创建一个多平台库,它可以从任何其他通用代码(例如,一个与Android和iOS共享的代码),以及如何编写将在所有平台上执行的测试,并使用具体平台提供的有效实现。</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">在本教程中,我们将探讨如何在macOS和iOS上使用Objective-C和Swift应用程序的Kotlin/Native代码。我们将从Kotlin代码构建一个框架。</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">在本教程中,我们将。</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">在本教程中,我们将看一看如何进行以下操作</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">在本教程中，我们将使用Gradle，但是可以使用IntelliJ IDEA项目结构或Maven来实现相同的目的。有关设置Gradle与Kotlin一起&lt;a href=&quot;../reference/using-gradle&quot;&gt;使用的&lt;/a&gt;详细信息，请参阅《使用Gradle》。</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">在本教程中，我们将使用Gradle，但是可以使用IntelliJ IDEA项目结构或Maven来实现相同的目的。有关设置Gradle与Kotlin一起&lt;a href=&quot;../reference/using-gradle&quot;&gt;使用的&lt;/a&gt;详细信息，请参阅《使用Gradle》。使用HTTP servlet所需的主要依赖关系是JavaEE API：</target>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">反过来， &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;also&lt;/code&gt; 将上下文对象作为lambda参数。如果未指定参数名称，则使用隐式默认名称 &lt;code&gt;it&lt;/code&gt; 来访问对象。 &lt;code&gt;it&lt;/code&gt; 比 &lt;code&gt;this&lt;/code&gt; 短，并且带有 &lt;code&gt;it&lt;/code&gt; 表达式通常更易于阅读。但是，在调用对象函数或属性时，您没有像 &lt;code&gt;this&lt;/code&gt; 隐式可用的对象。因此，具有的上下文对象作为 &lt;code&gt;it&lt;/code&gt; 是更好当对象被主要用作在函数调用的参数。 &lt;code&gt;it&lt;/code&gt; 也更好，如果你在代码块中使用多个变量。</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">反过来，可变集合不是协变的。否则，将导致运行时失败。如果 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 是 &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; 的子类型，则可以在其中插入其他 &lt;code&gt;Shape&lt;/code&gt; 继承者（例如 &lt;code&gt;Circle&lt;/code&gt; ），从而违反其 &lt;code&gt;Rectangle&lt;/code&gt; 类型参数。</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">反过来，set并不是&lt;a href=&quot;collections-overview&quot;&gt;定义&lt;/a&gt;为有序集合。但是，Kotlin &lt;code&gt;Set&lt;/code&gt; 按某些顺序存储元素。这些可以是插入顺序（在 &lt;code&gt;LinkedHashSet&lt;/code&gt; 中），自然排序顺序（在 &lt;code&gt;SortedSet&lt;/code&gt; 中）或其他顺序。一组元素的顺序也可以是未知的。在这种情况下，元素仍然会以某种方式排序，因此依赖元素位置的函数仍会返回其结果。但是，除非调用者知道所使用 &lt;code&gt;Set&lt;/code&gt; 的特定实现，否则它们对调用者是不可预测的。</target>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">在您的scratch中,您可以编写任何有效的Kotlin代码,包括新的函数和类。在scratches中支持IntelliJ IDEA的语法高亮、自动完成和其他代码编辑功能。</target>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">在你的klib中加入静态库</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">不兼容的变化</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">递增式编译</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">增量注解处理(自1.3.30起)。</target>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">递增式汇编</target>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">Kotlin/JVM和Kotlin/JS项目支持增量编译。自Kotlin 1.1.1(Kotlin/JVM)和1.3.20(Kotlin/JS)以来,它是默认启用的。</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">递增版本带来了工具的更新(通常包括功能)、性能的改进和错误的修复。我们尽量保持这些版本之间的兼容性,所以对编译器的修改主要是优化和警告的添加/删除。当然,实验性功能可能会在任何时候被添加、删除或更改。</target>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">递增和递减</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">将值增加&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt;并返回新值。</target>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">将值增加&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt;并返回新值。</target>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">增加该值。</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">将数值增加1。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">索引访问操作者</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">表示是否有其他对象 &quot;等于 &quot;这个对象。执行时必须满足以下要求:</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">指示正则表达式是否可以在指定的&lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;输入中&lt;/a&gt;找到至少一个匹配项。</target>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">指示正则表达式是否与整个&lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;输入&lt;/a&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">命名函数的Infix调用</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">Infix函数调用的优先级低于算术运算符，类型强制转换和 &lt;code&gt;rangeTo&lt;/code&gt; 运算符。以下表达式是等效的：</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">填充功能</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">下位法</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">来自显式浇铸的信息被用于类型推理。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">从Java类继承</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">导致 &lt;code&gt;copy&lt;/code&gt; 冲突的继承已在Kotlin 1.2中被警告弃用，在Kotlin 1.3中将是错误。</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">继承的功能</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">继承属性</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">继承的内置功能</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">用 &lt;code&gt;String&lt;/code&gt; 类型或原始类型的值初始化</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">在并发访问未初始化的&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例值时，可以多次调用Initializer函数，但是只有第一个返回的值将用作&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例的值。</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">列表的初始化函数</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">如果尚未初始化,则初始化当前线程的Kotlin运行时。</target>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">可以内联Lambda表达式只能被称为内联函数中或可以内联参数传递，但 &lt;code&gt;noinline&lt;/code&gt; 始终们可以在任何我们喜欢的方式来处理：在存储领域，围绕等通过</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">内联JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">内联标记</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">内联类</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">内联类允许从接口继承。</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">内联类仅自Kotlin 1.3起可用，目前仍处于&lt;em&gt;实验阶段&lt;/em&gt;。请参阅&lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;下面的&lt;/a&gt;详细信息</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">内联类仅自Kotlin 1.3起可用，目前仍处于&lt;em&gt;实验阶段&lt;/em&gt;。看到细节&lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;的参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">内联类支持常规类的一些功能。特别是,它们被允许声明属性和函数。</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">内联类与类型别名</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">在平台类型的null值上调用的内联扩展函数没有检查接收器是否为null,因此会允许null逃逸到其他代码中。Kotlin 1.2在调用站点强制进行这种检查,如果接收器为空,则抛出异常。</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">内联函数在&lt;a href=&quot;inline-functions&quot;&gt;此处&lt;/a&gt;进行说明。</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">内联函数现在允许为其内联函数参数设置默认值。</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">带有经过&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;修饰的类型参数的&lt;/a&gt;内联函数在每个调用站点上都会内联其实际的类型参数，这使 &lt;code&gt;arg is T&lt;/code&gt; 检查类型参数，但是如果 &lt;code&gt;arg&lt;/code&gt; 是泛型类型本身的实例，则&lt;em&gt;其&lt;/em&gt;类型参数仍会被擦除。例：</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">带有默认功能参数的内联函数</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">内联属性(从1.1开始</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">内联属性访问器</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">内联可能会导致生成的代码增长;然而,如果我们以合理的方式进行内联(即避免内联大型函数),它将在性能上得到回报,特别是在循环内的 &quot;巨变形 &quot;调用点。</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">内部班级</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">继承 &lt;code&gt;Throwable&lt;/code&gt; 的内部类从外部类捕获通用参数</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">从 &lt;code&gt;Throwable&lt;/code&gt; 继承的泛型类型的内部类在抛出捕获场景中可能会违反类型安全性，因此已被弃用，在Kotlin 1.2中发出警告，在Kotlin 1.3中出现错误。</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将指定集合&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素的&lt;/a&gt;所有元素插入此列表中的指定&lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将指定集合&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;元素的&lt;/a&gt;所有元素插入此列表中的指定&lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">将元素插入列表中指定&lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;索引处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">在一个类中，您可以声明另一个类的扩展。在这种扩展内部，有多个&lt;em&gt;隐式接收器&lt;/em&gt; -无需限定符即可访问其对象的成员。声明扩展的类的实例称为&lt;em&gt;调度接收器&lt;/em&gt;，扩展方法的接收器类型的实例称为&lt;em&gt;扩展接收器&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">内的功能的 &lt;code&gt;vararg&lt;/code&gt; 类型的-parameter &lt;code&gt;T&lt;/code&gt; 是可见的阵列 &lt;code&gt;T&lt;/code&gt; ，即， &lt;code&gt;ts&lt;/code&gt; 在例如上述可变型具有 &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">在带有接收器的lambda表达式中，您可以使用 &lt;code&gt;this&lt;/code&gt; 来引用接收器对象（在本例中为 &lt;code&gt;car&lt;/code&gt; ）。像往常一样，如果没有命名冲突，则可以忽略 &lt;code&gt;this&lt;/code&gt; ，这就是为什么我们可以简单地说 &lt;code&gt;$horsepowers&lt;/code&gt; &lt;code&gt;${this.horsepowers}&lt;/code&gt; 而不是$ {this.horsepowers}的原因。请注意，在Kotlin中， &lt;code&gt;this&lt;/code&gt; 取决于上下文可能具有不同的含义：如果在带有接收器的lambda表达式内部（可能是嵌套的）中使用，它指的是带有接收器的最内层lambda表达式的接收器对象。如果您需要&amp;ldquo;突破&amp;rdquo;函数文字并获得&amp;ldquo;原始&amp;rdquo;字样， &lt;code&gt;this&lt;/code&gt; （您正在执行的内部成员函数的实例），请在 &lt;code&gt;this@&lt;/code&gt; 之后提及包含的类名-因此，如果您位于Car的成员函数内部的带有接收者的函数文字中，请使用 &lt;code&gt;this@Car&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">在内部类内部，访问外部类的超类是通过使用外部类名称为 &lt;code&gt;super@Outer&lt;/code&gt; 限定的&lt;em&gt;super&lt;/em&gt;关键字完成的：</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">由于初始化逻辑中的问题，在枚举条目内部定义了不是 &lt;code&gt;inner class&lt;/code&gt; 的嵌套类型已被弃用。这会在Kotlin 1.2中引起警告，并在Kotlin 1.3中成为错误。</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">里面的 &lt;code&gt;apply&lt;/code&gt; 模块， &lt;code&gt;this&lt;/code&gt; 是指 &lt;code&gt;maybeNull&lt;/code&gt; 。这里有一个隐含的 &lt;code&gt;this&lt;/code&gt; 前面 &lt;code&gt;memberPropertyA&lt;/code&gt; ， &lt;code&gt;memberPropertyB&lt;/code&gt; 和 &lt;code&gt;memberFunctionA&lt;/code&gt; （除非这些根本不存在的 &lt;code&gt;maybeNull&lt;/code&gt; ，在这种情况下，他们将会在包含范围来寻找）。之后，还会在 &lt;code&gt;maybeNull&lt;/code&gt; 上调用 &lt;code&gt;memberFunctionB()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">在函数文字的主体内部，传递给调用的接收者对象将成为&lt;em&gt;隐式&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;，因此您可以在没有任何其他限定符的情况下访问该接收者对象的成员，或者使用&lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 表达式&lt;/a&gt;访问接收者对象。</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">在声明lateinit属性的类里面,你可以检查它是否已经被初始化。</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">在文件内部，相应的第一级标题介绍了整个模块和单个软件包的文档。标题文本对于模块必须是&amp;ldquo;模块 &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; &amp;rdquo;，对于包必须是&amp;ldquo; 包 &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">在作用域函数的lambda中，可以通过短引用而不是其实际名称来使用上下文对象。每个范围函数使用两种访问上下文对象的方式之一：作为lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;接收器&lt;/a&gt;（ &lt;code&gt;this&lt;/code&gt; ）或作为lambda参数（ &lt;code&gt;it&lt;/code&gt; ）。两者都提供相同的功能，因此我们将描述每种情况在每种情况下的利弊，并提供有关其用法的建议。</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">检查从C库中生成的Kotlin API。</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">检查发行版的 &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; 的详细信息。</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">为C库检查生成的Kotlin APIs</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">安装自定义的未处理异常钩子。返回旧的钩子,如果没有指定钩子,则返回null。每当有未捕获的异常到达Kotlin世界的边界时,例如顶级的main(),或者当Objective-C对Kotlin的调用没有用@Throws标记时,就会调用Hook。钩子必须是一个冻结的lambda,这样它就可以从任何线程/工作站调用。钩子只被调用一次,之后会被清除,所以即使是自定义的异常钩子,内存泄漏检测也能如期进行。</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">安装 libgit2 并为 git 库准备存根。</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">安装&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome扩展程序&lt;/a&gt;，该扩展程序允许通过Chrome在IntelliJ IDEA内部进行调试。这对于使用IntelliJ IDEA开发的任何类型的Web应用程序都是有用的，而不仅仅是Kotlin。</target>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">安装EduTools插件</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">实例检查</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">实例领域</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">对成员进行调用所需的实例,或对内类构造函数进行外类实例。</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">实例化一个函数类型</target>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">我们没有直接调用方法 &lt;code&gt;matches&lt;/code&gt; ，而是存储了对其的引用。这样的引用绑定到它的接收者。可以直接调用它（如上面的示例中一样），或者在需要函数类型的表达式时使用它：</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">编译器可以不为参数创建一个函数对象并生成一个调用,而是发出以下代码。</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native运行时代替线程来提供工作程序的概念：同时执行的控制流和关联的请求队列。工人与&amp;ldquo;演员模型&amp;rdquo;中的演员非常相似。一个工作人员可以与另一个工作人员交换Kotlin对象，以便任何时候每个可变对象都由一个工作人员拥有，但是所有权可以转移。请参阅&lt;a href=&quot;#transfer&quot;&gt;对象传输和冻结部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">指示编译器为带有声明位置差异的参数对应的类型实参生成或忽略通配符，例如 &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; 具有。</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">指示编译器为注释类型参数生成通配符,这些参数对应于具有声明点差异的参数。</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">指示Kotlin编译器不要为这个属性生成getters/setters,而是将其作为一个字段公开。</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">指示Kotlin编译器生成一个多文件类，其中包含在此文件中声明的顶级功能和属性作为其一部分。相应的多文件类的名称由&lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt;批注提供。</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">指示Kotlin编译器为该函数生成替代默认参数值的重载。</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">指示Kotlin编译器将注释的Java类视为给定Kotlin接口的纯实现。&quot;Pure &quot;是指类的每个类型参数都成为该接口的非平台类型参数。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">与Python中任意大的整数相反，Kotlin中的整数类型的&lt;em&gt;大小有限&lt;/em&gt;。该限制取决于类型，该类型决定了该数字在内存中占据多少位：</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">整体式范围（&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt;）有一个额外的功能：它们可以遍历。这些范围也是相应整数类型的&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;级数&lt;/a&gt;。这样的范围一般用于在迭代 &lt;code&gt;for&lt;/code&gt; 环路。</target>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA可以自动刮擦。要在短时间内停止键入后获得执行结果，请打开&amp;ldquo; &lt;strong&gt;交互&amp;rdquo;模式&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA将在&lt;a href=&quot;#maven-configuration&quot;&gt;Maven配置中&lt;/a&gt;为我们添加相应的条目。</target>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">与DOM互动</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">与DOM的交互</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">互动模式</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor进行&lt;/a&gt;拦截截取。</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor进行&lt;/a&gt;拦截截取。</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">拦截委托属性绑定</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">用&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;拦截此继续。</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">接口实现布局</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">表示在悬浮点之后的延续的接口，该延续返回类型 &lt;code&gt;T&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">接口中的悬浮液点后表示的延续这种类型的回报值 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">接口&lt;em&gt;A&lt;/em&gt;和&lt;em&gt;B&lt;/em&gt;都声明了函数&lt;em&gt;foo（）&lt;/em&gt;和&lt;em&gt;bar（）&lt;/em&gt;。它们都实现&lt;em&gt;foo（）&lt;/em&gt;，但是只有&lt;em&gt;B&lt;/em&gt;实现&lt;em&gt;bar（）&lt;/em&gt;（&lt;em&gt;A中&lt;/em&gt;没有将&lt;em&gt;bar（）&lt;/em&gt;标记为abstract ，因为如果函数没有主体，这是接口的默认值）。现在，如果我们从&lt;em&gt;A&lt;/em&gt;派生出具体的类&lt;em&gt;C&lt;/em&gt;，显然，我们必须重写&lt;em&gt;bar（）&lt;/em&gt;并提供一个实现。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">接口 继承</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin中的接口与Java 8非常相似。它们可以包含抽象方法的声明,以及方法实现。它们与抽象类的不同之处在于,接口不能存储状态,它们可以有属性,但这些属性需要是抽象的,或者提供访问器实现。它们可以有属性,但这些属性需要是抽象的,或者提供访问器实现。</target>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">与Java的互操作</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">与Java反射的互操作性</target>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">还提供了与Swift / Objective-C的互操作性，并在单独的文档&lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">将表达式引入为局部作用域中的变量： &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">Kotlin简介(俄语)</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">Kotlin编程介绍</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">将此值的位数反转。</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">将该值中包括符号位在内的位进行反转。</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">的调用&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt;直接在调用者的线程恢复协程无需经过去&lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;可能存在的协程的&lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;。调用者有责任确保建立正确的调用上下文。&lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt;可用于获取截获的连续性。</target>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">调用操作员</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">当原始延续完成且不再使用时，为&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;返回的延续实例调用。仅当&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;返回的调用实例不同于其调用实例时，才调用此函数。</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">在函数对象上调用 &lt;code&gt;call()&lt;/code&gt; 将调用该函数。如果它是成员函数，则第一个参数必须是&lt;em&gt;接收者&lt;/em&gt;（要在其上调用函数的对象，在这种情况下为 &lt;code&gt;person&lt;/code&gt; ），而其余参数必须是普通的函数参数（在这种情况下为 &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ） 。</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">调用 &lt;code&gt;findViewById()&lt;/code&gt; 可能会很慢，尤其是在视图层次结构庞大的情况下，因此Android扩展会尝试通过在容器中缓存视图来最小化 &lt;code&gt;findViewById()&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">调用函数类型实例</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">在其他集合上调用函数</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">Kotlin是一种面向对象的语言还是一种功能型语言?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">Kotlin与Java编程语言兼容吗?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">Kotlin是免费的吗?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">Kotlin难吗?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">Kotlin在社交媒体上吗?</target>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">是扩展功能</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">有Kotlin会议吗?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">这不是我们一开始就想要的吗?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">在一个单独的JavaScript对象中隔离声明。</target>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">它还可以与元注释一起使用。</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">可以通过一个在&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;中创建协程的简单示例来证明这一点：</target>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">当然，它可以作为单个表达式完成： &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">它演示了几种新技术。一种是在具有明确指定的上下文的情况下使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;，另一种是使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt;函数更改协程的上下文，同时仍保持在同一协程中，如下面的输出所示：</target>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">actor本身在什么上下文中执行并不重要(为了正确性)。一个actor是一个coroutine,而一个coroutine是按顺序执行的,所以将状态限制在特定的coroutine中可以作为共享可变状态问题的一个解决方案。事实上,actor可以修改自己的私有状态,但只能通过消息来影响对方(避免任何锁的需要)。</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">它期望目标为 &lt;code&gt;writeLogMessage&lt;/code&gt; 提供特定于平台的实现，并且通用代码现在可以使用此声明，而无需考虑如何实现。</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">当你有一个可调用的引用而不是lambda时,使用它也很方便。</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">也可以在项目中配置所有的Kotlin编译任务。</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">也可以使用标准的Chrome调试器来调试Kotlin应用程序。只要确保你能生成源码图。</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">也可以通过任意步长（不一定为1）迭代数字。这是通过&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt;功能完成的。</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">一次性导入特定布局的所有widget属性,非常方便。</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">它是通过将 &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 函数附加到元素源来创建的。要获得&lt;a href=&quot;index&quot;&gt;分组&lt;/a&gt;的实例，请使用 &lt;code&gt;groupingBy&lt;/code&gt; 扩展功能之一：</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">很容易用行动来证明。</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">将编译的Kotlin代码包含到以C，C ++，Swift，Objective-C和其他语言编写的现有项目中很容易。使用现有的本机代码，静态或动态&lt;a href=&quot;native/c_interop&quot;&gt;C库&lt;/a&gt;，Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;框架&lt;/a&gt;，图形引擎以及直接来自Kotlin / Native的其他任何工具也很容易。</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">对于Kotlin的C &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 类型，可以轻松使用生成的包装器类。由于生成了属性，因此在Kotlin代码中使用它们很自然。到目前为止，唯一的问题是我们如何在这些类上创建一个新实例。从 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 的声明中可以看到，它们的构造函数需要 &lt;code&gt;NativePtr&lt;/code&gt; 。当然，我们不愿意手动处理指针。相反，我们可以使用Kotlin API为我们实例化那些对象。</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">它相当于这段Java代码。</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">禁止内联类参与类层次结构。这意味着内联类不能扩展其他类，并且必须是&lt;em&gt;final&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">重要的是要注意，某些&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin / Native目标&lt;/a&gt;只能使用适当的主机构建：</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">重要的是要理解，就像在 &lt;code&gt;callAnything()&lt;/code&gt; 的情况下一样， &lt;code&gt;dataTable()&lt;/code&gt; 函数必须在运行时存在。在我们的情况下，我们需要确保包含插件的相应脚本文件：</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">不建议发布按产品风味分组的变体,以防它们有不同的依赖关系,因为这些变体会被合并到一个依赖关系列表中。</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">它不需要匹配目录和包:源文件可以任意放在文件系统中。</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">现在可以用一种通用的方式来枚举一个枚举类的值。</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">它是独立于平台的。无论我们是针对JVM、JavaScript还是其他平台,我们写的代码都是一样的。在掩护之下,编译器会负责让它适应每个平台。</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">类有可能像执行接口一样实现函数类型。然后，它必须提供带有给定签名的称为 &lt;code&gt;invoke&lt;/code&gt; 的运算符函数，然后可以将该类的实例分配给该函数类型的变量：</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">可以对通用类型的类型参数进行注解,以便为它们提供空性信息。例如,考虑一下Java声明中的这些注释。</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">可以一次性配置所有源集的语言设置。</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">可以使用 &lt;code&gt;memScoped { ... }&lt;/code&gt; 下的 &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 扩展属性创建 &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 实例的C表示形式的作用域稳定的指针。它允许使用需要C指针且生命周期绑定到某个 &lt;code&gt;MemScope&lt;/code&gt; 的API。例如：</target>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">可以为您自己的函数声明合同，但是此功能是&lt;strong&gt;实验性的，&lt;/strong&gt;因为当前语法处于早期原型状态，并且很可能会更改。另外，请注意，当前Kotlin编译器不验证合同，因此编写正确和合理的合同是程序员的责任。</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">可以按全局过滤标题。 &lt;code&gt;.def&lt;/code&gt; 文件中的 &lt;code&gt;headerFilter&lt;/code&gt; 属性值被视为以空格分隔的glob列表。如果包含的标头与任何glob匹配，则来自此标头的声明将包含在绑定中。</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">在一个多平台库中,一个平台可以有多个目标。例如,这些目标可以提供相同的API,但在运行时与之合作的库不同,如测试框架或日志解决方案。</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">可以指定哪些构建类型将被用于创建二进制文件,哪些不会。在下面的例子中,只创建调试可执行文件。</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">拥有键列表并希望通过将这些键中的每个键与某个值相关联来构建映射是一种很常见的情况。以前可以通过 &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 函数来做到这一点，但是现在我们引入了一种更有效，更容易探索的替代方法： &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 视为 &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; 是安全的-然后，您只能在其中添加 &lt;code&gt;Apple&lt;/code&gt; 实例，但这没关系，因为它可以接收任何 &lt;code&gt;Fruit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; 视为 &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 是安全的-它只会生产 &lt;code&gt;Apple&lt;/code&gt; 实例，但这没关系，因为 &lt;code&gt;Apple&lt;/code&gt; 是 &lt;code&gt;Fruit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">它与&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;条目&lt;/a&gt;集的hashCode相同。</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">现在该尝试从我们的Kotlin程序中使用C函数了。让我们调用 &lt;code&gt;accept_fun&lt;/code&gt; 函数并将C函数指针传递给Kotlin lambda：</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">这是声明类型参数T作为非常方便的&lt;em&gt;进行&lt;/em&gt;并避免麻烦子类型上使用的网站，但有些类&lt;strong&gt;不能&lt;/strong&gt;实际上只限于返回 &lt;code&gt;T&lt;/code&gt; 的！一个很好的例子是数组：</target>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">它启动了100K个coroutine,一秒钟后,每个coroutine打印一个点。现在,用线程试试。会发生什么?(很可能你的代码会产生某种内存外的错误)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">这就导致了在Kotlin中看到的以下签名。</target>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">只有在没有通配符的情况下,在Java中声明似乎不方便使用时,它才会有帮助。</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">只有在Java中声明似乎不方便使用时,它才会有帮助。</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">通过切换IntelliJ IDEA中的默认值并使格式化与Kotlin编码约定保持一致来消除这种模糊性,这似乎是一个合乎逻辑的下一步。但这将意味着所有现有的Kotlin项目在安装Kotlin插件的那一刻就会启用新的代码风格。这其实并不是插件更新的预期结果吧?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">这意味着，在执行基类构造函数时，尚未初始化在派生类中声明或覆盖的属性。如果在基类初始化逻辑中使用了这些属性中的任何一个（直接或间接地通过另一个重写的&lt;em&gt;开放&lt;/em&gt;成员实现），则可能导致错误的行为或运行时失败。因此，在设计基类时，应避免在构造函数，属性初始化程序和&lt;em&gt;init&lt;/em&gt;块中使用&lt;em&gt;开放&lt;/em&gt;成员。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">可能会尝试使用JVM的 &lt;code&gt;java.util.Scanner&lt;/code&gt; 类来解析结构化程度较低的输入格式。Kotlin旨在与JVM库良好地互操作，因此在Kotlin中使用它们非常自然。但是，请注意 &lt;code&gt;java.util.Scanner&lt;/code&gt; 非常慢。实际上，它是如此之慢，以至于用它解析10 &lt;sup&gt;5个&lt;/sup&gt;或更多整数可能不适合典型的2秒时限，这是简单的Kotlin的 &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; 可以处理的。</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">它使用容量为&lt;em&gt;4&lt;/em&gt;的缓冲通道打印&amp;ldquo;发送&amp;rdquo; &lt;em&gt;五次&lt;/em&gt;：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">它打印的行数如下:</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;调试模式下&lt;/a&gt;运行时，它会产生类似的结果：</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">它产生的东西是这样的。</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">它产生以下输出(可能顺序不同)。</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">它产生以下输出:</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">它返回传递给它的两个函数的组合： &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; 。现在，您可以将其应用于可调用引用：</target>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">它带有两个 &lt;code&gt;Int&lt;/code&gt; 参数并返回 &lt;code&gt;Double&lt;/code&gt; ，因此其类型为 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 。我们可以通过在函数名称前加上 &lt;code&gt;::&lt;/code&gt; 来引用函数本身，并且可以将其分配给变量（通常会推断出其类型，但我们将演示类型签名）：</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">它将产生特定于平台的共享对象（在Linux上为.so，在macOS上为.dylib，在Windows目标上为.dll）和C语言标头，从而允许使用C /中Kotlin / Native程序中可用的所有公共API。 C ++代码。有关使用此类共享库在Python和Kotlin / Native之间架起桥梁的示例，请参见 &lt;code&gt;samples/python_extension&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">它将产生一个平台特定的静态对象(.a库格式)和一个C语言头,允许你从C/C++代码中使用Kotlin/Native程序中所有可用的公共API。</target>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">开始使用Kotlin进行Android开发非常容易。在本教程中，我们将遵循Android Studio的预热过程。如果您在Android上使用Intellij IDEA，则过程几乎相同。</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">允许在&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;目标中&lt;/a&gt;传递相同的数组，甚至可以指定子范围，使其与目标范围重叠。</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">允许在&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;目标中&lt;/a&gt;传递相同的数组，甚至可以指定子范围，使其与目标范围重叠。</target>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">始终可以将IntelliJ IDEA代码样式显式设置为项目的正确代码样式。为此，请在 &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; &lt;em&gt;&amp;ldquo; Kotlin&amp;rdquo;&lt;/em&gt;中切换到&amp;ldquo; &lt;em&gt;项目&amp;rdquo;&lt;/em&gt;方案，&lt;em&gt;然后&lt;/em&gt;在&lt;em&gt;&amp;ldquo; &lt;/em&gt;&lt;em&gt;加载&amp;rdquo;&lt;/em&gt;选项卡上的&lt;em&gt;&amp;ldquo;使用默认来源：&amp;rdquo;中&lt;/em&gt;选择&lt;em&gt;&amp;ldquo; Kotlin过时的IntelliJ IDEA &lt;/em&gt;代码样式&lt;em&gt;&amp;rdquo;&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">当前无法将&lt;em&gt;null&lt;/em&gt;传递给声明为varargs的方法。</target>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">从 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 继承都可以，并且 &lt;code&gt;a()&lt;/code&gt; 和 &lt;code&gt;b()&lt;/code&gt; 没有问题，因为 &lt;code&gt;C&lt;/code&gt; 仅继承了每个函数的一个实现。但是对于 &lt;code&gt;f()&lt;/code&gt; 我们有两个 &lt;code&gt;C&lt;/code&gt; 继承的实现，因此我们必须在 &lt;code&gt;C&lt;/code&gt; 中重写 &lt;code&gt;f()&lt;/code&gt; 并提供我们自己的实现以消除歧义。</target>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">当你完成一个流时,关闭它是很重要的;否则,你的程序会泄漏一个文件句柄。请参阅下一节,了解如何很好地做到这一点。</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">确保选中&amp;ldquo; &lt;em&gt;包括Kotlin支持&amp;rdquo;&lt;/em&gt;复选框很重要。现在，我们可以在向导的下一步中保留默认设置。然后，我们继续选择&lt;em&gt;清空活动&lt;/em&gt;选项，然后单击&lt;em&gt;下一步&lt;/em&gt;，最后按&lt;em&gt;完成&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">重要的是要明白,现在这是一个本地应用程序,不需要运行时或虚拟机。我们现在可以从控制台运行编译后的二进制文件。</target>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">它不建议与申请科特林插件 &lt;code&gt;apply&lt;/code&gt; 于摇篮科特林DSL。&lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;下面&lt;/a&gt;提供了详细信息。</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">通常，我们需要复制一个对象以更改其&lt;em&gt;某些&lt;/em&gt;属性，但保持其余部分不变。这就是生成 &lt;code&gt;copy()&lt;/code&gt; 函数的目的。对于上面的 &lt;code&gt;User&lt;/code&gt; 类，其实现如下：</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">可以为一个组件声明一个cinterop依赖关系。</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">可能依赖于先前在Maven存储库中发布的Kotlin / Native库。该插件依赖Gradle的&lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;元数据&lt;/a&gt;支持，因此必须启用相应的功能。在 &lt;code&gt;settings.gradle&lt;/code&gt; 中添加以下行：</target>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">建议用这个注解将实验状态传播到依赖于无符号类型的API上。</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">你可以决定你的客户是否必须明确地选择使用你的API,但是请记住,无符号类型是一个实验性的功能,所以使用它们的API可能会因为语言的变化而突然中断。</target>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">缩短长的通用类型是很有用的。例如,我们经常想缩短集合类型。</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">一个lambda表达式只有一个参数是很常见的。</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">遍历此读取器的每一行，为读取的每一行调用&lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;操作&lt;/a&gt;，并在&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;读取器&lt;/a&gt;完成时关闭它。</target>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">在一个集合上迭代。</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">在一个范围内迭代。</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">字符序列的迭代器。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">可以通过调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt;函数来为&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;接口的继承者（包括 &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;List&lt;/code&gt; ）获取迭代器。获得迭代器后，它指向集合的第一个元素；调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;函数将返回此元素，并将迭代器位置移动到以下元素（如果存在）。一旦迭代器通过了最后一个元素，它就不能再用于检索元素。也无法将其重置到任何以前的位置。要再次遍历集合，请创建一个新的迭代器。</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">来自 &lt;code&gt;androidMain&lt;/code&gt; 源集的Android项目的JAR文件</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA支持</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305（ &lt;code&gt;javax.annotation&lt;/code&gt; ，更多详细信息在下面）</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305支持</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVM后端</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVM后端</target>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">Jar文件</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">Java 7对资源的尝试</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">支持Java 8字节码</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">支持Java 8标准库</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">Java注释</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">Java数组</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Http servlets可以从Kotlin中使用,就像其他Java库或框架一样。我们将看到如何制作一个简单的控制器,返回 &quot;Hello,World!&quot;。</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">Java互操作性</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">Java 反射</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVM目标中的Java支持</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">Java Varargs</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">Java注释与Kotlin 100%兼容。</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Java类有时会使用一个方法声明来表示具有可变参数数(varargs)的索引。</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">Java编译器选项</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">Kotlin中的Java泛型</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">Java互操作。</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Java在几年前才开始支持函数类型和lambda表达式。此前,Java通过使用一个接口来定义函数签名,并允许内联、匿名定义一个实现该接口的类来解决这个问题。这在Kotlin中也是可用的,部分原因是为了与Java库兼容,部分原因是它可以方便地指定事件处理程序(特别是当有多个事件类型必须由同一个监听器对象监听时)。考虑一个接口或一个(可能是抽象的)类,以及一个接受它的实例的函数。</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">Java反射适用于Kotlin类，反之亦然。如上所述，您可以使用 &lt;code&gt;instance::class.java&lt;/code&gt; ， &lt;code&gt;ClassName::class.java&lt;/code&gt; 或 &lt;code&gt;instance.javaClass&lt;/code&gt; 通过 &lt;code&gt;java.lang.Class&lt;/code&gt; 输入Java反射。</target>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">具有可空性注解的Java类型不是作为平台类型来表示,而是作为实际的可空或非空的Kotlin类型来表示。编译器支持几种类型的可空性注解,包括:</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Java的数组映射为提到&lt;a href=&quot;java-interop#java-arrays&quot;&gt;如下&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Java的盒式基元类型被映射为可空的Kotlin类型。</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Java的原始类型被转换为星形投影。</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Java的通配符被转换为类型投影。</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">Java默认方法调用</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">Java风格的反射</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">Java2Kotlin转换器</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">JavaScript后端</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">JavaScript DCE</target>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">JavaScript模块</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">JavaScript反思</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">JavaScript后端</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">现在JavaScript后台生成的代码更多的是可静态检查的,这对JS代码处理工具更友好,如minifiers、优化器、linters等。</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScript没有包（命名空间）的概念。它们通常由嵌套对象模拟。编译器将对 &lt;code&gt;external&lt;/code&gt; 声明的引用转换为纯无前缀名称（如果使用&lt;em&gt;纯&lt;/em&gt;模块）或纯导入。但是，如果JavaScript库在包中提供其声明，您将不会对此感到满意。您可以使用 &lt;code&gt;@JsQualifier(...)&lt;/code&gt; 批注告诉编译器在引用 &lt;code&gt;external&lt;/code&gt; 声明之前生成其他前缀。</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScript没有接口的概念。当函数期望其参数支持 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 方法时，只需传递实际具有这些方法的对象即可。您可以使用接口将其表示为静态类型的Kotlin，例如：</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains开发和维护了几个专门用于React社区的工具：&lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React绑定&lt;/a&gt;以及&lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;。后者可以帮助您开始使用没有构建配置的Kotlin构建React应用。</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">工作的背景</target>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">和我们一起在相关教程中继续探索C语言类型及其在Kotlin/Native中的表示。</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">参加课程</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">约书亚&amp;middot;布洛克称这些对象，你只能&lt;strong&gt;读&lt;/strong&gt;从&lt;strong&gt;生产者&lt;/strong&gt;，而那些只&lt;strong&gt;写&lt;/strong&gt;到&lt;strong&gt;消费者&lt;/strong&gt;。他建议：&amp;ldquo; &lt;em&gt;为了获得最大的灵活性，请在代表生产者或消费者的输入参数上使用通配符类型&lt;/em&gt; &amp;rdquo;，并提出以下助记符：</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">线程之间的跳转</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">只要将插件JAR文件添加到编译器插件classpath中,并指定sam-with-receiver注释列表即可。</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">就像在Java 8中一样,Kotlin现在允许在数字文字中使用下划线来分隔数字组。</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">就像Java 8一样,Kotlin支持SAM转换。这意味着,只要接口方法的参数类型与Kotlin函数的参数类型相匹配,Kotlin函数字面值就可以通过一个非默认方法自动转换为Java接口的实现。</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">就像Java和JavaScript一样,Kotlin支持行结束和块注释。</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">就像Java的匿名内类一样,对象表达式中的代码可以从包围的作用域中访问变量。与Java不同的是,这并不限于final或有效的final变量)。</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">就像Java中一样， &lt;code&gt;value&lt;/code&gt; 参数是一个特例。可以不使用显式名称来指定其值：</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">就像Java中一样，Kotlin中的枚举类具有综合方法，可以列出定义的枚举常量并通过其名称获取枚举常量。这些方法的签名如下（假设枚举类的名称为 &lt;code&gt;EnumClass&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">就像companion对象的普通成员一样,它们可以只用类名作为限定符被调用。</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">就像JavaDoc一样，KDoc注释以 &lt;code&gt;/**&lt;/code&gt; 开头，以 &lt;code&gt;*/&lt;/code&gt; 结尾。注释的每一行都可以以星号开头，该星号不被视为注释内容的一部分。</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc语法</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDoc目前支持以下区块标签。</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDoc不支持 &lt;code&gt;@deprecated&lt;/code&gt; 标记。相反，请使用 &lt;code&gt;@Deprecated&lt;/code&gt; 批注。</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc语法</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">Kapt可以生成Kotlin源。只需将生成的Kotlin源文件写入到 &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; 指定的目录中，这些文件就会与主要源文件一起编译。</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt编译器插件可以在Kotlin编译器的二进制发行版中使用。</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kapt使用Java编译器来运行注释处理器。</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">请记住，这只是语法糖-您实际上并没有在修改类或其实例。因此，您必须在要使用扩展功能/属性的任何地方导入它（因为扩展功能/属性不会随类的实例一起提供）。出于同样的原因，您不能覆盖扩展成员-您可以为子类型重新实现扩展成员，但是解决方案是在编译时根据调用它的表达式的静态类型进行的。因此，如果您为 &lt;code&gt;Vehicle&lt;/code&gt; 声明了一个扩展函数，并且为其子类 &lt;code&gt;Car&lt;/code&gt; 声明了一个具有相同名称和签名的扩展函数，然后执行以下操作，那么即使 &lt;code&gt;v&lt;/code&gt; 确实是 &lt;code&gt;Car&lt;/code&gt; ，也将调用 &lt;code&gt;Vehicle&lt;/code&gt; 的扩展函数：</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">多年来,保持语言的现代化。</target>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">Keepsafe的App Lock应用也已&lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;转换为100％Kotlin&lt;/a&gt;，从而使源代码行计数减少了30％，方法计数减少了10％。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;元素的键。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;是具有此键的元素的类型。</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;元素的键。&lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt;是具有此键的元素的类型。&lt;em&gt;通过引用&lt;/em&gt;比较上下文中的键。</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">关键词和操作者</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">一种由编译器生成的模块</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">样的这个参数。</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">Kind表示参数声明在源代码中的特定位置,如实例、扩展接收器参数或值参数。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1引入了协程，这是一种编写异步，非阻塞代码（以及更多）的新方法。在本教程中，我们将在 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 库的帮助下，了解使用Kotlin协程的一些基础知识，该库是现有Java库的帮助程序和包装程序的集合。</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1删除了Kotlin 1.0中对密封类和数据类的一些限制。现在你可以在同一个文件中定义顶层密封类的子类,而不仅仅是作为密封类的嵌套类。数据类现在可以扩展其他类。这可以用来很好地、干净地定义表达式类的层次结构。</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2引入了一组用于 &lt;code&gt;BigInteger&lt;/code&gt; 和 &lt;code&gt;BigDecimal&lt;/code&gt; 并从其他数字类型创建它们的函数。这些是：</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3继续发展和改进脚本API,引入了一些实验性的脚本定制支持,如添加外部属性、提供静态或动态依赖等。</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3继续改进和完善了Native目标。有关详细信息，请参见&lt;a href=&quot;native-overview&quot;&gt;Kotlin / Native概述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3引入了一种更简单的 &lt;code&gt;main&lt;/code&gt; 形式，该形式不带参数。现在，科特林的&amp;ldquo; Hello，World&amp;rdquo;要短19个字符！</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3引入了一种新的声明&amp;mdash; &lt;code&gt;inline class&lt;/code&gt; 。可以将内联类视为普通类的受限版本，特别是，内联类必须具有唯一的一个属性：</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3在Reflection API中引入了悬浮函数的可调用引用和对Coroutines的支持。</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3引入了对可运行Kotlin &lt;em&gt;暂存文件的&lt;/em&gt;支持。&lt;em&gt;Scratch文件&lt;/em&gt;是带有.kts扩展名的kotlin脚本文件，您可以直接在编辑器中运行并获取评估结果。</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3引入了对IDE中&lt;a href=&quot;coding-conventions&quot;&gt;推荐代码风格的&lt;/a&gt;支持。请查看&lt;a href=&quot;code-style-migration-guide&quot;&gt;此页面&lt;/a&gt;以获取迁移指南。</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3引入了无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3 放宽了这一限制,并增加了对大数子函数的支持。</target>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; 可以作为 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; 访问。还有就是 &lt;code&gt;_instance&lt;/code&gt; 函数来获取对象的唯一实例。</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">Kotlin Android扩展</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">Kotlin 编码约定和 IntelliJ IDEA 格式器</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">Kotlin Collections概述</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">Kotlin定义</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">Kotlin教育插件</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">Kotlin的进化</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">Kotlin示例</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradle插件1.3.41适用于Android Gradle Plugin 3.0及以上版本。</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">Kotlin JavaScript概述</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C提取API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C文件API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">用于&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;导航Timing API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API的&lt;/a&gt; Kotlin JavaScript包装器。</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">用于DOM API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">用于DOM CSS API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">用于DOM SVG API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">用于DOM URL API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">用于DOM事件API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">用于DOM解析API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">用于WebGL API的Kotlin JavaScript封装器。</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">Kotlin Koans</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans是一系列让你熟悉Kotlin语法的练习。每个练习都被创建为一个失败的单元测试,而你的工作就是让它通过。你可以通过以下两种方式来使用Kotlin Koans。</target>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin多平台项目需要Gradle 4.7及以上版本,不支持旧版Gradle。</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">Kotlin Multiplatform项目通过提供 &lt;code&gt;android&lt;/code&gt; 预设来支持Android平台。创建Android目标需要手动将一个Android Gradle插件（例如 &lt;code&gt;com.android.application&lt;/code&gt; 或 &lt;code&gt;com.android.library&lt;/code&gt; ）应用于项目。每个Gradle子项目只能创建一个Android目标：</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">Kotlin数字和NSNumber</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">Kotlin编程。大书呆子牧场指南</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">Kotlin脚本API</target>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">Kotlin Scripts (*.kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">Kotlin标准库</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin允许我们为类型上的一组预定义操作符提供实现。这些运算符具有固定的符号表示形式（如 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;*&lt;/code&gt; ）和固定的&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;优先级&lt;/a&gt;。为了实现运算符，我们为相应的类型提供了具有固定名称的&lt;a href=&quot;functions#member-functions&quot;&gt;成员函数&lt;/a&gt;或&lt;a href=&quot;extensions&quot;&gt;扩展函数&lt;/a&gt;，即对于二进制运算而言是左侧类型，对于一元运算符而言是参数类型。重载运算符的功能需要使用 &lt;code&gt;operator&lt;/code&gt; 修饰符进行标记。</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlin允许你将你的Kotlin项目编译成JavaScript模块,用于流行的模块系统。下面是可用选项的列表。</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlin允许您通过&lt;em&gt;可见性修饰符&lt;/em&gt;来强制符号可见性（Python仅通过下划线约定来实现），可以将其放置在符号声明上。如果不提供可见性修改器，则会获得默认的可见性级别，即&lt;em&gt;public&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlin还具有专门的类来表示原始类型的数组，而无需装箱： &lt;code&gt;ByteArray&lt;/code&gt; ， &lt;code&gt;ShortArray&lt;/code&gt; ， &lt;code&gt;IntArray&lt;/code&gt; 等。这些类与 &lt;code&gt;Array&lt;/code&gt; 类没有继承关系，但是它们具有相同的方法和属性集。它们每个都具有对应的工厂功能：</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlin还支持浮点数的传统符号。</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin和TeamCity的持续集成</target>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">Kotlin和OSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin和Swift都将nullability定义为类型规范的一部分,而Objc则在类型的方法和属性上定义了nullability。因此,以下。</target>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlin应用可以部署到任何支持Java Web应用的主机中,包括Amazon Web Services、Google Cloud Platform等。</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">Kotlin作为一种静态类型的编程语言,在编写Gradle构建脚本时发挥了很好的作用。得益于静态类型推理,Kotlin编译器可以更早地发现错误,并显示重要的编译错误信息和警告。IDE和编译器都可以使用类型信息来推断给定作用域中的可用函数和属性。</target>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin也可以作为一种脚本语言使用。脚本是一个包含顶级可执行代码的Kotlin源文件(.kts)。</target>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlin可以被编译到几个不同的平台上。在本文档中,我们假设目标平台是Java虚拟机,这赋予了一些额外的功能--特别是,您的代码将被编译成Java字节码,因此将与Java库的大型生态系统互操作。</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlin可以用于任何类型的开发,无论是服务器端、客户端的Web和Android。目前,Kotlin/Native正在开发中,对其他平台的支持也即将到来,如嵌入式系统、macOS和iOS。人们正在将Kotlin用于移动和服务器端应用,客户端与JavaScript或JavaFX,以及数据科学,这只是一些可能性。</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlin可以与现有的第三方库和框架（例如jQuery或React）一起使用。要使用强类型API访问第三方框架，您可以使用&lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt;工具将TypeScript定义从&amp;ldquo; &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;绝对类型&amp;rdquo;&lt;/a&gt;类型定义存储库转换为Kotlin 。或者，您可以使用&lt;a href=&quot;dynamic-type&quot;&gt;动态类型&lt;/a&gt;来访问任何框架，而无需强类型化。</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlin可以非常接近Python的 &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 理解的紧凑性。假设 &lt;code&gt;people&lt;/code&gt; 是具有 &lt;code&gt;name&lt;/code&gt; 属性的 &lt;code&gt;Person&lt;/code&gt; 对象的集合：</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlin在运行时无法区分数字类型（ &lt;code&gt;kotlin.Long&lt;/code&gt; 除外），即以下代码有效：</target>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlin非常在意代码的稳定性和向后兼容性。Kotlin的兼容性政策规定,只有在主要版本(1.2、1.3等)中才能引入 &quot;中断性改动&quot;(例如,使过去可以正常编译的代码不再编译的改动)。</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">Kotlin类和接口可以被Swift/Objective-C类和协议子类化。</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">Kotlin类在Objective-C中有一个 &lt;code&gt;KotlinBase&lt;/code&gt; 基类，该类在那里扩展了 &lt;code&gt;NSObject&lt;/code&gt; 类。我们也有用于集合和异常的包装器。大部分收集类型从另一端映射到相似的收集类型：</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">Kotlin代码可以轻松地从Java中调用。例如,Kotlin类的实例可以在Java方法中无缝创建和操作。然而,在将Kotlin代码集成到Java中时,需要注意Java和Kotlin之间的某些差异。在本页中,我们将介绍如何调整Kotlin代码与其Java客户端的互操作。</target>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin集合（即 &lt;code&gt;List&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; 等）未映射到任何特定的JavaScript类型。</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">如上表所述，将Kotlin集合转换为Swift / Objective-C集合。 Swift / Objective-C集合以相同的方式映射到Kotlin，除了 &lt;code&gt;NSMutableSet&lt;/code&gt; 和 &lt;code&gt;NSMutableDictionary&lt;/code&gt; 。 &lt;code&gt;NSMutableSet&lt;/code&gt; 不会转换为Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 。要为Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 传递对象，您可以显式地创建此类Kotlin集合，方法是使用例如 &lt;code&gt;mutableSetOf()&lt;/code&gt; 在Kotlin中创建它，或者在Swift中使用 &lt;code&gt;KotlinMutableSet&lt;/code&gt; 类（或在Objective-C中使用 &lt;code&gt;${prefix}MutableSet&lt;/code&gt; ，其中有 &lt;code&gt;prefix&lt;/code&gt; 是框架名称前缀）。 &lt;code&gt;MutableMap&lt;/code&gt; 也是如此。</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlin集合包含用于常用&lt;em&gt;聚合操作的&lt;/em&gt;函数，这些函数基于集合内容返回单个值。其中大多数是众所周知的，并且以与其他语言相同的方式工作：</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin集合提供了一组用于从集合中检索单个元素的函数。本页描述的函数既适用于列表,也适用于集合。</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">Kotlin社区是开放的,乐于助人的,欢迎大家加入。不要犹豫,加入并在任何你喜欢的平台上询问。</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlin编译器可以从JavaScript代码中生成正常的JavaScript类、函数和属性,你可以自由使用。然而,有一些微妙的事情你应该记住。</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlin编译器产生的是字节码,因此Kotlin应用程序与Java编写的应用程序在外观和感觉上确实没有区别。</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">Kotlin编译器细节</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin编译器将产生以下输出</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlin构造函数作为初始化器被导入到Swift/Objective-C中。</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin文档是一个很好的开始,请查看这些链接来让你的脚步湿润。</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">Kotlin没有Python的&lt;em&gt;资源管理器&lt;/em&gt;或Java的&lt;em&gt;try-with-resources&lt;/em&gt;，但是由于具有扩展功能，因此可以 &lt;code&gt;use&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">Kotlin没有检查的&lt;a href=&quot;exceptions&quot;&gt;异常&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">Kotlin没有检查异常。这有很多原因,但我们将提供一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">Kotlin在JavaScript中没有实现顶层属性的懒惰初始化。</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlin确保在编译时涉及&lt;a href=&quot;generics&quot;&gt;泛型&lt;/a&gt;的操作的类型安全，而在运行时，泛型类型的实例不保存有关其实际类型参数的信息。例如，将 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; 删除为 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 。通常，无法在运行时检查实例是否属于具有某些类型参数的泛型类型。</target>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin将其包结构暴露给JavaScript,所以除非你在根包中定义你的声明,否则你必须在JavaScript中使用完全限定的名称。比如说</target>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin修复了Java存在的一系列问题。</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">Kotlin遵循Java的命名惯例。特别是:</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Kotlin for Android案例研究</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">Kotlin for Android Developers</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Kotlin for Java Developers</target>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin函数类型的对象（例如lambda）将转换为Swift函数/ Objective-C块。但是，在转换函数和函数类型时如何映射参数类型和返回值是有区别的。在后一种情况下，原始类型被映射到其盒装表示形式。 Kotlin &lt;code&gt;Unit&lt;/code&gt; 返回值在Swift / Objective-C中表示为对应的 &lt;code&gt;Unit&lt;/code&gt; 单例。可以使用与其他任何Kotlin &lt;code&gt;object&lt;/code&gt; 相同的方式来检索此单例的值（请参阅上表中的单例）。总结一下：</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin函数是&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;一流的&lt;/em&gt;&lt;/a&gt;，这意味着它们可以存储在变量和数据结构中，作为参数传递给其他&lt;a href=&quot;#higher-order-functions&quot;&gt;高阶函数或&lt;/a&gt;从其他高阶函数返回。您可以通过其他非函数值可能使用的任何方式来使用函数。</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlin生成与异步模块定义(AMD)、CommonJS和通用模型定义(UMD)兼容的JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">Kotlin处理数字的方式与Java接近,但不完全相同。例如,数字没有隐式的加宽转换,而且在某些情况下,字形也略有不同。</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlin有一个相当小的运行时文件大小:该库约为964KB(截至1.3.41)。这意味着Kotlin只增加了一点.apk文件大小。</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlin有一个广泛的标准库,可以在您的应用程序中使用。在 pom 文件中配置以下依赖关系。</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlin已经被各大公司成功采用,其中有几家公司分享了他们的经验。</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlin具有面向对象和功能构造。您可以在OO和FP样式中使用它，或将两者的元素混合使用。凭借对高阶函数，函数类型和lambda等功能的一流支持，如果您正在或正在探索函数式编程，则Kotlin是一个不错的选择。</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlin 默认具有类及其成员 &lt;code&gt;final&lt;/code&gt; ，这使得使用要求类是 &lt;code&gt;open&lt;/code&gt; 框架和库（例如Spring AOP）变得不便。在&lt;em&gt;所有开放式&lt;/em&gt;编译器插件适应科特林到这些框架的要求，并与特定的注解类及其成员没有明确的开 &lt;code&gt;open&lt;/code&gt; 的关键字。</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlin有自己的反射库（您的构建中必须包含 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; ）。以JVM为目标时，您也可以使用Java反射工具。请注意，Kotlin反射功能还不够完善-特别是，您不能使用它来检查诸如 &lt;code&gt;String&lt;/code&gt; 之类的内置类。</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlin继承了Java的烦躁（但非常灵活）的I / O方式，但是简化了一些附加功能。我们不会在这里介绍所有内容，因此对于初学者来说，这是遍历文件的所有行的方式（您需要 &lt;code&gt;import java.io.File&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">Kotlin继承了Java的烦躁数组系统，因此原始类型具有自己的数组类型和转换函数，而其他任何类型都使用通用 &lt;code&gt;Array&lt;/code&gt; 类型，可以使用 &lt;code&gt;.toTypedArray()&lt;/code&gt; 转换为该类型。</target>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlin没有检查异常的概念，所有Kotlin异常都是未检查的。 Swift仅检查了错误。因此，如果Swift或Objective-C代码调用了抛出异常进行处理的Kotlin方法，则Kotlin方法应使用 &lt;code&gt;@Throws&lt;/code&gt; 批注进行标记。在这种情况下，所有Kotlin异常（ &lt;code&gt;Error&lt;/code&gt; ， &lt;code&gt;RuntimeException&lt;/code&gt; 和子类的实例除外）都转换为Swift错误/ &lt;code&gt;NSError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlin现在可以选择生成Java 8字节码（ &lt;code&gt;-jvm-target 1.8&lt;/code&gt; 命令行选项或Ant / Maven / Gradle中的相应选项）。目前，这不会改变字节码的语义（特别是，接口和lambda中的默认方法的生成与Kotlin 1.0中的完全相同），但是我们计划稍后再使用它。</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">与Java的SAM转换相反，Kotlin具有适当的&lt;a href=&quot;lambdas#function-types&quot;&gt;函数类型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">Kotlin有三种结构跳转表达方式。</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlin有两种类型的字符串字元:可能包含转义字符的转义字符串和可以包含换行符和任意文本的原始字符串。转义字符串很像Java字符串。</target>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">Kotlin在行动</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlin为无符号整数引入了以下类型。</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">Kotlin 是一门编译过的静态类型语言,这可能会给习惯了解释型、动态类型 Python 的人带来一些初始障碍。本文档旨在解释Kotlin的语法和概念中的相当一部分与Python中相应概念的比较。</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">Kotlin非常适合开发Android应用,它将现代语言的所有优点带到了Android平台,而不会引入任何新的限制。</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlin非常适合开发服务器端应用程序,它允许你编写简洁而富有表现力的代码,同时保持与现有的基于Java的技术栈的完全兼容,并保持平滑的学习曲线。</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">Kotlin是一种实用且不受质疑的语言，支持命令式和函数式编程风格，而不会迫使开发人员选择任何一种。我们可以使用&lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;尾部递归&lt;/a&gt;等Kotlin功能以函数形式实现函数 &lt;code&gt;f&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin是OSS静态类型的编程语言，主要针对JVM，Android，JavaScript和Native。它由&lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains开发&lt;/a&gt;。该项目于2010年开始，从一开始就是开源的。第一个官方1.0版本于2016年2月发布。</target>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">Kotlin与CommonJS，AMD和UMD兼容，&lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;从而使与不同&lt;/a&gt;模块系统的交互变得简单。</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlin被设计为程序员的实用性工具。在语言进化方面,它的实用性由以下原则来体现。</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlin的设计使已经熟悉Java的人易于学习。&lt;a href=&quot;../reference/comparison-to-java&quot;&gt;官方比较页面&lt;/a&gt;上提供了差异的快速概述。简短的介绍科特林的面向软件开发人员的基本语法可以直接在网站上从开始的参考部分找到&lt;a href=&quot;../reference/basic-syntax&quot;&gt;基本语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">Kotlin在设计时就考虑到了Java的互操作性,现有的Java代码可以很自然地从Kotlin中调用,而Kotlin代码也可以很顺利地从Java中使用。现有的Java代码可以很自然地从Kotlin中调用,Kotlin代码也可以很顺利地从Java中使用。在本节中,我们将介绍一些关于从Kotlin调用Java代码的细节。</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlin与 &lt;code&gt;kotlin.js&lt;/code&gt; 标准库一起作为单个文件分发，该文件本身已编译为UMD模块，因此您可以将其与上述任何模块系统一起使用。也可以在NPM上以&lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; 软件包形式购买&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlin的灵感来自于现有的语言,如Java、C#、JavaScript、Scala和Groovy。我们试图确保Kotlin易于学习,因此人们可以很容易地跳上船,在几天内阅读和编写Kotlin。学习习惯性的Kotlin和使用它的一些更高级的功能可能需要更长的时间,但总的来说它并不是一门复杂的语言。</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">Kotlin更简洁。粗略估计表明代码行数减少了约40％。它还具有更好的类型安全性，例如，对非空类型的支持使应用程序不易使用NPE。其他功能包括智能强制转换，高阶功能，扩展功能和带有接收器的Lambda，这些功能可以编写表达性代码并促进DSL的创建。</target>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin主要由JetBrains的工程师团队开发（目前的团队规模为50+）。首席语言设计师是&lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;。除了核心团队，GitHub上还有250多个外部贡献者。</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">所有主要的Java IDE（包括&lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;，&lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;，&lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt;和&lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans）&lt;/a&gt;都支持Kotlin 。此外，还提供了&lt;a href=&quot;../tutorials/command-line&quot;&gt;命令行编译器&lt;/a&gt;，它为编译和运行应用程序提供了直接的支持。</target>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlin在在线课程中的覆盖率很高,在这里查看推荐课程。</target>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">科特林让您轻松创建使用值的范围&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt;从功能 &lt;code&gt;kotlin.ranges&lt;/code&gt; 包及其操作的形式 &lt;code&gt;..&lt;/code&gt; 。通常， &lt;code&gt;rangeTo()&lt;/code&gt; 由 &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;!in&lt;/code&gt; 函数补充。</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlin使您可以独立于存储在其中的对象的确切类型来操作集合。换句话说，你添加一个 &lt;code&gt;String&lt;/code&gt; 到列表 &lt;code&gt;String&lt;/code&gt; S中的同样的方式，你会用做 &lt;code&gt;Int&lt;/code&gt; S或用户定义的类。因此，Kotlin标准库提供了用于创建，填充和管理任何类型的集合的通用接口，类和函数。</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">Kotlin元数据</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">如果将Kotlin模块编译成框架，则可以在Swift / Objective-C代码中使用（请参阅&lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle插件文档中的&lt;/a&gt; &amp;ldquo;目标和输出种类&amp;rdquo;部分）。有关&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;示例&lt;/a&gt;，请参见计算器示例。</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlin现在与&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt;（JSR-223）集成。该API允许在运行时评估代码段：</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlin现在支持将参数名称存储在字节码中。可以使用 &lt;code&gt;-java-parameters&lt;/code&gt; 命令行选项启用它。</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">除 &lt;code&gt;kotlin.Long&lt;/code&gt; 以外的Kotlin数字类型映射到JavaScript Number。</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin对象可以被钉住,即保证其在内存中的位置稳定,直到取消钉住,这种对象内部数据的指针可以传递给C函数。例如</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">应该在IDE中安装Kotlin插件1.3.21或更高版本。可以通过&lt;em&gt;语言和框架&lt;/em&gt;进行验证&lt;em&gt;。&lt;/em&gt;IDE 的&lt;em&gt;&amp;ldquo;设置&amp;rdquo;&lt;/em&gt;（或&lt;em&gt;&amp;ldquo;首选项&amp;rdquo;&lt;/em&gt;）中的&lt;em&gt;&amp;ldquo; &lt;/em&gt;&lt;em&gt;Kotlin更新&amp;rdquo;&lt;/em&gt;部分。</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEA的Kotlin插件支持&lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;抓痕&lt;/a&gt;。Scratches使您可以在与项目相同的IDE窗口中创建代码草稿，并即时运行它们。从头开始与项目无关；您可以从操作系统上的任何IntelliJ IDEA窗口访问并运行所有暂存器。</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin保留了JavaScript中的懒惰对象初始化。</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlin保留了 &lt;code&gt;kotlin.Int&lt;/code&gt; ， &lt;code&gt;kotlin.Byte&lt;/code&gt; ， &lt;code&gt;kotlin.Short&lt;/code&gt; ， &lt;code&gt;kotlin.Char&lt;/code&gt; 和 &lt;code&gt;kotlin.Long&lt;/code&gt; 的溢出语义。</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlin基本类型框被映射到特殊的Swift / Objective-C类。例如， &lt;code&gt;kotlin.Int&lt;/code&gt; 框表示为Swift中的 &lt;code&gt;KotlinInt&lt;/code&gt; 类实例（或Objective-C中的 &lt;code&gt;${prefix}Int&lt;/code&gt; 实例，其中 &lt;code&gt;prefix&lt;/code&gt; 是框架名称的前缀）。这些类是从 &lt;code&gt;NSNumber&lt;/code&gt; 派生的，因此实例是支持所有相应操作的正确 &lt;code&gt;NSNumber&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">在命名对象或同伴对象中声明的Kotlin属性将在该命名对象或包含同伴对象的类中具有静态支持字段。</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlin提供了一系列编译器选项,在IntelliJ IDEA中也可以使用。除了我们刚才看到的用于生成源码图的选项外,我们还可以设置</target>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">Kotlin提供了多种功能来在给定对象的上下文中执行代码块： &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;run&lt;/code&gt; ， &lt;code&gt;with&lt;/code&gt; ， &lt;code&gt;apply&lt;/code&gt; 和 &lt;code&gt;also&lt;/code&gt; 。有关为您的案例选择正确的示波器功能的指南，请参阅&amp;ldquo; &lt;a href=&quot;scope-functions&quot;&gt;示波器功能&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlin 为此提供了所谓的&lt;strong&gt;星形投影&lt;/strong&gt;语法：</target>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin提供了针对JavaScript的能力。它通过将Kotlin移植到JavaScript中来实现。目前的实现以ECMAScript 5.1为目标,但计划最终也以ECMAScript 2015为目标。</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlin提供了以下代表数字的内置类型(这与Java很接近)。</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">Kotlin为Ant提供了三个任务。</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlin要求在实例构建过程中初始化每个成员属性。有时，类的使用方式应使构造函数没有足够的信息来初始化所有属性（例如，制作构建器类或使用基于属性的依赖注入时）。为了不必使这些属性可为空，可以使用&lt;em&gt;后期初始化的属性&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; 文件中的Kotlin脚本</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">Kotlin单例（使用 &lt;code&gt;object&lt;/code&gt; 声明（包括 &lt;code&gt;companion object&lt;/code&gt; ）制成）作为具有单个实例的类导入到Swift / Objective-C中。该实例可通过工厂方法使用，例如，Objective-C中的 &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; 和Swift中的 &lt;code&gt;MySingleton()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">Kotlin单子</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">要编译的Kotlin源文件或目录</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlin源集可能与&lt;em&gt;&amp;ldquo;取决于&amp;rdquo;&lt;/em&gt;关系相关联，因此，如果源集 &lt;code&gt;foo&lt;/code&gt; 取决于源集 &lt;code&gt;bar&lt;/code&gt; 则：</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin源码可以和Java源码混合在同一个文件夹中,也可以放在不同的文件夹中。默认的惯例是使用不同的文件夹。</target>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin标准库构件和拆分包。</target>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin支持一种称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;尾递归&lt;/a&gt;的函数式编程。这允许某些通常使用循环编写的算法改为使用递归函数编写，但是没有堆栈溢出的风险。当一个函数用 &lt;code&gt;tailrec&lt;/code&gt; 修饰符标记并符合所需形式时，编译器会优化递归，而留下一个快速，高效的基于循环的版本：</target>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlin通过&lt;em&gt;Kotlin注释处理工具&lt;/em&gt;（ &lt;code&gt;kapt&lt;/code&gt; ）支持&lt;em&gt;注释处理&lt;/em&gt;。&lt;a href=&quot;kapt&quot;&gt;kapt页面&lt;/a&gt;上介绍了kapt与Gradle的用法。</target>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin支持本地函数,即一个函数在另一个函数里面。</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlin支持单父类继承-因此，每个类（根类 &lt;code&gt;Any&lt;/code&gt; 除外）都只有一个父类，称为&lt;em&gt;超类&lt;/em&gt;。 Kotlin希望您仔细考虑类的设计，以确保对其进行&lt;em&gt;子类化&lt;/em&gt;实际上是安全的，因此，默认情况下类是&lt;em&gt;关闭&lt;/em&gt;的，除非您明确声明该类为&lt;em&gt;open&lt;/em&gt;或&lt;em&gt;abstract&lt;/em&gt;，否则不能继承。然后，您可以通过声明一个新类来从该类中子类化，该新类在冒号后提及其父类：</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlin支持以下运算符和特殊符号。</target>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin支持数字上的标准算术运算集，这些算术运算被声明为适当类的成员（但编译器会优化对相应指令的调用）。请参阅&lt;a href=&quot;operator-overloading&quot;&gt;运算符重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">Kotlin支持传统的&lt;em&gt;break&lt;/em&gt;和循环&lt;em&gt;继续&lt;/em&gt;操作符。请参阅&lt;a href=&quot;returns&quot;&gt;返回和跳转&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlin面向广泛的Java版本，包括Java 6和Java 7，其中不允许接口中使用默认方法。为方便起见，Kotlin编译器可解决该限制，但该解决方法与Java 8中引入的 &lt;code&gt;default&lt;/code&gt; 方法不兼容。</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">Kotlin to JavaScript</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlin特别对待某些Java类型。此类类型不是从Java 照原样加载的，而是&lt;em&gt;映射&lt;/em&gt;到相应的Kotlin类型。映射仅在编译时起作用，运行时表示形式保持不变。Java的原始类型映射到相应的Kotlin类型（请记住&lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;平台类型&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlin将函数指针返回类型转换为可为空的 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; 对象。有必要先明确检查 &lt;code&gt;null&lt;/code&gt; 。为此，我们使用&lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis运算符&lt;/a&gt;。该 &lt;code&gt;cinterop&lt;/code&gt; 工具可以帮助我们把C函数指针指向一个简单的调用对象科特林。这就是我们在最后一行所做的。</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">科特林使用函数类型，如家族 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; 的声明该处理功能： &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlin将 &lt;code&gt;libnative_&lt;/code&gt; 前缀用于所创建的 &lt;code&gt;libnative_api.h&lt;/code&gt; 文件中的所有声明。让我们以一种更具可读性的方式呈现类型的映射：</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlin旨在与Java平台轻松互操作。它将Java类视为Kotlin类，而Java将Kotlin类视为Java类。但是，JavaScript是一种动态类型的语言，这意味着它不会在编译时检查类型。您可以通过&lt;a href=&quot;dynamic-type&quot;&gt;动态&lt;/a&gt;类型从Kotlin中自由地与JavaScript对话，但是如果您想要Kotlin类型系统的全部功能，则可以为JavaScript库创建Kotlin标头。</target>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlin允许您声明该属性而无需初始化它，并且您可以在构造后的某个时候（直接或通过函数）设置属性值。类本身及其用户都有责任注意在设置属性之前不要读取该属性，并且Kotlin允许您编写读取 &lt;code&gt;name&lt;/code&gt; 的代码，就像它是普通的，不可为空的属性一样。但是，编译器是无法强制执行正确的使用方法，因此，如果属性是读已设置之前，一个 &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; 将在运行时抛出。</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlin使用Spring Boot可以非常顺畅地工作，并且Kotlin可以完全遵循&lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring指南&lt;/a&gt;中创建RESTful服务的许多步骤。但是，在定义Gradle配置和项目布局结构以及初始化代码方面存在一些细微差异。</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlin使用不同的&lt;a href=&quot;build-tools&quot;&gt;构建工具&lt;/a&gt;，因此，如果我们使用的是Ant，Maven或Gradle之类的标准工具，则Kotlin项目的设置过程与与这些工具集成的任何其他语言或库没有什么不同。在使用JBS时，有一些小的要求和不同之处，这是IntelliJ IDEA使用的内部构建系统，TeamCity也支持该系统。</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlin处理异步代码的方法是使用coroutines,也就是可暂停计算的思想,即一个函数可以在某个时刻暂停执行,以后再恢复。</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlin的文档生成工具称为&lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;。有关用法说明，请参阅《&lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt;》。</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlin的文档语法称为&lt;em&gt;KDoc&lt;/em&gt;。 KDoc块放置在它描述的结构上方，并以 &lt;code&gt;/**&lt;/code&gt; 开头，并以 &lt;code&gt;*/&lt;/code&gt; 结束（可能在一行上；如果没有，则每个中间行应以对齐的星号开头）。文本的第一块是摘要。然后，您可以使用&lt;em&gt;块标记&lt;/em&gt;提供有关构造的特定部分的信息。某些块标记是 &lt;code&gt;@param&lt;/code&gt; (用于函数参数和泛型类型参数），以及 &lt;code&gt;@return&lt;/code&gt; (用于返回值）。您可以链接到方括号内的标识符。链接和块标记名称之外的所有文本均为Markdown格式。</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlin的泛型与Java的&lt;a href=&quot;generics&quot;&gt;泛型&lt;/a&gt;有些不同（请参阅Generics）。将Java类型导入Kotlin时，我们会执行一些转换：</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">Kotlin的循环类似于Python的循环。 &lt;code&gt;for&lt;/code&gt; 迭代任何&lt;em&gt;可迭代的&lt;/em&gt;事物（任何具有提供 &lt;code&gt;Iterator&lt;/code&gt; 对象的 &lt;code&gt;iterator()&lt;/code&gt; 函数的事物）或本身就是迭代器的事物：</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">Kotlin的对象模型与Python的对象模型有很大的不同。最重要的是，类&lt;em&gt;不能&lt;/em&gt;在运行时动态修改！ （有一些有限的例外，但你一般不应该这样做然而，。&lt;em&gt;是&lt;/em&gt;可以动态地&lt;em&gt;检查&lt;/em&gt;类和在运行时用一个功能叫做物体&lt;em&gt;反射&lt;/em&gt; -这可能是有用的，但应谨慎使用）所有必须直接在类主体中声明或作为&lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;扩展函数&lt;/em&gt;&lt;/a&gt;声明类中可能需要的属性（属性）和函数，因此您应该在类设计时仔细考虑。</target>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin的类型系统旨在消除代码中空引用的危险，也称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;&amp;ldquo;十亿美元的错误&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlin的类型系统旨在从我们的代码中消除 &lt;code&gt;NullPointerException&lt;/code&gt; 。NPE的唯一可能原因可能是：</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlin作为一种语言，在其标准库中仅提供最少的低级API，以使其他各种库都可以使用协程。与许多其他具有类似功能的语言不同， &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 不是Kotlin中的关键字，甚至都不是其标准库的一部分。此外，与期货和承诺相比，Kotlin的&lt;em&gt;暂停功能&lt;/em&gt;概念为异步操作提供了更安全，更不易出错的抽象。</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">与C＃和Gosu相似，Kotlin提供了使用新功能扩展类的功能，而不必继承该类或使用任何类型的设计模式（例如Decorator）。这通过称为&lt;em&gt;扩展的&lt;/em&gt;特殊声明来完成。Kotlin支持&lt;em&gt;扩展功能&lt;/em&gt;和&lt;em&gt;扩展属性&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin / Native &lt;a href=&quot;native/platform_libs&quot;&gt;库&lt;/a&gt;有助于在项目之间共享Kotlin代码。预先导入POSIX，gzip，OpenGL，Metal，Foundation和许多其他流行的库和Apple框架，并将它们作为Kotlin / Native库包含在编译器软件包中。</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Kotlin/Native Gradle插件</target>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">Kotlin/Native Runtime声明</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / Native还与Apple技术紧密集成。&lt;a href=&quot;apple-framework&quot;&gt;作为苹果框架&lt;/a&gt;的Kotlin / Native教程说明了如何将Kotlin代码编译为Swift和Objective-C的框架。</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native还与Objective-C和Swift紧密集成。&lt;a href=&quot;apple-framework&quot;&gt;作为苹果框架&lt;/a&gt;教程，在Kotlin / Native中进行了介绍。</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">作为动态库的Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">作为苹果框架的Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native可用于许多&lt;a href=&quot;basic-kotlin-native-app&quot;&gt;目标&lt;/a&gt;和应用程序，包括但不限于macOS，Windows，Linux和&lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native附带了 &lt;code&gt;cinterop&lt;/code&gt; 工具，该工具在C语言和Kotlin之间生成绑定。它使用 &lt;code&gt;.def&lt;/code&gt; 文件指定要导入的C库。&amp;ldquo; &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&amp;rdquo;&lt;/a&gt;教程中讨论了更多详细信息。</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native带有 &lt;code&gt;cinterop&lt;/code&gt; 工具。该工具在C语言和Kotlin之间生成绑定。它使用 &lt;code&gt;.def&lt;/code&gt; 文件指定要导入的C库。有关此问题的更多详细信息，请参见《&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries》&lt;/a&gt;教程。</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Native带有 &lt;code&gt;cinterop&lt;/code&gt; 工具。该工具在C语言和Kotlin之间生成绑定。它使用 &lt;code&gt;.def&lt;/code&gt; 文件指定要导入的C库。有关此问题的更多详细信息，请参见《&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries》&lt;/a&gt;教程。尝试C API映射的最快的方法是在所有的C声明 &lt;code&gt;interop.def&lt;/code&gt; 文件，而不会产生任何 &lt;code&gt;.h&lt;/code&gt; 的 &lt;code&gt;.c&lt;/code&gt; 的所有文件。然后将C声明放在特殊的 &lt;code&gt;---&lt;/code&gt; 分隔线之后的 &lt;code&gt;interop.def&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Kotlin / Native编译器可以从我们拥有的Kotlin代码中生成一个动态库。动态库通常带有一个头文件（ &lt;code&gt;.h&lt;/code&gt; 文件），我们将使用它从C调用编译后的代码。</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Kotlin/Native编译器可以用Kotlin代码生成一个适用于macOS和iOS的框架。所创建的框架包含了使用Objective-C和Swift所需的所有声明和二进制文件。理解这些技术的最好方法是自己尝试。让我们先创建一个小小的Kotlin库,并从一个Objective-C程序中使用它。</target>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">Kotlin/Native for Native</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Native具有与Objective-C和Swift语言的双向互操作。Kotlin对象与Objective-C / Swift参考计数集成在一起。未使用的Kotlin对象将自动删除。在&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C的互操作性&lt;/a&gt;文章包含有关互操作性的实施细则的更多信息。当然，可以导入现有框架并从Kotlin使用它。Kotlin / Native带有一整套预导入的系统框架。</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native具有垃圾回收，但是它不能帮助我们处理C语言中的Kotlin对象。Kotlin / Native与Objective-C和Swift互操作，并与它们的参考计数器集成。在&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C的互操作性&lt;/a&gt;文档文章包含有关它的更多细节。另外，还有教程&lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native作为Apple Framework&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Native执行严格的可变性检查，以确保重要的不变性，即该对象在该时刻是不变的或可以从单个线程访问（ &lt;code&gt;mutable XOR global&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">&lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;文档&lt;/a&gt;文章涵盖了与Swift和Objective-C的Kotlin / Native互操作。另外，&lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native作为Apple Framework&lt;/a&gt;教程涵盖了相同的主题。</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">Kotlin/Native互操作性</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Kotlin/Native与Swift/Objective-C的互操作性。</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Native是一种将Kotlin代码编译为本地二进制文件的技术，该二进制文件无需虚拟机即可运行。它是Kotlin编译器和Kotlin标准库的本机实现的基于&lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt;的后端。</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native目前正在开发&lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;中&lt;/a&gt;。它将Kotlin编译为无需VM即可运行的本机代码。已发布了技术预览版，但尚未投入生产，并且尚未针对我们计划支持1.0的所有平台。有关更多信息，请查看&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;发布Kotlin / Native&lt;/a&gt;的博客文章。</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Native的主要目的是允许对不需要或不可能使用&lt;em&gt;虚拟机的&lt;/em&gt;平台进行编译，例如嵌入式设备或iOS。它解决了开发人员需要生成不需要额外运行时或虚拟机的自包含程序的情况。</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">Kotlin/Native库</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin/Native库是包含预定义目录结构的zip文件,其布局如下。</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">科特林/本地插件需要摇篮的新版本，让我们在补丁 &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; 并使用以下 &lt;code&gt;distrubutionUrl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Native提供了与Objective-C / Swift的双向互操作性。可以在Kotlin代码中使用Objective-C框架和库。Kotlin模块也可以在Swift / Objective-C代码中使用。除此之外，Kotlin / Native具有&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;。还有&lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native作为动态库的&lt;/a&gt;教程，以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Native提供与Objective-C的双向互操作性。如果正确导入到构建中，则可以在Kotlin代码中使用Objective-C框架和库（默认情况下会导入系统框架）。请参阅例如&lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle插件文档中的&lt;/a&gt; &amp;ldquo;使用cinterop&amp;rdquo; 。如果Swift库的API已通过 &lt;code&gt;@objc&lt;/code&gt; 导出到Objective-C，则可以在Kotlin代码中使用它。尚不支持Pure Swift模块。</target>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Native为我们提供了使用标准C库的能力，从而开放了一个完整的功能生态系统，该功能生态系统几乎可以满足我们所需的所有需求。实际上，Kotlin / Native已经附带了一组预构建的&lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;平台库&lt;/a&gt;，这些库提供了标准库所提供的一些其他通用功能。</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin/Native运行时并不鼓励采用经典的面向线程的并发模型,该模型具有相互排斥的代码块和条件变量,因为这种模型众所周知容易出错且不可靠。相反,我们建议了一系列替代方法,允许你使用硬件并发并实现阻塞IO。这些方法如下,将在后面的章节中详细介绍。</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">Kotlin/本地资源和例子</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Kotlin/Native sources and examples (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Kotlin/Native sources and examples (.zip)</target>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / Native也支持C互操作。查看有关&lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native作为动态库的&lt;/a&gt;教程，或者查看&lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt;文档文章</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin/Native支持以下平台。</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin/Native支持与Native世界的双向互通。一方面,编译器创建。</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">Kotlin /本机目标预设（请参阅以下&lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;注释&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Kotlin / Native目标不需要其他测试依赖项，并且内置了 &lt;code&gt;kotlin.test&lt;/code&gt; API实现。</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Native 通过&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件使用&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;构建系统。我们将在下面查看如何配置Gradle构建。对于某些极端情况，仍然可以从&lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;GitHub上&lt;/a&gt;的Kotlin版本页面手动（不推荐）获得Kotlin / Native编译器。在本教程中，我们专注于使用Gradle构建。</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">KotlinConf Spinner应用</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">KotlinConf应用程序</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">Lambda表达式和匿名函数</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">Lambda表达式语法</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">Lambda表达式和匿名函数都是 &quot;函数字面&quot;,即没有声明,而是作为表达式立即传递的函数。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">Lambda表达式和匿名函数统称为&lt;em&gt;函数文字&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">当可以从上下文推断接收器类型时，Lambda表达式可用作接收器的函数文字。&lt;a href=&quot;type-safe-builders&quot;&gt;类型安全的构建器&lt;/a&gt;是最重要的用法之一：</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">兰姆达格式化</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">兰姆达参数</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">Lambda结果</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">语言设置</target>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">源集的语言设置会影响IDE中对源的分析。由于目前的限制,在Gradle构建中,只使用编译的默认源集的语言设置,并应用于所有参与编译的源。</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">后期初始化属性和变量</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Lateinit顶层属性和局部变量</target>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">懒惰地启动异步</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">懒惰财产</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">学习盆地</target>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">学习Kotlin</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">用EduTools插件学习Kotlin。</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">将其他选项保留为默认值，然后单击&amp;ldquo; &lt;strong&gt;完成&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">让我们有两个字符串生成器： &lt;code&gt;fizz&lt;/code&gt; 和 &lt;code&gt;buzz&lt;/code&gt; 。该 &lt;code&gt;fizz&lt;/code&gt; 产生的&amp;ldquo;嘶嘶声&amp;rdquo;串每300毫秒：</target>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">让我们启动一百个coroutine,所有的coroutine都做同样的动作一千次。我们还将测量它们的完成时间,以便进一步比较。</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">让我们将有关环境，孩子和工作的知识放在一起。假设我们的应用程序有一个具有生命周期的对象，但是该对象不是协程。例如，我们正在编写一个Android应用程序，并在Android活动的上下文中启动各种协程，以执行异步操作以获取和更新数据，制作动画等。在销毁活动时必须取消所有这些协程，以避免内存泄漏。当然，我们可以手动操作上下文和作业来绑定活动和协同程序的生命周期，但是 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 提供了一个抽象，该抽象封装了以下内容：&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;。您应该已经熟悉协程范围，因为所有协程构建器都声明为它的扩展。</target>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">让我们把它都跑七遍。</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">我们先来一打,随机延迟。</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">让我们以&lt;a href=&quot;#concurrent-using-async&quot;&gt;异步&lt;/a&gt;示例为例，并提取一个函数，该函数同时执行 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 和 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 并返回其结果的总和。由于&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;协&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;程生成&lt;/a&gt;器定义为在CoroutineScope上的扩展，因此我们需要将其包含在范围内，这就是&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;函数提供的功能：</target>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">让我们编写一个使用通道生成器的函数，该函数使用一个延迟字符串值的通道，等待每个接收到的延迟值，但仅等到下一个延迟值结束或关闭通道为止。此示例将&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt;和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt;子句放在同一 &lt;code&gt;select&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">让我们写一个整数生成器的例子，当主通道上的使用者无法跟上它的值时，它将其值发送到 &lt;code&gt;side&lt;/code&gt; 通道：</target>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">我们还要确保协程实际上是并行运行的。如果我们为每个 &lt;code&gt;async&lt;/code&gt; 添加一个1秒的 &lt;code&gt;delay()&lt;/code&gt; ，则生成的程序将不会运行1'000'000秒（超过11,5天）：</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">让我们假设上面的代码中 &lt;code&gt;preparePost&lt;/code&gt; 是一个长期运行的过程，因此将阻塞用户界面。我们可以做的是在一个单独的线程中启动它。然后，这将使我们避免UI阻塞。这是一种非常常见的技术，但是有一系列缺点：</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">让我们从Objective-C调用框架。为此，我们创建具有以下内容的 &lt;code&gt;main.m&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">让我们来看看我们Kotlin库的C API.`。</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">让我们单击&amp;ldquo; &lt;code&gt;App&lt;/code&gt; 运行&amp;rdquo;配置，以使我们的项目在真实的Android设备或仿真器上运行。</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">让我们单击Xcode中的&lt;em&gt;Run&lt;/em&gt;按钮，我们将看到我们的应用程序正在运行</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">让我们用以下内容创建一个 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 存根文件，以了解如何从Kotlin中看到C基本类型声明：</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">让我们创建一个 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 存根文件，其中包含以下内容，以了解如何从Kotlin中看到我们的C声明：</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">让我们再次创建一百万个协程，保留其 &lt;code&gt;Deferred&lt;/code&gt; 对象。现在不再需要原子计数器，因为我们可以返回要从协程中添加的数字：</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">让我们在 &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; 文件夹中创建 &lt;code&gt;Base64Test&lt;/code&gt; 类，并编写Base64的基本测试。</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">让我们用这样的方式来表示一个函数f(x):我们将1加到x上,然后,当所得数中至少有一个尾数为零时,我们去掉这个零。</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">让我们深入了解它的含义。协程的最大优点是它们可以&lt;em&gt;挂起&lt;/em&gt;而不会阻塞线程。编译器必须发出一些特殊的代码才能使其实现，因此我们必须标记&lt;em&gt;可能&lt;/em&gt;在代码中显式&lt;em&gt;挂起的&lt;/em&gt;函数。我们使用 &lt;code&gt;suspend&lt;/code&gt; 修饰符：</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">让我们将 &lt;code&gt;launch { ... }&lt;/code&gt; 的代码块提取到一个单独的函数中。在此代码上执行&amp;ldquo;提取函数&amp;rdquo;重构时，您将获得带有 &lt;code&gt;suspend&lt;/code&gt; 修饰符的新函数。那是您的第一个&lt;em&gt;暂停功能&lt;/em&gt;。暂停函数可以像常规函数一样在协程内部使用，但是它们的附加功能是它们可以依次使用其他暂停函数（如本例中的 &lt;code&gt;delay&lt;/code&gt; )来&lt;em&gt;暂停&lt;/em&gt;协程的执行。</target>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">首先让我们创建一个项目文件夹。本教程中的所有路径都是相对于这个文件夹的。有时,在添加新文件之前,必须先创建缺少的目录。</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">让我们直接讲一点，将其输入扩展名为 &lt;code&gt;.kt&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">让我们包括从 &lt;code&gt;SharedCode&lt;/code&gt; 项目到Android项目的依赖关系。我们需要修补 &lt;code&gt;app/build.gradle&lt;/code&gt; 文件，并将以下行添加到 &lt;code&gt;dependencies { .. }&lt;/code&gt; 块中：</target>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">让我们看一下在外部库&lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines中&lt;/a&gt;实现的 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">让我们看一个使用 &lt;code&gt;launch&lt;/code&gt; 的完整程序：</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">让我们来看看它,发现有什么变化。在Java中,你对字段进行了注释,将其与相应的视图进行了绑定。</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">让我们确保可以在iPhone模拟器或设备上运行应用程序。</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">让我们将源文件移动到项目下的 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 文件夹中。这是使用&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件时源所在的默认路径。我们使用以下块来指示配置项目以为我们生成动态或共享库：</target>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">让我们将源文件移动到项目下的 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 文件夹中。这是使用&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件时源所在位置的默认路径。我们使用以下块来指导和配置项目以为我们生成动态或共享库：</target>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">让我们用以下内容替换 &lt;code&gt;testSolution()&lt;/code&gt; 函数的内容：</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">我们多跑几趟吧</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">让我们运行 &lt;code&gt;linkNative&lt;/code&gt; Gradle任务以&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;在IDE中&lt;/a&gt;或通过调用以下控制台命令来构建库：</target>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">假设您正在编写一个简单的ORM。您的数据库库将一行表示为 &lt;code&gt;Entity&lt;/code&gt; 类的实例，并具有诸如 &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; 和 &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; 类的函数，用于从给定列中获取键入的值。我们可以创建一个类型化的包装类，如下所示：</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">假设我们需要从一个函数返回两件事。例如，结果对象和某种状态。在Kotlin中执行此操作的一种紧凑方法是声明一个&lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;数据类&lt;/em&gt;&lt;/a&gt;并返回其实例：</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">让我们看看如何将 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;object&lt;/code&gt; 映射到Objective-C和Swift。生成的 &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 文件包含有关 &lt;code&gt;Class&lt;/code&gt; ， &lt;code&gt;Interface&lt;/code&gt; 和 &lt;code&gt;Object&lt;/code&gt; 的确切定义：</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">让我们现在看 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 首先转向一个指针：</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">我们来总结一下表中的内容。</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">让我们切换回Android Studio，并从&lt;em&gt;Gradle&lt;/em&gt;工具窗口执行 &lt;code&gt;SharedCode&lt;/code&gt; 项目的 &lt;code&gt;build&lt;/code&gt; 目标。该任务将查找Xcode构建设置的环境变量，并将框架的正确变体复制到 &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; 文件夹中。然后，我们将该文件夹中的框架包含到构建中&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">我们先来看看Kotlin运行时的声明。</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">我们来看一个具体的例子。</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">让我们看一下 &lt;code&gt;kotlin.root.example&lt;/code&gt; 字段，它使用kotlin.root模拟我们的Kotlin代码的包结构 &lt;code&gt;kotlin.root.&lt;/code&gt; 字首。</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">让我们看一个示例，了解 &lt;code&gt;Iterable&lt;/code&gt; 和 &lt;code&gt;Sequence&lt;/code&gt; 之间的区别。</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">让我们看一下以 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 作为参数的生成函数。我们看到按值参数表示为 &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; 。对于类型化的指针参数，我们看到 &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 。Kotlin为我们提供了一个API，可以轻松处理这两种类型，让我们尝试一下。</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">让我们用一个使用coroutine流水线生成素数的例子,把流水线发挥到极致。我们从一个无限的数字序列开始。</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">让我们试试同样的coroutines。</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">让我们尝试使用Kotlin的API。让我们先调用 &lt;code&gt;pass_string&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">现在让我们更新Gradle脚本来实现,并配置我们的IDE。</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">让我们用它来与通道 &lt;code&gt;a&lt;/code&gt; 产生&amp;ldquo;你好&amp;rdquo;字符串四次，通道 &lt;code&gt;b&lt;/code&gt; 产生的&amp;ldquo;世界&amp;rdquo;四次：</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">让我们来看看这些接口和它们的实现。</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">让我们逐步了解一下在Kotlin中实现类型安全构建器的机制。首先，我们需要定义要构建的模型，在这种情况下，我们需要对HTML标签建模。通过一堆类很容易做到。例如， &lt;code&gt;HTML&lt;/code&gt; 是描述 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 标记的类，即，它定义了诸如 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 之类的子代。 （请参阅&lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;下面&lt;/a&gt;的声明。）</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">库作者可以使用 @Deprecated 和 @Experimental 注解来控制他们的 API 表面的演变。请注意,@Deprecated(level=HIDDEN)可以用来保持二进制的兼容性,即使是从API中删除的声明。</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">库代码应该始终明确指定公共/保护函数和属性的返回类型,从而永远不依赖公共API的类型推理。类型推理中的细微变化可能会导致返回类型在无意中改变,从而导致二进制兼容性问题。</target>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">图书馆搜索序列</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">对Kotlin注释设施的库支持。</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">根据Apache许可证,2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">像Java一样，Kotlin的泛型在运行时不会保留，即对象不携带传递给其构造函数的有关实际类型参数的信息，即 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; 与 &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; 是无法区分的。这使得无法进行&lt;em&gt;是&lt;/em&gt;该采取泛型考虑-checks。Kotlin仅允许&lt;em&gt;is&lt;/em&gt; -checks进行星型投影的泛型类型：</target>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">像Python中一样，Kotlin中的函数是一等值-它们可以分配给变量并作为参数传递。&lt;em&gt;函数的类型&lt;/em&gt;是&lt;em&gt;函数类型&lt;/em&gt;，用括号括起来的参数类型列表和返回类型的箭头指示。考虑以下功能：</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">像在Python中一样，语句可以用分号终止，但不建议使用。没有换行符；相反，如果这是使代码正确解析的唯一方法，则该行会自动与一个或多个后续行合并在一起。在实践中，这意味着如果我们在开放括号内（如在Python中），或者该行以&amp;ldquo;悬挂运算符&amp;rdquo;结尾（与Python不同），则语句在下一行继续执行解析，除非它与上一个连接（也不同于Python）。请注意，这几乎&lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;与JavaScript相反&lt;/a&gt;，后者通常会保持连接行，只要结果代码仍可解析。因此，以下是Kotlin和Python中的两个表达式（因为 &lt;code&gt;+&lt;/code&gt; 可以是一元的，因此第二行自行解析），但是在JavaScript中是：</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">像在Python中一样，您可以编写&lt;em&gt;lambda表达式&lt;/em&gt;：具有非常紧凑的语法的未命名函数声明，其结果可调用函数对象。在Kotlin中，lambda可以包含多个语句，这使得它们比Python的单表达式lambda &lt;a href=&quot;functional-programming#receivers&quot;&gt;更为&lt;/a&gt;有用。最后一条语句必须是一个表达式，其结果将成为lambda的返回值（除非 &lt;code&gt;Unit&lt;/code&gt; 是为lambda表达式指定的变量/参数的返回类型，在这种情况下，lambda没有返回值）。Lambda表达式用花​​括号括起来，并从列出其参数名称以及可能的类型开始（除非可以从上下文中推断类型）：</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">和数字一样,当需要可空引用时,字符会被装箱。框选操作不保留身份。</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">同样，如果以实验性&lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle元数据发布模式&lt;/a&gt;发布多平台库，并且该项目也设置为使用元数据，则对于公共源集仅指定一次依赖项就足够了。否则，除了公共模块外，每个平台特定的源集还应提供库的相应平台模块，如上所示。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">线性搜索</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">将库链接到应用程序中</target>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">链接到元素</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64,arm32,MIPS,MIPS little endian,Raspberry Pi)</target>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Linux MIPS目标（ &lt;code&gt;linuxMips32&lt;/code&gt; 和 &lt;code&gt;linuxMipsel32&lt;/code&gt; ）需要Linux主机。可以在任何受支持的主机上构建其他Linux目标。</target>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux： &lt;code&gt;libnative_api.h&lt;/code&gt; 和 &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">列出具体操作</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">列表元素（包括null）可以重复：列表可以包含任意数量的相等对象或单个对象的出现。如果两个列表的大小相同且元素在相同位置上的&lt;a href=&quot;equality#structural-equality&quot;&gt;结构相同，&lt;/a&gt;则认为两个列表相等。</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">列表迭代器</target>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">列表写操作</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">列表还提供了替换给定位置的元素的功能-set &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt;及其操作符形式 &lt;code&gt;[]&lt;/code&gt; 。 &lt;code&gt;set()&lt;/code&gt; 不会更改其他元素的索引。</target>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">列表和集合还提供用于更新元素的操作。它们在&amp;ldquo; &lt;a href=&quot;list-operations&quot;&gt;列表特定操作&amp;rdquo;&lt;/a&gt;和&amp;ldquo; &lt;a href=&quot;map-operations&quot;&gt;地图特定操作&amp;rdquo;中&lt;/a&gt;进行了描述。对于集合，更新是没有意义的，因为它实际上是在删除一个元素并添加另一个元素。</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">列表支持元素检索的所有常用操作： &lt;code&gt;elementAt()&lt;/code&gt; ， &lt;code&gt;first()&lt;/code&gt; ， &lt;code&gt;last()&lt;/code&gt; 以及&amp;ldquo; &lt;a href=&quot;collection-elements&quot;&gt;检索单个元素&amp;rdquo;中&lt;/a&gt;列出的其他操作。列表特有的是对元素的索引访问，因此读取元素的最简单方法是按索引检索它。这是通过使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;函数以及在参数或速记 &lt;code&gt;[index]&lt;/code&gt; 语法中传递的索引来完成的。</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">字面常数</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">本地委派属性(从1.1开始)。</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">本地功能</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">本地注释类</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">当地声明</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">本地委托属性</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">局部函数可以访问外部函数（即闭包）的局部变量，因此在上述情况下，被&lt;em&gt;访问对象&lt;/em&gt;可以是局部变量：</target>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">本地变量</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">局部变量通常是在同一时间声明和初始化的，在这种情况下，可以将变量的类型&lt;em&gt;推断&lt;/em&gt;为您使用其初始化的表达式的类型：</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">局部变量、函数和类不能有可见性修饰符。</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">锁用于确保只有一个线程可以初始化&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">对数： &lt;code&gt;log&lt;/code&gt; ， &lt;code&gt;log2&lt;/code&gt; ， &lt;code&gt;log10&lt;/code&gt; ， &lt;code&gt;ln&lt;/code&gt; ， &lt;code&gt;ln1p&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">徽标可以在&lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;此处&lt;/a&gt;下载。使用徽标时，请遵循存档中的 &lt;code&gt;guidelines.pdf&lt;/code&gt; 和&lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin品牌使用指南&lt;/a&gt;中的简单规则。</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">龙目岛（ &lt;code&gt;lombok.NonNull&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">多头以大写 &lt;code&gt;L&lt;/code&gt; 标记： &lt;code&gt;123L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">寻找更多API？创建一个&lt;a href=&quot;../multiplatform-library&quot;&gt;多平台库&lt;/a&gt;并共享它很容易！</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">查找具有 &lt;code&gt;operator&lt;/code&gt; 修饰符且没有参数的函数 &lt;code&gt;inc()&lt;/code&gt; ，适用于 &lt;code&gt;T&lt;/code&gt; 类型的接收器；</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">&lt;code&gt;unaryPlus()&lt;/code&gt; 带有 &lt;code&gt;operator&lt;/code&gt; 修饰符且没有用于接收方 &lt;code&gt;T&lt;/code&gt; 的参数的函数unaryPlus（），即成员函数或扩展函数；</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">循环的范围</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">提供基于coroutine的API的库的低级构件。</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">幸运的是，Kotlin得到了改进的&lt;em&gt;类型参数&lt;/em&gt;，从而减轻了其中的一些问题。通过在通用类型参数前面编写 &lt;code&gt;reified&lt;/code&gt; ，它在运行时确实可以使用，您将可以编写 &lt;code&gt;T::class&lt;/code&gt; 来获取&lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;类元数据&lt;/a&gt;。你只能做到这一点的内联函数（因为inline函数会被编译成它的调用点，其中类型信息&lt;em&gt;是&lt;/em&gt;可以在运行时），但它仍然很长的路要走。例如，您可以为具有不太雅致的签名的大型函数制作一个内联包装函数。</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">MacOS (x86_64)</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">确保其返回类型为 &lt;code&gt;Unit&lt;/code&gt; ，否则报告错误，</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">确保已&lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;安装&lt;/a&gt; CocoaPods 。我们建议使用CocoaPods 1.6.1或更高版本。</target>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">确保首先加载 &lt;code&gt;kotlin.js&lt;/code&gt; 运行时，然后加载您的应用程序。</target>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">让用户舒适地更新到新版本。</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">使得Objective-C类中的Kotlin方法可以通过Objective-C dispatch访问,作为UIKit或AppKit中的控件发送的动作使用。</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">使得Objective-C类中的Kotlin属性可以通过Objective-C dispatch来设置,作为IB出口使用。</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">在调用Kotlin &lt;code&gt;main&lt;/code&gt; 函数后，使Objective-C类的Kotlin子类可见，以便在运行时查找。</target>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">使得C/C++代码中给定名称的顶级函数可用。</target>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">使计算代码可以取消</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">频繁地进行null检查是很烦人的,所以如果你必须允许null的可能性,Kotlin中有几个非常有用的操作符来方便处理可能是null的值,如下所述。</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">格式不正确的字节序列由替换char &lt;code&gt;\uFFFD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">管理依赖性</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">管理来源</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">管理目标</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">手动配置</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">手动安装</target>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">许多现代IDE都支持Kotlin,并帮助编写习惯性的Kotlin代码。</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">许多选项也可以通过属性进行配置。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">地图具体操作</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">如果不是空值,则映射空值</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">地图写入操作</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap()和Map.toMutableMap()</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">映射类型</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">从C语言映射函数指针类型</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">从C语言映射函数指针</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">从C语言映射原始数据类型</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">从C语言映射字符串</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">映射结构和联盟C类型</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">从C语言映射结构和联合类型</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">标记接口，指示&lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;实现支持快速索引访问。</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">标记接口，指示&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;实现支持快速索引访问。</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">标记API元素</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">标记实验性API</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">标记规则:如果一个隐含的接收器被认为是用@Ann标记的,如果</target>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">将一个带有支持字段的顶层变量或对象标记为不可更改。可以在多个线程之间共享这样的对象,但它会被深度冻结,所以不能改变它的状态或它所引用的对象的状态。</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">将一个带有支持字段的顶层变量或对象标记为线程本地。该对象仍然是可变的,并且可以改变它的状态,但是每个线程都有一个不同的对象副本,所以一个线程的变化不会反映在另一个线程中。</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">标志着一个预期的注解类,它不需要在所有的平台上都有实际的对应物。</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">标记拦截协程连续的协程上下文元素。协程框架使用&lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;来检索拦截器，并使用&lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;调用来拦截所有协程连续。</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">标记拦截协程连续的协程上下文元素。协程框架使用&lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;来检索拦截器，并使用&lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;调用来拦截所有协程连续。</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">标记拦截协程连续的协程上下文元素。协程框架使用&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;来检索拦截器，并使用&lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;调用来拦截所有协程连续。</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">标记拦截协程连续的协程上下文元素。协程框架使用&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt;来检索拦截器，并使用&lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt;调用来拦截所有协程连续。</target>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">标志着依赖于实验性无符号类型的API,包括这些类型本身。</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">将带注释的属性的JVM支持字段标记为 &lt;code&gt;transient&lt;/code&gt; ，这意味着它不是对象的默认序列化形式的一部分。</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">将带注释的属性的JVM支持字段标记为 &lt;code&gt;volatile&lt;/code&gt; ，这意味着对该字段的写入将立即变为对其他线程可见。</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">将从带注释的函数生成的JVM方法标记为 &lt;code&gt;strictfp&lt;/code&gt; ，这意味着需要限制在该方法内部执行的浮点操作的精度，以实现更好的可移植性。</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">将从带注释的函数生成的JVM方法标记为 &lt;code&gt;synchronized&lt;/code&gt; ，这意味着将通过定义该方法的实例（对于静态方法，为类）的监视器来防止该方法被多个线程并发执行。</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">将注释的声明标记为废弃的。</target>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">kotlin-stdlib中的数学运算</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">数学函数和常数。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
