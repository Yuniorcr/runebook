<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="31c3d88842fee1685ad0d679c0db8a0fc174ec11" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of experimental features by passing the argument &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; to &lt;code&gt;kotlinc&lt;/code&gt;.</source>
          <target state="translated">要消除警告，您必须通过将参数 &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; 传递给 &lt;code&gt;kotlinc&lt;/code&gt; 来选择使用实验性功能。</target>
        </trans-unit>
        <trans-unit id="0e630e1d578ed6510bfa59a81e36360f93345c8c" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of this feature by passing the compiler argument &lt;code&gt;-Xinline-classes&lt;/code&gt;.</source>
          <target state="translated">要消除警告，您必须通过传递编译器参数 &lt;code&gt;-Xinline-classes&lt;/code&gt; 来选择使用此功能。</target>
        </trans-unit>
        <trans-unit id="28a952e26ac563cedfa7c9f543249e0cc2d66483" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xopt-in=kotlin.RequiresOptIn&lt;/code&gt;.</source>
          <target state="translated">要删除警告，请添加编译器参数 &lt;code&gt;-Xopt-in=kotlin.RequiresOptIn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3f08203a0ddf6e6bc4f31d19032cdb3e04aee85" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">要删除警告，请添加编译器参数 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d469d435bb3a113c1dd1088e7025b64a6a0198e5" translate="yes" xml:space="preserve">
          <source>To represent body of an external function. In most cases Kotlin does not require to provide bodies of external functions and properties, but if for some reason you want to (for example, due to limitation of your coding style guides), you should use &lt;code&gt;definedExternally&lt;/code&gt;.</source>
          <target state="translated">表示外部功能的主体。在大多数情况下，Kotlin不需要提供外部函数和属性的主体，但是如果出于某些原因（例如，由于编码样式指南的限制），则应使用 &lt;code&gt;definedExternally&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ce750db4ac36bdd72cdcddab7ef744528c90ce" translate="yes" xml:space="preserve">
          <source>To represent value of default argument.</source>
          <target state="translated">表示默认参数的值。</target>
        </trans-unit>
        <trans-unit id="14a14bea6684b1e554722af225128be0f57d25cd" translate="yes" xml:space="preserve">
          <source>To require an opt-in to using an API element, annotate its declaration with an opt-in requirement annotation:</source>
          <target state="translated">要要求在使用API元素时选择加入,请用opt-in requirement注解它的声明。</target>
        </trans-unit>
        <trans-unit id="54a0a9d97090503eaabc29843393d48b0c0faafe" translate="yes" xml:space="preserve">
          <source>To resolve ambiguities in exports (like overloads for functions with the same name), you can use the &lt;code&gt;@JsExport&lt;/code&gt; annotation together with &lt;code&gt;@JsName&lt;/code&gt; to specify the names for the generated and exported functions.</source>
          <target state="translated">要解决导出中的歧义（例如，具有相同名称的函数的重载），可以将 &lt;code&gt;@JsExport&lt;/code&gt; 批注与 &lt;code&gt;@JsName&lt;/code&gt; 一起使用，以指定生成和导出函数的名称。</target>
        </trans-unit>
        <trans-unit id="69457a99de832ac1adcb88dba9125bcc6ced4562" translate="yes" xml:space="preserve">
          <source>To retrieve the Java class of an object, use the &lt;code&gt;java&lt;/code&gt; extension property on a &lt;a href=&quot;reflection#class-references&quot;&gt;class reference&lt;/a&gt;:</source>
          <target state="translated">要检索对象的Java类，请在&lt;a href=&quot;reflection#class-references&quot;&gt;类引用&lt;/a&gt;上使用 &lt;code&gt;java&lt;/code&gt; 扩展属性：</target>
        </trans-unit>
        <trans-unit id="e9630cc244843d39b109cb4a4e7a2a47687f686a" translate="yes" xml:space="preserve">
          <source>To return a floating-point type, explicitly convert one of the arguments to a floating-point type.</source>
          <target state="translated">要返回浮点类型,请将其中一个参数显式转换为浮点类型。</target>
        </trans-unit>
        <trans-unit id="cab4ab009a9095119ec865716a0422fa20f520ff" translate="yes" xml:space="preserve">
          <source>To return to the pre-1.2 behavior, pass the flag &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; to the compiler.</source>
          <target state="translated">若要返回1.2之前的行为，请将标志 &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; 传递给编译器。</target>
        </trans-unit>
        <trans-unit id="5e0d2974dcfaa7063fb542a18d0b57f9a9db0a83" translate="yes" xml:space="preserve">
          <source>To run REPL in IntelliJ IDEA, open &lt;strong&gt;Tools | Kotlin | Kotlin REPL&lt;/strong&gt;.</source>
          <target state="translated">要在IntelliJ IDEA中运行REPL，请打开&amp;ldquo; &lt;strong&gt;工具&amp;rdquo; |&amp;ldquo;工具&amp;rdquo;。科特林| Kotlin REPL&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c80c0585cded44d08003b71c290d1079d4069543" translate="yes" xml:space="preserve">
          <source>To run REPL in the OS command line, open &lt;strong&gt;/bin/kotlinc-jvm&lt;/strong&gt; from the directory of standalone Kotlin compiler.</source>
          <target state="translated">要在OS命令行中运行REPL，请从独立Kotlin编译器的目录中打开&lt;strong&gt;/ bin / kotlinc-jvm&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3cc3c110a513b90b220f8954bf1227697a6710b3" translate="yes" xml:space="preserve">
          <source>To run a project, execute the standard lifecycle &lt;code&gt;run&lt;/code&gt; task, or the alias to which it corresponds:</source>
          <target state="translated">要运行项目，请执行标准的生命周期 &lt;code&gt;run&lt;/code&gt; 任务或其对应的别名：</target>
        </trans-unit>
        <trans-unit id="7fd27594c6ae21992652c27028d51d29604dfae3" translate="yes" xml:space="preserve">
          <source>To run a script, we just pass the &lt;code&gt;-script&lt;/code&gt; option to the compiler with the corresponding script file.</source>
          <target state="translated">要运行脚本，我们只需将 &lt;code&gt;-script&lt;/code&gt; 选项和相应的脚本文件传递给编译器。</target>
        </trans-unit>
        <trans-unit id="e2cae558670745cc7ac9e88ece3ef0ebf63a7483" translate="yes" xml:space="preserve">
          <source>To run kapt with compile avoidance:</source>
          <target state="translated">运行kapt时要避免编译。</target>
        </trans-unit>
        <trans-unit id="7bfb5403dc626e7b616c00072ab7971dc81d2cec" translate="yes" xml:space="preserve">
          <source>To run tests for a particular target suitable for testing, run a test task &lt;code&gt;&amp;lt;targetName&amp;gt;Test&lt;/code&gt;.</source>
          <target state="translated">要针对适合于测试的特定目标运行测试，请运行测试任务 &lt;code&gt;&amp;lt;targetName&amp;gt;Test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65dc2975423668b7d149d3345dc1e61eeea66998" translate="yes" xml:space="preserve">
          <source>To run tests for all targets, run the &lt;code&gt;check&lt;/code&gt; task.</source>
          <target state="translated">要对所有目标运行测试，请运行 &lt;code&gt;check&lt;/code&gt; 任务。</target>
        </trans-unit>
        <trans-unit id="2e3cf95b689244eb673190f3f6791a8430eef505" translate="yes" xml:space="preserve">
          <source>To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">要运行测试，请执行标准的生命周期 &lt;code&gt;check&lt;/code&gt; 任务：</target>
        </trans-unit>
        <trans-unit id="58d7a0df7bd3a304f110999cd04f5328dff8bc19" translate="yes" xml:space="preserve">
          <source>To run the application, right-click somewhere in the main file and select &lt;strong&gt;Run As | Kotlin Application&lt;/strong&gt;.</source>
          <target state="translated">要运行该应用程序，请右键单击主文件中的某个位置，然后选择&lt;strong&gt;&amp;ldquo;运行方式| Kotlin应用程序&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="307aa135f670640b026c3a84d1ad04d1025f9beb" translate="yes" xml:space="preserve">
          <source>To run the tests in the browser, we can execute the &lt;code&gt;browserTest&lt;/code&gt; task via IntelliJ IDEA, or use the gutter icons to execute all or individual tests:</source>
          <target state="translated">要在浏览器中运行测试，我们可以通过IntelliJ IDEA执行 &lt;code&gt;browserTest&lt;/code&gt; 任务，或使用装订线图标来执行所有或单个测试：</target>
        </trans-unit>
        <trans-unit id="2e4d15311fa7cd994c8e9ce22c145ce856d694db" translate="yes" xml:space="preserve">
          <source>To save your course as a zip file, go to &lt;strong&gt;Course Creator -&amp;gt; Generate Course Archive&lt;/strong&gt; action. The generated archive can be opened via the &lt;strong&gt;Browse Courses&lt;/strong&gt; available from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; and in the &lt;strong&gt;File Menu&lt;/strong&gt; with the &lt;strong&gt;Import Course&lt;/strong&gt; icon:</source>
          <target state="translated">要将课程另存为zip文件，请转到&amp;ldquo; &lt;strong&gt;课程创建者&amp;rdquo;-&amp;gt;&amp;ldquo;生成课程存档&amp;rdquo;&lt;/strong&gt;操作。可以通过&lt;strong&gt;欢迎屏幕中&lt;/strong&gt;可用的&lt;strong&gt;浏览课程&lt;/strong&gt;以及带有&lt;strong&gt;导入课程&lt;/strong&gt;图标的&lt;strong&gt;文件菜单&lt;/strong&gt;打开生成的档案：&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36a621d8894a43c60f62b88c51e7aa345450af8d" translate="yes" xml:space="preserve">
          <source>To search an element in a sorted list, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt;&lt;code&gt;binarySearch()&lt;/code&gt;&lt;/a&gt; function passing the value as an argument. If such an element exists, the function returns its index; otherwise, it returns &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; where &lt;code&gt;insertionPoint&lt;/code&gt; is the index where this element should be inserted so that the list remains sorted. If there is more than one element with the given value, the search can return any of their indices.</source>
          <target state="translated">要搜索排序列表中的元素，请调用将该值作为参数传递的&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt; &lt;code&gt;binarySearch()&lt;/code&gt; &lt;/a&gt;函数。如果存在这样的元素，则函数返回其索引；否则，它返回 &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; 其中 &lt;code&gt;insertionPoint&lt;/code&gt; 就是这个元素应当被插入，使得列表保持排序的索引。如果有多个具有给定值的元素，则搜索可以返回其任何索引。</target>
        </trans-unit>
        <trans-unit id="bf705e6bade184c44c4ccccae5cda8a8acf3a41e" translate="yes" xml:space="preserve">
          <source>To see how we can express how elements in the DOM can be created and structured in a concise way, check out the the &lt;a href=&quot;typesafe-html-dsl&quot;&gt;Typesafe HTML DSL&lt;/a&gt;.</source>
          <target state="translated">要查看我们如何表达如何以简洁的方式创建和构造DOM中的元素，请查看&lt;a href=&quot;typesafe-html-dsl&quot;&gt;Typesafe HTML DSL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="680ca05ae718e68cfb1629f08e49b399fcda4d93" translate="yes" xml:space="preserve">
          <source>To see the full Gradle script check out the source of the project on GitHub.</source>
          <target state="translated">要查看完整的Gradle脚本,请查看GitHub上的项目源代码。</target>
        </trans-unit>
        <trans-unit id="6bc22d1c45afda0ba0e9856d43874792a674530d" translate="yes" xml:space="preserve">
          <source>To select module kind, set the &lt;code&gt;moduleKind&lt;/code&gt; compiler option in the Gradle build script.</source>
          <target state="translated">要选择模块种类，请在Gradle构建脚本中设置 &lt;code&gt;moduleKind&lt;/code&gt; 编译器选项。</target>
        </trans-unit>
        <trans-unit id="06d76d8df652a0954c4314eb6cd119fb4f22f648" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Gradle, you should set &lt;code&gt;moduleKind&lt;/code&gt; property, i.e.</source>
          <target state="translated">要在通过Gradle进行编译时选择模块系统，应设置 &lt;code&gt;moduleKind&lt;/code&gt; 属性，即</target>
        </trans-unit>
        <trans-unit id="16681c84550456d5ff8bc73b03434df79d115f43" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Maven, you should set &lt;code&gt;moduleKind&lt;/code&gt; configuration property, i.e. your &lt;code&gt;pom.xml&lt;/code&gt; should look like this:</source>
          <target state="translated">要在通过Maven进行编译时选择模块系统，应设置 &lt;code&gt;moduleKind&lt;/code&gt; 配置属性，即 &lt;code&gt;pom.xml&lt;/code&gt; 应如下所示：</target>
        </trans-unit>
        <trans-unit id="45e994b1f4d37b99eaddc699cd613274dee03180" translate="yes" xml:space="preserve">
          <source>To set another location for project distribution files, add the &lt;code&gt;distribution&lt;/code&gt; block inside &lt;code&gt;browser&lt;/code&gt; in the build script and assign a value to the &lt;code&gt;directory&lt;/code&gt; property. Once you run a project build task, Gradle will save the output bundle in this location together with project resources.</source>
          <target state="translated">要为项目分发文件设置另一个位置，请在构建脚本中的 &lt;code&gt;browser&lt;/code&gt; 内部添加 &lt;code&gt;distribution&lt;/code&gt; 块，然后为 &lt;code&gt;directory&lt;/code&gt; 属性分配一个值。运行项目构建任务后，Gradle会将输出包和项目资源一起保存在此位置。</target>
        </trans-unit>
        <trans-unit id="269c5e540e50596c2266b2737868df5485939c07" translate="yes" xml:space="preserve">
          <source>To set the desired level, specify the &lt;code&gt;level&lt;/code&gt; parameter of the &lt;code&gt;@RequiresOptIn&lt;/code&gt; annotation.</source>
          <target state="translated">要设置所需的级别，请指定 &lt;code&gt;@RequiresOptIn&lt;/code&gt; 批注的 &lt;code&gt;level&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="5dfb90c4357595726b2e826922df2d26c2c78269" translate="yes" xml:space="preserve">
          <source>To setup a multiplatform project from scratch in a Gradle project, first apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to the project by adding the following to the beginning of the &lt;code&gt;build.gradle&lt;/code&gt; file:</source>
          <target state="translated">要从零开始在Gradle项目中设置多平台项目，请首先在 &lt;code&gt;build.gradle&lt;/code&gt; 文件的开头添加以下内容，将 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件应用于该项目：</target>
        </trans-unit>
        <trans-unit id="c7e47d17458659905c4f2f62bdab7488ae50c7a1" translate="yes" xml:space="preserve">
          <source>To skip automatic conversion and ensure raw pointers are used in the bindings, a &lt;code&gt;noStringConversion&lt;/code&gt; statement in the &lt;code&gt;.def&lt;/code&gt; file could be used, i.e.</source>
          <target state="translated">要跳过自动转换并确保在绑定中使用原始指针，可以使用 &lt;code&gt;.def&lt;/code&gt; 文件中的 &lt;code&gt;noStringConversion&lt;/code&gt; 语句，即</target>
        </trans-unit>
        <trans-unit id="db6bb94ddd68466610ca12cc204d3d3c6bd7dd12" translate="yes" xml:space="preserve">
          <source>To solve such issues, Kotlin introduces a special kind of class called an &lt;code&gt;inline class&lt;/code&gt;, which is declared by placing an &lt;code&gt;inline&lt;/code&gt; modifier before the name of the class:</source>
          <target state="translated">为了解决这些问题，Kotlin引入了一种特殊的类，称为 &lt;code&gt;inline class&lt;/code&gt; ，该类通过在类名之前放置一个 &lt;code&gt;inline&lt;/code&gt; 修饰符来声明：</target>
        </trans-unit>
        <trans-unit id="885ff03b6c597841318a22240c06f643cf1cd5fb" translate="yes" xml:space="preserve">
          <source>To solve this, mark the targets on both the library author and consumer sides with a custom attribute, which Gradle uses during dependency resolution.</source>
          <target state="translated">为了解决这个问题,在库作者端和消费者端都用自定义属性标记目标,Gradle在依赖解析时使用这个属性。</target>
        </trans-unit>
        <trans-unit id="c6edca763e12c6292a414b20b65eaba5f53f467b" translate="yes" xml:space="preserve">
          <source>To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an explicit &lt;em&gt;constructor&lt;/em&gt; keyword):</source>
          <target state="translated">要指定类的主要构造函数的可见性，请使用以下语法（请注意，您需要添加一个显式的&lt;em&gt;构造函数&lt;/em&gt;关键字）：</target>
        </trans-unit>
        <trans-unit id="419bcc45449c9e2a7d1fb4c22599e33f123b758a" translate="yes" xml:space="preserve">
          <source>To specify additional compilation options, use the &lt;code&gt;kotlinOptions&lt;/code&gt; property of a Kotlin compilation task.</source>
          <target state="translated">要指定其他编译选项，请使用Kotlin编译任务的 &lt;code&gt;kotlinOptions&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="0ac203e68342bc2b26ca6bd486204285a11e36be" translate="yes" xml:space="preserve">
          <source>To specify that a function type is &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;nullable&lt;/a&gt;, use parentheses: &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt;.</source>
          <target state="translated">要指定函数类型为&lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;可&lt;/a&gt;为空，请使用括号： &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa582abf300c214133b85270789a22565f82393f" translate="yes" xml:space="preserve">
          <source>To start coroutine debugging, you just need to set breakpoints and run the application in debug mode.</source>
          <target state="translated">要开始coroutine调试,你只需要设置断点并在调试模式下运行应用程序。</target>
        </trans-unit>
        <trans-unit id="e57f72b9d262e6ee5d6ce2e784cc4119575a7e41" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;当协程与结果或异常结束连续被调用。随后在结果延续上调用任何resume函数将产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29211ac1a181cd4bb3901bb410d7de3d38f88156" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;当协程与结果或异常结束连续被调用。随后在结果延续上调用任何resume函数将产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93a4c159e45ae9b13567d12cfe549a89c643e81c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;完成&lt;/a&gt;当协程与结果或异常结束连续被调用。随后在结果延续上调用任何resume函数将产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03689575e5ce0d05cb5875c63b25386ef2dc70ce" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;完成&lt;/a&gt;当协程与结果或异常结束连续被调用。随后在结果延续上调用任何resume函数将产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b715c677cb96aa31e520707c8bf7a084527dde6c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。在结果延续上重复调用任何恢复函数都会产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ae9d4ba7899cbe4180b0d690d30390847f2291f" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">要开始执行创建的协程，请在返回的&lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt;实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。在结果延续上重复调用任何恢复函数都会产生&lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfc6df82451691b1971099e0817380884cac3aec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="e102b42121057a6878b15b2e0b7a9abdd7059c88" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="a74d51560d5c774d1a56f8d84a208e43206f3604" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="aa80d28b000c404e7e7471739dc834ced4e443ec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="107268b53cdccea4df633455aa08e9eb59213796" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="15c18083bec73d38fe935b18a61bfb26719f41fa" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">要开始执行创建的协程，请在返回的Continuation实例上调用 &lt;code&gt;resume(Unit)&lt;/code&gt; 。在&lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;完成&lt;/a&gt;时，协程与结果或异常结束连续被调用。</target>
        </trans-unit>
        <trans-unit id="e2482fe90c75c3748aeac1be942111f81e932b33" translate="yes" xml:space="preserve">
          <source>To start the course, go to &lt;strong&gt;View -&amp;gt; Tool Windows -&amp;gt; Project&lt;/strong&gt;. You will find a course plan, the list of lessons. Every lesson has a set of tasks and code exercises you need to solve. Start with the very first one:</source>
          <target state="translated">要开始该课程，请转到&lt;strong&gt;查看-&amp;gt;工具窗口-&amp;gt;项目&lt;/strong&gt;。您会找到一个课程计划，课程列表。每节课都有您需要解决的一组任务和代码练习。从第一个开始：</target>
        </trans-unit>
        <trans-unit id="af4a3359bcc2d8aaecee721a7eaa5358429907bb" translate="yes" xml:space="preserve">
          <source>To start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;js-project-setup&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;, or pick a hands-on lab from the next section to work through.</source>
          <target state="translated">要开始将Kotlin用于JavaScript，请参阅&amp;ldquo;&lt;a href=&quot;js-project-setup&quot;&gt;设置Kotlin / JS项目&amp;rdquo;&lt;/a&gt;，或从下一部分中选择动手实验进行操作。</target>
        </trans-unit>
        <trans-unit id="5f3ceec14c1433cf322f7865c09a18312ccb1945" translate="yes" xml:space="preserve">
          <source>To start with, we'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</source>
          <target state="translated">首先,我们需要安装一个支持x64_64目标的Microsoft Visual C++编译器。最简单的方法是在Windows机器上安装一个Microsoft Visual Studio的版本。</target>
        </trans-unit>
        <trans-unit id="66185b084e5432ac45a03abd883161f880e5f11e" translate="yes" xml:space="preserve">
          <source>To switch to the old behavior, pass the fallback flag &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; to the compiler.</source>
          <target state="translated">要切换到旧的行为，请将后备标志 &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; 传递给编译器。</target>
        </trans-unit>
        <trans-unit id="cc3b8fe9e3a75acdfca2d542f5fc3f0b9c8e0c32" translate="yes" xml:space="preserve">
          <source>To switch to the old smart casts behavior, pass the fallback flag &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; as the compiler argument. It will become deprecated in Kotlin 1.3.</source>
          <target state="translated">要切换到旧的智能强制转换行为，请将后备标志 &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; 作为编译器参数传递。它会在Kotlin 1.3中弃用。</target>
        </trans-unit>
        <trans-unit id="526447430819405af6d133c6984847835417ebe8" translate="yes" xml:space="preserve">
          <source>To symbolicate addresses in Kotlin code (e.g. for stack trace elements corresponding to Kotlin code) &lt;code&gt;.dSYM&lt;/code&gt; bundle for Kotlin code is required.</source>
          <target state="translated">为了用Kotlin代码符号化地址（例如，用于与Kotlin代码相对应的堆栈跟踪元素），需要Kotlin代码的 &lt;code&gt;.dSYM&lt;/code&gt; 软件包。</target>
        </trans-unit>
        <trans-unit id="3ee56f12e381a099c59880a6823066a60e9d50df" translate="yes" xml:space="preserve">
          <source>To take all the elements except a given number of first or last elements, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt;&lt;code&gt;drop()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt;&lt;code&gt;dropLast()&lt;/code&gt;&lt;/a&gt; functions respectively.</source>
          <target state="translated">要获取除给定数量的第一个或最后一个元素以外的所有元素，请分别调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt; &lt;code&gt;drop()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt; &lt;code&gt;dropLast()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="27b36af5861b299fc805f783568e62a3fc319e12" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin.</source>
          <target state="translated">要针对JVM,应用Kotlin JVM插件。</target>
        </trans-unit>
        <trans-unit id="ca844ba87cff8c023079c9be62782b3a3fde8a97" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin. Starting with Kotlin 1.1.1, the plugin can be applied using the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;:</source>
          <target state="translated">要定位JVM，请应用Kotlin JVM插件。从Kotlin 1.1.1开始，可以使用&lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle插件DSL&lt;/a&gt;应用该插件：</target>
        </trans-unit>
        <trans-unit id="089288f0ea4e442474ea533e687f95ceb53b919e" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided by the developer, and therefore does not try to generate any JavaScript code from the declaration. This means that you should omit bodies of &lt;code&gt;external&lt;/code&gt; declarations. For example:</source>
          <target state="translated">要告诉Kotlin某个声明是用纯JavaScript编写的，您应该使用 &lt;code&gt;external&lt;/code&gt; 修饰符对其进行标记。当编译器看到这样的声明时，它假定开发人员提供了相应类，函数或属性的实现，因此不会尝试从该声明生成任何JavaScript代码。这意味着您应该省略 &lt;code&gt;external&lt;/code&gt; 声明的主体。例如：</target>
        </trans-unit>
        <trans-unit id="c054ec329a7a56272832fde51ee7e82f8f4336b8" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with the &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided externally (by the developer or via an &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm dependency&lt;/a&gt;), and therefore does not try to generate any JavaScript code from the declaration. This is also why &lt;code&gt;external&lt;/code&gt; declarations can't have a body. For example:</source>
          <target state="translated">要告诉Kotlin某个声明是用纯JavaScript编写的，您应该使用 &lt;code&gt;external&lt;/code&gt; 修饰符对其进行标记。当编译器看到这样的声明时，它假定相应类，函数或属性的实现是在外部提供的（由开发人员或通过&lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm依赖项提供&lt;/a&gt;），因此不会尝试从该声明生成任何JavaScript代码。这也是为什么 &lt;code&gt;external&lt;/code&gt; 声明不能具有主体的原因。例如：</target>
        </trans-unit>
        <trans-unit id="13b684242eb1261a088744c1edd0d98430ef5246" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that an &lt;code&gt;external&lt;/code&gt; class, package, function or property is a JavaScript module, you can use &lt;code&gt;@JsModule&lt;/code&gt; annotation. Consider you have the following CommonJS module called &quot;hello&quot;:</source>
          <target state="translated">要告诉Kotlin &lt;code&gt;external&lt;/code&gt; 类，包，函数或属性是JavaScript模块，可以使用 &lt;code&gt;@JsModule&lt;/code&gt; 批注。考虑您具有以下称为&amp;ldquo; hello&amp;rdquo;的CommonJS模块：</target>
        </trans-unit>
        <trans-unit id="9709dd3d7713138256dbb958ab241135af68f988" translate="yes" xml:space="preserve">
          <source>To test it, we'll use a simple async function that resolves to a specified string after a specified time:</source>
          <target state="translated">为了测试它,我们将使用一个简单的异步函数,在指定时间后解析到一个指定的字符串。</target>
        </trans-unit>
        <trans-unit id="1b99a15ae02c59db4c41dbf465be5149eb5f7541" translate="yes" xml:space="preserve">
          <source>To throw an exception object, use the &lt;em&gt;throw&lt;/em&gt;-expression:</source>
          <target state="translated">要抛出异常对象，请使用&lt;em&gt;throw&lt;/em&gt; -expression：</target>
        </trans-unit>
        <trans-unit id="c7a0e8b8a829212ce4bf38fa9f7e144c221c0093" translate="yes" xml:space="preserve">
          <source>To turn off DCE completely, use the &lt;code&gt;devMode&lt;/code&gt; option in the &lt;code&gt;dceTask&lt;/code&gt;:</source>
          <target state="translated">要完全关闭DCE，请使用 &lt;code&gt;devMode&lt;/code&gt; 中的 &lt;code&gt;dceTask&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="e5d84f46ddf483c214d924898fdd70375c5841ef" translate="yes" xml:space="preserve">
          <source>To turn on CSS support in your project, set the &lt;code&gt;cssSupport.enabled&lt;/code&gt; flag in the Gradle build file for &lt;code&gt;webpackTask&lt;/code&gt;, &lt;code&gt;runTask&lt;/code&gt;, and &lt;code&gt;testTask&lt;/code&gt; respectively. This configuration is also enabled by default when creating a new project using the wizard.</source>
          <target state="translated">要在项目中打开CSS支持，请 &lt;code&gt;cssSupport.enabled&lt;/code&gt; 在Gradle构建文件中为 &lt;code&gt;webpackTask&lt;/code&gt; ， &lt;code&gt;runTask&lt;/code&gt; 和 &lt;code&gt;testTask&lt;/code&gt; 设置cssSupport.enabled标志。使用向导创建新项目时，默认情况下也会启用此配置。</target>
        </trans-unit>
        <trans-unit id="374704e123399146f9a10acdf418e1645171dca5" translate="yes" xml:space="preserve">
          <source>To unwrap the reference:</source>
          <target state="translated">要解开参考文献:</target>
        </trans-unit>
        <trans-unit id="a91c18bfe059c0da75a37ebc4ffaf3efe0d2e769" translate="yes" xml:space="preserve">
          <source>To unzip a list of pairs, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt;&lt;code&gt;unzip()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要解压缩对列表，请调用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt; &lt;code&gt;unzip()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a0e0cb040b2c181af6e3ea61de668187d10e532" translate="yes" xml:space="preserve">
          <source>To use a property, simply refer to it by name:</source>
          <target state="translated">要使用一个属性,只需用名称来引用它。</target>
        </trans-unit>
        <trans-unit id="d8bf5ffe82f149520490d0887cef3348767dda39" translate="yes" xml:space="preserve">
          <source>To use a property, we simply refer to it by name, as if it were a field in Java:</source>
          <target state="translated">要使用一个属性,我们只需用名字来引用它,就像它是Java中的一个字段一样。</target>
        </trans-unit>
        <trans-unit id="f72769e7770abb5ce6cba411b555a198f8e3b8fb" translate="yes" xml:space="preserve">
          <source>To use an API that requires opt-in in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:OptIn&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">要使用要求文件中所有函数和类都选择加入的API，请在文件包说明和导入之前，在文件顶部添加文件级注释 &lt;code&gt;@file:OptIn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="213ffc2b7aa1496be9528a577f9f8df930989d35" translate="yes" xml:space="preserve">
          <source>To use an EAP build instead, we need to specify its version in &lt;code&gt;ext.kotlin_version&lt;/code&gt; and add the corresponding repository to the &lt;code&gt;buildscript&lt;/code&gt; section (usually EAP builds are located on &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt;)</source>
          <target state="translated">要改用EAP构建，我们需要在 &lt;code&gt;ext.kotlin_version&lt;/code&gt; 中指定其版本，并将相应的存储库添加到 &lt;code&gt;buildscript&lt;/code&gt; 部分（通常EAP构建位于&lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray上&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="95905a2dc80cd98916ed0f8c91572f9ae392d28e" translate="yes" xml:space="preserve">
          <source>To use an experimental API in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:UseExperimental&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">要在文件的所有函数和类中使用实验性API ，请在文件包规范和导入之前，在文件顶部添加文件级注释 &lt;code&gt;@file:UseExperimental&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7911ada2a93fd834ce5409496ee220d5914c628" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in a scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list.</source>
          <target state="translated">要从头开始使用项目中的类或函数，请像平常一样使用 &lt;code&gt;import&lt;/code&gt; 语句将它们导入到头文件中。然后编写代码并&lt;strong&gt;使用&lt;/strong&gt;在&amp;ldquo;&lt;strong&gt;使用模块的类路径&amp;rdquo;&lt;/strong&gt;列表中选择的相应模块运行它。</target>
        </trans-unit>
        <trans-unit id="905c85d4c4dbeeb5849e639296b6ff9051d12bf0" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in the scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list. To rebuild the module automatically before running the scratch, select &lt;strong&gt;Make before Run&lt;/strong&gt;.</source>
          <target state="translated">要从头开始使用项目中的类或函数，请照常使用 &lt;code&gt;import&lt;/code&gt; 语句将它们导入到头文件中。然后编写代码并&lt;strong&gt;使用&lt;/strong&gt;在&amp;ldquo; &lt;strong&gt;使用模块的类路径&amp;rdquo;&lt;/strong&gt;列表中选择的相应模块运行它。要在运行暂存器之前自动重建模块，&lt;strong&gt;请&lt;/strong&gt;选择&lt;strong&gt;&amp;ldquo;运行前制作&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5befb1fd889ec3d540fc6857e1cc44328178daf4" translate="yes" xml:space="preserve">
          <source>To use different modes for the same project, use &lt;code&gt;cssSupport.rules&lt;/code&gt;. Here, you can specify a list of &lt;code&gt;KotlinWebpackCssRules&lt;/code&gt;, each of which define a mode, as well as &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleinclude&quot;&gt;include&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleexclude&quot;&gt;exclude&lt;/a&gt; patterns.</source>
          <target state="translated">要对同一项目使用不同的模式，请使用 &lt;code&gt;cssSupport.rules&lt;/code&gt; 。在这里，您可以指定 &lt;code&gt;KotlinWebpackCssRules&lt;/code&gt; 的列表，每个列表定义一个模式以及&lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleinclude&quot;&gt;包含&lt;/a&gt;和&lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleexclude&quot;&gt;排除&lt;/a&gt;模式。</target>
        </trans-unit>
        <trans-unit id="7e6f898d3fd804cbaaa8f5e41eecb4b87b3f095b" translate="yes" xml:space="preserve">
          <source>To use it with Kotlin configure annotation processing dependency using &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">要将其与Kotlin一起使用，请使用 &lt;code&gt;kapt&lt;/code&gt; 配置注释处理依赖项：</target>
        </trans-unit>
        <trans-unit id="6b18f46b3a0f449d7eb395f93e2e99d2ceb07f22" translate="yes" xml:space="preserve">
          <source>To use reflection in a Gradle or Maven project, add the dependency on &lt;code&gt;kotlin-reflect&lt;/code&gt;:</source>
          <target state="translated">要在Gradle或Maven项目中使用反射，请添加对 &lt;code&gt;kotlin-reflect&lt;/code&gt; 的依赖：</target>
        </trans-unit>
        <trans-unit id="a24de3bc480fd74ef920d5e8c2200b8ea53a9381" translate="yes" xml:space="preserve">
          <source>To use such an extension outside its declaring package, we need to import it at the call site:</source>
          <target state="translated">要在其声明包之外使用这样的扩展,我们需要在调用站点导入它。</target>
        </trans-unit>
        <trans-unit id="f45da6c5e75b429df6c944cb1a348aa71eac1487" translate="yes" xml:space="preserve">
          <source>To use the Gradle worker API for parallel execution of kapt tasks, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">要使用Gradle worker API并行执行kapt任务，请将此行添加到 &lt;code&gt;gradle.properties&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="f4b36ae1fba60b209f3facc66006c1d59e359e4b" translate="yes" xml:space="preserve">
          <source>To use the library just</source>
          <target state="translated">要使用图书馆,只需</target>
        </trans-unit>
        <trans-unit id="f8b6262cd9dc8c43d7c667ac936a5f2566f2a0e4" translate="yes" xml:space="preserve">
          <source>To use these dependencies from a Kotlin code, import a package &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;. In the example above, it's &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt;.</source>
          <target state="translated">要使用Kotlin代码中的这些依赖项，请导入包 &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; 。在上面的示例中，它是 &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc228ddfd7202033ce71a7fc317732c5e0b0cb8d" translate="yes" xml:space="preserve">
          <source>To use these dependencies from the Kotlin code, import the packages &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">要使用Kotlin代码中的这些依赖关系，请导入包 &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22f56a6a1ece973c1e685039b7b24f3bed65f0bb" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to &lt;strong&gt;Settings | Editor | Inspections&lt;/strong&gt; and enable the &lt;strong&gt;Kotlin | Style issues | File is not formatted according to project settings&lt;/strong&gt; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">要验证您的代码是否按照样式指南进行了格式&lt;strong&gt;设置&lt;/strong&gt;，请转至&lt;strong&gt;&amp;ldquo;设置&amp;rdquo; |&amp;ldquo;设置&amp;rdquo;。&lt;/strong&gt;&lt;strong&gt;编辑器 &lt;/strong&gt;&lt;strong&gt;检查&lt;/strong&gt;并启用&lt;strong&gt;Kotlin | 样式问题| 根据项目设置&lt;/strong&gt;检查，&lt;strong&gt;文件未格式化&lt;/strong&gt;。默认情况下，会启用验证样式指南中描述的其他问题（例如命名约定）的其他检查。</target>
        </trans-unit>
        <trans-unit id="29ce373f521a913b58c57c24b3da2c509d708a6c" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to the inspection settings and enable the &quot;Kotlin | Style issues | File is not formatted according to project settings&quot; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">要验证你的代码是否按照样式指南进行了格式化,请进入检查设置并启用 &quot;Kotlin | 样式问题 | 文件未按照项目设置进行格式化 &quot;检查。默认情况下,会启用额外的检查来验证样式指南中描述的其他问题(例如命名约定)。</target>
        </trans-unit>
        <trans-unit id="a4960c3af648de37ee9fc988a1b8a755e743e505" translate="yes" xml:space="preserve">
          <source>To workaround this problem you can store a reference to the resource in the variable as opposed to returning it from the &lt;code&gt;withTimeout&lt;/code&gt; block.</source>
          <target state="translated">要变通解决此问题，您可以将对资源的引用存储在变量中，而不是从 &lt;code&gt;withTimeout&lt;/code&gt; 块返回资源。</target>
        </trans-unit>
        <trans-unit id="b6747c485a8043bd5cfaa965ac1719dda893a066" translate="yes" xml:space="preserve">
          <source>To wrap the reference:</source>
          <target state="translated">要包涵参考。</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a2b342afe760f02175e18eb57be53d77e5b4d945" translate="yes" xml:space="preserve">
          <source>Tools for Android Development</source>
          <target state="translated">Android开发工具</target>
        </trans-unit>
        <trans-unit id="933c173dc4997663d3dd2b639f726f17d399abb1" translate="yes" xml:space="preserve">
          <source>Top level/global variables of non-primitive types are by default accessible in the main thread (i.e., the thread which initialized &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime first) only. Access from another thread will lead to an &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; being thrown. To make such variables accessible in other threads, you can use either the &lt;code&gt;@ThreadLocal&lt;/code&gt; annotation, and mark the value thread local or &lt;code&gt;@SharedImmutable&lt;/code&gt;, which will make the value frozen and accessible from other threads.</source>
          <target state="translated">默认情况下，非基本类型的顶级/全局变量只能在主线程（即，首先初始化&lt;em&gt;Kotlin / Native&lt;/em&gt;运行时的线程）中访问。来自另一个线程的访问将导致引发 &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; 。若要使此类变量可在其他线程中访问，可以使用 &lt;code&gt;@ThreadLocal&lt;/code&gt; 批注，并将值thread标记为local或 &lt;code&gt;@SharedImmutable&lt;/code&gt; ，这将使该值冻结并可以从其他线程访问。</target>
        </trans-unit>
        <trans-unit id="d10164060fa5359f1cc0440621a4aa0561a65a4b" translate="yes" xml:space="preserve">
          <source>Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class. E.g.</source>
          <target state="translated">顶级的Kotlin函数和属性可以作为特殊类的成员来访问。每个Kotlin文件都会被翻译成这样一个类。例如</target>
        </trans-unit>
        <trans-unit id="72f832e9bb11ffaf0e6dadede4c2d82d643da82d" translate="yes" xml:space="preserve">
          <source>Top-level blocks</source>
          <target state="translated">顶层区块</target>
        </trans-unit>
        <trans-unit id="2b1be77aa458090db17874852b17692b274f4c30" translate="yes" xml:space="preserve">
          <source>Top-level functions and properties</source>
          <target state="translated">顶层功能和属性</target>
        </trans-unit>
        <trans-unit id="73a9d7257a50c4b586e17a750a9b120479406586" translate="yes" xml:space="preserve">
          <source>Top-level variables:</source>
          <target state="translated">顶层变量:</target>
        </trans-unit>
        <trans-unit id="093982a5b38ce32bb690b5df5afe9cfb58db39b3" translate="yes" xml:space="preserve">
          <source>Top-level, or member of an &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;object&lt;/em&gt; declaration&lt;/a&gt; or &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;a &lt;em&gt;companion object&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">顶级或成员的的&lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;对象&lt;/em&gt;申报&lt;/a&gt;或&lt;a href=&quot;object-declarations#companion-objects&quot;&gt;一个&lt;em&gt;同伴对象&lt;/em&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3f139abb7a549a1210b36f7dbf89215ad6c9902" translate="yes" xml:space="preserve">
          <source>Touch</source>
          <target state="translated">Touch</target>
        </trans-unit>
        <trans-unit id="1efa29eabe3ababde0e86df3b6d2edc46db3122e" translate="yes" xml:space="preserve">
          <source>TouchList</source>
          <target state="translated">TouchList</target>
        </trans-unit>
        <trans-unit id="86c192cdf813e67ab4284db18cce6c47a873de77" translate="yes" xml:space="preserve">
          <source>TrackEventInit</source>
          <target state="translated">TrackEventInit</target>
        </trans-unit>
        <trans-unit id="04a727b8d4352f2bb05170808566a662370f1470" translate="yes" xml:space="preserve">
          <source>Trailing comma</source>
          <target state="translated">后面的逗号</target>
        </trans-unit>
        <trans-unit id="7b5b3a2e5f602edd973d6bc7c27d9b7106a52ef4" translate="yes" xml:space="preserve">
          <source>Trailing commas</source>
          <target state="translated">逗号</target>
        </trans-unit>
        <trans-unit id="10b9c6cd7256580987215cb5bd31fae33f7491a8" translate="yes" xml:space="preserve">
          <source>Trailing commas are entirely optional &amp;ndash; your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</source>
          <target state="translated">尾部逗号完全是可选的&amp;ndash;如果没有它们，您的代码仍然可以使用。Kotlin样式指南鼓励在声明站点使用尾随逗号，并由您自行决定是否在呼叫站点使用。</target>
        </trans-unit>
        <trans-unit id="24c733cfc9ff52310bfeff0739e9d84bd974f090" translate="yes" xml:space="preserve">
          <source>Training Partners</source>
          <target state="translated">培训伙伴</target>
        </trans-unit>
        <trans-unit id="62000f6d60c7b6da6e48acb50b9e4d2454c263e3" translate="yes" xml:space="preserve">
          <source>TransferMode</source>
          <target state="translated">TransferMode</target>
        </trans-unit>
        <trans-unit id="5493525620b201e4aeb2e3e266e9b2a0148f6e9a" translate="yes" xml:space="preserve">
          <source>Transform operator</source>
          <target state="translated">变换运算符</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="e58ba5ae9c3b287bdcbf2771b01865f2bca67751" translate="yes" xml:space="preserve">
          <source>Transformations to &lt;code&gt;Iterable&lt;/code&gt; on &lt;code&gt;Sequence&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;Sequence&lt;/code&gt; 上转换为可 &lt;code&gt;Iterable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81c5e51e91e71b63dc5528985dabb38605c21cee" translate="yes" xml:space="preserve">
          <source>Transformations to &lt;code&gt;Sequence&lt;/code&gt; on &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, and &lt;code&gt;Map&lt;/code&gt;</source>
          <target state="translated">转换为 &lt;code&gt;Iterable&lt;/code&gt; ， &lt;code&gt;Array&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 上的 &lt;code&gt;Sequence&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45d5bc5a6500f8488347501d41f5194f063eae68" translate="yes" xml:space="preserve">
          <source>Transient</source>
          <target state="translated">Transient</target>
        </trans-unit>
        <trans-unit id="ba8d3f89d630067e3ad00c3e459e314bd98fb9a0" translate="yes" xml:space="preserve">
          <source>Transitive: for any non-null values &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, if &lt;code&gt;x.equals(y)&lt;/code&gt; returns true and &lt;code&gt;y.equals(z)&lt;/code&gt; returns true, then &lt;code&gt;x.equals(z)&lt;/code&gt; should return true.</source>
          <target state="translated">可传递的：对于 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 的任何非空值，如果 &lt;code&gt;x.equals(y)&lt;/code&gt; 返回true，而 &lt;code&gt;y.equals(z)&lt;/code&gt; 返回true，则 &lt;code&gt;x.equals(z)&lt;/code&gt; 应该返回true。</target>
        </trans-unit>
        <trans-unit id="a3b98ac58ac04384390fe968f8d17e1762075dcc" translate="yes" xml:space="preserve">
          <source>Translate primitive arrays to JS typed arrays</source>
          <target state="translated">将基元数组转换为JS类型数组。</target>
        </trans-unit>
        <trans-unit id="a1e378439cd6792c22e6754f9de426ee92e8887a" translate="yes" xml:space="preserve">
          <source>Translated to</source>
          <target state="translated">翻译成</target>
        </trans-unit>
        <trans-unit id="bd2fa02487c23403447e0670b33275ea05db6a74" translate="yes" xml:space="preserve">
          <source>Translation Rules</source>
          <target state="translated">翻译规则</target>
        </trans-unit>
        <trans-unit id="ab6dfa598f3ee1889c506fcb09d74fa1777c572b" translate="yes" xml:space="preserve">
          <source>Translation of type &lt;code&gt;Nothing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Nothing&lt;/code&gt; 类型的翻译</target>
        </trans-unit>
        <trans-unit id="6aceb57c8bb80570e896470165c635c1ee57a688" translate="yes" xml:space="preserve">
          <source>Translation rules</source>
          <target state="translated">翻译规则</target>
        </trans-unit>
        <trans-unit id="4d92e703a622ed46d6e27f0f0f77397beeb3e132" translate="yes" xml:space="preserve">
          <source>Transparent catch</source>
          <target state="translated">透明的捕捉器</target>
        </trans-unit>
        <trans-unit id="a15aca388afb19d901171e68fd72afd431d071e5" translate="yes" xml:space="preserve">
          <source>Traversing a map/list of pairs</source>
          <target state="translated">遍历地图/线对列表</target>
        </trans-unit>
        <trans-unit id="c5549ac8b888e22b01fa637b7351d8e5201d7fba" translate="yes" xml:space="preserve">
          <source>TreeWalker</source>
          <target state="translated">TreeWalker</target>
        </trans-unit>
        <trans-unit id="bf7930508d19dc53b19991f963b30e949ffffae4" translate="yes" xml:space="preserve">
          <source>Trigonometric: &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt; and inverse of them: &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;;</source>
          <target state="translated">三角函数： &lt;code&gt;cos&lt;/code&gt; ， &lt;code&gt;sin&lt;/code&gt; ， &lt;code&gt;tan&lt;/code&gt; 和它们的逆： &lt;code&gt;acos&lt;/code&gt; ， &lt;code&gt;asin&lt;/code&gt; ， &lt;code&gt;atan&lt;/code&gt; ， &lt;code&gt;atan2&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="b9283be1760ffff3d2b71a4bf3400fc0c777b4fb" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;修剪&lt;/a&gt;源字符串的每一行中的前导空格字符，后跟marginPrefix，如果它们是空白的，则删除第一行和最后一行（注意，空白与空白之间是差异）。</target>
        </trans-unit>
        <trans-unit id="5480c14a1f35b84e453f6cd73b5a2004a2f5d464" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;修剪&lt;/a&gt;源字符串的每一行中的前导空格字符，后跟marginPrefix，如果它们是空白的，则删除第一行和最后一行（注意，空白与空白之间是差异）。</target>
        </trans-unit>
        <trans-unit id="c35e61d912f4e00490fababb98d899c86bab87f9" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">&lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;修剪&lt;/a&gt;源字符串的每一行中的前导空格字符，后跟marginPrefix，如果它们是空白的，则删除第一行和最后一行（注意，空白与空白之间是差异）。</target>
        </trans-unit>
        <trans-unit id="84a97aca5ec5480f19364dafde3094ff54f3e81a" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">&lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;修剪&lt;/a&gt;源字符串的每一行中的前导空格字符，后跟marginPrefix，如果它们是空白的，则删除第一行和最后一行（注意，空白与空白之间是差异）。</target>
        </trans-unit>
        <trans-unit id="ae1a12e0ad64ac32c1b6bcc5a4f65c861d2ccdb6" translate="yes" xml:space="preserve">
          <source>Triple</source>
          <target state="translated">Triple</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="dd25f60abb02d8a8fead2fd0c632ac71f7dc7572" translate="yes" xml:space="preserve">
          <source>True if this BitSet contains no bits set to true.</source>
          <target state="translated">如果这个BitSet不包含设置为true的位,则为true。</target>
        </trans-unit>
        <trans-unit id="ebadece2244cd8c3930af24f6efed50ba5303aeb" translate="yes" xml:space="preserve">
          <source>Try is an expression</source>
          <target state="translated">尝试是一种表达方式</target>
        </trans-unit>
        <trans-unit id="76626410fd299e2579daa03a6a8e059a7c331dac" translate="yes" xml:space="preserve">
          <source>Try running the following code:</source>
          <target state="translated">尝试运行以下代码。</target>
        </trans-unit>
        <trans-unit id="ab16b9ed40416d31269e0f90879c02e2beaffb5d" translate="yes" xml:space="preserve">
          <source>Try the following example:</source>
          <target state="translated">试试下面的例子。</target>
        </trans-unit>
        <trans-unit id="6598cd1f03cde7303010f8b82688f8cd83e05fd7" translate="yes" xml:space="preserve">
          <source>Try the hierarchical project structure</source>
          <target state="translated">试试分层的项目结构</target>
        </trans-unit>
        <trans-unit id="6e8975e856a765f6b65172a38acea83accc861c3" translate="yes" xml:space="preserve">
          <source>Tuning the Gradle Build Script</source>
          <target state="translated">调整Gradle构建脚本</target>
        </trans-unit>
        <trans-unit id="ea1b6a2e19cb07b905a5f8a640d896e87bcec9bf" translate="yes" xml:space="preserve">
          <source>Turn any warnings into a compilation error.</source>
          <target state="translated">将任何警告变成编译错误。</target>
        </trans-unit>
        <trans-unit id="486df8c49f3484e79ec93676a1d2d32e3c21544f" translate="yes" xml:space="preserve">
          <source>Turn off the discovery of annotation processors in the compile classpath by adding this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">通过 &lt;code&gt;gradle.properties&lt;/code&gt; 添加到gradle.properties文件，在编译类路径中关闭对注释处理器的发现：</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a8a70d82aa05be09e708b91e7f3e4c134d89ffcd" translate="yes" xml:space="preserve">
          <source>Two characters are considered the same ignoring case if at least one of the following is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">如果以下至少一项为 &lt;code&gt;true&lt;/code&gt; ，则两个字符被视为相同的忽略大小写：</target>
        </trans-unit>
        <trans-unit id="ab472c51dfbccf051740af19176dfafb00b61af8" translate="yes" xml:space="preserve">
          <source>Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.</source>
          <target state="translated">两个具有相同种子的生成器在同一版本的Kotlin运行时产生相同的值序列。</target>
        </trans-unit>
        <trans-unit id="d137720f3328e5a478b178126ce3903c8817736d" translate="yes" xml:space="preserve">
          <source>Two maps containing the equal pairs are equal regardless of the pair order.</source>
          <target state="translated">包含相等对子的两幅地图无论对子顺序如何都是相等的。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="5f6616a8e5da9fee3d521ed755f2bea54b08215a" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: &amp;#x27;is&amp;#x27; and &amp;#x27;as&amp;#x27;</source>
          <target state="translated">类型检查和转换：&amp;ldquo;是&amp;rdquo;和&amp;ldquo;为&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d6cc07866d5f06f3719a56316deb52a9dd1a6362" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: 'is' and 'as'</source>
          <target state="translated">类型检查和转换:&quot;is &quot;和 &quot;as</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="723718d194ac3a64c7f264ffc4d4f72b344ce07d" translate="yes" xml:space="preserve">
          <source>Type aliases can have only one member, while functional interfaces can have multiple non-abstract members and one abstract member. Functional interfaces can also implement and extend other interfaces.</source>
          <target state="translated">类型别名可以只有一个成员,而功能接口可以有多个非抽象成员和一个抽象成员。功能接口也可以实现和扩展其他接口。</target>
        </trans-unit>
        <trans-unit id="69c8e849ce31321a314a70ac8ad4ed39beff1378" translate="yes" xml:space="preserve">
          <source>Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; and use &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; in your code, the Kotlin compiler always expands it to &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt;. Thus you can pass a variable of your type whenever a general function type is required and vice versa:</source>
          <target state="translated">类型别名不会引入新类型。它们等效于相应的基础类型。当您添加 &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; 并在代码中使用 &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; 时，Kotlin编译器始终将其扩展为 &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt; 。因此，只要需要通用函数类型，就可以传递您类型的变量，反之亦然：</target>
        </trans-unit>
        <trans-unit id="63f9c00fb5f4cc41a0eed5075c935b736c6b9723" translate="yes" xml:space="preserve">
          <source>Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.</source>
          <target state="translated">类型别名为现有类型提供了替代名称。如果类型名称太长,您可以引入一个不同的较短的名称,并使用新的名称代替。</target>
        </trans-unit>
        <trans-unit id="a2a8d10c5940641abcd5ce54fb8bcd8a1818a8ed" translate="yes" xml:space="preserve">
          <source>Type annotations in the JVM bytecode</source>
          <target state="translated">JVM字节码中的类型注释</target>
        </trans-unit>
        <trans-unit id="c296bfc3cf8da18578c109dce183097398bf868c" translate="yes" xml:space="preserve">
          <source>Type annotations on method parameters, method return types and property types;</source>
          <target state="translated">方法参数、方法返回类型和属性类型的类型注释。</target>
        </trans-unit>
        <trans-unit id="e35e3a28b52f56ce98adcccb56e038088090c61a" translate="yes" xml:space="preserve">
          <source>Type arguments</source>
          <target state="translated">类型参数</target>
        </trans-unit>
        <trans-unit id="f97f977bc0dba85c3cc52fd08f6033a3696be06a" translate="yes" xml:space="preserve">
          <source>Type arguments can be omitted if they can be inferred from the context, so the following example works as well:</source>
          <target state="translated">如果可以从上下文中推断出类型参数,那么可以省略,所以下面的例子也可以用。</target>
        </trans-unit>
        <trans-unit id="c98c974ad55a448f7905288ae79a3c29e3dafc00" translate="yes" xml:space="preserve">
          <source>Type arguments passed for the parameters of the classifier in this type. For example, in the type &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; the only type argument is &lt;code&gt;out Number&lt;/code&gt;.</source>
          <target state="translated">为该类型的分类器的参数传递的类型实参。例如，在 &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; 类型中，唯一的类型参数是 &lt;code&gt;out Number&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17f4a34465afc16c831c4800dd92a48a4229a238" translate="yes" xml:space="preserve">
          <source>Type casts to generic types with concrete type arguments, e.g. &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt;, cannot be checked at runtime.</source>
          <target state="translated">类型转换为具有具体类型参数的泛型类型，例如，在运行时无法检查 &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73156460a89d705ba62bd534bd81f39c8db2596a" translate="yes" xml:space="preserve">
          <source>Type checks and automatic casts</source>
          <target state="translated">类型检查和自动铸造</target>
        </trans-unit>
        <trans-unit id="793f10e89d89960ec6635302ed647f148619a822" translate="yes" xml:space="preserve">
          <source>Type erasure</source>
          <target state="translated">擦除类型</target>
        </trans-unit>
        <trans-unit id="40dc0a7305bb05f3cc921959233fc31aff814e2e" translate="yes" xml:space="preserve">
          <source>Type erasure and generic type checks</source>
          <target state="translated">类型清除和通用类型检查</target>
        </trans-unit>
        <trans-unit id="3a57e7033772e15f6c935d00cab613d6b63a13b4" translate="yes" xml:space="preserve">
          <source>Type inference for variable and property types</source>
          <target state="translated">变量和属性类型的类型推断</target>
        </trans-unit>
        <trans-unit id="6468c2c68f3a4de506104359dc49acb341f7ce4b" translate="yes" xml:space="preserve">
          <source>Type of this parameter. For a &lt;code&gt;vararg&lt;/code&gt; parameter, this is the type of the corresponding array, not the individual element.</source>
          <target state="translated">此参数的类型。对于 &lt;code&gt;vararg&lt;/code&gt; 参数，这是对应数组的类型，而不是单个元素。</target>
        </trans-unit>
        <trans-unit id="c9a3646a7ac556f56d25e93e18f2d2b1583d0264" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
          <target state="translated">类型参数</target>
        </trans-unit>
        <trans-unit id="67db91aa392a58df5790c33c41ae1990e5a33a95" translate="yes" xml:space="preserve">
          <source>Type projection is either the star projection, or an entity consisting of a specific type plus optional variance.</source>
          <target state="translated">类型投影是星型投影,或者是由特定类型加上可选的方差组成的实体。</target>
        </trans-unit>
        <trans-unit id="a1c1994c749574f626726569018d7132330feb4f" translate="yes" xml:space="preserve">
          <source>Type projections</source>
          <target state="translated">类型预测</target>
        </trans-unit>
        <trans-unit id="390df132c9a4d4db52e48418904c22311abcfb25" translate="yes" xml:space="preserve">
          <source>Type projections (use-site covariance and contravariance)</source>
          <target state="translated">类型预测(使用地点协方差和协方差)</target>
        </trans-unit>
        <trans-unit id="abe0a5c2d281fcb1877a803065e24a61b33d5485" translate="yes" xml:space="preserve">
          <source>Type qualifier defaults (since 1.1.50)</source>
          <target state="translated">类型限定符默认值(自1.1.50起)</target>
        </trans-unit>
        <trans-unit id="7774fb35aa4a81a2d582ed079ba64fde2c6c6958" translate="yes" xml:space="preserve">
          <source>Type qualifier nicknames (since 1.1.50)</source>
          <target state="translated">类型限定符昵称(自1.1.50起)。</target>
        </trans-unit>
        <trans-unit id="acbd0130304bd83955856731709666b221130b62" translate="yes" xml:space="preserve">
          <source>Type safety problem because of incorrect subtyping for intersection types</source>
          <target state="translated">类型安全问题,因为交叉口类型的子类型不正确。</target>
        </trans-unit>
        <trans-unit id="9199f1fd6ec494778d67bf415e37aa0839ac622f" translate="yes" xml:space="preserve">
          <source>Type safety problem because of lack of captured conversion against nullable type argument</source>
          <target state="translated">类型安全问题,因为缺乏针对可空类型参数的捕获转换。</target>
        </trans-unit>
        <trans-unit id="bb995680367f27e40ce4ad1d6abb4c604f7187b7" translate="yes" xml:space="preserve">
          <source>Type safety problem because several equal type variables are instantiated with a different types</source>
          <target state="translated">类型安全问题,因为几个相等的类型变量被实例化为不同的类型。</target>
        </trans-unit>
        <trans-unit id="40de16300b7ec7ebb7fd5b46ebfe06fa7442e5d2" translate="yes" xml:space="preserve">
          <source>Type usage</source>
          <target state="translated">类型用途</target>
        </trans-unit>
        <trans-unit id="4903c79122878e4bb6246343ee54954a9e90d953" translate="yes" xml:space="preserve">
          <source>Type variable leaks from builder inference because of using &lt;code&gt;this&lt;/code&gt; expression</source>
          <target state="translated">由于使用了 &lt;code&gt;this&lt;/code&gt; 表达式，因此类型变量从生成器推断中泄漏</target>
        </trans-unit>
        <trans-unit id="302ec0e139d68906dc0b295bb935fe896afa1e82" translate="yes" xml:space="preserve">
          <source>Type-Safe Builders</source>
          <target state="translated">安全型建筑商</target>
        </trans-unit>
        <trans-unit id="1c6379917dd2967a0cd2179d5b9d494b8ce1b4e8" translate="yes" xml:space="preserve">
          <source>Type-safe builders allow creating Kotlin-based domain-specific languages (DSLs) suitable for building complex hierarchical data structures in a semi-declarative way. Some of the example use cases for the builders are:</source>
          <target state="translated">类型安全构建器允许创建基于Kotlin的特定领域语言(DSL),适用于以半声明的方式构建复杂的分层数据结构。构建器的一些用例是:</target>
        </trans-unit>
        <trans-unit id="5c15b26d8e7df3e3ffb8c17df0302ea2aa484921" translate="yes" xml:space="preserve">
          <source>TypeCastException</source>
          <target state="translated">TypeCastException</target>
        </trans-unit>
        <trans-unit id="5f0d1a781a66df1f72742486a55df1e5b04f2308" translate="yes" xml:space="preserve">
          <source>Typealias describing custom exception reporting hook.</source>
          <target state="translated">描述自定义异常报告钩子的类型alias。</target>
        </trans-unit>
        <trans-unit id="f3f4c434904369ad0a9f93c33f4c9768b4547a37" translate="yes" xml:space="preserve">
          <source>TypedArrays support enabled by default</source>
          <target state="translated">默认启用TypedArrays支持</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="5ee39ed12bcc53f39d2691296714b602c56e8452" translate="yes" xml:space="preserve">
          <source>Types in C Language</source>
          <target state="translated">C语言中的类型</target>
        </trans-unit>
        <trans-unit id="9082e24429af3d96afc6c792bd53d243c13fe913" translate="yes" xml:space="preserve">
          <source>Types in Kotlin are optional in many places due to pervasive use of type-inference, but every declaration still has a well-defined static type that is known at compilation.</source>
          <target state="translated">由于type-inference的普遍使用,Kotlin中的类型在很多地方都是可选的,但每个声明仍然有一个定义良好的静态类型,在编译时就可以知道。</target>
        </trans-unit>
        <trans-unit id="629a9e78a0114f36f48645e6ead99e73e5226592" translate="yes" xml:space="preserve">
          <source>Types mapping between C and Kotlin/Native</source>
          <target state="translated">C和Kotlin/Native之间的类型映射。</target>
        </trans-unit>
        <trans-unit id="23a10fa48ff804faeadfa8169422520460b61a41" translate="yes" xml:space="preserve">
          <source>Typesafe HTML DSL</source>
          <target state="translated">Typesafe HTML DSL</target>
        </trans-unit>
        <trans-unit id="f4beb9af58f792082d8857ce30b4be1bdbe9b57a" translate="yes" xml:space="preserve">
          <source>Typography</source>
          <target state="translated">Typography</target>
        </trans-unit>
        <trans-unit id="4ae5c7578750deca68bcc325a7a71916e13eb9f0" translate="yes" xml:space="preserve">
          <source>UArraysKt</source>
          <target state="translated">UArraysKt</target>
        </trans-unit>
        <trans-unit id="bf674fff56341390c001cb60679614bd8b320e06" translate="yes" xml:space="preserve">
          <source>UByte</source>
          <target state="translated">UByte</target>
        </trans-unit>
        <trans-unit id="ffb6040505a41eac67ecae4d97b182ca73c78ec7" translate="yes" xml:space="preserve">
          <source>UByteArray</source>
          <target state="translated">UByteArray</target>
        </trans-unit>
        <trans-unit id="d70700d1cf06666209f322639803c081fb20d34b" translate="yes" xml:space="preserve">
          <source>UByteIterator</source>
          <target state="translated">UByteIterator</target>
        </trans-unit>
        <trans-unit id="5c472b4b939131094e43f08559b073c75fc2a028" translate="yes" xml:space="preserve">
          <source>UByteVar</source>
          <target state="translated">UByteVar</target>
        </trans-unit>
        <trans-unit id="f25071b42b8c8e395a2b2b3981b7f23745b87556" translate="yes" xml:space="preserve">
          <source>UByteVarOf</source>
          <target state="translated">UByteVarOf</target>
        </trans-unit>
        <trans-unit id="7df33eb953a0db74ecea7bf713e814fb3abc743c" translate="yes" xml:space="preserve">
          <source>UIEventInit</source>
          <target state="translated">UIEventInit</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="e8203a992b0218cb4341f1de99192c75977adf66" translate="yes" xml:space="preserve">
          <source>UIntArray</source>
          <target state="translated">UIntArray</target>
        </trans-unit>
        <trans-unit id="107a5f6058e02cbfca8e781b5a2a6f523ad395cb" translate="yes" xml:space="preserve">
          <source>UIntIterator</source>
          <target state="translated">UIntIterator</target>
        </trans-unit>
        <trans-unit id="b426f73d819457b44ee2c1f6127ae0354bab9219" translate="yes" xml:space="preserve">
          <source>UIntProgression</source>
          <target state="translated">UIntProgression</target>
        </trans-unit>
        <trans-unit id="733f5415b770d705f77b9612bf3ea932f2bce7d0" translate="yes" xml:space="preserve">
          <source>UIntRange</source>
          <target state="translated">UIntRange</target>
        </trans-unit>
        <trans-unit id="c9533b600e74bcc2cae112123bf64c63ddcac0d1" translate="yes" xml:space="preserve">
          <source>UIntVar</source>
          <target state="translated">UIntVar</target>
        </trans-unit>
        <trans-unit id="77c6c1f150c9389635fa7924b4f92a8549cf352c" translate="yes" xml:space="preserve">
          <source>UIntVarOf</source>
          <target state="translated">UIntVarOf</target>
        </trans-unit>
        <trans-unit id="89e5acbaebf4cf3fe914f8e97ce3365330718921" translate="yes" xml:space="preserve">
          <source>ULong</source>
          <target state="translated">ULong</target>
        </trans-unit>
        <trans-unit id="0aede794cd54bbb254cbbba847a9015fdedd384b" translate="yes" xml:space="preserve">
          <source>ULongArray</source>
          <target state="translated">ULongArray</target>
        </trans-unit>
        <trans-unit id="f83610c14f64002be2365b4b214aea8d4eb7c555" translate="yes" xml:space="preserve">
          <source>ULongIterator</source>
          <target state="translated">ULongIterator</target>
        </trans-unit>
        <trans-unit id="7f4860e3cc03b10b3ed8b10361499545cea0082e" translate="yes" xml:space="preserve">
          <source>ULongProgression</source>
          <target state="translated">ULongProgression</target>
        </trans-unit>
        <trans-unit id="904eba861b0907dd0e83aefaefd037f230269422" translate="yes" xml:space="preserve">
          <source>ULongRange</source>
          <target state="translated">ULongRange</target>
        </trans-unit>
        <trans-unit id="c10238514adfeb120f1beff5e873dea7b5ed95a8" translate="yes" xml:space="preserve">
          <source>ULongVar</source>
          <target state="translated">ULongVar</target>
        </trans-unit>
        <trans-unit id="f9dbd48fa2388e1f99c73bab257c97f132eb1089" translate="yes" xml:space="preserve">
          <source>ULongVarOf</source>
          <target state="translated">ULongVarOf</target>
        </trans-unit>
        <trans-unit id="b9a5671fcf84e88d78fc3704de6f9b452eff55a8" translate="yes" xml:space="preserve">
          <source>UNASSIGNED</source>
          <target state="translated">UNASSIGNED</target>
        </trans-unit>
        <trans-unit id="67a492265c45012bb305d1d916be6fecf6ea8e3e" translate="yes" xml:space="preserve">
          <source>UNDEFINED</source>
          <target state="translated">UNDEFINED</target>
        </trans-unit>
        <trans-unit id="a7864204909e345af29e9c794841c9fe894997a9" translate="yes" xml:space="preserve">
          <source>UNIX_LINES</source>
          <target state="translated">UNIX_LINES</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="c12e2347be0a8619c1d9ecacaec292e6f681ff3c" translate="yes" xml:space="preserve">
          <source>UNSAFE</source>
          <target state="translated">UNSAFE</target>
        </trans-unit>
        <trans-unit id="260ff90ffb9b1a7afc1635ad4eeec327ff83ec80" translate="yes" xml:space="preserve">
          <source>UPPERCASE_LETTER</source>
          <target state="translated">UPPERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="b19e8d66e7f004e226c44a75766dadab7d09911a" translate="yes" xml:space="preserve">
          <source>URLSearchParams</source>
          <target state="translated">URLSearchParams</target>
        </trans-unit>
        <trans-unit id="91e7bf3c4d0ab9784e0c43761883c8268e94bc3e" translate="yes" xml:space="preserve">
          <source>US_ASCII</source>
          <target state="translated">US_ASCII</target>
        </trans-unit>
        <trans-unit id="3f4264aca0374d417f001d13663bbf89f0617103" translate="yes" xml:space="preserve">
          <source>UShort</source>
          <target state="translated">UShort</target>
        </trans-unit>
        <trans-unit id="c9c0b8b91e36fe7c1c4c0418920e6f5691e8c55a" translate="yes" xml:space="preserve">
          <source>UShortArray</source>
          <target state="translated">UShortArray</target>
        </trans-unit>
        <trans-unit id="6c3a83167054246ea25835255ce7b0e018316b2a" translate="yes" xml:space="preserve">
          <source>UShortIterator</source>
          <target state="translated">UShortIterator</target>
        </trans-unit>
        <trans-unit id="a33eeb13596790b08a6df8799ea234e412c8c47b" translate="yes" xml:space="preserve">
          <source>UShortVar</source>
          <target state="translated">UShortVar</target>
        </trans-unit>
        <trans-unit id="282cb40f96ea3b82ef408a23ef69ab3812e1c45c" translate="yes" xml:space="preserve">
          <source>UShortVarOf</source>
          <target state="translated">UShortVarOf</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="f0217f65f3e1f538b0d8cda26e80a2285c43df22" translate="yes" xml:space="preserve">
          <source>UTF-16 code unit (see the section on &lt;a href=&quot;strings&quot;&gt;strings&lt;/a&gt; - in most cases, this is one Unicode character, but it might be just one half of a Unicode character)</source>
          <target state="translated">UTF-16代码单元（请参阅&lt;a href=&quot;strings&quot;&gt;字符串&lt;/a&gt;部分-在大多数情况下，这是一个Unicode字符，但可能只是Unicode字符的一半）</target>
        </trans-unit>
        <trans-unit id="3133dd8458a32c8b5ce4a722caa62b68748d9288" translate="yes" xml:space="preserve">
          <source>UTF_16</source>
          <target state="translated">UTF_16</target>
        </trans-unit>
        <trans-unit id="6ca2e2b19e1ecda564482fabe6d3670b269a5872" translate="yes" xml:space="preserve">
          <source>UTF_16BE</source>
          <target state="translated">UTF_16BE</target>
        </trans-unit>
        <trans-unit id="9754e677d06d03c4582e2dcf98147ca46f84d72e" translate="yes" xml:space="preserve">
          <source>UTF_16LE</source>
          <target state="translated">UTF_16LE</target>
        </trans-unit>
        <trans-unit id="447ed343c0ab25980389215d35f14db291c88450" translate="yes" xml:space="preserve">
          <source>UTF_32</source>
          <target state="translated">UTF_32</target>
        </trans-unit>
        <trans-unit id="92586032892e03cbec5d2f808289d67c3e5fe454" translate="yes" xml:space="preserve">
          <source>UTF_32BE</source>
          <target state="translated">UTF_32BE</target>
        </trans-unit>
        <trans-unit id="cbf0128f0e447f51c74b68507c6628894645216c" translate="yes" xml:space="preserve">
          <source>UTF_32LE</source>
          <target state="translated">UTF_32LE</target>
        </trans-unit>
        <trans-unit id="444b32f7d1774bb52a894fb896e3e3f1afe43c1f" translate="yes" xml:space="preserve">
          <source>UTF_8</source>
          <target state="translated">UTF_8</target>
        </trans-unit>
        <trans-unit id="ee17a2d4842b1562f38fb267817829d58a3dedfb" translate="yes" xml:space="preserve">
          <source>Uint16Array</source>
          <target state="translated">Uint16Array</target>
        </trans-unit>
        <trans-unit id="633c2aa79d88322b5d53222bfe0bb765531ece57" translate="yes" xml:space="preserve">
          <source>Uint32Array</source>
          <target state="translated">Uint32Array</target>
        </trans-unit>
        <trans-unit id="9dafd0a91ea1eadf5a4b323d71716a37f430543c" translate="yes" xml:space="preserve">
          <source>Uint8Array</source>
          <target state="translated">Uint8Array</target>
        </trans-unit>
        <trans-unit id="80d3d1902630c787d741b39af0ddaba8dab6c5b7" translate="yes" xml:space="preserve">
          <source>Uint8ClampedArray</source>
          <target state="translated">Uint8ClampedArray</target>
        </trans-unit>
        <trans-unit id="dbab18f3ded2bfe1f1beae0998ec97e669719cb0" translate="yes" xml:space="preserve">
          <source>Unary operations</source>
          <target state="translated">单利运算</target>
        </trans-unit>
        <trans-unit id="700a41ed5d6a21b389d3a06a552007f7d4970e83" translate="yes" xml:space="preserve">
          <source>Unary operators &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, and a function &lt;code&gt;inv&lt;/code&gt;.</source>
          <target state="translated">一元运算符 &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;++&lt;/code&gt; ， &lt;code&gt;--&lt;/code&gt; 和一个函数 &lt;code&gt;inv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7af4b44086924bef8511e74a06dc5652e98b37f" translate="yes" xml:space="preserve">
          <source>Unary prefix operators</source>
          <target state="translated">单音前缀运算符</target>
        </trans-unit>
        <trans-unit id="71f09f8fe1dde2289c868a03cb103ae030625690" translate="yes" xml:space="preserve">
          <source>Unchecked casts</source>
          <target state="translated">未勾选的投掷</target>
        </trans-unit>
        <trans-unit id="b8d5b81db1752990f9a00626b0f1fe949182953e" translate="yes" xml:space="preserve">
          <source>Unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. Unconfined dispatcher should not be used in general code.</source>
          <target state="translated">Unconfined dispatcher是一种先进的机制,它在某些角落的情况下可以起到帮助作用,在这些情况下,由于coroutine中的一些操作必须马上执行,所以不需要调度coroutine以后再执行,或者会产生不良的副作用。一般代码中不应使用无约束调度器。</target>
        </trans-unit>
        <trans-unit id="1ad54c8520658fa2b0366caffc5901ab7a388736" translate="yes" xml:space="preserve">
          <source>Unconfined vs confined dispatcher</source>
          <target state="translated">非密闭式与密闭式调度器的对比</target>
        </trans-unit>
        <trans-unit id="a2570f4d995169cd25ade0e53aebb8dd50e4a603" translate="yes" xml:space="preserve">
          <source>Undefined bidirectional character type. Undefined &lt;code&gt;char&lt;/code&gt; values have undefined directionality in the Unicode specification.</source>
          <target state="translated">未定义的双向字符类型。在Unicode规范中，未定义的 &lt;code&gt;char&lt;/code&gt; 值具有未定义的方向性。</target>
        </trans-unit>
        <trans-unit id="36bdd28a04792d2d0be5dfb8e33b3534b2fbd55b" translate="yes" xml:space="preserve">
          <source>Under the hood for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">在每个委托属性的幕后，Kotlin编译器都会生成一个辅助属性并委托给它。例如，对于属性 &lt;code&gt;prop&lt;/code&gt; ， &lt;code&gt;prop$delegate&lt;/code&gt; 生成隐藏属性prop $ delegate，并且访问器的代码仅委托给该附加属性：</target>
        </trans-unit>
        <trans-unit id="dd8b30eeb866c4439bd48cb8b3176d8c5f111d35" translate="yes" xml:space="preserve">
          <source>Under the hood, for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">在幕后，Kotlin编译器会为每个委托属性生成一个辅助属性并将其委托给它。例如，对于属性 &lt;code&gt;prop&lt;/code&gt; ， &lt;code&gt;prop$delegate&lt;/code&gt; 生成隐藏属性prop $ delegate，并且访问器的代码仅委托给此附加属性：</target>
        </trans-unit>
        <trans-unit id="3488dca90e45f8e2402977d7d251d68f390541e0" translate="yes" xml:space="preserve">
          <source>Underscore for unused variables (since 1.1)</source>
          <target state="translated">未使用变量的下划线(自1.1起)。</target>
        </trans-unit>
        <trans-unit id="fb79a41a5516422da2e439b9cf71e40fb6fb14d4" translate="yes" xml:space="preserve">
          <source>Underscores for unused parameters</source>
          <target state="translated">未使用参数的下划线</target>
        </trans-unit>
        <trans-unit id="c1313f733bf8697e7ec5cdf78f97cfd84d52c63d" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals</source>
          <target state="translated">数字文字中的下划线</target>
        </trans-unit>
        <trans-unit id="a32a8ccb60d72fd24a8aa497590c0bf8ba9cd8dc" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals (since 1.1)</source>
          <target state="translated">数字文字中的下划线(从1.1开始)</target>
        </trans-unit>
        <trans-unit id="796b398098842ca0559820831bbb74bc385b8a80" translate="yes" xml:space="preserve">
          <source>Unexpected behavior with &lt;code&gt;in&lt;/code&gt; infix operator and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 缀运算符和 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 中的异常行为</target>
        </trans-unit>
        <trans-unit id="1d199ddedf7802afc54d34deabe810e8a6bf5c4f" translate="yes" xml:space="preserve">
          <source>Unfortunately, if you want an empty collection, you need to either declare the resulting collection type explicitly, or supply the element type(s) to the function that constructs the collection:</source>
          <target state="translated">不幸的是,如果你想要一个空的集合,你需要显式地声明产生的集合类型,或者提供元素类型给构造集合的函数。</target>
        </trans-unit>
        <trans-unit id="e40bf9bbf42c1f6fc0258d8c13f458aad30b49f2" translate="yes" xml:space="preserve">
          <source>Unfortunately, the code formatter built into IntelliJ IDEA had to work long before this document was released and now has a default setup that produces different formatting from what is now recommended.</source>
          <target state="translated">不幸的是,IntelliJ IDEA中内置的代码格式化器在本文档发布前很久就已经开始工作了,现在的默认设置会产生与现在推荐的不同格式。</target>
        </trans-unit>
        <trans-unit id="12945de7af176c634a0d8ce8b70c82d42353176c" translate="yes" xml:space="preserve">
          <source>Unfortunately, using this would require us to type &lt;code&gt;p.name.value&lt;/code&gt; every time we wanted to use the property. We could do the following, but that's also not great since it introduces an extra property:</source>
          <target state="translated">不幸的是，使用此属性将要求我们每次要使用该属性时都键入 &lt;code&gt;p.name.value&lt;/code&gt; 。我们可以执行以下操作，但这也不好，因为它引入了额外的属性：</target>
        </trans-unit>
        <trans-unit id="8837f610cd63014d412facb51aa6f98460391f9a" translate="yes" xml:space="preserve">
          <source>Unicode correctness can be onerous in Python 2, since the &quot;default&quot; string type &lt;code&gt;str&lt;/code&gt; is really just a byte array, while &lt;code&gt;unicode&lt;/code&gt; is actually a sequence of &lt;em&gt;code units&lt;/em&gt; (see below) - and whether the code units are 16 or 32 bits wide depends on how your Python distribution was built. In Kotlin, there's no such confusion: &lt;code&gt;String&lt;/code&gt;, which is what you get when you make a string literal (which you can only do with double quotes), is an immutable sequence of UTF-16 code units. &lt;code&gt;ByteArray&lt;/code&gt; is a fixed-size (but otherwise mutable) byte array (and &lt;code&gt;String&lt;/code&gt; can specifically &lt;em&gt;not&lt;/em&gt; be used as a byte array).</source>
          <target state="translated">Unicode正确性在Python 2中可能很繁琐，因为&amp;ldquo;默认&amp;rdquo;字符串类型 &lt;code&gt;str&lt;/code&gt; 实际上只是一个字节数组，而 &lt;code&gt;unicode&lt;/code&gt; 实际上是一系列&lt;em&gt;代码单位&lt;/em&gt;（请参见下文）-代码单位是16位还是32位宽取决于关于您的Python发行版本的构建方式。在Kotlin中，没有这样的混淆： &lt;code&gt;String&lt;/code&gt; （字符串）是UTF-16代码单元的不可变序列，当您生成字符串文字时（只能用双引号将其得到）。 &lt;code&gt;ByteArray&lt;/code&gt; 是固定大小的（但在其他可变的）字节阵列（和 &lt;code&gt;String&lt;/code&gt; 可以特异性&lt;em&gt;不&lt;/em&gt;被用作一个字节数组）。</target>
        </trans-unit>
        <trans-unit id="505d5c38054a74d4b2175415322819ae4849fcad" translate="yes" xml:space="preserve">
          <source>Unified Module Definitions (UMD), which is compatible with both &lt;em&gt;AMD&lt;/em&gt; and &lt;em&gt;CommonJS&lt;/em&gt;, and works as &quot;plain&quot; when neither &lt;em&gt;AMD&lt;/em&gt; nor &lt;em&gt;CommonJS&lt;/em&gt; is available at runtime.</source>
          <target state="translated">统一模块定义（UMD），与&lt;em&gt;AMD&lt;/em&gt;和&lt;em&gt;CommonJS&lt;/em&gt;都兼容，并且在运行时&lt;em&gt;AMD&lt;/em&gt;和&lt;em&gt;CommonJS&lt;/em&gt;都不可用时，可以用作&amp;ldquo;普通&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="de5d8b50b3695e8d25f732afc1acabb23472bc08" translate="yes" xml:space="preserve">
          <source>Unified backends and extensibility</source>
          <target state="translated">统一的后端和可扩展性</target>
        </trans-unit>
        <trans-unit id="cb8c9c639d9b52130075c5077a53018a3b076842" translate="yes" xml:space="preserve">
          <source>Unified exception type for null checks</source>
          <target state="translated">统一的空检查异常类型</target>
        </trans-unit>
        <trans-unit id="4b0e76a89bd66d41a17ed421fa008af6ae14f66f" translate="yes" xml:space="preserve">
          <source>Unified standard library</source>
          <target state="translated">统一标准库</target>
        </trans-unit>
        <trans-unit id="c4aff5fbbb595afd545658cb39aa6df5dcca07e6" translate="yes" xml:space="preserve">
          <source>Unify exceptions from null checks</source>
          <target state="translated">统一空检查的异常</target>
        </trans-unit>
        <trans-unit id="c4f58ff59e65d2d98ffef40514cadc0e589f2165" translate="yes" xml:space="preserve">
          <source>Unify split by an empty match regex result across the platforms</source>
          <target state="translated">统一各平台的空匹配regex分割结果</target>
        </trans-unit>
        <trans-unit id="370ce5f1a9eb1b7143f06590af17c7841cb70b8d" translate="yes" xml:space="preserve">
          <source>UninitializedPropertyAccessException</source>
          <target state="translated">UninitializedPropertyAccessException</target>
        </trans-unit>
        <trans-unit id="a91e29c6a18b3d46ad21babc72fbe12a2806e9d6" translate="yes" xml:space="preserve">
          <source>UnionAudioTrackOrTextTrackOrVideoTrack</source>
          <target state="translated">UnionAudioTrackOrTextTrackOrVideoTrack</target>
        </trans-unit>
        <trans-unit id="b427069e00bef5cd6617471fa2f1c76d7e94c1b0" translate="yes" xml:space="preserve">
          <source>UnionClientOrMessagePortOrServiceWorker</source>
          <target state="translated">UnionClientOrMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="10052a20073fd80351eaa98a0618cc05908c3fe2" translate="yes" xml:space="preserve">
          <source>UnionElementOrHTMLCollection</source>
          <target state="translated">UnionElementOrHTMLCollection</target>
        </trans-unit>
        <trans-unit id="64df693fc6248e2d4b802ced57f664db2486df1a" translate="yes" xml:space="preserve">
          <source>UnionElementOrMouseEvent</source>
          <target state="translated">UnionElementOrMouseEvent</target>
        </trans-unit>
        <trans-unit id="5d95156c593ab4f5a1d6aa9b7adaaae5b5072eee" translate="yes" xml:space="preserve">
          <source>UnionElementOrProcessingInstruction</source>
          <target state="translated">UnionElementOrProcessingInstruction</target>
        </trans-unit>
        <trans-unit id="cb794bdbfe712bfdef6a341eb0ffeda3e61df94b" translate="yes" xml:space="preserve">
          <source>UnionElementOrRadioNodeList</source>
          <target state="translated">UnionElementOrRadioNodeList</target>
        </trans-unit>
        <trans-unit id="55e9b0c8b2893c068d7bad4f687cd74e04c97fae" translate="yes" xml:space="preserve">
          <source>UnionHTMLOptGroupElementOrHTMLOptionElement</source>
          <target state="translated">UnionHTMLOptGroupElementOrHTMLOptionElement</target>
        </trans-unit>
        <trans-unit id="9914d6bd1e51362b2ae64dd4e4f0c81df753f3a5" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrServiceWorker</source>
          <target state="translated">UnionMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="9f29b0aeda2c26ba869f1da1baf112b08de48285" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindow</source>
          <target state="translated">UnionMessagePortOrWindow</target>
        </trans-unit>
        <trans-unit id="0bdbd6bc95c6e23b6042a486f6d277c7a15fc86a" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindowProxy</source>
          <target state="translated">UnionMessagePortOrWindowProxy</target>
        </trans-unit>
        <trans-unit id="f6b935ab337145efdeadda28cae18aa89a845e36" translate="yes" xml:space="preserve">
          <source>Unit</source>
          <target state="translated">Unit</target>
        </trans-unit>
        <trans-unit id="6e47e918985f3919c21cc4a5d827ef9eada3d607" translate="yes" xml:space="preserve">
          <source>Unit return type. Must not be nullable</source>
          <target state="translated">单位返回类型。不得为空。</target>
        </trans-unit>
        <trans-unit id="0cc244abccf5ca3308a1494c12878b0d0e26feea" translate="yes" xml:space="preserve">
          <source>Unit-returning functions</source>
          <target state="translated">单位回报功能</target>
        </trans-unit>
        <trans-unit id="4e0950ee26dcc7da4ca806b4b340177a815e5066" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, the names of functions and modules can be &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;mangled&lt;/a&gt; in the generated JavaScript code. To keep such functions from elimination, use the mangled names in the &lt;code&gt;keep&lt;/code&gt; arguments as they appear in the generated JavaScript code.</source>
          <target state="translated">除非另有说明，否则函数和模块的名称可以在生成的JavaScript代码中进行&lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;修饰&lt;/a&gt;。为了避免消除此类功能，请在 &lt;code&gt;keep&lt;/code&gt; 参数中使用变形的名称，因为它们出现在生成的JavaScript代码中。</target>
        </trans-unit>
        <trans-unit id="e885d6886100fb26b71f7747ee932dbb05e71ce7" translate="yes" xml:space="preserve">
          <source>Unless you're working on a library, omit redundant modifiers (e.g. &lt;code&gt;public&lt;/code&gt;).</source>
          <target state="translated">除非您使用的是库，否则请省略多余的修饰符（例如 &lt;code&gt;public&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8feafcdb2005e6ef556074da45e878f1b7bc1d3a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; it does not intercept continuation.</source>
          <target state="translated">与&lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;不同，它不会拦截继续。</target>
        </trans-unit>
        <trans-unit id="b5baaedd3e64f7be16b02c01618d1a48a2f53082" translate="yes" xml:space="preserve">
          <source>Unlike Java, Kotlin does not have a separate &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&quot;import static&quot;&lt;/a&gt; syntax; all of these declarations are imported using the regular &lt;code&gt;import&lt;/code&gt; keyword.</source>
          <target state="translated">与Java不同，Kotlin没有单独的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&amp;ldquo;导入静态&amp;rdquo;&lt;/a&gt;语法。所有这些声明都是使用常规 &lt;code&gt;import&lt;/code&gt; 关键字导入的。</target>
        </trans-unit>
        <trans-unit id="7e26e1701ff3fbdbd8ab214ddee2ab24ae9fb3e0" translate="yes" xml:space="preserve">
          <source>Unlike Java, block comments in Kotlin can be nested.</source>
          <target state="translated">与Java不同,Kotlin中的块注释可以嵌套。</target>
        </trans-unit>
        <trans-unit id="d71d4e303da5f24db04f06a7b993b10b6d2cf202" translate="yes" xml:space="preserve">
          <source>Unlike Python, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; is an expression: the last expression of the &lt;code&gt;try&lt;/code&gt; block (if it succeeds) or the chosen &lt;code&gt;catch&lt;/code&gt; block becomes the result value (&lt;code&gt;finally&lt;/code&gt; doesn't affect the result), so we can refactor the function body above to:</source>
          <target state="translated">与Python不同， &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 是一个表达式： &lt;code&gt;try&lt;/code&gt; 块的最后一个表达式（如果成功）或所选的 &lt;code&gt;catch&lt;/code&gt; 块成为结果值（ &lt;code&gt;finally&lt;/code&gt; 不会影响结果），因此我们可以将上面的函数体重构为：</target>
        </trans-unit>
        <trans-unit id="9ffcb8e6d8c0e1886c9139362bf8a80448f390b9" translate="yes" xml:space="preserve">
          <source>Unlike a queue, a channel can be closed to indicate that no more elements are coming. On the receiver side it is convenient to use a regular &lt;code&gt;for&lt;/code&gt; loop to receive elements from the channel.</source>
          <target state="translated">与队列不同，可以关闭通道以指示不再有元素。在接收器端，使用常规的 &lt;code&gt;for&lt;/code&gt; 循环从通道接收元素很方便。</target>
        </trans-unit>
        <trans-unit id="79736268c87ef812b5a0caf77be57b249d138010" translate="yes" xml:space="preserve">
          <source>Unlike docstrings, KDoc blocks are not available to the program at runtime.</source>
          <target state="translated">与docstrings不同,KDoc块在程序运行时是不可用的。</target>
        </trans-unit>
        <trans-unit id="9e77ba9444bad622fec50b4242ad0088f476d99f" translate="yes" xml:space="preserve">
          <source>Unlike other pointers, the parameters of type &lt;code&gt;const char*&lt;/code&gt; are represented as a Kotlin &lt;code&gt;String&lt;/code&gt;. So it is possible to pass any Kotlin string to a binding expecting a C string.</source>
          <target state="translated">与其他指针不同， &lt;code&gt;const char*&lt;/code&gt; 类型的参数表示为Kotlin &lt;code&gt;String&lt;/code&gt; 。因此可以将任何Kotlin字符串传递给需要C字符串的绑定。</target>
        </trans-unit>
        <trans-unit id="cd3405f910e07d811413c0ab883fbacf2fe2d5fb" translate="yes" xml:space="preserve">
          <source>Unlike sources that can be fixed by hand in the worst case, binaries are a lot harder to migrate, and this makes backwards compatibility very important in the case of binaries. Incompatible changes to binaries can make updates very uncomfortable and thus should be introduced with even more care than those in the source language syntax.</source>
          <target state="translated">与源码不同,源码在最坏的情况下可以通过手工修复,而二进制文件则更难迁移,这使得向后兼容在二进制文件的情况下非常重要。对二进制文件的不兼容修改会让更新变得非常不舒服,因此在引入时应该比源语言语法中的修改更加谨慎。</target>
        </trans-unit>
        <trans-unit id="71ea4413722e85a3b020d9ed01e939aac7d2c7c0" translate="yes" xml:space="preserve">
          <source>Unlike the overload that accepts an argument of type &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;, this function does not compare this string and the specified &lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt; in a synchronized block.</source>
          <target state="translated">与接受类型为&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;的参数的重载不同，此函数不会在同步块中比较此字符串和指定的&lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="418fd8181d764c26cb6aebed80be5ec76fed83e8" translate="yes" xml:space="preserve">
          <source>Unsafe mode is intended for most performance critical operations, where object graph ownership is expected to be correct (such as application debugged earlier in &lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt; mode), just transfers ownership without further checks.</source>
          <target state="translated">不安全模式适用于大多数对性能至关重要的操作，在这些操作中，期望对象图的所有权是正确的（例如之前在&lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt;模式下调试的应用程序），而无需进一步检查即可转移所有权。</target>
        </trans-unit>
        <trans-unit id="eb25c274c554703f1d6ac7eff8cabedc73b12953" translate="yes" xml:space="preserve">
          <source>UnsafeVariance</source>
          <target state="translated">UnsafeVariance</target>
        </trans-unit>
        <trans-unit id="cfba46d6859cfbbcea2df0d333b94927ce585d13" translate="yes" xml:space="preserve">
          <source>Unsigned arithmetics</source>
          <target state="translated">无符号算术</target>
        </trans-unit>
        <trans-unit id="5c5289ec1ae0731b7a3321d477acd024a60473b2" translate="yes" xml:space="preserve">
          <source>Unsigned integers</source>
          <target state="translated">无符号整数</target>
        </trans-unit>
        <trans-unit id="5b676d18e8ccf61f5e227df4adab6b4ac25f32fd" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">自Kotlin 1.3起，无符号整数才可用，目前尚处于&lt;em&gt;实验阶段&lt;/em&gt;。看到细节&lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;的参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3f300d5a964ee1dfe6f01eeb8815de2c1adedd0" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details in the &lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">自Kotlin 1.3起，无符号整数才可用，并且当前处于&lt;a href=&quot;evolution/components-stability&quot;&gt;Beta中&lt;/a&gt;。看到细节&lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;的参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b747e738f03e7ea5b53d3e97fc3d06bb2fdd5460" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">自Kotlin 1.3起，无符号类型才可用，目前尚处于&lt;em&gt;试验阶段&lt;/em&gt;。请参阅&lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;下面的&lt;/a&gt;详细信息</target>
        </trans-unit>
        <trans-unit id="2d65bd8aeb4b2e88a04a2f25ed0b812fa94ab0cb" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details &lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">无符号类型仅自Kotlin 1.3起可用，并且当前处于&lt;a href=&quot;evolution/components-stability&quot;&gt;Beta中&lt;/a&gt;。请参阅&lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;下面的&lt;/a&gt;详细信息</target>
        </trans-unit>
        <trans-unit id="c69f19b70030748472412cf013c7f8262fa5cc73" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another experimental feature, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">无符号类型是使用另一个实验功能（即&lt;a href=&quot;inline-classes&quot;&gt;内联类）实现的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="963c1b3d4bd7cb3c897cb1ca5167eb9af57242de" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another feature that's not yet stable, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">无符号类型是使用尚不稳定的另一种功能（即&lt;a href=&quot;inline-classes&quot;&gt;内联类）实现的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22647f2117d5ec2026da9b7edc1161d8603f0593" translate="yes" xml:space="preserve">
          <source>Unsigned types support most of the operations of their signed counterparts.</source>
          <target state="translated">无符号类型支持其对应的有符号类型的大部分操作。</target>
        </trans-unit>
        <trans-unit id="a84f8397c523a0f7323640840daf25c5d28f242d" translate="yes" xml:space="preserve">
          <source>Unsound smartcasts on enum members</source>
          <target state="translated">对枚举成员进行无声智能广播</target>
        </trans-unit>
        <trans-unit id="fb52c13a5d3c511932c9721a05a0f30bebc8f773" translate="yes" xml:space="preserve">
          <source>Unsupported</source>
          <target state="translated">Unsupported</target>
        </trans-unit>
        <trans-unit id="d6b9cc70af4626956ac004db8653f110603b7231" translate="yes" xml:space="preserve">
          <source>UnsupportedOperationException</source>
          <target state="translated">UnsupportedOperationException</target>
        </trans-unit>
        <trans-unit id="2ce01f081a0318f94ee11d34764838aaa22a8009" translate="yes" xml:space="preserve">
          <source>Unused declarations can appear in cases like:</source>
          <target state="translated">未使用的声明可能出现在这样的情况下。</target>
        </trans-unit>
        <trans-unit id="7d866719de20162a43b046be2b1dd937f0e0c8b0" translate="yes" xml:space="preserve">
          <source>Unzip the standalone compiler into a directory and optionally add the &lt;code&gt;bin&lt;/code&gt; directory to the system path. The &lt;code&gt;bin&lt;/code&gt; directory contains the scripts needed to compile and run Kotlin on Windows, OS X and Linux.</source>
          <target state="translated">将独立的编译器解压缩到目录中，然后选择将 &lt;code&gt;bin&lt;/code&gt; 目录添加到系统路径中。该 &lt;code&gt;bin&lt;/code&gt; 目录包含编译和运行在Windows，OS X和Linux上运行科特林所需的脚本。</target>
        </trans-unit>
        <trans-unit id="ab7b8830d7d19c631f4db7f0e7cccdc5fc99c4ae" translate="yes" xml:space="preserve">
          <source>Update Gradle</source>
          <target state="translated">更新Gradle</target>
        </trans-unit>
        <trans-unit id="bd35499f667636f0205aff356fc79aa271c4a159" translate="yes" xml:space="preserve">
          <source>Update the application</source>
          <target state="translated">更新应用程序</target>
        </trans-unit>
        <trans-unit id="756c6de970516b187b891362c635541de1071978" translate="yes" xml:space="preserve">
          <source>Update to version A (where the change is announced)</source>
          <target state="translated">更新到版本A(宣布变更的地方)。</target>
        </trans-unit>
        <trans-unit id="a8909313fb96928caf2b3605836e51265cd9382c" translate="yes" xml:space="preserve">
          <source>Update to version B (where the change happens)</source>
          <target state="translated">更新到B版(发生变化的地方)。</target>
        </trans-unit>
        <trans-unit id="bc69b0f01bd4bf2a5762f9802698425322ca8ecc" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">更新该地图将指定映射键/值对&lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb9919809e0edbf2ce222896374072b2a1f62288" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">更新该地图将指定映射键/值对&lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9592e59ae4a1ea78ffeef819217ff2d297efc8bf" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">更新该地图将指定映射键/值对&lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ea39222df240b93c342df8ff54a9cb5e6582800" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">更新该地图将指定映射键/值对&lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="d63c48198d515b24d1b1b235598c3c48c2a4be5a" translate="yes" xml:space="preserve">
          <source>Updating Gradle Scripts</source>
          <target state="translated">更新Gradle脚本</target>
        </trans-unit>
        <trans-unit id="408c0db23a4308cddf6a6e9ce2a0a6679db93544" translate="yes" xml:space="preserve">
          <source>Updating elements</source>
          <target state="translated">更新要素</target>
        </trans-unit>
        <trans-unit id="5db2b695ba29ebd7f0ca8dec803b6b54c73ec2a6" translate="yes" xml:space="preserve">
          <source>Upper bounds</source>
          <target state="translated">上限</target>
        </trans-unit>
        <trans-unit id="6fe7e1ccf58a63e3bc126e60c26bcc1a9fac8e17" translate="yes" xml:space="preserve">
          <source>Upper bounds, or generic constraints imposed on this type parameter. See the &lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">上限或对此类型参数施加的一般约束。有关更多信息，请参阅&lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin语言文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="034e0e826c171bc69a42734bf5f512ba3665a32d" translate="yes" xml:space="preserve">
          <source>Usage of the &lt;code&gt;!!&lt;/code&gt; operator that is described below;</source>
          <target state="translated">的用法 &lt;code&gt;!!&lt;/code&gt; 如下所述的运算符；</target>
        </trans-unit>
        <trans-unit id="e1820bd9f032e11eff310c40682c9835a9eb3203" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as a warning.</source>
          <target state="translated">使用过时的元素将被报告为警告。</target>
        </trans-unit>
        <trans-unit id="8a6da2a0224bff4d0cdbf931eb3f79ea3c663d17" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as an error.</source>
          <target state="translated">使用过时的元素将被报告为错误。</target>
        </trans-unit>
        <trans-unit id="2f2278b9118c021e0836f33b45c4b344bc07faf3" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">除非给出了带有&lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt;批注的显式选择加入，例如 &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; 或带有 &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; 编译器选项，否则此类API的使用将被报告为警告。</target>
        </trans-unit>
        <trans-unit id="5b2bd12dd174680813870a73e531a53b2704ad9f" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; annotation, e.g. &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">除非使用&lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt;批注（例如 &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt; 或 &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; 编译器选项）明确选择加入，否则将此类API的使用报告为警告。</target>
        </trans-unit>
        <trans-unit id="17a2b4afa5d97d07993ae00f2065c3a2c91e4e36" translate="yes" xml:space="preserve">
          <source>Usages of such annotations will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../../kotlin/-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalJsExport::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.js.ExperimentalJsExport&lt;/code&gt; compiler option is given.</source>
          <target state="translated">除非给出了带有&lt;a href=&quot;../../kotlin/-opt-in/index&quot;&gt;OptIn&lt;/a&gt;注释的显式选择加入，例如 &lt;code&gt;@OptIn(ExperimentalJsExport::class)&lt;/code&gt; 或带有 &lt;code&gt;-Xopt-in=kotlin.js.ExperimentalJsExport&lt;/code&gt; 编译器选项，否则此类注释的使用将作为警告报告。</target>
        </trans-unit>
        <trans-unit id="5461bf95a53302a7c5df48274f6a4f3517903597" translate="yes" xml:space="preserve">
          <source>Usages of this annotation require an explicit compilation argument to be specified: either &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; or &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt;.</source>
          <target state="translated">使用此批注需要指定一个显式的编译参数： &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; 或 &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="070afea0c959ac4ab2122b78be879a1236b7d5f2" translate="yes" xml:space="preserve">
          <source>Use 4 spaces for indentation. Do not use tabs.</source>
          <target state="translated">使用4个空格进行缩进。不要使用制表符。</target>
        </trans-unit>
        <trans-unit id="505b02e2c68810a100167ed2394b7b09d07536b9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Kotlin from Swift&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Swift的Kotlin&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="259f61d0fe4d9980f69dcb9a143f67a783be3566" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; function to describe a conditional effect that happens in such case.</source>
          <target state="translated">使用&lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt;函数来描述在这种情况下发生的条件效应。</target>
        </trans-unit>
        <trans-unit id="7b3d7f2e06019f3ce17f9b7609b4e12a0a852225" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt;, &lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt; or &lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp&lt;/a&gt; extension functions to instantiate a &lt;code&gt;FileTreeWalk&lt;/code&gt; instance.</source>
          <target state="translated">使用&lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt;，&lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt;或&lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp&lt;/a&gt;扩展功能可实例化 &lt;code&gt;FileTreeWalk&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="24479d1c98fbbe2aeb0187678fa3eb554ac97484" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/bintray/gradle-bintray-plugin/issues/229#issuecomment-473123891&quot;&gt;a workaround for the Bintray plugin&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/bintray/gradle-bintray-plugin/issues/229#issuecomment-473123891&quot;&gt;对Bintray插件&lt;/a&gt;使用解决方法</target>
        </trans-unit>
        <trans-unit id="855c22b8caa56aad8a88d87618784ee61265712d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;apply&lt;/code&gt; for code blocks that don't return a value and mainly operate on the members of the receiver object. The common case for &lt;code&gt;apply&lt;/code&gt; is the object configuration. Such calls can be read as &amp;ldquo;&lt;em&gt;apply the following assignments to the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">使用 &lt;code&gt;apply&lt;/code&gt; 代码块没有返回值，主要是操作上的接收器对象的成员。 &lt;code&gt;apply&lt;/code&gt; 的常见情况是对象配置。此类调用可以理解为&amp;ldquo; &lt;em&gt;将以下分配应用于对象&amp;rdquo;。&lt;/em&gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="6ba975b0b8793e55988fa1e5cd1c3f8baae89326" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;arguments {}&lt;/code&gt; block to pass arguments to annotation processors:</source>
          <target state="translated">使用 &lt;code&gt;arguments {}&lt;/code&gt; 块将参数传递给注释处理器：</target>
        </trans-unit>
        <trans-unit id="9068946a50ad967859350bf76f77d127a3ad6ba3" translate="yes" xml:space="preserve">
          <source>Use C function pointer from Kotlin</source>
          <target state="translated">使用Kotlin的C函数指针。</target>
        </trans-unit>
        <trans-unit id="8d59d0d06987ce05b43d207e59345cd58bf6234b" translate="yes" xml:space="preserve">
          <source>Use Gradle 6.0 and above to generate wrapper (&lt;code&gt;gradle wrapper&lt;/code&gt;) in the project root directory to generate &lt;code&gt;gradlew&lt;/code&gt;, &lt;code&gt;gradlew.bat&lt;/code&gt;, and &lt;code&gt;gradle/wrapper/gradle-wrapper.jar&lt;/code&gt;.</source>
          <target state="translated">使用Gradle 6.0及更高 &lt;code&gt;gradle wrapper&lt;/code&gt; 在项目根目录中生成包装器（gradle wrapper）以生成 &lt;code&gt;gradlew&lt;/code&gt; ， &lt;code&gt;gradlew.bat&lt;/code&gt; 和 &lt;code&gt;gradle/wrapper/gradle-wrapper.jar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f14c4d527695edd872c7fe2172a6db2f31e9728" translate="yes" xml:space="preserve">
          <source>Use Kotlin from node.js with CommonJS</source>
          <target state="translated">用CommonJS从node.js中使用Kotlin。</target>
        </trans-unit>
        <trans-unit id="7955d34ca487ac99a425deedc1ddb62d16416242" translate="yes" xml:space="preserve">
          <source>Use Kotlin in the browser with AMD</source>
          <target state="translated">在浏览器中使用AMD的Kotlin</target>
        </trans-unit>
        <trans-unit id="80ebd15dbf9fc53c163f2e8494fee09225815763" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;string template&lt;/a&gt; for your reversed name by adding a dollar sign &lt;code&gt;$&lt;/code&gt; and enclosing it in curly braces &amp;ndash; &lt;code&gt;${state.name.reversed()}&lt;/code&gt;.</source>
          <target state="translated">通过添加美元符号 &lt;code&gt;$&lt;/code&gt; 并将其括在花括号&amp;ndash; &lt;code&gt;${state.name.reversed()}&lt;/code&gt; 为反向名称使用&lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;字符串模板&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2449126f023eebada4dc8166f2d086abc1f70c85" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;string template&lt;/a&gt; to insert your name length into the string by adding a dollar sign &lt;code&gt;$&lt;/code&gt; and enclosing it in curly braces &amp;ndash; &lt;code&gt;${it.length}&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is the default name of a &lt;a href=&quot;../../reference/coding-conventions#lambda-parameters&quot;&gt;lambda parameter&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;字符串模板&lt;/a&gt;，通过添加美元符号 &lt;code&gt;$&lt;/code&gt; 并将其括在花括号&amp;ndash; &lt;code&gt;${it.length}&lt;/code&gt; ，将名称长度插入字符串中。 &lt;code&gt;it&lt;/code&gt; 是&lt;a href=&quot;../../reference/coding-conventions#lambda-parameters&quot;&gt;lambda参数&lt;/a&gt;的默认名称。</target>
        </trans-unit>
        <trans-unit id="567ed77b3fedba236234b46ed9dd13b2639d5a1d" translate="yes" xml:space="preserve">
          <source>Use a Kotlin Gradle project as a CocoaPods dependency</source>
          <target state="translated">使用Kotlin Gradle项目作为CocoaPods的依赖性</target>
        </trans-unit>
        <trans-unit id="dad9d5856fb71823437fdf612d7806d4ef4bcde8" translate="yes" xml:space="preserve">
          <source>Use a custom JDK home directory to include into the classpath if it differs from the default &lt;code&gt;JAVA_HOME&lt;/code&gt;.</source>
          <target state="translated">如果自定义JDK主目录与默认的 &lt;code&gt;JAVA_HOME&lt;/code&gt; 不同，请使用它来将其包含在类路径中。</target>
        </trans-unit>
        <trans-unit id="5dafba398135044480a3e13e8cf827e6d5239bcb" translate="yes" xml:space="preserve">
          <source>Use a function returning nullable value:</source>
          <target state="translated">使用函数返回nullable值。</target>
        </trans-unit>
        <trans-unit id="09ab22034a8c650e65b27de7b44cb4d61caf9b2b" translate="yes" xml:space="preserve">
          <source>Use a string template by adding a dollar sign &lt;code&gt;$&lt;/code&gt; before this variable name directly in the text output like this &amp;ndash; &lt;code&gt;$name&lt;/code&gt;.</source>
          <target state="translated">通过在这样的文本输出中直接在此变量名之前添加美元符号 &lt;code&gt;$&lt;/code&gt; 来使用字符串模板- &lt;code&gt;$name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6761a777f295b6258dc7a19c0a25a2a4cc06a051" translate="yes" xml:space="preserve">
          <source>Use any members that don't mention the star-projected type parameter(s) at all</source>
          <target state="translated">使用任何没有提及星形预测类型参数的成员。</target>
        </trans-unit>
        <trans-unit id="02c711d6a5cfe540ce71589b8b208d49d3883457" translate="yes" xml:space="preserve">
          <source>Use any members that return the star-projected type parameter(s), but the return type will appear to be &lt;code&gt;Any?&lt;/code&gt; (unless the type parameter is constrained, in which case you'll get the type mentioned in the constraint)</source>
          <target state="translated">使用任何返回星形投影类型参数的成员，但是返回类型将显示为&amp;ldquo; &lt;code&gt;Any?&lt;/code&gt; （除非类型参数受到约束，在这种情况下，您将获得约束中提到的类型）</target>
        </trans-unit>
        <trans-unit id="14a29ba383c84d15925a42f871530f52904ae908" translate="yes" xml:space="preserve">
          <source>Use cases</source>
          <target state="translated">使用案例</target>
        </trans-unit>
        <trans-unit id="6914afc57d4eceefab3ce74c4e34c13830de00b1" translate="yes" xml:space="preserve">
          <source>Use dynamic to interact with libraries</source>
          <target state="translated">使用动态与库互动</target>
        </trans-unit>
        <trans-unit id="a696c211088879b039bc564a3a89ee0e5d5cf819" translate="yes" xml:space="preserve">
          <source>Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.</source>
          <target state="translated">自由使用扩展函数。每当你有一个主要作用于一个对象的函数时,考虑把它变成一个接受该对象作为接收器的扩展函数。为了尽量减少API污染,在合理的情况下限制扩展函数的可见性。必要时,使用本地扩展函数、成员扩展函数或具有私有可见性的顶层扩展函数。</target>
        </trans-unit>
        <trans-unit id="d507109a798498dbaa1e633727d124b6d6bc26b0" translate="yes" xml:space="preserve">
          <source>Use for APIs which have a third-party implementation available at runtime.</source>
          <target state="translated">用于在运行时有第三方实现的API。</target>
        </trans-unit>
        <trans-unit id="3f1d8d5003fdff477f08dfe445e9b40450048a1d" translate="yes" xml:space="preserve">
          <source>Use for dependencies needed for the internal logic of a module.</source>
          <target state="translated">用于模块内部逻辑所需的依赖关系。</target>
        </trans-unit>
        <trans-unit id="f46a150eeba438f84a49eada07a259f489c6609a" translate="yes" xml:space="preserve">
          <source>Use four spaces for indentation. Do not use tabs.</source>
          <target state="translated">使用四个空格进行缩进。不要使用制表符。</target>
        </trans-unit>
        <trans-unit id="ce69d8e8477848e488f670533689cb83c9f8c099" translate="yes" xml:space="preserve">
          <source>Use it &lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;from Android app&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;在Android应用中&lt;/a&gt;使用它</target>
        </trans-unit>
        <trans-unit id="62f9973d0d21db3635e8a7ac730a624b82c527d3" translate="yes" xml:space="preserve">
          <source>Use kotlinx.html to generate HTML</source>
          <target state="translated">使用kotlinx.html生成HTML。</target>
        </trans-unit>
        <trans-unit id="c9f5118d1f54f80362016bfd5b442c56f51dfc9b" translate="yes" xml:space="preserve">
          <source>Use native libraries in the hierarchical structure</source>
          <target state="translated">在层次结构中使用本地库</target>
        </trans-unit>
        <trans-unit id="7f896877d7535f3235fee51d8eb8bb2fc4692498" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for constructor parameters.</source>
          <target state="translated">对构造参数使用常规缩进(4个空格)。</target>
        </trans-unit>
        <trans-unit id="8e22c1db7346b432b927919ebe9e716628c63ef8" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for function parameters.</source>
          <target state="translated">函数参数使用常规缩进(4个空格)。</target>
        </trans-unit>
        <trans-unit id="b28f6c3f00f4a4b985821c624ebe6f5d2ab53f74" translate="yes" xml:space="preserve">
          <source>Use regular indent (four spaces) for constructor parameters.</source>
          <target state="translated">对构造参数使用常规缩进(四个空格)。</target>
        </trans-unit>
        <trans-unit id="9f39c73e1f23d3754cec94f86de325d9e4b9a4f1" translate="yes" xml:space="preserve">
          <source>Use target shortcuts</source>
          <target state="translated">使用目标快捷键</target>
        </trans-unit>
        <trans-unit id="6356c2b337336539cb098b460ea9fc43a2a742aa" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.text/replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt; function to remove the empty spaces in the name.</source>
          <target state="translated">使用&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.text/replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt;函数删除名称中的空白。</target>
        </trans-unit>
        <trans-unit id="72171ae8b75ba095394479592bf8ca1cc4cab18c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../../api/latest/jvm/stdlib/stdlib/kotlin.io/println&quot;&gt;&lt;code&gt;println()&lt;/code&gt;&lt;/a&gt; function to print computing status and the result of multiplication to the output.</source>
          <target state="translated">使用&lt;a href=&quot;../../../api/latest/jvm/stdlib/stdlib/kotlin.io/println&quot;&gt; &lt;code&gt;println()&lt;/code&gt; &lt;/a&gt;函数可将计算状态和相乘结果打印到输出中。</target>
        </trans-unit>
        <trans-unit id="be7280e72c76af98308a3c66e2b7e24f9cc56702" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; function to await the computation result.</source>
          <target state="translated">使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt; &lt;code&gt;await()&lt;/code&gt; &lt;/a&gt;函数等待计算结果。</target>
        </trans-unit>
        <trans-unit id="0461db73580d6d4278fffb255e74938d931ed12e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;&lt;code&gt;async()&lt;/code&gt;&lt;/a&gt; function to create coroutines that compute deferred values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt; &lt;code&gt;async()&lt;/code&gt; &lt;/a&gt;函数创建协程，以计算延迟值 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6065d1c978fbee3b2ff226845a77482cccebc712" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; function to imitate CPU-consuming blocking code. It suspends the coroutine for 100 ms without blocking the thread.</source>
          <target state="translated">使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt;函数模仿占用CPU的阻塞代码。它在不阻塞线程的情况下将协程暂停100 ms。</target>
        </trans-unit>
        <trans-unit id="b591373cb35b1a0f6e2219e8ca5964a4f1c5a083" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; function to imitate CPU-consuming code. It suspends the coroutine for 300 ms without blocking the thread.</source>
          <target state="translated">使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt;函数来模仿占用CPU的代码。它在不阻塞线程的情况下将协程暂停300 ms。</target>
        </trans-unit>
        <trans-unit id="c33adc7173a74761298cf96415d2790cf72a0ec3" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;&lt;code&gt;runBlocking()&lt;/code&gt;&lt;/a&gt; block to wrap a coroutine.</source>
          <target state="translated">使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt; &lt;code&gt;runBlocking()&lt;/code&gt; &lt;/a&gt;块包装协程。</target>
        </trans-unit>
        <trans-unit id="50099ad72d8ea21daa614b797c104f31da58f3d2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;countDistinctCharacters()&lt;/code&gt; function to count the unique letters in your name.</source>
          <target state="translated">使用 &lt;code&gt;countDistinctCharacters()&lt;/code&gt; 函数计算名称中的唯一字母。</target>
        </trans-unit>
        <trans-unit id="4a252bcad831096a6694a845390d272ffaa5046b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;plugin&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;maven-publish&lt;/code&gt; Gradle&lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;插件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2153a3c57b5ac237e2457368e65faee188870aa7" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;until&lt;/code&gt; function to loop over an open range:</source>
          <target state="translated">使用 &lt;code&gt;until&lt;/code&gt; 功能可在一个开放范围内循环：</target>
        </trans-unit>
        <trans-unit id="0bd4c99e44de0d3ffdb3c45eb15b74d7b4c2b386" translate="yes" xml:space="preserve">
          <source>Use the IR backend</source>
          <target state="translated">使用红外后端</target>
        </trans-unit>
        <trans-unit id="9e774b3c689a7ceab89fb14ac0440aed57436890" translate="yes" xml:space="preserve">
          <source>Use the Kotlin dynamic library from C</source>
          <target state="translated">使用C语言的Kotlin动态库</target>
        </trans-unit>
        <trans-unit id="44f7acf29bd5c28fb7d8d6e6f897b376b75ea2f3" translate="yes" xml:space="preserve">
          <source>Use the boxed version of an inline class in return type position for covariant and generic-specialized overrides</source>
          <target state="translated">在返回类型位置使用盒装版本的内联类,用于共变量和通用专用覆盖。</target>
        </trans-unit>
        <trans-unit id="4f2625d939200fe0f3767b996a1eaa8c5f1f235d" translate="yes" xml:space="preserve">
          <source>Use the following factory methods to declare elements of the &lt;code&gt;binaries&lt;/code&gt; collection.</source>
          <target state="translated">使用以下工厂方法声明 &lt;code&gt;binaries&lt;/code&gt; 集合的元素。</target>
        </trans-unit>
        <trans-unit id="fca17390ef51588303bcc0395c954faa0b511dcd" translate="yes" xml:space="preserve">
          <source>Use the intention from the IDE to include the missing import line:</source>
          <target state="translated">使用来自IDE的意图,包括缺少的导入行。</target>
        </trans-unit>
        <trans-unit id="c9fe0e8ecff640eabedf59913fdfab4613b76bf4" translate="yes" xml:space="preserve">
          <source>Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of &lt;code&gt;Boolean&lt;/code&gt; type, unless the meaning of all parameters is absolutely clear from context.</source>
          <target state="translated">当方法采用相同原始类型的多个参数或 &lt;code&gt;Boolean&lt;/code&gt; 类型的参数时，请使用命名参数语法，除非从上下文中绝对清楚所有参数的含义。</target>
        </trans-unit>
        <trans-unit id="09617aa736694d6bc881574c01e808ebeb4fb7c7" translate="yes" xml:space="preserve">
          <source>Use the path to the Java runtime version 1.8 or 11 for the &lt;em&gt;Gradle JVM&lt;/em&gt; field. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or &lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/&lt;/a&gt; for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">在&lt;em&gt;Gradle JVM&lt;/em&gt;字段中使用Java运行时版本1.8或11的路径。请查看&lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt;或&lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/，&lt;/a&gt;以获得最佳的JRE，OpenJDK或JDK发行版。</target>
        </trans-unit>
        <trans-unit id="b686514332051bdffa546563fa862bdb9f30b3de" translate="yes" xml:space="preserve">
          <source>Use the scope function &lt;a href=&quot;../../reference/scope-functions#let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; to run the function within the object context.</source>
          <target state="translated">使用作用域函数&lt;a href=&quot;../../reference/scope-functions#let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt;在对象上下文中运行该函数。</target>
        </trans-unit>
        <trans-unit id="efe23756e108375f4f234fa62c62b1a3192f2334" translate="yes" xml:space="preserve">
          <source>Use the shared Kotlin library &lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;from iOS app&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;iOS应用程序中&lt;/a&gt;共享的Kotlin库</target>
        </trans-unit>
        <trans-unit id="bdbe6eb3123e18a3df48280aadc1acf4ad69906d" translate="yes" xml:space="preserve">
          <source>Use the specified paths as base directories. Base directories are used for calculating relative paths in the source map.</source>
          <target state="translated">使用指定的路径作为基础目录。基础目录用于计算源地图中的相对路径。</target>
        </trans-unit>
        <trans-unit id="0e87c063aea31b41f461fabf9570d133ee5c90c0" translate="yes" xml:space="preserve">
          <source>Use the standard library function &lt;code&gt;reversed()&lt;/code&gt; to reverse your name.</source>
          <target state="translated">使用标准库函数 &lt;code&gt;reversed()&lt;/code&gt; 可以反转您的名字。</target>
        </trans-unit>
        <trans-unit id="f9852a84398c6954bfc8ee0f3c95a700b78ffafb" translate="yes" xml:space="preserve">
          <source>Use the types &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; and &lt;code&gt;KotlinCompileCommon&lt;/code&gt; for the JS and Common targets, accordingly.</source>
          <target state="translated">相应地，将类型 &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; 和 &lt;code&gt;KotlinCompileCommon&lt;/code&gt; 用于JS和Common目标。</target>
        </trans-unit>
        <trans-unit id="ba751862add42b30b98929193759e854e81a1255" translate="yes" xml:space="preserve">
          <source>Use this function for projects that contain both Java and Kotlin source files. Note that the default source directories for Java sources don't follow the Java plugin's defaults. Instead, they are derived from the Kotlin source sets. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are &lt;code&gt;src/jvmMain/java&lt;/code&gt; (for production Java sources) and &lt;code&gt;src/jvmTest/java&lt;/code&gt; for test Java sources. Learn how to &lt;a href=&quot;mpp-configure-compilations#include-java-sources-in-jvm-compilations&quot;&gt;include Java sources in JVM compilations&lt;/a&gt;.</source>
          <target state="translated">对于同时包含Java和Kotlin源文件的项目，请使用此功能。请注意，Java源的默认源目录不遵循Java插件的默认目录。相反，它们来自Kotlin源集。例如，如果JVM目标的默认名称为 &lt;code&gt;jvm&lt;/code&gt; ，则路径为 &lt;code&gt;src/jvmMain/java&lt;/code&gt; （对于生产Java源代码）和 &lt;code&gt;src/jvmTest/java&lt;/code&gt; (对于测试Java源代码）。了解如何&lt;a href=&quot;mpp-configure-compilations#include-java-sources-in-jvm-compilations&quot;&gt;在JVM编译中包括Java源代码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e03be997274e2b63af86d76fc7bf98a2088dbc4" translate="yes" xml:space="preserve">
          <source>Use ts2kt to interact with libraries</source>
          <target state="translated">使用ts2kt与图书馆交互</target>
        </trans-unit>
        <trans-unit id="106c8f3de5148d18865fbc697fa5d5cdeecc28c4" translate="yes" xml:space="preserve">
          <source>Use-site variance: Type projections</source>
          <target state="translated">用地变更。类型预测</target>
        </trans-unit>
        <trans-unit id="e2476b5675d923b0014d65b682cc8d7c7848dd3a" translate="yes" xml:space="preserve">
          <source>UseExperimental</source>
          <target state="translated">UseExperimental</target>
        </trans-unit>
        <trans-unit id="5948d8b97ec29bff3672a84e9d432b919624dc55" translate="yes" xml:space="preserve">
          <source>Used both during compilation and at runtime and is exported to library consumers.</source>
          <target state="translated">在编译时和运行时使用,并输出给库消费者。</target>
        </trans-unit>
        <trans-unit id="8ac3c810c772a41c5e178656755fecd6523a14fa" translate="yes" xml:space="preserve">
          <source>Used during compilation and at runtime for the current module, but is not exposed for compilation of other modules depending on the one with the `implementation` dependency.</source>
          <target state="translated">在编译过程中和运行时对当前模块使用,但在编译其他模块时不暴露,这取决于有 &quot;implementation &quot;依赖的模块。</target>
        </trans-unit>
        <trans-unit id="73310b7839f171659371cc3680a3ce118bf8dc6d" translate="yes" xml:space="preserve">
          <source>Used for compilation of the current module and is not available at runtime nor during compilation of other modules.</source>
          <target state="translated">用于当前模块的编译,在运行时或其他模块的编译过程中不可用。</target>
        </trans-unit>
        <trans-unit id="06c609f5a60b09cc00048be8eb23732ff873a513" translate="yes" xml:space="preserve">
          <source>Used only with &lt;code&gt;-Xjvm-default=compatibility|all-compatibility&lt;/code&gt;.</source>
          <target state="translated">仅与 &lt;code&gt;-Xjvm-default=compatibility|all-compatibility&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27716b3301b8979f846685e09578fc4d968ef31" translate="yes" xml:space="preserve">
          <source>User-defined contracts</source>
          <target state="translated">用户定义的合同</target>
        </trans-unit>
        <trans-unit id="2546ff21c7035e67f381dd0185abecc195a459e2" translate="yes" xml:space="preserve">
          <source>Users of Kotlin on the Server Side</source>
          <target state="translated">服务器端的Kotlin用户</target>
        </trans-unit>
        <trans-unit id="47181373df2bd78be6294c0add1dbe6339b4681b" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">将提供的&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用指定的语言环境替换指定的参数而获得的字符串。</target>
        </trans-unit>
        <trans-unit id="3391e8d9489d92fff425335dfe200993b486d0ea" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">将提供的&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用默认语言环境替换指定参数而获得的字符串。</target>
        </trans-unit>
        <trans-unit id="704ebbde6e2b32eeb1c2f67d4e693a35f67af0fd" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">将提供的&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用指定的语言环境替换指定的参数而获得的字符串。</target>
        </trans-unit>
        <trans-unit id="aac052dc5a6c0e7fbd28f5bc3a043e4ecb32e5f5" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">将提供的&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用指定的语言环境替换指定的参数而获得的字符串。如果&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt;为 &lt;code&gt;null&lt;/code&gt; ,则不应用任何本地化。</target>
        </trans-unit>
        <trans-unit id="0dd3b1deb8f1d7bfb8c12c5a14f2ab32a21d65af" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">将提供的&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用默认语言环境替换指定参数而获得的字符串。</target>
        </trans-unit>
        <trans-unit id="7a75a8ac839c741b8d08dc9c1deee0d88e4f979c" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">将提供的&lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用指定的语言环境替换指定的参数而获得的字符串。</target>
        </trans-unit>
        <trans-unit id="9d3ac3ea11a7f22b1d758a682e71f98cc029fa36" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">将提供的&lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用默认语言环境替换指定参数而获得的字符串。</target>
        </trans-unit>
        <trans-unit id="10dc34a2059cb8159f0a883b5dd86e0bc6137e07" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">将提供的&lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用指定的语言环境替换指定的参数而获得的字符串。</target>
        </trans-unit>
        <trans-unit id="f82d324c322c9f91adb6f0983572279a3329ac89" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">将提供的&lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用指定的语言环境替换指定的参数而获得的字符串。如果&lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt;为 &lt;code&gt;null&lt;/code&gt; ,则不应用任何本地化。</target>
        </trans-unit>
        <trans-unit id="65bfa57761f82862cfd81ebd5b8013f5e01aaad7" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">将提供的&lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;格式&lt;/a&gt;用作格式字符串，并返回通过使用默认语言环境替换指定参数而获得的字符串。</target>
        </trans-unit>
        <trans-unit id="42fcdb82df9fab88befa785457e65d1af96aa239" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">使用该字符串作为格式字符串,并返回一个使用默认locale替换指定参数获得的字符串。</target>
        </trans-unit>
        <trans-unit id="3f6866db3da817af6ed67e3dae70c3ec02de81e2" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">使用这个字符串作为格式字符串,并返回一个用指定的locale替换指定参数得到的字符串。</target>
        </trans-unit>
        <trans-unit id="6484cdf608c52e6f223f86ea931137798547136f" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">将此字符串用作格式字符串，并返回通过使用指定的语言环境替换指定的参数而获得的字符串。如果&lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt;为 &lt;code&gt;null&lt;/code&gt; ,则不应用任何本地化。</target>
        </trans-unit>
        <trans-unit id="a6a6e896b98588b46d5642885789c195ba9adc2a" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">将此字符串用作格式字符串，并返回通过使用指定的语言环境替换指定的参数而获得的字符串。如果&lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt;为 &lt;code&gt;null&lt;/code&gt; ,则不应用任何本地化。</target>
        </trans-unit>
        <trans-unit id="4e62e86755452347944ce24bc99c8763bab8c2b5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;receive&lt;/a&gt; suspending function we can receive &lt;em&gt;either&lt;/em&gt; from one channel or the other. But &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; expression allows us to receive from &lt;em&gt;both&lt;/em&gt; simultaneously using its &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; clauses:</source>
          <target state="translated">使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;接收&lt;/a&gt;暂停功能，我们可以接收&lt;em&gt;任一&lt;/em&gt;从一个通道或其他。但是&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt;表达式允许我们使用其&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt;子句同时接收&lt;em&gt;两者&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="08f3f41e2b1efe6c5dce0e5fec64099ed03bdf2b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;lambdas&quot;&gt;higher-order functions&lt;/a&gt; imposes certain runtime penalties: each function is an object, and it captures a closure, i.e. those variables that are accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead.</source>
          <target state="translated">使用&lt;a href=&quot;lambdas&quot;&gt;高阶函数会&lt;/a&gt;带来一定的运行时损失：每个函数都是一个对象，并且它捕获一个闭包，即在函数主体中访问的那些变量。内存分配（用于函数对象和类）和虚拟调用会引入运行时开销。</target>
        </trans-unit>
        <trans-unit id="491e6c994c3baf4cc8af39219068162e74e38931" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;::Foo&lt;/code&gt;, the zero-argument constructor of the class Foo, we can simply call it like this:</source>
          <target state="translated">使用 &lt;code&gt;::Foo&lt;/code&gt; ，即Foo类的零参数构造函数，我们可以像这样简单地调用它：</target>
        </trans-unit>
        <trans-unit id="df28902f080c8e95c2e047504754d8fc98471dfb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; inside &lt;code&gt;when&lt;/code&gt; expressions included in loops</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 表达式包含在循环中时，使用 &lt;code&gt;break&lt;/code&gt; 并在内部 &lt;code&gt;continue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1288042cdb0bedb4cedef04fffbbc6421151560c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;when&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;when&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="b4d45feb4cce668fd7098830e83bf2557a415c16" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;if&lt;/em&gt; as an expression:</source>
          <target state="translated">使用&lt;em&gt;if&lt;/em&gt;作为表达式：</target>
        </trans-unit>
        <trans-unit id="7956ce97b97e87d0f55a6ea0cc6e4e05373fcf15" translate="yes" xml:space="preserve">
          <source>Using AMD</source>
          <target state="translated">使用AMD</target>
        </trans-unit>
        <trans-unit id="aae897c446cafc25370dcce91792d5e6dfa9a087" translate="yes" xml:space="preserve">
          <source>Using Ant</source>
          <target state="translated">使用蚂蚁</target>
        </trans-unit>
        <trans-unit id="44ab2ab05f55d2266ffc569dcf7fc124a65679b4" translate="yes" xml:space="preserve">
          <source>Using C Interop and libcurl for an App</source>
          <target state="translated">在App中使用C语言的Interop和libcurl。</target>
        </trans-unit>
        <trans-unit id="a59cc5aadf82954e8f0283bd3dfcaae639efbadd" translate="yes" xml:space="preserve">
          <source>Using C library from Kotlin/Native</source>
          <target state="translated">使用Kotlin/Native的C库</target>
        </trans-unit>
        <trans-unit id="d678710e9135632a43d33f3d5da6bf72dddacbe5" translate="yes" xml:space="preserve">
          <source>Using CommonJS</source>
          <target state="translated">使用CommonJS</target>
        </trans-unit>
        <trans-unit id="e42f7c8cd0e8730768cbb184338fabc772fadfd5" translate="yes" xml:space="preserve">
          <source>Using Dynamic</source>
          <target state="translated">使用动态</target>
        </trans-unit>
        <trans-unit id="cbe69bb9e7692bc07945db15e10c51c3ee312db2" translate="yes" xml:space="preserve">
          <source>Using Generated Headers from C</source>
          <target state="translated">使用从C语言生成的标题</target>
        </trans-unit>
        <trans-unit id="27c679a18ee1d9ed93d7a66b728665e446e0b013" translate="yes" xml:space="preserve">
          <source>Using Gradle</source>
          <target state="translated">使用Gradle</target>
        </trans-unit>
        <trans-unit id="17fbd0b7659b724c4b82377e5e5b6176a4a4d7c0" translate="yes" xml:space="preserve">
          <source>Using Gradle Kotlin DSL</source>
          <target state="translated">使用Gradle Kotlin DSL</target>
        </trans-unit>
        <trans-unit id="71d5b086b763a415271837d49bf05b383ed34176" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA Build System</source>
          <target state="translated">使用IntelliJ IDEA构建系统</target>
        </trans-unit>
        <trans-unit id="be4003165448a14831defb73021c979f0b4b46d4" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA debugger, you can dig deeper into each coroutine to debug your code.</source>
          <target state="translated">使用IntelliJ IDEA调试器,您可以深入挖掘每个coroutine来调试您的代码。</target>
        </trans-unit>
        <trans-unit id="81cb9f3916c8314e916dfe4f86e42b9f41066648" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA we can easily run and debug the application in any of the possible application servers defined such as Tomcat, Glassfish or WildFly. In this case we're going to use Tomcat which has previously &lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;been defined as an application server in IntelliJ IDEA&lt;/a&gt;. Note that application server support is only available in IntelliJ IDEA Ultimate.</source>
          <target state="translated">使用IntelliJ IDEA，我们可以轻松地在定义的任何可能的应用程序服务器（例如Tomcat，Glassfish或WildFly）中运行和调试应用程序。在这种情况下，我们将使用以前&lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;在IntelliJ IDEA中定义为应用程序服务器的&lt;/a&gt; Tomcat 。请注意，仅在IntelliJ IDEA Ultimate中提供应用程序服务器支持。</target>
        </trans-unit>
        <trans-unit id="4709ae28ff320dfabd65f0869103704aedfcf674" translate="yes" xml:space="preserve">
          <source>Using JNI with Kotlin</source>
          <target state="translated">在Kotlin中使用JNI</target>
        </trans-unit>
        <trans-unit id="2bbc39d0664d569562a91137d4d90178cf23c617" translate="yes" xml:space="preserve">
          <source>Using Kotlin Android Extensions</source>
          <target state="translated">使用Kotlin Android扩展</target>
        </trans-unit>
        <trans-unit id="b022874247f51c944909afa759f623b6478ca32e" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android Development</source>
          <target state="translated">使用Kotlin进行Android开发</target>
        </trans-unit>
        <trans-unit id="60a1392d0c8d40966f3ba2738ae5f701e549f245" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android development, you can benefit from:</source>
          <target state="translated">使用Kotlin进行Android开发,你可以从中受益。</target>
        </trans-unit>
        <trans-unit id="aaf246aafd7124667a554d398075e5452aa83ed4" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Server-side Development</source>
          <target state="translated">使用Kotlin进行服务器端开发</target>
        </trans-unit>
        <trans-unit id="2b0fb5591f02bcbebcc2bd375ac8a71d601338b0" translate="yes" xml:space="preserve">
          <source>Using Kotlin/Native Targets</source>
          <target state="translated">使用Kotlin/Native Targets</target>
        </trans-unit>
        <trans-unit id="936b968752b32f197dc84832341b3f607b83a027" translate="yes" xml:space="preserve">
          <source>Using Maven</source>
          <target state="translated">使用Maven</target>
        </trans-unit>
        <trans-unit id="ef7af2346af2c37f7e6ee428aab1c98075a789a9" translate="yes" xml:space="preserve">
          <source>Using SharedCode from Android</source>
          <target state="translated">从Android中使用SharedCode</target>
        </trans-unit>
        <trans-unit id="603ab8042b5d1c17d5b50d529fa9db7d658d860a" translate="yes" xml:space="preserve">
          <source>Using Struct and Union Types from Kotlin</source>
          <target state="translated">从Kotlin中使用Struct和联合类型</target>
        </trans-unit>
        <trans-unit id="6e4c13998b5f91e0846d37840959ab407900c453" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">使用 &lt;code&gt;for&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="4fe7e2f58454fbb71457b9ce1e7ce104ef338243" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;while&lt;/code&gt; loop</source>
          <target state="translated">使用 &lt;code&gt;while&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="29dae43467cc406389583f725ed8cb7bcc1c247d" translate="yes" xml:space="preserve">
          <source>Using a Kotlin/JavaScript library.</source>
          <target state="translated">使用Kotlin/JavaScript库。</target>
        </trans-unit>
        <trans-unit id="d3383ee07c516c1fa1802c63fcedaaefadd8e48c" translate="yes" xml:space="preserve">
          <source>Using a callable reference to an existing declaration:</source>
          <target state="translated">使用对现有声明的可调用引用。</target>
        </trans-unit>
        <trans-unit id="197fb49229d662d3379f8cffecb5a8e470235340" translate="yes" xml:space="preserve">
          <source>Using a code block within a function literal, in one of the forms:</source>
          <target state="translated">在函数文字中使用代码块,形式之一。</target>
        </trans-unit>
        <trans-unit id="a7c34a78b0f5530284b929714a111e0120a19cb8" translate="yes" xml:space="preserve">
          <source>Using a standard build tool</source>
          <target state="translated">使用标准的构建工具</target>
        </trans-unit>
        <trans-unit id="6825ce8ddbdb846319b075044bc1aefd9c058144" translate="yes" xml:space="preserve">
          <source>Using artifacts built with Kotlin 1.4.x in a Kotlin 1.3.x project</source>
          <target state="translated">在Kotlin 1.3.x项目中使用Kotlin 1.4.x构建的工件。</target>
        </trans-unit>
        <trans-unit id="5a3edbb4ebc2b355b2a8f195be33f5a03ead3d30" translate="yes" xml:space="preserve">
          <source>Using bindings</source>
          <target state="translated">使用绑定</target>
        </trans-unit>
        <trans-unit id="92c77c8ea60a2ffe09d3b8484f979577fe3fe402" translate="yes" xml:space="preserve">
          <source>Using cinterop</source>
          <target state="translated">使用cinterop</target>
        </trans-unit>
        <trans-unit id="6f335b7fd336f32636cf82fea33e6e5a118b4de7" translate="yes" xml:space="preserve">
          <source>Using collections</source>
          <target state="translated">使用收藏</target>
        </trans-unit>
        <trans-unit id="ce4da38f792e511ab4d77c2e6a228d9a0f717f17" translate="yes" xml:space="preserve">
          <source>Using conditional expressions</source>
          <target state="translated">使用条件表达式</target>
        </trans-unit>
        <trans-unit id="918641690842037efdc3f921e9d2a03a1b94d884" translate="yes" xml:space="preserve">
          <source>Using conditional statements</source>
          <target state="translated">使用条件语句</target>
        </trans-unit>
        <trans-unit id="3fc2b300fe4dab146a33f883986c605263212bcf" translate="yes" xml:space="preserve">
          <source>Using experimental APIs</source>
          <target state="translated">使用实验性API</target>
        </trans-unit>
        <trans-unit id="ebd9b5845829e10c5bf4bfdb285f0143f1b0cc17" translate="yes" xml:space="preserve">
          <source>Using extension functions</source>
          <target state="translated">使用扩展功能</target>
        </trans-unit>
        <trans-unit id="b252910d4e8badbe4bca9df0c30fd5478c5c630b" translate="yes" xml:space="preserve">
          <source>Using in CLI</source>
          <target state="translated">在CLI中使用</target>
        </trans-unit>
        <trans-unit id="30f417bc0504e6fe1552d975f144e48529a622bd" translate="yes" xml:space="preserve">
          <source>Using in Gradle</source>
          <target state="translated">在Gradle中使用</target>
        </trans-unit>
        <trans-unit id="987fbf118a45b1d5fc70735f1b4a9cb07d729a9e" translate="yes" xml:space="preserve">
          <source>Using in Maven</source>
          <target state="translated">在Maven中使用</target>
        </trans-unit>
        <trans-unit id="b58b6328c1df079d0d8cccee5234ec40deb70287" translate="yes" xml:space="preserve">
          <source>Using infix functions</source>
          <target state="translated">使用下位函数</target>
        </trans-unit>
        <trans-unit id="a915c033f5e92eb86f6eb764c7d3fbfec97399c7" translate="yes" xml:space="preserve">
          <source>Using instances of a custom class that implements a function type as an interface:</source>
          <target state="translated">使用实现函数类型的自定义类的实例作为接口。</target>
        </trans-unit>
        <trans-unit id="b7d1f08b0755e4efecc6155b06410d6d8f47dd0c" translate="yes" xml:space="preserve">
          <source>Using kotlinx.html</source>
          <target state="translated">使用kotlinx.html</target>
        </trans-unit>
        <trans-unit id="e33a647f9d820f02525a9e589cf38c7cb15aa9e1" translate="yes" xml:space="preserve">
          <source>Using lambda expressions to filter and map collections:</source>
          <target state="translated">使用lambda表达式来过滤和映射集合。</target>
        </trans-unit>
        <trans-unit id="85b9a9b134d068b76d1d9da5eba9082360a75376" translate="yes" xml:space="preserve">
          <source>Using loops</source>
          <target state="translated">使用循环</target>
        </trans-unit>
        <trans-unit id="e702f70d153e5bb48504257ee3c4806c305f3fd0" translate="yes" xml:space="preserve">
          <source>Using modules</source>
          <target state="translated">使用模块</target>
        </trans-unit>
        <trans-unit id="9af9fabd79c052500b25a5c07039f994d4da9bd7" translate="yes" xml:space="preserve">
          <source>Using nullable &lt;code&gt;Boolean&lt;/code&gt; values in conditions</source>
          <target state="translated">在条件中使用可为空的 &lt;code&gt;Boolean&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="d6a1a404256e60f476abcfdb633a3c534e236959" translate="yes" xml:space="preserve">
          <source>Using nullable values and checking for &lt;em&gt;null&lt;/em&gt;</source>
          <target state="translated">使用可为空的值并检查是否为&lt;em&gt;空&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="872ffc0740cd8cd114c0bd134533ae0bef8b975c" translate="yes" xml:space="preserve">
          <source>Using our favorite editor, we create a new file called &lt;em&gt;library.kt&lt;/em&gt;:</source>
          <target state="translated">使用我们最喜欢的编辑器，我们创建一个名为&lt;em&gt;library.kt&lt;/em&gt;的新文件：</target>
        </trans-unit>
        <trans-unit id="4b0f18fbc913dc4d928de83407023cd4eadce18c" translate="yes" xml:space="preserve">
          <source>Using packages from npm</source>
          <target state="translated">使用npm的软件包</target>
        </trans-unit>
        <trans-unit id="550a8f8d20b2e8584106d065339f4d4da1689dfc" translate="yes" xml:space="preserve">
          <source>Using ranges</source>
          <target state="translated">使用范围</target>
        </trans-unit>
        <trans-unit id="51f179a48f07181aae2f460999afe3b38f8238e7" translate="yes" xml:space="preserve">
          <source>Using scope functions apply/with/run/also/let</source>
          <target state="translated">使用范围函数apply/with/run/o/let。</target>
        </trans-unit>
        <trans-unit id="3ec4dda09fda63d9abb963027b78f1d3b6ffe21e" translate="yes" xml:space="preserve">
          <source>Using string templates</source>
          <target state="translated">使用字符串模板</target>
        </trans-unit>
        <trans-unit id="4e76a46a35a0080ea05cb7befbedfc77e476e034" translate="yes" xml:space="preserve">
          <source>Using strings</source>
          <target state="translated">使用字符串</target>
        </trans-unit>
        <trans-unit id="e23bbbb1e9be4eb1c796c8553364504fb8af04eb" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; result type, means we can only return all the values at once. To represent the stream of values that are being asynchronously computed, we can use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html&quot;&gt;&lt;code&gt;Flow&amp;lt;Int&amp;gt;&lt;/code&gt;&lt;/a&gt; type just like we would use the &lt;code&gt;Sequence&amp;lt;Int&amp;gt;&lt;/code&gt; type for synchronously computed values:</source>
          <target state="translated">使用 &lt;code&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; 结果类型，意味着我们只能一次返回所有值。为了表示异步计算的值流，我们可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html&quot;&gt; &lt;code&gt;Flow&amp;lt;Int&amp;gt;&lt;/code&gt; &lt;/a&gt;类型，就像我们对同步计算的值使用 &lt;code&gt;Sequence&amp;lt;Int&amp;gt;&lt;/code&gt; 类型一样：</target>
        </trans-unit>
        <trans-unit id="18148327a2ccfbb8e71316dac9304b16aaccd2b3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin for building &lt;a href=&quot;multiplatform&quot;&gt;multiplatform projects&lt;/a&gt; is described in &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;Building Multiplatform Projects with Gradle&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 的插件用于构建&lt;a href=&quot;multiplatform&quot;&gt;多平台项目&lt;/a&gt;被描述在&lt;a href=&quot;building-mpp-with-gradle&quot;&gt;建设多项目摇篮&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="662526f9ec265672a8f5eadc1e458fce90d93089" translate="yes" xml:space="preserve">
          <source>Using the C Function Pointer from Kotlin</source>
          <target state="translated">使用Kotlin的C函数指针</target>
        </trans-unit>
        <trans-unit id="3b3c88f2622b6c11af48eeafb534d5bf373c1268" translate="yes" xml:space="preserve">
          <source>Using the Code from Objective-C</source>
          <target state="translated">使用Objective-C的代码</target>
        </trans-unit>
        <trans-unit id="2751cf504326591f0615360e90b35bf6098ad931" translate="yes" xml:space="preserve">
          <source>Using the Code from Swift</source>
          <target state="translated">使用Swift的代码</target>
        </trans-unit>
        <trans-unit id="d94748ae1985e15517523c51bbe68be1dc451c79" translate="yes" xml:space="preserve">
          <source>Using the Kotlin/JS IR compiler</source>
          <target state="translated">使用Kotlin/JS IR编译器</target>
        </trans-unit>
        <trans-unit id="51e131a08f907def09c45df11a971dfb390d42ac" translate="yes" xml:space="preserve">
          <source>Using the command line to run scripts</source>
          <target state="translated">使用命令行运行脚本</target>
        </trans-unit>
        <trans-unit id="0dde1829bc0d42dfa9d3d99dc69c6583462ddf28" translate="yes" xml:space="preserve">
          <source>Using the tool &lt;code&gt;ts2kt&lt;/code&gt; (TypeScript to Kotlin) we can convert any &lt;code&gt;d.ts&lt;/code&gt; files to Kotlin. To install the tool we can use &lt;code&gt;npm&lt;/code&gt;</source>
          <target state="translated">使用工具 &lt;code&gt;ts2kt&lt;/code&gt; （TypeScript到Kotlin），我们可以将任何 &lt;code&gt;d.ts&lt;/code&gt; 文件转换为Kotlin。要安装该工具，我们可以使用 &lt;code&gt;npm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a89a0f28e4e5bf44543e1c9581c55c0e6aecc40d" translate="yes" xml:space="preserve">
          <source>Using trailing commas has several benefits:</source>
          <target state="translated">使用拖尾逗号有几个好处。</target>
        </trans-unit>
        <trans-unit id="4ebccac5de220cac33103fa30ac3780779ac2fcd" translate="yes" xml:space="preserve">
          <source>Using ts2kt to generate header files for Kotlin</source>
          <target state="translated">使用ts2kt为Kotlin生成头文件</target>
        </trans-unit>
        <trans-unit id="e0fbba9738442b4c0647e5831e5969871c4f6a2a" translate="yes" xml:space="preserve">
          <source>Using type checks and automatic casts</source>
          <target state="translated">使用类型检查和自动铸造</target>
        </trans-unit>
        <trans-unit id="d8d81e999a726d52e9414f74a35f368a368d19de" translate="yes" xml:space="preserve">
          <source>Usually these fields are private but they can be exposed in one of the following ways:</source>
          <target state="translated">通常这些字段是私有的,但它们可以通过以下方式之一被暴露。</target>
        </trans-unit>
        <trans-unit id="c1278d398657af96687576590c71d68b9a3f58aa" translate="yes" xml:space="preserve">
          <source>Usually, a native binary can be compiled as &lt;em&gt;debug&lt;/em&gt; with more debug information and fewer optimizations, and &lt;em&gt;release&lt;/em&gt; where optimizations are enabled and there is no (or at least less) debug information available.</source>
          <target state="translated">通常情况下，本机二进制可被编译为&lt;em&gt;调试&lt;/em&gt;提供更多的调试信息和更少的优化，并&lt;em&gt;释放&lt;/em&gt;其中优化被启用，也没有（或者至少以下）调试可用信息。</target>
        </trans-unit>
        <trans-unit id="12caefb8a5010ce40aa23c1ea29352f8837f75ed" translate="yes" xml:space="preserve">
          <source>Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it &lt;em&gt;unsafe&lt;/em&gt;. The unsafe cast in Kotlin is done by the infix operator &lt;em&gt;as&lt;/em&gt; (see &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;operator precedence&lt;/a&gt;):</source>
          <target state="translated">通常，如果无法进行强制转换，则强制转换运算符会引发异常。因此，我们称其为&lt;em&gt;不安全&lt;/em&gt;。在科特林不安全投是用管道符做&lt;em&gt;的&lt;/em&gt;（见&lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;运算符优先级&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="078efedb0f7a9297e4a66c7bf48c73578606e64d" translate="yes" xml:space="preserve">
          <source>Utility functions for concurrent programming.</source>
          <target state="translated">并发编程的实用功能。</target>
        </trans-unit>
        <trans-unit id="54a27f71a3926c933fffb4cc8fcd736d36aae00b" translate="yes" xml:space="preserve">
          <source>Utility functions for working with Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;streams&lt;/a&gt;.</source>
          <target state="translated">用于Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;流的&lt;/a&gt;实用程序功能。</target>
        </trans-unit>
        <trans-unit id="70a0023fe530c9e1dc6b5efd1156df2342cee154" translate="yes" xml:space="preserve">
          <source>Utility functions for working with the browser DOM.</source>
          <target state="translated">用于处理浏览器DOM的实用功能。</target>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="b48498a5cff3c4e7ce37b18fdd81413319dd4656" translate="yes" xml:space="preserve">
          <source>VALUE_PARAMETER</source>
          <target state="translated">VALUE_PARAMETER</target>
        </trans-unit>
        <trans-unit id="242cc9162b91c0b54499ac05fdd663dcea97e3ff" translate="yes" xml:space="preserve">
          <source>ValidityState</source>
          <target state="translated">ValidityState</target>
        </trans-unit>
        <trans-unit id="4ca51107e6a14998cd7631ba2234ead0b2f51037" translate="yes" xml:space="preserve">
          <source>Value arguments</source>
          <target state="translated">价值论据</target>
        </trans-unit>
        <trans-unit id="bc813f9a338f88bada03e57203025b97e72de98e" translate="yes" xml:space="preserve">
          <source>Value parameter of a function or a constructor</source>
          <target state="translated">函数或构造函数的参数值</target>
        </trans-unit>
        <trans-unit id="ae0d9f73010cf89531cbcdadc5148c931b0aba52" translate="yes" xml:space="preserve">
          <source>Values are &lt;em&gt;collected&lt;/em&gt; from the flow using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; function.</source>
          <target state="translated">值是&lt;em&gt;收集&lt;/em&gt;来自使用流&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;收集&lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="9d4b78efaf35ec9ac8ccb78b50e8f937f6c083fa" translate="yes" xml:space="preserve">
          <source>Values are &lt;em&gt;emitted&lt;/em&gt; from the flow using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html&quot;&gt;emit&lt;/a&gt; function.</source>
          <target state="translated">值&lt;em&gt;发射&lt;/em&gt;从使用流&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html&quot;&gt;EMIT&lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="ae7d4e58b65d5a70d4dfae24ee97f38d7c1a9ff0" translate="yes" xml:space="preserve">
          <source>Values can be updated. In turn, keys never change: once you add an entry, its key is constant.</source>
          <target state="translated">值是可以更新的。反过来,键值永远不会改变:一旦你添加了一个条目,它的键值就是不变的。</target>
        </trans-unit>
        <trans-unit id="83ce8efcd219286f9e80c1c630307f7c0a05ac1f" translate="yes" xml:space="preserve">
          <source>Values of an annotation instance are exposed as properties to Kotlin code:</source>
          <target state="translated">注释实例的值作为属性暴露在Kotlin代码中。</target>
        </trans-unit>
        <trans-unit id="e2e1116424b8a24a96cede1b506dcc3d11485f0b" translate="yes" xml:space="preserve">
          <source>VarType</source>
          <target state="translated">VarType</target>
        </trans-unit>
        <trans-unit id="42ec9490f36e6cae9913c4374b09e32237c707ad" translate="yes" xml:space="preserve">
          <source>Varargs and optional/named parameters</source>
          <target state="translated">Varargs和可选/命名参数</target>
        </trans-unit>
        <trans-unit id="10eea16b487acafb1da690a6fa932f924aadcf7a" translate="yes" xml:space="preserve">
          <source>Variable inspection</source>
          <target state="translated">可变检查</target>
        </trans-unit>
        <trans-unit id="342ee951b83918c9c708f1243be034edc6ba7220" translate="yes" xml:space="preserve">
          <source>Variable inspections for var variables works out of the box for primitive types. For non-primitive types there are custom pretty printers for lldb in &lt;code&gt;konan_lldb.py&lt;/code&gt;:</source>
          <target state="translated">var变量的变量检查对于基本类型开箱即用。对于非基本类型，在 &lt;code&gt;konan_lldb.py&lt;/code&gt; 中有用于lldb的自定义漂亮打印机：</target>
        </trans-unit>
        <trans-unit id="a018b33a39aac69fe200a8b99412d4c30ecc8054" translate="yes" xml:space="preserve">
          <source>Variable names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">变量名称应使用 &lt;code&gt;lowerCamelCase&lt;/code&gt; 而不是 &lt;code&gt;snake_case&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43edb35cae8befc5879d0b7aa2cd22c92255e5d7" translate="yes" xml:space="preserve">
          <source>Variable number of arguments (Varargs)</source>
          <target state="translated">可变参数数(Varargs)</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="eaac90ed072370b9f57426b726154a33050c4fed" translate="yes" xml:space="preserve">
          <source>Variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; get the values returned by &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt; called on elements of the collection.</source>
          <target state="translated">变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 获得在集合的元素上调用的 &lt;code&gt;component1()&lt;/code&gt; 和 &lt;code&gt;component2()&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="808412b58bbf8525d5dac7961edbdfc05c3db76a" translate="yes" xml:space="preserve">
          <source>Variables that can be reassigned use the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">可以重新分配的变量使用 &lt;code&gt;var&lt;/code&gt; 关键字：</target>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="1a91ea423a97d4a87943d588b081e7e38282531c" translate="yes" xml:space="preserve">
          <source>Variance directions</source>
          <target state="translated">差异指示</target>
        </trans-unit>
        <trans-unit id="5c16bf6df0ccb8c8f8d9897278f38f99a8d180ae" translate="yes" xml:space="preserve">
          <source>Variant generics</source>
          <target state="translated">变体属名</target>
        </trans-unit>
        <trans-unit id="48aeb525f24a17a17a2746ff3465033889ff970a" translate="yes" xml:space="preserve">
          <source>Various collections and sequences can be converted to flows using &lt;code&gt;.asFlow()&lt;/code&gt; extension functions.</source>
          <target state="translated">可以使用 &lt;code&gt;.asFlow()&lt;/code&gt; 扩展函数将各种集合和序列转换为流。</target>
        </trans-unit>
        <trans-unit id="7ed714f305f37a57ecb8473b7415dfab9db01f6a" translate="yes" xml:space="preserve">
          <source>Various utilities for working with strings and char sequences.</source>
          <target state="translated">用于处理字符串和字符序列的各种实用程序。</target>
        </trans-unit>
        <trans-unit id="280853b24c26b2f29a476f73ab7f87fbd08c6186" translate="yes" xml:space="preserve">
          <source>Vector128</source>
          <target state="translated">Vector128</target>
        </trans-unit>
        <trans-unit id="6c08e229ae1df722641eb28302211d6c86591e45" translate="yes" xml:space="preserve">
          <source>Vector128Var</source>
          <target state="translated">Vector128Var</target>
        </trans-unit>
        <trans-unit id="9ffb8650f3fdd46d87c18838f3017eda5ad872f4" translate="yes" xml:space="preserve">
          <source>Vector128VarOf</source>
          <target state="translated">Vector128VarOf</target>
        </trans-unit>
        <trans-unit id="288ce52d20fd503b110a72d86e9675e1c95e19eb" translate="yes" xml:space="preserve">
          <source>Verify the emulator configuration and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">验证仿真器配置，然后单击&amp;ldquo; &lt;strong&gt;完成&amp;rdquo;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="de621f8c2654b2397c981cb428da06adf04bb6fe" translate="yes" xml:space="preserve">
          <source>Versioned separately from the language</source>
          <target state="translated">与语文分开的版本</target>
        </trans-unit>
        <trans-unit id="84bee7b1488f1e88fea6081e11b80da21edf9ec4" translate="yes" xml:space="preserve">
          <source>VideoFacingModeEnum</source>
          <target state="translated">VideoFacingModeEnum</target>
        </trans-unit>
        <trans-unit id="fa871b63d316a5ccaf06d516a54da0961996827d" translate="yes" xml:space="preserve">
          <source>VideoResizeModeEnum</source>
          <target state="translated">VideoResizeModeEnum</target>
        </trans-unit>
        <trans-unit id="64fea40a0473c85795b9336e14b2b716b018b418" translate="yes" xml:space="preserve">
          <source>VideoTrack</source>
          <target state="translated">VideoTrack</target>
        </trans-unit>
        <trans-unit id="c02eab00438fffc417a6ac0aa9bb22fc06605beb" translate="yes" xml:space="preserve">
          <source>View binding</source>
          <target state="translated">查看装订</target>
        </trans-unit>
        <trans-unit id="db9fea7c8a56a15e997acc428b673797be1af865" translate="yes" xml:space="preserve">
          <source>View caching</source>
          <target state="translated">查看缓存</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="0d73e14a3fcddf8956a7da60bbcb1e077c95f7a0" translate="yes" xml:space="preserve">
          <source>Visibility Modifiers</source>
          <target state="translated">可见度修改器</target>
        </trans-unit>
        <trans-unit id="28ffb1b2d0c701707ce3c73f2c7cf4a513706777" translate="yes" xml:space="preserve">
          <source>Visibility is an aspect of a Kotlin declaration regulating where that declaration is accessible in the source code. Visibility can be changed with one of the following modifiers: &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">可见性是Kotlin声明的一个方面，规定了在源代码中可访问该声明的位置。可以使用以下修饰符之一更改可见性： &lt;code&gt;public&lt;/code&gt; ， &lt;code&gt;protected&lt;/code&gt; ， &lt;code&gt;internal&lt;/code&gt; ， &lt;code&gt;private&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="849b37d75d9e78cb34f760a7b86638406d0e4272" translate="yes" xml:space="preserve">
          <source>Visibility modifiers</source>
          <target state="translated">可见度修改器</target>
        </trans-unit>
        <trans-unit id="572b59949083550c2f89c909f2a69634e1647c72" translate="yes" xml:space="preserve">
          <source>Visibility modifiers are required for declarations if the default visibility exposes them to the public API. This helps ensure that no declarations are exposed to the public API unintentionally.</source>
          <target state="translated">如果默认的可见性将声明暴露给公共 API,则需要使用可见性修饰符。这有助于确保任何声明都不会无意中暴露给公共API。</target>
        </trans-unit>
        <trans-unit id="8ccb166e167967c0af7bc8270ccff3bc3f332444" translate="yes" xml:space="preserve">
          <source>Visibility modifiers can't be placed on local variables, since their visibility is always limited to the containing block.</source>
          <target state="translated">可见性修饰符不能放在局部变量上,因为它们的可见性总是被限制在包含的块上。</target>
        </trans-unit>
        <trans-unit id="6cd8f7e2419769693129b0c2082de4e40a0da3a3" translate="yes" xml:space="preserve">
          <source>Visibility of Top-level Declarations</source>
          <target state="translated">顶层声明的可见性</target>
        </trans-unit>
        <trans-unit id="b794e604145c856d9c96b2bfb79a673421c9cf64" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;internal&lt;/code&gt; modifier.</source>
          <target state="translated">用 &lt;code&gt;internal&lt;/code&gt; 修饰符标记的声明的可见性。</target>
        </trans-unit>
        <trans-unit id="63bf3a48e0f5fd4c5b7c9576056b33b03784b05d" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;private&lt;/code&gt; modifier.</source>
          <target state="translated">标有 &lt;code&gt;private&lt;/code&gt; 修饰符的声明的可见性。</target>
        </trans-unit>
        <trans-unit id="d02ce232d311d05d3099c6a996cbef8c4dd286f9" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;protected&lt;/code&gt; modifier.</source>
          <target state="translated">标有 &lt;code&gt;protected&lt;/code&gt; 修饰符的声明的可见性。</target>
        </trans-unit>
        <trans-unit id="dd1c739248ca96578cca7f9bfb547899b54a876f" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;public&lt;/code&gt; modifier, or with no modifier at all.</source>
          <target state="translated">标有 &lt;code&gt;public&lt;/code&gt; 修饰符或根本没有修饰符的声明的可见性。</target>
        </trans-unit>
        <trans-unit id="de706486df3bb39a3413cb5cbbb1d996126bda21" translate="yes" xml:space="preserve">
          <source>Visibility of this callable, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">此可调用对象的可见性；如果在Kotlin中无法表示其可见性，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dac6119f07007062b4875b1638bac8a721585f4a" translate="yes" xml:space="preserve">
          <source>Visibility of this class, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">此类的可见性；如果无法在Kotlin中表示其可见性，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aabca03bdef260f1cffd784ffe10c2b762503211" translate="yes" xml:space="preserve">
          <source>Visibility rules regarding complex class hierarchies with companion objects</source>
          <target state="translated">关于复杂的类层次结构与伴生对象的可见性规则。</target>
        </trans-unit>
        <trans-unit id="ac3022e113442db8619d262ae03fa9c0097a6e0d" translate="yes" xml:space="preserve">
          <source>Volatile</source>
          <target state="translated">Volatile</target>
        </trans-unit>
        <trans-unit id="74365b04f91d0aa9f5cfe78a2b9d8c743270db07" translate="yes" xml:space="preserve">
          <source>Volatiles are of no help</source>
          <target state="translated">挥发物无济于事</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="4e946026a7ff331eb2b9dc124f891817863bd199" translate="yes" xml:space="preserve">
          <source>WASM</source>
          <target state="translated">WASM</target>
        </trans-unit>
        <trans-unit id="25ca2ee13f635d58b0c2cff69efbc6a4f1b88f58" translate="yes" xml:space="preserve">
          <source>WASM32</source>
          <target state="translated">WASM32</target>
        </trans-unit>
        <trans-unit id="406538ae6cd24bca924c59857d3c75a306aa56eb" translate="yes" xml:space="preserve">
          <source>WATCHOS</source>
          <target state="translated">WATCHOS</target>
        </trans-unit>
        <trans-unit id="b9fac4aec6291b1c5ab0f9569e59e39d2636356c" translate="yes" xml:space="preserve">
          <source>WCString</source>
          <target state="translated">WCString</target>
        </trans-unit>
        <trans-unit id="c1cd547450ddf19820dbba6198904ce66087e598" translate="yes" xml:space="preserve">
          <source>WHITESPACE</source>
          <target state="translated">WHITESPACE</target>
        </trans-unit>
        <trans-unit id="2e31950e28a56c4fe6e7025b187b2fd4fefe4871" translate="yes" xml:space="preserve">
          <source>WINDOWS</source>
          <target state="translated">WINDOWS</target>
        </trans-unit>
        <trans-unit id="d9fff1c0dfb1298ad2bb377a3be85896a8fef6d6" translate="yes" xml:space="preserve">
          <source>Waiting for a job</source>
          <target state="translated">等待工作</target>
        </trans-unit>
        <trans-unit id="43754c49f6c1a5cc1ea3d54dbf166c296a415ea2" translate="yes" xml:space="preserve">
          <source>Warning! Annotating your API with &lt;code&gt;@JvmDefault&lt;/code&gt; has serious implications on binary compatibility. Make sure to carefully read the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;reference page&lt;/a&gt; before using &lt;code&gt;@JvmDefault&lt;/code&gt; in production.</source>
          <target state="translated">警告！使用 &lt;code&gt;@JvmDefault&lt;/code&gt; 注释API 会对二进制兼容性产生严重影响。在生产中使用 &lt;code&gt;@JvmDefault&lt;/code&gt; 之前，请确保仔细阅读&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;参考页&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d38e4cd7c43347e6b57a76218aeff28900c3be2" translate="yes" xml:space="preserve">
          <source>Warning: using reflection is usually the wrong way to solve problems in Kotlin! In particular, if you have several classes that all have some common properties/functions and you want to write a function that can take an instance of any of those classes and use those properties, the correct approach is to define an interface with the common properties/functions and make all the relevant classes implement it; the function can then take that interface as a parameter. If you don't control those classes, you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapter pattern&lt;/a&gt; and write wrapper classes that implement the interface - this is very easy thanks to Kotlin's &lt;a href=&quot;inheritance#delegation&quot;&gt;delegation feature&lt;/a&gt;. You can also get a lot of leverage out of using generics in clever ways.</source>
          <target state="translated">警告：使用反射通常是解决Kotlin问题的错误方法！特别是，如果您有几个都具有某些公共属性/功能的类，并且想要编写一个可以接受任何这些类的实例并使用这些属性的函数，则正确的方法是定义一个具有公共属性的接口/ functions，并使所有相关的类实现它；然后，该函数可以将该接口作为参数。如果您不控制这些类，则可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapter模式&lt;/a&gt;并编写实现该接口的包装器类-由于Kotlin的&lt;a href=&quot;inheritance#delegation&quot;&gt;委托功能，&lt;/a&gt;这非常容易。通过巧妙地使用泛型，您还可以获得很多优势。</target>
        </trans-unit>
        <trans-unit id="5869fc3835710be9dffa94b09164944fe6c00863" translate="yes" xml:space="preserve">
          <source>Warnings as errors</source>
          <target state="translated">作为错误的警告</target>
        </trans-unit>
        <trans-unit id="7d7a6c37ae0a89dc47c6393b7b23a560c9ff63a7" translate="yes" xml:space="preserve">
          <source>Watch for deprecation warnings in advance for the best update experience.</source>
          <target state="translated">为了获得最佳的更新体验,请提前关注废止警告。</target>
        </trans-unit>
        <trans-unit id="621508220c73315e0bfc68d68f589c562907f45d" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;SharedCode&lt;/code&gt; framework to the Xcode project. For that let's click on the root node of the &lt;em&gt;project navigator&lt;/em&gt; and select the &lt;em&gt;target&lt;/em&gt; settings. Next, we click on the &lt;code&gt;+&lt;/code&gt; in the &lt;em&gt;Embedded Binaries&lt;/em&gt; section, click &lt;em&gt;Add Other&amp;hellip;&lt;/em&gt; button in the dialog to choose the framework from the disk. We can point to the following folder:</source>
          <target state="translated">我们将 &lt;code&gt;SharedCode&lt;/code&gt; 框架添加到Xcode项目中。为此，我们单击&lt;em&gt;项目导航器的&lt;/em&gt;根节点，然后选择&lt;em&gt;目标&lt;/em&gt;设置。接下来，我们在&lt;em&gt;Embedded Binaries&lt;/em&gt;部分中单击 &lt;code&gt;+&lt;/code&gt; ，在对话框中单击&lt;em&gt;Add Other&amp;hellip;&lt;/em&gt;按钮，以从磁盘中选择框架。我们可以指向以下文件夹：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a9f25c8723418966c0e0b17f9549ea1ce5a5f99" translate="yes" xml:space="preserve">
          <source>We also need to use the &lt;em&gt;war&lt;/em&gt; plugin that helps us generate the corresponding WAR artifacts for running/deploying</source>
          <target state="translated">我们还需要使用&lt;em&gt;war&lt;/em&gt;插件来帮助我们生成相应的WAR工件以进行运行/部署</target>
        </trans-unit>
        <trans-unit id="8f769d9a3ee354265c33ea15ceda2db82197765c" translate="yes" xml:space="preserve">
          <source>We are just trying out an idea and want some users to play with it and give feedback. If it doesn't work out, we may drop it any minute.</source>
          <target state="translated">我们只是在尝试一个想法,想让一些用户来玩玩,给点反馈。如果不成功,我们可能随时会放弃它。</target>
        </trans-unit>
        <trans-unit id="f808d588d4d3fcebee5f5b3ff2c14b3f46e0e3a6" translate="yes" xml:space="preserve">
          <source>We are now migrating Kotlin/JVM and Kotlin/JS to the same IR. As a result, all three backends share a lot of logic and have a unified pipeline. This allows us to implement most features, optimizations, and bug fixes only once for all platforms. Both new IR-based back-ends are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;.</source>
          <target state="translated">我们现在将Kotlin / JVM和Kotlin / JS迁移到同一IR。结果，所有三个后端共享大量逻辑并具有统一的管道。这使我们对于所有平台仅实现一次大多数功能，优化和错误修复。两个新的基于IR的后端均位于&lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05a06031f1e06a7952c57e44121ca5e185850421" translate="yes" xml:space="preserve">
          <source>We are now ready to start coding the iOS application and to use the Kotlin code from it</source>
          <target state="translated">我们现在准备开始对iOS应用进行编码,并使用其中的Kotlin代码。</target>
        </trans-unit>
        <trans-unit id="cff8cb63586d851860fe613c1e521ee0461e4b2e" translate="yes" xml:space="preserve">
          <source>We are ready to use the &lt;code&gt;SharedCode&lt;/code&gt; library from our Android and iOS applications.</source>
          <target state="translated">我们准备使用Android和iOS应用程序中的 &lt;code&gt;SharedCode&lt;/code&gt; 库。</target>
        </trans-unit>
        <trans-unit id="14edea8060ff3b0350a868b06c73ba61ae235890" translate="yes" xml:space="preserve">
          <source>We are starting with an implementation for the JVM. Let's create a file &lt;code&gt;Base64.kt&lt;/code&gt; in &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; folder and provide a simple implementation, which delegates to &lt;code&gt;java.util.Base64&lt;/code&gt;:</source>
          <target state="translated">我们从JVM的实现开始。让我们在 &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; 文件夹中创建一个 &lt;code&gt;Base64.kt&lt;/code&gt; 文件，并提供一个简单的实现，该实现委托给 &lt;code&gt;java.util.Base64&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b38f2316b8757428d73f475d7c1fadf769b873b4" translate="yes" xml:space="preserve">
          <source>We are using &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; for this tutorial. Both the &lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;free and open source&lt;/a&gt; IntelliJ IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;Community Edition&lt;/a&gt; and IntelliJ IDEA Ultimate Edition work for this tutorial. We can download and install both of them from &lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt; if necessary. The Kotlin plugin is included with IntelliJ IDEA by default, but still, we need to make sure the Kotlin plugin version is 1.3.41 (or newer) in the &lt;em&gt;Settings&lt;/em&gt; or &lt;em&gt;Preferences&lt;/em&gt; dialog, under the Language &amp;amp; Frameworks | Kotlin section.</source>
          <target state="translated">我们在本教程中使用&lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt;。无论是&lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;免费和开源&lt;/a&gt;的IntelliJ IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;社区版&lt;/a&gt;和本教程的IntelliJ IDEA终极版工作。如果需要，我们可以从&lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt;下载并安装它们。默认情况下，IntelliJ IDEA包含Kotlin插件，但仍然需要确保在&amp;ldquo;语言和框架&amp;rdquo; | &lt;em&gt;&amp;ldquo;设置&amp;rdquo;&lt;/em&gt;或&lt;em&gt;&amp;ldquo;首选项&amp;rdquo;&lt;/em&gt;对话框中，确保Kotlin插件的版本为1.3.41（或更高版本）。科特林节。</target>
        </trans-unit>
        <trans-unit id="55cc632a1ea27e5e64ad2495a5384f62f48dbc86" translate="yes" xml:space="preserve">
          <source>We are using the &lt;code&gt;delay()&lt;/code&gt; function that's like &lt;code&gt;Thread.sleep()&lt;/code&gt;, but better: it &lt;em&gt;doesn't block a thread&lt;/em&gt;, but only suspends the coroutine itself. The thread is returned to the pool while the coroutine is waiting, and when the waiting is done, the coroutine resumes on a free thread in the pool.</source>
          <target state="translated">我们正在使用与 &lt;code&gt;Thread.sleep()&lt;/code&gt; 类似的 &lt;code&gt;delay()&lt;/code&gt; 函数，但更好：它&lt;em&gt;不会阻塞线程&lt;/em&gt;，而只是挂起协程本身。协程正在等待时，线程将返回到池中，等待完成后，协程将在池中的空闲线程上恢复。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da1efc61212d59164e482ecaadd2d5e755cb8ec9" translate="yes" xml:space="preserve">
          <source>We believe that a lot of users could use a much faster cycle, where critical compiler bug fixes arrive immediately, making the code more safe and correct. So, Kotlin 1.3 introduces &lt;em&gt;progressive&lt;/em&gt; compiler mode, which can be enabled by passing the argument &lt;code&gt;-progressive&lt;/code&gt; to the compiler.</source>
          <target state="translated">我们认为，许多用户可以使用更快的周期，在此周期内，关键的编译器错误修复程序会立即到达，从而使代码更安全，更正确。因此，Kotlin 1.3引入了&lt;em&gt;渐进式&lt;/em&gt;编译器模式，可以通过将参数 &lt;code&gt;-progressive&lt;/code&gt; 传递给编译器来启用。</target>
        </trans-unit>
        <trans-unit id="0e996e5615a264af995c203eaebe6185c018bf0a" translate="yes" xml:space="preserve">
          <source>We believe that the words &lt;strong&gt;in&lt;/strong&gt; and &lt;strong&gt;out&lt;/strong&gt; are self-explaining (as they were successfully used in C# for quite some time already), thus the mnemonic mentioned above is not really needed, and one can rephrase it for a higher purpose:</source>
          <target state="translated">我们认为&lt;strong&gt;in&lt;/strong&gt;和&lt;strong&gt;out&lt;/strong&gt;这两个词是不言自明的（因为它们已经在C＃中成功使用了相当长的时间），因此上面提到的助记符并不是真正需要的，可以将其改写为更高的目的：</target>
        </trans-unit>
        <trans-unit id="a4b5a076e237cd86b9569bc0bd72070895b09bdf" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;lib.exe&lt;/code&gt; from the toolchain to generate the static library wrapper &lt;code&gt;libnative.lib&lt;/code&gt; that automates the DLL usage from the code:</source>
          <target state="translated">我们从工具链中调用 &lt;code&gt;lib.exe&lt;/code&gt; 来生成静态库包装程序 &lt;code&gt;libnative.lib&lt;/code&gt; ，该包装程序可自动从代码中使用DLL：</target>
        </trans-unit>
        <trans-unit id="b380a7bf1b634600b0c261666fb452d97fe21714" translate="yes" xml:space="preserve">
          <source>We call Kotlin classes directly from Objective-C code. A Kotlin &lt;code&gt;object&lt;/code&gt; has the class method function &lt;code&gt;object&lt;/code&gt;, which allows us to get the only instance of the object and to call &lt;code&gt;Object&lt;/code&gt; methods on it. The widespread pattern is used to create an instance of the &lt;code&gt;Clazz&lt;/code&gt; class. We call the &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; on Objective-C. We may also use &lt;code&gt;[DemoClazz new]&lt;/code&gt; for constructors without parameters. Global declarations from the Kotlin sources are scoped under the &lt;code&gt;DemoLibKt&lt;/code&gt; class in Objective-C. All methods are turned into class methods of that class. The &lt;code&gt;strings&lt;/code&gt; function is turned into &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; function in Objective-C, we can pass &lt;code&gt;NSString&lt;/code&gt; directly to it. The return is visible as &lt;code&gt;NSString&lt;/code&gt; too.</source>
          <target state="translated">我们直接从Objective-C代码中调用Kotlin类。 Kotlin &lt;code&gt;object&lt;/code&gt; 具有类方法函数 &lt;code&gt;object&lt;/code&gt; ，这使我们能够获取对象的唯一实例并在其上调用 &lt;code&gt;Object&lt;/code&gt; 方法。广泛使用的模式用于创建 &lt;code&gt;Clazz&lt;/code&gt; 类的实例。我们在Objective-C上称为 &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; 。对于没有参数的构造函数，我们也可以使用 &lt;code&gt;[DemoClazz new]&lt;/code&gt; 。来自Kotlin来源的全局声明在Objective-C中的 &lt;code&gt;DemoLibKt&lt;/code&gt; 类之下。所有方法都变成该类的类方法。该 &lt;code&gt;strings&lt;/code&gt; 函数变成 &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; 在Objective-C中，我们可以直接将 &lt;code&gt;NSString&lt;/code&gt; 传递给它。返回也显示为 &lt;code&gt;NSString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6efbfc50d097338c67f6c25e5a2530e00802bbf1" translate="yes" xml:space="preserve">
          <source>We can also check a value for being &lt;em&gt;in&lt;/em&gt; or &lt;em&gt;!in&lt;/em&gt; a &lt;a href=&quot;ranges&quot;&gt;range&lt;/a&gt; or a collection:</source>
          <target state="translated">我们还可以检查&lt;a href=&quot;ranges&quot;&gt;范围&lt;/a&gt;或集合中&lt;em&gt;处于&lt;/em&gt;或&lt;em&gt;！中&lt;/em&gt;的值：</target>
        </trans-unit>
        <trans-unit id="6d48b261007df82564fff9e248b32f0b0877a7db" translate="yes" xml:space="preserve">
          <source>We can also run the project from the command line, without using IntelliJ IDEA Ultimate, if we apply the gretty plugin. In order to do this, we need to make the following changes to build.gradle:</source>
          <target state="translated">如果我们应用gretty插件,我们也可以在不使用IntelliJ IDEA Ultimate的情况下,从命令行运行项目。为了做到这一点,我们需要对build.gradle做如下修改。</target>
        </trans-unit>
        <trans-unit id="be71c4616ae57b989081464748078b992e6a499b" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; option.</source>
          <target state="translated">我们还可以看到如何通过 &lt;code&gt;sourceMap&lt;/code&gt; 选项进行指示来定义我们是否希望编译器为我们生成源映射。</target>
        </trans-unit>
        <trans-unit id="db36be1716cde1f09b5bb491a1d29f546a1af582" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; parameter.</source>
          <target state="translated">我们还可以看到如何通过 &lt;code&gt;sourceMap&lt;/code&gt; 参数来指示我们是否要定义编译器为我们生成源映射。</target>
        </trans-unit>
        <trans-unit id="b5bd60fd46fe6ea1c5b448761b2e310af9a2b34e" translate="yes" xml:space="preserve">
          <source>We can check whether an object conforms to a given type at runtime by using the &lt;code&gt;is&lt;/code&gt; operator or its negated form &lt;code&gt;!is&lt;/code&gt;:</source>
          <target state="translated">我们可以使用 &lt;code&gt;is&lt;/code&gt; 运算符或其取反形式 &lt;code&gt;!is&lt;/code&gt; 在运行时检查对象是否符合给定类型：</target>
        </trans-unit>
        <trans-unit id="80fca726c567776685be62a6f296ba802e4a0c48" translate="yes" xml:space="preserve">
          <source>We can choose to let &lt;code&gt;MotorVehicle&lt;/code&gt; implement that interface, since it's got the required members - but now we need to mark those members with &lt;code&gt;override&lt;/code&gt;, and we can remove &lt;code&gt;open&lt;/code&gt; since an overridden function is implicitly open:</source>
          <target state="translated">我们可以选择让 &lt;code&gt;MotorVehicle&lt;/code&gt; 的实现该接口，因为它有需要的成员-但是现在我们需要与这些成员标记 &lt;code&gt;override&lt;/code&gt; ，我们可以删除 &lt;code&gt;open&lt;/code&gt; 以来一个重写的功能是隐式打开：</target>
        </trans-unit>
        <trans-unit id="b29aa01092a4a2f64bc0e5bf97de56d6e4257337" translate="yes" xml:space="preserve">
          <source>We can click the file reference on the right to navigate directly to the corresponding statement. Alternatively, we can manually switch to the &lt;em&gt;Sources&lt;/em&gt; tab, and find the correct file in the file tree. Navigating to the Kotlin file actually shows us regular Kotlin code (as opposed to minified JavaScript):</source>
          <target state="translated">我们可以单击右侧的文件引用直接导航到相应的语句。或者，我们可以手动切换到&amp;ldquo;&lt;em&gt;源&amp;rdquo;&lt;/em&gt;选项卡，然后在文件树中找到正确的文件。导航到Kotlin文件实际上向我们展示了常规的Kotlin代码（与最小化的JavaScript相反）：</target>
        </trans-unit>
        <trans-unit id="3df63e38e36909132576c3c502bfc7296d767131" translate="yes" xml:space="preserve">
          <source>We can combine the declarative nature of the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html&quot;&gt;catch&lt;/a&gt; operator with a desire to handle all the exceptions, by moving the body of the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; operator into &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; and putting it before the &lt;code&gt;catch&lt;/code&gt; operator. Collection of this flow must be triggered by a call to &lt;code&gt;collect()&lt;/code&gt; without parameters:</source>
          <target state="translated">我们可以将&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html&quot;&gt;catch&lt;/a&gt;运算符的声明性与处理所有异常的愿望结合起来，方法是将&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt;运算符的主体移到&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt;并将其放在 &lt;code&gt;catch&lt;/code&gt; 运算符之前。必须通过不带参数的调用 &lt;code&gt;collect()&lt;/code&gt; 来触发此流的收集：</target>
        </trans-unit>
        <trans-unit id="6ab28e12a4329ff5188bb6bb1c34f1f3bf4ce258" translate="yes" xml:space="preserve">
          <source>We can configure the Kotlin compiler option to use any of these. The last option (UMD) will generate UMD and fallback to the other options if one is not available. Currently Kotlin compiler options are per IntelliJ IDEA project as opposed to a Kotlin module.</source>
          <target state="translated">我们可以将Kotlin编译器选项配置为使用其中的任何一个。最后一个选项(UMD)将生成UMD,如果没有一个选项,则回退到其他选项。目前Kotlin编译器选项是每个IntelliJ IDEA项目,而不是一个Kotlin模块。</target>
        </trans-unit>
        <trans-unit id="5b4c1b5549ed7b71f56b6d1ba48bd66bf46537dc" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with &quot;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">我们可以定义异步样式的函数，这些函数使用带有明确的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;引用的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;协程生成器&lt;em&gt;异步&lt;/em&gt;调用 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 和 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 。我们用&amp;ldquo; Async&amp;rdquo;后缀来命名此类函数，以突出显示以下事实：它们仅启动异步计算，并且需要使用所得的递延值来获得结果。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="452dc3c84f7cabd350d9558a57e866a1cf25ff79" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with the &quot;&amp;hellip;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">我们可以定义异步样式的函数，这些函数使用带有显式&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;引用的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;协程生成器&lt;em&gt;异步&lt;/em&gt;调用 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 和 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 。我们使用&amp;ldquo;&amp;hellip;Async&amp;rdquo;后缀来命名此类函数，以突出显示这样一个事实，即它们仅开始异步计算，并且需要使用所得的递延值来获得结果。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ecb356b303055242a64963a7b2a1f314c6be1d3" translate="yes" xml:space="preserve">
          <source>We can define custom accessors for a property. If we define a custom getter, it will be called every time we access the property (this allows us to implement a computed property). Here's an example of a custom getter:</source>
          <target state="translated">我们可以为一个属性定义自定义的访问器。如果我们定义了一个自定义的getter,它将在我们每次访问该属性时被调用(这允许我们实现一个计算属性)。下面是一个自定义getter的例子。</target>
        </trans-unit>
        <trans-unit id="b31aa9761950ea554c775fecf5e0c018baf882fd" translate="yes" xml:space="preserve">
          <source>We can easily call it directly (&lt;code&gt;isOdd(5)&lt;/code&gt;), but we can also use it as a function type value, e.g. pass it to another function. To do this, we use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">我们可以轻松地直接调用它（ &lt;code&gt;isOdd(5)&lt;/code&gt; ），但是我们也可以将其用作函数类型值，例如，将其传递给另一个函数。为此，我们使用 &lt;code&gt;::&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="ae17c1ca56657ad30866237b96021ef47b3cda29" translate="yes" xml:space="preserve">
          <source>We can explicitly convert a character to an &lt;code&gt;Int&lt;/code&gt; number:</source>
          <target state="translated">我们可以将字符显式转换为 &lt;code&gt;Int&lt;/code&gt; 数字：</target>
        </trans-unit>
        <trans-unit id="d31ec9f07f4bc208cadad8ae2ec0b5f65d7cdf75" translate="yes" xml:space="preserve">
          <source>We can explicitly return a value from the lambda using the &lt;a href=&quot;returns#return-at-labels&quot;&gt;qualified return&lt;/a&gt; syntax. Otherwise, the value of the last expression is implicitly returned.</source>
          <target state="translated">我们可以使用&lt;a href=&quot;returns#return-at-labels&quot;&gt;限定的返回&lt;/a&gt;语法从lambda显式返回一个值。否则，隐式返回最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="5af6b3dce006afd131588be4e84caa508a65cc20" translate="yes" xml:space="preserve">
          <source>We can import either a single name, e.g.</source>
          <target state="translated">我们可以导入一个单一的名称,例如。</target>
        </trans-unit>
        <trans-unit id="8a9f3b72eb46629a298e0a057eccfdabab01c204" translate="yes" xml:space="preserve">
          <source>We can install &lt;code&gt;kotlinizer&lt;/code&gt; to the default repository:</source>
          <target state="translated">我们可以将 &lt;code&gt;kotlinizer&lt;/code&gt; 安装到默认存储库中：</target>
        </trans-unit>
        <trans-unit id="6d3bad56e3c4235f442b8c993bfc65c9b26cdc43" translate="yes" xml:space="preserve">
          <source>We can now add our first Kotlin source code file and IntelliJ IDEA will prompt us to configure the project for Kotlin. On doing so, we should select as target JavaScript</source>
          <target state="translated">现在我们可以添加我们的第一个Kotlin源代码文件,IntelliJ IDEA将提示我们为Kotlin配置项目。在这样做的时候,我们应该选择作为目标 JavaScript</target>
        </trans-unit>
        <trans-unit id="dc96081c653c84bb3dd3b5b83bfc524f3cd03b65" translate="yes" xml:space="preserve">
          <source>We can now do this (but it's still possible to call the function the normal way):</source>
          <target state="translated">现在我们可以这样做了(但仍然可以用正常的方式调用函数)。</target>
        </trans-unit>
        <trans-unit id="2028680260413907a6ff455452315ba4c9be7fe7" translate="yes" xml:space="preserve">
          <source>We can now start debugging our program. For example, we can set a breakpoint by clicking on one of the line numbers. The developer tools even support setting breakpoints within a statement. As with regular JavaScript code, any set breakpoints will persist across page reloads. This also makes it possible to debug Kotlin's main method which is executed when the script is first loaded.</source>
          <target state="translated">现在我们可以开始调试我们的程序了。例如,我们可以通过点击其中一个行号来设置断点。开发工具甚至支持在语句中设置断点。和普通的JavaScript代码一样,任何设置的断点都会在页面重新加载时持续存在。这也使得调试Kotlin的主方法成为可能,该方法会在脚本首次加载时执行。</target>
        </trans-unit>
        <trans-unit id="bb97bda68a25be3b25091829fa426075294c2d71" translate="yes" xml:space="preserve">
          <source>We can now use any of the standard Gradle tasks for Spring Boot to run the application. As such, running</source>
          <target state="translated">我们现在可以使用任何标准的Gradle任务来运行Spring Boot的应用程序。因此,运行</target>
        </trans-unit>
        <trans-unit id="c6898463443208b858c46602bd14f4fe18a2e216" translate="yes" xml:space="preserve">
          <source>We can override a non-abstract open member with an abstract one</source>
          <target state="translated">我们可以用一个抽象的成员覆盖一个非抽象的开放成员。</target>
        </trans-unit>
        <trans-unit id="443dbeb7b5959da838f042d1c795f241e1156ec7" translate="yes" xml:space="preserve">
          <source>We can replace &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt; with &lt;code&gt;Thread.sleep&lt;/code&gt; in the body of &lt;code&gt;simple&lt;/code&gt;'s &lt;code&gt;flow { ... }&lt;/code&gt; and see that the main thread is blocked in this case.</source>
          <target state="translated">我们可以在 &lt;code&gt;simple&lt;/code&gt; 的 &lt;code&gt;flow { ... }&lt;/code&gt; 的主体中用 &lt;code&gt;Thread.sleep&lt;/code&gt; 替换&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;，然后看到在这种情况下主线程被阻塞了。</target>
        </trans-unit>
        <trans-unit id="ec8ade084fb51f7b34b89fae3c572fe0de063884" translate="yes" xml:space="preserve">
          <source>We can run the compiler without parameters to have an interactive shell. We can type any valid Kotlin code and see the results.</source>
          <target state="translated">我们可以在没有参数的情况下运行编译器,以拥有一个交互式的shell.我们可以输入任何有效的Kotlin代码并查看结果。我们可以输入任何有效的Kotlin代码并查看结果。</target>
        </trans-unit>
        <trans-unit id="f29622b395465874ab1409644634bdf5bd547c3e" translate="yes" xml:space="preserve">
          <source>We can see how the API is created. To start with, we need to initialize the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure. Let's take a look at the latest part of the &lt;code&gt;libnative_api.h&lt;/code&gt; for this:</source>
          <target state="translated">我们可以看到如何创建API。首先，我们需要初始化 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 结构。让我们看一下 &lt;code&gt;libnative_api.h&lt;/code&gt; 的最新部分：</target>
        </trans-unit>
        <trans-unit id="3d6f52d4243822ccee088838c7cbe381743f9a4c" translate="yes" xml:space="preserve">
          <source>We can see the completion cause is not null, because the flow was aborted due to downstream exception:</source>
          <target state="translated">我们可以看到,完成原因并不是空的,因为流量是由于下游异常而中止的。</target>
        </trans-unit>
        <trans-unit id="d27d56a268fbe45c1d0688c4606abf60011997ba" translate="yes" xml:space="preserve">
          <source>We can simply refer to any class or member function inside our node.js code by simply importing the module using &lt;code&gt;require&lt;/code&gt;:</source>
          <target state="translated">我们可以简单地通过使用 &lt;code&gt;require&lt;/code&gt; 导入模块来引用node.js代码中的任何类或成员函数：</target>
        </trans-unit>
        <trans-unit id="831ccd2e7105b549d27fa757caf8f798b465ce95" translate="yes" xml:space="preserve">
          <source>We can simulate custom infix operations by using &lt;a href=&quot;functions#infix-notation&quot;&gt;infix function calls&lt;/a&gt;.</source>
          <target state="translated">我们可以使用&lt;a href=&quot;functions#infix-notation&quot;&gt;infix函数调用&lt;/a&gt;来模拟自定义的infix操作。</target>
        </trans-unit>
        <trans-unit id="509f912bd5b5b6af65e5240f9ef362cc1a5f0b3f" translate="yes" xml:space="preserve">
          <source>We can start by creating a library file in Kotlin and save it as &lt;code&gt;hello.kt&lt;/code&gt;:</source>
          <target state="translated">我们可以从在Kotlin中创建一个库文件开始并将其另存为 &lt;code&gt;hello.kt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="89f8fe8ceb180f0a0bdf079538aa483abb6121b4" translate="yes" xml:space="preserve">
          <source>We can then do this:</source>
          <target state="translated">我们就可以这样做。</target>
        </trans-unit>
        <trans-unit id="ce9fbf3c0deb149f881d772488fa422e85d659ce" translate="yes" xml:space="preserve">
          <source>We can tune how tests are executed in Kotlin/JS by adjusting the settings available in the &lt;code&gt;testTask&lt;/code&gt; block in our &lt;code&gt;build.gradle.kts&lt;/code&gt;. For example, using the Karma test runner together with a headless instance of Chrome and an instance of Firefox looks like this:</source>
          <target state="translated">我们可以调整如何测试在科特林/ JS通过调整现有的设置执行 &lt;code&gt;testTask&lt;/code&gt; 在我们的块 &lt;code&gt;build.gradle.kts&lt;/code&gt; 。例如，将Karma测试运行程序与Chrome的无头实例和Firefox的实例结合使用，如下所示：</target>
        </trans-unit>
        <trans-unit id="b16a2933e2edce96547337fb1fedcb97e299ea34" translate="yes" xml:space="preserve">
          <source>We can use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;buffer&lt;/a&gt; operator on a flow to run emitting code of the &lt;code&gt;simple&lt;/code&gt; flow concurrently with collecting code, as opposed to running them sequentially:</source>
          <target state="translated">我们可以在流上使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;缓冲区&lt;/a&gt;运算符，以与收集代码同时运行，以发出 &lt;code&gt;simple&lt;/code&gt; 流的代码，而不是依次运行它们：</target>
        </trans-unit>
        <trans-unit id="67a4cc600951e3a005f1c78d3f5d6ddad7aa6cbe" translate="yes" xml:space="preserve">
          <source>We can use arbitrary expressions (not only constants) as branch conditions</source>
          <target state="translated">我们可以使用任意的表达式(不仅仅是常数)作为分支条件。</target>
        </trans-unit>
        <trans-unit id="1d0515ada05fe82e395d7a6707b6351170a6e35a" translate="yes" xml:space="preserve">
          <source>We can use classes or functions from a Kotlin project, in our scratches and worksheets.</source>
          <target state="translated">我们可以在我们的scratch和工作表中使用Kotlin项目中的类或函数。</target>
        </trans-unit>
        <trans-unit id="8b191724788dd23ede6b8c2149628b7a54092d58" translate="yes" xml:space="preserve">
          <source>We can use explicit conversions to widen numbers</source>
          <target state="translated">我们可以使用显式转换来扩大数字的范围。</target>
        </trans-unit>
        <trans-unit id="dfb0038c9e10b5e80574a36666be3c3e86aa4353" translate="yes" xml:space="preserve">
          <source>We collectively refer to &lt;em&gt;Experimental&lt;/em&gt;, &lt;em&gt;Alpha&lt;/em&gt; and &lt;em&gt;Beta&lt;/em&gt; as &lt;strong&gt;pre-stable&lt;/strong&gt; levels.</source>
          <target state="translated">我们将&amp;ldquo;&lt;em&gt;实验&amp;rdquo;&lt;/em&gt;，&amp;ldquo; &lt;em&gt;Alpha&amp;rdquo;&lt;/em&gt;和&amp;ldquo; &lt;em&gt;Beta&amp;rdquo;&lt;/em&gt;统称为&lt;strong&gt;稳定&lt;/strong&gt;水平。</target>
        </trans-unit>
        <trans-unit id="fca14a2211b4e71b478b08b4747bfb20c5dc2a24" translate="yes" xml:space="preserve">
          <source>We continue to explore more C language types and their representation in Kotlin/Native in our other tutorials:</source>
          <target state="translated">我们将在其他教程中继续探索更多的C语言类型及其在Kotlin/Native中的表现形式。</target>
        </trans-unit>
        <trans-unit id="51b6f004886664d749f4d2984398143458f52375" translate="yes" xml:space="preserve">
          <source>We could call this using default arguments:</source>
          <target state="translated">我们可以使用默认参数来调用它。</target>
        </trans-unit>
        <trans-unit id="8ae10259ccef551da0909b6299a0fa1b0a4f1215" translate="yes" xml:space="preserve">
          <source>We could do a similar thing with contravariant projection by using &lt;code&gt;in&lt;/code&gt;:</source>
          <target state="translated">通过使用 &lt;code&gt;in&lt;/code&gt; ,我们可以对逆投影做类似的事情：</target>
        </trans-unit>
        <trans-unit id="39a9864b239884664ddf63f83dbaeb179ea24a10" translate="yes" xml:space="preserve">
          <source>We could use the same means of synchronization that are applicable to threads (a &lt;code&gt;CountDownLatch&lt;/code&gt; is what crosses my mind in this case), but let's take a safer and cleaner path.</source>
          <target state="translated">我们可以使用适用于线程的相同同步方式（在这种情况下， &lt;code&gt;CountDownLatch&lt;/code&gt; 是我想到的），但是让我们走一条更安全，更清洁的道路。</target>
        </trans-unit>
        <trans-unit id="d12b57fa3f5ee09d20d2af80c6064fa21722785e" translate="yes" xml:space="preserve">
          <source>We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;basic-kotlin-native-app#create-gradle-project&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</source>
          <target state="translated">我们在&lt;a href=&quot;basic-kotlin-native-app#create-gradle-project&quot;&gt;A Basic Kotlin / Native Application&lt;/a&gt;教程中介绍了使用Gradle设置与IDE兼容的项目的基础知识。如果您正在寻找有关如何启动新的Kotlin / Native项目并在IntelliJ IDEA中打开它的详细的第一步和说明，请进行检查。在本教程中，我们将研究Kotlin / Native的高级C互操作相关用法以及Gradle的&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;多平台&lt;/a&gt;构建。</target>
        </trans-unit>
        <trans-unit id="34c7674c59bff58842f8120c227b39dfc459b5e2" translate="yes" xml:space="preserve">
          <source>We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;using-gradle&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</source>
          <target state="translated">我们在&lt;a href=&quot;using-gradle&quot;&gt;A Basic Kotlin / Native Application&lt;/a&gt;教程中介绍了使用Gradle设置与IDE兼容的项目的基础知识。如果您正在寻找有关如何启动新的Kotlin / Native项目并在IntelliJ IDEA中打开它的详细的第一步和说明，请进行检查。在本教程中，我们将研究Kotlin / Native的高级C互操作相关用法以及Gradle的&lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;多平台&lt;/a&gt;构建。</target>
        </trans-unit>
        <trans-unit id="6b1e2f897849388e9b5afd5f5e40ff3ed5d9341c" translate="yes" xml:space="preserve">
          <source>We create &lt;code&gt;build.gradle&lt;/code&gt;&lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle build file with the following contents:</source>
          <target state="translated">我们使用以下内容创建 &lt;code&gt;build.gradle&lt;/code&gt; &lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle构建文件：</target>
        </trans-unit>
        <trans-unit id="d792e0e9b2d61d7c507d6ac3c55fb78219ae3d1b" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;lib.h&lt;/code&gt; file to see how C functions are mapped into Kotlin:</source>
          <target state="translated">我们创建一个 &lt;code&gt;lib.h&lt;/code&gt; 文件来查看如何将C函数映射到Kotlin中：</target>
        </trans-unit>
        <trans-unit id="b48d0f7550a4bac04ad5285d58e805e5af18955b" translate="yes" xml:space="preserve">
          <source>We create a similar implementation file (and missing directories) for the iOS target in the &lt;code&gt;SharedCode/src/iosMain/kotlin/actual.kt&lt;/code&gt;:</source>
          <target state="translated">我们在 &lt;code&gt;SharedCode/src/iosMain/kotlin/actual.kt&lt;/code&gt; 中为iOS目标创建一个类似的实现文件（和缺少的目录）：</target>
        </trans-unit>
        <trans-unit id="785942d151a588aee24ed9a38ee1d8176b8dc181" translate="yes" xml:space="preserve">
          <source>We create the &lt;code&gt;hello.kt&lt;/code&gt; file with the library contents:</source>
          <target state="translated">我们使用库内容创建 &lt;code&gt;hello.kt&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="fcb050d7cd97c1f800f9df98029b55284f1e77b7" translate="yes" xml:space="preserve">
          <source>We decided to productize this idea, but it hasn't reached the final shape yet.</source>
          <target state="translated">我们决定将这个想法产品化,但它还没有达到最终的形状。</target>
        </trans-unit>
        <trans-unit id="a6ed76b8d0d9018634906744837677e15921589b" translate="yes" xml:space="preserve">
          <source>We declare the generic type parameter before the function name for it to be available in the receiver type expression. See &lt;a href=&quot;generics&quot;&gt;Generic functions&lt;/a&gt;.</source>
          <target state="translated">我们在函数名称之前声明通用类型参数，以使其在接收器类型表达式中可用。请参见&lt;a href=&quot;generics&quot;&gt;通用函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="908a5325e4c7755c51db166d96c5a188313020b0" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t currently support sharing a source set for these combinations:</source>
          <target state="translated">我们目前不支持共享这些组合的源集：</target>
        </trans-unit>
        <trans-unit id="e038eb8a21b3199cc32241632b06a3909918bfe9" translate="yes" xml:space="preserve">
          <source>We don't have to annotate the &lt;code&gt;HTML&lt;/code&gt; or &lt;code&gt;Head&lt;/code&gt; classes with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; because their superclass is already annotated:</source>
          <target state="translated">我们不必使用 &lt;code&gt;@HtmlTagMarker&lt;/code&gt; 注释 &lt;code&gt;HTML&lt;/code&gt; 或 &lt;code&gt;Head&lt;/code&gt; 类，因为它们的超类已经被注释了：</target>
        </trans-unit>
        <trans-unit id="0d7e408c93316e02af7f4048c236f0b36f5b8539" translate="yes" xml:space="preserve">
          <source>We encourage you to try out the new Kotlin/JVM backend, which is currently in Alpha, and to file any issues and feature requests to our &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;issue tracker&lt;/a&gt;. This will help us to unify the compiler pipelines and bring compiler extensions like Jetpack Compose to the Kotlin community more quickly.</source>
          <target state="translated">我们鼓励您试用当前在Alpha中的新Kotlin / JVM后端，并将所有问题和功能请求提交给我们的&lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;问题跟踪器&lt;/a&gt;。这将有助于我们统一编译器管道，并将诸如Jetpack Compose之类的编译器扩展更快地带入Kotlin社区。</target>
        </trans-unit>
        <trans-unit id="efdd6ede6c8f3bf00110a9f180aa0db3e0e10e52" translate="yes" xml:space="preserve">
          <source>We encourage you to use our new &lt;a href=&quot;#new-jvm-ir-backend&quot;&gt;JVM IR&lt;/a&gt; and &lt;a href=&quot;#new-js-ir-backend&quot;&gt;JS IR&lt;/a&gt; backends, which are currently in Alpha, and share your feedback with us.</source>
          <target state="translated">我们鼓励您使用当前在Alpha中的新的&lt;a href=&quot;#new-jvm-ir-backend&quot;&gt;JVM IR&lt;/a&gt;和&lt;a href=&quot;#new-js-ir-backend&quot;&gt;JS IR&lt;/a&gt;后端，并与我们分享您的反馈。</target>
        </trans-unit>
        <trans-unit id="8e3df53e494bf93b03698e74de62415d2b98fbd8" translate="yes" xml:space="preserve">
          <source>We evolve the Kotlin Standard Library (kotlin-stdlib) for stable platforms according to the principles stated above. Changes to the contracts for its API undergo the same procedures as changes in the language itself.</source>
          <target state="translated">我们根据上述原则为稳定的平台发展Kotlin标准库(kotlin-stdlib)。对其API合同的修改与语言本身的修改经过同样的程序。</target>
        </trans-unit>
        <trans-unit id="a2535fe7404df5a6eb12c3a3917ab80b4135dbff" translate="yes" xml:space="preserve">
          <source>We frequently create classes whose main purpose is to hold data. In such a class some standard functionality and utility functions are often mechanically derivable from the data. In Kotlin, this is called a &lt;em&gt;data class&lt;/em&gt; and is marked as &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">我们经常创建主要目的是保存数据的类。在此类中，通常可以从数据中机械地得出一些标准功能和实用功能。在Kotlin中，这称为&lt;em&gt;数据类&lt;/em&gt;，并标记为 &lt;code&gt;data&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1a30f61b55b7b7e943a650a6aabc19b05c3bdf8d" translate="yes" xml:space="preserve">
          <source>We get only numbers up to 3 and a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; after trying to emit number 4:</source>
          <target state="translated">尝试发出数字4之后，我们仅得到不超过3的数字和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="24aab8ad063fec7c5b2558d6a061d3a136f3a35e" translate="yes" xml:space="preserve">
          <source>We get quite a different output, where a line is printed at each emission from either &lt;code&gt;nums&lt;/code&gt; or &lt;code&gt;strs&lt;/code&gt; flows:</source>
          <target state="translated">我们得到了截然不同的输出，其中从 &lt;code&gt;nums&lt;/code&gt; 或 &lt;code&gt;strs&lt;/code&gt; 流的每次发射中打印一行：</target>
        </trans-unit>
        <trans-unit id="5ee091486d809b243b18a19355b403e23f19e065" translate="yes" xml:space="preserve">
          <source>We have significantly reworked the API for JSON serialization to make it more consistent and easier to use. From now on, we'll continue developing the JSON serialization API in a backward-compatible manner. However, if you have used previous versions of it, you'll need to rewrite some of your code when migrating to 1.0.0-RC. To help you with this, we also offer the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md&quot;&gt;Kotlin Serialization Guide&lt;/a&gt; &amp;ndash; the complete set of documentation for &lt;code&gt;kotlinx.serialization&lt;/code&gt;. It will guide you through the process of using the most important features and it can help you address any issues that you might face.</source>
          <target state="translated">我们已经对JSON序列化的API进行了重大改进，以使其更加一致和易于使用。从现在开始，我们将继续以向后兼容的方式开发JSON序列化API。但是，如果您使用过以前的版本，则在迁移到1.0.0-RC时需要重写一些代码。为了帮助您解决此问题，我们还提供了&lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md&quot;&gt;Kotlin序列化指南&lt;/a&gt; &lt;code&gt;kotlinx.serialization&lt;/code&gt; 的完整文档集。它将指导您完成使用最重要功能的过程，并可以帮助您解决可能遇到的任何问题。</target>
        </trans-unit>
        <trans-unit id="1094efa9f8fd00ffe04a3c7c86c1ceab68f5986d" translate="yes" xml:space="preserve">
          <source>We make sure to document precisely which subcomponents are not stable. We also do our best to warn users where possible and ask to opt in explicitly to avoid accidental usages of features that have not been released as stable.</source>
          <target state="translated">我们确保准确记录哪些子组件不稳定。我们也会尽可能地警告用户,并要求用户明确地选择使用,以避免意外地使用那些没有发布为稳定的功能。</target>
        </trans-unit>
        <trans-unit id="a128ace07ce2a614969d8901fa6d436be396c723" translate="yes" xml:space="preserve">
          <source>We manage a lifecycle of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; that is tied to the lifecycle of our activity. &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as default dispatcher:</source>
          <target state="translated">我们通过创建与活动的生命周期相关联的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;实例来管理协程的生命周期。可以通过&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope（）&lt;/a&gt;或&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope（）&lt;/a&gt;工厂函数创建 &lt;code&gt;CoroutineScope&lt;/code&gt; 实例。前者创建通用作用域，而后者创建UI应用程序的作用域，并使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt;作为默认调度程序：</target>
        </trans-unit>
        <trans-unit id="ccd2d1dce53a36cd421422934713d352fc3aea2f" translate="yes" xml:space="preserve">
          <source>We manage the lifecycles of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; tied to the lifecycle of our activity. A &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates a scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as the default dispatcher:</source>
          <target state="translated">我们通过创建与活动的生命周期相关联的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;实例来管理协程的生命周期。甲 &lt;code&gt;CoroutineScope&lt;/code&gt; 实例可以由创建&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope（）&lt;/a&gt;或&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope（）&lt;/a&gt;工厂函数。前者创建通用作用域，而后者创建UI应用程序的作用域，并使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt;作为默认调度程序：</target>
        </trans-unit>
        <trans-unit id="b2f8eb551efabdb4e2888f30edf606cbdfff7bc8" translate="yes" xml:space="preserve">
          <source>We may find the whole sources from that tutorial on &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/tutorials/mpp-iOS-Android&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">我们可以在&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/tutorials/mpp-iOS-Android&quot;&gt;GitHub上&lt;/a&gt;找到该教程的全部资源。</target>
        </trans-unit>
        <trans-unit id="990e3fee35a9a6ae47d7273521920489a64503a8" translate="yes" xml:space="preserve">
          <source>We may include all declarations directly into the &lt;code&gt;.def&lt;/code&gt; file after a &lt;code&gt;---&lt;/code&gt; separator. It can be helpful to include macros or other C defines into the code generated by the &lt;code&gt;cinterop&lt;/code&gt; tool. Method bodies are compiled and fully included into the binary too. Let's use that feature to have a runnable example without a need for a C compiler. To implement that, we need to add implementations to the C functions from the &lt;code&gt;lib.h&lt;/code&gt; file, and place these functions into a &lt;code&gt;.def&lt;/code&gt; file. We will have the following &lt;code&gt;interop.def&lt;/code&gt; result:</source>
          <target state="translated">我们可能在 &lt;code&gt;---&lt;/code&gt; 分隔符之后将所有声明直接包含在 &lt;code&gt;.def&lt;/code&gt; 文件中。在 &lt;code&gt;cinterop&lt;/code&gt; 工具生成的代码中包含宏或其他C定义可能会有所帮助。方法体被编译并完全包含在二进制文件中。让我们使用该功能创建一个可运行的示例，而无需C编译器。为此，我们需要从 &lt;code&gt;lib.h&lt;/code&gt; 文件向C函数添加实现，并将这些函数放入 &lt;code&gt;.def&lt;/code&gt; 文件中。我们将得到以下 &lt;code&gt;interop.def&lt;/code&gt; 结果：</target>
        </trans-unit>
        <trans-unit id="bb703fd0c61569a76d50c3b521794196aa1b8db0" translate="yes" xml:space="preserve">
          <source>We need to assign the &lt;code&gt;id&lt;/code&gt; to the &lt;code&gt;TextView&lt;/code&gt; control of our activity to access it from the code. Let's patch the &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; file (the name may be different if we changed it in the new project wizard) and add several more attributes to the &lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">我们需要将 &lt;code&gt;id&lt;/code&gt; 分配给活动的 &lt;code&gt;TextView&lt;/code&gt; 控件，以便从代码中访问它。让我们修补 &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; 文件（如果在新项目向导中更改了名称，则名称可能会有所不同），并向 &lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt; 元素添加更多属性：</target>
        </trans-unit>
        <trans-unit id="6b59ffea87e48a8dddabef126cfdaa1e77887d03" translate="yes" xml:space="preserve">
          <source>We need to configure an Xcode project to use our framework. The configuration depends on the target platform.</source>
          <target state="translated">我们需要配置一个Xcode项目来使用我们的框架。配置取决于目标平台。</target>
        </trans-unit>
        <trans-unit id="8c3349f607cc5a810a187a7d773102a89d925fbd" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial contains more explanations for that step. Let's assume, we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">我们需要在机器上安装Kotlin编译器。《&lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;基本Kotlin应用程序&lt;/a&gt;教程》包含有关该步骤的更多说明。假设我们有一个控制台，可以使用 &lt;code&gt;kotlinc-native&lt;/code&gt; ， &lt;code&gt;cinterop&lt;/code&gt; 和 &lt;code&gt;klib&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="027177ad8c50f7e3918b01a86e99731d536a90cd" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial covers that step in details. Let's assume that we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">我们需要在机器上安装Kotlin编译器。在&lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;一个基本的科特林应用&lt;/a&gt;教程涵盖了详细的一步。假设我们有一个控制台，可以使用 &lt;code&gt;kotlinc-native&lt;/code&gt; ， &lt;code&gt;cinterop&lt;/code&gt; 和 &lt;code&gt;klib&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="3c043e1a723b8be73d20799e39d49b6268885069" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial explains the steps in detail. Let's assume we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">我们需要在机器上安装Kotlin编译器。在&lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;一个基本的科特林应用&lt;/a&gt;教程将详细介绍的步骤。假设我们有一个控制台，可以使用 &lt;code&gt;kotlinc-native&lt;/code&gt; ， &lt;code&gt;cinterop&lt;/code&gt; 和 &lt;code&gt;klib&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="ab5784dabb9482fdb660b478b956f2503674f995" translate="yes" xml:space="preserve">
          <source>We need to refresh the Gradle Project settings to apply these changes. Click on the &lt;code&gt;Sync Now&lt;/code&gt; link or use the &lt;em&gt;Gradle&lt;/em&gt; tool window and click the refresh action from the context menu on the root Gradle project.</source>
          <target state="translated">我们需要刷新Gradle Project设置以应用这些更改。单击 &lt;code&gt;Sync Now&lt;/code&gt; 链接，或使用&lt;em&gt;Gradle&lt;/em&gt;工具窗口，然后从Gradle根项目的上下文菜单中单击刷新操作。</target>
        </trans-unit>
        <trans-unit id="e0a25a2206a6fb40af56c49d12ab94e8fd653881" translate="yes" xml:space="preserve">
          <source>We need to supply the right Framework out of those four depending on the selected target in the Xcode project. It depends on the target configuration selected in Xcode. Also, we'd like to make Xcode compile the Framework for us before the build. We need to include the additional task to the end of the &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; Gradle file:</source>
          <target state="translated">我们需要根据Xcode项目中选定的目标提供这四个框架中的正确框架。这取决于在Xcode中选择的目标配置。另外，我们希望在构建之前让Xcode为我们编译Framework。我们需要将其他任务添加到 &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; Gradle文件的末尾：</target>
        </trans-unit>
        <trans-unit id="27d58e7d45f1a7f3fbb5989a56fe0b4132ca9bca" translate="yes" xml:space="preserve">
          <source>We now define the &lt;em&gt;GreetingController&lt;/em&gt; which serves requests of the form &lt;em&gt;/greeting?name={value}&lt;/em&gt; and returns a JSON object representing an instance of &lt;em&gt;Greeting&lt;/em&gt;</source>
          <target state="translated">现在，我们定义&lt;em&gt;GreetingController&lt;/em&gt;，该请求为&lt;em&gt;/ greeting？name = {value}&lt;/em&gt;形式的请求，并返回表示&lt;em&gt;Greeting&lt;/em&gt;实例的JSON对象&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5172c1ac8d2fad040b4dc376d3d08d8d24a279b3" translate="yes" xml:space="preserve">
          <source>We now have a local variable &lt;code&gt;number&lt;/code&gt; whose value is 42 and whose type is &lt;code&gt;Int&lt;/code&gt; (because that's the type of the literal &lt;code&gt;42&lt;/code&gt;), and another local variable &lt;code&gt;message&lt;/code&gt; whose value is &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; and whose type is &lt;code&gt;String&lt;/code&gt;. Subsequent usages of the variable must use only the name, not &lt;code&gt;var&lt;/code&gt;:</source>
          <target state="translated">现在，我们有了一个本地变量 &lt;code&gt;number&lt;/code&gt; 其值为42，类型为 &lt;code&gt;Int&lt;/code&gt; （因为这是文字 &lt;code&gt;42&lt;/code&gt; 的类型），还有另一个本地变量 &lt;code&gt;message&lt;/code&gt; 其值为 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ，类型为 &lt;code&gt;String&lt;/code&gt; 。变量的后续用法必须仅使用名称，而不使用 &lt;code&gt;var&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dfb0f090289673dd1e3bce3bdb08b454f3c07da9" translate="yes" xml:space="preserve">
          <source>We now need an HTML page to load the code, so we'll create a file called &lt;code&gt;index.html&lt;/code&gt;. If you want more information on how Kotlin compiles to JavaScript and the output generated, check out the &lt;a href=&quot;../kotlin-to-javascript/kotlin-to-javascript&quot;&gt;Kotlin to JavaScript&lt;/a&gt; tutorial.</source>
          <target state="translated">现在，我们需要一个HTML页面来加载代码，因此我们将创建一个名为 &lt;code&gt;index.html&lt;/code&gt; 的文件。如果您想了解有关Kotlin如何编译为JavaScript以及生成的输出的更多信息，请查看&lt;a href=&quot;../kotlin-to-javascript/kotlin-to-javascript&quot;&gt;Kotlin to JavaScript&lt;/a&gt;教程。</target>
        </trans-unit>
        <trans-unit id="8ae2c927826795d420c34c1b15ddab31d41644c0" translate="yes" xml:space="preserve">
          <source>We observed that annotating your code almost hasn't changed when you switched to Kotlin. Now let's see what changes should be made to the build script.</source>
          <target state="translated">我们观察到,当你切换到Kotlin时,注释你的代码几乎没有改变。现在让我们看看应该对构建脚本做哪些修改。</target>
        </trans-unit>
        <trans-unit id="8ffa6d76c8e1bf7a1c5dd4d42cd1a6d0515ef81b" translate="yes" xml:space="preserve">
          <source>We open Xcode and select &lt;em&gt;Create a new Xcode project&lt;/em&gt; option. In the dialog, we choose the iOS target and select the &lt;em&gt;Single View App&lt;/em&gt;. Fill the next page with defaults, and use the &lt;code&gt;KotlinIOS&lt;/code&gt; (or something else) as the &lt;em&gt;Product Name&lt;/em&gt;. Let's select Swift as the language (it is possible to use Objective-C too). We should instruct Xcode to place the project into the &lt;code&gt;native&lt;/code&gt; folder under our project, later we will use relative paths in the configuration files.</source>
          <target state="translated">我们打开Xcode并选择&lt;em&gt;Create a new Xcode project&lt;/em&gt;选项。在对话框中，我们选择iOS目标，然后选择&lt;em&gt;Single View App&lt;/em&gt;。使用默认值填充下一页，并使用 &lt;code&gt;KotlinIOS&lt;/code&gt; （或其他&lt;em&gt;名称&lt;/em&gt;）作为&lt;em&gt;产品名称&lt;/em&gt;。让我们选择Swift作为语言（也可以使用Objective-C）。我们应该指示Xcode将项目放入项目下的 &lt;code&gt;native&lt;/code&gt; 文件夹中，稍后我们将在配置文件中使用相对路径。</target>
        </trans-unit>
        <trans-unit id="a2530cc820c7c771c8fc29995c153d4bf24643ea" translate="yes" xml:space="preserve">
          <source>We provide &lt;em&gt;all-open&lt;/em&gt; plugin support both for Gradle and Maven with the complete IDE integration.</source>
          <target state="translated">我们通过完整的IDE集成为Gradle和Maven 提供&lt;em&gt;全开放式&lt;/em&gt;插件支持。</target>
        </trans-unit>
        <trans-unit id="8737e3b3a5c293a6cb9372838dbc9870d668570a" translate="yes" xml:space="preserve">
          <source>We provide the -language-version and -api-version flags that make a new version emulate the behaviour of an old one, for compatibility purposes. Normally, at least one previous version is supported. This effectively leaves a time span of two full feature release cycles for migration (which usually amounts to about two years). Using an older kotlin-stdlib or kotlin-reflect with a newer compiler without specifying compatibility flags is not recommended, and the compiler will report a &lt;a href=&quot;compatibility-modes&quot;&gt;warning&lt;/a&gt; when this happens.</source>
          <target state="translated">我们提供-language-version和-api-version标志，这些标志使新版本模仿旧版本的行为，以实现兼容性。通常，至少支持一个以前的版本。这实际上为迁移留出了两个完整功能发布周期的时间跨度（通常大约为两年）。不建议在未指定兼容性标志的情况下将较旧的kotlin-stdlib或kotlin-reflect与较新的编译器一起使用，并且当发生这种情况时，编译器将报告&lt;a href=&quot;compatibility-modes&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e91c098e8aab839aef30caa8d584e2cae0663d0e" translate="yes" xml:space="preserve">
          <source>We qualified the type parameter with the &lt;code&gt;reified&lt;/code&gt; modifier, now it&amp;rsquo;s accessible inside the function, almost as if it were a normal class. Since the function is inlined, no reflection is needed, normal operators like &lt;code&gt;!is&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; are working now. Also, we can call it as mentioned above: &lt;code&gt;myTree.findParentOfType&amp;lt;MyTreeNodeType&amp;gt;()&lt;/code&gt;.</source>
          <target state="translated">我们使用 &lt;code&gt;reified&lt;/code&gt; 修饰符对类型参数进行了限定，现在可以在函数内部访问它了，几乎就像是普通类一样。由于内联函数，不需要反射，正常的运营商如 &lt;code&gt;!is&lt;/code&gt; 和 &lt;code&gt;as&lt;/code&gt; 现在正在工作。同样，我们可以如上所述调用它： &lt;code&gt;myTree.findParentOfType&amp;lt;MyTreeNodeType&amp;gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7840bc09de48b5cc97bf23a9db5d15e17420d9fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;code&gt;with&lt;/code&gt; for calling functions on the context object without providing the lambda result. In the code, &lt;code&gt;with&lt;/code&gt; can be read as &amp;ldquo;&lt;em&gt;with this object, do the following.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">我们建议 &lt;code&gt;with&lt;/code&gt; 调用上下文对象上，而无须提供拉姆达结果。在代码中， &lt;code&gt;with&lt;/code&gt; &lt;em&gt;此对象&lt;/em&gt;可以读为&amp;ldquo; &lt;em&gt;，请执行以下操作。&lt;/em&gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ee965fb5c972bf1b84c2210f41280ef6b6a7b02d" translate="yes" xml:space="preserve">
          <source>We recommend that you use expected and actual declarations only for Kotlin declarations that have platform-specific dependencies. It is better to implement as much functionality as possible in the shared module even if doing so takes more time.</source>
          <target state="translated">我们建议你只对具有平台特定依赖性的Kotlin声明使用预期和实际声明。最好在共享模块中实现尽可能多的功能,即使这样做需要更多的时间。</target>
        </trans-unit>
        <trans-unit id="55acd20cd8a96e52ff245292bd60de85bd57b76c" translate="yes" xml:space="preserve">
          <source>We see from these definitions that the Kotlin object &lt;code&gt;Object&lt;/code&gt; is mapped into &lt;code&gt;libnative_kref_example_Object&lt;/code&gt;, and &lt;code&gt;Clazz&lt;/code&gt; is mapped into &lt;code&gt;libnative_kref_example_Clazz&lt;/code&gt;. Both structs contain nothing but the &lt;code&gt;pinned&lt;/code&gt; field with a pointer, the field type &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is defined as &lt;code&gt;void*&lt;/code&gt; above.</source>
          <target state="translated">我们从这些定义的科特林对象看 &lt;code&gt;Object&lt;/code&gt; 映射到 &lt;code&gt;libnative_kref_example_Object&lt;/code&gt; ，并 &lt;code&gt;Clazz&lt;/code&gt; 被映射到 &lt;code&gt;libnative_kref_example_Clazz&lt;/code&gt; 。这两个结构 &lt;code&gt;libnative_KNativePtr&lt;/code&gt; 包含带有指针的 &lt;code&gt;pinned&lt;/code&gt; 字段，字段类型libnative_KNativePtr在上面被定义为 &lt;code&gt;void*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6899aab23e93f36bbb67e40e2a50b9ebcd2d51b" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;cinterop&lt;/code&gt; generated wrapper types for our &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types. For &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; type declarations in C, we have the Kotlin classes &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; generated respectively. The wrappers inherit from the &lt;code&gt;CStructVar&lt;/code&gt; base class and declare all fields as Kotlin properties. It uses &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; to represent a by-value structure parameter and &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;?&lt;/code&gt; to represent passing a pointer to a structure or a union.</source>
          <target state="translated">我们看到 &lt;code&gt;cinterop&lt;/code&gt; 为我们的 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 类型生成了包装器类型。对于C中的 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 类型声明，我们分别生成了Kotlin类 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 。包装器继承自 &lt;code&gt;CStructVar&lt;/code&gt; 基类，并将所有字段声明为Kotlin属性。它使用 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 表示按值结构参数，而 &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;?&lt;/code&gt; 表示传递指向结构或联合的指针。</target>
        </trans-unit>
        <trans-unit id="f057034bf9d5d678ae656c6371649fbb0395e9c1" translate="yes" xml:space="preserve">
          <source>We see that Kotlin &lt;code&gt;String&lt;/code&gt; and Objective-C &lt;code&gt;NSString*&lt;/code&gt; are mapped transparently. Similarly, &lt;code&gt;Unit&lt;/code&gt; type from Kotlin is mapped to &lt;code&gt;void&lt;/code&gt;. We see primitive types are mapped directly. Non-nullable primitive types are mapped transparently. Nullable primitive types are mapped into &lt;code&gt;Kotlin&amp;lt;TYPE&amp;gt;*&lt;/code&gt; types, as shown in the table &lt;a href=&quot;#kotlin-numbers-and-nsnumber&quot;&gt;above&lt;/a&gt;. Both higher order functions &lt;code&gt;acceptFunF&lt;/code&gt; and &lt;code&gt;supplyFun&lt;/code&gt; are included, and accept Objective-C blocks.</source>
          <target state="translated">我们看到Kotlin &lt;code&gt;String&lt;/code&gt; 和Objective-C &lt;code&gt;NSString*&lt;/code&gt; 是透明映射的。同样，来自Kotlin的 &lt;code&gt;Unit&lt;/code&gt; 类型被映射为 &lt;code&gt;void&lt;/code&gt; 。我们看到原始类型被直接映射。不可空的原始类型被透明地映射。可空基元类型映射为 &lt;code&gt;Kotlin&amp;lt;TYPE&amp;gt;*&lt;/code&gt; 类型，如上表&lt;a href=&quot;#kotlin-numbers-and-nsnumber&quot;&gt;所示&lt;/a&gt;。包含了两个更高阶的函数 &lt;code&gt;acceptFunF&lt;/code&gt; 和 &lt;code&gt;supplyFun&lt;/code&gt; ，并接受Objective-C块。</target>
        </trans-unit>
        <trans-unit id="35a16af72746a4a3a02afc71cbee1736ad51d23a" translate="yes" xml:space="preserve">
          <source>We see that our function typedef from C has been turned into Kotlin &lt;code&gt;typealias&lt;/code&gt;. It uses &lt;code&gt;CPointer&amp;lt;..&amp;gt;&lt;/code&gt; type to represent the pointer parameters, and &lt;code&gt;CFunction&amp;lt;(Int)-&amp;gt;Int&amp;gt;&lt;/code&gt; to represent the function signature. There is an &lt;code&gt;invoke&lt;/code&gt; operator extension function available for all &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; types, so that it is possible to call it as we would call any other function in Kotlin.</source>
          <target state="translated">我们看到，来自C的函数typedef已变成Kotlin &lt;code&gt;typealias&lt;/code&gt; 。它使用 &lt;code&gt;CPointer&amp;lt;..&amp;gt;&lt;/code&gt; 类型表示指针参数，并使用 &lt;code&gt;CFunction&amp;lt;(Int)-&amp;gt;Int&amp;gt;&lt;/code&gt; 表示函数签名。所有 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; 类型都有一个 &lt;code&gt;invoke&lt;/code&gt; operator扩展函数，因此可以像调用Kotlin中的任何其他函数一样调用它。</target>
        </trans-unit>
        <trans-unit id="28a890b04741a752c8a070159a08ecb4fb5a731d" translate="yes" xml:space="preserve">
          <source>We see that while the first number was still being processed the second, and third were already produced, so the second one was &lt;em&gt;conflated&lt;/em&gt; and only the most recent (the third one) was delivered to the collector:</source>
          <target state="translated">我们看到，虽然第一个数字仍在处理中，第二个已经生产，第三个已经生产，所以第二个被&lt;em&gt;混合了&lt;/em&gt;，只有最新的（第三个）被交付给收集器：</target>
        </trans-unit>
        <trans-unit id="c2878a9c7f0b432f6ca797d421e5946bffba2e7e" translate="yes" xml:space="preserve">
          <source>We should drag the created build phase to the top of the list</source>
          <target state="translated">我们应该将创建的构建阶段拖到列表的顶部</target>
        </trans-unit>
        <trans-unit id="96dd80304356c421140b6cec43e73736a5d2cf73" translate="yes" xml:space="preserve">
          <source>We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumBy()&lt;/code&gt;. But the compiler rightfully complains:</source>
          <target state="translated">我们只需要 &lt;code&gt;sumBy()&lt;/code&gt; 每个协程，然后在这里等待其结果，然后将所有结果通过标准库函数sumBy（）进行加法运算。但是编译器正确地抱怨：</target>
        </trans-unit>
        <trans-unit id="256672724470d83204a91011d31c7585e8e896c2" translate="yes" xml:space="preserve">
          <source>We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumOf()&lt;/code&gt;. But the compiler rightfully complains:</source>
          <target state="translated">我们只需要 &lt;code&gt;sumOf()&lt;/code&gt; 每个协程，然后在这里等待其结果，然后将所有结果通过标准库函数sumOf（）相加即可。但是编译器正确地抱怨：</target>
        </trans-unit>
        <trans-unit id="7d4baf88fc00c2c6a8043a4496a26dfca6b633d7" translate="yes" xml:space="preserve">
          <source>We start with a very simple action that increments a shared mutable variable using multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;.</source>
          <target state="translated">我们从一个非常简单的动作开始，该动作使用多线程&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;增加一个共享的可变变量。</target>
        </trans-unit>
        <trans-unit id="d6e2ee50e438c21fd164031d81fcec588a999b4f" translate="yes" xml:space="preserve">
          <source>We still have concurrent execution of both operations as evident from the output of the above main function:</source>
          <target state="translated">从上述主函数的输出中可以看出,我们仍然可以并发执行这两种操作。</target>
        </trans-unit>
        <trans-unit id="d309cfebc83a39f58f865d0bd1891f05f3570150" translate="yes" xml:space="preserve">
          <source>We still have concurrent execution of both operations, as evident from the output of the above &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="translated">从上述 &lt;code&gt;main&lt;/code&gt; 功能的输出可以明显看出，我们仍然可以同时执行这两个操作：</target>
        </trans-unit>
        <trans-unit id="c7c80eca3836dfb2ec346ec74a1498c04b650629" translate="yes" xml:space="preserve">
          <source>We suggest you try the method &lt;a href=&quot;../java.io.-file/use-lines&quot;&gt;useLines&lt;/a&gt; instead which closes the stream when the processing is complete.</source>
          <target state="translated">建议您尝试使用&lt;a href=&quot;../java.io.-file/use-lines&quot;&gt;useLines&lt;/a&gt;方法，该方法将在处理完成后关闭流。</target>
        </trans-unit>
        <trans-unit id="1f5ae8ba8a817df47cdd30f0d60e67f7842b5f3f" translate="yes" xml:space="preserve">
          <source>We use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; intermediate operator in this example to delay each element and make the code that emits sample flows more declarative and shorter.</source>
          <target state="translated">在此示例中，我们使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt;中间运算符来延迟每个元素，并使发出采样流的代码更具声明性且更短。</target>
        </trans-unit>
        <trans-unit id="d00e20f64ce7aa51453973eb86f6197d3fb8aac0" translate="yes" xml:space="preserve">
          <source>We use a normal sequential invocation, because the code in the coroutine, just like in the regular code, is &lt;em&gt;sequential&lt;/em&gt; by default. The following example demonstrates it by measuring the total time it takes to execute both suspending functions:</source>
          <target state="translated">我们使用普通的顺序调用，因为协程中的代码与常规代码中的代码一样，默认情况下是&lt;em&gt;顺序&lt;/em&gt;的。下面的示例通过测量执行两个挂起功能所需的总时间来演示此过程：</target>
        </trans-unit>
        <trans-unit id="aadde77016fbc4d33f0abaca395b0e32828abddd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;import SharedCode&lt;/code&gt; to import our Framework, which we compiled with Kotlin/Native from Kotlin code. Next, we call the Kotlin function from it as &lt;code&gt;CommonKt.createApplicationScreenMessage()&lt;/code&gt;. Follow the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial for more details on the Kotlin/Native to Swift (or Objective-C) interop.</source>
          <target state="translated">我们使用 &lt;code&gt;import SharedCode&lt;/code&gt; 导入我们的框架，我们使用Kotlin / Native从Kotlin代码编译了该框架。接下来，我们从中将Kotlin函数称为 &lt;code&gt;CommonKt.createApplicationScreenMessage()&lt;/code&gt; 。遵循&lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native作为Apple Framework&lt;/a&gt;教程，以获取有关Kotlin / Native到Swift（或Objective-C）互操作的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="085b9979a689e14ecd3808ec279a6c3ad33ba2ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;staticCFunction{..}&lt;/code&gt; helper function from Kotlin/Native to wrap a Kotlin lambda function into a C function pointer. It only allows having unbound and non-capturing lambda functions. For example, it is not able to use a local variable from the function. We may only use globally visible declarations. Throwing exceptions from a &lt;code&gt;staticCFunction{..}&lt;/code&gt; will end up in non-deterministic side-effects. It is vital to make sure that we are not throwing any sudden exceptions from it.</source>
          <target state="translated">我们使用Kotlin / Native 的 &lt;code&gt;staticCFunction{..}&lt;/code&gt; 辅助函数将Kotlin lambda函数包装到C函数指针中。它仅允许具有未绑定和不捕获的lambda函数。例如，它不能使用该函数中的局部变量。我们只能使用全局可见的声明。从 &lt;code&gt;staticCFunction{..}&lt;/code&gt; 异常将导致不确定的副作用。重要的是要确保我们不会引发任何突然的异常情况。</target>
        </trans-unit>
        <trans-unit id="6d750a9144d219b73169d8ec8ee3282a5ce16530" translate="yes" xml:space="preserve">
          <source>We use the condition in the Gradle script to select the target platform for the framework. It is either &lt;code&gt;iOS arm64&lt;/code&gt; or &lt;code&gt;iOS x86_64&lt;/code&gt; depending on environment variables.</source>
          <target state="translated">我们使用Gradle脚本中的条件为框架选择目标平台。根据环境变量，它可以是 &lt;code&gt;iOS arm64&lt;/code&gt; 或 &lt;code&gt;iOS x86_64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87ead7e377be828bc8f924111dcab22679cf1455" translate="yes" xml:space="preserve">
          <source>We use the extension property &lt;code&gt;ptr&lt;/code&gt; which comes from &lt;code&gt;memScoped&lt;/code&gt; lambda receiver type to turn &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; instances into native pointers. Those pointers are only valid inside the &lt;code&gt;memScoped&lt;/code&gt; block.</source>
          <target state="translated">我们使用来自 &lt;code&gt;memScoped&lt;/code&gt; lambda接收器类型的扩展属性 &lt;code&gt;ptr&lt;/code&gt; 将 &lt;code&gt;MyStruct&lt;/code&gt; 和 &lt;code&gt;MyUnion&lt;/code&gt; 实例转换为本机指针。这些指针仅在 &lt;code&gt;memScoped&lt;/code&gt; 块内部有效。</target>
        </trans-unit>
        <trans-unit id="3d19fb9c3674e9e7d03350ce663d175de7004c2d" translate="yes" xml:space="preserve">
          <source>We will be using &lt;a href=&quot;https://developer.android.com/studio/&quot;&gt;Android Studio&lt;/a&gt; for the Android part of the tutorial. It is also possible to use &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; Community or Ultimate edition.</source>
          <target state="translated">我们将在本教程的Android部分使用&lt;a href=&quot;https://developer.android.com/studio/&quot;&gt;Android Studio&lt;/a&gt;。也可以使用&lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt;社区版或Ultimate版。</target>
        </trans-unit>
        <trans-unit id="495de00f60f65274c47ffb67586fe526a49cb4f3" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for the example. You need to make sure you have the latest version of the Kotlin plugin installed, 1.3.x or newer. We select &lt;em&gt;File | New | Project&lt;/em&gt;, select &lt;em&gt;Kotlin | Kotlin (Multiplatform Library)&lt;/em&gt; and configure the project in the way we want.</source>
          <target state="translated">我们将使用IntelliJ IDEA Community Edition作为示例。您需要确保已安装最新版本的Kotlin插件1.3.x或更高版本。我们选择&lt;em&gt;文件|新增|项目&lt;/em&gt;，选择&lt;em&gt;Kotlin | Kotlin（多平台库）&lt;/em&gt;并按照我们想要的方式配置项目。</target>
        </trans-unit>
        <trans-unit id="9c7906ddfb7d83aa5b930b2241b862ba86c46dd5" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for this tutorial, though using Ultimate edition is possible as well.</source>
          <target state="translated">我们将在本教程中使用IntelliJ IDEA社区版,不过使用Ultimate版也是可以的。</target>
        </trans-unit>
        <trans-unit id="240e26cd69c673ca5063d1fec6c288458947715f" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for this tutorial, though using Ultimate edition is possible as well. The Kotlin plugin 1.3.x or higher should be installed in the IDE. This can be verified via the &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE. Native part of this project is written using Mac OS X, but don't worry if you are using another platform, the platform affects only directory names in this particular tutorial.</source>
          <target state="translated">本教程将使用IntelliJ IDEA社区版，但也可以使用Ultimate版。应该在IDE中安装Kotlin插件1.3.x或更高版本。可以通过&lt;em&gt;语言和框架&lt;/em&gt;进行验证&lt;em&gt;。&lt;/em&gt;IDE 的&lt;em&gt;&amp;ldquo;设置&amp;rdquo;&lt;/em&gt;（或&lt;em&gt;&amp;ldquo;首选项&amp;rdquo;&lt;/em&gt;）中的&lt;em&gt;&amp;ldquo; &lt;/em&gt;&lt;em&gt;Kotlin更新&amp;rdquo;&lt;/em&gt;部分。该项目的本机部分是使用Mac OS X编写的，但是如果您使用的是其他平台，请不要担心，该平台仅影响此特定教程中的目录名称。</target>
        </trans-unit>
        <trans-unit id="a5df86530b0f4b4eea42ee317054bed9ca2a9e03" translate="yes" xml:space="preserve">
          <source>We will be using the &lt;code&gt;x64 Native Tools Command Prompt &amp;lt;VERSION&amp;gt;&lt;/code&gt; console. We'll see the shortcut to open the console in the start menu. It comes with a Microsoft Visual Studio package.</source>
          <target state="translated">我们将使用 &lt;code&gt;x64 Native Tools Command Prompt &amp;lt;VERSION&amp;gt;&lt;/code&gt; 控制台。我们将在开始菜单中看到打开控制台的快捷方式。它带有Microsoft Visual Studio软件包。</target>
        </trans-unit>
        <trans-unit id="356ae5746574838fa3924ac6e010e44bd7dc600e" translate="yes" xml:space="preserve">
          <source>We will continue exploring more C language types and their representation in Kotlin/Native in next tutorials:</source>
          <target state="translated">我们将在接下来的教程中继续探索更多的C语言类型及其在Kotlin/Native中的表现形式。</target>
        </trans-unit>
        <trans-unit id="d5797487ddb0eb41e5d2e9c68ced4d766fd86f98" translate="yes" xml:space="preserve">
          <source>We will continue to explore more complicated C language types and their representation in Kotlin/Native in the next tutorials:</source>
          <target state="translated">我们将在接下来的教程中继续探索更复杂的C语言类型及其在Kotlin/Native中的表示。</target>
        </trans-unit>
        <trans-unit id="6cf9027aa102f6f0a5c64a43d077861c549d000f" translate="yes" xml:space="preserve">
          <source>We will cover this functionality with common tests and then publish the final library to Maven.</source>
          <target state="translated">我们将用常见的测试来覆盖这个功能,然后将最终的库发布到Maven。</target>
        </trans-unit>
        <trans-unit id="23c2f2e6b1a14ab9c7e2d8312c7379c2ecdd3c02" translate="yes" xml:space="preserve">
          <source>We will create a simple Kotlin/JavaScript library.</source>
          <target state="translated">我们将创建一个简单的Kotlin/JavaScript库。</target>
        </trans-unit>
        <trans-unit id="194f5ab4f85b03618fc04358b4a842a9d1306f59" translate="yes" xml:space="preserve">
          <source>We will then see something similar to this:</source>
          <target state="translated">我们就会看到类似这样的情况。</target>
        </trans-unit>
        <trans-unit id="3a29960a39a18059d04b2735de83331640c538de" translate="yes" xml:space="preserve">
          <source>We would like to emphasize that extension functions are dispatched &lt;strong&gt;statically&lt;/strong&gt;, i.e. they are not virtual by receiver type. This means that the extension function being called is determined by the type of the expression on which the function is invoked, not by the type of the result of evaluating that expression at runtime. For example:</source>
          <target state="translated">我们要强调的是，扩展功能是&lt;strong&gt;静态&lt;/strong&gt;分配的，即，它们不是由接收者类型虚拟的。这意味着被调用的扩展函数是由在其上调用该函数的表达式的类型确定的，而不是由在运行时对该表达式求值的结果的类型确定的。例如：</target>
        </trans-unit>
        <trans-unit id="b83946b87080a81db62683de18b3b00c28f7ba2c" translate="yes" xml:space="preserve">
          <source>We wouldn't know if this function would be invoked on only activities from our sources or on plain Java activities also. Because of this, we don&amp;rsquo;t use caching there, even if &lt;code&gt;MyActivity&lt;/code&gt; instance from the previous example is passed as a receiver.</source>
          <target state="translated">我们不知道是否仅在源代码中的活动或纯Java活动中调用此函数。因此，即使将上一个示例中的 &lt;code&gt;MyActivity&lt;/code&gt; 实例作为接收者进行传递，我们也不会在此处使用缓存。</target>
        </trans-unit>
        <trans-unit id="64fbc9430739427e8ecff708c04a32c1ecf8e64f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new API to &lt;code&gt;kotlin-reflect&lt;/code&gt; that can be used to enumerate all the direct subtypes of a &lt;code&gt;sealed&lt;/code&gt; class, namely &lt;code&gt;KClass.sealedSubclasses&lt;/code&gt;.</source>
          <target state="translated">我们在 &lt;code&gt;kotlin-reflect&lt;/code&gt; 中添加了一个新API ，可用于枚举 &lt;code&gt;sealed&lt;/code&gt; 类的所有直接子类型，即 &lt;code&gt;KClass.sealedSubclasses&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8104ed41ba0ad6b8cb42477062cc9a8702abbeec" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added one more action in IntelliJ IDEA 2020.1 with Gradle 6.0 and above &amp;ndash; &lt;strong&gt;Load Script Configurations&lt;/strong&gt;, which loads changes to the script configurations without updating the whole project. This takes much less time than reimporting the whole project.</source>
          <target state="translated">我们在具有Gradle 6.0及更高版本的IntelliJ IDEA 2020.1中添加了另一项操作&amp;ndash;&lt;strong&gt;加载脚本配置&lt;/strong&gt;，该加载无需更改整个项目即可加载对脚本配置的更改。与重新导入整个项目相比，这花费的时间要少得多。</target>
        </trans-unit>
        <trans-unit id="40438146e777422ec29b09a135f9a4faaaaf0ee2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve reworked how C interop libraries are built. With the new tooling, Kotlin/Native produces interop libraries up to 4 times as fast as before, and artifacts are 25% to 30% the size they used to be.</source>
          <target state="translated">我们重新设计了C互操作库的构建方式。使用新工具，Kotlin / Native可以生成互操作库，速度是之前的4倍，并且工件的大小是以前的25％到30％。</target>
        </trans-unit>
        <trans-unit id="280290f99293d030e512b76f98e946df19f3aa24" translate="yes" xml:space="preserve">
          <source>We'd start solving it by creating a Kotlin source file with an arbitrary name. &lt;code&gt;A.kt&lt;/code&gt; will do well. First, we need to implement a function specified in the problem statement as:</source>
          <target state="translated">我们将通过使用任意名称创建Kotlin源文件来开始解决它。 &lt;code&gt;A.kt&lt;/code&gt; 会做的很好。首先，我们需要将问题语句中指定的功能实现为：</target>
        </trans-unit>
        <trans-unit id="48dd517a499e14c158e9fa4782184f8188502e0f" translate="yes" xml:space="preserve">
          <source>We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;getting-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</source>
          <target state="translated">我们将使用IntelliJ IDEA（最终版或社区版）。要了解如何在IntelliJ IDEA中启动新的Kotlin项目，请参阅&lt;a href=&quot;getting-started&quot;&gt;IntellJ IDEA入门&lt;/a&gt;教程。如果您使用的是构建工具，请参见&amp;ldquo; &lt;a href=&quot;build-tools&quot;&gt;构建工具&amp;rdquo;&lt;/a&gt;下的相应条目。</target>
        </trans-unit>
        <trans-unit id="13befb7a01cdbb85144f68b9efce98f561e6a626" translate="yes" xml:space="preserve">
          <source>We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;jvm-get-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</source>
          <target state="translated">我们将使用IntelliJ IDEA（最终版或社区版）。要了解如何在IntelliJ IDEA中启动新的Kotlin项目，请参阅&lt;a href=&quot;jvm-get-started&quot;&gt;IntellJ IDEA入门&lt;/a&gt;教程。如果您使用的是构建工具，请参见&amp;ldquo;&lt;a href=&quot;build-tools&quot;&gt;构建工具&amp;rdquo;&lt;/a&gt;下的相应条目。</target>
        </trans-unit>
        <trans-unit id="1f7aa73d697a63f1be8df9974161860c77d7f65f" translate="yes" xml:space="preserve">
          <source>We'll create a new Android project via &lt;em&gt;Start New Android Project&lt;/em&gt; item. If using IntelliJ IDEA, we need to select &lt;em&gt;Android&lt;/em&gt; in the left panel of the &lt;em&gt;New Project&lt;/em&gt; wizard.</source>
          <target state="translated">我们将通过&amp;ldquo; &lt;em&gt;开始新的Android项目&amp;rdquo;&lt;/em&gt;项创建一个新的Android项目。如果使用IntelliJ IDEA，我们需要在&lt;em&gt;New Project&lt;/em&gt;向导的左侧面板中选择&lt;em&gt;Android&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adbf109def75db2c462938914849c5eb6eed73eb" translate="yes" xml:space="preserve">
          <source>We'll learn how to:</source>
          <target state="translated">我们将学习如何。</target>
        </trans-unit>
        <trans-unit id="65dfa3289b9a70c638718585acaabd5931d1b082" translate="yes" xml:space="preserve">
          <source>We'll look at &lt;a href=&quot;android-frameworks#dagger&quot;&gt;Dagger&lt;/a&gt;, &lt;a href=&quot;android-frameworks#butterknife&quot;&gt;Butterknife&lt;/a&gt;, &lt;a href=&quot;android-frameworks#data-binding&quot;&gt;Data Binding&lt;/a&gt; and &lt;a href=&quot;android-frameworks#dbflow&quot;&gt;DBFlow&lt;/a&gt; (other frameworks can be set up similarly). All these frameworks work through annotation processing: you annotate the code to have the boiler-plate code generated for you. Annotations allow to hide all the verbosity and keep your code simple, and if you need to understand what actually happens at runtime, you can look at the generated code. Note that all these frameworks generate source code in Java, not Kotlin.</source>
          <target state="translated">我们将看看&lt;a href=&quot;android-frameworks#dagger&quot;&gt;Dagger&lt;/a&gt;，&lt;a href=&quot;android-frameworks#butterknife&quot;&gt;Butterknife&lt;/a&gt;，&lt;a href=&quot;android-frameworks#data-binding&quot;&gt;Data Binding&lt;/a&gt;和&lt;a href=&quot;android-frameworks#dbflow&quot;&gt;DBFlow&lt;/a&gt;（其他框架可以类似地设置）。所有这些框架都通过注释处理工作：对代码进行注释，以为您生成样板代码。注释可以隐藏所有的详细信息，并使代码保持简单，如果您需要了解运行时实际发生的情况，则可以查看生成的代码。请注意，所有这些框架均使用Java而非Kotlin生成源代码。</target>
        </trans-unit>
        <trans-unit id="c7ac9f8cb4bffee3deae462c300ad8acc7b22566" translate="yes" xml:space="preserve">
          <source>We'll use the following &lt;code&gt;build.gradle&lt;/code&gt;&lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle build file with the following contents:</source>
          <target state="translated">我们将使用以下 &lt;code&gt;build.gradle&lt;/code&gt; &lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle构建文件，其内容如下：</target>
        </trans-unit>
        <trans-unit id="35e9daf2777de53728fdd63d8121926825802dd9" translate="yes" xml:space="preserve">
          <source>We're allowed to pass a &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;boast()&lt;/code&gt; because &lt;code&gt;Car&lt;/code&gt; is a subclass of &lt;code&gt;MotorVehicle&lt;/code&gt;. We're allowed to pass a &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;ride()&lt;/code&gt; because &lt;code&gt;Car&lt;/code&gt; implements &lt;code&gt;Driveable&lt;/code&gt; (thanks to being a subclass &lt;code&gt;MotorVehicle&lt;/code&gt;). Inside &lt;code&gt;boast()&lt;/code&gt;, we're only allowed to access the members of the declared parameter type &lt;code&gt;MotorVehicle&lt;/code&gt;, even if we're in a situation where we know that it's really a &lt;code&gt;Car&lt;/code&gt; (because there could be other callers that pass a non-&lt;code&gt;Car&lt;/code&gt;). Inside &lt;code&gt;ride()&lt;/code&gt;, we're only allowed to access the members of the declared parameter type &lt;code&gt;Driveable&lt;/code&gt;. This ensures that every member lookup is safe - the compiler only allows you to pass objects that are guaranteed to have the necessary members. The downside is that you will sometimes be forced to declare &quot;unnecessary&quot; interfaces or wrapper classes in order to make a function accept instances of different classes.</source>
          <target state="translated">我们允许一个通过 &lt;code&gt;Car&lt;/code&gt; 来 &lt;code&gt;boast()&lt;/code&gt; ，因为 &lt;code&gt;Car&lt;/code&gt; 是一个子类 &lt;code&gt;MotorVehicle&lt;/code&gt; 。我们可以将 &lt;code&gt;Car&lt;/code&gt; 传递给 &lt;code&gt;ride()&lt;/code&gt; ,因为 &lt;code&gt;Car&lt;/code&gt; 实现了 &lt;code&gt;Driveable&lt;/code&gt; （由于是 &lt;code&gt;MotorVehicle&lt;/code&gt; 的子类）。在 &lt;code&gt;boast()&lt;/code&gt; 内部，即使我们处在已知它确实是 &lt;code&gt;Car&lt;/code&gt; 的情况下，也只允许访问声明的参数类型 &lt;code&gt;MotorVehicle&lt;/code&gt; 的成员（因为可能有其他调用者传递非 &lt;code&gt;Car&lt;/code&gt; 的信息)）。内 &lt;code&gt;ride()&lt;/code&gt; ，我们只允许访问声明的参数类型 &lt;code&gt;Driveable&lt;/code&gt; 的成员。这样可以确保每个成员查找都是安全的-编译器仅允许您传递保证具有必需成员的对象。缺点是有时会迫使您声明&amp;ldquo;不必要的&amp;rdquo;接口或包装器类，以使函数接受不同类的实例。</target>
        </trans-unit>
        <trans-unit id="a12f1bb4ce7d202790746259d8059bc20b4c1c93" translate="yes" xml:space="preserve">
          <source>We're going to see how to set up TeamCity to build our Kotlin project. For more information and basics of TeamCity please check the &lt;a href=&quot;https://www.jetbrains.com/teamcity/documentation/&quot;&gt;Documentation page&lt;/a&gt; which contains information about installation, basic configuration, etc.</source>
          <target state="translated">我们将看到如何设置TeamCity来构建我们的Kotlin项目。有关TeamCity的更多信息和基础，请查看&amp;ldquo; &lt;a href=&quot;https://www.jetbrains.com/teamcity/documentation/&quot;&gt;文档&amp;rdquo;页面&lt;/a&gt;，其中包含有关安装，基本配置等的信息。</target>
        </trans-unit>
        <trans-unit id="dfe8cb673d9e8e417b1ac641d5d52b9b44cf3e8b" translate="yes" xml:space="preserve">
          <source>We're not going to cover the &lt;a href=&quot;../../reference/control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt; in depth here since it doesn't have a close equivalent in Python, but check it out - it's pretty nifty, as it lets you compare one expression against many kinds of expressions in a very compact way (but it's not a full functional-programming-style pattern matcher). For example:</source>
          <target state="translated">我们不会在这里深入介绍&lt;a href=&quot;../../reference/control-flow#when-expression&quot;&gt; &lt;code&gt;when&lt;/code&gt; 表达式&lt;/a&gt;，因为它在Python中没有非常接近的等效表达式，但是请检查一下-这非常漂亮，因为它使您可以非常紧凑地比较一个表达式与多种表达式方式（但这不是完整的功能编程风格的模式匹配器）。例如：</target>
        </trans-unit>
        <trans-unit id="859b2e88a4b107551034ec5b70f0408cd92fac5e" translate="yes" xml:space="preserve">
          <source>We've also added the &lt;code&gt;ArrayDeque&lt;/code&gt; class &amp;ndash; an implementation of a double-ended queue. Double-ended queue lets you can add or remove elements both at the beginning and the end of the queue in an amortized constant time. You can use a double-ended queue by default when you need a queue or a stack in your code.</source>
          <target state="translated">我们还添加了 &lt;code&gt;ArrayDeque&lt;/code&gt; 类&amp;ndash;一个双端队列的实现。双端队列使您可以在摊销后的固定时间内在队列的开头和结尾处添加或删除元素。当您在代码中需要队列或堆栈时，默认情况下可以使用双端队列。</target>
        </trans-unit>
        <trans-unit id="7a6d4821c53a1c0b88e02c8ce15a60335e60fc0a" translate="yes" xml:space="preserve">
          <source>We've converted the ButterKnife &lt;a href=&quot;https://github.com/JakeWharton/butterknife/tree/master/sample/app/src/main/java/com/example&quot;&gt;sample&lt;/a&gt; to Kotlin. The resulting code can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-butterknife&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">我们已经将ButterKnife &lt;a href=&quot;https://github.com/JakeWharton/butterknife/tree/master/sample/app/src/main/java/com/example&quot;&gt;样本&lt;/a&gt;转换为Kotlin。结果代码可以在&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-butterknife&quot;&gt;这里&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="30d2a23216aee2ca42dc00c09139bd8bf210d9fc" translate="yes" xml:space="preserve">
          <source>We've deprecated the &lt;code&gt;contains()&lt;/code&gt;, &lt;code&gt;indexOf()&lt;/code&gt;, and &lt;code&gt;lastIndexOf()&lt;/code&gt; extension functions of &lt;code&gt;FloatArray&lt;/code&gt; and &lt;code&gt;DoubleArray&lt;/code&gt; because they use the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt; standard equality, which contradicts the total order equality in some corner cases. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-28753&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">我们已弃用 &lt;code&gt;FloatArray&lt;/code&gt; 和 &lt;code&gt;DoubleArray&lt;/code&gt; 的 &lt;code&gt;contains()&lt;/code&gt; ， &lt;code&gt;indexOf()&lt;/code&gt; 和 &lt;code&gt;lastIndexOf()&lt;/code&gt; 扩展函数，因为它们使用&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt;标准等式，这在某些特殊情况下与总顺序等式相矛盾。有关详细信息，请参&lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-28753&quot;&gt;见此问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9565458367bc75e7700ec47534de831e4a66b878" translate="yes" xml:space="preserve">
          <source>We've deprecated the &lt;code&gt;min()&lt;/code&gt; and &lt;code&gt;max()&lt;/code&gt; collection functions in favor of &lt;code&gt;minOrNull()&lt;/code&gt; and &lt;code&gt;maxOrNull()&lt;/code&gt;, which more properly reflect their behavior &amp;ndash; returning &lt;code&gt;null&lt;/code&gt; on empty collections. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-38854&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">我们不建议使用 &lt;code&gt;min()&lt;/code&gt; 和 &lt;code&gt;max()&lt;/code&gt; 集合函数，而 &lt;code&gt;minOrNull()&lt;/code&gt; 和 &lt;code&gt;maxOrNull()&lt;/code&gt; ，它们更恰当地反映了它们的行为&amp;ndash;在空集合上返回 &lt;code&gt;null&lt;/code&gt; 。有关详细信息，请参&lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-38854&quot;&gt;见此问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="215b5a7efdc1c89ee7092df264b96d7d1f704519" translate="yes" xml:space="preserve">
          <source>We've deprecated the functions &lt;code&gt;toShort()&lt;/code&gt; and &lt;code&gt;toByte()&lt;/code&gt; on &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; because they could lead to unexpected results because of the narrow value range and smaller variable size.</source>
          <target state="translated">我们不 &lt;code&gt;toShort()&lt;/code&gt; 在 &lt;code&gt;Double&lt;/code&gt; 和 &lt;code&gt;Float&lt;/code&gt; 上使用toShort（）和 &lt;code&gt;toByte()&lt;/code&gt; 函数，因为它们的值范围狭窄且变量大小较小，可能导致意外结果。</target>
        </trans-unit>
        <trans-unit id="61c686dd7fee7d596ed3150966a1df858b5684ea" translate="yes" xml:space="preserve">
          <source>We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">现在，我们已经看到了所有定义，现在是修复代码的时候了。让我们&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;在IDE中&lt;/a&gt;运行 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle任务，或使用以下命令运行代码：</target>
        </trans-unit>
        <trans-unit id="7303eeb28a81c2ad71ddaf7a7ef26c96a5d46db5" translate="yes" xml:space="preserve">
          <source>We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">现在，我们已经看到了所有定义，现在是修复代码的时候了。让我们&lt;a href=&quot;using-intellij-idea&quot;&gt;在IDE中&lt;/a&gt;运行 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle任务，或使用以下命令运行代码：</target>
        </trans-unit>
        <trans-unit id="8159d531b6661d9ca1d3ee3cd78cdb26173e7e20" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">我们已经看到了所有定义，现在是修复代码的时候了。让我们&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;在IDE中&lt;/a&gt;运行 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle任务，或使用以下命令运行代码：</target>
        </trans-unit>
        <trans-unit id="5060dcbe8547bb3d7e1fb6bf0d1175fce384646a" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">我们已经看到了所有定义，现在是修复代码的时候了。让我们&lt;a href=&quot;using-intellij-idea&quot;&gt;在IDE中&lt;/a&gt;运行 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle任务，或使用以下命令运行代码：</target>
        </trans-unit>
        <trans-unit id="d875c328d56b6ba3de658fff30f901e7a7dadd62" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">我们已经看到了所有定义，现在是修复和运行代码的时候了。让我们&lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;在IDE中&lt;/a&gt;运行 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle任务，或使用以下命令运行代码：</target>
        </trans-unit>
        <trans-unit id="6a79043503070152826fab6d2dc8528967704ffa" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">我们已经看到了所有定义，是时候修复和运行代码了。让我们&lt;a href=&quot;using-intellij-idea&quot;&gt;在IDE中&lt;/a&gt;运行 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle任务，或使用以下命令运行代码：</target>
        </trans-unit>
        <trans-unit id="a792d756a38347597c27360412bb8f8fa517b753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;AN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;AN&quot;。</target>
        </trans-unit>
        <trans-unit id="24dbecca4697c39dcb12d83d3e21e053a4fbf4ac" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;BN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;BN&quot;。</target>
        </trans-unit>
        <trans-unit id="b592dbfa74287749b5b330052c7e3f462ec0a974" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;CS&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;CS&quot;。</target>
        </trans-unit>
        <trans-unit id="d484194528c4965d5cfe46ac4072c437b4f7364f" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;EN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;EN&quot;。</target>
        </trans-unit>
        <trans-unit id="73f96fcc50384aeb2e177d07991c8003c66a6753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ES&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;ES&quot;。</target>
        </trans-unit>
        <trans-unit id="818ef5444e8d72a94e14f04b5d6b122d1830655b" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ET&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;ET&quot;。</target>
        </trans-unit>
        <trans-unit id="34c6763955af9013896491090181dbcd5a8dd74c" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;NSM&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;NSM&quot;。</target>
        </trans-unit>
        <trans-unit id="956c2a4c465d4b08d54fa1ddb34419c1810351ef" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;PDF&quot; in the Unicode specification.</source>
          <target state="translated">Unicode规范中的弱双向字符类型 &quot;PDF&quot;。</target>
        </trans-unit>
        <trans-unit id="5ea903ebda4f9f28f642d78e916dc09051395c95" translate="yes" xml:space="preserve">
          <source>WeakReference</source>
          <target state="translated">WeakReference</target>
        </trans-unit>
        <trans-unit id="051061c35dede06e751f127657cfd8dabc9b47ce" translate="yes" xml:space="preserve">
          <source>WebAssembly</source>
          <target state="translated">WebAssembly</target>
        </trans-unit>
        <trans-unit id="10cf3089a5d1b6f0fd308ab8ea55feb903fcea98" translate="yes" xml:space="preserve">
          <source>WebAssembly (wasm32)</source>
          <target state="translated">WebAssembly (wasm32)</target>
        </trans-unit>
        <trans-unit id="54a290ccb466e5479f81f8b2a84a8c409c89300b" translate="yes" xml:space="preserve">
          <source>WebGLActiveInfo</source>
          <target state="translated">WebGLActiveInfo</target>
        </trans-unit>
        <trans-unit id="e6b73caf842064140299b1ca0b4460e6e2d7b8db" translate="yes" xml:space="preserve">
          <source>WebGLContextAttributes</source>
          <target state="translated">WebGLContextAttributes</target>
        </trans-unit>
        <trans-unit id="4270da2ffdc4cd7b0f031d7be5d3da6756d9f418" translate="yes" xml:space="preserve">
          <source>WebGLContextEventInit</source>
          <target state="translated">WebGLContextEventInit</target>
        </trans-unit>
        <trans-unit id="40e776dc5c04c24ed694e56559baff72c6650985" translate="yes" xml:space="preserve">
          <source>WebGLObject</source>
          <target state="translated">WebGLObject</target>
        </trans-unit>
        <trans-unit id="21ae6cd2acfef9ca69acf1201e1d6a74d9cbc06a" translate="yes" xml:space="preserve">
          <source>WebGLRenderingContext</source>
          <target state="translated">WebGLRenderingContext</target>
        </trans-unit>
        <trans-unit id="4801b56eb1b5d686e9a1febe6821b4d7326421a2" translate="yes" xml:space="preserve">
          <source>WebGLRenderingContextBase</source>
          <target state="translated">WebGLRenderingContextBase</target>
        </trans-unit>
        <trans-unit id="5484abb27b9c8304c0334e77ca1817b8faf244f4" translate="yes" xml:space="preserve">
          <source>WebGLShaderPrecisionFormat</source>
          <target state="translated">WebGLShaderPrecisionFormat</target>
        </trans-unit>
        <trans-unit id="598b5bbd37e1ce6914df736dcaf0620916e3e37e" translate="yes" xml:space="preserve">
          <source>WebGLUniformLocation</source>
          <target state="translated">WebGLUniformLocation</target>
        </trans-unit>
        <trans-unit id="3a3301048780c886766fd5f9fc46f7ed9edce741" translate="yes" xml:space="preserve">
          <source>Webpack provides two different &quot;flavors&quot; of CommonJS, &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt;, which affect the way your declarations are made available. While in most cases, you probably want &lt;code&gt;commonjs2&lt;/code&gt;, which adds the &lt;code&gt;module.exports&lt;/code&gt; syntax to the generated library, you can also opt for the &quot;pure&quot; &lt;code&gt;commonjs&lt;/code&gt; option, which implements the CommonJS specification exactly. To learn more about the difference between &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt;, check &lt;a href=&quot;https://github.com/webpack/webpack/issues/1114&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">的WebPack提供的CommonJS的，两个不同的&amp;ldquo;口味&amp;rdquo; &lt;code&gt;commonjs&lt;/code&gt; 和 &lt;code&gt;commonjs2&lt;/code&gt; ，这会影响你的声明提供的方式。尽管在大多数情况下，您可能希望使用 &lt;code&gt;commonjs2&lt;/code&gt; ，该模块将 &lt;code&gt;module.exports&lt;/code&gt; 语法添加到所生成的库中，但是您也可以选择&amp;ldquo; pure&amp;rdquo; &lt;code&gt;commonjs&lt;/code&gt; 选项，该选项完全实现了CommonJS规范。要了解有关 &lt;code&gt;commonjs&lt;/code&gt; 和 &lt;code&gt;commonjs2&lt;/code&gt; 之间的区别的更多信息，请&lt;a href=&quot;https://github.com/webpack/webpack/issues/1114&quot;&gt;在此处&lt;/a&gt;检查。</target>
        </trans-unit>
        <trans-unit id="ee12f5d174e362fdee2c3d0937fed7a0a0418b29" translate="yes" xml:space="preserve">
          <source>What IDEs support Kotlin?</source>
          <target state="translated">哪些IDE支持Kotlin?</target>
        </trans-unit>
        <trans-unit id="f19e03186b38de86427a604326b5e20ce36b16e0" translate="yes" xml:space="preserve">
          <source>What Java has that Kotlin does not</source>
          <target state="translated">Java有哪些Kotlin没有的东西</target>
        </trans-unit>
        <trans-unit id="7c25e3810f499ecbecfd573d100c2992ec85dfee" translate="yes" xml:space="preserve">
          <source>What Kotlin has that Java does not</source>
          <target state="translated">Kotlin拥有Java没有的东西</target>
        </trans-unit>
        <trans-unit id="a0618cd665f03aa3f49f142cd97a9d8c33d6f6d0" translate="yes" xml:space="preserve">
          <source>What advantages does Kotlin give me over the Java programming language?</source>
          <target state="translated">与Java编程语言相比,Kotlin给我带来了哪些优势?</target>
        </trans-unit>
        <trans-unit id="2ec574e0a3bc1f92310ec6597730108793dbab22" translate="yes" xml:space="preserve">
          <source>What are we building?</source>
          <target state="translated">我们在建造什么?</target>
        </trans-unit>
        <trans-unit id="54d0e194d6d22dc2c5cc598434a07c74290a1df0" translate="yes" xml:space="preserve">
          <source>What build tools support Kotlin?</source>
          <target state="translated">哪些构建工具支持Kotlin?</target>
        </trans-unit>
        <trans-unit id="b663cb1b85b44f2ed22f76f75c249fd71cd30ee5" translate="yes" xml:space="preserve">
          <source>What can I use Kotlin for?</source>
          <target state="translated">我可以用Kotlin做什么?</target>
        </trans-unit>
        <trans-unit id="1c253aa8f7093e6c010267944ec10ed903d9b3d6" translate="yes" xml:space="preserve">
          <source>What companies are using Kotlin?</source>
          <target state="translated">哪些公司在使用Kotlin?</target>
        </trans-unit>
        <trans-unit id="05e8ab4ca375bf042d9384276202b934420c2059" translate="yes" xml:space="preserve">
          <source>What do we do if need to invoke them &lt;em&gt;sequentially&lt;/em&gt; &amp;ndash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt;&lt;em&gt;and then&lt;/em&gt;&lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and compute the sum of their results? In practice we do this if we use the results of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</source>
          <target state="translated">如果需要&lt;em&gt;顺序&lt;/em&gt;调用它们，我们该怎么办&amp;ndash;首先执行 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; &lt;em&gt;，然后执行&lt;/em&gt; &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; ，&lt;em&gt;然后&lt;/em&gt;计算其结果的总和？在实践中，如果我们使用第一个函数的结果来决定是否需要调用第二个函数或决定如何调用第二个函数，就可以这样做。</target>
        </trans-unit>
        <trans-unit id="ec5e65d31d420634cb6bd22727661d2a91c1e71b" translate="yes" xml:space="preserve">
          <source>What do we do if we need them to be invoked &lt;em&gt;sequentially&lt;/em&gt; &amp;mdash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt;&lt;em&gt;and then&lt;/em&gt;&lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;, and compute the sum of their results? In practice we do this if we use the result of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</source>
          <target state="translated">如果我们需要&lt;em&gt;顺序&lt;/em&gt;调用它们，该怎么办&amp;mdash;首先执行 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; &lt;em&gt;，然后执行&lt;/em&gt; &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; ，然后计算其结果的总和？在实践中，如果我们使用第一个函数的结果来决定是否需要调用第二个函数或决定如何调用第二个函数，就可以这样做。</target>
        </trans-unit>
        <trans-unit id="e75dc4fbbde8bc3398e1fc23b66dca3f704f50fe" translate="yes" xml:space="preserve">
          <source>What does Kotlin compile down to?</source>
          <target state="translated">Kotlin编译成什么?</target>
        </trans-unit>
        <trans-unit id="cbc1b72459c6cd091c4b5fc250725f50ac98c379" translate="yes" xml:space="preserve">
          <source>What does it print at the end? It is highly unlikely to ever print &quot;Counter = 100000&quot;, because a hundred coroutines increment the &lt;code&gt;counter&lt;/code&gt; concurrently from multiple threads without any synchronization.</source>
          <target state="translated">最后显示什么？几乎不可能打印&amp;ldquo; Counter = 100000&amp;rdquo;，因为一百个协程从多个线程同时增加了 &lt;code&gt;counter&lt;/code&gt; ，而没有任何同步。</target>
        </trans-unit>
        <trans-unit id="18807a12b7e25a451e442847837857201bfc7505" translate="yes" xml:space="preserve">
          <source>What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt;, some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt;. Why? Because it might be performing IO (&lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt;)&amp;hellip; So it results in this kind of code all over the place:</source>
          <target state="translated">这个签名怎么说？它说，每次我将字符串附加到某个东西（ &lt;code&gt;StringBuilder&lt;/code&gt; ，某种日志，控制台等）时，我都必须捕获那些 &lt;code&gt;IOExceptions&lt;/code&gt; 。为什么？因为它可能正在执行IO（ &lt;code&gt;Writer&lt;/code&gt; 也实现了 &lt;code&gt;Appendable&lt;/code&gt; ）&amp;hellip;&amp;hellip;所以它到处都是这种代码：</target>
        </trans-unit>
        <trans-unit id="7f65d1bc84288a4305aabbbfaad8cd7fe25a6b3d" translate="yes" xml:space="preserve">
          <source>What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt;, some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt;. Why? Because it might be performing IO (&lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt;)&amp;hellip; So it results into this kind of code all over the place:</source>
          <target state="translated">这个签名怎么说？它说每次我将字符串附加到某个东西（ &lt;code&gt;StringBuilder&lt;/code&gt; ，某种日志，控制台等）时，都必须捕获那些 &lt;code&gt;IOExceptions&lt;/code&gt; 。为什么？因为它可能正在执行IO（ &lt;code&gt;Writer&lt;/code&gt; 也实现了 &lt;code&gt;Appendable&lt;/code&gt; ）&amp;hellip;&amp;hellip;所以它到处都是这种代码：</target>
        </trans-unit>
        <trans-unit id="683b8d36e158b49d7282ac38785e02d0ec00e146" translate="yes" xml:space="preserve">
          <source>What happens if multiple children of a coroutine throw an exception? The general rule is &quot;the first exception wins&quot;, so the first thrown exception is exposed to the handler. But that may cause lost exceptions, for example if coroutine throws an exception in its &lt;code&gt;finally&lt;/code&gt; block. So, additional exceptions are suppressed.</source>
          <target state="translated">如果协程的多个子级抛出异常会怎样？一般规则是&amp;ldquo;第一个异常获胜&amp;rdquo;，因此第一个引发的异常向处理程序公开。但这可能会导致丢失的异常，例如，协程在其 &lt;code&gt;finally&lt;/code&gt; 块中抛出异常。因此，抑制了其他异常。</target>
        </trans-unit>
        <trans-unit id="365b6a79e0879610a6d21849bc8cc5cf6d51d197" translate="yes" xml:space="preserve">
          <source>What has happened here is called &lt;strong&gt;type projection&lt;/strong&gt;: we said that &lt;code&gt;from&lt;/code&gt; is not simply an array, but a restricted (&lt;strong&gt;projected&lt;/strong&gt;) one: we can only call those methods that return the type parameter &lt;code&gt;T&lt;/code&gt;, in this case it means that we can only call &lt;code&gt;get()&lt;/code&gt;. This is our approach to &lt;strong&gt;use-site variance&lt;/strong&gt;, and corresponds to Java's &lt;code&gt;Array&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, but in a slightly simpler way.</source>
          <target state="translated">这里发生的事情称为&lt;strong&gt;类型投影&lt;/strong&gt;：我们说 &lt;code&gt;from&lt;/code&gt; 不是简单的数组，而是受限制的（&lt;strong&gt;投影&lt;/strong&gt;）数组：我们只能调用那些返回类型参数 &lt;code&gt;T&lt;/code&gt; 的方法，在这种情况下，这意味着我们只能调用 &lt;code&gt;get()&lt;/code&gt; 。这是我们&lt;strong&gt;使用地点差异的方法&lt;/strong&gt;，并且与Java的 &lt;code&gt;Array&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 相对应。扩展Object&amp;gt;，但以一种稍微简单的方式。</target>
        </trans-unit>
        <trans-unit id="77aa02de8be96f4d1a2d486916d80f88707bf2e0" translate="yes" xml:space="preserve">
          <source>What if there are no dependencies between invocation of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</source>
          <target state="translated">如果在 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 和 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 的调用之间没有依赖关系并且我们希望通过&lt;em&gt;同时&lt;/em&gt;执行这两者来更快地得到答案，该怎么办？这是&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;帮助的地方。</target>
        </trans-unit>
        <trans-unit id="6a9d26c1d8e7803f441abc75ddaa9a3cb6ee5810" translate="yes" xml:space="preserve">
          <source>What if there are no dependencies between invocations of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</source>
          <target state="translated">如果 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 和 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 的调用之间没有依赖关系，并且我们希望通过&lt;em&gt;同时&lt;/em&gt;执行这两者来更快地得到答案，该怎么办？这是&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;异步&lt;/a&gt;帮助的地方。</target>
        </trans-unit>
        <trans-unit id="e3c61df73a1cd1792c66d92381a767d6d084db44" translate="yes" xml:space="preserve">
          <source>What is Kotlin?</source>
          <target state="translated">什么是Kotlin?</target>
        </trans-unit>
        <trans-unit id="9c97b9a8111f68ce8c52dfe8c2a3959e4d0cfd92" translate="yes" xml:space="preserve">
          <source>What is the current version of Kotlin?</source>
          <target state="translated">目前Kotlin的版本是什么?</target>
        </trans-unit>
        <trans-unit id="72b9dc537736b5c80161df96b96d566c2340d8ed" translate="yes" xml:space="preserve">
          <source>What types do we have in the C language? Let's first list all of them. I have used the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_data_types&quot;&gt;C data types&lt;/a&gt; article from Wikipedia as a basis. There are following types in the C programming language:</source>
          <target state="translated">我们使用C语言有哪些类型？让我们首先列出所有这些。我以Wikipedia 的&lt;a href=&quot;https://en.wikipedia.org/wiki/C_data_types&quot;&gt;C数据类型&lt;/a&gt;文章为基础。C编程语言中有以下几种类型：</target>
        </trans-unit>
        <trans-unit id="b3a3d061e51769639781e9a3b9954e0ba115ec4b" translate="yes" xml:space="preserve">
          <source>What we actually want is simply pass a type to this function, i.e. call it like this:</source>
          <target state="translated">其实我们想要的是简单地传递一个类型给这个函数,即这样调用它。</target>
        </trans-unit>
        <trans-unit id="a50c7ef1f0fafc2256df6585bc99119f3c512a67" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.1</source>
          <target state="translated">Kotlin 1.1的新增功能</target>
        </trans-unit>
        <trans-unit id="9a4d9d06c26d113727033d8ae4c1b63e386642d5" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.2</source>
          <target state="translated">Kotlin 1.2的新功能</target>
        </trans-unit>
        <trans-unit id="293419c5954282d33701ae5e04016a88fddb332a" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.3</source>
          <target state="translated">Kotlin 1.3的新功能</target>
        </trans-unit>
        <trans-unit id="9389cd373bffcc015f87751d1dc27567fa32b8ba" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.1</source>
          <target state="translated">Kotlin 1.1中的新内容</target>
        </trans-unit>
        <trans-unit id="39982142e8f2af3375fc2ff57e8c12a82c314d40" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.2</source>
          <target state="translated">Kotlin 1.2中的新内容</target>
        </trans-unit>
        <trans-unit id="215e0c6f310ade62568bdc051de3a2c9b6801880" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.3</source>
          <target state="translated">Kotlin 1.3中的新内容</target>
        </trans-unit>
        <trans-unit id="5d9f851e585b75f9f88496923e3d47ca44295647" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.4.0</source>
          <target state="translated">Kotlin 1.4.0中的新内容</target>
        </trans-unit>
        <trans-unit id="3d4b36bc57457b9920995102b0eb6da42363fb68" translate="yes" xml:space="preserve">
          <source>What's next?</source>
          <target state="translated">下一步是什么?</target>
        </trans-unit>
        <trans-unit id="18389155bba5ed3245c0f065f5a1c5b22a9f917a" translate="yes" xml:space="preserve">
          <source>Whatever way you choose to solve koans, you can see the solution for each task: in the online version click on &quot;Show answer&quot;, inside EduTools plugin choose &quot;Peek solution&quot;. We recommend checking the solution after you implement the task to compare your solution with the proposed one. Make sure you don't cheat!</source>
          <target state="translated">无论你选择何种方式解考,都可以看到每个任务的解决方案:在在线版中点击 &quot;显示答案&quot;,在EduTools插件里面选择 &quot;窥视解决方案&quot;。我们建议在你实现任务后检查解决方案,以比较你的解决方案与建议的解决方案。确保你不作弊!</target>
        </trans-unit>
        <trans-unit id="00a0667e561fb370ec041d741f3ea97adc25dc28" translate="yes" xml:space="preserve">
          <source>WheelEventInit</source>
          <target state="translated">WheelEventInit</target>
        </trans-unit>
        <trans-unit id="e3117f509259d5d29ab1ad441436b902cca8f031" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</source>
          <target state="translated">如果&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;覆盖&lt;/a&gt;为 &lt;code&gt;true&lt;/code&gt; ,并且&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt;为目录，则仅当它为空时才替换它。</target>
        </trans-unit>
        <trans-unit id="f0d8a684192ba53b6aed7c801b9b7ef648714954" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</source>
          <target state="translated">如果&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;覆盖&lt;/a&gt;为 &lt;code&gt;true&lt;/code&gt; ,并且&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt;为目录，则仅当该目录为空时才替换它。</target>
        </trans-unit>
        <trans-unit id="2d29ca92f5092a739732a54c47f3da4e556b36a7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;mpp-create-lib&quot;&gt;creating a project with the Project Wizard&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;mpp-create-lib&quot;&gt;创建与项目向导项目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f50fe0838c0d3908e85b9819f34dd2e3eeee8c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</source>
          <target state="translated">当不带参数使用 &lt;code&gt;launch { ... }&lt;/code&gt; ，它将从要启动的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;继承上下文（并因此继承调度程序）。在这种情况下，它继承了在 &lt;code&gt;main&lt;/code&gt; 线程中运行的主 &lt;code&gt;runBlocking&lt;/code&gt; 协程的上下文。</target>
        </trans-unit>
        <trans-unit id="44dcaec5d16f5bf398df957b0d47d8f09a80f320" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; that it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</source>
          <target state="translated">如果在没有参数的情况下使用 &lt;code&gt;launch { ... }&lt;/code&gt; ，它将从要启动的&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;继承上下文（并因此继承调度程序）。在这种情况下，它继承了在 &lt;code&gt;main&lt;/code&gt; 线程中运行的主 &lt;code&gt;runBlocking&lt;/code&gt; 协程的上下文。</target>
        </trans-unit>
        <trans-unit id="a67ed24b676d6021025f2b0f67bd9c35fd94aa47" translate="yes" xml:space="preserve">
          <source>When Expression</source>
          <target state="translated">表达式时</target>
        </trans-unit>
        <trans-unit id="e8a56a195bc479e7e07a6420a30ef594182bfdc7" translate="yes" xml:space="preserve">
          <source>When Java types are imported into Kotlin, all the references of the type &lt;code&gt;java.lang.Object&lt;/code&gt; are turned into &lt;code&gt;Any&lt;/code&gt;. Since &lt;code&gt;Any&lt;/code&gt; is not platform-specific, it only declares &lt;code&gt;toString()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt; as its members, so to make other members of &lt;code&gt;java.lang.Object&lt;/code&gt; available, Kotlin uses &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;.</source>
          <target state="translated">将Java类型导入Kotlin后，所有类型为 &lt;code&gt;java.lang.Object&lt;/code&gt; 的引用都将转换为 &lt;code&gt;Any&lt;/code&gt; 。由于 &lt;code&gt;Any&lt;/code&gt; 不是特定于平台的，因此它仅声明 &lt;code&gt;toString()&lt;/code&gt; ， &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 作为其成员，因此为了使 &lt;code&gt;java.lang.Object&lt;/code&gt; 的其他成员可用，Kotlin使用了&lt;a href=&quot;extensions&quot;&gt;扩展功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de657bff6abe90a927125239467dfc7f66aa4d06" translate="yes" xml:space="preserve">
          <source>When Kotlin classes make use of &lt;a href=&quot;generics#declaration-site-variance&quot;&gt;declaration-site variance&lt;/a&gt;, there are two options of how their usages are seen from the Java code. Let's say we have the following class and two functions that use it:</source>
          <target state="translated">当Kotlin类使用&lt;a href=&quot;generics#declaration-site-variance&quot;&gt;声明位置方差时&lt;/a&gt;，有两种方法可以从Java代码中看到它们的用法。假设我们有以下类和两个使用它的函数：</target>
        </trans-unit>
        <trans-unit id="752a77d62b6432105ad9d079610666a77a3a539f" translate="yes" xml:space="preserve">
          <source>When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;a href=&quot;exception-classes#kotlin.Throws%24exceptionClasses&quot;&gt;exceptionClasses&lt;/a&gt; or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt;. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</source>
          <target state="translated">从Swift / Objective-C代码调用的Kotlin函数引发异常（该异常是&lt;a href=&quot;exception-classes#kotlin.Throws%24exceptionClasses&quot;&gt;exceptionClasses&lt;/a&gt;或其子类之一的实例）时，它会作为 &lt;code&gt;NSError&lt;/code&gt; 传播。其他到达Swift / Objective-C的Kotlin异常被视为未处理，并导致程序终止。</target>
        </trans-unit>
        <trans-unit id="8df342c27a1154aea786d8fd951c9e3bea894932" translate="yes" xml:space="preserve">
          <source>When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;code&gt;@Throws&lt;/code&gt;-specified classes or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt;. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</source>
          <target state="translated">当从Swift / Objective-C代码调用的Kotlin函数抛出一个异常（该异常是 &lt;code&gt;@Throws&lt;/code&gt; 指定的类或其子类之一的实例）时，它会作为 &lt;code&gt;NSError&lt;/code&gt; 传播。其他到达Swift / Objective-C的Kotlin异常被视为未处理，并导致程序终止。</target>
        </trans-unit>
        <trans-unit id="32316c9a35a40c6afef037fd3a597555044f54d5" translate="yes" xml:space="preserve">
          <source>When a C function takes or returns a struct / union &lt;code&gt;T&lt;/code&gt; by value, the corresponding argument type or return type is represented as &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当C函数通过值获取或返回struct / union &lt;code&gt;T&lt;/code&gt; 时，相应的参数类型或返回类型表示为 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbdcfd2e9efefb419f2bd9e89cb02a695c22cf07" translate="yes" xml:space="preserve">
          <source>When a big team is migrating onto a new version, it may appear in a &quot;inconsistent state&quot; at some point, when some developers have already updated, and others haven't. To prevent the former from writing and committing code that others may not be able to compile, we provide the following command line switches (also available in the IDE and &lt;a href=&quot;../using-gradle#compiler-options&quot;&gt;Gradle&lt;/a&gt;/&lt;a href=&quot;../using-maven#specifying-compiler-options&quot;&gt;Maven&lt;/a&gt;):</source>
          <target state="translated">当一个大团队迁移到新版本时，某些开发人员已经更新而其他开发人员没有更新时，它有时可能会处于&amp;ldquo;不一致状态&amp;rdquo;。为了防止前者编写和提交其他人可能无法编译的代码，我们提供了以下命令行开关（在IDE和&lt;a href=&quot;../using-gradle#compiler-options&quot;&gt;Gradle&lt;/a&gt; / &lt;a href=&quot;../using-maven#specifying-compiler-options&quot;&gt;Maven中&lt;/a&gt;也可用）：</target>
        </trans-unit>
        <trans-unit id="18b8e63399abd55d3bbbdde25d3e2fcb80bd3160" translate="yes" xml:space="preserve">
          <source>When a coroutine is launched in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; of another coroutine, it inherits its context via &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html&quot;&gt;CoroutineScope.coroutineContext&lt;/a&gt; and the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the new coroutine becomes a &lt;em&gt;child&lt;/em&gt; of the parent coroutine's job. When the parent coroutine is cancelled, all its children are recursively cancelled, too.</source>
          <target state="translated">当协程在推出&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;另一个协程，它通过继承它的上下文&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html&quot;&gt;CoroutineScope.coroutineContext&lt;/a&gt;和&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;招聘&lt;/a&gt;新协程成为&lt;em&gt;孩子&lt;/em&gt;的家长协程的工作。当父协程被取消时，其所有子进程也将被递归取消。</target>
        </trans-unit>
        <trans-unit id="8b40f9ca947a81bd12ef472c030664610317efac" translate="yes" xml:space="preserve">
          <source>When a data class derived from a type that already had the &lt;code&gt;copy&lt;/code&gt; function with the same signature, the &lt;code&gt;copy&lt;/code&gt; implementation generated for the data class used the defaults from the supertype, leading to counter-intuitive behavior, or failed at runtime if there were no default parameters in the supertype.</source>
          <target state="translated">当从已经具有具有相同签名的 &lt;code&gt;copy&lt;/code&gt; 功能的类型派生的数据类时，为该数据类生成的 &lt;code&gt;copy&lt;/code&gt; 实现使用超类型的默认值，从而导致违反直觉的行为，如果没有默认值，则在运行时失败超型中的参数。</target>
        </trans-unit>
        <trans-unit id="e1f3667f48b1b3a74567f895c3f805750be29c9e" translate="yes" xml:space="preserve">
          <source>When a declaration has &lt;code&gt;@JsModule&lt;/code&gt;, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to project's static resources and include via &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element. To tell Kotlin that it's ok to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from non-module environment, you should put &lt;code&gt;@JsNonModule&lt;/code&gt; declaration. For example, given JavaScript code:</source>
          <target state="translated">当声明具有 &lt;code&gt;@JsModule&lt;/code&gt; 时，如果不将其编译为JavaScript模块，则不能在Kotlin代码中使用它。通常，开发人员以JavaScript模块和可下载的 &lt;code&gt;.js&lt;/code&gt; 文件的形式分发其库，您可以将其复制到项目的静态资源中，并通过 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素包括在内。要告诉Kotlin 在非模块环境中使用 &lt;code&gt;@JsModule&lt;/code&gt; 声明是可以的，您应该放置 &lt;code&gt;@JsNonModule&lt;/code&gt; 声明。例如，给定的JavaScript代码：</target>
        </trans-unit>
        <trans-unit id="cdc056f54b314225b42eb84b111e0f374e0f43fb" translate="yes" xml:space="preserve">
          <source>When a declaration is marked as &lt;code&gt;@JsModule&lt;/code&gt;, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to your project's static resources and include via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. To tell Kotlin that it's okay to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from a non-module environment, add the &lt;code&gt;@JsNonModule&lt;/code&gt; annotation. For example, consider the following JavaScript code:</source>
          <target state="translated">当声明标记为 &lt;code&gt;@JsModule&lt;/code&gt; 时，如果不将其编译为JavaScript模块，则不能从Kotlin代码中使用它。通常，开发人员以JavaScript模块和可下载的 &lt;code&gt;.js&lt;/code&gt; 文件的形式分发其库，您可以将其复制到项目的静态资源中，并通过 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记包括在内。要告诉Kotlin在非模块环境中可以使用 &lt;code&gt;@JsModule&lt;/code&gt; 声明是可以的，请添加 &lt;code&gt;@JsNonModule&lt;/code&gt; 批注。例如，考虑以下JavaScript代码：</target>
        </trans-unit>
        <trans-unit id="6b2a92ee663b6eefd13c4799f36aa168f8eb6c67" translate="yes" xml:space="preserve">
          <source>When a flow represents partial results of the operation or operation status updates, it may not be necessary to process each value, but instead, only most recent ones. In this case, the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;conflate&lt;/a&gt; operator can be used to skip intermediate values when a collector is too slow to process them. Building on the previous example:</source>
          <target state="translated">当流表示操作的部分结果或操作状态更新时，可能不必处理每个值，而只需要处理最近的值即可。在这种情况下，当收集器太慢而无法处理中间值时，可以使用&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;合并&lt;/a&gt;运算符跳过中间值。以前面的示例为基础：</target>
        </trans-unit>
        <trans-unit id="06eb4fdaeb1116ee0773fa0c7742573f91abd273" translate="yes" xml:space="preserve">
          <source>When a function is called with both positional and named arguments, all the positional arguments should be placed before the first named one. For example, the call &lt;code&gt;f(1, y = 2)&lt;/code&gt; is allowed, but &lt;code&gt;f(x = 1, 2)&lt;/code&gt; is not.</source>
          <target state="translated">当同时使用位置参数和命名参数调用函数时，所有位置参数应放在第一个命名参数之前。例如，允许调用 &lt;code&gt;f(1, y = 2)&lt;/code&gt; ，但不允许 &lt;code&gt;f(x = 1, 2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c39ba3c630d6c34d1a8dfc3a61b0e9ace62da655" translate="yes" xml:space="preserve">
          <source>When a function of an external base class is overloaded by signature, you can't override it in a derived class.</source>
          <target state="translated">当一个外部基类的函数被签名重载时,你不能在派生类中重载它。</target>
        </trans-unit>
        <trans-unit id="f0551e05b4cdcabc413ed022b08af90ba98955ec" translate="yes" xml:space="preserve">
          <source>When a function of external base class is overloaded by signature, you can't override it in a derived class.</source>
          <target state="translated">当外部基类的函数被签名重载时,你不能在派生类中重载它。</target>
        </trans-unit>
        <trans-unit id="1cc5a0d8a7f78114a2ac1e09f9cb178d1a485871" translate="yes" xml:space="preserve">
          <source>When a function returns a single expression, the curly braces can be omitted and the body is specified after a &lt;strong&gt;=&lt;/strong&gt; symbol:</source>
          <target state="translated">当函数返回单个表达式时，可以省略花括号，并在&lt;strong&gt;=&lt;/strong&gt;符号后指定主体：</target>
        </trans-unit>
        <trans-unit id="4d60c7b0c4e08585362731f2e3c9cea8a0422110" translate="yes" xml:space="preserve">
          <source>When a variable is assigned from a safe call expression and checked for null, the smart cast is now applied to the safe call receiver as well:</source>
          <target state="translated">当一个变量从安全调用表达式中赋值并被检查为空时,智能投射现在也被应用到安全调用接收器。</target>
        </trans-unit>
        <trans-unit id="75ac04198276b2032c15af24079f880bbc7d4548" translate="yes" xml:space="preserve">
          <source>When an abstract class implements one or more interfaces, it is not required to provide definitions of the members of its interfaces (but it can if it wants to). It must still &lt;em&gt;declare&lt;/em&gt; such members, using &lt;code&gt;abstract override&lt;/code&gt; and not providing any body for the function or property:</source>
          <target state="translated">当抽象类实现一个或多个接口时，不需要提供其接口成员的定义（但如果需要，可以提供）。它仍必须使用 &lt;code&gt;abstract override&lt;/code&gt; 并且不为函数或属性提供任何主体来&lt;em&gt;声明&lt;/em&gt;此类成员：</target>
        </trans-unit>
        <trans-unit id="78ca79aa88621d9e1ad1b6380be2be6eed3fd311" translate="yes" xml:space="preserve">
          <source>When an equality check operands are statically known to be &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; (nullable or not), the check follows the IEEE 754 Standard for Floating-Point Arithmetic.</source>
          <target state="translated">当相等检查操作数静态已知为 &lt;code&gt;Float&lt;/code&gt; 或 &lt;code&gt;Double&lt;/code&gt; （可为空或不可为null）时，检查将遵循IEEE 754浮点算法标准。</target>
        </trans-unit>
        <trans-unit id="a72bfaeeae8d98102d2bd16c961c912a01957df4" translate="yes" xml:space="preserve">
          <source>When an inline function is &lt;code&gt;public&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt; and is not a part of a &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;internal&lt;/code&gt; declaration, it is considered a &lt;a href=&quot;visibility-modifiers#modules&quot;&gt;module&lt;/a&gt;'s public API. It can be called in other modules and is inlined at such call sites as well.</source>
          <target state="translated">当内联函数是 &lt;code&gt;public&lt;/code&gt; 或 &lt;code&gt;protected&lt;/code&gt; 并且不是 &lt;code&gt;private&lt;/code&gt; 或 &lt;code&gt;internal&lt;/code&gt; 声明的一部分时，它将被视为&lt;a href=&quot;visibility-modifiers#modules&quot;&gt;模块&lt;/a&gt;的公共API。可以在其他模块中调用它，也可以在此类调用位置内联。</target>
        </trans-unit>
        <trans-unit id="a8b8b82c3468010f3b6d8941f07253746e1af976" translate="yes" xml:space="preserve">
          <source>When an instance of a subclass is constructed, the superclass &quot;part&quot; is constructed first (via the superclass constructor). This means that during execution of the constructor of an open class, it could be that the object being constructed is an instance of a subclass, in which case the subclass-specific properties have not been initialized yet. For that reason, calling an open function from a constructor is risky: it might be overridden in the subclass, and if it is accessing subclass-specific properties, those won't be initialized yet.</source>
          <target state="translated">当一个子类的实例被构造时,超类 &quot;部分 &quot;首先被构造(通过超类构造函数)。这意味着在执行一个开放类的构造函数时,可能被构造的对象是一个子类的实例,在这种情况下,子类的特定属性还没有被初始化。因此,从构造函数中调用一个开放函数是有风险的:它可能会在子类中被覆盖,如果它正在访问子类的特定属性,这些属性还没有被初始化。</target>
        </trans-unit>
        <trans-unit id="5b0f246d38c7c57581718b09879ae1a9f3dd0cfb" translate="yes" xml:space="preserve">
          <source>When applied to a class or a member with internal visibility allows to use it from public inline functions and makes it effectively public.</source>
          <target state="translated">当应用于一个类或一个具有内部可见性的成员时,允许从公共内联函数中使用它,并使其有效地公开。</target>
        </trans-unit>
        <trans-unit id="b2719f8cfa129fbdd0adc701d2dba400cfb7a4df" translate="yes" xml:space="preserve">
          <source>When applied to annotation class X specifies that X defines a DSL language</source>
          <target state="translated">当应用于注解类X时,说明X定义了一种DSL语言。</target>
        </trans-unit>
        <trans-unit id="4383cdeb336d893261a8fd71ba6fa7f60d10ca1e" translate="yes" xml:space="preserve">
          <source>When applied, the CocoaPods plugin does the following:</source>
          <target state="translated">当应用时,CocoaPods插件会进行以下操作。</target>
        </trans-unit>
        <trans-unit id="d3cb13a5dd74d5989c8544a9bd856469cfe20ca8" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;excludeDependentModules&lt;/code&gt; and &lt;code&gt;headerFilter&lt;/code&gt; are used, they are applied as an intersection.</source>
          <target state="translated">当同时使用 &lt;code&gt;excludeDependentModules&lt;/code&gt; 和 &lt;code&gt;headerFilter&lt;/code&gt; 时，它们将作为交集应用。</target>
        </trans-unit>
        <trans-unit id="5bd916e17d31ae892ecde1eb2457f0a21c18c0ca" translate="yes" xml:space="preserve">
          <source>When building a Kotlin/JS project using Kotlin 1.3.xx, you may encounter a Gradle error if one of your dependencies (or any transitive dependency) was built using Kotlin 1.4 or higher: &lt;code&gt;Could not determine the dependencies of task ':client:jsTestPackageJson'.&lt;/code&gt; / &lt;code&gt;Cannot choose between the following variants&lt;/code&gt;. This is a known problem, a workaround is provided &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-40226&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">使用Kotlin 1.3.xx构建Kotlin / JS项目时，如果使用Kotlin 1.4或更高版本构建了一个依赖项（或任何传递性依赖项），则可能会遇到Gradle错误： &lt;code&gt;Could not determine the dependencies of task ':client:jsTestPackageJson'.&lt;/code&gt; / &lt;code&gt;Cannot choose between the following variants&lt;/code&gt; 。这是一个已知问题，&lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-40226&quot;&gt;此处&lt;/a&gt;提供了一种解决方法。</target>
        </trans-unit>
        <trans-unit id="7f14a9a00a723afb155894bffae89af46e21d16f" translate="yes" xml:space="preserve">
          <source>When building an Objective-C framework or a native library (shared or static), you may need to pack not just the classes of the current project, but also the classes of its dependencies. Specify which dependencies to export to a binary using the &lt;code&gt;export&lt;/code&gt; method.</source>
          <target state="translated">在构建Objective-C框架或本机库（共享或静态）时，您可能不仅需要打包当前项目的类，还需要打包其依赖项的类。使用 &lt;code&gt;export&lt;/code&gt; 方法指定要导出到二进制文件的依赖项。</target>
        </trans-unit>
        <trans-unit id="c05de934df0888bf3a4ea0106e90f35a575c92fc" translate="yes" xml:space="preserve">
          <source>When building an Objective-C framework, it is often necessary to pack not just the classes of the current project, but also the classes of some of its dependencies. The Binaries DSL allows one to specify which dependencies will be exported in the framework using the &lt;code&gt;export&lt;/code&gt; method. Note that only API dependencies of a corresponding source set can be exported.</source>
          <target state="translated">在构建Objective-C框架时，通常不仅要打包当前项目的类，还要打包其某些依赖项的类。 Binaries DSL允许使用 &lt;code&gt;export&lt;/code&gt; 方法指定将在框架中导出哪些依赖项。请注意，只能导出相应源集的API依赖项。</target>
        </trans-unit>
        <trans-unit id="6c939554f4725c1c653be2725d54eb9e654761fc" translate="yes" xml:space="preserve">
          <source>When building from Xcode, you can use CocoaPods libraries without writing .def files manually and setting cinterop tool parameters. In this case, all required parameters can be obtained from the Xcode project configured by CocoaPods.</source>
          <target state="translated">当从Xcode中构建时,您可以使用CocoaPods库,而无需手动编写.def文件和设置cinterop工具参数。在这种情况下,所有需要的参数都可以从CocoaPods配置的Xcode项目中获得。</target>
        </trans-unit>
        <trans-unit id="c700148c224a841d5e4fb27c316b7b0f072a2aee" translate="yes" xml:space="preserve">
          <source>When called on an object with a predicate provided, &lt;code&gt;takeIf&lt;/code&gt; returns this object if it matches the predicate. Otherwise, it returns &lt;code&gt;null&lt;/code&gt;. So, &lt;code&gt;takeIf&lt;/code&gt; is a filtering function for a single object. In turn, &lt;code&gt;takeUnless&lt;/code&gt; returns the object if it doesn't match the predicate and &lt;code&gt;null&lt;/code&gt; if it does. The object is available as a lambda argument (&lt;code&gt;it&lt;/code&gt;).</source>
          <target state="translated">在提供谓词的对象上调用时， &lt;code&gt;takeIf&lt;/code&gt; 返回与谓词匹配的对象。否则，它返回 &lt;code&gt;null&lt;/code&gt; 。因此， &lt;code&gt;takeIf&lt;/code&gt; 是单个对象的过滤功能。反过来，如果 &lt;code&gt;takeUnless&lt;/code&gt; 与谓词不匹配，则返回该对象；如果与谓词不匹配，则返回 &lt;code&gt;null&lt;/code&gt; 。该对象可用作lambda参数（ &lt;code&gt;it&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="70ae5c844919498cf5a44f8ce155a9c7029cae97" translate="yes" xml:space="preserve">
          <source>When called on lists, &lt;code&gt;addAll()&lt;/code&gt; adds new elements in the same order as they go in the argument. You can also call &lt;code&gt;addAll()&lt;/code&gt; specifying an element position as the first argument. The first element of the argument collection will be inserted at this position. Other elements of the argument collection will follow it, shifting the receiver elements to the end.</source>
          <target state="translated">在列表上调用时， &lt;code&gt;addAll()&lt;/code&gt; 会按照与参数中添加元素相同的顺序添加新元素。您还可以调用 &lt;code&gt;addAll()&lt;/code&gt; ,将元素位置指定为第一个参数。参数集合的第一个元素将插入到此位置。参数集合的其他元素将紧随其后，将接收器元素移到末尾。</target>
        </trans-unit>
        <trans-unit id="4503c0345f7f96c5163267795a01f8ff6d6296b7" translate="yes" xml:space="preserve">
          <source>When called with the default arguments, the functions return the result similar to calling &lt;code&gt;toString()&lt;/code&gt; on the collection: a &lt;code&gt;String&lt;/code&gt; of elements' string representations separated by commas with spaces.</source>
          <target state="translated">当使用默认参数调用，该函数返回类似调用结果 &lt;code&gt;toString()&lt;/code&gt; 的集合：一个 &lt;code&gt;String&lt;/code&gt; 元素的字符串表示的分离用空格逗号。</target>
        </trans-unit>
        <trans-unit id="4f800ac9ce646dbfd1c595ccbbdab36f597cb7a9" translate="yes" xml:space="preserve">
          <source>When called with the key present in the map, operators overwrite the values of the corresponding entries.</source>
          <target state="translated">当调用地图中存在的键时,运算符会覆盖相应条目的值。</target>
        </trans-unit>
        <trans-unit id="0e3f5ee2c33fac5afe961b2bc4ee6475eb75da8a" translate="yes" xml:space="preserve">
          <source>When calling Kotlin functions from Java, nobody prevents us from passing &lt;em&gt;null&lt;/em&gt; as a non-null parameter. That's why Kotlin generates runtime checks for all public functions that expect non-nulls. This way we get a &lt;code&gt;NullPointerException&lt;/code&gt; in the Java code immediately.</source>
          <target state="translated">从Java调用Kotlin函数时，没有人阻止我们将&lt;em&gt;null&lt;/em&gt;作为非null参数传递。这就是Kotlin为所有期望非null的公共函数生成运行时检查的原因。这样，我们立即在Java代码中获得了 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bf4931382d70d2a150fc1284b61bdc2c9c96f9a" translate="yes" xml:space="preserve">
          <source>When calling a function, you can name one or more of its arguments. This may be helpful when a function has a large number of arguments, and it's difficult to associate a value with an argument, especially if it's a boolean or &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">调用函数时，可以命名一个或多个参数。当函数具有大量参数并且难以将值与参数关联时，这可能会有所帮助，尤其是当它是布尔值或 &lt;code&gt;null&lt;/code&gt; 值时。</target>
        </trans-unit>
        <trans-unit id="afccfc52da19240ad334120985339616ba8ee626" translate="yes" xml:space="preserve">
          <source>When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; or the &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;@JsExport annotation&lt;/a&gt; to assign well-defined names to the functions that you want to call.</source>
          <target state="translated">当对 &lt;code&gt;dynamic&lt;/code&gt; 类型的值调用用Kotlin编写的函数时，请记住由Kotlin到JavaScript编译器执行的名称修改。您可能需要使用&lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName批注&lt;/a&gt;或&lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;@JsExport批注&lt;/a&gt;为您要调用的函数分配明确定义的名称。</target>
        </trans-unit>
        <trans-unit id="a66c232a7677f7941a6400aa2f6dc79238791bec" translate="yes" xml:space="preserve">
          <source>When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; to assign well-defined names to the functions that you need to call.</source>
          <target state="translated">当对 &lt;code&gt;dynamic&lt;/code&gt; 类型的值调用用Kotlin编写的函数时，请记住由Kotlin到JavaScript编译器执行的名称修改。您可能需要使用&lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName批注&lt;/a&gt;为需要调用的函数分配定义明确的名称。</target>
        </trans-unit>
        <trans-unit id="f401901149779f5935d80aef38d169d9b80565b3" translate="yes" xml:space="preserve">
          <source>When calling this function, you don&amp;rsquo;t have to name all its arguments:</source>
          <target state="translated">调用此函数时，不必命名其所有参数：</target>
        </trans-unit>
        <trans-unit id="a144ef75b391ae884d7e13a94311bf67580a2244" translate="yes" xml:space="preserve">
          <source>When chaining other functions after &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;, don't forget to perform the null check or the safe call (&lt;code&gt;?.&lt;/code&gt;) because their return value is nullable.</source>
          <target state="translated">在 &lt;code&gt;takeIf&lt;/code&gt; 和 &lt;code&gt;takeUnless&lt;/code&gt; 之后链接其他函数时，请不要忘记执行null检查或安全调用（ &lt;code&gt;?.&lt;/code&gt; ），因为它们的返回值是可为空的。</target>
        </trans-unit>
        <trans-unit id="c0a48c6031f8ea84f7db041425c7fe40478df5e8" translate="yes" xml:space="preserve">
          <source>When compiling (we'll use this term interchangeably with &lt;a href=&quot;https://en.wiktionary.org/wiki/transpile&quot;&gt;transpiling&lt;/a&gt;) to JavaScript, Kotlin outputs two main files:</source>
          <target state="translated">当编译为JavaScript 时（我们将这个术语与&lt;a href=&quot;https://en.wiktionary.org/wiki/transpile&quot;&gt;transpiling&lt;/a&gt;互换使用），Kotlin输出两个主要文件：</target>
        </trans-unit>
        <trans-unit id="9a71722d03195d233742cd235099b2a024ee3092" translate="yes" xml:space="preserve">
          <source>When compiling Kotlin code to targets JVM 1.8 and above, you could compile non-abstract methods of Kotlin interfaces into Java's &lt;code&gt;default&lt;/code&gt; methods. For this purpose, there was a mechanism that includes the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation for marking such methods and the &lt;code&gt;-Xjvm-default&lt;/code&gt; compiler option that enables processing of this annotation.</source>
          <target state="translated">将Kotlin代码编译为目标JVM 1.8及更高版本时，可以将Kotlin接口的非抽象方法编译为Java的 &lt;code&gt;default&lt;/code&gt; 方法。为此，存在一种机制，其中包括用于标记此类方法的 &lt;code&gt;@JvmDefault&lt;/code&gt; 批注以及用于处理此批注的 &lt;code&gt;-Xjvm-default&lt;/code&gt; 编译器选项。</target>
        </trans-unit>
        <trans-unit id="8c097f144946019495809506583d55bf5b42ced5" translate="yes" xml:space="preserve">
          <source>When compiling to JVM byte codes, the compiler optimizes access to arrays so that there's no overhead introduced:</source>
          <target state="translated">当编译成JVM字节码时,编译器会优化对数组的访问,这样就不会引入任何开销。</target>
        </trans-unit>
        <trans-unit id="d5652ef4fdb2127a183b6f70658b4242e9138b50" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, methods having or inheriting this annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. When such a method called through framework API throws an exception, it is either propagated as &lt;code&gt;NSError&lt;/code&gt; or considered unhandled (if exception &lt;code&gt;is&lt;/code&gt;&lt;a href=&quot;../../kotlin/-error/index#kotlin.Error&quot;&gt;kotlin.Error&lt;/a&gt; or &lt;a href=&quot;../../kotlin/-runtime-exception/index#kotlin.RuntimeException&quot;&gt;kotlin.RuntimeException&lt;/a&gt;). In any case exception is not checked to be instance of one of the &lt;a href=&quot;exception-classes&quot;&gt;exceptionClasses&lt;/a&gt;.</source>
          <target state="translated">当编译到Objective-C / Swift框架时，具有或继承此批注的方法在Objective-C 中表示为 &lt;code&gt;NSError*&lt;/code&gt; 方法，而在Swift中表示为 &lt;code&gt;throws&lt;/code&gt; 方法。当通过框架API调用的此类方法引发异常时，该异常将作为 &lt;code&gt;NSError&lt;/code&gt; 传播或被视为未处理（如果异常 &lt;code&gt;is&lt;/code&gt; &lt;a href=&quot;../../kotlin/-error/index#kotlin.Error&quot;&gt;kotlin.Error&lt;/a&gt;或&lt;a href=&quot;../../kotlin/-runtime-exception/index#kotlin.RuntimeException&quot;&gt;kotlin.RuntimeException&lt;/a&gt;）。在任何情况下，都不会将异常检查为&lt;a href=&quot;exception-classes&quot;&gt;exceptionClasses&lt;/a&gt;之一的实例。</target>
        </trans-unit>
        <trans-unit id="6587d9ea4d853cd6df9a3004ea764022f98d9281" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, non-&lt;code&gt;suspend&lt;/code&gt; functions having or inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt;/&lt;code&gt;Error&lt;/code&gt; parameter in completion handler.</source>
          <target state="translated">当编译到Objective-C / Swift框架时，具有或继承 &lt;code&gt;@Throws&lt;/code&gt; 批注的非 &lt;code&gt;suspend&lt;/code&gt; 挂函数在Objective-C中表示为 &lt;code&gt;NSError*&lt;/code&gt; 方法，而在Swift中表示为 &lt;code&gt;throws&lt;/code&gt; 方法。 &lt;code&gt;suspend&lt;/code&gt; 函数的表示形式在完成处理程序中始终具有 &lt;code&gt;NSError*&lt;/code&gt; / &lt;code&gt;Error&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="488e4ca566eb9082ca3b6286ce0e3243bb17b8f2" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, non-&lt;code&gt;suspend&lt;/code&gt; functions having or inheriting this annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt;/&lt;code&gt;Error&lt;/code&gt; parameter in completion handler</source>
          <target state="translated">当编译到Objective-C / Swift框架时，具有或继承此批注的非 &lt;code&gt;suspend&lt;/code&gt; 函数在Objective-C中表示为 &lt;code&gt;NSError*&lt;/code&gt; 生产方法，而在Swift中表示为 &lt;code&gt;throws&lt;/code&gt; 方法。 &lt;code&gt;suspend&lt;/code&gt; 函数的表示形式在完成处理程序中始终具有 &lt;code&gt;NSError*&lt;/code&gt; / &lt;code&gt;Error&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="0a9ee7ef1045f5338ee8701cbc0ba2b21b7f1d68" translate="yes" xml:space="preserve">
          <source>When compiling to Swift or the Objective-C framework, functions that have or are inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift.</source>
          <target state="translated">当编译为Swift或Objective-C框架时，具有或继承 &lt;code&gt;@Throws&lt;/code&gt; 批注的函数在Objective-C中表示为 &lt;code&gt;NSError*&lt;/code&gt; 方法，而在Swift中表示为 &lt;code&gt;throws&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b96c28145bcb8f6ff8815136a3e9f396b218615b" translate="yes" xml:space="preserve">
          <source>When compiling, the compiler always outputs the kotlin.js file. The easiest way to reference this without having to refer to paths, is to set the output library folder for the compiler options to &lt;code&gt;node_modules&lt;/code&gt;. This way, Node will automatically pick it up as it does an exhaustive search for files under these folders</source>
          <target state="translated">编译时，编译器始终输出kotlin.js文件。无需引用路径即可引用此方法的最简单方法是将编译器选项的输出库文件夹设置为 &lt;code&gt;node_modules&lt;/code&gt; 。这样，Node会在对这些文件夹下的文件进行彻底搜索时自动将其选中</target>
        </trans-unit>
        <trans-unit id="5b6df5ad94ece159e4d2e7854f633a08ec2ced8b" translate="yes" xml:space="preserve">
          <source>When creating a new application or module that targets JavaScript, we need to select &lt;code&gt;Kotlin - JavaScript&lt;/code&gt; as the target</source>
          <target state="translated">创建针对JavaScript的新应用程序或模块时，我们需要选择 &lt;code&gt;Kotlin - JavaScript&lt;/code&gt; 作为目标</target>
        </trans-unit>
        <trans-unit id="40c235de508210259df882cfb516e8a1d647fb3f" translate="yes" xml:space="preserve">
          <source>When declaring dependencies on npm packages, you are now required to explicitly specify a version or version range based on &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm&amp;rsquo;s semver syntax&lt;/a&gt;. Specifying multiple version ranges is also supported.</source>
          <target state="translated">现在，声明对npm软件包的依赖性时，您需要根据&lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm的semver语法&lt;/a&gt;明确指定版本或版本范围。还支持指定多个版本范围。</target>
        </trans-unit>
        <trans-unit id="03565eec78cb8bfb0c999a9b15ff0e6c755df92b" translate="yes" xml:space="preserve">
          <source>When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline:</source>
          <target state="translated">当在多行lambda中声明参数名称时,将名称放在第一行,然后是箭头和换行。</target>
        </trans-unit>
        <trans-unit id="3ef5c76bfa4e43b35f38295e1d456c70ff2408cf" translate="yes" xml:space="preserve">
          <source>When executing this run configuration, we can note that the Gradle process continues watching for changes to the program:</source>
          <target state="translated">在执行这个运行配置时,我们可以注意到Gradle进程会继续观察程序的变化。</target>
        </trans-unit>
        <trans-unit id="04dc660c0cd261412da813263e6942fbca96f489" translate="yes" xml:space="preserve">
          <source>When flow collection completes (normally or exceptionally) it may need to execute an action. As you may have already noticed, it can be done in two ways: imperative or declarative.</source>
          <target state="translated">当流量收集完成时(正常或异常),它可能需要执行一个动作。你可能已经注意到了,它可以通过两种方式来完成:命令式或声明式。</target>
        </trans-unit>
        <trans-unit id="210a72ecd64e91bda5f9f64c7a09dfe81ca0e12e" translate="yes" xml:space="preserve">
          <source>When flow represents the most recent value of a variable or operation (see also the related section on &lt;a href=&quot;#conflation&quot;&gt;conflation&lt;/a&gt;), it might be needed to perform a computation that depends on the most recent values of the corresponding flows and to recompute it whenever any of the upstream flows emit a value. The corresponding family of operators is called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html&quot;&gt;combine&lt;/a&gt;.</source>
          <target state="translated">当流代表变量或操作的最新值时（另请参阅有关&lt;a href=&quot;#conflation&quot;&gt;合并&lt;/a&gt;的相关部分），可能需要执行依赖于相应流的最新值的计算，并在任何上游出现时重新进行计算。流发出一个值。相应的运算符家族称为&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html&quot;&gt;Combine&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="16ca0ed2cf53ba99dfc24939c39b34cc8182bea3" translate="yes" xml:space="preserve">
          <source>When given a &lt;code&gt;-library foo&lt;/code&gt; flag, the compiler searches the &lt;code&gt;foo&lt;/code&gt; library in the following order:</source>
          <target state="translated">当给定 &lt;code&gt;-library foo&lt;/code&gt; 标志时，编译器按以下顺序搜索 &lt;code&gt;foo&lt;/code&gt; 库：</target>
        </trans-unit>
        <trans-unit id="dd5a17a3b22c6470172a587dc5be67c1d1df4d62" translate="yes" xml:space="preserve">
          <source>When given the above snippet the &lt;code&gt;cinterop&lt;/code&gt; tool will search &lt;code&gt;libfoo.a&lt;/code&gt; in &lt;code&gt;/opt/local/lib&lt;/code&gt; and &lt;code&gt;/usr/local/opt/curl/lib&lt;/code&gt;, and if it is found include the library binary into &lt;code&gt;klib&lt;/code&gt;.</source>
          <target state="translated">当给出以上代码片段时， &lt;code&gt;cinterop&lt;/code&gt; 工具将在 &lt;code&gt;/opt/local/lib&lt;/code&gt; 和 &lt;code&gt;/usr/local/opt/curl/lib&lt;/code&gt; 中搜索 &lt;code&gt;libfoo.a&lt;/code&gt; ，如果找到，则将二进制库包含到 &lt;code&gt;klib&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="010f9a9f094ca37e15156897e51ac67f748d0305" translate="yes" xml:space="preserve">
          <source>When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation)</source>
          <target state="translated">在实现一个接口时,要保持实现成员与接口成员的顺序相同(如果有必要,可以穿插一些用于实现的额外私有方法</target>
        </trans-unit>
        <trans-unit id="27dfae03dd6477eb5611a6a8eca02c237e81ed5f" translate="yes" xml:space="preserve">
          <source>When in &lt;code&gt;both&lt;/code&gt; mode, the IR compiler backend and default compiler backend are both used when building a library from your sources (hence the name). This means that both &lt;code&gt;klib&lt;/code&gt; files with Kotlin IR as well as &lt;code&gt;jar&lt;/code&gt; files for the default compiler will be generated. When published under the same Maven coordinate, Gradle will automatically choose the right artifact depending on the use case &amp;ndash; &lt;code&gt;js&lt;/code&gt; for the old compiler, &lt;code&gt;klib&lt;/code&gt; for the new one. This enables you to compile and publish your library for projects that are using either of the two compiler backends.</source>
          <target state="translated">在 &lt;code&gt;both&lt;/code&gt; 模式下，从源构建库时都使用IR编译器后端和默认编译器后端（因此命名）。这意味着将同时 &lt;code&gt;klib&lt;/code&gt; 带有Kotlin IR的klib文件以及用于默认编译器的 &lt;code&gt;jar&lt;/code&gt; 文件。当在相同的Maven坐标公布，摇篮会自动选择取决于使用的情况下，正确的神器- &lt;code&gt;js&lt;/code&gt; 旧编译器， &lt;code&gt;klib&lt;/code&gt; 为新的。这使您可以为使用两个编译器后端之一的项目编译和发布库。</target>
        </trans-unit>
        <trans-unit id="0d8190bf6bb340fcc1bfe9465dd44a27ec0f22ba" translate="yes" xml:space="preserve">
          <source>When installed for the first time, EduTools plugin asks if you're a Learner or an Educator. Please choose &lt;strong&gt;Educator&lt;/strong&gt; to enable course creation functionality:</source>
          <target state="translated">首次安装时，EduTools插件会询问您是学习者还是教育者。请选择&lt;strong&gt;教育者&lt;/strong&gt;以启用课程创建功能：</target>
        </trans-unit>
        <trans-unit id="8932a8146c0a90dc2dd58707de728ef7a12acaa8" translate="yes" xml:space="preserve">
          <source>When installed for the first time, the EduTools plugin asks if you're a Learner or an Educator. Please choose &lt;strong&gt;Learner&lt;/strong&gt;:</source>
          <target state="translated">首次安装时，EduTools插件会询问您是学习者还是教育者。请选择&lt;strong&gt;学习者&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="10a5b3cb7bba7c274d069162e0ee74e696f381e7" translate="yes" xml:space="preserve">
          <source>When library headers are imported to a C program with the &lt;code&gt;#include&lt;/code&gt; directive, all of the headers included by these headers are also included in the program. So all header dependencies are included in generated stubs as well.</source>
          <target state="translated">使用 &lt;code&gt;#include&lt;/code&gt; 指令将库标头导入C程序时，这些标头包含的所有标头也将包含在程序中。因此，所有标头依赖性也都包含在生成的存根中。</target>
        </trans-unit>
        <trans-unit id="3922383306a8a09a6b0e8b2eb8f9a1db1f1ab0db" translate="yes" xml:space="preserve">
          <source>When list elements aren't &lt;code&gt;Comparable&lt;/code&gt;, you should provide a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; to use in the binary search. The list must be sorted in ascending order according to this &lt;code&gt;Comparator&lt;/code&gt;. Let's have a look at an example:</source>
          <target state="translated">当列表元素不可 &lt;code&gt;Comparable&lt;/code&gt; ，您应该提供一个&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt;以在二进制搜索中使用。该列表必须根据此 &lt;code&gt;Comparator&lt;/code&gt; 以升序排序。让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="eb20fed2a040f5bec7d775d79d512be41c67a260" translate="yes" xml:space="preserve">
          <source>When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind.</source>
          <target state="translated">当在使用多个高阶函数的复杂表达式和循环之间做出选择时,要了解每种情况下执行操作的成本,并牢记性能考虑。</target>
        </trans-unit>
        <trans-unit id="34a85c247b6ac08983d01a72671ac866f48daed6" translate="yes" xml:space="preserve">
          <source>When multiple children of a coroutine fail with an exception, the general rule is &quot;the first exception wins&quot;, so the first exception gets handled. All additional exceptions that happen after the first one are attached to the first exception as suppressed ones.</source>
          <target state="translated">当一个coroutine的多个子程序出现异常时,一般的规则是 &quot;第一个异常获胜&quot;,所以第一个异常被处理。在第一个异常之后发生的所有额外的异常都作为被抑制的异常附加在第一个异常上。</target>
        </trans-unit>
        <trans-unit id="2970ac1e3a2dbc090d5bfcbffc924f278b84baec" translate="yes" xml:space="preserve">
          <source>When returning a value, the parser gives preference to the qualified return, i.e.</source>
          <target state="translated">当返回一个值时,解析器会优先考虑限定的返回值,也就是</target>
        </trans-unit>
        <trans-unit id="91e0d5690967c5e3915ccf3388a11d3d82da8814" translate="yes" xml:space="preserve">
          <source>When running this example in the browser, the DOM will be assembled in a straightforward way. This is easily confirmed by checking the Elements of the website using the developer tools of our browser:</source>
          <target state="translated">当在浏览器中运行这个例子时,DOM将以一种简单的方式组装。通过使用我们浏览器的开发工具检查网站的元素,很容易确认这一点。</target>
        </trans-unit>
        <trans-unit id="6b57a6650ec36adfcbda42de47e0a60e863df953" translate="yes" xml:space="preserve">
          <source>When somebody calls the function &lt;code&gt;getDate()&lt;/code&gt;, they won't be informed about the experimental API used in its body.</source>
          <target state="translated">当有人调用函数 &lt;code&gt;getDate()&lt;/code&gt; 时，不会通知他们体内使用的实验性API。</target>
        </trans-unit>
        <trans-unit id="bfa8681d13a7c615930222f478ec4f7aeac79c5a" translate="yes" xml:space="preserve">
          <source>When somebody calls the function &lt;code&gt;getDate()&lt;/code&gt;, they won't be informed about the opt-in requirements for APIs used in its body.</source>
          <target state="translated">当有人调用函数 &lt;code&gt;getDate()&lt;/code&gt; 时，不会通知他们主体中使用的API的选择加入要求。</target>
        </trans-unit>
        <trans-unit id="6e6f8bdf23dc342f6366d0ca972d7d991572a9e7" translate="yes" xml:space="preserve">
          <source>When supported by the platform adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</source>
          <target state="translated">当平台支持时,将指定的异常添加到为了传递这个异常而被抑制的异常列表中。</target>
        </trans-unit>
        <trans-unit id="6393b31c82857a557e8af4f2a0be0aaf5d58b5c5" translate="yes" xml:space="preserve">
          <source>When supported by the platform, adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</source>
          <target state="translated">当平台支持时,将指定的异常添加到为了传递这个异常而被抑制的异常列表中。</target>
        </trans-unit>
        <trans-unit id="3c40217c2fbf96f7f32af012e76efee928b75c4a" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, a different plugin should be applied:</source>
          <target state="translated">当针对JavaScript时,应该应用不同的插件。</target>
        </trans-unit>
        <trans-unit id="6febffb6e2904e4bbf90391b0727f1dbf05ee0c1" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlin2Js&lt;/code&gt; and &lt;code&gt;compileTestKotlin2Js&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin2Js&lt;/code&gt; for custom source sets.</source>
          <target state="translated">以JavaScript为目标时，这些任务分别称为 &lt;code&gt;compileKotlin2Js&lt;/code&gt; 和 &lt;code&gt;compileTestKotlin2Js&lt;/code&gt; ，以及用于自定义源集的 &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin2Js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb89dbb9f04dc9361c7746b53e92457b21476e1a" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlinJs&lt;/code&gt; and &lt;code&gt;compileTestKotlinJs&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;KotlinJs&lt;/code&gt; for custom source sets.</source>
          <target state="translated">以JavaScript为目标时，这些任务分别称为 &lt;code&gt;compileKotlinJs&lt;/code&gt; 和 &lt;code&gt;compileTestKotlinJs&lt;/code&gt; ，以及自定义源集的 &lt;code&gt;compile&amp;lt;Name&amp;gt;KotlinJs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68caa257adc3424d8615357e16a81ae92f1364f3" translate="yes" xml:space="preserve">
          <source>When targeting Node.js with Kotlin/JS, we can simply execute the &lt;code&gt;run&lt;/code&gt; Gradle task. This can be done for example via the command line, using the Gradle wrapper:</source>
          <target state="translated">使用Kotlin / JS定位Node.js时，我们只需执行 &lt;code&gt;run&lt;/code&gt; Gradle任务即可。例如，可以使用Gradle包装器通过命令行完成此操作：</target>
        </trans-unit>
        <trans-unit id="8307ea9f68fd265bde506b102ae1144dc569ce2b" translate="yes" xml:space="preserve">
          <source>When targeting only JavaScript, use the &lt;code&gt;kotlin-js&lt;/code&gt; plugin. &lt;a href=&quot;js-project-setup&quot;&gt;Learn more&lt;/a&gt;</source>
          <target state="translated">仅定位JavaScript时，请使用 &lt;code&gt;kotlin-js&lt;/code&gt; 插件。&lt;a href=&quot;js-project-setup&quot;&gt;了解更多&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3700a9140aca950bb22b2b6e73a90e60e275240a" translate="yes" xml:space="preserve">
          <source>When targeting the JVM, Kotlin produces Java compatible bytecode. When targeting JavaScript, Kotlin transpiles to ES5.1 and generates code which is compatible with module systems including AMD and CommonJS. When targeting native, Kotlin will produce platform-specific code (via LLVM).</source>
          <target state="translated">当以JVM为目标时,Kotlin生成与Java兼容的字节码。当以JavaScript为目标时,Kotlin会移植到ES5.1,并生成与包括AMD和CommonJS在内的模块系统兼容的代码。当针对原生的时候,Kotlin会生成平台特定的代码(通过LLVM)。</target>
        </trans-unit>
        <trans-unit id="2fd9751d3f79fd88ae2a197e9ec6c24a47840b01" translate="yes" xml:space="preserve">
          <source>When targeting the JVM, the tasks are called &lt;code&gt;compileKotlin&lt;/code&gt; for production code and &lt;code&gt;compileTestKotlin&lt;/code&gt; for test code. The tasks for custom source sets are called accordingly to the &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin&lt;/code&gt; pattern.</source>
          <target state="translated">当针对JVM，任务被称为 &lt;code&gt;compileKotlin&lt;/code&gt; 生产代码和 &lt;code&gt;compileTestKotlin&lt;/code&gt; 测试代码。自定义源集的任务将根据 &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin&lt;/code&gt; 模式进行调用。</target>
        </trans-unit>
        <trans-unit id="cb9436a471e8dbc8503c3b6e6a7c9d3c34f6ebb0" translate="yes" xml:space="preserve">
          <source>When targeting the browser, our project is required to have an HTML page. This page will be served by the development server while we are working on our application, and should embed our compiled Kotlin/JS file. Create and fill an HTML file &lt;code&gt;/src/main/resources/index.html&lt;/code&gt;:</source>
          <target state="translated">以浏览器为目标时，我们的项目必须具有HTML页面。在我们处理应用程序时，此页面将由开发服务器提供，并应嵌入我们编译后的Kotlin / JS文件。创建并填充一个HTML文件 &lt;code&gt;/src/main/resources/index.html&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f18755d5fafc0688db03f9113e5e8aba876e9f17" translate="yes" xml:space="preserve">
          <source>When the argument type is final, there's usually no point in generating the wildcard, so &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; is always &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt;, no matter what position it takes.</source>
          <target state="translated">当参数类型为final时，生成通配符通常没有意义，因此 &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; 始终为 &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; ，无论它处于什么位置。</target>
        </trans-unit>
        <trans-unit id="4260e7c630e27226c5f3f5f47519e7ba6fce2dbf" translate="yes" xml:space="preserve">
          <source>When the operands &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are statically known to be &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; or their nullable counterparts (the type is declared or inferred or is a result of a &lt;a href=&quot;typecasts#smart-casts&quot;&gt;smart cast&lt;/a&gt;), the operations on the numbers and the range that they form follow the IEEE 754 Standard for Floating-Point Arithmetic.</source>
          <target state="translated">当将操作数 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 静态已知为 &lt;code&gt;Float&lt;/code&gt; 或 &lt;code&gt;Double&lt;/code&gt; 或它们的可为空的对应对象（类型已声明或推断或是&lt;a href=&quot;typecasts#smart-casts&quot;&gt;智能强制转换&lt;/a&gt;的结果）时，对数字和它们形成的范围的运算遵循IEEE 754浮点算法的标准。</target>
        </trans-unit>
        <trans-unit id="50fe39e80afdb0bafe5609ac0ee60d49bbca274d" translate="yes" xml:space="preserve">
          <source>When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</source>
          <target state="translated">当原始&lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;延续&lt;/a&gt;完成时，协程框架会调用&lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt;，如果结果被截获（即， &lt;code&gt;interceptContinuation&lt;/code&gt; 先前已返回不同的延续实例），则产生的延续。</target>
        </trans-unit>
        <trans-unit id="41195e5948b5d9d14accce4fb777d5a5399f88d7" translate="yes" xml:space="preserve">
          <source>When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</source>
          <target state="translated">当原始&lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;延续&lt;/a&gt;完成时，协程框架将调用&lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt;，如果结果被截获，即是如果 &lt;code&gt;interceptContinuation&lt;/code&gt; 先前已返回另一个继续实例，则该结果将继续。</target>
        </trans-unit>
        <trans-unit id="aee129400c7cdc16a95ec0912c8a4fd0a5a9f195" translate="yes" xml:space="preserve">
          <source>When the processing of an &lt;code&gt;Iterable&lt;/code&gt; includes multiple steps, they are executed eagerly: each processing step completes and returns its result &amp;ndash; an intermediate collection. The following step executes on this collection. In turn, multi-step processing of sequences is executed lazily when possible: actual computing happens only when the result of the whole processing chain is requested.</source>
          <target state="translated">当 &lt;code&gt;Iterable&lt;/code&gt; 的处理包括多个步骤时，它们将急切地执行：每个处理步骤完成并返回其结果&amp;ndash;中间集合。在此集合上执行以下步骤。反过来，在可能的情况下延迟执行序列的多步处理：只有在请求整个处理链的结果时才进行实际计算。</target>
        </trans-unit>
        <trans-unit id="45bf077d097fcdb663238684f69205850ecd18da" translate="yes" xml:space="preserve">
          <source>When the project consists of exclusively Kotlin source code, the easiest way to compile the project is to use the &lt;em&gt;kotlinc&lt;/em&gt; task:</source>
          <target state="translated">如果项目仅包含Kotlin源代码，则编译项目的最简单方法是使用&lt;em&gt;kotlinc&lt;/em&gt;任务：</target>
        </trans-unit>
        <trans-unit id="de3a7fefd9c0e4fdceeb9aa1f2016defc2704512" translate="yes" xml:space="preserve">
          <source>When this annotation is placed on a generic function parameter of a function, it enables to infer the type arguments of that generic function from the lambda body passed to that parameter.</source>
          <target state="translated">当这个注解被放置在一个函数的通用函数参数上时,它能够从传递给该参数的lambda体推断出该通用函数的类型参数。</target>
        </trans-unit>
        <trans-unit id="4048f5f513aab453351704d3921c71dee68c7768" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;定界符&lt;/a&gt;开头和结尾时，返回一个新的char序列，该&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;定界符&lt;/a&gt;从开始和结束处都删除了。否则返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="71738510e58b58513693f2e894d632554b8f850d" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;定界符&lt;/a&gt;开始并结束时，返回一个新的char序列，该&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;定界符&lt;/a&gt;从开始和结束处都删除了该定界符。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="662d6d4b8c6d089b2ede0be25f7514459a1a7dc8" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;定界符&lt;/a&gt;开头和结尾时，返回一个新的char序列，该&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;定界符&lt;/a&gt;从开始和结束处都删除了。否则返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="7019a5ff21fc052821e44fe7b2517fb2a7e50ce1" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;定界符&lt;/a&gt;开始并结束时，返回一个新的char序列，该&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;定界符&lt;/a&gt;从开始和结束处都删除了该定界符。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="f0f3cdbdc4358626eb141b88edd210afb71fcf1c" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;定界符&lt;/a&gt;开头和结尾时，返回一个新的char序列，该&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;定界符&lt;/a&gt;从开始和结束处都删除了。否则返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="1343302e14e8f4c4b12b4a77e8795e48eee2bf82" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;定界符&lt;/a&gt;开始并结束时，返回一个新的char序列，该&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;定界符&lt;/a&gt;从开始和结束处都删除了该定界符。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="451a99a6d4be3b4584fd97e74744059ae797634b" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;前缀&lt;/a&gt;开头并以给定&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;结尾时，返回一个新的char序列，该序列同时删除了给定&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;前缀&lt;/a&gt;和&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;。否则返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="21ec09c18e0e164102ac5fa7a001d480731fe38a" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;前缀&lt;/a&gt;开头并以给定的&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;结尾时，返回一个新的char序列，该序列同时删除了给定的&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;前缀&lt;/a&gt;和&lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="474027059649f995528fdc9848631cfc13badca6" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;前缀&lt;/a&gt;开头并以给定&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;结尾时，返回一个新的char序列，该序列同时删除了给定&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;前缀&lt;/a&gt;和&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;。否则返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="e1059589b0f168a1d76360357b34244200d2d5f4" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;前缀&lt;/a&gt;开头并以给定的&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;结尾时，返回一个新的char序列，该序列同时删除了给定的&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;前缀&lt;/a&gt;和&lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="b4f20b674cd62de8c48c773a81ba6fdddb62b434" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;前缀&lt;/a&gt;开头并以给定&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;结尾时，返回一个新的char序列，该序列同时删除了给定&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;前缀&lt;/a&gt;和&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;后缀&lt;/a&gt;。否则返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="cdb86094485044abedbde00e051a13f9d6e30f2e" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">当此char序列以给定的&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;前缀&lt;/a&gt;开头并以给定的&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;结尾时，返回一个新的char序列，该序列同时删除了给定的&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;前缀&lt;/a&gt;和&lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;后缀&lt;/a&gt;。否则，返回具有相同字符的新char序列。</target>
        </trans-unit>
        <trans-unit id="81b6ffb12763bc2138c97cf448035b6d9b90a8a2" translate="yes" xml:space="preserve">
          <source>When this map already has an implicit default value provided with a former call to &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;, it is being replaced by this call.</source>
          <target state="translated">如果此映射已经具有一个隐含的默认值，该默认值由先前对&lt;a href=&quot;with-default&quot;&gt;withDefault的&lt;/a&gt;调用提供，则它将被该调用替换。</target>
        </trans-unit>
        <trans-unit id="4cb6af1ae576c542ddecdff3ea4125d59a9ee8e7" translate="yes" xml:space="preserve">
          <source>When to use</source>
          <target state="translated">何时使用</target>
        </trans-unit>
        <trans-unit id="d17ab536e904cdcbae105ffd675f6f9b2f2e25d6" translate="yes" xml:space="preserve">
          <source>When transforming maps, you have two options: transform keys leaving values unchanged and vice versa. To apply a given transformation to keys, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-keys&quot;&gt;&lt;code&gt;mapKeys()&lt;/code&gt;&lt;/a&gt;; in turn, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-values&quot;&gt;&lt;code&gt;mapValues()&lt;/code&gt;&lt;/a&gt; transforms values. Both functions use the transformations that take a map entry as an argument, so you can operate both its key and value.</source>
          <target state="translated">变换地图时，有两个选择：变换键，使值保持不变，反之亦然。要将给定的转换应用于键，请使用&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-keys&quot;&gt; &lt;code&gt;mapKeys()&lt;/code&gt; &lt;/a&gt;；反过来，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-values&quot;&gt; &lt;code&gt;mapValues()&lt;/code&gt; &lt;/a&gt;转换值。这两个函数都使用将映射条目作为参数的转换，因此您可以操作其键和值。</target>
        </trans-unit>
        <trans-unit id="8770eb3127ee3d553d5540c7c283a25cbf45081e" translate="yes" xml:space="preserve">
          <source>When two or more function overloads have otherwise the same parameter lists that differ only in the return type of a functional parameter, this annotation enables overload selection by the type of the value returned from the lambda function passed to this functional parameter.</source>
          <target state="translated">当两个或多个函数重载的参数列表本来是相同的,只是在函数参数的返回类型上有所不同时,这个注解可以通过传递给这个函数参数的lambda函数返回的值的类型来选择重载。</target>
        </trans-unit>
        <trans-unit id="3c33f3916421868809be7997c01c86f79f8dba67" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;, apply the Kotlin plugins using the &lt;code&gt;plugins { ... }&lt;/code&gt; block. If you apply them with &lt;code&gt;apply { plugin(...) }&lt;/code&gt; instead, you may encounter unresolved references to the extensions generated by Gradle Kotlin DSL. To resolve that, you can comment out the erroneous usages, run the Gradle task &lt;code&gt;kotlinDslAccessorsSnapshot&lt;/code&gt;, then uncomment the usages back and rerun the build or reimport the project into the IDE.</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL时&lt;/a&gt;，请使用 &lt;code&gt;plugins { ... }&lt;/code&gt; 块来应用Kotlin插件。如果改为使用 &lt;code&gt;apply { plugin(...) }&lt;/code&gt; 来应用它们，则可能会遇到未解析的对Gradle Kotlin DSL生成的扩展的引用。要解决此问题，您可以注释掉错误的用法，运行Gradle任务 &lt;code&gt;kotlinDslAccessorsSnapshot&lt;/code&gt; ，然后取消注释用法，然后重新运行构建或将项目重新导入到IDE中。</target>
        </trans-unit>
        <trans-unit id="969e0f1eba169f04310601e387fff4607230faf4" translate="yes" xml:space="preserve">
          <source>When using AMD, we set the compiler option to use AMD. Once we do that, we can then reference any modules that we've defined as if they were regular AMD ones.</source>
          <target state="translated">当使用AMD时,我们将编译器选项设置为使用AMD。一旦我们这样做,我们就可以引用我们定义的任何模块,就像它们是普通的AMD模块一样。</target>
        </trans-unit>
        <trans-unit id="53fe6e4bace8d3f91a163b97ab403728f060528c" translate="yes" xml:space="preserve">
          <source>When using DSLs, one might have come across the problem that too many functions can be called in the context. We can call methods of every available implicit receiver inside a lambda and therefore get an inconsistent result, like the tag &lt;code&gt;head&lt;/code&gt; inside another &lt;code&gt;head&lt;/code&gt;:</source>
          <target state="translated">使用DSL时，可能会遇到一个问题，即在上下文中可以调用太多功能。我们可以将拉姆达内所有可用的隐式接收器的方法，因此得到不一致的结果，像标签 &lt;code&gt;head&lt;/code&gt; 另一内部 &lt;code&gt;head&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fac3c8199ff8ff114bd0a9de76148fcb9a8c3dbd" translate="yes" xml:space="preserve">
          <source>When using UMD or CommonJS, for example, your callsite could look like this:</source>
          <target state="translated">例如,当使用UMD或CommonJS时,你的callite可以看起来像这样。</target>
        </trans-unit>
        <trans-unit id="7c361123f4c7cb5fe21faa0f281e0ce914b368c3" translate="yes" xml:space="preserve">
          <source>When using a generic type where you have star-projected one or more of its type parameters, you can:</source>
          <target state="translated">当使用一个通用类型时,你已经对它的一个或多个类型参数进行了星形预测,你可以。</target>
        </trans-unit>
        <trans-unit id="7db42a19309e043040b1f118ec7a9ccf3b7c095b" translate="yes" xml:space="preserve">
          <source>When using an acronym as part of a declaration name, capitalize it if it consists of two letters (&lt;code&gt;IOStream&lt;/code&gt;); capitalize only the first letter if it is longer (&lt;code&gt;XmlFormatter&lt;/code&gt;, &lt;code&gt;HttpInputStream&lt;/code&gt;).</source>
          <target state="translated">在声明名称中使用首字母缩写词时，如果首字母缩写词由两个字母（ &lt;code&gt;IOStream&lt;/code&gt; ）组成，则将其大写。如果首字母较长则大写（ &lt;code&gt;XmlFormatter&lt;/code&gt; ， &lt;code&gt;HttpInputStream&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c3685d4fda3e975e4ad59872db610504afb8dcbd" translate="yes" xml:space="preserve">
          <source>When using if/else as an expression, the &lt;code&gt;else&lt;/code&gt; part is mandatory (but there can also be &lt;code&gt;else if&lt;/code&gt; parts). If the body that ends up being evaluated contains more than one line, it's the result of the last line that becomes the result of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;.</source>
          <target state="translated">使用if / else作为表达式时， &lt;code&gt;else&lt;/code&gt; 部分是必需的（但是 &lt;code&gt;else if&lt;/code&gt; 部分也可以存在else）。如果最终被评估的主体包含多行，则最后一行的结果成为 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="c13d37c9e596a2177cf34971de8b2f9ef301b366" translate="yes" xml:space="preserve">
          <source>When using such &lt;code&gt;klib&lt;/code&gt; in your program, the library is linked automatically.</source>
          <target state="translated">在程序中使用此类 &lt;code&gt;klib&lt;/code&gt; 时，该库将自动链接。</target>
        </trans-unit>
        <trans-unit id="de988175b9de40e29ae018fb8ec5826b1dac85a5" translate="yes" xml:space="preserve">
          <source>When using the IR compiler, the &lt;code&gt;binaries.executable()&lt;/code&gt; instruction must be present in the &lt;code&gt;js&lt;/code&gt; target configuration block of your &lt;code&gt;build.gradle(.kts)&lt;/code&gt;. If this option is omitted, only Kotlin-internal library files are generated. These files can be used from other projects, but not run on their own.</source>
          <target state="translated">使用IR编译器时， &lt;code&gt;binaries.executable()&lt;/code&gt; 指令必须出现在 &lt;code&gt;build.gradle(.kts)&lt;/code&gt; 的 &lt;code&gt;js&lt;/code&gt; 目标配置块中。如果省略此选项，则仅生成Kotlin内部库文件。这些文件可以从其他项目中使用，但不能单独运行。</target>
        </trans-unit>
        <trans-unit id="6eb8f752ff8f2ca50e7eef437c4f1437c5c24a5d" translate="yes" xml:space="preserve">
          <source>When using the command-line compiler, add the compiler option &lt;code&gt;-Xuse-ir&lt;/code&gt;.</source>
          <target state="translated">使用命令行编译器时，添加编译器选项 &lt;code&gt;-Xuse-ir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23eb1fb1d8c12c86796891c59eb085c47d128eb5" translate="yes" xml:space="preserve">
          <source>When using the command-line compiler, switch to explicit API mode by adding the &lt;code&gt;-Xexplicit-api&lt;/code&gt; compiler option with the value &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt;.</source>
          <target state="translated">使用命令行编译器时，通过添加 &lt;code&gt;-Xexplicit-api&lt;/code&gt; 编译器选项（其值为 &lt;code&gt;strict&lt;/code&gt; 或 &lt;code&gt;warning&lt;/code&gt; )来切换到显式API模式。</target>
        </trans-unit>
        <trans-unit id="0acd4ad721ee61253910c4ba13a8be0c94889bbe" translate="yes" xml:space="preserve">
          <source>When we call a &lt;code&gt;vararg&lt;/code&gt;-function, we can pass arguments one-by-one, e.g. &lt;code&gt;asList(1, 2, 3)&lt;/code&gt;, or, if we already have an array and want to pass its contents to the function, we use the &lt;strong&gt;spread&lt;/strong&gt; operator (prefix the array with &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">当我们把一个 &lt;code&gt;vararg&lt;/code&gt; -function，我们可以通过一个参数接一个，例如 &lt;code&gt;asList(1, 2, 3)&lt;/code&gt; ，或者，如果我们已经有一个阵列，并希望将其内容传递给该函数，我们使用&lt;strong&gt;扩散&lt;/strong&gt;运算符（在数组前面加上 &lt;code&gt;*&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="79dc6e08abcd7d48d398a4ca21168dbf49b9bdf0" translate="yes" xml:space="preserve">
          <source>When we call methods on variables of platform types, Kotlin does not issue nullability errors at compile time, but the call may fail at runtime, because of a null-pointer exception or an assertion that Kotlin generates to prevent nulls from propagating:</source>
          <target state="translated">当我们在平台类型的变量上调用方法时,Kotlin在编译时不会发出空性错误,但在运行时可能会因为空指针异常或Kotlin产生的防止空值传播的断言而导致调用失败。</target>
        </trans-unit>
        <trans-unit id="ad1fe34b679899f7dee6782797e3bf361c2fe90a" translate="yes" xml:space="preserve">
          <source>When we declare many types in our supertype list, it may appear that we inherit more than one implementation of the same method. For example</source>
          <target state="translated">当我们在超类型列表中声明许多类型时,可能会出现我们继承了同一方法的多个实现。例如</target>
        </trans-unit>
        <trans-unit id="08c1783813dd9fc626a089b7cae223c9d065db16" translate="yes" xml:space="preserve">
          <source>When we have a named function declared like this:</source>
          <target state="translated">当我们有一个命名的函数这样声明时。</target>
        </trans-unit>
        <trans-unit id="61f9a57deb03c55b45ac7741559138e62485b782" translate="yes" xml:space="preserve">
          <source>When we have a nullable reference &lt;code&gt;b&lt;/code&gt;, we can say &quot;if &lt;code&gt;b&lt;/code&gt; is not null, use it, otherwise use some non-null value&quot;:</source>
          <target state="translated">当我们有一个可为空的引用 &lt;code&gt;b&lt;/code&gt; 时，我们可以说&amp;ldquo;如果 &lt;code&gt;b&lt;/code&gt; 不为null，则使用它，否则使用一些非null值&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="fbc0820779d8db91f205b3ecbf7db0ccf41073a0" translate="yes" xml:space="preserve">
          <source>When we have a nullable reference &lt;code&gt;r&lt;/code&gt;, we can say &quot;if &lt;code&gt;r&lt;/code&gt; is not null, use it, otherwise use some non-null value &lt;code&gt;x&lt;/code&gt;&quot;:</source>
          <target state="translated">当我们有一个可为空的引用 &lt;code&gt;r&lt;/code&gt; 时，我们可以说&amp;ldquo;如果 &lt;code&gt;r&lt;/code&gt; 不为null，则使用它，否则使用一些非null值 &lt;code&gt;x&lt;/code&gt; &amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="5732d17582b0ef91e5bb01d205646ae68f3db2fc" translate="yes" xml:space="preserve">
          <source>When we pass a lambda to a dynamic call, all of its parameters by default have the type &lt;code&gt;dynamic&lt;/code&gt;:</source>
          <target state="translated">当我们将lambda传递给动态调用时，默认情况下，其所有参数的类型均为 &lt;code&gt;dynamic&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0be162a260a9be965f47e4e14ba8852bd8d1fa24" translate="yes" xml:space="preserve">
          <source>When we read from &lt;code&gt;p&lt;/code&gt; that delegates to an instance of &lt;code&gt;Delegate&lt;/code&gt;, the &lt;code&gt;getValue()&lt;/code&gt; function from &lt;code&gt;Delegate&lt;/code&gt; is called, so that its first parameter is the object we read &lt;code&gt;p&lt;/code&gt; from and the second parameter holds a description of &lt;code&gt;p&lt;/code&gt; itself (e.g. you can take its name). For example:</source>
          <target state="translated">当我们读出 &lt;code&gt;p&lt;/code&gt; 委托给的一个实例 &lt;code&gt;Delegate&lt;/code&gt; 的 &lt;code&gt;getValue()&lt;/code&gt; 从函数 &lt;code&gt;Delegate&lt;/code&gt; 被调用，所以它的第一个参数是对象，我们读到 &lt;code&gt;p&lt;/code&gt; 从第二个参数持有的描述 &lt;code&gt;p&lt;/code&gt; 本身（例如，你可以采取其名称）。例如：</target>
        </trans-unit>
        <trans-unit id="111d8dd13a5f3aef5861ae64c3f6c02ff4cb90bb" translate="yes" xml:space="preserve">
          <source>When working from IntelliJ IDEA, we can find the &lt;code&gt;run&lt;/code&gt; action in the Gradle tool window.</source>
          <target state="translated">使用IntelliJ IDEA进行操作时，我们可以在Gradle工具窗口中找到 &lt;code&gt;run&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="ad6c6017c96852fa45cd533d083255cb214a9f4c" translate="yes" xml:space="preserve">
          <source>When wrapping chained calls, put the &lt;code&gt;.&lt;/code&gt; character or the &lt;code&gt;?.&lt;/code&gt; operator on the next line, with a single indent:</source>
          <target state="translated">当包装链接的呼叫时，请放入 &lt;code&gt;.&lt;/code&gt; 字符或 &lt;code&gt;?.&lt;/code&gt; 下一行的运算符，带有一个缩进：</target>
        </trans-unit>
        <trans-unit id="9f05d7113cc0860bca9dd1b2c8b1f2efc8346629" translate="yes" xml:space="preserve">
          <source>When writing Kotlin code, an object may need to be converted from a Kotlin type to the equivalent Swift/Objective-C type (or vice versa). In this case a plain old Kotlin cast can be used, e.g.</source>
          <target state="translated">当编写Kotlin代码时,可能需要将一个对象从Kotlin类型转换为等价的Swift/Objective-C类型(反之亦然)。在这种情况下,可以使用普通的Kotlin类型,例如</target>
        </trans-unit>
        <trans-unit id="9cafd8bf742afb2fbc35d3c6537af8b35836e156" translate="yes" xml:space="preserve">
          <source>When writing libraries, it's recommended to follow an additional set of rules to ensure API stability:</source>
          <target state="translated">在编写库的时候,建议多遵循一套规则,以保证API的稳定性。</target>
        </trans-unit>
        <trans-unit id="d741918b948509f4aba6408fd1ef9e8a1136bd6e" translate="yes" xml:space="preserve">
          <source>When writing native applications, oftentimes we need to access certain functionality that is not included in the Kotlin standard library, such as making HTTP requests, reading and writing from disk, etc.</source>
          <target state="translated">在编写本地应用程序时,很多时候我们需要访问某些Kotlin标准库中没有包含的功能,比如进行HTTP请求、从磁盘读写等。</target>
        </trans-unit>
        <trans-unit id="463d09586d01fae3ba7cf55cbbc35d4b7f20011b" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;mpp-create-lib&quot;&gt;create a multiplatform project&lt;/a&gt;, the Project Wizard automatically applies the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; Gradle plugin in the file &lt;code&gt;build.gradle&lt;/code&gt;(&lt;code&gt;.kts&lt;/code&gt;).</source>
          <target state="translated">当你&lt;a href=&quot;mpp-create-lib&quot;&gt;创建一个多项目&lt;/a&gt;，项目向导自动应用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 摇篮插件在文件 &lt;code&gt;build.gradle&lt;/code&gt; （ &lt;code&gt;.kts&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f3156a4be9cfb99131296400d8e473f56e52183c" translate="yes" xml:space="preserve">
          <source>When you are ready, verify the task with the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If you passed, there will be the &lt;strong&gt;Congratulations!&lt;/strong&gt; message:</source>
          <target state="translated">准备就绪后，&lt;strong&gt;请使用&lt;/strong&gt; &amp;ldquo; &lt;strong&gt;任务描述&amp;rdquo;&lt;/strong&gt;面板顶部的&amp;ldquo; &lt;strong&gt;检查&amp;rdquo;&lt;/strong&gt;图标来验证任务。如果您通过了，那就&lt;strong&gt;恭喜您！&lt;/strong&gt;信息：</target>
        </trans-unit>
        <trans-unit id="598dab40b3272c1fb9a453390cd6e6de1808ea5d" translate="yes" xml:space="preserve">
          <source>When you call a member function on &lt;code&gt;this&lt;/code&gt;, you can skip the &lt;code&gt;this.&lt;/code&gt; part. If you have a non-member function with the same name, use this with caution, because in some cases it can be called instead:</source>
          <target state="translated">当您在 &lt;code&gt;this&lt;/code&gt; 上调用成员函数时，可以跳过 &lt;code&gt;this.&lt;/code&gt; 部分。如果您有一个同名的非成员函数，请谨慎使用，因为在某些情况下可以调用它：</target>
        </trans-unit>
        <trans-unit id="bd4f91db759426c5c027f930c965bc523e90edeb" translate="yes" xml:space="preserve">
          <source>When you call this function, the compiler will know that the execution doesn't continue beyond the call:</source>
          <target state="translated">当你调用这个函数时,编译器就会知道在调用之后不会继续执行。</target>
        </trans-unit>
        <trans-unit id="ebc718bb513c3e899345e0a1f6bade26496caf51" translate="yes" xml:space="preserve">
          <source>When you choose the JavaScript target, any Kotlin code that is part of the project as well as the standard library that ships with Kotlin is transpiled to JavaScript. However, this excludes the JDK and any JVM or Java framework or library used. Any file that is not Kotlin will be ignored during compilation.</source>
          <target state="translated">当您选择JavaScript目标时,任何作为项目一部分的Kotlin代码以及Kotlin附带的标准库都会被移植到JavaScript中。但是,这不包括JDK和任何JVM或使用的Java框架或库。任何非Kotlin的文件都将在编译过程中被忽略。</target>
        </trans-unit>
        <trans-unit id="61cb3b5bb55f1ec33f90df7914d7d8c5178a623a" translate="yes" xml:space="preserve">
          <source>When you compile a multiplatform project for a specific platform, the code for both the common and platform-specific parts is generated.</source>
          <target state="translated">当你为特定平台编译多平台项目时,会同时生成通用部分和特定平台部分的代码。</target>
        </trans-unit>
        <trans-unit id="a4955e4afeb340ef9f82c25ba0af627acbecccfb" translate="yes" xml:space="preserve">
          <source>When you create a multiplatform project, targets are added to the &lt;code&gt;kotlin&lt;/code&gt; block in the file &lt;code&gt;build.gradle&lt;/code&gt; (&lt;code&gt;build.gradle.kts&lt;/code&gt;).</source>
          <target state="translated">创建多平台项目时， &lt;code&gt;kotlin&lt;/code&gt; 目标添加到文件 &lt;code&gt;build.gradle&lt;/code&gt; （ &lt;code&gt;build.gradle.kts&lt;/code&gt; ）中的kotlin块中。</target>
        </trans-unit>
        <trans-unit id="487f53e65f3e40a392960d7ffe8fb70d789db81a" translate="yes" xml:space="preserve">
          <source>When you create a progression implicitly by iterating a range, this progression's &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; elements are the range's endpoints, and the &lt;code&gt;step&lt;/code&gt; is 1.</source>
          <target state="translated">通过迭代范围隐式创建进度时，此进度的 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 元素是范围的端点， &lt;code&gt;step&lt;/code&gt; 为1。</target>
        </trans-unit>
        <trans-unit id="51bafee0f48839d4b74895eeb5d22b3bc95f6844" translate="yes" xml:space="preserve">
          <source>When you create own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt;&lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt;&lt;code&gt;AbstractSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt;&lt;code&gt;AbstractMap&lt;/code&gt;&lt;/a&gt;, and their mutable counterparts.</source>
          <target state="translated">创建自己的集合接口实现时，必须实现其成员函数。为了使新实现的创建更加容易，请使用标准库中Collection接口的骨架实现：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt; &lt;code&gt;AbstractCollection&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt; &lt;code&gt;AbstractSet&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt; &lt;code&gt;AbstractMap&lt;/code&gt; &lt;/a&gt;及其可变对象。</target>
        </trans-unit>
        <trans-unit id="de5ca0060f568734c25c44dc064e42505647a415" translate="yes" xml:space="preserve">
          <source>When you create your own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt;&lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt;&lt;code&gt;AbstractSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt;&lt;code&gt;AbstractMap&lt;/code&gt;&lt;/a&gt;, and their mutable counterparts.</source>
          <target state="translated">创建自己的集合接口实现时，必须实现它们的成员函数。为了使新实现的创建更加容易，请使用标准库中集合接口的骨架实现：&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt; &lt;code&gt;AbstractCollection&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt; &lt;code&gt;AbstractSet&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt; &lt;code&gt;AbstractMap&lt;/code&gt; &lt;/a&gt;及其可变对象。</target>
        </trans-unit>
        <trans-unit id="dc3c8353ca1e574cdd5fef24454fb4fda2fc3277" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Pair&lt;/code&gt;s, you can do the reverse transformation &amp;ndash; &lt;em&gt;unzipping&lt;/em&gt; &amp;ndash; that builds two lists from these pairs:</source>
          <target state="translated">当你有一个 &lt;code&gt;List&lt;/code&gt; 的 &lt;code&gt;Pair&lt;/code&gt; S，你可以做反向转变- &lt;em&gt;解压&lt;/em&gt; -即建立从这些对两个列表：</target>
        </trans-unit>
        <trans-unit id="5c27d02fe0802eb2c5dc736c355913900c0370a9" translate="yes" xml:space="preserve">
          <source>When you have a variable or parameter of function type (sometimes called a &lt;em&gt;function reference&lt;/em&gt;), you can call it as if it were an ordinary function, and that will cause the referenced function to be called:</source>
          <target state="translated">当您具有函数类型的变量或参数（有时称为&lt;em&gt;函数引用&lt;/em&gt;）时，可以像调用普通函数一样对其进行调用，这将导致引用的函数被调用：</target>
        </trans-unit>
        <trans-unit id="e1aaa92f5ddb308d5297a444696d8b7457b69a72" translate="yes" xml:space="preserve">
          <source>When you have finished creating your course, it's a good idea to view your course from a learner's perspective and test it. Right-click on the course view and go to &lt;strong&gt;Course Creator -&amp;gt; Create Course Preview&lt;/strong&gt; to open your course in learner mode:</source>
          <target state="translated">完成课程创建后，最好从学习者的角度查看课程并进行测试。右键单击课程视图，然后转到&amp;ldquo; &lt;strong&gt;课程创建者&amp;rdquo;-&amp;gt;&amp;ldquo;创建课程预览&amp;rdquo;&lt;/strong&gt;以学习者模式打开课程：</target>
        </trans-unit>
        <trans-unit id="a3250cc79c522d1ac623227bb111869e351b8f95" translate="yes" xml:space="preserve">
          <source>When you run this code, you'll see that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are executed in the same order as they appear in the code. First, you see &lt;code&gt;filter:&lt;/code&gt; for all elements, then &lt;code&gt;length:&lt;/code&gt; for the elements left after filtering, and then the output of the two last lines. This is how the list processing goes:</source>
          <target state="translated">运行此代码时，您会看到 &lt;code&gt;filter()&lt;/code&gt; 和 &lt;code&gt;map()&lt;/code&gt; 函数的执行顺序与代码中出现的顺序相同。首先，看到 &lt;code&gt;filter:&lt;/code&gt; 对于所有元素，然后是 &lt;code&gt;length:&lt;/code&gt; 对于过滤后剩余的元素，然后是最后两行的输出。列表处理如下：</target>
        </trans-unit>
        <trans-unit id="05ad4ed8cb6fd5863366c2a4f1abcdd6e5010b48" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;also&lt;/code&gt; in the code, you can read it as &amp;ldquo;&lt;em&gt;and also do the following with the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">当您 &lt;code&gt;also&lt;/code&gt; 代码中看到时，可以将其读取为&amp;ldquo;，&lt;em&gt;并且还可以对该对象执行以下操作。&lt;/em&gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="6928284bef91c96791612dd21e00cae5d64a5053" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;also&lt;/code&gt; in the code, you can read it as &amp;ldquo;&lt;em&gt;and also do the following&lt;/em&gt;&amp;rdquo;.</source>
          <target state="translated">当您 &lt;code&gt;also&lt;/code&gt; 代码中看到时，可以将其读取为&amp;ldquo;，&lt;em&gt;然后执行以下操作&lt;/em&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8d24e43a2e1296ae8492ad2425aad4e306037e84" translate="yes" xml:space="preserve">
          <source>When you switch to Kotlin, your xml layout files don't change at all. For instance, you use &lt;code&gt;variable&lt;/code&gt; within &lt;code&gt;data&lt;/code&gt; to describe a variable that may be used within the layout. You can declare a variable of a Kotlin type:</source>
          <target state="translated">当您切换到Kotlin时，您的xml布局文件完全不变。例如，您在 &lt;code&gt;data&lt;/code&gt; 使用 &lt;code&gt;variable&lt;/code&gt; 来描述可在布局中使用的变量。您可以声明Kotlin类型的变量：</target>
        </trans-unit>
        <trans-unit id="1239262e94d3c7df345c600c729ad2ad431b78a5" translate="yes" xml:space="preserve">
          <source>When you take an interface or an open class as a parameter, you generally don't know the real type of the parameter at runtime, since it could be an instance of a subclass or of any class that implements the interface. It is possible to check what the exact type is, but like in Python, you should generally avoid it and instead design your class hierarchy such that you can do what you need by proper overriding of functions or properties.</source>
          <target state="translated">当你把一个接口或一个开放类作为参数时,你一般在运行时不知道参数的真实类型,因为它可能是一个子类或任何实现该接口的类的实例。检查确切的类型是什么是可能的,但就像在Python中一样,你一般应该避免这样做,而应该设计你的类层次结构,使你可以通过适当地覆盖函数或属性来完成你需要的事情。</target>
        </trans-unit>
        <trans-unit id="08daa6c22199d25d4c67e8e2145164a79b9c18ed" translate="yes" xml:space="preserve">
          <source>When you use an API in the code intended for third-party use (a library), you can propagate its opt-in requirement to your API as well. To do this, annotate your declaration with the &lt;a href=&quot;#opt-in-requirement-annotations&quot;&gt;&lt;em&gt;opt-in requirement annotation&lt;/em&gt;&lt;/a&gt; of the API used in its body. This enables you to use the API elements marked with this annotation.</source>
          <target state="translated">当您在供第三方使用的代码（库）中使用API​​时，也可以将其选择加入要求传播到您的API中。为此，请使用主体中使用的API的&amp;ldquo;&lt;a href=&quot;#opt-in-requirement-annotations&quot;&gt;&lt;em&gt;加入要求&amp;rdquo;注释&lt;/em&gt;&lt;/a&gt;对声明进行&lt;em&gt;注释&lt;/em&gt;。这使您可以使用带有此批注标记的API元素。</target>
        </trans-unit>
        <trans-unit id="9a7fe00cf3644a358da554d74666746417284178" translate="yes" xml:space="preserve">
          <source>When you use an arithmetic operator on two integers of different types, the result is &quot;upgraded&quot; to the widest type. Note that the result might still overflow.</source>
          <target state="translated">当你对两个不同类型的整数使用算术运算符时,结果会被 &quot;升级 &quot;为最宽的类型。请注意,结果可能仍然会溢出。</target>
        </trans-unit>
        <trans-unit id="3c62a163cbef716d256d43a2d19d876bb12a78c5" translate="yes" xml:space="preserve">
          <source>When you use an experimental API in the code intended for third-party use (a library), you can mark your API as experimental as well. To do this, annotate your declaration with the &lt;em&gt;experimental marker annotation&lt;/em&gt; of the API used in its body. This enables you to use the API elements annotated with this marker.</source>
          <target state="translated">在供第三方使用的代码（库）中使用实验性API时，您也可以将API标记为实验性。为此，请在声明中使用主体中使用的API 的&lt;em&gt;实验性标记注释&lt;/em&gt;。这使您可以使用带有此标记注释的API元素。</target>
        </trans-unit>
        <trans-unit id="06b65a21854b89868579d67b03180df54f3544a9" translate="yes" xml:space="preserve">
          <source>When you use named arguments in a function call, you can freely change the order they are listed in, and if you want to use their default values you can just leave them out altogether.</source>
          <target state="translated">当你在函数调用中使用命名参数时,你可以自由地改变它们的排列顺序,如果你想使用它们的默认值,你可以完全不使用它们。</target>
        </trans-unit>
        <trans-unit id="48d4e3a5ba4e31277cb9f0e61d2e54f709bf8961" translate="yes" xml:space="preserve">
          <source>When you're annotating a property or a primary constructor parameter, there are multiple Java elements which are generated from the corresponding Kotlin element, and therefore multiple possible locations for the annotation in the generated Java bytecode. To specify how exactly the annotation should be generated, use the following syntax:</source>
          <target state="translated">当您要对一个属性或主构造参数进行注释时,会有多个Java元素从相应的Kotlin元素中生成,因此在生成的Java字节码中,注释可能有多个位置。要指定注解的具体生成方式,请使用以下语法。</target>
        </trans-unit>
        <trans-unit id="b61884cef7d3f26b08581a78b91851698ab0fd2b" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;jvmMain&lt;/code&gt; is compiled for a certain target, &lt;code&gt;commonMain&lt;/code&gt; takes part in that compilation as well and is also compiled into the same target binary form, such as JVM class files.</source>
          <target state="translated">每当为某个目标编译 &lt;code&gt;jvmMain&lt;/code&gt; 时， &lt;code&gt;commonMain&lt;/code&gt; 也会参与该编译，并且还会编译为相同的目标二进制格式，例如JVM类文件。</target>
        </trans-unit>
        <trans-unit id="89ad1e4f32412313aa6f0bd650dfc39dcb173e7f" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same object more than once, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer, provided no information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the object is modified.</source>
          <target state="translated">只要在同一对象上多次调用它， &lt;code&gt;hashCode&lt;/code&gt; 方法就必须一致地返回相同的整数，只要不修改该对象的 &lt;code&gt;equals&lt;/code&gt; 比较中使用的信息即可。</target>
        </trans-unit>
        <trans-unit id="55d78075233bceac802e1984993c3d3b3088601f" translate="yes" xml:space="preserve">
          <source>Whenever you create an instance of this class, you must specify an actual type in place of &lt;code&gt;T&lt;/code&gt;, unless the compiler can infer it from the constructor parameters: &lt;code&gt;TreeNode(&quot;foo&quot;)&lt;/code&gt; or &lt;code&gt;TreeNode&amp;lt;String&amp;gt;(null)&lt;/code&gt;. Every use of this instance will act as if it were an instance of a class that looks like this:</source>
          <target state="translated">每当创建此类的实例时，都必须指定实际的类型来代替 &lt;code&gt;T&lt;/code&gt; ，除非编译器可以从构造函数参数 &lt;code&gt;TreeNode(&quot;foo&quot;)&lt;/code&gt; 或 &lt;code&gt;TreeNode&amp;lt;String&amp;gt;(null)&lt;/code&gt; 推断出它。每次使用此实例都会像看起来像是一个类的实例一样：</target>
        </trans-unit>
        <trans-unit id="8ca39f6f0f111844ff04d02c9f4bf0efee656845" translate="yes" xml:space="preserve">
          <source>Whenever you use an arithmetic operator on two integers of the same type (or when you use a unary operator like negation), &lt;em&gt;there is no automatic &quot;upgrading&quot; if the result doesn't fit in the type of the operands!&lt;/em&gt; Try this:</source>
          <target state="translated">每当您对相同类型的两个整数使用算术运算符时（或使用诸如否定之类的一元运算符）时，&lt;em&gt;如果结果不适合操作数的类型，则不会自动进行&amp;ldquo;升级&amp;rdquo;！&lt;/em&gt;试试这个：</target>
        </trans-unit>
        <trans-unit id="b65896c2c2c1091be4cf3076a04d4d7b1bc8f223" translate="yes" xml:space="preserve">
          <source>Whenever you want a variable that can only take on a limited number of values where the only feature of each value is that it's distinct from all the other values, you can create an &lt;em&gt;enum class&lt;/em&gt;:</source>
          <target state="translated">每当您想要一个只能包含有限数量的值的变量，并且每个值的唯一特征是与所有其他值都不同时，可以创建一个&lt;em&gt;枚举类&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="b72a1d211e3475b177a16c0ad833aad00f45de47" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;__TYPE__&lt;/code&gt; is one of the simple type names and &lt;code&gt;__CTYPE__&lt;/code&gt; is the related Objective-C type, e.g. &lt;code&gt;initWithChar(char)&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;__TYPE__&lt;/code&gt; 是简单类型名称之一，而 &lt;code&gt;__CTYPE__&lt;/code&gt; 是相关的Objective-C类型，例如 &lt;code&gt;initWithChar(char)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="279ee64e67a8a3e973e45233e8ce0a407cbaf608" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;declarationToKeep&lt;/code&gt; has the following syntax:</source>
          <target state="translated">其中 &lt;code&gt;declarationToKeep&lt;/code&gt; 具有以下语法：</target>
        </trans-unit>
        <trans-unit id="eb06827a60ce404697c981082d7a9ff58779079e" translate="yes" xml:space="preserve">
          <source>Where can I get an HD Kotlin logo?</source>
          <target state="translated">哪里可以得到高清Kotlin标志?</target>
        </trans-unit>
        <trans-unit id="00d532d7604042ff0388fc0d8b327eb21555113f" translate="yes" xml:space="preserve">
          <source>Where can I learn more about Kotlin?</source>
          <target state="translated">哪里可以了解更多关于Kotlin的信息?</target>
        </trans-unit>
        <trans-unit id="60dc3003b0157a1bb3a0084a1e562958004b1c24" translate="yes" xml:space="preserve">
          <source>Whether a main function should be called</source>
          <target state="translated">是否应该调用主函数</target>
        </trans-unit>
        <trans-unit id="350fceb3b43601161521c9570f080755bec5203a" translate="yes" xml:space="preserve">
          <source>Whether metadata file with binary descriptors should be generated</source>
          <target state="translated">是否应该生成带有二进制描述符的元数据文件。</target>
        </trans-unit>
        <trans-unit id="b1689158ae06f88b863b7fd9b887d675c25f4bd4" translate="yes" xml:space="preserve">
          <source>Whether sourcemap file should be generated</source>
          <target state="translated">是否要生成源码图文件</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="translated">哪些打印。</target>
        </trans-unit>
        <trans-unit id="c668af734b8bab593fb373580041499369e8214b" translate="yes" xml:space="preserve">
          <source>Which versions of JVM does Kotlin target?</source>
          <target state="translated">Kotlin针对哪些版本的JVM?</target>
        </trans-unit>
        <trans-unit id="02402c88e9d606c5d9042e0b0c12d1739344aeb9" translate="yes" xml:space="preserve">
          <source>While Kotlin annotations look like Python decorators, they are far less flexible: they can generally only be used for metadata. They are pure data-containing classes, and do not contain any executable code. Some built-in annotations have an effect on the compilation process (such as &lt;code&gt;@JvmStatic&lt;/code&gt;), but custom annotations are only useful for providing metadata that can be inspected at runtime by the reflection system. We won't delve deeply into annotations here, but here is an example. The annotations on the annotation declaration itself specify what constructs the annotation may be applied to and whether it is available for runtime inspection.</source>
          <target state="translated">尽管Kotlin批注看起来像Python装饰器，但它们的灵活性要差得多：它们通常只能用于元数据。它们是纯数据类，不包含任何可执行代码。某些内置注释会影响编译过程（例如 &lt;code&gt;@JvmStatic&lt;/code&gt; ），但是自定义注释仅可用于提供可由反射系统在运行时检查的元数据。我们不会在这里深入研究批注，但这是一个示例。注释声明本身上的注释指定注释可以应用于哪些构造以及是否可用于运行时检查。</target>
        </trans-unit>
        <trans-unit id="a68a67a970d91d390715c4a5723442211582200e" translate="yes" xml:space="preserve">
          <source>While Loops</source>
          <target state="translated">While Loops</target>
        </trans-unit>
        <trans-unit id="c1b7c19248a78707f3905a80fc2242e3ecc22b20" translate="yes" xml:space="preserve">
          <source>While being different, conceptually, Flow &lt;em&gt;is&lt;/em&gt; a reactive stream and it is possible to convert it to the reactive (spec and TCK compliant) Publisher and vice versa. Such converters are provided by &lt;code&gt;kotlinx.coroutines&lt;/code&gt; out-of-the-box and can be found in corresponding reactive modules (&lt;code&gt;kotlinx-coroutines-reactive&lt;/code&gt; for Reactive Streams, &lt;code&gt;kotlinx-coroutines-reactor&lt;/code&gt; for Project Reactor and &lt;code&gt;kotlinx-coroutines-rx2&lt;/code&gt;/&lt;code&gt;kotlinx-coroutines-rx3&lt;/code&gt; for RxJava2/RxJava3). Integration modules include conversions from and to &lt;code&gt;Flow&lt;/code&gt;, integration with Reactor's &lt;code&gt;Context&lt;/code&gt; and suspension-friendly ways to work with various reactive entities.</source>
          <target state="translated">虽然是不同的，从概念上讲，流量&lt;em&gt;是&lt;/em&gt;反应性流，并且可以将其转化成反应性（规格和TCK兼容）出版商和反之亦然。这种转换器由设置 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 外的所述盒，并且可以在相应的反应性模块（找到 &lt;code&gt;kotlinx-coroutines-reactive&lt;/code&gt; 为反应性流， &lt;code&gt;kotlinx-coroutines-reactor&lt;/code&gt; 用于工程反应堆和 &lt;code&gt;kotlinx-coroutines-rx2&lt;/code&gt; / &lt;code&gt;kotlinx-coroutines-rx3&lt;/code&gt; 用于RxJava2 / RxJava3的coroutines- rx3）。集成模块包括往返于 &lt;code&gt;Flow&lt;/code&gt; 的转换，与Reactor的 &lt;code&gt;Context&lt;/code&gt; 集成以及与各种反应式实体一起使用的易于悬挂的方式。</target>
        </trans-unit>
        <trans-unit id="178ea4ef9776a99f280cbce3c37b6808c99bffb3" translate="yes" xml:space="preserve">
          <source>While compilation from the console seems to be easy and clear, it does not scale well for larger projects with hundreds of files and libraries. For real-world projects it is recommended to use a &lt;a href=&quot;using-gradle&quot;&gt;build system&lt;/a&gt; and &lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt;.</source>
          <target state="translated">尽管从控制台进行的编译看起来很简单明了，但对于具有数百个文件和库的大型项目而言，它的伸缩性并不理想。对于实际项目，建议使用&lt;a href=&quot;using-gradle&quot;&gt;构建系统&lt;/a&gt;和&lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="405a10cf31f596bca1e965bfbd41f2ec04a34af9" translate="yes" xml:space="preserve">
          <source>While compilation from the console seems to be easy and clear, we should notice, that it does not scale well for bigger projects with hundreds of files and libraries. In addition to this, the command line approach does not explain to an IDE how to open such a project, where the sources are located, what dependencies are used, or how the dependencies are downloaded and so on.</source>
          <target state="translated">虽然从控制台编译似乎很容易,也很清晰,但我们应该注意到,对于有数百个文件和库的大型项目来说,它并不能很好地扩展。除此之外,命令行的方法并不能向IDE解释如何打开这样的项目,源码在哪里,使用了哪些依赖关系,或者如何下载依赖关系等等。</target>
        </trans-unit>
        <trans-unit id="1e744f3d4d9082a8982116fd4e4676866618d662" translate="yes" xml:space="preserve">
          <source>While cross-platform compilation is possible, which means using one platform to compile for a different one, in this case we'll be targeting the same platform we're compiling on.</source>
          <target state="translated">虽然跨平台编译是可能的,这意味着使用一个平台为不同的平台编译,但在这种情况下,我们将针对同一个平台进行编译。</target>
        </trans-unit>
        <trans-unit id="6ce105800554de67a92cb5eed4d6aabf562edfb9" translate="yes" xml:space="preserve">
          <source>While doing so was not useful in this particular example, one could get interesting effects by adding an unprojected parameter type &lt;code&gt;via: Bowl&amp;lt;T&amp;gt;&lt;/code&gt;, in which case the generic type parameter of &lt;code&gt;via&lt;/code&gt; would be forced to be &quot;in-between&quot; those of &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">尽管在此特定示例中这样做没有用，但可以通过添加一个未投影的参数类型 &lt;code&gt;via: Bowl&amp;lt;T&amp;gt;&lt;/code&gt; 来获得有趣的效果：Bowl &amp;lt;T&amp;gt;，在这种情况下， &lt;code&gt;via&lt;/code&gt; 的通用类型参数将被强制介于以下两者之间： &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74f25352205ca76e991ebde88bff4a464449ff37" translate="yes" xml:space="preserve">
          <source>While it is possible in Kotlin to dynamically create new classes at runtime or to add members to a class, it's tricky and slow, and generally discouraged. However, it is easy to dynamically inspect an object to see e.g. what properties and functions it contains and which annotations exist on them. This is called &lt;em&gt;reflection&lt;/em&gt;, and it's not very performant, so avoid it unless you really need it.</source>
          <target state="translated">尽管在Kotlin中可以在运行时动态创建新类或将成员添加到类中，但这既棘手又缓慢，并且通常不鼓励这样做。但是，可以很容易地动态检查对象以查看例如对象包含的属性和功能以及对象上存在的注释。这被称为&lt;em&gt;反射&lt;/em&gt;，它不是很有效，因此除非真正需要它，否则请避免使用它。</target>
        </trans-unit>
        <trans-unit id="00ebcc3032e38c0f9dbd212c37ea7b7605032b6f" translate="yes" xml:space="preserve">
          <source>While it is possible to use the command line, either directly or by combining it with a script file (i.e., sh or bat file), we should notice, that it does not scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin.</source>
          <target state="translated">尽管可以直接使用命令行，也可以将其与脚本文件（即sh或bat文件）结合使用，但我们应该注意到，对于具有数百个文件和库的大型项目，它的伸缩性不佳。然后最好将Kotlin / Native编译器与构建系统一起使用，因为它有助于下载和缓存具有传递依赖项的Kotlin / Native编译器二进制文件和库，并运行编译器和测试。 Kotlin / Native可以通过&lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件使用&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;构建系统。</target>
        </trans-unit>
        <trans-unit id="ccb7cdd4315f54dc22cc954a705304d8025d4496" translate="yes" xml:space="preserve">
          <source>While it is possible to use the command line, either directly or by combining it with a script file (i.e., sh or bat file), we should notice, that it does not scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin.</source>
          <target state="translated">虽然可以直接使用命令行，也可以将其与脚本文件（即sh或bat文件）结合使用，但我们应该注意到，对于具有数百个文件和库的大型项目，它的伸缩性不佳。然后最好将Kotlin / Native编译器与构建系统一起使用，因为它有助于下载和缓存具有传递依赖项的Kotlin / Native编译器二进制文件和库，并运行编译器和测试。 Kotlin / Native可以通过&lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt;插件使用&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt;构建系统。</target>
        </trans-unit>
        <trans-unit id="4688c1c9cfee712dab9268862c4aa04c7274850f" translate="yes" xml:space="preserve">
          <source>While it was already possible to extract this variable just before &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;when&lt;/code&gt; has its scope properly restricted to the body of &lt;code&gt;when&lt;/code&gt;, and so preventing namespace pollution. See the full documentation on &lt;code&gt;when&lt;/code&gt;&lt;a href=&quot;control-flow#when-expression&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">虽然它已经可能只是之前提取该变量 &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;val&lt;/code&gt; 在 &lt;code&gt;when&lt;/code&gt; 有适当的范围仅限于身体 &lt;code&gt;when&lt;/code&gt; ，所以防止命名空间污染请 &lt;code&gt;when&lt;/code&gt; &lt;a href=&quot;control-flow#when-expression&quot;&gt;此处&lt;/a&gt;查看完整的文档。</target>
        </trans-unit>
        <trans-unit id="18fc211f02fff65fa62198ec0d6b2196f5fda852" translate="yes" xml:space="preserve">
          <source>While most IDE's including &lt;a href=&quot;https://www.jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; can generate the corresponding Gradle file, we're going to take a look at how to create this manually, to have a better understanding of how things work under the covers. If you'd like to use the IDE, check out &lt;a href=&quot;using-intellij-idea&quot;&gt;Using IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">尽管包括&lt;a href=&quot;https://www.jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt;在内的大多数IDE都可以生成相应的Gradle文件，但我们还是要看一下如何手动创建此Gradle文件，以更好地了解事物的幕后工作方式。如果您想使用IDE，请查看&lt;a href=&quot;using-intellij-idea&quot;&gt;Using IntelliJ IDEA&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edf1dfe40b0f0a7f06896b58374c31b6b8d9a056" translate="yes" xml:space="preserve">
          <source>While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.2 to Kotlin 1.3</source>
          <target state="translated">虽然大部分的语言变化已经通过其他渠道公布了,比如更新变更日志或编译器警告,但本文档总结了所有这些变化,为从Kotlin 1.2迁移到Kotlin 1.3提供了完整的参考。</target>
        </trans-unit>
        <trans-unit id="b3798978e8389c22f139d4b97896bde1b7b9685d" translate="yes" xml:space="preserve">
          <source>While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.3 to Kotlin 1.4.</source>
          <target state="translated">虽然大部分的语言变化已经通过其他渠道公布了,比如更新变更日志或编译器警告,但本文档总结了所有这些变化,为从Kotlin 1.3迁移到Kotlin 1.4提供了完整的参考。</target>
        </trans-unit>
        <trans-unit id="399ba37d2ce977b9a644dbef3594c75ca535f65a" translate="yes" xml:space="preserve">
          <source>While the above solution works well for situations in which we have a corresponding header file (be this something we've defined ourselves or converted from a TypeScript header), often times we need to work with some library that does not have a header. For instance, let's say we want to use a jQuery plugin, that allows us to convert an HTML table to a nice looking navigable grid.</source>
          <target state="translated">虽然上面的解决方案对于我们有相应的头文件(无论是我们自己定义的文件还是从TypeScript头文件转换而来的文件)的情况很好,但很多时候我们需要使用一些没有头文件的库。比如说,我们想使用一个jQuery插件,它可以让我们将一个HTML表格转换为一个漂亮的可导航网格。</target>
        </trans-unit>
        <trans-unit id="7193542d5cd6b24f8c9a4e41a255c37b1a878838" translate="yes" xml:space="preserve">
          <source>While the converter is not fool-proof, it does a pretty decent job of converting most boilerplate code from Java to Kotlin. Some manual tweaking however is sometimes required.</source>
          <target state="translated">虽然转换器不是万无一失的,但它在将大多数模板代码从Java转换到Kotlin方面做得相当不错。然而,有时需要进行一些手动调整。</target>
        </trans-unit>
        <trans-unit id="d3c9392710d351a08ea5a20fd29014ffdd0dc8f8" translate="yes" xml:space="preserve">
          <source>While the dots suggest that packages are nested inside each other, that's not actually the case from a language standpoint. While it's a good idea to organize your code such that the &quot;subpackages&quot; of &lt;code&gt;content&lt;/code&gt;, such as &lt;code&gt;content.exercises&lt;/code&gt; and &lt;code&gt;content.articles&lt;/code&gt;, both contain content-related code, these three packages are unrelated from a language standpoint. However, if you use &lt;em&gt;modules&lt;/em&gt; (as defined by your build system), it is typically the case that all &quot;subpackages&quot; go in the same module, in which case symbols with &lt;a href=&quot;visibility-modifiers&quot;&gt;&lt;code&gt;internal&lt;/code&gt; visibility&lt;/a&gt; are visible throughout the subpackages.</source>
          <target state="translated">尽管这些点表明程序包彼此嵌套，但从语言角度来看，实际上并非如此。虽然最好组织代码以使 &lt;code&gt;content&lt;/code&gt; 的&amp;ldquo;子包&amp;rdquo;（例如 &lt;code&gt;content.exercises&lt;/code&gt; 和 &lt;code&gt;content.articles&lt;/code&gt; ）都包含与内容相关的代码，但是从语言角度来看，这三个包是无关的。但是，如果使用&lt;em&gt;模块&lt;/em&gt;（由构建系统定义），则通常所有&amp;ldquo;子包&amp;rdquo;都位于同一模块中，在这种情况下，具有&lt;a href=&quot;visibility-modifiers&quot;&gt; &lt;code&gt;internal&lt;/code&gt; 可见性的&lt;/a&gt;符号在整个子包中都是可见的。</target>
        </trans-unit>
        <trans-unit id="6f4289b089753c293140e137503818ca7bef2f53" translate="yes" xml:space="preserve">
          <source>While the output of the compiler does not have any dependencies or virtual machine requirements, the compiler itself and the Gradle build system require a Java 1.8 or 11 runtime. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or another resource for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">尽管编译器的输出没有任何依赖关系或虚拟机要求，但编译器本身和Gradle构建系统需要Java 1.8或11运行时。请查看&lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt;或其他资源，以获得最佳的JRE，OpenJDK或JDK发行版。</target>
        </trans-unit>
        <trans-unit id="10c2d0246f094d4009ab7bad0367365f4bcc7c84" translate="yes" xml:space="preserve">
          <source>While the output of the compiler does not have any dependencies or virtual machine requirements, the compiler itself requires &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;Java 1.8 or higher runtime&lt;/a&gt;.</source>
          <target state="translated">尽管编译器的输出没有任何依赖关系或虚拟机要求，但编译器本身需要&lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;Java 1.8或更高版本的runtime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34d621226a511f26c66770b36d29a5c867fde780" translate="yes" xml:space="preserve">
          <source>While this example happened to use the same expression, that is not necessary - overloaded functions can do completely different things if need be (although your code can get confusing if you make functions that have very different behavior be overloads of each other).</source>
          <target state="translated">虽然这个例子碰巧使用了相同的表达式,但这是没有必要的--如果需要的话,重载函数可以做完全不同的事情(尽管如果你让行为非常不同的函数成为彼此的重载,你的代码会变得混乱)。</target>
        </trans-unit>
        <trans-unit id="68ab041f58d77da2145ef925bbf99b70a47a9c63" translate="yes" xml:space="preserve">
          <source>While uploading your library to Bintray, you will see multiple versions for each artifact (such as &lt;code&gt;my-library-jvm&lt;/code&gt;, &lt;code&gt;my-library-metadata&lt;/code&gt;, etc.). To fix this, add &lt;code&gt;systemProp.org.gradle.internal.publish.checksums.insecure=true&lt;/code&gt;. See &lt;a href=&quot;https://github.com/gradle/gradle/issues/11412&quot;&gt;this issue&lt;/a&gt; for details. This is a common Gradle 6.0 issue that is neither MPP nor Kotlin specific.</source>
          <target state="translated">将库上传到Bintray时，您将看到每个工件的多个版本（例如 &lt;code&gt;my-library-jvm&lt;/code&gt; ， &lt;code&gt;my-library-metadata&lt;/code&gt; 等）。要解决此问题，请添加 &lt;code&gt;systemProp.org.gradle.internal.publish.checksums.insecure=true&lt;/code&gt; 。有关详细信息，请参&lt;a href=&quot;https://github.com/gradle/gradle/issues/11412&quot;&gt;见此问题&lt;/a&gt;。这是常见的Gradle 6.0问题，既不是MPP也不是Kotlin特有的。</target>
        </trans-unit>
        <trans-unit id="29d4507848ac2db4dd040b8f1b98e137154ce676" translate="yes" xml:space="preserve">
          <source>While we don&amp;rsquo;t recommend it, you can use a wildcard &lt;code&gt;*&lt;/code&gt; in place of a version number if you do not want to specify a version or version range explicitly.</source>
          <target state="translated">虽然我们不建议这样做，但是如果您不想显式指定版本或版本范围，则可以使用通配符 &lt;code&gt;*&lt;/code&gt; 代替版本号。</target>
        </trans-unit>
        <trans-unit id="79482c24120b8d210f4051a8c238d3feb29fa237" translate="yes" xml:space="preserve">
          <source>Who develops Kotlin?</source>
          <target state="translated">谁开发了Kotlin?</target>
        </trans-unit>
        <trans-unit id="6b8ca7e4bd278a327d17a1ff62cc87137c652d74" translate="yes" xml:space="preserve">
          <source>Why Kotlin/Native?</source>
          <target state="translated">为什么选择Kotlin/Native?</target>
        </trans-unit>
        <trans-unit id="5327cb3e3f7820311f240e8254b2120a882043dc" translate="yes" xml:space="preserve">
          <source>Why not just add required manifest options to all Kotlin libraries</source>
          <target state="translated">为什么不在所有的Kotlin库中添加必要的manifest选项呢?</target>
        </trans-unit>
        <trans-unit id="dc289721e21b7419371258307342fbd161fffe25" translate="yes" xml:space="preserve">
          <source>Wildcard-types</source>
          <target state="translated">Wildcard-types</target>
        </trans-unit>
        <trans-unit id="1a6e732a37845c36fcda3afa6f1ba0d920b0ebca" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers</source>
          <target state="translated">WindowEventHandlers</target>
        </trans-unit>
        <trans-unit id="0be6c8c411ba30d8cffb7e90ca7acef58e77aa71" translate="yes" xml:space="preserve">
          <source>WindowLocalStorage</source>
          <target state="translated">WindowLocalStorage</target>
        </trans-unit>
        <trans-unit id="4695cae95157eec4a2f36b8710914191b7160a60" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope</source>
          <target state="translated">WindowOrWorkerGlobalScope</target>
        </trans-unit>
        <trans-unit id="837e70bad69f4bf6bd4622325d1fb73918d9e99b" translate="yes" xml:space="preserve">
          <source>WindowSessionStorage</source>
          <target state="translated">WindowSessionStorage</target>
        </trans-unit>
        <trans-unit id="7d22ecce0385c959845f551d5a3b5ab183398dfa" translate="yes" xml:space="preserve">
          <source>Windowed</source>
          <target state="translated">Windowed</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="628596087f96fc1704310fa20e91f817ad0907ae" translate="yes" xml:space="preserve">
          <source>Windows (mingw x86_64, x86)</source>
          <target state="translated">Windows (mingw x86_64,x86)</target>
        </trans-unit>
        <trans-unit id="3501a24aebe2c74160390742479cffed6294f769" translate="yes" xml:space="preserve">
          <source>Windows targets require a Windows host;</source>
          <target state="translated">Windows目标需要一个Windows主机。</target>
        </trans-unit>
        <trans-unit id="ce9d44e441b23e1629b147f917e9518ae0913959" translate="yes" xml:space="preserve">
          <source>Windows: &lt;code&gt;libnative_api.h&lt;/code&gt;, &lt;code&gt;libnative_symbols.def&lt;/code&gt; and &lt;code&gt;libnative.dll&lt;/code&gt;</source>
          <target state="translated">Windows： &lt;code&gt;libnative_api.h&lt;/code&gt; ， &lt;code&gt;libnative_symbols.def&lt;/code&gt; 和 &lt;code&gt;libnative.dll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a374d672ab75b4235e338c90ddfcf6afbecca5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; plugin you can learn and teach Kotlin through code practicing tasks. It is available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. This tutorial describes course creation for an educator. If you want to use EduTools plugin for learning, read &lt;a href=&quot;edu-tools-learner&quot;&gt;&quot;Learning Kotlin with EduTools plugin&quot;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt;插件，您可以通过代码练习任务来学习和教导Kotlin。它在&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt;和&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA中&lt;/a&gt;都可用。本教程描述了为教育者创建课程的过程。如果要使用EduTools插件进行学习，请阅读&lt;a href=&quot;edu-tools-learner&quot;&gt;&amp;ldquo;&lt;/a&gt;使用EduTools插件学习Kotlin&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d7e4afdf3ca90295d086cf8bfcf9a9049903e7a2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; plugin you can learn and teach Kotlin through code practicing tasks. It is available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. This tutorial describes the interactive learning. If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;&quot;Teaching Kotlin with EduTools plugin&quot;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt;插件，您可以通过代码练习任务来学习和教导Kotlin。它在&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt;和&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA中&lt;/a&gt;都可用。本教程描述了交互式学习。如果要使用EduTools插件进行教学，请阅读&lt;a href=&quot;edu-tools-educator&quot;&gt;&amp;ldquo;使用EduTools插件教Kotlin&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddbee1008f9f20e446d88d4f79956907a6b4c399" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;the new hierarchical project structure support&lt;/a&gt;, you can share code among several targets in a multiplatform project. You can use platform-dependent libraries, such as &lt;code&gt;Foundation&lt;/code&gt;, &lt;code&gt;UIKit&lt;/code&gt;, and &lt;code&gt;posix&lt;/code&gt; in source sets shared among several native targets. This can help you share more native code without being limited by platform-specific dependencies.</source>
          <target state="translated">借助&lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;新的分层项目结构支持&lt;/a&gt;，您可以在多平台项目中的多个目标之间共享代码。您可以在多个本机目标之间共享的源集中使用平台相关的库，例如 &lt;code&gt;Foundation&lt;/code&gt; ， &lt;code&gt;UIKit&lt;/code&gt; 和 &lt;code&gt;posix&lt;/code&gt; 。这可以帮助您共享更多的本机代码，而不受特定于平台的依赖项的限制。</target>
        </trans-unit>
        <trans-unit id="91c32707acceb3a92d660aaa2664e3b3b359ee59" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;let&lt;/code&gt;, you can rewrite it:</source>
          <target state="translated">使用 &lt;code&gt;let&lt;/code&gt; ，您可以重写它：</target>
        </trans-unit>
        <trans-unit id="af688b954f4540e476c35b0f74f11c5204100c85" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lisa&lt;/code&gt; and &lt;code&gt;anne&lt;/code&gt; from the infix example, you can now do:</source>
          <target state="translated">使用infix示例中的 &lt;code&gt;lisa&lt;/code&gt; 和 &lt;code&gt;anne&lt;/code&gt; ，现在可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="32acfa5cff03b7f1ee491ea16213412942069586" translate="yes" xml:space="preserve">
          <source>With Gradle 6.0 and above, you are now able to load all scripts at once as opposed to the previous implementation where they were loaded individually. Since each request requires the Gradle configuration phase to be executed, this could be resource-intensive for large Gradle projects.</source>
          <target state="translated">在Gradle 6.0及以上版本中,你现在能够一次性加载所有的脚本,而不是像以前那样单独加载。由于每个请求都需要执行Gradle配置阶段,这对于大型Gradle项目来说可能是资源密集型的。</target>
        </trans-unit>
        <trans-unit id="c2bc622686f7933d6457fe256aa33e7162dce61a" translate="yes" xml:space="preserve">
          <source>With Gradle Kotlin DSL, configure source sets with &lt;code&gt;java.sourceSets { ... }&lt;/code&gt; instead.</source>
          <target state="translated">使用Gradle Kotlin DSL，改为使用 &lt;code&gt;java.sourceSets { ... }&lt;/code&gt; 配置源集。</target>
        </trans-unit>
        <trans-unit id="bf21fbd8ac94a33fdcdb64a0972b9b5c1c2c5132" translate="yes" xml:space="preserve">
          <source>With Gradle metadata enabled, an additional 'root' publication named &lt;code&gt;kotlinMultiplatform&lt;/code&gt; is added to the project's publications. The default artifact ID of this publication matches the project name without any additional suffix. To configure this publication, access it via the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL of the &lt;code&gt;maven-publish&lt;/code&gt; plugin:</source>
          <target state="translated">启用Gradle元数据后， &lt;code&gt;kotlinMultiplatform&lt;/code&gt; 名为kotlinMultiplatform的其他&amp;ldquo;根&amp;rdquo;出版物添加到项目的出版物中。该出版物的默认工件ID与项目名称匹配，没有任何其他后缀。要配置此发布，请通过 &lt;code&gt;maven-publish&lt;/code&gt; 插件的 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL 访问它：</target>
        </trans-unit>
        <trans-unit id="cfc45b937026fd4fbaf26509635a71da2f380172" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.3, it is possible to mark members of a &lt;code&gt;companion&lt;/code&gt; object of interfaces with annotations &lt;code&gt;@JvmStatic&lt;/code&gt; and &lt;code&gt;@JvmField&lt;/code&gt;. In the classfile, such members will be lifted to the corresponding interface and marked as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">使用Kotlin 1.3，可以使用注解 &lt;code&gt;@JvmStatic&lt;/code&gt; 和 &lt;code&gt;@JvmField&lt;/code&gt; 标记接口的 &lt;code&gt;companion&lt;/code&gt; 对象的成员。在类文件中，此类成员将被提升到相应的接口并标记为 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b65590d91561b1b8e789678b4dd06427d7909a3" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4 you can now add a trailing comma in enumerations such as argument and parameter lists, &lt;code&gt;when&lt;/code&gt; entries, and components of destructuring declarations. With a trailing comma, you can add new items and change their order without adding or removing commas.</source>
          <target state="translated">随着科特林1.4现在您可以在枚举如参数和参数列表，添加一个尾随逗号 &lt;code&gt;when&lt;/code&gt; 条目，解构声明的组成部分。使用逗号结尾时，您可以添加新项并更改其顺序，而无需添加或删除逗号。</target>
        </trans-unit>
        <trans-unit id="492f25a9a5171ae34e810e40b21b2cb1efcdaaeb" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4, you can use the new tools in IntelliJ IDEA to simplify Kotlin development:</source>
          <target state="translated">通过Kotlin 1.4,您可以使用IntelliJ IDEA中的新工具来简化Kotlin开发。</target>
        </trans-unit>
        <trans-unit id="0ed9b754f624185d343cb02b0b8d34dd9ae4ed13" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4.0, we are shipping the first stable version of &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;kotlinx.serialization&lt;/a&gt; - 1.0.0-RC. Now we are pleased to declare the JSON serialization API in &lt;code&gt;kotlinx-serialization-core&lt;/code&gt; (previously known as &lt;code&gt;kotlinx-serialization-runtime&lt;/code&gt;) stable. Libraries for other serialization formats remain experimental, along with some advanced parts of the core library.</source>
          <target state="translated">随着Kotlin 1.4.0的发布，我们将发布&lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;kotlinx.serialization&lt;/a&gt;的第一个稳定版本-1.0.0 -RC。现在，我们很高兴在 &lt;code&gt;kotlinx-serialization-core&lt;/code&gt; （以前称为 &lt;code&gt;kotlinx-serialization-runtime&lt;/code&gt; ）中声明JSON序列化API稳定。其他序列化格式的库以及核心库的某些高级部分仍处于试验阶段。</target>
        </trans-unit>
        <trans-unit id="5b6d7af5fe3aafc8094b8a2cfd86e6ef8192a99f" translate="yes" xml:space="preserve">
          <source>With Kotlin &lt;a href=&quot;../../reference/multiplatform&quot;&gt;multiplatform&lt;/a&gt; projects, it is possible to share the same Kotlin code between all the supported platforms. Check out the tutorial on &lt;a href=&quot;mpp-ios-android&quot;&gt;sharing Kotlin code between iOS and Android&lt;/a&gt; or have a look at how to build your own &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt;.</source>
          <target state="translated">使用Kotlin &lt;a href=&quot;../../reference/multiplatform&quot;&gt;多平台&lt;/a&gt;项目，可以在所有受支持的平台之间共享相同的Kotlin代码。查看有关&lt;a href=&quot;mpp-ios-android&quot;&gt;在iOS和Android之间共享Kotlin代码&lt;/a&gt;的教程，或者看看如何构建自己的&lt;a href=&quot;../multiplatform-library&quot;&gt;多平台库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63565c10375a2623a1558273ad959c355a70e5ce" translate="yes" xml:space="preserve">
          <source>With Kotlin Gradle DSL, the sections of predefined source sets should be marked &lt;code&gt;by getting&lt;/code&gt;.</source>
          <target state="translated">使用Kotlin Gradle DSL时，应 &lt;code&gt;by getting&lt;/code&gt; 标记预定义源集的各个部分。</target>
        </trans-unit>
        <trans-unit id="ec7fe3c48a3cadc6919466836bffd195ba2a63be" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform libraries, you can reuse the multiplatform logic in common and platform-specific code. Common code can rely on a set of libraries that cover everyday tasks such as &lt;a href=&quot;http://ktor.io/clients/http-client/multiplatform.html&quot;&gt;HTTP&lt;/a&gt;, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;serialization&lt;/a&gt;, and &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;managing coroutines&lt;/a&gt;.</source>
          <target state="translated">借助Kotlin Multiplatform库，您可以在通用代码和特定于平台的代码中重用多平台逻辑。通用代码可以依靠一组涵盖日常任务的库，例如&lt;a href=&quot;http://ktor.io/clients/http-client/multiplatform.html&quot;&gt;HTTP&lt;/a&gt;，&lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;序列化&lt;/a&gt;和&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;管理协程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f3221afc2f20039e82884001a629bfe8610d1ab" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, share the code using the mechanisms Kotlin provides:</source>
          <target state="translated">通过Kotlin多平台,使用Kotlin提供的机制共享代码。</target>
        </trans-unit>
        <trans-unit id="adbab2d42979bafe508a0df0d9f59300200f67c7" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, spend less time on writing and maintaining the same code for &lt;a href=&quot;mpp-supported-platforms&quot;&gt;different platforms&lt;/a&gt; &amp;ndash; just share it using the mechanisms Kotlin provides:</source>
          <target state="translated">借助Kotlin Multiplatform，您可以花更少的时间在&lt;a href=&quot;mpp-supported-platforms&quot;&gt;不同平台&lt;/a&gt;上编写和维护相同的代码-只需使用Kotlin提供的机制即可共享它：</target>
        </trans-unit>
        <trans-unit id="0e972123cd69ffcab96ad056c6c91d5aacf5be07" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, you can share the code using the mechanisms Kotlin provides:</source>
          <target state="translated">通过Kotlin多平台,你可以使用Kotlin提供的机制共享代码。</target>
        </trans-unit>
        <trans-unit id="3962fde44c4aec537b82dcd2abfc22db4cc626fa" translate="yes" xml:space="preserve">
          <source>With a value of 1, walker visits only the origin directory and all its immediate children, with a value of 2 also grandchildren, etc.</source>
          <target state="translated">值为1时,行者只访问原籍目录及其所有直系子弟,值为2时,还访问孙辈等。</target>
        </trans-unit>
        <trans-unit id="ef51393788d21d74c116e9c29eea336ed0a6d471" translate="yes" xml:space="preserve">
          <source>With callbacks, the idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.</source>
          <target state="translated">对于回调,我们的想法是将一个函数作为参数传递给另一个函数,一旦进程完成,这个函数就会被调用。</target>
        </trans-unit>
        <trans-unit id="016040b5eae4bf27f5a939a1b5c8156662185437" translate="yes" xml:space="preserve">
          <source>With collections and functions, polymorphism becomes more complicated - see the section on &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">使用集合和函数，多态会变得更加复杂-请参见有关&lt;a href=&quot;generics&quot;&gt;泛型&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="c1dcb9e12e7f211f30c8a5176d8ae68de49c58b9" translate="yes" xml:space="preserve">
          <source>With either version of the import, you can now simply do:</source>
          <target state="translated">无论是哪个版本的导入,你现在都可以简单地做到。</target>
        </trans-unit>
        <trans-unit id="fe95a6fd3800d1f0d89afcda519d105e6e6110b2" translate="yes" xml:space="preserve">
          <source>With function literals, local functions and object expression, functions can be nested in Kotlin. Qualified &lt;em&gt;return&lt;/em&gt;s allow us to return from an outer function. The most important use case is returning from a lambda expression. Recall that when we write this:</source>
          <target state="translated">使用函数文字，局部函数和对象表达式，可以将函数嵌套在Kotlin中。合格的&lt;em&gt;return&lt;/em&gt;允许我们从外部函数返回。最重要的用例是从lambda表达式返回。回想一下，当我们编写此代码时：</target>
        </trans-unit>
        <trans-unit id="eb6ed75ff29820dbdcda23941139d4c1d4ba7dd2" translate="yes" xml:space="preserve">
          <source>With named arguments we can make the code much more readable:</source>
          <target state="translated">通过命名参数,我们可以使代码更易读。</target>
        </trans-unit>
        <trans-unit id="3450c7c71d6bf1ddf49a4323aca70311d456d430" translate="yes" xml:space="preserve">
          <source>With that, our project should now build and produce the corresponding artifacts.</source>
          <target state="translated">有了这些,我们的项目现在应该构建并产生相应的工件。</target>
        </trans-unit>
        <trans-unit id="355ad4d87e7870b0c272b188aa3ef65d4dc920f9" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt;, available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, you can learn Kotlin through code practicing tasks.</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt;和&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA中&lt;/a&gt;都可用的&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools插件&lt;/a&gt;，您可以通过代码练习任务来学习Kotlin。</target>
        </trans-unit>
        <trans-unit id="36b14af153f14d3f9734df37394a46678fa4ba5c" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt;, available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, you can teach Kotlin through code practicing tasks. Take a look at the &lt;a href=&quot;https://www.jetbrains.com/help/education/educator-start-guide.html?section=Kotlin&quot;&gt;Educator Start Guide&lt;/a&gt; to learn how to create a simple Kotlin course that includes a set of programming tasks and integrated tests.</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt;和&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA中&lt;/a&gt;都可用的&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools插件&lt;/a&gt;，您可以通过代码练习任务来教Kotlin。请参阅《&lt;a href=&quot;https://www.jetbrains.com/help/education/educator-start-guide.html?section=Kotlin&quot;&gt;教育者入门指南》，&lt;/a&gt;以学习如何创建简单的Kotlin课程，其中包括一组编程任务和集成测试。</target>
        </trans-unit>
        <trans-unit id="f5382fb55641e05a034b3ea5d0c0d4be768aee31" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PropertyDelegateProvider&lt;/code&gt; interface from the standard library, you can create delegate providers without creating new classes.</source>
          <target state="translated">使用标准库中的 &lt;code&gt;PropertyDelegateProvider&lt;/code&gt; 接口，您可以创建委托提供程序而无需创建新类。</target>
        </trans-unit>
        <trans-unit id="dadda346a2629bde84d619a153f6df49f573d66b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;cancellable&lt;/code&gt; operator only the numbers from 1 to 3 are collected:</source>
          <target state="translated">使用 &lt;code&gt;cancellable&lt;/code&gt; 运算符，仅收集从1到3的数字：</target>
        </trans-unit>
        <trans-unit id="7f45b301e2a74f1dd5893d4a531ceba47efa69ee" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin &lt;strong&gt;source&lt;/strong&gt;&lt;strong&gt;sets&lt;/strong&gt; are also used to group sources but source files for different platforms are located in different source sets. For each declared target two source sets are created: &lt;code&gt;&amp;lt;target-name&amp;gt;Main&lt;/code&gt; and &lt;code&gt;&amp;lt;target-name&amp;gt;Test&lt;/code&gt; containing product and test sources for this platform. Common for all platforms sources are located in &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; source sets created by default. More information about source sets can be found &lt;a href=&quot;../building-mpp-with-gradle#configuring-source-sets&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件时，&lt;strong&gt;源&lt;/strong&gt;&lt;strong&gt;集&lt;/strong&gt;也用于对源进行分组，但是不同平台的源文件位于不同的源集中。对于每个声明的目标，将创建两个源集： &lt;code&gt;&amp;lt;target-name&amp;gt;Main&lt;/code&gt; 和 &lt;code&gt;&amp;lt;target-name&amp;gt;Test&lt;/code&gt; ,其中包含此平台的产品和测试源。所有平台的通用源均位于默认创建的 &lt;code&gt;commonMain&lt;/code&gt; 和 &lt;code&gt;commonTest&lt;/code&gt; 源集中。有关源集的更多信息，请参见&lt;a href=&quot;../building-mpp-with-gradle#configuring-source-sets&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5d94234e74f15ed4145669bdb5e37f9dfb14ae3" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin a compilation always produces a &lt;code&gt;*.klib&lt;/code&gt; file. A separate &lt;code&gt;binaries&lt;/code&gt; block is used to configure what final native binaries should be produced by each target. Each binary can be configured independently including linker options, executable entry point etc.</source>
          <target state="translated">使用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件，编译始终会生成 &lt;code&gt;*.klib&lt;/code&gt; 文件。一个单独的 &lt;code&gt;binaries&lt;/code&gt; 块用于配置每个目标应生成哪些最终本机二进制文件。每个二进制文件都可以独立配置，包括链接器选项，可执行入口点等。</target>
        </trans-unit>
        <trans-unit id="c6cb3a91147cfe093062a0839b721e658dabc4bd" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin interops are configured as a part of a compilation (see details &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;here&lt;/a&gt;). The rest of an interop configuration is the same as for the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin.</source>
          <target state="translated">使用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件，互操作被配置为编译的一部分（请参阅&lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;此处的&lt;/a&gt;详细信息）。互操作配置的其余部分与 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 插件相同。</target>
        </trans-unit>
        <trans-unit id="1706d3b6b7ce15bdbf71dc7c9e04a857f530061f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin target platforms can be added into a project using special methods available in the &lt;code&gt;kotlin&lt;/code&gt; extension. Each method adds into a project one &lt;strong&gt;target&lt;/strong&gt; which can be accessed using the &lt;code&gt;targets&lt;/code&gt; property. Each target can be configured independently including output kinds, additional compiler options etc. See details about targets at the &lt;a href=&quot;../building-mpp-with-gradle#setting-up-targets&quot;&gt;corresponding page&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 插件，可以使用 &lt;code&gt;kotlin&lt;/code&gt; 扩展中提供的特殊方法将目标平台添加到项目中。每种方法都将一个&lt;strong&gt;目标&lt;/strong&gt;添加到项目中，可以使用 &lt;code&gt;targets&lt;/code&gt; 属性对其进行访问。可以独立配置每个目标，包括输出种类，其他编译器选项等。有关目标的详细信息，请参见&lt;a href=&quot;../building-mpp-with-gradle#setting-up-targets&quot;&gt;相应页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71022b4d02eeeda0e92ce39399dff9342c3334b7" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin a set of target platforms is specified as a list in properties of the main component:</source>
          <target state="translated">使用 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 插件，可以在主要组件的属性中将一组目标平台指定为列表：</target>
        </trans-unit>
        <trans-unit id="6a03f6034b00496a7bad530da3196155a72cc860" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin dependencies are configured in a traditional for Gradle way by grouping them into configurations using the project &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">使用 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 插件，可以通过使用项目 &lt;code&gt;dependencies&lt;/code&gt; 块将它们分组为配置，从而以传统的Gradle方式配置依赖项：</target>
        </trans-unit>
        <trans-unit id="e33e92feed8df1d895d9a97b45aacf36671d526c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin interop with a native library can be declared in component dependencies:</source>
          <target state="translated">使用 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 插件，可以在组件依赖项中声明与本机库的互操作：</target>
        </trans-unit>
        <trans-unit id="a97bf25e776050662c47b29cee8cd98d22ea2c1d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin output kinds are specified as a list in properties of a component:</source>
          <target state="translated">使用 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 插件时，输出类型被指定为组件属性中的列表：</target>
        </trans-unit>
        <trans-unit id="32e186967f7559f8d4cf421fcfd2faf96d838898" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin source sets are used to separate test and product sources. Also you can specify different sources for different platforms in the same source set:</source>
          <target state="translated">借助 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 插件，源集用于分离测试和产品源。您也可以在同一源集中为不同平台指定不同的源：</target>
        </trans-unit>
        <trans-unit id="7fa674450fbd80d59d43844df0d5a16d3f6b263d" translate="yes" xml:space="preserve">
          <source>With the coroutine debugger, you can:</source>
          <target state="translated">通过coroutine调试器,你可以。</target>
        </trans-unit>
        <trans-unit id="29b0fbf80a9fbc5a69ad66b25c87ece38e49f33b" translate="yes" xml:space="preserve">
          <source>With the flexible new Kotlin Project Wizard, you have a place to easily create and configure different types of Kotlin projects, including multiplatform projects, which can be difficult to configure without a UI.</source>
          <target state="translated">通过灵活的新Kotlin项目向导,你可以在这里轻松地创建和配置不同类型的Kotlin项目,包括多平台项目,如果没有UI,很难配置。</target>
        </trans-unit>
        <trans-unit id="a5c6c878f4a74b6cd56b16a6f707da3f34b03dce" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following declarations for our C functions:</source>
          <target state="translated">借助IntelliJ IDEA的&lt;em&gt;Goto声明&lt;/em&gt;或编译器错误，我们为C函数看到了以下声明：</target>
        </trans-unit>
        <trans-unit id="cf252d7abb4fe418f54b8621d262b977ba904b60" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following generated API for our C functions, &lt;code&gt;struct&lt;/code&gt;, and &lt;code&gt;union&lt;/code&gt;:</source>
          <target state="translated">借助IntelliJ IDEA的&lt;em&gt;Goto声明&lt;/em&gt;或编译器错误，我们看到了为C函数 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 生成的以下API ：</target>
        </trans-unit>
        <trans-unit id="874119f71c620e91c1bb9c2e75fd174caab63b63" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following generated API for our C functions:</source>
          <target state="translated">借助IntelliJ IDEA的&lt;em&gt;Goto声明&lt;/em&gt;或编译器错误，我们看到了为C函数生成的以下API：</target>
        </trans-unit>
        <trans-unit id="566c1425784d4c2e6ede1f7dfe672ee70373f129" translate="yes" xml:space="preserve">
          <source>With the new &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;&lt;code&gt;@JsExport&lt;/code&gt;&lt;/a&gt; annotation and the ability to &lt;strong&gt;&lt;a href=&quot;js-ir-compiler#preview-generation-of-typescript-declaration-files-dts&quot;&gt;generate TypeScript definitions&lt;/a&gt; from Kotlin code&lt;/strong&gt;, the Kotlin/JS IR compiler backend improves JavaScript &amp;amp; TypeScript interoperability. This also makes it easier to integrate Kotlin/JS code with existing tooling, to create &lt;strong&gt;hybrid applications&lt;/strong&gt; and leverage code-sharing functionality in multiplatform projects.</source>
          <target state="translated">借助新的&lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt; &lt;code&gt;@JsExport&lt;/code&gt; &lt;/a&gt;批注以及&lt;strong&gt;从Kotlin代码&lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;js-ir-compiler#preview-generation-of-typescript-declaration-files-dts&quot;&gt;生成TypeScript定义的功能&lt;/a&gt;&lt;/strong&gt;，Kotlin / JS IR编译器后端改善了JavaScript和TypeScript的互操作性。这也使得将Kotlin / JS代码与现有工具集成在一起，创建&lt;strong&gt;混合应用程序&lt;/strong&gt;以及在多平台项目中利用代码共享功能变得更加容易。</target>
        </trans-unit>
        <trans-unit id="5bc753b11e4bb4891a70a654bb57daca9017fc7f" translate="yes" xml:space="preserve">
          <source>With the new hierarchical project structure support, you can share code among &lt;a href=&quot;mpp-supported-platforms&quot;&gt;several platforms&lt;/a&gt; in a &lt;a href=&quot;mpp-discover-project&quot;&gt;multiplatform project&lt;/a&gt;.</source>
          <target state="translated">借助新的分层项目结构支持，您可以在一个&lt;a href=&quot;mpp-discover-project&quot;&gt;多平台项目&lt;/a&gt;中的&lt;a href=&quot;mpp-supported-platforms&quot;&gt;多个平台&lt;/a&gt;之间共享代码。</target>
        </trans-unit>
        <trans-unit id="574c1c740a16fa65a0f397005ee3b1c60f44325d" translate="yes" xml:space="preserve">
          <source>With these features, you can make your Gradle build file much more concise and easy to read:</source>
          <target state="translated">有了这些功能,你可以让你的Gradle构建文件更加简洁易读。</target>
        </trans-unit>
        <trans-unit id="55c0b9fe68cd1e4b20ebebcee0ed1689356c0a07" translate="yes" xml:space="preserve">
          <source>With these helpers, the part of code for reading input becomes simpler, closely following the input specification in the problem statement line by line:</source>
          <target state="translated">有了这些助手,读取输入的部分代码就变得简单了,紧紧地按照问题语句中的输入规范一行一行地编写。</target>
        </trans-unit>
        <trans-unit id="a228c17a745863a462bf780050c335cd1bf004e4" translate="yes" xml:space="preserve">
          <source>With these two interfaces, we can make a more versatile fruit bowl. The bowl itself needs to both produce and consume its generic type, so it can neither be covariant nor contravariant, but it can implement our covariant and contravariant interfaces:</source>
          <target state="translated">有了这两个接口,我们就可以做出一个更通用的果碗。果碗本身既要生产也要消耗它的通用类型,所以它既不能是共变的,也不能是反变的,但是它可以实现我们的共变和反变接口。</target>
        </trans-unit>
        <trans-unit id="4a7d204c839bbeda2e10e199023fa5b9c64dcb76" translate="yes" xml:space="preserve">
          <source>With this external declaration, you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments, where the default values are calculated by the JavaScript implementation of &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt;.</source>
          <target state="translated">使用此外部声明，您可以调用带有一个必需参数和两个可选参数的 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; ，其中默认值由 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; 的JavaScript实现计算得出。</target>
        </trans-unit>
        <trans-unit id="72d67501a892da363116927ae13a84e4aecbce70" translate="yes" xml:space="preserve">
          <source>With this mechanism, a common source set defines an &lt;em&gt;expected declaration&lt;/em&gt;, and platform source sets must provide the &lt;em&gt;actual declaration&lt;/em&gt; that corresponds to the expected declaration. This works for most Kotlin declarations, such as functions, classes, interfaces, enumerations, properties, and annotations.</source>
          <target state="translated">通过这种机制，公共源集定义了&lt;em&gt;期望的声明&lt;/em&gt;，并且平台源集必须提供与期望的声明相对应的&lt;em&gt;实际&lt;/em&gt;声明。这适用于大多数Kotlin声明，例如函数，类，接口，枚举，属性和注释。</target>
        </trans-unit>
        <trans-unit id="717e11f293d4b13a9a59d035d72d380a87efce32" translate="yes" xml:space="preserve">
          <source>With this setup, we can access elements of our DOM. To access the properties of the &lt;code&gt;input&lt;/code&gt; field, we invoke &lt;code&gt;getElementById&lt;/code&gt; and cast it to &lt;code&gt;HTMLInputElement&lt;/code&gt;. We can then safely access its properties, such as &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="translated">通过此设置，我们可以访问DOM的元素。要访问 &lt;code&gt;input&lt;/code&gt; 字段的属性，我们调用 &lt;code&gt;getElementById&lt;/code&gt; 并将其 &lt;code&gt;HTMLInputElement&lt;/code&gt; 为HTMLInputElement。然后，我们可以安全地访问其属性，例如 &lt;code&gt;value&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="41b77f41d3f8979c93fc79a64e556733e4160ef4" translate="yes" xml:space="preserve">
          <source>With this setup, we can recompile our project after each code change to see our changes. Kotlin/JS also supports a more convenient way of automatically rebuilding our application while we are developing it. To find out how to set up this &lt;em&gt;continuous mode&lt;/em&gt;, check out the &lt;a href=&quot;dev-server-continuous-compilation&quot;&gt;corresponding tutorial&lt;/a&gt;.</source>
          <target state="translated">通过此设置，我们可以在每次代码更改后重新编译我们的项目，以查看我们的更改。Kotlin / JS还支持在开发过程中自动重建应用程序的更便捷方法。要了解如何设置此&lt;em&gt;连续模式&lt;/em&gt;，请查看&lt;a href=&quot;dev-server-continuous-compilation&quot;&gt;相应的教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9928576b159a395a58ce4f2d7b6c66f40874468" translate="yes" xml:space="preserve">
          <source>With this, we can then access any of the functionality defined inside &lt;code&gt;customerBL&lt;/code&gt;.</source>
          <target state="translated">这样，我们便可以访问 &lt;code&gt;customerBL&lt;/code&gt; 内部定义的任何功能。</target>
        </trans-unit>
        <trans-unit id="8dacc9ec11c6c308f4e37da6d574002e02a0ff3a" translate="yes" xml:space="preserve">
          <source>Without the curly braces, only the first line is a part of the body. Indentation in Kotlin matters only for human readers, so the second print is outside the if and will always be executed.</source>
          <target state="translated">没有大括号,只有第一行是正文的一部分。Kotlin中的缩进只对人类读者重要,所以第二行打印在if之外,并且会一直执行。</target>
        </trans-unit>
        <trans-unit id="d2ecf10500acdd56e5aa15cdc3d632f4d1b83484" translate="yes" xml:space="preserve">
          <source>Without this ability to intercept the binding between the property and its delegate, to achieve the same functionality you'd have to pass the property name explicitly, which isn't very convenient:</source>
          <target state="translated">如果没有这个能力来截取属性和它的委托人之间的绑定,要实现同样的功能,你就必须显式传递属性名,这不是很方便。</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="b539d8a8b3ce433f937b71658160ff7e5f64cd4c" translate="yes" xml:space="preserve">
          <source>Worker that &lt;a href=&quot;value&quot;&gt;value&lt;/a&gt; is bound to.</source>
          <target state="translated">&lt;a href=&quot;value&quot;&gt;值&lt;/a&gt;绑定到的工作者。</target>
        </trans-unit>
        <trans-unit id="a502b8bb9786901c6dc61e82d98c92b4b73ae927" translate="yes" xml:space="preserve">
          <source>WorkerBoundReference</source>
          <target state="translated">WorkerBoundReference</target>
        </trans-unit>
        <trans-unit id="74a0d635bad8cb921832f022e80f37a47e5b135d" translate="yes" xml:space="preserve">
          <source>WorkerLocation</source>
          <target state="translated">WorkerLocation</target>
        </trans-unit>
        <trans-unit id="315e6d0000af41369aa07e54a100988d3fd17dee" translate="yes" xml:space="preserve">
          <source>WorkerNavigator</source>
          <target state="translated">WorkerNavigator</target>
        </trans-unit>
        <trans-unit id="2c80abf6e395bd6f326cb30a261f19ee445cba02" translate="yes" xml:space="preserve">
          <source>WorkerOptions</source>
          <target state="translated">WorkerOptions</target>
        </trans-unit>
        <trans-unit id="87bb291b389446f9344ad088d8d62a7a62a19eca" translate="yes" xml:space="preserve">
          <source>WorkerType</source>
          <target state="translated">WorkerType</target>
        </trans-unit>
        <trans-unit id="b6ef3acd0f91c0c6e2a6bad2692c8aa84dfc4c73" translate="yes" xml:space="preserve">
          <source>Workers</source>
          <target state="translated">Workers</target>
        </trans-unit>
        <trans-unit id="4854bbfffb40975ef729e9def93b58f75765479a" translate="yes" xml:space="preserve">
          <source>Workers with message passing</source>
          <target state="translated">有信息传递的工人</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="7323cd213254c74db3a887f36bfadb481e7d4c0e" translate="yes" xml:space="preserve">
          <source>Working on all platforms is an explicit goal for Kotlin, but we see it as a premise to a much more important goal: sharing code between platforms. With support for JVM, Android, JavaScript, iOS, Linux, Windows, Mac and even embedded systems like STM32, Kotlin can handle any and all components of a modern application. And this brings the invaluable benefit of reuse for code and expertise, saving the effort for tasks more challenging than implementing everything twice or multiple times.</source>
          <target state="translated">在所有平台上工作是Kotlin的一个明确目标,但我们认为这是实现一个更重要目标的前提:平台之间共享代码。由于支持JVM、Android、JavaScript、iOS、Linux、Windows、Mac甚至是STM32等嵌入式系统,Kotlin可以处理现代应用程序的任何和所有组件。而这带来了代码和专业技术重用的宝贵好处,省去了比两次或多次实现所有东西更具挑战性的任务。</target>
        </trans-unit>
        <trans-unit id="f538870f3ed8ccb71b1f28d4023b06274de86076" translate="yes" xml:space="preserve">
          <source>Working with Build Tools</source>
          <target state="translated">使用构建工具</target>
        </trans-unit>
        <trans-unit id="4c5d22ef62b4e454bd0bf1e1374aa13390ad7ed1" translate="yes" xml:space="preserve">
          <source>Working with C strings</source>
          <target state="translated">使用C弦</target>
        </trans-unit>
        <trans-unit id="9ac89fee8e06569c4ebc756f83cddf2bbd9a8ca8" translate="yes" xml:space="preserve">
          <source>Working with Enum Constants</source>
          <target state="translated">使用Enum常量</target>
        </trans-unit>
        <trans-unit id="1f8482b2bf142fad82a2f635e71a135183f56a5d" translate="yes" xml:space="preserve">
          <source>Working with JavaScript</source>
          <target state="translated">使用JavaScript</target>
        </trans-unit>
        <trans-unit id="8fc3285c1f9933f649e39499a1f3946c5619cf72" translate="yes" xml:space="preserve">
          <source>Working with Kotlin and JavaScript Modules</source>
          <target state="translated">使用Kotlin和JavaScript模块</target>
        </trans-unit>
        <trans-unit id="9a49aac8293420ff01c5e9c031ff773d05799074" translate="yes" xml:space="preserve">
          <source>Working with nulls</source>
          <target state="translated">处理空值</target>
        </trans-unit>
        <trans-unit id="e5c0c5bddfae833279acedcc9a537af19daf0f06" translate="yes" xml:space="preserve">
          <source>Working with tasks</source>
          <target state="translated">工作任务</target>
        </trans-unit>
        <trans-unit id="7d46e00971b365b4ef3386294882d7496a7f75ed" translate="yes" xml:space="preserve">
          <source>Working with the Command Line Compiler</source>
          <target state="translated">使用命令行编译器</target>
        </trans-unit>
        <trans-unit id="f2a7db7b02d37c7f54b499213bb3a991f17a1744" translate="yes" xml:space="preserve">
          <source>Working with the strings</source>
          <target state="translated">弦的工作</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
