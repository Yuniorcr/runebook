<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="0758911fe007939762ea0a98ab73ee500552cb01" translate="yes" xml:space="preserve">
          <source>The parameter may be a number (as shown in the example above) dictating the size of each chunk. Alternatively, &lt;code&gt;byChunk&lt;/code&gt; accepts a user-provided buffer that it uses directly.</source>
          <target state="translated">该参数可以是指示每个块大小的数字（如上例所示）。或者， &lt;code&gt;byChunk&lt;/code&gt; 接受它直接使用的用户提供的缓冲区。</target>
        </trans-unit>
        <trans-unit id="c903948dffd2abfd68770b5195aac5d542b83003" translate="yes" xml:space="preserve">
          <source>The parameters of this distribution. The random number is x = (x * multipler + increment) % modulus.</source>
          <target state="translated">这个分布的参数。随机数为x=(x*倍数+增量)%模数。</target>
        </trans-unit>
        <trans-unit id="2c7bb35e4246e498ccd1516d5c0a045c041414c6" translate="yes" xml:space="preserve">
          <source>The parameters to the non-variadic function:</source>
          <target state="translated">非变量函数的参数。</target>
        </trans-unit>
        <trans-unit id="8c00f330278c8a3688d755f58c6ef387d6c281e7" translate="yes" xml:space="preserve">
          <source>The parameters to the variadic function:</source>
          <target state="translated">变量函数的参数。</target>
        </trans-unit>
        <trans-unit id="5ebad486f6049114c19bd433cacf524aaf10fabc" translate="yes" xml:space="preserve">
          <source>The parameters with which to instantiate the template.</source>
          <target state="translated">用于实例化模板的参数。</target>
        </trans-unit>
        <trans-unit id="4fbe12ec5cf422714865a37fd1864dec27719969" translate="yes" xml:space="preserve">
          <source>The parent allocator is publicly accessible either as a direct member if it holds state, or as an alias to &lt;code&gt;Allocator.instance&lt;/code&gt; otherwise. One may use it for making calls that won't count toward statistics collection.</source>
          <target state="translated">父分配器可以公开访问（如果它持有状态），可以是直接成员，否则可以是 &lt;code&gt;Allocator.instance&lt;/code&gt; 的别名。可能有人会用它来拨打不计入统计信息的呼叫。</target>
        </trans-unit>
        <trans-unit id="a7916e9fe1cbcecc9e5b2265b50cee59f409bc09" translate="yes" xml:space="preserve">
          <source>The parent allocator. Depending on whether &lt;code&gt;ParentAllocator&lt;/code&gt; holds state or not, this is a member variable or an alias for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">父分配器。根据 &lt;code&gt;ParentAllocator&lt;/code&gt; 是否保持状态，这是 &lt;code&gt;ParentAllocator.instance&lt;/code&gt; 的成员变量或别名。</target>
        </trans-unit>
        <trans-unit id="6a766f10bdfc11306f72dafd5b728bd7317c675f" translate="yes" xml:space="preserve">
          <source>The parser initially sets it to TOK.concatenateAssign, and semantic() later decides which of the three it will be set to.</source>
          <target state="translated">解析器最初将其设置为TOK.concatenateAssign,之后由semantic()决定将其设置为三者中的哪一个。</target>
        </trans-unit>
        <trans-unit id="8ca59cb5bd26311e5307aeb5f44c313335ea3580" translate="yes" xml:space="preserve">
          <source>The passed in input was correct, but more input was expected.</source>
          <target state="translated">传入的输入是正确的,但预计会有更多的输入。</target>
        </trans-unit>
        <trans-unit id="04a94fe6ab7793bd68edc946edd3c4d4f906c623" translate="yes" xml:space="preserve">
          <source>The passed text will be printed first, followed by a newline, then the short and long version of every option will be printed. The short and long version will be aligned to the longest option of every &lt;code&gt;Option&lt;/code&gt; passed. If the option is required, then &quot;Required:&quot; will be printed after the long version of the &lt;code&gt;Option&lt;/code&gt;. If a help message is present it will be printed next. The format is illustrated by this code:</source>
          <target state="translated">传递的文本将首先打印，然后换行，然后将打印每个选项的简短版本和详细版本。短版本和长版本将与传递的每个 &lt;code&gt;Option&lt;/code&gt; 的最长选项对齐。如果该选项是必需的，则在该 &lt;code&gt;Option&lt;/code&gt; 的长版本之后将显示&amp;ldquo; Required：&amp;rdquo; 。如果出现帮助消息，则将其下打印。格式由以下代码说明：</target>
        </trans-unit>
        <trans-unit id="ae0176808c4338a2b32bdc055054955a47109b3c" translate="yes" xml:space="preserve">
          <source>The path given by &lt;code&gt;path&lt;/code&gt;, with the extension given by &lt;code&gt;ext&lt;/code&gt; appended if the path doesn't already have one.  Including the dot in the extension is optional.  This function always allocates a new string, except in the case when path is immutable and already has an extension.</source>
          <target state="translated">path指定的 &lt;code&gt;path&lt;/code&gt; ，如果路径还没有扩展名，则附加 &lt;code&gt;ext&lt;/code&gt; 扩展名。在扩展名中包括点是可选的。该函数总是分配一个新的字符串，除非path是不可变的并且已经具有扩展名。</target>
        </trans-unit>
        <trans-unit id="9978fd2b7b1c58a32b59d2d933a84ff2eeb9cad1" translate="yes" xml:space="preserve">
          <source>The path name to expand.</source>
          <target state="translated">要展开的路径名称。</target>
        </trans-unit>
        <trans-unit id="dba74006c9911dd825361c79175c3816c02f4fd6" translate="yes" xml:space="preserve">
          <source>The path of the executable as a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">可执行文件的路径，以 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c35dcd32a0cd2b956596caddc202c46a4ae3354" translate="yes" xml:space="preserve">
          <source>The path to be matched against</source>
          <target state="translated">要匹配的路径</target>
        </trans-unit>
        <trans-unit id="a5d7f6c37fe93af27b88af304f713208b3e7e43a" translate="yes" xml:space="preserve">
          <source>The path to the file.</source>
          <target state="translated">文件的路径。</target>
        </trans-unit>
        <trans-unit id="b9caa4476a8447e566c7b52e6155891828512bf8" translate="yes" xml:space="preserve">
          <source>The path to the shell to use to run the specified program. By default this is &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于运行指定程序的外壳程序的路径。默认情况下是&lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a791a6dee2401c3ac563dc595efe14cc5ee858e9" translate="yes" xml:space="preserve">
          <source>The permutation to permutate &lt;code&gt;range&lt;/code&gt; to.</source>
          <target state="translated">排列到排列 &lt;code&gt;range&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bf6df59e4efc6178ad86ce4d172dd74e35f57bc" translate="yes" xml:space="preserve">
          <source>The permuted range.</source>
          <target state="translated">琢磨的范围。</target>
        </trans-unit>
        <trans-unit id="b51b8abc388ed1faa0574f36244673bca9d03127" translate="yes" xml:space="preserve">
          <source>The pivot element.</source>
          <target state="translated">枢轴元件。</target>
        </trans-unit>
        <trans-unit id="2141dbd9249b3127ee2311abb3285ea6f62646d8" translate="yes" xml:space="preserve">
          <source>The plan is to support all of the above except throwing D exceptions directly in C++ code (but they will be throwable indirectly by calling into a D function with C++ linkage).</source>
          <target state="translated">计划是除了在C++代码中直接抛出D异常外,其他的都支持(但会通过调用C++链接的D函数间接抛出)。</target>
        </trans-unit>
        <trans-unit id="5e9fcc91fd47a551fe2c3ec3018788e0626a6afc" translate="yes" xml:space="preserve">
          <source>The platform-specific native shell path.</source>
          <target state="translated">平台特有的本地shell路径。</target>
        </trans-unit>
        <trans-unit id="c744ae6de5a0c2342c1ec26c71bf9d84af5482c5" translate="yes" xml:space="preserve">
          <source>The point is to allow AliasDeclarationY to use &lt;code&gt;__traits()&lt;/code&gt;, see issue 7804.</source>
          <target state="translated">关键是允许AliasDeclarationY使用 &lt;code&gt;__traits()&lt;/code&gt; ，请参见问题7804。</target>
        </trans-unit>
        <trans-unit id="0b4bb95d6a8d2b3e99a53954eaab5d58c7eb10b4" translate="yes" xml:space="preserve">
          <source>The pointer</source>
          <target state="translated">指针</target>
        </trans-unit>
        <trans-unit id="fd5b5206507758892b71f3f58e5e23e1c1f7f65c" translate="yes" xml:space="preserve">
          <source>The pointer, dynamic array, or reference is set to &lt;code&gt;null&lt;/code&gt; after the delete is performed. Any attempt to reference the data after the deletion via another reference to it will result in undefined behavior.</source>
          <target state="translated">执行删除后，指针，动态数组或引用将设置为 &lt;code&gt;null&lt;/code&gt; 。删除后通过其他引用来引用数据的任何尝试都会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="594f71d424c88492080e5062a3ecf8853308a43e" translate="yes" xml:space="preserve">
          <source>The pointer-based version returns a &lt;code&gt;SortedRange&lt;/code&gt; wrapper over index, of type &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; thus reflecting the ordering of the index. The index-based version returns &lt;code&gt;void&lt;/code&gt; because the ordering relation involves not only &lt;code&gt;index&lt;/code&gt; but also &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">基于指针的版本将返回 &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; 类型的索引上的 &lt;code&gt;SortedRange&lt;/code&gt; 包装器，从而反映了索引的顺序。基于索引的版本返回 &lt;code&gt;void&lt;/code&gt; ,因为排序关系不仅涉及 &lt;code&gt;index&lt;/code&gt; 而且涉及 &lt;code&gt;r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c0b6520bd81ff00673e639fb3748bb290589c44" translate="yes" xml:space="preserve">
          <source>The policy to use.</source>
          <target state="translated">用的政策。</target>
        </trans-unit>
        <trans-unit id="5bfa0d8b059a39ab26c6f284f964719eecf94f69" translate="yes" xml:space="preserve">
          <source>The policy used by this mutex.</source>
          <target state="translated">该mutex使用的策略。</target>
        </trans-unit>
        <trans-unit id="8629893a44c9c276074edd00bae067e6b519cbda" translate="yes" xml:space="preserve">
          <source>The position in &lt;code&gt;array&lt;/code&gt; to insert the &lt;code&gt;stuff&lt;/code&gt;.</source>
          <target state="translated">中的位置 &lt;code&gt;array&lt;/code&gt; 插入 &lt;code&gt;stuff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9eb86610993ddd6856217e1e6d70c91e6f75dbc" translate="yes" xml:space="preserve">
          <source>The position in the input string where the error occurred.</source>
          <target state="translated">输入字符串中发生错误的位置。</target>
        </trans-unit>
        <trans-unit id="f421096d1588c50f7ea09d98220627162688c28b" translate="yes" xml:space="preserve">
          <source>The position of the minimum (respectively maximum) element of forward range &lt;code&gt;range&lt;/code&gt;, i.e. a subrange of &lt;code&gt;range&lt;/code&gt; starting at the position of its smallest (respectively largest) element and with the same ending as &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">向前范围 &lt;code&gt;range&lt;/code&gt; 的最小（分别为最大）元素的位置，即范围的子 &lt;code&gt;range&lt;/code&gt; ，从其最小（分别为最大）元素的位置开始，并以 &lt;code&gt;range&lt;/code&gt; 相同的结尾。</target>
        </trans-unit>
        <trans-unit id="51fc654e8d5c11108a73d4836e9e77c133dfb257" translate="yes" xml:space="preserve">
          <source>The possible states of the &lt;code&gt;Ternary&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ternary&lt;/code&gt; 的可能状态</target>
        </trans-unit>
        <trans-unit id="76c6cabbb86643a051bf73c292aa98533c672138" translate="yes" xml:space="preserve">
          <source>The possible targets are computed more conservatively than the language allows, eliminating all dangerous conversions. For example, &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; does not include &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">可能的目标计算比语言所允许的保守得多，从而消除了所有危险的转换。例如， &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; 不包含 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11d29604df18454624b74cfa89078e0417260306" translate="yes" xml:space="preserve">
          <source>The possible values for units are &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, (microseconds), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds, i.e. 100 ns), and &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">单位的可能值为 &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; ， &lt;code&gt;&quot;days&quot;&lt;/code&gt; ， &lt;code&gt;&quot;hours&quot;&lt;/code&gt; ， &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; ， &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; ， &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; 毫秒&amp;rdquo;（毫秒）， &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; ，（微秒）， &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; （百纳秒，即100 ns）和 &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c4f82ffde3ae1f423f2307932836a1e645ef668" translate="yes" xml:space="preserve">
          <source>The postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; and &lt;code&gt;__aggrPostblit&lt;/code&gt; are generated without any implicit qualifiers and are not considered struct members. This leads to the situation where qualifying an entire struct declaration with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; does not have any impact on the above-mentioned postblits. However, since &lt;code&gt;__xpostblit&lt;/code&gt; is a member of the struct and an alias of one of the other postblits, the qualifiers applied to the struct will affect the aliased postblit.</source>
          <target state="translated">Postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; 和 &lt;code&gt;__aggrPostblit&lt;/code&gt; 是在没有任何隐式限定符的情况下生成的，不被视为结构成员。这导致这样的情况：用 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;immutable&lt;/code&gt; 对整个struct声明进行限定不会对上述postblit产生任何影响。但是，由于 &lt;code&gt;__xpostblit&lt;/code&gt; 是该结构的成员，并且是其他postblits的别名，因此应用于该结构的限定符将影响该别名的postblit。</target>
        </trans-unit>
        <trans-unit id="d47161252adc52b1f430344a53bb4997710446f2" translate="yes" xml:space="preserve">
          <source>The power modulus value of (base ^ exponent) % modulus.</source>
          <target state="translated">(基^指数)%模数的功率模数值。</target>
        </trans-unit>
        <trans-unit id="309c3d73f76b800f2ba5fd6059ce5bcf824a5c98" translate="yes" xml:space="preserve">
          <source>The pre contracts specify the preconditions before a statement is executed. The most typical use of this would be in validating the parameters to a function. The post contracts validate the result of the statement. The most typical use of this would be in validating the return value of a function and of any side effects it has. In D, pre contracts begin with &lt;code&gt;in&lt;/code&gt;, and post contracts begin with &lt;code&gt;out&lt;/code&gt;. They come at the end of the function signature and before the opening brace of the function body.</source>
          <target state="translated">预合同规定了执行语句之前的先决条件。最典型的用途是验证函数的参数。后期合同验证了报表的结果。这种方法最典型的用途是验证函数的返回值以及它具有的任何副作用。在D中，预合同以 &lt;code&gt;in&lt;/code&gt; 开头，后合同以 &lt;code&gt;out&lt;/code&gt; 开头。它们出现在功能签名的末尾，在功能主体的开口撑杆之前。</target>
        </trans-unit>
        <trans-unit id="bad3757e2d3ea8e03615372cc42932fa498e0342" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;less&lt;/code&gt; defines the lexicographical ordering to be used on the range.</source>
          <target state="translated">谓词 &lt;code&gt;less&lt;/code&gt; 定义要在范围上使用的字典顺序。</target>
        </trans-unit>
        <trans-unit id="75eafad6126e4b32c7a8770becfcb1f1b009b4fa" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;pred&lt;/code&gt; needs to accept an element of &lt;code&gt;r&lt;/code&gt; and the separator &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">谓词 &lt;code&gt;pred&lt;/code&gt; 需要接受 &lt;code&gt;r&lt;/code&gt; 的元素和分隔符 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73639f6f297aaeaa7398fc5473b39c5c235bf984" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the needle, defaulting to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The negated predicate &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; can be used to search instead for the first element</source>
          <target state="translated">用于将每个元素与指针进行比较的谓词，默认为等于 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。否定谓词 &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; 可用于搜索第一个元素</target>
        </trans-unit>
        <trans-unit id="ad19c283f2ff0ef86cf40f35fd842064c7bd010d" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the separator, defaulting to &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">用于将每个元素与分隔符进行比较的谓词，默认为 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5a87643179e233709de5c2f1a144d80a09a77b5" translate="yes" xml:space="preserve">
          <source>The predicate for deciding where to split the range when no separator is passed</source>
          <target state="translated">当没有传递分隔符时,用于决定在哪里分割范围的谓词。</target>
        </trans-unit>
        <trans-unit id="e35b33251882d624f933a2c1b64ccb5eb65ade7b" translate="yes" xml:space="preserve">
          <source>The predicate for determining when to stop counting.</source>
          <target state="translated">确定何时停止计数的前提条件。</target>
        </trans-unit>
        <trans-unit id="0c33296dd22cd76b6c27b1beb8636640e4665dda" translate="yes" xml:space="preserve">
          <source>The predicate is expected to satisfy certain rules in order for &lt;code&gt;sort&lt;/code&gt; to behave as expected - otherwise, the program may fail on certain inputs (but not others) when not compiled in release mode, due to the cursory &lt;code&gt;assumeSorted&lt;/code&gt; check. Specifically, &lt;code&gt;sort&lt;/code&gt; expects &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; to imply &lt;code&gt;less(a,c)&lt;/code&gt; (transitivity), and, conversely, &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; to imply &lt;code&gt;!less(a,c)&lt;/code&gt;. Note that the default predicate (&lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;) does not always satisfy these conditions for floating point types, because the expression will always be &lt;code&gt;false&lt;/code&gt; when either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is NaN. Use &lt;a href=&quot;std_math#cmp&quot;&gt;&lt;code&gt;std.math.cmp&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">谓词应满足某些规则，以便 &lt;code&gt;sort&lt;/code&gt; 能按预期方式运行-否则，由于未完成发布模式而进行的粗略&amp;ldquo; &lt;code&gt;assumeSorted&lt;/code&gt; 检查，程序可能无法在某些输入（而非其他）上失败。具体来说， &lt;code&gt;sort&lt;/code&gt; 期望 &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; 隐含 &lt;code&gt;less(a,c)&lt;/code&gt; （传递性），反之， &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; 隐含 &lt;code&gt;!less(a,c)&lt;/code&gt; 。请注意，默认谓词（ &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; ）并不总是满足浮点类型的这些条件，因为当 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 时表达式始终为 &lt;code&gt;false&lt;/code&gt; 是NaN。请改用&lt;a href=&quot;std_math#cmp&quot;&gt; &lt;code&gt;std.math.cmp&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27f1015c9d3c968b66e69f35344a3e7b0807ccce" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; and accepts any callable function that can be executed via &lt;code&gt;pred(element, s)&lt;/code&gt;.</source>
          <target state="translated">谓词将传递到&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;并接受可以通过 &lt;code&gt;pred(element, s)&lt;/code&gt; 执行的任何可调用函数。</target>
        </trans-unit>
        <trans-unit id="2040ad77d27bfa42d579b0732a628553443b56b4" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;.</source>
          <target state="translated">谓词传递给&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;，可以接受字符串，也可以通过 &lt;code&gt;pred(element, element)&lt;/code&gt; 执行的任何可调用对象。</target>
        </trans-unit>
        <trans-unit id="c1cc6d6782bb5ddbb272e878b0a97cd35ebd9643" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">谓词传递给&lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt;，可以接受字符串，也可以通过 &lt;code&gt;pred(element)&lt;/code&gt; 执行的任何可调用对象。</target>
        </trans-unit>
        <trans-unit id="30b49793439ff4c8d008cc1bf8471d003e4d8abc" translate="yes" xml:space="preserve">
          <source>The predicate that determines whether elements from each respective range match. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">谓词，确定每个范围内的元素是否匹配。默认为相等 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11c0e0e174294f0d039166c9a6e153edb402dcf7" translate="yes" xml:space="preserve">
          <source>The predicate that the range should be partitioned by.</source>
          <target state="translated">范围应该被分割的谓词。</target>
        </trans-unit>
        <trans-unit id="efb36bba668de1092c1769f6aab990aa0cb00922" translate="yes" xml:space="preserve">
          <source>The predicate the ranges are sorted by.</source>
          <target state="translated">范围排序的谓词。</target>
        </trans-unit>
        <trans-unit id="87bdd1f3ad180a36d78f0b0a9fe20115fabf7d4e" translate="yes" xml:space="preserve">
          <source>The predicate to evaluate.</source>
          <target state="translated">要评价的谓词。</target>
        </trans-unit>
        <trans-unit id="793b27dece0d99ba7788014f7bf7dd0fb1085592" translate="yes" xml:space="preserve">
          <source>The predicate to partition by.</source>
          <target state="translated">谓语以分。</target>
        </trans-unit>
        <trans-unit id="d5491576ad03ca04a8526c028f920296327ac77a" translate="yes" xml:space="preserve">
          <source>The predicate to satisfy.</source>
          <target state="translated">要满足的前提条件。</target>
        </trans-unit>
        <trans-unit id="c929e818343f11140b434407d7b74c242dda71fa" translate="yes" xml:space="preserve">
          <source>The predicate to sort by.</source>
          <target state="translated">要排序的谓词。</target>
        </trans-unit>
        <trans-unit id="04024868be7f287d2663bbef1dbf103a8da3cc6b" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements between the range and the needle(s).</source>
          <target state="translated">用于比较范围和针之间的元素的谓词。</target>
        </trans-unit>
        <trans-unit id="28f32071ce8ed6579de4bc0673c1fb09d434c803" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements.</source>
          <target state="translated">用于比较元素的谓词。</target>
        </trans-unit>
        <trans-unit id="8e5598b5509b9c6eafc0eab8a5a91702947d0e63" translate="yes" xml:space="preserve">
          <source>The predicate to use for determining a match.</source>
          <target state="translated">用于确定匹配的谓词。</target>
        </trans-unit>
        <trans-unit id="89fd4b4f61967cf71a560e54be19f8d76cbb1cde" translate="yes" xml:space="preserve">
          <source>The predicate to use for the rearrangement.</source>
          <target state="translated">用于重排的谓词。</target>
        </trans-unit>
        <trans-unit id="aafedf7f211b6bcd89cdb1a78ec67451cd224b87" translate="yes" xml:space="preserve">
          <source>The predicate to use in comparing elements for commonality. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">谓词，用于比较元素的通用性。默认为相等 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d6ef6e2289f7e8b2fa887a80d23adf75d1641e1" translate="yes" xml:space="preserve">
          <source>The predicate used for comparison, modeled as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt; strict weak ordering&lt;/a&gt; (irreflexive, antisymmetric, transitive, and implying a transitive equivalence)</source>
          <target state="translated">用于比较的谓词，建模为&lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt;严格的弱排序&lt;/a&gt;（不反身，反对称，及物和暗示及物等价）</target>
        </trans-unit>
        <trans-unit id="7f8c0f3692256237f756958104cf2f7dfb39d06e" translate="yes" xml:space="preserve">
          <source>The predicate used to compare the values.</source>
          <target state="translated">用于比较数值的谓词。</target>
        </trans-unit>
        <trans-unit id="97370c26d71acf94352a17fb62d152e3830e5289" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a false result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">谓词从左到右进行评价,如果遇到错误的结果,则以捷径方式中止评价,在这种情况下,后面的实例不需要编译。</target>
        </trans-unit>
        <trans-unit id="1d7464c6a5c260ac34ab99c016228d6b560c3e52" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a true result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">谓词从左到右进行评价,如果遇到真结果,则以捷径方式中止评价,在这种情况下,后面的实例不需要编译。</target>
        </trans-unit>
        <trans-unit id="c330fdecec36e8afd7824dda6b681cda50cda735" translate="yes" xml:space="preserve">
          <source>The preferred way to do memory management in Objective-C is to use Automatic Reference Counting, &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt;. This is not supported in D, therefore manual memory management is required to be used instead. This is achieved by calling &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; on an Objective-C instance, like in the old days of Objective-C.</source>
          <target state="translated">在Objective-C中进行内存管理的首选方法是使用自动引用计数&lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt;。D不支持此功能，因此需要使用手动内存管理。这是通过在Objective-C实例上调用&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt;来实现的，就像在Objective-C的早期一样。</target>
        </trans-unit>
        <trans-unit id="9c5a92eca5579a36fc2d0481a3b2f7e8a916467c" translate="yes" xml:space="preserve">
          <source>The presentation of unit test results to the user.</source>
          <target state="translated">向用户展示单元测试结果。</target>
        </trans-unit>
        <trans-unit id="8662f0b9530b0402d97b53b894f53167be45df40" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions, if any.</source>
          <target state="translated">异常链中的前一个异常,如果有的话。</target>
        </trans-unit>
        <trans-unit id="279b676cef017bbf61d78e4700dc992f1809ccb0" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions.</source>
          <target state="translated">异常链中的前一个异常。</target>
        </trans-unit>
        <trans-unit id="e3fc0517fe6d8889b123aa839a1f6e19c03962c2" translate="yes" xml:space="preserve">
          <source>The primary allocator.</source>
          <target state="translated">主要分配器。</target>
        </trans-unit>
        <trans-unit id="4f0154c15aa8860cab6cca5d166473b2dfba4c14" translate="yes" xml:space="preserve">
          <source>The primary range of a container</source>
          <target state="translated">容器的主要范围</target>
        </trans-unit>
        <trans-unit id="ab5e84bf7b0a53be5c65c8499a656cc503de367a" translate="yes" xml:space="preserve">
          <source>The primary range type associated with the container.</source>
          <target state="translated">与容器相关联的主要范围类型。</target>
        </trans-unit>
        <trans-unit id="33a169f7cc45c68212a77c63178f168570e503e4" translate="yes" xml:space="preserve">
          <source>The primary usefulness of</source>
          <target state="translated">的主要用途</target>
        </trans-unit>
        <trans-unit id="6d1a3cd0b06a0c49d350401e273d786a65d53304" translate="yes" xml:space="preserve">
          <source>The primary way that programs should time how long something takes is to do</source>
          <target state="translated">程序应该对某件事情所需的时间进行计时的主要方法是做以下工作</target>
        </trans-unit>
        <trans-unit id="c12de0da440bbe44b6cbc2ce06649502cfbb1a15" translate="yes" xml:space="preserve">
          <source>The process ID number.</source>
          <target state="translated">流程ID号。</target>
        </trans-unit>
        <trans-unit id="57ea5f74d898ca9f45c60b0cceb17881be0464f6" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase has no dependence on subsequent phases. For example, the scanner is not perturbed by the semantic analyzer. This separation of the passes makes language tools like syntax directed editors relatively easy to produce. It also is possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="translated">编译过程分为多个阶段。每个阶段都不依赖于后续阶段。例如，语义分析器不会干扰扫描器。通行证的这种分离使得语言工具（如语法导向的编辑器）相对易于生产。也可以通过以&amp;ldquo;标记化&amp;rdquo;形式存储D源来压缩D源。</target>
        </trans-unit>
        <trans-unit id="28114859ca08917818ce7134f60ebbc9ff108b7d" translate="yes" xml:space="preserve">
          <source>The process of constructing a trie is more involved and is hidden from the user in a form of the convenience functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; and the even more convenient &lt;a href=&quot;#toTrie&quot;&gt;&lt;code&gt;toTrie&lt;/code&gt;&lt;/a&gt;. In general a set or built-in AA with &lt;code&gt;dchar&lt;/code&gt; type can be turned into a trie. The trie object in this module is read-only (immutable); it's effectively frozen after construction.</source>
          <target state="translated">构建特里结构的过程是更复杂的，并且从用户的方便性的功能的形式隐藏&lt;a href=&quot;#codepointTrie&quot;&gt; &lt;code&gt;codepointTrie&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#codepointSetTrie&quot;&gt; &lt;code&gt;codepointSetTrie&lt;/code&gt; &lt;/a&gt;和更方便&lt;a href=&quot;#toTrie&quot;&gt; &lt;code&gt;toTrie&lt;/code&gt; &lt;/a&gt;。通常，具有 &lt;code&gt;dchar&lt;/code&gt; 类型的AA或内置AA 可以转换为trie。该模块中的trie对象是只读的（不可变的）。施工后有效冻结。</target>
        </trans-unit>
        <trans-unit id="d2a069ebee0eb3fc705692f747a2a23547f8a461" translate="yes" xml:space="preserve">
          <source>The process of deducing template type parameters from function arguments is called Implicit Function Template Instantiation (IFTI).</source>
          <target state="translated">从函数参数推导模板类型参数的过程称为隐式函数模板实例化(Implicit Function Template Instantiation,IFTI)。</target>
        </trans-unit>
        <trans-unit id="a65917e549f3ee7bf2fcc111ebfc87ae282e8929" translate="yes" xml:space="preserve">
          <source>The process will be &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;forcefully and abruptly terminated&lt;/a&gt;. If &lt;code&gt;codeOrSignal&lt;/code&gt; is specified, it must be a nonnegative number which will be used as the exit code of the process. If not, the process wil exit with code 1. Do not use &lt;code&gt;codeOrSignal = 259&lt;/code&gt;, as this is a special value (aka. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;) used by Windows to signal that a process has in fact</source>
          <target state="translated">该过程将被&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;强制终止&lt;/a&gt;。如果指定了 &lt;code&gt;codeOrSignal&lt;/code&gt; ，则它必须是一个非负数，它将用作进程的退出代码。如果不是，则该进程将以代码1退出。请勿使用 &lt;code&gt;codeOrSignal = 259&lt;/code&gt; ，因为这是Windows使用的特殊值（又名&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;），用于指示进程实际上已经</target>
        </trans-unit>
        <trans-unit id="a52379dcfb4fdf54c286085a8d7b935d4c3bf51f" translate="yes" xml:space="preserve">
          <source>The program can explicitly inform the garbage collector that an object is no longer referred to with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, and then the garbage collector calls the destructor immediately. The destructor is guaranteed to never be called twice.</source>
          <target state="translated">该程序可以显式通知垃圾回收器，不再使用&lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt;引用对象，然后垃圾回收器立即调用析构函数。保证析构函数永远不会被调用两次。</target>
        </trans-unit>
        <trans-unit id="da8f18e43875ff3b21ffb3a65f1d74da9627baee" translate="yes" xml:space="preserve">
          <source>The program name,</source>
          <target state="translated">节目名称。</target>
        </trans-unit>
        <trans-unit id="212a3b865b9d39089a835e861cd51456362e9629" translate="yes" xml:space="preserve">
          <source>The proper way to instantiate this object is to call &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt;. Once instantiated, this object behaves as a finite random-access range with assignable, lvalue elements and a length equal to the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; that created it plus 1.</source>
          <target state="translated">实例化此对象的正确方法是调用 &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt; 。实例化后，此对象的行为就如同一个有限的随机访问范围，其中包含可分配的lvalue元素，其长度等于创建它的 &lt;code&gt;TaskPool&lt;/code&gt; 中工作线程的数量加1。</target>
        </trans-unit>
        <trans-unit id="06cb3e37f16148a51f8965d4f1cdc4ea883f0365" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;.__vptr&lt;/code&gt; and &lt;code&gt;.__monitor&lt;/code&gt; give access to the class object's vtbl[] and monitor, respectively, but should not be used in user code.</source>
          <target state="translated">属性 &lt;code&gt;.__vptr&lt;/code&gt; 和 &lt;code&gt;.__monitor&lt;/code&gt; 分别提供对类对象的vtbl []和monitor的访问权限，但不应在用户代码中使用。</target>
        </trans-unit>
        <trans-unit id="465978af9e7d0929cd7aec7d44ae79ba13368247" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;.outer&lt;/code&gt; used in a nested class gives the &lt;code&gt;this&lt;/code&gt; pointer to its enclosing class. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would return a pointer to enclosing function frame with &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">嵌套类中使用的属性 &lt;code&gt;.outer&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 指针指向其封闭类。如果没有封闭的类上下文， &lt;code&gt;.outer&lt;/code&gt; 将返回一个指向带有 &lt;code&gt;void*&lt;/code&gt; 封闭功能框架的指针。</target>
        </trans-unit>
        <trans-unit id="18230b4e21a7c31cb0b0a527787c1242f4f98838" translate="yes" xml:space="preserve">
          <source>The proxied value must be an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">代理值必须是&lt;b&gt;左值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2aa3e8b16a5d628661af4b4300a9494770cb4fda" translate="yes" xml:space="preserve">
          <source>The ptr aliases are integral types guaranteed to be large enough to hold a pointer without losing bits:</source>
          <target state="translated">ptr别名是积分类型,保证足够大,可以容纳一个指针而不丢失位。</target>
        </trans-unit>
        <trans-unit id="5110028f04b358ea03cfe31d14fda076a20fecde" translate="yes" xml:space="preserve">
          <source>The purpose is to bypass the special case decoding that &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; does to character arrays. As a result, using ranges with &lt;code&gt;byCodeUnit&lt;/code&gt; can be &lt;code&gt;nothrow&lt;/code&gt; while &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; throws when it encounters invalid Unicode sequences.</source>
          <target state="translated">目的是绕过&lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt;对字符数组所做的特殊情况解码。结果，当遇到无效Unicode序列时， &lt;code&gt;byCodeUnit&lt;/code&gt; 会 &lt;code&gt;nothrow&lt;/code&gt; 异常，而&lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt;会使用范围。</target>
        </trans-unit>
        <trans-unit id="c265a2d12f1e7e5cd63d17026023fdb0d5f3f129" translate="yes" xml:space="preserve">
          <source>The purpose of this is so that continue will go to the next of the statements, and break will go to the end of the statements.</source>
          <target state="translated">这样做的目的是为了让继续会转到下一个语句,而断裂会转到语句的结尾。</target>
        </trans-unit>
        <trans-unit id="1651c6e27b3326d67f792a155dd955abdff9b39f" translate="yes" xml:space="preserve">
          <source>The qualifier template from the given type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">给定类型 &lt;code&gt;T&lt;/code&gt; 的限定词模板</target>
        </trans-unit>
        <trans-unit id="e09036cabacde1d4e95f44667e0017f4b4c08158" translate="yes" xml:space="preserve">
          <source>The qualifiers of the affix are not always the same as the qualifiers of the argument. This is because the affixes are not part of the data itself, but instead are just</source>
          <target state="translated">词缀的限定词并不总是与参数的限定词相同。这是因为词缀并不是数据本身的一部分,而只是作为</target>
        </trans-unit>
        <trans-unit id="0c6a006eb9560342bd14cc8557e22fb25a226fd2" translate="yes" xml:space="preserve">
          <source>The random-access range to partition.</source>
          <target state="translated">要分区的随机访问范围。</target>
        </trans-unit>
        <trans-unit id="97092cfd186fb5b900f835cf73b9eb2468215664" translate="yes" xml:space="preserve">
          <source>The random-access range to rearrange.</source>
          <target state="translated">要重新排列的随机访问范围。</target>
        </trans-unit>
        <trans-unit id="e4ce54dd9a7b88e5f2bf201fe3fb2e94f16d9fa9" translate="yes" xml:space="preserve">
          <source>The random-access range to reorder.</source>
          <target state="translated">要重新排序的随机访问范围。</target>
        </trans-unit>
        <trans-unit id="9759b91222e0376d244c7fe53ea2166dd785b989" translate="yes" xml:space="preserve">
          <source>The range API is supported for both encoding and decoding:</source>
          <target state="translated">编码和解码都支持范围API。</target>
        </trans-unit>
        <trans-unit id="f827934761dc7cbd89045f8928d650c1c6adfe0d" translate="yes" xml:space="preserve">
          <source>The range being partitioned</source>
          <target state="translated">被分割的范围</target>
        </trans-unit>
        <trans-unit id="ff34249e986a29860f6c5d437ad8145efcb4a0b9" translate="yes" xml:space="preserve">
          <source>The range primitives that the resulting range provides depends whether or not &lt;code&gt;r&lt;/code&gt; provides them. Except the functions &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;, which also require the range to have a length as well as &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;</source>
          <target state="translated">结果范围提供的范围原语取决于 &lt;code&gt;r&lt;/code&gt; 是否提供它们。除了 &lt;code&gt;back&lt;/code&gt; 和 &lt;code&gt;popBack&lt;/code&gt; 函数之外，该函数还要求范围具有长度以及 &lt;code&gt;back&lt;/code&gt; 和 &lt;code&gt;popBack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e867771f52adb05da2dc3c29c4eccce7ead17be" translate="yes" xml:space="preserve">
          <source>The range to append to.</source>
          <target state="translated">要追加的范围。</target>
        </trans-unit>
        <trans-unit id="b8f92036ba2322967a7c304f2680091886c10a9f" translate="yes" xml:space="preserve">
          <source>The range to check.</source>
          <target state="translated">要检查的范围。</target>
        </trans-unit>
        <trans-unit id="92faab42363803d3ec822fdd1af0c67c9ba8588a" translate="yes" xml:space="preserve">
          <source>The range to count.</source>
          <target state="translated">要计算的范围。</target>
        </trans-unit>
        <trans-unit id="2a5042de5707ed27e3cd38336bffdd36cd0572c7" translate="yes" xml:space="preserve">
          <source>The range to handle.</source>
          <target state="translated">处理的范围。</target>
        </trans-unit>
        <trans-unit id="e058b4d6c31bc35cf580da1ebefcc71d18f5d1ca" translate="yes" xml:space="preserve">
          <source>The range to index.</source>
          <target state="translated">要索引的范围。</target>
        </trans-unit>
        <trans-unit id="80d973acf722de6a5268aeaa4c8fc9646330d9bc" translate="yes" xml:space="preserve">
          <source>The range to permute.</source>
          <target state="translated">的范围内进行消磨。</target>
        </trans-unit>
        <trans-unit id="804c985240d645660c7de05e2788995416dc345a" translate="yes" xml:space="preserve">
          <source>The range to read from.</source>
          <target state="translated">要读取的范围。</target>
        </trans-unit>
        <trans-unit id="8b4ec9a859bd18ea04f9de73b722dd789467f7e7" translate="yes" xml:space="preserve">
          <source>The range to search.</source>
          <target state="translated">要搜索的范围。</target>
        </trans-unit>
        <trans-unit id="121036e1b0b497292221a25f49b6dd27cc53e9e1" translate="yes" xml:space="preserve">
          <source>The range to sort.</source>
          <target state="translated">要排序的范围。</target>
        </trans-unit>
        <trans-unit id="cc147be5451f6cfb0b41f5b2277bb929ce23d7db" translate="yes" xml:space="preserve">
          <source>The range to subtract from &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;r1&lt;/code&gt; 减去的范围。</target>
        </trans-unit>
        <trans-unit id="49d274ac9ff8b631f4dc3f4b09f1138c62b7ffc0" translate="yes" xml:space="preserve">
          <source>The range to write to.</source>
          <target state="translated">要写入的范围。</target>
        </trans-unit>
        <trans-unit id="49360fcd22b248a482a8ca2592193dd9241be2ca" translate="yes" xml:space="preserve">
          <source>The range type</source>
          <target state="translated">范围类型</target>
        </trans-unit>
        <trans-unit id="802ba550fbcee32bf81ae1613d2bfa286e1456a5" translate="yes" xml:space="preserve">
          <source>The range types for &lt;code&gt;RedBlackTree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RedBlackTree&lt;/code&gt; 的范围类型</target>
        </trans-unit>
        <trans-unit id="a11d808dfbdf148bbb169a6a95255aca3179a47b" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;begin&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">范围的 &lt;code&gt;front&lt;/code&gt; 是间隔的 &lt;code&gt;begin&lt;/code&gt; 。当 &lt;code&gt;popFront&lt;/code&gt; 时，func用于生成下一个 &lt;code&gt;front&lt;/code&gt; 。如果popFirst是 &lt;code&gt;PopFirst.yes&lt;/code&gt; ，则在返回范围之前调用 &lt;code&gt;popFront&lt;/code&gt; （因此 &lt;code&gt;front&lt;/code&gt; 是func将生成的时间点）。</target>
        </trans-unit>
        <trans-unit id="2230a6c9d63e9a6e8252220108f18931ca810d49" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;end&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">范围的 &lt;code&gt;front&lt;/code&gt; 是区间的 &lt;code&gt;end&lt;/code&gt; 。当 &lt;code&gt;popFront&lt;/code&gt; 时，func用于生成下一个 &lt;code&gt;front&lt;/code&gt; 。如果popFirst是 &lt;code&gt;PopFirst.yes&lt;/code&gt; ，则在返回范围之前调用 &lt;code&gt;popFront&lt;/code&gt; （因此 &lt;code&gt;front&lt;/code&gt; 是func将生成的时间点）。</target>
        </trans-unit>
        <trans-unit id="bc87d893530544a1088c66c1a3ebadf8aa8d14c3" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types (i.e. &lt;code&gt;CommonType&lt;/code&gt; must exist for the two element types). The result is a range that offers the weakest capabilities of the two (e.g. &lt;code&gt;ForwardRange&lt;/code&gt; if &lt;code&gt;R1&lt;/code&gt; is a random-access range and &lt;code&gt;R2&lt;/code&gt; is a forward range).</source>
          <target state="translated">范围可能有所不同，但是它们必须具有兼容的元素类型（即，两种元素类型必须存在 &lt;code&gt;CommonType&lt;/code&gt; ）。结果是提供两个功能中最弱的范围（例如，如果 &lt;code&gt;R1&lt;/code&gt; 是随机访问范围而 &lt;code&gt;R2&lt;/code&gt; 是正向范围，则为 &lt;code&gt;ForwardRange&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3f573b0cbf92f973f94497f03f6ff76a63fec72f" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types. The result is a range that offers the weakest capabilities of all &lt;code&gt;Ranges&lt;/code&gt;.</source>
          <target state="translated">范围可能不同，但是它们必须具有兼容的元素类型。结果是范围提供了所有 &lt;code&gt;Ranges&lt;/code&gt; 最弱的功能。</target>
        </trans-unit>
        <trans-unit id="b730db3bfe83c0cd05e43737d06094aae7960b40" translate="yes" xml:space="preserve">
          <source>The ranges to compute the intersection for.</source>
          <target state="translated">要计算交点的范围。</target>
        </trans-unit>
        <trans-unit id="46baca537890237a1942208ed4eade3a2e0fe13d" translate="yes" xml:space="preserve">
          <source>The ranges to compute the union for.</source>
          <target state="translated">要计算联合的范围。</target>
        </trans-unit>
        <trans-unit id="5497d81d16c2927140f25a4c1006f37fea2563ca" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the class definition. The pointer to the vtbl[] (the array of pointers to virtual functions) is assigned. Constructors are passed fully formed objects for which virtual functions can be called. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">原始数据使用类定义中提供的值进行静态初始化。vtbl[](指向虚拟函数的指针数组)的指针被分配。构造函数被传递给完全形成的对象,可以为其调用虚拟函数。这个操作相当于在新分配的对象上做一个静态版本的内存拷贝。</target>
        </trans-unit>
        <trans-unit id="fcae8af2965ab59e0bb8589c5d279780cbfa5e92" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the struct definition. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">使用结构定义中提供的值对原始数据进行静态初始化。这个操作相当于在新分配的对象上做一个静态版本的内存拷贝。</target>
        </trans-unit>
        <trans-unit id="b86128a6bd2767acc00fa6def304105cbf1e478d" translate="yes" xml:space="preserve">
          <source>The read end of the pipe.</source>
          <target state="translated">管道的读取端。</target>
        </trans-unit>
        <trans-unit id="13a2374af67fe26dbb9c14a59fb5ce5f9e9d781a" translate="yes" xml:space="preserve">
          <source>The read/write mutex module provides a primitive for maintaining shared read access and mutually exclusive write access.</source>
          <target state="translated">读/写互斥模块提供了一个维持共享读访问和互斥写访问的基元。</target>
        </trans-unit>
        <trans-unit id="1ea37ce134dc82d56b80e1186c5f0aadafbf2545" translate="yes" xml:space="preserve">
          <source>The real part of the number.</source>
          <target state="translated">数字的真实部分。</target>
        </trans-unit>
        <trans-unit id="d84af79636d58f1538ce03a4ef706cc4269fc0ca" translate="yes" xml:space="preserve">
          <source>The reason why local symbols are not considered by UFCS, is to avoid unexpected name conflicts. See below problematic examples.</source>
          <target state="translated">UFCS之所以不考虑本地符号,是为了避免意外的名称冲突。请看下面的问题例子。</target>
        </trans-unit>
        <trans-unit id="6e1a9e9d57c1e11e3c0d69a36fca45727647f054" translate="yes" xml:space="preserve">
          <source>The reason why parsing the UUID string failed (if known)</source>
          <target state="translated">解析UUID字符串失败的原因(如果知道)。</target>
        </trans-unit>
        <trans-unit id="444ce1c54b9e6e4aeb187c02bb491ead21cc3157" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T.length&lt;/code&gt; is greater than one, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">收到的消息。如果 &lt;code&gt;T.length&lt;/code&gt; 大于1，则消息将打包到&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="629439e6d0394e525c1da0e460386c227bde37f1" translate="yes" xml:space="preserve">
          <source>The recommended default type for set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. For details, see the current implementation: &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">推荐的&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;默认类型。有关详细信息，请参见当前实现：&lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1dc42bd6a98f128cb04e650caf0c66b2c441a15" translate="yes" xml:space="preserve">
          <source>The recommended solution (see Unicode Implementation Guidelines) is using multi-stage tables that are an implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; data structure with integer keys and a fixed number of stages. For the remainder of the section this will be called a fixed trie. The following describes a particular implementation that is aimed for the speed of access at the expense of ideal size savings.</source>
          <target state="translated">推荐的解决方案（请参阅Unicode实施指南）使用多级表，该表是具有整数键和固定级数的&lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt;数据结构的实现。在本节的其余部分，这将称为固定特里。下面描述了一种特定的实现，该实现旨在以节省理想大小为代价的访问速度。</target>
        </trans-unit>
        <trans-unit id="64d2cded1f6173c486fb7ad21ff19a0763451581" translate="yes" xml:space="preserve">
          <source>The recommended type of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; to represent [a, b) intervals of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. As used in &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;. Any interval type should pass &lt;a href=&quot;#isIntegralPair&quot;&gt;&lt;code&gt;isIntegralPair&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">推荐的&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;类型，用于表示[a，b）&lt;a href=&quot;#Code%20point&quot;&gt;代码点的&lt;/a&gt;间隔。如&lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; 中&lt;/a&gt;所使用。任何间隔类型都应传递&lt;a href=&quot;#isIntegralPair&quot;&gt; &lt;code&gt;isIntegralPair&lt;/code&gt; &lt;/a&gt;特征。</target>
        </trans-unit>
        <trans-unit id="859ae610f623e658d3afadb3f75618929c558560" translate="yes" xml:space="preserve">
          <source>The recommended use of &lt;code&gt;KRRegion&lt;/code&gt; is as a</source>
          <target state="translated">建议将 &lt;code&gt;KRRegion&lt;/code&gt; 用作</target>
        </trans-unit>
        <trans-unit id="388d2ad6c415253a61a360bde9d489b23f6dc8d0" translate="yes" xml:space="preserve">
          <source>The ref-ness of a function is determined from all &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body:</source>
          <target state="translated">函数的引用性取决于函数体内的所有&lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3b502b2fed948d53834e6a08aa36762dc04287b2" translate="yes" xml:space="preserve">
          <source>The reference label must match a reference defined elsewhere. This may be a D symbol in scope of the source code being documented, like &lt;code&gt;[Object]&lt;/code&gt; in the example above, or it may be an explicit reference that is defined in the same documentation comment, like &lt;code&gt;[ref]&lt;/code&gt; in the example above. In the example both instances of &lt;code&gt;[ref]&lt;/code&gt; in item &lt;code&gt;1.&lt;/code&gt; will be replaced with the URL and title text from the matching definition at the bottom of the example. The first link will read &lt;code&gt;reference link&lt;/code&gt; and the second will read &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">参考标签必须与其他地方定义的参考匹配。这可以是所记录的源代码范围内的D符号，例如上例中的 &lt;code&gt;[Object]&lt;/code&gt; ，也可以是在同一文档注释中定义的显式引用，例如上例中的 &lt;code&gt;[ref]&lt;/code&gt; 。在该示例中，第 &lt;code&gt;1.&lt;/code&gt; 项中 &lt;code&gt;[ref]&lt;/code&gt; 的两个实例都将替换为示例底部匹配定义中的URL和标题文本。第一个链接将读取 &lt;code&gt;reference link&lt;/code&gt; ，第二个链接将读取 &lt;code&gt;ref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7f3a52223d62265f3e1ec0b1d084d2cc36a6550" translate="yes" xml:space="preserve">
          <source>The region only stores three pointers, corresponding to the current position in the store and the limits. One allocation entails rounding up the allocation size for alignment purposes, bumping the current pointer, and comparing it against the limit.</source>
          <target state="translated">该区域只存储三个指针,分别对应存储中的当前位置和极限。一次分配需要将分配大小四舍五入,以达到对齐的目的,将当前指针撞开,并与限制进行比较。</target>
        </trans-unit>
        <trans-unit id="8dfea884780d568afe3690e3e3875bf9d38d17dd" translate="yes" xml:space="preserve">
          <source>The registry does not perform synchronization, as registration is assumed to be executed serially, as is the case for C constructors.</source>
          <target state="translated">注册表不执行同步,因为注册被假定为串行执行,就像C构造函数一样。</target>
        </trans-unit>
        <trans-unit id="323d86762a22443df4223066c5d79a8182348cc7" translate="yes" xml:space="preserve">
          <source>The rehashed associative array.</source>
          <target state="translated">重构的关联数组。</target>
        </trans-unit>
        <trans-unit id="2287a637460b49ec8f0775da73953a50ae5c2dbd" translate="yes" xml:space="preserve">
          <source>The relative path.</source>
          <target state="translated">相对路径。</target>
        </trans-unit>
        <trans-unit id="6288b454d7838d0a858531ccb0a8c1a5187d7261" translate="yes" xml:space="preserve">
          <source>The removed &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">删除的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c0fe435252d4242a9ba6f628f9c2050e5381799" translate="yes" xml:space="preserve">
          <source>The replacement text is recursively scanned for more macros. If a macro is recursively encountered, with no argument or with the same argument text as the enclosing macro, it is replaced with no text. Macro invocations that cut across replacement text boundaries are not expanded. If the macro name is undefined, the replacement text has no characters in it. If a &amp;amp;dollar;(NAME) is desired to exist in the output without being macro expanded, the &amp;amp;dollar; should be &lt;a href=&quot;#punctuation_escapes&quot;&gt; backslash-escaped&lt;/a&gt;: &lt;code&gt;\$&lt;/code&gt;.</source>
          <target state="translated">递归扫描替换文本以查找更多宏。如果递归地遇到一个宏，该宏没有参数或与封闭的宏具有相同的参数文本，则将其替换为没有文本。跨替换文本边界的宏调用不会扩展。如果宏名未定义，则替换文本中没有字符。如果希望在不进行宏扩展的情况下在输出中存在＆dollar;（NAME），则＆dollar; 应该用&lt;a href=&quot;#punctuation_escapes&quot;&gt;反斜杠转义&lt;/a&gt;： &lt;code&gt;\$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00c0559f793b29523699536174f193f79d1404f9" translate="yes" xml:space="preserve">
          <source>The representation of the passed string.</source>
          <target state="translated">传递的字符串的表示方法。</target>
        </trans-unit>
        <trans-unit id="541a2ee308f80899ed39d343b6df8bc566dc23af" translate="yes" xml:space="preserve">
          <source>The requested type. The currently stored value must implicitly convert to the requested type, in fact &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt;. If an implicit conversion is not possible, throws a &lt;code&gt;VariantException&lt;/code&gt;.</source>
          <target state="translated">要求的类型。当前存储的值必须隐式转换为请求的类型，实际上是 &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt; 。如果无法进行隐式转换，则抛出 &lt;code&gt;VariantException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5eb7b072c5ec5c51e2bc9f0c47309355a93d189e" translate="yes" xml:space="preserve">
          <source>The required value.</source>
          <target state="translated">所需数值;</target>
        </trans-unit>
        <trans-unit id="2b92c124327023d2112fc02de9225ba21a0e356f" translate="yes" xml:space="preserve">
          <source>The rest of the EH data can be placed anywhere, it is immutable.</source>
          <target state="translated">其余的EH数据可以放在任何地方,它是不可改变的。</target>
        </trans-unit>
        <trans-unit id="bc76ec74ecd985115be5a95df44e330a29c95a31" translate="yes" xml:space="preserve">
          <source>The result cannot be represented exactly, so rounding occurred.</source>
          <target state="translated">结果不能准确表示,所以发生了四舍五入。</target>
        </trans-unit>
        <trans-unit id="ab324d21f7bc55d7dd8b6c95008f59bdf991ab91" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">结果为 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4130bb4d8bac0fbef0c07bb06c97970f537d8b6" translate="yes" xml:space="preserve">
          <source>The result is [s&lt;sub&gt;0&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;, ...] where s&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">结果为[s &lt;sub&gt;0&lt;/sub&gt;，s &lt;sub&gt;1&lt;/sub&gt;，...]，其中s &lt;sub&gt;n&lt;/sub&gt;是使用默认格式设置的第n个元素。</target>
        </trans-unit>
        <trans-unit id="2b142e927d8266a5d73b4c96f242e530946b4181" translate="yes" xml:space="preserve">
          <source>The result is reasonable even if the programmer fails to check for errors.</source>
          <target state="translated">即使程序员没有查错,结果也是合理的。</target>
        </trans-unit>
        <trans-unit id="e6fee708ae88c1f8ca73e67b83e15b2edc455c01" translate="yes" xml:space="preserve">
          <source>The result is reasonable result even if the programmer fails to check for errors.</source>
          <target state="translated">即使程序员没有查错,结果也是合理的结果。</target>
        </trans-unit>
        <trans-unit id="5df04c97a049ab6feec7de9282693846423b4f8b" translate="yes" xml:space="preserve">
          <source>The result is the equivalent of what the initializer would look like for the contents of the associative array, e.g.: [&quot;red&quot; : 10, &quot;blue&quot; : 20].</source>
          <target state="translated">其结果相当于初始化器对关联数组内容的描述,如 [&quot;红&quot;:10,&quot;蓝&quot;:20]。</target>
        </trans-unit>
        <trans-unit id="08ac164a7aed36036f9bcf755150a74df3d7b24f" translate="yes" xml:space="preserve">
          <source>The result is the string converted to UTF-8. A</source>
          <target state="translated">其结果是将字符串转换为UTF-8。A</target>
        </trans-unit>
        <trans-unit id="1509a90746b95e562f0978b9e4493748f60d91cb" translate="yes" xml:space="preserve">
          <source>The result is the string returned from the class instance's &lt;b&gt;.toString()&lt;/b&gt; method. A</source>
          <target state="translated">结果是从类实例的&lt;b&gt;.toString（）&lt;/b&gt;方法返回的字符串。一个</target>
        </trans-unit>
        <trans-unit id="778aba0a364d09c18b371bc8036e82626d093a0a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;takeExactly&lt;/code&gt; is identical to that of &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; in cases where the original range defines &lt;code&gt;length&lt;/code&gt; or is infinite.</source>
          <target state="translated">&lt;code&gt;takeExactly&lt;/code&gt; 的结果与原始范围定义 &lt;code&gt;length&lt;/code&gt; 或无限的情况下的&lt;a href=&quot;#take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="07564cb52ad1e727fc81a3311ff06a2d773285ae" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been cleared.</source>
          <target state="translated">在指定位被清除后调用getAttr的结果。</target>
        </trans-unit>
        <trans-unit id="f30cfdc760b36139b0f53b5d0be507ea3d824ed7" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been set.</source>
          <target state="translated">指定位被设置后调用getAttr的结果。</target>
        </trans-unit>
        <trans-unit id="445b97c22b054bdd6ff54c4dae46c9df7f4357c6" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;getopt&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;getopt&lt;/code&gt; 函数的结果。</target>
        </trans-unit>
        <trans-unit id="c4e35be57e8c5a96f93fd5bad1cb28bc557187a1" translate="yes" xml:space="preserve">
          <source>The result of the cast operation.</source>
          <target state="translated">投放操作的结果。</target>
        </trans-unit>
        <trans-unit id="83715d44bc2b7900f8b6419b6c4fbc003acad08e" translate="yes" xml:space="preserve">
          <source>The result of the comparison (negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, positive if &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the values are equal)</source>
          <target state="translated">比较的结果（如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 负，如果 &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt; 正，如果值相等则为 &lt;code&gt;0&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b2ab3e5031cd5a46b28a9645ebcd2ff7f110159a" translate="yes" xml:space="preserve">
          <source>The result of the comparison, &lt;code&gt;true&lt;/code&gt; if the values are equal</source>
          <target state="translated">比较的结果，如果值相等则为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c6e42e7ac37e1c83ed4b193d1c4849e41daad91" translate="yes" xml:space="preserve">
          <source>The result of the comparison.</source>
          <target state="translated">比较的结果。</target>
        </trans-unit>
        <trans-unit id="6c6d52fd3aff83619b0b5496c6e3c7be89c2a3aa" translate="yes" xml:space="preserve">
          <source>The result of the expression if no exception is thrown.</source>
          <target state="translated">如果没有发生异常,则表达式的结果。</target>
        </trans-unit>
        <trans-unit id="0c56ce95759c8e42c05e176cc9b231a6a3180930" translate="yes" xml:space="preserve">
          <source>The result of the operation, which is the same as the built-in operator</source>
          <target state="translated">操作的结果,与内置的操作符相同。</target>
        </trans-unit>
        <trans-unit id="5b1c264300cd8b658cc8b4e315b7758a06a23af7" translate="yes" xml:space="preserve">
          <source>The result of the operation.</source>
          <target state="translated">行动的结果。</target>
        </trans-unit>
        <trans-unit id="9d8e130938ba904bc8f047659f58c659ed670a0b" translate="yes" xml:space="preserve">
          <source>The result of this expression will be discarded. Print error messages if the operation has no side effects (and hence is meaningless).</source>
          <target state="translated">此表达式的结果将被丢弃。如果操作没有副作用(因此没有意义),则打印错误信息。</target>
        </trans-unit>
        <trans-unit id="2a7cfc7639682da470adfb6b183264f1a3b8552c" translate="yes" xml:space="preserve">
          <source>The result type of an</source>
          <target state="translated">的结果类型</target>
        </trans-unit>
        <trans-unit id="4056040f4fa407b267fad8cbca77b5fc61b11543" translate="yes" xml:space="preserve">
          <source>The resulting addresses will be used in a call to &lt;code&gt;Socket.bind&lt;/code&gt;.</source>
          <target state="translated">结果地址将用于 &lt;code&gt;Socket.bind&lt;/code&gt; 的调用中。</target>
        </trans-unit>
        <trans-unit id="3b20f209f4a7f010b51d8af08450b0f594e3ca06" translate="yes" xml:space="preserve">
          <source>The resulting center-justified string. The returned string is GC-allocated. To avoid GC allocation, use &lt;a href=&quot;#centerJustifier&quot;&gt;&lt;code&gt;centerJustifier&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">结果中心对齐的字符串。返回的字符串是GC分配的。为避免分配GC，请改用&lt;a href=&quot;#centerJustifier&quot;&gt; &lt;code&gt;centerJustifier&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6de191dd7ab6e3535ad839e47c65dfd4fc76b1d8" translate="yes" xml:space="preserve">
          <source>The resulting index.</source>
          <target state="translated">结果指数。</target>
        </trans-unit>
        <trans-unit id="3934e1c05473de8755d2bda617c6973f102e169c" translate="yes" xml:space="preserve">
          <source>The return code of the operation. The value stored in val should be used only if the return value is &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt;.</source>
          <target state="translated">操作的返回码。仅当返回值为 &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt; 时,才应使用val中存储的值。</target>
        </trans-unit>
        <trans-unit id="1da37adfbfe4961b78a217ba2c3b5022d249608b" translate="yes" xml:space="preserve">
          <source>The return expression associated with the first test expression that made the predicate yield true, or the default return expression if no test expression matched.</source>
          <target state="translated">与使谓词产生真的第一个测试表达式相关联的返回表达式,如果没有匹配的测试表达式,则使用默认的返回表达式。</target>
        </trans-unit>
        <trans-unit id="96d68b6363dece3bf1b664aecfe8cf00504e56f0" translate="yes" xml:space="preserve">
          <source>The return type (int or long). It defaults to time_t, which is normally 32 bits on a 32-bit system and 64 bits on a 64-bit system.</source>
          <target state="translated">返回类型(int或long),默认为time_t,在32位系统中为32位,在64位系统中为64位。默认值为time_t,32位系统通常为32位,64位系统为64位。</target>
        </trans-unit>
        <trans-unit id="205ac1a8649e05600dd566c06cc715bf690a04c6" translate="yes" xml:space="preserve">
          <source>The return type must not have unshared aliasing unless &lt;code&gt;fun&lt;/code&gt; is &lt;code&gt;pure&lt;/code&gt; or the &lt;code&gt;Task&lt;/code&gt; is executed via &lt;code&gt;executeInNewThread&lt;/code&gt; instead of using a &lt;code&gt;TaskPool&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;fun&lt;/code&gt; 是 &lt;code&gt;pure&lt;/code&gt; 函数或者通过 &lt;code&gt;executeInNewThread&lt;/code&gt; 而不是使用 &lt;code&gt;TaskPool&lt;/code&gt; 来执行 &lt;code&gt;Task&lt;/code&gt; ,否则返回类型不得具有非共享别名。</target>
        </trans-unit>
        <trans-unit id="0e9168599ed0b4047c1160546ea0dbeb54368257" translate="yes" xml:space="preserve">
          <source>The return type of the error handler.</source>
          <target state="translated">错误处理程序的返回类型。</target>
        </trans-unit>
        <trans-unit id="97a463467304a89d6cd8cb9cc6d419fcfa020151" translate="yes" xml:space="preserve">
          <source>The return type of the function called by this &lt;code&gt;Task&lt;/code&gt;. This can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;Task&lt;/code&gt; 调用的函数的返回类型。这可以是 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5cb9f689236bc6a0892c16310f01988eb2264f8" translate="yes" xml:space="preserve">
          <source>The return type of tryVisit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">tryVisit的返回类型是从访问函数中推导出来的,并且在所有的重载中必须是相同的。</target>
        </trans-unit>
        <trans-unit id="1337a5d1a9830872413420563b85bf03297ab386" translate="yes" xml:space="preserve">
          <source>The return type of visit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">访问的返回类型是从访问函数中推导出来的,并且在所有的重载中必须是相同的。</target>
        </trans-unit>
        <trans-unit id="1ae63b720e25e931777a9598eac602b1cc909af8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="463c16879da8ce6d09697a58e7475146e16150d1" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="c060f61f5611e03952bbbab3e92b4fea17da134a" translate="yes" xml:space="preserve">
          <source>The return value of the function is cached, so the procedures described below will only be performed the first time the function is called. All subsequent runs will return the same string, regardless of whether environment variables and directory structures have changed in the meantime.</source>
          <target state="translated">函数的返回值会被缓存,所以只有在第一次调用函数时才会执行下面描述的程序。所有后续的运行都将返回相同的字符串,不管环境变量和目录结构是否发生了变化。</target>
        </trans-unit>
        <trans-unit id="818fa28d06533d229f1e780afce11dd92bba71cd" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stderr&quot;&gt;&lt;code&gt;core.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装了&lt;a href=&quot;core_stdio#stderr&quot;&gt; &lt;code&gt;core.stdio.stderr&lt;/code&gt; &lt;/a&gt;，因此是全局线程。必须在单线程或锁定上下文中将 &lt;code&gt;stderr&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; ，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="c5c6e553a95738c70b1b18bed8de44ea5bcf8eb1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdin&quot;&gt;&lt;code&gt;core.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装了&lt;a href=&quot;core_stdio#stdin&quot;&gt; &lt;code&gt;core.stdio.stdin&lt;/code&gt; &lt;/a&gt;，因此是全局线程。将 &lt;code&gt;stdin&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; 必须在单线程或锁定上下文中完成，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="58bd0e7417109f330774ab518ccd7daa1f03d122" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdout&quot;&gt;&lt;code&gt;core.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装了&lt;a href=&quot;core_stdio#stdout&quot;&gt; &lt;code&gt;core.stdio.stdout&lt;/code&gt; &lt;/a&gt;，因此是全局线程。必须在单线程或锁定上下文中将 &lt;code&gt;stdout&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; ，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="ac381e0220e927fc50320b0674e141c6fbd265c5" translate="yes" xml:space="preserve">
          <source>The returned object additionally supports &lt;a href=&quot;#unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的对象还支持&lt;a href=&quot;#unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6492e8cd4172777485864f95c54fa9ab563046c6" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is by default taken to be the current working directory. If specified, &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">返回的路径是相对于 &lt;code&gt;base&lt;/code&gt; 的，默认情况下将其作为当前工作目录。如果指定， &lt;code&gt;base&lt;/code&gt; 必须是绝对路径，并且始终假定它引用目录。如果 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 引用相同的目录，则该函数返回 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27a61535d29f02d1215deba5ffbffddc1e97e7db" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is usually the current working directory. &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">返回的路径是相对于 &lt;code&gt;base&lt;/code&gt; 的，通常是当前工作目录。 &lt;code&gt;base&lt;/code&gt; 必须是绝对路径，并且始终假定它引用目录。如果 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 引用相同的目录，则该函数返回 &lt;code&gt;'.'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e221dcc2a55e6ae3990cde11462a83ddb8c59e57" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;a href=&quot;#ticksToNSecs&quot;&gt;&lt;code&gt;ticksToNSecs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ticksToNSecs&quot;&gt; &lt;code&gt;ticksToNSecs&lt;/code&gt; &lt;/a&gt;的相反方向。</target>
        </trans-unit>
        <trans-unit id="c6ea2f4408254d943e5179ee3bbfade7f366fbe9" translate="yes" xml:space="preserve">
          <source>The right part of &lt;code&gt;r&lt;/code&gt; after partitioning.  If &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;. If &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in the left part of &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;.</source>
          <target state="translated">分割后 &lt;code&gt;r&lt;/code&gt; 的右部分。如果 &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt; ， &lt;code&gt;partition&lt;/code&gt; 保留了所有元件的相对排序 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 在 &lt;code&gt;r&lt;/code&gt; 为其 &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; 。如果 &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt; ， &lt;code&gt;partition&lt;/code&gt; 保留了所有元件的相对排序 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 中的左侧部分 &lt;code&gt;r&lt;/code&gt; 为其中 &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74483ebbb544d307348c8757c03b1bb648258bec" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison</source>
          <target state="translated">右边的比较</target>
        </trans-unit>
        <trans-unit id="0e9a080e28a8d91db65b56c19e48812d639eb325" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for equality</source>
          <target state="translated">比较平等的右侧</target>
        </trans-unit>
        <trans-unit id="82b77c8515d584392179571806e80acab0df8e0e" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for ordering</source>
          <target state="translated">右侧的比较,以便订购</target>
        </trans-unit>
        <trans-unit id="ce77342cf014dfbdd37bba884529bb7b1ea8eb76" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator</source>
          <target state="translated">操作员的右侧</target>
        </trans-unit>
        <trans-unit id="9e41eb8c1a87bc5b03b6c14f9d03728097407757" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator (left-hand side is &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">操作者的右手边（左侧是 &lt;code&gt;this&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="44c8baae8e4b1cafc92c8edb1f1a4bc6398dfd3a" translate="yes" xml:space="preserve">
          <source>The right-hand side operand</source>
          <target state="translated">右手边的操作数</target>
        </trans-unit>
        <trans-unit id="ac11224128b70935424423a8a77fd6fd68210ba1" translate="yes" xml:space="preserve">
          <source>The right-hand side operand (&lt;code&gt;Rhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">右侧操作数（ &lt;code&gt;Rhs&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="0295cf674c21bae7e541254ba48b44bd641bdb8f" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the assignment, after the operation has been computed</source>
          <target state="translated">赋值中的右侧类型,在计算出操作后</target>
        </trans-unit>
        <trans-unit id="718e1f58f1f55d464000d479f6fd938c33906894" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the operator</source>
          <target state="translated">右手边类型的操作员</target>
        </trans-unit>
        <trans-unit id="a73d548c23060689342ba25b61016e797895c8bb" translate="yes" xml:space="preserve">
          <source>The right-hand side type involved in the operator</source>
          <target state="translated">运营商所涉及的右侧类型</target>
        </trans-unit>
        <trans-unit id="e3fed9dabe35a6b8579a8bd12124493c72510d8b" translate="yes" xml:space="preserve">
          <source>The right-hand side value in the assignment, after the operator has been evaluated</source>
          <target state="translated">赋值中的右侧值,在运算符被评估后。</target>
        </trans-unit>
        <trans-unit id="cd88512e1e583ed536b72443b9651f20abee0041" translate="yes" xml:space="preserve">
          <source>The routine called when a message is sent to a full mailbox.</source>
          <target state="translated">当一个邮件被发送到一个完整的邮箱时调用的例程。</target>
        </trans-unit>
        <trans-unit id="b66d87a6c0e08abdd807f5a483f6da0a435298a3" translate="yes" xml:space="preserve">
          <source>The routines and algorithms are derived from the</source>
          <target state="translated">这些例程和算法来自于</target>
        </trans-unit>
        <trans-unit id="89f0c0488274c89f59fab106ec127c844449805c" translate="yes" xml:space="preserve">
          <source>The rules for strings are the usual for literals: If it can fit in an &lt;code&gt;int&lt;/code&gt;, it is an &lt;code&gt;int&lt;/code&gt;. Otherwise, it is a &lt;code&gt;long&lt;/code&gt;. But, if the user specifically asks for a &lt;code&gt;long&lt;/code&gt; with the &lt;code&gt;L&lt;/code&gt; suffix, always give the &lt;code&gt;long&lt;/code&gt;. Give an unsigned iff it is asked for with the &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; suffix. Octals created from integers preserve the type of the passed-in integral.</source>
          <target state="translated">字符串规则是文字常识：如果它可以容纳 &lt;code&gt;int&lt;/code&gt; ，则为 &lt;code&gt;int&lt;/code&gt; 。否则，它会很 &lt;code&gt;long&lt;/code&gt; 。但是，如果用户特别要求一个 &lt;code&gt;long&lt;/code&gt; 与 &lt;code&gt;L&lt;/code&gt; 后缀，总是给人 &lt;code&gt;long&lt;/code&gt; 。如果要求使用 &lt;code&gt;U&lt;/code&gt; 或 &lt;code&gt;u&lt;/code&gt; 后缀，请给出未签名的iff 。由整数创建的八进制保留传入的整数的类型。</target>
        </trans-unit>
        <trans-unit id="e0dffdc084b14542b868ac2c2fcdcfbf771ea55f" translate="yes" xml:space="preserve">
          <source>The runtime module exposes information specific to the D runtime code.</source>
          <target state="translated">运行时模块暴露了D运行时代码的特定信息。</target>
        </trans-unit>
        <trans-unit id="1e0c7d670da430e1c2fcc83076d681bba14efcaf" translate="yes" xml:space="preserve">
          <source>The safety level of this function is faked. It shows itself as &lt;code&gt;@trusted pure nothrow&lt;/code&gt; to not break existing code.</source>
          <target state="translated">该功能的安全级别是伪造的。它显示为 &lt;code&gt;@trusted pure nothrow&lt;/code&gt; ，不会破坏现有代码。</target>
        </trans-unit>
        <trans-unit id="269ccafe0cbb6bd48c0c364d60e7c6c6e04d5947" translate="yes" xml:space="preserve">
          <source>The same applies to other &lt;code&gt;Object&lt;/code&gt; methods such as &lt;code&gt;opCmp&lt;/code&gt;, &lt;code&gt;toHash&lt;/code&gt;, etc.</source>
          <target state="translated">这同样适用于其他 &lt;code&gt;Object&lt;/code&gt; 方法，例如 &lt;code&gt;opCmp&lt;/code&gt; ， &lt;code&gt;toHash&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="e9e9404807d647f780072b029fb88dbb6d89a0b9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt;, except that final functions that do not override anything are included.</source>
          <target state="translated">与&lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt;相同，除了包括不覆盖任何内容的最终函数。</target>
        </trans-unit>
        <trans-unit id="93baf85b2a1ff9ebbdedf5ac60d17440ac90bad4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt;, except that final functions that don't override anything return true.</source>
          <target state="translated">与&lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt;相同，除了不覆盖任何内容的最终函数返回true。</target>
        </trans-unit>
        <trans-unit id="484feea935bb2f51a17677737f5a18c29ab34260" translate="yes" xml:space="preserve">
          <source>The same is true for structs.</source>
          <target state="translated">对于结构也是如此。</target>
        </trans-unit>
        <trans-unit id="daa76d61107754eb643bbf2894986cd43d9f6292" translate="yes" xml:space="preserve">
          <source>The same lookup across blocks, scripts, or binary properties, but performed at run-time. This version is provided for cases where &lt;code&gt;name&lt;/code&gt; is not known beforehand; otherwise compile-time checked &lt;a href=&quot;#opDispatch&quot;&gt;&lt;code&gt;opDispatch&lt;/code&gt;&lt;/a&gt; is typically a better choice.</source>
          <target state="translated">跨块，脚本或二进制属性进行相同的查找，但在运行时执行。此版本用于事先不知道 &lt;code&gt;name&lt;/code&gt; 情况；否则，编译时检查的&lt;a href=&quot;#opDispatch&quot;&gt; &lt;code&gt;opDispatch&lt;/code&gt; &lt;/a&gt;通常是更好的选择。</target>
        </trans-unit>
        <trans-unit id="bed255bb45839fece8e5cb2e49994a8474ab1390" translate="yes" xml:space="preserve">
          <source>The saturated result of the operator.</source>
          <target state="translated">运营商的饱和结果。</target>
        </trans-unit>
        <trans-unit id="44ebf5442f3ff515c11231f709e48f19fb0fd8ce" translate="yes" xml:space="preserve">
          <source>The scanner function. It should scan from p1 through p2 - 1.</source>
          <target state="translated">扫描仪功能。它应该从p1到p2-1扫描。</target>
        </trans-unit>
        <trans-unit id="2b5611ba00d0c5303ec080902ad8f7d6474ce6c0" translate="yes" xml:space="preserve">
          <source>The scanning function.</source>
          <target state="translated">扫描功能。</target>
        </trans-unit>
        <trans-unit id="6c94bc26dd8e2388a5758b02c027326a48e92c3c" translate="yes" xml:space="preserve">
          <source>The scheduling priority of this thread.</source>
          <target state="translated">本线程的调度优先级。</target>
        </trans-unit>
        <trans-unit id="bce914b8aac817557e08a2a5b7b1a5b382065247" translate="yes" xml:space="preserve">
          <source>The scope characteristic is inherited, so any classes derived from a scope class are also scope.</source>
          <target state="translated">scope特性是继承的,所以从scope类派生出来的任何类也是scope。</target>
        </trans-unit>
        <trans-unit id="bece65d16e0da3cd8d963615575ef27d8569dde0" translate="yes" xml:space="preserve">
          <source>The second</source>
          <target state="translated">第二种</target>
        </trans-unit>
        <trans-unit id="f0aa270a7ba151a0f73151e3a972f6dc7bf0ee07" translate="yes" xml:space="preserve">
          <source>The second array to compare</source>
          <target state="translated">第二个要比较的数组</target>
        </trans-unit>
        <trans-unit id="970cba63abb463ea9e374f88bdbe56bd7fb71605" translate="yes" xml:space="preserve">
          <source>The second form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;ref&lt;/code&gt;, and has &lt;a href=&quot;#return-ref-parameters&quot;&gt;return ref parameter&lt;/a&gt; semantics with additional &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;scope parameter&lt;/a&gt; semantics.</source>
          <target state="translated">第二种形式将 &lt;code&gt;return&lt;/code&gt; 附加到 &lt;code&gt;ref&lt;/code&gt; ，并具有&lt;a href=&quot;#return-ref-parameters&quot;&gt;return ref参数&lt;/a&gt;语义和其他&lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;范围参数&lt;/a&gt;语义。</target>
        </trans-unit>
        <trans-unit id="061d4f927a4a2679d380b604c58cb6c22d22e3d1" translate="yes" xml:space="preserve">
          <source>The second form of this function is usually not called directly; instead, it is used via &lt;a href=&quot;std_string#format&quot;&gt;&lt;code&gt;std.string.format&lt;/code&gt;&lt;/a&gt;, as shown in the examples below. Supported format characters are 'e', 'f', 'g', 'a', and 's'.</source>
          <target state="translated">通常不直接调用此函数的第二种形式。而是通过&lt;a href=&quot;std_string#format&quot;&gt; &lt;code&gt;std.string.format&lt;/code&gt; 使用&lt;/a&gt;，如以下示例所示。支持的格式字符为&amp;ldquo; e&amp;rdquo;，&amp;ldquo; f&amp;rdquo;，&amp;ldquo; g&amp;rdquo;，&amp;ldquo; a&amp;rdquo;和&amp;ldquo; s&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6175891dc518c6e785380cc43703fbdbef055ecb" translate="yes" xml:space="preserve">
          <source>The second form, &lt;code&gt;goto default;&lt;/code&gt;, transfers to the innermost &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; of an enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">第二种形式， &lt;code&gt;goto default;&lt;/code&gt; 转换为封闭的&lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;的最内部的&lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt;。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1b51588d42d45bcafc26dcdf68b259620359d8f6" translate="yes" xml:space="preserve">
          <source>The second function</source>
          <target state="translated">第二个功能</target>
        </trans-unit>
        <trans-unit id="9a381cf5b12ec2751302d71f1f36bb254a3a2a6d" translate="yes" xml:space="preserve">
          <source>The second makes use of template mixins:</source>
          <target state="translated">第二种是利用模板混搭。</target>
        </trans-unit>
        <trans-unit id="b6d7d023028752f2dd5e8e8741a79baee2991163" translate="yes" xml:space="preserve">
          <source>The second portion of the time;</source>
          <target state="translated">第二部分时间。</target>
        </trans-unit>
        <trans-unit id="d17baa58ea7c9cb2b5fdeeba1668762e0d314080" translate="yes" xml:space="preserve">
          <source>The second range</source>
          <target state="translated">第二个范围</target>
        </trans-unit>
        <trans-unit id="03495ddd562bb985866c15203033cded1697fdb5" translate="yes" xml:space="preserve">
          <source>The second range to be compared.</source>
          <target state="translated">第二个要比较的范围。</target>
        </trans-unit>
        <trans-unit id="17805909c78bc23c485d6d0eee55678a2626d3ec" translate="yes" xml:space="preserve">
          <source>The second range.</source>
          <target state="translated">第二个范围。</target>
        </trans-unit>
        <trans-unit id="b5c0d389b19e84b52a4b93582ba1ef6275bab88b" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">第二个，将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;设置为第二个。</target>
        </trans-unit>
        <trans-unit id="ca5f5f8367bfce8ad586cc8594d3c281eb469bd2" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的秒设置为秒。</target>
        </trans-unit>
        <trans-unit id="996418c92be5b452f3de4ff986e1cee8b8da9918" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">第二个将这个&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;设置为第二个。</target>
        </trans-unit>
        <trans-unit id="fb3c67e4431bd2d01f2e0a28a1a5ab4c776bb0a0" translate="yes" xml:space="preserve">
          <source>The second type to receive the type name for</source>
          <target state="translated">第二种类型接收类型名称为</target>
        </trans-unit>
        <trans-unit id="572604b99f4f13c97178a7bb83d0a01c9c1fdbf8" translate="yes" xml:space="preserve">
          <source>The second version of &lt;code&gt;AutoImplement&lt;/code&gt; automatically implements &lt;code&gt;Interface&lt;/code&gt;, while deriving from &lt;code&gt;BaseClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AutoImplement&lt;/code&gt; 的第二个版本在继承自 &lt;code&gt;BaseClass&lt;/code&gt; 的同时自动实现 &lt;code&gt;Interface&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9922ebb56662094439fd0982652299a78a77cb79" translate="yes" xml:space="preserve">
          <source>The second version of the function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.  In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">该函数的第二个版本以 &lt;code&gt;printf&lt;/code&gt; 样式的方式将数据记录到 &lt;code&gt;sharedLog&lt;/code&gt; 。为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;sharedLog&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。另外，该 &lt;code&gt;LogLevel&lt;/code&gt; 的必须大于或等于比所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;stdSharedLogger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fca00f96f63ee8d1d8ffcc6e490cc9b3f2af7ff1" translate="yes" xml:space="preserve">
          <source>The second version returns the number of times &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;haystack&lt;/code&gt;. Throws an exception if &lt;code&gt;needle.empty&lt;/code&gt;, as the count of the empty range in any range would be infinite. Overlapped counts are not considered, for example &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">第二个版本返回的次数 &lt;code&gt;needle&lt;/code&gt; 发生在 &lt;code&gt;haystack&lt;/code&gt; 。如果 &lt;code&gt;needle.empty&lt;/code&gt; 抛出异常，因为任何范围内的空范围的计数都是无限的。不考虑重叠计数，例如 &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ，而不是 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0ad6e5d9828f85ec68413d4266b0a775c993286" translate="yes" xml:space="preserve">
          <source>The second way is to cast data to immutable. When doing so, it is up to the programmer to ensure that any mutable references to the same data are not used to modify the data after the cast.</source>
          <target state="translated">第二种方法是将数据转为不可变。在这样做的时候,程序员要确保任何对同一数据的可变引用不会在投递后被用来修改数据。</target>
        </trans-unit>
        <trans-unit id="98a2a2f9f0974d5cf21ef2c42fb8d7b511ec7622" translate="yes" xml:space="preserve">
          <source>The second way is to use the precision specifier. The length comes first, followed by the pointer:</source>
          <target state="translated">第二种方法是使用精度指定器。先有长度,后有指针。</target>
        </trans-unit>
        <trans-unit id="6258e42911fadc579ef629cac8b879505c815405" translate="yes" xml:space="preserve">
          <source>The second will queue readers if there are any writers queued. Writers are passed through one at a time, and once there are no writers present, all queued readers will be alerted.</source>
          <target state="translated">第二种会在有作家排队的情况下,对读者进行排队。作家一次通过一个,一旦没有作家出现,所有排队的读者都会被提醒。</target>
        </trans-unit>
        <trans-unit id="222f9be8417077b869fc4ec2ffe85613dca810b0" translate="yes" xml:space="preserve">
          <source>The selector parameter for Objective-C methods.</source>
          <target state="translated">Objective-C方法的选择器参数。</target>
        </trans-unit>
        <trans-unit id="c7b62a580f33ebf95a2e808ad6d0fddcde51f3ed" translate="yes" xml:space="preserve">
          <source>The semantics of a bidirectional range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">双向范围（在编译过程中不可检查）的语义假定如下（ &lt;code&gt;r&lt;/code&gt; 是类型 &lt;code&gt;R&lt;/code&gt; 的对象）：</target>
        </trans-unit>
        <trans-unit id="17817f0aec7117e53dffc5a42bb0ce81b624678f" translate="yes" xml:space="preserve">
          <source>The semantics of a forward range (not checkable during compilation) are the same as for an input range, with the additional requirement that backtracking must be possible by saving a copy of the range object with &lt;code&gt;save&lt;/code&gt; and using it later.</source>
          <target state="translated">正向范围的语义（在编译过程中不可检查）与输入范围的语义相同，另外还要求必须通过使用 &lt;code&gt;save&lt;/code&gt; 保存范围对象的副本并稍后使用它才能实现回溯。</target>
        </trans-unit>
        <trans-unit id="9ad7ef472479146863a20e103ea6caeaec90cbb2" translate="yes" xml:space="preserve">
          <source>The semantics of a module are not affected by what imports it.</source>
          <target state="translated">模块的语义不受导入模块的内容影响。</target>
        </trans-unit>
        <trans-unit id="1896dacb2ba5ac95d6272bdae742dc30f30d5318" translate="yes" xml:space="preserve">
          <source>The semantics of a random-access range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">假定随机访问范围的语义（在编译期间不可检查）如下（ &lt;code&gt;r&lt;/code&gt; 是类型 &lt;code&gt;R&lt;/code&gt; 的对象）：</target>
        </trans-unit>
        <trans-unit id="a29d19e0a1c63b8d3f0187e1b535c432966dec4b" translate="yes" xml:space="preserve">
          <source>The semaphore module provides a general use semaphore for synchronization.</source>
          <target state="translated">旗语模块提供了一个用于同步的通用旗语。</target>
        </trans-unit>
        <trans-unit id="0cb8e57171fd0fa8e03b5c22f3ff466ddf864a6e" translate="yes" xml:space="preserve">
          <source>The sequence of tokens is parsed to form syntax trees.</source>
          <target state="translated">对标记的序列进行解析,形成语法树。</target>
        </trans-unit>
        <trans-unit id="438ac8d829e20acc25c07ebf7273d7538987132c" translate="yes" xml:space="preserve">
          <source>The sequence to check for the &lt;code&gt;BOM&lt;/code&gt;</source>
          <target state="translated">检查 &lt;code&gt;BOM&lt;/code&gt; 的顺序</target>
        </trans-unit>
        <trans-unit id="aec41afa837cbb030bd78ed48712b8225ab720a9" translate="yes" xml:space="preserve">
          <source>The short symbol for this option</source>
          <target state="translated">此选项的简称为</target>
        </trans-unit>
        <trans-unit id="14ab0adc14c1851e03d1a893322666eb1605f066" translate="yes" xml:space="preserve">
          <source>The shuffled random-access range.</source>
          <target state="translated">洗牌后的随机访问范围。</target>
        </trans-unit>
        <trans-unit id="b938bafa6a37b04fed1bbf8b758bf0a54b828b83" translate="yes" xml:space="preserve">
          <source>The sign of &amp;Gamma;(x).</source>
          <target state="translated">&amp;Gamma;（x）的符号。</target>
        </trans-unit>
        <trans-unit id="691fa1f516ff445955097300abb84801c17ce9af" translate="yes" xml:space="preserve">
          <source>The signature of this function should be:</source>
          <target state="translated">该函数的签名应是:</target>
        </trans-unit>
        <trans-unit id="1c551bae643970a0fd547169fd9a9d141dddbbc8" translate="yes" xml:space="preserve">
          <source>The signed type is converted to the unsigned type.</source>
          <target state="translated">符号类型转换为无符号类型。</target>
        </trans-unit>
        <trans-unit id="ee800310ad7741a1c2a988b7683af21966b44816" translate="yes" xml:space="preserve">
          <source>The similarity per &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; has an issue in that it grows with the lengths of the two strings, even though the strings are not actually very similar. For example, the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; is increasingly similar with the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; as more instances of &lt;code&gt;&quot;world&quot;&lt;/code&gt; are appended. To prevent that, &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; computes a normalized version of the similarity that is computed as &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt;. The function &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (a so-called normalized kernel) is bounded in &lt;code&gt;[0, 1]&lt;/code&gt;, reaches &lt;code&gt;0&lt;/code&gt; only for ranges that don't match in any position, and &lt;code&gt;1&lt;/code&gt; only for identical ranges.</source>
          <target state="translated">每个 &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; 的相似性是一个问题，即使两个字符串实际上并不十分相似，它也会随着两个字符串的长度而增长。例如，范围 &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; 与范围 &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; 的范围越来越相似，因为附加了更多的 &lt;code&gt;&quot;world&quot;&lt;/code&gt; 实例。为防止这种情况， &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; 计算相似度的规范化版本，计算为 &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt; 。函数 &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; （所谓的归一化内核）的边界是 &lt;code&gt;[0, 1]&lt;/code&gt; ，到达 &lt;code&gt;0&lt;/code&gt; 仅对范围不匹配在任何位置，和 &lt;code&gt;1&lt;/code&gt; 只为相同范围。</target>
        </trans-unit>
        <trans-unit id="88799e576696dc3374489d7e5f75d72056dc1dfa" translate="yes" xml:space="preserve">
          <source>The simplest form of importing is to just list the modules being imported:</source>
          <target state="translated">最简单的导入方式是只列出被导入的模块。</target>
        </trans-unit>
        <trans-unit id="e2009ad4b4c0d89d88051ad98575cc82bbbcf921" translate="yes" xml:space="preserve">
          <source>The simplest immutable declarations use it as a storage class. It can be used to declare manifest constants.</source>
          <target state="translated">最简单的不可变声明将它作为一个存储类。它可以用来声明清单常量。</target>
        </trans-unit>
        <trans-unit id="b20f562102f67ba45af181d477da8263c4656fad" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;bringToFront&lt;/code&gt; is for rotating elements in a buffer. For example:</source>
          <target state="translated">&lt;code&gt;bringToFront&lt;/code&gt; 最简单的用法是旋转缓冲区中的元素。例如：</target>
        </trans-unit>
        <trans-unit id="87bc4b882bb607c1c565d6a1ffe9da4b18a9935d" translate="yes" xml:space="preserve">
          <source>The sine and cosine of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 的正弦和余弦。</target>
        </trans-unit>
        <trans-unit id="4beb2d03043706421491257b91174cce75401dc3" translate="yes" xml:space="preserve">
          <source>The single element to check.</source>
          <target state="translated">要检查的单一要素。</target>
        </trans-unit>
        <trans-unit id="e20b632a66e4a0973d296fc8dc97c6e7878340fa" translate="yes" xml:space="preserve">
          <source>The single needle to check, which may be either a single element or an input range of elements.</source>
          <target state="translated">要检查的单针,可以是单个元素,也可以是一个元素的输入范围。</target>
        </trans-unit>
        <trans-unit id="936e0c490ea32a66488b88e6407723c37e53055d" translate="yes" xml:space="preserve">
          <source>The size in bytes of the block to add. If sz is zero then the no operation will occur. If p is null then sz must be zero.</source>
          <target state="translated">要添加的块的字节数。如果sz为0,那么将进行no操作。如果p为空,那么sz必须为零。</target>
        </trans-unit>
        <trans-unit id="d5f548166d575892e245b5d531ead88e195d968a" translate="yes" xml:space="preserve">
          <source>The size in bytes of the extended memory block referenced by p or zero if no extension occurred.</source>
          <target state="translated">p引用的扩展内存块的大小,以字节为单位,如果没有发生扩展,则为零。</target>
        </trans-unit>
        <trans-unit id="f5a5bf7ffaae9ea0e47a648c75ab38577c22cdee" translate="yes" xml:space="preserve">
          <source>The size in bytes of the memory block referenced by p or zero on error.</source>
          <target state="translated">p引用的内存块的大小,以字节为单位,错误时为0。</target>
        </trans-unit>
        <trans-unit id="47c428b4443aaffa87ab01d194f64c1d9938dadd" translate="yes" xml:space="preserve">
          <source>The size of each block can be selected either during compilation or at run time. Statically-known block sizes are frequent in practice and yield slightly better performance. To choose a block size statically, pass it as the &lt;code&gt;blockSize&lt;/code&gt; parameter as in &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt;. To choose a block size parameter, use &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; and pass the block size to the constructor.</source>
          <target state="translated">可以在编译期间或运行时选择每个块的大小。静态已知的块大小在实践中经常出现，并且会产生更好的性能。若要静态选择块大小，请像 &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt; 中一样将其作为 &lt;code&gt;blockSize&lt;/code&gt; 参数传递。要选择块大小参数，请使用 &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; 并将块大小传递给构造函数。</target>
        </trans-unit>
        <trans-unit id="a8db79a8cc24d1fb50ebc2a5392b4de19bea96fb" translate="yes" xml:space="preserve">
          <source>The size of each chunk</source>
          <target state="translated">每块的大小</target>
        </trans-unit>
        <trans-unit id="812d083ae4b6202df6ef9285312c396838fbce8c" translate="yes" xml:space="preserve">
          <source>The size of file in bytes.</source>
          <target state="translated">文件的大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="5299bf2c3bb77629866128b69aa3cd98cc936e97" translate="yes" xml:space="preserve">
          <source>The size of the allocated length at the end depends on the block size:</source>
          <target state="translated">末尾分配长度的大小取决于块的大小。</target>
        </trans-unit>
        <trans-unit id="a507a2fd30a698197eb87aec60496407de2cc9b4" translate="yes" xml:space="preserve">
          <source>The size of the buffer to store the evaluated elements.</source>
          <target state="translated">缓冲区的大小,用于存储被评估的元素。</target>
        </trans-unit>
        <trans-unit id="f51f328cc82fa5e1146c1bcd8d39f77ba7f1a772" translate="yes" xml:space="preserve">
          <source>The size of the chunks</source>
          <target state="translated">块状物的大小</target>
        </trans-unit>
        <trans-unit id="f95ddc1cb4621988d676a326385232a6d69ff6df" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buf&lt;/code&gt; containing the formatted string.</source>
          <target state="translated">包含格式化字符串的 &lt;code&gt;buf&lt;/code&gt; 切片。</target>
        </trans-unit>
        <trans-unit id="c76fb8fffafacca9cf978997fee5c7ec6adb0669" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buffer&lt;/code&gt; containing the data that was actually read. This will be shorter than &lt;code&gt;buffer&lt;/code&gt; if EOF was reached before the buffer could be filled.</source>
          <target state="translated">包含实际读取的数据的 &lt;code&gt;buffer&lt;/code&gt; 片。如果在填充缓冲区之前达到了EOF，则它会比 &lt;code&gt;buffer&lt;/code&gt; 短。</target>
        </trans-unit>
        <trans-unit id="25175c4c04d78f4f21e72598ea69bd88d569188a" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;target&lt;/code&gt; containing the copied elements.</source>
          <target state="translated">包含复制元素的 &lt;code&gt;target&lt;/code&gt; 切片。</target>
        </trans-unit>
        <trans-unit id="ad4934ab24ff890e3942dd0930dacb128284b747" translate="yes" xml:space="preserve">
          <source>The slice of buffer containing the decoded result.</source>
          <target state="translated">包含解码结果的缓冲区片断。</target>
        </trans-unit>
        <trans-unit id="2493c4fc7b08258cd8cb15270e3f883e67df77ba" translate="yes" xml:space="preserve">
          <source>The slice of buffer that contains the encoded string.</source>
          <target state="translated">包含编码字符串的缓冲区片断。</target>
        </trans-unit>
        <trans-unit id="ad35a55effab17cdb298d4bb62b7946a0a05ee95" translate="yes" xml:space="preserve">
          <source>The slice on the left and any slices on the right must not overlap. All operands are evaluated exactly once, even if the array slice has zero elements in it.</source>
          <target state="translated">左边的分片和右边的分片不能重叠。所有操作数都被精确地评估一次,即使数组分片中的元素为零。</target>
        </trans-unit>
        <trans-unit id="7d8c2f61d4c506e7a291057e4bc000a710aed4c4" translate="yes" xml:space="preserve">
          <source>The slice's usable size will not match the block size. Use &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; to retrieve actual usable capacity.</source>
          <target state="translated">切片的可用大小与块大小不匹配。使用&lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;检索实际可用容量。</target>
        </trans-unit>
        <trans-unit id="bba8f7aecbe8029037e1ea79aca03fd651b20234" translate="yes" xml:space="preserve">
          <source>The smallest size that can be allocated is two words (16 bytes on 64-bit systems, 8 bytes on 32-bit systems). This is because the free list management needs two words (one for the length, the other for the next pointer in the singly-linked list).</source>
          <target state="translated">可以分配的最小大小是两个字(64位系统为16字节,32位系统为8字节)。这是因为自由列表管理需要两个字(一个用于长度,另一个用于单链路列表中的下一个指针)。</target>
        </trans-unit>
        <trans-unit id="c8f2935f9d51846f40ce3a8ff14ea8411e17c417" translate="yes" xml:space="preserve">
          <source>The so-called &quot;all-lengths gap-weighted string kernel&quot; computes a similarity measure between &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; based on all of their common subsequences of all lengths. Gapped subsequences are also included.</source>
          <target state="translated">所谓的&amp;ldquo;全长度间隙加权字符串内核&amp;rdquo;根据所有长度的所有公共子序列计算 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; 之间的相似性。缺口子序列也包括在内。</target>
        </trans-unit>
        <trans-unit id="b69c2f4a1b196deb3a8f2c9757a25cc977da4151" translate="yes" xml:space="preserve">
          <source>The solution is to use exception handling to report errors. All errors are objects derived from abstract class &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;Error&lt;/code&gt; has a pure virtual function called toString() which produces a &lt;code&gt;string&lt;/code&gt; with a human readable description of the error.</source>
          <target state="translated">解决方案是使用异常处理报告错误。所有错误都是从抽象类 &lt;code&gt;Error&lt;/code&gt; 派生的对象。 &lt;code&gt;Error&lt;/code&gt; 具有称为toString（）的纯虚函数，该函数会生成带有错误的人类可读描述的 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="869eb1c2ddd5095ece630ff3cd9aa908770a28d3" translate="yes" xml:space="preserve">
          <source>The sorted alias sequence</source>
          <target state="translated">排序后的别名序列</target>
        </trans-unit>
        <trans-unit id="5890e22a27a487c3d84b74c6aadd83e7f574f4f1" translate="yes" xml:space="preserve">
          <source>The sorted, left-hand side of the random access range to be sorted.</source>
          <target state="translated">被排序的,要排序的随机访问范围的左侧。</target>
        </trans-unit>
        <trans-unit id="327825eee250d31d85788280f6649c7f91900518" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;Tuple&lt;/code&gt; to assign from. Each element of the source &lt;code&gt;Tuple&lt;/code&gt; must be implicitly assignable to each respective element of the target &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">要分配的源 &lt;code&gt;Tuple&lt;/code&gt; 。源 &lt;code&gt;Tuple&lt;/code&gt; 每个元素必须隐式地可分配给目标 &lt;code&gt;Tuple&lt;/code&gt; 每个元素。</target>
        </trans-unit>
        <trans-unit id="5030b9b136204dc20df5dd72c92bea98a422bbd5" translate="yes" xml:space="preserve">
          <source>The source file is checked to see what character set it is, and the appropriate scanner is loaded. ASCII and UTF formats are accepted.</source>
          <target state="translated">检查源文件,看它是什么字符集,并加载适当的扫描仪。接受ASCII和UTF格式。</target>
        </trans-unit>
        <trans-unit id="dfdc9b54ae3eba8ba8704bc6e8f6a3bd3398e870" translate="yes" xml:space="preserve">
          <source>The source file is divided up into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="translated">源文件分为一系列令牌。&lt;a href=&quot;lex#specialtokens&quot;&gt;特殊标记&lt;/a&gt;被其他标记替换。&lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;被处理并删除。</target>
        </trans-unit>
        <trans-unit id="81874a58d9273e37ffa0ff4c91450536e1226f36" translate="yes" xml:space="preserve">
          <source>The source file name of the caller.</source>
          <target state="translated">调用者的源文件名。</target>
        </trans-unit>
        <trans-unit id="63c931360a6dacfd65be2e57e259c4c016ac5c72" translate="yes" xml:space="preserve">
          <source>The source file of the caller.</source>
          <target state="translated">调用者的源文件。</target>
        </trans-unit>
        <trans-unit id="5e1d1c43260b49fce3e8356d81c8f39a6eaf6f86" translate="yes" xml:space="preserve">
          <source>The source location.</source>
          <target state="translated">来源地;</target>
        </trans-unit>
        <trans-unit id="57597d8f1413ea294f9a97a53e7900b691ef6e36" translate="yes" xml:space="preserve">
          <source>The source object</source>
          <target state="translated">源对象</target>
        </trans-unit>
        <trans-unit id="a8df6910eb6a7836cdf1dd95711fe44c7f692e87" translate="yes" xml:space="preserve">
          <source>The source of the cast</source>
          <target state="translated">铸件的来源</target>
        </trans-unit>
        <trans-unit id="79f7b5f01174bbbd5d3e9abcd1ae8cab2d28d824" translate="yes" xml:space="preserve">
          <source>The source range.</source>
          <target state="translated">源范围。</target>
        </trans-unit>
        <trans-unit id="139f7114b9b6fbeefdd429dfd8ce09ec26e9b7ae" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, all followed by &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">源文本从其源表示形式解码为Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Characters&lt;/i&gt;&lt;/a&gt;。该&lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;字符&lt;/i&gt;&lt;/a&gt; s的进一步分为：&lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;空白符&lt;/i&gt;&lt;/a&gt;，&lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;行尾&lt;/i&gt;&lt;/a&gt;，&lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;评论&lt;/i&gt;&lt;/a&gt; S，&lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; S，&lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;令牌&lt;/i&gt;&lt;/a&gt; S，all，然后&lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21e734d8ecbd4a33f2c2bfd5df8fb1b69390624d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch technique, i.e., the lexical analyzer makes the longest token it can. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="translated">使用最大的munch技术将源文本拆分为标记，即，词法分析器会尽可能地使用最长的标记。例如， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 是右移标记，比标记大两个。此规则有两个例外：</target>
        </trans-unit>
        <trans-unit id="262fd934f3ad11cda48e320770c23b6cbce4d978" translate="yes" xml:space="preserve">
          <source>The source text is terminated by whichever comes first.</source>
          <target state="translated">源文以先到者为结束。</target>
        </trans-unit>
        <trans-unit id="81738bf1b1d3def6ac2869102bc650c16fdd9cf9" translate="yes" xml:space="preserve">
          <source>The source type in the conversion or comparison</source>
          <target state="translated">转换或比较中的源类型</target>
        </trans-unit>
        <trans-unit id="7363cb9e0bea89a84f2ef7322159cb48984847e8" translate="yes" xml:space="preserve">
          <source>The specific &lt;code&gt;LogLevel&lt;/code&gt; used for logging the log message.</source>
          <target state="translated">用于记录日志消息的特定 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02d763555333f9cf77c0541a37bf5b34481db397" translate="yes" xml:space="preserve">
          <source>The specification for the form of embedded documentation comments only specifies how information is to be presented to the compiler. It is implementation-defined how that information is used and the form of the final presentation. Whether the final presentation form is an HTML web page, a man page, a PDF file, etc. is not specified as part of the D Programming Language.</source>
          <target state="translated">嵌入文档注释的形式规范只规定了如何向编译器提供信息。如何使用这些信息以及最终呈现的形式是由实现定义的。最终的呈现形式是HTML网页、man页、PDF文件等,并没有作为D编程语言的一部分来规定。</target>
        </trans-unit>
        <trans-unit id="c631213db2c74550b3a422d0caf42968e12b014d" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 的平方根。</target>
        </trans-unit>
        <trans-unit id="b54a2e145a2a6ad88bd2025575b8d9841ee25294" translate="yes" xml:space="preserve">
          <source>The squared modulus of &lt;code&gt;z&lt;/code&gt;. For genericity, if called on a real number, returns its square.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 的平方模。对于通用性，如果调用实数，则返回其平方。</target>
        </trans-unit>
        <trans-unit id="d04cf6152ee5948faeb5107c99bbd4c4ee9e3f00" translate="yes" xml:space="preserve">
          <source>The stack and/or registers are being scanned.</source>
          <target state="translated">栈和/或寄存器正在被扫描。</target>
        </trans-unit>
        <trans-unit id="7f3ea7f5b668b927908903c59ab3b69fcb5af861" translate="yes" xml:space="preserve">
          <source>The stack size for this fiber.</source>
          <target state="translated">该光纤的堆栈尺寸。</target>
        </trans-unit>
        <trans-unit id="d77b689dcb1ab13845e33f5ac0d239d2be984a77" translate="yes" xml:space="preserve">
          <source>The stack size for this thread.</source>
          <target state="translated">本线程的堆栈大小。</target>
        </trans-unit>
        <trans-unit id="1902c662d9b13b82fe81369d128dde4e10ffcdaa" translate="yes" xml:space="preserve">
          <source>The stack trace of where the error happened. This is an opaque object that can either be converted to &lt;code&gt;string&lt;/code&gt;, or iterated over with &lt;code&gt; foreach&lt;/code&gt; to extract the items in the stack trace (as strings).</source>
          <target state="translated">错误发生位置的堆栈跟踪。这是一个不透明的对象，可以将其转换为 &lt;code&gt;string&lt;/code&gt; ，或者使用 &lt;code&gt; foreach&lt;/code&gt; 进行迭代以提取堆栈跟踪中的项（作为字符串）。</target>
        </trans-unit>
        <trans-unit id="9f20dc3ac3213d71596e365d3a32376deda65355" translate="yes" xml:space="preserve">
          <source>The stack variables referenced by a nested function are still valid even after the function exits (this is different from D 1.0). This is called a</source>
          <target state="translated">嵌套函数引用的堆栈变量即使在函数退出后仍然有效(这与D 1.0不同)。这就是所谓的</target>
        </trans-unit>
        <trans-unit id="813353f101357b03d0b61c073a4c5ccf1975eaf3" translate="yes" xml:space="preserve">
          <source>The standard HTTP methods : &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616 Section 5.1.1&lt;/a&gt;</source>
          <target state="translated">标准的HTTP方法：&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616第5.1.1节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5be2cd87a2b0f4860fcc1853c1fefdfb3d5a3f6e" translate="yes" xml:space="preserve">
          <source>The standard error stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's error stream.</source>
          <target state="translated">子进程的标准错误流。这可以是打开以进行写入的任何&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;。默认情况下，子进程继承父进程的错误流。</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">标准误差流。</target>
        </trans-unit>
        <trans-unit id="28e8c3771deea57b1287ddecdda74142b64d7ee8" translate="yes" xml:space="preserve">
          <source>The standard input stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for reading. By default the child process inherits the parent's input stream.</source>
          <target state="translated">子进程的标准输入流。这可以是打开以读取的任何&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;。默认情况下，子进程继承父进程的输入流。</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">标准输入流。</target>
        </trans-unit>
        <trans-unit id="7f5d48c8b0f2de69f4c747237a77a2d1bfba7b08" translate="yes" xml:space="preserve">
          <source>The standard library lends a hand for comparing strings with mixed encodings (by transparently decoding, see &lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt;&lt;code&gt;std.algorithm.cmp&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;case-insensitive comparison&lt;/a&gt; and &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;normalization&lt;/a&gt;.</source>
          <target state="translated">标准库有助于比较混合编码的字符串（通过透明解码，请参见&lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt; &lt;code&gt;std.algorithm.cmp&lt;/code&gt; &lt;/a&gt;），&lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;不区分大小写的比较&lt;/a&gt;和&lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;规范化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d461322cb73ba656cc10ee6e78ac236193d95ae6" translate="yes" xml:space="preserve">
          <source>The standard output stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's output stream.</source>
          <target state="translated">子进程的标准输出流。这可以是打开以进行写入的任何&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;。默认情况下，子进程继承父进程的输出流。</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">标准输出流。</target>
        </trans-unit>
        <trans-unit id="21e7fda428c2c6b1ed80304e44601e7fae93a662" translate="yes" xml:space="preserve">
          <source>The start tag of the element</source>
          <target state="translated">元素的起始标签</target>
        </trans-unit>
        <trans-unit id="e872d9d6a6689ad057f6c088df86c8dbaa1e7c70" translate="yes" xml:space="preserve">
          <source>The starting point of the interval. It is included in the interval.</source>
          <target state="translated">区间的起点。它包括在区间内。</target>
        </trans-unit>
        <trans-unit id="3554fc05aa3ab3a9ddf7ec9973a0bf7f4072e5a0" translate="yes" xml:space="preserve">
          <source>The starting value.</source>
          <target state="translated">起始值;</target>
        </trans-unit>
        <trans-unit id="a84bd1411e0ff3c732833affc83038a36b88c2e4" translate="yes" xml:space="preserve">
          <source>The state of the sequence is stored as a &lt;code&gt;Tuple&lt;/code&gt; so it can be heterogeneous.</source>
          <target state="translated">序列的状态存储为 &lt;code&gt;Tuple&lt;/code&gt; 因此它可以是异构的。</target>
        </trans-unit>
        <trans-unit id="a8013cbe10851e46bc860bd1d31ef9871f35e223" translate="yes" xml:space="preserve">
          <source>The state of this fiber as an enumerated value.</source>
          <target state="translated">该光纤的状态为一个枚举值。</target>
        </trans-unit>
        <trans-unit id="debdb4248e291669b86fe314e231ec5f465f64cb" translate="yes" xml:space="preserve">
          <source>The std time to convert.</source>
          <target state="translated">转换的标准时间。</target>
        </trans-unit>
        <trans-unit id="e0b383e1171d8d015f97f2490da3a859a852e7d9" translate="yes" xml:space="preserve">
          <source>The stored &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">存储的 &lt;code&gt;Logger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d23198b78726b12c064950153015ab0cde6faecb" translate="yes" xml:space="preserve">
          <source>The strategy for finding the next available block is first fit.</source>
          <target state="translated">寻找下一个可用区块的策略是先配合。</target>
        </trans-unit>
        <trans-unit id="c2420fb1448496dbbd08ceea8e09dc60562adfb8" translate="yes" xml:space="preserve">
          <source>The stream to pass to INTERLEAVEFUNCTION.</source>
          <target state="translated">要传递给INTERLEAVEFUNCTION的流。</target>
        </trans-unit>
        <trans-unit id="18822dcb8b0bc3c64136bcaebcbf45df0cd6a713" translate="yes" xml:space="preserve">
          <source>The string</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="e64ff94f3ecfd8fab9d37892f66980e617d6433b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;command&lt;/code&gt; is passed verbatim to the shell, and is therefore subject to its rules about command structure, argument/filename quoting and escaping of special characters. The path to the shell executable defaults to &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;command&lt;/code&gt; 是逐字传递到外壳程序的，因此要遵守其有关命令结构，参数/文件名引号和特殊字符转义的规则。Shell可执行文件的路径默认为&lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2bf86f45ac17363df2917e94c577fdefa4162b88" translate="yes" xml:space="preserve">
          <source>The string indicating which characters to replace and what to replace them with. It is generated by &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串，指示要替换的字符以及替换的字符。它由&lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; &lt;/a&gt;生成。</target>
        </trans-unit>
        <trans-unit id="f0533873999a54cfe4dbbd386fac2585e64d8e51" translate="yes" xml:space="preserve">
          <source>The string is meant to be human readable, not machine parseable (e.g. whether there is an &lt;code&gt;'s'&lt;/code&gt; on the end of the unit name usually depends on whether it's plural or not, and empty units are not included unless the Duration is &lt;code&gt;zero&lt;/code&gt;). Any code needing a specific string format should use &lt;code&gt;total&lt;/code&gt; or &lt;code&gt;split&lt;/code&gt; to get the units needed to create the desired string format and create the string itself.</source>
          <target state="translated">该字符串应是人类可读的，而不是机器可解析的（例如，单元名称末尾是否带有 &lt;code&gt;'s'&lt;/code&gt; 通常取决于其是否为复数形式，并且除非Duration &lt;code&gt;zero&lt;/code&gt; 否则不包括空单元）。任何需要特定字符串格式的代码都应使用 &lt;code&gt;total&lt;/code&gt; 或 &lt;code&gt;split&lt;/code&gt; 来获得创建所需字符串格式和创建字符串本身所需的单位。</target>
        </trans-unit>
        <trans-unit id="2bd07e9629d13f3f409b884d3ffac3a7eb0da845" translate="yes" xml:space="preserve">
          <source>The string literal specifies a linker directive to be embedded in the generated object file.</source>
          <target state="translated">字符串指定要嵌入到生成的对象文件中的链接器指令。</target>
        </trans-unit>
        <trans-unit id="32d9e6c3c8e59228cc1e78ece5ad6aef58df9887" translate="yes" xml:space="preserve">
          <source>The string literals are assembled as UTF-8 char arrays, and the postfix is applied to convert to wchar or dchar as necessary as a final step.</source>
          <target state="translated">字符串被组装成UTF-8字符数组,并在最后一步应用后缀来转换为wchar或dchar。</target>
        </trans-unit>
        <trans-unit id="e1f9801101f016db2a559c014cb349546f881701" translate="yes" xml:space="preserve">
          <source>The string representation of this &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;Tuple&lt;/code&gt; 的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="95ecc1c83a5bc8c9a30b488436872240eb5cf883" translate="yes" xml:space="preserve">
          <source>The string that conventionally marks the end of all options (default '--').</source>
          <target state="translated">习惯上标记所有选项结束的字符串(默认为'--')。</target>
        </trans-unit>
        <trans-unit id="a364f528b991ce1bd157c8e5da1cb5665c7d72c5" translate="yes" xml:space="preserve">
          <source>The string to be decoded</source>
          <target state="translated">要解码的字符串</target>
        </trans-unit>
        <trans-unit id="a6de95ac63fa71760fd1a5b11770046f783a2524" translate="yes" xml:space="preserve">
          <source>The string to be encoded</source>
          <target state="translated">要编码的字符串</target>
        </trans-unit>
        <trans-unit id="e2b9d608f0fe83dbf1e7d9c07afcec863203911e" translate="yes" xml:space="preserve">
          <source>The string to capitalize.</source>
          <target state="translated">要大写的字符串。</target>
        </trans-unit>
        <trans-unit id="cf1478823e2820a59dba10485e438b40c5348725" translate="yes" xml:space="preserve">
          <source>The string to center</source>
          <target state="translated">绳子对中</target>
        </trans-unit>
        <trans-unit id="2e9ccd0a631efea8fdc72a8c62875a331c029bd3" translate="yes" xml:space="preserve">
          <source>The string to demangle.</source>
          <target state="translated">要解开的绳子。</target>
        </trans-unit>
        <trans-unit id="b67968a1752f9ee5eb2c12fda8191f64a6136ec4" translate="yes" xml:space="preserve">
          <source>The string to parse</source>
          <target state="translated">要解析的字符串</target>
        </trans-unit>
        <trans-unit id="5681bac273a271a57db9a94a9ee8c1380568e850" translate="yes" xml:space="preserve">
          <source>The string to return the representation of.</source>
          <target state="translated">返回表示的字符串。</target>
        </trans-unit>
        <trans-unit id="6f72b4c4ff92e79f46043b6ac90fd712bc168dfd" translate="yes" xml:space="preserve">
          <source>The string used to separate the elements of an array or associative array (default is &quot;&quot; which means the elements are separated by whitespace).</source>
          <target state="translated">用于分隔数组或关联数组元素的字符串(默认为&quot;&quot;,表示元素用空格分隔)。</target>
        </trans-unit>
        <trans-unit id="555d16dee4415f5ab0acc21725fda20143e994af" translate="yes" xml:space="preserve">
          <source>The strip group of functions allow stripping of either leading, trailing, or both leading and trailing elements.</source>
          <target state="translated">strip函数组允许对前导元素、尾部元素或前导元素和尾部元素进行剥离。</target>
        </trans-unit>
        <trans-unit id="58b660c2a16b28679d8eef710bda4717a0e26225" translate="yes" xml:space="preserve">
          <source>The structs &lt;code&gt;Yes&lt;/code&gt; and &lt;code&gt;No&lt;/code&gt; are provided as shorthand for &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; and &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; and are preferred for brevity and readability. These convenience structs mean it is usually unnecessary and counterproductive to create an alias of a &lt;code&gt;Flag&lt;/code&gt; as a way of avoiding typing out the full type while specifying the affirmative or negative options.  Passing categorical data by means of unstructured &lt;code&gt;bool&lt;/code&gt; parameters is classified under &quot;simple-data coupling&quot; by Steve McConnell in the &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;Code Complete&lt;/a&gt; book, along with three other kinds of coupling. The author argues citing several studies that coupling has a negative effect on code quality. &lt;code&gt;Flag&lt;/code&gt; offers a simple structuring method for passing yes/no flags to APIs.</source>
          <target state="translated">提供的 &lt;code&gt;Yes&lt;/code&gt; 和 &lt;code&gt;No&lt;/code&gt; 结构是 &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; 和 &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; 简写，为简洁起见和可读性，它们是首选。这些便利结构意味着创建 &lt;code&gt;Flag&lt;/code&gt; 的别名通常是不必要的且适得其反，从而避免在指定肯定或否定选项时避免键入完整类型。借助非结构化 &lt;code&gt;bool&lt;/code&gt; 参数传递分类数据，在&amp;ldquo; &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;代码完成&amp;rdquo;&lt;/a&gt;书中的史蒂夫&amp;middot;麦康奈尔（Steve McConnell）的&amp;ldquo;简单数据耦合&amp;rdquo;下，与其他三种耦合一起进行了分类。作者引用了几项研究，认为耦合对代码质量有负面影响。 &lt;code&gt;Flag&lt;/code&gt; 提供了一种简单的结构化方法，用于将yes / no标志传递给API。</target>
        </trans-unit>
        <trans-unit id="076392e866b208f90ee610d973e43efceb10e97e" translate="yes" xml:space="preserve">
          <source>The subclass of EncodingScheme to register.</source>
          <target state="translated">要注册的 EncodingScheme 的子类。</target>
        </trans-unit>
        <trans-unit id="c1ed1f004de54db1586dcfe56503caa35fb79f44" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;sizes&lt;/code&gt; must be equal 21.</source>
          <target state="translated">&lt;code&gt;sizes&lt;/code&gt; 总和必须等于21。</target>
        </trans-unit>
        <trans-unit id="789facc231279c33347577b57e2a474fbfbd6abb" translate="yes" xml:space="preserve">
          <source>The sum of all bit lengths in one bitfield instantiation must be exactly 8, 16, 32, or 64. If padding is needed, just allocate one bitfield with an empty name.</source>
          <target state="translated">一个位域实例中所有位长的总和必须正好是8、16、32或64。如果需要填充,只需分配一个空名的位场。</target>
        </trans-unit>
        <trans-unit id="2cfe229a83e79df357cdfd328b79e038bc593b6f" translate="yes" xml:space="preserve">
          <source>The sum of all the elements in the range r.</source>
          <target state="translated">r范围内所有元素的总和。</target>
        </trans-unit>
        <trans-unit id="9be88f8537261298343db1ff319dde4340861d75" translate="yes" xml:space="preserve">
          <source>The supplied code as a delegate.</source>
          <target state="translated">所提供的代码作为一个委托。</target>
        </trans-unit>
        <trans-unit id="63d3a3cda8996c92ecd751aecdc230c95f7170d2" translate="yes" xml:space="preserve">
          <source>The swapping strategy parameter is not implemented yet; currently it is ignored.</source>
          <target state="translated">交换策略参数还没有实现,目前是忽略的。</target>
        </trans-unit>
        <trans-unit id="80b980e073fe362e9683180ed237939256d93352" translate="yes" xml:space="preserve">
          <source>The swapping strategy to employ.</source>
          <target state="translated">要采用的交换策略。</target>
        </trans-unit>
        <trans-unit id="170969e1d0fabb640f8089b36d7401a205bca51c" translate="yes" xml:space="preserve">
          <source>The swapping strategy to use.</source>
          <target state="translated">要使用的交换策略。</target>
        </trans-unit>
        <trans-unit id="98e99ba24a8243b8fd6b17bc749b4554c5b7f75e" translate="yes" xml:space="preserve">
          <source>The swapping strategy.</source>
          <target state="translated">的交换策略。</target>
        </trans-unit>
        <trans-unit id="48042820d83937bec0797943750b58634bf67f60" translate="yes" xml:space="preserve">
          <source>The symbol containing the &lt;code&gt;static foreach&lt;/code&gt; variables.</source>
          <target state="translated">包含 &lt;code&gt;static foreach&lt;/code&gt; 变量的符号。</target>
        </trans-unit>
        <trans-unit id="56e1148f66671625bb0c6990da38dc2d64edea1a" translate="yes" xml:space="preserve">
          <source>The symbol this &lt;code&gt;alias this&lt;/code&gt; resolves to</source>
          <target state="translated">此 &lt;code&gt;alias this&lt;/code&gt; 解析为的符号</target>
        </trans-unit>
        <trans-unit id="dac6f5e28e8cd7e2f90032028de6bb0f0117f4f9" translate="yes" xml:space="preserve">
          <source>The symlink to create. A relative path is relative to the current working directory.</source>
          <target state="translated">要创建的符号链接。相对路径是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="83a33998cfc84a9e39e9f0423cfd7357619092df" translate="yes" xml:space="preserve">
          <source>The synchronization gets released even if</source>
          <target state="translated">同步化被释放,即使</target>
        </trans-unit>
        <trans-unit id="f52720ebc8b4fb3263a1e381206af9d0efeeb0c2" translate="yes" xml:space="preserve">
          <source>The synchronized statement wraps a statement with a mutex to synchronize access among multiple threads.</source>
          <target state="translated">synchronized语句用mutex包装一个语句,以实现多个线程之间的同步访问。</target>
        </trans-unit>
        <trans-unit id="54b1dbc833575883512c8f1664c887a121ae9fd3" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;b&gt;/c/string/&lt;/b&gt;, where &lt;b&gt;c&lt;/b&gt; is either a single character, or multiple characters separated by whitespace or commas, and &lt;b&gt;string&lt;/b&gt; is the replacement text.</source>
          <target state="translated">语法为&lt;b&gt;/ c / string /&lt;/b&gt;，其中&lt;b&gt;c&lt;/b&gt;是单个字符，或由空格或逗号分隔的多个字符，而&lt;b&gt;string&lt;/b&gt;是替换文本。</target>
        </trans-unit>
        <trans-unit id="d9da9fc28de038f5884f945667be4b8054f95702" translate="yes" xml:space="preserve">
          <source>The syntax trees are traversed to declare variables, load symbol tables, assign types, and in general determine the meaning of the program.</source>
          <target state="translated">语法树的遍历是为了声明变量,加载符号表,分配类型,并在一般情况下确定程序的意义。</target>
        </trans-unit>
        <trans-unit id="fa94a6e6326b720f3ede8ff8d6c4dce16a4fa303" translate="yes" xml:space="preserve">
          <source>The system clock ticks are the ticks of the system clock at the highest precision that the system provides.</source>
          <target state="translated">系统时钟滴数是指系统提供的最高精度的系统时钟的滴数。</target>
        </trans-unit>
        <trans-unit id="5387aa28c9051257b0dae7b093c61c8a7eb3427d" translate="yes" xml:space="preserve">
          <source>The system-provided garbage-collector allocator. This should be the default fallback allocator tapping into system memory. It offers manual &lt;code&gt;free&lt;/code&gt; and dutifully collects litter.</source>
          <target state="translated">系统提供的垃圾收集器分配器。这应该是进入系统内存的默认后备分配器。它提供 &lt;code&gt;free&lt;/code&gt; 手册，忠实地收集垃圾。</target>
        </trans-unit>
        <trans-unit id="ec81049f6e21b9ea49ff325809160b315623cf2d" translate="yes" xml:space="preserve">
          <source>The table below gives a synopsis of predefined allocator building blocks, with their respective modules. Either &lt;code&gt;import&lt;/code&gt; the needed modules individually, or &lt;code&gt;import&lt;/code&gt;&lt;code&gt;std.experimental.building_blocks&lt;/code&gt;, which imports them all &lt;code&gt;public&lt;/code&gt;ly. The building blocks can be assembled in unbounded ways and also combined with your own. For a collection of typical and useful preassembled allocators and for inspiration in defining more such assemblies, refer to &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt;&lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下表概述了预定义的分配器构建块及其各自的模块。可以单独 &lt;code&gt;import&lt;/code&gt; 所需的模块，也可以 &lt;code&gt;import&lt;/code&gt; &lt;code&gt;std.experimental.building_blocks&lt;/code&gt; ，然后将其全部 &lt;code&gt;public&lt;/code&gt; 导入。这些构建块可以以无限制的方式组装，也可以与您自己的组装在一起。有关典型和有用的预组装分配器的集合，以及对定义更多此类组装的启发，请参阅&lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt; &lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d173662a2aa058963145fe71e5e20907062a55be" translate="yes" xml:space="preserve">
          <source>The target hardware does not have a floating point unit</source>
          <target state="translated">目标硬件没有浮点单位。</target>
        </trans-unit>
        <trans-unit id="c5cdb1793dc5882606089de2cbe88b09e1226416" translate="yes" xml:space="preserve">
          <source>The target hardware has a floating point unit</source>
          <target state="translated">目标硬件有一个浮点单元</target>
        </trans-unit>
        <trans-unit id="b0979a69d6f3a7dae7324755cd1aa56f216e319b" translate="yes" xml:space="preserve">
          <source>The target object</source>
          <target state="translated">目标对象</target>
        </trans-unit>
        <trans-unit id="0b824dcd9bca9b5db9480c831c6a63d26770ea48" translate="yes" xml:space="preserve">
          <source>The target of the search. Must be an input range. If any of &lt;code&gt;needles&lt;/code&gt; is a range with elements comparable to elements in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; such that the search can backtrack.</source>
          <target state="translated">搜索的目标。必须是输入范围。如果任何一个 &lt;code&gt;needles&lt;/code&gt; 具有与 &lt;code&gt;haystack&lt;/code&gt; 中的元素可比的元素的范围，则 &lt;code&gt;haystack&lt;/code&gt; 必须为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;向前范围&lt;/a&gt;，以便搜索可以回溯。</target>
        </trans-unit>
        <trans-unit id="1bfc030365108c10d6974605e9bd398b8361c092" translate="yes" xml:space="preserve">
          <source>The target range to copy common elements to.</source>
          <target state="translated">要复制常用元素的目标范围。</target>
        </trans-unit>
        <trans-unit id="829e896e39b70090cbc3b2de79f25fe9335f1b77" translate="yes" xml:space="preserve">
          <source>The target range.</source>
          <target state="translated">靶场。</target>
        </trans-unit>
        <trans-unit id="23350db16fa1f3e6288ccb87e5a181ba79379e10" translate="yes" xml:space="preserve">
          <source>The target supports interfacing with Objective-C</source>
          <target state="translated">目标支持与Objective-C的接口</target>
        </trans-unit>
        <trans-unit id="eac1bff04784409ef03a30482f19ef41091d6414" translate="yes" xml:space="preserve">
          <source>The target type in the conversion or comparison</source>
          <target state="translated">转换或比较中的目标类型</target>
        </trans-unit>
        <trans-unit id="390654f1dbf50ff204a2f1fd9ed2609258c428a9" translate="yes" xml:space="preserve">
          <source>The target type of the cast</source>
          <target state="translated">投放的目标类型</target>
        </trans-unit>
        <trans-unit id="5431c3bccb7e8fdc6dc54d831207394bad385ccd" translate="yes" xml:space="preserve">
          <source>The target variable.</source>
          <target state="translated">目标变量。</target>
        </trans-unit>
        <trans-unit id="b71a4a76d74bf9f8e3d2c97011ae3038c9fc6fff" translate="yes" xml:space="preserve">
          <source>The technical term 'Special Functions' includes several families of transcendental functions, which have important applications in particular branches of mathematics and physics.</source>
          <target state="translated">技术术语 &quot;特殊函数 &quot;包括几个超函数族,它们在数学和物理学的特殊分支中有着重要的应用。</target>
        </trans-unit>
        <trans-unit id="2b45d76d889fde617363950e6293b054095035b5" translate="yes" xml:space="preserve">
          <source>The template API is slightly more efficient. It does not have to allocate memory dynamically, all memory is allocated on the stack. The OOP API has to allocate in the finish method if no buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate, but the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; classes still have to be created using &lt;code&gt;new&lt;/code&gt; which allocates them using the GC.  The OOP API is useful to change the digest function and/or digest backend at 'runtime'. The benefit here is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.  If just one specific digest type and backend is needed, the template API is usually a good fit. In this simplest case, the template API can even be used without templates: Just use the &quot;&lt;b&gt;x&lt;/b&gt;&quot; structs directly.</source>
          <target state="translated">模板API效率更高。它不必动态分配内存，所有内存都分配在堆栈上。如果未提供缓冲区，则OOP API必须在finish方法中进行分配。如果为OOP API finish函数提供缓冲区，则不会分配缓冲区，但是&lt;a href=&quot;#Digest&quot;&gt; &lt;code&gt;Digest&lt;/code&gt; &lt;/a&gt;类仍必须使用 &lt;code&gt;new&lt;/code&gt; 创建，后者使用GC对其进行分配。 OOP API可用于在&amp;ldquo;运行时&amp;rdquo;更改摘要功能和/或摘要后端。这样做的好处是，例如Phobos MD5Digest和OpenSSLMD5Digest实现的切换与ABI兼容。如果仅需要一种特定的摘要类型和后端，则通常适合使用模板API。在这种最简单的情况下，甚至可以在不使用模板的情况下使用模板API：只需使用&amp;ldquo; &lt;b&gt;x&lt;/b&gt;&amp;rdquo;直接构建。</target>
        </trans-unit>
        <trans-unit id="408001ca506523fa6af663497d5def923a607239" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;. If asking for &lt;code&gt;char&lt;/code&gt;, content will be converted from the connection character set (specified in HTTP response headers or FTP connection properties, both ISO-8859-1 by default) to UTF-8.</source>
          <target state="translated">模板参数 &lt;code&gt;T&lt;/code&gt; 指定要返回的类型。可能的值为 &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;ubyte&lt;/code&gt; ,以返回 &lt;code&gt;char[]&lt;/code&gt; 或 &lt;code&gt;ubyte[]&lt;/code&gt; 。如果要求 &lt;code&gt;char&lt;/code&gt; ，内容将从连接字符集（在HTTP响应标头或FTP连接属性中指定，默认情况下均为ISO-8859-1）转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="3d301625295a49a8e01e8072c1823836d6260302" translate="yes" xml:space="preserve">
          <source>The template picked to instantiate is the one that is most specialized that fits the types of the</source>
          <target state="translated">挑选实例化的模板是最专业的,符合类型的模板。</target>
        </trans-unit>
        <trans-unit id="02b51510e4339a80ea7cc2a65d41d079d75e78b8" translate="yes" xml:space="preserve">
          <source>The template to instantiate.</source>
          <target state="translated">要实例化的模板。</target>
        </trans-unit>
        <trans-unit id="e41f924354ea35f5712eb828813900cd1d5f4161" translate="yes" xml:space="preserve">
          <source>The term and concept of a 'critical region' comes from &lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;Mono's SGen garbage collector&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;关键区域&amp;rdquo;的术语和概念来自&lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;Mono的SGen垃圾收集器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efe68f5f28809042f03e04ab3e7e40904902798b" translate="yes" xml:space="preserve">
          <source>The tested value</source>
          <target state="translated">测试值</target>
        </trans-unit>
        <trans-unit id="836717195b2e4f6e650af52f82b03152a0dc0a7a" translate="yes" xml:space="preserve">
          <source>The text from &lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;</source>
          <target state="translated">来自&lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;的文本</target>
        </trans-unit>
        <trans-unit id="459f3d558c2480422a70a7a05484244d80510d43" translate="yes" xml:space="preserve">
          <source>The text to print at the beginning of the help output.</source>
          <target state="translated">在帮助输出的开头要打印的文字。</target>
        </trans-unit>
        <trans-unit id="b43a60a00dd34982ab5b9431db8979ee331c8fcd" translate="yes" xml:space="preserve">
          <source>The text to printed at the beginning of the help output.</source>
          <target state="translated">在帮助输出的开头打印的文字。</target>
        </trans-unit>
        <trans-unit id="f99eb9686d85d18418cbec2f3108af60157b8372" translate="yes" xml:space="preserve">
          <source>The third form, &lt;code&gt;goto case;&lt;/code&gt;, transfers to the next &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">第三种形式， &lt;code&gt;goto case;&lt;/code&gt; ，转移到下一&lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;最内包围的&lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d93a13c865f0a3f12bf9f0bb2248b62195335a7" translate="yes" xml:space="preserve">
          <source>The third version counts the elements for which &lt;code&gt;pred(x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">第三个版本计算 &lt;code&gt;pred(x)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的元素。执行 &lt;code&gt;pred&lt;/code&gt; 的 &amp;Omicron;（ &lt;code&gt;haystack.length&lt;/code&gt; ）个评估。</target>
        </trans-unit>
        <trans-unit id="a7f1a71c5e73a907487dd15adada9e34f7e659b3" translate="yes" xml:space="preserve">
          <source>The thread function.</source>
          <target state="translated">线程功能。</target>
        </trans-unit>
        <trans-unit id="3959bc13b481b7efab32161f7b4d802658e73e9a" translate="yes" xml:space="preserve">
          <source>The thread identifier to search for.</source>
          <target state="translated">要搜索的线程标识符。</target>
        </trans-unit>
        <trans-unit id="5a0f4bf2e74aee3208cf1615166945a5d795e350" translate="yes" xml:space="preserve">
          <source>The thread module provides support for thread creation and management.</source>
          <target state="translated">线程模块提供对线程创建和管理的支持。</target>
        </trans-unit>
        <trans-unit id="d7abe70146b93589cb3df68907f1263f3d11f70c" translate="yes" xml:space="preserve">
          <source>The thread object associated with the thread identifier, null if not found.</source>
          <target state="translated">与线程标识符相关联的线程对象,如果没有找到则为空。</target>
        </trans-unit>
        <trans-unit id="ab55fec985d480d7e55fafd41bc48fa26e59c5c7" translate="yes" xml:space="preserve">
          <source>The thread object representing the calling thread. The result of deleting this object is undefined. If the current thread is not attached to the runtime, a null reference is returned.</source>
          <target state="translated">代表调用线程的线程对象。删除该对象的结果是未定义的。如果当前线程没有连接到运行时,则返回一个空引用。</target>
        </trans-unit>
        <trans-unit id="e5711fdf4eb878a460acdc3e1a74ec3adfd4c562" translate="yes" xml:space="preserve">
          <source>The thread to add.</source>
          <target state="translated">要添加的线。</target>
        </trans-unit>
        <trans-unit id="7d29c86c6e1877f0c1dbf42c7ab48cb432ebae10" translate="yes" xml:space="preserve">
          <source>The thread to remove.</source>
          <target state="translated">要删除的线。</target>
        </trans-unit>
        <trans-unit id="d0b4719e19dcec3e27e7ac05162455919bfcbe02" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;. The semantics of the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; are identical to the regular &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#BitmappedBlock&quot;&gt; &lt;code&gt;BitmappedBlock&lt;/code&gt; &lt;/a&gt;的线程安全版本。 &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 的语义与常规&lt;a href=&quot;#BitmappedBlock&quot;&gt; &lt;code&gt;BitmappedBlock&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="59a01b618381df97fff6e53a1c501e32c03fcf01" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;code&gt;Region&lt;/code&gt; allocator. Allocations and deallocations are lock-free based using &lt;a href=&quot;core_atomic#cas&quot;&gt;&lt;code&gt;core.atomic.cas&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Region&lt;/code&gt; 分配器的线程安全版本。分配和取消分配使用&lt;a href=&quot;core_atomic#cas&quot;&gt; &lt;code&gt;core.atomic.cas&lt;/code&gt; &lt;/a&gt;是无锁的。</target>
        </trans-unit>
        <trans-unit id="1aa46d46c716c543c618abaaa5d085bc00056cfe" translate="yes" xml:space="preserve">
          <source>The tick of the system clock (as a &lt;code&gt;TickDuration&lt;/code&gt;) when the application started.</source>
          <target state="translated">应用程序启动时系统时钟的滴答声（作为 &lt;code&gt;TickDuration&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c9d9d06b3436a3b01b898cdc70083c5a552bbada" translate="yes" xml:space="preserve">
          <source>The tid register by name.</source>
          <target state="translated">滴滴按名称登记。</target>
        </trans-unit>
        <trans-unit id="c95778519910f76a9057566bdc33da531d73931d" translate="yes" xml:space="preserve">
          <source>The time complexity of &lt;code&gt;resolveInternalPointer&lt;/code&gt; is &amp;Omicron;(&lt;code&gt;k&lt;/code&gt;), where &lt;code&gt;k&lt;/code&gt; is the size of the object within which the internal pointer is looked up.</source>
          <target state="translated">&lt;code&gt;resolveInternalPointer&lt;/code&gt; 的时间复杂度为〇（ &lt;code&gt;k&lt;/code&gt; ），其中 &lt;code&gt;k&lt;/code&gt; 是在其中查找内部指针的对象的大小。</target>
        </trans-unit>
        <trans-unit id="c6f885eba6e13ebbe7785527359e11e5b18d7b86" translate="yes" xml:space="preserve">
          <source>The time in this time zone that needs to be adjusted to UTC time.</source>
          <target state="translated">这个时区的时间,需要调整为UTC时间。</target>
        </trans-unit>
        <trans-unit id="36444ba6ba0b4c42e3d384843ef7cb9d529fafd9" translate="yes" xml:space="preserve">
          <source>The time it takes for a collection to complete is not bounded. While in practice it is very quick, this cannot normally be guaranteed.</source>
          <target state="translated">完成一次收集所需的时间是没有限制的。虽然在实践中,完成时间非常快,但通常无法保证。</target>
        </trans-unit>
        <trans-unit id="de1882702ad690d9d775a9f36384bf0f0cf2e003" translate="yes" xml:space="preserve">
          <source>The time point to check for inclusion in this interval.</source>
          <target state="translated">检查是否包含在这个区间的时间点。</target>
        </trans-unit>
        <trans-unit id="6e148efcac14a5504ed5ebc4915f1425f4ffaad7" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is after it.</source>
          <target state="translated">的时间点,检查这个区间是否在它之后。</target>
        </trans-unit>
        <trans-unit id="0af6ef24e2680b0852356a3c276c84d96252cda5" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is before it.</source>
          <target state="translated">的时间点,检查这个区间是否在它之前。</target>
        </trans-unit>
        <trans-unit id="8a3820a8c6e406527bb35a80565a009d598d8a36" translate="yes" xml:space="preserve">
          <source>The time point to set &lt;code&gt;begin&lt;/code&gt; to.</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; 设置的时间点。</target>
        </trans-unit>
        <trans-unit id="cbec4c576826e4c65a07a27c4030261f911b3fc7" translate="yes" xml:space="preserve">
          <source>The time point to set end to.</source>
          <target state="translated">设定结束的时间点。</target>
        </trans-unit>
        <trans-unit id="4e8c71e16602a3ead734892883c0297513fcb288" translate="yes" xml:space="preserve">
          <source>The time point which begins the interval.</source>
          <target state="translated">开始间隔的时间点。</target>
        </trans-unit>
        <trans-unit id="b2fbbe21f1348e2b8375bc085e626db9a6aa48c4" translate="yes" xml:space="preserve">
          <source>The time point which ends (but is not included in) the interval.</source>
          <target state="translated">间隔结束(但不包括在)的时间点。</target>
        </trans-unit>
        <trans-unit id="78c4a788ebf74ce66cd510d9291804e7429c59df" translate="yes" xml:space="preserve">
          <source>The time point which ends the interval.</source>
          <target state="translated">结束间隔的时间点。</target>
        </trans-unit>
        <trans-unit id="a07ced07ea48cf9efd3c59008997a5861e92661c" translate="yes" xml:space="preserve">
          <source>The time portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的时间部分。</target>
        </trans-unit>
        <trans-unit id="eaefa3fbda7de51442bf3c3c08acb463add5f535" translate="yes" xml:space="preserve">
          <source>The time required of the base function</source>
          <target state="translated">基本功能所需时间</target>
        </trans-unit>
        <trans-unit id="5dfcadc4d17bd6640e6259395ec434dc6bc95330" translate="yes" xml:space="preserve">
          <source>The time required of the target function</source>
          <target state="translated">目标函数所需时间</target>
        </trans-unit>
        <trans-unit id="48cf786f30ef005c486cb7a01e2f10f8f8403d94" translate="yes" xml:space="preserve">
          <source>The time to return if the given file does not exist.</source>
          <target state="translated">如果给定的文件不存在,返回的时间。</target>
        </trans-unit>
        <trans-unit id="4267537c103e163837339d1b65e1d8cf5f9910a8" translate="yes" xml:space="preserve">
          <source>The time to wait.</source>
          <target state="translated">等待的时间。</target>
        </trans-unit>
        <trans-unit id="fa99618f433466483613abfd766711a1f7a82462" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;Duration&lt;/code&gt; (e.g. &lt;code&gt;&quot;days&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 的时间单位（例如 &lt;code&gt;&quot;days&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e6cd7e80f003f95225b75b6571da8250b5085bd4" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;TickDuration&lt;/code&gt; (e.g. &lt;code&gt;&quot;msecs&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 的时间单位（例如 &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="da60824664e52c129d1706b86eb17c66b6fccefc" translate="yes" xml:space="preserve">
          <source>The time zone for the SysTime that's returned.</source>
          <target state="translated">返回的SysTime的时区。</target>
        </trans-unit>
        <trans-unit id="c438d5ef1eeaa45747297e85768ff04bc9674297" translate="yes" xml:space="preserve">
          <source>The time zone that the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; will be in (&lt;code&gt;FILETIME&lt;/code&gt;s are in UTC).</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 所在&lt;/a&gt;的时区（ &lt;code&gt;FILETIME&lt;/code&gt; 的单位为UTC）。</target>
        </trans-unit>
        <trans-unit id="8ed6f652fe44fd70fdb71a9b99c39e57d001f270" translate="yes" xml:space="preserve">
          <source>The time zone that the time in the &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct is assumed to be (if the &lt;code&gt;SYSTEMTIME&lt;/code&gt; was supplied by a Windows system call, the &lt;code&gt;SYSTEMTIME&lt;/code&gt; will either be in local time or UTC, depending on the call).</source>
          <target state="translated">假定 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 结构中的时间为时区（如果 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 是由Windows系统调用提供的，则根据调用， &lt;code&gt;SYSTEMTIME&lt;/code&gt; 可以是本地时间，也可以是UTC）。</target>
        </trans-unit>
        <trans-unit id="e2b1325df63f2bced3800f46b247c623c3e4272e" translate="yes" xml:space="preserve">
          <source>The time zone to convert the given time to (no conversion occurs if null).</source>
          <target state="translated">要将给定时间转换为的时区(如果为空,则不发生转换)。</target>
        </trans-unit>
        <trans-unit id="07061a5295594952467858d09a80f0ac4c6b93c5" translate="yes" xml:space="preserve">
          <source>The time zone which the DOS file time is assumed to be in.</source>
          <target state="translated">假定DOS文件时间所在的时区。</target>
        </trans-unit>
        <trans-unit id="ea5d10f63e5499e351af6e045b5284865995d1c6" translate="yes" xml:space="preserve">
          <source>The time-domain signal.</source>
          <target state="translated">时域信号。</target>
        </trans-unit>
        <trans-unit id="77a3aa828967d445cff64c8dd096774ce4063dcd" translate="yes" xml:space="preserve">
          <source>The timeout duration to set. Must not be negative.</source>
          <target state="translated">要设置的超时时间。不得为负值。</target>
        </trans-unit>
        <trans-unit id="d16c09d69ed3827cc0d9a393d7d97a0e7218d947" translate="yes" xml:space="preserve">
          <source>The times when endianness matters are:</source>
          <target state="translated">恩典重要的时候是。</target>
        </trans-unit>
        <trans-unit id="e3fa37b42db66accd6b9bcd0e0be5ca501e23ea7" translate="yes" xml:space="preserve">
          <source>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the internal representation of &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从1 UTC 1月1日午夜开始的总hnsec。这是&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的内部表示。</target>
        </trans-unit>
        <trans-unit id="1c5851853cba4938d9ece2d746e33f63f5ccc8b6" translate="yes" xml:space="preserve">
          <source>The total number of CPU cores available on the current machine, as reported by the operating system.</source>
          <target state="translated">当前机器上可用的CPU核心总数,由操作系统报告。</target>
        </trans-unit>
        <trans-unit id="79b5fcc0a58019c01762b4288a59bbc0fed9cdab" translate="yes" xml:space="preserve">
          <source>The total number of fields minus the number of hidden fields.</source>
          <target state="translated">总字段数减去隐藏字段数。</target>
        </trans-unit>
        <trans-unit id="dc0f294e7939a4a8cc8e219285559a0f838c9d26" translate="yes" xml:space="preserve">
          <source>The total number of valid bits in the given bit array</source>
          <target state="translated">在给定的位数组中,有效位的总数。</target>
        </trans-unit>
        <trans-unit id="df0ace455640aad44a2f2df358df6cfc839cb3dc" translate="yes" xml:space="preserve">
          <source>The total size of a static array cannot exceed 16Mb.</source>
          <target state="translated">静态阵列的总大小不能超过16Mb。</target>
        </trans-unit>
        <trans-unit id="976a549fe53e07ee95927e3a3f5dc68542025ca7" translate="yes" xml:space="preserve">
          <source>The traditional C way of detecting and reporting errors is not traditional, it is ad-hoc and varies from function to function, including:</source>
          <target state="translated">传统的C语言检测和报告错误的方式并不传统,它是临时性的,不同的功能之间也有差异,包括:。</target>
        </trans-unit>
        <trans-unit id="67c33a524b8d09894199c567d354a8e0cb98ab34" translate="yes" xml:space="preserve">
          <source>The trailing end of the sub-format string following the specifier for each item is interpreted as the array delimiter, and is therefore omitted following the last array item. The &lt;b&gt;%|&lt;/b&gt; delimiter specifier may be used to indicate where the delimiter begins, so that the portion of the format string prior to it will be retained in the last array element:</source>
          <target state="translated">每个项目的说明符之后的子格式字符串的结尾被解释为数组定界符，因此在最后一个数组项目之后被省略。在&lt;b&gt;％| &lt;/b&gt;分隔符说明符可用于指示分隔符的起始位置，以便格式字符串之前的部分将保留在最后一个数组元素中：</target>
        </trans-unit>
        <trans-unit id="ba1799b6274ed3732b914694e0713f19f1425685" translate="yes" xml:space="preserve">
          <source>The transformation target</source>
          <target state="translated">改造目标</target>
        </trans-unit>
        <trans-unit id="dc8b213c861da206308d6e24e6eb30fbdfae1604" translate="yes" xml:space="preserve">
          <source>The transformation to apply.</source>
          <target state="translated">要应用的转变。</target>
        </trans-unit>
        <trans-unit id="b1e46c489c0f174beeea6508fe063266ccec2c4d" translate="yes" xml:space="preserve">
          <source>The transversal assumes, without verifying, that the elements of a range of ranges have all the same length. This option is useful if checking was already done from the outside of the range.</source>
          <target state="translated">横向假设,不需要验证,一个范围的元素都有相同的长度。如果已经从范围外进行了检查,这个选项就很有用。</target>
        </trans-unit>
        <trans-unit id="c892e981eb5136632b424a66b388d449fc7ea3de" translate="yes" xml:space="preserve">
          <source>The transversal enforces that the elements of a range of ranges have all the same length (e.g. an array of arrays, all having the same length). Checking is done once upon construction of the transversal range.</source>
          <target state="translated">横向强制要求范围的元素具有相同的长度(例如,一个数组,所有的数组具有相同的长度)。横向范围的构造时,检查只进行一次。</target>
        </trans-unit>
        <trans-unit id="39be873b141578a1b5b94098b6cdd594b486bf6c" translate="yes" xml:space="preserve">
          <source>The try/catch/finally statements look a lot nicer than endless if (error) goto errorhandler; statements.</source>
          <target state="translated">try/catch/finally 语句比起无休止的 if (error)goto errorhandler;语句要好看得多。</target>
        </trans-unit>
        <trans-unit id="2180bb589eb009453566d9091bc41a602b56f38e" translate="yes" xml:space="preserve">
          <source>The tuple passes in a range closed to the left and open to the right (consistent with built-in slices), e.g. &lt;code&gt;tuple(1, 3)&lt;/code&gt; means indices &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; but not &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">元组在从左向右打开（与内置切片一致）的范围内通过，例如 &lt;code&gt;tuple(1, 3)&lt;/code&gt; 表示索引 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; ,但不等于 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07a7ad5d5f1c875f8f019e5586ed049f63bb8fa1" translate="yes" xml:space="preserve">
          <source>The two functions are almost identical semantically. The expressions in the first are lowered to contract blocks that look almost exactly like the second, except that a separate block is created for each expression in the first, thus avoiding shadowing variable names.</source>
          <target state="translated">这两个函数在语义上几乎完全相同。第一个函数中的表达式被下放到合同块中,看起来几乎和第二个函数一模一样,只是第一个函数中的每个表达式都会创建一个单独的块,从而避免了变量名的阴影。</target>
        </trans-unit>
        <trans-unit id="28b3f8f71ef0f4ce43325479aa6cdea23771283e" translate="yes" xml:space="preserve">
          <source>The two sockets are indistinguishable.</source>
          <target state="translated">两个插座是分不清的。</target>
        </trans-unit>
        <trans-unit id="61509f7d94291812c28aff0f194b21e094315464" translate="yes" xml:space="preserve">
          <source>The type being allocated embeds no pointers. Examples: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt; Tuple!(int, float)&lt;/code&gt;. The implicit conservative assumption is that the type has members with indirections so it needs to be scanned if garbage collected. Example of types with pointers: &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)&lt;/code&gt;.</source>
          <target state="translated">分配的类型不嵌入任何指针。示例： &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;int[]&lt;/code&gt; ， &lt;code&gt; Tuple!(int, float)&lt;/code&gt; 。隐式的保守假设是该类型的成员具有间接性，因此如果收集了垃圾，则需要对其进行扫描。带有指针的类型的示例： &lt;code&gt;int*[]&lt;/code&gt; ， &lt;code&gt;Tuple!(int, string)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c92e87e9681d72db37be621f13a19e6f9ccab9d8" translate="yes" xml:space="preserve">
          <source>The type being allocated is &lt;code&gt;immutable&lt;/code&gt; and has no pointers. The thread that allocated it must also deallocate it. Example: &lt;code&gt;immutable(int)&lt;/code&gt;.</source>
          <target state="translated">分配的类型是 &lt;code&gt;immutable&lt;/code&gt; ，没有指针。分配它的线程也必须取消分配它。示例： &lt;code&gt;immutable(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e05464f951110a64f08a5f46efef5075a235c4f" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, embeds no indirections, and has fixed size.</source>
          <target state="translated">被分配的类型可以在各线程间共享,不嵌入任何内向项,并具有固定的大小。</target>
        </trans-unit>
        <trans-unit id="31e0418a4ffc820d767ece7d24f4809101c1c145" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has fixed size.</source>
          <target state="translated">被分配的类型可以在各线程之间共享,可以嵌入内联,并且有固定的大小。</target>
        </trans-unit>
        <trans-unit id="6fe4cebdd8e8add445c91158cc91cb4158edec6a" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has variable size.</source>
          <target state="translated">被分配的类型可以在各线程之间共享,可以嵌入内向,并且大小可变。</target>
        </trans-unit>
        <trans-unit id="ddfa6b8808ffdca7214f401f8531dd3f2c5d3a94" translate="yes" xml:space="preserve">
          <source>The type can be inferred from the initializer:</source>
          <target state="translated">类型可以从初始化器中推断出来。</target>
        </trans-unit>
        <trans-unit id="a2bca00fd97360bf19d51b245e76c8ddf38d445e" translate="yes" xml:space="preserve">
          <source>The type for a callback function. This is legacy and deprecated. It is included for historical compatibility and is not documented.</source>
          <target state="translated">回调函数的类型。这是遗留的,已经废弃。它是为了历史的兼容性而包含的,没有记录在案。</target>
        </trans-unit>
        <trans-unit id="121e0a2d6317bfb42929d38aae907c92fbe1c037" translate="yes" xml:space="preserve">
          <source>The type for a unary expression is incompatible. Print error message.</source>
          <target state="translated">单元表达式的类型不兼容。打印错误信息。</target>
        </trans-unit>
        <trans-unit id="6c3d19b0730f008ab63e19c7a8d36ffbf8fb1da1" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt; to handle.</source>
          <target state="translated">可处理的 &lt;code&gt;Throwable&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="3c9c6ef66ad21283731c4e03058407f8e8389f4f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt;s to catch. Defaults to &lt;code&gt;Exception&lt;/code&gt;</source>
          <target state="translated">要捕获的 &lt;code&gt;Throwable&lt;/code&gt; 的类型。默认为 &lt;code&gt;Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="334019df59cb8690811d0f69b9dd1719fafb9c56" translate="yes" xml:space="preserve">
          <source>The type of a bit field can be any integral type or enumerated type. The most efficient type to store in bitfields is bool, followed by unsigned types, followed by signed types.</source>
          <target state="translated">位字段的类型可以是任何积分类型或枚举类型。位字段中最有效的存储类型是bool,其次是无符号类型,然后是有符号类型。</target>
        </trans-unit>
        <trans-unit id="94b6a8f2e23e23e45fa071980296e38bdaa78842" translate="yes" xml:space="preserve">
          <source>The type of a const declaration is itself const.</source>
          <target state="translated">const声明的类型本身就是const。</target>
        </trans-unit>
        <trans-unit id="f092f06205403400bf68aeecbf79e12113097113" translate="yes" xml:space="preserve">
          <source>The type of a string is determined by the semantic phase of compilation. The type is one of: char[], wchar[], dchar[], and is determined by implicit conversion rules. If there are two equally applicable implicit conversions, the result is an error. To disambiguate these cases, a cast or a postfix of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; can be used:</source>
          <target state="translated">字符串的类型由编译的语义阶段确定。类型是char []，wchar []，dchar []之一，由隐式转换规则确定。如果存在两个同样适用的隐式转换，则结果为错误。为了消除这些情况的歧义，可以使用 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; 或 &lt;code&gt;d&lt;/code&gt; 的强制转换或后缀：</target>
        </trans-unit>
        <trans-unit id="ca53c8f136489f724620c0090bfc2e63be277e6a" translate="yes" xml:space="preserve">
          <source>The type of an</source>
          <target state="translated">的类型</target>
        </trans-unit>
        <trans-unit id="31de113d851dba3763860dc7a09ef0a95ac4302d" translate="yes" xml:space="preserve">
          <source>The type of concurrency used when logical threads are created is determined by the Scheduler selected at initialization time. The default behavior is currently to create a new kernel thread per call to spawn, but other schedulers are available that multiplex fibers across the main thread or use some combination of the two approaches.</source>
          <target state="translated">创建逻辑线程时使用的并发类型由初始化时选择的调度器决定。目前默认的行为是每次调用 spawn 时创建一个新的内核线程,但也有其他调度器可以在主线程上复用光纤或使用两种方法的某种组合。</target>
        </trans-unit>
        <trans-unit id="98b545b7a4a8236494e660dadf828715e09984c5" translate="yes" xml:space="preserve">
          <source>The type of encoding cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type.</source>
          <target state="translated">编码类型无法推断。因此,必须明确规定编码类型。</target>
        </trans-unit>
        <trans-unit id="28559fdc7fafacf56a4b4aa4caf411513cf1a53a" translate="yes" xml:space="preserve">
          <source>The type of exception to catch.</source>
          <target state="translated">要捕捉的异常类型。</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">的类型</target>
        </trans-unit>
        <trans-unit id="e2db65940bfb878a54cfaaae819d3064fa148502" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;t&lt;/code&gt; 关联的 &lt;code&gt;TypeInfo&lt;/code&gt; 对象的类型</target>
        </trans-unit>
        <trans-unit id="3fe50288d353a1cb4576b8e3e05c3c630fa3b33c" translate="yes" xml:space="preserve">
          <source>The type of the array elements</source>
          <target state="translated">数组元素的类型</target>
        </trans-unit>
        <trans-unit id="d37e2aaad386c1ac5e9f0016c42e7b609226d289" translate="yes" xml:space="preserve">
          <source>The type of the expression.</source>
          <target state="translated">表达式的类型。</target>
        </trans-unit>
        <trans-unit id="028c1d38d3da5ded0145ae38e0f7c2dbd53920e7" translate="yes" xml:space="preserve">
          <source>The type of the integer is resolved as follows:</source>
          <target state="translated">整数的类型解析如下。</target>
        </trans-unit>
        <trans-unit id="212a76fc03c17bbe0ddb79883b2541fa9887cff9" translate="yes" xml:space="preserve">
          <source>The type of the integral subject to checking.</source>
          <target state="translated">被检查的积分类型。</target>
        </trans-unit>
        <trans-unit id="c013517e503aa577ef8db2efdfe587a3e89caa97" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter.</source>
          <target state="translated">输出的类型无法推断。因此,有必要将编码明确地指定为模板参数。</target>
        </trans-unit>
        <trans-unit id="03cbac5dfebfa2a554890fbfd9c43c204a18bfcf" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type in the template parameter.</source>
          <target state="translated">输出的类型无法推断。因此,必须在模板参数中明确指定编码类型。</target>
        </trans-unit>
        <trans-unit id="d39ec39bd451294d5515fb3a127cb955f855d7d6" translate="yes" xml:space="preserve">
          <source>The type of the previous</source>
          <target state="translated">以前的类型</target>
        </trans-unit>
        <trans-unit id="033a19799f0fa5ac9cef064ceb5d1268d8f17524" translate="yes" xml:space="preserve">
          <source>The type of the resulting array elements</source>
          <target state="translated">产生的数组元素的类型</target>
        </trans-unit>
        <trans-unit id="81040b338b2e6abd79e9a3fdf3377720163baee6" translate="yes" xml:space="preserve">
          <source>The type of the return value.</source>
          <target state="translated">返回值的类型。</target>
        </trans-unit>
        <trans-unit id="dd58ac5452c68f3b56c536830be3fca377a108cc" translate="yes" xml:space="preserve">
          <source>The type of the slice is a dynamic array of the element type of the</source>
          <target state="translated">的元素类型的动态数组。</target>
        </trans-unit>
        <trans-unit id="cd785b1199a8635d3d151523c5ad55526bbbd6f9" translate="yes" xml:space="preserve">
          <source>The type of the symbol.</source>
          <target state="translated">符号的类型。</target>
        </trans-unit>
        <trans-unit id="452196a4318917b63a4cfe89691bc99e9fba3c75" translate="yes" xml:space="preserve">
          <source>The type of units to add (&quot;years&quot; or &quot;months&quot;).</source>
          <target state="translated">要添加的单位类型(&quot;年 &quot;或 &quot;月&quot;);</target>
        </trans-unit>
        <trans-unit id="f9dccb4c7e9a59ec9ebfcaaaf2ab57b17a652de7" translate="yes" xml:space="preserve">
          <source>The type returned by &lt;code&gt;takeOne&lt;/code&gt; is a random-access range with length regardless of &lt;code&gt;R&lt;/code&gt;'s capabilities, as long as it is a forward range. (another feature that distinguishes &lt;code&gt;takeOne&lt;/code&gt; from &lt;code&gt;take&lt;/code&gt;). If (D R) is an input range but not a forward range, return type is an input range with all random-access capabilities except save.</source>
          <target state="translated">&lt;code&gt;takeOne&lt;/code&gt; 返回的类型是一个随机访问范围，其长度与 &lt;code&gt;R&lt;/code&gt; 的功能无关，只要它是前向范围即可。（另一个将 &lt;code&gt;takeOne&lt;/code&gt; 与 &lt;code&gt;take&lt;/code&gt; 区别开的功能）。如果（DR）是输入范围而不是正向范围，则返回类型是具有所有随机访问功能（保存除外）的输入范围。</target>
        </trans-unit>
        <trans-unit id="df7e4abf69509dd860941f1b197de09e0d181452" translate="yes" xml:space="preserve">
          <source>The type stored inside &lt;code&gt;bomTable&lt;/code&gt;.</source>
          <target state="translated">存储在 &lt;code&gt;bomTable&lt;/code&gt; 中的类型。</target>
        </trans-unit>
        <trans-unit id="6da0e0e3a59ae4f419059fd79e6a5b2efe510dd1" translate="yes" xml:space="preserve">
          <source>The type to cast from. The programmer must ensure it is legal to make this cast.</source>
          <target state="translated">要投射的类型。程序员必须确保其合法地进行投射。</target>
        </trans-unit>
        <trans-unit id="6fc6b3afd9d09c214bbb47deabcb3d5029a321f8" translate="yes" xml:space="preserve">
          <source>The type to cast to.</source>
          <target state="translated">要投向的类型。</target>
        </trans-unit>
        <trans-unit id="7a12dddb89baf93f3c8ff660933719a4552a94a9" translate="yes" xml:space="preserve">
          <source>The type to check</source>
          <target state="translated">要检查的类型</target>
        </trans-unit>
        <trans-unit id="20caa9de7c60aa932980e2103bddf1b7c37802ff" translate="yes" xml:space="preserve">
          <source>The type to check Returns A &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">要检查的类型返回A &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="129cd5fe4646df1f906533b11f848d4c99ca621d" translate="yes" xml:space="preserve">
          <source>The type to check.</source>
          <target state="translated">要检查的类型。</target>
        </trans-unit>
        <trans-unit id="e0884902d15a178811c08946d7f41f322c3b3c6e" translate="yes" xml:space="preserve">
          <source>The type to convert to (either an integral type or a floating point type).</source>
          <target state="translated">要转换的类型(积分类型或浮点类型)。</target>
        </trans-unit>
        <trans-unit id="731464fe86427c8aef65d3aa38988badaf10df11" translate="yes" xml:space="preserve">
          <source>The type to qualify</source>
          <target state="translated">符合条件的类型</target>
        </trans-unit>
        <trans-unit id="d4255aeb11f7f1166da5fe91079652809cb8c332" translate="yes" xml:space="preserve">
          <source>The type to transform</source>
          <target state="translated">要转换的类型</target>
        </trans-unit>
        <trans-unit id="a182178d558aaac6dc8d492d1e7dc9ff9e25bdd0" translate="yes" xml:space="preserve">
          <source>The types bool, byte, ubyte, short, ushort, int, uint, pointer, Object, and interfaces are returned in EAX.</source>
          <target state="translated">EAX中返回的类型有bool、byte、ubyte、short、ushort、int、uint、指针、Object和接口。</target>
        </trans-unit>
        <trans-unit id="0110212887a1a5d92fbf43e56315c07c9570e0ab" translate="yes" xml:space="preserve">
          <source>The types defined will all follow the naming convention:</source>
          <target state="translated">定义的类型都将遵循命名惯例。</target>
        </trans-unit>
        <trans-unit id="04692c0de4f65115c6356357897fe3c8458aeb37" translate="yes" xml:space="preserve">
          <source>The types for a binary expression are incompatible. Print error message.</source>
          <target state="translated">二进制表达式的类型不兼容。打印错误信息。</target>
        </trans-unit>
        <trans-unit id="5522b90b8401affc194c75d94ed28b129ed2edae" translate="yes" xml:space="preserve">
          <source>The types of template parameters are deduced for a particular template instantiation by comparing the template argument with the corresponding template parameter.</source>
          <target state="translated">通过比较模板参数与对应的模板参数,推导出特定模板实例的模板参数类型。</target>
        </trans-unit>
        <trans-unit id="066569f5b571624866c51a31fa6ddcb337821083" translate="yes" xml:space="preserve">
          <source>The types of the &lt;code&gt;Tuple&lt;/code&gt;'s components.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 组件的类型。</target>
        </trans-unit>
        <trans-unit id="3c8b9bedfec2099e1aa223db3144a32e496f4931" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;FILE*&lt;/code&gt; handle is maintained in a reference-counted manner, such that as soon as the last &lt;code&gt;File&lt;/code&gt; variable bound to a given &lt;code&gt;FILE*&lt;/code&gt; goes out of scope, the underlying &lt;code&gt;FILE*&lt;/code&gt; is automatically closed.</source>
          <target state="translated">基础 &lt;code&gt;FILE*&lt;/code&gt; 句柄以引用计数的方式维护，这样，一旦绑定到给定 &lt;code&gt;FILE*&lt;/code&gt; 的最后一个 &lt;code&gt;File&lt;/code&gt; 变量超出范围，基础 &lt;code&gt;FILE*&lt;/code&gt; 就会自动关闭。</target>
        </trans-unit>
        <trans-unit id="afc75b662708321c7f89938e96034aeb600136f1" translate="yes" xml:space="preserve">
          <source>The unfilled part of target</source>
          <target state="translated">目标的未填写部分</target>
        </trans-unit>
        <trans-unit id="634a8a351a2208e39d6a5ada2c8d683b264478f7" translate="yes" xml:space="preserve">
          <source>The units of time to convert from.</source>
          <target state="translated">时间单位换算为:</target>
        </trans-unit>
        <trans-unit id="ca496597d1b0052334d45f82b4d1ebb346322b8a" translate="yes" xml:space="preserve">
          <source>The units of time to convert to.</source>
          <target state="translated">换算成的时间单位。</target>
        </trans-unit>
        <trans-unit id="0be285da06571b223018436a72e418b7f4b54a74" translate="yes" xml:space="preserve">
          <source>The units of time to validate.</source>
          <target state="translated">审定的时间单位。</target>
        </trans-unit>
        <trans-unit id="421844a18abe81313eecb91da7e35563552d941b" translate="yes" xml:space="preserve">
          <source>The units to add.</source>
          <target state="translated">要增加的单位。</target>
        </trans-unit>
        <trans-unit id="b4529f66e815e24cb45e91c0feb5284c7f7ff115" translate="yes" xml:space="preserve">
          <source>The units to add. Must be &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">要添加的单位。必须是 &lt;code&gt;&quot;days&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a30f00fc7d9dabd0ab88732559ada44060afc844" translate="yes" xml:space="preserve">
          <source>The units to convert to. Accepts &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; and smaller only.</source>
          <target state="translated">转换成的单位。仅接受 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; 或更小。</target>
        </trans-unit>
        <trans-unit id="77097e55fb24c41c45ac8fd555bdb9f92cb58569" translate="yes" xml:space="preserve">
          <source>The unix time to convert.</source>
          <target state="translated">unix时间的转换。</target>
        </trans-unit>
        <trans-unit id="20dd814c3aa8014ba5957f08ad17be1db064e4d2" translate="yes" xml:space="preserve">
          <source>The unsorted, right-hand side of the random access range to be sorted.</source>
          <target state="translated">未排序的,要排序的随机访问范围的右侧。</target>
        </trans-unit>
        <trans-unit id="d1d3c14f93e1c2e8f53e8dab18a0c8184c6c7a98" translate="yes" xml:space="preserve">
          <source>The upper bound of the clamp.</source>
          <target state="translated">钳的上界。</target>
        </trans-unit>
        <trans-unit id="0983ef86eb34d76a2780b35b3edfbd68c63c7dea" translate="yes" xml:space="preserve">
          <source>The url to receive content from</source>
          <target state="translated">接收内容的网址</target>
        </trans-unit>
        <trans-unit id="446e2b0a1f994283348417fe7415a244c477d8c8" translate="yes" xml:space="preserve">
          <source>The use in the example above is correct because &lt;code&gt;result&lt;/code&gt; was private to &lt;code&gt;letters&lt;/code&gt; and is inaccessible in writing after the function returns. The following example shows an incorrect use of &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">上面的示例中的用法是正确的，因为 &lt;code&gt;result&lt;/code&gt; 是 &lt;code&gt;letters&lt;/code&gt; 专有的，并且在函数返回后无法用书面形式访问。下面的示例显示了对 &lt;code&gt;assumeUnique&lt;/code&gt; 的错误使用。</target>
        </trans-unit>
        <trans-unit id="f765f067fdbcdb23f122179aadad4e3aab7633fe" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged - use either of &lt;a href=&quot;#matchAll&quot;&gt;&lt;code&gt;matchAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#matchFirst&quot;&gt;&lt;code&gt;matchFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不鼓励使用此功能-使用&lt;a href=&quot;#matchAll&quot;&gt; &lt;code&gt;matchAll&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#matchFirst&quot;&gt; &lt;code&gt;matchFirst&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12cefe2def110643149592a34e2703038ffe95e9" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged, please use &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="translated">不建议使用此功能，请显式使用&lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="258077ec71c841ca26961567df7573b36d2e9600" translate="yes" xml:space="preserve">
          <source>The user-defined attribute to search for</source>
          <target state="translated">要搜索的用户自定义属性</target>
        </trans-unit>
        <trans-unit id="aef8bf31a8de472e5ee4f185e2b79cc50024f24a" translate="yes" xml:space="preserve">
          <source>The usual arithmetic conversions convert operands of binary operators to a common type. The operands must already be of arithmetic types. The following rules are applied in order, looking at the base type:</source>
          <target state="translated">通常的算术转换将二进制运算符的操作数转换为一种通用类型。操作数必须已经是算术类型的。从基本类型来看,依次应用以下规则。</target>
        </trans-unit>
        <trans-unit id="ed8ed81507c265fdc6ddf599aacfb34e442e2017" translate="yes" xml:space="preserve">
          <source>The value held internally by this &lt;code&gt;Nullable&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;Nullable&lt;/code&gt; 在内部保留的值。</target>
        </trans-unit>
        <trans-unit id="18c2cd4ec56e16370bc6d10103dd74ac049c5530" translate="yes" xml:space="preserve">
          <source>The value held previously by &lt;code&gt;here&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; 以前保留的值。</target>
        </trans-unit>
        <trans-unit id="758230c61eadaee99aa3c3ef284aa623718c1933" translate="yes" xml:space="preserve">
          <source>The value of 'val'.</source>
          <target state="translated">val'的值。</target>
        </trans-unit>
        <trans-unit id="b06c415192563751b142dd5d437c6004b2e9459e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;expr&lt;/code&gt;, if any.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 的值（如果有）。</target>
        </trans-unit>
        <trans-unit id="efa4633a9b927147870c40861701a3a66f460ac4" translate="yes" xml:space="preserve">
          <source>The value of an</source>
          <target state="translated">价值</target>
        </trans-unit>
        <trans-unit id="e705d7da4d67602f093ecd07ec55976add979079" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember&lt;/i&gt;&lt;/a&gt; is given by its &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;. If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is the first</source>
          <target state="translated">一个值&lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember&lt;/i&gt;&lt;/a&gt;由其给出&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;赋值&lt;/i&gt;&lt;/a&gt;。如果没有&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;，它是第一个</target>
        </trans-unit>
        <trans-unit id="cfdd678ef3efc50d4d19e113e22570e812ee97e8" translate="yes" xml:space="preserve">
          <source>The value of cos(y) + i sin(y).</source>
          <target state="translated">cos(y)+i sin(y)的值。</target>
        </trans-unit>
        <trans-unit id="ce228048bba4c787805c0ea9367075ff06ba1fcc" translate="yes" xml:space="preserve">
          <source>The value of cosh(y) + i sinh(y)</source>
          <target state="translated">cosh(y)+i sinh(y)的值。</target>
        </trans-unit>
        <trans-unit id="dffcef37a6c60e8c1178ac476b670c4fbdc86276" translate="yes" xml:space="preserve">
          <source>The value of the bound being violated</source>
          <target state="translated">被违反的约束值</target>
        </trans-unit>
        <trans-unit id="911671dbc78d40ead01af236d912c34ae5fc15c4" translate="yes" xml:space="preserve">
          <source>The value of the selected choice.</source>
          <target state="translated">选择的价值。</target>
        </trans-unit>
        <trans-unit id="2079c7788ad766ba6207e480774a32436765df0d" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as a &lt;code&gt;long&lt;/code&gt;, or &lt;code&gt;long.max&lt;/code&gt;/&lt;code&gt;long.min&lt;/code&gt; if outside the representable range.</source>
          <target state="translated">这个值 &lt;code&gt;BigInt&lt;/code&gt; 有作为 &lt;code&gt;long&lt;/code&gt; ，或 &lt;code&gt;long.max&lt;/code&gt; / &lt;code&gt;long.min&lt;/code&gt; 如果可表示的范围之外。</target>
        </trans-unit>
        <trans-unit id="bfb5bbd989c9054cc2b242d5eea3691758f09eed" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as an &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;int.max&lt;/code&gt;/&lt;code&gt;int.min&lt;/code&gt; if outside the representable range.</source>
          <target state="translated">这个值 &lt;code&gt;BigInt&lt;/code&gt; 有作为 &lt;code&gt;int&lt;/code&gt; ，或 &lt;code&gt;int.max&lt;/code&gt; / &lt;code&gt;int.min&lt;/code&gt; 如果可表示的范围之外。</target>
        </trans-unit>
        <trans-unit id="44a86e613513bb5b90f75505c846e4f1a8d5e443" translate="yes" xml:space="preserve">
          <source>The value of x - i * y, where i is the number of times that y can be completely subtracted from x. The result has the same sign as x.</source>
          <target state="translated">x-i*y 的值,其中 i 是 y 可以完全从 x 中减去的次数,结果与 x 的符号相同。</target>
        </trans-unit>
        <trans-unit id="fbda37a05f283a201fa47e61f1a28829aac6ca57" translate="yes" xml:space="preserve">
          <source>The value that serves as the stopping criterion. This value is not included in the range.</source>
          <target state="translated">作为停止标准的值。此值不包括在范围内。</target>
        </trans-unit>
        <trans-unit id="06ef9451ca2a6ddc30c31abb46ec77c558d2c434" translate="yes" xml:space="preserve">
          <source>The value to act as a proxy for all operations. It must be an lvalue.</source>
          <target state="translated">作为所有操作的代理值。它必须是一个l值。</target>
        </trans-unit>
        <trans-unit id="c4437657364f8d6c0ea26bb67bc977fd2c3d6762" translate="yes" xml:space="preserve">
          <source>The value to add to the current value at each iteration.</source>
          <target state="translated">每次迭代时要加到当前值上的值。</target>
        </trans-unit>
        <trans-unit id="9ea1a4ae4b9c004c5d2afcb14b6504f978c0f7ea" translate="yes" xml:space="preserve">
          <source>The value to append.</source>
          <target state="translated">要附加的值。</target>
        </trans-unit>
        <trans-unit id="3e27e971fbf5a179f864e36ffcc71eeed5543b79" translate="yes" xml:space="preserve">
          <source>The value to be reference counted</source>
          <target state="translated">参考值的计算</target>
        </trans-unit>
        <trans-unit id="48cc3d885cf27d16c55ff2638b8883795263bff6" translate="yes" xml:space="preserve">
          <source>The value to bind to.</source>
          <target state="translated">要绑定的值。</target>
        </trans-unit>
        <trans-unit id="a802e0b8a3a2b83e804f3a0f0ce8a9cba9671bc8" translate="yes" xml:space="preserve">
          <source>The value to cast. It must be of type &lt;code&gt;From&lt;/code&gt;, otherwise a compile-time error is emitted.</source>
          <target state="translated">要转换的值。它必须是 &lt;code&gt;From&lt;/code&gt; 类型，否则会发出编译时错误。</target>
        </trans-unit>
        <trans-unit id="62da9509e3333e477d714ba7dbd138814897fd19" translate="yes" xml:space="preserve">
          <source>The value to clamp.</source>
          <target state="translated">要夹紧的数值。</target>
        </trans-unit>
        <trans-unit id="4ad7684bb8903fcc2f377acbdab0d055ec3933a5" translate="yes" xml:space="preserve">
          <source>The value to convert.</source>
          <target state="translated">要转换的值。</target>
        </trans-unit>
        <trans-unit id="50f2da1a55629d14637add94e8f4d0df9b3b3315" translate="yes" xml:space="preserve">
          <source>The value to divide from this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">要从此 &lt;code&gt;TickDuration&lt;/code&gt; 中除的值。</target>
        </trans-unit>
        <trans-unit id="0a1bf08b423c514be4510f8c180b0baca8c3ce06" translate="yes" xml:space="preserve">
          <source>The value to divide from this duration.</source>
          <target state="translated">从该持续时间中除以数值。</target>
        </trans-unit>
        <trans-unit id="1354007d97f6ba4733c332273819ddc621808569" translate="yes" xml:space="preserve">
          <source>The value to exchange.</source>
          <target state="translated">兑换的价值。</target>
        </trans-unit>
        <trans-unit id="1212730d5cf61a8236b91aa2562728d9cffb815c" translate="yes" xml:space="preserve">
          <source>The value to initialize this &lt;code&gt;Nullable&lt;/code&gt; with.</source>
          <target state="translated">用于初始化此 &lt;code&gt;Nullable&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="d9870b988dc93826e41d9e14caae258236099356" translate="yes" xml:space="preserve">
          <source>The value to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">该 &lt;code&gt;Duration&lt;/code&gt; 乘以的值。</target>
        </trans-unit>
        <trans-unit id="b63d59c749f4e3c4e27b5c62bc54fa60f14460d7" translate="yes" xml:space="preserve">
          <source>The value to multiply/divide this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">该 &lt;code&gt;Duration&lt;/code&gt; 乘以/除以的值。</target>
        </trans-unit>
        <trans-unit id="5f9706fe37a21ebb4f5356314e9dbb0f193612de" translate="yes" xml:space="preserve">
          <source>The value to search for.</source>
          <target state="translated">要搜索的价值。</target>
        </trans-unit>
        <trans-unit id="26611747ab051faf83da9bb9d7c2556f3251cdff" translate="yes" xml:space="preserve">
          <source>The value to store.</source>
          <target state="translated">要存储的值。</target>
        </trans-unit>
        <trans-unit id="572affcd555e45a118ca8c255703b01188667dc6" translate="yes" xml:space="preserve">
          <source>The value to test.</source>
          <target state="translated">要测试的数值。</target>
        </trans-unit>
        <trans-unit id="19051782b6b3c278237f01645d39c916e236a933" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
          <target state="translated">要写的值。</target>
        </trans-unit>
        <trans-unit id="ed8375fc18b2f2889a5d8178e1f4e71c024e1115" translate="yes" xml:space="preserve">
          <source>The value to yield.</source>
          <target state="translated">的价值,以产。</target>
        </trans-unit>
        <trans-unit id="36090b23e6b19abea403f7cf11708f739d6ebe0a" translate="yes" xml:space="preserve">
          <source>The value.</source>
          <target state="translated">价值。</target>
        </trans-unit>
        <trans-unit id="d9c7ac0f2459cf0fcaba3e1a3c53a1114b6dd604" translate="yes" xml:space="preserve">
          <source>The values of the statistics. Has the same length as &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="translated">统计信息的值。与 &lt;code&gt;opts&lt;/code&gt; 具有相同的长度。</target>
        </trans-unit>
        <trans-unit id="73dba46e865b8a15dc63f7dc2a467e9bb9da631f" translate="yes" xml:space="preserve">
          <source>The values to compare the value to.</source>
          <target state="translated">要比较的值。</target>
        </trans-unit>
        <trans-unit id="c472612eda8a57b671db853841e452b39218b0df" translate="yes" xml:space="preserve">
          <source>The values to select the maximum from. At least two arguments must be passed.</source>
          <target state="translated">要选择的最大值。必须至少传递两个参数。</target>
        </trans-unit>
        <trans-unit id="7a965cfb58b4af69ed40e336a152e8e938e3ae5e" translate="yes" xml:space="preserve">
          <source>The values to select the minimum from. At least two arguments must be passed, and they must be comparable with &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">从中选择最小值的值。至少必须传递两个参数，并且它们必须与 &lt;code&gt;&amp;lt;&lt;/code&gt; 相匹配。</target>
        </trans-unit>
        <trans-unit id="6c4b476e00d554e5b462693564ced434266700cc" translate="yes" xml:space="preserve">
          <source>The vararg module is intended to facilitate vararg manipulation in D. It should be interface compatible with the C module &quot;stdarg,&quot; and the two modules may share a common implementation if possible (as is done here).</source>
          <target state="translated">vararg模块的目的是为了方便在D中进行vararg操作,它应该与C模块 &quot;stdarg &quot;的接口兼容,如果可能的话,这两个模块可以共享一个共同的实现(这里就是这样做的)。</target>
        </trans-unit>
        <trans-unit id="e58c51068f71cad0c83773e1d40394fdd897c493" translate="yes" xml:space="preserve">
          <source>The variable to initialize</source>
          <target state="translated">要初始化的变量</target>
        </trans-unit>
        <trans-unit id="da94a792f23c83ccf884c163bc10a13c232be367" translate="yes" xml:space="preserve">
          <source>The variadic arguments are normally consumed in order. POSIX-style &lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt; positional parameter syntax&lt;/a&gt; is also supported. Each argument is formatted into a sequence of chars according to the format specification, and the characters are passed to &lt;code&gt;w&lt;/code&gt;. As many arguments as specified in the format string are consumed and formatted. If there are fewer arguments than format specifiers, a &lt;code&gt;FormatException&lt;/code&gt; is thrown. If there are more remaining arguments than needed by the format specification, they are ignored but only if at least one argument was formatted.</source>
          <target state="translated">可变参数通常按顺序使用。还支持POSIX样式的&lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt;位置参数语法&lt;/a&gt;。根据格式说明，每个自变量都被格式化为char序列，并将字符传递给 &lt;code&gt;w&lt;/code&gt; 。使用并格式化了格式字符串中指定的尽可能多的参数。如果参数少于格式说明符，则将引发 &lt;code&gt;FormatException&lt;/code&gt; 。如果剩余的参数超出了格式规范的要求，则仅当格式化至少一个参数时，它们才会被忽略。</target>
        </trans-unit>
        <trans-unit id="fa8f9f636d8a6045425f97a32a164b87a688ed99" translate="yes" xml:space="preserve">
          <source>The variadic part is converted to a dynamic array and the rest is the same as for non-variadic functions.</source>
          <target state="translated">变量部分转化为动态数组,其余与非变量函数相同。</target>
        </trans-unit>
        <trans-unit id="4280e8c5fae666595a22ad15b85940850cfe38e7" translate="yes" xml:space="preserve">
          <source>The vector extensions are currently implemented for the OS X 32 bit target, and all 64 bit targets.</source>
          <target state="translated">目前,OS X 32位目标和所有64位目标都实现了向量扩展。</target>
        </trans-unit>
        <trans-unit id="9a3f2a8776586397a6e7f50b19626acf584f35ca" translate="yes" xml:space="preserve">
          <source>The vendor specific version number, as in version_major.version_minor</source>
          <target state="translated">厂商特定的版本号,如 version_major.version_minor。</target>
        </trans-unit>
        <trans-unit id="00e7fe40797e665c537b4d388116b4be59e896ff" translate="yes" xml:space="preserve">
          <source>The version of the D Programming Language Specification supported by the compiler.</source>
          <target state="translated">编译器支持的D编程语言规范的版本。</target>
        </trans-unit>
        <trans-unit id="349a4c5870066cd09694037d969de8543ecfc287" translate="yes" xml:space="preserve">
          <source>The version specification makes it straightforward to group a set of features under one major version, for example:</source>
          <target state="translated">例如,版本规范可以直接将一组功能归入一个主要版本。</target>
        </trans-unit>
        <trans-unit id="8bd1d61a79fbe94ca1f6332082364d1be24742ef" translate="yes" xml:space="preserve">
          <source>The vtable consists of:</source>
          <target state="translated">该表包括:</target>
        </trans-unit>
        <trans-unit id="f3b5820f28d3bae10a6ec27f163ae2a69ac3fe29" translate="yes" xml:space="preserve">
          <source>The way the type of</source>
          <target state="translated">类型的方式</target>
        </trans-unit>
        <trans-unit id="0fcc6679e5070c2e4f446305491364698920c76a" translate="yes" xml:space="preserve">
          <source>The way to read this is: start with negative meaning that all numbers smaller then the next one are not present in this set (and positive - the contrary). Then switch positive/negative after each number passed from left to right.</source>
          <target state="translated">解读的方法是:从负数开始,意味着所有小于下一个数字的数字都不在这个集合中(正数则相反)。然后在从左到右的每一个数字之后切换正/负数。</target>
        </trans-unit>
        <trans-unit id="ee95d5338e2cc507c044af212b980a2ccdb0be06" translate="yes" xml:space="preserve">
          <source>The week that each time point in the range will be.</source>
          <target state="translated">周,范围内的每个时间点将。</target>
        </trans-unit>
        <trans-unit id="ccaf69d731f86b374a2484d6db7113668b98a057" translate="yes" xml:space="preserve">
          <source>The worker treads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by the &lt;code&gt;taskPool&lt;/code&gt; property are daemon by default. The worker threads of manually instantiated task pools are non-daemon by default.</source>
          <target state="translated">默认情况下，由 &lt;code&gt;taskPool&lt;/code&gt; 属性返回的 &lt;code&gt;TaskPool&lt;/code&gt; 实例中的worker进程是守护程序。默认情况下，手动实例化的任务池的工作线程是非守护程序。</target>
        </trans-unit>
        <trans-unit id="032848bfda222930e013953265615c3e0ccbd961" translate="yes" xml:space="preserve">
          <source>The working directory for the new process. By default the child process inherits the parent's working directory.</source>
          <target state="translated">新进程的工作目录。默认情况下,子进程继承父进程的工作目录。</target>
        </trans-unit>
        <trans-unit id="5b0246698510343503660da61604a3af0a5e9947" translate="yes" xml:space="preserve">
          <source>The wrapped statement.</source>
          <target state="translated">包的声明。</target>
        </trans-unit>
        <trans-unit id="83d3fe39ddb643ccc2434ee8c1b4b3abc6a78d80" translate="yes" xml:space="preserve">
          <source>The wrapped type for which Nullable provides a null value.</source>
          <target state="translated">Nullable提供空值的封装类型。</target>
        </trans-unit>
        <trans-unit id="52054c2c6d64acc406d7bd018817d7a8a1e5c5bf" translate="yes" xml:space="preserve">
          <source>The write end of the pipe.</source>
          <target state="translated">管道的写端。</target>
        </trans-unit>
        <trans-unit id="d72f5499f6b8ab39b36f3e5d6ad25d6e2121747c" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的年份设置为BC 年。</target>
        </trans-unit>
        <trans-unit id="70438f0b3fdbdd369345e88c2fd45090d92cb7e3" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的年份设置为的BC 年。</target>
        </trans-unit>
        <trans-unit id="744d36d482072547f2d6e876741e0a75ffde2547" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的年份设置为BC 年。</target>
        </trans-unit>
        <trans-unit id="90ffac4afd7dedd0db0cf62512494ecd5d03ce9b" translate="yes" xml:space="preserve">
          <source>The year of the day to validate.</source>
          <target state="translated">日的年份来验证。</target>
        </trans-unit>
        <trans-unit id="6a632533914c1a4222f015d798cec051375cb6c9" translate="yes" xml:space="preserve">
          <source>The year portion of the date.</source>
          <target state="translated">日期的年份部分。</target>
        </trans-unit>
        <trans-unit id="674f0ed2625d2fbf8d46e126ee7509b07e39337e" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的年份设置为的年份。</target>
        </trans-unit>
        <trans-unit id="78b3d4944643d10e9690ce8b16f07cee0b861543" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的年份设置为的年份。</target>
        </trans-unit>
        <trans-unit id="938c9fb56ce9737aba86f7a255d511c39f3f1219" translate="yes" xml:space="preserve">
          <source>The year to set this Date's year to.</source>
          <target state="translated">将这个Date的年份设定为。</target>
        </trans-unit>
        <trans-unit id="25dac3542e9629d3c6f770b554d3c9420550d89e" translate="yes" xml:space="preserve">
          <source>The year to to be tested.</source>
          <target state="translated">年待测。</target>
        </trans-unit>
        <trans-unit id="b05a3a1416ac42134535e13e8cceef19ad3efbf2" translate="yes" xml:space="preserve">
          <source>The ~= operator. It can have one of the following operators:</source>
          <target state="translated">~=运算符。它可以有以下运算符之一。</target>
        </trans-unit>
        <trans-unit id="483dc9258037e4ea0f71ce99febdf439cc645ac7" translate="yes" xml:space="preserve">
          <source>Then each of the arguments whose type does not match that of the delegate is converted to a delegate.</source>
          <target state="translated">然后将每个类型不符合委托人的参数转换为委托人。</target>
        </trans-unit>
        <trans-unit id="4ef903eb9cd7218e2998c6f06dec42c64cb3057d" translate="yes" xml:space="preserve">
          <source>ThenStatement</source>
          <target state="translated">ThenStatement</target>
        </trans-unit>
        <trans-unit id="cffa55acb530a469e1c0e72f460da047941e3e1e" translate="yes" xml:space="preserve">
          <source>There are advantages to storing bookkeeping data separated from the payload (as opposed to e.g. using &lt;code&gt;AffixAllocator&lt;/code&gt; to store metadata together with each allocation). The layout is more compact (overhead is one bit per block), searching for a free block during allocation enjoys better cache locality, and deallocation does not touch memory around the payload being deallocated (which is often cold).</source>
          <target state="translated">存储与有效负载分离的簿记数据具有优势（例如，与使用 &lt;code&gt;AffixAllocator&lt;/code&gt; 一起将元数据与每个分配存储在一起）。布局更紧凑（开销为每个块一位），在分配期间搜索空闲块享有更好的缓存局部性，并且释放不会触及正在释放的有效负载周围的内存（这通常很冷）。</target>
        </trans-unit>
        <trans-unit id="71da829c4cc0769086794220605ec04ef8da0ce9" translate="yes" xml:space="preserve">
          <source>There are eight usable logging level. These level are</source>
          <target state="translated">有8个可用的记录级别。这些级别是</target>
        </trans-unit>
        <trans-unit id="88bbdd16439c34d51b5285ff9a938ae545ede756" translate="yes" xml:space="preserve">
          <source>There are four kinds of arrays:</source>
          <target state="translated">阵列有四种。</target>
        </trans-unit>
        <trans-unit id="e137971ce6d07a865f890bb2bb72e21617522984" translate="yes" xml:space="preserve">
          <source>There are four overloads of this function. The first two take an array of strings, &lt;code&gt;args&lt;/code&gt;, which should contain the program name as the zeroth element and any command-line arguments in subsequent elements. The third and fourth versions are included for convenience, and may be used when there are no command-line arguments. They take a single string, &lt;code&gt;program&lt;/code&gt;, which specifies the program name.</source>
          <target state="translated">此函数有四个重载。前两个采用字符串数组 &lt;code&gt;args&lt;/code&gt; ，其中应包含程序名称作为第零个元素，并在后续元素中包含任何命令行参数。为了方便起见，包括了第三和第四版本，并且在没有命令行参数时可以使用它们。它们采用单个字符串 &lt;code&gt;program&lt;/code&gt; ，它指定程序名称。</target>
        </trans-unit>
        <trans-unit id="72dc9dd21f6b2060d2cd40a0fb38433822ac81cb" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="translated">此模块中有一些辅助函数，这些函数生成公共委托以传递给 &lt;code&gt;bwdRange&lt;/code&gt; 。他们的文档以&amp;ldquo;范围生成功能&amp;rdquo;开始，使其易于搜索。</target>
        </trans-unit>
        <trans-unit id="b5dd0af54e988a94be1d9ad088b9582f13489afd" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="translated">此模块中有一些辅助函数，这些函数生成公共委托以传递给 &lt;code&gt;bwdRange&lt;/code&gt; 。他们的文档以&amp;ldquo;范围生成功能&amp;rdquo;开始，以使其易于搜索。</target>
        </trans-unit>
        <trans-unit id="7d94c1629b0bd4094ede841815962ed80d0586ef" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="translated">此模块中有一些辅助函数，这些函数生成公共委托以传递给 &lt;code&gt;fwdRange&lt;/code&gt; 。他们的文档以&amp;ldquo;范围生成功能&amp;rdquo;开始，使其易于搜索。</target>
        </trans-unit>
        <trans-unit id="4b9f6a69e089c92a07a88022f54475869259bbc2" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="translated">此模块中有一些辅助函数，这些函数生成公共委托以传递给 &lt;code&gt;fwdRange&lt;/code&gt; 。他们的文档以&amp;ldquo;范围生成功能&amp;rdquo;开始，以使其易于搜索。</target>
        </trans-unit>
        <trans-unit id="fd1414ed61178080af45a1f5ca51914c6e9d26e1" translate="yes" xml:space="preserve">
          <source>There are many articles available that can bolster understanding ranges:</source>
          <target state="translated">有很多文章可以支撑理解范围。</target>
        </trans-unit>
        <trans-unit id="c2d037a1149b17d68159307022f28fe56d8f92d3" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt;&lt;/a&gt;, or other such C &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;extended type modifiers&lt;/a&gt; in D. These are handled by &lt;a href=&quot;attribute#linkage&quot;&gt;linkage attributes&lt;/a&gt;, such as &lt;code&gt;extern (C)&lt;/code&gt;.</source>
          <target state="translated">有没有 &lt;code&gt;__cdecl&lt;/code&gt; ， &lt;code&gt;__far&lt;/code&gt; ， &lt;code&gt;__stdcall&lt;/code&gt; ，&lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt; &lt;/a&gt;，或其它这样的&amp;Ccedil; &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;扩展型改性剂&lt;/a&gt;中D.这些通过处理&lt;a href=&quot;attribute#linkage&quot;&gt;联动的属性&lt;/a&gt;，诸如 &lt;code&gt;extern (C)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b9f66c209295069e84d0b1adcf2cd5cdb6933de" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;code&gt;__declspec&lt;/code&gt;, or other such nonstandard C++ extensions in D.</source>
          <target state="translated">有没有 &lt;code&gt;__cdecl&lt;/code&gt; ， &lt;code&gt;__far&lt;/code&gt; ， &lt;code&gt;__stdcall&lt;/code&gt; ， &lt;code&gt;__declspec&lt;/code&gt; ，或在D.其它这样的非标准C ++扩展</target>
        </trans-unit>
        <trans-unit id="b1bbd1ded800fb7f0f4f094477d38ab432c667c3" translate="yes" xml:space="preserve">
          <source>There are no volatile type modifiers in D.</source>
          <target state="translated">D中没有挥发型修饰词。</target>
        </trans-unit>
        <trans-unit id="bf7de3e93eae097ffa9c0cf65d8e97655fc5a893" translate="yes" xml:space="preserve">
          <source>There are other web resources on regular expressions to help newcomers, and a good &lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;reference with tutorial&lt;/a&gt; can easily be found.</source>
          <target state="translated">正则表达式上还有其他Web资源可以帮助新手，并且可以轻松找到&lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;教程&lt;/a&gt;的良好参考。</target>
        </trans-unit>
        <trans-unit id="6c5539350a7f6635346ecf0167abeb30fa2fea73" translate="yes" xml:space="preserve">
          <source>There are several forms of the</source>
          <target state="translated">有几种形式</target>
        </trans-unit>
        <trans-unit id="6bdc06ec8e2f529ede508fc3fd01087470669fa0" translate="yes" xml:space="preserve">
          <source>There are several things going on here:</source>
          <target state="translated">这里有几件事。</target>
        </trans-unit>
        <trans-unit id="06fc1953f9bbd669c6940d581b7a118ebf65b6cd" translate="yes" xml:space="preserve">
          <source>There are several workarounds for this limitation:</source>
          <target state="translated">对于这个限制,有几种变通方法。</target>
        </trans-unit>
        <trans-unit id="83683e99bdd11374a698bc33993ac450a4156b31" translate="yes" xml:space="preserve">
          <source>There are three categories of functions from the perspective of memory safety:</source>
          <target state="translated">从内存安全的角度看,有三类功能。</target>
        </trans-unit>
        <trans-unit id="eebb936bce7d3ae26cde36cf7bb35604dacc5791" translate="yes" xml:space="preserve">
          <source>There are three kinds of comments:</source>
          <target state="translated">有三种意见。</target>
        </trans-unit>
        <trans-unit id="0ec3b7350c3966a7a5f315773f8a0d6461bc2b7c" translate="yes" xml:space="preserve">
          <source>There are two APIs for digests: The template API and the OOP API. The template API uses structs and template helpers like &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;. The OOP API implements digests as classes inheriting the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; interface. All digests are named so that the template API struct is called &quot;&lt;b&gt;x&lt;/b&gt;&quot; and the OOP API class is called &quot;&lt;b&gt;x&lt;/b&gt;Digest&quot;. For example we have &lt;code&gt;MD5&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt;, &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt;, etc.</source>
          <target state="translated">有两种用于摘要的API：模板API和OOP API。模板API使用结构和模板助手，例如&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;。 OOP API将摘要实现为继承&lt;a href=&quot;#Digest&quot;&gt; &lt;code&gt;Digest&lt;/code&gt; &lt;/a&gt;接口的类。所有摘要均已命名，因此模板API结构被称为&amp;ldquo; &lt;b&gt;x&lt;/b&gt; &amp;rdquo;，而OOP API类被称为&amp;ldquo; &lt;b&gt;x&lt;/b&gt; Digest&amp;rdquo;。例如，我们有 &lt;code&gt;MD5&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt; ， &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="f36743287cbe9730e4d00f520be725403f6d9245" translate="yes" xml:space="preserve">
          <source>There are two broad kinds of operations to do on an array - affecting the handle to the array, and affecting the contents of the array.</source>
          <target state="translated">在数组上有两大类操作--影响数组的句柄和影响数组的内容。</target>
        </trans-unit>
        <trans-unit id="2f32e0774371c9709a85def64d98a62e794b8e4d" translate="yes" xml:space="preserve">
          <source>There are two options for handlers. The &lt;code&gt;bool&lt;/code&gt; version is deprecated but will be kept for legacy support. Returning &lt;code&gt;true&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.pass&lt;/code&gt; from the extended version. Returning &lt;code&gt;false&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.fail&lt;/code&gt; from the extended version.</source>
          <target state="translated">处理程序有两个选项。该 &lt;code&gt;bool&lt;/code&gt; 版本已弃用，但会保留传统支持。从处理程序返回 &lt;code&gt;true&lt;/code&gt; 等同于从扩展版本返回 &lt;code&gt;UnitTestResult.pass&lt;/code&gt; 。从处理程序中返回 &lt;code&gt;false&lt;/code&gt; 等同于从扩展版本中返回 &lt;code&gt;UnitTestResult.fail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ba98a9e569b41d605493fc4327d51d93311f773" translate="yes" xml:space="preserve">
          <source>There are two ways of using tilde expansion in a path. One involves using the tilde alone or followed by a path separator. In this case, the tilde will be expanded with the value of the environment variable &lt;code&gt;HOME&lt;/code&gt;. The second way is putting a username after the tilde (i.e. &lt;code&gt;~john/Mail&lt;/code&gt;). Here, the username will be searched for in the user database (i.e. &lt;code&gt;/etc/passwd&lt;/code&gt; on Unix systems) and will expand to whatever path is stored there. The username is considered the string after the tilde ending at the first instance of a path separator.</source>
          <target state="translated">有两种在路径中使用波浪号扩展的方法。其中之一是单独使用波浪号，或者使用路径分隔符。在这种情况下，代字号将使用环境变量 &lt;code&gt;HOME&lt;/code&gt; 的值扩展。第二种方法是将用户名放在波浪号后面（即 &lt;code&gt;~john/Mail&lt;/code&gt; ）。在这里，将在用户数据库（即Unix系统上的 &lt;code&gt;/etc/passwd&lt;/code&gt; ）中搜索用户名，并将其扩展到存储在其中的任何路径。用户名被视为波浪符号后的字符串，该字符串在路径分隔符的第一个实例处结束。</target>
        </trans-unit>
        <trans-unit id="4751b63f33932c16045492e8c9d0524f058f4c0a" translate="yes" xml:space="preserve">
          <source>There are two ways to declarate a symbol as member of a namespace: &lt;code&gt;Nspace&lt;/code&gt; and &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt;. The former creates a scope for the symbol, and inject them in the parent scope at the same time. The later, this class, has no semantic implications and is only used for mangling. Additionally, this class allows one to use reserved identifiers (D keywords) in the namespace.</source>
          <target state="translated">有两种方法可以将符号声明为名称空间的成员： &lt;code&gt;Nspace&lt;/code&gt; 和 &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt; 。前者为符号创建作用域，然后将其同时注入父作用域。后面的类没有语义含义，仅用于修饰。另外，此类允许一个人在名称空间中使用保留的标识符（D关键字）。</target>
        </trans-unit>
        <trans-unit id="87bb5bc4a10799fcef3cdb638af33c37c5ac5274" translate="yes" xml:space="preserve">
          <source>There can be any number of unit test functions in a module, including within struct, union and class declarations. They are executed in lexical order.</source>
          <target state="translated">在一个模块中可以有任何数量的单元测试函数,包括在结构、联合和类的声明中。它们是按照词法顺序执行的。</target>
        </trans-unit>
        <trans-unit id="ed108d2e4ffaebbc3cca03de1cfa2dee10188c4a" translate="yes" xml:space="preserve">
          <source>There can be more than one invariant declared per class or struct.</source>
          <target state="translated">每个类或结构可以声明一个以上的不变量。</target>
        </trans-unit>
        <trans-unit id="07b99c3830a2a4bb0228e8b9b17dd7669ccd56c2" translate="yes" xml:space="preserve">
          <source>There can be multiple documented unittests and they can appear in any order. They will be attached to the last non-unittest declaration:</source>
          <target state="translated">可以有多个记录的单元测试,它们可以以任何顺序出现。它们将被附加到最后一个非unittest声明中。</target>
        </trans-unit>
        <trans-unit id="a95e25d0165fbf5408fd68a513879e3e08629026" translate="yes" xml:space="preserve">
          <source>There can be multiple static constructors and static destructors within one module. The static constructors are run in lexical order, the static destructors are run in reverse lexical order.</source>
          <target state="translated">在一个模块中可以有多个静态构造函数和静态破坏函数,静态构造函数按词法顺序运行,静态破坏函数按反向词法顺序运行。静态构造函数按词法顺序运行,静态破坏函数按相反的词法顺序运行。</target>
        </trans-unit>
        <trans-unit id="079786d2cc065de51998cade65524ac448945bab" translate="yes" xml:space="preserve">
          <source>There can be only one destructor per class, the destructor does not have any parameters, and has no attributes. It is always virtual.</source>
          <target state="translated">每个类只能有一个destructor,destructor没有任何参数,也没有属性。它永远是虚拟的。</target>
        </trans-unit>
        <trans-unit id="a32fb137b8708f3a1060842effbe53862ee224b5" translate="yes" xml:space="preserve">
          <source>There can be only zero or one</source>
          <target state="translated">只能有零或一</target>
        </trans-unit>
        <trans-unit id="e54e87553bcbc89bb92a0dbc881f7633b6a68acf" translate="yes" xml:space="preserve">
          <source>There has been a great deal of discussion in the D newsgroups over this, and several implementations:  &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;signal slots library&lt;/a&gt;</source>
          <target state="translated">D新闻组对此进行了大量讨论，并讨论了几种实现方式： &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;信号槽库&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb4241af492e556aa6aed9941d820f825c722aec" translate="yes" xml:space="preserve">
          <source>There have been several D implementations of Signals and Slots. This version makes use of several new features in D, which make using it simpler and less error prone. In particular, it is no longer necessary to instrument the slots.</source>
          <target state="translated">信号和槽的D版实现已经有好几个了。这个版本利用了D中的一些新特性,使其使用更加简单,不易出错。特别是,不再需要对槽进行仪表化。</target>
        </trans-unit>
        <trans-unit id="137e54850bfef26233dbe4876142a62cdeee9d88" translate="yes" xml:space="preserve">
          <source>There is a hierarchy of allocation kinds. When an allocator is implemented for a given combination of flags, it is used. Otherwise, the next down the list is chosen.</source>
          <target state="translated">分配器的种类是有层次的。当给定的标志组合有一个分配器时,就会使用它。否则,就会选择下一个分配器。</target>
        </trans-unit>
        <trans-unit id="fb4bb1493d0166938db3cf214276bbc597f0dc3b" translate="yes" xml:space="preserve">
          <source>There is a rich set of functions for string handling defined in other modules. Functions related to Unicode and ASCII are found in &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_ascii&quot;&gt;&lt;code&gt;std.ascii&lt;/code&gt;&lt;/a&gt;, respectively. Other functions that have a wider generality than just strings can be found in &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">There is a rich set of functions for string handling defined in other modules. Functions related to Unicode and ASCII are found in &lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;std_ascii&quot;&gt; &lt;code&gt;std.ascii&lt;/code&gt; &lt;/a&gt;, respectively. Other functions that have a wider generality than just strings can be found in &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="567058ffed748f85071d989bbf1a314374e793b2" translate="yes" xml:space="preserve">
          <source>There is a special type of array which acts as a wildcard that can hold arrays of any kind, declared as &lt;code&gt;void[]&lt;/code&gt;. Void arrays are used for low-level operations where some kind of array data is being handled, but the exact type of the array elements are unimportant. The &lt;code&gt;.length&lt;/code&gt; of a void array is the length of the data in bytes, rather than the number of elements in its original type. Array indices in indexing and slicing operations are interpreted as byte indices.</source>
          <target state="translated">有一种特殊类型的数组，它充当通配符，可以保存任何声明为 &lt;code&gt;void[]&lt;/code&gt; 数组。空数组用于处理某些数组数据的低级操作，但是数组元素的确切类型并不重要。空数组的 &lt;code&gt;.length&lt;/code&gt; 是数据的长度（以字节为单位），而不是其原始类型中的元素数。索引和切片操作中的数组索引被解释为字节索引。</target>
        </trans-unit>
        <trans-unit id="33cea21ca6b34b343eb25bbde6ebec03ec759bdc" translate="yes" xml:space="preserve">
          <source>There is currently only one special token sequence, &lt;code&gt;#line&lt;/code&gt;.</source>
          <target state="translated">当前只有一个特殊的令牌序列 &lt;code&gt;#line&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef49fac97d8d2e188e2b78d1a813470cc50ed39b" translate="yes" xml:space="preserve">
          <source>There is currently work in progress to make the runtime library free of GC heap allocations, to allow its use in scenarios where the use of GC infrastructure is not possible.</source>
          <target state="translated">目前正在努力使运行时库摆脱GC堆分配,以便在不可能使用GC基础设施的场景中使用它。</target>
        </trans-unit>
        <trans-unit id="4d933b4164fe170e150ab2367873a597423583d2" translate="yes" xml:space="preserve">
          <source>There is no more need to translate error codes into human readable strings, the correct string is generated by the error detection code, not the error recovery code. This also leads to consistent error messages for the same error between applications.</source>
          <target state="translated">不再需要将错误代码翻译成人类可读的字符串,正确的字符串由错误检测代码生成,而不是错误恢复代码。这也导致了不同应用程序之间相同错误的错误信息的一致性。</target>
        </trans-unit>
        <trans-unit id="f17b623fe683ff68f6ed189b8d0d74d5452c95d7" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 不会占用 &lt;code&gt;NegInfInterval&lt;/code&gt; 的重载，因为不可能有从负无穷大到正无穷大的间隔。</target>
        </trans-unit>
        <trans-unit id="e26153f4d19858ed80c05ff7d79d4191b5074d49" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 不会占用 &lt;code&gt;PosInfInterval&lt;/code&gt; 的重载，因为不可能有从负无穷大到正无穷大的间隔。</target>
        </trans-unit>
        <trans-unit id="5f100a7a77aee94633ec1e2fffc1096ce477240e" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">没有占用 &lt;code&gt;NegInfInterval&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt; 过载，因为不可能有从负无穷大到正无穷大的间隔。</target>
        </trans-unit>
        <trans-unit id="5ac7b0e8d9f0ebf981b0a2590d75065c28e84b23" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">没有一个需要 &lt;code&gt;PosInfInterval&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt; 过载，因为从负无穷大到正无穷大的间隔是不可能的。</target>
        </trans-unit>
        <trans-unit id="f2973bc2fd6add6e6231856c6dedc987f0924540" translate="yes" xml:space="preserve">
          <source>There is no remove command functionality. Do a &lt;a href=&quot;#clearCommands&quot;&gt;&lt;code&gt;clearCommands&lt;/code&gt;&lt;/a&gt; and set the needed commands instead.</source>
          <target state="translated">没有删除命令功能。执行&lt;a href=&quot;#clearCommands&quot;&gt; &lt;code&gt;clearCommands&lt;/code&gt; &lt;/a&gt;并设置所需的命令。</target>
        </trans-unit>
        <trans-unit id="5030f2329ed730fd9eebd4cf5437fa2be5db1b38" translate="yes" xml:space="preserve">
          <source>There is no remove header functionality. Do a &lt;a href=&quot;#clearRequestHeaders&quot;&gt;&lt;code&gt;clearRequestHeaders&lt;/code&gt;&lt;/a&gt; and set the needed headers instead.</source>
          <target state="translated">没有删除标头功能。执行&lt;a href=&quot;#clearRequestHeaders&quot;&gt; &lt;code&gt;clearRequestHeaders&lt;/code&gt; &lt;/a&gt;并设置所需的标头。</target>
        </trans-unit>
        <trans-unit id="97b11eff895aae8a00d7fa461823417d322a76c8" translate="yes" xml:space="preserve">
          <source>There is no virtual table.</source>
          <target state="translated">没有虚拟表。</target>
        </trans-unit>
        <trans-unit id="5dac0a061658caed895ea08b3637f43c40d7da9d" translate="yes" xml:space="preserve">
          <source>There is no volatile type modifier in D. To declare a C function that uses volatile, just drop the keyword from the declaration.</source>
          <target state="translated">D中没有volatile类型修饰符,如果要声明一个使用volatile的C函数,只需在声明中去掉关键字即可。</target>
        </trans-unit>
        <trans-unit id="2434d329704768f135cc60da2cb84c7ba22ac13f" translate="yes" xml:space="preserve">
          <source>There is one exception to the fact that the new type is not related to the old type. &lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;Pseudo-member&lt;/a&gt; functions are usable with the new type; they will be forwarded on to the proxied value.</source>
          <target state="translated">新类型与旧类型无关的事实是一个例外。&lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;伪成员&lt;/a&gt;函数可与新类型一起使用。他们将被转发到代理价值。</target>
        </trans-unit>
        <trans-unit id="ba21f8033d033a747c90b386e1729af20f18ceb8" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a class. They are applied in lexical order.</source>
          <target state="translated">一个类中可能有多个不变量。它们是按词法顺序应用的。</target>
        </trans-unit>
        <trans-unit id="9a039cc903df4604c54902450e403871fe046481" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a struct. They are applied in lexical order.</source>
          <target state="translated">一个结构中可能有多个不变量。它们是按词法顺序应用的。</target>
        </trans-unit>
        <trans-unit id="d77d0c2b7a22ee08dcc65faf1983734627d5bea1" translate="yes" xml:space="preserve">
          <source>There may be one or more callable entities (&lt;code&gt;functions&lt;/code&gt; argument) to apply.</source>
          <target state="translated">可能有一个或多个可调用的实体（ &lt;code&gt;functions&lt;/code&gt; 参数）要应用。</target>
        </trans-unit>
        <trans-unit id="32ca8690590fc77f40e2a27fd064159d0d52468b" translate="yes" xml:space="preserve">
          <source>There must be at least one non-variadic parameter declared.</source>
          <target state="translated">必须至少声明一个非变量参数。</target>
        </trans-unit>
        <trans-unit id="60b895f637fb0461c08aa3c29c276b9513bb30e3" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a function symbol.</source>
          <target state="translated">必须有一个&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression，&lt;/i&gt;&lt;/a&gt;并且它必须在编译时对函数符号求值。</target>
        </trans-unit>
        <trans-unit id="ed59ba7f34618cfcf4f2f62b488d49f3556f524b" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a string literal.</source>
          <target state="translated">必须有一个&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression，&lt;/i&gt;&lt;/a&gt;并且它必须在编译时计算为字符串文字。</target>
        </trans-unit>
        <trans-unit id="9800621b870999653a584633cd52d141e5fbaea7" translate="yes" xml:space="preserve">
          <source>There's only one instance of each module, and it is statically allocated.</source>
          <target state="translated">每个模块只有一个实例,而且是静态分配的。</target>
        </trans-unit>
        <trans-unit id="2acf8c215fcf96c4f44ab4510da81603fd6cc2b3" translate="yes" xml:space="preserve">
          <source>Therefore, it is the programmer's responsibility to ensure that &lt;code&gt;opCmp&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; are consistent with each other. If &lt;code&gt;opEquals&lt;/code&gt; is not specified, the compiler provides a default version that does member-wise comparison. If this suffices, one may define only &lt;code&gt;opCmp&lt;/code&gt; to customize the behaviour of the inequality operators. But if not, then a custom version of &lt;code&gt;opEquals&lt;/code&gt; should be defined as well, in order to preserve consistent semantics between the two kinds of comparison operators.</source>
          <target state="translated">因此，程序员有责任确保 &lt;code&gt;opCmp&lt;/code&gt; 和 &lt;code&gt;opEquals&lt;/code&gt; 彼此一致。如果未指定 &lt;code&gt;opEquals&lt;/code&gt; ，则编译器将提供一个默认版本，该版本会进行成员比较。如果足够，可以只定义 &lt;code&gt;opCmp&lt;/code&gt; 来自定义不等式运算符的行为。但是，如果没有，则还应该定义 &lt;code&gt;opEquals&lt;/code&gt; 的自定义版本，以保留两种比较运算符之间的一致语义。</target>
        </trans-unit>
        <trans-unit id="f6272f7f8273a14bd5544dddbcb1b98032093e68" translate="yes" xml:space="preserve">
          <source>These allow you to construct a &lt;code&gt;Duration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="translated">这些允许您从具有给定长度的给定时间单位构造 &lt;code&gt;Duration&lt;/code&gt; 时间。</target>
        </trans-unit>
        <trans-unit id="da7cf3cb33f506c60b3bae2d7621731fe8a25b5a" translate="yes" xml:space="preserve">
          <source>These are a temporary means of providing a GC hook for DLL use. They may be replaced with some other similar functionality later.</source>
          <target state="translated">这些是为DLL的使用提供GC钩子的一种临时手段。以后可能会被其他类似的功能所取代。</target>
        </trans-unit>
        <trans-unit id="6b408f5f827798e4336b44c606a3a8049fa5f385" translate="yes" xml:space="preserve">
          <source>These are convenience aliases for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the SHA implementation.</source>
          <target state="translated">这些是使用SHA实现的&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; 的&lt;/a&gt;方便别名。</target>
        </trans-unit>
        <trans-unit id="cc11c250252b92e0b68a712fc50db2f954bbf31e" translate="yes" xml:space="preserve">
          <source>These are found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;rt/&lt;/a&gt;.</source>
          <target state="translated">这些可以在Druntime的&lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;rt /&lt;/a&gt;中找到。</target>
        </trans-unit>
        <trans-unit id="d82964c86f7448130324ef200af867ae90f45f65" translate="yes" xml:space="preserve">
          <source>These are mostly undocumented, as documentation for the functions these declarations provide bindings to can be found on external resources.</source>
          <target state="translated">这些声明大多是无文档的,因为这些声明提供绑定的函数的文档可以在外部资源中找到。</target>
        </trans-unit>
        <trans-unit id="a0b799b4059387b1ffa81eb5e832597a15aaf9ea" translate="yes" xml:space="preserve">
          <source>These are not directly overloadable, but instead are rewritten in terms of the ++</source>
          <target state="translated">这些都是不能直接过载的,而是用++的方式重写的。</target>
        </trans-unit>
        <trans-unit id="684251477ee92646066796884e053236894cc9d8" translate="yes" xml:space="preserve">
          <source>These are not to be conflated with atomic operations. They do not guarantee any atomicity. This may be provided by coincidence as a result of the instructions used on the target, but this should not be relied on for portable programs. Further, no memory fences are implied by these functions. They should not be used for communication between threads. They may be used to guarantee a write or read cycle occurs at a specified address.</source>
          <target state="translated">这些不能与原子操作混为一谈。它们不保证任何原子性。这可能是由于在目标上使用的指令的巧合而提供的,但对于可移植程序来说,不应该依赖这一点。此外,这些函数没有暗示任何内存栅栏。它们不应该用于线程之间的通信。它们可用于保证写或读周期发生在指定地址。</target>
        </trans-unit>
        <trans-unit id="ebd50df5a290d3b9f19a683a307dc1ce5e6fed02" translate="yes" xml:space="preserve">
          <source>These are of type &lt;code&gt;bool&lt;/code&gt; and when cast to another integral type become the values 1 and 0, respectively.</source>
          <target state="translated">它们是 &lt;code&gt;bool&lt;/code&gt; 类型，当转换为另一个整数类型时，其值分别为1和0。</target>
        </trans-unit>
        <trans-unit id="812c2acf872ebe10657aaa2bbdf1807e2d587d11" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-debug=&lt;/code&gt;</source>
          <target state="translated">这些大概是在命令行中设置为 &lt;code&gt;-debug=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c1d2e1e32630d5e744bf290c6e49eb16fa04f9" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-version=n&lt;/code&gt; and &lt;code&gt;-version=identifier&lt;/code&gt;.</source>
          <target state="translated">大概在命令行中将它们设置为 &lt;code&gt;-version=n&lt;/code&gt; 和 &lt;code&gt;-version=identifier&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2ddfd41f42add825e0e95354286885963260165" translate="yes" xml:space="preserve">
          <source>These are the return codes for the seek callbacks</source>
          <target state="translated">这些是seek回调的返回代码。</target>
        </trans-unit>
        <trans-unit id="402db899657981891e40b75b734371cded453058" translate="yes" xml:space="preserve">
          <source>These are the same kinds of scenarios where different optimization settings affect the results.</source>
          <target state="translated">这些都是同种情况下,不同的优化设置会影响结果。</target>
        </trans-unit>
        <trans-unit id="1b6a4816df5dd7b7abf0b558eca9229ade75c78d" translate="yes" xml:space="preserve">
          <source>These arrays are statically allocated when they appear in global scope. Otherwise, they need to be marked with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; storage classes to make them statically allocated arrays.</source>
          <target state="translated">这些数组出现在全局范围中时将被静态分配。否则，需要将它们标记为 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 存储类，以使其成为静态分配的数组。</target>
        </trans-unit>
        <trans-unit id="89a145122969b840110b2fc3e84b6ee09c611afa" translate="yes" xml:space="preserve">
          <source>These attributes may appear after the formal parameter list, in which case they apply either to a method's &lt;code&gt;this&lt;/code&gt; parameter, or to a free function's first parameter</source>
          <target state="translated">这些属性可能出现在形式参数列表之后，在这种情况下，它们要么应用于方法的 &lt;code&gt;this&lt;/code&gt; 参数，要么应用于自由函数的第一个参数。</target>
        </trans-unit>
        <trans-unit id="a7f7fc51e48ac814a4df7b5cf79166bee33de381" translate="yes" xml:space="preserve">
          <source>These attributes may be inferred when the compiler has the function body available, such as with templates.</source>
          <target state="translated">这些属性可以在编译器有函数体可用时推断出来,比如用模板。</target>
        </trans-unit>
        <trans-unit id="2c92e5f8eec2fac65821b6ee901edef5b0d32346" translate="yes" xml:space="preserve">
          <source>These behaviors may be specified when a mailbox is full.</source>
          <target state="translated">当邮箱已满时,可指定这些行为。</target>
        </trans-unit>
        <trans-unit id="36131b1e9db1f47f4a6ae00babc38af51f8234a5" translate="yes" xml:space="preserve">
          <source>These characters are not normally used in isolation unless they are being described. They include such characters as accents, diacritics, Hebrew points, Arabic vowel signs, and Indic matras.</source>
          <target state="translated">这些字符通常不单独使用,除非正在描述它们。它们包括重音、双音符、希伯来语点、阿拉伯语元音符号和印地语母音等字符。</target>
        </trans-unit>
        <trans-unit id="5af07f8dc23a2ff314c5b53d75ac93fc8390edf4" translate="yes" xml:space="preserve">
          <source>These compound format specifiers may be nested in the case of a nested array argument:</source>
          <target state="translated">在嵌套数组参数的情况下,这些复合格式指定符可以被嵌套。</target>
        </trans-unit>
        <trans-unit id="636ef2d434aea6975bee7e2e69eaea244d21ce1f" translate="yes" xml:space="preserve">
          <source>These constraints are addressed by techniques outlined in &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;Memory Management&lt;/a&gt;, including the mechanisms provided by D to control allocations outside the GC heap.</source>
          <target state="translated">这些限制通过&amp;ldquo; &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;内存管理&amp;rdquo;中&lt;/a&gt;概述的技术来解决，其中包括D提供的用于控制GC堆外部分配的机制。</target>
        </trans-unit>
        <trans-unit id="ce5525a7da98014873ce5f20228128913e88d54f" translate="yes" xml:space="preserve">
          <source>These declarations are transformed into templates:</source>
          <target state="translated">这些声明被转化为模板。</target>
        </trans-unit>
        <trans-unit id="cd87aa675633720f30baafcf6365c73aa7dc6850" translate="yes" xml:space="preserve">
          <source>These directories are recognized by some tools, like the Objective-C compiler and linker, to be frameworks. To link with a framework from DMD, use the following flags:</source>
          <target state="translated">这些目录被一些工具,比如Objective-C编译器和链接器,识别为框架。要与DMD中的框架链接,请使用以下标志。</target>
        </trans-unit>
        <trans-unit id="2db5010283f3eff8277b4bb683d65dd36da0605f" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_HTTP_VERSION option.</source>
          <target state="translated">这些枚举与CURLOPT_HTTP_VERSION选项一起使用。</target>
        </trans-unit>
        <trans-unit id="66b51419f8ca45e5302436f93fca4afec04366fd" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_NETRC option.</source>
          <target state="translated">这些枚举与CURLOPT_NETRC选项一起使用。</target>
        </trans-unit>
        <trans-unit id="792d4e3a997f4a55954321b6a67c17e920eebf88" translate="yes" xml:space="preserve">
          <source>These equivalents hold for most C compilers. The C standard does not pin down the sizes of the types, so some care is needed.</source>
          <target state="translated">这些等价物适用于大多数C编译器。C标准并没有明确规定类型的大小,所以需要注意。</target>
        </trans-unit>
        <trans-unit id="dd5b42710c6e5261013fdb1ae53fc4cbc41fd9bf" translate="yes" xml:space="preserve">
          <source>These equivalents hold when the D and C++ compilers used are companions on the host platform.</source>
          <target state="translated">当使用的D和C++编译器是主机平台上的同伴时,这些等价物成立。</target>
        </trans-unit>
        <trans-unit id="90ade43ed5cb1a3092e67126f0f81a88dfd49b38" translate="yes" xml:space="preserve">
          <source>These extensions can be pretty-printed by &lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm&lt;/a&gt;. The &lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg&lt;/a&gt; debugger supports them.</source>
          <target state="translated">这些扩展名可以由&lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm&lt;/a&gt;打印。该&lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg&lt;/a&gt;调试器支持他们。</target>
        </trans-unit>
        <trans-unit id="ad13d21d22689769fb2cd4c608e9e8fc232324fc" translate="yes" xml:space="preserve">
          <source>These field were added in CURLVERSION_FOURTH. Same as 'libiconv_version' if built with HAVE_ICONV</source>
          <target state="translated">这些字段是在CURLVERSION_FOURTH中添加的。如果使用HAVE_ICONV构建,则与'libiconv_version'相同。</target>
        </trans-unit>
        <trans-unit id="507497a0514f5bd17890a554cbbbf16c831493b7" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent a complex attribute.</source>
          <target state="translated">这些标志可以用位数OR-一起表示一个复杂的属性。</target>
        </trans-unit>
        <trans-unit id="0046ed397526fe785a54f9113f894289f9d20106" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent complex storage class.</source>
          <target state="translated">这些标志可以用位数OR-一起表示复杂的存储类。</target>
        </trans-unit>
        <trans-unit id="91bde2af8a3dc4b91f2f8c73ebb091513ee7a69a" translate="yes" xml:space="preserve">
          <source>These flags can be set/reset via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;core.stdc.fenv&lt;/code&gt; 中的函数设置/重置这些标志。</target>
        </trans-unit>
        <trans-unit id="10b77f7a0eebb3e7a656fbdfd23d4cee9e1bc0e6" translate="yes" xml:space="preserve">
          <source>These flags indicate that an exceptional floating-point condition has occurred. They indicate that a NaN or an infinity has been generated, that a result is inexact, or that a signalling NaN has been encountered. If floating-point exceptions are enabled (unmasked), a hardware exception will be generated instead of setting these flags.</source>
          <target state="translated">这些标志表示发生了一个特殊的浮点条件,它们表示产生了一个NaN或无穷大,结果不精确,或者遇到了一个信号NaN。它们表示产生了一个NaN或无穷大,结果不精确,或者遇到了一个信号NaN。如果启用了浮点异常(未屏蔽),则会产生一个硬件异常,而不是设置这些标志。</target>
        </trans-unit>
        <trans-unit id="e250dcdba1c724b4c5950d43225e8f190c1411c5" translate="yes" xml:space="preserve">
          <source>These functions allow getting and setting the OS scheduling priority of the worker threads in this &lt;code&gt;TaskPool&lt;/code&gt;. They forward to &lt;code&gt;core.thread.Thread.priority&lt;/code&gt;, so a given priority value here means the same thing as an identical priority value in &lt;code&gt;core.thread&lt;/code&gt;.</source>
          <target state="translated">这些功能允许在此 &lt;code&gt;TaskPool&lt;/code&gt; 中获取和设置工作线程的操作系统调度优先级。它们转发到 &lt;code&gt;core.thread.Thread.priority&lt;/code&gt; ，因此给定的优先级值与 &lt;code&gt;core.thread&lt;/code&gt; 中相同的优先级值具有相同的含义。</target>
        </trans-unit>
        <trans-unit id="563010f17028868ed8865c10ee72ad70b45bdc1f" translate="yes" xml:space="preserve">
          <source>These functions allow the creation of &lt;code&gt;Task&lt;/code&gt; objects on the stack rather than the GC heap. The lifetime of a &lt;code&gt;Task&lt;/code&gt; created by &lt;code&gt;scopedTask&lt;/code&gt; cannot exceed the lifetime of the scope it was created in.</source>
          <target state="translated">这些功能允许在堆栈而不是GC堆上创建 &lt;code&gt;Task&lt;/code&gt; 对象。 &lt;code&gt;scopedTask&lt;/code&gt; 创建的 &lt;code&gt;Task&lt;/code&gt; 的生存期不能超过其创建范围的生存期。</target>
        </trans-unit>
        <trans-unit id="4c3aa616b64e71a662b37e0ffc58b47e53c7d7a0" translate="yes" xml:space="preserve">
          <source>These functions are defined by</source>
          <target state="translated">这些功能的定义是</target>
        </trans-unit>
        <trans-unit id="64a3eca56341ef165f9199f2a7eb38f22c9f31d6" translate="yes" xml:space="preserve">
          <source>These functions are only available if &lt;code&gt;hasPeek!T&lt;/code&gt; is true.</source>
          <target state="translated">仅当 &lt;code&gt;hasPeek!T&lt;/code&gt; 为true时，这些功能才可用。</target>
        </trans-unit>
        <trans-unit id="ca1095cd637088fb9ac4b341f976f96ce873e4a7" translate="yes" xml:space="preserve">
          <source>These functions are only supported on POSIX platforms, as the Windows operating systems do not provide the ability to overwrite the current process image with another. In single-threaded programs it is possible to approximate the effect of &lt;code&gt;execv*&lt;/code&gt; by using &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and terminating the current process once the child process has returned. For example:</source>
          <target state="translated">这些功能仅在POSIX平台上受支持，因为Windows操作系统不提供使用另一个功能覆盖当前过程映像的功能。在单线程程序中，可以通过使用&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;并在子进程返回后终止当前进程来近似 &lt;code&gt;execv*&lt;/code&gt; 的效果。例如：</target>
        </trans-unit>
        <trans-unit id="536f51437dc16a03b75f3b412228393928fdac5c" translate="yes" xml:space="preserve">
          <source>These functions are recognized by the compiler, and calls to them are guaranteed to not be removed (as dead assignment elimination or presumed to have no effect) or reordered in the same thread.</source>
          <target state="translated">这些函数被编译器识别,对它们的调用保证不会被删除(作为死任务消除或假定没有效果),也不会在同一线程中重新排序。</target>
        </trans-unit>
        <trans-unit id="1689bc1bc5afab34bd94fef9d049d296d24218eb" translate="yes" xml:space="preserve">
          <source>These functions find the first occurrence of &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; and then split &lt;code&gt;haystack&lt;/code&gt; as follows.</source>
          <target state="translated">这些功能首先在 &lt;code&gt;haystack&lt;/code&gt; 找到 &lt;code&gt;needle&lt;/code&gt; ，然后按以下方式拆分 &lt;code&gt;haystack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b1cfbf3893f882218472af28278eb2e9814bf0e" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">通过适当选择 &lt;code&gt;pred&lt;/code&gt; ,这些函数可用于计算任意极值。对于正确的功能， &lt;code&gt;pred&lt;/code&gt; 必须是严格的偏序，即传递（如果 &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; 然后 &lt;code&gt;pred(a, c)&lt;/code&gt; ）和不反身的（ &lt;code&gt;pred(a, a)&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e60755fe688a68024196bc269a7db2354557a4c9" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;). The trichotomy property of inequality is not required: these algoritms consider elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal (for the purpose of counting) if &lt;code&gt;pred&lt;/code&gt; puts them in the same equivalence class, i.e. &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">通过适当选择 &lt;code&gt;pred&lt;/code&gt; ,这些函数可用于计算任意极值。对于正确的功能， &lt;code&gt;pred&lt;/code&gt; 必须是严格的偏序，即传递（如果 &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; 然后 &lt;code&gt;pred(a, c)&lt;/code&gt; ）和不反身的（ &lt;code&gt;pred(a, a)&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ）。不要求不等式的三分法性质：如果 &lt;code&gt;pred&lt;/code&gt; 将元素 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 放在相同的等价类中，则这些算法将它们视为相等（出于计数目的），即 &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4885c55c8f009fc55e3ded5c636baed4e8b1027a" translate="yes" xml:space="preserve">
          <source>These functions must be defined for any D program linked against this library.</source>
          <target state="translated">这些函数必须为任何与该库链接的D程序定义。</target>
        </trans-unit>
        <trans-unit id="863522dc2f55e2bd3557bec461908ee54bfe9148" translate="yes" xml:space="preserve">
          <source>These functions substitute for dynamic_cast. dynamic_cast does not work on earlier versions of gcc.</source>
          <target state="translated">这些函数替代了dynamic_cast,dynamic_cast在早期的gcc版本中无法使用。</target>
        </trans-unit>
        <trans-unit id="a6f52bdfe03bd9c3b6aa669ea2216cab6aa5652c" translate="yes" xml:space="preserve">
          <source>These functions will, when possible, do the load/store as a single operation. In general, this is possible when the size of the operation is less than or equal to &lt;code&gt;(void*).sizeof&lt;/code&gt;, although some targets may support larger operations. If the load/store cannot be done as a single operation, multiple smaller operations will be used.</source>
          <target state="translated">如果可能，这些功能将作为单个操作进行加载/存储。通常，当操作的大小小于或等于 &lt;code&gt;(void*).sizeof&lt;/code&gt; 时，这是可能的，尽管某些目标可能支持更大的操作。如果无法通过单个操作完成加载/存储，则将使用多个较小的操作。</target>
        </trans-unit>
        <trans-unit id="aa2712a3447962365aa53a08ef19b228a050bafc" translate="yes" xml:space="preserve">
          <source>These interfaces are intended to provide virtual function-based wrappers around input ranges with element type E. This is useful where a well-defined binary interface is required, such as when a DLL function or virtual function needs to accept a generic range as a parameter. Note that &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt; and friends check for conformance to structural interfaces not for implementation of these &lt;code&gt;interface&lt;/code&gt; types.</source>
          <target state="translated">这些接口旨在为元素类型E的输入范围提供基于虚拟函数的包装器。这在需要定义明确的二进制接口时很有用，例如DLL函数或虚拟函数需要接受通用范围作为参数时。请注意，&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt;和好友检查是否与结构化接口相符，而不是针对这些 &lt;code&gt;interface&lt;/code&gt; 类型的实现。</target>
        </trans-unit>
        <trans-unit id="e7b0ea076cc1a10005c1bfd351e1967a3ff3876c" translate="yes" xml:space="preserve">
          <source>These interfaces are not capable of forwarding &lt;code&gt;ref&lt;/code&gt; access to elements.</source>
          <target state="translated">这些接口无法转发对元素的 &lt;code&gt;ref&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="8fa26313291d5018e0a3e59f0f8f336286abcb0a" translate="yes" xml:space="preserve">
          <source>These issues also apply to appending arrays with the ~= operator. Concatenation using the ~ operator is not affected since it always reallocates.</source>
          <target state="translated">这些问题也适用于使用 ~=操作符进行数组追加。使用 ~ 运算符进行的连接不受影响,因为它总是重新分配。</target>
        </trans-unit>
        <trans-unit id="b9ff0eb99086639c464f06ffda166431e591559b" translate="yes" xml:space="preserve">
          <source>These members are populated when one of the following functions are called successfully:</source>
          <target state="translated">当下列函数之一被成功调用时,这些成员将被填充。</target>
        </trans-unit>
        <trans-unit id="e69f6a6ea64238818e57857e50d3b4e6fac28582" translate="yes" xml:space="preserve">
          <source>These methods return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这些方法返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2f532d1b48edcd9143f50919e4b67ad8068e5c5" translate="yes" xml:space="preserve">
          <source>These policies may be used alone, e.g. &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; defines a &lt;code&gt;uint&lt;/code&gt;-like type that reaches a stable NaN state for all erroneous operations. They may also be &quot;stacked&quot; on top of each other, owing to the property that a checked integral emulates an actual integral, which means another checked integral can be built on top of it. Some combinations of interest include:</source>
          <target state="translated">这些策略可以单独使用，例如 &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; 定义了类似于 &lt;code&gt;uint&lt;/code&gt; 的类型，该类型对于所有错误操作均达到稳定的NaN状态。由于检查的积分模拟实际的积分的性质，它们也可能彼此&amp;ldquo;堆叠&amp;rdquo;，这意味着可以在其顶部构建另一个检查的积分。一些感兴趣的组合包括：</target>
        </trans-unit>
        <trans-unit id="7368ecff3f3d439be72be4fcfde0947c1e9f8e58" translate="yes" xml:space="preserve">
          <source>These prefix instructions do not appear in the same statement as the instructions they prefix; they appear in their own statement. For example:</source>
          <target state="translated">这些前缀指令与它们前缀的指令不出现在同一语句中,它们出现在自己的语句中。例如:</target>
        </trans-unit>
        <trans-unit id="9636b646d702390220bc4fa38bc7bba209069d1d" translate="yes" xml:space="preserve">
          <source>These properties can be used to set and get this &lt;code&gt;Logger&lt;/code&gt;. Every modification to this &lt;code&gt;Logger&lt;/code&gt; will only be visible in the thread the modification has been done from.</source>
          <target state="translated">这些属性可用于设置和获取此 &lt;code&gt;Logger&lt;/code&gt; 。对该 &lt;code&gt;Logger&lt;/code&gt; 的每次修改仅在修改所基于的线程中可见。</target>
        </trans-unit>
        <trans-unit id="d0c185c1fb708b1056aa4da779b1949039005b7f" translate="yes" xml:space="preserve">
          <source>These properties control whether the worker threads are daemon threads. A daemon thread is automatically terminated when all non-daemon threads have terminated. A non-daemon thread will prevent a program from terminating as long as it has not terminated.</source>
          <target state="translated">这些属性控制着工作线程是否是守护者线程。当所有非守护线程都终止时,守护线程会自动终止。只要一个非守护进程线程没有终止,它就会阻止程序终止。</target>
        </trans-unit>
        <trans-unit id="15376758dabe755dcb87d082399d9c18e9269e9e" translate="yes" xml:space="preserve">
          <source>These properties get and set the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by &lt;code&gt;taskPool&lt;/code&gt;. The default value is &lt;code&gt;totalCPUs&lt;/code&gt; - 1. Calling the setter after the first call to &lt;code&gt;taskPool&lt;/code&gt; does not changes number of worker threads in the instance returned by &lt;code&gt;taskPool&lt;/code&gt;.</source>
          <target state="translated">这些属性获取和设置工作线程的数量 &lt;code&gt;TaskPool&lt;/code&gt; 通过返回的实例 &lt;code&gt;taskPool&lt;/code&gt; 。默认值为 &lt;code&gt;totalCPUs&lt;/code&gt; -1。在第一次调用 &lt;code&gt;taskPool&lt;/code&gt; 之后调用setter 不会更改 &lt;code&gt;taskPool&lt;/code&gt; 返回的实例中的辅助线程数。</target>
        </trans-unit>
        <trans-unit id="980ecd42d3382da4165c5745d3e514950a686c39" translate="yes" xml:space="preserve">
          <source>These pseudo ops are for inserting raw data directly into the code. &lt;code&gt;db&lt;/code&gt; is for bytes, &lt;code&gt;ds&lt;/code&gt; is for 16 bit words, &lt;code&gt;di&lt;/code&gt; is for 32 bit words, &lt;code&gt;dl&lt;/code&gt; is for 64 bit words, &lt;code&gt;df&lt;/code&gt; is for 32 bit floats, &lt;code&gt;dd&lt;/code&gt; is for 64 bit doubles, and &lt;code&gt;de&lt;/code&gt; is for 80 bit extended reals. Each can have multiple operands. If an operand is a string literal, it is as if there were</source>
          <target state="translated">这些伪操作用于将原始数据直接插入代码中。 &lt;code&gt;db&lt;/code&gt; 用于字节， &lt;code&gt;ds&lt;/code&gt; 用于16位字， &lt;code&gt;di&lt;/code&gt; 用于32位字， &lt;code&gt;dl&lt;/code&gt; 用于64位字， &lt;code&gt;df&lt;/code&gt; 用于32位浮点数， &lt;code&gt;dd&lt;/code&gt; 用于64位双精度数，而 &lt;code&gt;de&lt;/code&gt; 用于80位扩展实数。每个都可以有多个操作数。如果操作数是字符串文字，就好像有</target>
        </trans-unit>
        <trans-unit id="dc738e7762e036039780916cbdd5404d3269d8a0" translate="yes" xml:space="preserve">
          <source>These reordering guarantees are only made with regards to other operations done through these functions; the compiler is free to reorder regular loads/stores with regards to loads/stores done through these functions.</source>
          <target state="translated">这些重新排序的保证只针对通过这些函数完成的其他操作,编译器可以自由地对通过这些函数完成的负载/存储进行重新排序。</target>
        </trans-unit>
        <trans-unit id="59c337390b522d2f745f8ff19e4af335466b8d80" translate="yes" xml:space="preserve">
          <source>These rules exist to ensure that D source code can be tokenized independently of syntactic or semantic analysis.</source>
          <target state="translated">这些规则的存在是为了确保D源代码可以独立于语法或语义分析而被标记化。</target>
        </trans-unit>
        <trans-unit id="0c76e41e867d53b374fa782852a104df9aca82b4" translate="yes" xml:space="preserve">
          <source>These tokens are replaced with other tokens according to the following table:</source>
          <target state="translated">根据下表,这些代币被其他代币取代。</target>
        </trans-unit>
        <trans-unit id="d0bdde0a231ee1346d31198eca44ed30c45d180a" translate="yes" xml:space="preserve">
          <source>These two functions are publicly imported by &lt;a href=&quot;std_string&quot;&gt;&lt;code&gt;std.string&lt;/code&gt;&lt;/a&gt; to be easily available.</source>
          <target state="translated">这两个函数由&lt;a href=&quot;std_string&quot;&gt; &lt;code&gt;std.string&lt;/code&gt; &lt;/a&gt;公开导入，以便于使用。</target>
        </trans-unit>
        <trans-unit id="d116b35a1d1eb38f8d6deaebff517f7281edce29" translate="yes" xml:space="preserve">
          <source>These two methods set and get the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">这两种方法设置并获取使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c31bee48bf9882a765ab31f12d60d8852693f17b" translate="yes" xml:space="preserve">
          <source>These two were added to Bionic in Lollipop.</source>
          <target state="translated">这两个是在棒棒糖中添加到Bionic中的。</target>
        </trans-unit>
        <trans-unit id="51b1a7127ec2cda2b11c1f4d950a66756e0a424a" translate="yes" xml:space="preserve">
          <source>These types and operations will be the ones defined for the architecture the compiler is targeting. If a particular CPU family has varying support for vector types, an additional runtime check may be necessary. The compiler does not emit runtime checks; those must be done by the programmer.</source>
          <target state="translated">这些类型和操作将是为编译器所针对的架构所定义的。如果一个特定的CPU系列对向量类型有不同的支持,可能需要额外的运行时检查。编译器不会发出运行时检查,这些检查必须由程序员来完成。</target>
        </trans-unit>
        <trans-unit id="6f060e83954cb7bb657a24fc206a36f49a7d93ba" translate="yes" xml:space="preserve">
          <source>These variadic functions have a special local variable declared for them, &lt;code&gt;_argptr&lt;/code&gt;, which is a &lt;code&gt;core.vararg&lt;/code&gt; reference to the first of the variadic arguments. To access the arguments, &lt;code&gt;_argptr&lt;/code&gt; must be used in conjuction with &lt;code&gt;va_arg&lt;/code&gt;:</source>
          <target state="translated">这些可变参数函数为它们声明了一个特殊的局部变量 &lt;code&gt;_argptr&lt;/code&gt; ，这是对第一个可变参数的 &lt;code&gt;core.vararg&lt;/code&gt; 引用。要访问参数，必须将 &lt;code&gt;_argptr&lt;/code&gt; 与 &lt;code&gt;va_arg&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="234027e68858253217a4940ca8276de49e1921e6" translate="yes" xml:space="preserve">
          <source>They cannot be accessed directly, but can be when converted to an array type:</source>
          <target state="translated">它们不能直接被访问,但当转换为数组类型时可以被访问。</target>
        </trans-unit>
        <trans-unit id="221e10b06207df21853c30ac081dc011d76ee4a6" translate="yes" xml:space="preserve">
          <source>Things that are reliable and can be done:</source>
          <target state="translated">可靠的事情,可以做。</target>
        </trans-unit>
        <trans-unit id="3c0e4517dcdbca852a34fee2578fdfec0c6193f9" translate="yes" xml:space="preserve">
          <source>This 6-digit (24 bits) hexadecimal number does not show pre-release number, and it is always a greater number in a more recent release. It makes comparisons with greater than and less than work.</source>
          <target state="translated">这个6位数(24位)的十六进制数字不显示发布前的数字,在最近的版本中,它总是一个大于的数字。它使大于和小于的比较工作。</target>
        </trans-unit>
        <trans-unit id="229cd848f340b1059ab841306649066eb2235f02" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt;&lt;code&gt;NSLog&lt;/code&gt;&lt;/a&gt; function prints a message to the System Log facility, i.e. to stderr and Console.</source>
          <target state="translated">此&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt; &lt;code&gt;NSLog&lt;/code&gt; &lt;/a&gt;函数将消息打印到系统日志工具，即stderr和控制台。</target>
        </trans-unit>
        <trans-unit id="d3784623518bf5135672133e5b2128ce4da1e03a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; implementation writes log messages to the associated file. The name of the file has to be passed on construction time. If the file is already present new log messages will be append at its end.</source>
          <target state="translated">该 &lt;code&gt;Logger&lt;/code&gt; 实现将日志消息写入关联的文件。文件名必须在构造时传递。如果文件已经存在，则将在其末尾附加新的日志消息。</target>
        </trans-unit>
        <trans-unit id="713e6c7267281da115b32a479fb632b10a4676bf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; is called by the free standing log functions. This allows to create thread local redirections and still use the free standing log functions.</source>
          <target state="translated">独立记录功能调用此 &lt;code&gt;Logger&lt;/code&gt; 。这允许创建线程本地重定向，并且仍然使用独立日志功能。</target>
        </trans-unit>
        <trans-unit id="e1905487aa2f3222c1f92ca85d42ee6ef82cec0b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;delegate&lt;/code&gt; is called in case a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; gets logged.</source>
          <target state="translated">如果记录了带有 &lt;code&gt;LogLevel.fatal&lt;/code&gt; 的日志消息，则将调用此 &lt;code&gt;delegate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="742a25561151a973ba133d1f0c2d43dea4909a81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as a template argument to functions which compare file names, and determines whether the comparison is case sensitive or not.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 用作比较文件名的函数的模板参数，并确定比较是否区分大小写。</target>
        </trans-unit>
        <trans-unit id="5b6a1b7ec8e15b4671a0723320a6b157081a9b40" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used to select the primitives of the range to handle by the &lt;a href=&quot;#handle&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;/a&gt; range wrapper. The values of the &lt;code&gt;enum&lt;/code&gt; can be &lt;code&gt;OR&lt;/code&gt;'d to select multiple primitives to be handled.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 用于通过&lt;a href=&quot;#handle&quot;&gt; &lt;code&gt;handle&lt;/code&gt; &lt;/a&gt;范围包装器选择要处理的范围的基元。 &lt;code&gt;enum&lt;/code&gt; 的值可以进行 &lt;code&gt;OR&lt;/code&gt; 以选择要处理的多个基元。</target>
        </trans-unit>
        <trans-unit id="60302f8f7437eabfe1118a9f0d4373fe741b982e" translate="yes" xml:space="preserve">
          <source>This &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, U)(U rhs)</source>
          <target state="translated">这个&lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;（字符串op，U）（U rhs）</target>
        </trans-unit>
        <trans-unit id="0844f4e216523548601b41cd5d7151c085ad2d4f" translate="yes" xml:space="preserve">
          <source>This Element is stored inside the &lt;code&gt;MultiLogger&lt;/code&gt; and associates a &lt;code&gt;Logger&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">该元素存储在 &lt;code&gt;MultiLogger&lt;/code&gt; 内部，并将 &lt;code&gt;Logger&lt;/code&gt; 与 &lt;code&gt;string&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="3f3ba7f1176ff2dafbb0e0f64e80accd29320699" translate="yes" xml:space="preserve">
          <source>This Exception is thrown if something goes wrong when encoding or decoding a URI.</source>
          <target state="translated">如果在编码或解码URI时出错,就会抛出这个异常。</target>
        </trans-unit>
        <trans-unit id="7f52bee84df158d351adbe607d7ed92c29a830ca" translate="yes" xml:space="preserve">
          <source>This access can span multiple nesting levels:</source>
          <target state="translated">这种访问可以跨越多个嵌套级别。</target>
        </trans-unit>
        <trans-unit id="6b73948545ca0a17466100c56872304c05fd8262" translate="yes" xml:space="preserve">
          <source>This advice applies only to static references or references embedded inside other objects. There is not much point for such stored on the stack to be nulled because new stack frames are initialized anyway.</source>
          <target state="translated">这个建议只适用于静态引用或嵌入其他对象内部的引用。对于这种存储在堆栈上的引用来说,被清空是没有多大意义的,因为新的堆栈框架无论如何都会被初始化。</target>
        </trans-unit>
        <trans-unit id="b180cae02977110add927a1c4e0c64f40292d64f" translate="yes" xml:space="preserve">
          <source>This algorithm is lazy, doing work progressively as elements are pulled off the result.  Time complexity is proportional to the sum of element counts over all inputs.  If all inputs have the same element type and offer it by &lt;code&gt;ref&lt;/code&gt;, output becomes a range with mutable &lt;code&gt;front&lt;/code&gt; (and &lt;code&gt;back&lt;/code&gt; where appropriate) that reflects in the original inputs.  If any of the inputs &lt;code&gt;rs&lt;/code&gt; is infinite so is the result (&lt;code&gt;empty&lt;/code&gt; being always &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">该算法是惰性的，随着元素从结果中拉出而逐渐进行工作。时间复杂度与所有输入的元素计数之和成正比。如果所有输入都具有相同的元素类型，并由 &lt;code&gt;ref&lt;/code&gt; 提供，则输出将变成一个范围可变，其范围在 &lt;code&gt;front&lt;/code&gt; （适当时可以在 &lt;code&gt;back&lt;/code&gt; ）反映原始输入。如果任何输入 &lt;code&gt;rs&lt;/code&gt; 是无限的，则结果也是如此（ &lt;code&gt;empty&lt;/code&gt; 始终为 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="17ac7dad87e44aee326cfad5b437dc8fb209353e" translate="yes" xml:space="preserve">
          <source>This allocator sits on top of &lt;code&gt;ParentAllocator&lt;/code&gt; and quantizes allocation sizes, usually from arbitrary positive numbers to a small set of round numbers (e.g. powers of two, page sizes etc). This technique is commonly used to:</source>
          <target state="translated">此分配器位于 &lt;code&gt;ParentAllocator&lt;/code&gt; 之上，并量化分配大小，通常是从任意正数到一小组舍入数（例如，2的幂，页大小等）。此技术通常用于：</target>
        </trans-unit>
        <trans-unit id="c92308ef13d80d3dc1f8f963c2ddd3981e8c6bde" translate="yes" xml:space="preserve">
          <source>This allows you to construct a &lt;code&gt;TickDuration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="translated">这使您可以从具有给定长度的给定时间单位构造一个 &lt;code&gt;TickDuration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75add17a5265c1c86eea3c10773eb85a2a082611" translate="yes" xml:space="preserve">
          <source>This also checks if T passes &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">这还将检查T是否通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21d1b39871e7f1893df45ac1736d0defe8bdb68b" translate="yes" xml:space="preserve">
          <source>This approach to sorting is akin to the &lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian transform&lt;/a&gt;, also known as the decorate-sort-undecorate pattern in Python and Lisp. The complexity is the same as that of the corresponding &lt;code&gt;sort&lt;/code&gt;, but &lt;code&gt;schwartzSort&lt;/code&gt; evaluates &lt;code&gt;transform&lt;/code&gt; only &lt;code&gt;r.length&lt;/code&gt; times (less than half when compared to regular sorting). The usage can be best illustrated with an example.</source>
          <target state="translated">这种排序方法类似于&lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian变换&lt;/a&gt;，在Python和Lisp中也称为decorate-sort-unecorate模式。复杂度与相应 &lt;code&gt;sort&lt;/code&gt; 的复杂度相同，但是 &lt;code&gt;schwartzSort&lt;/code&gt; 仅计算 &lt;code&gt;transform&lt;/code&gt; &lt;code&gt;r.length&lt;/code&gt; 次（与常规排序相比，减少一半）。用法可以通过一个例子最好地说明。</target>
        </trans-unit>
        <trans-unit id="5d88f963aa92f920cdc8aeb7a00bc154db20bbb5" translate="yes" xml:space="preserve">
          <source>This array can be used by a precise GC to avoid false pointers.</source>
          <target state="translated">这个数组可以被一个精确的GC使用,以避免错误的指针。</target>
        </trans-unit>
        <trans-unit id="c35154b2193fa21859ceac41f1d4b9a67330be66" translate="yes" xml:space="preserve">
          <source>This attack can also be mitigated via rate limiting and banning IPs which have too many rejected requests. However, this does not completely solve the problem, as the attacker could be in control of a bot net. To fully defend against the timing attack, rate limiting, banning IPs, and using this function should be used together.</source>
          <target state="translated">这种攻击也可以通过限制速率和禁止有太多拒绝请求的IP来缓解。但是,这并不能完全解决这个问题,因为攻击者可能会控制一个僵尸网络。为了完全防御定时攻击,限制速率、禁止IP和使用这个功能应该一起使用。</target>
        </trans-unit>
        <trans-unit id="0a9127e0dd3d0b5214532b99c1123e71d947a773" translate="yes" xml:space="preserve">
          <source>This binary operator returns a narrower, built-in integer type where applicable, according to the following table.</source>
          <target state="translated">这个二进制运算符根据下表,在适用的情况下返回一个较窄的内置整数类型。</target>
        </trans-unit>
        <trans-unit id="37d90ec49bcad1514fffff07ef5725f0a4ce3b52" translate="yes" xml:space="preserve">
          <source>This block contains the info to allow appending.</source>
          <target state="translated">该块包含允许追加的信息。</target>
        </trans-unit>
        <trans-unit id="bf616d2c8bb18a1f79e9b94bb01fac01a9f85e97" translate="yes" xml:space="preserve">
          <source>This block is guaranteed to have a pointer to its base while it is alive. Interior pointers can be safely ignored. This attribute is useful for eliminating false pointers in very large data structures and is only implemented for data structures at least a page in size.</source>
          <target state="translated">这个块在活着的时候,保证有一个指向它的基座的指针。内部指针可以被安全地忽略。这个属性对于消除非常大的数据结构中的错误指针非常有用,并且只对至少有一页大小的数据结构实施。</target>
        </trans-unit>
        <trans-unit id="bf3bcec7830ceded3b9368b09e74254cb38823f2" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. It's highly platform dependent.</source>
          <target state="translated">它将一个类型分解成 &quot;更简单 &quot;的类型,这些类型可以在寄存器中传递给一个函数,并在寄存器中返回。它高度依赖于平台。</target>
        </trans-unit>
        <trans-unit id="c8f37b58b4d0486e147bae447382fe4c40e89ace" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. This is the implementation for the x86_64 System V ABI (not used for Win64), based on &lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf.&lt;/a&gt;</source>
          <target state="translated">这将类型分解为&amp;ldquo;简单&amp;rdquo;类型，可以将其传递给寄存器中的函数，然后返回给寄存器。这是基于&lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf&lt;/a&gt;的x86_64 System V ABI（不适用于Win64）的实现。</target>
        </trans-unit>
        <trans-unit id="0bd70fd848ca13dea85fa0c9ed45a1bd7458ccab" translate="yes" xml:space="preserve">
          <source>This can be a useful function to place in a chain, after functions that have expensive evaluation, as a lazy alternative to &lt;a href=&quot;std_array#array&quot;&gt;&lt;code&gt;std.array.array&lt;/code&gt;&lt;/a&gt;. In particular, it can be placed after a call to &lt;a href=&quot;#map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, or before a call &lt;a href=&quot;std_range#filter&quot;&gt;&lt;code&gt;std.range.filter&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range#tee&quot;&gt;&lt;code&gt;std.range.tee&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">这可能是有用的功能，可以放在链上，而这些功能需要昂贵的评估，可以替代&lt;a href=&quot;std_array#array&quot;&gt; &lt;code&gt;std.array.array&lt;/code&gt; &lt;/a&gt;。特别是，可以将其放置在调用&lt;a href=&quot;#map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;之后或调用&lt;a href=&quot;std_range#filter&quot;&gt; &lt;code&gt;std.range.filter&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;std_range#tee&quot;&gt; &lt;code&gt;std.range.tee&lt;/code&gt; 之前&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b2e989aa67544fd1198815cd532b63a0f766b8f" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = File.readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="translated">这可以比 &lt;code&gt;line = File.readln()&lt;/code&gt; 更快，因为您可以为每个调用重用缓冲区。请注意，重用缓冲区意味着如果要保留以前的内容，则必须复制它们。</target>
        </trans-unit>
        <trans-unit id="9135461de3ded4b1c69a8c8663d6dc1b7b1298f3" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="translated">这可以比 &lt;code&gt;line = readln()&lt;/code&gt; 更快，因为您可以为每个调用重用缓冲区。请注意，重用缓冲区意味着如果要保留以前的内容，则必须复制它们。</target>
        </trans-unit>
        <trans-unit id="a112b2327f090d0fc1bf3af12645c6807ea32f38" translate="yes" xml:space="preserve">
          <source>This can be used to manually allocate arrays. Initial slice size is 0.</source>
          <target state="translated">这可以用来手动分配数组。初始分片大小为0。</target>
        </trans-unit>
        <trans-unit id="77b164cf465602d02b3ffc40b53faf3928b97c45" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;_init&lt;/code&gt; to its original state.</source>
          <target state="translated">这可用于将 &lt;code&gt;_init&lt;/code&gt; 设置的状态恢复到其原始状态。</target>
        </trans-unit>
        <trans-unit id="fd9b6c28efb844ef78e5e1874ec7103f9aedb900" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;builtin_init&lt;/code&gt; to its original state.</source>
          <target state="translated">这可用于将 &lt;code&gt;builtin_init&lt;/code&gt; 设置的状态恢复到其原始状态。</target>
        </trans-unit>
        <trans-unit id="bf855a97cfb23a3029962fde96c07063d751f784" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initDMD&lt;/code&gt; to its original state. Useful if there's a need for multiple sessions of the DMD compiler in the same application.</source>
          <target state="translated">这可用于将 &lt;code&gt;initDMD&lt;/code&gt; 设置的状态恢复到其原始状态。如果在同一应用程序中需要多个DMD编译器会话，则很有用。</target>
        </trans-unit>
        <trans-unit id="8b9d5f27029fa9824ee5b1d78b90c2ec7ef5fd1e" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initialize&lt;/code&gt; to its original state.</source>
          <target state="translated">这可以用于通过 &lt;code&gt;initialize&lt;/code&gt; 将状态集恢复为其原始状态。</target>
        </trans-unit>
        <trans-unit id="ab6e2c03932762345b65936a6392947f9f7fc40e" translate="yes" xml:space="preserve">
          <source>This causes the array to be reallocated in place, and the existing contents copied over to the new array. If the new array length is shorter, the array is not reallocated, and no data is copied. It is equivalent to slicing the array:</source>
          <target state="translated">这将导致数组在原地被重新分配,并将现有的内容复制到新的数组中。如果新的数组长度较短,则不重新分配数组,也不复制数据。这相当于对数组进行切片。</target>
        </trans-unit>
        <trans-unit id="2dc8c51a26f6ef694173726a55aa90d7d6530cc8" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a read lock for the enclosing mutex.</source>
          <target state="translated">这个类本身就可以被认为是一个mutex,用来协商包围mutex的读锁。</target>
        </trans-unit>
        <trans-unit id="c087ce5411ffc17188818ec319892aeaf2de87df" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a write lock for the enclosing mutex.</source>
          <target state="translated">这个类本身就可以被认为是一个mutex,用于为包围的mutex协商一个写锁。</target>
        </trans-unit>
        <trans-unit id="e6fa3f3a70f061e4c741e7043e9f128e38434b5c" translate="yes" xml:space="preserve">
          <source>This class contains only static methods, and cannot be instantiated. See below for examples of use.</source>
          <target state="translated">该类只包含静态方法,不能实例化。请看下面的使用实例。</target>
        </trans-unit>
        <trans-unit id="e74dd67572321fcf836dd082da1156043102db48" translate="yes" xml:space="preserve">
          <source>This class encapsulates a task queue and a set of worker threads. Its purpose is to efficiently map a large number of &lt;code&gt;Task&lt;/code&gt;s onto a smaller number of threads. A task queue is a FIFO queue of &lt;code&gt;Task&lt;/code&gt; objects that have been submitted to the &lt;code&gt;TaskPool&lt;/code&gt; and are awaiting execution. A worker thread is a thread that executes the &lt;code&gt;Task&lt;/code&gt; at the front of the queue when one is available and sleeps when the queue is empty.</source>
          <target state="translated">此类封装了一个任务队列和一组工作线程。其目的是有效地将大量 &lt;code&gt;Task&lt;/code&gt; 映射到较少数量的线程上。任务队列是已提交到 &lt;code&gt;TaskPool&lt;/code&gt; 并等待执行的 &lt;code&gt;Task&lt;/code&gt; 对象的FIFO队列。工作线程是一个线程，当一个线程可用时，该线程在队列的最前面执行 &lt;code&gt;Task&lt;/code&gt; ，而在队列为空时进入睡眠状态。</target>
        </trans-unit>
        <trans-unit id="cb7ed7def5fa337d461b92cc10d68f83905440de" translate="yes" xml:space="preserve">
          <source>This class encapsulates all threading functionality for the D programming language. As thread manipulation is a required facility for garbage collection, all user threads should derive from this class, and instances of this class should never be explicitly deleted. A new thread may be created using either derivation or composition, as in the following example.</source>
          <target state="translated">这个类封装了D编程语言的所有线程功能。由于线程操作是垃圾收集所需的设施,所以所有的用户线程都应该从这个类派生出来,而且这个类的实例永远不应该被显式删除。一个新的线程可以使用派生或组成来创建,如下例所示。</target>
        </trans-unit>
        <trans-unit id="060824159317cc2ae0b94150653daf83c3c520fb" translate="yes" xml:space="preserve">
          <source>This class is Windows-Only.</source>
          <target state="translated">这个类是Windows-Only的。</target>
        </trans-unit>
        <trans-unit id="74950bb501f7c21fc01a4eeb41b151e182fd4b25" translate="yes" xml:space="preserve">
          <source>This class is intended to simplify certain common programming techniques.</source>
          <target state="translated">该类旨在简化某些常见的编程技术。</target>
        </trans-unit>
        <trans-unit id="23197b76b4ee940fb447d39ecd365edbbb4617e7" translate="yes" xml:space="preserve">
          <source>This class is the base of every logger. In order to create a new kind of logger a deriving class needs to implement the &lt;code&gt;writeLogMsg&lt;/code&gt; method. By default this is not thread-safe.</source>
          <target state="translated">此类是每个记录器的基础。为了创建一种新的记录器，派生类需要实现 &lt;code&gt;writeLogMsg&lt;/code&gt; 方法。默认情况下，这不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="5087e482a877ae3c12085be27794a8883c7a901f" translate="yes" xml:space="preserve">
          <source>This class provides a cooperative concurrency mechanism integrated with the threading and garbage collection functionality. Calling a fiber may be considered a blocking operation that returns when the fiber yields (via Fiber.yield()). Execution occurs within the context of the calling thread so synchronization is not necessary to guarantee memory visibility so long as the same thread calls the fiber each time. Please note that there is no requirement that a fiber be bound to one specific thread. Rather, fibers may be freely passed between threads so long as they are not currently executing. Like threads, a new fiber thread may be created using either derivation or composition, as in the following example.</source>
          <target state="translated">这个类提供了一个与线程和垃圾收集功能集成的合作并发机制。调用光纤可以被认为是一个阻塞操作,当光纤产生时返回(通过Fiber.yield())。执行发生在调用线程的上下文中,所以只要每次调用光纤的是同一个线程,就不需要同步来保证内存的可见性。请注意,没有要求光纤必须绑定到一个特定的线程。相反,只要线程当前没有执行,光纤可以在线程之间自由传递。和线程一样,新的光纤线程也可以使用派生或组成的方式创建,如下例。</target>
        </trans-unit>
        <trans-unit id="82a75ec7718c8b6f47e4366c93dbe98cf77e29de" translate="yes" xml:space="preserve">
          <source>This class represents a barrier across which threads may only travel in groups of a specific size.</source>
          <target state="translated">该类代表了一个障碍,线程只能以特定大小的组为单位穿行。</target>
        </trans-unit>
        <trans-unit id="766ad20f64361ee3b240dfaf608ee851aeb433ae" translate="yes" xml:space="preserve">
          <source>This class represents a condition variable as conceived by C.A.R. Hoare. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="translated">这个类代表了C.A.R.Hoare所设想的一个条件变量。然而,按照Mesa类型监控器,&quot;signal &quot;被替换为 &quot;notify&quot;,以表明当发送通知时,控制权不会转移到服务员身上。</target>
        </trans-unit>
        <trans-unit id="4ebd970226df03dbe75e13571a9e96c6ff81d3f8" translate="yes" xml:space="preserve">
          <source>This class represents a general counting semaphore as concieved by Edsger Dijkstra. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="translated">这个类代表了Edsger Dijkstra构思的一个通用计数信号体。然而,按照Mesa类型监控器,&quot;signal &quot;被替换为 &quot;notify&quot;,以表明当发送通知时,控制权不会转移到服务员身上。</target>
        </trans-unit>
        <trans-unit id="c8cd845734952865e5a8f06563815740028af34a" translate="yes" xml:space="preserve">
          <source>This class represents a general purpose, recursive mutex.</source>
          <target state="translated">这个类表示一个通用的、递归的mutex。</target>
        </trans-unit>
        <trans-unit id="59a28f2816234c02947ecfa7c34d28fcd7aff787" translate="yes" xml:space="preserve">
          <source>This class represents a mutex that allows any number of readers to enter, but when a writer enters, all other readers and writers are blocked.</source>
          <target state="translated">该类表示一个mutex,允许任何数量的读者进入,但当一个作家进入时,所有其他读者和作家都会被阻止。</target>
        </trans-unit>
        <trans-unit id="869079d3acf8bad41ab545f5cd5b6ff38c3d966c" translate="yes" xml:space="preserve">
          <source>This class should usually be used via the global instantiation available via the &lt;a href=&quot;std_parallelism#taskPool&quot;&gt;&lt;code&gt;std.parallelism.taskPool&lt;/code&gt;&lt;/a&gt; property. Occasionally it is useful to explicitly instantiate a &lt;code&gt;TaskPool&lt;/code&gt;:</source>
          <target state="translated">通常应通过&lt;a href=&quot;std_parallelism#taskPool&quot;&gt; &lt;code&gt;std.parallelism.taskPool&lt;/code&gt; &lt;/a&gt;属性提供的全局实例化来使用此类。有时，显式实例化 &lt;code&gt;TaskPool&lt;/code&gt; 很有用：</target>
        </trans-unit>
        <trans-unit id="67a778401b8293f4ab050d1d10ec2027dc2c3143" translate="yes" xml:space="preserve">
          <source>This class uses a high-performance counter. On Windows systems, it uses &lt;code&gt;QueryPerformanceCounter&lt;/code&gt;, and on Posix systems, it uses &lt;code&gt;clock_gettime&lt;/code&gt; if available, and &lt;code&gt;gettimeofday&lt;/code&gt; otherwise.</source>
          <target state="translated">此类使用高性能计数器。在Windows系统上，它使用 &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; ，在Posix系统上，它使用 &lt;code&gt;clock_gettime&lt;/code&gt; (如果可用），否则使用 &lt;code&gt;gettimeofday&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaa98a68eef2ad7cd1dc56f0e12cad2e4ff0ed1d" translate="yes" xml:space="preserve">
          <source>This code handles backtrace generation using DWARF debug_line section in ELF and Mach-O files for Posix.</source>
          <target state="translated">这段代码在ELF和Mach-O文件中使用DWARF debug_line部分处理Posix的回溯生成。</target>
        </trans-unit>
        <trans-unit id="6140309682aaa69b6ff498f8a25796d0edfd215e" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="translated">这段代码处理forach循环的UTF字符串解码。char、wchar和dchar之间有6种转换组合,每种组合有2种。</target>
        </trans-unit>
        <trans-unit id="982470496432064145436b3b7c81c481f591fd15" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach_reverse loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="translated">这段代码处理foreach_reverse循环的UTF字符串解码。char、wchar和dchar之间有6种转换组合,每种组合有2种。</target>
        </trans-unit>
        <trans-unit id="e76eacdedc4fa73ee336ac22c18ef834f35805af" translate="yes" xml:space="preserve">
          <source>This code reads ELF files and sections using memory mapped IO.</source>
          <target state="translated">这段代码使用内存映射IO读取ELF文件和部分。</target>
        </trans-unit>
        <trans-unit id="db89b4b4bb5b2f93ea6d6ff02b4131b5059932ab" translate="yes" xml:space="preserve">
          <source>This combining of the environment and the function is called a</source>
          <target state="translated">这种环境和函数的结合称为一个</target>
        </trans-unit>
        <trans-unit id="f04a03c616b5e70e398965fd9e6bb2d3b0919b13" translate="yes" xml:space="preserve">
          <source>This command-line parameter does not affect custom unit test handlers.</source>
          <target state="translated">这个命令行参数不影响自定义单元测试处理程序。</target>
        </trans-unit>
        <trans-unit id="230aa360bfc55c5cf21e968f489f8b1241790aa2" translate="yes" xml:space="preserve">
          <source>This compile-time flag is &lt;code&gt;true&lt;/code&gt; if logging is not statically disabled.</source>
          <target state="translated">如果未静态禁用日志记录，则此编译时标志为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d82eb07cfddf77181a4fa8aca621ce6591fd7ca9" translate="yes" xml:space="preserve">
          <source>This constructor is only called when we figured out which function template to instantiate.</source>
          <target state="translated">这个构造函数只有在我们弄清楚要实例化哪个函数模板时才会被调用。</target>
        </trans-unit>
        <trans-unit id="aa95214feed626f5e6eebb5c6959ff1d8bcafc67" translate="yes" xml:space="preserve">
          <source>This constructor is the inverse of &lt;a href=&quot;#opCast&quot;&gt;&lt;code&gt;opCast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此构造函数与&lt;a href=&quot;#opCast&quot;&gt; &lt;code&gt;opCast&lt;/code&gt; 相反&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8fcfb06ab6c25d2bbe46e5cfe782e5b576ac2d4" translate="yes" xml:space="preserve">
          <source>This contains the copyright notice. The macro COPYRIGHT is set to the contents of the section when it documents the module declaration. The copyright section only gets this special treatment when it is for the module declaration.</source>
          <target state="translated">这里面包含了版权声明。当它记录模块声明时,宏观的 COPYRIGHT 被设置为该部分的内容。只有当模块声明时,版权部分才会得到这种特殊处理。</target>
        </trans-unit>
        <trans-unit id="822ca8d08b221bc29495c95da9984e8cee76c282" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage decoding buffers.</source>
          <target state="translated">这种方便的方法减轻了手动管理解码缓冲区的需要。</target>
        </trans-unit>
        <trans-unit id="cf045283f89baa3e44e42e507f01aa06b96bde31" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage output buffers.</source>
          <target state="translated">这种方便的方法减轻了手动管理输出缓冲区的需要。</target>
        </trans-unit>
        <trans-unit id="16b88e43157a2f6f2c5142b90b7d5fe45695bbef" translate="yes" xml:space="preserve">
          <source>This created a new Fiber for the supplied op and adds it to the dispatch list.</source>
          <target state="translated">这就为所提供的操作创建了一个新的光纤,并将其添加到调度列表中。</target>
        </trans-unit>
        <trans-unit id="fdc94e4392e59112302f3c3212c7174cb2489e38" translate="yes" xml:space="preserve">
          <source>This creates a new Fiber for the supplied op and then starts the dispatcher.</source>
          <target state="translated">这将为提供的操作创建一个新的光纤,然后启动调度器。</target>
        </trans-unit>
        <trans-unit id="af45f3f128eb584feb53ad796c2bd75a57d5180c" translate="yes" xml:space="preserve">
          <source>This defines a new type &lt;code&gt;X&lt;/code&gt; which has values &lt;code&gt;X.A=0&lt;/code&gt;, &lt;code&gt;X.B=1&lt;/code&gt;, &lt;code&gt;X.C=2&lt;/code&gt;:</source>
          <target state="translated">这定义了一个新的 &lt;code&gt;X&lt;/code&gt; 类型，其值 &lt;code&gt;X.A=0&lt;/code&gt; ， &lt;code&gt;X.B=1&lt;/code&gt; ， &lt;code&gt;X.C=2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d27799b2bf9fed9292a027676e909387c978ddb" translate="yes" xml:space="preserve">
          <source>This definition of mutable functions is more general than the one traditionally employed by pure functional languages because it allows a D pure function to use state mutation, as long as all state is created internally or reachable through its arguments. In particular, a pure function may allocate memory by means of e.g. &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt; without these being special cases. A pure function is allowed to loop indefinitely or terminate the program.</source>
          <target state="translated">这种可变函数的定义比纯函数语言传统上使用的定义更笼统，因为只要所有状态都是在内部创建或通过其参数可访问的，它就允许D纯函数使用状态突变。尤其是，纯函数可以通过例如 &lt;code&gt;new&lt;/code&gt; 或 &lt;code&gt;malloc&lt;/code&gt; 分配内存，而这些都不是特殊情况。允许纯函数无限循环或终止程序。</target>
        </trans-unit>
        <trans-unit id="524100fdceb69609090212fc4caf6a68ca169c00" translate="yes" xml:space="preserve">
          <source>This deletes the key e1 from the associative array e2</source>
          <target state="translated">这将从关联数组e2中删除键e1。</target>
        </trans-unit>
        <trans-unit id="e594f9c668086e01075383fb67708b16f0e2344d" translate="yes" xml:space="preserve">
          <source>This describes the OOP API. To understand when to use the template API and when to use the OOP API, see the module documentation at the top of this page.</source>
          <target state="translated">这里描述了OOP API。要了解什么时候使用模板API,什么时候使用OOP API,请看本页顶部的模块文档。</target>
        </trans-unit>
        <trans-unit id="3007dc64e992f88997b93bf75939ee91b3bf45cf" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;code&gt;x86&lt;/code&gt; and &lt;code&gt;x86_64&lt;/code&gt; implementations of the inline assembler. The inline assembler platform support that a compiler provides is indicated by the &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; and &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; version identifiers, respectively.</source>
          <target state="translated">本文档介绍了嵌入式汇编程序的 &lt;code&gt;x86&lt;/code&gt; 和 &lt;code&gt;x86_64&lt;/code&gt; 实现。编译器提供的内联汇编程序平台支持分别由 &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; 和 &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; 版本标识符指示。</target>
        </trans-unit>
        <trans-unit id="569cf1450215141639c3396e75fe3e0e30e8cd78" translate="yes" xml:space="preserve">
          <source>This document is the reference manual for the D Programming Language. For more information and other documents, see &lt;a href=&quot;https://dlang.org/&quot;&gt;The D Language Website&lt;/a&gt;.</source>
          <target state="translated">本文档是D编程语言的参考手册。有关更多信息和其他文档，请参见&lt;a href=&quot;https://dlang.org/&quot;&gt;The D Language Website&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b76c1da48d91edda64500d21af760a6ce3c2286" translate="yes" xml:space="preserve">
          <source>This document specifies how to interface with C++ directly.</source>
          <target state="translated">本文档规定了如何直接与C++接口。</target>
        </trans-unit>
        <trans-unit id="4eaa9b84c7822b2e3e77fa7e5df36263689f6cc9" translate="yes" xml:space="preserve">
          <source>This documents the general structure of a Digest in the template API. All digest implementations should implement the following members and therefore pass the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test.</source>
          <target state="translated">本文档在模板API中记录了摘要的一般结构。所有摘要实现均应实现以下成员，并因此通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;测试。</target>
        </trans-unit>
        <trans-unit id="ac0dd62d84db23b0de6fee189b1020c75493d355" translate="yes" xml:space="preserve">
          <source>This does not assign the pointer of &lt;code&gt;rhs&lt;/code&gt; to this &lt;code&gt;RefRange&lt;/code&gt;. Rather it assigns the range pointed to by &lt;code&gt;rhs&lt;/code&gt; to the range pointed to by this &lt;code&gt;RefRange&lt;/code&gt;. This is because</source>
          <target state="translated">这不会将 &lt;code&gt;rhs&lt;/code&gt; 的指针分配给此 &lt;code&gt;RefRange&lt;/code&gt; 。而是将 &lt;code&gt;rhs&lt;/code&gt; 指向的范围分配给此 &lt;code&gt;RefRange&lt;/code&gt; 指向的范围。这是因为</target>
        </trans-unit>
        <trans-unit id="e81812302527d63ee87960159e6a1b9dd25fb020" translate="yes" xml:space="preserve">
          <source>This does not include any time during which the StopWatch was stopped but does include</source>
          <target state="translated">这不包括停表期间的任何时间,但包括</target>
        </trans-unit>
        <trans-unit id="c432390e6bbf7d9fb981f314323bac09cd4ec391" translate="yes" xml:space="preserve">
          <source>This does not mean, however, that one can change the data:</source>
          <target state="translated">但这并不意味着可以改变数据。</target>
        </trans-unit>
        <trans-unit id="1d63844eee394540a61e05092a78018f8dcdacad" translate="yes" xml:space="preserve">
          <source>This doesn't include '\n', '\r', \t' and other non-space &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;. For commonly used less strict semantics see &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这不包括'\ n'，'\ r'，\ t'和其他非空格&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;。有关常用的不太严格的语义，请参见&lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b899c5918773ae82ab7898c96cd3e0a68f5b5e5e" translate="yes" xml:space="preserve">
          <source>This doesn't work for TLS memory, though.</source>
          <target state="translated">但这对TLS内存不起作用。</target>
        </trans-unit>
        <trans-unit id="add950f77c9072c48dcd0ff96facedd547735caa" translate="yes" xml:space="preserve">
          <source>This easy handle has completed. 'result' contains the CURLcode of the transfer</source>
          <target state="translated">这个简单的处理已经完成。'result'包含了传输的CURL代码。</target>
        </trans-unit>
        <trans-unit id="ef5d8951fd69c70c7d61e2bd1231248df49b6d3e" translate="yes" xml:space="preserve">
          <source>This example creates a DOM (Document Object Model) tree from an XML file.</source>
          <target state="translated">这个例子从XML文件中创建一个DOM(文档对象模型)树。</target>
        </trans-unit>
        <trans-unit id="74ec60c9c14341e9d9e5373aa773d98804f76f30" translate="yes" xml:space="preserve">
          <source>This example does much the same thing, except that the file is deconstructed and reconstructed by hand. This is more work, but the techniques involved offer vastly more power.</source>
          <target state="translated">这个例子做的事情大同小异,只是文件是由人工解构和重建的。这是更多的工作,但所涉及的技术提供了更大的力量。</target>
        </trans-unit>
        <trans-unit id="7a4cbb05cb72419e58f855fffb51071ca39f119b" translate="yes" xml:space="preserve">
          <source>This example encodes the input data one byte at a time.</source>
          <target state="translated">这个例子每次对输入数据进行一个字节的编码。</target>
        </trans-unit>
        <trans-unit id="efc529b5b8a635fe0248f0e1b5570f3e5c62ec50" translate="yes" xml:space="preserve">
          <source>This example encodes the input one line at a time.</source>
          <target state="translated">这个例子一次只对一行输入进行编码。</target>
        </trans-unit>
        <trans-unit id="709f6883e08535336d0975187381366956732f0d" translate="yes" xml:space="preserve">
          <source>This example of template foo has a value parameter that is specialized for 10:</source>
          <target state="translated">本例模板foo的值参数专门为10。</target>
        </trans-unit>
        <trans-unit id="0c7fc0bf8d7d58bae3c653e435da196f5834dccc" translate="yes" xml:space="preserve">
          <source>This example shows decoding one byte at a time.</source>
          <target state="translated">这个例子显示了一次一个字节的解码。</target>
        </trans-unit>
        <trans-unit id="ca9412e6a6a265cc25cdadaa2feca886b99350b4" translate="yes" xml:space="preserve">
          <source>This example shows decoding over a range of input data lines.</source>
          <target state="translated">这个例子显示了在一系列输入数据线上的解码。</target>
        </trans-unit>
        <trans-unit id="3ca157dc5296c9dbda3b67885000d1a3d169c64b" translate="yes" xml:space="preserve">
          <source>This example uses a mixin to implement a generic Duff's device for an arbitrary statement (in this case, the arbitrary statement is in bold). A nested function is generated as well as a delegate literal, these can be inlined by the compiler:</source>
          <target state="translated">这个例子使用一个 mixin 来实现一个通用的 Duff's 设备,用于任意语句(在本例中,任意语句用粗体表示)。一个嵌套的函数和一个委托文字被生成,这些可以被编译器内联。</target>
        </trans-unit>
        <trans-unit id="9fd04b9d165e95a5b5d46f431bdbd8794b151b29" translate="yes" xml:space="preserve">
          <source>This example will create an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;, and log the message using &lt;code&gt;NSLog&lt;/code&gt; to stderr.</source>
          <target state="translated">本示例将创建一个Objective-C字符串 &lt;code&gt;NSString&lt;/code&gt; ，并使用 &lt;code&gt;NSLog&lt;/code&gt; 将消息记录到stderr。</target>
        </trans-unit>
        <trans-unit id="5b44fd2927053fecf7f02a805bef21a73969e7c8" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an error occurs when parsing a UUID from a string.</source>
          <target state="translated">如果从字符串中解析UUID时发生错误,就会抛出这个异常。</target>
        </trans-unit>
        <trans-unit id="83cf2ca3dac976d4903c104f6cecb54eca32e9c0" translate="yes" xml:space="preserve">
          <source>This exists in order to find where &lt;code&gt;STC.maybescope&lt;/code&gt; is getting turned off.</source>
          <target state="translated">存在是为了找到 &lt;code&gt;STC.maybescope&lt;/code&gt; 正在关闭的位置。</target>
        </trans-unit>
        <trans-unit id="ec12e985e5f97029a4fdcc178a312496ababfe99" translate="yes" xml:space="preserve">
          <source>This fiber must be in state HOLD.</source>
          <target state="translated">该光纤必须处于HOLD状态。</target>
        </trans-unit>
        <trans-unit id="050dfac3109c2719a43b56525c7b1b2f0f5442dd" translate="yes" xml:space="preserve">
          <source>This fiber must be in state TERM or HOLD.</source>
          <target state="translated">该光纤必须处于TERM或HOLD状态。</target>
        </trans-unit>
        <trans-unit id="8069d75e504b5df60eaae8b05121a6dfce90e592" translate="yes" xml:space="preserve">
          <source>This field has been deprecated. Please use &lt;code&gt;cacheLevels&lt;/code&gt; instead.</source>
          <target state="translated">此字段已弃用。请改用 &lt;code&gt;cacheLevels&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a88f12f8698a93effebf4b21ac2fcaaf1ed6557e" translate="yes" xml:space="preserve">
          <source>This field is populated when using &lt;a href=&quot;#csvReader&quot;&gt;&lt;code&gt;csvReader&lt;/code&gt;&lt;/a&gt; but not by &lt;a href=&quot;#csvNextToken&quot;&gt;&lt;code&gt;csvNextToken&lt;/code&gt;&lt;/a&gt; as this data will have already been fed to the output range.</source>
          <target state="translated">使用&lt;a href=&quot;#csvReader&quot;&gt; &lt;code&gt;csvReader&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;#csvNextToken&quot;&gt; &lt;code&gt;csvNextToken&lt;/code&gt; 时&lt;/a&gt;，将填充此字段，因为此数据已被输入到输出范围。</target>
        </trans-unit>
        <trans-unit id="00b3ae505bfa7b5877d4290b9bf62b73f3526eab" translate="yes" xml:space="preserve">
          <source>This field was added in CURLVERSION_THIRD</source>
          <target state="translated">这个字段是在CURLVERSION_THIRD中添加的。</target>
        </trans-unit>
        <trans-unit id="ded4afb1457e0f04e1bc6ce625b9a154f7bfa729" translate="yes" xml:space="preserve">
          <source>This flag has no effect on &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该标志对&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt;没有影响。</target>
        </trans-unit>
        <trans-unit id="0c7a11a8d6d19389f0abbac4fa34ba46bd07ad35" translate="yes" xml:space="preserve">
          <source>This function</source>
          <target state="translated">该功能</target>
        </trans-unit>
        <trans-unit id="63a837cbc01e12716c2a63542540dfd3d20ec868" translate="yes" xml:space="preserve">
          <source>This function allocates memory.</source>
          <target state="translated">该函数分配内存。</target>
        </trans-unit>
        <trans-unit id="92814a3bf729ba0c96c36e96433e5f0d828849bd" translate="yes" xml:space="preserve">
          <source>This function allows user-defined subclasses of EncodingScheme to be declared in other modules.</source>
          <target state="translated">这个函数允许用户在其他模块中声明EncodingScheme的子类。</target>
        </trans-unit>
        <trans-unit id="471f7413c5ebea16f57422410a8bf930e30c75d3" translate="yes" xml:space="preserve">
          <source>This function also decomposes hangul syllables as prescribed by the standard.</source>
          <target state="translated">这个功能还可以按标准规定分解汉字音节。</target>
        </trans-unit>
        <trans-unit id="534457dcd59761dcb843df10d6fcec190ed3b4c4" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. The variadic overload is guaranteed to only perform a single allocation, as is the range version if &lt;code&gt;paths&lt;/code&gt; is a forward range.</source>
          <target state="translated">此函数始终分配内存以保存结果路径。如果 &lt;code&gt;paths&lt;/code&gt; 是正向范围，则保证可变参数重载仅执行单个分配，范围版本也是如此。</target>
        </trans-unit>
        <trans-unit id="bd9256b25c3dea2b100b91fc151d4d49aa057003" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#asNormalizedPath&quot;&gt;&lt;code&gt;asNormalizedPath&lt;/code&gt;&lt;/a&gt; to not allocate memory.</source>
          <target state="translated">此函数始终分配内存以保存结果路径。使用&lt;a href=&quot;#asNormalizedPath&quot;&gt; &lt;code&gt;asNormalizedPath&lt;/code&gt; &lt;/a&gt;不分配内存。</target>
        </trans-unit>
        <trans-unit id="187779b43f44c34c6b32550dd282a3cd2f13a1e6" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#buildNormalizedPath&quot;&gt;&lt;code&gt;buildNormalizedPath&lt;/code&gt;&lt;/a&gt; to allocate memory and return a string.</source>
          <target state="translated">此函数始终分配内存以保存结果路径。使用&lt;a href=&quot;#buildNormalizedPath&quot;&gt; &lt;code&gt;buildNormalizedPath&lt;/code&gt; &lt;/a&gt;分配内存并返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="565ae089ae893ce04d0723fbc06da8efba3b5449" translate="yes" xml:space="preserve">
          <source>This function calls &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt;&lt;code&gt;FlushFileBuffers&lt;/code&gt;&lt;/a&gt; on Windows and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt;&lt;code&gt;fsync&lt;/code&gt;&lt;/a&gt; on POSIX for the file handle.</source>
          <target state="translated">此函数在Windows 上调用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt; &lt;code&gt;FlushFileBuffers&lt;/code&gt; &lt;/a&gt;，在POSIX 上&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt; &lt;code&gt;fsync&lt;/code&gt; &lt;/a&gt;作为文件句柄。</target>
        </trans-unit>
        <trans-unit id="f8c2e50367d22c68b1ef6bf70b530cf16359f88a" translate="yes" xml:space="preserve">
          <source>This function can allocate if the &lt;code&gt;Yes.allocateGC&lt;/code&gt; flag is passed. This has the benefit of have better complexity than the &lt;code&gt;Yes.allocateGC&lt;/code&gt; option. However, this option is only available for ranges whose equality can be determined via each element's &lt;code&gt;toHash&lt;/code&gt; method. If customized equality is needed, then the &lt;code&gt;pred&lt;/code&gt; template parameter can be passed, and the function will automatically switch to the non-allocating algorithm. See &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; for more details on how to define &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">如果传递了 &lt;code&gt;Yes.allocateGC&lt;/code&gt; 标志，则此函数可以分配。与 &lt;code&gt;Yes.allocateGC&lt;/code&gt; 选项相比，这样做的好处是具有更好的复杂性。但是，此选项仅适用于可以通过每个元素的 &lt;code&gt;toHash&lt;/code&gt; 方法确定其相等性的范围。如果需要自定义的相等性，则可以传递 &lt;code&gt;pred&lt;/code&gt; template参数，该函数将自动切换到非分配算法。有关如何定义 &lt;code&gt;pred&lt;/code&gt; 的更多详细信息，请参见&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b1f8d9be7c40727aeac47ccfd7444f517f04172" translate="yes" xml:space="preserve">
          <source>This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">这个功能可以 &lt;code&gt;@trusted&lt;/code&gt; 如果相应构造 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="287c25734ab50e3ae9a7c39776861bb5646f4c1c" translate="yes" xml:space="preserve">
          <source>This function can perform a case-sensitive or a case-insensitive comparison. This is controlled through the &lt;code&gt;cs&lt;/code&gt; template parameter which, if not specified, is given by &lt;a href=&quot;#CaseSensitive&quot;&gt;&lt;code&gt;CaseSensitive&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.osDefault&lt;/code&gt;.</source>
          <target state="translated">此函数可以执行区分大小写或不区分大小写的比较。这由 &lt;code&gt;cs&lt;/code&gt; 模板参数控制，如果未指定，则由&lt;a href=&quot;#CaseSensitive&quot;&gt; &lt;code&gt;CaseSensitive&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.osDefault&lt;/code&gt; 给出。</target>
        </trans-unit>
        <trans-unit id="5e873b6c5b5805640016d4214ee3463e370b995d" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt; the POSIX requirements for the 'basename' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="translated">此函数符合&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt;&amp;ldquo; basename&amp;rdquo; shell实用程序的POSIX要求&lt;/a&gt;（对Windows路径进行了适当的修改）。</target>
        </trans-unit>
        <trans-unit id="271fe9a4358104e29e9baaf0f70ca7697a626f35" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt; the POSIX requirements for the 'dirname' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="translated">此函数符合&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt;&amp;ldquo; dirname&amp;rdquo; shell实用程序的POSIX要求&lt;/a&gt;（对Windows路径进行了适当的修改）。</target>
        </trans-unit>
        <trans-unit id="f911814cd134bf58a8ba7e68aae37ec618511b50" translate="yes" xml:space="preserve">
          <source>This function consumes the input. After each call the input will start with either a delimiter or record break (\n, \r\n, \r) which must be removed for subsequent calls.</source>
          <target state="translated">该函数消耗输入。在每次调用后,输入将以一个定界符或记录中断开始(\n,\r\n,\r),这些记录必须在后续调用中被删除。</target>
        </trans-unit>
        <trans-unit id="82adca51d2d89c2e52168f23c5014dcf4b09b7e3" translate="yes" xml:space="preserve">
          <source>This function creates a complete DOM (Document Object Model) tree.</source>
          <target state="translated">该函数创建一个完整的DOM(文档对象模型)树。</target>
        </trans-unit>
        <trans-unit id="34f7e14685f9dc1d8824f48b2307f8cd989b3e43" translate="yes" xml:space="preserve">
          <source>This function decodes the entities &amp;amp;amp;, &amp;amp;quot;, &amp;amp;apos;, &amp;amp;lt; and &amp;amp;gt, as well as decimal and hexadecimal entities such as &amp;amp;#x20AC;</source>
          <target state="translated">该功能对实体＆amp;，&amp;ldquo;，&amp;rdquo;，＆lt; 和＆gt，以及十进制和十六进制实体，例如＆＃x20AC;</target>
        </trans-unit>
        <trans-unit id="37bc9985a8792341b2d7a8d50dc7ab55bd1e93ad" translate="yes" xml:space="preserve">
          <source>This function defends against this attack by always comparing every single item in the array if the two arrays are the same length. Therefore, this function is always &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;) for ranges of the same length.</source>
          <target state="translated">如果两个数组的长度相同，则此函数通过始终比较数组中的每个单个项来防御这种攻击。因此，对于相同长度的范围，此函数始终为&amp;omicron;（ &lt;code&gt;n&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="07fbd70f1f7940fca06c0a8a3c74b8aabe9ac979" translate="yes" xml:space="preserve">
          <source>This function does not provide overloads for wstring and dstring, as there's no clear answer on how that should be implemented. It could be argued, that string, wstring and dstring input should have the same output, but that wouldn't be compatible with Boost, which generates different output for strings and wstrings. It's always possible to pass wstrings and dstrings by using the ubyte[] function overload (but be aware of endianness issues!).</source>
          <target state="translated">这个函数不提供wstring和dstring的重载,因为没有明确的答案应该如何实现。可以说,字符串、wstring和dstring的输入应该有相同的输出,但这与Boost不兼容,因为Boost会为字符串和wstrings生成不同的输出。通过使用ubyte[]函数重载来传递wstrings和dstrings总是可能的(但是要注意endianness问题!)。</target>
        </trans-unit>
        <trans-unit id="a7eab1a520623d1ac5e68ed2c102542d0c568c2a" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units The code units are stored in a user-supplied fixed-size array, which must be passed by reference.</source>
          <target state="translated">该函数将单个代码点编码成一个或多个代码单元,代码单元存储在一个用户提供的固定大小的数组中,该数组必须通过引用传递。</target>
        </trans-unit>
        <trans-unit id="a4dfecb064dc08682e5d5f6ff6e2a923d6c06c55" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. It returns a string containing those code units.</source>
          <target state="translated">该函数将一个代码点编码成一个或多个代码单位。它返回一个包含这些代码单位的字符串。</target>
        </trans-unit>
        <trans-unit id="d23af3939d6f49cb27a211fdfb01f49551cd4f68" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. The code units are passed one at a time to the supplied delegate.</source>
          <target state="translated">该函数将一个代码点编码成一个或多个代码单位。这些代码单元每次都会被传递给所提供的委托人。</target>
        </trans-unit>
        <trans-unit id="fd5007482279246870e612a2f7b9d7848a9ec8a9" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more ubytes. The supplied buffer must be code unit aligned. (For example, UTF-16LE or UTF-16BE must be wchar-aligned, UTF-32LE or UTF-32BE must be dchar-aligned, etc.)</source>
          <target state="translated">该函数将单个码点编码为一个或多个uby字节。提供的缓冲区必须是代码单位对齐的。例如,UTF-16LE或UTF-16BE必须是wchar对齐,UTF-32LE或UTF-32BE必须是dchar对齐,等等。</target>
        </trans-unit>
        <trans-unit id="5a399e2ee90c7d22546000e946a9cf8427b4a082" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">使用此函数可以轻松地将&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;转换为字符串，而不必关心确切的格式，而只是以清晰的方式显示信息。使用 &lt;code&gt;to!string&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; 或 &lt;code&gt;writeln&lt;/code&gt; 之类的函数（使用toString转换用户定义的类型）时，还可以轻松地简单地将&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;转换为字符串。因此，不太可能有太多代码直接调用toString。</target>
        </trans-unit>
        <trans-unit id="1c7ed4f81f0a82e13d48bb2e31cd6ec82cd2b86c" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">使用此函数可以轻松地将&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;转换为字符串，而不必关心确切的格式，而只是以清晰的方式显示信息。使用 &lt;code&gt;to!string&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; 或 &lt;code&gt;writeln&lt;/code&gt; 之类的函数（使用toString转换用户定义的类型）时，还可以轻松地简单地将&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;转换为字符串。因此，不太可能有太多代码直接调用toString。</target>
        </trans-unit>
        <trans-unit id="6a64dc24e50c98de86395100f53371f383577cde" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">使用此功能可以轻松地将&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;转换为字符串，而不必关心确切的格式，而只是以清晰的方式显示信息。使用 &lt;code&gt;to!string&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; 或 &lt;code&gt;writeln&lt;/code&gt; 之类的函数（使用toString转换用户定义的类型）时，还可以轻松地将&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;转换为字符串。因此，不太可能有太多代码直接调用toString。</target>
        </trans-unit>
        <trans-unit id="14f41e253b823f745b15c2cc550803f474f520f9" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">存在此函数的目的在于，可以轻松地将&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;转换为字符串，而不必关心确切的格式，而只是以清晰的方式显示信息。使用 &lt;code&gt;to!string&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; 或 &lt;code&gt;writeln&lt;/code&gt; 之类的函数（使用toString转换用户定义的类型）时，还可以轻松地将&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;转换为字符串。因此，不太可能有太多代码直接调用toString。</target>
        </trans-unit>
        <trans-unit id="1148e69f156783aee95aaac3af378446a842c947" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 3) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="translated">此函数从名称空间UUID和名称生成基于名称（版本3）的UUID。如果未传递任何名称空间UUID，则使用空的UUID &lt;code&gt;UUID.init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66eef894e5457f79fe590d4b75d5bdb426faba8d" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 5) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="translated">此函数从名称空间UUID和名称生成基于名称（版本5）的UUID。如果未传递任何名称空间UUID，则使用空的UUID &lt;code&gt;UUID.init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebad38cdc822b58300e9d455ffae98ef3b8355b1" translate="yes" xml:space="preserve">
          <source>This function generates a random number based UUID from a random number generator.</source>
          <target state="translated">该函数从随机数生成器中生成一个基于随机数的UUID。</target>
        </trans-unit>
        <trans-unit id="f6f7c9706e6dcaec3dbc1161d8b30b320ab44ea3" translate="yes" xml:space="preserve">
          <source>This function has high relative accuracy for values of x far from zero. (For values near zero, use erf(x)).</source>
          <target state="translated">这个函数对于远离零的x值有很高的相对精度。对于接近零的值,使用 erf(x))。</target>
        </trans-unit>
        <trans-unit id="e015cb774f65ac50bf4cc869720d1f86b5a714ec" translate="yes" xml:space="preserve">
          <source>This function is #1 on the list of functions that eat cpu time. Be very, very careful about slowing it down.</source>
          <target state="translated">这个函数是吃cpu时间的函数列表中的第一名。要非常非常小心地减慢它的速度。</target>
        </trans-unit>
        <trans-unit id="3d30b43ff787a8dfba63ef7540785dda2309b0ec" translate="yes" xml:space="preserve">
          <source>This function is &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">此函数为&amp;Omicron;（ &lt;code&gt;r.length&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="60a203a8ffe09817c002b043b4f7c89faa37bc5d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;@safe&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 的对应构造函数为 &lt;code&gt;@safe&lt;/code&gt; ,则此函数为 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f04b8551bbda2b81d8696beac9a1b771dca8c71" translate="yes" xml:space="preserve">
          <source>This function is Posix-Only.</source>
          <target state="translated">这个功能是Posix-Only的。</target>
        </trans-unit>
        <trans-unit id="fbf60467a7efe2e24827c64edfe554cec3d53403" translate="yes" xml:space="preserve">
          <source>This function is Windows-Only.</source>
          <target state="translated">此功能仅适用于Windows。</target>
        </trans-unit>
        <trans-unit id="103c72135b781967b4b7d6c0026bb26f7259605d" translate="yes" xml:space="preserve">
          <source>This function is also useful in checking for the existence of an environment variable.</source>
          <target state="translated">这个函数在检查环境变量是否存在时也很有用。</target>
        </trans-unit>
        <trans-unit id="ff6b0b14fd4304f9c34b27c03cced94d986e4033" translate="yes" xml:space="preserve">
          <source>This function is character-range specific and, contrary to &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt;, runs of whitespace will be merged together (no empty tokens will be produced).</source>
          <target state="translated">此功能是特定于字符范围的，并且与 &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt; 相反，空白空格将合并在一起（不会生成空令牌）。</target>
        </trans-unit>
        <trans-unit id="65b5ee7f9fec25cbb593bdce1cbdc98ea5f973e1" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and calls &lt;code&gt;deallocateAll&lt;/code&gt; for them in turn.</source>
          <target state="translated">仅当两个分配器都定义了该函数，然后依次为其调用 &lt;code&gt;deallocateAll&lt;/code&gt; 时，才定义此函数。</target>
        </trans-unit>
        <trans-unit id="8e12c13033743e308c93ef7b1af47f1c5b48d3a7" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and forwards appropriately depending on &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">仅当两个分配器都定义了此函数，然后才根据 &lt;code&gt;b.length&lt;/code&gt; 进行适当转发。</target>
        </trans-unit>
        <trans-unit id="ebd4634555bf7b1d8d38cdad8559fbd72f2f0cbb" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and returns the conjunction of &lt;code&gt;empty&lt;/code&gt; calls for the two.</source>
          <target state="translated">该功能仅定义如果两个分配器定义它，并返回的联合 &lt;code&gt;empty&lt;/code&gt; 两个电话。</target>
        </trans-unit>
        <trans-unit id="72987efb86a1c65d967d861a8683d92ed7f13b9d" translate="yes" xml:space="preserve">
          <source>This function is not generally very useful; it's almost always better to use the faster functions nextUp() or nextDown() instead.</source>
          <target state="translated">这个函数一般不是很有用,最好使用更快的函数nextUp()或nextDown()来代替。</target>
        </trans-unit>
        <trans-unit id="e7e3e7b8bfa4b21481d77f68ea65de0d9b8237c1" translate="yes" xml:space="preserve">
          <source>This function is not supported at compile time.</source>
          <target state="translated">编译时不支持此功能。</target>
        </trans-unit>
        <trans-unit id="1569b54f86e9b2550627b7e8e8f05e326ad676e8" translate="yes" xml:space="preserve">
          <source>This function is not thread-safe!</source>
          <target state="translated">这个功能不是线程安全的</target>
        </trans-unit>
        <trans-unit id="41af9d14cc682c76550081ea13492c59097f2bca" translate="yes" xml:space="preserve">
          <source>This function is only aware of EncodingSchemes which have been registered with the register() function.</source>
          <target state="translated">这个函数只知道已经用register()函数注册的EncodingSchemes。</target>
        </trans-unit>
        <trans-unit id="290ee1b0991973abcaa58bca7c5f6871e5deb008" translate="yes" xml:space="preserve">
          <source>This function is only implemented to 80 bit precision.</source>
          <target state="translated">该功能仅实现80位精度。</target>
        </trans-unit>
        <trans-unit id="ee429d1ffe9a170a1a75d5b4a2ff165cd4f65550" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, all elements of tiargs won't be modified.</source>
          <target state="translated">这个函数是针对错误发生的重入式函数,如果返回false,所有tiargs的元素都不会被修改。如果返回false,tiargs的所有元素将不会被修改。</target>
        </trans-unit>
        <trans-unit id="a118a63c84fce3cf7c06f5f8756bac60c7cca3ac" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, any members of this object won't be modified, and repetition call will reproduce same error.</source>
          <target state="translated">这个函数是针对错误发生的重入式函数,如果返回false,所有tiargs的元素都不会被修改。如果返回false,这个对象的任何成员都不会被修改,重复调用会重现同样的错误。</target>
        </trans-unit>
        <trans-unit id="45e502c95c63dd3997ac1ae57545286a53eaf26c" translate="yes" xml:space="preserve">
          <source>This function is supported in CTFE code. Note that error messages caused by a malformed UUID parsed at compile time can be cryptic, but errors are detected and reported at compile time.</source>
          <target state="translated">CTFE代码中支持此功能。请注意,在编译时解析的UUID错误引起的错误信息可能是神秘的,但在编译时就会检测并报告错误。</target>
        </trans-unit>
        <trans-unit id="5bb3aca496547a19019cbfbd46c1d03c7dd418c6" translate="yes" xml:space="preserve">
          <source>This function is tentatively defined as &lt;code&gt;nothrow&lt;/code&gt; to prevent &lt;code&gt;opPostMove&lt;/code&gt; from being defined without &lt;code&gt;nothrow&lt;/code&gt;, which would allow for possibly confusing changes in program flow.</source>
          <target state="translated">此功能暂时定义为 &lt;code&gt;nothrow&lt;/code&gt; 以防止 &lt;code&gt;opPostMove&lt;/code&gt; 从没有被定义的 &lt;code&gt;nothrow&lt;/code&gt; ，这将允许可能混淆的程序流的变化。</target>
        </trans-unit>
        <trans-unit id="185d734d5fc912e0041185bf79a2b6f944b2db35" translate="yes" xml:space="preserve">
          <source>This function is used to (re)initialize the digest. It must be called before using the digest and it also works as a 'reset' function if the digest has already processed data.</source>
          <target state="translated">这个函数用于(重新)初始化摘要。它必须在使用摘要之前被调用,如果摘要已经处理过数据,它也可以作为一个 &quot;复位 &quot;函数。</target>
        </trans-unit>
        <trans-unit id="99071cc1c1c24be1d51b7e6eda1e08791479ed2b" translate="yes" xml:space="preserve">
          <source>This function is used to read the content of DFLAGS. Flags are separated based on spaces and tabs.</source>
          <target state="translated">该函数用于读取DFLAGS的内容。标志以空格和制表符分开。</target>
        </trans-unit>
        <trans-unit id="2d39d375bb67b5bea56b7ea75d0a2e4ee34a5fe2" translate="yes" xml:space="preserve">
          <source>This function is useful for maintaining worker-local resources.</source>
          <target state="translated">这个功能对维护工人本地资源很有用。</target>
        </trans-unit>
        <trans-unit id="c37fe60667a42f9d7da86b803e8b5052d66d498d" translate="yes" xml:space="preserve">
          <source>This function is, in particular, meant to help maintain garbage collector invariants when a lock is not used.</source>
          <target state="translated">这个函数尤其是为了在不使用锁的时候帮助维护垃圾收集器的不变性。</target>
        </trans-unit>
        <trans-unit id="aa18c6da596117f8b9e11fbedcdfb9a943118fde" translate="yes" xml:space="preserve">
          <source>This function logs data in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以 &lt;code&gt;printf&lt;/code&gt; 样式记录数据。</target>
        </trans-unit>
        <trans-unit id="77ac69a4b95956005ebe3b90c8e1ca91567efe01" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以 &lt;code&gt;printf&lt;/code&gt; 样式的方式将数据记录到 &lt;code&gt;sharedLog&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98febaf749a97b9336fc523ba35aa7fdcff34cf1" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;, optionally depending on a condition.</source>
          <target state="translated">此函数将数据记录到 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; ，视情况而定。</target>
        </trans-unit>
        <trans-unit id="eda414e04cca7c9801e1364601be4f243d02a0be" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">该功能的日志数据所使用的 &lt;code&gt;Logger&lt;/code&gt; 根据与一个条件 &lt;code&gt;LogLevel&lt;/code&gt; 所使用的 &lt;code&gt;Logger&lt;/code&gt; 中一个 &lt;code&gt;printf&lt;/code&gt; 风格的方式。</target>
        </trans-unit>
        <trans-unit id="66789021f1f75fa2b910c0e9aaed002765517585" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition.</source>
          <target state="translated">此功能根据条件将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea29ac02cb23a3225768859acfa66ad70cf0ae39" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a explicitly passed condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此函数根据使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 明确传递的条件将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7a8c9b909022c7e8d9e73cb0c216e864ba19a51" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以 &lt;code&gt;printf&lt;/code&gt; 样式将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="628f5766ea3ce125dda3efbe604aac9ecda078eb" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; and depending on a condition in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以特定的 &lt;code&gt;LogLevel&lt;/code&gt; 并根据条件以 &lt;code&gt;printf&lt;/code&gt; 样式方式将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f75a8e8d5f3578debc1682e9b8a4e7729b3c532e" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以特定的 &lt;code&gt;LogLevel&lt;/code&gt; 以 &lt;code&gt;printf&lt;/code&gt; 样式的方式将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="ca804d9917691f26fc7fe486237e02550749abb2" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">此函数通过特定 &lt;code&gt;LogLevel&lt;/code&gt; 将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3ca01c9755ef83db66052e862db8bfa8416b4a46" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此函数使用二手 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 将数据记录到二手 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="32b20bbe0e9053ff439b8531776b44b5d48b2b21" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此功能将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="de4891742f4a098eab831566cf8b20847dcaef47" translate="yes" xml:space="preserve">
          <source>This function logs data.</source>
          <target state="translated">该功能可记录数据。</target>
        </trans-unit>
        <trans-unit id="f6a6f2512cc3b6d3cec5f7eabcb2475f26f787b9" translate="yes" xml:space="preserve">
          <source>This function modifies &lt;code&gt;inp&lt;/code&gt; and thus &lt;code&gt;inp&lt;/code&gt; must be an L-value.</source>
          <target state="translated">此函数修改 &lt;code&gt;inp&lt;/code&gt; ，因此 &lt;code&gt;inp&lt;/code&gt; 必须为L值。</target>
        </trans-unit>
        <trans-unit id="e7aa3a07169729c5a673fe4e99d00fd959fedfe3" translate="yes" xml:space="preserve">
          <source>This function normally allocates a new string (the possible exception being the case when path is immutable and doesn't already have an extension).</source>
          <target state="translated">这个函数通常会分配一个新的字符串(可能的例外情况是当路径是不可变的,并且还没有扩展时)。</target>
        </trans-unit>
        <trans-unit id="7c7d082480a49d72cdaa9587898253b55870d5fe" translate="yes" xml:space="preserve">
          <source>This function only handles 1:1 &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; mapping and thus is not sufficient for certain alphabets like German, Greek and few others.</source>
          <target state="translated">此功能仅处理1：1的&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;映射，因此对于某些字母（例如德语，希腊语和其他少数几个字母）是不够的。</target>
        </trans-unit>
        <trans-unit id="4d4c84cebd7adfe7f4082a2a17dcc09bc723efd3" translate="yes" xml:space="preserve">
          <source>This function performs several memory allocations.</source>
          <target state="translated">该函数执行多项内存分配。</target>
        </trans-unit>
        <trans-unit id="36f6f15315bfa28fc8956871508424ecedf0dc3c" translate="yes" xml:space="preserve">
          <source>This function picks the most suitable regular expression engine depending on the pattern properties.</source>
          <target state="translated">该函数根据模式属性选择最合适的正则表达式引擎。</target>
        </trans-unit>
        <trans-unit id="34bd902809c0b5255b567c50dd18197e0b398a33" translate="yes" xml:space="preserve">
          <source>This function prints the passed &lt;code&gt;Option&lt;/code&gt;s and text in an aligned manner on &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">此函数在 &lt;code&gt;stdout&lt;/code&gt; 上以对齐方式打印传递的 &lt;code&gt;Option&lt;/code&gt; 和文本。</target>
        </trans-unit>
        <trans-unit id="770ded5804f61f67694592c9314c6c39ad348096" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the end of a string, and returns the decoded code point which those code units represent.</source>
          <target state="translated">该函数从字符串的末尾删除一个或多个代码单元,并返回这些代码单元所代表的解码码点。</target>
        </trans-unit>
        <trans-unit id="63d27ce6c5e48781869a5f906f514c111b2ab498" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the start of a string, and returns the decoded code point which those code units represent.</source>
          <target state="translated">这个函数从一个字符串的开头删除一个或多个代码单元,并返回这些代码单元所代表的解码码点。</target>
        </trans-unit>
        <trans-unit id="991bbd196cea9f8531404b722484d52c7268693c" translate="yes" xml:space="preserve">
          <source>This function removes one or more ubytes from the start of an array, and returns the decoded code point which those ubytes represent.</source>
          <target state="translated">这个函数从一个数组的开头删除一个或多个uby字节,并返回这些uby字节所代表的解码码点。</target>
        </trans-unit>
        <trans-unit id="bd8d3ae1218b20b89d6f5e7ab875d1f322ea2c00" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; on Windows, &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; on POSIX, and &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; on Android.</source>
          <target state="translated">这个函数返回 &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; 在Windows上， &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; 关于POSIX和 &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; 在Android上。</target>
        </trans-unit>
        <trans-unit id="cfc5056dabba79a946af25fc1dd8feac3fe04895" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to a static copy of the version info struct. See above.</source>
          <target state="translated">这个函数返回一个指向版本信息结构静态副本的指针。参见上文。</target>
        </trans-unit>
        <trans-unit id="bb8f6db61ab479424f86bd4d40e2eb70c3733a62" translate="yes" xml:space="preserve">
          <source>This function returns a thread unique &lt;code&gt;Logger&lt;/code&gt;, that by default propergates all data logged to it to the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">此函数返回一个线程唯一的 &lt;code&gt;Logger&lt;/code&gt; ，默认情况下，它将记录到该线程的所有数据分配到 &lt;code&gt;sharedLog&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85a54448d469e795c947752c78a6d4cb2de70c6f" translate="yes" xml:space="preserve">
          <source>This function searches with policy &lt;code&gt;sp&lt;/code&gt; to find the largest right subrange on which &lt;code&gt;pred(value, x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly greater than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数使用策略 &lt;code&gt;sp&lt;/code&gt; 搜索，以找到所有 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;pred(value, x)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的最大右子范围（例如，如果 &lt;code&gt;pred&lt;/code&gt; &amp;ldquo;小于&amp;rdquo;，则返回元素严格大于 &lt;code&gt;value&lt;/code&gt; 的范围的那一部分）。搜索时间表及其复杂性记录在&lt;a href=&quot;#SearchPolicy&quot;&gt; &lt;code&gt;SearchPolicy&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86863ccd0cc5913a3769149726c682b13dc136f9" translate="yes" xml:space="preserve">
          <source>This function sets an association in the multi handle between the given socket and a private pointer of the application. This is (only) useful for curl_multi_socket uses.</source>
          <target state="translated">这个函数在多句柄中设置给定套接字和应用程序的私有指针之间的关联。这个函数(仅)对 curl_multi_socket 的使用有用。</target>
        </trans-unit>
        <trans-unit id="45ebc1498e7faf85df00e384f08e7ba59324aaf5" translate="yes" xml:space="preserve">
          <source>This function should be used for expensive functions, as waiting on a condition variable introduces latency, but avoids wasted CPU cycles.</source>
          <target state="translated">这个函数应该用于昂贵的函数,因为在条件变量上的等待会引入延迟,但可以避免浪费CPU周期。</target>
        </trans-unit>
        <trans-unit id="1e6634f9a998d963ab6d1c10d0d15ad19ccda248" translate="yes" xml:space="preserve">
          <source>This function should be used when you expect the result of the &lt;code&gt;Task&lt;/code&gt; to be available on a timescale shorter than that of an OS context switch.</source>
          <target state="translated">当您希望 &lt;code&gt;Task&lt;/code&gt; 的结果在比操作系统上下文切换更短的时间范围内可用时，应使用此功能。</target>
        </trans-unit>
        <trans-unit id="84d0dda7f69c92e937d2c85cb930b35b5906bc64" translate="yes" xml:space="preserve">
          <source>This function simply returns the &lt;code&gt;Rebindable&lt;/code&gt; object passed in. It's useful in generic programming cases when a given object may be either a regular &lt;code&gt;class&lt;/code&gt; or a &lt;code&gt;Rebindable&lt;/code&gt;.</source>
          <target state="translated">此函数仅返回传入的 &lt;code&gt;Rebindable&lt;/code&gt; 对象。在给定对象可能是常规 &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;Rebindable&lt;/code&gt; 的泛型编程情况下，此函数很有用。</target>
        </trans-unit>
        <trans-unit id="75bbfb153afd3973808d9088100797f6903e565d" translate="yes" xml:space="preserve">
          <source>This function supercedes &lt;a href=&quot;#toUCSindex&quot;&gt;&lt;code&gt;toUCSindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数取代&lt;a href=&quot;#toUCSindex&quot;&gt; &lt;code&gt;toUCSindex&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82566e279c83708bdcc5beef2341e2cb52b9d496" translate="yes" xml:space="preserve">
          <source>This function supersedes &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt;.</source>
          <target state="translated">此函数取代 &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8a982375de1de2eaf1b0bfc6ef749e37da8e235" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode(), however, note that the function codePoints() supersedes it more conveniently.</source>
          <target state="translated">这个函数取代了std.utf.decode(),但是,请注意,函数codePoints()取代它更方便。</target>
        </trans-unit>
        <trans-unit id="3610464c0d3095b814b50eec2269b0b83ec7dc6a" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode().</source>
          <target state="translated">这个函数取代了std.utf.decode()。</target>
        </trans-unit>
        <trans-unit id="3ed87f3ac177989d1d591be6e146c6a7ad9b003c" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode(), however, note that the function codeUnits() supersedes it more conveniently.</source>
          <target state="translated">这个函数取代了std.utf.encode(),但是,请注意,函数codeUnits()取代它更方便。</target>
        </trans-unit>
        <trans-unit id="98db0a10ff6e0809060d25a9c9ccbac61cd894c8" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode().</source>
          <target state="translated">这个函数取代了std.utf.encode()。</target>
        </trans-unit>
        <trans-unit id="6581afa2c255deba8c9a51b34c12340690fe56e5" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTF8(), std.utf.toUTF16() and std.utf.toUTF32() (but note that to!() supersedes it more conveniently).</source>
          <target state="translated">这个函数取代了std.utf.toUTF8()、std.utf.toUTF16()和std.utf.toUTF32()(但注意to!()取代它更方便)。</target>
        </trans-unit>
        <trans-unit id="b48f04fdfd63524d418640a2544c0d752dc1f11b" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTFindex().</source>
          <target state="translated">这个函数取代了std.utf.toUTFindex()。</target>
        </trans-unit>
        <trans-unit id="463c192ee5d4e01c6f9684913be662a0a7946d01" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.validate(), however note that this function returns a bool indicating whether the input was valid or not, whereas the older function would throw an exception.</source>
          <target state="translated">这个函数取代了std.utf.validate(),但是要注意的是,这个函数返回一个表示输入是否有效的bool,而旧的函数会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="b42d760296ed5ca95af88ffb26c20168d2a48b77" translate="yes" xml:space="preserve">
          <source>This function takes a non-scope delegate, meaning it can be used with closures. If you can't allocate a closure due to objects on the stack that have scoped destruction, see &lt;code&gt;scopedTask&lt;/code&gt;, which takes a scope delegate.</source>
          <target state="translated">此函数采用非作用域委托，这意味着它可以与闭包一起使用。如果由于堆栈上具有范围破坏的对象而无法分配闭包，请参阅 &lt;code&gt;scopedTask&lt;/code&gt; ，它接受了一个范围委托。</target>
        </trans-unit>
        <trans-unit id="df71b7c251663548a0f5121464d05a78978a7d9e" translate="yes" xml:space="preserve">
          <source>This function takes a set of path segments, given as an input range of string elements or as a set of string arguments, and concatenates them with each other. Directory separators are inserted between segments if necessary. If any of the path segments are absolute (as defined by &lt;a href=&quot;#isAbsolute&quot;&gt;&lt;code&gt;isAbsolute&lt;/code&gt;&lt;/a&gt;), the preceding segments will be dropped.</source>
          <target state="translated">此函数采用一组路径段（作为字符串元素的输入范围或一组字符串参数给出），并将它们彼此串联在一起。如有必要，在段之间插入目录分隔符。如果任何路径段都是绝对的（由&lt;a href=&quot;#isAbsolute&quot;&gt; &lt;code&gt;isAbsolute&lt;/code&gt; &lt;/a&gt;定义），则前面的段将被删除。</target>
        </trans-unit>
        <trans-unit id="3df6f1df50a9028bb24157314b57114720f745cc" translate="yes" xml:space="preserve">
          <source>This function template needs be between the compiler and a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">此功能模板需要介于编译器和较旧的运行时挂钩之间，后者绕过安全性，纯度和可抛出性检查。为防止破坏现有代码，此函数模板被临时声明为 &lt;code&gt;@trusted pure&lt;/code&gt; ,直到实现可以达到现代D的期望为止。</target>
        </trans-unit>
        <trans-unit id="c911ca2b3e26ac7f7502675d63ee542618ab2fa0" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure nothrow&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">该功能模板是从一个较旧的运行时钩子移植而来的，该钩子绕过了安全性，纯度和可投掷性检查。为防止破坏现有代码，此函数模板临时声明为 &lt;code&gt;@trusted pure nothrow&lt;/code&gt; ,直到可以使实现达到现代D的期望为止。</target>
        </trans-unit>
        <trans-unit id="9fd88572c57bc63342adb7e4bba717ecc664649b" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">该功能模板是从一个较旧的运行时钩子移植而来的，该钩子绕过了安全性，纯度和可投掷性检查。为防止破坏现有代码，此函数模板被临时声明为 &lt;code&gt;@trusted pure&lt;/code&gt; ,直到实现可以达到现代D的期望为止。</target>
        </trans-unit>
        <trans-unit id="54aa9e4c989c8754e09bfc948cb90d22fd4c28bf" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">该功能模板是从一个较旧的运行时钩子移植而来的，该钩子绕过了安全性，纯度和可投掷性检查。为防止破坏现有代码，此函数模板被临时声明为 &lt;code&gt;@trusted&lt;/code&gt; ,直到可以使实现达到现代D的期望为止。</target>
        </trans-unit>
        <trans-unit id="c6faa363e2dc5b5097ffda67002301974586de4b" translate="yes" xml:space="preserve">
          <source>This function transforms &lt;code&gt;decimal&lt;/code&gt; value into a value in the factorial number system stored in &lt;code&gt;fac&lt;/code&gt;.</source>
          <target state="translated">此函数将 &lt;code&gt;decimal&lt;/code&gt; 值转换为存储在 &lt;code&gt;fac&lt;/code&gt; 中的阶乘系统中的值。</target>
        </trans-unit>
        <trans-unit id="8756d8490c0c80f8a3d6e17d81badb070e1ac3c5" translate="yes" xml:space="preserve">
          <source>This function uses a search with policy &lt;code&gt;sp&lt;/code&gt; to find the largest left subrange on which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly smaller than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数使用带有策略 &lt;code&gt;sp&lt;/code&gt; 的搜索来查找所有 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;pred(x, value)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的最大左子范围（例如，如果 &lt;code&gt;pred&lt;/code&gt; 为&amp;ldquo;小于&amp;rdquo;，则返回元素严格小于 &lt;code&gt;value&lt;/code&gt; 的范围的一部分））。搜索时间表及其复杂性记录在&lt;a href=&quot;#SearchPolicy&quot;&gt; &lt;code&gt;SearchPolicy&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4d6e17a7f140767c7776fa94ca98edbcfe8ab26" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded array as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="translated">这个函数将接受一个无效编码的数组作为输入,如果在字符串的开头发现一个无效的序列,这个函数将删除它,并返回值INVALID_SEQUENCE。如果在字符串的开头发现一个无效的序列,这个函数将删除它,并返回值INVALID_SEQUENCE。</target>
        </trans-unit>
        <trans-unit id="b3cc6b0a88ba3b96758bad3549ef80853faeb94e" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded string as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="translated">这个函数将接受一个无效编码的字符串作为输入,如果在字符串的开头发现一个无效的序列,这个函数将删除它,并返回值INVALID_SEQUENCE。如果在字符串的开头发现一个无效的序列,这个函数将删除它,并返回值INVALID_SEQUENCE。</target>
        </trans-unit>
        <trans-unit id="b4c790e3c00edf06c3c523e9a96acaa7028222ba" translate="yes" xml:space="preserve">
          <source>This function will also strip &lt;code&gt;\n\r&lt;/code&gt;.</source>
          <target state="translated">此功能还将删除 &lt;code&gt;\n\r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2b84c3cd64925b3bc63cc6da8970f088bb9f6ed" translate="yes" xml:space="preserve">
          <source>This function will be called when an exception is constructed. The user-supplied trace handler will be called if one has been supplied, otherwise no trace will be generated.</source>
          <target state="translated">当一个异常被构造时,这个函数将被调用。如果有用户提供的跟踪处理程序,则会被调用,否则不会产生跟踪。</target>
        </trans-unit>
        <trans-unit id="5d78c169d84f9e0fc354575058eb3e604cfbfdad" translate="yes" xml:space="preserve">
          <source>This function will be called with elements of &lt;code&gt;inputRange&lt;/code&gt; progressively as iteration proceeds.</source>
          <target state="translated">随着迭代的进行，将使用 &lt;code&gt;inputRange&lt;/code&gt; 的元素逐渐调用此函数。</target>
        </trans-unit>
        <trans-unit id="68ba6b0b259ab19a35f9197082fe2ab6d70f5d70" translate="yes" xml:space="preserve">
          <source>This function will generate a module called &lt;code&gt;__entrypoint&lt;/code&gt;, and set the globals &lt;code&gt;entrypoint&lt;/code&gt; and &lt;code&gt;rootHasMain&lt;/code&gt;.</source>
          <target state="translated">此函数将生成一个名为 &lt;code&gt;__entrypoint&lt;/code&gt; 的模块，并设置全局 &lt;code&gt;entrypoint&lt;/code&gt; 和 &lt;code&gt;rootHasMain&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc2b9580fcf2b39177541158722d4ae408a87a59" translate="yes" xml:space="preserve">
          <source>This function works by splitting the range to be reduced into work units, which are slices to be reduced in parallel. Once the results from all work units are computed, a final serial reduction is performed on these results to compute the final answer. Therefore, care must be taken to choose the seed value appropriately.</source>
          <target state="translated">该函数的工作原理是将待还原的范围分割成工作单元,这些工作单元是要并行还原的切片。一旦计算出所有工作单元的结果,就会对这些结果进行最后的串行还原,计算出最终的答案。因此,必须注意适当地选择种子值。</target>
        </trans-unit>
        <trans-unit id="d3aad905401dc04f581b2c6077d97923bbd2a8dd" translate="yes" xml:space="preserve">
          <source>This function writes the passed text and &lt;code&gt;Option&lt;/code&gt; into an output range in the manner described in the documentation of function &lt;code&gt;defaultGetoptPrinter&lt;/code&gt;.</source>
          <target state="translated">该函数以函数 &lt;code&gt;defaultGetoptPrinter&lt;/code&gt; 的文档中描述的方式将传递的文本和 &lt;code&gt;Option&lt;/code&gt; 写入输出范围。</target>
        </trans-unit>
        <trans-unit id="055b5453fa39d56b283008b9edaf05dd119fac56" translate="yes" xml:space="preserve">
          <source>This functions is equivalent to &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt;.</source>
          <target state="translated">此函数等效于 &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3de8acad7b682bb3660ea91b4edba8b390f1f531" translate="yes" xml:space="preserve">
          <source>This functions is used at runtime to determine if a &lt;code&gt;LogLevel&lt;/code&gt; is active. The same previously defined version statements are used to disable certain levels. Again the version statements are associated with a compile unit and can therefore not disable logging in other compile units. pure bool isLoggingEnabled()(LogLevel ll) @safe nothrow @nogc</source>
          <target state="translated">该函数在运行时用于确定 &lt;code&gt;LogLevel&lt;/code&gt; 是否处于活动状态。相同的先前定义的版本语句用于禁用某些级别。同样，版本语句与编译单元相关联，因此不能禁用其他编译单元中的日志记录。纯布尔isLoggingEnabled（）（LogLevel ll）@safe nothrow @nogc</target>
        </trans-unit>
        <trans-unit id="9f907426d2ef951648d87f5cd993e54c9a2f733d" translate="yes" xml:space="preserve">
          <source>This functions returns a trace handler, allowing to inspect the current stack trace.</source>
          <target state="translated">该函数返回一个跟踪处理程序,允许检查当前堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="84eb391f18a28223816cf561bff30465c4000886" translate="yes" xml:space="preserve">
          <source>This gets replaced by the number of local bytes in the local stack frame. It is most handy when the &lt;code&gt;naked&lt;/code&gt; is invoked and a custom stack frame is programmed.</source>
          <target state="translated">它被替换为本地堆栈帧中的本地字节数。当它是最得心应手的 &lt;code&gt;naked&lt;/code&gt; 调用和一个自定义堆栈帧编程。</target>
        </trans-unit>
        <trans-unit id="e8e4bebddf13552333bc85ebe7b11a4e7247c831" translate="yes" xml:space="preserve">
          <source>This handle is used to specify the process in OS-specific APIs. On POSIX, this function returns a &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; with the same value as &lt;a href=&quot;#Pid.processID&quot;&gt;&lt;code&gt;Pid.processID&lt;/code&gt;&lt;/a&gt;, while on Windows it returns a &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt;.</source>
          <target state="translated">该句柄用于指定特定于OS的API中的过程。在POSIX上，此函数返回 &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; ，其值与&lt;a href=&quot;#Pid.processID&quot;&gt; &lt;code&gt;Pid.processID&lt;/code&gt; &lt;/a&gt;相同，而在Windows上，它返回 &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33c852a0522cad2c2b4928299e850452d227ef5f" translate="yes" xml:space="preserve">
          <source>This handler overrides any legacy module unit tester set by the moduleUnitTester property.</source>
          <target state="translated">该处理程序会覆盖任何由模块UnitTester属性设置的传统模块单元测试器。</target>
        </trans-unit>
        <trans-unit id="c35e1bd5e0e6a04521fa5520ade57041fbf6240b" translate="yes" xml:space="preserve">
          <source>This hasher is compatible with the &lt;code&gt;Digest&lt;/code&gt; API:</source>
          <target state="translated">该哈希器与 &lt;code&gt;Digest&lt;/code&gt; API 兼容：</target>
        </trans-unit>
        <trans-unit id="3993e1a9197061dc1bf704959d048cb51b8578f3" translate="yes" xml:space="preserve">
          <source>This implements a standard critical section.</source>
          <target state="translated">这实现了一个标准的关键部分。</target>
        </trans-unit>
        <trans-unit id="e2f62226ce4de7b0f3cba225bd19bb063907d826" translate="yes" xml:space="preserve">
          <source>This initialization is done before any constructors are called.</source>
          <target state="translated">这个初始化是在调用任何构造函数之前完成的。</target>
        </trans-unit>
        <trans-unit id="2e9f56ef2bea3abd9b78b212cb634ac700d5b66a" translate="yes" xml:space="preserve">
          <source>This instance needs an identifier for name mangling purposes. Create one by taking the template declaration name and adding the type signature for it.</source>
          <target state="translated">这个实例需要一个标识符,以便于名称混杂。通过取模板声明名并为其添加类型签名来创建一个。</target>
        </trans-unit>
        <trans-unit id="912f09d79c05dc09ba32bc17497f7cccd43f92de" translate="yes" xml:space="preserve">
          <source>This is a D version 2 compiler</source>
          <target state="translated">这是一个D版2的编译器</target>
        </trans-unit>
        <trans-unit id="e5c32108063ea48a95f2ccade44899e02af1ccaa" translate="yes" xml:space="preserve">
          <source>This is a best-effort implementation of &lt;code&gt;length&lt;/code&gt; for any kind of range.</source>
          <target state="translated">对于任何类型的范围，这都是尽力而为的 &lt;code&gt;length&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="05c823d62e8c286f879871b1e12c6f9007211866" translate="yes" xml:space="preserve">
          <source>This is a compiler magic function - it doesn't behave like regular D functions.</source>
          <target state="translated">这是一个编译器魔法函数--它的行为不像普通的D函数。</target>
        </trans-unit>
        <trans-unit id="b09964b15b26c39a9ce61274e2f775777d6323e9" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC32 implementation.</source>
          <target state="translated">这是使用CRC32实现的&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt;的方便别名。</target>
        </trans-unit>
        <trans-unit id="512068cf15e63810e132140770d7648100089a8e" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ECMA implementation.</source>
          <target state="translated">这是一个方便的别名&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt;使用CRC64-ECMA实现。</target>
        </trans-unit>
        <trans-unit id="b3d4ec4ec88de63e322958e6b0d979a689b11d53" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the MD5 implementation.</source>
          <target state="translated">这是使用MD5实现的&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt;的方便别名。</target>
        </trans-unit>
        <trans-unit id="bd636dcefd273f520355be9a0afa2783ad66dbef" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the RIPEMD160 implementation.</source>
          <target state="translated">这是一个方便的别名&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt;使用RIPEMD160实现。</target>
        </trans-unit>
        <trans-unit id="29b73ef07a42490f2884582abd8be259990a85c2" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ISO implementation.</source>
          <target state="translated">这是一个方便的别名&lt;a href=&quot;std_digest_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest.digest&lt;/code&gt; &lt;/a&gt;使用CRC64-ISO实现。</target>
        </trans-unit>
        <trans-unit id="69463742eb10b8885c85b63b60e71b70ccfdbb6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function similar to &lt;a href=&quot;#digest&quot;&gt;&lt;code&gt;digest&lt;/code&gt;&lt;/a&gt;, but it returns the string representation of the hash. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="translated">这是一个类似于&lt;a href=&quot;#digest&quot;&gt; &lt;code&gt;digest&lt;/code&gt; &lt;/a&gt;的便利函数，但是它返回哈希的字符串表示形式。每个通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;测试的摘要都可以与此功能一起使用。</target>
        </trans-unit>
        <trans-unit id="d797c320e5f08f4ede0b091329f09c40bcd4c23b" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate a hash using the template API. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="translated">这是使用模板API计算哈希值的便捷功能。每个通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;测试的摘要都可以与此功能一起使用。</target>
        </trans-unit>
        <trans-unit id="c5b7feb30ef91eb966259d553831f946792e76d5" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate the hash of a value using the OOP API.</source>
          <target state="translated">这是一个使用OOP API计算一个值的哈希值的方便函数。</target>
        </trans-unit>
        <trans-unit id="3fbe8b98c7fb42d7985a89e6cebbca4b22e50702" translate="yes" xml:space="preserve">
          <source>This is a convenience function which returns an initialized digest, so it's not necessary to call start manually.</source>
          <target state="translated">这是一个方便的函数,它返回一个初始化的摘要,所以没有必要手动调用start。</target>
        </trans-unit>
        <trans-unit id="b07fdbfd8e90c114315c0c22212b8f6590899cf6" translate="yes" xml:space="preserve">
          <source>This is a dmd specific setting.</source>
          <target state="translated">这是一个dmd特定的设置。</target>
        </trans-unit>
        <trans-unit id="87a04bae60dfddd5f321bbf38e370a4d6f98d8c6" translate="yes" xml:space="preserve">
          <source>This is a full list of Unicode properties accessible through &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; with specific helpers per category nested within. Consult the &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;CLDR utility&lt;/a&gt; when in doubt about the contents of a particular set.</source>
          <target state="translated">这是Unicode属性的完整列表，可通过&lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt;访问，其中嵌套了每个类别的特定帮助器。如果对特定集合的内容有疑问，请咨询&lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;CLDR实用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c8f19a42bba7727a8ce8284636a08320c4e65f1" translate="yes" xml:space="preserve">
          <source>This is a general replacement tool that construct a new string by replacing matches of pattern &lt;code&gt;re&lt;/code&gt; in the &lt;code&gt;input&lt;/code&gt;. Unlike the other overload there is no format string instead captures are passed to to a user-defined functor &lt;code&gt;fun&lt;/code&gt; that returns a new string to use as replacement.</source>
          <target state="translated">这是一般的替换刀具通过取代模式的匹配构造一个新的字符串 &lt;code&gt;re&lt;/code&gt; 在 &lt;code&gt;input&lt;/code&gt; 。与其他重载不同，没有格式字符串，而是将捕获内容传递到用户定义的functor &lt;code&gt;fun&lt;/code&gt; ，该functor 返回一个新字符串以用作替换。</target>
        </trans-unit>
        <trans-unit id="48a52f467fdd89c347f6d4a8f50f81ff656d5562" translate="yes" xml:space="preserve">
          <source>This is a great way to implement simple circular buffers.</source>
          <target state="translated">这是实现简单循环缓冲的好方法。</target>
        </trans-unit>
        <trans-unit id="02adbf08da9a4c46841118c88fd0ba75eb2c489f" translate="yes" xml:space="preserve">
          <source>This is a less strict parser compared to the parser used in the UUID constructor. It enforces the following rules:</source>
          <target state="translated">与UUID构造函数中使用的解析器相比,这是一个不太严格的解析器。它执行以下规则。</target>
        </trans-unit>
        <trans-unit id="ecac55bd6998bb669ca8527fad92e747f31aecf4" translate="yes" xml:space="preserve">
          <source>This is a low-level messaging API upon which more structured or restrictive APIs may be built. The general idea is that every messageable entity is represented by a common handle type called a Tid, which allows messages to be sent to logical threads that are executing in both the current process and in external processes using the same interface. This is an important aspect of scalability because it allows the components of a program to be spread across available resources with few to no changes to the actual implementation.</source>
          <target state="translated">这是一个低级的消息传递API,可以在此基础上建立更多结构化或限制性的API。一般的想法是,每个可消息实体都由一个称为Tid的通用句柄类型来表示,它允许将消息发送到使用相同接口在当前进程和外部进程中执行的逻辑线程。这是可扩展性的一个重要方面,因为它允许程序的组件分布在可用的资源上,而对实际实现几乎不做任何改变。</target>
        </trans-unit>
        <trans-unit id="c99b5a617247c271e1cb66e28acf2ff8127a04e2" translate="yes" xml:space="preserve">
          <source>This is a magic return code for the write callback that, when returned, will signal libcurl to pause receiving on the current transfer.</source>
          <target state="translated">这是写回调的一个神奇的返回码,返回后,会给libcurl发出信号,让它暂停接收当前的传输。</target>
        </trans-unit>
        <trans-unit id="8a547f3bc057670af878d63b618663f30d9c888a" translate="yes" xml:space="preserve">
          <source>This is a number that uniquely identifies the process on the operating system, for at least as long as the process is running. Once &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; has been called on the &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt;, this method will return an invalid (negative) process ID.</source>
          <target state="translated">这是一个数字，至少在进程运行期间，它唯一地标识操作系统上的进程。一旦在&lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt;上调用了&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;，此方法将返回一个无效的（负）进程ID。</target>
        </trans-unit>
        <trans-unit id="2ba143cb17d230b35dd3e77b4d46b42bf59cd667" translate="yes" xml:space="preserve">
          <source>This is a port of &lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt; boost.uuid&lt;/a&gt; from the Boost project with some minor additions and API changes for a more D-like API.</source>
          <target state="translated">这是Boost项目中的&lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt;boost.uuid&lt;/a&gt;端口，其中进行了一些小的添加，并对API进行了更改，以实现更像D的API。</target>
        </trans-unit>
        <trans-unit id="3639c2b895158186c93cfc3d4a942fd3a8a4bcfc" translate="yes" xml:space="preserve">
          <source>This is a public domain version of qsort.d. All it does is call C's qsort().</source>
          <target state="translated">这是qsort.d的公有领域版本,它所做的只是调用C的qsort()。</target>
        </trans-unit>
        <trans-unit id="2506c523fc3fb4d236735f105644ec414dfd3b6c" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will const signal libcurl to pause sending data on the current transfer.</source>
          <target state="translated">这是读取回调的返回代码,返回后,将 const 信号 libcurl 暂停发送当前传输的数据。</target>
        </trans-unit>
        <trans-unit id="a5f3cb2b8bae68d0d790adf6bf0c62982e12ad3f" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will signal libcurl to immediately abort the current transfer.</source>
          <target state="translated">这是读取回调的返回代码,返回后,将向libcurl发出信号,立即中止当前的传输。</target>
        </trans-unit>
        <trans-unit id="0df6a7dff27cb6ce3775bea09f58211a06e0fa4d" translate="yes" xml:space="preserve">
          <source>This is a shell around a back end symbol</source>
          <target state="translated">这是一个围绕后端符号的外壳</target>
        </trans-unit>
        <trans-unit id="dc048af9db69350bf7d515c9bc813c09c6660d30" translate="yes" xml:space="preserve">
          <source>This is a shell containing a TraitsExp that can be either resolved to a type or to a symbol.</source>
          <target state="translated">这是一个包含TraitsExp的shell,它可以被解析为一个类型或一个符号。</target>
        </trans-unit>
        <trans-unit id="5ad2832faed57297a9408dcd8abe79e66f2c28ae" translate="yes" xml:space="preserve">
          <source>This is a simplified declaration of the &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt;&lt;code&gt;NSString&lt;/code&gt;&lt;/a&gt; class. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt; method allocates an instance of the class. The &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt;&lt;code&gt;initWithUTF8String:&lt;/code&gt;&lt;/a&gt; method will be used to convert a C string in UTF-8 to an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; method is used to release an deallocate the string. Since D doesn't support &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt; it's needed to manually release Objective-C instances.</source>
          <target state="translated">这是&lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt; &lt;code&gt;NSString&lt;/code&gt; &lt;/a&gt;类的简化声明。该&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt;方法分配的类的一个实例。该&lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt; &lt;code&gt;initWithUTF8String:&lt;/code&gt; &lt;/a&gt;方法将用于C字符串以UTF-8转换为一个Objective-C串， &lt;code&gt;NSString&lt;/code&gt; 。该&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt;方法用于释放DEALLOCATE的字符串。由于D不支持&lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC，&lt;/a&gt;因此需要手动释放Objective-C实例。</target>
        </trans-unit>
        <trans-unit id="9b885a66018a314237093b8fb5cb095cdbb3b8c2" translate="yes" xml:space="preserve">
          <source>This is a special compiler recognized attribute, it has several requirements, which all will be enforced by the compiler:</source>
          <target state="translated">这是一个特殊的编译器认可的属性,它有几个要求,都会被编译器执行。</target>
        </trans-unit>
        <trans-unit id="ae39fd6f553ae7cbf7dc06cf4c01bdb3470af4ef" translate="yes" xml:space="preserve">
          <source>This is a speed optimization, a good guess at the maximum size of the resulting buffer will improve performance by eliminating reallocations and copying.</source>
          <target state="translated">这是一种速度优化,猜测好结果缓冲区的最大大小,可以通过消除重分配和复制来提高性能。</target>
        </trans-unit>
        <trans-unit id="35d1d3de86a677e769796c4bc667e5033e36cade" translate="yes" xml:space="preserve">
          <source>This is a strict parser. It only accepts the pattern above. It doesn't support any leading or trailing characters. It only accepts characters used for hex numbers and the string must have hyphens exactly like above.</source>
          <target state="translated">这是一个严格的解析器。它只接受上述模式。它不支持任何前导符或尾部字符。它只接受用于十六进制数字的字符,并且字符串必须有与上面完全相同的连字符。</target>
        </trans-unit>
        <trans-unit id="5ae5fdcefc9284313dd41ba3b8a3e36e9a73a45c" translate="yes" xml:space="preserve">
          <source>This is a subclass of ElementParser. Most of the useful functions are documented there.</source>
          <target state="translated">这是 ElementParser 的一个子类。大多数有用的功能都在这里被记录下来。</target>
        </trans-unit>
        <trans-unit id="f2e662785d1d5993dfe200ed0cd32d243953366c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic algorithms that implement set operations.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含实现集合操作的通用算法。</target>
        </trans-unit>
        <trans-unit id="e1b41f495bf4c79d2ddcbf0100179c8d893eed73" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic comparison algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用比较算法。</target>
        </trans-unit>
        <trans-unit id="7b5ed9bdf36ce4d3eb2f4fa31e710341bfe1a347" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic iteration algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用迭代算法。</target>
        </trans-unit>
        <trans-unit id="a1ca49a48babc2bf7a88dc2f9edada29da0b74aa" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic mutation algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用的变异算法。</target>
        </trans-unit>
        <trans-unit id="9256c3179b28cb98f2ccafcbf01fa1114c7ffabd" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic searching algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用搜索算法。</target>
        </trans-unit>
        <trans-unit id="d621cd2fb3907321fd3307426e0197b19ae1cd6c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic sorting algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用的排序算法。</target>
        </trans-unit>
        <trans-unit id="1a6a835a510bef24f9a4d09ad766e6b4789c5a10" translate="yes" xml:space="preserve">
          <source>This is accessible via the ClassData, but since it is frequently needed directly (like for rtti comparisons), make it directly accessible.</source>
          <target state="translated">这个是可以通过ClassData访问的,但由于经常直接需要(比如rtti比较),所以要让它直接访问。</target>
        </trans-unit>
        <trans-unit id="7c814acc56ca032045c3a40a509dc625dc91c4d4" translate="yes" xml:space="preserve">
          <source>This is actually what &lt;a href=&quot;#byLine&quot;&gt;&lt;code&gt;byLine&lt;/code&gt;&lt;/a&gt; does internally, so its usage is recommended if you want to process a complete file.</source>
          <target state="translated">这实际上是&lt;a href=&quot;#byLine&quot;&gt; &lt;code&gt;byLine&lt;/code&gt; &lt;/a&gt;在内部执行的操作，因此，如果要处理完整的文件，建议使用它。</target>
        </trans-unit>
        <trans-unit id="43e213b7894a106692ed41475e921810e2f2ef96" translate="yes" xml:space="preserve">
          <source>This is an</source>
          <target state="translated">这是一个</target>
        </trans-unit>
        <trans-unit id="d562af56401d0e00dc584df85564d362806b263a" translate="yes" xml:space="preserve">
          <source>This is an advanced type manipulation necessary e.g. for replacing the placeholder type &lt;code&gt;This&lt;/code&gt; in &lt;a href=&quot;std_variant#Algebraic&quot;&gt;&lt;code&gt;std.variant.Algebraic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一种先进的类型的操作需要例如用于替换占位符类型 &lt;code&gt;This&lt;/code&gt; 在&lt;a href=&quot;std_variant#Algebraic&quot;&gt; &lt;code&gt;std.variant.Algebraic&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3325f1bf2305c77a1849c9f8a9c2843663095726" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="991e65c6e6968487ccb7bb69ca7320b94e4ca93f" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="b4ce5ff6ecd05c751170313d80d40096c853a878" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="d9558990a88eaad4533f53210d24e334b473686d" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="57c783fecd68424a831ee827a2afa820a6eb2e72" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="c0181596da443b5ba169ba47d5e2dd20f026611e" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="7d3c5e22d15f79f627e001b482acc6838518ff93" translate="yes" xml:space="preserve">
          <source>This is an example Scheduler that mirrors the default scheduling behavior of creating one kernel thread per call to spawn. It is fully functional and may be instantiated and used, but is not a necessary part of the default functioning of this module.</source>
          <target state="translated">这是一个Scheduler的例子,它反映了默认的调度行为,即每次调用 spawn时创建一个内核线程。它功能齐全,可以被实例化和使用,但不是这个模块默认功能的必要部分。</target>
        </trans-unit>
        <trans-unit id="6ff549d63c3ff212a46a7da946a73dffb4f080d9" translate="yes" xml:space="preserve">
          <source>This is an example scheduler that creates a new Fiber per call to spawn and multiplexes the execution of all fibers within the main thread.</source>
          <target state="translated">这是一个调度器的例子,每次调用 spawn 都会创建一个新的光纤,并在主线程内复用执行所有光纤。</target>
        </trans-unit>
        <trans-unit id="9b07c47f7921db818ae08b3487fd61d30861252d" translate="yes" xml:space="preserve">
          <source>This is an infinite range, so it is never empty.</source>
          <target state="translated">这是一个无限的范围,所以它永远不会空。</target>
        </trans-unit>
        <trans-unit id="12f3a1e35d9244804e6a51ca5a2db8f208c379f7" translate="yes" xml:space="preserve">
          <source>This is an interface to the libcurl library.</source>
          <target state="translated">这是对libcurl库的一个接口。</target>
        </trans-unit>
        <trans-unit id="0ecf41c17b4ddd40e8365245329f080912127dd4" translate="yes" xml:space="preserve">
          <source>This is an overload of &lt;code&gt;translate&lt;/code&gt; which takes an existing buffer to write the contents to.</source>
          <target state="translated">这是 &lt;code&gt;translate&lt;/code&gt; 的重载，它需要一个现有的缓冲区将内容写入其中。</target>
        </trans-unit>
        <trans-unit id="1ecb65db27289cae51fc17448747e90751d9751d" translate="yes" xml:space="preserve">
          <source>This is by design. During construction the &lt;code&gt;Variant&lt;/code&gt; needs static type information about the type being held, so as to store a pointer to function for fast retrieval.</source>
          <target state="translated">这是设计使然。在构造期间， &lt;code&gt;Variant&lt;/code&gt; 需要有关所保存类型的静态类型信息，以便存储指向函数的指针以进行快速检索。</target>
        </trans-unit>
        <trans-unit id="60ab54d413619310ad332327e4504502f2306f23" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.compare(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="translated">这被TypeInfo.compare(p1,p2)调用。如果该结构不支持const对象比较,它将在运行时抛出 &quot;not implemented &quot;错误。</target>
        </trans-unit>
        <trans-unit id="c89ac618e64974e5137c2fd8360adb505768057f" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.equals(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="translated">这被TypeInfo.equals(p1,p2)调用。如果该结构不支持const对象比较,它将在运行时抛出 &quot;not implemented &quot;错误。</target>
        </trans-unit>
        <trans-unit id="165808d159b6f286bb50d6195dc7d22725a89812" translate="yes" xml:space="preserve">
          <source>This is called for a delete statement where the value being deleted is a pointer to a struct with a destructor but doesn't have an overloaded delete operator.</source>
          <target state="translated">当被删除的值是一个指向有析构器的结构的指针,但没有重载删除操作符时,就会调用这个语句。</target>
        </trans-unit>
        <trans-unit id="252a57647acdf0a645523b6daf74e75444387572" translate="yes" xml:space="preserve">
          <source>This is designed for efficient memory reuse with some value-semantics structs, eg. &lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt;&lt;code&gt;std.bigint.BigInt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是为具有某些价值语义结构（例如）的有效内存重用而设计的。&lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt; &lt;code&gt;std.bigint.BigInt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06ae0b36fee3b8fd0ea0e39cba211a57066e0aad" translate="yes" xml:space="preserve">
          <source>This is done by matching the C compiler's data types, layouts, and function call/return sequences.</source>
          <target state="translated">这是通过匹配C编译器的数据类型、布局和函数调用/返回序列来实现的。</target>
        </trans-unit>
        <trans-unit id="11029a896ea23a30143fb56e21fe3c178f1a4a41" translate="yes" xml:space="preserve">
          <source>This is especially useful for adding/removing attributes to/from types in generic code, where the actual type name cannot be spelt out.</source>
          <target state="translated">这对于在通用代码中添加/删除属性到/从类型中添加/删除属性特别有用,因为实际的类型名称无法拼写出来。</target>
        </trans-unit>
        <trans-unit id="b13063fd35605a68f66f22b807caf15b21927ce2" translate="yes" xml:space="preserve">
          <source>This is especially useful when used with inheritance. For example, you might want to implement a final base method which returns a derived class type. Typically you would return a base type, but this won't allow you to call or access derived properties of the type:</source>
          <target state="translated">这在与继承一起使用时特别有用。例如,你可能想实现一个返回派生类类型的final base方法。通常情况下,你会返回一个基类型,但这将不允许你调用或访问该类型的派生属性。</target>
        </trans-unit>
        <trans-unit id="33a5219de6733b72248cb459ae3c108de0b27b6d" translate="yes" xml:space="preserve">
          <source>This is for cases where you need a value representing the OS at runtime. If you're doing something which should compile differently on different OSes, then please use &lt;code&gt;version (Windows)&lt;/code&gt;, &lt;code&gt;version (linux)&lt;/code&gt;, etc.</source>
          <target state="translated">这是在需要运行时表示操作系统的值的情况下使用的。如果您要执行的操作应在不同的操作系统上进行不同的编译，请使用 &lt;code&gt;version (Windows)&lt;/code&gt; ， &lt;code&gt;version (linux)&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="9085623d5748a41a60ced02ac9ea7374a5eb5654" translate="yes" xml:space="preserve">
          <source>This is generally fine, and by its very nature, converting from system ticks to any type of seconds (hnsecs, nsecs, etc.) will introduce rounding errors, but if code needs to avoid any of the small rounding errors introduced by conversion, then it needs to use MonoTime's &lt;code&gt;ticks&lt;/code&gt; property and keep all calculations in ticks rather than using &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常这很好，就其本质而言，从系统刻度转换为任何类型的秒数（hnsecs，nsecs等）都会引入舍入错误，但是如果代码需要避免转换引起的任何小舍入错误，则它需要使用MonoTime的 &lt;code&gt;ticks&lt;/code&gt; 属性并将所有计算保持在ticks中，而不是使用&lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88fe60e9205a837e1c893e74b0d472fd048224ed" translate="yes" xml:space="preserve">
          <source>This is generally the fastest method to convert a floating-point number to an integer. Note that the results from this function depend on the rounding mode, if the fractional part of x is exactly 0.5. If using the default rounding mode (ties round to even integers) lrint(4.5) == 4, lrint(5.5)==6.</source>
          <target state="translated">这通常是将浮点数转换为整数的最快方法。注意,这个函数的结果取决于四舍五入模式,如果x的小数部分正好是0.5。如果使用默认的四舍五入模式(四舍五入为偶数),则lrint(4.5)==4,lrint(5.5)==6。</target>
        </trans-unit>
        <trans-unit id="f53ca66b2923ca36935e7ce2bb35685de87690d9" translate="yes" xml:space="preserve">
          <source>This is intended for cases where you need to deal with endianness at runtime. If you're doing something which should compile differently depending on whether you're compiling on a big endian or little endian machine, then please use &lt;code&gt;version (BigEndian)&lt;/code&gt; and &lt;code&gt;version (LittleEndian)&lt;/code&gt;.</source>
          <target state="translated">这适用于需要在运行时处理字节序的情况。如果您要执行的操作根据在大端或小端机器上进行编译而不同，请使用 &lt;code&gt;version (BigEndian)&lt;/code&gt; 和 &lt;code&gt;version (LittleEndian)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b3b92fb9499542d848207397387795d022c0de6" translate="yes" xml:space="preserve">
          <source>This is intended to be called at the start of the program to yield all scheduling to the active Scheduler instance. This is necessary for schedulers that explicitly dispatch threads rather than simply relying on the operating system to do so, and so start should always be called within main() to begin normal program execution.</source>
          <target state="translated">这个函数的目的是在程序开始时被调用,以便将所有的调度工作交给活动的Scheduler实例。这对于显式调度线程的调度器来说是必要的,而不是简单地依靠操作系统来调度线程,因此start应该总是在main()中被调用,以开始正常的程序执行。</target>
        </trans-unit>
        <trans-unit id="168edfe34c09b55f1deed4c37990e3c71a1ca3c1" translate="yes" xml:space="preserve">
          <source>This is more efficient than testing each bit in a sparsely populated bit set. Note that the first bit in the bit set would be bit 0.</source>
          <target state="translated">这比测试一个人口稀少的位集中的每个位更有效率。注意,位集中的第一个位将是位0。</target>
        </trans-unit>
        <trans-unit id="8fcde002524d5c331c8548b6dca27a95656e7bce" translate="yes" xml:space="preserve">
          <source>This is most handy when the array indices are given by enums:</source>
          <target state="translated">当数组索引是由枚举给出时,这是最方便的。</target>
        </trans-unit>
        <trans-unit id="c31ac80c96aa26f46ec6ee9192e9e74924da45e0" translate="yes" xml:space="preserve">
          <source>This is needed because AssignExp rewrites CommaExp, hence it needs to trigger the deprecation.</source>
          <target state="translated">这是因为AssignExp重写了CommaExp,因此需要触发弃用。</target>
        </trans-unit>
        <trans-unit id="e7738cc186f07169467da57ea636fc910ff8ff41" translate="yes" xml:space="preserve">
          <source>This is not recursive; it will not search for symbols within symbols such as nested structs or unions.</source>
          <target state="translated">这不是递归的,它不会在符号中搜索符号,如嵌套结构或联合。</target>
        </trans-unit>
        <trans-unit id="79018f9004b6204ff482d1449a187f60021b161a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;takeWhile&lt;/code&gt; in other languages.</source>
          <target state="translated">这与其他语言中的 &lt;code&gt;takeWhile&lt;/code&gt; 类似。</target>
        </trans-unit>
        <trans-unit id="da1506be46b53535dcad92fb4d88063b66606cfa" translate="yes" xml:space="preserve">
          <source>This is so we can slice a TypeTuple</source>
          <target state="translated">这样,我们就可以将一个TypeTuple分片</target>
        </trans-unit>
        <trans-unit id="1ea183190e1a8d4a5c65894e3d7aa69b999c8015" translate="yes" xml:space="preserve">
          <source>This is the D way, and is used consistently in the D runtime library and examples.</source>
          <target state="translated">这是D的方式,在D的运行库和例子中是一致使用的。</target>
        </trans-unit>
        <trans-unit id="b87f9cb349c407cc69c74e007c81d9397e42baeb" translate="yes" xml:space="preserve">
          <source>This is the FILE * or void * the regular output should be written to.</source>
          <target state="translated">这是常规输出应该写入的FILE *或void *。</target>
        </trans-unit>
        <trans-unit id="e03f57cd49f977fe295ada31586860acb7b55e0d" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the socket callback</source>
          <target state="translated">这是传递给套接字回调的参数。</target>
        </trans-unit>
        <trans-unit id="be469fab3c85ca74b768977fadfadf33a82814bf" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the timer callback</source>
          <target state="translated">这是传递给定时器回调的参数。</target>
        </trans-unit>
        <trans-unit id="47d1ba0ce023e632a01bb533e80836298674478a" translate="yes" xml:space="preserve">
          <source>This is the date and time when the full source package was created. The timestamp is not stored in git, as the timestamp is properly set in the tarballs by the maketgz script.</source>
          <target state="translated">这是创建完整源代码包的日期和时间。时间戳不会存储在 git 中,因为时间戳是由 maketgz 脚本在 tarballs 中正确设置的。</target>
        </trans-unit>
        <trans-unit id="bcb4b4d07cd24ad03f4d73cf2a834d60bf057434" translate="yes" xml:space="preserve">
          <source>This is the global package copyright</source>
          <target state="translated">这就是全球包装的版权</target>
        </trans-unit>
        <trans-unit id="00bd1884cd8f1f3700cdc8b2d576c08ba85d63de" translate="yes" xml:space="preserve">
          <source>This is the length in bytes of the hash value which is returned by &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;. It's also the required size of a buffer passed to &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是由&lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt;返回的哈希值的字节长度。这也是传递给&lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt;所需的缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="629c1787bf8dac085ebe6f000afbc79766608202" translate="yes" xml:space="preserve">
          <source>This is the most specific allocation policy: the memory being allocated is thread local, has no indirections at all, and will not be reallocated. Examples of types fitting this description: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">这是最具体的分配策略：分配的内存是线程本地的，根本没有间接寻址，也不会重新分配。适合此描述的类型的示例： &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;Tuple!(int, long)&lt;/code&gt; ，但不包含包含间接 &lt;code&gt;Tuple!(int, string)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d53bdfa25144b5efcd12699a648c0b943568037" translate="yes" xml:space="preserve">
          <source>This is the numeric version of the libcurl version number, meant for easier parsing and comparions by programs. The LIBCURL_VERSION_NUM define will always follow this syntax:</source>
          <target state="translated">这是libcurl版本号的数字版本,目的是为了方便程序的解析和比较。LIBCURL_VERSION_NUM定义将始终遵循这个语法。</target>
        </trans-unit>
        <trans-unit id="f516424ebe0c21d1c77be3938d4dc4c573211582" translate="yes" xml:space="preserve">
          <source>This is the old ctor sorting algorithm that does not find all cycles.</source>
          <target state="translated">这是老式的ctor排序算法,不能找到所有的循环。</target>
        </trans-unit>
        <trans-unit id="6e92c9060948634b2691b12a3f666bd6c1016991" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;getTimes&lt;/code&gt; except that it also gives you the file creation time - which isn't possible on Posix systems.</source>
          <target state="translated">这与 &lt;code&gt;getTimes&lt;/code&gt; 相同，除了它还为您提供文件创建时间-这在Posix系统上是不可能的。</target>
        </trans-unit>
        <trans-unit id="d8bc2540cd8cdfdea3a8a5b982374faccf0dd6c1" translate="yes" xml:space="preserve">
          <source>This is the socket callback function pointer</source>
          <target state="translated">这是套接字回调函数的指针。</target>
        </trans-unit>
        <trans-unit id="61598e1f6a7ec5d30e11d3aead7284998d0c4762" translate="yes" xml:space="preserve">
          <source>This is the timer callback function pointer</source>
          <target state="translated">这是定时器的回调函数指针。</target>
        </trans-unit>
        <trans-unit id="c718912a86bcbf8011f76f57098fa90f1498a69a" translate="yes" xml:space="preserve">
          <source>This is the version number of the libcurl package from which this header file origins:</source>
          <target state="translated">这是libcurl包的版本号,这个头文件来源于此。</target>
        </trans-unit>
        <trans-unit id="a98c5dbd73e5200bae0821dc0199531a02a94575" translate="yes" xml:space="preserve">
          <source>This is to support compiling expressions within the context of a function.</source>
          <target state="translated">这是为了支持在函数的上下文中编译表达式。</target>
        </trans-unit>
        <trans-unit id="1f258032a2e34908ad83c367bba4f67f9bf0d8fc" translate="yes" xml:space="preserve">
          <source>This is true even if the</source>
          <target state="translated">即使在</target>
        </trans-unit>
        <trans-unit id="915f3d07336b61352341e4f59f1cdec1c322cabb" translate="yes" xml:space="preserve">
          <source>This is useful for:</source>
          <target state="translated">这对于:</target>
        </trans-unit>
        <trans-unit id="fcc8360025ee8f837157968edcf3a60c6d678ceb" translate="yes" xml:space="preserve">
          <source>This is useful in cases where the user is expected to type in one of a known set of strings, and the program will helpfully auto-complete the string once sufficient characters have been entered that uniquely identify it.</source>
          <target state="translated">当用户需要输入一组已知的字符串时,这很有用,一旦输入了足够的字符,程序就会帮助用户自动完成该字符串,以唯一地识别它。</target>
        </trans-unit>
        <trans-unit id="e4e34d37acfaa90ff5c5cdca9c0444e2392c7b7c" translate="yes" xml:space="preserve">
          <source>This is useful when dealing with memory-mapped I/O (MMIO) where a store can have an effect other than just writing a value, or where sequential loads with no intervening stores can retrieve different values from the same location due to external stores to the location.</source>
          <target state="translated">这在处理内存映射I/O(MMIO)时很有用,在这种情况下,一个存储除了写一个值之外,还可以产生其他的效果,或者在没有中间存储的顺序加载时,由于外部存储到该位置,可以从同一位置检索不同的值。</target>
        </trans-unit>
        <trans-unit id="130a13f443489357f62d68edb3556823f7774c09" translate="yes" xml:space="preserve">
          <source>This is usually the default diagnostic reporter.</source>
          <target state="translated">这通常是默认的诊断报告器。</target>
        </trans-unit>
        <trans-unit id="6b8bd52c73d65472e04e60bf842e33bc426a473d" translate="yes" xml:space="preserve">
          <source>This is very useful as a template constraint (see examples)</source>
          <target state="translated">这作为模板约束是非常有用的(见示例)</target>
        </trans-unit>
        <trans-unit id="c9c38689ba29d74fc53f435aaf473866b312b836" translate="yes" xml:space="preserve">
          <source>This is, however, NOT equivalent to POSIX' &lt;code&gt;execv*&lt;/code&gt;. For one thing, the executed program is started as a separate process, with all this entails. Secondly, in a multithreaded program, other threads will continue to do work while the current thread is waiting for the child process to complete.  A better option may sometimes be to terminate the current program immediately after spawning the child process. This is the behaviour exhibited by the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt;&lt;code&gt;__exec&lt;/code&gt;&lt;/a&gt; functions in Microsoft's C runtime library, and it is how D's now-deprecated Windows &lt;code&gt;execv*&lt;/code&gt; functions work. Example:</source>
          <target state="translated">但是，这不等同于POSIX的 &lt;code&gt;execv*&lt;/code&gt; 。一方面，执行的程序是作为一个单独的过程启动的，因此需要这样做。其次，在多线程程序中，当当前线程正在等待子进程完成时，其他线程将继续工作。有时更好的选择可能是在生成子进程之后立即终止当前程序。这是Microsoft C运行时库中&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt; &lt;code&gt;__exec&lt;/code&gt; &lt;/a&gt;函数所表现的行为，这也是D现在不推荐使用的Windows &lt;code&gt;execv*&lt;/code&gt; 函数的工作方式。例：</target>
        </trans-unit>
        <trans-unit id="86cd963d96c400e127b41fb5e1c683fd1645332a" translate="yes" xml:space="preserve">
          <source>This level is used to display information about the program.</source>
          <target state="translated">该级别用于显示有关程序的信息。</target>
        </trans-unit>
        <trans-unit id="7bd1213d23d1dea834726c3d604226e3f0bd7985" translate="yes" xml:space="preserve">
          <source>This library provides a mechanism whereby other modules may add &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for any other encoding.</source>
          <target state="translated">该库提供了一种机制，通过该机制，其他模块可以为任何其他编码添加&lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="a3c0ccf8cf8329e21b5b2e67a76439bedab69306" translate="yes" xml:space="preserve">
          <source>This library provides full Level 1 support* according to &lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18&lt;/a&gt;. Specifically:</source>
          <target state="translated">根据&lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18，&lt;/a&gt;该库提供完整的1级支持* 。特别：</target>
        </trans-unit>
        <trans-unit id="4904626a5781bdaca7da93c6ed4103629917781b" translate="yes" xml:space="preserve">
          <source>This library supplies &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for ASCII, ISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251, WINDOWS-1252, UTF-8, and (on little-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian architectures) UTF-16BE and UTF-32BE.</source>
          <target state="translated">该库为ASCII，ISO-8859-1（也称为LATIN-1），ISO-8859-2（LATIN-2），WINDOWS-1250，WINDOWS-1251，WINDOWS-1252，UTF-8和UTF-8 提供了&lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt;子类。 （在小端架构上）UTF-16LE和UTF-32LE；或（在大端架构上）UTF-16BE和UTF-32BE。</target>
        </trans-unit>
        <trans-unit id="2ab23006d99b3e64b2eb41b8a2440b3e86ff5b16" translate="yes" xml:space="preserve">
          <source>This library uses a remarkably common ECMAScript syntax flavor with the following extensions:</source>
          <target state="translated">这个库使用了一个非常常见的ECMAScript语法,并有以下扩展。</target>
        </trans-unit>
        <trans-unit id="1d7d527b40f488b0b076be50f2a630625a4b71d6" translate="yes" xml:space="preserve">
          <source>This library will supply your function with a new instance of ElementHandler, which may be used to parse inside the element whose start tag was just found, or to identify the tag attributes of the element, etc.  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; and &amp;lt;br/&amp;gt;.</source>
          <target state="translated">该库将为您的函数提供一个新的ElementHandler实例，该实例可用于解析刚刚找到其开始标签的元素内部，或者标识该元素的标签属性，等等。请注意，您的函数将同时被调用开始标签和空标签。也就是说，我们在&amp;lt;br&amp;gt; &amp;lt;/br&amp;gt;和&amp;lt;br/&amp;gt;之间没有区别。</target>
        </trans-unit>
        <trans-unit id="5bcb738af6294ebb159f7ef50c2f4ed098badaa1" translate="yes" xml:space="preserve">
          <source>This macro below was added in 7.16.3 to push users who recompile to use the new curl_multi_socket_action() instead of the old curl_multi_socket()</source>
          <target state="translated">下面这个宏是在7.16.3中添加的,目的是促使重新编译的用户使用新的curl_multi_socket_action()而不是旧的curl_multi_socket()</target>
        </trans-unit>
        <trans-unit id="05317d0fb9b73229e7a4b236f6860aa4bc992df1" translate="yes" xml:space="preserve">
          <source>This makes the intent clearer, because the first statement can easily be misread as the following code:</source>
          <target state="translated">这样一来,意图就更明确了,因为第一条语句很容易被误读成下面的代码。</target>
        </trans-unit>
        <trans-unit id="4d0a27a35faef1bf1f6ffad88638e7121e05700e" translate="yes" xml:space="preserve">
          <source>This means that pointers to elements of an &lt;code&gt;Array&lt;/code&gt; will become dangling as soon as the element is removed from the &lt;code&gt;Array&lt;/code&gt;. On the other hand the memory allocated by an &lt;code&gt;Array&lt;/code&gt; will be scanned by the GC and GC managed objects referenced from an &lt;code&gt;Array&lt;/code&gt; will be kept alive.</source>
          <target state="translated">这意味着一旦将元素从 &lt;code&gt;Array&lt;/code&gt; 中移除，指向 &lt;code&gt;Array&lt;/code&gt; 元素的指针就会悬空。另一方面，由 &lt;code&gt;Array&lt;/code&gt; 分配的内存将由GC扫描，并且从 &lt;code&gt;Array&lt;/code&gt; 引用的GC管理的对象将保持活动状态。</target>
        </trans-unit>
        <trans-unit id="604c9cc6344fc7f1b954e8b21d2a6ca0c3ac4133" translate="yes" xml:space="preserve">
          <source>This member holds all &lt;code&gt;Logger&lt;/code&gt;s stored in the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">该成员拥有存储在 &lt;code&gt;MultiLogger&lt;/code&gt; 中的所有 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2222d90d3dcd66aaa74b009940ed8d8638bced76" translate="yes" xml:space="preserve">
          <source>This memoizes all values of &lt;code&gt;fact&lt;/code&gt; up to the largest argument. To only cache the final result, move &lt;code&gt;memoize&lt;/code&gt; outside the function as shown below.</source>
          <target state="translated">这将记住 &lt;code&gt;fact&lt;/code&gt; 所有值，直到最大的论点为止。要仅缓存最终结果，请将 &lt;code&gt;memoize&lt;/code&gt; 移到函数外部，如下所示。</target>
        </trans-unit>
        <trans-unit id="3a167a300836fdd4ab2e0e008d931c833538789e" translate="yes" xml:space="preserve">
          <source>This method allows expansion within the respective bucket range. It succeeds if both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;b.length + delta&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;.</source>
          <target state="translated">这种方法允许在相应的铲斗范围内扩展。如果 &lt;code&gt;b.length&lt;/code&gt; 和 &lt;code&gt;b.length + delta&lt;/code&gt; 都落在 &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt; 形式的范围内，则成功。</target>
        </trans-unit>
        <trans-unit id="4461edb18d36faaf19bc846025f3b95c67801b6c" translate="yes" xml:space="preserve">
          <source>This method allows forwarding log entries from one logger to another.</source>
          <target state="translated">此方法允许将日志条目从一个记录仪转发到另一个记录仪。</target>
        </trans-unit>
        <trans-unit id="3816a6346828017f335a6081c798a8a0dd6de4dd" translate="yes" xml:space="preserve">
          <source>This method allows reallocation within the respective bucket range. If both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;, then reallocation is in place. Otherwise, reallocation with moving is attempted.</source>
          <target state="translated">此方法允许在各个存储段范围内重新分配。如果 &lt;code&gt;b.length&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 都在 &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt; 形式的范围内，则重新分配就位。否则，将尝试通过移动进行重新分配。</target>
        </trans-unit>
        <trans-unit id="b9a458cd0b30230c45418803529ca936bac85057" translate="yes" xml:space="preserve">
          <source>This method can be more efficient than the one in the previous example because &lt;code&gt;stdin.readln(buf)&lt;/code&gt; reuses (if possible) memory allocated for &lt;code&gt;buf&lt;/code&gt;, whereas &lt;code&gt;line = stdin.readln()&lt;/code&gt; makes a new memory allocation for every line.  For even better performance you can help &lt;code&gt;readln&lt;/code&gt; by passing in a large buffer to avoid memory reallocations. This can be done by reusing the largest buffer returned by &lt;code&gt;readln&lt;/code&gt;:</source>
          <target state="translated">此方法可能比上一个示例更有效，因为 &lt;code&gt;stdin.readln(buf)&lt;/code&gt; 会重用（如果可能）为 &lt;code&gt;buf&lt;/code&gt; 分配的内存，而 &lt;code&gt;line = stdin.readln()&lt;/code&gt; 会为每行进行新的内存分配。为了获得更好的性能，您可以通过传递一个大缓冲区来避免内存重新分配，从而帮助 &lt;code&gt;readln&lt;/code&gt; 。这可以通过重用 &lt;code&gt;readln&lt;/code&gt; 返回的最大缓冲区来完成：</target>
        </trans-unit>
        <trans-unit id="7f7c9ac03db99dc39088ab7814b92a020b0c3ad1" translate="yes" xml:space="preserve">
          <source>This method inserts a new Logger into the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">此方法将新的Logger插入 &lt;code&gt;MultiLogger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7e456631bd1026dc4c8384262111ee00c2ae6280" translate="yes" xml:space="preserve">
          <source>This method is defined if both allocators define it, and forwards to &lt;code&gt;SmallAllocator&lt;/code&gt; or &lt;code&gt;LargeAllocator&lt;/code&gt; appropriately.</source>
          <target state="translated">如果两个分配器都定义了此方法，则该方法将被适当地转发到 &lt;code&gt;SmallAllocator&lt;/code&gt; 或 &lt;code&gt;LargeAllocator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29c6c590b7cd5abdf60b16e55a89efa8f2694069" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it, and work similarly to &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">这种方法被定义仅当至少一个所述的分配器定义它的，并工作类似于 &lt;code&gt;reallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c403891dca13c06af654365809bbef8d64860536" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt;. If &lt;code&gt; LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">仅当至少一个分配器定义此方法时，才定义此方法。如果 &lt;code&gt;SmallAllocator&lt;/code&gt; 定义 &lt;code&gt;expand&lt;/code&gt; 并且 &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt; ，则将呼叫转发到 &lt;code&gt;SmallAllocator&lt;/code&gt; 。如果 &lt;code&gt; LargeAllocator&lt;/code&gt; 定义 &lt;code&gt;expand&lt;/code&gt; 并且 &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt; ，则将呼叫转发到 &lt;code&gt;LargeAllocator&lt;/code&gt; 。否则，调用返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc308051788a72be786da5419b09693d8595fa4d" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;reallocate&lt;/code&gt; and &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; SmallAllocator&lt;/code&gt;. If &lt;code&gt;LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">仅当至少一个分配器定义此方法时，才定义此方法。如果 &lt;code&gt;SmallAllocator&lt;/code&gt; 定义了 &lt;code&gt;reallocate&lt;/code&gt; 并且 &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt; ，则将呼叫转发到 &lt;code&gt; SmallAllocator&lt;/code&gt; 。如果 &lt;code&gt;LargeAllocator&lt;/code&gt; 定义了 &lt;code&gt;expand&lt;/code&gt; 并且 &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt; ，则将呼叫转发到 &lt;code&gt; LargeAllocator&lt;/code&gt; 。否则，调用返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="620e46438ddff127931a59ae1ef3a8f250fd07f0" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. The good allocation size is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise. (If one of the allocators does not define &lt;code&gt;goodAllocSize&lt;/code&gt;, the default implementation in this module applies.)</source>
          <target state="translated">仅当至少一个分配器定义此方法时，才定义此方法。良好的分配大小获自 &lt;code&gt;SmallAllocator&lt;/code&gt; 如果 &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt; ，或 &lt;code&gt;LargeAllocator&lt;/code&gt; 否则。（如果分配器之一未定义 &lt;code&gt;goodAllocSize&lt;/code&gt; ，则适用此模块中的默认实现。）</target>
        </trans-unit>
        <trans-unit id="d239e7b226a63994c92bb5f28f2af2cc148e0855" translate="yes" xml:space="preserve">
          <source>This method is defined only if both allocators define it. The call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt; LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">仅当两个分配器都定义此方法时，才定义此方法。如果 &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt; ， &lt;code&gt; LargeAllocator&lt;/code&gt; 呼叫转发给 &lt;code&gt;SmallAllocator&lt;/code&gt; ，否则，将呼叫转发给LargeAllocator。</target>
        </trans-unit>
        <trans-unit id="b5f2a8f9e894a52f7a4a03fd41c115c5a28e5d48" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;</source>
          <target state="translated">仅当基础范围为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围时，&lt;/a&gt;此方法才可用</target>
        </trans-unit>
        <trans-unit id="8fd044a02e3e694fc797ffa7b6155202b89056a3" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;.</source>
          <target state="translated">仅当基础范围为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围时，&lt;/a&gt;此方法才可用。</target>
        </trans-unit>
        <trans-unit id="832bf9b6aa94575865959f7e42866388acb50190" translate="yes" xml:space="preserve">
          <source>This method is only defined if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;Allocator&lt;/code&gt; 定义了 &lt;code&gt;deallocate&lt;/code&gt; 时,才定义此方法。</target>
        </trans-unit>
        <trans-unit id="d110cb43a292fbf904825bc3d4bb27446be41655" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; deallocateAll&lt;/code&gt;, and calls it for each bucket in turn. Returns &lt;code&gt;true&lt;/code&gt; if all allocators could deallocate all.</source>
          <target state="translated">仅当所有涉及的分配器都定义 &lt;code&gt; deallocateAll&lt;/code&gt; 并依次为每个存储桶调用时，才定义此方法。如果所有分配器都可以取消分配全部，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39358dd310cc162f2c05e4b4ad0f8504cf1a91af" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; resolveInternalPointer&lt;/code&gt;, and tries it for each bucket in turn.</source>
          <target state="translated">仅当所有涉及的分配器都定义 &lt;code&gt; resolveInternalPointer&lt;/code&gt; 并依次对每个存储桶尝试时，才定义此方法。</target>
        </trans-unit>
        <trans-unit id="9dbdb0a556e3c7305bbb92177faa9a39d0b98a27" translate="yes" xml:space="preserve">
          <source>This method logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the this &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此方法以 &lt;code&gt;printf&lt;/code&gt; 样式将数据记录到使用此 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 的已使用 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b6f8a28a408a1ebec1b43e9856020fe703ce80ce" translate="yes" xml:space="preserve">
          <source>This method logs data with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此方法使用使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 记录数据。</target>
        </trans-unit>
        <trans-unit id="3c1dde3d6319c6f9ff98c98c06a035679376bc16" translate="yes" xml:space="preserve">
          <source>This method removes a Logger from the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">此方法从 &lt;code&gt;MultiLogger&lt;/code&gt; 中删除一个Logger 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
