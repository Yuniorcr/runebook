<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="86db8edf378862e012fa8f8fcf58a7d5108946ce" translate="yes" xml:space="preserve">
          <source>The default allocator.</source>
          <target state="translated">默认的分配器。</target>
        </trans-unit>
        <trans-unit id="84034aca41f128da43b408ac2e8f9758bed62159" translate="yes" xml:space="preserve">
          <source>The default constructor for the &lt;code&gt;NullLogger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NullLogger&lt;/code&gt; 的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="60dfda69676fc480f5f6faa42faf083636619c98" translate="yes" xml:space="preserve">
          <source>The default constructor for the &lt;code&gt;StdForwardLogger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StdForwardLogger&lt;/code&gt; 的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="44546e235ac407a00aa0d819574df31ac96d3e13" translate="yes" xml:space="preserve">
          <source>The default directory where the TZ Database files are stored. It's empty for Windows, since Windows doesn't have them. You can also use the TZDatabaseDir version to pass an arbitrary path at compile-time, rather than hard-coding it here. Android concatenates all time zone data into a single file called tzdata and stores it in the directory below.</source>
          <target state="translated">保存TZ数据库文件的默认目录。对于Windows来说,它是空的,因为Windows没有这些文件。你也可以使用TZDatabaseDir版本在编译时传递一个任意路径,而不是在这里硬编码。Android会将所有时区数据连接到一个名为tzdata的文件中,并将其存储在下面的目录中。</target>
        </trans-unit>
        <trans-unit id="8df16f51964aeebfe4bc3a051bf58dca3ecbc7ca" translate="yes" xml:space="preserve">
          <source>The default extension to use.</source>
          <target state="translated">要使用的默认扩展。</target>
        </trans-unit>
        <trans-unit id="85ad9abd95b264167c92cdc2a1adee2b573ef599" translate="yes" xml:space="preserve">
          <source>The default good size allocation is deduced as &lt;code&gt;n&lt;/code&gt; rounded up to the allocator's alignment.</source>
          <target state="translated">默认的良好大小分配推导出为 &lt;code&gt;n&lt;/code&gt; ,四舍五入到分配器的对齐方式。</target>
        </trans-unit>
        <trans-unit id="1b0fe911bc214b516e59012b05dd0e28695378c4" translate="yes" xml:space="preserve">
          <source>The default initializer is evaluated at compile time.</source>
          <target state="translated">默认的初始化器在编译时被评估。</target>
        </trans-unit>
        <trans-unit id="09875c3ec3c0432a38d2825c4ab0b5b1b8a97473" translate="yes" xml:space="preserve">
          <source>The default initializers are evaluated at compile time.</source>
          <target state="translated">默认的初始化器在编译时被评估。</target>
        </trans-unit>
        <trans-unit id="b315cb15ffa0ca81f8d98d7b66d415e4aa5dc1b4" translate="yes" xml:space="preserve">
          <source>The default initializers may not contain references to mutable data.</source>
          <target state="translated">默认初始化器可能不包含对可变数据的引用。</target>
        </trans-unit>
        <trans-unit id="198b7d1107c41684b20ca53736c0025d3ab9b73c" translate="yes" xml:space="preserve">
          <source>The default inline behavior is typically selectable with a compiler switch such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-inline&quot;&gt;&lt;em&gt;-inline&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">默认内联行为通常可以通过&lt;a href=&quot;https://dlang.org/dmd.html#switch-inline&quot;&gt;&lt;em&gt;-inline&lt;/em&gt;&lt;/a&gt;等编译器开关进行选择。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4be45be08a1c8c22dbb96c12305596159d25e0b" translate="yes" xml:space="preserve">
          <source>The default layout of the fields of a struct is an exact match with the</source>
          <target state="translated">结构体的字段的默认布局是与</target>
        </trans-unit>
        <trans-unit id="2f337be32b3aefecfcb4859e625057b7bd434d30" translate="yes" xml:space="preserve">
          <source>The default linkage for member functions of COM classes is &lt;code&gt;extern(System)&lt;/code&gt;.  Note that if you want to implement or override any base-class methods of D interfaces or classes (ones which do not inherit from &lt;code&gt;IUnknown&lt;/code&gt;), you have to explicitly mark them as having the &lt;code&gt;extern(D)&lt;/code&gt; linkage:</source>
          <target state="translated">COM类的成员函数的默认链接为 &lt;code&gt;extern(System)&lt;/code&gt; 。请注意，如果要实现或重写D接口或类的任何基类方法（不继承自 &lt;code&gt;IUnknown&lt;/code&gt; 的方法），则必须将它们明确标记为具有 &lt;code&gt;extern(D)&lt;/code&gt; 链接：</target>
        </trans-unit>
        <trans-unit id="7f4262f95c707a983226fca6d9fb6bf885e79c8c" translate="yes" xml:space="preserve">
          <source>The default namespaces (&lt;a href=&quot;#dnsNamespace&quot;&gt;&lt;code&gt;dnsNamespace&lt;/code&gt;&lt;/a&gt;, ...) defined by this module should be used when appropriate.</source>
          <target state="translated">在适当的情况下，应使用此模块定义的默认名称空间（&lt;a href=&quot;#dnsNamespace&quot;&gt; &lt;code&gt;dnsNamespace&lt;/code&gt; &lt;/a&gt;，...）。</target>
        </trans-unit>
        <trans-unit id="c2f98d39df30add62dee5880988c4ddc9def3c49" translate="yes" xml:space="preserve">
          <source>The default scheduling priority that is set for a thread. On systems where multiple scheduling policies are defined, this value represents the default priority for the scheduling policy of the process.</source>
          <target state="translated">为线程设置的默认调度优先级。在定义了多个调度策略的系统中,这个值代表进程的调度策略的默认优先级。</target>
        </trans-unit>
        <trans-unit id="39cb60f50514180fcf08c0496a2e6d58784782d0" translate="yes" xml:space="preserve">
          <source>The default seed value.</source>
          <target state="translated">默认的种子值。</target>
        </trans-unit>
        <trans-unit id="cd5dbb92220cc6a8e8b2d5783ecebaacc60df5fc" translate="yes" xml:space="preserve">
          <source>The default value of a &lt;code&gt;Checked!(X, WithNaN)&lt;/code&gt; is its NaN value, so care must be taken that all variables are explicitly initialized. Any arithmetic and logic operation involving at least on NaN becomes NaN itself. All of &lt;code&gt;a == b&lt;/code&gt;, &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;a &amp;gt; b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt;, &lt;code&gt;a &amp;gt;= b&lt;/code&gt; yield &lt;code&gt;false&lt;/code&gt; if at least one of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is NaN.</source>
          <target state="translated">&lt;code&gt;Checked!(X, WithNaN)&lt;/code&gt; 的默认值是它的NaN值，因此必须注意所有变量都被显式初始化。至少涉及NaN的任何算术和逻辑运算本身就是NaN。如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中的至少一个是NaN ，则所有 &lt;code&gt;a == b&lt;/code&gt; ， &lt;code&gt;a &amp;lt; b&lt;/code&gt; ， &lt;code&gt;a &amp;gt; b&lt;/code&gt; ， &lt;code&gt;a &amp;lt;= b&lt;/code&gt; ， &lt;code&gt;a &amp;gt;= b&lt;/code&gt; 产生 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60336805f352e76f45059516632dd3aebf2bb4c8" translate="yes" xml:space="preserve">
          <source>The default value used for values not explicitly initialized. It is the NaN value, i.e. &lt;code&gt;T.min&lt;/code&gt; for signed integrals and &lt;code&gt;T.max&lt;/code&gt; for unsigned integrals.</source>
          <target state="translated">用于未显式初始化的值的默认值。这是NaN值，即 &lt;code&gt;T.min&lt;/code&gt; 签收积分和 &lt;code&gt;T.max&lt;/code&gt; 无符号积分。</target>
        </trans-unit>
        <trans-unit id="175f9e59ae6d8d45a5ecbc8d3bf95ccec9b46335" translate="yes" xml:space="preserve">
          <source>The default value.</source>
          <target state="translated">默认值。</target>
        </trans-unit>
        <trans-unit id="5298372926ef4a5550bf5eba62d1b79774021d32" translate="yes" xml:space="preserve">
          <source>The default way to configure the runtime is by passing command line arguments starting with &lt;code&gt;--DRT-&lt;/code&gt; and followed by the option name, e.g. &lt;code&gt;--DRT-gcopt&lt;/code&gt; to configure the GC. When command line parsing is enabled, command line options starting with &lt;code&gt;--DRT-&lt;/code&gt; are filtered out before calling main, so the program will not see them. They are still available via &lt;code&gt;rt_args()&lt;/code&gt;.</source>
          <target state="translated">配置运行时的默认方法是传递以 &lt;code&gt;--DRT-&lt;/code&gt; 开头的命令行参数，后接选项名称，例如 &lt;code&gt;--DRT-gcopt&lt;/code&gt; 来配置GC。启用命令行解析后，以 &lt;code&gt;--DRT-&lt;/code&gt; 开头的命令行选项在调用main之前会被滤除，因此程序将看不到它们。它们仍然可以通过 &lt;code&gt;rt_args()&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="ba1df5a4c503e2e5ff553646b53232a4dc9fad0b" translate="yes" xml:space="preserve">
          <source>The delegate or function having the currently held value as parameter is called with &lt;code&gt;variant&lt;/code&gt;'s current value. Visiting handlers are passed in the template parameter list. It is statically ensured that all held types of &lt;code&gt;variant&lt;/code&gt; are handled across all handlers. &lt;code&gt;visit&lt;/code&gt; allows delegates and static functions to be passed as parameters.</source>
          <target state="translated">将具有当前保留值作为参数的委托或函数与 &lt;code&gt;variant&lt;/code&gt; 的当前值一起调用。访问处理程序在模板参数列表中传递。静态确保所有持有的 &lt;code&gt;variant&lt;/code&gt; 类型都在所有处理程序中进行处理。 &lt;code&gt;visit&lt;/code&gt; 允许将委托和静态函数作为参数传递。</target>
        </trans-unit>
        <trans-unit id="a9153a9a54229a058c01d02e777396fe2144ca6b" translate="yes" xml:space="preserve">
          <source>The delegate the fiber should call</source>
          <target state="translated">光纤的委托人应该调用</target>
        </trans-unit>
        <trans-unit id="2b6e50abb4f0914ce14cb54a228ba5c564bcd73a" translate="yes" xml:space="preserve">
          <source>The delegate to be called if the value evaluates to false.</source>
          <target state="translated">值为false时要调用的委托。</target>
        </trans-unit>
        <trans-unit id="95f480c7d2ae51400206ecb9e084d35ded98b8d3" translate="yes" xml:space="preserve">
          <source>The demangle module converts mangled D symbols to a representation similar to what would have existed in code.</source>
          <target state="translated">demangle模块将杂乱的D符号转换为类似于代码中的表示方式。</target>
        </trans-unit>
        <trans-unit id="48b3f69fad23d9b2d8c32fdb445562e4fbbe9924" translate="yes" xml:space="preserve">
          <source>The demangled name or the original string if the name is not a mangled D name.</source>
          <target state="translated">解除的名称或原始字符串,如果该名称不是一个杂乱的D名称。</target>
        </trans-unit>
        <trans-unit id="0cc17d9f531c72835705e440a701b890a1903124" translate="yes" xml:space="preserve">
          <source>The demangled type name or the original string if the name is not a mangled D type.</source>
          <target state="translated">拆解后的类型名称,如果名称不是拆解后的D类型,则为原始字符串。</target>
        </trans-unit>
        <trans-unit id="60c01151d0f392e7605b5a47b38d319dce929d2b" translate="yes" xml:space="preserve">
          <source>The description of this option</source>
          <target state="translated">该选项的说明</target>
        </trans-unit>
        <trans-unit id="f84ede836de109cb779bab9fc0b1fd8d408f2a87" translate="yes" xml:space="preserve">
          <source>The desired &lt;a href=&quot;#FunctionAttribute&quot;&gt;&lt;code&gt;FunctionAttribute&lt;/code&gt;&lt;/a&gt;s of the result type.</source>
          <target state="translated">结果类型的所需&lt;a href=&quot;#FunctionAttribute&quot;&gt; &lt;code&gt;FunctionAttribute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23d72f95e07dcbef384a7cb27da3b8ccb18812f3" translate="yes" xml:space="preserve">
          <source>The desired allocation size in bytes.</source>
          <target state="translated">所需的分配大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="9a65e8347e92f2a998eac03474e781c85ca96f7b" translate="yes" xml:space="preserve">
          <source>The desired extension size in bytes.</source>
          <target state="translated">所需的扩展大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="af2fe61e437d6dfeba930d32d765dbac31989651" translate="yes" xml:space="preserve">
          <source>The desired linkage of the result type.</source>
          <target state="translated">所需结果类型的链接。</target>
        </trans-unit>
        <trans-unit id="59cf426293fa685ffeb3c9d3c020fed48d5397c1" translate="yes" xml:space="preserve">
          <source>The desired size in bytes.</source>
          <target state="translated">所需大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="ac522378c8d7addb4cb9d53d5b7d048c9264b788" translate="yes" xml:space="preserve">
          <source>The destructor automatically closes the file as soon as no &lt;code&gt;File&lt;/code&gt; object refers to it anymore.</source>
          <target state="translated">一旦没有 &lt;code&gt;File&lt;/code&gt; 对象引用该析构函数，则该析构函数将自动关闭该文件。</target>
        </trans-unit>
        <trans-unit id="8c331e4eecbd8270b0e4ce21fab87b6858ba74cc" translate="yes" xml:space="preserve">
          <source>The destructor for the super class automatically gets called when the destructor ends. There is no way to call the super destructor explicitly.</source>
          <target state="translated">当超级类的destructor结束时,超级类的destructor会自动被调用。没有办法显式地调用超类的析构器。</target>
        </trans-unit>
        <trans-unit id="f6330e2ba0f0050af5f9f70cf0eec4389de5eb4b" translate="yes" xml:space="preserve">
          <source>The destructor is expected to release any resources held by the object.</source>
          <target state="translated">解构器将释放对象持有的任何资源。</target>
        </trans-unit>
        <trans-unit id="7159cd12fe27172c0a0982e4b8092e7e75f8821b" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。例如，滚动一个&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;一年的天数将获得完全相同的&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7c404d040d8fd24e8c117abcb04c6ad2d048280" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。例如，将&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;滚动一年的天数将获得完全相同的&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3c3c9ee3f68d7a39533f5e98688e28838282e6b" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。例如，将&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;滚动一年的时间可以获得完全相同的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24751c549ef6022fb5253fa2ab74c9f98d81a539" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; one hours's worth of minutes gets the exact same &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。例如，将&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;滚动一小时的分钟数将得到完全相同的&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8c7039887bf08601f56a0509005c2c5688e3ba7" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。滚动&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 12个月将获得完全相同的&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;。但是，由于每个月中天数的不同，天数仍然会受到影响。</target>
        </trans-unit>
        <trans-unit id="4c92275a7e175bacd3ce746d6adc1eff5f6f35c0" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。将&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;滚动12个月将获得完全相同的&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。但是，由于每个月中天数的不同，天数仍然会受到影响。</target>
        </trans-unit>
        <trans-unit id="bd425db182cd0598846f2e904965692d4bd6f1e2" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。滚动&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 12个月可获得完全相同的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;。但是，由于每个月中天数的不同，天数仍然会受到影响。</target>
        </trans-unit>
        <trans-unit id="9607cb254c58607b6f72a2ec85c44f16a7c46305" translate="yes" xml:space="preserve">
          <source>The difference between this version of &lt;code&gt;everyDuration&lt;/code&gt; and the version which just takes a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; is that this one also takes the number of years and months (along with an &lt;code&gt;AllowDayOverflow&lt;/code&gt; to indicate whether adding years and months should allow the days to overflow).</source>
          <target state="translated">此版本的 &lt;code&gt;everyDuration&lt;/code&gt; 和仅使用&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;的版本之间的区别在于，此版本还需要花费年数和月份数（以及 &lt;code&gt;AllowDayOverflow&lt;/code&gt; 来指示是否添加年数和月份是否应允许天数溢出） 。</target>
        </trans-unit>
        <trans-unit id="448504c864d4f8f6a21520c51c1f3e9b8a81d617" translate="yes" xml:space="preserve">
          <source>The digamma function is the logarithmic derivative of the gamma function.</source>
          <target state="translated">digamma函数是gamma函数的对数导数。</target>
        </trans-unit>
        <trans-unit id="df031407b714e9d3fe5339c97f81f1b5df587638" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 1st shift. Positive means left, negative means right.</source>
          <target state="translated">1档的方向和幅度。正表示左,负表示右。</target>
        </trans-unit>
        <trans-unit id="ac46a68fb5f59b21b538d08a263d443a6d4a88ba" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 2nd shift. Positive means left, negative means right.</source>
          <target state="translated">二档的方向和幅度。正表示左,负表示右。</target>
        </trans-unit>
        <trans-unit id="2f490894285820c4987bf19f75fcde524a0fa198" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 3rd shift. Positive means left, negative means right.</source>
          <target state="translated">三档的方向和幅度。正表示左,负表示右。</target>
        </trans-unit>
        <trans-unit id="3c5a37562720e9b61ecfa6b8583112dc5d6824cf" translate="yes" xml:space="preserve">
          <source>The direction in time to expand the interval.</source>
          <target state="translated">在时间上扩大区间的方向。</target>
        </trans-unit>
        <trans-unit id="52fc8addeaa24de333c4f04db15ff317feeb8f10" translate="yes" xml:space="preserve">
          <source>The direction to iterate in. If passing the return value to &lt;code&gt;fwdRange&lt;/code&gt;, use &lt;code&gt;Direction.fwd&lt;/code&gt;. If passing it to &lt;code&gt;bwdRange&lt;/code&gt;, use &lt;code&gt;Direction.bwd&lt;/code&gt;.</source>
          <target state="translated">要迭代的方向。如果将返回值传递给 &lt;code&gt;fwdRange&lt;/code&gt; ，请使用 &lt;code&gt;Direction.fwd&lt;/code&gt; 。如果将其传递给 &lt;code&gt;bwdRange&lt;/code&gt; ，请使用 &lt;code&gt;Direction.bwd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae829e1bef022f58af3dfe6292cdbc4a3e16363d" translate="yes" xml:space="preserve">
          <source>The directories listed in the PATH environment variable.</source>
          <target state="translated">PATH环境变量中列出的目录。</target>
        </trans-unit>
        <trans-unit id="745a52fd17585cda122240a437ff94eb24ff53ba" translate="yes" xml:space="preserve">
          <source>The directory from which the application loaded.</source>
          <target state="translated">应用程序加载的目录。</target>
        </trans-unit>
        <trans-unit id="c70ca0dd7d389cc0f66b4748ce2158d5f654afbf" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TEMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TEMP&lt;/code&gt; 环境变量给定的目录。</target>
        </trans-unit>
        <trans-unit id="9ae0bd7ea20121e71f355b6ae61308dbc4fc4a8d" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TMP&lt;/code&gt; 环境变量给定的目录。</target>
        </trans-unit>
        <trans-unit id="daef8bc56ebc827befeb7f02e13c0987eaa60ed2" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TMPDIR&lt;/code&gt; 环境变量给定的目录。</target>
        </trans-unit>
        <trans-unit id="d4eec1b6c0603738af374e4a976caa00a506fd85" translate="yes" xml:space="preserve">
          <source>The directory to iterate over. If empty, the current directory will be iterated.</source>
          <target state="translated">要迭代的目录。如果为空,则会遍历当前目录。</target>
        </trans-unit>
        <trans-unit id="98b1c4850f41f23860e357cb3645bbbb143947fc" translate="yes" xml:space="preserve">
          <source>The directory where the TZ Database files are located.</source>
          <target state="translated">TZ数据库文件所在的目录。</target>
        </trans-unit>
        <trans-unit id="5185a0b5ceb9f32e8b2ce8a938cb585e46dedffd" translate="yes" xml:space="preserve">
          <source>The directory where the TZ Database files are located. Because these files are not located on Windows systems, provide them and give their location here to use &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">TZ数据库文件所在的目录。由于这些文件不在Windows系统上，因此请提供它们并在此处指定位置以使用&lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b936f38c2f1aa54bd76a7cc62b14148166a642a" translate="yes" xml:space="preserve">
          <source>The disadvantages of &lt;code&gt;ContiguousFreeList&lt;/code&gt; over &lt;code&gt;FreeList&lt;/code&gt; are its pay upfront model (as opposed to &lt;code&gt;FreeList&lt;/code&gt;'s pay-as-you-go approach), and a hard limit on the number of nodes in the list. Thus, a large number of long- lived objects may occupy the entire block, making it unavailable for serving allocations from the free list. However, an absolute cap on the free list size may be beneficial.</source>
          <target state="translated">与 &lt;code&gt;FreeList&lt;/code&gt; 相比， &lt;code&gt;ContiguousFreeList&lt;/code&gt; 的缺点在于它的付费预付模型（与 &lt;code&gt;FreeList&lt;/code&gt; 的按需付费方式相对）和对列表中节点数的硬限制。因此，大量的长期对象可能会占据整个块，从而使其无法用于空闲列表中的服务分配。但是，对空闲列表大小的绝对上限可能是有益的。</target>
        </trans-unit>
        <trans-unit id="3b64019a956fdeb2b48af242389c7dfaf52e1521" translate="yes" xml:space="preserve">
          <source>The distinction is made in the semantic analysis pass.</source>
          <target state="translated">在语义分析关中进行了区分。</target>
        </trans-unit>
        <trans-unit id="d29faf2564401dd940d152dda18be8c2fa0d07a8" translate="yes" xml:space="preserve">
          <source>The document comment is a series of</source>
          <target state="translated">文件评论是一系列的</target>
        </trans-unit>
        <trans-unit id="e57c999ce3911b8c1791d1a7eb04e0490e4fee0b" translate="yes" xml:space="preserve">
          <source>The documentation comment processor includes a simple macro text preprocessor. When a &amp;amp;dollar;(</source>
          <target state="translated">文档注释处理器包括一个简单的宏文本预处理器。当一个＆dollar;（</target>
        </trans-unit>
        <trans-unit id="0f835ee5f6e2ea0040d44210ead7dc160306901a" translate="yes" xml:space="preserve">
          <source>The documentation comments can themselves be commented using the &amp;amp;dollar;&lt;code&gt;(DDOC_COMMENT comment text)&lt;/code&gt; syntax. These comments do not nest.</source>
          <target state="translated">文档注释本身可以使用＆dollar;进行注释。 &lt;code&gt;(DDOC_COMMENT comment text)&lt;/code&gt; 语法。这些注释不嵌套。</target>
        </trans-unit>
        <trans-unit id="ad9fa243a6cd23895dc3ad60e16a76e4b15cce21" translate="yes" xml:space="preserve">
          <source>The domain literal is not a valid RFC 5321 address literal</source>
          <target state="translated">域名文字不是有效的RFC 5321地址文字。</target>
        </trans-unit>
        <trans-unit id="e9bc2306173e1f523fc346c3259e214855410cc4" translate="yes" xml:space="preserve">
          <source>The domain literal is not a valid RFC 5321 address literal and it contains obsolete characters</source>
          <target state="translated">域名文字不是有效的RFC 5321地址文字,它包含过时的字符。</target>
        </trans-unit>
        <trans-unit id="9635c78033f40ef6473df58ddae1875249393348" translate="yes" xml:space="preserve">
          <source>The domain of definition is 0 &amp;lt;= x &amp;lt;= 1. In this implementation a and b are restricted to positive values. The integral from x to 1 may be obtained by the symmetry relation</source>
          <target state="translated">定义域为0 &amp;lt;= x &amp;lt;=1。在此实现中，a和b限制为正值。从x到1的积分可以通过对称关系获得</target>
        </trans-unit>
        <trans-unit id="7630f4b6e086656f20c44179d8d49a08885c5ad0" translate="yes" xml:space="preserve">
          <source>The domain part contains an element that is too long</source>
          <target state="translated">域名部分包含一个过长的元素。</target>
        </trans-unit>
        <trans-unit id="f9e782a18f0e80044819c477465949e037991e2b" translate="yes" xml:space="preserve">
          <source>The domain part is too long</source>
          <target state="translated">域名部分太长</target>
        </trans-unit>
        <trans-unit id="b4015656a3a26966f5bb779ad625cb099b930b1f" translate="yes" xml:space="preserve">
          <source>The domain part of the email address, that is, the part after the @ sign.</source>
          <target state="translated">电子邮件地址的域名部分,也就是@号之后的部分。</target>
        </trans-unit>
        <trans-unit id="bc43c1b6acb6b3f1be54a397e4365b408708f795" translate="yes" xml:space="preserve">
          <source>The drain of the data read.</source>
          <target state="translated">读取数据的消耗。</target>
        </trans-unit>
        <trans-unit id="d6c5fc3ceb4e2b528f0297088355338c6c888969" translate="yes" xml:space="preserve">
          <source>The duration from the starting point to the end point.</source>
          <target state="translated">从起点到终点的持续时间。</target>
        </trans-unit>
        <trans-unit id="13e96de5799e2b95c36e302f2857b76d002475c9" translate="yes" xml:space="preserve">
          <source>The duration to add to or subtract from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;或从中减去的持续时间。</target>
        </trans-unit>
        <trans-unit id="5de9a67b89b5b7a6e94e2e5ed705920f06e257b1" translate="yes" xml:space="preserve">
          <source>The duration to add to or subtract from this &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">要添加到此 &lt;code&gt;Duration&lt;/code&gt; 或从中减去的持续时间。</target>
        </trans-unit>
        <trans-unit id="045eb63ee5246a358977769376ebbddf4f7e79de" translate="yes" xml:space="preserve">
          <source>The duration to add to the time point passed to the delegate.</source>
          <target state="translated">要添加到传递给委托人的时间点的持续时间。</target>
        </trans-unit>
        <trans-unit id="f712fda6f39835e50109819b59fa2e17d776d88d" translate="yes" xml:space="preserve">
          <source>The duration to divide this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">该持续时间除以的 &lt;code&gt;Duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebebf2b9a88fc743bbefdf245fe1996fed62b5d4" translate="yes" xml:space="preserve">
          <source>The duration to expand the interval by.</source>
          <target state="translated">扩大间隔的持续时间。</target>
        </trans-unit>
        <trans-unit id="6b8d59a6b4eb6f151c22d18ab315e8905cbca345" translate="yes" xml:space="preserve">
          <source>The duration to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s fractional seconds to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的分数秒设置为的持续时间。</target>
        </trans-unit>
        <trans-unit id="10a00cd16c4e11d477797057c8547364622ecc0c" translate="yes" xml:space="preserve">
          <source>The duration to shift the interval by.</source>
          <target state="translated">要移动的时间间隔。</target>
        </trans-unit>
        <trans-unit id="b1c624813bb3a1615cc85c1ae1a0262dd3e649d6" translate="yes" xml:space="preserve">
          <source>The duration which separates each successive time point in the range.</source>
          <target state="translated">范围内每个连续时间点之间的持续时间。</target>
        </trans-unit>
        <trans-unit id="4aceca3575bedab7bdf950c54d8f75f4cd974c6c" translate="yes" xml:space="preserve">
          <source>The effect of this function, as well as the meaning of &lt;code&gt;codeOrSignal&lt;/code&gt;, is highly platform dependent. Details are given below. Common to all platforms is that this function only</source>
          <target state="translated">此功能的效果以及 &lt;code&gt;codeOrSignal&lt;/code&gt; 的含义在很大程度上取决于平台。细节在下面给出。所有平台的共同点是仅此功能</target>
        </trans-unit>
        <trans-unit id="b949a7d4d40b96549035bb1b9cabaaf6d915fa2c" translate="yes" xml:space="preserve">
          <source>The effect on &lt;code&gt;inp&lt;/code&gt; depends on the kind of function called:</source>
          <target state="translated">对 &lt;code&gt;inp&lt;/code&gt; 的影响取决于调用的函数类型：</target>
        </trans-unit>
        <trans-unit id="562dbad759d6f2a80acd12d273fe89562ff6f2e0" translate="yes" xml:space="preserve">
          <source>The element (or range) to be treated as the separator between range segments to be split.</source>
          <target state="translated">要处理的元素(或范围)作为要分割的范围段之间的分隔符。</target>
        </trans-unit>
        <trans-unit id="67f3be77d3c98017b171a56f0b2ef27d5b2a4614" translate="yes" xml:space="preserve">
          <source>The element at offset &lt;code&gt;1&lt;/code&gt; has been removed and the rest of the elements have shifted up to fill its place, however, the original array remains of the same length. This is because all functions in &lt;code&gt;std.algorithm&lt;/code&gt; only change</source>
          <target state="translated">偏移量为 &lt;code&gt;1&lt;/code&gt; 的元素已被删除，其余元素已上移以填充其位置，但是原始数组的长度保持不变。这是因为 &lt;code&gt;std.algorithm&lt;/code&gt; 中的所有功能都只会更改</target>
        </trans-unit>
        <trans-unit id="889dab60cf01b0f7421719ab37f1b28c9311efa0" translate="yes" xml:space="preserve">
          <source>The element corresponding with a left (opening) parenthesis.</source>
          <target state="translated">与左(开口)括号对应的元素。</target>
        </trans-unit>
        <trans-unit id="0932ed8af54392d39cf0d92fcbcc4890a1724cbd" translate="yes" xml:space="preserve">
          <source>The element corresponding with a right (closing) parenthesis.</source>
          <target state="translated">与右括号(闭合)相对应的元素。</target>
        </trans-unit>
        <trans-unit id="dedbb295326b4d3eda9e5e759f27bfe1c5ac6bc2" translate="yes" xml:space="preserve">
          <source>The element is assumed to contain text</source>
          <target state="translated">假设该元素包含文本</target>
        </trans-unit>
        <trans-unit id="8312cc74e186b12d4ed20f4003b6c04acdd49b6e" translate="yes" xml:space="preserve">
          <source>The element or a reference to the element at the specified index.</source>
          <target state="translated">元素或对指定索引的元素的引用。</target>
        </trans-unit>
        <trans-unit id="7131957f7eb94e306d342b5195eb84dc3e1e781f" translate="yes" xml:space="preserve">
          <source>The element or sub-range to count in the &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; 要计数的元素或子范围。</target>
        </trans-unit>
        <trans-unit id="7a38c4dc1b72acf54e9b103de60a08c5dad1c7f0" translate="yes" xml:space="preserve">
          <source>The element removed.</source>
          <target state="translated">删除的内容;</target>
        </trans-unit>
        <trans-unit id="f20b1e66abf934338028bfca19daea068ac238b3" translate="yes" xml:space="preserve">
          <source>The element searched for.</source>
          <target state="translated">搜索的元素。</target>
        </trans-unit>
        <trans-unit id="3af3bbcb06a3c010f8dd6e115df00414b2ef76c3" translate="yes" xml:space="preserve">
          <source>The element to match.</source>
          <target state="translated">要匹配的元素。</target>
        </trans-unit>
        <trans-unit id="bfcc76451138cf6e179bded66babeafecdbfe06a" translate="yes" xml:space="preserve">
          <source>The element to stop at.</source>
          <target state="translated">要素停在。</target>
        </trans-unit>
        <trans-unit id="b80bff8085fdd511cb9c4d9e05da48019bf3dd74" translate="yes" xml:space="preserve">
          <source>The element type for 32-bit implementation.</source>
          <target state="translated">32位实现的元素类型。</target>
        </trans-unit>
        <trans-unit id="218ef2dcaf3b3057dc646bab34be48640fa2fc83" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;Char[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">范围的元素类型将为 &lt;code&gt;Char[]&lt;/code&gt; 。范围原语可能在I / O错误时引发 &lt;code&gt;StdioException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8e0ad7d182f093115b2321024fb0d43eeab8ccb" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;ubyte[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">范围的元素类型将为 &lt;code&gt;ubyte[]&lt;/code&gt; 。范围原语可能在I / O错误时引发 &lt;code&gt;StdioException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146f6e63904487c6bc88a456ffe5bb5d872efab2" translate="yes" xml:space="preserve">
          <source>The element type of &lt;code&gt;R&lt;/code&gt;. &lt;code&gt;R&lt;/code&gt; does not have to be a range. The element type is determined as the type yielded by &lt;code&gt;r.front&lt;/code&gt; for an object &lt;code&gt;r&lt;/code&gt; of type &lt;code&gt;R&lt;/code&gt;. For example, &lt;code&gt;ElementType!(T[])&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T[]&lt;/code&gt; isn't a narrow string; if it is, the element type is &lt;code&gt;dchar&lt;/code&gt;. If &lt;code&gt;R&lt;/code&gt; doesn't have &lt;code&gt;front&lt;/code&gt;, &lt;code&gt;ElementType!R&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 的元素类型。 &lt;code&gt;R&lt;/code&gt; 不必是范围。元素类型确定为 &lt;code&gt;r.front&lt;/code&gt; 为类型 &lt;code&gt;R&lt;/code&gt; 的对象 &lt;code&gt;r&lt;/code&gt; 产生的类型。例如，如果 &lt;code&gt;T[]&lt;/code&gt; 不是窄字符串，则 &lt;code&gt;ElementType!(T[])&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; ；如果是，则元素类型为 &lt;code&gt;dchar&lt;/code&gt; 。如果 &lt;code&gt;R&lt;/code&gt; 不具有 &lt;code&gt;front&lt;/code&gt; ，则 &lt;code&gt;ElementType!R&lt;/code&gt; 为 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="242b60e2b158a7060db8baf4f6cc26e6d87af9f3" translate="yes" xml:space="preserve">
          <source>The element's CData items</source>
          <target state="translated">元素的CD数据项</target>
        </trans-unit>
        <trans-unit id="c3b9d2b70df47460f19754a079e90ba32c948935" translate="yes" xml:space="preserve">
          <source>The element's child elements</source>
          <target state="translated">该元素的子元素</target>
        </trans-unit>
        <trans-unit id="a931fa1a5c6e1ac62a1fb67480e5e8ac09b9bdb7" translate="yes" xml:space="preserve">
          <source>The element's comments</source>
          <target state="translated">该元素的注释</target>
        </trans-unit>
        <trans-unit id="a2b54c10854bacd9d44680700556c9e99d65c27d" translate="yes" xml:space="preserve">
          <source>The element's items</source>
          <target state="translated">该元素的项目</target>
        </trans-unit>
        <trans-unit id="585ede5c120291a9643e02011ada89b79cd9d6f7" translate="yes" xml:space="preserve">
          <source>The element's processing instructions</source>
          <target state="translated">元素的处理指令</target>
        </trans-unit>
        <trans-unit id="eb70f51eec72df5d60ca23b74395601f21da9c66" translate="yes" xml:space="preserve">
          <source>The element's text items</source>
          <target state="translated">元素的文本项</target>
        </trans-unit>
        <trans-unit id="e5bc2ae39e4f9e29954c5367c1c69157fdd19e00" translate="yes" xml:space="preserve">
          <source>The email address to check</source>
          <target state="translated">检查的电子邮件地址</target>
        </trans-unit>
        <trans-unit id="48e5305233fe3d75b0443ee1f50818a6d648fd6c" translate="yes" xml:space="preserve">
          <source>The email status code</source>
          <target state="translated">邮件状态代码</target>
        </trans-unit>
        <trans-unit id="4346e3e9e5e3a95198a31c78de02c8e03150e933" translate="yes" xml:space="preserve">
          <source>The encoded string</source>
          <target state="translated">编码后的字符串</target>
        </trans-unit>
        <trans-unit id="381ff9274ef41642af8e81eebffce945d9f4f6ee" translate="yes" xml:space="preserve">
          <source>The encoding element type of &lt;code&gt;R&lt;/code&gt;. For narrow strings (&lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt; and their qualified variants including &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;wstring&lt;/code&gt;), &lt;code&gt;ElementEncodingType&lt;/code&gt; is the character type of the string. For all other types, &lt;code&gt;ElementEncodingType&lt;/code&gt; is the same as &lt;code&gt;ElementType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 的编码元素类型。对于窄字符串（ &lt;code&gt;char[]&lt;/code&gt; ， &lt;code&gt;wchar[]&lt;/code&gt; 及其限定的变体，包括 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;wstring&lt;/code&gt; ）， &lt;code&gt;ElementEncodingType&lt;/code&gt; 是字符串的字符类型。对于所有其他类型， &lt;code&gt;ElementEncodingType&lt;/code&gt; 与 &lt;code&gt;ElementType&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8ddaa2a73311c2a472b8bde0c140d7d16072aef8" translate="yes" xml:space="preserve">
          <source>The end point of the interval. It is excluded from the interval.</source>
          <target state="translated">区间的终点。它被排除在区间之外。</target>
        </trans-unit>
        <trans-unit id="3045098b74bc924c86c93e1e08406b98332239d1" translate="yes" xml:space="preserve">
          <source>The endianness that the bytes are assumed to be in.</source>
          <target state="translated">字节的字节数。</target>
        </trans-unit>
        <trans-unit id="d625680f2f5053e8d89e9dc8332e606f7d3ff5c0" translate="yes" xml:space="preserve">
          <source>The endianness that the program was compiled for.</source>
          <target state="translated">编制程序的目的。</target>
        </trans-unit>
        <trans-unit id="2c31e59fa05bc473d51ba9ff8b1fbea71679f185" translate="yes" xml:space="preserve">
          <source>The endianness to write the bytes in.</source>
          <target state="translated">写入字节的字节数。</target>
        </trans-unit>
        <trans-unit id="4b673a6e15bd55d6aa4a35d2bd69a88952502624" translate="yes" xml:space="preserve">
          <source>The entire contents of the archive.</source>
          <target state="translated">档案的全部内容。</target>
        </trans-unit>
        <trans-unit id="598292bc5270606189fdedc665ef492ceced68f0" translate="yes" xml:space="preserve">
          <source>The entire random number library architecture is derived from the excellent &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C++0X&lt;/a&gt; random number facility proposed by Jens Maurer and contributed to by researchers at the Fermi laboratory (excluding Xorshift).</source>
          <target state="translated">整个随机数库的体系结构均由Jens Maurer提出的出色的&lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C ++ 0X&lt;/a&gt;随机数工具派生而成，并由费米实验室的研究人员（不包括Xorshift）提供。</target>
        </trans-unit>
        <trans-unit id="694779fd846cde08f1b1e4968157c26de84e61a0" translate="yes" xml:space="preserve">
          <source>The entry point of this module is &lt;code&gt;traceHandlerOpApplyImpl&lt;/code&gt;, and the only really &quot;public&quot; symbol (since all &lt;code&gt;rt&lt;/code&gt; symbols are private). In the future, this implementation should probably be made idiomatic, so that it can for example work with attributes.</source>
          <target state="translated">该模块的入口是 &lt;code&gt;traceHandlerOpApplyImpl&lt;/code&gt; ，也是唯一真正的&amp;ldquo;公共&amp;rdquo;符号（因为所有 &lt;code&gt;rt&lt;/code&gt; 符号都是私有的）。将来，可能应使此实现变得惯用，这样它可以与属性一起使用。</target>
        </trans-unit>
        <trans-unit id="888201d962022c79856dc1d83803a781978d38cd" translate="yes" xml:space="preserve">
          <source>The equality and inequality operators are treated separately because while practically all user-defined types can be compared for equality, only a subset of types have a meaningful ordering. For example, while it makes sense to determine if two RGB color vectors are equal, it is not meaningful to say that one color is greater than another, because colors do not have an ordering. Thus, one would define &lt;code&gt;opEquals&lt;/code&gt; for a &lt;code&gt;Color&lt;/code&gt; type, but not &lt;code&gt;opCmp&lt;/code&gt;.</source>
          <target state="translated">对等号和不等号运算符进行单独处理，因为尽管实际上可以比较所有用户定义的类型的相等性，但只有类型的子集具有有意义的顺序。例如，虽然确定两个RGB颜色向量是否相等是有意义的，但是说一种颜色大于另一种颜色是没有意义的，因为颜色没有排序。因此，可以为 &lt;code&gt;Color&lt;/code&gt; 类型定义 &lt;code&gt;opEquals&lt;/code&gt; ，而不是 &lt;code&gt;opCmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b1ab6f47e6e402fb3a24bfb9f554e1d0036e9f7" translate="yes" xml:space="preserve">
          <source>The equivalent of member function pointers can be constructed using anonymous lambda functions:</source>
          <target state="translated">成员函数指针的等价物可以使用匿名lambda函数来构造。</target>
        </trans-unit>
        <trans-unit id="b934e5ce8d172dbc9fefc885ad8f4ba875129f8a" translate="yes" xml:space="preserve">
          <source>The error message incase &lt;code&gt;version != D_TypeInfo&lt;/code&gt;</source>
          <target state="translated">错误消息， &lt;code&gt;version != D_TypeInfo&lt;/code&gt; 万一！= D_TypeInfo</target>
        </trans-unit>
        <trans-unit id="74494fb82c47edd9793007790b8ec76ed5efb325" translate="yes" xml:space="preserve">
          <source>The error message to put in the exception if it is thrown.</source>
          <target state="translated">如果抛出异常,要在异常中加入错误信息。</target>
        </trans-unit>
        <trans-unit id="ac179c7a25f054b9a84b196608bf4de9e907b671" translate="yes" xml:space="preserve">
          <source>The error number.</source>
          <target state="translated">错误编号。</target>
        </trans-unit>
        <trans-unit id="bb2bfcd8d277ad988cd58683c68c61867529b4d8" translate="yes" xml:space="preserve">
          <source>The escape sequences listed in &lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt;中列出的转义序列为：</target>
        </trans-unit>
        <trans-unit id="813068399b629e54556fe2331c136edacd43967a" translate="yes" xml:space="preserve">
          <source>The escapes section is a series of substitutions which replace special characters with a string. It's useful when the output format requires escaping of certain characters, for example in HTML &lt;b&gt;&amp;amp;&lt;/b&gt; should be escaped with &lt;b&gt;&amp;amp;amp;&lt;/b&gt;.</source>
          <target state="translated">转义部分是一系列替换，用字符串替换特殊字符。当输出格式要求转义某些字符（例如以HTML格式转义）&lt;b&gt;并&lt;/b&gt;应使用&lt;b&gt;＆amp;&lt;/b&gt;转义时，此功能很有用&lt;b&gt;。&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="75a80775312b743d79dc5f0458ad6638745e66ff" translate="yes" xml:space="preserve">
          <source>The event handler that gets called to inform of upload/download progress.</source>
          <target state="translated">用于通知上传/下载进度的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="28ee4bbd0a86e9401b5c283e4626c6777888197c" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending.</source>
          <target state="translated">当需要发送数据时被调用的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="ec0b1eb03ea092eed8857727c86d04dbd3bf6621" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending. The length of the &lt;code&gt;void[]&lt;/code&gt; specifies the maximum number of bytes that can be sent.</source>
          <target state="translated">需要发送数据时调用的事件处理程序。 &lt;code&gt;void[]&lt;/code&gt; 的长度指定可以发送的最大字节数。</target>
        </trans-unit>
        <trans-unit id="c126a38e12f3ea900a6ea7dfdda2e34138f69566" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the curl backend needs to seek the data to be sent.</source>
          <target state="translated">当curl后端需要寻找要发送的数据时被调用的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="c7e1c85c7ca7e98c1826ed981521b324453ed7c7" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the net socket has been created but a &lt;code&gt;connect()&lt;/code&gt; call has not yet been done. This makes it possible to set misc. socket options.</source>
          <target state="translated">创建网络套接字但尚未完成 &lt;code&gt;connect()&lt;/code&gt; 调用时将调用的事件处理程序。这样就可以设置misc。套接字选项。</target>
        </trans-unit>
        <trans-unit id="02f312ca0b7e961f5a4f5917e4aa7edb41e07360" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data.</source>
          <target state="translated">接收传入数据的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="b87e0289d3effbf7cf04a5f7cfbfced82cc1d3d4" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data. Be sure to copy the incoming ubyte[] since it is not guaranteed to be valid after the callback returns.</source>
          <target state="translated">接收传入数据的事件处理程序。一定要复制传入的ubyte[],因为在回调返回后不能保证它是有效的。</target>
        </trans-unit>
        <trans-unit id="4c604b49f0361c7bde910df7da9e4d17ed0e24e3" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming headers for protocols that uses headers.</source>
          <target state="translated">接收使用头文件的协议的传入头文件的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="52a6be95e3d2f965951f9ddade7c43108c67742d" translate="yes" xml:space="preserve">
          <source>The event module provides a primitive for lightweight signaling of other threads (emulating Windows events on Posix)</source>
          <target state="translated">事件模块为其他线程的轻量级信号传递提供了一个基元(在Posix上模拟Windows事件)</target>
        </trans-unit>
        <trans-unit id="76cbd20f024df6b80d67a632d5c0a1a01fd91d83" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOExtString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">确切的格式与 &lt;code&gt;toISOExtString&lt;/code&gt; 中的描述完全相同，不同之处在于允许尾随零-包括小数秒和全零。但是，小数点后面没有任何小数点是无效的。同样，虽然&lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; 绝不&lt;/a&gt;会在小数秒内生成超过7位数字的字符串（因为这是百赫纳秒精度的限制），但它会允许超过7位数字以便从其他精度更高的源读取字符串（但是，任何超过7的数字都将被截断）。</target>
        </trans-unit>
        <trans-unit id="dbfdac6af98f1a47c12d787fa314f16848732e36" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOString&quot;&gt;&lt;code&gt;toISOString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">确切的格式与 &lt;code&gt;toISOString&lt;/code&gt; 中的描述完全相同，不同之处在于允许尾随零-包括小数点全为零。但是，小数点后面没有任何小数点是无效的。同样，尽管&lt;a href=&quot;#toISOString&quot;&gt; &lt;code&gt;toISOString&lt;/code&gt; &lt;/a&gt;绝不会在小数秒内生成超过7位数字的字符串（因为这是十进制纳秒精度的限制），但它将允许超过7位数字以便从其他精度更高的源读取字符串（但是，任何超过7的数字都将被截断）。</target>
        </trans-unit>
        <trans-unit id="8035aabeb60ff48fad9d3507168fac10a852f522" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toSimpleString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toSimpleString&quot;&gt;&lt;code&gt;toSimpleString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">确切的格式与 &lt;code&gt;toSimpleString&lt;/code&gt; 中的描述完全相同，不同之处在于允许尾随零-包括小数秒和全零。但是，小数点后面没有任何小数点是无效的。此外，虽然&lt;a href=&quot;#toSimpleString&quot;&gt; &lt;code&gt;toSimpleString&lt;/code&gt; 绝不&lt;/a&gt;会在小数秒内生成超过7位数字的字符串（因为这是百赫纳秒精度的限制），但它将允许超过7位数字以便从其他精度更高的源读取字符串（但是，任何超过7的数字都将被截断）。</target>
        </trans-unit>
        <trans-unit id="65836ccc655a37d33dfc806f525851b4dc381228" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged pointer in the struct A. The pointer is of type &lt;code&gt;uint*&lt;/code&gt; as specified by the first argument, and is named x, as specified by the second argument.</source>
          <target state="translated">上面的示例在结构A中创建了一个带标记的指针。该指针的类型为 &lt;code&gt;uint*&lt;/code&gt; （由第一个参数指定），并被命名为x（由第二个参数指定）。</target>
        </trans-unit>
        <trans-unit id="a8289a8de27bbcdd9e4b7b9885e6899b4349a782" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged reference to an Object in the struct A. This expects the same parameters as &lt;code&gt;taggedPointer&lt;/code&gt;, except the first argument which must be a class type instead of a pointer type.</source>
          <target state="translated">上面的示例在结构A中创建对Object的带标记的引用。除了第一个参数必须是类类型而不是指针类型之外，它期望的参数与 &lt;code&gt;taggedPointer&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="95c0102684861c4577b62ad69eb70ff34b2390d6" translate="yes" xml:space="preserve">
          <source>The example above wreaks havoc on client code because it is modifying arrays that callers considered immutable. To obtain an immutable array from the writable array &lt;code&gt;buffer&lt;/code&gt;, replace the last line with:</source>
          <target state="translated">上面的示例对客户端代码造成了严重破坏，因为它正在修改调用者认为不可变的数组。要从可写数组 &lt;code&gt;buffer&lt;/code&gt; 获取不可变数组，请将最后一行替换为：</target>
        </trans-unit>
        <trans-unit id="399a22d99c9e7b3b5ee30ddef81ec062aec6bdce" translate="yes" xml:space="preserve">
          <source>The example below features an allocator modeled after &lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt;, which uses a battery of free-list allocators spaced so as to keep internal fragmentation to a minimum. The &lt;code&gt;FList&lt;/code&gt; definitions specify no bounds for the freelist because the &lt;code&gt;Segregator&lt;/code&gt; does all size selection in advance.</source>
          <target state="translated">下面的示例以&lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt;建模，分配器使用了一系列自由列表分配器，这些分配器以一定间隔隔开，以使内部碎片最小化。该 &lt;code&gt;FList&lt;/code&gt; 定义，因为该指定空闲列表没有界限 &lt;code&gt;Segregator&lt;/code&gt; 做事先所有的尺寸选择。</target>
        </trans-unit>
        <trans-unit id="e7e36cfec3178137ce69212f870f1fab248ea421" translate="yes" xml:space="preserve">
          <source>The example below features an allocator modeled after &lt;a href=&quot;https://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt;, which uses a battery of free-list allocators spaced so as to keep internal fragmentation to a minimum. The &lt;code&gt;FList&lt;/code&gt; definitions specify no bounds for the freelist because the &lt;code&gt;Segregator&lt;/code&gt; does all size selection in advance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c82011a176c73b7fd2e55e8d4ca5d5e5bc2671" translate="yes" xml:space="preserve">
          <source>The example sets a new &lt;code&gt;FileLogger&lt;/code&gt; as new &lt;code&gt;sharedLog&lt;/code&gt;.  If at some point you want to use the original default logger again, you can use &lt;code&gt;sharedLog = null;&lt;/code&gt;. This will put back the original.</source>
          <target state="translated">该示例将一个新的 &lt;code&gt;FileLogger&lt;/code&gt; 设置为新的 &lt;code&gt;sharedLog&lt;/code&gt; 。如果您想再次使用原始的默认记录器，则可以使用 &lt;code&gt;sharedLog = null;&lt;/code&gt; 。这将放回原件。</target>
        </trans-unit>
        <trans-unit id="ad582bc954e72accfcbe7e749d32e98547d0b17c" translate="yes" xml:space="preserve">
          <source>The exception module defines all system-level exceptions and provides a mechanism to alter system-level error handling.</source>
          <target state="translated">异常模块定义了所有系统级的异常,并提供了一个改变系统级错误处理的机制。</target>
        </trans-unit>
        <trans-unit id="7a6c8dd2c388cd128d91f81fff3c160065b3f34b" translate="yes" xml:space="preserve">
          <source>The exception thrown during finalization.</source>
          <target state="translated">在定稿时抛出的异常。</target>
        </trans-unit>
        <trans-unit id="9e6c1b1caa6f537b3b32ae230a3319f2a84949f0" translate="yes" xml:space="preserve">
          <source>The exception to throw if the value evaluates to false.</source>
          <target state="translated">当值为false时要抛出的异常。</target>
        </trans-unit>
        <trans-unit id="10d46feeb5a300f1f28f6d3818a7a14193d2059d" translate="yes" xml:space="preserve">
          <source>The expanded data.</source>
          <target state="translated">扩大的数据。</target>
        </trans-unit>
        <trans-unit id="cbc3d84209a76290f33343978e317c76e214fa4c" translate="yes" xml:space="preserve">
          <source>The exponent is negative and the factor is one, i.e., output[j] := sum[ exp(-2 PI i j k / N) input[k] ].</source>
          <target state="translated">指数为负,因数为一,即输出[j]:=sum[exp(-2 PI i j k/N)input[k]]。</target>
        </trans-unit>
        <trans-unit id="08786360cdc12838546c00b5767cf2cab959b50c" translate="yes" xml:space="preserve">
          <source>The exponent is positive and the factor is 1/N, i.e., output[j] := (1 / N) sum[ exp(+2 PI i j k / N) input[k] ].</source>
          <target state="translated">指数为正,因数为1/N,即输出[j]:=(1/N)sum[exp(+2 PI i j k/N)input[k]]。</target>
        </trans-unit>
        <trans-unit id="c871c5d07aafe7ec6925f7e7fae1500b032e2b52" translate="yes" xml:space="preserve">
          <source>The expression and the errorHandler must have a common type they can both be implicitly casted to, and that type will be the type of the compound expression.</source>
          <target state="translated">表达式和errorHandler必须有一个共同的类型,它们都可以隐式地投向,这个类型将是复合表达式的类型。</target>
        </trans-unit>
        <trans-unit id="34375c5ee3f5635a2e38da6b0e76fc609894c573" translate="yes" xml:space="preserve">
          <source>The expression asserted not to throw.</source>
          <target state="translated">表示断言不扔。</target>
        </trans-unit>
        <trans-unit id="940dd3375faca27ce190b8fb03def99092a3aab1" translate="yes" xml:space="preserve">
          <source>The expression form is:</source>
          <target state="translated">表达形式为:</target>
        </trans-unit>
        <trans-unit id="cc54de17f165e5e9a2ba7fa962f4eecaa39f90b2" translate="yes" xml:space="preserve">
          <source>The expression is evaluated.</source>
          <target state="translated">该表达式已被评估。</target>
        </trans-unit>
        <trans-unit id="22a556158ebfbc64522a677428ab0391c34f8183" translate="yes" xml:space="preserve">
          <source>The expression that copy constructs or moves the value.</source>
          <target state="translated">复制构造或移动值的表达式。</target>
        </trans-unit>
        <trans-unit id="91f707cf0e8e3128051036fb96ff3b7693733b1d" translate="yes" xml:space="preserve">
          <source>The expression to resolve as type or symbol.</source>
          <target state="translated">要解析为类型或符号的表达式。</target>
        </trans-unit>
        <trans-unit id="29c4204e99277952fc7a54ab66543bc42d61a803" translate="yes" xml:space="preserve">
          <source>The expression to run and return its result.</source>
          <target state="translated">要运行的表达式并返回其结果。</target>
        </trans-unit>
        <trans-unit id="92d0bb2bd94dd52b7503e678d48be02f028860ef" translate="yes" xml:space="preserve">
          <source>The expression to test.</source>
          <target state="translated">要测试的表达方式。</target>
        </trans-unit>
        <trans-unit id="3ba5f3fe8e3c4ad3783ea96faee9ce1e4526ddb4" translate="yes" xml:space="preserve">
          <source>The expression which may throw an exception.</source>
          <target state="translated">可能引发异常的表达式。</target>
        </trans-unit>
        <trans-unit id="646fe39033d4569a34021185a6750173a3852965" translate="yes" xml:space="preserve">
          <source>The expression:</source>
          <target state="translated">这句话:</target>
        </trans-unit>
        <trans-unit id="24968438ed1fc3f9aa123f08e882cf9dcb629a30" translate="yes" xml:space="preserve">
          <source>The extension part of a file name, including the dot.  If there is no extension, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">文件名的扩展名部分，包括点。如果没有扩展名，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="001c41a8faed92276e0710e5f77bacf1f43befe9" translate="yes" xml:space="preserve">
          <source>The extra *'s and +'s on the comment opening, closing and left margin are ignored and are not part of the embedded documentation. Comments not following one of those forms are not documentation comments.</source>
          <target state="translated">注释开头、结尾和左边空白处多余的*号和+号会被忽略,不属于嵌入式文档的一部分。不遵循这些形式之一的注释不属于文档注释。</target>
        </trans-unit>
        <trans-unit id="60cbf9a8b6c782eeaf3b240238aaad4006024e93" translate="yes" xml:space="preserve">
          <source>The factory should print an error and abort the program if it cannot successfully initialize the GC instance.</source>
          <target state="translated">如果工厂不能成功初始化GC实例,应打印错误并中止程序。</target>
        </trans-unit>
        <trans-unit id="f5a2d7b1faf4a00e391206a0b6d040b1dd55f507" translate="yes" xml:space="preserve">
          <source>The fallback allocator.</source>
          <target state="translated">后备分配器。</target>
        </trans-unit>
        <trans-unit id="6444c34b4999b63334e3fe1c10565688c176440d" translate="yes" xml:space="preserve">
          <source>The fiber function.</source>
          <target state="translated">的纤维功能。</target>
        </trans-unit>
        <trans-unit id="c0e4569946778edcb0cfe73790a6deb0f483408e" translate="yes" xml:space="preserve">
          <source>The fiber module provides OS-indepedent lightweight threads aka fibers.</source>
          <target state="translated">纤维模块提供了与操作系统无关的轻质线,也就是纤维。</target>
        </trans-unit>
        <trans-unit id="4ebf4ba0f41676101df65de78d14565377976d26" translate="yes" xml:space="preserve">
          <source>The fiber object representing the calling fiber or null if no fiber is currently active within this thread. The result of deleting this object is undefined.</source>
          <target state="translated">代表调用光纤的光纤对象,如果该线程内当前没有光纤活动,则为空。删除此对象的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="7163e2b220c5c73c7ee35da99996a1282317d054" translate="yes" xml:space="preserve">
          <source>The field is ended when there is no input, even if the quote was not closed.</source>
          <target state="translated">当没有输入时,即使报价没有关闭,该字段也会被结束。</target>
        </trans-unit>
        <trans-unit id="779d09c98e4cfcdaab8d2edfcd062b2bc1c5fe62" translate="yes" xml:space="preserve">
          <source>The fields below this were added in CURLVERSION_SECOND</source>
          <target state="translated">下面的字段是在CURLVERSION_SECOND中添加的。</target>
        </trans-unit>
        <trans-unit id="7fb4d8eebf35f6bbc1f833a412d5cc7420dea229" translate="yes" xml:space="preserve">
          <source>The file (or directory) to get a DirEntry for.</source>
          <target state="translated">要获取DirEntry的文件(或目录)。</target>
        </trans-unit>
        <trans-unit id="40dabb9eb8e81154153036d71178601514e1f7f3" translate="yes" xml:space="preserve">
          <source>The file and line of the call.</source>
          <target state="translated">召的文件和行。</target>
        </trans-unit>
        <trans-unit id="e2f6f4f187fd62357491cbe8478aa3ae4cefb31e" translate="yes" xml:space="preserve">
          <source>The file attributes or 0 if the file attributes were encoded for an incompatible OS (Windows vs. POSIX).</source>
          <target state="translated">文件属性,如果文件属性是为不兼容的操作系统编码的,则为0(Windows与POSIX)。</target>
        </trans-unit>
        <trans-unit id="2587d80da404ef88f56c1d45c26f059538ee948c" translate="yes" xml:space="preserve">
          <source>The file attributes or 0 if the file attributes were encoded for an incompatible OS (Windows vs. Posix).</source>
          <target state="translated">文件属性,如果文件属性是为不兼容的操作系统(Windows与Posix)编码的,则为0。</target>
        </trans-unit>
        <trans-unit id="f357296885e979c9eb815032610719a979731bd8" translate="yes" xml:space="preserve">
          <source>The file attributes.</source>
          <target state="translated">文件属性。</target>
        </trans-unit>
        <trans-unit id="f692a5a95eb19a88be916cc17fd3a299fdb0b4c2" translate="yes" xml:space="preserve">
          <source>The file data in compressed form.</source>
          <target state="translated">压缩形式的文件数据。</target>
        </trans-unit>
        <trans-unit id="11cc9842d65b87247a394d2db23ff2854dbd2625" translate="yes" xml:space="preserve">
          <source>The file data.</source>
          <target state="translated">文件数据。</target>
        </trans-unit>
        <trans-unit id="21cf4d39fea8701f9ccea1f6e9c33a8dca629be0" translate="yes" xml:space="preserve">
          <source>The file name of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">D源代码的文件名,对应的错误是从哪里抛出的。</target>
        </trans-unit>
        <trans-unit id="b64522363b929d137710605ff07b8daf334bc620" translate="yes" xml:space="preserve">
          <source>The file name to show. If not set, the actual file name will be used (if this is a file part)</source>
          <target state="translated">要显示的文件名。如果没有设置,将使用实际的文件名(如果这是一个文件部分)。</target>
        </trans-unit>
        <trans-unit id="bf8ad1ee8706b576c3d861ca4c35b04004625b5d" translate="yes" xml:space="preserve">
          <source>The file names for packages and modules should also be composed of the ASCII characters lower case letters, digits or &lt;code&gt;_&lt;/code&gt; and should not be a &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">软件包和模块的文件名还应该由ASCII字符，小写字母，数字或 &lt;code&gt;_&lt;/code&gt; 组成,并且不能作为&lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;关键字&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="568163d3852e8f82e9cc9864a262f9868cd7a80a" translate="yes" xml:space="preserve">
          <source>The file names for packages and modules should be composed only of the ASCII lower case letters, digits, and &lt;code&gt;_&lt;/code&gt;s, and should not be a &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">软件包和模块的文件名应仅由ASCII小写字母，数字和 &lt;code&gt;_&lt;/code&gt; s组成，而不能作为&lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;关键字&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27e521d84e71e057af31f6b16036a8dda6098775" translate="yes" xml:space="preserve">
          <source>The file that is being linked. This is the target path that's stored in the symlink. A relative path is relative to the created symlink.</source>
          <target state="translated">被链接的文件。这是存储在符号链接中的目标路径。相对路径是相对于创建的符号链接而言的。</target>
        </trans-unit>
        <trans-unit id="a48d130bf6ed7fe001b9b68c13bd4356b06eb640" translate="yes" xml:space="preserve">
          <source>The file that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">如果抛出&lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; ,&lt;/a&gt;它将列出该文件。</target>
        </trans-unit>
        <trans-unit id="886ddc5df982fa3a52b4dae1cc5e097e3fae8531" translate="yes" xml:space="preserve">
          <source>The file to get the attributes of.</source>
          <target state="translated">要获取属性的文件。</target>
        </trans-unit>
        <trans-unit id="c5856ac3b9ed35958ce9f401bbff0c265bcd66da" translate="yes" xml:space="preserve">
          <source>The file to get the symbolic link attributes of.</source>
          <target state="translated">要获取符号链接属性的文件。</target>
        </trans-unit>
        <trans-unit id="d5a902223a6a641c14dbfbc008db96721d6af330" translate="yes" xml:space="preserve">
          <source>The file used for logging.</source>
          <target state="translated">用于记录的文件。</target>
        </trans-unit>
        <trans-unit id="f7969ce864cdb7d64da59da6dfc8b40cf28ba7bb" translate="yes" xml:space="preserve">
          <source>The file where the error occurred.</source>
          <target state="translated">发生错误的文件。</target>
        </trans-unit>
        <trans-unit id="3ff1fcb05fd162b545299ba30ad59377c1eb86a5" translate="yes" xml:space="preserve">
          <source>The file where the error occurred. Defaults to &lt;code&gt;__FILE__&lt;/code&gt;.</source>
          <target state="translated">发生错误的文件。默认为 &lt;code&gt;__FILE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a7b4c097e4526bdecb31861d25a87231f1a612b" translate="yes" xml:space="preserve">
          <source>The file where the exception occurred.</source>
          <target state="translated">发生异常的文件。</target>
        </trans-unit>
        <trans-unit id="2a8a857ec47a034acf4c2fcaed0de229c31869d5" translate="yes" xml:space="preserve">
          <source>The filename of the &lt;code&gt;File&lt;/code&gt; log messages are written to.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 日志消息的文件名被写入。</target>
        </trans-unit>
        <trans-unit id="37dc45c1af7cba50c135f406c906822e95a5938d" translate="yes" xml:space="preserve">
          <source>The filename of the output file of the &lt;code&gt;FileLogger&lt;/code&gt;. If that file can not be opened for writting an exception will be thrown.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; 的输出文件的文件名。如果无法打开该文件以进行写入，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="3910614447549528bc2d2fc1be565210c1526e11" translate="yes" xml:space="preserve">
          <source>The finish function returns the final hash sum and resets the Digest.</source>
          <target state="translated">完成函数返回最终的哈希和并重置Digest。</target>
        </trans-unit>
        <trans-unit id="133d5dd83ff02e493d05a0e47c1deb319a8252d7" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must be at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes big.</source>
          <target state="translated">finish函数返回哈希值。它需要一个可选的缓冲区将数据复制到其中。如果传递了缓冲区，则它必须至少为&lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;个字节大。</target>
        </trans-unit>
        <trans-unit id="22bbeb22c4ba0a11e694a3fb88ce4ce66c1aa8c4" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must have a length at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes.</source>
          <target state="translated">finish函数返回哈希值。它需要一个可选的缓冲区将数据复制到其中。如果传递了缓冲区，则其长度必须至少为&lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;个字节。</target>
        </trans-unit>
        <trans-unit id="957dc77c438abefa8c77eaf7563108a790ce4d94" translate="yes" xml:space="preserve">
          <source>The first</source>
          <target state="translated">第一个</target>
        </trans-unit>
        <trans-unit id="fb47524b87677bd448123bb56b7daf118be97145" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; is evaluated at compile time, and converted to a boolean value. If the value is true, the static assert is ignored. If the value is false, an error diagnostic is issued and the compile fails.</source>
          <target state="translated">第一个&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;在编译时求值，并转换为布尔值。如果该值为true，则忽略静态断言。如果该值为false，则发出错误诊断，并且编译失败。</target>
        </trans-unit>
        <trans-unit id="a33576b80d4f4e8bd604397c308091bd4d49eeac" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Exception&lt;/code&gt; which was bypassed when this Error was thrown, or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;Exception&lt;/code&gt;s were pending.</source>
          <target state="translated">引发此错误时将绕过的第一个 &lt;code&gt;Exception&lt;/code&gt; ;如果没有 &lt;code&gt;Exception&lt;/code&gt; 待处理，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83bd533ac7ce9ad8a841e8cf9ee5bfbb37b7a8f6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;v1&lt;/code&gt; for which &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; is true determines the result. This could lead to unexpected behaviour.</source>
          <target state="translated">第一 &lt;code&gt;v1&lt;/code&gt; 为其中 &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; 为真确定的结果。这可能会导致意外的行为。</target>
        </trans-unit>
        <trans-unit id="ba9501cbc71e13c8461adcfc7cfb46ad49a3228f" translate="yes" xml:space="preserve">
          <source>The first argument for the predicate.</source>
          <target state="translated">谓词的第一个论点。</target>
        </trans-unit>
        <trans-unit id="d76b59c9568cb4d5adeddeb8e61ac34ba34641de" translate="yes" xml:space="preserve">
          <source>The first argument is a class type or an expression of class type. The second argument is a string that matches the name of one of the functions of that class. The result is a tuple of the virtual overloads of that function. It does not include final functions that do not override anything.</source>
          <target state="translated">第一个参数是一个类类型或类类型的表达式。第二个参数是与该类的一个函数名称相匹配的字符串,结果是该函数的虚拟重载的元组。结果是该函数的虚拟重载的元组。它不包括不重载任何内容的最终函数。</target>
        </trans-unit>
        <trans-unit id="dd726d5af5bf0120b5bd49b63370601b230f8cd3" translate="yes" xml:space="preserve">
          <source>The first argument is a type that has members, or is an expression of a type that has members. The second argument is a string. If the string is a valid property of the type, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">第一个参数是具有成员的类型，或者是具有成员的类型的表达式。第二个参数是一个字符串。如果字符串是该类型的有效属性，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a43e4ec8b9b76809401c1e8287827f1c5ded36c" translate="yes" xml:space="preserve">
          <source>The first argument is an aggregate (e.g. struct/class/module). The second argument is a &lt;code&gt;string&lt;/code&gt; that matches the name of the member(s) to return. The third argument is a &lt;code&gt;bool&lt;/code&gt;, and is optional. If &lt;code&gt;true&lt;/code&gt;, the result will also include template overloads. The result is a tuple of all the overloads of the supplied name.</source>
          <target state="translated">第一个参数是一个聚合（例如struct / class / module）。第二个参数是与要返回的成员名称匹配的 &lt;code&gt;string&lt;/code&gt; 。第三个参数是 &lt;code&gt;bool&lt;/code&gt; ，并且是可选的。如果为 &lt;code&gt;true&lt;/code&gt; ，则结果还将包括模板重载。结果是提供的名称的所有重载的元组。</target>
        </trans-unit>
        <trans-unit id="2a174554ed3bb0d11c52209ee3ed7c598d6bcaa6" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;Checked&lt;/code&gt;, e.g. &lt;code&gt;int&lt;/code&gt; if the left-hand side of the operator is &lt;code&gt;Checked!int&lt;/code&gt;</source>
          <target state="translated">的第一个参数 &lt;code&gt;Checked&lt;/code&gt; ，如 &lt;code&gt;int&lt;/code&gt; 如果操作员的左侧是 &lt;code&gt;Checked!int&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8841f05f16f8289043fb3adb8a0d9f6c62e9f3bb" translate="yes" xml:space="preserve">
          <source>The first argument that passes the test &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">通过测试 &lt;code&gt;pred&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="6f69babce0033893a00ba9dd4fdded8c5d91d428" translate="yes" xml:space="preserve">
          <source>The first argument to apply to &lt;code&gt;fun&lt;/code&gt;</source>
          <target state="translated">适用于 &lt;code&gt;fun&lt;/code&gt; 的第一个论点</target>
        </trans-unit>
        <trans-unit id="5e0881d9245470375fca9c2a63d7fd75c1ab511d" translate="yes" xml:space="preserve">
          <source>The first array to compare</source>
          <target state="translated">第一个要比较的数组</target>
        </trans-unit>
        <trans-unit id="6402ea9c3911f868771a9ad2ee306a3ff47b76c7" translate="yes" xml:space="preserve">
          <source>The first choice that &lt;code&gt;switchObject&lt;/code&gt; can be casted to the type of argument it accepts will be called with &lt;code&gt;switchObject&lt;/code&gt; casted to that type, and the value it'll return will be returned by &lt;code&gt;castSwitch&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;switchObject&lt;/code&gt; 强制转换为它接受的参数类型的第一个选择将被调用， &lt;code&gt;switchObject&lt;/code&gt; 转换为该类型，并且将返回的值将由 &lt;code&gt;castSwitch&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="8c0a3698b1be7dcab735cd7cac7d279e510c1569" translate="yes" xml:space="preserve">
          <source>The first element of the array is the size of the type (for classes it is the &lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize&lt;/i&gt;&lt;/a&gt;).</source>
          <target state="translated">数组的第一个元素是类型的大小（对于类，它是&lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize&lt;/i&gt;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d156d92ea93ea0bd49c4929ebca8565a10591e92" translate="yes" xml:space="preserve">
          <source>The first element of the array.</source>
          <target state="translated">数组的第一个元素。</target>
        </trans-unit>
        <trans-unit id="d8e16b70885d5121ddc9494a6960e6bb4c96cb43" translate="yes" xml:space="preserve">
          <source>The first expression is converted to &lt;code&gt;bool&lt;/code&gt;, and is evaluated.</source>
          <target state="translated">第一个表达式将转换为 &lt;code&gt;bool&lt;/code&gt; 并被求值。</target>
        </trans-unit>
        <trans-unit id="cf9e5f533fce6e846463f393ddd35d42bb1f1cd6" translate="yes" xml:space="preserve">
          <source>The first field in the input</source>
          <target state="translated">输入的第一个字段</target>
        </trans-unit>
        <trans-unit id="d4d950398e4d3043c7b4cad357808ae2f4342dfd" translate="yes" xml:space="preserve">
          <source>The first form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;scope&lt;/code&gt;, and has &lt;a href=&quot;#return-scope-parameters&quot;&gt;return scope parameter&lt;/a&gt; semantics for the value of the &lt;code&gt;ref&lt;/code&gt; parameter.</source>
          <target state="translated">第一种形式将 &lt;code&gt;return&lt;/code&gt; 附加到 &lt;code&gt;scope&lt;/code&gt; ，并具有 &lt;code&gt;ref&lt;/code&gt; 参数值的&lt;a href=&quot;#return-scope-parameters&quot;&gt;return scope参数&lt;/a&gt;语义。</target>
        </trans-unit>
        <trans-unit id="8b1ce77e77b315411f0f72483fe564f04bb631f4" translate="yes" xml:space="preserve">
          <source>The first function</source>
          <target state="translated">第一个功能</target>
        </trans-unit>
        <trans-unit id="f3024cc5ecfa3c08bdbe44b263a51764ec97fd6f" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the &lt;code&gt;Interface&lt;/code&gt;, but the first virtual function pointer.</source>
          <target state="translated">&lt;code&gt;vtbl[]&lt;/code&gt; 的第一个成员不是指向 &lt;code&gt;Interface&lt;/code&gt; 的指针，而是第一个虚函数指针。</target>
        </trans-unit>
        <trans-unit id="847d6d02e0c1f522b786c8972c9a6146a642fa90" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the InterfaceInfo, but the first virtual function pointer.</source>
          <target state="translated">&lt;code&gt;vtbl[]&lt;/code&gt; 的第一个成员不是指向InterfaceInfo的指针，而是第一个虚函数指针。</target>
        </trans-unit>
        <trans-unit id="c2d2ce897245ef2180a0c50b1783471cf2be4244" translate="yes" xml:space="preserve">
          <source>The first overload exists only if &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt;. So if &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; or called for a constant or immutable object, then &lt;code&gt;refCountedPayload&lt;/code&gt; will also be qualified as safe and nothrow (but will still assert if not initialized).</source>
          <target state="translated">仅当 &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt; 时，才存在第一个重载。因此，如果 &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; 或为常量或不可变对象调用，则 &lt;code&gt;refCountedPayload&lt;/code&gt; 也将被视为安全且不抛出异常（但如果未初始化，则仍会断言）。</target>
        </trans-unit>
        <trans-unit id="dfd8266058456fb8b44a614fe1b78098bba5c6d8" translate="yes" xml:space="preserve">
          <source>The first overload of &lt;code&gt;makeIndex&lt;/code&gt; writes to a range containing pointers, and the second writes to a range containing offsets. The first overload requires &lt;code&gt;Range&lt;/code&gt; to be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, and the latter requires it to be a random-access range.</source>
          <target state="translated">&lt;code&gt;makeIndex&lt;/code&gt; 的第一个重载写入包含指针的范围，第二个重载包含偏移量的范围。第一个重载要求 &lt;code&gt;Range&lt;/code&gt; 为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围&lt;/a&gt;，而第二个过载则要求其为随机访问范围。</target>
        </trans-unit>
        <trans-unit id="2797f8bab40930285c67d69e0f78f4ff6b12f672" translate="yes" xml:space="preserve">
          <source>The first overload of this function will return &lt;code&gt;T.init&lt;/code&gt; if the range is empty. However, the second overload will return &lt;code&gt;seed&lt;/code&gt; on empty ranges.</source>
          <target state="translated">如果范围为空，则此函数的第一个重载将返回 &lt;code&gt;T.init&lt;/code&gt; 。但是，第二次过载将在空范围内返回 &lt;code&gt;seed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa15d56dc093902b6572dae74b23ea12e4df8659" translate="yes" xml:space="preserve">
          <source>The first part is done automatically by the language, the second part is done if a postblit function is defined for the struct. The postblit has access only to the destination struct object, not the source. Its job is to &amp;lsquo;fix up&amp;rsquo; the destination as necessary, such as making copies of referenced data, incrementing reference counts, etc. For example:</source>
          <target state="translated">第一部分由语言自动完成，第二部分（如果为结构定义了postblit函数）完成。postblit只能访问目标struct对象，而不能访问源。它的工作是根据需要&amp;ldquo;固定&amp;rdquo;目标，例如制作参考数据的副本，增加参考计数等。例如：</target>
        </trans-unit>
        <trans-unit id="b6a25e3471beef6bed20eb948a4b0de3cefb170f" translate="yes" xml:space="preserve">
          <source>The first part of the desired time zones.</source>
          <target state="translated">所需时区的第一部分。</target>
        </trans-unit>
        <trans-unit id="f479a5f1dc2ec5b3e8f93d2c246a61132b592fa7" translate="yes" xml:space="preserve">
          <source>The first range</source>
          <target state="translated">第一个范围</target>
        </trans-unit>
        <trans-unit id="978014a33cbc746b950a93b0f0736f4203ea8def" translate="yes" xml:space="preserve">
          <source>The first range to be compared.</source>
          <target state="translated">第一个要比较的范围。</target>
        </trans-unit>
        <trans-unit id="ca9cc691843153958d1dfce3f9f135428053bc03" translate="yes" xml:space="preserve">
          <source>The first range.</source>
          <target state="translated">第一个范围。</target>
        </trans-unit>
        <trans-unit id="376b0679101f4b59ef8dcfe360d9831914d2f062" translate="yes" xml:space="preserve">
          <source>The first section is the</source>
          <target state="translated">第一节是</target>
        </trans-unit>
        <trans-unit id="0a2ac8281c00878fb6aeb93d4c1aa8543d1c7cdd" translate="yes" xml:space="preserve">
          <source>The first template argument is the size of the region and the second is the needed alignment. Depending on the alignment requested and platform details, the actual available storage may be smaller than the compile-time parameter. To make sure that at least &lt;code&gt;n&lt;/code&gt; bytes are available in the region, use &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt;.</source>
          <target state="translated">第一个模板参数是区域的大小，第二个是所需的对齐方式。根据请求的对齐方式和平台详细信息，实际可用存储空间可能小于编译时参数。要确保该区域中至少有 &lt;code&gt;n&lt;/code&gt; 个字节可用，请使用 &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f09dcfe52dd359d217c384efcd5e2b579c11d4d5" translate="yes" xml:space="preserve">
          <source>The first thing a catch handler does is call this.</source>
          <target state="translated">捕捉处理程序首先要做的就是调用这个。</target>
        </trans-unit>
        <trans-unit id="06bc16353a0bd43b921f8f9a4d6fe2a9b273859a" translate="yes" xml:space="preserve">
          <source>The first time point in the range.</source>
          <target state="translated">范围内的第一个时间点。</target>
        </trans-unit>
        <trans-unit id="ee856ba33815edde83d3ab4573c1bb58ec0e2ba8" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if &lt;code&gt;alloc&lt;/code&gt;'s primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">前两个重载仅在 &lt;code&gt;alloc&lt;/code&gt; 的原语起作用时抛出。如果复制操作抛出异常，则涉及复制初始化的重载将释放内存并传播异常。</target>
        </trans-unit>
        <trans-unit id="333231d0183ec9a4310007ffcf10aa12ccaa5deb" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if the used allocator's primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">前两个重载只有在使用的分配器的基元抛出时才会抛出。涉及复制初始化的重载会在复制操作抛出时重新分配内存并传播异常。</target>
        </trans-unit>
        <trans-unit id="8adbee74bf4af885c51ba2cdd7ef319e8a5ccd70" translate="yes" xml:space="preserve">
          <source>The first type to receive the type name for</source>
          <target state="translated">第一个接收类型名称为</target>
        </trans-unit>
        <trans-unit id="24a327b5e33473298dc52e8aa179b1270880d206" translate="yes" xml:space="preserve">
          <source>The first version counts the number of elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;pred&lt;/code&gt; defaults to equality. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">第一版本计数的元素数 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;r&lt;/code&gt; 为其 &lt;code&gt;pred(x, value)&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;pred&lt;/code&gt; 默认为相等。执行 &lt;code&gt;pred&lt;/code&gt; 的 &amp;Omicron;（ &lt;code&gt;haystack.length&lt;/code&gt; ）个评估。</target>
        </trans-unit>
        <trans-unit id="c9816b3b28ee2e6c5406da992bb1cbb42be32059" translate="yes" xml:space="preserve">
          <source>The first way is to use a literal that is already immutable, such as string literals. String literals are always immutable.</source>
          <target state="translated">第一种方法是使用已经是不可变的文字,比如字符串字元。字符串字元总是不可变的。</target>
        </trans-unit>
        <trans-unit id="b05e9e189cc2bf7e6e8a6f344ff95d0591fc3a0f" translate="yes" xml:space="preserve">
          <source>The first will queue writers until no readers hold the mutex, then pass the writers through one at a time. If a reader acquires the mutex while there are still writers queued, the reader will take precedence.</source>
          <target state="translated">首先将作家排队,直到没有读者持有mutex,然后一次通过一个作家。如果有读者获得了mutex,而仍有写手在排队,则该读者将获得优先权。</target>
        </trans-unit>
        <trans-unit id="1b1951cc36673198c26cd910de69ac59cf5f6d05" translate="yes" xml:space="preserve">
          <source>The focus of this module is the core needs of developing Unicode-aware applications. To that effect it provides the following optimized primitives:</source>
          <target state="translated">该模块的重点是开发 Unicode-aware 应用程序的核心需求。为此,它提供了以下优化的基元。</target>
        </trans-unit>
        <trans-unit id="6fa1fe0d7308c90108a99d43bd343885cf39b2f7" translate="yes" xml:space="preserve">
          <source>The following IEEE 'real' formats are currently supported:</source>
          <target state="translated">目前支持以下IEEE &quot;真实 &quot;格式。</target>
        </trans-unit>
        <trans-unit id="fd79ad5ff3bdc8ea5cc9c7e973de1494e808a075" translate="yes" xml:space="preserve">
          <source>The following algorithm is used:</source>
          <target state="translated">采用以下算法。</target>
        </trans-unit>
        <trans-unit id="3781d7d912eacb6b194d6abe4908fafb2e1b7d5d" translate="yes" xml:space="preserve">
          <source>The following algorithms are currently implemented:</source>
          <target state="translated">目前实施的算法如下:</target>
        </trans-unit>
        <trans-unit id="d55ceaf72919876c8f40561d12b134a3ea66a2f7" translate="yes" xml:space="preserve">
          <source>The following alias declarations are valid:</source>
          <target state="translated">下列别名声明有效:</target>
        </trans-unit>
        <trans-unit id="3cfdc04ab915c01ce32c8d0e68bf6bc781aec0c7" translate="yes" xml:space="preserve">
          <source>The following are all embedded documentation comments:</source>
          <target state="translated">以下是所有嵌入的文档注释。</target>
        </trans-unit>
        <trans-unit id="98d73aa2fbdeacfd5d17519697402797329a5e39" translate="yes" xml:space="preserve">
          <source>The following are rules of input ranges are assumed to hold true in all Phobos code. These rules are not checkable at compile-time, so not conforming to these rules when writing ranges or range based code will result in undefined behavior.</source>
          <target state="translated">以下是输入范围的规则,假设在所有 Phobos 代码中都是正确的,这些规则在编译时不可检查,所以在编写范围或基于范围的代码时,不符合这些规则会导致未定义的行为。这些规则在编译时是不可检查的,所以在编写范围或基于范围的代码时,如果不符合这些规则,将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="eabfe29dc68817824868f2b1cc59ea44b7368f75" translate="yes" xml:space="preserve">
          <source>The following are what the Unicode standard considers as line terminators:</source>
          <target state="translated">以下是Unicode标准认为的行终止符。</target>
        </trans-unit>
        <trans-unit id="21052e7f487ea1e8da6a5dfd837062e0257bbb6f" translate="yes" xml:space="preserve">
          <source>The following binary operators are overloadable:</source>
          <target state="translated">以下二进制运算符是可以过载的。</target>
        </trans-unit>
        <trans-unit id="85cad5d1bff24fce98bfd578ab9c72fa9869b15d" translate="yes" xml:space="preserve">
          <source>The following code compares the use of &lt;code&gt;formatValue&lt;/code&gt; and &lt;code&gt;formattedWrite&lt;/code&gt;.</source>
          <target state="translated">以下代码比较了 &lt;code&gt;formatValue&lt;/code&gt; 和 &lt;code&gt;formattedWrite&lt;/code&gt; 的用法。</target>
        </trans-unit>
        <trans-unit id="36006625c3fb62c010db1770cfe9a955d1abc844" translate="yes" xml:space="preserve">
          <source>The following code does a full unzip</source>
          <target state="translated">下面的代码可以完全解压</target>
        </trans-unit>
        <trans-unit id="707a5e8dae71e24794f64d11490781d72f147427" translate="yes" xml:space="preserve">
          <source>The following code should compile for any forward range.</source>
          <target state="translated">下面的代码应该可以编译任何前向范围。</target>
        </trans-unit>
        <trans-unit id="b75b3b21bc4ed533a6d7d4185c0635676c150be0" translate="yes" xml:space="preserve">
          <source>The following describes the behavior of the qualified postblit definitions:</source>
          <target state="translated">下面描述了合格的blit后定义的行为。</target>
        </trans-unit>
        <trans-unit id="cc1ef4d0137291a52b36237f0a56da4b9479ab3e" translate="yes" xml:space="preserve">
          <source>The following describes the specific implementation of the vector types for the X86 and X86_64 architectures.</source>
          <target state="translated">下面介绍X86和X86_64架构的向量类型的具体实现。</target>
        </trans-unit>
        <trans-unit id="105f7db9c11f1b737bfecc2ad34e6e665b2f7c19" translate="yes" xml:space="preserve">
          <source>The following divide or modulus integral operands:</source>
          <target state="translated">下面的除法或模数积分操作数。</target>
        </trans-unit>
        <trans-unit id="f4a4096a1a2c3a608e01b521d07c483d3463c6b6" translate="yes" xml:space="preserve">
          <source>The following elements describe the locations of GC managed pointers within the memory occupied by an instance of the type. For type T, there are &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; possible pointers represented by the bits of the array values.</source>
          <target state="translated">以下元素描述了该类型的实例占用的内存中GC管理的指针的位置。对于类型T，存在 &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; 可能的指针，这些指针由数组值的位表示。</target>
        </trans-unit>
        <trans-unit id="64e995a24781ca67ad26542b15d464819ff2f49a" translate="yes" xml:space="preserve">
          <source>The following example shows binding of a pure virtual function, its implementation in a derived class, a non-virtual member function, and a member field:</source>
          <target state="translated">下面的例子显示了一个纯虚拟函数、它在派生类中的实现、一个非虚拟成员函数和一个成员字段的绑定。</target>
        </trans-unit>
        <trans-unit id="7394f4cff4af73de38cdcc123f9d9cc433c49d32" translate="yes" xml:space="preserve">
          <source>The following expression must be true for &lt;code&gt;hasSlicing&lt;/code&gt; to be &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">为了使 &lt;code&gt;hasSlicing&lt;/code&gt; 为true，以下表达式必须为 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9182b2bc4da6786571366018715b092f896d0a9d" translate="yes" xml:space="preserve">
          <source>The following flag from DMD can be used to add a new path in which to search for frameworks:</source>
          <target state="translated">DMD的以下标志可以用来添加一个新的路径来搜索框架。</target>
        </trans-unit>
        <trans-unit id="f255eea7299aed827ce99b1b18680817e56fa6aa" translate="yes" xml:space="preserve">
          <source>The following forms of slice expression can be convertible to a static array type:</source>
          <target state="translated">以下形式的分片表达式可以转换为静态数组类型。</target>
        </trans-unit>
        <trans-unit id="b112356e7e4259c722c195a6e095476ecaa2fdb9" translate="yes" xml:space="preserve">
          <source>The following functions are publicly imported:</source>
          <target state="translated">以下功能是公开导入的。</target>
        </trans-unit>
        <trans-unit id="37498d7cc50ed898202c2748c98849d1a32c6302" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined, but are deprecated:</source>
          <target state="translated">定义了以下标识符,但已被废弃。</target>
        </trans-unit>
        <trans-unit id="4b758467388bb94c690cea1fb26de17875ff1787" translate="yes" xml:space="preserve">
          <source>The following information might be of help with choosing the appropriate block size. Actual allocation occurs in sizes multiple of the block size. Allocating one block is the fastest because only one 0 bit needs to be found in the metadata. Allocating 2 through 64 blocks is the next cheapest because it affects a maximum of two &lt;code&gt;ulong&lt;/code&gt; in the metadata. Allocations greater than 64 blocks require a multiword search through the metadata.</source>
          <target state="translated">以下信息可能有助于选择适当的块大小。实际分配的大小是块大小的倍数。分配一个块最快，因为在元数据中只需找到一个0位。分配2到64个块是下一个最便宜的，因为它影响元数据中最多两个 &lt;code&gt;ulong&lt;/code&gt; 。大于64个块的分配要求通过元数据进行多字搜索。</target>
        </trans-unit>
        <trans-unit id="3576cbb0f30565829c9a8b467650fa45b457f446" translate="yes" xml:space="preserve">
          <source>The following is a list of important Unicode notions and definitions. Any conventions used specifically in this module alone are marked as such. The descriptions are based on the formal definition as found in &lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt; chapter three of The Unicode Standard Core Specification.&lt;/a&gt;</source>
          <target state="translated">以下是重要的Unicode概念和定义的列表。仅在此模块中专门使用的任何约定均已标记为此类。这些描述基于&lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt;Unicode标准核心规范第三章中&lt;/a&gt;的正式定义。</target>
        </trans-unit>
        <trans-unit id="ce914524ba4b9740fa3dd3403eb5305729b98aee" translate="yes" xml:space="preserve">
          <source>The following is a list of important Unicode notions and definitions. Any conventions used specifically in this module alone are marked as such. The descriptions are based on the formal definition as found in &lt;a href=&quot;https://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt; chapter three of The Unicode Standard Core Specification.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee35f7e05bf101609042076d8164187dce2ce440" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;Allocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Allocator&lt;/code&gt; 定义了以下方法并将其转发，则定义以下方法： &lt;code&gt;deallocateAll&lt;/code&gt; ， &lt;code&gt;empty&lt;/code&gt; ， &lt;code&gt;owns&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91a10c7b038d71ce23d47d4e91b5d6d57a0c0ec0" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 定义了以下方法并将其转发，则定义以下方法： &lt;code&gt;allocateAll&lt;/code&gt; ， &lt;code&gt;expand&lt;/code&gt; ， &lt;code&gt;owns&lt;/code&gt; ， &lt;code&gt;reallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14685afb8641a641e101312bd747ad3ce716f779" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 定义了以下方法并将其转发，则会定义以下方法： &lt;code&gt;expand&lt;/code&gt; ， &lt;code&gt;owns&lt;/code&gt; ， &lt;code&gt;reallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5e999922ed0b2b38ea541add7eceec13e307896" translate="yes" xml:space="preserve">
          <source>The following methods are forwarded to the parent allocator if present: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;.</source>
          <target state="translated">以下方法（如果存在）将转发给父分配器： &lt;code&gt;allocateAll&lt;/code&gt; ， &lt;code&gt;owns&lt;/code&gt; ， &lt;code&gt;deallocateAll&lt;/code&gt; ， &lt;code&gt;empty&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90832fc606780913417ad9424b5b78d805e2f1c9" translate="yes" xml:space="preserve">
          <source>The following must not compile:</source>
          <target state="translated">下面的内容一定不能编译。</target>
        </trans-unit>
        <trans-unit id="151cf7cc11e7e2474415594512b78561ff78c2e4" translate="yes" xml:space="preserve">
          <source>The following op assignment operators are overloadable:</source>
          <target state="translated">下面的操作赋值运算符是可以重载的。</target>
        </trans-unit>
        <trans-unit id="1686f8bc7687029bb8df07eb18087ba36d800516" translate="yes" xml:space="preserve">
          <source>The following operations are not allowed in safe functions:</source>
          <target state="translated">安全函数中不允许进行以下操作。</target>
        </trans-unit>
        <trans-unit id="74510166d7dbf32dd076c82ed552fa55a6bbe522" translate="yes" xml:space="preserve">
          <source>The following part &lt;code&gt;=&amp;gt;&lt;/code&gt;</source>
          <target state="translated">以下部分 &lt;code&gt;=&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f46ca3cf008a6a798269fad6d3b26dd55f13657" translate="yes" xml:space="preserve">
          <source>The following registers are supported. Register names are always in upper case.</source>
          <target state="translated">支持以下寄存器。寄存器名称总是大写。</target>
        </trans-unit>
        <trans-unit id="747c928a756931b0ee0b7f4bfca0b996d4e0288f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to class construction:</source>
          <target state="translated">以下限制适用于班级建设。</target>
        </trans-unit>
        <trans-unit id="b257030ef10af45e49786ee89d857d61ed4e94b9" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to struct construction:</source>
          <target state="translated">以下限制适用于结构的建造。</target>
        </trans-unit>
        <trans-unit id="35dabc106beeab4a557770a611849cc8c36d5347" translate="yes" xml:space="preserve">
          <source>The following restrictions apply:</source>
          <target state="translated">有以下限制:</target>
        </trans-unit>
        <trans-unit id="2f5e979077d2f3caabdbb4640da99e0c00a00749" translate="yes" xml:space="preserve">
          <source>The following steps happen:</source>
          <target state="translated">发生以下步骤:</target>
        </trans-unit>
        <trans-unit id="b441496fc086e7e8d354986714d6c04ebf32cc29" translate="yes" xml:space="preserve">
          <source>The following table compactly summarises the different process creation functions and how they relate to each other:</source>
          <target state="translated">下表简要总结了不同的流程创建功能及其相互之间的关系。</target>
        </trans-unit>
        <trans-unit id="05b248b2126c26cb91a89762582c19941d257e43" translate="yes" xml:space="preserve">
          <source>The following table is a quick reference guide for which Phobos modules to use for a given category of functionality. Note that some modules may appear in more than one category, as some Phobos modules are quite generic and can be applied in a variety of situations.</source>
          <target state="translated">下表是一个快速参考指南,说明哪些 Phobos 模块可用于特定类别的功能。请注意,有些模块可能出现在多个类别中,因为有些 Phobos 模块非常通用,可以应用于各种情况。</target>
        </trans-unit>
        <trans-unit id="a2cf73cb06dd66656b8e69a1d451407dbc663bbe" translate="yes" xml:space="preserve">
          <source>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to succesfully invoke the postblit:</source>
          <target state="translated">下表列出了与成功调用postblit所需使用的对象类型相关联的postblit的所有分组限定符的可能性。</target>
        </trans-unit>
        <trans-unit id="45f0025d65c3c173c7ccd0fb97c1cf0de30e0385" translate="yes" xml:space="preserve">
          <source>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to successfully invoke the postblit:</source>
          <target state="translated">下表列出了与成功调用postblit所需使用的对象类型相关联的postblit的所有分组限定符的可能性。</target>
        </trans-unit>
        <trans-unit id="824da93e42b4013db578b67b46a78528e680f556" translate="yes" xml:space="preserve">
          <source>The following transformations of floating point expressions are not allowed because under IEEE rules they could produce different results.</source>
          <target state="translated">以下浮点表达式的变换是不允许的,因为根据IEEE规则,它们可能产生不同的结果。</target>
        </trans-unit>
        <trans-unit id="a206952bbb005ee76451476eb55d6acde4281a6d" translate="yes" xml:space="preserve">
          <source>The following typedef's are signatures of malloc, free, realloc, strdup and calloc respectively. Function pointers of these types can be passed to the curl_global_init_mem() function to set user defined memory management callback routines.</source>
          <target state="translated">下面的typedef分别是malloc、free、realloc、strdup和calloc的签名,这些类型的函数指针可以传递给curl_global_init_mem()函数,设置用户定义的内存管理回调例程。这些类型的函数指针可以传递给curl_global_init_mem()函数来设置用户定义的内存管理回调例程。</target>
        </trans-unit>
        <trans-unit id="6266d602387c0c2612f1f18ac8c95fc02fe3bb5d" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is applied the expanded &lt;code&gt;Tuple&lt;/code&gt;, so it may contain as many formats as the &lt;code&gt;Tuple&lt;/code&gt; has fields.</source>
          <target state="translated">格式 &lt;code&gt;inner&lt;/code&gt; 应用于扩展的 &lt;code&gt;Tuple&lt;/code&gt; ，因此它可能包含与 &lt;code&gt;Tuple&lt;/code&gt; 具有的字段一样多的格式。</target>
        </trans-unit>
        <trans-unit id="d91cc2eaba6a476564c6ddbd8124208fde7d92fe" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is one format, that is applied on all fields of the &lt;code&gt;Tuple&lt;/code&gt;. The inner format must be compatible to all of them.</source>
          <target state="translated">&lt;code&gt;inner&lt;/code&gt; 格式是一种格式，适用于 &lt;code&gt;Tuple&lt;/code&gt; 的所有字段。内部格式必须与所有这些格式兼容。</target>
        </trans-unit>
        <trans-unit id="b804a9979bb24328a2b2b5b25616b3fc268adff1" translate="yes" xml:space="preserve">
          <source>The format of the data to read.</source>
          <target state="translated">读取数据的格式。</target>
        </trans-unit>
        <trans-unit id="0a7a62414c21f47b50a1e92c766dda1b08a5910c" translate="yes" xml:space="preserve">
          <source>The format of the date should follow this template:</source>
          <target state="translated">日期的格式应遵循此模板。</target>
        </trans-unit>
        <trans-unit id="659e106c79a7ed685e316895f1b36b5ece514b7f" translate="yes" xml:space="preserve">
          <source>The format of the instructions is, of course, highly dependent on the native instruction set of the target CPU, and so is &lt;a href=&quot;iasm&quot;&gt;implementation defined&lt;/a&gt;. But, the format will follow the following conventions:</source>
          <target state="translated">指令的格式当然高度依赖于目标CPU的本机指令集，因此&lt;a href=&quot;iasm&quot;&gt;实现也是定义的&lt;/a&gt;。但是，格式将遵循以下约定：</target>
        </trans-unit>
        <trans-unit id="d00ef203b4bd1ca0d23b1201e668116dd138801d" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">故意不指定字符串的格式，关心字符串格式的代码应使用 &lt;code&gt;toISOString&lt;/code&gt; ， &lt;code&gt;toISOExtString&lt;/code&gt; ， &lt;code&gt;toSimpleString&lt;/code&gt; 或其他一些显式生成代码所需格式的自定义格式函数。原因是代码可以清楚地知道其使用的格式，从而使维护代码和与使用生成的字符串的其他软件进行交互的错误率降低。出于同样的原因，&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;没有 &lt;code&gt;fromString&lt;/code&gt; 函数，但确实具有 &lt;code&gt;fromISOString&lt;/code&gt; ， &lt;code&gt;fromISOExtString&lt;/code&gt; 和 &lt;code&gt;fromSimpleString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e82eb1994e0d2ee7e98c5b8f8c20cfd78e8b067" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">故意不指定字符串的格式，关心字符串格式的代码应使用 &lt;code&gt;toISOString&lt;/code&gt; ， &lt;code&gt;toISOExtString&lt;/code&gt; ， &lt;code&gt;toSimpleString&lt;/code&gt; 或其他一些显式生成代码所需格式的自定义格式函数。原因是代码可以清楚地知道其使用的格式，从而使维护代码和与使用生成的字符串的其他软件进行交互的错误率降低。出于同样的原因，&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;没有 &lt;code&gt;fromString&lt;/code&gt; 函数，但确实具有 &lt;code&gt;fromISOString&lt;/code&gt; ， &lt;code&gt;fromISOExtString&lt;/code&gt; 和 &lt;code&gt;fromSimpleString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96cf4abaa3ec73526e49a27860bcadf20906a190" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">故意不指定字符串的格式，关心字符串格式的代码应使用 &lt;code&gt;toISOString&lt;/code&gt; ， &lt;code&gt;toISOExtString&lt;/code&gt; ， &lt;code&gt;toSimpleString&lt;/code&gt; 或其他一些显式生成代码所需格式的自定义格式函数。原因是代码可以清楚地知道其使用的格式，从而使维护代码和与使用生成的字符串的其他软件进行交互的错误率降低。出于同样的原因，&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;没有 &lt;code&gt;fromString&lt;/code&gt; 函数，但确实具有 &lt;code&gt;fromISOString&lt;/code&gt; ， &lt;code&gt;fromISOExtString&lt;/code&gt; 和 &lt;code&gt;fromSimpleString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a7f64095e841cf54dadcac2f9cbc728022a8d4" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt; and &lt;code&gt;fromISOExtString&lt;/code&gt;.</source>
          <target state="translated">故意未指定字符串的格式，关心字符串格式的代码应使用 &lt;code&gt;toISOString&lt;/code&gt; ， &lt;code&gt;toISOExtString&lt;/code&gt; 或其他一些显式生成代码所需格式的自定义格式函数。原因是代码可以清楚地知道其使用的格式，从而使维护代码和与使用生成的字符串的其他软件进行交互的错误率降低。出于同样的原因，&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;没有 &lt;code&gt;fromString&lt;/code&gt; 函数，而确实具有 &lt;code&gt;fromISOString&lt;/code&gt; 和 &lt;code&gt;fromISOExtString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffca9618faa656329893915994f22e9af2d88357" translate="yes" xml:space="preserve">
          <source>The format returned by toString may or may not change in the future.</source>
          <target state="translated">toString返回的格式将来可能会或不会改变。</target>
        </trans-unit>
        <trans-unit id="03b68c7b67ac69b6f5b3f857c44f365ee971e450" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;' '&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含一个 &lt;code&gt;' '&lt;/code&gt; （与 &lt;code&gt;printf&lt;/code&gt; 兼容）。</target>
        </trans-unit>
        <trans-unit id="f06eba7969af19af6a609393b286c72694c125a1" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'#'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含 &lt;code&gt;'#'&lt;/code&gt; （ &lt;code&gt;printf&lt;/code&gt; 兼容性）。</target>
        </trans-unit>
        <trans-unit id="2b3efef6165630dae7b0c5941cb57f0ff6fb2723" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含 &lt;code&gt;'+'&lt;/code&gt; （ &lt;code&gt;printf&lt;/code&gt; 兼容性）。</target>
        </trans-unit>
        <trans-unit id="6460ee5bc9ce27cd4f9cfd713bf8f2494817b14f" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;','&lt;/code&gt;</source>
          <target state="translated">格式说明符包含 &lt;code&gt;','&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="962882364923635b105d5f54d8d7565b59680ac3" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含 &lt;code&gt;'-'&lt;/code&gt; （ &lt;code&gt;printf&lt;/code&gt; 兼容性）。</target>
        </trans-unit>
        <trans-unit id="d34bdd42fd319223df703e24b238ea323c66c17e" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含 &lt;code&gt;'0'&lt;/code&gt; （与 &lt;code&gt;printf&lt;/code&gt; 兼容）。</target>
        </trans-unit>
        <trans-unit id="4e47d83ed9645d662de3546c090652b44c5fa2bb" translate="yes" xml:space="preserve">
          <source>The format string can be checked at compile-time (see &lt;a href=&quot;#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; for details):</source>
          <target state="translated">可以在编译时检查格式字符串（有关详细信息，请参见&lt;a href=&quot;#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="bd749ebde47823b6d49d60691dec84566b639bf8" translate="yes" xml:space="preserve">
          <source>The format string can reference parts of match using the following notation.</source>
          <target state="translated">格式字符串可以使用以下符号引用匹配的部分。</target>
        </trans-unit>
        <trans-unit id="2d3aec5d983c44f1af503ee811b2266d3dca8cd3" translate="yes" xml:space="preserve">
          <source>The format string has the following grammar:</source>
          <target state="translated">格式字符串的语法如下:</target>
        </trans-unit>
        <trans-unit id="0625c7ec1018d088678495be9b57d04b31498a03" translate="yes" xml:space="preserve">
          <source>The format string supports the formatting of array and nested array elements via the grouping format specifiers &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt;. Each matching pair of &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt; corresponds with a single array argument. The enclosed sub-format string is applied to individual array elements. The trailing portion of the sub-format string following the conversion specifier for the array element is interpreted as the array delimiter, and is therefore omitted following the last array element. The &lt;b&gt;%|&lt;/b&gt; specifier may be used to explicitly indicate the start of the delimiter, so that the preceding portion of the string will be included following the last array element. (See below for explicit examples.)</source>
          <target state="translated">格式字符串通过分组格式说明符&lt;b&gt;％（&lt;/b&gt;和&lt;b&gt;％）&lt;/b&gt;支持数组和嵌套数组元素的格式。&lt;b&gt;％（&lt;/b&gt;和&lt;b&gt;％）的&lt;/b&gt;每个匹配对都对应一个数组参数。附带的子格式字符串应用于单个数组元素。数组元素的转换说明符之后的子格式字符串的结尾部分被解释为数组定界符，因此在最后一个数组元素之后被省略。在&lt;b&gt;％|&lt;/b&gt;说明符可用于显式指示定界符的开始，以便字符串的前面部分将包含在最后一个数组元素之后。 （请参阅下面的显式示例。）</target>
        </trans-unit>
        <trans-unit id="693a71e5dd0ab926d97018418f98a27b3e174029" translate="yes" xml:space="preserve">
          <source>The format string used for this log call.</source>
          <target state="translated">本次日志调用使用的格式字符串。</target>
        </trans-unit>
        <trans-unit id="9fa2fc4abd1b83aca1055ee06f982cdb131c59e5" translate="yes" xml:space="preserve">
          <source>The formatting flag is applied individually to each value, for example:</source>
          <target state="translated">格式化标志被单独应用于每个值,例如。</target>
        </trans-unit>
        <trans-unit id="d26ac44ffe5a86909c11c81e0ef71d3888da5c4c" translate="yes" xml:space="preserve">
          <source>The forms of the</source>
          <target state="translated">的形式</target>
        </trans-unit>
        <trans-unit id="38e88fa7315be494a88a395eb056b9ace726e37c" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. Returns null if there is no Soundex representation for the string.</source>
          <target state="translated">包含Soundex结果的四个字符数组。如果字符串没有Soundex表示,则返回空值。</target>
        </trans-unit>
        <trans-unit id="0480c3df77ed33fc07e614d2d8de8fc045910624" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. The array has zero's in it if there is no Soundex representation for the string.</source>
          <target state="translated">包含Soundex结果的四个字符数组。如果字符串没有Soundex表示,则数组中为零。</target>
        </trans-unit>
        <trans-unit id="5766013bffb3825b0abbe1d083667aa11616b979" translate="yes" xml:space="preserve">
          <source>The fourth form, &lt;code&gt;goto case&lt;/code&gt;&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;, transfers to the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; with a matching &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">第四种形式， &lt;code&gt;goto case&lt;/code&gt; &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; &lt;code&gt;;&lt;/code&gt; ，转移到&lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;最内包围的&lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;具有匹配&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;的表达&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13efbc5e672643becc355867b63d8f22b9e474d7" translate="yes" xml:space="preserve">
          <source>The fourth version counts the number of elements in a range. It is an optimization for the third version: if the given range has the &lt;code&gt;length&lt;/code&gt; property the count is returned right away, otherwise performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) to walk the range.</source>
          <target state="translated">第四个版本计算范围内的元素数。这是对第三个版本的优化：如果给定范围具有 &lt;code&gt;length&lt;/code&gt; 属性，则立即返回计数，否则执行&amp;Omicron;（ &lt;code&gt;haystack.length&lt;/code&gt; ）遍历该范围。</target>
        </trans-unit>
        <trans-unit id="48edc0798b06f223cb1ddbda6fdb31f83f4e14ab" translate="yes" xml:space="preserve">
          <source>The fractional part of x.</source>
          <target state="translated">x的小数部分。</target>
        </trans-unit>
        <trans-unit id="afaeb9378608c5260a3259e8f02e82dbd938d6f1" translate="yes" xml:space="preserve">
          <source>The fractional seconds portion of the time.</source>
          <target state="translated">小数秒部分的时间。</target>
        </trans-unit>
        <trans-unit id="a033f1a65da2c07804aca3b53ca406684bb91d81" translate="yes" xml:space="preserve">
          <source>The free list is circular, with the last node pointing back to the first.</source>
          <target state="translated">自由列表是循环的,最后一个节点指向第一个节点。</target>
        </trans-unit>
        <trans-unit id="c4517bc5d244bf2185e9745bb334e09ef6af1ee0" translate="yes" xml:space="preserve">
          <source>The free tree has special handling of duplicates (a singly-linked list per node) in anticipation of large number of duplicates. Allocation time from the free tree is expected to be &amp;Omicron;(&lt;code&gt;log n&lt;/code&gt;) where &lt;code&gt;n&lt;/code&gt; is the number of distinct sizes (not total nodes) kept in the free tree.</source>
          <target state="translated">自由树对重复项有特殊处理（每个节点一个单链接的列表），因为预期会有大量重复项。从自由树分配的时间预计为〇（ &lt;code&gt;log n&lt;/code&gt; ），其中 &lt;code&gt;n&lt;/code&gt; 是在自由树中保留的不同大小（不是总节点）的数量。</target>
        </trans-unit>
        <trans-unit id="ee4d09c6e55b89fcf5b3563176298a96aa717ff4" translate="yes" xml:space="preserve">
          <source>The freelist is maintained in increasing address order, which makes coalescing easy.</source>
          <target state="translated">自由列表是按照地址顺序递增的方式来维护的,这使得聚合变得很容易。</target>
        </trans-unit>
        <trans-unit id="8fea8f11f99f1f8b366c244a4de1a614fd67b29c" translate="yes" xml:space="preserve">
          <source>The front element in the container</source>
          <target state="translated">容器中的前置元件</target>
        </trans-unit>
        <trans-unit id="13da137fb2ab48bf4928214ec4fc5ac7d9dd7e0b" translate="yes" xml:space="preserve">
          <source>The full URL to get/put</source>
          <target state="translated">获取/输入的完整URL</target>
        </trans-unit>
        <trans-unit id="bdda625bfb1430028e4b6006d0968612c21121d6" translate="yes" xml:space="preserve">
          <source>The full list of named character entities from the &lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5 Spec&lt;/a&gt; is supported except for the named entities which contain multiple code points. Below is a</source>
          <target state="translated">支持&lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5规范&lt;/a&gt;中命名字符实体的完整列表，但包含多个代码点的命名实体除外。下面是一个</target>
        </trans-unit>
        <trans-unit id="53abcf6f821b2e7ec7e516af58f09e5bd8d1aff5" translate="yes" xml:space="preserve">
          <source>The full module system</source>
          <target state="translated">完整的模块系统</target>
        </trans-unit>
        <trans-unit id="ee63124c4c066661e689e48b06ebee05399673e5" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the symbol.</source>
          <target state="translated">符号的全称。</target>
        </trans-unit>
        <trans-unit id="4d00150ca0468a4f7743a4f3a38c13aec942337c" translate="yes" xml:space="preserve">
          <source>The fully-qualified names of both types if the two type names are not the same, or the unqualified names of both types if the two type names are the same.</source>
          <target state="translated">如果两种类型名称不相同,则为两种类型的全限定名称;如果两种类型名称相同,则为两种类型的非限定名称。</target>
        </trans-unit>
        <trans-unit id="38a1580a58c3012db59e4a8a700c45c0c6b1674d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fd&lt;/code&gt; is added to the nested references of the newly created variable such that a closure is made for the variable when the address of &lt;code&gt;fd&lt;/code&gt; is taken.</source>
          <target state="translated">将函数 &lt;code&gt;fd&lt;/code&gt; 添加到新创建的变量的嵌套引用中，以便在获取 &lt;code&gt;fd&lt;/code&gt; 的地址时对该变量进行封闭。</target>
        </trans-unit>
        <trans-unit id="1bc8d00dffc62265a3b988178c4153a69f61f3ec" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;remove&lt;/code&gt; works on bidirectional ranges that have assignable lvalue elements. The moving strategy is (listed from fastest to slowest):</source>
          <target state="translated">该功能 &lt;code&gt;remove&lt;/code&gt; 对具有可分配左值元素的双向范围有效。移动策略（从最快到最慢列出）：</target>
        </trans-unit>
        <trans-unit id="dfdecb6a33548c2c3a57ed9788619ffcbcd64fcd" translate="yes" xml:space="preserve">
          <source>The function allocates memory if and only if it gets to the third stage of this algorithm.</source>
          <target state="translated">如果且仅当该函数到了该算法的第三阶段时,该函数才会分配内存。</target>
        </trans-unit>
        <trans-unit id="59d7ef7bccfe8628462077a719a53074c919f8fa" translate="yes" xml:space="preserve">
          <source>The function call operator, &lt;code&gt;()&lt;/code&gt;, can be overloaded by declaring a function named &lt;code&gt;opCall&lt;/code&gt;:</source>
          <target state="translated">可以通过声明一个名为 &lt;code&gt;opCall&lt;/code&gt; 的函数来重载函数调用运算符 &lt;code&gt;()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="75414fa30a8eeadba0f9df43d9a81faffe1eb302" translate="yes" xml:space="preserve">
          <source>The function declaration makes it clear what the inputs and outputs to the function are.</source>
          <target state="translated">函数声明要明确函数的输入和输出是什么。</target>
        </trans-unit>
        <trans-unit id="36bd72a87a6fb51210593d16c9d3850d26ad2813" translate="yes" xml:space="preserve">
          <source>The function generated tests if the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; passed belongs to this set or not. The result is to be used with string mixin. The intended usage area is aggressive optimization via meta programming in parser generators and the like.</source>
          <target state="translated">该函数生成的&lt;a href=&quot;#Code%20point&quot;&gt;代码&lt;/a&gt;将测试传递的代码点是否属于此集合。结果将与字符串mixin一起使用。预期的使用区域是通过解析器生成器等中的元编程进行的积极优化。</target>
        </trans-unit>
        <trans-unit id="98e31cd639a66b786829a51b07b196c9eb02f441" translate="yes" xml:space="preserve">
          <source>The function is doing something impure, so mark it as impure. If there's a purity error, return true.</source>
          <target state="translated">该函数正在做一些不纯洁的事情,所以将其标记为不纯洁。如果有纯度错误,返回true。</target>
        </trans-unit>
        <trans-unit id="78716a8e02a777fde55cd9f5bd9506b86f2cd433" translate="yes" xml:space="preserve">
          <source>The function is doing something that may allocate with the GC, so mark it as not nogc (not no-how).</source>
          <target state="translated">该函数正在做一些可能与GC分配的事情,所以标记为not nogc(不是no-how)。</target>
        </trans-unit>
        <trans-unit id="1582435911618910fd1cebd4a56e5bade73d2f42" translate="yes" xml:space="preserve">
          <source>The function is doing something unsafe, so mark it as unsafe. If there's a safe error, return true.</source>
          <target state="translated">该函数正在做一些不安全的事情,所以将其标记为不安全。如果出现安全错误,返回true。</target>
        </trans-unit>
        <trans-unit id="185793595bc4f7b5898c63f905d91abe291e2c5e" translate="yes" xml:space="preserve">
          <source>The function is explicitly annotated &lt;code&gt;@nogc&lt;/code&gt; because inference could fail, see &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;issue 17084&lt;/a&gt;.</source>
          <target state="translated">该函数已显式注释 &lt;code&gt;@nogc&lt;/code&gt; ,因为推断可能会失败，请参见&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;问题17084&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94377b90d447230e8a5ccf1a52d33d616f20136c" translate="yes" xml:space="preserve">
          <source>The function is intended to replace the hexadecimal literal strings starting with &lt;code&gt;'x'&lt;/code&gt;, which could be removed to simplify the core language.</source>
          <target state="translated">该函数旨在替换以 &lt;code&gt;'x'&lt;/code&gt; 开头的十六进制文字字符串，可以将其删除以简化核心语言。</target>
        </trans-unit>
        <trans-unit id="408608d2bfc199a6a551d83606a62872252fdf6d" translate="yes" xml:space="preserve">
          <source>The function overloads returning a string allocate their return values using the GC. The versions returning static arrays use pass-by-value for the return value, effectively avoiding dynamic allocation.</source>
          <target state="translated">返回字符串的函数重载使用GC分配其返回值。返回静态数组的版本对返回值使用逐值传递,有效地避免了动态分配。</target>
        </trans-unit>
        <trans-unit id="7b0e25cbd51eccc8cf3fde77bb9a906902973f49" translate="yes" xml:space="preserve">
          <source>The function parameter attributes &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;scope&lt;/code&gt; are used to track what happens to low-level pointers passed to functions. Such pointers include: raw pointers, arrays, &lt;code&gt;this&lt;/code&gt;, classes, &lt;code&gt;ref&lt;/code&gt; parameters, delegate/lazy parameters, and aggregates containing a pointer.</source>
          <target state="translated">函数参数属性 &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;scope&lt;/code&gt; 用于跟踪传递给函数的低级指针发生了什么。此类指针包括：原始指针，数组， &lt;code&gt;this&lt;/code&gt; ，类， &lt;code&gt;ref&lt;/code&gt; 参数，委托/惰性参数以及包含指针的聚合。</target>
        </trans-unit>
        <trans-unit id="6e994bfc1a839ed290d4129f0f5733e981d5373e" translate="yes" xml:space="preserve">
          <source>The function returns a range containing the consecutive reduced values. If there is more than one &lt;code&gt;fun&lt;/code&gt;, the element type will be &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt; std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; containing one element for each &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">该函数返回一个包含连续减少值的范围。如果有多个 &lt;code&gt;fun&lt;/code&gt; ，则元素类型将为&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt; std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;，每个 &lt;code&gt;fun&lt;/code&gt; 包含一个元素。</target>
        </trans-unit>
        <trans-unit id="f1de9581bb40aa0605e1d4f2b900b32c62cf6dcb" translate="yes" xml:space="preserve">
          <source>The function returns immediately, leaving the child process to execute in parallel with its parent. It is recommended to always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; unless the process was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag, as detailed in the documentation for &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">该函数立即返回，使子进程与其父进程并行执行。建议始终对返回的&lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;，除非已使用 &lt;code&gt;Config.detached&lt;/code&gt; 标志生成了该进程，如 &lt;code&gt;wait&lt;/code&gt; 文档中所述。</target>
        </trans-unit>
        <trans-unit id="d1462ec35dc456ac6ff3045ecdc8148b89412c36" translate="yes" xml:space="preserve">
          <source>The function source code must be available to the compiler. Functions which exist in the source code only as extern declarations cannot be executed in CTFE.</source>
          <target state="translated">函数的源代码必须提供给编译器。在源代码中仅作为外部声明存在的函数不能在CTFE中执行。</target>
        </trans-unit>
        <trans-unit id="c99c9ccaa6aadf1ddb21d118ac9a2b39a2936c1d" translate="yes" xml:space="preserve">
          <source>The function that wants to measure speed.</source>
          <target state="translated">想要测量速度的功能。</target>
        </trans-unit>
        <trans-unit id="411ac38391245e7bd9f2d61489a0679e909d3705" translate="yes" xml:space="preserve">
          <source>The function to become the base of the speed.</source>
          <target state="translated">的功能,成为速的基。</target>
        </trans-unit>
        <trans-unit id="ca30c519a6a156f76c6573e841573612bc2aad51" translate="yes" xml:space="preserve">
          <source>The function to execute.</source>
          <target state="translated">要执行的功能。</target>
        </trans-unit>
        <trans-unit id="38560d673ec14174a5201f65e942b10ff886f6eb" translate="yes" xml:space="preserve">
          <source>The function to execute. This may be the actual function passed by the user to spawn itself, or may be a wrapper function.</source>
          <target state="translated">要执行的功能。这可能是用户传递给自己的实际函数,也可能是一个包装函数。</target>
        </trans-unit>
        <trans-unit id="67a64604c4717ec6e34e3f3a6e53ee63c3039ae1" translate="yes" xml:space="preserve">
          <source>The function used to check if &lt;code&gt;addr&lt;/code&gt; is marked.</source>
          <target state="translated">该功能用于检查是否标记了 &lt;code&gt;addr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4a8105c562ae246a8ce7c12b0a3320ba9511dc7" translate="yes" xml:space="preserve">
          <source>The function used to generate the next time point in the range.</source>
          <target state="translated">用于生成范围内下一个时间点的函数。</target>
        </trans-unit>
        <trans-unit id="dc715bdc2551fef5137debdc9a1fe82c19568021" translate="yes" xml:space="preserve">
          <source>The function used to generate the time points of the range over the interval.</source>
          <target state="translated">用于在区间内生成范围的时间点的函数。</target>
        </trans-unit>
        <trans-unit id="f3d2158936e817ae5d4b5a34d016e49a32ca1146" translate="yes" xml:space="preserve">
          <source>The function will not return if any enclosing finally clause does a return, goto or throw that exits the finally clause.</source>
          <target state="translated">如果任何包围的final子句做了返回、goto或throw等退出final子句的操作,该函数将不会返回。</target>
        </trans-unit>
        <trans-unit id="46f3e02eaaa99bc9ca72c46c606ddf965d307189" translate="yes" xml:space="preserve">
          <source>The functionality closely follows the IEEE754-2008 standard for floating-point arithmetic, including the use of camelCase names rather than C99-style lower case names. All of these functions behave correctly when presented with an infinity or NaN.</source>
          <target state="translated">该功能严格遵循IEEE754-2008浮点运算标准,包括使用camelCase名称而不是C99式的小写名称。当出现无穷大或NaN时,所有这些函数都能正常工作。</target>
        </trans-unit>
        <trans-unit id="a8b49dde8278905e1da61afa2345291851916bc1" translate="yes" xml:space="preserve">
          <source>The functionally is based on &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;. LibCurl is licensed under an MIT/X derivative license.</source>
          <target state="translated">功能上基于&lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;。LibCurl是根据MIT / X衍生许可证许可的。</target>
        </trans-unit>
        <trans-unit id="2ff1dde920de616d6287f3db648daa34cd769c38" translate="yes" xml:space="preserve">
          <source>The functionally is based on &lt;a href=&quot;https://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;. LibCurl is licensed under an MIT/X derivative license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9193abd91f293a360c49af75182f625a029338" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#formatValue&quot;&gt;&lt;code&gt;formatValue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unformatValue&quot;&gt;&lt;code&gt;unformatValue&lt;/code&gt;&lt;/a&gt; are used for the plumbing.</source>
          <target state="translated">函数&lt;a href=&quot;#formatValue&quot;&gt; &lt;code&gt;formatValue&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unformatValue&quot;&gt; &lt;code&gt;unformatValue&lt;/code&gt; &lt;/a&gt;用于管道。</target>
        </trans-unit>
        <trans-unit id="09d84b61f63134826318f5b038f0d9e7c6a89164" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#multiwayMerge&quot;&gt;&lt;code&gt;multiwayMerge&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiwayUnion&quot;&gt;&lt;code&gt;multiwayUnion&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setDifference&quot;&gt;&lt;code&gt;setDifference&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setIntersection&quot;&gt;&lt;code&gt;setIntersection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setSymmetricDifference&quot;&gt;&lt;code&gt;setSymmetricDifference&lt;/code&gt;&lt;/a&gt; expect a range of sorted ranges as input.</source>
          <target state="translated">函数&lt;a href=&quot;#multiwayMerge&quot;&gt; &lt;code&gt;multiwayMerge&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#multiwayUnion&quot;&gt; &lt;code&gt;multiwayUnion&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setDifference&quot;&gt; &lt;code&gt;setDifference&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setIntersection&quot;&gt; &lt;code&gt;setIntersection&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setSymmetricDifference&quot;&gt; &lt;code&gt;setSymmetricDifference&lt;/code&gt; &lt;/a&gt;期望输入一定范围的排序范围。</target>
        </trans-unit>
        <trans-unit id="4fde7de03cdc04e15dde2a51577db6987e675d9f" translate="yes" xml:space="preserve">
          <source>The functions can use &lt;code&gt;@trusted&lt;/code&gt; instead of &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">这些函数可以使用 &lt;code&gt;@trusted&lt;/code&gt; 而不是 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30a160975f83d4201f4fd65daf1113007bc807be" translate="yes" xml:space="preserve">
          <source>The gamma and related functions, and the error function are crucial for mathematical statistics. The Bessel and related functions arise in problems involving wave propagation (especially in optics). Other major categories of special functions include the elliptic integrals (related to the arc length of an ellipse), and the hypergeometric functions.</source>
          <target state="translated">伽马函数和相关函数以及误差函数对数理统计至关重要。Bessel函数和相关函数出现在涉及波传播的问题中(特别是在光学领域)。其他主要类别的特殊函数包括椭圆积分(与椭圆的弧长有关)和超几何函数。</target>
        </trans-unit>
        <trans-unit id="447281d1324337b15482dcfc848c6a78d28256cf" translate="yes" xml:space="preserve">
          <source>The gapped similarity at the current match length (initially 1, grows with each call to &lt;code&gt;popFront&lt;/code&gt;).</source>
          <target state="translated">当前匹配长度（最初为1，随着对 &lt;code&gt;popFront&lt;/code&gt; 的每次调用都增加）的相似度。</target>
        </trans-unit>
        <trans-unit id="05176e7bf5bf611688f908ea258370d40d6b3039" translate="yes" xml:space="preserve">
          <source>The garbage collector calls the destructor function when the object is deleted. The syntax is:</source>
          <target state="translated">当对象被删除时,垃圾回收器会调用destructor函数。语法为:</target>
        </trans-unit>
        <trans-unit id="8162594fc1e13b54530b98ac255177e2a9d2ab78" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan non-pointer fields for GC pointers.</source>
          <target state="translated">垃圾回收器不会扫描非指针字段的GC指针。</target>
        </trans-unit>
        <trans-unit id="bace0715c82c9b149257399e18cc90537b20fbf1" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not created by the D Thread interface. Nor does it scan the data segments of other DLLs, etc.</source>
          <target state="translated">垃圾回收器不会扫描非D线程接口创建的线程堆栈。也不扫描其他DLL的数据段等。</target>
        </trans-unit>
        <trans-unit id="679912e5f590d3f8f03034fbcabdaff8e29c8cba" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not registered with the D runtime, nor does it scan the data segments of shared libraries that aren't registered with the D runtime.</source>
          <target state="translated">垃圾回收器不会扫描未在D运行时注册的线程堆栈,也不会扫描未在D运行时注册的共享库的数据段。</target>
        </trans-unit>
        <trans-unit id="248f5f617e65210251e2aceaf897cfac6784a5ad" translate="yes" xml:space="preserve">
          <source>The garbage collector is not guaranteed to run the destructor for all unreferenced objects. Furthermore, the order in which the garbage collector calls destructors for unreferenced objects is not specified. This means that when the garbage collector calls a destructor for an object of a class that has members which are references to garbage collected objects, those references may no longer be valid. This means that destructors cannot reference sub objects. This rule does not apply to auto objects or objects destructed with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, as the destructor is not being run by the garbage collector, meaning all references are valid.</source>
          <target state="translated">不能保证垃圾收集器为所有未引用的对象运行析构函数。此外，未指定垃圾收集器为未引用的对象调用析构函数的顺序。这意味着，当垃圾回收器为某个类的对象调用析构函数时，该类的对象具有对垃圾回收对象的引用，这些引用可能不再有效。这意味着析构函数无法引用子对象。该规则不适用于自动对象或使用&lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; 破坏的&lt;/a&gt;对象，因为析构函数不是由垃圾收集器运行的，这意味着所有引用都是有效的。</target>
        </trans-unit>
        <trans-unit id="7ed0a2988d2028482af5b70f4886f714e874cd68" translate="yes" xml:space="preserve">
          <source>The garbage collector looks for roots in:</source>
          <target state="translated">垃圾收集器寻找根在。</target>
        </trans-unit>
        <trans-unit id="a61608c994e8531817d927f16b69cb4ec2652687" translate="yes" xml:space="preserve">
          <source>The general usage guideline is to keep regex complexity on the side of simplicity, as its capabilities reside in purely character-level manipulation. As such it's ill-suited for tasks involving higher level invariants like matching an integer number &lt;em&gt;bounded&lt;/em&gt; in an [a,b] interval. Checks of this sort of are better addressed by additional post-processing.</source>
          <target state="translated">通用用法指南是将正则表达式的复杂性放在简单性的一边，因为它的功能仅存在于字符级操作中。因此，它不适合涉及更高级别不变性的任务，例如匹配以[a，b]区间为&lt;em&gt;界&lt;/em&gt;的整数。通过额外的后处理可以更好地解决此类检查。</target>
        </trans-unit>
        <trans-unit id="587ae2153e1cd24d01fed6ce88e2ec32ff8c2014" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;opAssign&lt;/code&gt; function has the following signature:</source>
          <target state="translated">生成的 &lt;code&gt;opAssign&lt;/code&gt; 函数具有以下签名：</target>
        </trans-unit>
        <trans-unit id="e40de6a32624f7e6b5379975d2cd46fa3f2fa94f" translate="yes" xml:space="preserve">
          <source>The generated links to D symbols are relative if they have the same root package as the module being documented. If not, their URLs are preceded by a &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; macro, where &lt;code&gt;pkg&lt;/code&gt; is the root package of the symbol being linked to. Links to D symbols are generated with a &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; macro after the module name. So the generated URL for &lt;code&gt;[Object]&lt;/code&gt; in the above example is as if you had written:</source>
          <target state="translated">如果生成的D符号链接与所记录的模块具有相同的根包，则它们是相对的。如果不是，则它们的URL前面带有 &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; 宏，其中 &lt;code&gt;pkg&lt;/code&gt; 是链接到的符号的根包。在模块名称后使用 &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; 宏生成指向D符号的链接。因此，上面示例中为 &lt;code&gt;[Object]&lt;/code&gt; 生成的URL就像您已经编写了：</target>
        </trans-unit>
        <trans-unit id="b65a1da736509a9381ee000758f5d850e508e3e2" translate="yes" xml:space="preserve">
          <source>The generated links to D symbols are relative if they have the same root package as the module being documented. If not, their URLs are preceeded by a &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; macro, where &lt;code&gt;pkg&lt;/code&gt; is the root package of the symbol being linked to. Links to D symbols are generated with a &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; macro after the module name. So the generated URL for &lt;code&gt;[Object]&lt;/code&gt; in the above example is as if you had written:</source>
          <target state="translated">如果所生成的D符号链接与所记录的模块具有相同的根包，则它们是相对的。如果不是，则它们的URL以 &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; 宏开头，其中 &lt;code&gt;pkg&lt;/code&gt; 是链接到的符号的根包。在模块名称后使用 &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; 宏生成D符号的链接。因此，上面示例中为 &lt;code&gt;[Object]&lt;/code&gt; 生成的URL 就像您已经编写了：</target>
        </trans-unit>
        <trans-unit id="adc505580a3e3a25fed9b9c63e6f0745b68f08fa" translate="yes" xml:space="preserve">
          <source>The getopt module implements a &lt;code&gt;getopt&lt;/code&gt; function, which adheres to the POSIX syntax for command line options. GNU extensions are supported in the form of long options introduced by a double dash (&quot;--&quot;). Support for bundling of command line options, as was the case with the more traditional single-letter approach, is provided but not enabled by default.</source>
          <target state="translated">getopt模块实现了 &lt;code&gt;getopt&lt;/code&gt; 函数，该函数遵循POSIX语法的命令行选项。以双破折号（&amp;ldquo;-&amp;rdquo;）引入的长选项形式支持GNU扩展。与更传统的单字母方法一样，提供了对命令行选项捆绑的支持，但默认情况下未启用。</target>
        </trans-unit>
        <trans-unit id="38436bf13581d96cda14b3d712a9839eef76ade6" translate="yes" xml:space="preserve">
          <source>The given HMAC token is compared with the expected token using the &lt;code&gt;==&lt;/code&gt; string comparison, which returns &lt;code&gt;false&lt;/code&gt; as soon as the first wrong element is found. If a wrong element is found, then a rejection is sent back to the sender.</source>
          <target state="translated">使用 &lt;code&gt;==&lt;/code&gt; 字符串比较将给定的HMAC令牌与期望的令牌进行比较，一旦发现第一个错误的元素，它将返回 &lt;code&gt;false&lt;/code&gt; 。如果发现错误的元素，则拒绝被发送回发件人。</target>
        </trans-unit>
        <trans-unit id="262b74b064f7ed4973ae2acf3633f01634ced6b1" translate="yes" xml:space="preserve">
          <source>The given array exposed to a standard D array.</source>
          <target state="translated">给定的数组暴露在一个标准的D数组中。</target>
        </trans-unit>
        <trans-unit id="8bc950de5698dccabc99a10c52424998aec0c7a6" translate="yes" xml:space="preserve">
          <source>The given array of &lt;code&gt;char&lt;/code&gt; or random-access range of &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;ubyte&lt;/code&gt; is expected to be in the format specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; section 3.3 with the grammar rule</source>
          <target state="translated">给定的 &lt;code&gt;char&lt;/code&gt; 数组或 &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;ubyte&lt;/code&gt; 的随机访问范围应采用&lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;第3.3节中指定的格式，并带有语法规则</target>
        </trans-unit>
        <trans-unit id="8e4b65ce211d4254d0e9eed3b78782f1021e49fe" translate="yes" xml:space="preserve">
          <source>The given array of &lt;code&gt;char&lt;/code&gt; or random-access range of &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;ubyte&lt;/code&gt; is expected to be in the format specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; section 3.3 with the grammar rule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12501a73a540c686a37f4823a66a820dabde2f39" translate="yes" xml:space="preserve">
          <source>The glob pattern</source>
          <target state="translated">球状图案</target>
        </trans-unit>
        <trans-unit id="496ff2fc921b0a5cf99d9a4227ed4bf96d90c632" translate="yes" xml:space="preserve">
          <source>The grapheme cluster represents a horizontally segmentable unit of text, consisting of some grapheme base (which may consist of a Korean syllable) together with any number of nonspacing marks applied to it.</source>
          <target state="translated">字词群代表一个可水平分割的文本单位,由一些字词基数(可能由一个韩语音节组成)和任何数量的非间隔标记组成。</target>
        </trans-unit>
        <trans-unit id="37af0a5e629675000a6dfa7103d088d3ddd62dac" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the given arguments.</source>
          <target state="translated">给定参数的最大公除数。</target>
        </trans-unit>
        <trans-unit id="8b3e1c284ef7e8df3ea6a61551c667aeed265141" translate="yes" xml:space="preserve">
          <source>The hack for bugzilla 4820 case is still questionable. Perhaps would have to handle a delegate expression with 'null' context properly in front-end.</source>
          <target state="translated">针对bugzilla 4820案例的破解还是值得商榷的。也许要在前端正确处理一个带有'null'上下文的delegate表达式。</target>
        </trans-unit>
        <trans-unit id="38f5b63c8a583d4d295cf756159c50490e54c13e" translate="yes" xml:space="preserve">
          <source>The handle to an array is specified by naming the array, as in p, s or a:</source>
          <target state="translated">数组的句柄是通过命名数组来指定的,比如p、s或a。</target>
        </trans-unit>
        <trans-unit id="06b9457ea3f4fa7b2cb019db8602c7584d3ac0a3" translate="yes" xml:space="preserve">
          <source>The handler to run if the expression throwed.</source>
          <target state="translated">如果表达式被抛出,要运行的处理程序。</target>
        </trans-unit>
        <trans-unit id="bb782c4330787617d4fce577aae35ea8ac20fb68" translate="yes" xml:space="preserve">
          <source>The hash function RIPEMD-160</source>
          <target state="translated">哈希函数RIPEMD-160。</target>
        </trans-unit>
        <trans-unit id="1a548321e03af2d162f5b6fb8172e4e75095c3be" translate="yes" xml:space="preserve">
          <source>The hashBlockSize and digestSize are in bits. However, it's likely easier to simply use the convenience aliases: SHA1, SHA224, SHA256, SHA384, SHA512, SHA512_224 and SHA512_256.</source>
          <target state="translated">hashBlockSize和digestSize的单位是比特。然而,简单地使用方便的别名可能更容易。SHA1,SHA224,SHA256,SHA384,SHA512,SHA512_224 和 SHA512_256.</target>
        </trans-unit>
        <trans-unit id="71c022924374f373de8247c9ee1154db2efdf429" translate="yes" xml:space="preserve">
          <source>The header can also be left empty if the input contains a header row and all columns should be iterated. The header from the input can always be accessed from the &lt;code&gt;header&lt;/code&gt; field.</source>
          <target state="translated">如果输入包含标题行并且所有列都应进行迭代，则标题也可以保留为空。输入的标题始终可以在 &lt;code&gt;header&lt;/code&gt; 字段中访问。</target>
        </trans-unit>
        <trans-unit id="23806478590a3d73211d3f9cfeab9ec2c30f42f5" translate="yes" xml:space="preserve">
          <source>The header of &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; for tutorials on ranges.</source>
          <target state="translated">有关范围教程的&lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;的标头。</target>
        </trans-unit>
        <trans-unit id="a73e614d706951342951d40aeeb01697424cadb7" translate="yes" xml:space="preserve">
          <source>The headers read from a successful response.</source>
          <target state="translated">从成功的响应中读取的标题。</target>
        </trans-unit>
        <trans-unit id="1ba658c4da138d5aa67105b1d7cc27b3cfde13e6" translate="yes" xml:space="preserve">
          <source>The highlighting macros start with &lt;code&gt;DDOC_&lt;/code&gt;. They control the formatting of individual parts of the presentation.</source>
          <target state="translated">突出显示宏以 &lt;code&gt;DDOC_&lt;/code&gt; 开头。它们控制演示文稿各个部分的格式。</target>
        </trans-unit>
        <trans-unit id="7850bd95e95bab4d64e3c6d1c398982e32639f37" translate="yes" xml:space="preserve">
          <source>The hook to wrap</source>
          <target state="translated">缠绕的钩子</target>
        </trans-unit>
        <trans-unit id="8f90c58c05f3db77fe848d30cab0798e3f6b00e3" translate="yes" xml:space="preserve">
          <source>The hook's members are looked up statically in a Design by Introspection manner and are all optional. The table below illustrates the members that a hook type may define and their influence over the behavior of the &lt;code&gt;Checked&lt;/code&gt; type using it. In the table, &lt;code&gt;hook&lt;/code&gt; is an alias for &lt;code&gt;Hook&lt;/code&gt; if the type &lt;code&gt;Hook&lt;/code&gt; does not introduce any state, or an object of type &lt;code&gt;Hook&lt;/code&gt; otherwise.</source>
          <target state="translated">挂钩的成员以&amp;ldquo;通过自省设计&amp;rdquo;的方式静态查找，并且都是可选的。下表说明了挂钩类型可以定义的成员，以及它们对使用它的 &lt;code&gt;Checked&lt;/code&gt; 类型的行为的影响。在表中， &lt;code&gt;hook&lt;/code&gt; 是一个别名 &lt;code&gt;Hook&lt;/code&gt; 如果类型 &lt;code&gt;Hook&lt;/code&gt; 不引入任何状态，或类型的对象 &lt;code&gt;Hook&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="c351eba3d013581a191d3a885a49968be29fd469" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的小时设置为一天中的小时。</target>
        </trans-unit>
        <trans-unit id="66136c779346b036c2def79ac7f0dfb73004b7bb" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">将此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;的小时设置为一天中的小时。</target>
        </trans-unit>
        <trans-unit id="a6a4e60304c50d5e98aa115b78722f98c55537a4" translate="yes" xml:space="preserve">
          <source>The hour portion of the time;</source>
          <target state="translated">小时部分的时间。</target>
        </trans-unit>
        <trans-unit id="ae576aa7ec4954f0a9eb6186b74173801d58e446" translate="yes" xml:space="preserve">
          <source>The hours to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的小时设置为的小时。</target>
        </trans-unit>
        <trans-unit id="dc9947af90e8e00095ff57d0a5f1abb3e951dbc5" translate="yes" xml:space="preserve">
          <source>The idea being these are compatible with C structs.</source>
          <target state="translated">我们的想法是这些都与C结构兼容。</target>
        </trans-unit>
        <trans-unit id="1355f078be2cb8440aa75f9a09689cdae9f0217b" translate="yes" xml:space="preserve">
          <source>The idea of a contract is simple - it's just an expression that must evaluate to true. If it does not, the contract is broken, and by definition, the program has a bug in it. Contracts form part of the specification for a program, moving it from the documentation to the code itself. And as every programmer knows, documentation tends to be incomplete, out of date, wrong, or non-existent. Moving the contracts into the code makes them verifiable against the program.</source>
          <target state="translated">契约的概念很简单--它只是一个必须求值为真的表达式。如果它不为真,那么合同就被破坏了,根据定义,程序中存在一个错误。契约构成了程序规范的一部分,把它从文档转移到代码本身。而每个程序员都知道,文档往往是不完整的、过时的、错误的或不存在的。将合同移到代码中,使得它们可以对照程序进行验证。</target>
        </trans-unit>
        <trans-unit id="f6757769fd791ee402dbfe3e43c1aa10845db21c" translate="yes" xml:space="preserve">
          <source>The identity operator &lt;code&gt;is&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">身份操作 &lt;code&gt;is&lt;/code&gt; 不能超载。</target>
        </trans-unit>
        <trans-unit id="1a6dd428d8629e97cfcace7f86b78f24c85c36c4" translate="yes" xml:space="preserve">
          <source>The imaginary part of the number.</source>
          <target state="translated">数的虚部。</target>
        </trans-unit>
        <trans-unit id="1ac7f7e21c56da918de0900c242a59f862e477cf" translate="yes" xml:space="preserve">
          <source>The immutable applies to the type within the following parentheses. So, while &lt;code&gt;s&lt;/code&gt; can be assigned new values, the contents of &lt;code&gt;s[]&lt;/code&gt; cannot be:</source>
          <target state="translated">不可变适用于以下括号内的类型。因此，虽然可以为 &lt;code&gt;s&lt;/code&gt; 分配新值，但 &lt;code&gt;s[]&lt;/code&gt; 的内容不能为：</target>
        </trans-unit>
        <trans-unit id="b076480db50c8a69f17ceccfb8074a2146342dec" translate="yes" xml:space="preserve">
          <source>The immutable array.</source>
          <target state="translated">不变的数组。</target>
        </trans-unit>
        <trans-unit id="d4da7504d70ac035ecf312cd124c3e9b875475b7" translate="yes" xml:space="preserve">
          <source>The implementation exploits properties of types and operations to minimize additional work.</source>
          <target state="translated">该实现利用类型和操作的属性来减少额外的工作。</target>
        </trans-unit>
        <trans-unit id="94333a362aef71aa736007c1291437cf4a5d5675" translate="yes" xml:space="preserve">
          <source>The implementation guarantees that all threads simultaneously calling initOnce with the same var argument block until var is fully initialized. All side-effects of init are globally visible afterwards.</source>
          <target state="translated">该实现保证了所有线程同时用同一个var参数块调用initOnce,直到var被完全初始化。之后init的所有副作用都是全局可见的。</target>
        </trans-unit>
        <trans-unit id="2e2b0dbd8c35c5a1541392596f49b59f590b7d4b" translate="yes" xml:space="preserve">
          <source>The implementation is available as a public member.</source>
          <target state="translated">实施是作为公共成员提供的。</target>
        </trans-unit>
        <trans-unit id="61a0fdac2dd135b95e81234f7a42c96423c9eb12" translate="yes" xml:space="preserve">
          <source>The implementation is based on the pseudocode in Fig. 4 of the paper &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&quot;Efﬁcient Computation of Gapped Substring Kernels on Large Alphabets&quot;&lt;/a&gt; by Rousu et al., with additional algorithmic and systems-level optimizations.</source>
          <target state="translated">该实现基于Rousu等人在论文&lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&amp;ldquo;大字母上的空子字符串核的有效计算&amp;rdquo;&lt;/a&gt;中图4中的伪代码，并进行了其他算法和系统级优化。</target>
        </trans-unit>
        <trans-unit id="c3c79f00444b1a8f6b8dd0d247228e66376bb4b5" translate="yes" xml:space="preserve">
          <source>The implementation may handle the case of the first</source>
          <target state="translated">本实施例可以对第一种情况进行处理。</target>
        </trans-unit>
        <trans-unit id="3f62d25116bc0232c42a3fb96db6f12be7eef293" translate="yes" xml:space="preserve">
          <source>The implementations of all predefined macros are implementation-defined. The reference implementation's macro definitions can be found &lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">所有预定义宏的实现都是实现定义的。参考实现的宏定义可以在&lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;此处&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="ce44ea558c01cd44607fe7bfdaba1c3db8da7616" translate="yes" xml:space="preserve">
          <source>The implicit conversions of built-in scalar types can be explicitly represented by using function call syntax. For example:</source>
          <target state="translated">内置标量类型的隐式转换可以通过使用函数调用语法来显式表示。例如:</target>
        </trans-unit>
        <trans-unit id="8663ba6f06eeb782a371db21df4acbb1af0c444b" translate="yes" xml:space="preserve">
          <source>The importance of component programming (properties, signals and slots, etc)</source>
          <target state="translated">组件编程的重要性(属性、信号和插槽等)。</target>
        </trans-unit>
        <trans-unit id="c5712d89ed6b6b5326913e6635b003b614c7a5c4" translate="yes" xml:space="preserve">
          <source>The imports are looked up to satisfy any unresolved symbols at that scope. Imported symbols may hide symbols from outer scopes.</source>
          <target state="translated">导入的符号会被查找以满足该作用域的任何未解决的符号。导入的符号可以隐藏外部作用域的符号。</target>
        </trans-unit>
        <trans-unit id="28c93ed79edf143da68c0f3519f73741ba79046d" translate="yes" xml:space="preserve">
          <source>The index of the element that should be in sorted position after the function is done.</source>
          <target state="translated">函数完成后,应该在排序位置的元素的索引。</target>
        </trans-unit>
        <trans-unit id="7b8cbc4deacf04830f34d38905f8ffd00330c728" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the maximum in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 最大值的第一次遇到的索引。如果 &lt;code&gt;range&lt;/code&gt; 为空，则返回-1。</target>
        </trans-unit>
        <trans-unit id="1a84eb9548c30b563a95a1fcfb270886bdd52d9e" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the minimum element in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 最小元素的首次遇到的索引。如果 &lt;code&gt;range&lt;/code&gt; 为空，则返回-1。</target>
        </trans-unit>
        <trans-unit id="33a0038a0fcaf095d5057aead72f83713739fc8b" translate="yes" xml:space="preserve">
          <source>The index of the last occurrence of &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is not found, then &lt;code&gt;-1&lt;/code&gt; is returned. The &lt;code&gt;startIdx&lt;/code&gt; slices &lt;code&gt;s&lt;/code&gt; in the following way &lt;code&gt;s[0 .. startIdx]&lt;/code&gt;. &lt;code&gt;startIdx&lt;/code&gt; represents a codeunit index in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 中最后一次出现的索引。如果找不到 &lt;code&gt;c&lt;/code&gt; ，则返回 &lt;code&gt;-1&lt;/code&gt; 。所述 &lt;code&gt;startIdx&lt;/code&gt; 切片 &lt;code&gt;s&lt;/code&gt; 通过以下方式 &lt;code&gt;s[0 .. startIdx]&lt;/code&gt; 。 &lt;code&gt;startIdx&lt;/code&gt; 表示 &lt;code&gt;s&lt;/code&gt; 中的代码单位索引。</target>
        </trans-unit>
        <trans-unit id="c2e5baf3f6abe9b83760e32cef1632ac5f67ea47" translate="yes" xml:space="preserve">
          <source>The index of the pivot for partitioning, must be less than &lt;code&gt;r.length&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;r.length&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">枢轴进行分区的索引，必须小于 &lt;code&gt;r.length&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 如果 &lt;code&gt;r.length&lt;/code&gt; 是 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4e8d4da6e42c851e373823697d10ed8eae4adf3" translate="yes" xml:space="preserve">
          <source>The index of the type among &lt;code&gt;AllowedTypesParam&lt;/code&gt;, zero-based.</source>
          <target state="translated">在 &lt;code&gt;AllowedTypesParam&lt;/code&gt; 中的类型的索引，从零开始。</target>
        </trans-unit>
        <trans-unit id="6f4d7d5591308d1987c179c707865f7263b2522b" translate="yes" xml:space="preserve">
          <source>The index of this archive member within the archive.</source>
          <target state="translated">该档案成员在档案馆内的索引。</target>
        </trans-unit>
        <trans-unit id="6bca3732803cf0cac5bd51a87fe2e1e77dd22909" translate="yes" xml:space="preserve">
          <source>The index of this archive member within the archive. Set this to a different value for reordering the members of an archive.</source>
          <target state="translated">此存档成员在存档中的索引。将其设置为不同的值,以便重新排列归档成员的顺序。</target>
        </trans-unit>
        <trans-unit id="9b3efb64d9c8c3a8462cc2762d6a92ac26c24dcc" translate="yes" xml:space="preserve">
          <source>The index starts at &lt;code&gt;start&lt;/code&gt; and is incremented by one on every iteration.</source>
          <target state="translated">该索引从开始处 &lt;code&gt;start&lt;/code&gt; 并在每次迭代时增加1。</target>
        </trans-unit>
        <trans-unit id="86fe7372a9779ec608c645bda74b3617bd2f68d1" translate="yes" xml:space="preserve">
          <source>The index to start reading from (instead of starting at the front). If index is a pointer, then it is updated to the index after the bytes read. The overloads with index are only available if &lt;code&gt;hasSlicing!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">从其开始读取的索引（而不是从最前面开始）。如果index是指针，则在读取字节后将其更新为索引。仅当 &lt;code&gt;hasSlicing!R&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时,带索引的重载才可用。</target>
        </trans-unit>
        <trans-unit id="3b0d5226f25947ab0cd2172717539dced2cf1ca0" translate="yes" xml:space="preserve">
          <source>The index to start writing to. If index is a pointer, then it is updated to the index after the bytes read.</source>
          <target state="translated">要开始写入的索引。如果index是指针,则在读取字节后更新为索引。</target>
        </trans-unit>
        <trans-unit id="4dd9df4788f29de75fb62d913aea700844f5ed25" translate="yes" xml:space="preserve">
          <source>The index.</source>
          <target state="translated">该指数。</target>
        </trans-unit>
        <trans-unit id="f9ffb074b766c5938ff8b7357963618eaf462bcb" translate="yes" xml:space="preserve">
          <source>The indexed range. If rs consists of only one range, the return type is an alias of that range's type.</source>
          <target state="translated">索引的范围。如果rs只包含一个范围,返回类型是该范围类型的别名。</target>
        </trans-unit>
        <trans-unit id="619765ffdaa0071187a8f77abd362e7dda091d2c" translate="yes" xml:space="preserve">
          <source>The inference is done by determining if the function body follows the rules of the particular attribute.</source>
          <target state="translated">推理的方法是判断函数体是否遵循特定属性的规则。</target>
        </trans-unit>
        <trans-unit id="44470f7ce0660d4121c31a312118ccb100fd5b58" translate="yes" xml:space="preserve">
          <source>The initial count for the semaphore.</source>
          <target state="translated">旗语的初始计数。</target>
        </trans-unit>
        <trans-unit id="8c9e853ca955ba71f49e1626fd9e59d97a172b5c" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with its predicates converted to an equivalent single predicate.</source>
          <target state="translated">初始范围包装为 &lt;code&gt;SortedRange&lt;/code&gt; ，其谓词转换为等效的单个谓词。</target>
        </trans-unit>
        <trans-unit id="47bf51e4f2c2e73e2360a982a3dcd26ed977c3bb" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt;.</source>
          <target state="translated">初始范围包装成 &lt;code&gt;SortedRange&lt;/code&gt; 与谓词 &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae187df68ec47146dca1715d3e3c373579beb355" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;binaryFun!less&lt;/code&gt;.</source>
          <target state="translated">最初的范围包装成 &lt;code&gt;SortedRange&lt;/code&gt; 与谓词 &lt;code&gt;binaryFun!less&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80d1aad4ad1e534532ce1e885f47d8eb7c78b11f" translate="yes" xml:space="preserve">
          <source>The initial size of each buffer. If &lt;code&gt;next&lt;/code&gt; takes its array by reference, it may resize the buffers.</source>
          <target state="translated">每个缓冲区的初始大小。如果 &lt;code&gt;next&lt;/code&gt; 通过引用获取其数组，则可以调整缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="06bcd9aed8f8362952958dfe41f57dcc25fe7b79" translate="yes" xml:space="preserve">
          <source>The initialization expression for the type.</source>
          <target state="translated">类型的初始化表达式。</target>
        </trans-unit>
        <trans-unit id="ef4a846934e7e3a7c6fada2c58784a67e938dc53" translate="yes" xml:space="preserve">
          <source>The initializer for a manifest constant is evaluated using compile time function evaluation.</source>
          <target state="translated">清单常量的初始化器使用编译时函数评估。</target>
        </trans-unit>
        <trans-unit id="4866f78cdd0450f210abe845a0008dc25126137c" translate="yes" xml:space="preserve">
          <source>The initializer for a non-local immutable declaration must be evaluatable at compile time:</source>
          <target state="translated">非本地不可变声明的初始化器在编译时必须是可评估的。</target>
        </trans-unit>
        <trans-unit id="c3ff76d4230d39e88bec6a17e3fa23c6428b640f" translate="yes" xml:space="preserve">
          <source>The initializer for a non-static local immutable declaration is evaluated at run time:</source>
          <target state="translated">非静态局部不可变声明的初始化器在运行时被评估。</target>
        </trans-unit>
        <trans-unit id="8f27ed7b518832024e3d6a15cbe377f8e47f39ab" translate="yes" xml:space="preserve">
          <source>The initializer for a static variable must be evaluatable at compile time, and they are initialized upon the start of the thread (or the start of the program for &lt;code&gt;__gshared&lt;/code&gt;). There are no static constructors or static destructors for static local variables.</source>
          <target state="translated">静态变量的初始化程序必须在编译时可求值，并且它们在线程启动时（或 &lt;code&gt;__gshared&lt;/code&gt; 的程序启动时）进行初始化。静态局部变量没有静态构造函数或静态析构函数。</target>
        </trans-unit>
        <trans-unit id="56398784568892251b9dcc7b9a121fdad0fc1209" translate="yes" xml:space="preserve">
          <source>The inout forms a wildcard that stands in for any of mutable, const, immutable, inout, or inout const. When the function is called, the inout of the return type is changed to whatever the mutable, const, immutable, inout, or inout const status of the argument type to the parameter inout was.</source>
          <target state="translated">inout形成一个通配符,代表mutable、const、immutable、inout或inout const中的任何一种。当函数被调用时,返回类型的inout会被改变为参数inout的参数类型的mutable、const、immutable、inout或inout const状态。</target>
        </trans-unit>
        <trans-unit id="47e39fe3c6321bc48452728017762afb10e65931" translate="yes" xml:space="preserve">
          <source>The inout in the return type is then rewritten to be the inout matched qualifiers:</source>
          <target state="translated">然后将返回类型中的inout改写为inout匹配的限定符。</target>
        </trans-unit>
        <trans-unit id="894e5ecc4ff73411cc66384f9e949e3263a04d5e" translate="yes" xml:space="preserve">
          <source>The input data is too long (There's no guarantee the first part of the data is valid)</source>
          <target state="translated">输入的数据太长(不能保证数据的第一部分是有效的</target>
        </trans-unit>
        <trans-unit id="37721cea9b7ff856cc5a0d72da55bfcef8342f2c" translate="yes" xml:space="preserve">
          <source>The input elements. If there are less elements than the specified length of the static array, the rest of it is default-initialized. If there are more than specified, the first elements up to the specified length are used.</source>
          <target state="translated">输入的元素。如果元素数量少于静态数组的指定长度,则其余元素默认为初始化。如果元素数量超过指定长度,则使用指定长度以内的第一个元素。</target>
        </trans-unit>
        <trans-unit id="4b42c37fa56b476654b6a22d064c38aab28dcdfc" translate="yes" xml:space="preserve">
          <source>The input is returned.</source>
          <target state="translated">输入的内容会被返回。</target>
        </trans-unit>
        <trans-unit id="fb78206bd59b576b51359aab6e37d1fe64780809" translate="yes" xml:space="preserve">
          <source>The input may have originated from &lt;code&gt;U[]&lt;/code&gt; or &lt;code&gt;immutable(U)[]&lt;/code&gt;, so it may be actually shared or not. Returning an unqualified affix may result in race conditions, whereas returning a &lt;code&gt;shared&lt;/code&gt; affix may result in inadvertent sharing of mutable thread-local data across multiple threads. So the returned type is conservatively &lt;code&gt;ref const&lt;/code&gt;.</source>
          <target state="translated">输入可能源自 &lt;code&gt;U[]&lt;/code&gt; 或 &lt;code&gt;immutable(U)[]&lt;/code&gt; ，因此它可能实际上是共享的或不是共享的。返回不合格的词缀可能会导致竞争状况，而返回 &lt;code&gt;shared&lt;/code&gt; 词缀可能会导致在多个线程之间无意间共享可变线程局部数据。因此，返回的类型保守地为 &lt;code&gt;ref const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab7802e78bae021ec9f77bb19cdbefc46c138fde" translate="yes" xml:space="preserve">
          <source>The input range being passed through.</source>
          <target state="translated">被传递的输入范围。</target>
        </trans-unit>
        <trans-unit id="c0225247a221452c012002a0bc4a76423e77fd6b" translate="yes" xml:space="preserve">
          <source>The input range must not be empty.</source>
          <target state="translated">输入范围不能为空。</target>
        </trans-unit>
        <trans-unit id="786f6ba29b51fa6818ec422c83e424f885e18b3d" translate="yes" xml:space="preserve">
          <source>The input range set up to parse one line at a time into a record tuple.</source>
          <target state="translated">设置的输入范围,每次将一行解析为一个记录元组。</target>
        </trans-unit>
        <trans-unit id="4c83aa414329fad18718e6fa488a3b442df22d1b" translate="yes" xml:space="preserve">
          <source>The input range to check.</source>
          <target state="translated">要检查的输入范围。</target>
        </trans-unit>
        <trans-unit id="4dd476cc824391e088069cbddbb750e2eef61f40" translate="yes" xml:space="preserve">
          <source>The input text string s is formed into a paragraph by breaking it up into a sequence of lines, delineated by \n, such that the number of columns is not exceeded on each line. The last line is terminated with a \n.</source>
          <target state="translated">输入的文本字符串s被分成一系列的行,用&quot;\n &quot;来划分,形成一个段落,这样每行的列数就不会超过。最后一行用一个\n结束。</target>
        </trans-unit>
        <trans-unit id="93424042a1977cf3da75467c8916a2a7eddec8a8" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point.</source>
          <target state="translated">该函数的输入必须是一个有效的代码点。</target>
        </trans-unit>
        <trans-unit id="44b890bb7f50ef5e291775cda4bfde289081100b" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point. This is enforced by the function's in-contract.</source>
          <target state="translated">该函数的输入必须是一个有效的代码点。这是由函数的契约中强制执行的。</target>
        </trans-unit>
        <trans-unit id="c67615e6ffc16592b049d69cbff653f9fe85f2f3" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by DocumentParser's in contract.</source>
          <target state="translated">该函数的输入必须是有效的XML。这是由DocumentParser在合同中强制执行的。</target>
        </trans-unit>
        <trans-unit id="4bb4a25af5340195ef134855f808d1711e956a9a" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by the function's in contract.</source>
          <target state="translated">该函数的输入必须是有效的XML。这是由函数的in contract强制执行的。</target>
        </trans-unit>
        <trans-unit id="323b8c9102f07dbc17e6156b32bdb18e8608c8b5" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded.</source>
          <target state="translated">该函数的输入必须是有效的编码。</target>
        </trans-unit>
        <trans-unit id="d4a76f46d20716b9c53fd13981afb49f20693850" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded. This is enforced by the function's in-contract.</source>
          <target state="translated">该函数的输入必须是有效的编码。这是由函数的契约中强制执行的。</target>
        </trans-unit>
        <trans-unit id="52bc0973d7be9145a7f9c10120f8ee1522aa2643" translate="yes" xml:space="preserve">
          <source>The instantiated template.</source>
          <target state="translated">实例化的模板。</target>
        </trans-unit>
        <trans-unit id="caa69ad6f2cd188077c7e982e4e11f26b6cdf5a4" translate="yes" xml:space="preserve">
          <source>The integral and floating type sizes should be considered as minimums. Algorithms should be designed to continue to work properly if the type size increases.</source>
          <target state="translated">积分型和浮动型的大小应被视为最小值。如果字体大小增加,算法的设计应能继续正常工作。</target>
        </trans-unit>
        <trans-unit id="bfaa650f603081ed06b593e3b4e5c458c3260e28" translate="yes" xml:space="preserve">
          <source>The integral is</source>
          <target state="translated">积分是</target>
        </trans-unit>
        <trans-unit id="d07416a83435e11558037f6cda4d47f4d33fe73e" translate="yes" xml:space="preserve">
          <source>The integral is evaluated by a continued fraction expansion or, when b * x is small, by a power series.</source>
          <target state="translated">积分通过持续的分数展开来评估,或者当b*x较小时,通过幂级数来评估。</target>
        </trans-unit>
        <trans-unit id="4502af3e801c133bfaf7193afbee4f48610ef881" translate="yes" xml:space="preserve">
          <source>The integral type to convert the first &lt;code&gt;T.sizeof&lt;/code&gt; bytes to.</source>
          <target state="translated">将第一个 &lt;code&gt;T.sizeof&lt;/code&gt; 字节转换为的整数类型。</target>
        </trans-unit>
        <trans-unit id="51127e20341aada7d08b3905487eaefce7dd284a" translate="yes" xml:space="preserve">
          <source>The integral value to return the absolute value of.</source>
          <target state="translated">返回绝对值的积分值。</target>
        </trans-unit>
        <trans-unit id="54f14afee26358f556f656a70b82a5a8901a5411" translate="yes" xml:space="preserve">
          <source>The intent of this function is to provide an allocation-less way to call a C function using a D slice. The function internally allocates a buffer if needed, but frees it on exit.</source>
          <target state="translated">这个函数的目的是提供一种无需分配的方式来使用D片调用C函数。如果需要的话,这个函数会在内部分配一个缓冲区,但在退出时释放它。</target>
        </trans-unit>
        <trans-unit id="aa32bace5214cedb20ff140ded35da64a7980bf0" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opDollar!i&lt;/code&gt; should return the length of the array along its &lt;code&gt;i&lt;/code&gt;'th dimension, or a user-defined object representing the end of the array along that dimension, that is understood by &lt;code&gt;opSlice&lt;/code&gt; and &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">目的是 &lt;code&gt;opDollar!i&lt;/code&gt; 应该返回数组在其第 &lt;code&gt;i&lt;/code&gt; 个维度上的长度，或者是一个用户定义的对象，该对象代表该数组在该维度上的末尾，这是 &lt;code&gt;opSlice&lt;/code&gt; 和 &lt;code&gt;opIndex&lt;/code&gt; 可以理解的。</target>
        </trans-unit>
        <trans-unit id="7ed569bfceb9bac4ccf7954c87c2cc7395c8f770" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opSlice!i&lt;/code&gt; should return a user-defined object that represents an interval of indices along the &lt;code&gt;i&lt;/code&gt;'th dimension of the array. This object is then passed to &lt;code&gt;opIndex&lt;/code&gt; to perform the actual slicing operation. If only one-dimensional slicing is desired, &lt;code&gt;opSlice&lt;/code&gt; may be declared without the compile-time parameter &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">目的是 &lt;code&gt;opSlice!i&lt;/code&gt; 应该返回一个用户定义的对象，该对象表示沿着数组第 &lt;code&gt;i&lt;/code&gt; 个维度的索引间隔。然后将此对象传递给 &lt;code&gt;opIndex&lt;/code&gt; 以执行实际的切片操作。如果只需要一 &lt;code&gt;opSlice&lt;/code&gt; 片，则可以声明opSlice而不使用编译时参数 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf6066b8690ba4fa47007edd6d83a6b71547ae35" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism defined above (back up to a comment remarkably similar to this one) is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">上文所定义的虚拟表机制的接口(回溯到与此非常相似的评论)目前被认为是试验性的。该接口可能会以不兼容的方式改变。如果这对你来说是个问题,请不要在这个时候使用这个接口。</target>
        </trans-unit>
        <trans-unit id="6250bca0465ce111dcc80945b2149f4168412958" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">虚拟表格机制的接口目前被认为是试验性的。该接口可能会以不兼容的方式改变。如果这对你来说是个问题,请不要在这个时候使用这个接口。</target>
        </trans-unit>
        <trans-unit id="8d2e293904f5395fe014c79325ed5dca620f1643" translate="yes" xml:space="preserve">
          <source>The interface to this is found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc/gcinterface.d&lt;/a&gt;.</source>
          <target state="translated">可以在Druntime的&lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc / gcinterface.d中&lt;/a&gt;找到此接口。</target>
        </trans-unit>
        <trans-unit id="70ba1bd45dceaea5f1daa9192d952a7efda4639e" translate="yes" xml:space="preserve">
          <source>The interval that this &lt;code&gt;IntervalRange&lt;/code&gt; currently covers.</source>
          <target state="translated">此 &lt;code&gt;IntervalRange&lt;/code&gt; 当前覆盖的间隔。</target>
        </trans-unit>
        <trans-unit id="b1b8b6efa0b6085f29ca02a503001474bd874de3" translate="yes" xml:space="preserve">
          <source>The interval that this range currently covers.</source>
          <target state="translated">该范围当前所覆盖的区间。</target>
        </trans-unit>
        <trans-unit id="99ed0102a151474509c2f50c80c6a8fd9abde664" translate="yes" xml:space="preserve">
          <source>The interval to check against this interval.</source>
          <target state="translated">对照此区间进行检查的区间。</target>
        </trans-unit>
        <trans-unit id="e9709ec7167a6294d35ca54cb0db7b761b6bd4bb" translate="yes" xml:space="preserve">
          <source>The interval to check for against this interval.</source>
          <target state="translated">根据这个区间来检查的区间。</target>
        </trans-unit>
        <trans-unit id="c93a05b54bf8db01ca44894e1b6574520f0f25cd" translate="yes" xml:space="preserve">
          <source>The interval to check for inclusion in this interval.</source>
          <target state="translated">要检查是否包含在这个区间内的区间。</target>
        </trans-unit>
        <trans-unit id="7af5c560175f78550b8fa16520f8bceb2478bd1e" translate="yes" xml:space="preserve">
          <source>The interval to check for intersection with this interval.</source>
          <target state="translated">要检查的区间与这个区间是否有交集。</target>
        </trans-unit>
        <trans-unit id="758e2e8521e78873ca075d9d09978b3e79b23a85" translate="yes" xml:space="preserve">
          <source>The interval to check whether its adjecent to this interval.</source>
          <target state="translated">检查其是否与该区间相邻的区间。</target>
        </trans-unit>
        <trans-unit id="ec8c525abec811d6fafbe3af351dcf7c933228a1" translate="yes" xml:space="preserve">
          <source>The interval to create a span together with this interval.</source>
          <target state="translated">要和这个区间一起创建一个跨度。</target>
        </trans-unit>
        <trans-unit id="ffa8edd7fe1af9b169dddd595e3c77f03e44244d" translate="yes" xml:space="preserve">
          <source>The interval to intersect with this interval.</source>
          <target state="translated">与这个区间相交的区间。</target>
        </trans-unit>
        <trans-unit id="450cf7fb1673450b11d1c6b4254176a2488c262a" translate="yes" xml:space="preserve">
          <source>The interval to merge with this interval.</source>
          <target state="translated">要与这个区间合并的区间。</target>
        </trans-unit>
        <trans-unit id="6dd87bff580699a73195a62f3312346bd1ffd61d" translate="yes" xml:space="preserve">
          <source>The invariant can be checked with an &lt;code&gt;assert()&lt;/code&gt; expression:</source>
          <target state="translated">可以使用 &lt;code&gt;assert()&lt;/code&gt; 表达式检查不变量：</target>
        </trans-unit>
        <trans-unit id="3d1bc4f7a43b5f2dfbf63c4d45e4f9ad2787305a" translate="yes" xml:space="preserve">
          <source>The invariant is a contract saying that the &lt;code&gt;assert&lt;/code&gt;s must hold true. The invariant is checked when a class or struct constructor completes, and at the start of the class or struct destructor. For public or exported functions, the order of execution is:</source>
          <target state="translated">不变式是一个约定，要求 &lt;code&gt;assert&lt;/code&gt; 必须成立。当类或结构构造函数完成时以及在类或结构析构函数的开始处检查不变量。对于公共或导出功能，执行顺序为：</target>
        </trans-unit>
        <trans-unit id="db3237f4b413cd2d050f8846cd6a9cf6b11b5b9b" translate="yes" xml:space="preserve">
          <source>The invariant is in the form of a &lt;code&gt;const&lt;/code&gt; member function. The invariant is defined to</source>
          <target state="translated">不变式为 &lt;code&gt;const&lt;/code&gt; 成员函数的形式。不变量定义为</target>
        </trans-unit>
        <trans-unit id="4013ec9a85db3fcab85de75b73cedbcdfe5398d3" translate="yes" xml:space="preserve">
          <source>The invariant is not checked if the class or struct is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">如果使用默认的 &lt;code&gt;.init&lt;/code&gt; 值隐式构造了类或结构，则不检查不变量。</target>
        </trans-unit>
        <trans-unit id="b006ea59664dde8c9966b0ba37f0d9de49867d7b" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the class instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">如果使用默认的 &lt;code&gt;.init&lt;/code&gt; 值隐式构造了类实例，则不需要保留不变式。</target>
        </trans-unit>
        <trans-unit id="90d62a6c20b7727a896f3c7231e895bd333ec112" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the struct instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">如果使用默认的 &lt;code&gt;.init&lt;/code&gt; 值隐式构造struct实例，则不需要保留不变式。</target>
        </trans-unit>
        <trans-unit id="ae2f7e963cff5e59d45cd356ad6b537b6f9c2bbf" translate="yes" xml:space="preserve">
          <source>The isMarked callback function.</source>
          <target state="translated">isMarked回调函数。</target>
        </trans-unit>
        <trans-unit id="b53b0d99e692dbe7d750a9e3a8ec485970e1fe1a" translate="yes" xml:space="preserve">
          <source>The issue remains of calling &lt;code&gt;a.deallocate(b)&lt;/code&gt; from a different thread than the one that allocated &lt;code&gt;b&lt;/code&gt;. It follows that both threads must have access to the same instance &lt;code&gt;a&lt;/code&gt; of the respective allocator type. By definition of D, this is possible only if &lt;code&gt;a&lt;/code&gt; has the &lt;code&gt;shared&lt;/code&gt; qualifier. It follows that the allocator type must implement &lt;code&gt;allocate&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; as &lt;code&gt;shared&lt;/code&gt; methods. That way, the allocator commits to allowing usable &lt;code&gt;shared&lt;/code&gt; instances.</source>
          <target state="translated">问题仍然是从与分配 &lt;code&gt;b&lt;/code&gt; 的线程不同的线程中调用 &lt;code&gt;a.deallocate(b)&lt;/code&gt; 。因此，两个线程必须有权访问各自分配器类型的相同实例 &lt;code&gt;a&lt;/code&gt; 。根据D的定义，仅当 &lt;code&gt;a&lt;/code&gt; 具有 &lt;code&gt;shared&lt;/code&gt; 限定符时才有可能。因此，分配器类型必须实现 &lt;code&gt;allocate&lt;/code&gt; 和 &lt;code&gt;deallocate&lt;/code&gt; 作为 &lt;code&gt;shared&lt;/code&gt; 方法。这样，分配器将致力于允许可用的 &lt;code&gt;shared&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="f906deb3cb569875f4c530161fd80e93b9be746c" translate="yes" xml:space="preserve">
          <source>The key is the IANA time zone database name, and the value is a list of Windows time zone names which are close (usually only one, but it could be multiple).</source>
          <target state="translated">键是IANA时区数据库名称,值是与之接近的Windows时区名称列表(通常只有一个,但也可能是多个)。</target>
        </trans-unit>
        <trans-unit id="0cdd5bd88b6b5b8af271fba7af0cd3f24ac411a0" translate="yes" xml:space="preserve">
          <source>The key is the Windows time zone name, and the value is a list of IANA TZ database names which are close (currently only ever one, but it allows for multiple in case it's ever necessary).</source>
          <target state="translated">键是Windows时区名称,值是与之接近的IANA TZ数据库名称列表(目前只有一个,但它允许多个,以备不时之需)。</target>
        </trans-unit>
        <trans-unit id="07021616652b4190834cc6f5cd3d6a99828ab34d" translate="yes" xml:space="preserve">
          <source>The key.</source>
          <target state="translated">关键。</target>
        </trans-unit>
        <trans-unit id="a80046e2f9e469e161e9b64d7a84ab6bec7ee185" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;do&lt;/code&gt; can be used to announce the function body. Although any number of pre or post contracts of any form may follow each other, &lt;code&gt;do&lt;/code&gt; is required only when the last contract before the body is a block statement. (Before the acceptance of &lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003&lt;/a&gt;, the keyword &lt;code&gt;body&lt;/code&gt; was required instead of &lt;code&gt;do&lt;/code&gt;, and may still be encountered in old code bases. In the long term, &lt;code&gt;body&lt;/code&gt; may be deprecated, but for now it's allowed both as a keyword in this context and as an identifier elsewhere, although &lt;code&gt;do&lt;/code&gt; is preferred.)</source>
          <target state="translated">关键字 &lt;code&gt;do&lt;/code&gt; 可以用来声明功能主体。尽管可以以任意形式签订任意数量的合同， &lt;code&gt;do&lt;/code&gt; 只有在主体之前的最后一个合同为整体声明时，才需要这样做。（在接受&lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003&lt;/a&gt;之前，关键字 &lt;code&gt;body&lt;/code&gt; 是必需的，而不是 &lt;code&gt;do&lt;/code&gt; ，并且可能在旧代码库中仍然会遇到。从长远来看， &lt;code&gt;body&lt;/code&gt; 可能已被弃用，但就目前而言，它既可以用作关键字，也可以用作的标识符别处，尽管 &lt;code&gt;do&lt;/code&gt; 是优选的。）</target>
        </trans-unit>
        <trans-unit id="d0cf199fa5ede60a30e00df7068d936c5578eb01" translate="yes" xml:space="preserve">
          <source>The kind of pragma it is determined by the</source>
          <target state="translated">Pragma的种类是由以下因素决定的</target>
        </trans-unit>
        <trans-unit id="8c29b92f234fc529a35e51b203804649a01ac419" translate="yes" xml:space="preserve">
          <source>The lambda function arguments must not have a template instantiation as an explicit argument type. Any other argument types (basic, user-defined, template) are supported.</source>
          <target state="translated">lambda函数的参数必须没有模板实例作为显式参数类型。支持任何其他参数类型(基本的,用户定义的,模板的)。</target>
        </trans-unit>
        <trans-unit id="bdcf91e0f4f606e17a112c301f88ad8c5b2c10fe" translate="yes" xml:space="preserve">
          <source>The lambda function body must contain a single expression (no return statement) which contains only numeric values, manifest constants, enum values, function arguments and function calls. If the expression contains local variables or return statements, the function is considered incomparable.</source>
          <target state="translated">lambda函数体必须包含一个单一的表达式(没有返回语句),它只包含数值、显式常量、枚举值、函数参数和函数调用。如果表达式包含局部变量或返回语句,则该函数被认为是不可比较的。</target>
        </trans-unit>
        <trans-unit id="95be9f6bb557ebac60c617f8309a121bd86960bc" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;所在月份的最后一天。</target>
        </trans-unit>
        <trans-unit id="7a278dbcde6702c093900cb5053e8bf5709be9d8" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;所在月份的最后一天。</target>
        </trans-unit>
        <trans-unit id="49136c9e4ea103b38fd972475d00bbb19f727989" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;所在月份的最后一天。</target>
        </trans-unit>
        <trans-unit id="a7a9289af76d268aef34222393a4318b6b13e368" translate="yes" xml:space="preserve">
          <source>The last element in the container</source>
          <target state="translated">容器中的最后一个元素</target>
        </trans-unit>
        <trans-unit id="6a4a00d2337afbe6c2df52717b98e8e13215bd50" translate="yes" xml:space="preserve">
          <source>The last element of the array.</source>
          <target state="translated">数组的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="9093baea1e3cf86fea0c4e3a6b9e58ab2a97f5a2" translate="yes" xml:space="preserve">
          <source>The last modification time in DosFileFormat.</source>
          <target state="translated">DosFileFormat中的最后一次修改时间。</target>
        </trans-unit>
        <trans-unit id="bdc0ac79d31e7752c2d29a6d8b9bf43609b17c83" translate="yes" xml:space="preserve">
          <source>The last parameter is passed in EAX rather than being pushed on the stack if the following conditions are met:</source>
          <target state="translated">如果满足以下条件,最后一个参数以EAX形式传递,而不是在堆栈上推送。</target>
        </trans-unit>
        <trans-unit id="746b4bdff136b3fa913bf1eeb63d7355bf56ba56" translate="yes" xml:space="preserve">
          <source>The last template parameter if it's a &lt;code&gt;TemplateTupleParameter&lt;/code&gt;</source>
          <target state="translated">最后一个模板参数（如果是 &lt;code&gt;TemplateTupleParameter&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="81aad1de98ee0f65f497fb989a25778e1871d9df" translate="yes" xml:space="preserve">
          <source>The lazy initializer value</source>
          <target state="translated">懒惰初始化值</target>
        </trans-unit>
        <trans-unit id="ea4b5c8a99ea43d9dec4f2b203a2486705eaedf1" translate="yes" xml:space="preserve">
          <source>The lazy variadic delegate solution is preferable to using a lazy variadic array, because each array index would evaluate every element:</source>
          <target state="translated">懒惰变量委托方案优于使用懒惰变量数组,因为每个数组索引会评估每个元素。</target>
        </trans-unit>
        <trans-unit id="421c4166a84b43c53a129a72090df266fc5436fb" translate="yes" xml:space="preserve">
          <source>The least significant bit in any &lt;code&gt;size_t&lt;/code&gt; unit is the starting bit of this unit, and the most significant bit is the last bit of this unit. Therefore, passing e.g. an array of &lt;code&gt;int&lt;/code&gt;s may result in a different &lt;code&gt;BitArray&lt;/code&gt; depending on the processor's endianness.</source>
          <target state="translated">任何 &lt;code&gt;size_t&lt;/code&gt; 单位中的最低有效位都是该单元的起始位，最高有效位是该单元的最后一位。因此，根据处理器的字节序，传递例如 &lt;code&gt;int&lt;/code&gt; 的数组可能会导致不同的 &lt;code&gt;BitArray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eeb9274b7abe5ec5313e249b7496b6be61a66b8b" translate="yes" xml:space="preserve">
          <source>The left operand of the &lt;code&gt;,&lt;/code&gt; is evaluated, then the right operand is evaluated. The type of the expression is the type of the right operand, and the result is the result of the right operand. Using the result of comma expressions isn't allowed.</source>
          <target state="translated">的左操作数 &lt;code&gt;,&lt;/code&gt; 进行评估，然后在右边的操作数进行评估。表达式的类型是右操作数的类型，结果是右操作数的结果。不允许使用逗号表达式的结果。</target>
        </trans-unit>
        <trans-unit id="f0716ee491b6b3f2e07375f7797e5c102ad33bdc" translate="yes" xml:space="preserve">
          <source>The left-hand side (or sole) argument</source>
          <target state="translated">左侧(或唯一)论点</target>
        </trans-unit>
        <trans-unit id="4d310cf569bfdf7161ed54cffc976e1b48e7851c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">比较的左侧（ &lt;code&gt;Lhs&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="204d5f370e11576f0fecb8929fdcdb88b117af5c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;T&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">比较的左侧（ &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="4fefd353c917f9a3bb60b52cf3d51cddee41a3f3" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for equality</source>
          <target state="translated">平等比较的左手边</target>
        </trans-unit>
        <trans-unit id="2b109cf29bece1affa9b23e640454252b8ecd16d" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for ordering</source>
          <target state="translated">左侧的比较,用于订购</target>
        </trans-unit>
        <trans-unit id="ae7fc7c90c99a250cd16f28bd7d7dbc3b81e86a8" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator</source>
          <target state="translated">操作员的左侧</target>
        </trans-unit>
        <trans-unit id="b4517c6bf6d758579387be92cded7d53dd545722" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">运算符的左侧（ &lt;code&gt;Lhs&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="1d155e4a7561179c70fb7012ae70744e878991c7" translate="yes" xml:space="preserve">
          <source>The left-hand side operand</source>
          <target state="translated">左手边的操作数</target>
        </trans-unit>
        <trans-unit id="56ecf39f32678f6ba12fdb543c053bc2a2538cfe" translate="yes" xml:space="preserve">
          <source>The left-hand side operand (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">左侧操作数（ &lt;code&gt;Lhs&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="fdc93a0d76b637886498906e463f3074234e7249" translate="yes" xml:space="preserve">
          <source>The leftmost side of the inheritance graph of the interfaces all share their vptrs, this is the single inheritance model. Every time the inheritance graph forks (for multiple inheritance) a new vptr is created and stored in the class' instance. Every time a virtual method is overridden, a new vtbl[] must be created with the updated method pointers in it.</source>
          <target state="translated">继承图最左边的接口都共享它们的vptr,这就是单继承模型。每当继承图分叉时(对于多重继承),就会创建一个新的vptr,并存储在类的实例中。每当一个虚拟方法被重写时,必须创建一个新的vtbl[],里面有更新的方法指针。</target>
        </trans-unit>
        <trans-unit id="f8ab85ff43a9b405f7f858dd6bd44661050bcbfb" translate="yes" xml:space="preserve">
          <source>The leftover portion of &lt;code&gt;tgt&lt;/code&gt; after all elements from &lt;code&gt;src&lt;/code&gt; have been moved.</source>
          <target state="translated">来自 &lt;code&gt;src&lt;/code&gt; 的所有元素移动后， &lt;code&gt;tgt&lt;/code&gt; 的剩余部分。</target>
        </trans-unit>
        <trans-unit id="ff1f6ec0205e886692fcbf4cdbd24c49883d76fd" translate="yes" xml:space="preserve">
          <source>The leftover portions of the two ranges after one or the other of the ranges have been exhausted.</source>
          <target state="translated">两个范围中的一个或另一个范围用完后剩余的部分。</target>
        </trans-unit>
        <trans-unit id="4aa5bf288555be6562c9b8eb71a2ee00b9edbaea" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">使用此运算符的&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="06d117fb1568b3c185b1dd70cf5e4111bec8c49d" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">使用此运算符的&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="31c5da3679aa5d6d97a971e899c7a8329e3f0d92" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">使用此运算符的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="1d00a55c762fc066020331efbb630b4cfc23721c" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">使用此运算符的&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="e029991ebf163a2ec03f499fc47cd21941b26f69" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator are</source>
          <target state="translated">使用此运算符的 &lt;code&gt;Duration&lt;/code&gt; 的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="2131ddc8b843bbfb7a2f56781e6183f4a90599d7" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">使用此运算符重载的 &lt;code&gt;Duration&lt;/code&gt; 的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="5584f88d5b275ee008fabf19cf9bf9477c6ef1e2" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator are</source>
          <target state="translated">使用此运算符的 &lt;code&gt;TickDuration&lt;/code&gt; 的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="c5479006c238183b17f8e4535d66092bdb92a1fe" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">使用此运算符重载的 &lt;code&gt;TickDuration&lt;/code&gt; 的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="0bd23cc00d282f158f381c5c9ffe519dc3f30f3b" translate="yes" xml:space="preserve">
          <source>The length dimension(s) of the resulting array</source>
          <target state="translated">所得数组的长度维度</target>
        </trans-unit>
        <trans-unit id="44d89bfdd05d1a58a582eeedae0d9a14e3912d91" translate="yes" xml:space="preserve">
          <source>The length of a Base64 encoding of an array of the given length.</source>
          <target state="translated">给定长度的数组的Base64编码的长度。</target>
        </trans-unit>
        <trans-unit id="a5db64910ec8c3458fc1370fda6dd6afe4df6242" translate="yes" xml:space="preserve">
          <source>The length of the Base64 encoding.</source>
          <target state="translated">Base64编码的长度。</target>
        </trans-unit>
        <trans-unit id="a6c0235529e0d9db5d811993877bcc8428ae8800" translate="yes" xml:space="preserve">
          <source>The length of the decoded string corresponding to a Base64 encoding of length sourceLength.</source>
          <target state="translated">对应于长度为 sourceLength 的 Base64 编码的解码字符串的长度。</target>
        </trans-unit>
        <trans-unit id="11a141a49e0a68aaa17cb7bd6222ca0a80676913" translate="yes" xml:space="preserve">
          <source>The length of the initial segment of &lt;code&gt;r&lt;/code&gt; to sort.</source>
          <target state="translated">要排序的 &lt;code&gt;r&lt;/code&gt; 的初始段的长度。</target>
        </trans-unit>
        <trans-unit id="79633e883a28c37fc7cd1efc3c868307222fbc17" translate="yes" xml:space="preserve">
          <source>The length of the resulting range is the sum of all lengths of the ranges passed as input. This means that all elements (duplicates included) are transferred to the resulting range.</source>
          <target state="translated">生成的范围的长度是作为输入的所有范围的长度之和。这意味着所有的元素(包括重复的元素)都会被转移到结果范围中。</target>
        </trans-unit>
        <trans-unit id="e1ae840eb910889a7516866d4d199999a725e819" translate="yes" xml:space="preserve">
          <source>The length of the token is known to be 40 characters long due to its format, so the attacker first sends &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt;, then &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt;, and so on.</source>
          <target state="translated">由于令牌的格式，令牌的长度已知为40个字符，因此攻击者首先发送 &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt; ，然后发送 &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="1987089f20ee0b5d2ec2f8112d140a36df239f5b" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined.</source>
          <target state="translated">定义插座选项的级别。</target>
        </trans-unit>
        <trans-unit id="b86bd023c662d4e208c258be711aadc0b1b2efae" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined:</source>
          <target state="translated">定义插座选项的级别。</target>
        </trans-unit>
        <trans-unit id="2ae0654a2a0ebe273a0d01c5f266e55c0eaa1eb7" translate="yes" xml:space="preserve">
          <source>The lexical analysis is independent of the syntax parsing and the semantic analysis. The lexical analyzer splits the source text up into tokens. The lexical grammar describes the syntax of these tokens. The grammar is designed to be suitable for high speed scanning and to make it easy to write a correct scanner. It has a minimum of special case rules and there is only one phase of translation.</source>
          <target state="translated">词法分析独立于语法解析和语义分析。词法分析器将源文本分割成标记。词法语法描述这些标记的语法。该语法的设计是为了适合高速扫描,并使其易于编写正确的扫描器。它的特例规则最少,而且只有一个翻译阶段。</target>
        </trans-unit>
        <trans-unit id="f491d891c138db3f9bceff46473b495e216f49dc" translate="yes" xml:space="preserve">
          <source>The lexical analysis is independent of the syntax parsing and the semantic analysis. The lexical analyzer splits the source text up into tokens. The lexical grammar describes the syntax of those tokens. The grammar is designed to be suitable for high speed scanning and to make it easy to write a correct scanner for it. It has a minimum of special case rules and there is only one phase of translation.</source>
          <target state="translated">词法分析独立于语法解析和语义分析。词法分析器将源文本分割成标记。词法语法描述这些标记的语法。该语法的设计是为了适合高速扫描,并使其易于编写正确的扫描器。它有最少的特殊情况规则,而且只有一个翻译阶段。</target>
        </trans-unit>
        <trans-unit id="64fc62f1647f32635083b06c594d00bb08d6c211" translate="yes" xml:space="preserve">
          <source>The lexical order of the attributes &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;scope&lt;/code&gt; is not significant.</source>
          <target state="translated">属性 &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;scope&lt;/code&gt; 的词汇顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="ecb003b0d2de026222073a3d8a4296c476e97462" translate="yes" xml:space="preserve">
          <source>The lifetime of a Borrowed or Readonly pointer value starts when it is assigned a value from an Owner or another Borrowed pointer, and ends at the last read of that value.</source>
          <target state="translated">一个Borrowed或Readonly指针值的寿命从它被从一个Owner或另一个Borrowed指针分配一个值开始,到该值的最后一次读取结束。</target>
        </trans-unit>
        <trans-unit id="f68c7b698966b101a1a595982c2044cc2a404192" translate="yes" xml:space="preserve">
          <source>The line number information from where the call originates</source>
          <target state="translated">呼叫发起地的线路号码信息。</target>
        </trans-unit>
        <trans-unit id="630ea807f4230ab332463ca98ac961bf9f44e6d5" translate="yes" xml:space="preserve">
          <source>The line number of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">D源代码的行号,对应的错误是从哪里抛出的。</target>
        </trans-unit>
        <trans-unit id="229e0a2bdd93317a19e4a68e09629b3b6f154aca" translate="yes" xml:space="preserve">
          <source>The line number of the caller.</source>
          <target state="translated">呼叫者的线路号。</target>
        </trans-unit>
        <trans-unit id="0ad55de99f59d99a8ffdf4bac1fdfeed484559cb" translate="yes" xml:space="preserve">
          <source>The line number on which this error occurred.</source>
          <target state="translated">发生此错误的行号。</target>
        </trans-unit>
        <trans-unit id="b99341808eb5c2aeef537e3bc3ba23e7d2391ae4" translate="yes" xml:space="preserve">
          <source>The line number that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">如果抛出&lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; ,&lt;/a&gt;它将列出的行号。</target>
        </trans-unit>
        <trans-unit id="f269870f6d1360520fe00512e2c2e3c4c0c50b6e" translate="yes" xml:space="preserve">
          <source>The line number where the exception occurred.</source>
          <target state="translated">发生异常的行号。</target>
        </trans-unit>
        <trans-unit id="f737b0208cdb15cf160156fb11b96cdbc64efed4" translate="yes" xml:space="preserve">
          <source>The line terminator (&lt;code&gt;'\n'&lt;/code&gt; by default) is part of the string read (it could be missing in the last line of the file). Several types are supported for &lt;code&gt;line&lt;/code&gt;, and the behavior of &lt;code&gt;lines&lt;/code&gt; changes accordingly:</source>
          <target state="translated">行终止符（默认为 &lt;code&gt;'\n'&lt;/code&gt; ）是读取的字符串的一部分（文件的最后一行可能会丢失）。几种类型都支持 &lt;code&gt;line&lt;/code&gt; 和行为 &lt;code&gt;lines&lt;/code&gt; 相应变化：</target>
        </trans-unit>
        <trans-unit id="4223574eefbbf292923ac805daa2d742c2ceff1c" translate="yes" xml:space="preserve">
          <source>The line that was read, including the line terminator character.</source>
          <target state="translated">读取的行,包括行结束符。</target>
        </trans-unit>
        <trans-unit id="0c791857d998bbf0bb74dbde8821e8c09defc3d6" translate="yes" xml:space="preserve">
          <source>The line where the error occurred.</source>
          <target state="translated">发生错误的线路。</target>
        </trans-unit>
        <trans-unit id="5ba806293f71618709ac5ca5570d100d47098201" translate="yes" xml:space="preserve">
          <source>The line where the error occurred. Defaults to &lt;code&gt;__LINE__&lt;/code&gt;.</source>
          <target state="translated">发生错误的行。默认为 &lt;code&gt;__LINE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9ec5dcfd170a3e54aa2b0486e8b3a659ecba856" translate="yes" xml:space="preserve">
          <source>The linkage form &lt;code&gt;extern (C++, &lt;/code&gt;</source>
          <target state="translated">链接形式 &lt;code&gt;extern (C++, &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a68509fefd64796f7d1a07f49a259470873e621" translate="yes" xml:space="preserve">
          <source>The linkage is recognized on all platforms but will issue a compile error if it is used on a platform where Objective-C support is not available. This allows to easily hide Objective-C declarations from platforms where it is not available using the &lt;a href=&quot;version#version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; statement, without resorting to string mixins or other workarounds.</source>
          <target state="translated">在所有平台上都可以识别该链接，但是如果在没有Objective-C支持的平台上使用该链接，则会发出编译错误。这允许使用&lt;a href=&quot;version#version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt;语句轻松从无法使用的平台隐藏Objective-C声明，而无需使用字符串混合或其他变通方法。</target>
        </trans-unit>
        <trans-unit id="ee2dc34efb622f40653a49dbfe76ceb8d1ee0eff" translate="yes" xml:space="preserve">
          <source>The list of allowed types. If empty, any type is allowed.</source>
          <target state="translated">允许的类型列表。如果为空,则允许使用任何类型。</target>
        </trans-unit>
        <trans-unit id="7d752b3e0c165ac9972ad67362f39567c19601ad" translate="yes" xml:space="preserve">
          <source>The literal may not exceed the range of the type. The literal is rounded to fit into the significant digits of the type.</source>
          <target state="translated">字面意思不能超过类型的范围。字面意思是四舍五入,以适应类型的重要数字。</target>
        </trans-unit>
        <trans-unit id="cfda6f32ee8182b11470321e18429ff54847d85e" translate="yes" xml:space="preserve">
          <source>The local part is in a deprecated form</source>
          <target state="translated">本地部分采用的是废弃的形式。</target>
        </trans-unit>
        <trans-unit id="6f51eadb663d2759618c2c7f55ed73ce81e81662" translate="yes" xml:space="preserve">
          <source>The local part of the address is too long</source>
          <target state="translated">地址的本地部分太长</target>
        </trans-unit>
        <trans-unit id="d43703ab62f0fdfb0730decc44b9accfe993fc48" translate="yes" xml:space="preserve">
          <source>The local part of the email address, that is, the part before the @ sign.</source>
          <target state="translated">电子邮件地址的本地部分,也就是@号之前的部分。</target>
        </trans-unit>
        <trans-unit id="fb2b16bfeb403dd9d23822ef47a96282d2506733" translate="yes" xml:space="preserve">
          <source>The logger used by the logging function as reference.</source>
          <target state="translated">记录功能所使用的记录仪作为参考。</target>
        </trans-unit>
        <trans-unit id="9dc35ce16bcd5e0f3997b30f4a3a933ead8e2be7" translate="yes" xml:space="preserve">
          <source>The long</source>
          <target state="translated">长</target>
        </trans-unit>
        <trans-unit id="cdce859b555eda9a366f161871fcdb633ee5b0eb" translate="yes" xml:space="preserve">
          <source>The long symbol for this option</source>
          <target state="translated">此选项的长符号</target>
        </trans-unit>
        <trans-unit id="eb826857f96e2fa8c72d4f984e7520701feb3d3d" translate="yes" xml:space="preserve">
          <source>The loop is correctly written:</source>
          <target state="translated">循环的写法是正确的。</target>
        </trans-unit>
        <trans-unit id="80cd3f025f71ab9fb6d037c50456d7fb59577d15" translate="yes" xml:space="preserve">
          <source>The lower bound of the clamp.</source>
          <target state="translated">钳的下限。</target>
        </trans-unit>
        <trans-unit id="c3ba355fcfd258cdc3b0962e2c92c7fd02aec3ad" translate="yes" xml:space="preserve">
          <source>The macro &quot;##&quot; is ISO C, we assume pre-ISO C doesn't support it.</source>
          <target state="translated">宏 &quot;##&quot;是ISO C,我们认为ISO C前不支持。</target>
        </trans-unit>
        <trans-unit id="4493cedee574dfabffbc81a40e14a5b6a3a6b77b" translate="yes" xml:space="preserve">
          <source>The macros section follows the same syntax as the &lt;b&gt;Params:&lt;/b&gt; section. It's a series of</source>
          <target state="translated">宏部分的语法与&lt;b&gt;Params：&lt;/b&gt;部分相同。这是一系列的</target>
        </trans-unit>
        <trans-unit id="cf6c8468c449f6bacda719f4e15ba7d61861d0e7" translate="yes" xml:space="preserve">
          <source>The magnitude is an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of unsigned integers that satisfies either &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;&lt;code&gt;std.range.primitives.isForwardRange&lt;/code&gt;&lt;/a&gt;. The first (leftmost) element of the magnitude is considered the most significant.</source>
          <target state="translated">大小是满足&lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt; &lt;code&gt;std.range.primitives.isForwardRange&lt;/code&gt; &lt;/a&gt;的无符号整数的&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;。幅度的第一个（最左侧）元素被认为是最重要的。</target>
        </trans-unit>
        <trans-unit id="7ae8a3b1299a2612db122fcc08bc88452fa0e22f" translate="yes" xml:space="preserve">
          <source>The magnitude of x is limited to about 106.56 for IEEE 80-bit arithmetic; 1 or -1 is returned outside this range.</source>
          <target state="translated">对于IEEE 80位算术来说,x的幅度被限制在106.56左右;在这个范围之外,会返回1或-1。</target>
        </trans-unit>
        <trans-unit id="327523b3c0bae538d6dd857c0b63c542d4c2e3ff" translate="yes" xml:space="preserve">
          <source>The main &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; module provides template-based tools for working with ranges, but sometimes an object-based interface for ranges is needed, such as when runtime polymorphism is required. For this purpose, this submodule provides a number of object and &lt;code&gt;interface&lt;/code&gt; definitions that can be used to wrap around range objects created by the &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; templates.</source>
          <target state="translated">主要的&lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;模块提供了用于范围的基于模板的工具，但是有时需要用于范围的基于对象的接口，例如当需要运行时多态时。为此，此子模块提供了许多对象和 &lt;code&gt;interface&lt;/code&gt; 定义，可用于包装由&lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;模板创建的范围对象。</target>
        </trans-unit>
        <trans-unit id="3c02f05cd38724c7e8cb17756e9c5152cd9c1060" translate="yes" xml:space="preserve">
          <source>The main entry point for garbage collection. The supplied delegate will be passed ranges representing both stack and register values.</source>
          <target state="translated">垃圾收集的主要入口。提供的委托人将被传递代表堆栈和寄存器值的范围。</target>
        </trans-unit>
        <trans-unit id="70a5f20578712db84e71fcdbe8fd245260ba0674" translate="yes" xml:space="preserve">
          <source>The main reasons that a program might need to use ticks directly is if the system clock has higher precision than hnsecs, and the program needs that higher precision, or if the program needs to avoid the rounding errors caused by converting to hnsecs.</source>
          <target state="translated">程序可能需要直接使用ticks的主要原因是,如果系统时钟的精度比hnsecs高,而程序需要更高的精度,或者程序需要避免转换为hnsecs造成的舍入误差。</target>
        </trans-unit>
        <trans-unit id="99346c9361ee044918b5692d75d84b05203809b4" translate="yes" xml:space="preserve">
          <source>The main uses cases for &lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; 的主要用例是：</target>
        </trans-unit>
        <trans-unit id="37721286eae1f656c81db469ea0c2aa0407bd201" translate="yes" xml:space="preserve">
          <source>The major 32-bit x86 microarchitecture 'dynasties' have been:</source>
          <target state="translated">主要的32位x86微架构 &quot;王朝 &quot;已经。</target>
        </trans-unit>
        <trans-unit id="982a1e7c4fc73fa370e90c954afb1f355930cd55" translate="yes" xml:space="preserve">
          <source>The managed array.</source>
          <target state="translated">管理阵列。</target>
        </trans-unit>
        <trans-unit id="24b3c10fb402cc3696f43a7e032402872866e5ae" translate="yes" xml:space="preserve">
          <source>The mangled name for a function with function pointer type T and the given fully qualified name.</source>
          <target state="translated">一个函数指针类型为T的函数和给定的完全限定名称的杂乱名称。</target>
        </trans-unit>
        <trans-unit id="2222f24e9ff7ad414fdd6df5db1a3a27354c9552" translate="yes" xml:space="preserve">
          <source>The mangled name for a symbols of type T and the given fully qualified name.</source>
          <target state="translated">T型符号的杂乱名称和给定的完全限定名称。</target>
        </trans-unit>
        <trans-unit id="582a49c9af38036e1960cd170f7932701e0fb6f3" translate="yes" xml:space="preserve">
          <source>The mangled name with deduplicated identifiers</source>
          <target state="translated">带有重复标识符的杂乱名称</target>
        </trans-unit>
        <trans-unit id="08774dd4c4d75e3bd42a748ee71506481a4f0a1b" translate="yes" xml:space="preserve">
          <source>The mangled string representing the type</source>
          <target state="translated">代表类型的杂乱字符串</target>
        </trans-unit>
        <trans-unit id="40a84060f0327e9db3cfd8bbb21dc9782f40397c" translate="yes" xml:space="preserve">
          <source>The manner in which to display the output of each &lt;code&gt;Option.&lt;/code&gt;</source>
          <target state="translated">显示每个 &lt;code&gt;Option.&lt;/code&gt; 输出的方式。</target>
        </trans-unit>
        <trans-unit id="aa7ae029a5326a80d32c23d17dde2c45ccbc8321" translate="yes" xml:space="preserve">
          <source>The mapping of package and module identifiers to directory and file names.</source>
          <target state="translated">包和模块标识符与目录和文件名的映射。</target>
        </trans-unit>
        <trans-unit id="43effc8161287353136863e8d2f53a67a4ef703b" translate="yes" xml:space="preserve">
          <source>The max aliases are the largest integral types:</source>
          <target state="translated">最大别名是最大的积分类型。</target>
        </trans-unit>
        <trans-unit id="986ee926972449f806f769e32d7dd4ba24b84874" translate="yes" xml:space="preserve">
          <source>The maximal element of the passed-in range.</source>
          <target state="translated">传入范围的最大元素。</target>
        </trans-unit>
        <trans-unit id="ae723b7ad52bbfa1e17cf08fd49aa1b7abbdc458" translate="yes" xml:space="preserve">
          <source>The maximum allowed nesting level.</source>
          <target state="translated">允许的最大嵌套水平。</target>
        </trans-unit>
        <trans-unit id="c15b5870b72ff9ade8671f564f3ad47e5d8703b2" translate="yes" xml:space="preserve">
          <source>The maximum guarantee of &lt;code&gt;pure&lt;/code&gt; is called &quot;strong purity&quot;. It can enable optimizations based on the fact that a function is guaranteed to not mutate anything which isn't passed to it. For cases where the compiler can guarantee that a pure function cannot alter its arguments, it can enable full, functional purity (i.e. the guarantee that the function will always return the same result for the same arguments). To that end, a pure function:</source>
          <target state="translated">最高的 &lt;code&gt;pure&lt;/code&gt; 保证称为&amp;ldquo;强纯度&amp;rdquo;。它可以基于以下事实进行优化：保证一个函数不会对任何未传递给它的东西进行变异。对于编译器可以保证纯函数不能更改其参数的情况，它可以启用完整的函数纯净度（即，保证函数对于相同的参数始终返回相同的结果）。为此，一个纯函数：</target>
        </trans-unit>
        <trans-unit id="c855c6313f529356306d651f3e145813bb160323" translate="yes" xml:space="preserve">
          <source>The maximum length of &lt;code&gt;filename&lt;/code&gt; is given by the constant &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt;. (On Windows, this number is defined as the maximum number of UTF-16 code points, and the test will therefore only yield strictly correct results when &lt;code&gt;filename&lt;/code&gt; is a string of &lt;code&gt;wchar&lt;/code&gt;s.)</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 的最大长度由常量 &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt; 给出。（在Windows上，此数字定义为UTF-16代码点的最大数量，因此，仅在 &lt;code&gt;filename&lt;/code&gt; 是 &lt;code&gt;wchar&lt;/code&gt; 字符串时，测试才会产生严格正确的结果。）</target>
        </trans-unit>
        <trans-unit id="05e735a756b3fa2f43497424f8b3020883222ceb" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes of output that should be captured.</source>
          <target state="translated">应该捕获的最大输出字节数。</target>
        </trans-unit>
        <trans-unit id="f3e3e4f751fc559f30cd92f8522a3febd435ec99" translate="yes" xml:space="preserve">
          <source>The maximum number of elements the array can store without reallocating memory and invalidating iterators upon insertion.</source>
          <target state="translated">数组可以存储的最大元素数,而不需要重新分配内存和插入时使迭代器无效。</target>
        </trans-unit>
        <trans-unit id="ff490f34a5e2c376eac774681e1598898ac5391d" translate="yes" xml:space="preserve">
          <source>The maximum number of messages or zero if no limit.</source>
          <target state="translated">最大信息数量,如果没有限制,则为零。</target>
        </trans-unit>
        <trans-unit id="23ffb3d6838b02986026c5eeb543b889e4e64af2" translate="yes" xml:space="preserve">
          <source>The maximum of the passed-in args. The type of the returned value is the type among the passed arguments that is able to store the largest value.</source>
          <target state="translated">传入的参数中的最大值。返回值的类型是传递的参数中能够存储最大值的类型。</target>
        </trans-unit>
        <trans-unit id="e3f981b26c63cbef1dde8cf88e0c6fd5a78eba99" translate="yes" xml:space="preserve">
          <source>The maximum of the passed-in values. The type of the returned value is the type among the passed arguments that is able to store the largest value. If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt;&lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="translated">传入值的最大值。返回值的类型是传递的参数中能够存储最大值的类型。如果参数中至少一个是NaN，则结果是未指定的值。有关如何处理NaN的示例，请参见&lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt; &lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7eb2470a27937a3494cee9a54b8062f651c54299" translate="yes" xml:space="preserve">
          <source>The maximum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the maximum valid priority for the scheduling policy of the process.</source>
          <target state="translated">可以为一个线程设置的最大调度优先级。在定义了多个调度策略的系统中,这个值代表进程的调度策略的最大有效优先级。</target>
        </trans-unit>
        <trans-unit id="f397747108afabbaad398b1bbfbbdd699e4c5ce8" translate="yes" xml:space="preserve">
          <source>The maximum size of the GC buffer to hold the return values</source>
          <target state="translated">GC缓冲区的最大尺寸,用于保存返回值。</target>
        </trans-unit>
        <trans-unit id="075c481912178c8ac79090ee5b3669c3def2fbb2" translate="yes" xml:space="preserve">
          <source>The maximum value representable is &lt;code&gt;T.max&lt;/code&gt; for signed integrals, &lt;code&gt; T.max - 1&lt;/code&gt; for unsigned integrals. The minimum value representable is &lt;code&gt; T.min + 1&lt;/code&gt; for signed integrals, &lt;code&gt;0&lt;/code&gt; for unsigned integrals.</source>
          <target state="translated">对于有符号积分，可表示的最大值为 &lt;code&gt;T.max&lt;/code&gt; ，对于无符号积分，可表示的最大值为 &lt;code&gt; T.max - 1&lt;/code&gt; 。对于有符号积分，可表示的最小值为 &lt;code&gt; T.min + 1&lt;/code&gt; ，对于无符号积分，可表示的最小值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4957d9a3700ae6f7d93e51da85b7d5a4964d27b2" translate="yes" xml:space="preserve">
          <source>The mean of &lt;code&gt;r&lt;/code&gt; when &lt;code&gt;r&lt;/code&gt; is non-empty.</source>
          <target state="translated">当 &lt;code&gt;r&lt;/code&gt; 为非空 &lt;code&gt;r&lt;/code&gt; 时，r的平均值。</target>
        </trans-unit>
        <trans-unit id="c587177906e3358831db8b1c6944ffdb24226077" translate="yes" xml:space="preserve">
          <source>The members are completely hidden to the user, and so the only operations on those types are ones that do not require any knowledge of the contents of those types. For example:</source>
          <target state="translated">这些成员对用户来说是完全隐藏的,所以对这些类型的操作只有那些不需要知道这些类型内容的操作。例如:</target>
        </trans-unit>
        <trans-unit id="00dd946dd7ec09c0536b1658fc7e8ead520e7c8e" translate="yes" xml:space="preserve">
          <source>The memory is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">该存储器被从获得 &lt;code&gt;SmallAllocator&lt;/code&gt; 如果 &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt; ，或 &lt;code&gt;LargeAllocator&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="f8c96911fea13cb1c02d9f105c0c295fa2deb239" translate="yes" xml:space="preserve">
          <source>The memory location of different memory blocks is not defined. Ordered comparison (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;) between two pointers is permitted when both pointers point to the same array, or when at least one pointer is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">未定义不同存储块的存储位置。当两个指针都指向同一数组或至少一个指针为 &lt;code&gt;null&lt;/code&gt; 时，允许在两个指针之间进行有序比较（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe0b84897743c23c53a5e9577a10299a7a7b020c" translate="yes" xml:space="preserve">
          <source>The memory usage of this implementation is guaranteed to be constant in &lt;code&gt;range.length&lt;/code&gt;.</source>
          <target state="translated">确保此实现的内存使用情况在 &lt;code&gt;range.length&lt;/code&gt; 中是恒定的。</target>
        </trans-unit>
        <trans-unit id="7609ac8f3cf653b1ce0270fa8139880a547a9eea" translate="yes" xml:space="preserve">
          <source>The message for the exception.</source>
          <target state="translated">异常的信息。</target>
        </trans-unit>
        <trans-unit id="4c338cd37584d6e6e69bd4c24d1ae2acb50b8634" translate="yes" xml:space="preserve">
          <source>The message that was sent.</source>
          <target state="translated">发出的信息。</target>
        </trans-unit>
        <trans-unit id="68d612f02557a1940b9b2866c12015c2578745a2" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;AssertError&lt;/code&gt; if the assumption turns out to be false.</source>
          <target state="translated">如果假设为假，则包含在 &lt;code&gt;AssertError&lt;/code&gt; 中的消息。</target>
        </trans-unit>
        <trans-unit id="488aa84d557c1a01800a687e8f424ca1dc36fdd6" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;ErrnoException&lt;/code&gt; if it is thrown.</source>
          <target state="translated">如果抛出该消息，则包含在 &lt;code&gt;ErrnoException&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="79b8f8765c27119a953cd29d5a9f80179e617637" translate="yes" xml:space="preserve">
          <source>The metaclass of this class.</source>
          <target state="translated">这个类的元类。</target>
        </trans-unit>
        <trans-unit id="93cc36b0067843c6450f0911a4ca8b3ad0ea0493" translate="yes" xml:space="preserve">
          <source>The method used to enable or disable the unit tests. Use of a compiler switch such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt; to enable them is suggested.</source>
          <target state="translated">用于启用或禁用单元测试的方法。建议使用&lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt;之类的编译器开关来启用它们。</target>
        </trans-unit>
        <trans-unit id="c6a75cd2237917d2ed85214e205b4f1cf25efd9f" translate="yes" xml:space="preserve">
          <source>The minimal element of the passed-in range.</source>
          <target state="translated">传入范围的最小元素。</target>
        </trans-unit>
        <trans-unit id="ab6714e3fe053113da2960956c8eb82b3e5bbc67" translate="yes" xml:space="preserve">
          <source>The minimal number of edits to transform s into t.  Does not allocate GC memory.</source>
          <target state="translated">将s转化为t的最小编辑次数,不分配GC内存。</target>
        </trans-unit>
        <trans-unit id="10a4be4f3adcabd3abe79325f2076e9b9a100888" translate="yes" xml:space="preserve">
          <source>The minimum duration the calling thread should be suspended.</source>
          <target state="translated">调用线程应暂停的最短期限。</target>
        </trans-unit>
        <trans-unit id="28711c27ca983081eb31b72306fa4a118f39be3b" translate="yes" xml:space="preserve">
          <source>The minimum extension size in bytes.</source>
          <target state="translated">最小扩展大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="c06ab7e4e215252c3c928d52e3071658c4a68764" translate="yes" xml:space="preserve">
          <source>The minimum of the passed-in values.</source>
          <target state="translated">传入值的最小值。</target>
        </trans-unit>
        <trans-unit id="edffbb1612aecedbb9b2455ef9f7bc186445862c" translate="yes" xml:space="preserve">
          <source>The minimum of the passed-in values. The type of the returned value is the type among the passed arguments that is able to store the smallest value. If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt;&lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="translated">传入值的最小值。返回值的类型是传递的参数中能够存储最小值的类型。如果参数中至少一个是NaN，则结果是未指定的值。有关如何处理NaN的示例，请参见&lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt; &lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95346b92b5307b71b43fcd27332d111b5c7b81cb" translate="yes" xml:space="preserve">
          <source>The minimum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the minimum valid priority for the scheduling policy of the process.</source>
          <target state="translated">可以为一个线程设置的最小调度优先级。在定义了多个调度策略的系统中,这个值代表进程的调度策略的最小有效优先级。</target>
        </trans-unit>
        <trans-unit id="91d9db5c5ad3a0f6b05ff83250575799825e9e6d" translate="yes" xml:space="preserve">
          <source>The minimum, respectively maximum element of a range together with the number it occurs in the range.</source>
          <target state="translated">一个范围的最小,分别是最大的元素,以及它在该范围内出现的数量。</target>
        </trans-unit>
        <trans-unit id="4776ba2a4d44664c280371c94d75db0a68aa7f47" translate="yes" xml:space="preserve">
          <source>The minute portion of the time;</source>
          <target state="translated">分钟的部分时间。</target>
        </trans-unit>
        <trans-unit id="804dde72e3fca52bb6fee9e6c9a891f7a218393e" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的分钟设置为的分钟。</target>
        </trans-unit>
        <trans-unit id="fd8186f6e2f846fa308524ef0f64113f0d7289dd" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的分钟设置为的分钟。</target>
        </trans-unit>
        <trans-unit id="80d86d248f3ac806d407ff7069134427130713b0" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">将此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;的分钟设置为的分钟。</target>
        </trans-unit>
        <trans-unit id="de600cb5888514e99355f24b957b0d7134a283a8" translate="yes" xml:space="preserve">
          <source>The mode must be compatible with the mode of the file descriptor.</source>
          <target state="translated">模式必须与文件描述符的模式兼容。</target>
        </trans-unit>
        <trans-unit id="204cac3357eeb22cb6ce425410ebf52a7b2c34ef" translate="yes" xml:space="preserve">
          <source>The mode the memory mapped file is opened with.</source>
          <target state="translated">内存映射文件的打开模式。</target>
        </trans-unit>
        <trans-unit id="973816115210d9c45eb2bc6fdd4a572e4108483e" translate="yes" xml:space="preserve">
          <source>The modified &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for any time on this date (since, the modified Julian day changes at midnight).</source>
          <target state="translated">修改后的&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;儒略日&lt;/a&gt;在该日期的任何时间（因为修改后的儒略日在午夜更改）。</target>
        </trans-unit>
        <trans-unit id="d6cf19189a246f4659acb849b3f0cc1663f9b978" translate="yes" xml:space="preserve">
          <source>The modified &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for any time on this date (since, the modified Julian day changes at midnight).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860d6be9b0cf54ee441891db4a2fd6202c776fe2" translate="yes" xml:space="preserve">
          <source>The modifier to apply.</source>
          <target state="translated">要应用的修改器。</target>
        </trans-unit>
        <trans-unit id="124f2941f2e52ecf62ccffc3b7646e3953931e7d" translate="yes" xml:space="preserve">
          <source>The modifiers of the &lt;code&gt;lhsMod&lt;/code&gt; mismatching the ones with the &lt;code&gt;rhsMod&lt;/code&gt; are printed, i.e. lhs(shared) vs. rhs() prints &quot;&lt;code&gt;shared&lt;/code&gt;&quot;, wheras lhs() vs rhs(shared) prints &quot;non-shared&quot;.</source>
          <target state="translated">&lt;code&gt;lhsMod&lt;/code&gt; 的修饰符与rhsMod不匹配，即 &lt;code&gt;rhsMod&lt;/code&gt; （shared）与rhs（）打印&amp;ldquo; &lt;code&gt;shared&lt;/code&gt; &amp;rdquo;，而wheras lhs（）vs rhs（shared）打印&amp;ldquo;非共享&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="95523edab7d804c0b6ab6eed37c8c3cadada1694" translate="yes" xml:space="preserve">
          <source>The module edges as found in the &lt;code&gt;importedModules&lt;/code&gt; member of each ModuleInfo. Generated in sortCtors.</source>
          <target state="translated">在每个ModuleInfo 的 &lt;code&gt;importedModules&lt;/code&gt; 成员中找到的模块边缘。在sortCtors中生成。</target>
        </trans-unit>
        <trans-unit id="47af20b56ee3955f4fd47d6c7951eb2d036d5a4c" translate="yes" xml:space="preserve">
          <source>The module for this virtual table</source>
          <target state="translated">该虚拟表的模块</target>
        </trans-unit>
        <trans-unit id="cab05c206d3bb715fd01c040c88f5fe361c942e4" translate="yes" xml:space="preserve">
          <source>The modulus</source>
          <target state="translated">模数</target>
        </trans-unit>
        <trans-unit id="82131155f810a5f75ba3764eb1563b749deb3cf3" translate="yes" xml:space="preserve">
          <source>The monotonic clock has no relation to wall clock time. Rather, it holds its time as the number of ticks of the clock which have occurred since the clock started (typically when the system booted up). So, to determine how much time has passed between two points in time, one monotonic time is subtracted from the other to determine the number of ticks which occurred between the two points of time, and those ticks are divided by the number of ticks that occur every second (as represented by MonoTime.ticksPerSecond) to get a meaningful duration of time. Normally, MonoTime does these calculations for the programmer, but the &lt;code&gt;ticks&lt;/code&gt; and &lt;code&gt;ticksPerSecond&lt;/code&gt; properties are provided for those who require direct access to the system ticks. The normal way that MonoTime would be used is</source>
          <target state="translated">单调时钟与挂钟时间无关。而是将其时间保留为自时钟启动以来（通常是系统启动时）发生的时钟滴答数。因此，要确定两个时间点之间经过了多少时间，请从另一个时间中减去一个单调时间，以确定在两个时间点之间发生的滴答声数量，然后将这些滴答声除以发生的滴答声数量。每秒（由MonoTime.ticksPerSecond表示）以获取有意义的持续时间。通常，MonoTime为程序员执行这些计算，但是 &lt;code&gt;ticks&lt;/code&gt; 和 &lt;code&gt;ticksPerSecond&lt;/code&gt; 属性是为需要直接访问系统ticks的用户提供的。通常使用MonoTime的方式是</target>
        </trans-unit>
        <trans-unit id="d74977e8496820ecedeff19e20ade1b05de3e4b6" translate="yes" xml:space="preserve">
          <source>The month of the day to validate (January is 1).</source>
          <target state="translated">日的月份进行验证(1月为1)。</target>
        </trans-unit>
        <trans-unit id="6ebaf2163e939c5ad1bf15c5f8dae4f8a043e786" translate="yes" xml:space="preserve">
          <source>The month of the day to validate.</source>
          <target state="translated">日的月份来验证。</target>
        </trans-unit>
        <trans-unit id="d4d21752a92d87f995da2fa4e777f8856076f4d2" translate="yes" xml:space="preserve">
          <source>The month of the year to get the number of months to.</source>
          <target state="translated">年的月份,以获得月数到。</target>
        </trans-unit>
        <trans-unit id="3b03ba6279034200ca13bdea73b6dd032c6515f6" translate="yes" xml:space="preserve">
          <source>The month portion of the date (January is 1).</source>
          <target state="translated">日期的月份部分(一月为1)。</target>
        </trans-unit>
        <trans-unit id="e6fd335018a8476e0b61c3352fc0e3562dbfcc53" translate="yes" xml:space="preserve">
          <source>The month that each time point in the range will be in (January is 1).</source>
          <target state="translated">每个时间点的范围内的月份(一月为1)。</target>
        </trans-unit>
        <trans-unit id="3a058535cdaf9aa70980ff68790ecdb70d352df1" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">将此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的月份设置为的月份。</target>
        </trans-unit>
        <trans-unit id="b85e045063e5ffa8ef021269a9798226e87028d9" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的月份设置为的月份。</target>
        </trans-unit>
        <trans-unit id="a9daf4d7ebc51fc3e649125b409fa21bb86aa474" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的月份设置为的月份。</target>
        </trans-unit>
        <trans-unit id="cf6b4f0b397f7fd7fb57c763984e8789cb54772a" translate="yes" xml:space="preserve">
          <source>The most basic contract is the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;. An &lt;b&gt;assert&lt;/b&gt; declares an expression that must evaluate to true, with an optional failure string as a second argument:</source>
          <target state="translated">最基本的合同是&lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;。一个&lt;b&gt;assert&lt;/b&gt;声明一个必须计算为true的表达式，并使用一个可选的失败字符串作为第二个参数：</target>
        </trans-unit>
        <trans-unit id="8a6bd68f79c5b13e9b7d8eaf7293f850cd2e0e6d" translate="yes" xml:space="preserve">
          <source>The most conservative/general allocation: memory may be shared, deallocated in a different thread, may or may not be resized, and may embed references.</source>
          <target state="translated">最保守/一般的分配方式:内存可以共享,在不同的线程中重新分配,可以调整大小,也可以不调整大小,还可以嵌入引用。</target>
        </trans-unit>
        <trans-unit id="1f6880935884c96d8b2634bfd6b4fbc9dbe4652c" translate="yes" xml:space="preserve">
          <source>The most interesting case is when gapped matches still participate in the result, but not as strongly as ungapped matches. The result will be a smooth, fine-grained similarity measure between the input strings. This is where values of &lt;code&gt;lambda&lt;/code&gt; between 0 and 1 enter into play: gapped matches are</source>
          <target state="translated">最有趣的情况是当空缺的比赛仍参与结果，但不如空缺的比赛强。结果将是输入字符串之间的平滑，细粒度的相似性度量。这是0到1之间的 &lt;code&gt;lambda&lt;/code&gt; 值起作用的地方：差距匹配是</target>
        </trans-unit>
        <trans-unit id="9317ec6cdc50605b3f7ad3a0a9efb80f09d16bb9" translate="yes" xml:space="preserve">
          <source>The mutex associated with this condition.</source>
          <target state="translated">与此条件相关的mutex。</target>
        </trans-unit>
        <trans-unit id="8402314bcd0aba6dacdd48ffde4057ad88f89bec" translate="yes" xml:space="preserve">
          <source>The mutex module provides a primitive for maintaining mutually exclusive access.</source>
          <target state="translated">互斥模块提供了一个维护互斥访问的基元。</target>
        </trans-unit>
        <trans-unit id="437cb228e7e76ab9ff7feb1b0fb4ca0971be7ae2" translate="yes" xml:space="preserve">
          <source>The mutex with which this condition will be associated.</source>
          <target state="translated">与该条件相关联的mutex。</target>
        </trans-unit>
        <trans-unit id="4d5ce17987e89e660e90474cca14f7f4718221ad" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;string&lt;/code&gt; is aliased to &lt;code&gt;immutable(char)[]&lt;/code&gt;, so the above declarations could be equivalently written as:</source>
          <target state="translated">名称 &lt;code&gt;string&lt;/code&gt; 别名为 &lt;code&gt;immutable(char)[]&lt;/code&gt; ，因此上述声明可以等效地写为：</target>
        </trans-unit>
        <trans-unit id="abdfc7dd54ebeb228e02bc4ac46894950c3ebbee" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class::WhiteHole&lt;/a&gt; Perl module by Michael G Schwern.</source>
          <target state="translated">该名称来自Michael G Schwern的&lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class :: WhiteHole&lt;/a&gt; Perl模块。</target>
        </trans-unit>
        <trans-unit id="173aa229bfebb13b14fcecd5dd6654d108541499" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class::BlackHole&lt;/a&gt; Perl module by Sean M. Burke.</source>
          <target state="translated">该名称来自Sean M. Burke的&lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class :: BlackHole&lt;/a&gt; Perl模块。</target>
        </trans-unit>
        <trans-unit id="ba677412cf6055cfe046fa4f2b82702d23be25af" translate="yes" xml:space="preserve">
          <source>The name if the &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 的名称</target>
        </trans-unit>
        <trans-unit id="b2072d20b70963efec270cc1f87503a1f3984cd8" translate="yes" xml:space="preserve">
          <source>The name last used to initialize this this file, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">上次用于初始化此文件的名称，否则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef45a06b2c7cb94d26e3df83157cd1f979d10e1a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to insert.</source>
          <target state="translated">要插入的 &lt;code&gt;Logger&lt;/code&gt; 的名称。</target>
        </trans-unit>
        <trans-unit id="dd55ce2538ac752361cbfd21c951f733e9d094b0" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to remove. If the &lt;code&gt;Logger&lt;/code&gt; is not found &lt;code&gt;null&lt;/code&gt; will be returned. Only the first occurrence of a &lt;code&gt;Logger&lt;/code&gt; with the given name will be removed.</source>
          <target state="translated">要删除的 &lt;code&gt;Logger&lt;/code&gt; 的名称。如果找不到 &lt;code&gt;Logger&lt;/code&gt; ,则将返回 &lt;code&gt;null&lt;/code&gt; 。仅会删除首次出现的具有给定名称的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc826e0e638f15943c2d93a5fc1dee8020c30510" translate="yes" xml:space="preserve">
          <source>The name of the archive member; it is used to index the archive directory for the member. Each member must have a unique name. Do not change without removing member from the directory first.</source>
          <target state="translated">归档成员的名称;用于为该成员编制归档目录索引。每个成员必须有一个唯一的名称。在未从目录中删除成员之前,请勿更改。</target>
        </trans-unit>
        <trans-unit id="9ee544165e4b0ac751c5682d99380143dea28b21" translate="yes" xml:space="preserve">
          <source>The name of the coverage file.</source>
          <target state="translated">覆盖文件的名称。</target>
        </trans-unit>
        <trans-unit id="8ede299dc9f0c5729961ad67f198075314269cda" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library to load.</source>
          <target state="translated">要加载的动态库的名称。</target>
        </trans-unit>
        <trans-unit id="eb57c5ab9b22c7728fcb5026ae94a8f672f4064a" translate="yes" xml:space="preserve">
          <source>The name of the file in the path name, without any leading directory and with an optional suffix chopped off.  If &lt;code&gt;suffix&lt;/code&gt; is specified, it will be compared to &lt;code&gt;path&lt;/code&gt; using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">路径名中的文件名，不带任何前导目录，并且带有可选的后缀。如果指定了 &lt;code&gt;suffix&lt;/code&gt; ，则将使用 &lt;code&gt;filenameCmp!cs&lt;/code&gt; 将其与 &lt;code&gt;path&lt;/code&gt; 进行比较，其中 &lt;code&gt;cs&lt;/code&gt; 是一个可选的模板参数，确定比较是否区分大小写。有关详细信息，请参见&lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="300f2fc600e9d7ddc4bfc394a66a2e870cf5e607" translate="yes" xml:space="preserve">
          <source>The name of the file that signaled this error.</source>
          <target state="translated">发出该错误信号的文件名称。</target>
        </trans-unit>
        <trans-unit id="c3104c1d832397234efa203c02c8d138f5d9f9fd" translate="yes" xml:space="preserve">
          <source>The name of the file to get the modification time for.</source>
          <target state="translated">要获取修改时间的文件名。</target>
        </trans-unit>
        <trans-unit id="e8109b9ee879cd4547f4e2ca59c0889a944b8289" translate="yes" xml:space="preserve">
          <source>The name of the time zone.</source>
          <target state="translated">时区的名称。</target>
        </trans-unit>
        <trans-unit id="f27bf1b63b731926e3cb9f283408921e662cdceb" translate="yes" xml:space="preserve">
          <source>The name of the time zone. Exactly how the time zone name is formatted depends on the derived class. In the case of &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt;, it's the TZ Database name, whereas with &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, it's the name that Windows chose to give the registry key for that time zone (typically the name that they give &lt;a href=&quot;#stdTime&quot;&gt;&lt;code&gt;stdTime&lt;/code&gt;&lt;/a&gt; if the OS is in English). For other time zone types, what it is depends on how they're implemented.</source>
          <target state="translated">时区的名称。时区名称的确切格式取决于派生类。在&lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt;的情况下，它是TZ数据库名称，而在&lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; 的情况下&lt;/a&gt;，这是Windows选择为该时区提供注册表项的名称（如果操作系统为英文，则通常为&lt;a href=&quot;#stdTime&quot;&gt; &lt;code&gt;stdTime&lt;/code&gt; &lt;/a&gt;）。对于其他时区类型，具体取决于它们的实现方式。</target>
        </trans-unit>
        <trans-unit id="7356c9b705dbe74fbd4051d488c2e6132abcd4c9" translate="yes" xml:space="preserve">
          <source>The name of this thread.</source>
          <target state="translated">这条线的名字。</target>
        </trans-unit>
        <trans-unit id="c1776179bbf96730aef0ae7bbd1e4946315a478b" translate="yes" xml:space="preserve">
          <source>The name to associate with tid.</source>
          <target state="translated">要联想到tid的名字。</target>
        </trans-unit>
        <trans-unit id="6450e623e92fd399a84552aa61d8d22ade4cc69a" translate="yes" xml:space="preserve">
          <source>The name to locate within the registry.</source>
          <target state="translated">要在登记处内查找的名称。</target>
        </trans-unit>
        <trans-unit id="2b6764cf8c6facb0fec9b546a291b7a2d4a5f2ee" translate="yes" xml:space="preserve">
          <source>The name to unregister.</source>
          <target state="translated">要取消注册的名称。</target>
        </trans-unit>
        <trans-unit id="237ed33d70031f44c43457be931f956373047992" translate="yes" xml:space="preserve">
          <source>The names of the &lt;code&gt;Tuple&lt;/code&gt;'s components. Unnamed fields have empty names.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 组件的名称。未命名字段的名称为空。</target>
        </trans-unit>
        <trans-unit id="3ad8dfc5a740c084b53b8cdd123ef24e70479c04" translate="yes" xml:space="preserve">
          <source>The names of the fields that are to be aligned.</source>
          <target state="translated">要对齐的字段名称;</target>
        </trans-unit>
        <trans-unit id="32748ca9205b0eda60d1a2b3377d67735262b73b" translate="yes" xml:space="preserve">
          <source>The natural alignment of an aggregate is the maximum alignment of its fields. It can be overridden by setting the alignment outside of the aggregate.</source>
          <target state="translated">集合体的自然对齐方式是其字段的最大对齐方式。它可以通过在集合体之外设置对齐方式来覆盖。</target>
        </trans-unit>
        <trans-unit id="4d205145a6dee0cb48fa4896fcd5718737412eec" translate="yes" xml:space="preserve">
          <source>The necessity of &lt;code&gt;FPTemporary&lt;/code&gt; stems from the optimized floating-point operations and registers present in virtually all processors. When adding numbers in the example above, the addition may in fact be done in &lt;code&gt;real&lt;/code&gt; precision internally. In that case, storing the intermediate &lt;code&gt;result&lt;/code&gt; in &lt;code&gt;double format&lt;/code&gt; is not only less precise, it is also (surprisingly) slower, because a conversion from &lt;code&gt;real&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt; is performed every pass through the loop. This being a lose-lose situation, &lt;code&gt;FPTemporary!F&lt;/code&gt; has been defined as the</source>
          <target state="translated">&lt;code&gt;FPTemporary&lt;/code&gt; 的必要性源于几乎所有处理器中都存在的优化浮点运算和寄存器。在上面的示例中加数字时，实际上可以在内部以 &lt;code&gt;real&lt;/code&gt; 精度进行加。在这种情况下，存储中间 &lt;code&gt;result&lt;/code&gt; 在 &lt;code&gt;double format&lt;/code&gt; 不仅不太精确，这也是（令人惊讶的）慢，因为从一个转换 &lt;code&gt;real&lt;/code&gt; 到 &lt;code&gt;double&lt;/code&gt; 通过循环执行的每个通。这是一个双输的局面， &lt;code&gt;FPTemporary!F&lt;/code&gt; 已经被定义为</target>
        </trans-unit>
        <trans-unit id="ce69a83fa824acdbab753bf226be620b99f45d75" translate="yes" xml:space="preserve">
          <source>The needles against which the range is to be checked, which may be individual elements or input ranges of elements.</source>
          <target state="translated">要检查范围的针,可以是单个元素或元素的输入范围。</target>
        </trans-unit>
        <trans-unit id="bfdb89ae3952e0ebbdb470ec1b2208c20a477858" translate="yes" xml:space="preserve">
          <source>The needles to check against, which may be single elements, or bidirectional ranges of elements.</source>
          <target state="translated">要对照的针,可以是单个元素,也可以是元素的双向范围。</target>
        </trans-unit>
        <trans-unit id="aadc952b806bed5663dabd85a1e647a24a59b7a9" translate="yes" xml:space="preserve">
          <source>The network interface to use in form of the the IP of the interface.</source>
          <target state="translated">要使用的网络接口的IP形式的接口。</target>
        </trans-unit>
        <trans-unit id="d0400083bef2e7ef7cc46b24ddfeddfeb8ab8c14" translate="yes" xml:space="preserve">
          <source>The new GC is added to the list of available garbage collectors that can be selected via the usual configuration options, e.g. by embedding &lt;code&gt;rt_options&lt;/code&gt; into the binary:</source>
          <target state="translated">新的GC将添加到可用垃圾收集器的列表中，可以通过常规配置选项来选择垃圾收集器，例如，将 &lt;code&gt;rt_options&lt;/code&gt; 嵌入二进制文件中：</target>
        </trans-unit>
        <trans-unit id="9669eec52fe11c4d6bad1a51de754d4e92f468df" translate="yes" xml:space="preserve">
          <source>The new capacity of the array (which may be larger than the requested capacity).</source>
          <target state="translated">阵列的新容量(可能大于请求的容量)。</target>
        </trans-unit>
        <trans-unit id="1cf6198accddd14ad946cf8a5d9d64fbb23a0e02" translate="yes" xml:space="preserve">
          <source>The new collect handler. Set to null to use the default handler.</source>
          <target state="translated">新的收集处理程序。设为null则使用默认处理程序。</target>
        </trans-unit>
        <trans-unit id="0c74f8b0b947d138316f600a118f4af837db2c6f" translate="yes" xml:space="preserve">
          <source>The new daemon status for this thread.</source>
          <target state="translated">这条线的新守护状态。</target>
        </trans-unit>
        <trans-unit id="cc66954b4cb782475e75068053434548b84f648b" translate="yes" xml:space="preserve">
          <source>The new extension</source>
          <target state="translated">新的扩展部分</target>
        </trans-unit>
        <trans-unit id="6c6fed22d3bfa6cee371ded07b99f5fc419355ad" translate="yes" xml:space="preserve">
          <source>The new handle will have all options set as the one it was duplicated from. An exception to this is that all options that cannot be shared across threads are reset thereby making it safe to use the duplicate in a new thread.</source>
          <target state="translated">新的句柄将拥有所有选项的设置,就像它被复制的那个句柄一样。一个例外的情况是,所有不能跨线程共享的选项都会被重置,因此在新线程中使用复制的句柄是安全的。</target>
        </trans-unit>
        <trans-unit id="acc5bddfa65365c1a41f6c814bd0b6ebf529b8b6" translate="yes" xml:space="preserve">
          <source>The new length of the array</source>
          <target state="translated">阵列的新长度</target>
        </trans-unit>
        <trans-unit id="44a43ff11b1752259ff91b328a916debf3f4639d" translate="yes" xml:space="preserve">
          <source>The new name of this thread.</source>
          <target state="translated">这条线的新名字。</target>
        </trans-unit>
        <trans-unit id="06d8bda027bfab1541ebec46a9bfa9f862174683" translate="yes" xml:space="preserve">
          <source>The new path name.</source>
          <target state="translated">新的路径名称。</target>
        </trans-unit>
        <trans-unit id="69ac0b91bb8b9e837548ad9dd2ea12af0f0c91cd" translate="yes" xml:space="preserve">
          <source>The new position of the pivot</source>
          <target state="translated">枢轴的新位置</target>
        </trans-unit>
        <trans-unit id="66818226d4d8e1db31b172237309a1e18f4a385a" translate="yes" xml:space="preserve">
          <source>The new scheduling priority of this thread.</source>
          <target state="translated">本线程新的调度优先级。</target>
        </trans-unit>
        <trans-unit id="bd1e49caf2a8a204c7259f45e5e91918594335cb" translate="yes" xml:space="preserve">
          <source>The new trace handler. Set to null to use the default handler.</source>
          <target state="translated">新的跟踪处理程序。设为null则使用默认处理程序。</target>
        </trans-unit>
        <trans-unit id="ef32f36ed520dab3a13bb8e95c2b955f22dc9b02" translate="yes" xml:space="preserve">
          <source>The new type supports all operations that the underlying type does, including all operators such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, etc.</source>
          <target state="translated">新类型支持基础类型执行的所有操作，包括所有运算符，例如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;--&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="4c2af0bb285d74b0268707c20367567927c3ffc7" translate="yes" xml:space="preserve">
          <source>The new unit tester. Set both to null to use the default unit tester.</source>
          <target state="translated">新的单元测试器。将两者都设置为空,以使用默认的单元测试器。</target>
        </trans-unit>
        <trans-unit id="6444785f7ab11942d704329e47346be10efdb756" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;px&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;px&lt;/code&gt; 的新值</target>
        </trans-unit>
        <trans-unit id="a51d15a8fa704020915ee450c5caa4010f6aa779" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的新值</target>
        </trans-unit>
        <trans-unit id="e4e6a0eafbf606dbc06607e9b4455a1bb56b0445" translate="yes" xml:space="preserve">
          <source>The new-style generator objects hold their own state so they are immune of threading issues. The generators feature a number of well-known and well-documented methods of generating random numbers. An overall fast and reliable means to generate random numbers is the Mt19937 generator, which derives its name from &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; with a period of 2 to the power of 19937&quot;. In memory-constrained situations, &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;linear congruential generators&lt;/a&gt; such as &lt;code&gt;MinstdRand0&lt;/code&gt; and &lt;code&gt;MinstdRand&lt;/code&gt; might be useful. The standard library provides an alias Random for whichever generator it considers the most fit for the target environment.</source>
          <target state="translated">新型生成器对象保持其自己的状态，因此它们不受线程问题的影响。生成器具有生成随机数的许多众所周知且有据可查的方法。 Mt19937生成器是一种生成随机数的整体快速而可靠的方法，它的名称来源于&amp;ldquo; 周期为2到19937的幂的&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; &amp;rdquo;。在内存受限的情况下，&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;线性同余生成器（&lt;/a&gt;例如 &lt;code&gt;MinstdRand0&lt;/code&gt; 和 &lt;code&gt;MinstdRand&lt;/code&gt; )可能会有用。标准库为它认为最适合目标环境的任何生成器提供一个别名Random。</target>
        </trans-unit>
        <trans-unit id="6e04d5ec9d8b3f77749de3ac5300639b2dab8407" translate="yes" xml:space="preserve">
          <source>The newline following the opening identifier is not part of the string, but the last newline before the closing identifier is part of the string. The closing identifier must be placed on its own line at the leftmost column.</source>
          <target state="translated">开头标识符后的换行不属于字符串的一部分,但结尾标识符前的最后一个换行是字符串的一部分。结尾标识符必须放在最左栏的单独一行。</target>
        </trans-unit>
        <trans-unit id="51929efa4bba26701d3e4c3aa50f3e9c95ba7e57" translate="yes" xml:space="preserve">
          <source>The newly constructed object.</source>
          <target state="translated">新建的对象。</target>
        </trans-unit>
        <trans-unit id="c4d7c48e5f93c9ad9f6d35527dbfa50a57849838" translate="yes" xml:space="preserve">
          <source>The newly-created array, or &lt;code&gt;null&lt;/code&gt; if either &lt;code&gt;length&lt;/code&gt; was &lt;code&gt;0&lt;/code&gt; or allocation failed.</source>
          <target state="translated">新创建的数组；如果 &lt;code&gt;length&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; 或分配失败，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81ee0139f4bf3ca132aff416b4badbbfb8df40c" translate="yes" xml:space="preserve">
          <source>The next unnamed section is the</source>
          <target state="translated">下一个未命名的部分是</target>
        </trans-unit>
        <trans-unit id="4c1d1956fd234c462fed35c0d040ec6b5d07b95f" translate="yes" xml:space="preserve">
          <source>The non-static data members of a struct are called</source>
          <target state="translated">一个结构的非静态数据成员被称为</target>
        </trans-unit>
        <trans-unit id="604fdea6e74692fe9e13e9f5a58a3d2b1b6ac2cf" translate="yes" xml:space="preserve">
          <source>The normal (or Gaussian, or bell-shaped) distribution is defined as:</source>
          <target state="translated">正态分布(或高斯分布,或钟形分布)定义为:</target>
        </trans-unit>
        <trans-unit id="eff21418db566bf6deaa5b9e66141af90f3d37fd" translate="yes" xml:space="preserve">
          <source>The normal flow of program logic is performance critical.</source>
          <target state="translated">程序逻辑的正常流动对性能至关重要。</target>
        </trans-unit>
        <trans-unit id="7d10d0ff78a75299a167b0002f609034c9aaa171" translate="yes" xml:space="preserve">
          <source>The nth &lt;code&gt;ulong&lt;/code&gt; in the representation of this &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;BigInt&lt;/code&gt; 的表示形式中的第n个 &lt;code&gt;ulong&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb3057bb9b7c5b0a70e9ce3b421bd111159e0bc0" translate="yes" xml:space="preserve">
          <source>The nth number to retrieve. Must be less than &lt;a href=&quot;#ulongLength&quot;&gt;&lt;code&gt;ulongLength&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#uintLength&quot;&gt;&lt;code&gt;uintLength&lt;/code&gt;&lt;/a&gt; with respect to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">要检索的第n个数字。关于 &lt;code&gt;T&lt;/code&gt; ,必须小于&lt;a href=&quot;#ulongLength&quot;&gt; &lt;code&gt;ulongLength&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#uintLength&quot;&gt; &lt;code&gt;uintLength&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b76d5847a278447b3f3920d9aa794bc68c09f466" translate="yes" xml:space="preserve">
          <source>The null value which denotes the null state of this &lt;code&gt;Nullable&lt;/code&gt;. Must be of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">表示此 &lt;code&gt;Nullable&lt;/code&gt; 的null状态的null值。必须为 &lt;code&gt;T&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="199b0fb0977641f832ecd7a38d40b0a14f3dad41" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;Tgt&lt;/code&gt; elements written.</source>
          <target state="translated">写入的 &lt;code&gt;Tgt&lt;/code&gt; 元素的数量。</target>
        </trans-unit>
        <trans-unit id="95368522e59bb86a89704bd4d6738e476908f01e" translate="yes" xml:space="preserve">
          <source>The number of bits of state of this generator. This must be a positive multiple of the size in bits of UIntType. If nbits is large this struct may occupy slightly more memory than this so it can use a circular counter instead of shifting the entire array.</source>
          <target state="translated">该生成器的状态位数,必须是UIntType的正数倍。这必须是UIntType的位数大小的正数倍。如果nbits很大,这个结构可能会比这个结构占用稍多的内存,所以它可以使用一个循环计数器,而不是移动整个数组。</target>
        </trans-unit>
        <trans-unit id="ed0599417ff90656d7b8a7db044e9965e3ca5970" translate="yes" xml:space="preserve">
          <source>The number of buffers to cycle through when calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;next&lt;/code&gt; 时要循环通过的缓冲区数。</target>
        </trans-unit>
        <trans-unit id="30308060113660277e7be67f08fdce3f91011c41" translate="yes" xml:space="preserve">
          <source>The number of bytes actually received, &lt;code&gt;0&lt;/code&gt; if the remote side has closed the connection, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">实际接收的字节数，如果远程端已关闭连接， &lt;code&gt;Socket.ERROR&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; ，否则为Socket.ERROR。</target>
        </trans-unit>
        <trans-unit id="52771a2599e853e22c9997ae74caf507a27e6674" translate="yes" xml:space="preserve">
          <source>The number of bytes actually sent, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">实际发送的字节数， &lt;code&gt;Socket.ERROR&lt;/code&gt; 失败，则返回Socket.ERROR。</target>
        </trans-unit>
        <trans-unit id="cb4925770f917957f95841228cf7a081251584ac" translate="yes" xml:space="preserve">
          <source>The number of bytes written to &lt;code&gt;result&lt;/code&gt;. The length, in bytes, of the actual result - very different from getsockopt()</source>
          <target state="translated">写入 &lt;code&gt;result&lt;/code&gt; 的字节数。实际结果的长度（以字节为单位）-与getsockopt（）完全不同</target>
        </trans-unit>
        <trans-unit id="18e0b014069c5b9a5015fd8266605137eb19d431" translate="yes" xml:space="preserve">
          <source>The number of cache levels in the CPU.</source>
          <target state="translated">CPU的缓存级别数。</target>
        </trans-unit>
        <trans-unit id="4e1a5c7628d25ca94f5309da0ccfd2a5e3544707" translate="yes" xml:space="preserve">
          <source>The number of chunks buffered asynchronously</source>
          <target state="translated">异步缓冲的分块数。</target>
        </trans-unit>
        <trans-unit id="d794552fb711e9d13296816f458408c772152acf" translate="yes" xml:space="preserve">
          <source>The number of code units in &lt;code&gt;input&lt;/code&gt; when encoded to &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">编码为 &lt;code&gt;C&lt;/code&gt; 时 &lt;code&gt;input&lt;/code&gt; 的代码单位数</target>
        </trans-unit>
        <trans-unit id="4af8e22ffe4686545114fe30d8267cec1e21b38c" translate="yes" xml:space="preserve">
          <source>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per &lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, section 3&lt;/a&gt;). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1.</source>
          <target state="translated">UTF序列中的代码单元数。对于UTF-8，这是介于1和4之间的值（根据&lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629，第3节&lt;/a&gt;）。对于UTF-16，它是1或2。对于UTF-32，它总是1。</target>
        </trans-unit>
        <trans-unit id="9b086774b97ab095e92a7ab074a4a0747c6a4cdd" translate="yes" xml:space="preserve">
          <source>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per &lt;a href=&quot;https://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, section 3&lt;/a&gt;). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb0aafa3d3443973bc7f248675786f305586655" translate="yes" xml:space="preserve">
          <source>The number of colons in the selector needs to match the number of parameters the method is declared with</source>
          <target state="translated">选择器中冒号的数量需要与方法声明的参数数量相匹配。</target>
        </trans-unit>
        <trans-unit id="cf1a54117f4160455c190793bfbc5f270d3ef431" translate="yes" xml:space="preserve">
          <source>The number of colons in the string need to match the number of arguments the method accept.</source>
          <target state="translated">字符串中的冒号数量需要与方法接受的参数数量一致。</target>
        </trans-unit>
        <trans-unit id="74867ebd8619c3c9f54bb7be26778ccc990cfd33" translate="yes" xml:space="preserve">
          <source>The number of days to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的天数。</target>
        </trans-unit>
        <trans-unit id="17519ebe025dfa827b2543290a321667b7bbfac2" translate="yes" xml:space="preserve">
          <source>The number of elements brought to the front, i.e., the length of &lt;code&gt;back&lt;/code&gt;.</source>
          <target state="translated">带到前面的元素数，即 &lt;code&gt;back&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="30c9197d75a0a694e962a609bbc59e4ba11be6f0" translate="yes" xml:space="preserve">
          <source>The number of elements in an</source>
          <target state="translated">元素的数量</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">数组中元素的数量。</target>
        </trans-unit>
        <trans-unit id="325aeffb680232bb5eba0a4534994930400a1165" translate="yes" xml:space="preserve">
          <source>The number of elements inserted</source>
          <target state="translated">插入的要素数量</target>
        </trans-unit>
        <trans-unit id="4f13d3392d3b50fea45a81fe242fa67f3021e8e8" translate="yes" xml:space="preserve">
          <source>The number of elements inserted.</source>
          <target state="translated">插入的元素数量;</target>
        </trans-unit>
        <trans-unit id="c6d6d4be5d1980bfa9a3ce44b333a124372b6ae3" translate="yes" xml:space="preserve">
          <source>The number of elements removed</source>
          <target state="translated">删除的要素数量</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">删除的元素数量;</target>
        </trans-unit>
        <trans-unit id="a147df2d8f03d61a2cbd49ca985ab3c09c4946c0" translate="yes" xml:space="preserve">
          <source>The number of elements to evaluate in a single &lt;code&gt;Task&lt;/code&gt;. Must be less than or equal to &lt;code&gt;bufSize&lt;/code&gt;, and should be a fraction of &lt;code&gt;bufSize&lt;/code&gt; such that all worker threads can be used. If the default of size_t.max is used, workUnitSize will be set to the pool-wide default.</source>
          <target state="translated">单个 &lt;code&gt;Task&lt;/code&gt; 中要评估的元素数。必须小于或等于 &lt;code&gt;bufSize&lt;/code&gt; ，并且应为 &lt;code&gt;bufSize&lt;/code&gt; 的一部分，以便可以使用所有辅助线程。如果使用默认值size_t.max，则workUnitSize将设置为池范围的默认值。</target>
        </trans-unit>
        <trans-unit id="9de93b8e68b06f4138b723f65ba57f9135fbd680" translate="yes" xml:space="preserve">
          <source>The number of elements which must be popped from the front of &lt;code&gt;haystack&lt;/code&gt; before reaching an element for which &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; for any element in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;-1&lt;/code&gt; is returned. If only &lt;code&gt;pred&lt;/code&gt; is provided, &lt;code&gt;pred(haystack)&lt;/code&gt; is tested for each element.</source>
          <target state="translated">在到达 &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的元素之前必须从 &lt;code&gt;haystack&lt;/code&gt; 的前端弹出的元素数。如果 &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; 对于 &lt;code&gt;haystack&lt;/code&gt; 中的任何元素都不 &lt;code&gt;true&lt;/code&gt; ，则返回 &lt;code&gt;-1&lt;/code&gt; 。如果只有 &lt;code&gt;pred&lt;/code&gt; 设置， &lt;code&gt;pred(haystack)&lt;/code&gt; 对每个元件进行测试。</target>
        </trans-unit>
        <trans-unit id="11ccb90c9b9e42a2c399f8ec744f0b51f68401b5" translate="yes" xml:space="preserve">
          <source>The number of files in this archive.</source>
          <target state="translated">该档案中的文件数量。</target>
        </trans-unit>
        <trans-unit id="495bce27f099960a19a7f2777229fe07b08dc353" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since January 1st, 1 A.D. UTC.</source>
          <target state="translated">世界协调时公元1月1日以来的hnsecs数量。</target>
        </trans-unit>
        <trans-unit id="0128cf9b280876e985f5bc63b3c33b05eec8b671" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since midnight, January 1st, 1 A.D. UTC.</source>
          <target state="translated">自世界协调时公元1月1日午夜以来的hnsecs数量。</target>
        </trans-unit>
        <trans-unit id="dfa696143d106fe9221db705fdd3a015ad40f3ab" translate="yes" xml:space="preserve">
          <source>The number of lines buffered asynchronously</source>
          <target state="translated">异步缓冲的行数。</target>
        </trans-unit>
        <trans-unit id="9bd6f12f8ce1f299c0d0263b77bcc143be77d073" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的月数或年数。</target>
        </trans-unit>
        <trans-unit id="b9c39f066ee7dbe68f94fd81f8c5f3cf00396747" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的月数或年数。</target>
        </trans-unit>
        <trans-unit id="57340a14727c652a36c1e1fc1ba3e2830bbfa123" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的月数或年数。</target>
        </trans-unit>
        <trans-unit id="02485194b1dc362bace73e65c9372da46a13c61b" translate="yes" xml:space="preserve">
          <source>The number of months to add to the time point passed to the delegate.</source>
          <target state="translated">在传递给委托人的时间点上增加月数。</target>
        </trans-unit>
        <trans-unit id="aca30d94828d21a4c6a8ef3a42e227aa33b46f16" translate="yes" xml:space="preserve">
          <source>The number of months to expand the interval by.</source>
          <target state="translated">月数,以扩大间隔。</target>
        </trans-unit>
        <trans-unit id="4f7751ef3f5968bb794d3b81c43237882d9d52ee" translate="yes" xml:space="preserve">
          <source>The number of months to shift the interval by.</source>
          <target state="translated">挪动间隔的月数。</target>
        </trans-unit>
        <trans-unit id="63a68d030d7307514d07c50786c06b3b1b3f26d9" translate="yes" xml:space="preserve">
          <source>The number of pages is variable (but not less then 1) unlike the number of entries in the index. The slots of the index all have to contain a number of a page that is present. The lookup is then just a couple of operations - slice the upper bits, lookup an index for these, take a page at this index and use the lower bits as an offset within this page.</source>
          <target state="translated">与索引中的条目数不同,页数是可变的(但不能小于1)。索引的槽位都要包含一个存在的页数。那么查找就只需要几个操作--切开上位,查找这些的索引,在这个索引处取一个页,然后用下位作为这个页内的偏移。</target>
        </trans-unit>
        <trans-unit id="a4a9d929861b7f4540e0616b20649c026af1b75f" translate="yes" xml:space="preserve">
          <source>The number of positions in the &lt;code&gt;haystack&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returned true.</source>
          <target state="translated">在 &lt;code&gt;haystack&lt;/code&gt; 中 &lt;code&gt;pred&lt;/code&gt; 返回true 的职位数。</target>
        </trans-unit>
        <trans-unit id="e5d60a9e70df9e4591b2299d06f99ccc91195edd" translate="yes" xml:space="preserve">
          <source>The number of sockets with status changes, &lt;code&gt;0&lt;/code&gt; on timeout, or &lt;code&gt;-1&lt;/code&gt; on interruption. If the return value is greater than &lt;code&gt;0&lt;/code&gt;, the &lt;code&gt;SocketSets&lt;/code&gt; are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.  &lt;code&gt;SocketSet&lt;/code&gt;'s updated to include only those sockets which an event occured. For a &lt;code&gt;connect()&lt;/code&gt;ing socket, writeability means connected. For a &lt;code&gt;listen()&lt;/code&gt;ing socket, readability means listening &lt;code&gt;Winsock&lt;/code&gt;; possibly internally limited to 64 sockets per set.</source>
          <target state="translated">状态更改的套接字数，超时时为 &lt;code&gt;0&lt;/code&gt; 或中断时为 &lt;code&gt;-1&lt;/code&gt; 。如果返回值大于 &lt;code&gt;0&lt;/code&gt; ，则将 &lt;code&gt;SocketSets&lt;/code&gt; 更新为仅包含状态更改的套接字。对于连接套接字，写状态更改意味着已建立连接并且可以发送连接。对于侦听套接字，读取状态更改意味着存在传入的连接请求，并且可以接受。 &lt;code&gt;SocketSet&lt;/code&gt; 的更新为仅包括发生事件的那些套接字。对于 &lt;code&gt;connect()&lt;/code&gt; 套接字，可写性表示已连接。对于 &lt;code&gt;listen()&lt;/code&gt; 套接字，可读性意味着监听 &lt;code&gt;Winsock&lt;/code&gt; ; 可能内部限制为每组64个套接字。</target>
        </trans-unit>
        <trans-unit id="92623bd7d09398f80bbab3bb0f5f2ef38d3da421" translate="yes" xml:space="preserve">
          <source>The number of system ticks in this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;TickDuration&lt;/code&gt; 中的系统刻度数。</target>
        </trans-unit>
        <trans-unit id="7611dde88762f088b010293dbcd7b4751f9ec60a" translate="yes" xml:space="preserve">
          <source>The number of the disk where this member can be found.</source>
          <target state="translated">该成员所在磁盘的编号。</target>
        </trans-unit>
        <trans-unit id="8f11ee7d7d27eb3d41061b45eac584df0b5f1cfe" translate="yes" xml:space="preserve">
          <source>The number of ticks in the TickDuration.</source>
          <target state="translated">TickDuration中的tick数。</target>
        </trans-unit>
        <trans-unit id="c3535c21516c22bad36e4ae79f60e710279eebd0" translate="yes" xml:space="preserve">
          <source>The number of ticks in the monotonic time.</source>
          <target state="translated">在单调的时间里,蜱虫的数量。</target>
        </trans-unit>
        <trans-unit id="133c2247d181f5eb459c19f2950580ed684e418a" translate="yes" xml:space="preserve">
          <source>The number of ticks that MonoTime has per second - i.e. the resolution or frequency of the system's monotonic clock.</source>
          <target state="translated">MonoTime每秒拥有的滴数--即系统单调时钟的分辨率或频率。</target>
        </trans-unit>
        <trans-unit id="8271982f8f2afc20c964508f18ca6b32767857e7" translate="yes" xml:space="preserve">
          <source>The number of ticks that the system clock has in one second.</source>
          <target state="translated">系统时钟在一秒钟内的跳动次数。</target>
        </trans-unit>
        <trans-unit id="8b51266ea49a500bd86819d90d5f5babd9fda252" translate="yes" xml:space="preserve">
          <source>The number of times each function is to be executed.</source>
          <target state="translated">每个函数的执行次数。</target>
        </trans-unit>
        <trans-unit id="f1050ae226927365357fc51efba9b81760d7056b" translate="yes" xml:space="preserve">
          <source>The number of times the output range's &lt;code&gt;put&lt;/code&gt; method was invoked.</source>
          <target state="translated">调用输出范围的 &lt;code&gt;put&lt;/code&gt; 方法的次数。</target>
        </trans-unit>
        <trans-unit id="4d82522805f2ebbbf559fec74a61f5c7cb9cc3a6" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 的单位数。</target>
        </trans-unit>
        <trans-unit id="794f084381c766ea0ff9fffa3e14bba305b1eb34" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 中的单位数。</target>
        </trans-unit>
        <trans-unit id="22c3d0c8685c468fadcdccd79c29727ddf2e7e9a" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的单位数。</target>
        </trans-unit>
        <trans-unit id="9b148446ca97774856b435f40497b3469e8ca6ab" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的单位数。</target>
        </trans-unit>
        <trans-unit id="b3b24aff6aba1d0b2f312ff80d7560f7feabc059" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;的单位数。</target>
        </trans-unit>
        <trans-unit id="37c2540cc1f38510b5307fd0d898532d4c17f0e5" translate="yes" xml:space="preserve">
          <source>The number of units to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">该 &lt;code&gt;Duration&lt;/code&gt; 乘以的单位数。</target>
        </trans-unit>
        <trans-unit id="5f6b34534215487ddb13229d1e9eb704abfb659b" translate="yes" xml:space="preserve">
          <source>The number of values inserted.</source>
          <target state="translated">插入的值的数量。</target>
        </trans-unit>
        <trans-unit id="d14be6e779a48d8faa82f80e4dc078722606651d" translate="yes" xml:space="preserve">
          <source>The number of waiting threads to release in unison.</source>
          <target state="translated">等候线程的数量来统一释放。</target>
        </trans-unit>
        <trans-unit id="365cb2c08dafe42960332e827da68e53b00a9bd8" translate="yes" xml:space="preserve">
          <source>The number of years to add to the time point passed to the delegate.</source>
          <target state="translated">在传递给代表的时间点上增加年数。</target>
        </trans-unit>
        <trans-unit id="fcc2e5d2212e8d8be70b8d4677e493fc3848a020" translate="yes" xml:space="preserve">
          <source>The number of years to expand the interval by.</source>
          <target state="translated">年数,以扩大间隔。</target>
        </trans-unit>
        <trans-unit id="2241ab252f8a5484883abb33a8af4a6dad25eb69" translate="yes" xml:space="preserve">
          <source>The number of years to shift the interval by.</source>
          <target state="translated">挪动间隔的年数。</target>
        </trans-unit>
        <trans-unit id="ab33e33805a08eda08dd986381c2b8f8b862f93b" translate="yes" xml:space="preserve">
          <source>The number to validate.</source>
          <target state="translated">要验证的数字。</target>
        </trans-unit>
        <trans-unit id="b28803e23c2f1bebd73a4d48e79b273e730f7db3" translate="yes" xml:space="preserve">
          <source>The numeric literals &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; can be implicitly converted to the &lt;code&gt;bool&lt;/code&gt; values &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;, respectively. Casting an expression to &lt;code&gt;bool&lt;/code&gt; means testing for &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;!=0&lt;/code&gt; for arithmetic types, and &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;!=null&lt;/code&gt; for pointers or references.</source>
          <target state="translated">可以将数字文字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 隐式转换为 &lt;code&gt;bool&lt;/code&gt; 值 &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; 。将表达式转换为 &lt;code&gt;bool&lt;/code&gt; 意味着对于算术类型测试为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;!=0&lt;/code&gt; ，对于指针或引用测试为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;!=null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe0da3c8ef7d3c766ce89becdf0b23671a0397f9" translate="yes" xml:space="preserve">
          <source>The numeric version number is also available &quot;in parts&quot; by using these constants</source>
          <target state="translated">数字化的版本号也可以通过使用这些常数 &quot;分批 &quot;提供。</target>
        </trans-unit>
        <trans-unit id="126529265bda77a1ffa31840d1614e6dc6547606" translate="yes" xml:space="preserve">
          <source>The object to throw.</source>
          <target state="translated">要扔的对象。</target>
        </trans-unit>
        <trans-unit id="917127d4e18a9f0f96c8fddb70a363dd7f1bb7b1" translate="yes" xml:space="preserve">
          <source>The object-oriented features of D all come from classes. The class hierarchy has as its root the class Object. Object defines a minimum level of functionality that each derived class has, and a default implementation for that functionality.</source>
          <target state="translated">D的面向对象特性都来自于类。类的层次结构以类Object为根。Object定义了每个派生类所具有的最低功能级别,以及该功能的默认实现。</target>
        </trans-unit>
        <trans-unit id="83450785309cc6865682ad266cad8f967bd48d27" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that comparingBenchmark has not been ported over, because it's a trivial wrapper around benchmark. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。注意，comparingBenchmark尚未移植，因为它是围绕基准的琐碎包装。请参阅&lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="efeb1eab4dde5b659a31f85b9f2c2ca05099ac2d" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that measureTime has not been ported over, because it's a trivial wrapper around StopWatch. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。请注意，measureTime尚未移植，因为它是StopWatch的一个小包装。请参阅&lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="8251e06b859fc1bf7834e47982a51786233d653a" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt;&lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。请参阅&lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt; &lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="3836851ebe09983822b4948475513fd0ffdb5b68" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。请参阅&lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="852cd69a4d8476a6740350b9e4fa04e022f147f2" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。请参阅&lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="e2b766119f4b2cc6bf40fa4a91668ec3bf749415" translate="yes" xml:space="preserve">
          <source>The one area in which this function violates RFC 5322 is that it accepts &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in folding whitespace in the place of &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, because the HTTP spec requires it.</source>
          <target state="translated">此功能违反RFC 5322 的地方是因为HTTP规范要求它在折叠空格中代替 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 接受 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e2e3dd788c39da352fad71950c0b91387508356" translate="yes" xml:space="preserve">
          <source>The one shared instance.</source>
          <target state="translated">的一个共享实例。</target>
        </trans-unit>
        <trans-unit id="c72b10055e71a8b6b107b05c7231e9b97b023ff1" translate="yes" xml:space="preserve">
          <source>The only accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">唯一接受的单位是 &lt;code&gt;&quot;days&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5649b3ae07a628e1e89097ca2f1b006efdc1767" translate="yes" xml:space="preserve">
          <source>The only operators that can accept operands of type bool are: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, !, &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;?:&lt;/code&gt;.</source>
          <target state="translated">唯一可以接受bool类型的操作数的运算符是： &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;^=&lt;/code&gt; ，！ ＆ &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;?:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8437a6599312b98a4f8ede285a1950b78c0b6f0d" translate="yes" xml:space="preserve">
          <source>The only operators that can accept operands of type bool are: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt; ! &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;?:&lt;/code&gt;.</source>
          <target state="translated">唯一可以接受bool类型的操作数的运算符是： &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; ！ &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;?:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1537443715ac19491a620a6f1ab8a8c13f12a2ec" translate="yes" xml:space="preserve">
          <source>The only pointers that are tracked are those declared in the &lt;code&gt;@live&lt;/code&gt; function as &lt;code&gt;this&lt;/code&gt;, function parameters or local variables. Variables from other functions are not tracked, even &lt;code&gt;@live&lt;/code&gt; ones, as the analysis of interactions with other functions depends entirely on that function signature, not its internals. Parameters that are &lt;code&gt;const&lt;/code&gt; are not tracked.</source>
          <target state="translated">唯一被跟踪的指针是在 &lt;code&gt;@live&lt;/code&gt; 函数中声明为 &lt;code&gt;this&lt;/code&gt; ，函数参数或局部变量的指针。不会跟踪其他函数的变量，即使是 &lt;code&gt;@live&lt;/code&gt; 也不跟踪，因为与其他函数的交互分析完全取决于该函数签名，而不是其内部。不会跟踪 &lt;code&gt;const&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="984e1c71edfda04f82606405d232f57e26747587" translate="yes" xml:space="preserve">
          <source>The only reason to have a max limit for this is to avoid the risk of a bad server feeding libcurl with a never-ending header that will cause reallocs infinitely</source>
          <target state="translated">设置最大限制的唯一原因是为了避免服务器给libcurl提供一个无休止的头,从而导致reallocs无穷无尽的风险。</target>
        </trans-unit>
        <trans-unit id="6b3469bf6885e1dc5e98c3245a18dbbf237d2baa" translate="yes" xml:space="preserve">
          <source>The opAssign function will be built for a struct &lt;code&gt;S&lt;/code&gt; if the following constraints are met:</source>
          <target state="translated">如果满足以下约束，则将为结构 &lt;code&gt;S&lt;/code&gt; 构建opAssign函数：</target>
        </trans-unit>
        <trans-unit id="7e056906d7315529b66ec021904f0bc134465c13" translate="yes" xml:space="preserve">
          <source>The operand syntax more or less follows the Intel CPU documentation conventions. In particular, the convention is that for two operand instructions the source is the right operand and the destination is the left operand. The syntax differs from that of Intel's in order to be compatible with the D language tokenizer and to simplify parsing.</source>
          <target state="translated">操作数语法或多或少地遵循了英特尔CPU文档的惯例。特别是,约定对于两个操作数指令,源操作数为右操作数,目的操作数为左操作数。为了与D语言tokenizer兼容和简化解析,其语法与Intel的不同。</target>
        </trans-unit>
        <trans-unit id="73d4a21766587b932de571c9748f396e770947d7" translate="yes" xml:space="preserve">
          <source>The operands are AND'd together.</source>
          <target state="translated">操作数是一起AND的。</target>
        </trans-unit>
        <trans-unit id="8d68364ecd5a5efc98bbefe2167cf9e02f879955" translate="yes" xml:space="preserve">
          <source>The operands are OR'd together.</source>
          <target state="translated">操作数是一起OR的。</target>
        </trans-unit>
        <trans-unit id="164b0a5deb7171b65940816115319c8c761747b7" translate="yes" xml:space="preserve">
          <source>The operands are XOR'd together.</source>
          <target state="translated">操作数是一起XOR的。</target>
        </trans-unit>
        <trans-unit id="efb02cff4c27dc22b01308f5fbd88aaf28eb4b20" translate="yes" xml:space="preserve">
          <source>The operands must be arithmetic types. They undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">操作数必须是算术类型。他们经历了&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常的算术转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d66ba90561dbdef784a715ae4ab9b7cee0e0776" translate="yes" xml:space="preserve">
          <source>The operands must be integral types, and undergo the &lt;a href=&quot;type#integer-promotions&quot;&gt;Integer Promotions&lt;/a&gt;. The result type is the type of the left operand after the promotions. The result value is the result of shifting the bits by the right operand's value.</source>
          <target state="translated">操作数必须是整数类型，并且必须经过&lt;a href=&quot;type#integer-promotions&quot;&gt;整数提升&lt;/a&gt;。结果类型是提升后左操作数的类型。结果值是将位移位右操作数的值的结果。</target>
        </trans-unit>
        <trans-unit id="194f20d5a432fe368709d99fb1ac7743c7e38bcc" translate="yes" xml:space="preserve">
          <source>The operation takes time proportional to the number of adjacent free blocks at the front of the free list. These blocks get coalesced, whether &lt;code&gt;allocateAll&lt;/code&gt; succeeds or fails due to fragmentation.</source>
          <target state="translated">该操作花费的时间与空闲列表前面的相邻空闲块的数量成正比。这些块将合并，无论是由于碎片， &lt;code&gt;allocateAll&lt;/code&gt; 是成功还是失败。</target>
        </trans-unit>
        <trans-unit id="f1c4e404ec78b75726373485d13f7546b584f7c2" translate="yes" xml:space="preserve">
          <source>The operator involved</source>
          <target state="translated">所涉经营者</target>
        </trans-unit>
        <trans-unit id="56d4f8f0aeb6a713fa59381e88345eb1ab065529" translate="yes" xml:space="preserve">
          <source>The operator involved (without the &lt;code&gt;&quot;=&quot;&lt;/code&gt;, e.g. &lt;code&gt;&quot;+&quot;&lt;/code&gt; for &lt;code&gt;&quot;+=&quot;&lt;/code&gt; etc)</source>
          <target state="translated">所涉及的运算符（不带 &lt;code&gt;&quot;=&quot;&lt;/code&gt; ，例如， &lt;code&gt;&quot;+&quot;&lt;/code&gt; 代表 &lt;code&gt;&quot;+=&quot;&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="141e2b7ce22914ac93e27f77aab194720297a6c0" translate="yes" xml:space="preserve">
          <source>The operator involved in the &lt;code&gt;opAssign&lt;/code&gt; operation</source>
          <target state="translated">参与 &lt;code&gt;opAssign&lt;/code&gt; 操作的操作员</target>
        </trans-unit>
        <trans-unit id="c70edf6dccf2f2bcea3add3cefb68aaf253c7966" translate="yes" xml:space="preserve">
          <source>The operator symbol</source>
          <target state="translated">操作符号</target>
        </trans-unit>
        <trans-unit id="a647036ebf74c7864e90900632a3906ffefe590e" translate="yes" xml:space="preserve">
          <source>The operator symbol (without the &lt;code&gt;=&lt;/code&gt;)</source>
          <target state="translated">运算符（不带 &lt;code&gt;=&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e53e52b5f08d1bbd687148f6992aae7c464c1b9d" translate="yes" xml:space="preserve">
          <source>The operator, e.g. &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">操作员，例如 &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="638907907a566c0abcca8d70105d1f419f1a935d" translate="yes" xml:space="preserve">
          <source>The option &quot;--Foo&quot; is rejected due to &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt;, but not &quot;--Bar&quot;, &quot;--bAr&quot; etc. because the directive &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; turned sensitivity off before option &quot;bar&quot; was parsed.</source>
          <target state="translated">选项&amp;ldquo; --Foo&amp;rdquo;由于 &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt; 而被拒绝，但由于&amp;ldquo; --Bar&amp;rdquo;，&amp;ldquo;-bAr&amp;rdquo;等原因而被拒绝，因为伪指令 &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; 在选项&amp;ldquo;之前关闭了灵敏度&amp;rdquo;栏&amp;rdquo;被解析。</target>
        </trans-unit>
        <trans-unit id="ca52d0f89f2c76dbc26910f2e62e7d1ae6cb85b2" translate="yes" xml:space="preserve">
          <source>The option character (default '-').</source>
          <target state="translated">选项字符(默认为'-')。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">可选的</target>
        </trans-unit>
        <trans-unit id="2c9d42a79cf23316432c06818064db7b0873ce86" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; may be used to assign arbitrary &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; objects as the standard input, output and error streams, respectively, of the child process. The former must be opened for reading, while the latter two must be opened for writing. The default is for the child process to inherit the standard streams of its parent.</source>
          <target state="translated">可选参数 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 可用于将任意&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;对象分配为子进程的标准输入，输出和错误流。前者必须开放供阅读，而后两者必须开放供写作。子进程的默认设置是继承其父进程的标准流。</target>
        </trans-unit>
        <trans-unit id="fa35856038ac4a3b33d6b7f25cf0f4d58ca154fb" translate="yes" xml:space="preserve">
          <source>The optional identifier in either type of &lt;code&gt;out&lt;/code&gt; contract is set to the return value of the function.</source>
          <target state="translated">两种类型的 &lt;code&gt;out&lt;/code&gt; 合同中的可选标识符都设置为函数的返回值。</target>
        </trans-unit>
        <trans-unit id="2a198d0d9bb81399553ce901d094fc3b34485c1e" translate="yes" xml:space="preserve">
          <source>The optional parameters &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt; are meant for avoiding duplicate computation. Many applications may have already computed &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; and/or &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt;. In that case, they can be passed as &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt;, respectively.</source>
          <target state="translated">可选参数 &lt;code&gt;sSelfSim&lt;/code&gt; 和 &lt;code&gt;tSelfSim&lt;/code&gt; 用于避免重复计算。许多应用程序可能已经计算了 &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; 和/或 &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt; 。在这种情况下，它们可以分别作为 &lt;code&gt;sSelfSim&lt;/code&gt; 和 &lt;code&gt;tSelfSim&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="5c87a0f28ba13b43a3c29d6c4b297e44986adfc3" translate="yes" xml:space="preserve">
          <source>The optional second &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; can be used to supply additional information, such as a text string, that will be printed out along with the error diagnostic.</source>
          <target state="translated">可选的第二个&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;可用于提供其他信息，例如文本字符串，这些信息将与错误诊断一起打印出来。</target>
        </trans-unit>
        <trans-unit id="c53af2790b7d2658a475ec200743c6decbbbabb1" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;minSize == unbounded&lt;/code&gt; and &lt;code&gt;maxSize == unbounded&lt;/code&gt; are not available for &lt;code&gt;ContiguousFreeList&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;minSize == unbounded&lt;/code&gt; 和 &lt;code&gt;maxSize == unbounded&lt;/code&gt; 不适用于 &lt;code&gt;ContiguousFreeList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="908f73a8a6b26eae214ea14d01c95ac8e585a696" translate="yes" xml:space="preserve">
          <source>The options corresponding to the statistics collected.</source>
          <target state="translated">与所收集的统计数据相对应的选项。</target>
        </trans-unit>
        <trans-unit id="9f44bfb42bea099b410e3ae043b64bf941a3d3a9" translate="yes" xml:space="preserve">
          <source>The order in which</source>
          <target state="translated">顺序</target>
        </trans-unit>
        <trans-unit id="b05eb5dee9e8e5735c1321572abe7fba26d328c8" translate="yes" xml:space="preserve">
          <source>The order in which modules are called to run their unit tests.</source>
          <target state="translated">调用模块运行单元测试的顺序。</target>
        </trans-unit>
        <trans-unit id="ded62be1138c956a50d03fffedad7ec44e6f9533" translate="yes" xml:space="preserve">
          <source>The order in which modules are imported does not affect the semantics.</source>
          <target state="translated">模块导入的顺序不影响语义。</target>
        </trans-unit>
        <trans-unit id="506073a2cdf721a37f43310020509dea0ea03bee" translate="yes" xml:space="preserve">
          <source>The order in which the array elements are computed is implementation defined, and may even occur in parallel. An application must not depend on this order.</source>
          <target state="translated">数组元素的计算顺序是由实现定义的,甚至可以并行进行。应用程序不能依赖于这个顺序。</target>
        </trans-unit>
        <trans-unit id="fae272dd73f8d57ce9c199e28861d6ffb1d9af6c" translate="yes" xml:space="preserve">
          <source>The order in which the strings appear in the result is not defined.</source>
          <target state="translated">结果中字符串出现的顺序没有定义。</target>
        </trans-unit>
        <trans-unit id="ce7e17de4cb24469d3444a40e36096efcb9cbfd4" translate="yes" xml:space="preserve">
          <source>The order is defined as follows:</source>
          <target state="translated">顺序定义如下:</target>
        </trans-unit>
        <trans-unit id="29a373653e2bfc1cca0d961f259da0c1298ecbea" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments for functions with linkage other than &lt;code&gt;extern (D)&lt;/code&gt;.</source>
          <target state="translated">具有除 &lt;code&gt;extern (D)&lt;/code&gt; 以外的链接的函数的函数自变量的求值顺序。</target>
        </trans-unit>
        <trans-unit id="a021fc1e222d6a27aea27e4b5f97128841b9a128" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;操作数的&lt;i&gt;求值顺序&lt;/i&gt;。</target>
        </trans-unit>
        <trans-unit id="2d093662468f96c13ae9c5b9d6116c7cabff1635" translate="yes" xml:space="preserve">
          <source>The order of execution within a function is controlled by &lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statement&lt;/i&gt;&lt;/a&gt;s. A function's body consists of a sequence of zero or more</source>
          <target state="translated">函数中的执行顺序由&lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statements&lt;/i&gt;&lt;/a&gt;控制。函数的主体由零个或多个序列组成</target>
        </trans-unit>
        <trans-unit id="86b67a2b0c6a048e601645470c096d4bbf2604b6" translate="yes" xml:space="preserve">
          <source>The order of static initialization is implicitly determined by the</source>
          <target state="translated">静态初始化的顺序隐含在由</target>
        </trans-unit>
        <trans-unit id="24e23dd7191b5b1c5bce0de2b67d0f3911ebed53" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum) element.</source>
          <target state="translated">用于确定极限(最小或最大)元素的排序谓词。</target>
        </trans-unit>
        <trans-unit id="15fe5b10e5755a86213c0dc1ab135ad913a77ba2" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum).</source>
          <target state="translated">用于确定极限值(最小或最大)的排序谓词。</target>
        </trans-unit>
        <trans-unit id="15cad23161bf9aec9c429568dd291ae988b53252" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the maximum element.</source>
          <target state="translated">用于确定最大元素的排序谓词。</target>
        </trans-unit>
        <trans-unit id="c31f591c19316494ae227e4269b1bc55d8071c12" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the minimum element.</source>
          <target state="translated">用来确定最小元素的排序谓词。</target>
        </trans-unit>
        <trans-unit id="c29760283ce7793aa4d7bc71616456fe1b03fbb5" translate="yes" xml:space="preserve">
          <source>The ordering to be used to determine lexicographical ordering of the permutations.</source>
          <target state="translated">用来确定排列组合的词性顺序。</target>
        </trans-unit>
        <trans-unit id="e1d7ba6a0bf70661c8825f1616095c8946712ba1" translate="yes" xml:space="preserve">
          <source>The original input string which should have been parsed.</source>
          <target state="translated">应该被解析的原始输入字符串。</target>
        </trans-unit>
        <trans-unit id="d69e475dd9b96313d02abbca4307d1659af41d28" translate="yes" xml:space="preserve">
          <source>The original range.</source>
          <target state="translated">原来的范围。</target>
        </trans-unit>
        <trans-unit id="8724db772d60fec4013f34182f1e847ecec76068" translate="yes" xml:space="preserve">
          <source>The original string.</source>
          <target state="translated">原来的字符串。</target>
        </trans-unit>
        <trans-unit id="59de85bb0dd2a62ce448e919359e8b24cc7a90ea" translate="yes" xml:space="preserve">
          <source>The osthread module provides low-level, OS-dependent code for thread creation and management.</source>
          <target state="translated">osthread模块为线程的创建和管理提供了低级的、依赖于操作系统的代码。</target>
        </trans-unit>
        <trans-unit id="2c0e83de5dd344b677213345fa51e9db2eed3ab8" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ClockType&lt;/code&gt;s are provided so that other clocks provided by the underlying C, system calls can be used with &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; without having to use the C API directly.</source>
          <target state="translated">提供了其他 &lt;code&gt;ClockType&lt;/code&gt; ，以便底层C，系统调用提供的其他时钟可以与&lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; 一起使用，而不必直接使用C API。</target>
        </trans-unit>
        <trans-unit id="c97e71bfcc50324ba20390fc9837bc308a37f3b9" translate="yes" xml:space="preserve">
          <source>The other piece of data used is the DWARF &lt;code&gt;.debug_line&lt;/code&gt; section, which contains the line informations of a program, necessary to associate the instruction address with its (file, line) information.  Since debug lines informations are quite large, they are encoded using a program that is to be fed to a finite state machine. See &lt;code&gt;runStateMachine&lt;/code&gt; and &lt;code&gt;readLineNumberProgram&lt;/code&gt; for more details.</source>
          <target state="translated">使用的另一条数据是DWARF &lt;code&gt;.debug_line&lt;/code&gt; 部分，其中包含程序的行信息，该信息是将指令地址与其（文件，行）信息相关联所必需的。由于调试行信息非常大，因此使用要馈送到有限状态机的程序对它们进行编码。有关更多详细信息，请参见 &lt;code&gt;runStateMachine&lt;/code&gt; 和 &lt;code&gt;readLineNumberProgram&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">产出是:</target>
        </trans-unit>
        <trans-unit id="a69373623c7518d00fa36ea24366f398f8ce8bad" translate="yes" xml:space="preserve">
          <source>The output of the code above is:</source>
          <target state="translated">上述代码的输出是:</target>
        </trans-unit>
        <trans-unit id="515b77d0f9f95e74d1d9b053ac5339be1c82aca5" translate="yes" xml:space="preserve">
          <source>The output range used to write the help information.</source>
          <target state="translated">用于编写帮助信息的输出范围。</target>
        </trans-unit>
        <trans-unit id="708e6e32f4bb4d910b35568c24af1ecbdd8ae5b7" translate="yes" xml:space="preserve">
          <source>The overflow indicator (assigned &lt;code&gt;true&lt;/code&gt; in case there's an error)</source>
          <target state="translated">溢出指示器（如果有错误，则分配为 &lt;code&gt;true&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="49d360d20fd79e75a1f6f41c1f5efdbc589a5b18" translate="yes" xml:space="preserve">
          <source>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end.</source>
          <target state="translated">溢出是粘性的,也就是说可以进行一系列的操作,只需要在最后检查溢出即可。</target>
        </trans-unit>
        <trans-unit id="ef93ac8e948c5ada2f00084b4ec036473c66f367" translate="yes" xml:space="preserve">
          <source>The overlapping portion of the two arrays.</source>
          <target state="translated">两个阵列的重叠部分。</target>
        </trans-unit>
        <trans-unit id="fae150090ecb0366b43d58bfc4a6f3010da8d11c" translate="yes" xml:space="preserve">
          <source>The overload which accepts function arguments takes integral types in the order that the time unit strings were given, and those integers are passed by &lt;code&gt;ref&lt;/code&gt;. split assigns the values for the units to each corresponding integer. Any integral type may be used, but no attempt is made to prevent integer overflow, so don't use small integral types in circumstances where the values for those units aren't likely to fit in an integral type that small.</source>
          <target state="translated">接受函数参数的重载按时间单位字符串给出的顺序采用整数类型，这些整数由 &lt;code&gt;ref&lt;/code&gt; 传递。split将单位的值分配给每个对应的整数。可以使用任何整数类型，但是不会尝试防止整数溢出，因此，在那些单位的值不太可能适合这么小的整数类型的情况下，请不要使用较小的整数类型。</target>
        </trans-unit>
        <trans-unit id="8a27d36415963d11bb0a2a74d725380e58b5b81a" translate="yes" xml:space="preserve">
          <source>The overload with no arguments returns the values for the units in a struct with members whose names are the same as the given time unit strings. The members are all &lt;code&gt;long&lt;/code&gt;s. This overload will also work with no time strings being given, in which case</source>
          <target state="translated">没有参数的重载将返回结构中具有其名称与给定时间单位字符串相同的成员的单位的值。成员都是 &lt;code&gt;long&lt;/code&gt; 的。在没有给出时间字符串的情况下，这种重载也可以工作，在这种情况下</target>
        </trans-unit>
        <trans-unit id="36651e7ea0b89af408ad5149a0f7f1de2f23e2a1" translate="yes" xml:space="preserve">
          <source>The owner is the sole pointer to a memory object graph. An Owner pointer normally does not have a &lt;code&gt;scope&lt;/code&gt; attribute. If a pointer with the &lt;code&gt;scope&lt;/code&gt; attribute is initialized with an expression not derived from a tracked pointer, it is an Owner.  If an Owner pointer is assigned to another Owner pointer, the former enters the Undefined state.</source>
          <target state="translated">所有者是指向内存对象图的唯一指针。所有者指针通常没有 &lt;code&gt;scope&lt;/code&gt; 属性。如果使用不是从跟踪指针派生的表达式初始化具有 &lt;code&gt;scope&lt;/code&gt; 属性的指针，则它是所有者。如果将一个所有者指针分配给另一个所有者指针，则前者将进入&amp;ldquo;未定义&amp;rdquo;状态。</target>
        </trans-unit>
        <trans-unit id="260af145e3cbda28a26f16fe1989f4e1c8d1a0d0" translate="yes" xml:space="preserve">
          <source>The package module can then be imported with the standard module import declaration:</source>
          <target state="translated">然后可以用标准的模块导入声明导入包模块。</target>
        </trans-unit>
        <trans-unit id="5512330e5fcd74efc6dbc5aca616099f51685035" translate="yes" xml:space="preserve">
          <source>The package module must have the file name &lt;code&gt;package.d&lt;/code&gt;. The module name is declared to be the fully qualified name of the package. Package modules can be imported just like any other modules:</source>
          <target state="translated">软件包模块必须具有文件名 &lt;code&gt;package.d&lt;/code&gt; 。模块名称被声明为软件包的标准名称。包模块可以像其他模块一样导入：</target>
        </trans-unit>
        <trans-unit id="e03b2152cc1b6a58ba8032733b5d2def3eb73480" translate="yes" xml:space="preserve">
          <source>The package module's file name must be &lt;code&gt;package.d&lt;/code&gt;. The module name is declared to be the fully qualified name of the package. Package modules can be imported just like any other modules:</source>
          <target state="translated">软件包模块的文件名必须为 &lt;code&gt;package.d&lt;/code&gt; 。模块名称被声明为程序包的标准名称。包模块可以像其他模块一样导入：</target>
        </trans-unit>
        <trans-unit id="136770d3c4f96881a7cd83ac52b3b200de071989" translate="yes" xml:space="preserve">
          <source>The padding data can be accessed, but its contents are undefined.</source>
          <target state="translated">可以访问padding数据,但其内容未定义。</target>
        </trans-unit>
        <trans-unit id="c23637ad29e92d690ee7e91ffa4bbac52dae1105" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;level&lt;/code&gt; indicates the number of trie levels to use, allowed values are: 1, 2, 3 or 4. Levels represent different trade-offs speed-size wise.</source>
          <target state="translated">参数 &lt;code&gt;level&lt;/code&gt; 指示要使用的特里级别的数量，允许的值为：1、2、3或4。级别表示不同的权衡速度大小明智的选择。</target>
        </trans-unit>
        <trans-unit id="0ee7ae2b2ebe38b1747e38029361876a0bcd2e42" translate="yes" xml:space="preserve">
          <source>The parameter is an</source>
          <target state="translated">该参数是一个</target>
        </trans-unit>
        <trans-unit id="14dbb4daa817a9a1b69f1e2b66e17c6c825d9628" translate="yes" xml:space="preserve">
          <source>The parameter is an input to the function. Input parameters behaves as if they have the &lt;code&gt;const scope&lt;/code&gt; storage classes. Input parameters may be passed by reference by the compiler. Unlike &lt;code&gt;ref&lt;/code&gt; parameters, &lt;code&gt;in&lt;/code&gt; parameters can bind to both lvalues and rvalues (such as literals). Types that would trigger a side effect if passed by value (such as types with postblit, copy constructor, or destructor), and types which cannot be copied, e.g. if their copy constructor is marked as &lt;code&gt;@disable&lt;/code&gt;, will always be passed by reference. Dynamic arrays, classes, associative arrays, function pointers, and delegates will always be passed by value, to allow for covariance. If the type of the parameter does not fall in one of those categories, whether or not it is passed by reference is implementation defined, and the backend is free to choose the method that will best fit the ABI of the platform. Note: This requires the &lt;code&gt;-preview=in&lt;/code&gt; switch, available in v2.094.0 or higher.</source>
          <target state="translated">参数是函数的输入。输入参数的行为就像它们具有 &lt;code&gt;const scope&lt;/code&gt; 存储类一样。输入参数可以由编译器通过引用传递。与 &lt;code&gt;ref&lt;/code&gt; 参数不同， &lt;code&gt;in&lt;/code&gt; 参数可以绑定到左值和右值（例如文字）。如果通过值传递将触发副作用的类型（例如具有postblit，复制构造函数或析构函数的类型）以及无法复制的类型，例如，如果将其复制构造函数标记为 &lt;code&gt;@disable&lt;/code&gt; ，将始终通过引用传递。动态数组，类，关联数组，函数指针和委托将始终按值传递，以实现协方差。如果参数的类型不属于这些类别之一，则是否通过引用传递参数都由实现定义，并且后端可以自由选择最适合平台ABI的方法。注意：这需要 &lt;code&gt;-preview=in&lt;/code&gt; 开关（在v2.094.0或更高版本中可用）。</target>
        </trans-unit>
        <trans-unit id="0758911fe007939762ea0a98ab73ee500552cb01" translate="yes" xml:space="preserve">
          <source>The parameter may be a number (as shown in the example above) dictating the size of each chunk. Alternatively, &lt;code&gt;byChunk&lt;/code&gt; accepts a user-provided buffer that it uses directly.</source>
          <target state="translated">该参数可以是指示每个块大小的数字（如上例所示）。或者， &lt;code&gt;byChunk&lt;/code&gt; 接受它直接使用的用户提供的缓冲区。</target>
        </trans-unit>
        <trans-unit id="3a7b9fcbdd08c7e12be96a35248bec20128f934f" translate="yes" xml:space="preserve">
          <source>The parameter must not escape the function call (e.g. by being assigned to a global variable). Ignored for any parameter that is not a reference type.</source>
          <target state="translated">参数不能逃避函数调用(例如,被分配给一个全局变量)。对于任何不是引用类型的参数,忽略。</target>
        </trans-unit>
        <trans-unit id="da7a5827114de776669ef80597ccf4da04a43fa6" translate="yes" xml:space="preserve">
          <source>The parameter will be a mutable copy of its argument</source>
          <target state="translated">该参数将是其参数的一个可变异副本</target>
        </trans-unit>
        <trans-unit id="c903948dffd2abfd68770b5195aac5d542b83003" translate="yes" xml:space="preserve">
          <source>The parameters of this distribution. The random number is x = (x * multipler + increment) % modulus.</source>
          <target state="translated">这个分布的参数。随机数为x=(x*倍数+增量)%模数。</target>
        </trans-unit>
        <trans-unit id="2c7bb35e4246e498ccd1516d5c0a045c041414c6" translate="yes" xml:space="preserve">
          <source>The parameters to the non-variadic function:</source>
          <target state="translated">非变量函数的参数。</target>
        </trans-unit>
        <trans-unit id="8c00f330278c8a3688d755f58c6ef387d6c281e7" translate="yes" xml:space="preserve">
          <source>The parameters to the variadic function:</source>
          <target state="translated">变量函数的参数。</target>
        </trans-unit>
        <trans-unit id="5ebad486f6049114c19bd433cacf524aaf10fabc" translate="yes" xml:space="preserve">
          <source>The parameters with which to instantiate the template.</source>
          <target state="translated">用于实例化模板的参数。</target>
        </trans-unit>
        <trans-unit id="4fbe12ec5cf422714865a37fd1864dec27719969" translate="yes" xml:space="preserve">
          <source>The parent allocator is publicly accessible either as a direct member if it holds state, or as an alias to &lt;code&gt;Allocator.instance&lt;/code&gt; otherwise. One may use it for making calls that won't count toward statistics collection.</source>
          <target state="translated">父分配器可以公开访问（如果它持有状态），可以是直接成员，否则可以是 &lt;code&gt;Allocator.instance&lt;/code&gt; 的别名。可能有人会用它来拨打不计入统计信息的呼叫。</target>
        </trans-unit>
        <trans-unit id="a7916e9fe1cbcecc9e5b2265b50cee59f409bc09" translate="yes" xml:space="preserve">
          <source>The parent allocator. Depending on whether &lt;code&gt;ParentAllocator&lt;/code&gt; holds state or not, this is a member variable or an alias for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">父分配器。根据 &lt;code&gt;ParentAllocator&lt;/code&gt; 是否保持状态，这是 &lt;code&gt;ParentAllocator.instance&lt;/code&gt; 的成员变量或别名。</target>
        </trans-unit>
        <trans-unit id="6a766f10bdfc11306f72dafd5b728bd7317c675f" translate="yes" xml:space="preserve">
          <source>The parser initially sets it to TOK.concatenateAssign, and semantic() later decides which of the three it will be set to.</source>
          <target state="translated">解析器最初将其设置为TOK.concatenateAssign,之后由semantic()决定将其设置为三者中的哪一个。</target>
        </trans-unit>
        <trans-unit id="8ca59cb5bd26311e5307aeb5f44c313335ea3580" translate="yes" xml:space="preserve">
          <source>The passed in input was correct, but more input was expected.</source>
          <target state="translated">传入的输入是正确的,但预计会有更多的输入。</target>
        </trans-unit>
        <trans-unit id="04a94fe6ab7793bd68edc946edd3c4d4f906c623" translate="yes" xml:space="preserve">
          <source>The passed text will be printed first, followed by a newline, then the short and long version of every option will be printed. The short and long version will be aligned to the longest option of every &lt;code&gt;Option&lt;/code&gt; passed. If the option is required, then &quot;Required:&quot; will be printed after the long version of the &lt;code&gt;Option&lt;/code&gt;. If a help message is present it will be printed next. The format is illustrated by this code:</source>
          <target state="translated">传递的文本将首先打印，然后换行，然后将打印每个选项的简短版本和详细版本。短版本和长版本将与传递的每个 &lt;code&gt;Option&lt;/code&gt; 的最长选项对齐。如果该选项是必需的，则在该 &lt;code&gt;Option&lt;/code&gt; 的长版本之后将显示&amp;ldquo; Required：&amp;rdquo; 。如果出现帮助消息，则将其下打印。格式由以下代码说明：</target>
        </trans-unit>
        <trans-unit id="ae0176808c4338a2b32bdc055054955a47109b3c" translate="yes" xml:space="preserve">
          <source>The path given by &lt;code&gt;path&lt;/code&gt;, with the extension given by &lt;code&gt;ext&lt;/code&gt; appended if the path doesn't already have one.  Including the dot in the extension is optional.  This function always allocates a new string, except in the case when path is immutable and already has an extension.</source>
          <target state="translated">path指定的 &lt;code&gt;path&lt;/code&gt; ，如果路径还没有扩展名，则附加 &lt;code&gt;ext&lt;/code&gt; 扩展名。在扩展名中包括点是可选的。该函数总是分配一个新的字符串，除非path是不可变的并且已经具有扩展名。</target>
        </trans-unit>
        <trans-unit id="9978fd2b7b1c58a32b59d2d933a84ff2eeb9cad1" translate="yes" xml:space="preserve">
          <source>The path name to expand.</source>
          <target state="translated">要展开的路径名称。</target>
        </trans-unit>
        <trans-unit id="dba74006c9911dd825361c79175c3816c02f4fd6" translate="yes" xml:space="preserve">
          <source>The path of the executable as a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">可执行文件的路径，以 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c35dcd32a0cd2b956596caddc202c46a4ae3354" translate="yes" xml:space="preserve">
          <source>The path to be matched against</source>
          <target state="translated">要匹配的路径</target>
        </trans-unit>
        <trans-unit id="a5d7f6c37fe93af27b88af304f713208b3e7e43a" translate="yes" xml:space="preserve">
          <source>The path to the file.</source>
          <target state="translated">文件的路径。</target>
        </trans-unit>
        <trans-unit id="b9caa4476a8447e566c7b52e6155891828512bf8" translate="yes" xml:space="preserve">
          <source>The path to the shell to use to run the specified program. By default this is &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于运行指定程序的外壳程序的路径。默认情况下是&lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a791a6dee2401c3ac563dc595efe14cc5ee858e9" translate="yes" xml:space="preserve">
          <source>The permutation to permutate &lt;code&gt;range&lt;/code&gt; to.</source>
          <target state="translated">排列到排列 &lt;code&gt;range&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bf6df59e4efc6178ad86ce4d172dd74e35f57bc" translate="yes" xml:space="preserve">
          <source>The permuted range.</source>
          <target state="translated">琢磨的范围。</target>
        </trans-unit>
        <trans-unit id="b51b8abc388ed1faa0574f36244673bca9d03127" translate="yes" xml:space="preserve">
          <source>The pivot element.</source>
          <target state="translated">枢轴元件。</target>
        </trans-unit>
        <trans-unit id="2141dbd9249b3127ee2311abb3285ea6f62646d8" translate="yes" xml:space="preserve">
          <source>The plan is to support all of the above except throwing D exceptions directly in C++ code (but they will be throwable indirectly by calling into a D function with C++ linkage).</source>
          <target state="translated">计划是除了在C++代码中直接抛出D异常外,其他的都支持(但会通过调用C++链接的D函数间接抛出)。</target>
        </trans-unit>
        <trans-unit id="5e9fcc91fd47a551fe2c3ec3018788e0626a6afc" translate="yes" xml:space="preserve">
          <source>The platform-specific native shell path.</source>
          <target state="translated">平台特有的本地shell路径。</target>
        </trans-unit>
        <trans-unit id="c744ae6de5a0c2342c1ec26c71bf9d84af5482c5" translate="yes" xml:space="preserve">
          <source>The point is to allow AliasDeclarationY to use &lt;code&gt;__traits()&lt;/code&gt;, see issue 7804.</source>
          <target state="translated">关键是允许AliasDeclarationY使用 &lt;code&gt;__traits()&lt;/code&gt; ，请参见问题7804。</target>
        </trans-unit>
        <trans-unit id="0b4bb95d6a8d2b3e99a53954eaab5d58c7eb10b4" translate="yes" xml:space="preserve">
          <source>The pointer</source>
          <target state="translated">指针</target>
        </trans-unit>
        <trans-unit id="cf7acba2bb0e0c6f04c4c0cb72022cca37ae2438" translate="yes" xml:space="preserve">
          <source>The pointer is in an invalid state. Dereferencing such a pointer is an error.</source>
          <target state="translated">指针处于无效状态。提取这样的指针是一个错误。</target>
        </trans-unit>
        <trans-unit id="fd5b5206507758892b71f3f58e5e23e1c1f7f65c" translate="yes" xml:space="preserve">
          <source>The pointer, dynamic array, or reference is set to &lt;code&gt;null&lt;/code&gt; after the delete is performed. Any attempt to reference the data after the deletion via another reference to it will result in undefined behavior.</source>
          <target state="translated">执行删除后，指针，动态数组或引用将设置为 &lt;code&gt;null&lt;/code&gt; 。删除后通过其他引用来引用数据的任何尝试都会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="594f71d424c88492080e5062a3ecf8853308a43e" translate="yes" xml:space="preserve">
          <source>The pointer-based version returns a &lt;code&gt;SortedRange&lt;/code&gt; wrapper over index, of type &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; thus reflecting the ordering of the index. The index-based version returns &lt;code&gt;void&lt;/code&gt; because the ordering relation involves not only &lt;code&gt;index&lt;/code&gt; but also &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">基于指针的版本将返回 &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; 类型的索引上的 &lt;code&gt;SortedRange&lt;/code&gt; 包装器，从而反映了索引的顺序。基于索引的版本返回 &lt;code&gt;void&lt;/code&gt; ,因为排序关系不仅涉及 &lt;code&gt;index&lt;/code&gt; 而且涉及 &lt;code&gt;r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c0b6520bd81ff00673e639fb3748bb290589c44" translate="yes" xml:space="preserve">
          <source>The policy to use.</source>
          <target state="translated">用的政策。</target>
        </trans-unit>
        <trans-unit id="5bfa0d8b059a39ab26c6f284f964719eecf94f69" translate="yes" xml:space="preserve">
          <source>The policy used by this mutex.</source>
          <target state="translated">该mutex使用的策略。</target>
        </trans-unit>
        <trans-unit id="8629893a44c9c276074edd00bae067e6b519cbda" translate="yes" xml:space="preserve">
          <source>The position in &lt;code&gt;array&lt;/code&gt; to insert the &lt;code&gt;stuff&lt;/code&gt;.</source>
          <target state="translated">中的位置 &lt;code&gt;array&lt;/code&gt; 插入 &lt;code&gt;stuff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9eb86610993ddd6856217e1e6d70c91e6f75dbc" translate="yes" xml:space="preserve">
          <source>The position in the input string where the error occurred.</source>
          <target state="translated">输入字符串中发生错误的位置。</target>
        </trans-unit>
        <trans-unit id="f421096d1588c50f7ea09d98220627162688c28b" translate="yes" xml:space="preserve">
          <source>The position of the minimum (respectively maximum) element of forward range &lt;code&gt;range&lt;/code&gt;, i.e. a subrange of &lt;code&gt;range&lt;/code&gt; starting at the position of its smallest (respectively largest) element and with the same ending as &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">向前范围 &lt;code&gt;range&lt;/code&gt; 的最小（分别为最大）元素的位置，即范围的子 &lt;code&gt;range&lt;/code&gt; ，从其最小（分别为最大）元素的位置开始，并以 &lt;code&gt;range&lt;/code&gt; 相同的结尾。</target>
        </trans-unit>
        <trans-unit id="51fc654e8d5c11108a73d4836e9e77c133dfb257" translate="yes" xml:space="preserve">
          <source>The possible states of the &lt;code&gt;Ternary&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ternary&lt;/code&gt; 的可能状态</target>
        </trans-unit>
        <trans-unit id="76c6cabbb86643a051bf73c292aa98533c672138" translate="yes" xml:space="preserve">
          <source>The possible targets are computed more conservatively than the language allows, eliminating all dangerous conversions. For example, &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; does not include &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">可能的目标计算比语言所允许的保守得多，从而消除了所有危险的转换。例如， &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; 不包含 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11d29604df18454624b74cfa89078e0417260306" translate="yes" xml:space="preserve">
          <source>The possible values for units are &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, (microseconds), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds, i.e. 100 ns), and &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">单位的可能值为 &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; ， &lt;code&gt;&quot;days&quot;&lt;/code&gt; ， &lt;code&gt;&quot;hours&quot;&lt;/code&gt; ， &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; ， &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; ， &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; 毫秒&amp;rdquo;（毫秒）， &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; ，（微秒）， &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; （百纳秒，即100 ns）和 &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c4f82ffde3ae1f423f2307932836a1e645ef668" translate="yes" xml:space="preserve">
          <source>The postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; and &lt;code&gt;__aggrPostblit&lt;/code&gt; are generated without any implicit qualifiers and are not considered struct members. This leads to the situation where qualifying an entire struct declaration with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; does not have any impact on the above-mentioned postblits. However, since &lt;code&gt;__xpostblit&lt;/code&gt; is a member of the struct and an alias of one of the other postblits, the qualifiers applied to the struct will affect the aliased postblit.</source>
          <target state="translated">Postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; 和 &lt;code&gt;__aggrPostblit&lt;/code&gt; 是在没有任何隐式限定符的情况下生成的，不被视为结构成员。这导致这样的情况：用 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;immutable&lt;/code&gt; 对整个struct声明进行限定不会对上述postblit产生任何影响。但是，由于 &lt;code&gt;__xpostblit&lt;/code&gt; 是该结构的成员，并且是其他postblits的别名，因此应用于该结构的限定符将影响该别名的postblit。</target>
        </trans-unit>
        <trans-unit id="d47161252adc52b1f430344a53bb4997710446f2" translate="yes" xml:space="preserve">
          <source>The power modulus value of (base ^ exponent) % modulus.</source>
          <target state="translated">(基^指数)%模数的功率模数值。</target>
        </trans-unit>
        <trans-unit id="309c3d73f76b800f2ba5fd6059ce5bcf824a5c98" translate="yes" xml:space="preserve">
          <source>The pre contracts specify the preconditions before a statement is executed. The most typical use of this would be in validating the parameters to a function. The post contracts validate the result of the statement. The most typical use of this would be in validating the return value of a function and of any side effects it has. In D, pre contracts begin with &lt;code&gt;in&lt;/code&gt;, and post contracts begin with &lt;code&gt;out&lt;/code&gt;. They come at the end of the function signature and before the opening brace of the function body.</source>
          <target state="translated">预合同规定了执行语句之前的先决条件。最典型的用途是验证函数的参数。后期合同验证了报表的结果。这种方法最典型的用途是验证函数的返回值以及它具有的任何副作用。在D中，预合同以 &lt;code&gt;in&lt;/code&gt; 开头，后合同以 &lt;code&gt;out&lt;/code&gt; 开头。它们出现在功能签名的末尾，在功能主体的开口撑杆之前。</target>
        </trans-unit>
        <trans-unit id="bad3757e2d3ea8e03615372cc42932fa498e0342" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;less&lt;/code&gt; defines the lexicographical ordering to be used on the range.</source>
          <target state="translated">谓词 &lt;code&gt;less&lt;/code&gt; 定义要在范围上使用的字典顺序。</target>
        </trans-unit>
        <trans-unit id="75eafad6126e4b32c7a8770becfcb1f1b009b4fa" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;pred&lt;/code&gt; needs to accept an element of &lt;code&gt;r&lt;/code&gt; and the separator &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">谓词 &lt;code&gt;pred&lt;/code&gt; 需要接受 &lt;code&gt;r&lt;/code&gt; 的元素和分隔符 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73639f6f297aaeaa7398fc5473b39c5c235bf984" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the needle, defaulting to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The negated predicate &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; can be used to search instead for the first element</source>
          <target state="translated">用于将每个元素与指针进行比较的谓词，默认为等于 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。否定谓词 &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; 可用于搜索第一个元素</target>
        </trans-unit>
        <trans-unit id="ad19c283f2ff0ef86cf40f35fd842064c7bd010d" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the separator, defaulting to &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">用于将每个元素与分隔符进行比较的谓词，默认为 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5a87643179e233709de5c2f1a144d80a09a77b5" translate="yes" xml:space="preserve">
          <source>The predicate for deciding where to split the range when no separator is passed</source>
          <target state="translated">当没有传递分隔符时,用于决定在哪里分割范围的谓词。</target>
        </trans-unit>
        <trans-unit id="e35b33251882d624f933a2c1b64ccb5eb65ade7b" translate="yes" xml:space="preserve">
          <source>The predicate for determining when to stop counting.</source>
          <target state="translated">确定何时停止计数的前提条件。</target>
        </trans-unit>
        <trans-unit id="0c33296dd22cd76b6c27b1beb8636640e4665dda" translate="yes" xml:space="preserve">
          <source>The predicate is expected to satisfy certain rules in order for &lt;code&gt;sort&lt;/code&gt; to behave as expected - otherwise, the program may fail on certain inputs (but not others) when not compiled in release mode, due to the cursory &lt;code&gt;assumeSorted&lt;/code&gt; check. Specifically, &lt;code&gt;sort&lt;/code&gt; expects &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; to imply &lt;code&gt;less(a,c)&lt;/code&gt; (transitivity), and, conversely, &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; to imply &lt;code&gt;!less(a,c)&lt;/code&gt;. Note that the default predicate (&lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;) does not always satisfy these conditions for floating point types, because the expression will always be &lt;code&gt;false&lt;/code&gt; when either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is NaN. Use &lt;a href=&quot;std_math#cmp&quot;&gt;&lt;code&gt;std.math.cmp&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">谓词应满足某些规则，以便 &lt;code&gt;sort&lt;/code&gt; 能按预期方式运行-否则，由于未完成发布模式而进行的粗略&amp;ldquo; &lt;code&gt;assumeSorted&lt;/code&gt; 检查，程序可能无法在某些输入（而非其他）上失败。具体来说， &lt;code&gt;sort&lt;/code&gt; 期望 &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; 隐含 &lt;code&gt;less(a,c)&lt;/code&gt; （传递性），反之， &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; 隐含 &lt;code&gt;!less(a,c)&lt;/code&gt; 。请注意，默认谓词（ &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; ）并不总是满足浮点类型的这些条件，因为当 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 时表达式始终为 &lt;code&gt;false&lt;/code&gt; 是NaN。请改用&lt;a href=&quot;std_math#cmp&quot;&gt; &lt;code&gt;std.math.cmp&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27f1015c9d3c968b66e69f35344a3e7b0807ccce" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; and accepts any callable function that can be executed via &lt;code&gt;pred(element, s)&lt;/code&gt;.</source>
          <target state="translated">谓词将传递到&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;并接受可以通过 &lt;code&gt;pred(element, s)&lt;/code&gt; 执行的任何可调用函数。</target>
        </trans-unit>
        <trans-unit id="2040ad77d27bfa42d579b0732a628553443b56b4" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;.</source>
          <target state="translated">谓词传递给&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;，可以接受字符串，也可以通过 &lt;code&gt;pred(element, element)&lt;/code&gt; 执行的任何可调用对象。</target>
        </trans-unit>
        <trans-unit id="c1cc6d6782bb5ddbb272e878b0a97cd35ebd9643" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">谓词传递给&lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt;，可以接受字符串，也可以通过 &lt;code&gt;pred(element)&lt;/code&gt; 执行的任何可调用对象。</target>
        </trans-unit>
        <trans-unit id="30b49793439ff4c8d008cc1bf8471d003e4d8abc" translate="yes" xml:space="preserve">
          <source>The predicate that determines whether elements from each respective range match. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">谓词，确定每个范围内的元素是否匹配。默认为相等 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11c0e0e174294f0d039166c9a6e153edb402dcf7" translate="yes" xml:space="preserve">
          <source>The predicate that the range should be partitioned by.</source>
          <target state="translated">范围应该被分割的谓词。</target>
        </trans-unit>
        <trans-unit id="efb36bba668de1092c1769f6aab990aa0cb00922" translate="yes" xml:space="preserve">
          <source>The predicate the ranges are sorted by.</source>
          <target state="translated">范围排序的谓词。</target>
        </trans-unit>
        <trans-unit id="87bdd1f3ad180a36d78f0b0a9fe20115fabf7d4e" translate="yes" xml:space="preserve">
          <source>The predicate to evaluate.</source>
          <target state="translated">要评价的谓词。</target>
        </trans-unit>
        <trans-unit id="793b27dece0d99ba7788014f7bf7dd0fb1085592" translate="yes" xml:space="preserve">
          <source>The predicate to partition by.</source>
          <target state="translated">谓语以分。</target>
        </trans-unit>
        <trans-unit id="d5491576ad03ca04a8526c028f920296327ac77a" translate="yes" xml:space="preserve">
          <source>The predicate to satisfy.</source>
          <target state="translated">要满足的前提条件。</target>
        </trans-unit>
        <trans-unit id="c929e818343f11140b434407d7b74c242dda71fa" translate="yes" xml:space="preserve">
          <source>The predicate to sort by.</source>
          <target state="translated">要排序的谓词。</target>
        </trans-unit>
        <trans-unit id="1d648ec381e9cf43fb0241bd298676f64d9af32e" translate="yes" xml:space="preserve">
          <source>The predicate to sort the transformed elements by.</source>
          <target state="translated">对转换后的元素进行排序的谓词。</target>
        </trans-unit>
        <trans-unit id="04024868be7f287d2663bbef1dbf103a8da3cc6b" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements between the range and the needle(s).</source>
          <target state="translated">用于比较范围和针之间的元素的谓词。</target>
        </trans-unit>
        <trans-unit id="28f32071ce8ed6579de4bc0673c1fb09d434c803" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements.</source>
          <target state="translated">用于比较元素的谓词。</target>
        </trans-unit>
        <trans-unit id="8e5598b5509b9c6eafc0eab8a5a91702947d0e63" translate="yes" xml:space="preserve">
          <source>The predicate to use for determining a match.</source>
          <target state="translated">用于确定匹配的谓词。</target>
        </trans-unit>
        <trans-unit id="89fd4b4f61967cf71a560e54be19f8d76cbb1cde" translate="yes" xml:space="preserve">
          <source>The predicate to use for the rearrangement.</source>
          <target state="translated">用于重排的谓词。</target>
        </trans-unit>
        <trans-unit id="aafedf7f211b6bcd89cdb1a78ec67451cd224b87" translate="yes" xml:space="preserve">
          <source>The predicate to use in comparing elements for commonality. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">谓词，用于比较元素的通用性。默认为相等 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d6ef6e2289f7e8b2fa887a80d23adf75d1641e1" translate="yes" xml:space="preserve">
          <source>The predicate used for comparison, modeled as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt; strict weak ordering&lt;/a&gt; (irreflexive, antisymmetric, transitive, and implying a transitive equivalence)</source>
          <target state="translated">用于比较的谓词，建模为&lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt;严格的弱排序&lt;/a&gt;（不反身，反对称，及物和暗示及物等价）</target>
        </trans-unit>
        <trans-unit id="7f8c0f3692256237f756958104cf2f7dfb39d06e" translate="yes" xml:space="preserve">
          <source>The predicate used to compare the values.</source>
          <target state="translated">用于比较数值的谓词。</target>
        </trans-unit>
        <trans-unit id="97370c26d71acf94352a17fb62d152e3830e5289" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a false result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">谓词从左到右进行评价,如果遇到错误的结果,则以捷径方式中止评价,在这种情况下,后面的实例不需要编译。</target>
        </trans-unit>
        <trans-unit id="1d7464c6a5c260ac34ab99c016228d6b560c3e52" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a true result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">谓词从左到右进行评价,如果遇到真结果,则以捷径方式中止评价,在这种情况下,后面的实例不需要编译。</target>
        </trans-unit>
        <trans-unit id="c330fdecec36e8afd7824dda6b681cda50cda735" translate="yes" xml:space="preserve">
          <source>The preferred way to do memory management in Objective-C is to use Automatic Reference Counting, &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt;. This is not supported in D, therefore manual memory management is required to be used instead. This is achieved by calling &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; on an Objective-C instance, like in the old days of Objective-C.</source>
          <target state="translated">在Objective-C中进行内存管理的首选方法是使用自动引用计数&lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt;。D不支持此功能，因此需要使用手动内存管理。这是通过在Objective-C实例上调用&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt;来实现的，就像在Objective-C的早期一样。</target>
        </trans-unit>
        <trans-unit id="9c5a92eca5579a36fc2d0481a3b2f7e8a916467c" translate="yes" xml:space="preserve">
          <source>The presentation of unit test results to the user.</source>
          <target state="translated">向用户展示单元测试结果。</target>
        </trans-unit>
        <trans-unit id="8662f0b9530b0402d97b53b894f53167be45df40" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions, if any.</source>
          <target state="translated">异常链中的前一个异常,如果有的话。</target>
        </trans-unit>
        <trans-unit id="279b676cef017bbf61d78e4700dc992f1809ccb0" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions.</source>
          <target state="translated">异常链中的前一个异常。</target>
        </trans-unit>
        <trans-unit id="e3fc0517fe6d8889b123aa839a1f6e19c03962c2" translate="yes" xml:space="preserve">
          <source>The primary allocator.</source>
          <target state="translated">主要分配器。</target>
        </trans-unit>
        <trans-unit id="4f0154c15aa8860cab6cca5d166473b2dfba4c14" translate="yes" xml:space="preserve">
          <source>The primary range of a container</source>
          <target state="translated">容器的主要范围</target>
        </trans-unit>
        <trans-unit id="ab5e84bf7b0a53be5c65c8499a656cc503de367a" translate="yes" xml:space="preserve">
          <source>The primary range type associated with the container.</source>
          <target state="translated">与容器相关联的主要范围类型。</target>
        </trans-unit>
        <trans-unit id="33a169f7cc45c68212a77c63178f168570e503e4" translate="yes" xml:space="preserve">
          <source>The primary usefulness of</source>
          <target state="translated">的主要用途</target>
        </trans-unit>
        <trans-unit id="6d1a3cd0b06a0c49d350401e273d786a65d53304" translate="yes" xml:space="preserve">
          <source>The primary way that programs should time how long something takes is to do</source>
          <target state="translated">程序应该对某件事情所需的时间进行计时的主要方法是做以下工作</target>
        </trans-unit>
        <trans-unit id="c12de0da440bbe44b6cbc2ce06649502cfbb1a15" translate="yes" xml:space="preserve">
          <source>The process ID number.</source>
          <target state="translated">流程ID号。</target>
        </trans-unit>
        <trans-unit id="57ea5f74d898ca9f45c60b0cceb17881be0464f6" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase has no dependence on subsequent phases. For example, the scanner is not perturbed by the semantic analyzer. This separation of the passes makes language tools like syntax directed editors relatively easy to produce. It also is possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="translated">编译过程分为多个阶段。每个阶段都不依赖于后续阶段。例如，语义分析器不会干扰扫描器。通行证的这种分离使得语言工具（如语法导向的编辑器）相对易于生产。也可以通过以&amp;ldquo;标记化&amp;rdquo;形式存储D源来压缩D源。</target>
        </trans-unit>
        <trans-unit id="ea34e4c27e6af1bb0e75da5e0e23701dae05bbf4" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase is independent of subsequent phases. For example, the scanner is not affected by the semantic analyzer. This separation of passes makes language tools like syntax-directed editors relatively easy to create. It is also possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="translated">编译过程分为多个阶段。每个阶段都与后续阶段无关。例如，扫描器不受语义分析器的影响。这种通行分隔使得相对容易创建像语法指导的编辑器之类的语言工具。也可以通过以&amp;ldquo;令牌化&amp;rdquo;形式存储D源来压缩D源。</target>
        </trans-unit>
        <trans-unit id="28114859ca08917818ce7134f60ebbc9ff108b7d" translate="yes" xml:space="preserve">
          <source>The process of constructing a trie is more involved and is hidden from the user in a form of the convenience functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; and the even more convenient &lt;a href=&quot;#toTrie&quot;&gt;&lt;code&gt;toTrie&lt;/code&gt;&lt;/a&gt;. In general a set or built-in AA with &lt;code&gt;dchar&lt;/code&gt; type can be turned into a trie. The trie object in this module is read-only (immutable); it's effectively frozen after construction.</source>
          <target state="translated">构建特里结构的过程是更复杂的，并且从用户的方便性的功能的形式隐藏&lt;a href=&quot;#codepointTrie&quot;&gt; &lt;code&gt;codepointTrie&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#codepointSetTrie&quot;&gt; &lt;code&gt;codepointSetTrie&lt;/code&gt; &lt;/a&gt;和更方便&lt;a href=&quot;#toTrie&quot;&gt; &lt;code&gt;toTrie&lt;/code&gt; &lt;/a&gt;。通常，具有 &lt;code&gt;dchar&lt;/code&gt; 类型的AA或内置AA 可以转换为trie。该模块中的trie对象是只读的（不可变的）。施工后有效冻结。</target>
        </trans-unit>
        <trans-unit id="d2a069ebee0eb3fc705692f747a2a23547f8a461" translate="yes" xml:space="preserve">
          <source>The process of deducing template type parameters from function arguments is called Implicit Function Template Instantiation (IFTI).</source>
          <target state="translated">从函数参数推导模板类型参数的过程称为隐式函数模板实例化(Implicit Function Template Instantiation,IFTI)。</target>
        </trans-unit>
        <trans-unit id="a65917e549f3ee7bf2fcc111ebfc87ae282e8929" translate="yes" xml:space="preserve">
          <source>The process will be &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;forcefully and abruptly terminated&lt;/a&gt;. If &lt;code&gt;codeOrSignal&lt;/code&gt; is specified, it must be a nonnegative number which will be used as the exit code of the process. If not, the process wil exit with code 1. Do not use &lt;code&gt;codeOrSignal = 259&lt;/code&gt;, as this is a special value (aka. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;) used by Windows to signal that a process has in fact</source>
          <target state="translated">该过程将被&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;强制终止&lt;/a&gt;。如果指定了 &lt;code&gt;codeOrSignal&lt;/code&gt; ，则它必须是一个非负数，它将用作进程的退出代码。如果不是，则该进程将以代码1退出。请勿使用 &lt;code&gt;codeOrSignal = 259&lt;/code&gt; ，因为这是Windows使用的特殊值（又名&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;），用于指示进程实际上已经</target>
        </trans-unit>
        <trans-unit id="4c66fd47d6b0ea9f7f298e0ac3d4710fb98aca07" translate="yes" xml:space="preserve">
          <source>The process will be &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;forcefully and abruptly terminated&lt;/a&gt;. If &lt;code&gt;codeOrSignal&lt;/code&gt; is specified, it must be a nonnegative number which will be used as the exit code of the process. If not, the process wil exit with code 1. Do not use &lt;code&gt;codeOrSignal = 259&lt;/code&gt;, as this is a special value (aka. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;) used by Windows to signal that a process has in fact</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52379dcfb4fdf54c286085a8d7b935d4c3bf51f" translate="yes" xml:space="preserve">
          <source>The program can explicitly inform the garbage collector that an object is no longer referred to with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, and then the garbage collector calls the destructor immediately. The destructor is guaranteed to never be called twice.</source>
          <target state="translated">该程序可以显式通知垃圾回收器，不再使用&lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt;引用对象，然后垃圾回收器立即调用析构函数。保证析构函数永远不会被调用两次。</target>
        </trans-unit>
        <trans-unit id="da8f18e43875ff3b21ffb3a65f1d74da9627baee" translate="yes" xml:space="preserve">
          <source>The program name,</source>
          <target state="translated">节目名称。</target>
        </trans-unit>
        <trans-unit id="75fd342f2dff09b71b21a32efe312806ee1c88b1" translate="yes" xml:space="preserve">
          <source>The projection of &lt;code&gt;z&lt;/code&gt; onto the Riemann sphere.</source>
          <target state="translated">的投影 &lt;code&gt;z&lt;/code&gt; 到黎曼球体。</target>
        </trans-unit>
        <trans-unit id="212a3b865b9d39089a835e861cd51456362e9629" translate="yes" xml:space="preserve">
          <source>The proper way to instantiate this object is to call &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt;. Once instantiated, this object behaves as a finite random-access range with assignable, lvalue elements and a length equal to the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; that created it plus 1.</source>
          <target state="translated">实例化此对象的正确方法是调用 &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt; 。实例化后，此对象的行为就如同一个有限的随机访问范围，其中包含可分配的lvalue元素，其长度等于创建它的 &lt;code&gt;TaskPool&lt;/code&gt; 中工作线程的数量加1。</target>
        </trans-unit>
        <trans-unit id="06cb3e37f16148a51f8965d4f1cdc4ea883f0365" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;.__vptr&lt;/code&gt; and &lt;code&gt;.__monitor&lt;/code&gt; give access to the class object's vtbl[] and monitor, respectively, but should not be used in user code.</source>
          <target state="translated">属性 &lt;code&gt;.__vptr&lt;/code&gt; 和 &lt;code&gt;.__monitor&lt;/code&gt; 分别提供对类对象的vtbl []和monitor的访问权限，但不应在用户代码中使用。</target>
        </trans-unit>
        <trans-unit id="465978af9e7d0929cd7aec7d44ae79ba13368247" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;.outer&lt;/code&gt; used in a nested class gives the &lt;code&gt;this&lt;/code&gt; pointer to its enclosing class. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would return a pointer to enclosing function frame with &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">嵌套类中使用的属性 &lt;code&gt;.outer&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 指针指向其封闭类。如果没有封闭的类上下文， &lt;code&gt;.outer&lt;/code&gt; 将返回一个指向带有 &lt;code&gt;void*&lt;/code&gt; 封闭功能框架的指针。</target>
        </trans-unit>
        <trans-unit id="18230b4e21a7c31cb0b0a527787c1242f4f98838" translate="yes" xml:space="preserve">
          <source>The proxied value must be an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">代理值必须是&lt;b&gt;左值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2aa3e8b16a5d628661af4b4300a9494770cb4fda" translate="yes" xml:space="preserve">
          <source>The ptr aliases are integral types guaranteed to be large enough to hold a pointer without losing bits:</source>
          <target state="translated">ptr别名是积分类型,保证足够大,可以容纳一个指针而不丢失位。</target>
        </trans-unit>
        <trans-unit id="5110028f04b358ea03cfe31d14fda076a20fecde" translate="yes" xml:space="preserve">
          <source>The purpose is to bypass the special case decoding that &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; does to character arrays. As a result, using ranges with &lt;code&gt;byCodeUnit&lt;/code&gt; can be &lt;code&gt;nothrow&lt;/code&gt; while &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; throws when it encounters invalid Unicode sequences.</source>
          <target state="translated">目的是绕过&lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt;对字符数组所做的特殊情况解码。结果，当遇到无效Unicode序列时， &lt;code&gt;byCodeUnit&lt;/code&gt; 会 &lt;code&gt;nothrow&lt;/code&gt; 异常，而&lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt;会使用范围。</target>
        </trans-unit>
        <trans-unit id="c265a2d12f1e7e5cd63d17026023fdb0d5f3f129" translate="yes" xml:space="preserve">
          <source>The purpose of this is so that continue will go to the next of the statements, and break will go to the end of the statements.</source>
          <target state="translated">这样做的目的是为了让继续会转到下一个语句,而断裂会转到语句的结尾。</target>
        </trans-unit>
        <trans-unit id="1651c6e27b3326d67f792a155dd955abdff9b39f" translate="yes" xml:space="preserve">
          <source>The qualifier template from the given type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">给定类型 &lt;code&gt;T&lt;/code&gt; 的限定词模板</target>
        </trans-unit>
        <trans-unit id="e09036cabacde1d4e95f44667e0017f4b4c08158" translate="yes" xml:space="preserve">
          <source>The qualifiers of the affix are not always the same as the qualifiers of the argument. This is because the affixes are not part of the data itself, but instead are just</source>
          <target state="translated">词缀的限定词并不总是与参数的限定词相同。这是因为词缀并不是数据本身的一部分,而只是作为</target>
        </trans-unit>
        <trans-unit id="0c6a006eb9560342bd14cc8557e22fb25a226fd2" translate="yes" xml:space="preserve">
          <source>The random-access range to partition.</source>
          <target state="translated">要分区的随机访问范围。</target>
        </trans-unit>
        <trans-unit id="97092cfd186fb5b900f835cf73b9eb2468215664" translate="yes" xml:space="preserve">
          <source>The random-access range to rearrange.</source>
          <target state="translated">要重新排列的随机访问范围。</target>
        </trans-unit>
        <trans-unit id="e4ce54dd9a7b88e5f2bf201fe3fb2e94f16d9fa9" translate="yes" xml:space="preserve">
          <source>The random-access range to reorder.</source>
          <target state="translated">要重新排序的随机访问范围。</target>
        </trans-unit>
        <trans-unit id="9759b91222e0376d244c7fe53ea2166dd785b989" translate="yes" xml:space="preserve">
          <source>The range API is supported for both encoding and decoding:</source>
          <target state="translated">编码和解码都支持范围API。</target>
        </trans-unit>
        <trans-unit id="f827934761dc7cbd89045f8928d650c1c6adfe0d" translate="yes" xml:space="preserve">
          <source>The range being partitioned</source>
          <target state="translated">被分割的范围</target>
        </trans-unit>
        <trans-unit id="ff34249e986a29860f6c5d437ad8145efcb4a0b9" translate="yes" xml:space="preserve">
          <source>The range primitives that the resulting range provides depends whether or not &lt;code&gt;r&lt;/code&gt; provides them. Except the functions &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;, which also require the range to have a length as well as &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;</source>
          <target state="translated">结果范围提供的范围原语取决于 &lt;code&gt;r&lt;/code&gt; 是否提供它们。除了 &lt;code&gt;back&lt;/code&gt; 和 &lt;code&gt;popBack&lt;/code&gt; 函数之外，该函数还要求范围具有长度以及 &lt;code&gt;back&lt;/code&gt; 和 &lt;code&gt;popBack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e867771f52adb05da2dc3c29c4eccce7ead17be" translate="yes" xml:space="preserve">
          <source>The range to append to.</source>
          <target state="translated">要追加的范围。</target>
        </trans-unit>
        <trans-unit id="b8f92036ba2322967a7c304f2680091886c10a9f" translate="yes" xml:space="preserve">
          <source>The range to check.</source>
          <target state="translated">要检查的范围。</target>
        </trans-unit>
        <trans-unit id="92faab42363803d3ec822fdd1af0c67c9ba8588a" translate="yes" xml:space="preserve">
          <source>The range to count.</source>
          <target state="translated">要计算的范围。</target>
        </trans-unit>
        <trans-unit id="2a5042de5707ed27e3cd38336bffdd36cd0572c7" translate="yes" xml:space="preserve">
          <source>The range to handle.</source>
          <target state="translated">处理的范围。</target>
        </trans-unit>
        <trans-unit id="e058b4d6c31bc35cf580da1ebefcc71d18f5d1ca" translate="yes" xml:space="preserve">
          <source>The range to index.</source>
          <target state="translated">要索引的范围。</target>
        </trans-unit>
        <trans-unit id="80d973acf722de6a5268aeaa4c8fc9646330d9bc" translate="yes" xml:space="preserve">
          <source>The range to permute.</source>
          <target state="translated">的范围内进行消磨。</target>
        </trans-unit>
        <trans-unit id="804c985240d645660c7de05e2788995416dc345a" translate="yes" xml:space="preserve">
          <source>The range to read from.</source>
          <target state="translated">要读取的范围。</target>
        </trans-unit>
        <trans-unit id="8b4ec9a859bd18ea04f9de73b722dd789467f7e7" translate="yes" xml:space="preserve">
          <source>The range to search.</source>
          <target state="translated">要搜索的范围。</target>
        </trans-unit>
        <trans-unit id="121036e1b0b497292221a25f49b6dd27cc53e9e1" translate="yes" xml:space="preserve">
          <source>The range to sort.</source>
          <target state="translated">要排序的范围。</target>
        </trans-unit>
        <trans-unit id="cc147be5451f6cfb0b41f5b2277bb929ce23d7db" translate="yes" xml:space="preserve">
          <source>The range to subtract from &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;r1&lt;/code&gt; 减去的范围。</target>
        </trans-unit>
        <trans-unit id="49d274ac9ff8b631f4dc3f4b09f1138c62b7ffc0" translate="yes" xml:space="preserve">
          <source>The range to write to.</source>
          <target state="translated">要写入的范围。</target>
        </trans-unit>
        <trans-unit id="49360fcd22b248a482a8ca2592193dd9241be2ca" translate="yes" xml:space="preserve">
          <source>The range type</source>
          <target state="translated">范围类型</target>
        </trans-unit>
        <trans-unit id="802ba550fbcee32bf81ae1613d2bfa286e1456a5" translate="yes" xml:space="preserve">
          <source>The range types for &lt;code&gt;RedBlackTree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RedBlackTree&lt;/code&gt; 的范围类型</target>
        </trans-unit>
        <trans-unit id="a11d808dfbdf148bbb169a6a95255aca3179a47b" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;begin&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">范围的 &lt;code&gt;front&lt;/code&gt; 是间隔的 &lt;code&gt;begin&lt;/code&gt; 。当 &lt;code&gt;popFront&lt;/code&gt; 时，func用于生成下一个 &lt;code&gt;front&lt;/code&gt; 。如果popFirst是 &lt;code&gt;PopFirst.yes&lt;/code&gt; ，则在返回范围之前调用 &lt;code&gt;popFront&lt;/code&gt; （因此 &lt;code&gt;front&lt;/code&gt; 是func将生成的时间点）。</target>
        </trans-unit>
        <trans-unit id="2230a6c9d63e9a6e8252220108f18931ca810d49" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;end&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">范围的 &lt;code&gt;front&lt;/code&gt; 是区间的 &lt;code&gt;end&lt;/code&gt; 。当 &lt;code&gt;popFront&lt;/code&gt; 时，func用于生成下一个 &lt;code&gt;front&lt;/code&gt; 。如果popFirst是 &lt;code&gt;PopFirst.yes&lt;/code&gt; ，则在返回范围之前调用 &lt;code&gt;popFront&lt;/code&gt; （因此 &lt;code&gt;front&lt;/code&gt; 是func将生成的时间点）。</target>
        </trans-unit>
        <trans-unit id="bc87d893530544a1088c66c1a3ebadf8aa8d14c3" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types (i.e. &lt;code&gt;CommonType&lt;/code&gt; must exist for the two element types). The result is a range that offers the weakest capabilities of the two (e.g. &lt;code&gt;ForwardRange&lt;/code&gt; if &lt;code&gt;R1&lt;/code&gt; is a random-access range and &lt;code&gt;R2&lt;/code&gt; is a forward range).</source>
          <target state="translated">范围可能有所不同，但是它们必须具有兼容的元素类型（即，两种元素类型必须存在 &lt;code&gt;CommonType&lt;/code&gt; ）。结果是提供两个功能中最弱的范围（例如，如果 &lt;code&gt;R1&lt;/code&gt; 是随机访问范围而 &lt;code&gt;R2&lt;/code&gt; 是正向范围，则为 &lt;code&gt;ForwardRange&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3f573b0cbf92f973f94497f03f6ff76a63fec72f" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types. The result is a range that offers the weakest capabilities of all &lt;code&gt;Ranges&lt;/code&gt;.</source>
          <target state="translated">范围可能不同，但是它们必须具有兼容的元素类型。结果是范围提供了所有 &lt;code&gt;Ranges&lt;/code&gt; 最弱的功能。</target>
        </trans-unit>
        <trans-unit id="b730db3bfe83c0cd05e43737d06094aae7960b40" translate="yes" xml:space="preserve">
          <source>The ranges to compute the intersection for.</source>
          <target state="translated">要计算交点的范围。</target>
        </trans-unit>
        <trans-unit id="46baca537890237a1942208ed4eade3a2e0fe13d" translate="yes" xml:space="preserve">
          <source>The ranges to compute the union for.</source>
          <target state="translated">要计算联合的范围。</target>
        </trans-unit>
        <trans-unit id="5497d81d16c2927140f25a4c1006f37fea2563ca" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the class definition. The pointer to the vtbl[] (the array of pointers to virtual functions) is assigned. Constructors are passed fully formed objects for which virtual functions can be called. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">原始数据使用类定义中提供的值进行静态初始化。vtbl[](指向虚拟函数的指针数组)的指针被分配。构造函数被传递给完全形成的对象,可以为其调用虚拟函数。这个操作相当于在新分配的对象上做一个静态版本的内存拷贝。</target>
        </trans-unit>
        <trans-unit id="fcae8af2965ab59e0bb8589c5d279780cbfa5e92" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the struct definition. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">使用结构定义中提供的值对原始数据进行静态初始化。这个操作相当于在新分配的对象上做一个静态版本的内存拷贝。</target>
        </trans-unit>
        <trans-unit id="b86128a6bd2767acc00fa6def304105cbf1e478d" translate="yes" xml:space="preserve">
          <source>The read end of the pipe.</source>
          <target state="translated">管道的读取端。</target>
        </trans-unit>
        <trans-unit id="13a2374af67fe26dbb9c14a59fb5ce5f9e9d781a" translate="yes" xml:space="preserve">
          <source>The read/write mutex module provides a primitive for maintaining shared read access and mutually exclusive write access.</source>
          <target state="translated">读/写互斥模块提供了一个维持共享读访问和互斥写访问的基元。</target>
        </trans-unit>
        <trans-unit id="1ea37ce134dc82d56b80e1186c5f0aadafbf2545" translate="yes" xml:space="preserve">
          <source>The real part of the number.</source>
          <target state="translated">数字的真实部分。</target>
        </trans-unit>
        <trans-unit id="d84af79636d58f1538ce03a4ef706cc4269fc0ca" translate="yes" xml:space="preserve">
          <source>The reason why local symbols are not considered by UFCS, is to avoid unexpected name conflicts. See below problematic examples.</source>
          <target state="translated">UFCS之所以不考虑本地符号,是为了避免意外的名称冲突。请看下面的问题例子。</target>
        </trans-unit>
        <trans-unit id="6e1a9e9d57c1e11e3c0d69a36fca45727647f054" translate="yes" xml:space="preserve">
          <source>The reason why parsing the UUID string failed (if known)</source>
          <target state="translated">解析UUID字符串失败的原因(如果知道)。</target>
        </trans-unit>
        <trans-unit id="444ce1c54b9e6e4aeb187c02bb491ead21cc3157" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T.length&lt;/code&gt; is greater than one, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">收到的消息。如果 &lt;code&gt;T.length&lt;/code&gt; 大于1，则消息将打包到&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca01b3f617c720041b0621fa546228daeb7a4c84" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T&lt;/code&gt; has more than one entry, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">收到的消息。如果 &lt;code&gt;T&lt;/code&gt; 具有多个条目，则该消息将被打包到&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="629439e6d0394e525c1da0e460386c227bde37f1" translate="yes" xml:space="preserve">
          <source>The recommended default type for set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. For details, see the current implementation: &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">推荐的&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;默认类型。有关详细信息，请参见当前实现：&lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a1dc42bd6a98f128cb04e650caf0c66b2c441a15" translate="yes" xml:space="preserve">
          <source>The recommended solution (see Unicode Implementation Guidelines) is using multi-stage tables that are an implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; data structure with integer keys and a fixed number of stages. For the remainder of the section this will be called a fixed trie. The following describes a particular implementation that is aimed for the speed of access at the expense of ideal size savings.</source>
          <target state="translated">推荐的解决方案（请参阅Unicode实施指南）使用多级表，该表是具有整数键和固定级数的&lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt;数据结构的实现。在本节的其余部分，这将称为固定特里。下面描述了一种特定的实现，该实现旨在以节省理想大小为代价的访问速度。</target>
        </trans-unit>
        <trans-unit id="3ed788139c7014abe2c559b9a334cb4611135a55" translate="yes" xml:space="preserve">
          <source>The recommended solution (see Unicode Implementation Guidelines) is using multi-stage tables that are an implementation of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; data structure with integer keys and a fixed number of stages. For the remainder of the section this will be called a fixed trie. The following describes a particular implementation that is aimed for the speed of access at the expense of ideal size savings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d2cded1f6173c486fb7ad21ff19a0763451581" translate="yes" xml:space="preserve">
          <source>The recommended type of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; to represent [a, b) intervals of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. As used in &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;. Any interval type should pass &lt;a href=&quot;#isIntegralPair&quot;&gt;&lt;code&gt;isIntegralPair&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">推荐的&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;类型，用于表示[a，b）&lt;a href=&quot;#Code%20point&quot;&gt;代码点的&lt;/a&gt;间隔。如&lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; 中&lt;/a&gt;所使用。任何间隔类型都应传递&lt;a href=&quot;#isIntegralPair&quot;&gt; &lt;code&gt;isIntegralPair&lt;/code&gt; &lt;/a&gt;特征。</target>
        </trans-unit>
        <trans-unit id="859ae610f623e658d3afadb3f75618929c558560" translate="yes" xml:space="preserve">
          <source>The recommended use of &lt;code&gt;KRRegion&lt;/code&gt; is as a</source>
          <target state="translated">建议将 &lt;code&gt;KRRegion&lt;/code&gt; 用作</target>
        </trans-unit>
        <trans-unit id="388d2ad6c415253a61a360bde9d489b23f6dc8d0" translate="yes" xml:space="preserve">
          <source>The ref-ness of a function is determined from all &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body:</source>
          <target state="translated">函数的引用性取决于函数体内的所有&lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="3b502b2fed948d53834e6a08aa36762dc04287b2" translate="yes" xml:space="preserve">
          <source>The reference label must match a reference defined elsewhere. This may be a D symbol in scope of the source code being documented, like &lt;code&gt;[Object]&lt;/code&gt; in the example above, or it may be an explicit reference that is defined in the same documentation comment, like &lt;code&gt;[ref]&lt;/code&gt; in the example above. In the example both instances of &lt;code&gt;[ref]&lt;/code&gt; in item &lt;code&gt;1.&lt;/code&gt; will be replaced with the URL and title text from the matching definition at the bottom of the example. The first link will read &lt;code&gt;reference link&lt;/code&gt; and the second will read &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">参考标签必须与其他地方定义的参考匹配。这可以是所记录的源代码范围内的D符号，例如上例中的 &lt;code&gt;[Object]&lt;/code&gt; ，也可以是在同一文档注释中定义的显式引用，例如上例中的 &lt;code&gt;[ref]&lt;/code&gt; 。在该示例中，第 &lt;code&gt;1.&lt;/code&gt; 项中 &lt;code&gt;[ref]&lt;/code&gt; 的两个实例都将替换为示例底部匹配定义中的URL和标题文本。第一个链接将读取 &lt;code&gt;reference link&lt;/code&gt; ，第二个链接将读取 &lt;code&gt;ref&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7f3a52223d62265f3e1ec0b1d084d2cc36a6550" translate="yes" xml:space="preserve">
          <source>The region only stores three pointers, corresponding to the current position in the store and the limits. One allocation entails rounding up the allocation size for alignment purposes, bumping the current pointer, and comparing it against the limit.</source>
          <target state="translated">该区域只存储三个指针,分别对应存储中的当前位置和极限。一次分配需要将分配大小四舍五入,以达到对齐的目的,将当前指针撞开,并与限制进行比较。</target>
        </trans-unit>
        <trans-unit id="8dfea884780d568afe3690e3e3875bf9d38d17dd" translate="yes" xml:space="preserve">
          <source>The registry does not perform synchronization, as registration is assumed to be executed serially, as is the case for C constructors.</source>
          <target state="translated">注册表不执行同步,因为注册被假定为串行执行,就像C构造函数一样。</target>
        </trans-unit>
        <trans-unit id="323d86762a22443df4223066c5d79a8182348cc7" translate="yes" xml:space="preserve">
          <source>The rehashed associative array.</source>
          <target state="translated">重构的关联数组。</target>
        </trans-unit>
        <trans-unit id="2287a637460b49ec8f0775da73953a50ae5c2dbd" translate="yes" xml:space="preserve">
          <source>The relative path.</source>
          <target state="translated">相对路径。</target>
        </trans-unit>
        <trans-unit id="6288b454d7838d0a858531ccb0a8c1a5187d7261" translate="yes" xml:space="preserve">
          <source>The removed &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">删除的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c0fe435252d4242a9ba6f628f9c2050e5381799" translate="yes" xml:space="preserve">
          <source>The replacement text is recursively scanned for more macros. If a macro is recursively encountered, with no argument or with the same argument text as the enclosing macro, it is replaced with no text. Macro invocations that cut across replacement text boundaries are not expanded. If the macro name is undefined, the replacement text has no characters in it. If a &amp;amp;dollar;(NAME) is desired to exist in the output without being macro expanded, the &amp;amp;dollar; should be &lt;a href=&quot;#punctuation_escapes&quot;&gt; backslash-escaped&lt;/a&gt;: &lt;code&gt;\$&lt;/code&gt;.</source>
          <target state="translated">递归扫描替换文本以查找更多宏。如果递归地遇到一个宏，该宏没有参数或与封闭的宏具有相同的参数文本，则将其替换为没有文本。跨替换文本边界的宏调用不会扩展。如果宏名未定义，则替换文本中没有字符。如果希望在不进行宏扩展的情况下在输出中存在＆dollar;（NAME），则＆dollar; 应该用&lt;a href=&quot;#punctuation_escapes&quot;&gt;反斜杠转义&lt;/a&gt;： &lt;code&gt;\$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00c0559f793b29523699536174f193f79d1404f9" translate="yes" xml:space="preserve">
          <source>The representation of the passed string.</source>
          <target state="translated">传递的字符串的表示方法。</target>
        </trans-unit>
        <trans-unit id="541a2ee308f80899ed39d343b6df8bc566dc23af" translate="yes" xml:space="preserve">
          <source>The requested type. The currently stored value must implicitly convert to the requested type, in fact &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt;. If an implicit conversion is not possible, throws a &lt;code&gt;VariantException&lt;/code&gt;.</source>
          <target state="translated">要求的类型。当前存储的值必须隐式转换为请求的类型，实际上是 &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt; 。如果无法进行隐式转换，则抛出 &lt;code&gt;VariantException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5eb7b072c5ec5c51e2bc9f0c47309355a93d189e" translate="yes" xml:space="preserve">
          <source>The required value.</source>
          <target state="translated">所需数值;</target>
        </trans-unit>
        <trans-unit id="2b92c124327023d2112fc02de9225ba21a0e356f" translate="yes" xml:space="preserve">
          <source>The rest of the EH data can be placed anywhere, it is immutable.</source>
          <target state="translated">其余的EH数据可以放在任何地方,它是不可改变的。</target>
        </trans-unit>
        <trans-unit id="bc76ec74ecd985115be5a95df44e330a29c95a31" translate="yes" xml:space="preserve">
          <source>The result cannot be represented exactly, so rounding occurred.</source>
          <target state="translated">结果不能准确表示,所以发生了四舍五入。</target>
        </trans-unit>
        <trans-unit id="ab324d21f7bc55d7dd8b6c95008f59bdf991ab91" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">结果为 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4130bb4d8bac0fbef0c07bb06c97970f537d8b6" translate="yes" xml:space="preserve">
          <source>The result is [s&lt;sub&gt;0&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;, ...] where s&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">结果为[s &lt;sub&gt;0&lt;/sub&gt;，s &lt;sub&gt;1&lt;/sub&gt;，...]，其中s &lt;sub&gt;n&lt;/sub&gt;是使用默认格式设置的第n个元素。</target>
        </trans-unit>
        <trans-unit id="2b142e927d8266a5d73b4c96f242e530946b4181" translate="yes" xml:space="preserve">
          <source>The result is reasonable even if the programmer fails to check for errors.</source>
          <target state="translated">即使程序员没有查错,结果也是合理的。</target>
        </trans-unit>
        <trans-unit id="e6fee708ae88c1f8ca73e67b83e15b2edc455c01" translate="yes" xml:space="preserve">
          <source>The result is reasonable result even if the programmer fails to check for errors.</source>
          <target state="translated">即使程序员没有查错,结果也是合理的结果。</target>
        </trans-unit>
        <trans-unit id="5df04c97a049ab6feec7de9282693846423b4f8b" translate="yes" xml:space="preserve">
          <source>The result is the equivalent of what the initializer would look like for the contents of the associative array, e.g.: [&quot;red&quot; : 10, &quot;blue&quot; : 20].</source>
          <target state="translated">其结果相当于初始化器对关联数组内容的描述,如 [&quot;红&quot;:10,&quot;蓝&quot;:20]。</target>
        </trans-unit>
        <trans-unit id="08ac164a7aed36036f9bcf755150a74df3d7b24f" translate="yes" xml:space="preserve">
          <source>The result is the string converted to UTF-8. A</source>
          <target state="translated">其结果是将字符串转换为UTF-8。A</target>
        </trans-unit>
        <trans-unit id="1509a90746b95e562f0978b9e4493748f60d91cb" translate="yes" xml:space="preserve">
          <source>The result is the string returned from the class instance's &lt;b&gt;.toString()&lt;/b&gt; method. A</source>
          <target state="translated">结果是从类实例的&lt;b&gt;.toString（）&lt;/b&gt;方法返回的字符串。一个</target>
        </trans-unit>
        <trans-unit id="778aba0a364d09c18b371bc8036e82626d093a0a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;takeExactly&lt;/code&gt; is identical to that of &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; in cases where the original range defines &lt;code&gt;length&lt;/code&gt; or is infinite.</source>
          <target state="translated">&lt;code&gt;takeExactly&lt;/code&gt; 的结果与原始范围定义 &lt;code&gt;length&lt;/code&gt; 或无限的情况下的&lt;a href=&quot;#take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="07564cb52ad1e727fc81a3311ff06a2d773285ae" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been cleared.</source>
          <target state="translated">在指定位被清除后调用getAttr的结果。</target>
        </trans-unit>
        <trans-unit id="f30cfdc760b36139b0f53b5d0be507ea3d824ed7" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been set.</source>
          <target state="translated">指定位被设置后调用getAttr的结果。</target>
        </trans-unit>
        <trans-unit id="445b97c22b054bdd6ff54c4dae46c9df7f4357c6" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;getopt&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;getopt&lt;/code&gt; 函数的结果。</target>
        </trans-unit>
        <trans-unit id="c4e35be57e8c5a96f93fd5bad1cb28bc557187a1" translate="yes" xml:space="preserve">
          <source>The result of the cast operation.</source>
          <target state="translated">投放操作的结果。</target>
        </trans-unit>
        <trans-unit id="83715d44bc2b7900f8b6419b6c4fbc003acad08e" translate="yes" xml:space="preserve">
          <source>The result of the comparison (negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, positive if &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the values are equal)</source>
          <target state="translated">比较的结果（如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 负，如果 &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt; 正，如果值相等则为 &lt;code&gt;0&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b2ab3e5031cd5a46b28a9645ebcd2ff7f110159a" translate="yes" xml:space="preserve">
          <source>The result of the comparison, &lt;code&gt;true&lt;/code&gt; if the values are equal</source>
          <target state="translated">比较的结果，如果值相等则为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c6e42e7ac37e1c83ed4b193d1c4849e41daad91" translate="yes" xml:space="preserve">
          <source>The result of the comparison.</source>
          <target state="translated">比较的结果。</target>
        </trans-unit>
        <trans-unit id="6c6d52fd3aff83619b0b5496c6e3c7be89c2a3aa" translate="yes" xml:space="preserve">
          <source>The result of the expression if no exception is thrown.</source>
          <target state="translated">如果没有发生异常,则表达式的结果。</target>
        </trans-unit>
        <trans-unit id="0c56ce95759c8e42c05e176cc9b231a6a3180930" translate="yes" xml:space="preserve">
          <source>The result of the operation, which is the same as the built-in operator</source>
          <target state="translated">操作的结果,与内置的操作符相同。</target>
        </trans-unit>
        <trans-unit id="5b1c264300cd8b658cc8b4e315b7758a06a23af7" translate="yes" xml:space="preserve">
          <source>The result of the operation.</source>
          <target state="translated">行动的结果。</target>
        </trans-unit>
        <trans-unit id="9d8e130938ba904bc8f047659f58c659ed670a0b" translate="yes" xml:space="preserve">
          <source>The result of this expression will be discarded. Print error messages if the operation has no side effects (and hence is meaningless).</source>
          <target state="translated">此表达式的结果将被丢弃。如果操作没有副作用(因此没有意义),则打印错误信息。</target>
        </trans-unit>
        <trans-unit id="2a7cfc7639682da470adfb6b183264f1a3b8552c" translate="yes" xml:space="preserve">
          <source>The result type of an</source>
          <target state="translated">的结果类型</target>
        </trans-unit>
        <trans-unit id="4056040f4fa407b267fad8cbca77b5fc61b11543" translate="yes" xml:space="preserve">
          <source>The resulting addresses will be used in a call to &lt;code&gt;Socket.bind&lt;/code&gt;.</source>
          <target state="translated">结果地址将用于 &lt;code&gt;Socket.bind&lt;/code&gt; 的调用中。</target>
        </trans-unit>
        <trans-unit id="3b20f209f4a7f010b51d8af08450b0f594e3ca06" translate="yes" xml:space="preserve">
          <source>The resulting center-justified string. The returned string is GC-allocated. To avoid GC allocation, use &lt;a href=&quot;#centerJustifier&quot;&gt;&lt;code&gt;centerJustifier&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">结果中心对齐的字符串。返回的字符串是GC分配的。为避免分配GC，请改用&lt;a href=&quot;#centerJustifier&quot;&gt; &lt;code&gt;centerJustifier&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6de191dd7ab6e3535ad839e47c65dfd4fc76b1d8" translate="yes" xml:space="preserve">
          <source>The resulting index.</source>
          <target state="translated">结果指数。</target>
        </trans-unit>
        <trans-unit id="3934e1c05473de8755d2bda617c6973f102e169c" translate="yes" xml:space="preserve">
          <source>The return code of the operation. The value stored in val should be used only if the return value is &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt;.</source>
          <target state="translated">操作的返回码。仅当返回值为 &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt; 时,才应使用val中存储的值。</target>
        </trans-unit>
        <trans-unit id="1da37adfbfe4961b78a217ba2c3b5022d249608b" translate="yes" xml:space="preserve">
          <source>The return expression associated with the first test expression that made the predicate yield true, or the default return expression if no test expression matched.</source>
          <target state="translated">与使谓词产生真的第一个测试表达式相关联的返回表达式,如果没有匹配的测试表达式,则使用默认的返回表达式。</target>
        </trans-unit>
        <trans-unit id="96d68b6363dece3bf1b664aecfe8cf00504e56f0" translate="yes" xml:space="preserve">
          <source>The return type (int or long). It defaults to time_t, which is normally 32 bits on a 32-bit system and 64 bits on a 64-bit system.</source>
          <target state="translated">返回类型(int或long),默认为time_t,在32位系统中为32位,在64位系统中为64位。默认值为time_t,32位系统通常为32位,64位系统为64位。</target>
        </trans-unit>
        <trans-unit id="205ac1a8649e05600dd566c06cc715bf690a04c6" translate="yes" xml:space="preserve">
          <source>The return type must not have unshared aliasing unless &lt;code&gt;fun&lt;/code&gt; is &lt;code&gt;pure&lt;/code&gt; or the &lt;code&gt;Task&lt;/code&gt; is executed via &lt;code&gt;executeInNewThread&lt;/code&gt; instead of using a &lt;code&gt;TaskPool&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;fun&lt;/code&gt; 是 &lt;code&gt;pure&lt;/code&gt; 函数或者通过 &lt;code&gt;executeInNewThread&lt;/code&gt; 而不是使用 &lt;code&gt;TaskPool&lt;/code&gt; 来执行 &lt;code&gt;Task&lt;/code&gt; ,否则返回类型不得具有非共享别名。</target>
        </trans-unit>
        <trans-unit id="0e9168599ed0b4047c1160546ea0dbeb54368257" translate="yes" xml:space="preserve">
          <source>The return type of the error handler.</source>
          <target state="translated">错误处理程序的返回类型。</target>
        </trans-unit>
        <trans-unit id="97a463467304a89d6cd8cb9cc6d419fcfa020151" translate="yes" xml:space="preserve">
          <source>The return type of the function called by this &lt;code&gt;Task&lt;/code&gt;. This can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;Task&lt;/code&gt; 调用的函数的返回类型。这可以是 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5cb9f689236bc6a0892c16310f01988eb2264f8" translate="yes" xml:space="preserve">
          <source>The return type of tryVisit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">tryVisit的返回类型是从访问函数中推导出来的,并且在所有的重载中必须是相同的。</target>
        </trans-unit>
        <trans-unit id="1337a5d1a9830872413420563b85bf03297ab386" translate="yes" xml:space="preserve">
          <source>The return type of visit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">访问的返回类型是从访问函数中推导出来的,并且在所有的重载中必须是相同的。</target>
        </trans-unit>
        <trans-unit id="1ae63b720e25e931777a9598eac602b1cc909af8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="463c16879da8ce6d09697a58e7475146e16150d1" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="c060f61f5611e03952bbbab3e92b4fea17da134a" translate="yes" xml:space="preserve">
          <source>The return value of the function is cached, so the procedures described below will only be performed the first time the function is called. All subsequent runs will return the same string, regardless of whether environment variables and directory structures have changed in the meantime.</source>
          <target state="translated">函数的返回值会被缓存,所以只有在第一次调用函数时才会执行下面描述的程序。所有后续的运行都将返回相同的字符串,不管环境变量和目录结构是否发生了变化。</target>
        </trans-unit>
        <trans-unit id="1adffc51f8315eaf8be8bf12efa55eccecc130de" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stderr&quot;&gt;&lt;code&gt;core.stdc.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装了&lt;a href=&quot;core_stdc_stdio#stderr&quot;&gt; &lt;code&gt;core.stdc.stdio.stderr&lt;/code&gt; &lt;/a&gt;，因此是全局线程。必须在单线程或锁定上下文中将 &lt;code&gt;stderr&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; ，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="25646bf2b751680fc9f348ccd8f6fea18202d8c1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stdin&quot;&gt;&lt;code&gt;core.stdc.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装&lt;a href=&quot;core_stdc_stdio#stdin&quot;&gt; &lt;code&gt;core.stdc.stdio.stdin&lt;/code&gt; &lt;/a&gt;，因此是全局线程。必须在单线程或锁定上下文中将 &lt;code&gt;stdin&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; ，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="70b78c3af2ae7539b55d9cf5b58f2854c458dd90" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stdout&quot;&gt;&lt;code&gt;core.stdc.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装了&lt;a href=&quot;core_stdc_stdio#stdout&quot;&gt; &lt;code&gt;core.stdc.stdio.stdout&lt;/code&gt; &lt;/a&gt;，因此是全局线程。将 &lt;code&gt;stdout&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; 必须在单线程或锁定上下文中完成，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="818fa28d06533d229f1e780afce11dd92bba71cd" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stderr&quot;&gt;&lt;code&gt;core.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装了&lt;a href=&quot;core_stdio#stderr&quot;&gt; &lt;code&gt;core.stdio.stderr&lt;/code&gt; &lt;/a&gt;，因此是全局线程。必须在单线程或锁定上下文中将 &lt;code&gt;stderr&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; ，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="c5c6e553a95738c70b1b18bed8de44ea5bcf8eb1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdin&quot;&gt;&lt;code&gt;core.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装了&lt;a href=&quot;core_stdio#stdin&quot;&gt; &lt;code&gt;core.stdio.stdin&lt;/code&gt; &lt;/a&gt;，因此是全局线程。将 &lt;code&gt;stdin&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; 必须在单线程或锁定上下文中完成，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="58bd0e7417109f330774ab518ccd7daa1f03d122" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdout&quot;&gt;&lt;code&gt;core.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">返回的&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;包装了&lt;a href=&quot;core_stdio#stdout&quot;&gt; &lt;code&gt;core.stdio.stdout&lt;/code&gt; &lt;/a&gt;，因此是全局线程。必须在单线程或锁定上下文中将 &lt;code&gt;stdout&lt;/code&gt; 重新分配给其他 &lt;code&gt;File&lt;/code&gt; ，以避免竞争情况。</target>
        </trans-unit>
        <trans-unit id="ac381e0220e927fc50320b0674e141c6fbd265c5" translate="yes" xml:space="preserve">
          <source>The returned object additionally supports &lt;a href=&quot;#unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回的对象还支持&lt;a href=&quot;#unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6492e8cd4172777485864f95c54fa9ab563046c6" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is by default taken to be the current working directory. If specified, &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">返回的路径是相对于 &lt;code&gt;base&lt;/code&gt; 的，默认情况下将其作为当前工作目录。如果指定， &lt;code&gt;base&lt;/code&gt; 必须是绝对路径，并且始终假定它引用目录。如果 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 引用相同的目录，则该函数返回 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27a61535d29f02d1215deba5ffbffddc1e97e7db" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is usually the current working directory. &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">返回的路径是相对于 &lt;code&gt;base&lt;/code&gt; 的，通常是当前工作目录。 &lt;code&gt;base&lt;/code&gt; 必须是绝对路径，并且始终假定它引用目录。如果 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 引用相同的目录，则该函数返回 &lt;code&gt;'.'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e221dcc2a55e6ae3990cde11462a83ddb8c59e57" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;a href=&quot;#ticksToNSecs&quot;&gt;&lt;code&gt;ticksToNSecs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ticksToNSecs&quot;&gt; &lt;code&gt;ticksToNSecs&lt;/code&gt; &lt;/a&gt;的相反方向。</target>
        </trans-unit>
        <trans-unit id="c6ea2f4408254d943e5179ee3bbfade7f366fbe9" translate="yes" xml:space="preserve">
          <source>The right part of &lt;code&gt;r&lt;/code&gt; after partitioning.  If &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;. If &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in the left part of &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;.</source>
          <target state="translated">分割后 &lt;code&gt;r&lt;/code&gt; 的右部分。如果 &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt; ， &lt;code&gt;partition&lt;/code&gt; 保留了所有元件的相对排序 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 在 &lt;code&gt;r&lt;/code&gt; 为其 &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; 。如果 &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt; ， &lt;code&gt;partition&lt;/code&gt; 保留了所有元件的相对排序 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 中的左侧部分 &lt;code&gt;r&lt;/code&gt; 为其中 &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74483ebbb544d307348c8757c03b1bb648258bec" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison</source>
          <target state="translated">右边的比较</target>
        </trans-unit>
        <trans-unit id="0e9a080e28a8d91db65b56c19e48812d639eb325" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for equality</source>
          <target state="translated">比较平等的右侧</target>
        </trans-unit>
        <trans-unit id="82b77c8515d584392179571806e80acab0df8e0e" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for ordering</source>
          <target state="translated">右侧的比较,以便订购</target>
        </trans-unit>
        <trans-unit id="ce77342cf014dfbdd37bba884529bb7b1ea8eb76" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator</source>
          <target state="translated">操作员的右侧</target>
        </trans-unit>
        <trans-unit id="9e41eb8c1a87bc5b03b6c14f9d03728097407757" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator (left-hand side is &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">操作者的右手边（左侧是 &lt;code&gt;this&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="44c8baae8e4b1cafc92c8edb1f1a4bc6398dfd3a" translate="yes" xml:space="preserve">
          <source>The right-hand side operand</source>
          <target state="translated">右手边的操作数</target>
        </trans-unit>
        <trans-unit id="ac11224128b70935424423a8a77fd6fd68210ba1" translate="yes" xml:space="preserve">
          <source>The right-hand side operand (&lt;code&gt;Rhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">右侧操作数（ &lt;code&gt;Rhs&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="0295cf674c21bae7e541254ba48b44bd641bdb8f" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the assignment, after the operation has been computed</source>
          <target state="translated">赋值中的右侧类型,在计算出操作后</target>
        </trans-unit>
        <trans-unit id="718e1f58f1f55d464000d479f6fd938c33906894" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the operator</source>
          <target state="translated">右手边类型的操作员</target>
        </trans-unit>
        <trans-unit id="a73d548c23060689342ba25b61016e797895c8bb" translate="yes" xml:space="preserve">
          <source>The right-hand side type involved in the operator</source>
          <target state="translated">运营商所涉及的右侧类型</target>
        </trans-unit>
        <trans-unit id="e3fed9dabe35a6b8579a8bd12124493c72510d8b" translate="yes" xml:space="preserve">
          <source>The right-hand side value in the assignment, after the operator has been evaluated</source>
          <target state="translated">赋值中的右侧值,在运算符被评估后。</target>
        </trans-unit>
        <trans-unit id="cd88512e1e583ed536b72443b9651f20abee0041" translate="yes" xml:space="preserve">
          <source>The routine called when a message is sent to a full mailbox.</source>
          <target state="translated">当一个邮件被发送到一个完整的邮箱时调用的例程。</target>
        </trans-unit>
        <trans-unit id="b66d87a6c0e08abdd807f5a483f6da0a435298a3" translate="yes" xml:space="preserve">
          <source>The routines and algorithms are derived from the</source>
          <target state="translated">这些例程和算法来自于</target>
        </trans-unit>
        <trans-unit id="89f0c0488274c89f59fab106ec127c844449805c" translate="yes" xml:space="preserve">
          <source>The rules for strings are the usual for literals: If it can fit in an &lt;code&gt;int&lt;/code&gt;, it is an &lt;code&gt;int&lt;/code&gt;. Otherwise, it is a &lt;code&gt;long&lt;/code&gt;. But, if the user specifically asks for a &lt;code&gt;long&lt;/code&gt; with the &lt;code&gt;L&lt;/code&gt; suffix, always give the &lt;code&gt;long&lt;/code&gt;. Give an unsigned iff it is asked for with the &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; suffix. Octals created from integers preserve the type of the passed-in integral.</source>
          <target state="translated">字符串规则是文字常识：如果它可以容纳 &lt;code&gt;int&lt;/code&gt; ，则为 &lt;code&gt;int&lt;/code&gt; 。否则，它会很 &lt;code&gt;long&lt;/code&gt; 。但是，如果用户特别要求一个 &lt;code&gt;long&lt;/code&gt; 与 &lt;code&gt;L&lt;/code&gt; 后缀，总是给人 &lt;code&gt;long&lt;/code&gt; 。如果要求使用 &lt;code&gt;U&lt;/code&gt; 或 &lt;code&gt;u&lt;/code&gt; 后缀，请给出未签名的iff 。由整数创建的八进制保留传入的整数的类型。</target>
        </trans-unit>
        <trans-unit id="e32ff39ea4f694316ee9d2d062e0ec9da6e2270f" translate="yes" xml:space="preserve">
          <source>The runtime might have been terminated and not be usable anymore when the destructors are called. Otherwise, usage and requirements of &lt;code&gt;crt_destructor&lt;/code&gt; are similar to those of &lt;code&gt;crt_constructor&lt;/code&gt;.</source>
          <target state="translated">调用析构函数时，运行时可能已终止并且不再可用。否则，使用和要求 &lt;code&gt;crt_destructor&lt;/code&gt; 类似于那些 &lt;code&gt;crt_constructor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0dffdc084b14542b868ac2c2fcdcfbf771ea55f" translate="yes" xml:space="preserve">
          <source>The runtime module exposes information specific to the D runtime code.</source>
          <target state="translated">运行时模块暴露了D运行时代码的特定信息。</target>
        </trans-unit>
        <trans-unit id="1e0c7d670da430e1c2fcc83076d681bba14efcaf" translate="yes" xml:space="preserve">
          <source>The safety level of this function is faked. It shows itself as &lt;code&gt;@trusted pure nothrow&lt;/code&gt; to not break existing code.</source>
          <target state="translated">该功能的安全级别是伪造的。它显示为 &lt;code&gt;@trusted pure nothrow&lt;/code&gt; ，不会破坏现有代码。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
