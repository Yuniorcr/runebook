<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="481df4f9db6b7c39f75ab8b5d8402946a05557b9" translate="yes" xml:space="preserve">
          <source>An output range that discards the data it receives.</source>
          <target state="translated">丢弃收到的数据的输出范围。</target>
        </trans-unit>
        <trans-unit id="01b526186c983c89501e19ff25742faa0abd686c" translate="yes" xml:space="preserve">
          <source>An output range to write the contents to.</source>
          <target state="translated">要写入内容的输出范围。</target>
        </trans-unit>
        <trans-unit id="6ec96a76a1b7b768707aea157270f72d702aae35" translate="yes" xml:space="preserve">
          <source>An uninitialized &lt;code&gt;Variant&lt;/code&gt; is used in any way except assignment and &lt;code&gt;hasValue&lt;/code&gt;;</source>
          <target state="translated">未赋值的 &lt;code&gt;Variant&lt;/code&gt; 可以以任何方式使用，赋值和 &lt;code&gt;hasValue&lt;/code&gt; 除外；</target>
        </trans-unit>
        <trans-unit id="017d1765237968f656e289b4e56677bea3baad1b" translate="yes" xml:space="preserve">
          <source>An uninitialized value, generated from void initializers.</source>
          <target state="translated">一个未初始化的值,由void初始化器生成。</target>
        </trans-unit>
        <trans-unit id="6d865e1b843ed22f5ad95224465f066dd3bf97cd" translate="yes" xml:space="preserve">
          <source>An unqualified postblit will get called even if the struct is instantiated as &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;, but the compiler issues an error if the struct is instantiated as &lt;code&gt;shared&lt;/code&gt;:</source>
          <target state="translated">即使将struct实例化为 &lt;code&gt;immutable&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; ，也会调用不合格的postblit ，但是如果将struct实例化为 &lt;code&gt;shared&lt;/code&gt; ，则编译器会发出错误：</target>
        </trans-unit>
        <trans-unit id="02377b58a34c4a8ec19952d46cd99f893c878ed8" translate="yes" xml:space="preserve">
          <source>An unrecognized command-line argument is passed, and &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; was not present.</source>
          <target state="translated">传递了无法识别的命令行参数，并且不存在 &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="355743baaf25b39e6a1bf6c9a0897a53f7ca51a0" translate="yes" xml:space="preserve">
          <source>An unrecognized option such as &quot;--baz&quot; will be found untouched in &lt;code&gt;args&lt;/code&gt; after &lt;code&gt;getopt&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;getopt&lt;/code&gt; 返回后，在 &lt;code&gt;args&lt;/code&gt; 中将发现未识别的选项，例如&amp;ldquo; --baz&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b75455d22427a9d7061b91a6aa632f59812aa7cb" translate="yes" xml:space="preserve">
          <source>Analogously to class templates, struct, union and interfaces can be transformed into templates by supplying a template parameter list.</source>
          <target state="translated">类似于类模板,结构体、联合体和接口可以通过提供模板参数列表来转化为模板。</target>
        </trans-unit>
        <trans-unit id="381d6919b76a155cc3d0bed8744ee2e82e29874b" translate="yes" xml:space="preserve">
          <source>Analogously, &lt;code&gt;typeof(super)&lt;/code&gt; will generate the type of what &lt;code&gt;super&lt;/code&gt; would be in a non-static member function.</source>
          <target state="translated">类似地， &lt;code&gt;typeof(super)&lt;/code&gt; 将生成非静态成员函数中 &lt;code&gt;super&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="e760dd880de0f515f576dc77edef82d0231e14ae" translate="yes" xml:space="preserve">
          <source>Ancient Greek Musical Notation</source>
          <target state="translated">古希腊音乐记谱法</target>
        </trans-unit>
        <trans-unit id="aac24095b26055100b3e137537a2c7e0ad932e04" translate="yes" xml:space="preserve">
          <source>Ancient Greek Numbers</source>
          <target state="translated">古希腊数字</target>
        </trans-unit>
        <trans-unit id="3550f110a8c69b086b7eac12c46c400773c345dc" translate="yes" xml:space="preserve">
          <source>Ancient Symbols</source>
          <target state="translated">古代符号</target>
        </trans-unit>
        <trans-unit id="29bd442643bea5b50cf62a67104dd1d1aa8f0d1e" translate="yes" xml:space="preserve">
          <source>And Expressions</source>
          <target state="translated">和表现形式</target>
        </trans-unit>
        <trans-unit id="955032d49b799cc6cb579cffbe0f243b5d0f3d5f" translate="yes" xml:space="preserve">
          <source>And all the summary sections will now be green.</source>
          <target state="translated">而现在所有的总结部分都将是绿色的。</target>
        </trans-unit>
        <trans-unit id="e67c2d4e000dc2740dc758b29287dd9038d89a6b" translate="yes" xml:space="preserve">
          <source>And an example of D code providing a callback to C code:</source>
          <target state="translated">还有一个D代码提供回调C代码的例子。</target>
        </trans-unit>
        <trans-unit id="028627a78221787a21142d8d33379cef0d471467" translate="yes" xml:space="preserve">
          <source>AndAnd Expressions</source>
          <target state="translated">和和表达式</target>
        </trans-unit>
        <trans-unit id="d132739724126beb0a58639e9a6156fdf0949d66" translate="yes" xml:space="preserve">
          <source>AndAndExpression</source>
          <target state="translated">AndAndExpression</target>
        </trans-unit>
        <trans-unit id="b25772e958c7000fd371337d6359418dab3becfa" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu</source>
          <target state="translated">Andrei Alexandrescu</target>
        </trans-unit>
        <trans-unit id="8086e1eeb4770ea0dab8abf60035423c0a58a5b4" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu's article &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt; &lt;i&gt;On Iteration&lt;/i&gt;&lt;/a&gt; for conceptual aspect of ranges and the motivation</source>
          <target state="translated">Andrei Alexandrescu的&lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt;&lt;i&gt;关于迭代&lt;/i&gt;&lt;/a&gt;的文章介绍了范围和动机的概念方面 &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="b803b58141bc58845f04cfa8646ac85f1f1a979d" translate="yes" xml:space="preserve">
          <source>Anonymous Enums</source>
          <target state="translated">无名记</target>
        </trans-unit>
        <trans-unit id="7ccd2afbc983959f9583ca7f31cb4e5cf46494d9" translate="yes" xml:space="preserve">
          <source>Anonymous Functions and Anonymous Delegates</source>
          <target state="translated">匿名函数和匿名代表</target>
        </trans-unit>
        <trans-unit id="98a2443b6da1909f7a102e64a4964e0f390eb397" translate="yes" xml:space="preserve">
          <source>Anonymous Nested Classes</source>
          <target state="translated">匿名嵌套类</target>
        </trans-unit>
        <trans-unit id="46249cc944aedcf50eaf15b7e810784027798c68" translate="yes" xml:space="preserve">
          <source>Anonymous delegates can behave like arbitrary statement literals. For example, here an arbitrary statement is executed by a loop:</source>
          <target state="translated">匿名委托人可以表现得像任意语句的字面意思。例如,这里的任意语句由一个循环执行。</target>
        </trans-unit>
        <trans-unit id="e1acf88a52df3795f2b20ed6511eee7ceb7ec305" translate="yes" xml:space="preserve">
          <source>Another caveat of using sub-matcher is that skip is not available preciesly because sub-matcher doesn't detect all lengths.</source>
          <target state="translated">使用sub-matcher的另一个注意事项是,由于sub-matcher不能检测所有的长度,所以跳过不能预先使用。</target>
        </trans-unit>
        <trans-unit id="9a60f4e1a9ef014cfadbb26ea290e8c3eb775ed4" translate="yes" xml:space="preserve">
          <source>Another event handling module</source>
          <target state="translated">另一个事件处理模块</target>
        </trans-unit>
        <trans-unit id="bae2455d3699406c3641a5d660465c6bf6758fc6" translate="yes" xml:space="preserve">
          <source>Another example of formatting a &lt;code&gt;struct&lt;/code&gt; with a defined &lt;code&gt;toString&lt;/code&gt;, this time using the &lt;code&gt;scope delegate&lt;/code&gt; method.  This method is now discouraged for non-virtual functions. If possible, please use the output range method instead.</source>
          <target state="translated">另一个使用定义的 &lt;code&gt;toString&lt;/code&gt; 格式化 &lt;code&gt;struct&lt;/code&gt; 示例，这次使用 &lt;code&gt;scope delegate&lt;/code&gt; 方法。现在不建议将此方法用于非虚拟功能。如果可能，请改用输出范围方法。</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="85e6f644dc8e5726c5821532bf00eff211afd4d4" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; or non-basic &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; (i.e. any type that does not encode as a fixed one or two character sequence) that has been emitted to the mangled symbol before will not be emitted again, but is referenced by a special sequence encoding the relative position of the original occurrence in the mangled symbol name.</source>
          <target state="translated">以前已经发送到错误符号的任何&lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt;或非基本&lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;类型&lt;/i&gt;&lt;/a&gt;（即，没有编码为固定的一个或两个字符序列的任何类型）都不会再次发出，而是由编码相对位置的特殊序列引用变形符号名称中原始出现的位置。</target>
        </trans-unit>
        <trans-unit id="a4ebed2ed3fe69fdf17bf0f9ea8120a1a0f126ed" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;pure&lt;/code&gt; function that is not strongly pure cannot be assumed to be memoizable, and calls to it may not be elided even if it returns &lt;code&gt;void&lt;/code&gt; (save for compiler optimizations that prove the function has no effect). Function calls may still be elided, or results be memoized, by means of traditional inlining and optimization techniques available for all functions.</source>
          <target state="translated">任何非强纯的 &lt;code&gt;pure&lt;/code&gt; 函数都不能被假定为可记忆的，并且即使返回 &lt;code&gt;void&lt;/code&gt; 也不能忽略对其的调用（保存编译器优化以证明该函数无效）。仍然可以通过可用于所有功能的传统内联和优化技术来消除函数调用或记住结果。</target>
        </trans-unit>
        <trans-unit id="eb9050538a91f8603d45e66e05f6aeeb1d29c1a1" translate="yes" xml:space="preserve">
          <source>Any CSV input</source>
          <target state="translated">任何CSV输入</target>
        </trans-unit>
        <trans-unit id="3dd20dd36e01004b82e2eb3d1b7678c47e9521c9" translate="yes" xml:space="preserve">
          <source>Any IPv4 host address.</source>
          <target state="translated">任何IPv4主机地址。</target>
        </trans-unit>
        <trans-unit id="8aed77784e6588d748089e680321e31de462e28c" translate="yes" xml:space="preserve">
          <source>Any IPv4 port number.</source>
          <target state="translated">任何IPv4端口号。</target>
        </trans-unit>
        <trans-unit id="bb484c1e8a46997e29e20927039aa9b377327c02" translate="yes" xml:space="preserve">
          <source>Any IPv6 host address.</source>
          <target state="translated">任何IPv6主机地址。</target>
        </trans-unit>
        <trans-unit id="94c6cca2615cd31987c71c42944c48bb96956b95" translate="yes" xml:space="preserve">
          <source>Any IPv6 port number.</source>
          <target state="translated">任何IPv6端口号。</target>
        </trans-unit>
        <trans-unit id="1e80ff69d9bdfebf77e41c7bd69caee37e4adb6e" translate="yes" xml:space="preserve">
          <source>Any Object types will be serialized in a key-sorted order.</source>
          <target state="translated">任何对象类型都将以键排序的方式序列化。</target>
        </trans-unit>
        <trans-unit id="6f7c1cd84505fa215ea84971d24628315cd3387b" translate="yes" xml:space="preserve">
          <source>Any Statement that fails semantic() or has a component that is an ErrorExp or a TypeError should return an ErrorStatement from semantic().</source>
          <target state="translated">任何没有通过semantic()的Statement,或者有一个是ErrorExp或TypeError的组件,都应该从semantic()返回一个ErrorStatement。</target>
        </trans-unit>
        <trans-unit id="baa16ecc9203783f7d302f47d6c7e99ca53b7882" translate="yes" xml:space="preserve">
          <source>Any ambiguities in the grammar between</source>
          <target state="translated">语法上的任何歧义</target>
        </trans-unit>
        <trans-unit id="77ecebcd0dc38ae59d287e9d6832a173b570a0a2" translate="yes" xml:space="preserve">
          <source>Any atom</source>
          <target state="translated">任何原子</target>
        </trans-unit>
        <trans-unit id="638621cad02fb4ef96d35005061aa41c6d8d2099" translate="yes" xml:space="preserve">
          <source>Any casting of a class reference to a derived class reference is done with a runtime check to make sure it really is a downcast. &lt;code&gt;null&lt;/code&gt; is the result if it isn't.</source>
          <target state="translated">将类引用转换为派生类引用的任何操作都通过运行时检查来完成，以确保它确实是垂头丧气的。如果不是，则结果为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7916c4b8de53330f21dcd29a0e59721012e5dd75" translate="yes" xml:space="preserve">
          <source>Any class invariants for base classes are applied before the class invariant for the derived class.</source>
          <target state="translated">任何基类的类不变量都是在派生类的类不变量之前应用的。</target>
        </trans-unit>
        <trans-unit id="f7e950396436ad2a46ce9aad7dec469f189171b3" translate="yes" xml:space="preserve">
          <source>Any data referenced by the const declaration cannot be changed from the const declaration, but it might be changed by other references to the same data.</source>
          <target state="translated">任何被const声明引用的数据都不能从const声明中改变,但它可能会被其他对相同数据的引用所改变。</target>
        </trans-unit>
        <trans-unit id="ea9ba6b957e1ee541543e4ed84469edf4ec75cad" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined thread.</source>
          <target state="translated">任何未被加入的线程处理的异常。</target>
        </trans-unit>
        <trans-unit id="df41046890795b4eaa63b398c58e4d9d99374a20" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined threads.</source>
          <target state="translated">任何未被加入的线程处理的异常。</target>
        </trans-unit>
        <trans-unit id="010d3e9dcdbd22cd7fd006df77170e4cb60a5618" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this fiber if rethrow = false, null otherwise.</source>
          <target state="translated">如果rethrow=false,任何异常没有被这个光纤处理,否则为null。</target>
        </trans-unit>
        <trans-unit id="b6ba130c34ce4b05804f636f1f2f916c5937c009" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this thread if rethrow = false, null otherwise.</source>
          <target state="translated">任何未被本线程处理的异常,如果rethrow=false,否则为null。</target>
        </trans-unit>
        <trans-unit id="3547b50f09fd44e299559c0d0f1b8fb00ea84d79" translate="yes" xml:space="preserve">
          <source>Any expression that resolves to either a tuple of strings or an empty tuple is accepted. When the expression resolves to an empty tuple, it is equivalent to &lt;code&gt;extern (C++)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f674a6378976f81a229e3e40bb92d9695e3314fe" translate="yes" xml:space="preserve">
          <source>Any functions that execute in CTFE must also be executable at run time. The compile time evaluation of a function does the equivalent of running the function at run time. This means that the semantics of a function cannot depend on compile time values of the function. For example:</source>
          <target state="translated">任何在CTFE中执行的函数也必须在运行时可以执行。函数的编译时评估相当于在运行时运行该函数。这意味着函数的语义不能依赖于函数的编译时值。比如说</target>
        </trans-unit>
        <trans-unit id="a57e0db645362adce30e4484501c92ffe3bbf8b7" translate="yes" xml:space="preserve">
          <source>Any insertion, removal, or lookups in an associative array</source>
          <target state="translated">在关联数组中的任何插入、移除或查找。</target>
        </trans-unit>
        <trans-unit id="0e84b6b0c57f34d7c618d447a7ab2c9f8792eac9" translate="yes" xml:space="preserve">
          <source>Any interface that derives from a C++ interface is also a C++ interface. A C++ interface differs from a D interface in that:</source>
          <target state="translated">任何从C++接口派生出来的接口也是C++接口。C++接口与D接口的不同之处在于。</target>
        </trans-unit>
        <trans-unit id="440031e52a8a0c7f5013522c41d2f3dc66691e39" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, along with releasing any intervening synchronization mutexes.</source>
          <target state="translated">任何中间的最后子句都会被执行,同时释放任何中间的同步互斥。</target>
        </trans-unit>
        <trans-unit id="752a908277ccaeb8ca9908aea34bc98614160ea6" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, and any intervening synchronization objects are released.</source>
          <target state="translated">任何中间的最后子句都会被执行,任何中间的同步对象都会被释放。</target>
        </trans-unit>
        <trans-unit id="3c58819fbd73a8c9fe0c340f0db018003ce09975" translate="yes" xml:space="preserve">
          <source>Any invariants for fields are applied before the struct invariant.</source>
          <target state="translated">任何字段的不变量都是在结构不变量之前应用的。</target>
        </trans-unit>
        <trans-unit id="f9fe95fc6eae39aaf25f84d103f3acf7d7a384fd" translate="yes" xml:space="preserve">
          <source>Any license information for copyrighted code.</source>
          <target state="translated">任何受版权保护的代码的许可信息。</target>
        </trans-unit>
        <trans-unit id="67b9adde439b5f8364926599d4a45d83875f65d8" translate="yes" xml:space="preserve">
          <source>Any numerical type that supports the modulo operator &lt;code&gt;%&lt;/code&gt;. If bit-shifting &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; are also supported, Stein's algorithm will be used; otherwise, Euclid's algorithm is used as a fallback.</source>
          <target state="translated">任何支持模运算符 &lt;code&gt;%&lt;/code&gt; 的数值类型。如果还支持移位 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ，则将使用Stein算法。否则，使用Euclid算法作为后备。</target>
        </trans-unit>
        <trans-unit id="81c3013df61cbea6a4c917b70878d87da30767d9" translate="yes" xml:space="preserve">
          <source>Any pointer may be cast to &lt;code&gt;void*&lt;/code&gt; and from &lt;code&gt;void*&lt;/code&gt; back to its original type. Casting between pointer and non-pointer types is prohibited.</source>
          <target state="translated">任何指针都可以转换为 &lt;code&gt;void*&lt;/code&gt; ，也可以从 &lt;code&gt;void*&lt;/code&gt; 回其原始类型。禁止在指针和非指针类型之间进行强制转换。</target>
        </trans-unit>
        <trans-unit id="c5cc05a90008a92dc38ec7d27e928baccc65c4ac" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;NegInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;NegInfInterval&lt;/code&gt; is to create an infinite range which starts at negative infinity and goes to a fixed end point. Iterate over it in reverse.</source>
          <target state="translated">遍历 &lt;code&gt;NegInfInterval&lt;/code&gt; 的任何范围都是无限的。因此，使用 &lt;code&gt;NegInfInterval&lt;/code&gt; 的主要目的是创建一个无限范围，该范围从负无穷大到固定终点。反向迭代。</target>
        </trans-unit>
        <trans-unit id="fea46f39188f37b7400472b6a7256e566f0dadfc" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;PosInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;PosInfInterval&lt;/code&gt; is to create an infinite range which starts at a fixed point in time and goes to positive infinity.</source>
          <target state="translated">迭代 &lt;code&gt;PosInfInterval&lt;/code&gt; 的任何范围都是无限的。因此，使用 &lt;code&gt;PosInfInterval&lt;/code&gt; 的主要目的是创建一个无限范围，该范围从固定时间点开始并达到正无穷大。</target>
        </trans-unit>
        <trans-unit id="f9d9d3b6ac3e9e29441a9345be2bae022fb55442" translate="yes" xml:space="preserve">
          <source>Any sequence of character class elements implicitly forms a union.</source>
          <target state="translated">任何字符类元素的序列都隐含地形成一个联合体。</target>
        </trans-unit>
        <trans-unit id="f33c41254cc91d5ef5db3832237d967b66a6b7df" translate="yes" xml:space="preserve">
          <source>Any statement can be labeled, including empty statements, and so can serve as the target of a goto statement. Labeled statements can also serve as the target of a break or continue statement.</source>
          <target state="translated">任何语句都可以被标记,包括空语句,因此可以作为goto语句的目标。标记的语句也可以作为break或continue语句的目标。</target>
        </trans-unit>
        <trans-unit id="77bf850fc03647bf14bd010a86cea6f71dcbb566" translate="yes" xml:space="preserve">
          <source>Any type which implicitly converts to &lt;code&gt;dchar&lt;/code&gt;. In the case where it's a built-in type, or an enum of a built-in type, &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; is returned, whereas if it's a user-defined type, &lt;code&gt;dchar&lt;/code&gt; is returned.</source>
          <target state="translated">隐式转换为 &lt;code&gt;dchar&lt;/code&gt; 的任何类型。如果是内置类型或内置类型的枚举，则返回 &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; ，而如果是用户定义类型，则返回 &lt;code&gt;dchar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83413c5ae04e9398c07c45877def24fe2d3e627f" translate="yes" xml:space="preserve">
          <source>Any usage examples</source>
          <target state="translated">任何用法的例子</target>
        </trans-unit>
        <trans-unit id="5b0bf7c14ffa6d93dd97c17d04c8db163f500b7e" translate="yes" xml:space="preserve">
          <source>Append 'this' to the specific module members[]</source>
          <target state="translated">将'this'添加到特定的模块成员[]中。</target>
        </trans-unit>
        <trans-unit id="e6389badcbed51133ce737118947b50567eac4a2" translate="yes" xml:space="preserve">
          <source>Append &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;&lt;code&gt;ch&lt;/code&gt; to this grapheme.</source>
          <target state="translated">将&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt; &lt;code&gt;ch&lt;/code&gt; 附加到该字形。</target>
        </trans-unit>
        <trans-unit id="9423c656632feb94c95542550bc5776ab847c04f" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;e2&lt;/code&gt; to chain of exceptions that starts with &lt;code&gt;e1&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;e2&lt;/code&gt; 附加到以 &lt;code&gt;e1&lt;/code&gt; 开头的异常链。</target>
        </trans-unit>
        <trans-unit id="e3d06094350a95ba5b433011fb835e7124c4ec5e" translate="yes" xml:space="preserve">
          <source>Append a CData item to the interior of this element</source>
          <target state="translated">在这个元素的内部添加一个CD数据项。</target>
        </trans-unit>
        <trans-unit id="984824e040f0720fce2fc4f6a13d57fc728e8caa" translate="yes" xml:space="preserve">
          <source>Append a comment to the interior of this element</source>
          <target state="translated">在该元素的内部添加注释</target>
        </trans-unit>
        <trans-unit id="db03388cd72ade8520d2e378966e698614e72a5e" translate="yes" xml:space="preserve">
          <source>Append a complete element to the interior of this element</source>
          <target state="translated">在这个元素的内部添加一个完整的元素。</target>
        </trans-unit>
        <trans-unit id="ef21e116b7bca07b0b591badb0bc081fdcfe67e5" translate="yes" xml:space="preserve">
          <source>Append a processing instruction to the interior of this element</source>
          <target state="translated">在该元素内部添加处理指令。</target>
        </trans-unit>
        <trans-unit id="496596976c04bde5f7e7a5a8202d7b8abe85e980" translate="yes" xml:space="preserve">
          <source>Append a text item to the interior of this element</source>
          <target state="translated">在这个元素的内部添加一个文本项。</target>
        </trans-unit>
        <trans-unit id="f6dd93a31eb85b0a74d513a784054a244ba3c76c" translate="yes" xml:space="preserve">
          <source>Append all &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; from the input range &lt;code&gt;inp&lt;/code&gt; to this Grapheme.</source>
          <target state="translated">将输入范围 &lt;code&gt;inp&lt;/code&gt; 中的所有&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;追加到此字形。</target>
        </trans-unit>
        <trans-unit id="34b47904d2988c2185d4a53f77f7d8e792a3291d" translate="yes" xml:space="preserve">
          <source>Append array &lt;code&gt;y&lt;/code&gt; to array &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">将数组 &lt;code&gt;y&lt;/code&gt; 追加到数组 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad6cd5314f128c12adc628c28aef59e004d422e0" translate="yes" xml:space="preserve">
          <source>Append data represented by ptr[0..size]</source>
          <target state="translated">添加ptr[0..size]表示的数据。</target>
        </trans-unit>
        <trans-unit id="35f4f092745cbd38143bff7f25d5d2804e9a0623" translate="yes" xml:space="preserve">
          <source>Append data to the internal buffer.</source>
          <target state="translated">将数据追加到内部缓冲区。</target>
        </trans-unit>
        <trans-unit id="6cfc826c67159c690715f887f4b34b4df17e6673" translate="yes" xml:space="preserve">
          <source>Append dchar to char[]</source>
          <target state="translated">将dchar追加到char[]</target>
        </trans-unit>
        <trans-unit id="b6ff7bb65433411731c9ec32fd03f8c8b7ab8dbf" translate="yes" xml:space="preserve">
          <source>Append dchar to wchar[]</source>
          <target state="translated">将dchar追加到wchar[]</target>
        </trans-unit>
        <trans-unit id="f099c58d9143b4e0a6f01a50957762bf07adaa8f" translate="yes" xml:space="preserve">
          <source>Append dt to data.</source>
          <target state="translated">将dt添加到数据中。</target>
        </trans-unit>
        <trans-unit id="73602dd98d646af114882b411baed4caf29ed4aa" translate="yes" xml:space="preserve">
          <source>Append dtb to data.</source>
          <target state="translated">将dtb添加到数据中。</target>
        </trans-unit>
        <trans-unit id="05676aa51ec52e96deb89d7ae3b7bad0e2920095" translate="yes" xml:space="preserve">
          <source>Append instead of overwrite on upload!</source>
          <target state="translated">在上传时添加而不是覆盖!</target>
        </trans-unit>
        <trans-unit id="725e2673bb64dd768f5e35adc33733f051daff12" translate="yes" xml:space="preserve">
          <source>Append integer item to list.</source>
          <target state="translated">将整数项添加到列表中。</target>
        </trans-unit>
        <trans-unit id="8e98d78b75b667bfa9432c073969f89aad62837e" translate="yes" xml:space="preserve">
          <source>Append nbytes of 0 to the internal buffer.</source>
          <target state="translated">将nbytes的0添加到内部缓冲区。</target>
        </trans-unit>
        <trans-unit id="6100e49b257665109b21fcb575027c3b1d83fee9" translate="yes" xml:space="preserve">
          <source>Append output of C's printf() to internal buffer.</source>
          <target state="translated">将C的printf()的输出追加到内部缓冲区。</target>
        </trans-unit>
        <trans-unit id="6f1cd15bde5d09d444835959bdf7cf1009a819c1" translate="yes" xml:space="preserve">
          <source>Append output of C's vprintf() to internal buffer.</source>
          <target state="translated">将C的vprintf()的输出追加到内部缓冲区。</target>
        </trans-unit>
        <trans-unit id="26196f1c60516e313842646d760dfe092b0b8783" translate="yes" xml:space="preserve">
          <source>Append ptr to *plist.</source>
          <target state="translated">将ptr添加到*plist中。</target>
        </trans-unit>
        <trans-unit id="379fc789872b087a61658c08353344a2820471c2" translate="yes" xml:space="preserve">
          <source>Append s to list of object files to generate later.</source>
          <target state="translated">将s添加到以后生成的对象文件列表中。</target>
        </trans-unit>
        <trans-unit id="7c74420521a423ce5daf955e234405a229d6cc0f" translate="yes" xml:space="preserve">
          <source>Append the remaining segments of &lt;code&gt;path&lt;/code&gt; to the string and return.</source>
          <target state="translated">将 &lt;code&gt;path&lt;/code&gt; 的其余部分追加到字符串并返回。</target>
        </trans-unit>
        <trans-unit id="9e7e4b12820cee8e262b36441f586183f6d04cab" translate="yes" xml:space="preserve">
          <source>Append y[] to array x[]</source>
          <target state="translated">将y[]追加到数组x[]上。</target>
        </trans-unit>
        <trans-unit id="0ef306358b052f7e64b8bcc3cd14249cef33ca02" translate="yes" xml:space="preserve">
          <source>Appender!(E[]) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A : E[], E)(auto ref A array);</source>
          <target state="translated">Appender！（E []）&lt;strong id=&quot;appender&quot;&gt;追加器&lt;/strong&gt;（A：E []，E）（自动引用A数组）;</target>
        </trans-unit>
        <trans-unit id="4e11e6991b83788f5357a19dc342f52d09507315" translate="yes" xml:space="preserve">
          <source>Appender!A &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A)()</source>
          <target state="translated">追加程序！一个&lt;strong id=&quot;appender&quot;&gt;附加器&lt;/strong&gt;（A）（）</target>
        </trans-unit>
        <trans-unit id="b06a35dce8dc5935a09578e40179d4dbbd0cee5e" translate="yes" xml:space="preserve">
          <source>Appending does not always create a copy, see &lt;a href=&quot;#resize&quot;&gt; setting dynamic array length&lt;/a&gt; for details.</source>
          <target state="translated">追加并不总是创建副本，有关详细信息，请参见&lt;a href=&quot;#resize&quot;&gt;设置动态数组长度&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d23d95cfc1028cebc43e6d6bc87290142bad8a2a" translate="yes" xml:space="preserve">
          <source>Appending to and direct manipulation of grapheme's &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; may render it no longer valid. Certain applications may chose to use Grapheme as a &quot;small string&quot; of any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; and ignore this property entirely.</source>
          <target state="translated">附加并直接操纵&lt;a href=&quot;#Character&quot;&gt;字素&lt;/a&gt;的字符可能使其不再有效。某些应用程序可能选择将Grapheme用作任何&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;的&amp;ldquo;小字符串&amp;rdquo;，而完全忽略此属性。</target>
        </trans-unit>
        <trans-unit id="27687e63c8f2765f7f45c656d25a88a2f70872d2" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;buffer&lt;/code&gt; to file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;buffer&lt;/code&gt; 追加到文件 &lt;code&gt;name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7f62b12268c12952ecff14c3290b88618812066" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;item&lt;/code&gt; to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; types if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">将 &lt;code&gt;item&lt;/code&gt; 追加到托管数组。如果 &lt;code&gt;A&lt;/code&gt; 是其他类型的 &lt;code&gt;char&lt;/code&gt; 数组，则对 &lt;code&gt;char&lt;/code&gt; 类型执行编码。</target>
        </trans-unit>
        <trans-unit id="3fa391a5e33fe2002fc2b72cecadf723ca6b30fe" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;rhs&lt;/code&gt; to the managed array.</source>
          <target state="translated">将 &lt;code&gt;rhs&lt;/code&gt; 附加到托管数组。</target>
        </trans-unit>
        <trans-unit id="7623fabcaede88b964c04becc831d4ac3e3b23ce" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; may be a single element or an input range type.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 附加到 &lt;code&gt;c&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; 可以是单个元素或输入范围类型。</target>
        </trans-unit>
        <trans-unit id="18bc8e8710e112a386b8301eb1ea86dca70c5d37" translate="yes" xml:space="preserve">
          <source>Appends a string to a linked list. If no list exists, it will be created first. Returns the new list, after appending.</source>
          <target state="translated">将一个字符串添加到链接的列表中。如果没有列表存在,则会先创建一个列表。返回追加后的新列表。</target>
        </trans-unit>
        <trans-unit id="81cdccb19773651976963e90237f5de77beaf9e6" translate="yes" xml:space="preserve">
          <source>Appends an entire range to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; elements if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">将整个范围附加到托管阵列。如果 &lt;code&gt;A&lt;/code&gt; 是其他类型的 &lt;code&gt;char&lt;/code&gt; 数组，则对 &lt;code&gt;char&lt;/code&gt; 元素执行编码。</target>
        </trans-unit>
        <trans-unit id="e1a17d68e5eb26669b8a6fd759bf09e863160e46" translate="yes" xml:space="preserve">
          <source>Appends the contents of the argument &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">将参数 &lt;code&gt;rhs&lt;/code&gt; 的内容附加到 &lt;code&gt;this&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="20cd868cd32de230764914be80101e71a8f019d2" translate="yes" xml:space="preserve">
          <source>Appends to the managed array.</source>
          <target state="translated">添加到管理数组中。</target>
        </trans-unit>
        <trans-unit id="762f62942181d4b2666650e69bb8c92655c35501" translate="yes" xml:space="preserve">
          <source>AppleTalk</source>
          <target state="translated">AppleTalk</target>
        </trans-unit>
        <trans-unit id="82cac29a8ad5cbbc38d1a1fb84f536367b07a15f" translate="yes" xml:space="preserve">
          <source>Application Binary Interface</source>
          <target state="translated">应用二进制接口</target>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="translated">应用定义的页面缓存。</target>
        </trans-unit>
        <trans-unit id="a1097391b6d8c24e778f4782f5e62fadaf414d9d" translate="yes" xml:space="preserve">
          <source>Applies a delegate or function to the given &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; depending on the held type, ensuring that all types are handled by the visiting functions.</source>
          <target state="translated">根据保留的类型将委托或函数应用于给定的&lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt;，以确保所有类型均由访问函数处理。</target>
        </trans-unit>
        <trans-unit id="2e64c5b4326d836829a0ebf41a9e13a5e62411c7" translate="yes" xml:space="preserve">
          <source>Apply MODxxxx bits to existing type.</source>
          <target state="translated">将MODxxxx位应用到现有类型中。</target>
        </trans-unit>
        <trans-unit id="ee985a3510121398e40860de4ace149b4869d63d" translate="yes" xml:space="preserve">
          <source>Apply STCxxxx bits to existing type. Use *before* semantic analysis is run.</source>
          <target state="translated">将STCxxxx位应用于现有类型。在*语义分析运行之前使用。</target>
        </trans-unit>
        <trans-unit id="a27c3d86d32e5ed828ae9b07fd5ad23ae9593843" translate="yes" xml:space="preserve">
          <source>Apply a function fp to each member of a list.</source>
          <target state="translated">将函数fp应用于列表的每个成员。</target>
        </trans-unit>
        <trans-unit id="5c98d8debd927a2a04375be8cb963231c736c4c5" translate="yes" xml:space="preserve">
          <source>Applying a qualifier to a type that already has that qualifier is legal but has no effect, e.g. given an unqualified type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;shared(const shared T)&lt;/code&gt; yields the type &lt;code&gt;const shared T&lt;/code&gt;.</source>
          <target state="translated">将限定符应用于已经具有该限定符的类型是合法的，但是没有任何效果，例如，给定非限定类型 &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;shared(const shared T)&lt;/code&gt; 会产生 &lt;code&gt;const shared T&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="2a15b638351f6a01ae8878d2186ac098d189b867" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;immutable&lt;/code&gt; qualifier to any type (qualified or not) results in &lt;code&gt;immutable T&lt;/code&gt;. Applying any qualifier to &lt;code&gt;immutable T&lt;/code&gt; results in &lt;code&gt;immutable T&lt;/code&gt;. This makes &lt;code&gt;immutable&lt;/code&gt; a fixed point of qualifier combinations and makes types such as &lt;code&gt;const(immutable(shared T))&lt;/code&gt; impossible to create.</source>
          <target state="translated">施加 &lt;code&gt;immutable&lt;/code&gt; 限定符于任何类型的（合格与否）导致 &lt;code&gt;immutable T&lt;/code&gt; 。应用任何修饰词 &lt;code&gt;immutable T&lt;/code&gt; 的结果 &lt;code&gt;immutable T&lt;/code&gt; 。这使 &lt;code&gt;immutable&lt;/code&gt; 变成为限定词组合的固定点，并使诸如 &lt;code&gt;const(immutable(shared T))&lt;/code&gt; 之类的类型无法创建。</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5e35d0b2742a654477e1cd63556f021113ce5b4c" translate="yes" xml:space="preserve">
          <source>Arabic Extended-A</source>
          <target state="translated">阿拉伯文扩展版-A</target>
        </trans-unit>
        <trans-unit id="e2e75f0c9d3aecdda25899708775d147043e7830" translate="yes" xml:space="preserve">
          <source>Arabic Mathematical Alphabetic Symbols</source>
          <target state="translated">阿拉伯语数学字母符号表</target>
        </trans-unit>
        <trans-unit id="1855677dcc7468bb9c8e6a1cd81ba79444a4ff7e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-A</source>
          <target state="translated">阿拉伯文演示表格-A</target>
        </trans-unit>
        <trans-unit id="81d80ec90565c460cb86314a7772144c7915e63e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-B</source>
          <target state="translated">阿拉伯文演示表格-B</target>
        </trans-unit>
        <trans-unit id="f967001c1a34ccb5d4db68033cb95ea3afa4f067" translate="yes" xml:space="preserve">
          <source>Arabic Supplement</source>
          <target state="translated">阿拉伯文补编</target>
        </trans-unit>
        <trans-unit id="f984e10440745697cc3d65ba4c39e78b962f2e10" translate="yes" xml:space="preserve">
          <source>Arbitrary block of memory (&lt;code&gt;null&lt;/code&gt; is allowed; &lt;code&gt;owns(null)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">任意内存块（允许为 &lt;code&gt;null&lt;/code&gt; ； &lt;code&gt;owns(null)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="35ae340d74ec660428a4617d592eb281817c9ae4" translate="yes" xml:space="preserve">
          <source>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</source>
          <target state="translated">任意长度和复杂度的lookbehind,包括lookbehind中的lookahead和vis-versa。</target>
        </trans-unit>
        <trans-unit id="2b10f364535b59752b7187d9f87de14ac7b52ee5" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision ('bignum') arithmetic.</source>
          <target state="translated">任意精度('bignum')算术。</target>
        </trans-unit>
        <trans-unit id="04a64131d2f2d9afe00e52e932f2410778390372" translate="yes" xml:space="preserve">
          <source>ArchiveMember &lt;code&gt;de&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fcbd049669bd8c4ed6c2c7a64ef6513f2e0d6d" translate="yes" xml:space="preserve">
          <source>Are AMD extensions to MMX supported?</source>
          <target state="translated">是否支持AMD对MMX的扩展?</target>
        </trans-unit>
        <trans-unit id="01e21616c01d0a2fca25a82b396c6f6e959a0c86" translate="yes" xml:space="preserve">
          <source>Are LAHF and SAHF supported in 64-bit mode?</source>
          <target state="translated">64位模式下是否支持LAHF和SAHF?</target>
        </trans-unit>
        <trans-unit id="3a1445e9d8e93be79bf26c9c6c4caa120500ae1a" translate="yes" xml:space="preserve">
          <source>Are any of the Objects an error?</source>
          <target state="translated">是否有任何对象出现错误?</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="4293e4b957c97199f617f8492936758c0b738afa" translate="yes" xml:space="preserve">
          <source>Args &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">ARGS &lt;code&gt;args&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f5be29a09e6e60319db52d529ad7515c16471a5" translate="yes" xml:space="preserve">
          <source>Argument Deduction</source>
          <target state="translated">论证演绎</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">参数类型</target>
        </trans-unit>
        <trans-unit id="29654984a9e906a0a06167995d3f42a8d08cf353" translate="yes" xml:space="preserve">
          <source>Argument to xInit() and xShutdown()</source>
          <target state="translated">xInit()和xShutdown()的参数。</target>
        </trans-unit>
        <trans-unit id="daf86c8879ed0c69961403ceb76965c2482d6deb" translate="yes" xml:space="preserve">
          <source>ArgumentList</source>
          <target state="translated">ArgumentList</target>
        </trans-unit>
        <trans-unit id="8946712557cc8b1c3fb3e94fee0d0fce04b3802b" translate="yes" xml:space="preserve">
          <source>Arguments to pass to &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">传递给 &lt;code&gt;T&lt;/code&gt; 的构造函数的参数。</target>
        </trans-unit>
        <trans-unit id="bfbc91d37e47f927568d7a30e3496cf96960cf08" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the method.</source>
          <target state="translated">要传递给本方法的参数。</target>
        </trans-unit>
        <trans-unit id="89180ef2e932b4599c798900639013ef3f341134" translate="yes" xml:space="preserve">
          <source>Arguments to the function.</source>
          <target state="translated">函数的参数。</target>
        </trans-unit>
        <trans-unit id="cd64cf49b3ec9934a802f3e5622e652b8742e909" translate="yes" xml:space="preserve">
          <source>Arguments to variadic functions (such as &lt;code&gt;printf&lt;/code&gt;) are considered to be consumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9630a5d15efcdc7541a36a0160b3500004aba0a" translate="yes" xml:space="preserve">
          <source>Arithmetic between &lt;code&gt;VariantN&lt;/code&gt; objects and numeric values. All arithmetic operations return a &lt;code&gt;VariantN&lt;/code&gt; object typed depending on the types of both values involved. The conversion rules mimic D's built-in rules for arithmetic conversions.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; 对象和数值之间的算术运算。所有算术运算都返回一个 &lt;code&gt;VariantN&lt;/code&gt; 对象，其类型取决于所涉及的两个值的类型。转换规则模仿D的内置规则进行算术转换。</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="2c96bf3a668aac126792eaf02dadd14fa48e70d3" translate="yes" xml:space="preserve">
          <source>Array &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">数组&lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;（string op，Stuff）（东西）</target>
        </trans-unit>
        <trans-unit id="3660d1d1308b201f353bc8fa6130b29f9ba2d842" translate="yes" xml:space="preserve">
          <source>Array Bounds Checking</source>
          <target state="translated">阵列边界检查</target>
        </trans-unit>
        <trans-unit id="1f1275d2846b1606eecf7847c7e27140c6dc6c89" translate="yes" xml:space="preserve">
          <source>Array Concatenation</source>
          <target state="translated">阵列连接</target>
        </trans-unit>
        <trans-unit id="5d1d05717fafa53ed33983c8c412c01fb3ca32f6" translate="yes" xml:space="preserve">
          <source>Array Copying</source>
          <target state="translated">阵列复制</target>
        </trans-unit>
        <trans-unit id="0b0779db36c24b1c78ab44d3d32261e35d9bc05e" translate="yes" xml:space="preserve">
          <source>Array Declarations</source>
          <target state="translated">阵列声明</target>
        </trans-unit>
        <trans-unit id="83248d40160f2cce014335fe1581785cb6bcecaf" translate="yes" xml:space="preserve">
          <source>Array Index/Slice scope</source>
          <target state="translated">阵列索引/切片范围</target>
        </trans-unit>
        <trans-unit id="4b91e23ca287553cadb09bb925d112bdb13a167e" translate="yes" xml:space="preserve">
          <source>Array Indexing and Slicing Operators Overloading</source>
          <target state="translated">阵列索引和切片操作符 重载</target>
        </trans-unit>
        <trans-unit id="b3e061b1b0837d1a9960794f282dd75e750eb332" translate="yes" xml:space="preserve">
          <source>Array Initialization</source>
          <target state="translated">阵列初始化</target>
        </trans-unit>
        <trans-unit id="1c847e3a06bdc4135a7a456a0f00a984d2c67477" translate="yes" xml:space="preserve">
          <source>Array Length</source>
          <target state="translated">阵列长度</target>
        </trans-unit>
        <trans-unit id="f9f04b9d6c3b8a78da5ec9d06e0efef4332889f5" translate="yes" xml:space="preserve">
          <source>Array Literals</source>
          <target state="translated">阵列文字</target>
        </trans-unit>
        <trans-unit id="7106a989ccb65a04eb4c26053be05ad2d2e071e2" translate="yes" xml:space="preserve">
          <source>Array Operations</source>
          <target state="translated">阵列操作</target>
        </trans-unit>
        <trans-unit id="9d517d3c8494600360cbc4c90cee07bed4ba0d68" translate="yes" xml:space="preserve">
          <source>Array Properties</source>
          <target state="translated">阵列属性</target>
        </trans-unit>
        <trans-unit id="9703b944aa367c5aa673c3d017ce64794e77b9b2" translate="yes" xml:space="preserve">
          <source>Array Setting</source>
          <target state="translated">阵列设置</target>
        </trans-unit>
        <trans-unit id="1aa037357a9b7f1c16ef42cc60976b8847ef657b" translate="yes" xml:space="preserve">
          <source>Array Usage</source>
          <target state="translated">阵列用法</target>
        </trans-unit>
        <trans-unit id="c01b400578305839c9f204fb953e859a5125d529" translate="yes" xml:space="preserve">
          <source>Array and associative array operations. If a &lt;code&gt; VariantN&lt;/code&gt; contains an (associative) array, it can be indexed into. Otherwise, an exception is thrown.</source>
          <target state="translated">数组和关联数组操作。如果 &lt;code&gt; VariantN&lt;/code&gt; 包含（关联）数组，则可以对其进行索引。否则，将引发异常。</target>
        </trans-unit>
        <trans-unit id="b84dfacc31a0969124c8d1abef734c629bb90a1e" translate="yes" xml:space="preserve">
          <source>Array appending</source>
          <target state="translated">阵列追加</target>
        </trans-unit>
        <trans-unit id="5d76be94dc9a7b58ca84dbb5c3adb93a7d01641c" translate="yes" xml:space="preserve">
          <source>Array bound checks.</source>
          <target state="translated">阵列绑定检查。</target>
        </trans-unit>
        <trans-unit id="85acbf2069ff740d2820da623cb0a7f96c951889" translate="yes" xml:space="preserve">
          <source>Array bounds checks are disabled (command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck=off&lt;/em&gt;&lt;/a&gt;)</source>
          <target state="translated">禁用数组边界检查（命令行开关&lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck = off&lt;/em&gt;&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="c9495b0030caddeaddd3d77aa9749a4ea64f6f7d" translate="yes" xml:space="preserve">
          <source>Array bounds checks are necessary to enforce memory safety, so these are enabled (by default) for &lt;code&gt;@safe&lt;/code&gt; code even in &lt;b&gt;-release&lt;/b&gt; mode.</source>
          <target state="translated">数组边界检查是强制执行内存安全性所必需的，因此即使在&lt;b&gt;-release&lt;/b&gt;模式下，也对 &lt;code&gt;@safe&lt;/code&gt; 代码启用了这些检查（默认情况下）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cea52181688b642f5fdfd14c038de482c009d5f6" translate="yes" xml:space="preserve">
          <source>Array concatenation</source>
          <target state="translated">阵列连接</target>
        </trans-unit>
        <trans-unit id="57ff9464bbbd1fa1767e470a5012532b91719c42" translate="yes" xml:space="preserve">
          <source>Array container for internal usage.</source>
          <target state="translated">阵列容器,供内部使用。</target>
        </trans-unit>
        <trans-unit id="65a0b8da864827cd0478aba1fdf30610a77c4fd1" translate="yes" xml:space="preserve">
          <source>Array containing arrays that will be concatenated.</source>
          <target state="translated">包含将被连接的数组的数组。</target>
        </trans-unit>
        <trans-unit id="67d3696aeb8ef015e2952b35a392df743f65e443" translate="yes" xml:space="preserve">
          <source>Array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">Array literal将被分配到GC堆上。检查它的元素,看看是否有元素会在堆上逃逸。</target>
        </trans-unit>
        <trans-unit id="014dbf281d4d372cf828b4f858f7eb383406da80" translate="yes" xml:space="preserve">
          <source>Array literals (except when used to initialize static data)</source>
          <target state="translated">数组字元(除了用于初始化静态数据的时候</target>
        </trans-unit>
        <trans-unit id="f6a7d7c506c31a93cc6747b37be514d93fad8773" translate="yes" xml:space="preserve">
          <source>Array literals are a comma-separated list of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;s between square brackets &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;. The</source>
          <target state="translated">数组文字是在方括号 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 之间用逗号分隔的&lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;列表。的</target>
        </trans-unit>
        <trans-unit id="dae2c2b63d025ee4c0832bb31c33f2a5fbf34690" translate="yes" xml:space="preserve">
          <source>Array literals are allocated on the memory managed heap. Thus, they can be returned safely from functions:</source>
          <target state="translated">阵列字元是在内存管理堆上分配的。因此,它们可以从函数中安全返回。</target>
        </trans-unit>
        <trans-unit id="e69b9d12c30731402c84433338297ab2257d2102" translate="yes" xml:space="preserve">
          <source>Array of VarDeclaration's for parameters</source>
          <target state="translated">参数的 VarDeclaration 阵列</target>
        </trans-unit>
        <trans-unit id="5d9eb8f765adfc90b02ec28ca02924204c83af1e" translate="yes" xml:space="preserve">
          <source>Array of characters read.</source>
          <target state="translated">读取的字符数组。</target>
        </trans-unit>
        <trans-unit id="1a234f4c4feb75a8aa7b93d09c3a8859c0ea7eb5" translate="yes" xml:space="preserve">
          <source>Array of pairs giving the offset and type information for each member in an aggregate.</source>
          <target state="translated">提供集合中每个成员的偏移量和类型信息的对数组。</target>
        </trans-unit>
        <trans-unit id="3cc66155c78e1b4720002ac02361e391e42c1fdd" translate="yes" xml:space="preserve">
          <source>Array of the strings representing time units, starting with the smallest unit and going to the largest. It does not include &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">代表时间单位的字符串数组，从最小的单位开始，一直到最大的单位。它不包含 &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c26e25fdec1370d18f0c93ee54cfd77f08bc7279" translate="yes" xml:space="preserve">
          <source>Array options.</source>
          <target state="translated">阵列选项。</target>
        </trans-unit>
        <trans-unit id="fecbe8e577ceb3d414c1005061daf3736c402d86" translate="yes" xml:space="preserve">
          <source>Array representing the entire archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268c73e26ed36171acb2987f7e489853cedee3f4" translate="yes" xml:space="preserve">
          <source>Array representing the entire contents of the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ee133059983d2093ca847eb799753d9f96eeef" translate="yes" xml:space="preserve">
          <source>Array slicing, and array bounds checking</source>
          <target state="translated">数组分片,以及数组边界检查。</target>
        </trans-unit>
        <trans-unit id="f187d73020c36a9ee259d3863cac2e2a8546f9fe" translate="yes" xml:space="preserve">
          <source>Array specialized for &lt;code&gt;bool&lt;/code&gt;. Packs together values efficiently by allocating one bit per element.</source>
          <target state="translated">专门用于 &lt;code&gt;bool&lt;/code&gt; 数组。通过为每个元素分配一位有效地将值打包在一起。</target>
        </trans-unit>
        <trans-unit id="5058965ad79b9992b8f00aae6b40d9b43a8d0f10" translate="yes" xml:space="preserve">
          <source>Array syntax for json arrays.</source>
          <target state="translated">json数组的数组语法。</target>
        </trans-unit>
        <trans-unit id="5973135baae02b17a741da0daeae795a22336d6f" translate="yes" xml:space="preserve">
          <source>Array to append the flags to, if any.</source>
          <target state="translated">要附加标志的数组(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="d290f86768d5ed39f7a46e3545ef125df15763f2" translate="yes" xml:space="preserve">
          <source>Array to which binaries (shared/static libs and object files) will be appended</source>
          <target state="translated">添加二进制文件(共享/静态库和对象文件)的阵列</target>
        </trans-unit>
        <trans-unit id="c59fb5bcd382383b02c6f2e682a6e49d5169c774" translate="yes" xml:space="preserve">
          <source>Array type with deterministic control of memory. The memory allocated for the array is reclaimed as soon as possible; there is no reliance on the garbage collector. &lt;code&gt;Array&lt;/code&gt; uses &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; for managing its own memory.</source>
          <target state="translated">具有确定性控制内存的数组类型。尽快回收分配给该阵列的内存。不依赖垃圾收集器。 &lt;code&gt;Array&lt;/code&gt; 使用 &lt;code&gt;malloc&lt;/code&gt; ， &lt;code&gt;realloc&lt;/code&gt; 和 &lt;code&gt;free&lt;/code&gt; 来管理自己的内存。</target>
        </trans-unit>
        <trans-unit id="17f3d834c909f91543323d2da6d7e392df7fc04d" translate="yes" xml:space="preserve">
          <source>Array utilities.</source>
          <target state="translated">阵列实用程序。</target>
        </trans-unit>
        <trans-unit id="d8d1c5f297e5b542d7b3b426ee67519393b84051" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;Address&lt;/code&gt; instance per socket address.</source>
          <target state="translated">每个套接字地址带有一个 &lt;code&gt;Address&lt;/code&gt; 实例的阵列。</target>
        </trans-unit>
        <trans-unit id="7b02c75e5cfd1dbb8861cc9d33aefc7788debf27" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;AddressInfo&lt;/code&gt; per socket address.</source>
          <target state="translated">每个套接字地址带有一个 &lt;code&gt;AddressInfo&lt;/code&gt; 的数组。</target>
        </trans-unit>
        <trans-unit id="ccb9694106595867500e36f178956e556d5f06d5" translate="yes" xml:space="preserve">
          <source>Array!T &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">数组！T &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59ed81f06d61cee7ac46ef81d4494047f843a918" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff rhs)</source>
          <target state="translated">Array！bool &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;（string op，Stuff）（stuff rhs）</target>
        </trans-unit>
        <trans-unit id="f58b7e3beff7cb376f330022b72abdbf5e8d71a8" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">Array！bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;（string op，Stuff）（东西）</target>
        </trans-unit>
        <trans-unit id="fb8a70fa9de0823f16fd95fb5d95b4122c80f726" translate="yes" xml:space="preserve">
          <source>ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</source>
          <target state="translated">ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcde65a6ef36678480c533ad205a2b3653940979" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49604b859f9dbf7987784da7c49e4b4f67d157a7" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt;(UnionExp* pue, ref const Loc loc, Type type, Expression elem, size_t dim);</source>
          <target state="translated">ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt;（UnionExp * pue，ref const Loc loc，Type type，Expression elem，size_t dim）;</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="5ec121f807ed23a3ee478e2902d2a39d93f6938e" translate="yes" xml:space="preserve">
          <source>Arrays (dynamic and static)</source>
          <target state="translated">数组(动态和静态</target>
        </trans-unit>
        <trans-unit id="dad86d2f90fcf8d8a3cdfa4cf789d731af0dd940" translate="yes" xml:space="preserve">
          <source>Arrays and static arrays</source>
          <target state="translated">数组和静态数组</target>
        </trans-unit>
        <trans-unit id="1f1d0899c823da5c8626a1dbb08800ddf6eec849" translate="yes" xml:space="preserve">
          <source>Arrays of any type can be implicitly converted to a void array; the compiler inserts the appropriate calculations so that the &lt;code&gt;.length&lt;/code&gt; of the resulting array's size is in bytes rather than number of elements. Void arrays cannot be converted back to the original type without using a cast, and it is an error to convert to an array type whose element size does not evenly divide the length of the void array.</source>
          <target state="translated">任何类型的数组都可以隐式转换为void数组；编译器将插入适当的计算，以使所得数组大小的 &lt;code&gt;.length&lt;/code&gt; 以字节为单位，而不是元素数。如果不使用强制转换，则无法将无效数组转换回原始类型，并且将其转换为元素大小不能平均划分void数组长度的数组类型是错误的。</target>
        </trans-unit>
        <trans-unit id="d07335e1b59b41b81acffb9c1b5c94e2033e5ab4" translate="yes" xml:space="preserve">
          <source>Arrays read right to left as well:</source>
          <target state="translated">数组也从右往左读。</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="ebe044f5962ca7b8d7aab096e7aee2bc2b61b686" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;static foreach&lt;/code&gt; is a code generation construct and not a loop, &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; cannot be used to change control flow within it. Instead of breaking or continuing a suitable enclosing statement, such an usage yields an error (this is to prevent misunderstandings).</source>
          <target state="translated">由于 &lt;code&gt;static foreach&lt;/code&gt; 是代码生成结构，而不是循环，因此 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 无法用于更改其中的控制流。这种用法不会破坏或继续执行适当的封闭语句，而是产生错误（这是为了防止误解）。</target>
        </trans-unit>
        <trans-unit id="8fe64c824a70f2fd7f91ffe1f685564777c5e63c" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;scope&lt;/code&gt; parameter must not escape, the compiler can potentially avoid heap-allocating a unique argument to a &lt;code&gt;scope&lt;/code&gt; parameter. Due to this, passing an array literal, delegate literal or a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt; to a scope parameter may be allowed in a &lt;code&gt;@nogc&lt;/code&gt; context, depending on the compiler implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d13756a62d354c00bff64fd46fa593358676140" translate="yes" xml:space="preserve">
          <source>As a concession to practicality, a pure function can also:</source>
          <target state="translated">作为实用性的让步,纯功能也可以。</target>
        </trans-unit>
        <trans-unit id="8bc155ad0d18590ebe40ebe2b93eb23941ceadd8" translate="yes" xml:space="preserve">
          <source>As a contract, an &lt;code&gt;assert&lt;/code&gt; represents a guarantee that the code</source>
          <target state="translated">作为合同， &lt;code&gt;assert&lt;/code&gt; 表示对代码的保证</target>
        </trans-unit>
        <trans-unit id="bccab5f9b93fd641ceebcd69566613681ff777b0" translate="yes" xml:space="preserve">
          <source>As a debugging aid, the compiler may insert a runtime check to verify that the expression is indeed true. If it is false, an &lt;code&gt;AssertError&lt;/code&gt; is thrown. When compiling for release, this check is not generated. The special &lt;code&gt;assert(0)&lt;/code&gt; expression, however, is generated even in release mode. See the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; documentation for more information.</source>
          <target state="translated">作为调试的帮助，编译器可以插入运行时检查以验证表达式确实为真。如果为false，则抛出 &lt;code&gt;AssertError&lt;/code&gt; 。编译发布时，不会生成此检查。但是，即使在释放模式下也会生成特殊的 &lt;code&gt;assert(0)&lt;/code&gt; 表达式。有关更多信息，请参见&lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="90a896ea477e7a62fdbd266c90ef3478e166538a" translate="yes" xml:space="preserve">
          <source>As a micro-optimization, to avoid the heap allocation associated with &lt;code&gt;task&lt;/code&gt; or with the creation of a closure.</source>
          <target state="translated">作为微优化，避免与 &lt;code&gt;task&lt;/code&gt; 或创建闭包关联的堆分配。</target>
        </trans-unit>
        <trans-unit id="842753f613e1812047f79b9da908210026f9a41f" translate="yes" xml:space="preserve">
          <source>As above, but also provides &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="translated">如上所述，还提供 &lt;code&gt;back&lt;/code&gt; 和 &lt;code&gt;popBack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a95b268782f9af6c10edd99d4e3bb5baafff0eb" translate="yes" xml:space="preserve">
          <source>As above, but may be reallocated later. Examples of types fitting this description are &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt;double[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">如上所述，但可能稍后再分配。适合该描述的类型的示例是 &lt;code&gt;int[]&lt;/code&gt; ， &lt;code&gt;double[]&lt;/code&gt; ， &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt; ，但不是 &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; ，它包含一个间接寻址。</target>
        </trans-unit>
        <trans-unit id="ada3120f9cc1043d7b4f9c611d3e84f82bcb254e" translate="yes" xml:space="preserve">
          <source>As above, but may embed indirections. Examples of types fitting this description are &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Object[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;.</source>
          <target state="translated">如上所述，但可以嵌入间接方式。适合该描述的类型的示例是 &lt;code&gt;int*[]&lt;/code&gt; ， &lt;code&gt;Object[]&lt;/code&gt; ， &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1700838138f9af03c11ccaa20b548dd32d2a5c61" translate="yes" xml:space="preserve">
          <source>As above, but the memory allocated is aligned at &lt;code&gt;a&lt;/code&gt; bytes.</source>
          <target state="translated">如上所述，但是分配的内存对齐为 &lt;code&gt;a&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="9a7b2b5d58503b9d84dce03ccae75f857fd6475e" translate="yes" xml:space="preserve">
          <source>As above, but the type may be appended to in the future. Example: &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">如上所述，但将来可能会附加类型。示例： &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67b44aad993023067b75a99b577d6a3bad9df809" translate="yes" xml:space="preserve">
          <source>As above, but the type may embed references. Example: &lt;code&gt;immutable(Object)[]&lt;/code&gt;.</source>
          <target state="translated">如上所述，但是类型可以嵌入引用。示例： &lt;code&gt;immutable(Object)[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0ab111de9460a5c459418af453cc0583e8938ad" translate="yes" xml:space="preserve">
          <source>As an exception to the above, curl_off_t shall be typedef'ed to a 32-bit wide signed integral data type if there is no 64-bit type.</source>
          <target state="translated">作为一个例外,如果没有64位的类型,curl_off_t应该被类型化为一个32位宽的有符号积分数据类型。</target>
        </trans-unit>
        <trans-unit id="00c376f2504564e95535f66220527b7aef723e32" translate="yes" xml:space="preserve">
          <source>As copying the range means copying all elements, it can be safely returned from functions. For the same reason, copying the returned range may be expensive for a large number of arguments.</source>
          <target state="translated">由于复制范围意味着复制所有元素,因此可以安全地从函数中返回。出于同样的原因,对于大量的参数,复制返回的范围可能会很昂贵。</target>
        </trans-unit>
        <trans-unit id="86ffd7c99fd994cc802f084df86d92e7d718ebb0" translate="yes" xml:space="preserve">
          <source>As long as the target range elements support assignment from source range elements, different types of ranges are accepted:</source>
          <target state="translated">只要目标范围元素支持从源范围元素分配,就可以接受不同类型的范围。</target>
        </trans-unit>
        <trans-unit id="89f24648855e3c77be3def51419022b8377886d0" translate="yes" xml:space="preserve">
          <source>As of this time, &lt;code&gt;std.experimental.allocator&lt;/code&gt; is not integrated with D's built-in operators that allocate memory, such as &lt;code&gt;new&lt;/code&gt;, array literals, or array concatenation operators. That means &lt;code&gt;std.experimental.allocator&lt;/code&gt; is opt-in</source>
          <target state="translated">目前， &lt;code&gt;std.experimental.allocator&lt;/code&gt; 未与D的分配内存的内置运算符集成，例如 &lt;code&gt;new&lt;/code&gt; ，数组文字或数组串联运算符。这意味着选择加入 &lt;code&gt;std.experimental.allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b1738337554a47ddb128a4a9aaf14cc6fec9d90" translate="yes" xml:space="preserve">
          <source>As some GC implementations (such as the current conservative one) don't support GC memory allocation during object finalization, this function can be used to guard against such programming errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102c86647896232382d7c6363a032a8965f35f84" translate="yes" xml:space="preserve">
          <source>As the above example shows, a different compile-time argument is passed to &lt;code&gt;opDollar&lt;/code&gt; depending on which argument it appears in. A &lt;code&gt;$&lt;/code&gt; appearing in the first argument gets translated to &lt;code&gt;opDollar!0&lt;/code&gt;, a &lt;code&gt;$&lt;/code&gt; appearing in the second argument gets translated to &lt;code&gt;opDollar!1&lt;/code&gt;, and so on. Thus, the appropriate value for &lt;code&gt;$&lt;/code&gt; can be returned to implement multidimensional arrays.</source>
          <target state="translated">如上面的示例所示，根据它出现在哪个参数中，将不同的编译时参数传递给 &lt;code&gt;opDollar&lt;/code&gt; 。第一个参数中出现的 &lt;code&gt;$&lt;/code&gt; 转换为 &lt;code&gt;opDollar!0&lt;/code&gt; ，第二个参数中出现的 &lt;code&gt;$&lt;/code&gt; 转换为 &lt;code&gt;opDollar!1&lt;/code&gt; ，依此类推。因此，可以返回 &lt;code&gt;$&lt;/code&gt; 的适当值以实现多维数组。</target>
        </trans-unit>
        <trans-unit id="6f1f55e4d756cae86481e151850fb4d8b6d4d597" translate="yes" xml:space="preserve">
          <source>As the interval goes to negative infinity, the range is always iterated over backwards, never forwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be earlier in time than the one passed to it. If it's either identical or later in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">当间隔达到负无穷大时，范围总是向后迭代，而不是向前迭代。 &lt;code&gt;func&lt;/code&gt; 必须生成一个沿正确迭代方向的时间点，否则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。因此， &lt;code&gt;func&lt;/code&gt; 生成的时间点必须早于传递给它的时间点。如果时间相同或较晚，则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19397d297232fda90f291340ee30b5e3c1ea48c9" translate="yes" xml:space="preserve">
          <source>As the interval goes to positive infinity, the range is always iterated over forwards, never backwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">当间隔达到正无穷大时，范围总是在向前而不是向后迭代。 &lt;code&gt;func&lt;/code&gt; 必须生成一个沿正确迭代方向的时间点，否则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。因此， &lt;code&gt;func&lt;/code&gt; 生成的时间点必须晚于传递给它的时间点。如果时间相同或更早，则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80d4a16f3b080b8168646190c746d43efc570fe1" translate="yes" xml:space="preserve">
          <source>As this module is used for diagnostic, it should handle failures as gracefully as possible. Having the runtime error out on printing the stack trace one is trying to debug would be quite a terrible UX. For this reason, this module works on a &quot;best effort&quot; basis and will sometimes print mangled symbols, or &quot;???&quot; when it cannot do anything more useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85319de6635b6d77d85a430a22ed2839720cedf1" translate="yes" xml:space="preserve">
          <source>As we generate code, collect information about what parts of NT exception handling we need.</source>
          <target state="translated">当我们生成代码时,收集我们需要NT异常处理的哪些部分的信息。</target>
        </trans-unit>
        <trans-unit id="51268903c8fb9b838b2eb55d7979a33593c37355" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#lists&quot;&gt;lists&lt;/a&gt;, note that the initial &lt;code&gt;*&lt;/code&gt; in the example above will be stripped because it is part of a documentation comment that is delimited with asterisks, so you need at least three subsequent asterisks.</source>
          <target state="translated">与&lt;a href=&quot;#lists&quot;&gt;list一样&lt;/a&gt;，请注意，上面示例中的开头 &lt;code&gt;*&lt;/code&gt; 将被删除，因为它是文档注释中用星号分隔的一部分，因此您至少需要三个后续星号。</target>
        </trans-unit>
        <trans-unit id="ac7e95e21d2700c2e5e4f32e9e7f466df23faf33" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; there are 2 overloads - one with a format string, the other one with a user defined functor.</source>
          <target state="translated">与&lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; 一样&lt;/a&gt;，有2个重载-一个重载带有格式字符串，另一个重载带有用户定义的函子。</target>
        </trans-unit>
        <trans-unit id="4799d67b11d550709cf6847100b2162c1067dd7e" translate="yes" xml:space="preserve">
          <source>As with any global resource, setting &lt;code&gt;theAllocator&lt;/code&gt; and &lt;code&gt;processAllocator&lt;/code&gt; should not be done often and casually. In particular, allocating memory with one allocator and deallocating with another causes undefined behavior. Typically, these variables are set during application initialization phase and last through the application.  To avoid this, long-lived objects that need to perform allocations, reallocations, and deallocations relatively often may want to store a reference to the allocator object they use throughout their lifetime. Then, instead of using &lt;code&gt;theAllocator&lt;/code&gt; for internal allocation-related tasks, they'd use the internally held reference. For example, consider a user-defined hash table:</source>
          <target state="translated">与任何全局资源一样，不应经常随意地设置 &lt;code&gt;theAllocator&lt;/code&gt; 和 &lt;code&gt;processAllocator&lt;/code&gt; 。特别是，使用一个分配器分配内存并使用另一个分配器取消分配会导致未定义的行为。通常，这些变量在应用程序初始化阶段设置，并持续到整个应用程序。为了避免这种情况，需要相对频繁地执行分配，重新分配和释放的长寿命对象可能想要存储对其在整个生命周期中使用的分配器对象的引用。然后，他们将使用内部保存的引用，而不是将 &lt;code&gt;theAllocator&lt;/code&gt; 用于内部分配相关的任务。例如，考虑一个用户定义的哈希表：</target>
        </trans-unit>
        <trans-unit id="a187fce74f3c088795c6e5b47e1056e5126c0fae" translate="yes" xml:space="preserve">
          <source>Ask curl for its fd_set sets. The app can use these to select() or poll() on. We want curl_multi_perform() called as soon as one of them are ready.</source>
          <target state="translated">向 curl 索取它的 fd_set 集。应用程序可以使用这些集合来选择()或投票()。我们希望curl_multi_perform()在其中一个集合准备好后立即调用。</target>
        </trans-unit>
        <trans-unit id="407c3cb45f2c60add113bb40a5a457b3e7b28548" translate="yes" xml:space="preserve">
          <source>Ask the multi handle if there's any messages/informationals from the individual transfers. Messages include informationals such as error code from the transfer or just the fact that a transfer is completed. More details on these should be written down as well.</source>
          <target state="translated">询问多处理机是否有任何信息/信息从个人转移。信息包括传输的错误代码等信息,或者仅仅是传输已经完成的事实。这些细节也应该写下来。</target>
        </trans-unit>
        <trans-unit id="00a0f49dff6a5c0c910755166ec70967a98d46e8" translate="yes" xml:space="preserve">
          <source>Asm Statement</source>
          <target state="translated">Asm声明</target>
        </trans-unit>
        <trans-unit id="1afc7a2cc88dee030813b66323a3af633b890e22" translate="yes" xml:space="preserve">
          <source>Asm instruction</source>
          <target state="translated">Asm指令</target>
        </trans-unit>
        <trans-unit id="790208a1b6c1cdd2c13b57adc90b509e7d203c6c" translate="yes" xml:space="preserve">
          <source>Asm instructions are terminated by a ;, not by an end of line.</source>
          <target state="translated">Asm指令以;;结束,而不是以行结束。</target>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="translated">阿斯米声明</target>
        </trans-unit>
        <trans-unit id="90e6cfa22a58ec4314abe99303529bc30df1cd45" translate="yes" xml:space="preserve">
          <source>AsmStatement</source>
          <target state="translated">AsmStatement</target>
        </trans-unit>
        <trans-unit id="7c9be4e0207ca69f4c35ec2cd41e7f07aef7a2ef" translate="yes" xml:space="preserve">
          <source>Assemble &lt;code&gt;values&lt;/code&gt; into a range that carries all its elements in-situ.</source>
          <target state="translated">将 &lt;code&gt;values&lt;/code&gt; 组合到一个范围内，即可在原位携带所有元素。</target>
        </trans-unit>
        <trans-unit id="c617a006ef306c30de2e4c3a12d2334fbba7a9af" translate="yes" xml:space="preserve">
          <source>Assembler instructions can be labeled just like other statements. They can be the target of goto statements. For example:</source>
          <target state="translated">汇编器指令可以像其他语句一样被标记。它们可以成为goto语句的目标。例如</target>
        </trans-unit>
        <trans-unit id="e421bc1f45d2b482fe2ff716000545e5646f7277" translate="yes" xml:space="preserve">
          <source>Assembler instructions must be located inside an &lt;code&gt;asm&lt;/code&gt; block. Like functions, &lt;code&gt;asm&lt;/code&gt; statements must be anotated with adequate function attributes to be compatible with the caller. Asm statements attributes must be explicitly defined, they are not infered.</source>
          <target state="translated">汇编程序指令必须位于 &lt;code&gt;asm&lt;/code&gt; 块内。与函数类似，必须为 &lt;code&gt;asm&lt;/code&gt; 语句添加足够的函数属性以使其与调用程序兼容。必须明确定义Asm语句属性，否则无法推断它们。</target>
        </trans-unit>
        <trans-unit id="714e45eb8c405fbdb34a796120ab67c6ae2d72b9" translate="yes" xml:space="preserve">
          <source>Assembling Your Own Allocator</source>
          <target state="translated">组装你自己的分配器</target>
        </trans-unit>
        <trans-unit id="b52465945f6ab45ca943fa9fa1e9d738eca2cc3b" translate="yes" xml:space="preserve">
          <source>Assert Contract</source>
          <target state="translated">申明合同</target>
        </trans-unit>
        <trans-unit id="881c910749065a58abd709f4221af38a82fabadc" translate="yes" xml:space="preserve">
          <source>Assert Expressions</source>
          <target state="translated">断言表达式</target>
        </trans-unit>
        <trans-unit id="c7a5b9464524d049c6fe8ff66c5b2bdc7b543fff" translate="yes" xml:space="preserve">
          <source>Assert Failure</source>
          <target state="translated">断言失败</target>
        </trans-unit>
        <trans-unit id="d7d72241e6b5848e305187f74df13930409f541f" translate="yes" xml:space="preserve">
          <source>Assert checks.</source>
          <target state="translated">申明检查。</target>
        </trans-unit>
        <trans-unit id="843aa1baaf4b9511699ef763eb98fe79f5099f70" translate="yes" xml:space="preserve">
          <source>Assert failure functions in the GLIBC library.</source>
          <target state="translated">在GLIBC库中断言失败函数。</target>
        </trans-unit>
        <trans-unit id="94e6ce29a6460dbe0c0daaaab648acdb3c2883d7" translate="yes" xml:space="preserve">
          <source>AssertExpression</source>
          <target state="translated">AssertExpression</target>
        </trans-unit>
        <trans-unit id="a422512dc44cc15063776e77a81a3f8e6eb0d6de" translate="yes" xml:space="preserve">
          <source>AssertExpressions</source>
          <target state="translated">AssertExpressions</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="2f19e0385b8f9d7c5a7eb86bb2c7ba5f0e720900" translate="yes" xml:space="preserve">
          <source>Asserts that the given condition is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">断言给定条件为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="120daecc558f73b157187685546d1c314c351c50" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression does</source>
          <target state="translated">断言给定的表达式没有</target>
        </trans-unit>
        <trans-unit id="bba2525f9e139559b132642a96447978bab43209" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression throws the given type of &lt;code&gt;Throwable&lt;/code&gt;. The &lt;code&gt;Throwable&lt;/code&gt; is caught and does not escape assertThrown. However, any other &lt;code&gt;Throwable&lt;/code&gt;s</source>
          <target state="translated">断言给定表达式抛出给定类型的 &lt;code&gt;Throwable&lt;/code&gt; 。该 &lt;code&gt;Throwable&lt;/code&gt; 的被捕获并没有逃脱assertThrown。但是，任何其他 &lt;code&gt;Throwable&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="17e81c7a1f671e7e24608f38c1a74f6ff4e02c7b" translate="yes" xml:space="preserve">
          <source>Assign Expressions</source>
          <target state="translated">赋值表达式</target>
        </trans-unit>
        <trans-unit id="7f86ed464704ba1c6b681ec2726c5fbeefb20008" translate="yes" xml:space="preserve">
          <source>Assign a value to the current thread's instance. This function has the same caveats as its overload.</source>
          <target state="translated">为当前线程的实例赋值。这个函数与它的重载有相同的注意事项。</target>
        </trans-unit>
        <trans-unit id="76d3ba357057c554bcbcf6a7822d736c1e09e3bc" translate="yes" xml:space="preserve">
          <source>AssignExpression</source>
          <target state="translated">AssignExpression</target>
        </trans-unit>
        <trans-unit id="365e967e191a82b0dfa667724d9ef332e0565a97" translate="yes" xml:space="preserve">
          <source>Assigned to each element of range</source>
          <target state="translated">分配给范围的每个要素</target>
        </trans-unit>
        <trans-unit id="2490af57d4237289ce473c7f9d5d5a7e29bbba7a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Expressions</source>
          <target state="translated">赋值运算符表达式</target>
        </trans-unit>
        <trans-unit id="eda4293e36885d0479c5dae22502b3085be9643a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Overloading</source>
          <target state="translated">赋值运算符超载</target>
        </trans-unit>
        <trans-unit id="3bf524ec3b928fa7a8316d5c4f46f6427bafeb2e" translate="yes" xml:space="preserve">
          <source>Assignment from another &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">从另一个 &lt;code&gt;Tuple&lt;/code&gt; 分配。</target>
        </trans-unit>
        <trans-unit id="ad22a9ad0d4f785e89bbd9df67b80efd310fb186" translate="yes" xml:space="preserve">
          <source>Assignment from another BigInt.</source>
          <target state="translated">来自另一个BigInt的任务。</target>
        </trans-unit>
        <trans-unit id="c734c417d0433b21b0c33224a47f994821944ee9" translate="yes" xml:space="preserve">
          <source>Assignment from built-in integer types.</source>
          <target state="translated">从内置的整数类型赋值。</target>
        </trans-unit>
        <trans-unit id="a2c6b545c0015432c32a5f8afe451255b5b743ef" translate="yes" xml:space="preserve">
          <source>Assignment helper functions</source>
          <target state="translated">作业帮手功能</target>
        </trans-unit>
        <trans-unit id="84aa2531d79787134c4a3ba8faa799337584a358" translate="yes" xml:space="preserve">
          <source>Assignment operator. Has the same constraints as the constructor.</source>
          <target state="translated">赋值运算符。具有与构造函数相同的约束条件。</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">赋值运算符</target>
        </trans-unit>
        <trans-unit id="99b05821addb139efb582d5733eb165057e45a88" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;super&lt;/code&gt; is not allowed.</source>
          <target state="translated">不允许分配给 &lt;code&gt;super&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d46d956c7065444efb33c5f5602fe16eab572e8a" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;this&lt;/code&gt; is not allowed.</source>
          <target state="translated">不允许分配给 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac9f4d1b12010a7c21b70ea99324f1a0dd8bcccd" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the first element of the container.</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 分配给容器的第一个元素。</target>
        </trans-unit>
        <trans-unit id="922d6285649b37db600cf15c96dc723863c5afe5" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the last element of the container.</source>
          <target state="translated">将 &lt;code&gt;v&lt;/code&gt; 分配给容器的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="9af0d121c1f00202f8eb1627dd5494f59fbf6800" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to each element of input range &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 分配给输入范围 &lt;code&gt;range&lt;/code&gt; 的每个元素。</target>
        </trans-unit>
        <trans-unit id="e5f7c4ee9f81cf1e0b7f9cbc458913458f588507" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 分配给内部保持状态。</target>
        </trans-unit>
        <trans-unit id="21c3bd56c75643c04bab89ad011aec98a36c3a16" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 分配给内部保持状态。如果分配成功，则 &lt;code&gt;this&lt;/code&gt; 将为非空。</target>
        </trans-unit>
        <trans-unit id="8d0fc7c17a3a2b5f1514756ed138007924a3a66a" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null. No null checks are made. Note that the assignment may leave &lt;code&gt;this&lt;/code&gt; in the null state.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 分配给内部保持状态。如果分配成功，则 &lt;code&gt;this&lt;/code&gt; 将为非空。没有进行空检查。需要注意的是分配可能离开 &lt;code&gt;this&lt;/code&gt; 在空状态。</target>
        </trans-unit>
        <trans-unit id="5b359bc586830b69163a1e75c910372bb60f5dad" translate="yes" xml:space="preserve">
          <source>Assigns a &lt;code&gt;VariantN&lt;/code&gt; from a generic argument. Statically rejects disallowed types.</source>
          <target state="translated">从通用参数分配 &lt;code&gt;VariantN&lt;/code&gt; 。静态拒绝不允许的类型。</target>
        </trans-unit>
        <trans-unit id="44eb8314103f2fdd05abf9443854b7e8c14d4780" translate="yes" xml:space="preserve">
          <source>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</source>
          <target state="translated">将一个文件分配给另一个文件。赋值的目标会从它所附加的任何文件中分离出来,并将自己附加到新的文件上。</target>
        </trans-unit>
        <trans-unit id="057b5aa3c0ad5c43ab19d19f8ce9f6db63dca13d" translate="yes" xml:space="preserve">
          <source>Assigns a logical thread to execute the supplied op.</source>
          <target state="translated">指定一个逻辑线程来执行提供的操作。</target>
        </trans-unit>
        <trans-unit id="5425da91b2931a4dd8cdec7b13e0afa9866f1762" translate="yes" xml:space="preserve">
          <source>Assigns the given &lt;code&gt;value&lt;/code&gt; to the environment variable with the given &lt;code&gt;name&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is null the variable is removed from environment.</source>
          <target state="translated">将给定 &lt;code&gt;value&lt;/code&gt; 分配给具有给定 &lt;code&gt;name&lt;/code&gt; 的环境变量。如果 &lt;code&gt;value&lt;/code&gt; 为null，则将变量从环境中删除。</target>
        </trans-unit>
        <trans-unit id="a6b3ed4789854a21da3d57b64bb5165df47849f8" translate="yes" xml:space="preserve">
          <source>Assigns to the &lt;code&gt;n&lt;/code&gt;th element in the composite range. Defined if all ranges offer random access.</source>
          <target state="translated">分配给复合范围中的第 &lt;code&gt;n&lt;/code&gt; 个元素。定义是否所有范围都提供随机访问。</target>
        </trans-unit>
        <trans-unit id="a41d06f6960668b2b925acd3bf255f8df4491e62" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteral</source>
          <target state="translated">AssocArrayLiteral</target>
        </trans-unit>
        <trans-unit id="5a9bcf3e687e72baa7a855ea1562aeb0b0f6c922" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c12f36c1b476d37e1b0680000a7ced07747bab" translate="yes" xml:space="preserve">
          <source>Associate a local address with this socket.</source>
          <target state="translated">将一个本地地址与该套接字关联起来。</target>
        </trans-unit>
        <trans-unit id="6fdc76eca25e9805145ab4faa10fd711ec8e7f73" translate="yes" xml:space="preserve">
          <source>Associates name with tid in a process-local map. When the thread represented by tid terminates, any names associated with it will be automatically unregistered.</source>
          <target state="translated">在进程本地映射中,将名称与tid关联起来。当 tid 所代表的线程终止时,任何与它相关联的名字都会自动取消注册。</target>
        </trans-unit>
        <trans-unit id="d00bb7dcc304b2d3b149b7f7680cc932d7d86d19" translate="yes" xml:space="preserve">
          <source>Associates name with tid.</source>
          <target state="translated">将名字与tid联系起来。</target>
        </trans-unit>
        <trans-unit id="33ed59cb9cc5ad4f51c71cb705b6c66305c4ea95" translate="yes" xml:space="preserve">
          <source>Associative Array Example: counting Tuples</source>
          <target state="translated">关联数组示例:计算图元组</target>
        </trans-unit>
        <trans-unit id="66110798d937132b8b4c69b6c86f490e42147357" translate="yes" xml:space="preserve">
          <source>Associative Array Example: word count</source>
          <target state="translated">关联数组示例:字数</target>
        </trans-unit>
        <trans-unit id="62a00c8d718bd407e11a04d361c97fd9304d9228" translate="yes" xml:space="preserve">
          <source>Associative Array Literals</source>
          <target state="translated">关联阵列文字</target>
        </trans-unit>
        <trans-unit id="8cd02aabb1cb92301b44ecacb4a3476fbc048ed6" translate="yes" xml:space="preserve">
          <source>Associative Array Properties</source>
          <target state="translated">关联数组属性</target>
        </trans-unit>
        <trans-unit id="ac6bb05c1566d531b5e617bff01417f7eeacaa8d" translate="yes" xml:space="preserve">
          <source>Associative Arrays</source>
          <target state="translated">关联数组</target>
        </trans-unit>
        <trans-unit id="eac66f094196ab59907d539af93b0f79d61ccbc4" translate="yes" xml:space="preserve">
          <source>Associative array indexed by the name of each member of the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a88997c71f98db7849444ee105aa1b9e104461" translate="yes" xml:space="preserve">
          <source>Associative array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">关联数组的文字将被分配到GC堆上。检查它的元素,看看是否有任何元素会在堆上逃逸。</target>
        </trans-unit>
        <trans-unit id="2cdd3f26aaf9ed2ca50e34f9cba8cec0e214e787" translate="yes" xml:space="preserve">
          <source>Associative array literals</source>
          <target state="translated">关联数组文字</target>
        </trans-unit>
        <trans-unit id="aa59b9862478a41dd5f1d43314d8d4fd2f36cfac" translate="yes" xml:space="preserve">
          <source>Associative array literals are a comma-separated list of</source>
          <target state="translated">关联数组字元是一个以逗号分隔的列表,其中包括</target>
        </trans-unit>
        <trans-unit id="f1464f4beecb9ccd1b6cd79f0d3fdebe26677ef6" translate="yes" xml:space="preserve">
          <source>Associative array of attributes</source>
          <target state="translated">属性的关联数组</target>
        </trans-unit>
        <trans-unit id="b87ce9bf0d9a5c06c6d7bc4fc73a4cd816351837" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is converted by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3256b0ab3483fa8604ecf1ce16a782f56f85d2" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is printed by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="translated">关联数组到字符串的转换。通过调用 &lt;code&gt;to!T&lt;/code&gt; 来打印每个元素。</target>
        </trans-unit>
        <trans-unit id="6eed25868a22de24520441116395f69e925a6704" translate="yes" xml:space="preserve">
          <source>Associative array with all archive members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0cf74a282aed4f93bc7369a99f5541139720753" translate="yes" xml:space="preserve">
          <source>Associative arrays</source>
          <target state="translated">关联数组</target>
        </trans-unit>
        <trans-unit id="b7b195035b64b57f923bdef12ca24604e56d713e" translate="yes" xml:space="preserve">
          <source>Associative arrays are declared by placing the</source>
          <target state="translated">关联数组的声明是通过将</target>
        </trans-unit>
        <trans-unit id="e2e6b379c645fab1d146e1f88662672372565c42" translate="yes" xml:space="preserve">
          <source>Associative arrays are formatted by using &lt;code&gt;':'&lt;/code&gt; and &lt;code&gt;&quot;, &quot;&lt;/code&gt; as separators, and enclosed by &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;.</source>
          <target state="translated">关联数组使用 &lt;code&gt;':'&lt;/code&gt; 和 &lt;code&gt;&quot;, &quot;&lt;/code&gt; 作为分隔符进行格式化，并用 &lt;code&gt;'['&lt;/code&gt; 和 &lt;code&gt;']'&lt;/code&gt; 括起来。</target>
        </trans-unit>
        <trans-unit id="578b6958d55efc32eb2164f95c40c985b159a3d3" translate="yes" xml:space="preserve">
          <source>Associative arrays are initialized to having 0 elements.</source>
          <target state="translated">关联数组被初始化为0个元素。</target>
        </trans-unit>
        <trans-unit id="1f9ac76e68b33aa5367eaec796765ac41035935d" translate="yes" xml:space="preserve">
          <source>Associative arrays are returned in EAX.</source>
          <target state="translated">关联数组在EAX中返回。</target>
        </trans-unit>
        <trans-unit id="5ca5da5a3d3a14509f014f2f90e91f3a2f1bc8b9" translate="yes" xml:space="preserve">
          <source>Associative arrays consist of a pointer to an opaque, implementation defined type.</source>
          <target state="translated">关联数组由指向一个不透明的、实现定义的类型的指针组成。</target>
        </trans-unit>
        <trans-unit id="4b7aaeec3338d91fc185c073ff6aea7f4aaaf1d1" translate="yes" xml:space="preserve">
          <source>Associative arrays have an index that is not necessarily an integer, and can be sparsely populated. The index for an associative array is called the</source>
          <target state="translated">关联数组的索引不一定是整数,可以是稀疏的。关联数组的索引称为</target>
        </trans-unit>
        <trans-unit id="24b2b993b7d8aa8b139deca02db3001c61ba8f93" translate="yes" xml:space="preserve">
          <source>Associative arrays have unique keys. If r contains duplicate keys, then the result will contain the value of the last pair for that key in r.</source>
          <target state="translated">关联数组有唯一的键。如果r中包含重复的键,那么结果将包含r中该键的最后一对值。</target>
        </trans-unit>
        <trans-unit id="7140c60dcf97eae1fd241925dc294e9b664ccf47" translate="yes" xml:space="preserve">
          <source>Associativity and Commutativity</source>
          <target state="translated">关联性和共通性</target>
        </trans-unit>
        <trans-unit id="d4afb493c09c81bc22adc7df22495a98eac06f94" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt;. Then &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; leaves &lt;code&gt;a&lt;/code&gt; unchanged and returns &lt;code&gt;false&lt;/code&gt;, whereas &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to refer to &lt;code&gt;&quot;ah&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">假设 &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt; 。然后 &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; 留下 &lt;code&gt;a&lt;/code&gt; 不变并返回 &lt;code&gt;false&lt;/code&gt; ，而 &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; 前进 &lt;code&gt;a&lt;/code&gt; 指 &lt;code&gt;&quot;ah&quot;&lt;/code&gt; ，并返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c94a2c42cde8321b948dff42533f346ec9014aea" translate="yes" xml:space="preserve">
          <source>Assume that it is safe to append to this array. Appends made to this array after calling this function may append in place, even if the array was a slice of a larger array to begin with.</source>
          <target state="translated">假设对这个数组进行追加是安全的。在调用此函数后,对这个数组的追加可能会在原地追加,即使这个数组一开始就是一个更大数组的片断。</target>
        </trans-unit>
        <trans-unit id="3954f2a28b82752323144cbb88151e77e6d01da9" translate="yes" xml:space="preserve">
          <source>Assume the given array of integers &lt;code&gt;arr&lt;/code&gt; is a well-formed UTF string and return it typed as a UTF string.</source>
          <target state="translated">假设给定的整数数组 &lt;code&gt;arr&lt;/code&gt; 是格式正确的UTF字符串，然后将其返回为UTF字符串。</target>
        </trans-unit>
        <trans-unit id="51fef9f691908f559d18676822c2b16e9811cadf" translate="yes" xml:space="preserve">
          <source>Assume, that the range is sorted without checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46abda9a40531b5c7ab25b4f982669308c54d50" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e62b25f8e7aaa35a775d4bc9ee591164888166" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To keep the checking costs low, the cost is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) in release mode (no checks for sorted-ness are performed). In debug mode, a few random elements of &lt;code&gt;r&lt;/code&gt; are checked for sorted-ness. The size of the sample is proportional &amp;Omicron;(&lt;code&gt;log(r.length)&lt;/code&gt;). That way, checking has no effect on the complexity of subsequent operations specific to sorted ranges (such as binary search). The probability of an arbitrary unsorted range failing the test is very high (however, an almost-sorted range is likely to pass it). To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">假定 &lt;code&gt;r&lt;/code&gt; 由谓词排序 &lt;code&gt;pred&lt;/code&gt; ，并返回相应的 &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; 具有 &lt;code&gt;r&lt;/code&gt; 作为支撑。为了保持较低的检查成本，在发布模式下，成本为〇（ &lt;code&gt;1&lt;/code&gt; ）（不执行分类检查）。在调试模式下，将检查 &lt;code&gt;r&lt;/code&gt; 的几个随机元素的排序度。样本的大小成比例&amp;Omicron;（ &lt;code&gt;log(r.length)&lt;/code&gt; ）。这样，检查不会影响特定于已排序范围的后续操作的复杂性（例如二进制搜索）。任意未排序范围未通过测试的可能性非常高（但是，几乎排序的范围很可能会通过测试）。以成本〇（ &lt;code&gt;n&lt;/code&gt; ），请使用&lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt; &lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f92de52d34809fb9f9b5a422d22d2bd3f403b63b" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;T&lt;/code&gt; is an unqualified type, the graph below illustrates how qualifiers combine (combinations with &lt;code&gt;immutable&lt;/code&gt; are omitted). For each node, applying the qualifier labeling the edge leads to the resulting type.</source>
          <target state="translated">假设 &lt;code&gt;T&lt;/code&gt; 是非限定类型，下图说明了限定符如何组合（省略了 &lt;code&gt;immutable&lt;/code&gt; 组合）。对于每个节点，应用标记边缘的限定符会导致生成类型。</target>
        </trans-unit>
        <trans-unit id="317581a22ccf8624556bdb31509c5c5a51feef3f" translate="yes" xml:space="preserve">
          <source>Assuming that pages are laid out consequently in one array at &lt;code&gt;pages&lt;/code&gt;, the pseudo-code is:</source>
          <target state="translated">假设因此将页面布置在 &lt;code&gt;pages&lt;/code&gt; 一个数组中，则伪代码为：</target>
        </trans-unit>
        <trans-unit id="7bfdbbc84ee0d35091e2296c00a0a25e1c9d7c15" translate="yes" xml:space="preserve">
          <source>Assuming the file was at /example/test.d, this will output:</source>
          <target state="translated">假设文件在/example/test.d,这将输出。</target>
        </trans-unit>
        <trans-unit id="4ade9724e5f6c8aea4d40d9c22982099c0a42498" translate="yes" xml:space="preserve">
          <source>Assuming the reverse meaning (i.e. &quot;ignoreTerminator&quot;) and inserting the wrong code compiles and runs with erroneous results.  After replacing the boolean parameter with an instantiation of &lt;code&gt;Flag&lt;/code&gt;, code calling &lt;code&gt;getLine&lt;/code&gt; can be easily read and understood even by people not fluent with the API:</source>
          <target state="translated">假定含义相反（即&amp;ldquo; ignoreTerminator&amp;rdquo;）并插入错误的代码，则会编译并运行，结果错误。用 &lt;code&gt;Flag&lt;/code&gt; 的实例替换boolean参数后，即使不熟练使用API​​的人也可以轻松阅读和理解调用 &lt;code&gt;getLine&lt;/code&gt; 的代码：</target>
        </trans-unit>
        <trans-unit id="8b593995c88f61a609044a01e37e8e4ccc22e065" translate="yes" xml:space="preserve">
          <source>Assumptions</source>
          <target state="translated">Assumptions</target>
        </trans-unit>
        <trans-unit id="875a558108f6180c117cd2a9851fbd31bf1ad357" translate="yes" xml:space="preserve">
          <source>At Least Alias</source>
          <target state="translated">至少是别名</target>
        </trans-unit>
        <trans-unit id="319fc7f766d3014146f622cd42e082b9d29acc59" translate="yes" xml:space="preserve">
          <source>At any point in the program, for each memory object, there is exactly one live mutable pointer to it or all the live pointers to it are read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5e7ce73794fbffd33597afe29e6656f7606b48" translate="yes" xml:space="preserve">
          <source>At least one return statement, throw statement, or assert(0) expression is required if the function specifies a return type that is not void, unless the function contains inline assembler code.</source>
          <target state="translated">如果函数指定的返回类型不是void,则至少需要一个返回语句、抛出语句或assert(0)表达式,除非函数包含内联汇编器代码。</target>
        </trans-unit>
        <trans-unit id="90d61c89ed43af9a321f3f7948cd37fb3078855e" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. &lt;code&gt;Zip&lt;/code&gt; offers the lowest range facilities of all components, e.g. it offers random access iff all ranges offer random access, and also offers mutation and swapping if all ranges offer it. Due to this, &lt;code&gt;Zip&lt;/code&gt; is extremely powerful because it allows manipulating several ranges in lockstep.</source>
          <target state="translated">至少是一个输入范围。 &lt;code&gt;Zip&lt;/code&gt; 提供了所有组件中范围最低的工具，例如，如果所有范围都提供了随机访问权限，则它提供了随机访问；如果所有范围都提供了它，它也可以提供突变和交换功能。因此， &lt;code&gt;Zip&lt;/code&gt; 非常强大，因为它允许以锁步的方式操纵多个范围。</target>
        </trans-unit>
        <trans-unit id="bf82744118a56dc50e99bed95e0674d739012373" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. All other range primitives are given in the resulting range if &lt;code&gt;range&lt;/code&gt; has them. The exceptions are the bidirectional primitives, which are propagated only if &lt;code&gt;range&lt;/code&gt; has length.</source>
          <target state="translated">至少是一个输入范围。如果 &lt;code&gt;range&lt;/code&gt; 有其他所有范围原语，则在结果范围中给出它们。双向图元是唯一的例外，它们仅在 &lt;code&gt;range&lt;/code&gt; 具有长度时才传播。</target>
        </trans-unit>
        <trans-unit id="e9641b92bdebc39e62f8119a95b586fda5bb953c" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. If the range offers random access and &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt; offers them as well.</source>
          <target state="translated">至少是一个输入范围。如果范围提供随机访问和 &lt;code&gt;length&lt;/code&gt; ，则 &lt;code&gt;take&lt;/code&gt; 提供它们。</target>
        </trans-unit>
        <trans-unit id="b4f8bcff8fd004d35539b31be3e23eec00e83071" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. Range primitives such as bidirectionality and random access are given if the element type of &lt;code&gt;rr&lt;/code&gt; provides them.</source>
          <target state="translated">至少是一个输入范围。如果 &lt;code&gt;rr&lt;/code&gt; 的元素类型提供了范围原语，例​​如双向性和随机访问。</target>
        </trans-unit>
        <trans-unit id="ab81f7243697f45d24e88eac476807c5bafc54c5" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. The resulting range will adopt the range primitives of the underlying range as long as &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">至少是一个输入范围。只要&lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;true&lt;/code&gt; ，结果范围将采用基础范围的范围原语。</target>
        </trans-unit>
        <trans-unit id="13e0cdc536d3ebf98a18c0bc6152dede0a930dcf" translate="yes" xml:space="preserve">
          <source>At offset index into buffer, create nbytes of space by shifting upwards all data past index.</source>
          <target state="translated">在偏移索引进入缓冲区时,通过向上移动所有经过索引的数据来创造nbytes的空间。</target>
        </trans-unit>
        <trans-unit id="1427d1990cebaf6b24e9781e5fa4c566cf53ece6" translate="yes" xml:space="preserve">
          <source>At present, C++ exceptions cannot be caught in or thrown from D, and D exceptions cannot be caught in or thrown from C++. Additionally, objects in C++ stack frames are not guaranteed to be destroyed when unwinding the stack due to a D exception, and vice versa.</source>
          <target state="translated">目前,C++异常不能被D捕获或抛出,D异常也不能被C++捕获或抛出。另外,在因D异常而解除栈的时候,不能保证C++栈帧中的对象被销毁,反之亦然。</target>
        </trans-unit>
        <trans-unit id="8d76f9b99e41b5780a5b8aa58882552e760fb6a3" translate="yes" xml:space="preserve">
          <source>Atomically adds &lt;code&gt;mod&lt;/code&gt; to the value referenced by &lt;code&gt;val&lt;/code&gt; and returns the value &lt;code&gt;val&lt;/code&gt; held previously. This operation is both lock-free and atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79117be4a561837c4e341dc958c03f4b3575dace" translate="yes" xml:space="preserve">
          <source>Atomically increment the current count by one. This will notify one waiter, if there are any in the queue.</source>
          <target state="translated">原子化地将当前计数递增1。这将通知一个服务员,如果有队列中的服务员。</target>
        </trans-unit>
        <trans-unit id="0e72ffed036979247fd717525ebb223918c99bbc" translate="yes" xml:space="preserve">
          <source>Atomically subtracts &lt;code&gt;mod&lt;/code&gt; from the value referenced by &lt;code&gt;val&lt;/code&gt; and returns the value &lt;code&gt;val&lt;/code&gt; held previously. This operation is both lock-free and atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">试图释放堆内存</target>
        </trans-unit>
        <trans-unit id="2d4188d946f5310d84944e1cbc16ca3404e12f5e" translate="yes" xml:space="preserve">
          <source>Attempt to write a readonly database</source>
          <target state="translated">试图写一个只读数据库</target>
        </trans-unit>
        <trans-unit id="bad2e7923396bd94563de54c8743dd18ec710863" translate="yes" xml:space="preserve">
          <source>Attempting to read a non-existent file.</source>
          <target state="translated">试图读取一个不存在的文件。</target>
        </trans-unit>
        <trans-unit id="cfc72cd8439fa8fc0153768ece769b118903087b" translate="yes" xml:space="preserve">
          <source>Attempting to write to a read-only file.</source>
          <target state="translated">试图向一个只读文件写入。</target>
        </trans-unit>
        <trans-unit id="f3bc6684b273ddb5150c8f76dec58669641f537c" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the function blocks until either the lock can be obtained or the time elapsed exceeds timeout, returning true if the lock was acquired and false if the function timed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619f7dc21d7be2451ba09a0a31590c696e32ea77" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">试图获取包围的mutex的读锁。如果能够在不阻塞的情况下获得锁,则获得锁并返回true。如果不能获得,则不获取锁,返回false。</target>
        </trans-unit>
        <trans-unit id="3953627ccf0b01ecfcf23b7ad87c26a8060eafac" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the function blocks until either the lock can be obtained or the time elapsed exceeds timeout, returning true if the lock was acquired and false if the function timed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640457600821a8df2d538564c057e12d520f4905" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">试图获取包围的mutex上的写锁。如果能够在不阻塞的情况下获得锁,则获得锁并返回true。如果不能获得,则不获取锁,返回false。</target>
        </trans-unit>
        <trans-unit id="3b9757d22891fdb7b2db7ae0d5e59794d8111018" translate="yes" xml:space="preserve">
          <source>Attempts to cast Object o to class c. Returns o if successful, null if not.</source>
          <target state="translated">试图将Object o投向c类,如果成功则返回o,如果失败则返回null。</target>
        </trans-unit>
        <trans-unit id="fb9f33e63583d791ce38087ee972da2a9a91218e" translate="yes" xml:space="preserve">
          <source>Attempts to lock the specified file segment. If both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are zero, the entire file is locked.</source>
          <target state="translated">尝试锁定指定的文件段。如果 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;length&lt;/code&gt; 均为零，则整个文件将被锁定。</target>
        </trans-unit>
        <trans-unit id="25ad0c35f575b740f4d561c41e13284745953ceb" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host address as a human-readable string.</source>
          <target state="translated">试图以人类可读的字符串检索主机地址。</target>
        </trans-unit>
        <trans-unit id="0ee6b4fbb8496cdc7d0620d9b9ed398b895a55e3" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host name as a fully qualified domain name.</source>
          <target state="translated">试图将主机名作为一个完全合格的域名来检索。</target>
        </trans-unit>
        <trans-unit id="2288a588beafb785ffe5d4183be649edf540fac4" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the numeric port number as a string.</source>
          <target state="translated">试图以字符串形式检索数字端口号。</target>
        </trans-unit>
        <trans-unit id="f6c4cea55c8d840b0fc77f72a5e89fc5d0c7b734" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the service name as a string.</source>
          <target state="translated">试图以字符串形式检索服务名称。</target>
        </trans-unit>
        <trans-unit id="06a30d499359e73aad911822ebc036ba5b33b771" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the process associated with &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">尝试终止与 &lt;code&gt;pid&lt;/code&gt; 相关联的进程。</target>
        </trans-unit>
        <trans-unit id="5e521b72cd060c4862399350be7113a0bf337401" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution typing global memory. For example, if you pre-allocate memory in the DATA/TLS segment and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">注意：启用精确扫描需要稍微注意键入全局内存的情况。例如，如果您在DATA / TLS段中预先分配了内存，之后又将引用其他分配的对象实例放置到该内存中，则不得使用基本整数类型来保留空间。这样做将导致垃圾收集器无法检测到引用。相反，请使用将保守扫描该区域的数组类型。通常使用 &lt;code&gt;void*&lt;/code&gt; 是最好的选择，因为它还可以确保GC扫描的指针正确对齐。</target>
        </trans-unit>
        <trans-unit id="435469686dcf93332d214d0927042b6ab70eb76c" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution with type declarations. For example, if you reserve a buffer as part of a struct and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">注意：启用精确扫描需要在类型声明时稍加注意。例如，如果您将缓冲区保留为结构的一部分，然后将引用其他分配的引用的对象实例放置到此内存中，则不得使用基本整数类型来保留空间。这样做将导致垃圾收集器无法检测到引用。相反，请使用将保守扫描该区域的数组类型。通常使用 &lt;code&gt;void*&lt;/code&gt; 是最好的选择，因为它还可以确保GC扫描的指针正确对齐。</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="563889efc6708465a0f8d7b13b7a64dc9449be63" translate="yes" xml:space="preserve">
          <source>Attribute inference is not done for other functions, even if the function body is present.</source>
          <target state="translated">对于其他函数,即使函数体存在,也不会进行属性推断。</target>
        </trans-unit>
        <trans-unit id="fde0c64566e4280899df7f71f529a9c5822593d2" translate="yes" xml:space="preserve">
          <source>Attributed Unittests</source>
          <target state="translated">归属单位测试</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="3566d57f396227b960696c7c5f730c9617ce2ae9" translate="yes" xml:space="preserve">
          <source>Attributes are a way to modify one or more declarations. The general forms are:</source>
          <target state="translated">属性是修改一个或多个声明的一种方式。一般形式有:</target>
        </trans-unit>
        <trans-unit id="caa5510657413031ecde7637769e34ce12f05928" translate="yes" xml:space="preserve">
          <source>Attributes as obtained by &lt;a href=&quot;std_file#getAttributes&quot;&gt;&lt;code&gt;std.file.getAttributes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_file#DirEntry.attributes&quot;&gt;&lt;code&gt;std.file.DirEntry.attributes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a118fa9a5b31a61d074da7d6149cfba22d1f3ad" translate="yes" xml:space="preserve">
          <source>Authentication method as specified in &lt;a href=&quot;#AuthMethod&quot;&gt;&lt;code&gt;AuthMethod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#AuthMethod&quot;&gt; &lt;code&gt;AuthMethod&lt;/code&gt; 中&lt;/a&gt;指定的身份验证方法。</target>
        </trans-unit>
        <trans-unit id="1033f15759fcb47c36fb8ab321053fc3f1eca814" translate="yes" xml:space="preserve">
          <source>Authentication method equal to &lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt;&lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">等同于&lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt; &lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt; 的&lt;/a&gt;身份验证方法</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="66d5524bc6e9a905bcd8ad67ae1eb457c570b564" translate="yes" xml:space="preserve">
          <source>Authorization denied</source>
          <target state="translated">拒绝授权</target>
        </trans-unit>
        <trans-unit id="96526fc6efe098c9c6df94252412831b9ccb9466" translate="yes" xml:space="preserve">
          <source>Authors:</source>
          <target state="translated">Authors:</target>
        </trans-unit>
        <trans-unit id="ce0159a5518bc584a9e41b4b2690ef154fde135a" translate="yes" xml:space="preserve">
          <source>Auto Functions</source>
          <target state="translated">自动功能</target>
        </trans-unit>
        <trans-unit id="cac7a53f813ead2d8559f8bf1f813c3742d1564d" translate="yes" xml:space="preserve">
          <source>Auto Ref Functions</source>
          <target state="translated">自动参考功能</target>
        </trans-unit>
        <trans-unit id="5437bd3930e7f40ca7893e40f97b38d23c03f5fa" translate="yes" xml:space="preserve">
          <source>Auto functions have their return type inferred from any &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body.</source>
          <target state="translated">自动函数具有从函数主体中的任何&lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;推断出的返回类型。</target>
        </trans-unit>
        <trans-unit id="cec7110add8230fd3e3cee4a6982476165507102" translate="yes" xml:space="preserve">
          <source>Auto ref function can have explicit return type.</source>
          <target state="translated">Auto ref函数可以有明确的返回类型。</target>
        </trans-unit>
        <trans-unit id="1c98218626b244980716cf56d4d67cef842f3ffa" translate="yes" xml:space="preserve">
          <source>Auto ref functions infer their return type just as &lt;a href=&quot;#auto-functions&quot;&gt;auto functions&lt;/a&gt; do. In addition, they become &lt;a href=&quot;#ref-functions&quot;&gt;ref functions&lt;/a&gt; if all return expressions are lvalues, and it would not be a reference to a local or a parameter.</source>
          <target state="translated">自动引用函数会像&lt;a href=&quot;#auto-functions&quot;&gt;自动函数&lt;/a&gt;一样推断其返回类型。另外，如果所有返回表达式都是左值，它们将成为&lt;a href=&quot;#ref-functions&quot;&gt;ref函数&lt;/a&gt;，并且不会引用本地或参数。</target>
        </trans-unit>
        <trans-unit id="72dbdd4328b363da1dc721bef13390d325cb449b" translate="yes" xml:space="preserve">
          <source>Auto ref parameters can be combined with auto ref return attributes:</source>
          <target state="translated">自动参考参数可以与自动参考返回属性相结合。</target>
        </trans-unit>
        <trans-unit id="b60c388599c6393e9a67e964a642ad91629c903e" translate="yes" xml:space="preserve">
          <source>Auto start with constructor.</source>
          <target state="translated">用构造函数自动启动。</target>
        </trans-unit>
        <trans-unit id="efe7dcdfb00b164478f91903b1de63b3b45e9d2f" translate="yes" xml:space="preserve">
          <source>Auto-initialize the object</source>
          <target state="translated">自动初始化对象</target>
        </trans-unit>
        <trans-unit id="9d4560b6ff607cd4aecb5b5ff67e03b10904f66c" translate="yes" xml:space="preserve">
          <source>Autodecoding is enabled if this is set to true.</source>
          <target state="translated">如果设置为 &quot;true&quot;,则启用自动解码。</target>
        </trans-unit>
        <trans-unit id="360d06366226a26ec284df57dde94213ed2f94dc" translate="yes" xml:space="preserve">
          <source>Automatic input/output redirection using pipes</source>
          <target state="translated">使用管道自动输入/输出重定向。</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">自动加载静态链接的扩展</target>
        </trans-unit>
        <trans-unit id="d2178e65328973816c4ca61d0183a96480a9ed99" translate="yes" xml:space="preserve">
          <source>Available GC options are:</source>
          <target state="translated">现有的气相色谱仪选项有:</target>
        </trans-unit>
        <trans-unit id="e14fc18612f34181b225bea7665a50b7b0f96761" translate="yes" xml:space="preserve">
          <source>Available output formats:</source>
          <target state="translated">可用的输出格式:</target>
        </trans-unit>
        <trans-unit id="063d4770adfbdb2cd75f5fde3c562c12c1713762" translate="yes" xml:space="preserve">
          <source>Available parameters are: CURLFTPAUTH_DEFAULT - let libcurl decide CURLFTPAUTH_SSL - try &quot;AUTH SSL&quot; first, then TLS CURLFTPAUTH_TLS - try &quot;AUTH TLS&quot; first, then SSL</source>
          <target state="translated">可用的参数有 CURLFTPAUTH_DEFAULT-让libcurl决定 CURLFTPAUTH_SSL-先试 &quot;AUTH SSL&quot;,再试TLS CURLFTPAUTH_TLS-先试 &quot;AUTH TLS&quot;,再试SSL。</target>
        </trans-unit>
        <trans-unit id="463bce54270761ca786235a57251bca24f1dbc8b" translate="yes" xml:space="preserve">
          <source>Available space in bytes</source>
          <target state="translated">可用空间(单位:字节)</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="2be47cf0ea6736915b049bc8ea265c97a2606e56" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be a sign of poor decomposition of program structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains declarations needed by the other two.</source>
          <target state="translated">在可行的情况下避免周期性导入。它们可能是程序结构分解成独立模块的不良迹象。互相导入的两个模块通常可以重组为三个没有循环的模块,其中第三个模块包含其他两个模块所需的声明。</target>
        </trans-unit>
        <trans-unit id="4417a2a43deb22ade3de0092387bf58a8c4fe263" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be an indication of poor decomposition of a program's structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains the declarations needed by the other two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa042d5d9bad75e7a516100618f6fbb64a7728b7" translate="yes" xml:space="preserve">
          <source>Avoid dependence on byte order; i.e. whether the CPU is big-endian or little-endian.</source>
          <target state="translated">避免对字节顺序的依赖;即CPU是大字节还是小字节。</target>
        </trans-unit>
        <trans-unit id="87263cc0efbd41c932d10eec489a5a9fa53f4615" translate="yes" xml:space="preserve">
          <source>Avoid dependence on the size of a pointer or reference being the same size as a particular integral type.</source>
          <target state="translated">避免依赖指针或引用的大小与特定积分类型的大小相同。</target>
        </trans-unit>
        <trans-unit id="a5f3c22b10cd44ac8e47f76e9ce3358fd5ea5dbb" translate="yes" xml:space="preserve">
          <source>Avoid depending on the order of side effects in a computation that may get reordered by the compiler. For example:</source>
          <target state="translated">避免在计算中依赖副作用的顺序,因为这可能会被编译器重新排序。例如:</target>
        </trans-unit>
        <trans-unit id="07964cf6df89426658b50b243ee7036b1cf42153" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of classes with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">避免让类的公有字段与无量子发生变化,因为这样的话,无量子就无法验证公有接口。</target>
        </trans-unit>
        <trans-unit id="4d3d6af1490ba88616db8531edd7f4d34c56a495" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of structs with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">避免让结构的公有字段与不变量发生变化,因为这样的话,不变量无法验证公有接口。</target>
        </trans-unit>
        <trans-unit id="0209d0b0190d63b253227592d1649d56cf0d62a8" translate="yes" xml:space="preserve">
          <source>Avoid reliance on side effects in the invariant. as the invariant may or may not be executed.</source>
          <target state="translated">避免依赖不变式中的副作用.因为不变式可能会被执行,也可能不会被执行。</target>
        </trans-unit>
        <trans-unit id="9a2c3569f4cdef214baa0f7dccd251b7796ef000" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs as parameters or arguments to variadic functions.</source>
          <target state="translated">避免使用空结构作为变量函数的参数或参数。</target>
        </trans-unit>
        <trans-unit id="aa27a565a88b1217ee8242e278c52dfa4dc27415" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs when interfacing with C and C++ code.</source>
          <target state="translated">当与C和C++代码接口时,避免使用空结构。</target>
        </trans-unit>
        <trans-unit id="fa97dd47910ed157d733ff928c6533de2cbdb883" translate="yes" xml:space="preserve">
          <source>A|B</source>
          <target state="translated">A|B</target>
        </trans-unit>
        <trans-unit id="ee75ef351995c342c1fa5ff34f0c8888a0c4023e" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">乙 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed32df2c72f22e8029196feaab8d830b375f94a9" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;begin&lt;/code&gt;</source>
          <target state="translated">B &lt;code&gt;begin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9228bacbd6367d63160ad16de9da2a5dc0a4c8ac" translate="yes" xml:space="preserve">
          <source>B &lt;strong id=&quot;select&quot;&gt;select&lt;/strong&gt;(bool cond : false, A, B)(lazy A a, B b);</source>
          <target state="translated">B &lt;strong id=&quot;select&quot;&gt;选择&lt;/strong&gt;（bool cond：false，A，B）（懒惰A a，B b）;</target>
        </trans-unit>
        <trans-unit id="38af9591e3fb4695fab9bf9aa8e4b04997260819" translate="yes" xml:space="preserve">
          <source>BE stands for BlockExit.</source>
          <target state="translated">BE是BlockExit的缩写。</target>
        </trans-unit>
        <trans-unit id="f18291c5630b11c70838e02838757f776b664e5c" translate="yes" xml:space="preserve">
          <source>BE.xxxx</source>
          <target state="translated">BE.xxxx</target>
        </trans-unit>
        <trans-unit id="a8ac71a34c4bf8d47fcd34a3bb48e39638e1c9c2" translate="yes" xml:space="preserve">
          <source>BEL (alarm) character (U+0007).</source>
          <target state="translated">BEL(报警)字符(U+0007)。</target>
        </trans-unit>
        <trans-unit id="c4c51eeb133480a8ab13e2aac716dc1c49511996" translate="yes" xml:space="preserve">
          <source>BODY</source>
          <target state="translated">BODY</target>
        </trans-unit>
        <trans-unit id="4248a9b200b0703a243217afa7ea61bb6e9a6078" translate="yes" xml:space="preserve">
          <source>BOM</source>
          <target state="translated">BOM</target>
        </trans-unit>
        <trans-unit id="9e5d541d33dd4e690757280921ed4737bc5066d7" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;builtin&quot;&gt;builtin&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;builtin&quot;&gt;内置&lt;/strong&gt; BUILTIN ;</target>
        </trans-unit>
        <trans-unit id="e08e1bc55cdffceca473579010d3eed8f80f3da4" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt;(FuncDeclaration fd);</source>
          <target state="translated">BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt;（FuncDeclaration fd）;</target>
        </trans-unit>
        <trans-unit id="2ba208c7a57215fe25a2dc8edeb1eed6d80c323c" translate="yes" xml:space="preserve">
          <source>Back references</source>
          <target state="translated">后面的参考资料</target>
        </trans-unit>
        <trans-unit id="cc6aace08575981676ef15b08f05eb45989c65af" translate="yes" xml:space="preserve">
          <source>Back-end type seldom used directly by user code. Two commonly-used types using &lt;code&gt;VariantN&lt;/code&gt; are:</source>
          <target state="translated">用户代码很少直接使用后端类型。使用 &lt;code&gt;VariantN&lt;/code&gt; 的两种常用类型是：</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="59c009b9aac36256a825b962a8506069b93a0cd0" translate="yes" xml:space="preserve">
          <source>Backspace (U+0008).</source>
          <target state="translated">退格(U+0008)。</target>
        </trans-unit>
        <trans-unit id="cc460f6a8460cfc0b7f80f1ff3a6c734e2b3ea57" translate="yes" xml:space="preserve">
          <source>Backward.</source>
          <target state="translated">Backward.</target>
        </trans-unit>
        <trans-unit id="be7e10d1c5dd2ad77f6d5a617372a7bf013cb7bf" translate="yes" xml:space="preserve">
          <source>Bad</source>
          <target state="translated">Bad</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="a4ba5616fd448eeba2a0c6f11c812abe221ea915" translate="yes" xml:space="preserve">
          <source>Bamum Supplement</source>
          <target state="translated">Bamum补充剂</target>
        </trans-unit>
        <trans-unit id="8e0abbaab6b20b6084d656b5fa956a7ead91c3cf" translate="yes" xml:space="preserve">
          <source>Bare URLs</source>
          <target state="translated">裸露的URL</target>
        </trans-unit>
        <trans-unit id="f70b3222f4784cd8b2d7fa95c5e6ff653751d799" translate="yes" xml:space="preserve">
          <source>Bare URLs are sequences of characters that start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;, continue with one or more characters from the set of letters, digits and &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt;, and contain at least one period. URL recognition happens before all macro text substitution. The URL is wrapped in a &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; macro and is otherwise left untouched.</source>
          <target state="translated">裸URL是以 &lt;code&gt;http://&lt;/code&gt; 或 &lt;code&gt;https://&lt;/code&gt; 开头的字符序列，以字母，数字和 &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt; 一个或多个字符开头。，并且至少包含一个句点。URL识别发生在所有宏文本替换之前。该URL被包装在 &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; 宏中，否则保持不变。</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">基础类型</target>
        </trans-unit>
        <trans-unit id="cc110ca211bf143dd27dd71bfdb7b015a52cf91f" translate="yes" xml:space="preserve">
          <source>Base class construction is done by calling the base class constructor by the name &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">通过使用名称 &lt;code&gt;super&lt;/code&gt; 调用基类构造函数来完成基类构造：</target>
        </trans-unit>
        <trans-unit id="da5e0d7ff0c3f501f663124890a539611d14d952" translate="yes" xml:space="preserve">
          <source>Base class for synchronization errors.</source>
          <target state="translated">同步错误的基类。</target>
        </trans-unit>
        <trans-unit id="c38a7f6f1cb2f71a182073d464805a1edb6ea0e7" translate="yes" xml:space="preserve">
          <source>Base class for synchronization exceptions.</source>
          <target state="translated">同步异常的基类。</target>
        </trans-unit>
        <trans-unit id="672c3fd9686f0e99c9f798afb18e998c05c3a884" translate="yes" xml:space="preserve">
          <source>Base class for thread errors to be used for function inside GC when allocations are unavailable.</source>
          <target state="translated">当分配不可用时,用于GC内部函数的线程错误的基类。</target>
        </trans-unit>
        <trans-unit id="db07e1efbf8851dc009b2f7a1cf1562018684f57" translate="yes" xml:space="preserve">
          <source>Base class for thread exceptions.</source>
          <target state="translated">线程异常的基类。</target>
        </trans-unit>
        <trans-unit id="b0f6bbd9a7204a011357ddbe15da4f159805a9c3" translate="yes" xml:space="preserve">
          <source>Base classes are a list of these.</source>
          <target state="translated">基类是其中的一个列表。</target>
        </trans-unit>
        <trans-unit id="72c50689eae38c1c7d83b57fc2a2426479cefce2" translate="yes" xml:space="preserve">
          <source>Base exception thrown by &lt;code&gt;std.socket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.socket&lt;/code&gt; 抛出的基本异常。</target>
        </trans-unit>
        <trans-unit id="05df8270dbce2a852d75025619c0b4d03bd1da5f" translate="yes" xml:space="preserve">
          <source>BaseClass* &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt;;</source>
          <target state="translated">BaseClass * &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="22f60185c7bbe04f26adbe40ecfd3daf1c5e1e4a" translate="yes" xml:space="preserve">
          <source>Based on a design by Mikola Lysenko.</source>
          <target state="translated">根据Mikola Lysenko的设计。</target>
        </trans-unit>
        <trans-unit id="b9c44f636926230213ca4c58bc4bd5fa1a395472" translate="yes" xml:space="preserve">
          <source>Based on code written by Regan Heath</source>
          <target state="translated">基于Regan Heath编写的代码</target>
        </trans-unit>
        <trans-unit id="8a178898d54dc17c11ed3e0694b1794aa76cee7f" translate="yes" xml:space="preserve">
          <source>Based on ideas in Table 3.1 from &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt; Modern C++ Design&lt;/a&gt;, Andrei Alexandrescu (Addison-Wesley Professional, 2001)</source>
          <target state="translated">基于&lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt;Modern C ++ Design的&lt;/a&gt;表3.1中的思想，Andrei Alexandrescu（Addison-Wesley Professional，2001年）</target>
        </trans-unit>
        <trans-unit id="74c70ad4dc394c37a35d8a9a02d3bbf206c6a2c3" translate="yes" xml:space="preserve">
          <source>Baseok &lt;strong id=&quot;baseok&quot;&gt;baseok&lt;/strong&gt;;</source>
          <target state="translated">Baseok &lt;strong id=&quot;baseok&quot;&gt;baseok&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2958841f21ba5aab25e4b9de01c61072c4396f05" translate="yes" xml:space="preserve">
          <source>Basic (default)</source>
          <target state="translated">基本(默认)</target>
        </trans-unit>
        <trans-unit id="0376175c25ef469be8d7167b7c3f076d8a83135c" translate="yes" xml:space="preserve">
          <source>Basic Data Types</source>
          <target state="translated">基本数据类型</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">基本示例</target>
        </trans-unit>
        <trans-unit id="e19913977bf78df5f5b70c758a83b5ae4241e38e" translate="yes" xml:space="preserve">
          <source>Basic Latin</source>
          <target state="translated">基础拉丁语</target>
        </trans-unit>
        <trans-unit id="0c51e02cc99b54172f7d7ba26283b9a2651139e1" translate="yes" xml:space="preserve">
          <source>Basic Logging</source>
          <target state="translated">基本记录</target>
        </trans-unit>
        <trans-unit id="c1025054c73b30fcc4ab113e76ab64be203331d7" translate="yes" xml:space="preserve">
          <source>Basic SMTP protocol support.</source>
          <target state="translated">基本的SMTP协议支持。</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">基本类型</target>
        </trans-unit>
        <trans-unit id="bf25bdb7baac4ca40f143b32bfd463f5aa35f794" translate="yes" xml:space="preserve">
          <source>Basic and dumm visitor which implements a visit method for each AST node implemented in AST. This visitor is the parent of strict, transitive and permissive visitors.</source>
          <target state="translated">Basic 和 dumm 访客,它为 AST 中实现的每个 AST 节点实现了一个访问方法。这个访问者是严格的、转义的和允许的访问者的父类。</target>
        </trans-unit>
        <trans-unit id="da424bc11d72f3a523d822671599c05d2482dd43" translate="yes" xml:space="preserve">
          <source>Basic block control flow operators.</source>
          <target state="translated">基本的区块控制流程操作人员。</target>
        </trans-unit>
        <trans-unit id="55069311e393b3bc10e5288945ff6aebf4b60dce" translate="yes" xml:space="preserve">
          <source>Basic blocks: Basic blocks are a linked list of all the basic blocks in a function. startblock heads the list.</source>
          <target state="translated">基本块。基本区块是一个函数中所有基本区块的链接列表 startblock是列表的头。</target>
        </trans-unit>
        <trans-unit id="b015bc27621ab2a6e58582de340627d2513e110c" translate="yes" xml:space="preserve">
          <source>Basic data types are leaf types. Derived data types build on leaf types. User defined types are aggregates of basic and derived types.</source>
          <target state="translated">基本数据类型是叶子类型。派生数据类型建立在叶子类型的基础上。用户定义类型是基本类型和派生类型的集合。</target>
        </trans-unit>
        <trans-unit id="c76e778b9531849f5fdc3371b8bf8a9576ca93cb" translate="yes" xml:space="preserve">
          <source>Basic splitting with characters and numbers.</source>
          <target state="translated">用字符和数字进行基本分割。</target>
        </trans-unit>
        <trans-unit id="22d64c70202f0fd0175e71294c1f0654ef85c43d" translate="yes" xml:space="preserve">
          <source>Basic support for lock-free concurrent programming.</source>
          <target state="translated">基本支持无锁并发编程。</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="f3a7ec26a786494d0ab6bd615e7d7023643666db" translate="yes" xml:space="preserve">
          <source>Be wary of CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') attacks. &lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt; More info: &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&lt;/a&gt;</source>
          <target state="translated">警惕CWE-22：路径名对受限目录的不正确限制（&amp;ldquo;路径遍历&amp;rdquo;）攻击。&lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt;更多信息：&lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https&lt;/a&gt;：//www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating +来自+污染+来源</target>
        </trans-unit>
        <trans-unit id="0d9a6a84847309258cd9cad1f00b1d9b08270b36" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MultiwayMerge&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;MultiwayMerge&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;MultiwayMerge&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">因为 &lt;code&gt;MultiwayMerge&lt;/code&gt; 不分配额外的内存，所以它将保留 &lt;code&gt;ror&lt;/code&gt; 的修改。即， &lt;code&gt;MultiwayMerge&lt;/code&gt; 承担了 &lt;code&gt;ror&lt;/code&gt; 的所有权，并酌情交换和推进了它的元素。如果您希望 &lt;code&gt;ror&lt;/code&gt; 在调用后保留其内容，则可能希望将副本传递给 &lt;code&gt;MultiwayMerge&lt;/code&gt; （并可能在调用之间缓存副本）。</target>
        </trans-unit>
        <trans-unit id="34edc8e4b66b211204a07db61a02d64017fc4c94" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;largestPartialIntersection&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;largestPartialIntersection&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;largestPartialIntersection&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">由于 &lt;code&gt;largestPartialIntersection&lt;/code&gt; 不会分配额外的内存，因此将 &lt;code&gt;ror&lt;/code&gt; 保留为已修改状态。即， &lt;code&gt;largestPartialIntersection&lt;/code&gt; 承担 &lt;code&gt;ror&lt;/code&gt; 的所有权，并酌情交换和预付其元素。如果您希望 &lt;code&gt;ror&lt;/code&gt; 在调用后保留其内容，则可能希望将副本传递给 &lt;code&gt;largestPartialIntersection&lt;/code&gt; （并可能在调用之间缓存副本）。</target>
        </trans-unit>
        <trans-unit id="f9b6407740dfbc3c5fa141971e324ac38d1b4cc4" translate="yes" xml:space="preserve">
          <source>Because errors are unusual, execution of error handling code is not performance critical.</source>
          <target state="translated">因为错误是不寻常的,所以执行错误处理代码并不影响性能。</target>
        </trans-unit>
        <trans-unit id="1362358bff14273f0cd677a86a2f16a4032a69e1" translate="yes" xml:space="preserve">
          <source>Because immutable is transitive, data referred to by an immutable is also immutable:</source>
          <target state="translated">因为不可变是转义的,所以不可变所指的数据也是不可变的。</target>
        </trans-unit>
        <trans-unit id="37a897f3827c71e8379bebae37724c5759dd60a2" translate="yes" xml:space="preserve">
          <source>Because it doesn't return the value, this function is cheaper than &lt;code&gt;get&lt;/code&gt;. However, if you do need the value as well, you should just check the return of &lt;code&gt;get&lt;/code&gt; for &lt;code&gt;null&lt;/code&gt; instead of using this function first.</source>
          <target state="translated">因为它不返回值，所以此函数比 &lt;code&gt;get&lt;/code&gt; 便宜。但是，如果你确实需要的价值，以及，你应该检查返回 &lt;code&gt;get&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，而不是第一个使用此功能的。</target>
        </trans-unit>
        <trans-unit id="46a9674034fbe47581e972f1a85b13b8dd6bc584" translate="yes" xml:space="preserve">
          <source>Because modules are not part of C++, each function with C++ linkage in the global namespace must be globally unique within the program.</source>
          <target state="translated">因为模块不是C++的一部分,所以在全局命名空间中,每个带有C++链接的函数在程序中必须是全局唯一的。</target>
        </trans-unit>
        <trans-unit id="1a175b9174f2111e9e8065ab0dee738f3bde0af2" translate="yes" xml:space="preserve">
          <source>Because static arrays are passed to functions by value, a larger array can consume a lot of stack space. Use dynamic arrays instead.</source>
          <target state="translated">因为静态数组是通过值传递给函数的,所以较大的数组会消耗大量的栈空间。使用动态数组代替。</target>
        </trans-unit>
        <trans-unit id="f36468f4c3a8d99449e93cf621c400036ac04c35" translate="yes" xml:space="preserve">
          <source>Because the allocator does not reuse memory, any dangling references to deallocated memory will always result in deterministically crashing the process.</source>
          <target state="translated">因为分配器不重用内存,任何对deallocated内存的悬空引用总是会导致进程确定性地崩溃。</target>
        </trans-unit>
        <trans-unit id="d8c3a61715e6c076e516e2adb94c24e13d1a7e0e" translate="yes" xml:space="preserve">
          <source>Because the reduction is being performed in parallel, &lt;code&gt;functions&lt;/code&gt; must be associative. For notational simplicity, let # be an infix operator representing &lt;code&gt;functions&lt;/code&gt;. Then, (a # b) # c must equal a # (b # c). Floating point addition is not associative even though addition in exact arithmetic is. Summing floating point numbers using this function may give different results than summing serially. However, for many practical purposes floating point addition can be treated as associative.</source>
          <target state="translated">因为归约是并行执行的，所以 &lt;code&gt;functions&lt;/code&gt; 必须是关联的。为了简化符号，让＃为表示 &lt;code&gt;functions&lt;/code&gt; 的中缀运算符。然后，（a＃b）＃c必须等于＃（b＃c）。即使精确算术中的加法运算，浮点加法也不是关联的。使用此功能求和浮点数可能会得到与串行求和不同的结果。但是，出于许多实际目的，可以将浮点加法视为关联的。</target>
        </trans-unit>
        <trans-unit id="b6b9c971f1d02fbd8d1af3306f1013bb85ae0126" translate="yes" xml:space="preserve">
          <source>Because the validity of the day number depends on both on the year and month of which the day is occurring, take all three variables to validate the day.</source>
          <target state="translated">因为日号的有效性既取决于该日发生的年月日,所以取这三个变量来验证该日。</target>
        </trans-unit>
        <trans-unit id="04beefc07e753c0350f57ce75d35ae3795bc6efa" translate="yes" xml:space="preserve">
          <source>Because there are no units larger than years, there is no difference between adding and rolling years.</source>
          <target state="translated">因为没有大于年的单位,所以加年和滚年没有区别。</target>
        </trans-unit>
        <trans-unit id="8b9fa636d60436156ac4d9755dc04095e1b03ef6" translate="yes" xml:space="preserve">
          <source>Before the function actually returns, any objects with scope storage duration are destroyed, any enclosing finally clauses are executed, any scope(exit) statements are executed, any scope(success) statements are executed, and any enclosing synchronization objects are released.</source>
          <target state="translated">在函数实际返回之前,任何具有作用域存储持续时间的对象都会被销毁,任何包围性的最后子句都会被执行,任何 scope(exit)语句都会被执行,任何 scope(success)语句都会被执行,任何包围性的同步对象都会被释放。</target>
        </trans-unit>
        <trans-unit id="29b56d3b3ce732a418c6733f4aa512d819b9b955" translate="yes" xml:space="preserve">
          <source>Begins a full collection. While the meaning of this may change based on the garbage collector implementation, typical behavior is to scan all stack segments for roots, mark accessible memory blocks as alive, and then to reclaim free space. This action may need to suspend all running threads for at least part of the collection process.</source>
          <target state="translated">开始一个完整的收集。虽然这个含义可能会根据垃圾收集器的实现而改变,但典型的行为是扫描所有堆栈段的根,将可访问的内存块标记为有效,然后回收空闲空间。这个操作可能需要暂停所有正在运行的线程,至少在收集过程的一部分。</target>
        </trans-unit>
        <trans-unit id="a9290b213da7c41d3b9d381305e1a85dfd638ddf" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;#visit&quot;&gt;&lt;code&gt;visit&lt;/code&gt;&lt;/a&gt; but doesn't enforce that all types are handled by the visiting functions.</source>
          <target state="translated">表现为&lt;a href=&quot;#visit&quot;&gt; &lt;code&gt;visit&lt;/code&gt; &lt;/a&gt;但不强制所有类型都由访问功能处理。</target>
        </trans-unit>
        <trans-unit id="8671963c6358c10c30f0a9f60f5760e545d91151" translate="yes" xml:space="preserve">
          <source>Behaves like the identity function when args is empty.</source>
          <target state="translated">当args为空时,其行为与身份函数类似。</target>
        </trans-unit>
        <trans-unit id="f909782a90d0d82b3e7b38e26ebe9e00bc13126f" translate="yes" xml:space="preserve">
          <source>Being 100% compatible with C++ means more or less adding a fully functional C++ compiler front end to D. Anecdotal evidence suggests that writing such is a minimum of a 10 man-year project, essentially making a D compiler with such capability unimplementable. Other languages looking to hook up to C++ face the same problem, and the solutions have been:</source>
          <target state="translated">与C++100%兼容多少意味着要在D语言中加入一个全功能的C++编译器前端。传闻表明,编写这样的编译器至少是一个10人年的项目,基本上使得具有这种功能的D编译器无法实现。其他希望挂靠C++的语言也面临着同样的问题,解决的办法也有。</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="d6bc78c2edfd9a1e4a494692d443253b772c6030" translate="yes" xml:space="preserve">
          <source>Below here follows defines for the CURLOPT_IPRESOLVE option. If a host name resolves addresses using more than one IP protocol version, this option might be handy to force libcurl to use a specific IP version.</source>
          <target state="translated">下面是CURLOPT_IPRESOLVE选项的定义。如果一个主机名使用多个IP协议版本来解析地址,那么这个选项可以方便地强制libcurl使用特定的IP版本。</target>
        </trans-unit>
        <trans-unit id="8b8ee9a8f224bc381d10b9725300af6e8ad60b2f" translate="yes" xml:space="preserve">
          <source>Below is the table of names accepted by &lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt;&lt;code&gt;unicode.hangulSyllableType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下表是&lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt; &lt;code&gt;unicode.hangulSyllableType&lt;/code&gt; &lt;/a&gt;接受的名称表。</target>
        </trans-unit>
        <trans-unit id="f460beb4086eb83db26145c0c14bfc2836a2dd77" translate="yes" xml:space="preserve">
          <source>Below is the table with block names accepted by &lt;a href=&quot;#unicode.block&quot;&gt;&lt;code&gt;unicode.block&lt;/code&gt;&lt;/a&gt;. Note that the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; requires &quot;In&quot; to be prepended to the names of blocks so as to disambiguate scripts and blocks.</source>
          <target state="translated">下表是&lt;a href=&quot;#unicode.block&quot;&gt; &lt;code&gt;unicode.block&lt;/code&gt; &lt;/a&gt;接受的块名称表。请注意，速记版本&lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt;要求在块名称之前加上&amp;ldquo; In&amp;rdquo;，以消除脚本和块的歧义。</target>
        </trans-unit>
        <trans-unit id="c16ded473b8d6a501e3afbf1d6b1aaa3bb67b9a5" translate="yes" xml:space="preserve">
          <source>Below is the table with script names accepted by &lt;a href=&quot;#unicode.script&quot;&gt;&lt;code&gt;unicode.script&lt;/code&gt;&lt;/a&gt; and by the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">下表是&lt;a href=&quot;#unicode.script&quot;&gt; &lt;code&gt;unicode.script&lt;/code&gt; &lt;/a&gt;和速记版本&lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt;接受的脚本名称：</target>
        </trans-unit>
        <trans-unit id="5cce75cef6b6f1b3c31bc07730b294f2256592a7" translate="yes" xml:space="preserve">
          <source>Benchmark with two functions comparing.</source>
          <target state="translated">与两个函数比较的基准。</target>
        </trans-unit>
        <trans-unit id="aa8cbccdf814344c472fdc83108ce95f463d76c2" translate="yes" xml:space="preserve">
          <source>Benchmarks code for speed assessment and comparison.</source>
          <target state="translated">用于速度评估和比较的基准代码。</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="39b464ae10a3403acc76206ce3373cf277ad5588" translate="yes" xml:space="preserve">
          <source>Beta function</source>
          <target state="translated">Beta功能</target>
        </trans-unit>
        <trans-unit id="6cf60f60aed600fb3f70f4f199ce23160c46df50" translate="yes" xml:space="preserve">
          <source>Better C</source>
          <target state="translated">更好的C</target>
        </trans-unit>
        <trans-unit id="fa66737ffd71fbd94c99a79ae1d7c0f7a3f83f97" translate="yes" xml:space="preserve">
          <source>Bidi_Control</source>
          <target state="translated">Bidi_Control</target>
        </trans-unit>
        <trans-unit id="c1dd854953db9a48bc0d0ea0a3df0b423f22bafe" translate="yes" xml:space="preserve">
          <source>Bidirectional primitives. They are offered if &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt;.</source>
          <target state="translated">双向基元。如果 &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt; ,则提供它们。</target>
        </trans-unit>
        <trans-unit id="0fd2b2945fcece1d7de6dc41f877ba8c67c13689" translate="yes" xml:space="preserve">
          <source>Bidirectional range of elements</source>
          <target state="translated">元素的双向范围</target>
        </trans-unit>
        <trans-unit id="019ef9f3f8b5262d462588c43fd756f3913eee2d" translate="yes" xml:space="preserve">
          <source>Bidirectional range primitives. Provided only if both &lt;code&gt;hasSlicing!Source&lt;/code&gt; and &lt;code&gt;hasLength!Source&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">双向范围原语。仅当 &lt;code&gt;hasSlicing!Source&lt;/code&gt; 和 &lt;code&gt;hasLength!Source&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时才提供。</target>
        </trans-unit>
        <trans-unit id="71bfb07d0cb12b1ba4834790c7322d9de720c8a3" translate="yes" xml:space="preserve">
          <source>BidirectionalRange &lt;code&gt;range&lt;/code&gt;</source>
          <target state="translated">双向 &lt;code&gt;range&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="635846f5f8a3535fe06ebe7bdfb132d87f3a3a9b" translate="yes" xml:space="preserve">
          <source>Big endian byte order</source>
          <target state="translated">大恩迪安字节顺序</target>
        </trans-unit>
        <trans-unit id="880ccaf424d3d59837e9afca21d218a82696d56c" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;base&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;base&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15d8e19b48cf73cfcbd5673d000427a6c89fe0cf" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;dividend&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;dividend&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bf4e8892121a909f8719ff5ba16cf85f8324a8e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;divisor&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;divisor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9d72c5e7f7fec77eccf61954e6a190a6919e39" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;exponent&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;exponent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d09af76576312e7fbdeb58e15f85ddf03bdfeca" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;modulus&lt;/code&gt;</source>
          <target state="translated">大整数 &lt;code&gt;modulus&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6719bddb8d0310ee6d49cac219e4be2a60dd859e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;quotient&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;quotient&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6acf46d3f9c34c441344f4052f380185deff090a" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;remainder&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;remainder&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc0d6128e74b8ffa38299adc002109eff669779d" translate="yes" xml:space="preserve">
          <source>BigInt implements value semantics using copy-on-write. This means that assignment is cheap, but operations such as x++ will cause heap allocation. (But note that for most bigint operations, heap allocation is inevitable anyway.)</source>
          <target state="translated">BigInt使用copy-on-write实现了值语义。这意味着赋值很便宜,但x++等操作会造成堆分配。(但请注意,对于大多数bigint操作来说,无论如何,堆分配是不可避免的。)</target>
        </trans-unit>
        <trans-unit id="2ae987b3c8b155139b22a17dacfded40cd54d6e8" translate="yes" xml:space="preserve">
          <source>Binary Operator Overloading</source>
          <target state="translated">二进制运算符重载</target>
        </trans-unit>
        <trans-unit id="7ea3f10d7dc50a5d1d60c584be4ba66327be2344" translate="yes" xml:space="preserve">
          <source>Binary exponentiation</source>
          <target state="translated">二进制指数</target>
        </trans-unit>
        <trans-unit id="bc0e2dd063d01cb0a49d6952e1a447f5a0786666" translate="yes" xml:space="preserve">
          <source>Binary expressions except for &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt;, and &lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression&lt;/i&gt;&lt;/a&gt; are evaluated in lexical order (left-to-right). Example:</source>
          <target state="translated">除&lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;，&lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression&lt;/i&gt;&lt;/a&gt;之外的二进制表达式以词法顺序（从左到右）求值。例：</target>
        </trans-unit>
        <trans-unit id="3f59323ff0289ed186c342bdb4f9ade9bee4b594" translate="yes" xml:space="preserve">
          <source>Binary files: Number of bytes to offset from origin.</source>
          <target state="translated">二进制文件。从原点出发要偏移的字节数。</target>
        </trans-unit>
        <trans-unit id="5ec3f5b7c67a25b307ee5761394fbc7f85f5c4ec" translate="yes" xml:space="preserve">
          <source>Binary files: Position used as reference for the offset, must be one of &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt;, &lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt; or &lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt;.</source>
          <target state="translated">二进制文件：位置用作偏移参考，必须是一个&lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt;，&lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt;或&lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="710001c86b903db5ac28284015f70ad29d702165" translate="yes" xml:space="preserve">
          <source>Binary integers are a sequence of binary digits preceded by a &amp;lsquo;0b&amp;rsquo; or &amp;lsquo;0B&amp;rsquo;.</source>
          <target state="translated">二进制整数是由&amp;ldquo; 0b&amp;rdquo;或&amp;ldquo; 0B&amp;rdquo;开头的二进制数字序列。</target>
        </trans-unit>
        <trans-unit id="e30449766634fc47649993e043f53913e318f363" translate="yes" xml:space="preserve">
          <source>Binary operations: subtracting and intersecting flags</source>
          <target state="translated">二进制运算:减法和相交标志。</target>
        </trans-unit>
        <trans-unit id="5bc41f55b9ac5ad602ac2a15812f4fa17e719258" translate="yes" xml:space="preserve">
          <source>Binary predicate for determining equivalence of two elements.</source>
          <target state="translated">二元谓词,用于确定两个元素的等价性。</target>
        </trans-unit>
        <trans-unit id="1b5c4d6f642263934709007da433b44cfafe3dfa" translate="yes" xml:space="preserve">
          <source>Binary predicate that reverses the order of arguments, e.g., given &lt;code&gt;pred(a, b)&lt;/code&gt;, returns &lt;code&gt;pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">反转参数顺序的二进制谓词，例如，给定 &lt;code&gt;pred(a, b)&lt;/code&gt; ，返回 &lt;code&gt;pred(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3390f0873b37228eb9da1981c4edea13376f4ce4" translate="yes" xml:space="preserve">
          <source>Binary zero (NUL, U+0000).</source>
          <target state="translated">二进制零(NUL,U+0000)。</target>
        </trans-unit>
        <trans-unit id="f07c525c75d6754496cc9e553ac6cf1931c4d038" translate="yes" xml:space="preserve">
          <source>BinaryHeap!(Store, less) &lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt;(alias less = &quot;a &amp;lt; b&quot;, Store)(Store s, size_t initialSize = size_t.max);</source>
          <target state="translated">BinaryHeap！（Store，less）&lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt;（alias less =&amp;ldquo; a &amp;lt;b&amp;rdquo;，Store）（Store s，size_t initialSize = size_t.max）;</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">绑定值到准备好的报表</target>
        </trans-unit>
        <trans-unit id="29d9453c80dc53e32cc00f3280980ce7ea8a0687" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr)</source>
          <target state="translated">为::操作符delete(void*ptr)绑定。</target>
        </trans-unit>
        <trans-unit id="f7d97838adda037dd541956c0b38a3516ae36925" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr, const std::nothrow_t&amp;amp; tag)</source>
          <target state="translated">绑定:: operator delete（void * ptr，const std :: nothrow_t＆标签）</target>
        </trans-unit>
        <trans-unit id="9e8bd6d0542a61db39dc7370f4ff9f5bdec532e6" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count)</source>
          <target state="translated">绑定 ::operator new(std::size_t count)</target>
        </trans-unit>
        <trans-unit id="c9209fa1a437c94943e83fdcf912d410e070a043" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count, const std::nothrow_t&amp;amp;)</source>
          <target state="translated">绑定:: operator new（std :: size_t count，const std :: nothrow_t＆）</target>
        </trans-unit>
        <trans-unit id="c595af9a225910870bb198153cb9e584ec6c2237" translate="yes" xml:space="preserve">
          <source>Binds the internal state to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">将内部状态绑定到 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e718a122aa87d12e98c5f3055711cc94d264e1c" translate="yes" xml:space="preserve">
          <source>Bionic C runtime</source>
          <target state="translated">Bionic C运行时</target>
        </trans-unit>
        <trans-unit id="cec8cf9a0b27bd714792dac06606e5c1b0178367" translate="yes" xml:space="preserve">
          <source>Bit constructs</source>
          <target state="translated">位结构</target>
        </trans-unit>
        <trans-unit id="70402e7ad10ad5f2124d70b6b5dfed369e14c974" translate="yes" xml:space="preserve">
          <source>Bit decoding of the TargetOS</source>
          <target state="translated">TargetOS的比特解码</target>
        </trans-unit>
        <trans-unit id="da97ac52d02a77703c633362dd74456458d249b2" translate="yes" xml:space="preserve">
          <source>Bit fields are supported with the &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;bitfields&lt;/a&gt; template.</source>
          <target state="translated">位&lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;域&lt;/a&gt;模板支持位域。</target>
        </trans-unit>
        <trans-unit id="11ee76002d783da853ef20847f30176e5d03ae44" translate="yes" xml:space="preserve">
          <source>Bit flipping</source>
          <target state="translated">翻转位</target>
        </trans-unit>
        <trans-unit id="8f76655665dcf73e363d56fc2df9877070986357" translate="yes" xml:space="preserve">
          <source>Bit wise expressions perform a bitwise operation on their operands. Their operands must be integral types. First, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are done. Then, the bitwise operation is done.</source>
          <target state="translated">按位表达式对它们的操作数执行按位运算。它们的操作数必须是整数类型。首先，完成&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;常规的算术转换&lt;/a&gt;。然后，按位运算完成。</target>
        </trans-unit>
        <trans-unit id="0ab61da13a6c10abbc480c4a1c0747cb3baa6877" translate="yes" xml:space="preserve">
          <source>Bit-level manipulation facilities.</source>
          <target state="translated">位级操纵设施。</target>
        </trans-unit>
        <trans-unit id="d9eff8dc4264242a1ae12f932821b47da28a5cc7" translate="yes" xml:space="preserve">
          <source>Bitwise Expressions</source>
          <target state="translated">位元表达式</target>
        </trans-unit>
        <trans-unit id="df5079d347ee1e4244353fecfac2f5edf6b28c3c" translate="yes" xml:space="preserve">
          <source>Bitwise adapter over an integral type range. Consumes the range elements bit by bit, from the least significant bit to the most significant bit.</source>
          <target state="translated">在积分型范围内进行位式转换。从最小的有效位到最大的有效位,逐位消耗范围内的元素。</target>
        </trans-unit>
        <trans-unit id="9b504c7d294e8d9e76232c80318479234720041d" translate="yes" xml:space="preserve">
          <source>Bitwise rotate &lt;code&gt;value&lt;/code&gt; left (&lt;code&gt;rol&lt;/code&gt;) or right (&lt;code&gt;ror&lt;/code&gt;) by &lt;code&gt;count&lt;/code&gt; bit positions.</source>
          <target state="translated">按位旋转 &lt;code&gt;value&lt;/code&gt; 左（ &lt;code&gt;rol&lt;/code&gt; 或）右（ &lt;code&gt;ror&lt;/code&gt; 通过） &lt;code&gt;count&lt;/code&gt; 位的位置。</target>
        </trans-unit>
        <trans-unit id="8ac6960d99f504b227c089027d841f4e9c385375" translate="yes" xml:space="preserve">
          <source>Block Elements</source>
          <target state="translated">块状元素</target>
        </trans-unit>
        <trans-unit id="44f23b923d4c118ace9751471e8a32d3ddca275e" translate="yes" xml:space="preserve">
          <source>Block Statement</source>
          <target state="translated">块状声明</target>
        </trans-unit>
        <trans-unit id="7358e14919f4d134af66ef6ad913b5a7d1139ac8" translate="yes" xml:space="preserve">
          <source>Block comments can span multiple lines, but do not nest.</source>
          <target state="translated">块状注释可以跨越多行,但不要嵌套。</target>
        </trans-unit>
        <trans-unit id="7fbe37dc50c1260fc0044f00cb0158d89f4c81af" translate="yes" xml:space="preserve">
          <source>Block of memory to serve as support for the allocator. Memory must be larger than two words and word-aligned.</source>
          <target state="translated">作为分配器支持的内存块。内存必须大于两个字,且字数对齐。</target>
        </trans-unit>
        <trans-unit id="ae0016c0671df573a3221620d651641a4c8dfdcc" translate="yes" xml:space="preserve">
          <source>Block previously obtained by a call to &lt;code&gt;allocate&lt;/code&gt; against this allocator (&lt;code&gt;null&lt;/code&gt; is allowed).</source>
          <target state="translated">块先前由呼叫获得 &lt;code&gt;allocate&lt;/code&gt; 针对该分配器（ &lt;code&gt;null&lt;/code&gt; 是允许的）。</target>
        </trans-unit>
        <trans-unit id="3ccb689779e89b6ac603e18c3e2082f3bf5ed78f" translate="yes" xml:space="preserve">
          <source>Block to deallocate.</source>
          <target state="translated">块进行重新分配。</target>
        </trans-unit>
        <trans-unit id="8117bd427e84d25123d525df198441ce5a262ba4" translate="yes" xml:space="preserve">
          <source>BlockStatement</source>
          <target state="translated">BlockStatement</target>
        </trans-unit>
        <trans-unit id="1c575a00b6c6472431006e69a67cda683c681cb6" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator</source>
          <target state="translated">BookkeepingAllocator</target>
        </trans-unit>
        <trans-unit id="642b597338266fa6f0fcfa51d03f6363e4f3af1d" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator &lt;strong id=&quot;bkalloc&quot;&gt;bkalloc&lt;/strong&gt;;</source>
          <target state="translated">簿记&lt;strong id=&quot;bkalloc&quot;&gt;分配器bkalloc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="807b1864fdb6805b8347ae2bc9a6c20e8e44cbff" translate="yes" xml:space="preserve">
          <source>Boolean Operations</source>
          <target state="translated">布尔运算</target>
        </trans-unit>
        <trans-unit id="9a7bb38540335c853c8483b5f52966e014c86be1" translate="yes" xml:space="preserve">
          <source>Boolean flag set to true while the runtime is initialized.</source>
          <target state="translated">当运行时被初始化时,设置为true的布尔标志。</target>
        </trans-unit>
        <trans-unit id="919ba0f721b82028f799116e9733b52309e726b3" translate="yes" xml:space="preserve">
          <source>Boolean options</source>
          <target state="translated">布尔型选项</target>
        </trans-unit>
        <trans-unit id="d62f48763e9c33e113d6e562d9814ef6092b4bb1" translate="yes" xml:space="preserve">
          <source>Boolean values are converted to &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401d2f1688a777ae0bc5be157d0d7272e332e127" translate="yes" xml:space="preserve">
          <source>Boolean values are printed as &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">布尔值打印为 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="105c6c86d7dd1b24e773395f017e7ee3c51ac8ff" translate="yes" xml:space="preserve">
          <source>Boost License 1.0</source>
          <target state="translated">Boost License 1.0</target>
        </trans-unit>
        <trans-unit id="e47a3386c7e74d205f749769164e9ef5c8040834" translate="yes" xml:space="preserve">
          <source>Boost Signals</source>
          <target state="translated">提升信号</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="5ba82cb02c720f3652f57a038e834a4bcc4c4c2f" translate="yes" xml:space="preserve">
          <source>Bopomofo Extended</source>
          <target state="translated">Bopomofo扩展版</target>
        </trans-unit>
        <trans-unit id="50d58ef5d04eba875c690e66a2db13e6043d0608" translate="yes" xml:space="preserve">
          <source>Borrowed</source>
          <target state="translated">Borrowed</target>
        </trans-unit>
        <trans-unit id="a5cd3b3f934540f0788541fb598aaaad1cf890f6" translate="yes" xml:space="preserve">
          <source>Borrowers are considered Owners if they are initialized from other than a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a58aa19fb67e0b5abe5d7641293ce8ffcd1a87d" translate="yes" xml:space="preserve">
          <source>Borrowers can be Owners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60c93251f61201f166e2379b490f975956e31c4" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Algebraic&lt;/code&gt; and &lt;code&gt;Variant&lt;/code&gt; share &lt;code&gt; VariantN&lt;/code&gt;'s interface. (See their respective documentations below.)</source>
          <target state="translated">这两个 &lt;code&gt;Algebraic&lt;/code&gt; 和 &lt;code&gt;Variant&lt;/code&gt; 份额 &lt;code&gt; VariantN&lt;/code&gt; 的接口。（请参阅下面的相应文档。）</target>
        </trans-unit>
        <trans-unit id="6535ded07930e3ddda0a1fe0ceda88dc9ce33dfa" translate="yes" xml:space="preserve">
          <source>Both backward and forward.</source>
          <target state="translated">无论是后退还是前进。</target>
        </trans-unit>
        <trans-unit id="b8f7ae57cc9f0d657e03c01e9e4d98ba216ba14c" translate="yes" xml:space="preserve">
          <source>Both immutable and const are</source>
          <target state="translated">不可变和常量都是</target>
        </trans-unit>
        <trans-unit id="e6a3f4fd036b065b2e797530c76e1c67c7c891ad" translate="yes" xml:space="preserve">
          <source>Both isThis() and isNested() should return true if function needs a dual-context pointer, otherwise if isThis() returns true, isNested() should return false.</source>
          <target state="translated">如果函数需要一个双上下文指针,isThis()和isNested()都应该返回true,否则如果isThis()返回true,isNested()应该返回false。</target>
        </trans-unit>
        <trans-unit id="bf39d0ca68e0898427724a5e452ff23fb939fa46" translate="yes" xml:space="preserve">
          <source>Both rewrites are tried. If only one compiles, that one is taken. If they both resolve to the same function, the first rewrite is done. If they resolve to different functions, the best matching one is used. If they both match the same, but are different functions, an ambiguity error results.</source>
          <target state="translated">两个重写都试过了。如果只有一个被编译,则采用那个。如果它们都解析为同一个函数,则采用第一个重写。如果它们解析的是不同的函数,则使用匹配度最好的一个。如果它们都是相同的匹配,但是是不同的函数,那么就会产生歧义错误。</target>
        </trans-unit>
        <trans-unit id="0cd32d8791a4b901dbb6cc0f81dd64df4c40048e" translate="yes" xml:space="preserve">
          <source>Both the test and the return expressions are lazily evaluated.</source>
          <target state="translated">测试和返回表达式都会被懒惰地评估。</target>
        </trans-unit>
        <trans-unit id="171f0c459de342d1f54dbc2ce2646745cc4ebc56" translate="yes" xml:space="preserve">
          <source>Both variants are implemented as instantiations of the template &lt;a href=&quot;#Base64Impl&quot;&gt;&lt;code&gt;Base64Impl&lt;/code&gt;&lt;/a&gt;. Most users will not need to use this template directly; however, it can be used to create customized Base64 encodings, such as one that omits padding characters, or one that is safe to embed inside a regular expression.</source>
          <target state="translated">这两个变体都实现为模板&lt;a href=&quot;#Base64Impl&quot;&gt; &lt;code&gt;Base64Impl&lt;/code&gt; 的&lt;/a&gt;实例。大多数用户将不需要直接使用此模板。但是，它可以用于创建自定义的Base64编码，例如一种省略填充字符的编码，或者一种可以安全地嵌入到正则表达式中的编码。</target>
        </trans-unit>
        <trans-unit id="00d1805af0d734eef9db29bbdcf7d82b5d3e7f04" translate="yes" xml:space="preserve">
          <source>Box Drawing</source>
          <target state="translated">框图</target>
        </trans-unit>
        <trans-unit id="b8d28f7a363659e9c4b08c47130a0d8f80f5c106" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(binaryFun!pred, Range) &lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range needle)</source>
          <target state="translated">BoyerMooreFinder！（binaryFun！pred，范围）&lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，范围）（范围针）</target>
        </trans-unit>
        <trans-unit id="2a76fd949603813a813972f30d7b0eeea91480d5" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(pred, InputRange) &lt;code&gt;needle&lt;/code&gt;</source>
          <target state="translated">BoyerMooreFinder！（pred，InputRange） &lt;code&gt;needle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e5a99860d31900d36389daa3fa718de031554d4" translate="yes" xml:space="preserve">
          <source>Brahmi</source>
          <target state="translated">Brahmi</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="754a680c22eb1f9ecca61fac281a3f23b7fb9d29" translate="yes" xml:space="preserve">
          <source>Braille Patterns</source>
          <target state="translated">盲文图案</target>
        </trans-unit>
        <trans-unit id="b2fcd02a50371b93a9e3654260745ee0af90cca2" translate="yes" xml:space="preserve">
          <source>Break Statement</source>
          <target state="translated">休息声明</target>
        </trans-unit>
        <trans-unit id="76820814ec6d343b49333e574d3bb22a7fa8676a" translate="yes" xml:space="preserve">
          <source>Break and Continue out of Foreach</source>
          <target state="translated">从Foreach中断开并继续</target>
        </trans-unit>
        <trans-unit id="0a89343c3ed16b2574554e37596ef4b4facffb9f" translate="yes" xml:space="preserve">
          <source>Breaking from a parallel foreach loop via a break, labeled break, labeled continue, return or goto statement throws a &lt;code&gt;ParallelForeachError&lt;/code&gt;.  In the case of non-random access ranges, parallel foreach buffers lazily to an array of size &lt;code&gt;workUnitSize&lt;/code&gt; before executing the parallel portion of the loop. The exception is that, if a parallel foreach is executed over a range returned by &lt;code&gt;asyncBuf&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt;, the copying is elided and the buffers are simply swapped. In this case &lt;code&gt;workUnitSize&lt;/code&gt; is ignored and the work unit size is set to the buffer size of &lt;code&gt;range&lt;/code&gt;.  A memory barrier is guaranteed to be executed on exit from the loop, so that results produced by all threads are visible in the calling thread.  &lt;b&gt;Exception Handling&lt;/b&gt;:  When at least one exception is thrown from inside a parallel foreach loop, the submission of additional &lt;code&gt;Task&lt;/code&gt; objects is terminated as soon as possible, in a non-deterministic manner. All executing or enqueued work units are allowed to complete. Then, all exceptions that were thrown by any work unit are chained using &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The order of the exception chaining is non-deterministic.</source>
          <target state="translated">通过中断，标记为break，标记为continue，return或goto的语句从并行foreach循环中断，将抛出 &lt;code&gt;ParallelForeachError&lt;/code&gt; 。对于非随机访问范围，在执行循环的并行部分之前，将并行foreach缓冲区延迟为一个大小为 &lt;code&gt;workUnitSize&lt;/code&gt; 的数组。唯一的例外是，如果在 &lt;code&gt;asyncBuf&lt;/code&gt; 或 &lt;code&gt;map&lt;/code&gt; 返回的范围内执行了并行的foreach ，则复制被忽略，缓冲区被简单地交换。在这种情况下，将忽略 &lt;code&gt;workUnitSize&lt;/code&gt; 并将工作单位大小设置为 &lt;code&gt;range&lt;/code&gt; 的缓冲区大小。确保在退出循环时执行内存屏障，以便所有线程产生的结果在调用线程中可见。 &lt;b&gt;异常处理&lt;/b&gt;：当从并行的foreach循环内引发至少一个异常时，其他 &lt;code&gt;Task&lt;/code&gt; 对象的提交将以不确定性方式尽快终止。允许所有执行或排队的工作单元完成。然后，使用 &lt;code&gt;Throwable.next&lt;/code&gt; 将所有工作单元抛出的所有异常链接在一起并重新抛出。异常链接的顺序是不确定的。</target>
        </trans-unit>
        <trans-unit id="9d3201041918654fbf75089e070856aa79ebc523" translate="yes" xml:space="preserve">
          <source>Breaks x into an integral part and a fractional part, each of which has the same sign as x. The integral part is stored in i.</source>
          <target state="translated">将x分解为一个积分部分和一个小数部分,每个小数部分都与x具有相同的符号。</target>
        </trans-unit>
        <trans-unit id="4324d0ed28641cb58b631967da3876548c2a70ef" translate="yes" xml:space="preserve">
          <source>Bring leaves to common type.</source>
          <target state="translated">把叶子带到普通型。</target>
        </trans-unit>
        <trans-unit id="399d0f0935a4fd7e2adf0462c69b1578bb0496b9" translate="yes" xml:space="preserve">
          <source>Buffer &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">缓冲 &lt;code&gt;buffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="535393fe6f448d36dc112ebfa2c4ec8acdaebcaa" translate="yes" xml:space="preserve">
          <source>Buffer to receive error messages in, must be at least CURL_ERROR_SIZE bytes big. If this is not used, error messages go to stderr instead:</source>
          <target state="translated">接收错误信息的缓冲区,必须至少是CURL_ERROR_SIZE字节大。如果没有使用这个选项,错误信息就会进入stderr。</target>
        </trans-unit>
        <trans-unit id="303f92df69f201e44e4c0ca1825e2e280d1f0c91" translate="yes" xml:space="preserve">
          <source>Buffer to structure as a free list. If &lt;code&gt;ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, the buffer is assumed to be allocated by &lt;code&gt;parent&lt;/code&gt; and will be freed in the destructor.</source>
          <target state="translated">缓冲区构造为自由列表。如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 不是 &lt;code&gt;NullAllocator&lt;/code&gt; ，则假定该缓冲区由 &lt;code&gt;parent&lt;/code&gt; 分配，并将在析构函数中释放。</target>
        </trans-unit>
        <trans-unit id="c05d2a8029044c4c4e57f66bbd40a3eac5b198a2" translate="yes" xml:space="preserve">
          <source>Buffer to write the escaped path to</source>
          <target state="translated">写入转义路径的缓冲区</target>
        </trans-unit>
        <trans-unit id="c083c9d2a3d468528bb5dd1cebdd4400312c43c2" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is enlarged if necessary, then set to the slice exactly containing the line.</source>
          <target state="translated">buf在必要时被放大,然后设置为包含行的片断。</target>
        </trans-unit>
        <trans-unit id="7ab4ac68db7c219824ba8029fe0a1e0d5e5c01c5" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is resized as necessary.</source>
          <target state="translated">缓冲区用于存储产生的行数据。buf根据需要调整大小。</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="80432fb4403119d7fa36b39cc0581f74363b7507" translate="yes" xml:space="preserve">
          <source>Bugs:</source>
          <target state="translated">Bugs:</target>
        </trans-unit>
        <trans-unit id="e543d61d1db526d2c201a9150a8eeb4f6a08a7bb" translate="yes" xml:space="preserve">
          <source>Bugzilla 2137</source>
          <target state="translated">Bugzilla 2137</target>
        </trans-unit>
        <trans-unit id="d957a3ddca24bb7ba3415ed5d23a475def657008" translate="yes" xml:space="preserve">
          <source>Bugzilla 592</source>
          <target state="translated">Bugzilla 592</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="e4ce8210e89bb0abea338092bae131b54bcd5ff1" translate="yes" xml:space="preserve">
          <source>Build __xopCmp for TypeInfo_Struct static bool __xopCmp(ref const S p, ref const S q) { return p.opCmp(q); }</source>
          <target state="translated">为TypeInfo_Struct构建__xopCmp static bool __xopCmp(ref const S p,ref const S q){return p.opCmp(q);}。</target>
        </trans-unit>
        <trans-unit id="f3d924ea22f0f293cf6f3ebfcd84f23fb87ecdc9" translate="yes" xml:space="preserve">
          <source>Build __xopEquals for TypeInfo_Struct static bool __xopEquals(ref const S p, ref const S q) { return p == q; }</source>
          <target state="translated">为TypeInfo_Struct构建__xopEquals static bool __xopEquals(ref const S p,ref const S q){return p ==q;}。</target>
        </trans-unit>
        <trans-unit id="edd21187462263909c4e5bccda552a4211a055ce" translate="yes" xml:space="preserve">
          <source>Build _xtoHash for non-bitwise hashing static hash_t xtoHash(ref const S p) nothrow @trusted;</source>
          <target state="translated">建立 _xtoHash 来进行非位元哈希静态哈希_t xtoHash(ref const S p)nothrow @trusted;</target>
        </trans-unit>
        <trans-unit id="02755102e393b0ceee36f18acf3cd4f3a97f903b" translate="yes" xml:space="preserve">
          <source>Build a list out of the null-terminated argument list.</source>
          <target state="translated">从空端参数列表中建立一个列表。</target>
        </trans-unit>
        <trans-unit id="8926cd9ddf0e4003036d0a204fc3589b6f556c48" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to copy the value of e into.</source>
          <target state="translated">建立一个临时变量来复制e的值。</target>
        </trans-unit>
        <trans-unit id="7126b83ecb05ac49ee0d9a4bfd7fa2c9443a5db6" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to extract e's evaluation, if e is not trivial.</source>
          <target state="translated">建立一个临时变量来提取e的评价,如果e不是琐碎的。</target>
        </trans-unit>
        <trans-unit id="5f0947173a3022e64a66ace8a16da7bd0953de0d" translate="yes" xml:space="preserve">
          <source>Build opAssign for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;struct&lt;/code&gt; 构建opAssign 。</target>
        </trans-unit>
        <trans-unit id="bd267126bb39bb406bc3a0c8c87a8165b825fa2e" translate="yes" xml:space="preserve">
          <source>Build opEquals for struct. const bool opEquals(const S s) { ... }</source>
          <target state="translated">const bool opEquals(const S s){...}</target>
        </trans-unit>
        <trans-unit id="6dd999e7845d7581c295f9165da47448ffe76f29" translate="yes" xml:space="preserve">
          <source>Build scoped variables and reference-counted types.</source>
          <target state="translated">建立范围变量和引用计数类型。</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="e777aa2ee0a1277f1927115dd56047ae99acaf63" translate="yes" xml:space="preserve">
          <source>Building Blocks</source>
          <target state="translated">构建模块</target>
        </trans-unit>
        <trans-unit id="3f334616286956fcb816046552d7f9bf1acd6341" translate="yes" xml:space="preserve">
          <source>Building block functions, they translate to a single x87 instruction.</source>
          <target state="translated">构件函数,它们转化为一条x87指令。</target>
        </trans-unit>
        <trans-unit id="5d7f3504504044d481b2cb93792c53ee903721c6" translate="yes" xml:space="preserve">
          <source>Building blocks</source>
          <target state="translated">构建模块</target>
        </trans-unit>
        <trans-unit id="39c609d88be88f825074ec54ab9e12948dadee89" translate="yes" xml:space="preserve">
          <source>Building contract support into the language makes for:</source>
          <target state="translated">在语言中建立合同支持,使。</target>
        </trans-unit>
        <trans-unit id="e5d9a44c338285ef0b2cf2cbe5abd6d13da4bd15" translate="yes" xml:space="preserve">
          <source>Builds a &lt;code&gt;Trie&lt;/code&gt; with typically optimal speed-size trade-off and wraps it into a delegate of the following type: &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt;.</source>
          <target state="translated">构建通常具有最佳速度大小权衡的 &lt;code&gt;Trie&lt;/code&gt; ，并将其包装为以下类型的 &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt; ：bool Representative（dchar ch）。</target>
        </trans-unit>
        <trans-unit id="0ddd9b5faf4e195f0b71766badf13e8513590fa7" translate="yes" xml:space="preserve">
          <source>Builds an index of the top elements of a range.</source>
          <target state="translated">建立一个范围内顶级元素的索引。</target>
        </trans-unit>
        <trans-unit id="8ac6cb76b75c220d2577581173ee0a6d992a81d1" translate="yes" xml:space="preserve">
          <source>Builds an object. Usually this is invoked indirectly by using the &lt;a href=&quot;#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">建立一个对象。通常，这是通过使用&lt;a href=&quot;#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;函数间接调用的。</target>
        </trans-unit>
        <trans-unit id="12e943a67bf614d76638933b655f13c408534085" translate="yes" xml:space="preserve">
          <source>Built-in mathematical intrinsics.</source>
          <target state="translated">内置数学本体。</target>
        </trans-unit>
        <trans-unit id="393ada6b17ede7fe1acbc7b82bec2f4e8c1c04b5" translate="yes" xml:space="preserve">
          <source>Built-in postfix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to lambda invocations as follows: &lt;code&gt;expr++&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt;, and &lt;code&gt;expr--&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt;. Therefore, the result of postfix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is an rvalue just before the side effect has been effected.</source>
          <target state="translated">内置postfix一元表达式 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的评估方式如下：将它们降低（重写）为lambda调用： &lt;code&gt;expr++&lt;/code&gt; 变为 &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt; ，而 &lt;code&gt;expr--&lt;/code&gt; 变为 &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt; 。因此，后缀 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的结果是在产生副作用之前的右值。</target>
        </trans-unit>
        <trans-unit id="140a63c50a697c2475ba756ea1b637cf7b49226e" translate="yes" xml:space="preserve">
          <source>Built-in prefix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to assignments as follows: &lt;code&gt;++expr&lt;/code&gt; becomes &lt;code&gt;((expr) += 1)&lt;/code&gt;, and &lt;code&gt;--expr&lt;/code&gt; becomes &lt;code&gt;((expr) -= 1)&lt;/code&gt;. Therefore, the result of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is the lvalue after the side effect has been effected.</source>
          <target state="translated">内置前缀一元表达式 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 被评价为，如果降低（重写）到分配如下： &lt;code&gt;++expr&lt;/code&gt; 变为 &lt;code&gt;((expr) += 1)&lt;/code&gt; ，和 &lt;code&gt;--expr&lt;/code&gt; 变为 &lt;code&gt;((expr) -= 1)&lt;/code&gt; 。因此，前缀 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的结果是副作用产生后的左值。</target>
        </trans-unit>
        <trans-unit id="f4ef630934a7f1267240a157c0264f348c4dadf3" translate="yes" xml:space="preserve">
          <source>Built-in threading (e.g. &lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt;&lt;code&gt;core.thread&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">内置线程（例如&lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt; &lt;code&gt;core.thread&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="738019c18e7d3c678f51b2d2bb9de596778335f1" translate="yes" xml:space="preserve">
          <source>Builtin SIMD intrinsics</source>
          <target state="translated">内建SIMD固有功能</target>
        </trans-unit>
        <trans-unit id="809be9a33e4a381b76b3f2392efbde90e7cac474" translate="yes" xml:space="preserve">
          <source>Builtin mathematical intrinsics</source>
          <target state="translated">内置的数学本质</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="aee13f098c3fbc98d67893709d2f60dddc7f25f1" translate="yes" xml:space="preserve">
          <source>But the precision of &lt;code&gt;StopWatch&lt;/code&gt; differs from system to system. It is impossible to for it to be the same from system to system since the precision of the system clock varies from system to system, and other system-dependent and situation-dependent stuff (such as the overhead of a context switch between threads) can also affect &lt;code&gt;StopWatch&lt;/code&gt;'s accuracy.</source>
          <target state="translated">但是 &lt;code&gt;StopWatch&lt;/code&gt; 的精度因系统而异。由于系统时钟的精度因系统而异，因此不可能在系统之间保持相同，并且其他与系统有关和与情况有关的内容（例如线程之间的上下文切换的开销）可以也影响 &lt;code&gt;StopWatch&lt;/code&gt; 的准确性。</target>
        </trans-unit>
        <trans-unit id="768690cb6415ff721efd279bcb993c49ad663947" translate="yes" xml:space="preserve">
          <source>But, if one context is indirectly accessible from other context, it is allowed.</source>
          <target state="translated">但是,如果一个上下文可以从其他上下文间接访问,是允许的。</target>
        </trans-unit>
        <trans-unit id="bbd7cb5dd010de18293afcbf1ef490f5cd753c28" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because these names have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. Using all lower case package and module names will avoid or minimize problems when moving projects between dissimilar file systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45921646718dbb6e00896e143e95be14de95c04" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because those names can have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. All lower case package and module names will minimize problems moving projects between dissimilar file systems.</source>
          <target state="translated">按照惯例,包名和模块名都是小写的,这是因为这些名称与操作系统的目录和文件名有一一对应的关系,而许多文件系统不区分大小写。这是因为这些名称可以与操作系统的目录和文件名有一对一的对应关系,而许多文件系统是不区分大小写的。所有小写的包名和模块名可以最大限度地减少在不同文件系统之间移动项目的问题。</target>
        </trans-unit>
        <trans-unit id="2f986e628567a153d5373360f16e912e237bc63a" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;StoppingPolicy&lt;/code&gt; is set to &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;StoppingPolicy&lt;/code&gt; 设置为 &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c8a76e2827ccb54962a847a022109fb17e84070" translate="yes" xml:space="preserve">
          <source>By default a request has it's &quot;User-Agent&quot; field set to &lt;a href=&quot;#%20defaultUserAgent&quot;&gt;&lt;code&gt; defaultUserAgent&lt;/code&gt;&lt;/a&gt; even if &lt;code&gt;setUserAgent&lt;/code&gt; was never called. Pass an empty string to suppress the &quot;User-Agent&quot; field altogether.</source>
          <target state="translated">默认情况下，即使从未调用过 &lt;code&gt;setUserAgent&lt;/code&gt; ，请求的&amp;ldquo; User-Agent&amp;rdquo;字段仍设置为&lt;a href=&quot;#%20defaultUserAgent&quot;&gt; &lt;code&gt; defaultUserAgent&lt;/code&gt; &lt;/a&gt;。传递一个空字符串以完全禁止&amp;ldquo; User-Agent&amp;rdquo;字段。</target>
        </trans-unit>
        <trans-unit id="478b0d271a29c1d5ae05535cd04bb959cef13353" translate="yes" xml:space="preserve">
          <source>By default an &lt;code&gt;Error&lt;/code&gt; will be thrown.</source>
          <target state="translated">默认情况下，将引发 &lt;code&gt;Error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6de89d666cfcbf1e2d91df4f90cb3d04defa9a2" translate="yes" xml:space="preserve">
          <source>By default four &lt;code&gt;Logger&lt;/code&gt; implementations are given. The &lt;code&gt;FileLogger&lt;/code&gt; logs data to files. It can also be used to log to &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; as these devices are files as well. A &lt;code&gt;Logger&lt;/code&gt; that logs to &lt;code&gt;stdout&lt;/code&gt; can therefore be created by &lt;code&gt;new FileLogger(stdout)&lt;/code&gt;. The &lt;code&gt;MultiLogger&lt;/code&gt; is basically an associative array of &lt;code&gt;string&lt;/code&gt;s to &lt;code&gt;Logger&lt;/code&gt;. It propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;ArrayLogger&lt;/code&gt; contains an array of &lt;code&gt;Logger&lt;/code&gt; and also propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;NullLogger&lt;/code&gt; does not do anything. It will never log a message and will never throw on a log call with &lt;code&gt;LogLevel&lt;/code&gt;&lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">默认情况下，给出了四个 &lt;code&gt;Logger&lt;/code&gt; 实现。该 &lt;code&gt;FileLogger&lt;/code&gt; 记录的数据文件。由于这些设备也是文件，因此它也可以用于登录到 &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 。甲 &lt;code&gt;Logger&lt;/code&gt; 即日志 &lt;code&gt;stdout&lt;/code&gt; ，因此可以通过创建 &lt;code&gt;new FileLogger(stdout)&lt;/code&gt; 。所述 &lt;code&gt;MultiLogger&lt;/code&gt; 基本上是一个关联数组 &lt;code&gt;string&lt;/code&gt; s到 &lt;code&gt;Logger&lt;/code&gt; 。它将日志调用传播到其存储的 &lt;code&gt;Logger&lt;/code&gt; 。所述 &lt;code&gt;ArrayLogger&lt;/code&gt; 包含的阵列 &lt;code&gt;Logger&lt;/code&gt; ，并且还传播日志调用到其存储的 &lt;code&gt;Logger&lt;/code&gt; 。的 &lt;code&gt;NullLogger&lt;/code&gt; 不执行任何操作。它永远不会记录消息，也永远不会引发 &lt;code&gt;LogLevel&lt;/code&gt; &lt;code&gt;error&lt;/code&gt; 的日志调用。</target>
        </trans-unit>
        <trans-unit id="4ef4ca6979d9539ab9bd7cee842dec5c1148639b" translate="yes" xml:space="preserve">
          <source>By default it is conservatively assumed that allocated memory may be &lt;code&gt;cast&lt;/code&gt; to &lt;code&gt;shared&lt;/code&gt;, passed across threads, and deallocated in a different thread than the one that allocated it. If that's not the case, there are two options. First, &lt;code&gt;immutableShared&lt;/code&gt; means the memory is allocated for &lt;code&gt;immutable&lt;/code&gt; data and will be deallocated in the same thread it was allocated in. Second, &lt;code&gt;threadLocal&lt;/code&gt; means the memory is not to be shared across threads at all. The two flags cannot be simultaneously present.</source>
          <target state="translated">默认情况下，保守地假设分配的内存可以 &lt;code&gt;cast&lt;/code&gt; 为 &lt;code&gt;shared&lt;/code&gt; ，跨线程传递，并在与分配内存的线程不同的线程中释放。如果不是这种情况，则有两个选择。首先， &lt;code&gt;immutableShared&lt;/code&gt; 表示为 &lt;code&gt;immutable&lt;/code&gt; 数据分配了内存，并将在分配该内存的同一线程中将其释放。其次， &lt;code&gt;threadLocal&lt;/code&gt; 表示根本不跨线程共享内存。这两个标志不能同时出现。</target>
        </trans-unit>
        <trans-unit id="6f5b3a15a485cfab1e5a75e1fa6e376cde7fb92a" translate="yes" xml:space="preserve">
          <source>By default options are case-insensitive. You can change that behavior by passing &lt;code&gt;getopt&lt;/code&gt; the &lt;code&gt;caseSensitive&lt;/code&gt; directive like this:</source>
          <target state="translated">默认情况下，选项不区分大小写。你可以通过改变这种行为 &lt;code&gt;getopt&lt;/code&gt; 的 &lt;code&gt;caseSensitive&lt;/code&gt; 指令是这样的：</target>
        </trans-unit>
        <trans-unit id="dbec3e9c45747840b24455eb80ba1df0a750e9ae" translate="yes" xml:space="preserve">
          <source>By default the garbage collector uses all available CPU cores to mark the heap.</source>
          <target state="translated">默认情况下,垃圾收集器使用所有可用的CPU核来标记堆。</target>
        </trans-unit>
        <trans-unit id="b8fa023c2d92a0d81832e9bd89d175d5927659d9" translate="yes" xml:space="preserve">
          <source>By default, GC options can only be passed on the command line of the program to run, e.g.</source>
          <target state="translated">默认情况下,GC选项只能在程序运行的命令行中传递,如</target>
        </trans-unit>
        <trans-unit id="8b24a9b44aee4758b90d689774f561a91ccfd9f7" translate="yes" xml:space="preserve">
          <source>By default, a string literal is typed as a dynamic array, but the element count is known at compile time. So all string literals can be implicitly converted to static array types.</source>
          <target state="translated">默认情况下,字符串文字是作为动态数组类型的,但元素数在编译时是已知的。所以,所有的字符串文字都可以隐式转换为静态数组类型。</target>
        </trans-unit>
        <trans-unit id="8bdaa68e3c22ff7ff0194a0456f12cfccad4e7b3" translate="yes" xml:space="preserve">
          <source>By default, an array literal is typed as a dynamic array, but the element count is known at compile time. So all array literals can be implicitly converted to static array types.</source>
          <target state="translated">默认情况下,一个数组的文字是以动态数组的方式进行类型化的,但元素数在编译时是已知的。所以,所有的数组文字都可以隐式转换为静态数组类型。</target>
        </trans-unit>
        <trans-unit id="22091b5b2cb326fb7704d38d801e2ea343fe0a4b" translate="yes" xml:space="preserve">
          <source>By default, imports are</source>
          <target state="translated">默认情况下,进口是</target>
        </trans-unit>
        <trans-unit id="f143feea6dee31aa56bf9053dddf3e0e772b7f34" translate="yes" xml:space="preserve">
          <source>By default, non-immutable global declarations reside in thread local storage. When a global variable is marked with the &lt;code&gt;__gshared&lt;/code&gt; attribute, its value is shared across all threads.</source>
          <target state="translated">默认情况下，不可更改的全局声明驻留在线程本地存储中。当使用 &lt;code&gt;__gshared&lt;/code&gt; 属性标记全局变量时，其值将在所有线程之间共享。</target>
        </trans-unit>
        <trans-unit id="aad3d8313e40930c344804ce8ccc20bf40a3e89a" translate="yes" xml:space="preserve">
          <source>By default, parameters take rvalue arguments. A ref parameter takes an lvalue argument, so changes to its value will operate on the caller's argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079ae70c5ecf861c3729c19e224c7956b1bb4ed1" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;#execute&quot;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt; functions will capture child processes' both stdout and stderr. This can be undesirable if the standard output is to be processed or otherwise used by the invoking program, as &lt;code&gt;execute&lt;/code&gt;'s result would then contain a mix of output and warning/error messages.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;#execute&quot;&gt; &lt;code&gt;execute&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt;函数将捕获子进程的stdout和stderr。如果要处理标准输出或调用程序以其他方式使用标准输出，则这可能是不希望的，因为 &lt;code&gt;execute&lt;/code&gt; 的结果将包含输出和警告/错误消息的混合。</target>
        </trans-unit>
        <trans-unit id="5c5dc33ccdd6fb02e11d57deb9c037003d388703" translate="yes" xml:space="preserve">
          <source>By default, the above will print:</source>
          <target state="translated">默认情况下,上述内容会被打印出来。</target>
        </trans-unit>
        <trans-unit id="2a431b7902a6f8a61040ea86e57ea9fd88c07b45" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the environment of the parent process, along with any additional variables specified in the &lt;code&gt;env&lt;/code&gt; parameter. If the same variable exists in both the parent's environment and in &lt;code&gt;env&lt;/code&gt;, the latter takes precedence.</source>
          <target state="translated">默认情况下，子进程会继承父进程的环境以及 &lt;code&gt;env&lt;/code&gt; 参数中指定的任何其他变量。如果在父级环境和 &lt;code&gt;env&lt;/code&gt; 中都存在相同的变量，则后者优先。</target>
        </trans-unit>
        <trans-unit id="00f97c90e4779d49bd0154dcbe3ccd270b7c1a5c" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the parent's environment, and any environment variables passed to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; will be added to it. If this flag is set, the only variables in the child process' environment will be those given to spawnProcess.</source>
          <target state="translated">默认情况下，子进程会继承父进程的环境，并且传递给&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; 的&lt;/a&gt;所有环境变量都将添加到其中。如果设置了此标志，则子进程环境中唯一的变量将是赋予spawnProcess的变量。</target>
        </trans-unit>
        <trans-unit id="164f65e6c4e1ffea6984f3be9b15c6fd4fcd5bd7" translate="yes" xml:space="preserve">
          <source>By default, the return type is time_t (which is normally an alias for int on 32-bit systems and long on 64-bit systems), but if a different size is required than either int or long can be passed as a template argument to get the desired size.</source>
          <target state="translated">默认情况下,返回类型是time_t(通常在32位系统上是int的别名,在64位系统上是long的别名),但如果需要不同的大小,可以将int或long作为模板参数传递,以获得所需的大小。</target>
        </trans-unit>
        <trans-unit id="887970dcbfc9d8811c8813f736813ed286b7d258" translate="yes" xml:space="preserve">
          <source>By default, the rounding mode is roundToNearest and all hardware exceptions are disabled. For most applications, debugging is easier if the</source>
          <target state="translated">默认情况下,四舍五入模式是roundToNearest,所有硬件异常都被禁用。对于大多数应用程序来说,如果在应用程序中使用</target>
        </trans-unit>
        <trans-unit id="6e33332413c374faf23d6382e0a46b9fcaf1aadb" translate="yes" xml:space="preserve">
          <source>By definition, empty ranges are matched fully and if &lt;code&gt;needles&lt;/code&gt; contains an empty range, &lt;code&gt;skipOver&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">根据定义，空范围将完全匹配，并且如果 &lt;code&gt;needles&lt;/code&gt; 包含空范围，则 &lt;code&gt;skipOver&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10ce83358e38997bfd068876bacbbbb4077fd36b" translate="yes" xml:space="preserve">
          <source>By definition, if a pre contract fails, then the function received bad parameters. If a post contract fails, then there is a bug in the function. In either case, an &lt;code&gt;assert&lt;/code&gt; statement within the corresponding &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; block will throw an &lt;code&gt;AssertError&lt;/code&gt;.</source>
          <target state="translated">根据定义，如果预合同失败，则该函数接收到错误的参数。如果后期合同失败，则该函数中存在错误。无论哪种情况，相应 &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;out&lt;/code&gt; 块中的 &lt;code&gt;assert&lt;/code&gt; 语句都将引发 &lt;code&gt;AssertError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb96c2ff58da640b614e1d83a03d1ae961343b00" translate="yes" xml:space="preserve">
          <source>By fixing &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789&lt;/a&gt; opEquals is changed to be never implicitly generated. Now, struct objects comparison s1 == s2 is translated to: s1.tupleof == s2.tupleof to calculate structural equality. See EqualExp.op_overload.</source>
          <target state="translated">通过修复&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789，opEquals&lt;/a&gt;更改为从不隐式生成。现在，将结构对象比较s1 == s2转换为：s1.tupleof == s2.tupleof以计算结构相等性。请参阅EqualExp.op_overload。</target>
        </trans-unit>
        <trans-unit id="aac8d772d9fb45f1ebe981cf3bff581d81f0a9a1" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;std_utf#byUTF&quot;&gt;&lt;code&gt;std.utf.byUTF&lt;/code&gt;&lt;/a&gt; and its aliases, GC allocations via auto-decoding and thrown exceptions can be avoided, making &lt;code&gt;icmp&lt;/code&gt;&lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt;.</source>
          <target state="translated">通过使用&lt;a href=&quot;std_utf#byUTF&quot;&gt; &lt;code&gt;std.utf.byUTF&lt;/code&gt; &lt;/a&gt;及其别名，可以避免通过自动解码和引发异常来进行GC分配，从而使 &lt;code&gt;icmp&lt;/code&gt; &lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc291c2891b81ab141f345fa0230adb20fd10cd9" translate="yes" xml:space="preserve">
          <source>Byte order endianness.</source>
          <target state="translated">字节顺序endianness。</target>
        </trans-unit>
        <trans-unit id="1eb54b97f13d87edcd6a934d982b6f81fb1b387f" translate="yes" xml:space="preserve">
          <source>Byte order, least significant first</source>
          <target state="translated">字节顺序,最不重要的第一个</target>
        </trans-unit>
        <trans-unit id="b59f4e1ab4662646945739f875a2dc8274ccd34b" translate="yes" xml:space="preserve">
          <source>Byte order, most significant first</source>
          <target state="translated">字节顺序,最重要的第一个</target>
        </trans-unit>
        <trans-unit id="0c1f86b6eef786b75f48b5164472c5f379f29825" translate="yes" xml:space="preserve">
          <source>Byte value in hexadecimal, where</source>
          <target state="translated">十六进制的字节值,其中</target>
        </trans-unit>
        <trans-unit id="f4e5cf625ea1bf16e64b237498429dc72e94863d" translate="yes" xml:space="preserve">
          <source>Byte value in octal.</source>
          <target state="translated">字节值以八进制表示。</target>
        </trans-unit>
        <trans-unit id="a58fed109fdbc425c9e3e299c4f472aa1e81b9e2" translate="yes" xml:space="preserve">
          <source>Bytes (not items) to be allocated for the free list. Memory will be allocated during construction and deallocated in the destructor.</source>
          <target state="translated">要分配给自由列表的字节(不是项目)。内存将在构造过程中分配,并在反构造器中重新分配。</target>
        </trans-unit>
        <trans-unit id="b2e625cfca365b6f5ed6d88821a2c881a6679253" translate="yes" xml:space="preserve">
          <source>Bytes to allocate</source>
          <target state="translated">要分配的字节数</target>
        </trans-unit>
        <trans-unit id="2eadc64c1cdbc5d6ca752a0b38f5f0a02d05c4b1" translate="yes" xml:space="preserve">
          <source>Bytes to allocate using &lt;code&gt;ParentAllocator&lt;/code&gt;. This constructor is only defined If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;parent.allocate(n)&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the region will be initialized as empty (correctly initialized but unable to allocate).</source>
          <target state="translated">使用 &lt;code&gt;ParentAllocator&lt;/code&gt; 分配的字节。仅当 &lt;code&gt;ParentAllocator&lt;/code&gt; 与&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt;不同时才定义此构造函数。如果 &lt;code&gt;parent.allocate(n)&lt;/code&gt; 返回 &lt;code&gt;null&lt;/code&gt; ，则该区域将被初始化为空（正确初始化但无法分配）。</target>
        </trans-unit>
        <trans-unit id="d3fc47eb5e867c1a90c1c6140022201511e39c13" translate="yes" xml:space="preserve">
          <source>Byzantine Musical Symbols</source>
          <target state="translated">拜占庭音乐符号</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="91ab2886a8945715f467ad2616dd5309295ba114" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">&amp;ccedil; &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="922a6aa3cb89e34ea72fe9d27effc2df259df392" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;create&lt;/code&gt;</source>
          <target state="translated">C &lt;code&gt;create&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9652018eda95d6aa3dab8e093571b39cf52c2264" translate="yes" xml:space="preserve">
          <source>C ABI</source>
          <target state="translated">C ABI</target>
        </trans-unit>
        <trans-unit id="f824a58327e609cd9fdba23fe1a3c84c364898ea" translate="yes" xml:space="preserve">
          <source>C code can correspondingly call D functions, if the D functions use an attribute that is compatible with the C compiler, most likely the extern (C):</source>
          <target state="translated">C代码可以相应地调用D函数,如果D函数使用了与C编译器兼容的属性,很可能是extern(C)。</target>
        </trans-unit>
        <trans-unit id="0ffb7f8837c1a11eeb25850dd4e1e4ef9b573509" translate="yes" xml:space="preserve">
          <source>C code explicitly manages memory with calls to &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc()&lt;/a&gt; and &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free()&lt;/a&gt;. D allocates memory using the D garbage collector, so no explicit frees are necessary.</source>
          <target state="translated">C代码通过调用&lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc（）&lt;/a&gt;和&lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free（）&lt;/a&gt;显式管理内存。D使用D垃圾回收器分配内存，因此不需要显式的释放。</target>
        </trans-unit>
        <trans-unit id="d221b852c9ebec0058ed069c0351edaaeb33622d" translate="yes" xml:space="preserve">
          <source>C code often adjusts the alignment and packing of struct members with a command line switch or with various implementation specific #pragmas. D supports explicit alignment attributes that correspond to the C compiler's rules. Check what alignment the C code is using, and explicitly set it for the D struct declaration.</source>
          <target state="translated">C代码经常通过命令行开关或各种特定的实现#语法来调整结构成员的对齐和打包。D支持显式的对齐属性,对应C编译器的规则。检查C代码使用的是什么对齐方式,并对D结构声明进行显式设置。</target>
        </trans-unit>
        <trans-unit id="ad0081e0fe0dd4d8c8faa110d448e18b099251c6" translate="yes" xml:space="preserve">
          <source>C function calling conventions are specified by:</source>
          <target state="translated">C函数的调用惯例由以下规定。</target>
        </trans-unit>
        <trans-unit id="7bbdeb583f7af40df326e5ef45b5341310bfa3a8" translate="yes" xml:space="preserve">
          <source>C functions can be called directly from D. There is no need for wrapper functions, argument swizzling, and the C functions do not need to be put into a separate DLL.</source>
          <target state="translated">C函数可以直接从D中调用,不需要封装函数、参数swizzling,也不需要将C函数放入单独的DLL中。</target>
        </trans-unit>
        <trans-unit id="391732c6d45f595037ed6d3acf61093990d2af4d" translate="yes" xml:space="preserve">
          <source>C functions cannot be overloaded with another C function with the same name.</source>
          <target state="translated">C函数不能与另一个同名的C函数重载。</target>
        </trans-unit>
        <trans-unit id="5f547f273af63b8119db89b56d4a8680c878d370" translate="yes" xml:space="preserve">
          <source>C globals can be accessed directly from D. C globals have the C naming convention, and so must be in an &lt;code&gt;extern (C)&lt;/code&gt; block. Use the &lt;code&gt;extern&lt;/code&gt; storage class to indicate that the global is allocated in the C code, not the D code. C globals default to being in global, not thread local, storage. To reference global storage from D, use the &lt;code&gt;__gshared&lt;/code&gt; storage class.</source>
          <target state="translated">可以从D直接访问C全局变量。C全局变量具有C命名约定，因此必须位于 &lt;code&gt;extern (C)&lt;/code&gt; 块中。使用 &lt;code&gt;extern&lt;/code&gt; 存储类指示全局变量是在C代码而不是D代码中分配的。C全局变量默认为全局存储，而不是线程本地存储。要从D引用全局存储，请使用 &lt;code&gt;__gshared&lt;/code&gt; 存储类。</target>
        </trans-unit>
        <trans-unit id="088f42af395914ff1b11b211001ff8dc3bfb47de" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.initialize, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.initialize的C接口,返回1/0而不是bool。</target>
        </trans-unit>
        <trans-unit id="dc4b969769a12fb03185e79820cbdb1188eba5a6" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.loadLibrary</source>
          <target state="translated">Runtime.loadLibrary的C接口</target>
        </trans-unit>
        <trans-unit id="1ba4ae2523a2983e2479e8220f1eed45cabbda41" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.terminate, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.terminate的C接口,返回1/0而不是bool。</target>
        </trans-unit>
        <trans-unit id="8ebac48238568ab95c4c5ad69ed5cd780269c53c" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.unloadLibrary, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.unloadLibrary的C接口,返回1/0而不是bool。</target>
        </trans-unit>
        <trans-unit id="86cf735b5a9e30aaa5f0fee060cea7d39ebc4f60" translate="yes" xml:space="preserve">
          <source>C library routines. See callclib().</source>
          <target state="translated">C库例程。参见 callclib()。</target>
        </trans-unit>
        <trans-unit id="c1ff5ead3c46826c14b71159d580aef25ffbf060" translate="yes" xml:space="preserve">
          <source>C name mangling is done by adding a prefix on some platforms.</source>
          <target state="translated">在一些平台上,C名的混搭是通过添加前缀来实现的。</target>
        </trans-unit>
        <trans-unit id="126f7b78af09df06aa9df51a74fef4005eae1de9" translate="yes" xml:space="preserve">
          <source>C style variadic function</source>
          <target state="translated">C式变函数</target>
        </trans-unit>
        <trans-unit id="dd58d1bb166ddedbf2d0eda882e81a02524b0fbc" translate="yes" xml:space="preserve">
          <source>C#'s &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;embedded XML&lt;/a&gt;</source>
          <target state="translated">C＃的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;嵌入式XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34cf1ff3bbe582bde426d598f3ad72cfcc2d599c" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;free&lt;/code&gt; does not have a safe interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd30234820540d843ae13b550abfa205649ae3c" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;malloc&lt;/code&gt; does have a safe interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0143508b7b64b86b3401c85034e750942cedf11" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;strlen&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; do not have safe interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0548c5e650e5d6686abc5b2a04b9371833fa90" translate="yes" xml:space="preserve">
          <source>C's printf() and Strings</source>
          <target state="translated">C语言中的printf()和Strings</target>
        </trans-unit>
        <trans-unit id="4f540b0aaef1641b1d80a5208b7c055e606bf72a" translate="yes" xml:space="preserve">
          <source>C++ Interfaces</source>
          <target state="translated">C++接口</target>
        </trans-unit>
        <trans-unit id="f1642c1a4e4dce54c68aa20addb027e83adf0715" translate="yes" xml:space="preserve">
          <source>C++ Namespaces</source>
          <target state="translated">C++命名空间</target>
        </trans-unit>
        <trans-unit id="c5cb41022921444e105840eeb5b0879ab0ff1d75" translate="yes" xml:space="preserve">
          <source>C++ Support</source>
          <target state="translated">C++支持</target>
        </trans-unit>
        <trans-unit id="f9f27585ae5da3fc2a761861b44ded6adf3015ec" translate="yes" xml:space="preserve">
          <source>C++ Templates</source>
          <target state="translated">C++模板</target>
        </trans-unit>
        <trans-unit id="7e28b0c0a074b69119fdaf750d5061c6c3eed943" translate="yes" xml:space="preserve">
          <source>C++ allows a struct to inherit from a base struct. This is done in D using &lt;code&gt;alias this&lt;/code&gt;:</source>
          <target state="translated">C ++允许结构从基本结构继承。这是使用 &lt;code&gt;alias this&lt;/code&gt; 在D中完成的：</target>
        </trans-unit>
        <trans-unit id="270c92d90f5419eb56fc78a11ccc1e3fb6e75988" translate="yes" xml:space="preserve">
          <source>C++ and D follow different rules for function overloading. D source code, even when calling &lt;code&gt;extern (C++)&lt;/code&gt; functions, will still follow D overloading rules.</source>
          <target state="translated">C ++和D遵循不同的函数重载规则。即使调用 &lt;code&gt;extern (C++)&lt;/code&gt; 函数，D源代码仍将遵循D重载规则。</target>
        </trans-unit>
        <trans-unit id="803c33c0bd9c5c8e423f248219c12fcafd72a234" translate="yes" xml:space="preserve">
          <source>C++ can open the same namespace in the same file and multiple files. In D, this can be done as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9777d8f776f92bf25e9cab083b49833d4a402d3" translate="yes" xml:space="preserve">
          <source>C++ class</source>
          <target state="translated">C++类</target>
        </trans-unit>
        <trans-unit id="bc6ef19080a44be47740e7c8ef1fb2da8b514001" translate="yes" xml:space="preserve">
          <source>C++ classes can be declared in D by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; declarations. &lt;code&gt;extern (C++)&lt;/code&gt; interfaces have the same restrictions as D interfaces, which means that Multiple Inheritance is supported to the extent that only one base class can have member fields.</source>
          <target state="translated">可以通过在 &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;interface&lt;/code&gt; 声明中使用 &lt;code&gt;extern (C++)&lt;/code&gt; 属性在D中声明C ++类。 &lt;code&gt;extern (C++)&lt;/code&gt; 接口具有与D接口相同的限制，这意味着在仅一个基类可以具有成员字段的程度上，支持多重继承。</target>
        </trans-unit>
        <trans-unit id="2696fbb29a2404060229a5c0ef4dcf0d930ebf5a" translate="yes" xml:space="preserve">
          <source>C++ code explicitly manages memory with calls to &lt;code&gt;::operator new()&lt;/code&gt; and &lt;code&gt;::operator delete()&lt;/code&gt;. D's &lt;code&gt;new&lt;/code&gt; operator allocates memory using the D garbage collector, so no explicit delete is necessary. D's &lt;code&gt;new&lt;/code&gt; operator is not compatible with C++'s &lt;code&gt;::operator new&lt;/code&gt; and &lt;code&gt;::operator delete&lt;/code&gt;. Attempting to allocate memory with D's &lt;code&gt;new&lt;/code&gt; and deallocate with C++ &lt;code&gt;::operator delete&lt;/code&gt; will result in miserable failure.</source>
          <target state="translated">C ++代码通过调用 &lt;code&gt;::operator new()&lt;/code&gt; 和 &lt;code&gt;::operator delete()&lt;/code&gt; 显式管理内存。D的 &lt;code&gt;new&lt;/code&gt; 运算符使用D垃圾收集器分配内存，因此不需要显式删除。D的 &lt;code&gt;new&lt;/code&gt; 运算符与C ++的 &lt;code&gt;::operator new&lt;/code&gt; 和 &lt;code&gt;::operator delete&lt;/code&gt; 不兼容。尝试使用D的 &lt;code&gt;new&lt;/code&gt; 分配内存，并使用C ++ &lt;code&gt;::operator delete&lt;/code&gt; 取消分配内存将导致惨痛的失败。</target>
        </trans-unit>
        <trans-unit id="bc28c8a3178ea35aefa2bc7cad45f485c5c7f436" translate="yes" xml:space="preserve">
          <source>C++ constructors, copy constructors, move constructors and destructors cannot be called directly in D code, and D constructors, postblit operators and destructors cannot be directly exported to C++ code. Interoperation of types with these special operators is possible by either 1) disabling the operator in the client language and only using it in the host language, or 2) faithfully reimplementing the operator in the client language. With the latter approach, care needs to be taken to ensure observable semantics remain the same with both implementations, which can be difficult, or in some edge cases impossible, due to differences in how the operators work in the two languages. For example, in D all objects are movable and there is no move constructor.</source>
          <target state="translated">在D代码中不能直接调用C++构造函数、复制构造函数、移动构造函数和破坏函数,D构造函数、后置运算符和破坏函数也不能直接导出到C++代码中。类型与这些特殊运算符的互操作可以通过以下两种方式实现:1)在客户端语言中禁用该运算符,只在宿主语言中使用;2)在客户端语言中忠实地重新实现该运算符。采用后一种方法,需要注意确保两种实现的可观察语义保持一致,由于两种语言中操作符的工作方式不同,这可能是困难的,或者在某些边缘情况下是不可能的。例如,在D语言中,所有对象都是可移动的,而且没有移动构造函数。</target>
        </trans-unit>
        <trans-unit id="7201ae364cc48822a82b73b893189a5dd94aef18" translate="yes" xml:space="preserve">
          <source>C++ function and type templates can be bound by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on a function or type template declaration.</source>
          <target state="translated">可以通过在函数或类型模板声明上使用 &lt;code&gt;extern (C++)&lt;/code&gt; 属性来绑定C ++函数和类型模板。</target>
        </trans-unit>
        <trans-unit id="b5593ddf6c58f1012fa7ffeb46813794152a771a" translate="yes" xml:space="preserve">
          <source>C++ global functions, including those in namespaces, can be declared and called in D, or defined in D and called in C++.</source>
          <target state="translated">C++全局函数,包括命名空间中的函数,可以在D中声明和调用,也可以在D中定义,在C++中调用。</target>
        </trans-unit>
        <trans-unit id="4e9e4356221d1ee2aa897fff7328f9ee52314134" translate="yes" xml:space="preserve">
          <source>C++ interfaces are interfaces declared with C++ linkage:</source>
          <target state="translated">C++接口是用C++连接方式声明的接口。</target>
        </trans-unit>
        <trans-unit id="5099e4c841655b922a765e68cbf8aefc57d5356e" translate="yes" xml:space="preserve">
          <source>C++ namespace this symbol belongs to</source>
          <target state="translated">这个符号所属的C++命名空间</target>
        </trans-unit>
        <trans-unit id="c6f5200183cdf7ce197fbb3bc50824c16c47152a" translate="yes" xml:space="preserve">
          <source>C++ reference:</source>
          <target state="translated">C++参考。</target>
        </trans-unit>
        <trans-unit id="912b136567cd7cbd9fc8f323d5606bbe39d07750" translate="yes" xml:space="preserve">
          <source>C++ symbols that reside in namespaces can be accessed from D. A &lt;a href=&quot;attribute#namespace&quot;&gt;namespace&lt;/a&gt; can be added to the &lt;code&gt;extern (C++)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;LinkageAttribute&lt;/a&gt;:</source>
          <target state="translated">可以从D访问位于名称空间中的C ++符号。可以将&lt;a href=&quot;attribute#namespace&quot;&gt;名称空间&lt;/a&gt;添加到 &lt;code&gt;extern (C++)&lt;/code&gt; &lt;a href=&quot;attribute#linkage&quot;&gt;LinkageAttribute中&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="2f98b3c489784aabeb7da68a1d1411495ec51290" translate="yes" xml:space="preserve">
          <source>C++'s make_shared</source>
          <target state="translated">C++的make_shared</target>
        </trans-unit>
        <trans-unit id="588f44e70bf472a1f45f7efcfa562168c8457c0a" translate="yes" xml:space="preserve">
          <source>C-style Variadic Functions</source>
          <target state="translated">C-style Variadic Functions</target>
        </trans-unit>
        <trans-unit id="d5ccb24bc3ad9fc7c10cfe2824e9cb190ac91f9d" translate="yes" xml:space="preserve">
          <source>C-style array, function pointer and pointer to array declarations are deprecated:</source>
          <target state="translated">C-风格的数组、函数指针和数组指针的声明已被废弃。</target>
        </trans-unit>
        <trans-unit id="f0848a8145c311481df53130b777fe467332d312" translate="yes" xml:space="preserve">
          <source>C-style octal integer notation was deemed too easy to mix up with decimal notation; it is only fully supported in string literals. D still supports octal integer literals interpreted at compile time through the &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt;&lt;code&gt;std.conv.octal&lt;/code&gt;&lt;/a&gt; template, as in &lt;code&gt;octal!167&lt;/code&gt;.</source>
          <target state="translated">C风格的八进制整数表示法被认为太容易与十进制表示法混淆；它仅在字符串文字中完全受支持。D仍然支持在编译时通过&lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt; &lt;code&gt;std.conv.octal&lt;/code&gt; &lt;/a&gt;模板解释的八进制整数文字，如 &lt;code&gt;octal!167&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="9adf55a50113afd886edb1cbfcea7b8ecf56ed5e" translate="yes" xml:space="preserve">
          <source>C-style semantics on pointer arithmetic are strictly enforced. Pointer arithmetic is permitted only on pointers which point to static or dynamic array elements. Such pointers must point to an element of the array, or to the first element past the array. Pointer arithmetic is completely forbidden on pointers which are null, or which point to a non-array.</source>
          <target state="translated">指针运算的C式语义被严格执行。指针运算只允许在指向静态或动态数组元素的指针上进行。这样的指针必须指向数组中的一个元素,或者指向数组过去的第一个元素。指针算术完全禁止指向空或指向非数组的指针。</target>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="translated">C式变函数</target>
        </trans-unit>
        <trans-unit id="77ba44bb9e589c769fa658f005333eee147a4900" translate="yes" xml:space="preserve">
          <source>C-style variadic functions cannot be marked as &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">C风格的可变参数不能标记为 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ddb858f8a20b16ac93e15adcc78e42ffbd8db66" translate="yes" xml:space="preserve">
          <source>C-style variadic functions match the C calling convention for variadic functions, and is most useful for calling C library functions like &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">C风格的可变参数函数与可变参数函数的C调用约定匹配，并且对于调用诸如 &lt;code&gt;printf&lt;/code&gt; 之类的C库函数最有用。</target>
        </trans-unit>
        <trans-unit id="8818f4ee4a0e406f4fe10b1e03aebaf4d71f3819" translate="yes" xml:space="preserve">
          <source>C1 &lt;code&gt;next&lt;/code&gt;</source>
          <target state="translated">C1 &lt;code&gt;next&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30212c965112a877f52f60d83e8ff113ef1b3f96" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;path&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9089e6f07372bce6e832f5f650cb3e7c0c621e3b" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4aa0499528f63537a98f340c34d4972647df60e5" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;suffix&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;suffix&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c459d7b347295856b421ffb8792a1964353bfe70" translate="yes" xml:space="preserve">
          <source>C1[] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt;(C1, C2, C3, C4 = immutable(char))(C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null);</source>
          <target state="translated">C1 [] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt;（C1，C2，C3，C4 =不可变（字符））（C1 [] str，const（C2）[]从，const（C3）[]到，const（C4）[]修饰符= null） ;</target>
        </trans-unit>
        <trans-unit id="a0d01d3baedb5ae97bde5874c2012010c575e84c" translate="yes" xml:space="preserve">
          <source>C2 &lt;code&gt;empty&lt;/code&gt;</source>
          <target state="translated">C2 &lt;code&gt;empty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8e1804fe922cd90750831c2c298d54a222ba628" translate="yes" xml:space="preserve">
          <source>C2[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C2 [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b7d328ba78816f38f975bb5147f4c05534a9bc5" translate="yes" xml:space="preserve">
          <source>CAPI3REF</source>
          <target state="translated">CAPI3REF</target>
        </trans-unit>
        <trans-unit id="bd963590f78aa017d53387443be555aa971b1144" translate="yes" xml:space="preserve">
          <source>CData &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">CData &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afdd392374481b4db6ac2ce43fdc87d5888fe7e3" translate="yes" xml:space="preserve">
          <source>CDataException if the segment body is illegal (contains &quot;]]&amp;gt;&quot;)</source>
          <target state="translated">CDataException如果段主体是非法的（包含&amp;ldquo;]]&amp;gt;&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="3061e575e355c19788f22cb3d62aa0cd47f40e40" translate="yes" xml:space="preserve">
          <source>CData[] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;cdatas&quot;&gt;CData&lt;/strong&gt; [] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="92b00c2e72a02d322e30292a494b0f77de93d540" translate="yes" xml:space="preserve">
          <source>CJK Compatibility</source>
          <target state="translated">中日韩兼容性</target>
        </trans-unit>
        <trans-unit id="24dc7006e4bfb5dae3e8ea7f01d766f357b0514b" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Forms</source>
          <target state="translated">中日韩兼容表格</target>
        </trans-unit>
        <trans-unit id="28610435f9d6e37ccd13448891ef635456bc6798" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs</source>
          <target state="translated">中日韩的兼容性理念图</target>
        </trans-unit>
        <trans-unit id="3a3044d64bf35123af4c2034c39688d2f85c3b7d" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs Supplement</source>
          <target state="translated">中日韩兼容表意文字补充资料</target>
        </trans-unit>
        <trans-unit id="56398f3cc299fcadc8172ed7743fcc8d6604a2b2" translate="yes" xml:space="preserve">
          <source>CJK Radicals Supplement</source>
          <target state="translated">中日韩激进主义补充剂</target>
        </trans-unit>
        <trans-unit id="c80daba1e9c50935dee4c69ef20e42e31a63bfcb" translate="yes" xml:space="preserve">
          <source>CJK Strokes</source>
          <target state="translated">中日韩笔画</target>
        </trans-unit>
        <trans-unit id="41d774013768fc4cae9cda6ce11ff4062ab10d65" translate="yes" xml:space="preserve">
          <source>CJK Symbols and Punctuation</source>
          <target state="translated">中日韩的符号和标点符号</target>
        </trans-unit>
        <trans-unit id="a8e25b3246b6d0e0fa06fb72ba766979769141a7" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs</source>
          <target state="translated">中日韩统一表意文字</target>
        </trans-unit>
        <trans-unit id="6370cdf4d714b545f5b7bf4ee34e57e56e359487" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension A</source>
          <target state="translated">中日韩统一表意文字扩展A</target>
        </trans-unit>
        <trans-unit id="a1724e7543e72f713653f623821483898403f1d0" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension B</source>
          <target state="translated">中日韩统一表意文字扩展部分B</target>
        </trans-unit>
        <trans-unit id="71e4356045ae7c85afc88a13e5be97e037f502d4" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension C</source>
          <target state="translated">中日韩统一表意文字扩展C</target>
        </trans-unit>
        <trans-unit id="de4f53e7b0971e7c4fd9b6b5639b6d9d3d564380" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension D</source>
          <target state="translated">中日韩统一表意文字扩展D</target>
        </trans-unit>
        <trans-unit id="df31bd94e79946dcd6e346825f4e84b5f0358f50" translate="yes" xml:space="preserve">
          <source>CLI flag without leading &lt;code&gt;-&lt;/code&gt;, e.g. &lt;code&gt;color&lt;/code&gt;</source>
          <target state="translated">没有前导 &lt;code&gt;-&lt;/code&gt; 的 CLI标志，例如 &lt;code&gt;color&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d78b798fee78a64b81d6899e06efc15c1dccde51" translate="yes" xml:space="preserve">
          <source>COM Interfaces</source>
          <target state="translated">COM接口</target>
        </trans-unit>
        <trans-unit id="154721c66d149bb61466c03b8ff3861e25ef38c7" translate="yes" xml:space="preserve">
          <source>COM classes and C++ classes</source>
          <target state="translated">COM类和C++类</target>
        </trans-unit>
        <trans-unit id="ae337737f416d275254734defda66541f870f22e" translate="yes" xml:space="preserve">
          <source>COMPILER INTERFACE /////////////////////</source>
          <target state="translated">汇编器接口 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="0af12e3ea89b844b314d17c7e3f7bac655ebd0c7" translate="yes" xml:space="preserve">
          <source>CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt;;</source>
          <target state="translated">CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="95fe9c2b68a6150c2538241de478d073b3c01eb6" translate="yes" xml:space="preserve">
          <source>CPU architectures supported -mcpu=id</source>
          <target state="translated">支持的CPU架构 -mcpu=id</target>
        </trans-unit>
        <trans-unit id="73c7fc0f09e167cc17d6e2ae64cdb2bc100ca9d7" translate="yes" xml:space="preserve">
          <source>CPUs often support specialized vector types and vector operations (a.k.a.</source>
          <target state="translated">CPU通常支持专门的向量类型和向量运算(又称 &quot;向量运算&quot;)。</target>
        </trans-unit>
        <trans-unit id="bf887172139520e2ce3c00abdb93ee2e9fd86211" translate="yes" xml:space="preserve">
          <source>CRC32 of data</source>
          <target state="translated">数据的CRC32</target>
        </trans-unit>
        <trans-unit id="992514a6a8b2e73f449a04615c81ce6686d74551" translate="yes" xml:space="preserve">
          <source>CRC32 value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764a2bd592ab90f526cba7f18836f8fb323c69e5" translate="yes" xml:space="preserve">
          <source>CRC64-ECMA of data</source>
          <target state="translated">CRC64-ECMA的数据</target>
        </trans-unit>
        <trans-unit id="de219addfefcc2e27f49a3ca6fa5a51d3de19ec6" translate="yes" xml:space="preserve">
          <source>CRC64-ISO of data</source>
          <target state="translated">CRC64-数据的ISO</target>
        </trans-unit>
        <trans-unit id="91d96d88652e57b949051060aed04c0c7a55db68" translate="yes" xml:space="preserve">
          <source>CRCs are usually printed with the MSB first. When using &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt; the result will be in an unexpected order. Use &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt;'s optional order parameter to specify decreasing order for the correct result. The &lt;a href=&quot;#crcHexString&quot;&gt;&lt;code&gt;crcHexString&lt;/code&gt;&lt;/a&gt; alias can also be used for this purpose.</source>
          <target state="translated">CRC通常是首先用MSB打印的。当使用&lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; 时&lt;/a&gt;，结果将出现意外的顺序。使用&lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; &lt;/a&gt;的可选order参数为正确的结果指定降序。该&lt;a href=&quot;#crcHexString&quot;&gt; &lt;code&gt;crcHexString&lt;/code&gt; &lt;/a&gt;别名也可以用于此目的。</target>
        </trans-unit>
        <trans-unit id="20226dce447690b9ec8699b49af5230d49691790" translate="yes" xml:space="preserve">
          <source>CRL file</source>
          <target state="translated">CRL文件</target>
        </trans-unit>
        <trans-unit id="9d1c93dd97d25f4c239981585e218bded30a91de" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a402cf31f9cf0e6b5b8a55752e348488f03f726b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9864028d4f462263a4ffef0bfb1252c98316a14b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;csx&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;csx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d8934fa932e57010a67e3ca78ffd8b25af059e9" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6cb8e5d0c4fc4c6db7f22e70f099ed917c02dc9a" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ef70b18a1d95d31d7157c61d4106f2015fb5f903" translate="yes" xml:space="preserve">
          <source>CTFE</source>
          <target state="translated">CTFE</target>
        </trans-unit>
        <trans-unit id="f226c00a4d670c28c9ce96128a908ed75e3c4fc6" translate="yes" xml:space="preserve">
          <source>CTFE Sanity Checks</source>
          <target state="translated">CTFE安全检查</target>
        </trans-unit>
        <trans-unit id="bcdc8bcedfff54c513bf8524b5ea04b31a01d40f" translate="yes" xml:space="preserve">
          <source>CTFE is not supported.</source>
          <target state="translated">不支持CTFE。</target>
        </trans-unit>
        <trans-unit id="2e8b7f100028e56862c1d736efc547af30992b6b" translate="yes" xml:space="preserve">
          <source>CTFE is subject to the following restrictions:</source>
          <target state="translated">CTFE受以下限制:</target>
        </trans-unit>
        <trans-unit id="5cbcfb039635320e7ff7d8feb659fe88d90d6d53" translate="yes" xml:space="preserve">
          <source>CTFE-able expression, resolving to &lt;code&gt;TupleExp&lt;/code&gt; or &lt;code&gt;StringExp&lt;/code&gt;</source>
          <target state="translated">支持CTFE的表达式，解析为 &lt;code&gt;TupleExp&lt;/code&gt; 或 &lt;code&gt;StringExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da921efe49d919390e46ee7013dc94409e0427b9" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURL * &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt;（CURL * curl）;</target>
        </trans-unit>
        <trans-unit id="f3df3af8e49ed4cabb82ec3eb374069c299119bb" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt;();</source>
          <target state="translated">CURL * &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="6751502e2bc0440a5e6927ebe6c763c9fb33f615" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt;;</source>
          <target state="translated">CURL * &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="828fa48577f41dee0175a07d2bcd99aa7917b639" translate="yes" xml:space="preserve">
          <source>CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error instead of a memory allocation error if CURL_DOES_CONVERSIONS is defined</source>
          <target state="translated">如果定义了CURL_DOES_CONVERSIONS,CURLE_OUT_OF_MEMORY有时会显示一个转换错误,而不是内存分配错误。</target>
        </trans-unit>
        <trans-unit id="2ab51649023b66c808197a6d0ba638e7d65bf9da" translate="yes" xml:space="preserve">
          <source>CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt;(curl_httppost** httppost, curl_httppost** last_post, ...);</source>
          <target state="translated">CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt;（curl_httppost ** httppost，curl_httppost ** last_post，...）;</target>
        </trans-unit>
        <trans-unit id="ee42c010a41bbc2d374ffe159f6514f8ff046b0e" translate="yes" xml:space="preserve">
          <source>CURLINFO_RESPONSE_CODE is the new name for the option previously known as CURLINFO_HTTP_CODE</source>
          <target state="translated">CURLINFO_RESPONSE_CODE是以前称为CURLINFO_HTTP_CODE的选项的新名称。</target>
        </trans-unit>
        <trans-unit id="32ad7575f66b5734a63076c0cb3d75f3884da653" translate="yes" xml:space="preserve">
          <source>CURLM error code.</source>
          <target state="translated">CURLM错误代码。</target>
        </trans-unit>
        <trans-unit id="99dd99b527ed789fcfbdfc456b2eb941ef204be1" translate="yes" xml:space="preserve">
          <source>CURLM* &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt;();</source>
          <target state="translated">CURLM * &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="3b90f598cb268ee4dc09f1ac996362f90296018c" translate="yes" xml:space="preserve">
          <source>CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt;;</source>
          <target state="translated">CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1999612ad18366624e0d0b2cd56012c1afc025b3" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt;（CURLM * multi_handle，CURL * curl_handle）;</target>
        </trans-unit>
        <trans-unit id="22a1019ea56e4dab3fcad53491bac13d0d8af5fb" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t sockfd, void* sockp);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt;（CURLM * multi_handle，curl_socket_t sockfd，void * sockp）;</target>
        </trans-unit>
        <trans-unit id="25a2804bd3b7261884e99b1fc524c94a8f152120" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt;(CURLM* multi_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt;（CURLM * multi_handle）;</target>
        </trans-unit>
        <trans-unit id="0d7d7eae82011af95f4a6e15b19e86d79b7d077b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt;(CURLM* multi_handle, fd_set* read_fd_set, fd_set* write_fd_set, fd_set* exc_fd_set, int* max_fd);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt;（CURLM * multi_handle，fd_set * read_fd_set，fd_set * write_fd_set，fd_set * exc_fd_set，int * max_fd）;</target>
        </trans-unit>
        <trans-unit id="811b3bdcf0c9e88ad95fd7b9e1e9194bc510f1d4" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt;（CURLM * multi_handle，int * running_handles）;</target>
        </trans-unit>
        <trans-unit id="cdc21e6a79fac27e25ab2401a2231a5159d42fa2" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt;（CURLM * multi_handle，CURL * curl_handle）;</target>
        </trans-unit>
        <trans-unit id="b77796e4441642019f5f0ee725e2d2ccbaf79203" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt;(CURLM* multi_handle, CURLMoption option, ...);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt;（CURLM * multi_handle，CURLMoption选项，...）;</target>
        </trans-unit>
        <trans-unit id="a09fadf338e9129df789fdea317e027aaed23a5b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt;（CURLM * multi_handle，curl_socket_t s，int * running_handles）;</target>
        </trans-unit>
        <trans-unit id="ff40633804853059e167a117757dc66453ca66ad" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int ev_bitmask, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt;（CURLM * multi_handle，curl_socket_t s，int ev_bitmask，int * running_handles）;</target>
        </trans-unit>
        <trans-unit id="2466194fef4d1ee2ade6e8ccdeda99a667524258" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt;（CURLM * multi_handle，int * running_handles）;</target>
        </trans-unit>
        <trans-unit id="11ebb04cdf64624f9d24ec68ab137e1aca46350a" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt;(CURLM* multi_handle, c_long* milliseconds);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt;（CURLM * multi_handle，c_long *毫秒）;</target>
        </trans-unit>
        <trans-unit id="78c7684a9c1f8b1ac34050129574ece72e711bdd" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.</source>
          <target state="translated">CURLMcode类型,一般多错误代码。</target>
        </trans-unit>
        <trans-unit id="4dc759c2b4e3bdbdc1edda0576bc41603b22a66f" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.  tmp decl</source>
          <target state="translated">CURLMcode类型,一般多错误代码。 tmp decl</target>
        </trans-unit>
        <trans-unit id="8b52c35c36f45f74e7316bea0caa3ca7b9817c93" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code. &lt;em&gt;NOTE&lt;/em&gt; that this only returns errors etc regarding the whole multi stack. There might still have occurred problems on invidual transfers even when this returns OK.</source>
          <target state="translated">CURLMcode类型，常规的多错误代码。&lt;em&gt;注意&lt;/em&gt;，这只会返回关于整个多堆栈的错误等。即使返回&amp;ldquo;确定&amp;rdquo;，仍可能在个人传输上出现问题。</target>
        </trans-unit>
        <trans-unit id="24871c0c35a14246d94f5b601f5067185618ba89" translate="yes" xml:space="preserve">
          <source>CURLMsg* &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt;(CURLM* multi_handle, int* msgs_in_queue);</source>
          <target state="translated">CURLMsg * &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt;（CURLM * multi_handle，int * msgs_in_queue）;</target>
        </trans-unit>
        <trans-unit id="af2fa369dcf8fd4fae6663dacfb6660f7d91238e" translate="yes" xml:space="preserve">
          <source>CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options</source>
          <target state="translated">CURLPROTO_定义的是CURLOPT_*PROTOCOLS选项。</target>
        </trans-unit>
        <trans-unit id="d2e3b588ca39c50e2dd064cfebdc4915a19704fb" translate="yes" xml:space="preserve">
          <source>CURLSH* &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt;();</source>
          <target state="translated">CURLSH * &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="0cd2315c9c925b9d61d4c461b411526f237b821b" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt;(CURLSH*);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt;（CURLSH *）;</target>
        </trans-unit>
        <trans-unit id="c12fc1ef3ac28f47fb0a0bb249fb914036edd5d6" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt;(CURLSH*, CURLSHoption option, ...);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt;（CURLSH *，CURLSHoption选项，...）;</target>
        </trans-unit>
        <trans-unit id="80c9a3afaa37cabae0ead42d1ea2a983b4448ab3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_ILLEGAL_ARRAY if an illegal option is used in an array</source>
          <target state="translated">如果在数组中使用了非法的选项,那么CURL_FORMADD_ILLEGAL_ARRAY。</target>
        </trans-unit>
        <trans-unit id="237caace3d00237f9fad71d5fdcb4b423276a5aa" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_INCOMPLETE if the some FormInfo is not complete (or error)</source>
          <target state="translated">CURL_FORMADD_INCOMPLETE,如果某些FormInfo不完整(或错误)。</target>
        </trans-unit>
        <trans-unit id="16321db303d4490b9645491e5cfe20deb293518b" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if a curl_httppost struct cannot be allocated</source>
          <target state="translated">CURL_FORMADD_MEMORY,如果一个curl_httppost结构不能被分配的话</target>
        </trans-unit>
        <trans-unit id="468f4fa1bb410d0fd70e03f6a5dce8bd45ccdbe3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if some allocation for string copying failed.</source>
          <target state="translated">CURL_FORMADD_MEMORY如果字符串复制的分配失败。</target>
        </trans-unit>
        <trans-unit id="244588782f153f2f49d14b88a76a4b1567aa1f97" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the FormInfo allocation fails</source>
          <target state="translated">如果FormInfo分配失败,则CURL_FORMADD_MEMORY。</target>
        </trans-unit>
        <trans-unit id="21b7579474f488d4369aa40ec4d89dc3bb5304c5" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the allocation of a FormInfo struct failed</source>
          <target state="translated">如果FormInfo结构的分配失败,CURL_FORMADD_MEMORY。</target>
        </trans-unit>
        <trans-unit id="f486f564c902d8b166b922ce6666a103809fa080" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_NULL if a null pointer was given for a char</source>
          <target state="translated">CURL_FORMADD_NULL,如果一个char的指针为null的话。</target>
        </trans-unit>
        <trans-unit id="03c087c14e47ce05c5a730cee27884e0f0271510" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OK on success</source>
          <target state="translated">CURL_FORMADD_OK在成功后,会有一个新的版本。</target>
        </trans-unit>
        <trans-unit id="657acce1995ce0c4c4cc9704302fc40b3180ce0c" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OPTION_TWICE if one option is given twice for one Form</source>
          <target state="translated">CURL_FORMADD_OPTION_TWICE,如果一个表单中的一个选项被赋予两次,那么CURL_FORMADD_OPTION_TWICE就会出现。</target>
        </trans-unit>
        <trans-unit id="fb231ca0da85a5247735b55bae68726897d51402" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used</source>
          <target state="translated">如果使用了未知的选项,那么CURL_FORMADD_UNKNOWN_OPTION。</target>
        </trans-unit>
        <trans-unit id="c1c36583a3bee413dd4d6eabaaf03906540af6c8" translate="yes" xml:space="preserve">
          <source>CURL_LOCK_DATA_SHARE is used internally to say that the locking is just made to change the internal state of the share itself.</source>
          <target state="translated">CURL_LOCK_DATA_SHARE内部使用的是说,锁定只是为了改变共享本身的内部状态。</target>
        </trans-unit>
        <trans-unit id="08d333ae982f2ab5fd05c92959c9f03604998f78" translate="yes" xml:space="preserve">
          <source>CURL_VERSION</source>
          <target state="translated">CURL_VERSION</target>
        </trans-unit>
        <trans-unit id="311de4a4e55e22b4fb916aea606488f2810807f6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt;(CURL* curl, CURLINFO info, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt;（CURL * curl，CURLINFO info，...）;</target>
        </trans-unit>
        <trans-unit id="732ee216b7a86b2068f3e21e26d039d5ff87d0a6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt;(CURL* handle, int bitmask);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt;（CURL *句柄，int位掩码）；</target>
        </trans-unit>
        <trans-unit id="743291b335af5fe8701249accd883cdee309abc2" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt;（CURL * curl）;</target>
        </trans-unit>
        <trans-unit id="5ef9ed35887a97572c7e153166cf3c37d4499135" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt;（CURL * curl，void * buffer，size_t buflen，size_t * n）;</target>
        </trans-unit>
        <trans-unit id="03f5e5216a441a870631a8ebbf1324f0d53aad46" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt;（CURL * curl，void * buffer，size_t buflen，size_t * n）;</target>
        </trans-unit>
        <trans-unit id="c2267b7c0b6dd8f394f4e53f9877924630091aa4" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt;(CURL* curl, CURLoption option, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt;（CURL * curl，CURLoption选项，...）;</target>
        </trans-unit>
        <trans-unit id="856a997055fde5b0daa6466669272d7c21200826" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt;(c_long flags);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt;（c_long标志）;</target>
        </trans-unit>
        <trans-unit id="ad44c3dd1dc580f2f09873c3d8bc4b0f2c99e680" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt;(c_long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt;（c_long标志，curl_malloc_callback m，curl_free_callback f，curl_realloc_callback r，curl_strdup_callback s，curl_calloc_callback c）;</target>
        </trans-unit>
        <trans-unit id="47d9bbe805f8580c705596e7003de4a50cbc2583" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;result&quot;&gt;result&lt;/strong&gt;;</source>
          <target state="translated">CURLcode &lt;strong id=&quot;result&quot;&gt;结果&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="304f1ec0769d4c548febbdf47625f266fdcfab5b" translate="yes" xml:space="preserve">
          <source>CURLformoption &lt;strong id=&quot;option&quot;&gt;option&lt;/strong&gt;;</source>
          <target state="translated">CURLformoption &lt;strong id=&quot;option&quot;&gt;选项&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="a4c24fe1a70e51826ba9ae7c30e20cd7e2a29828" translate="yes" xml:space="preserve">
          <source>CURLversion &lt;strong id=&quot;age&quot;&gt;age&lt;/strong&gt;;</source>
          <target state="translated">CURLversion &lt;strong id=&quot;age&quot;&gt;年龄&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b4a140e494ddd4ae40e04aab42088b88b1becbfe" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;buf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afe63bc0735098979cb97ac441f55ea9bf41ba0b" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bacd88197768daee4b3de506c5c3a95e5a62751a" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06ae80fea6ce71846e64d1060826cd17e855a35" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7150792a1546098dee35fe7a98fdfc975256a790" translate="yes" xml:space="preserve">
          <source>Cache size and behaviour</source>
          <target state="translated">缓存大小和行为</target>
        </trans-unit>
        <trans-unit id="f800f99aa3df3800502bbb36ab972cc0eb0d5c0b" translate="yes" xml:space="preserve">
          <source>CacheInfo[5] &lt;strong id=&quot;datacache&quot;&gt;datacache&lt;/strong&gt;;</source>
          <target state="translated">CacheInfo [5]数据&lt;strong id=&quot;datacache&quot;&gt;缓存&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="6bcc4b116e2d06311b0fc9927d035dbff820590a" translate="yes" xml:space="preserve">
          <source>Calculate and return</source>
          <target state="translated">计算和返回</target>
        </trans-unit>
        <trans-unit id="3d6ed85fb2e3f634e358f0719e27875d435ea774" translate="yes" xml:space="preserve">
          <source>Calculate built-in properties which just the type is necessary.</source>
          <target state="translated">计算只需要类型的内置属性。</target>
        </trans-unit>
        <trans-unit id="a4aa52fc673bba9caf0d9f71c29d0ae6f9877456" translate="yes" xml:space="preserve">
          <source>Calculate field[i].overlapped and overlapUnsafe, and check that all of explicit field initializers have unique memory space on instance.</source>
          <target state="translated">计算field[i].overlapped和overlapUnsafe,并检查所有显式字段初始化器在实例上是否有唯一的内存空间。</target>
        </trans-unit>
        <trans-unit id="5c68d55b4c8ec705956e2d8e0515e64b113840ed" translate="yes" xml:space="preserve">
          <source>Calculate the base-10 logarithm of x.</source>
          <target state="translated">计算x的10次方对数。</target>
        </trans-unit>
        <trans-unit id="aa77a0a0c44f9dd6e1b336ed64c758b221d1485c" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence ending one code unit before &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">计算在 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;index&lt;/code&gt; 之前一个代码单元结束的UTF序列的长度。</target>
        </trans-unit>
        <trans-unit id="14c2e14715fa06b8f138716be37c507138d963e7" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence starting at &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">计算开始于UTF序列的长度 &lt;code&gt;index&lt;/code&gt; 在 &lt;code&gt;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e12b3a821d4bde6f6cb14b1be6565da8f2b8ddac" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x.</source>
          <target state="translated">计算x的自然对数。</target>
        </trans-unit>
        <trans-unit id="3f112af5d27881f2633fc0efa7c8c3ce5a0a8242" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x. The branch cut is along the negative axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30b6367e2a4061ed4b790ec3600b0de931f9e1f" translate="yes" xml:space="preserve">
          <source>Calculate the next largest floating point value after x.</source>
          <target state="translated">计算x之后的下一个最大浮点值。</target>
        </trans-unit>
        <trans-unit id="b9c742d632c337bd8cbf69961edcf3221964c540" translate="yes" xml:space="preserve">
          <source>Calculate the next smallest floating point value before x.</source>
          <target state="translated">计算x之前的下一个最小的浮点值。</target>
        </trans-unit>
        <trans-unit id="018fa0870c360e2cac7a8c4bc28e389efc5f1613" translate="yes" xml:space="preserve">
          <source>Calculate the remainder x REM y, following IEC 60559.</source>
          <target state="translated">按照IEC 60559的规定,计算余量x REM y。</target>
        </trans-unit>
        <trans-unit id="3fba25e1430b0ae9ada9b4efe1168d1151f49b29" translate="yes" xml:space="preserve">
          <source>Calculates 2&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">计算2 &lt;sup&gt;x&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="63c1fbfad55eb2f0634d2925033191320d7fe148" translate="yes" xml:space="preserve">
          <source>Calculates e&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">计算e &lt;sup&gt;x&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="552f818572293e7e3df3d8078e1d8502861c8778" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number</source>
          <target state="translated">计算一个数字的绝对值</target>
        </trans-unit>
        <trans-unit id="4ec6328d585b956e719618a807b023dcff090ac5" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be2a6f70202c3264162991c74bed6c4baae9236" translate="yes" xml:space="preserve">
          <source>Calculates the arc cosine of x, returning a value ranging from 0 to &amp;pi;.</source>
          <target state="translated">计算x的反余弦值，返回值范围为0到&amp;pi;。</target>
        </trans-unit>
        <trans-unit id="d946a27b03ca4cac969d0047946f4fc66affc0fa" translate="yes" xml:space="preserve">
          <source>Calculates the arc sine of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">计算x的反正弦值，返回-&amp;pi;/ 2到&amp;pi;/ 2的值。</target>
        </trans-unit>
        <trans-unit id="d9e1b5526d250f5e8ab8ddc83903cc95d1cc029a" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">计算x的反正切值，返回值介于-&amp;pi;/ 2到&amp;pi;/ 2之间。</target>
        </trans-unit>
        <trans-unit id="3783817bf938b83309854c6205d56ee4a302e644" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of y / x, returning a value ranging from -&amp;pi; to &amp;pi;.</source>
          <target state="translated">计算y / x的反正切，返回-&amp;pi;到&amp;pi;的值。</target>
        </trans-unit>
        <trans-unit id="e1c3e20fd2cd7d94fdcf1efca206597755351a82" translate="yes" xml:space="preserve">
          <source>Calculates the base-2 logarithm of x: log&lt;sub&gt;2&lt;/sub&gt;x</source>
          <target state="translated">计算x的以2为底的对数：log &lt;sub&gt;2&lt;/sub&gt; x</target>
        </trans-unit>
        <trans-unit id="ba562ff7e573b706f15ed8cff069704fa53ed5ac" translate="yes" xml:space="preserve">
          <source>Calculates the cube root of x.</source>
          <target state="translated">计算x的立方根。</target>
        </trans-unit>
        <trans-unit id="c6b3ccb038ca0414c5d73b25ada62fdde6188a5c" translate="yes" xml:space="preserve">
          <source>Calculates the hash value of &lt;code&gt;arg&lt;/code&gt; with an optional &lt;code&gt;seed&lt;/code&gt; initial value. The result might not be equal to &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt;.</source>
          <target state="translated">用可选的 &lt;code&gt;seed&lt;/code&gt; 初始值计算 &lt;code&gt;arg&lt;/code&gt; 的哈希值。结果可能不等于 &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6077e40f1d7c6b4630a9eabd54e9cc9ad6cdbbd5" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic cosine of x.</source>
          <target state="translated">计算x的双曲余弦。</target>
        </trans-unit>
        <trans-unit id="c3be2955cec737e95210a83c0153e5a7b26737f0" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic sine of x.</source>
          <target state="translated">计算x的双曲正弦。</target>
        </trans-unit>
        <trans-unit id="836a3048b7c344efad04edc701d9a39358e4ddc2" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic tangent of x.</source>
          <target state="translated">计算x的双曲正切。</target>
        </trans-unit>
        <trans-unit id="26863b4aef8c0a694cd2e723d6778f9f04e7eb52" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic cosine of x.</source>
          <target state="translated">计算x的反双曲余弦。</target>
        </trans-unit>
        <trans-unit id="c627e3b3df39ce6438ba816e8a109c0ffed6f76d" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic sine of x.</source>
          <target state="translated">计算x的反双曲正弦。</target>
        </trans-unit>
        <trans-unit id="8af98eaa49794884fefd803885cf1f1893246ddf" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic tangent of x, returning a value from ranging from -1 to 1.</source>
          <target state="translated">计算x的反双曲正切,返回一个从-1到1的值。</target>
        </trans-unit>
        <trans-unit id="5c5618c4bbf47d472509dd6366443a216865a98d" translate="yes" xml:space="preserve">
          <source>Calculates the length needed to store the encoded string corresponding to an input of the given length.</source>
          <target state="translated">计算与给定长度的输入对应的编码字符串所需的存储长度。</target>
        </trans-unit>
        <trans-unit id="027e373dfea678dcf40ffef9e131551d07153fd8" translate="yes" xml:space="preserve">
          <source>Calculates the length of the hypotenuse of a right-angled triangle with sides of length x and y. The hypotenuse is the value of the square root of the sums of the squares of x and y:</source>
          <target state="translated">计算边长为x和y的直角三角形的斜边长度。斜边是x和y的平方根之和的值。</target>
        </trans-unit>
        <trans-unit id="49efa739aec865cfda8564b9080c48989d5e33a7" translate="yes" xml:space="preserve">
          <source>Calculates the natural logarithm of 1 + x.</source>
          <target state="translated">计算1+x的自然对数。</target>
        </trans-unit>
        <trans-unit id="2c06de5b0b0a99a9dfc2d0912c58bdadc98082d6" translate="yes" xml:space="preserve">
          <source>Calculates the next representable value after x in the direction of y.</source>
          <target state="translated">计算x之后沿y方向的下一个可表示值。</target>
        </trans-unit>
        <trans-unit id="3754c2ce035cf1b13a7cd37e615749fb652610b4" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer using the X86 SSE4 POPCNT instruction. POPCNT is not available on all X86 CPUs.</source>
          <target state="translated">使用X86 SSE4 POPCNT指令计算整数中的设置位数。POPCNT并非在所有X86 CPU上都可用。</target>
        </trans-unit>
        <trans-unit id="06d72e9a8ced5d5423191cc63ca6b46b4610af0d" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer.</source>
          <target state="translated">计算整数中设置的位数。</target>
        </trans-unit>
        <trans-unit id="9a6eed62af9d1a47c1ab6bc79899d39e32a6483a" translate="yes" xml:space="preserve">
          <source>Calculates the remainder from the calculation x/y.</source>
          <target state="translated">计算x/y计算的余数。</target>
        </trans-unit>
        <trans-unit id="fe24886c3219456f2196eb244fb852afd4fb56a9" translate="yes" xml:space="preserve">
          <source>Calculates the value of the natural logarithm base (e) raised to the power of x, minus 1.</source>
          <target state="translated">计算自然对数基数(e)提高到x的幂,减1的值。</target>
        </trans-unit>
        <trans-unit id="af2f291e997ca41e56ba422f46bf86ff11ebb79d" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;n&lt;/sup&gt;. The branch cut is on the negative axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f6cce6873a9a6bb919b268ff433dd1e133a874" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;y&lt;/sup&gt;.</source>
          <target state="translated">计算x &lt;sup&gt;y&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="801ce4a0b5aa9b661ade0819332605cc7b1ae809" translate="yes" xml:space="preserve">
          <source>Call each of the connected slots, passing the argument(s) i to them. Nested call will be ignored.</source>
          <target state="translated">调用每个连接的插槽,将参数i传递给它们。嵌套调用将被忽略。</target>
        </trans-unit>
        <trans-unit id="5f9f4deb84100f6aec181820d5a751140cd068c1" translate="yes" xml:space="preserve">
          <source>Call this after printing out fatal error messages to clean up and exit the compiler.</source>
          <target state="translated">在打印出致命的错误信息后调用此功能来清理并退出编译器。</target>
        </trans-unit>
        <trans-unit id="f75e5681020d520d2c6f752e809e81b0c81a85b8" translate="yes" xml:space="preserve">
          <source>CallExp &lt;code&gt;ce&lt;/code&gt;</source>
          <target state="translated">CallExp &lt;code&gt;ce&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf7b36d93b4e5475d0f1769a4ea2f0934f697c5" translate="yes" xml:space="preserve">
          <source>Callback for each received StatusLine.</source>
          <target state="translated">对每个收到的状态线进行回调。</target>
        </trans-unit>
        <trans-unit id="f3869aa6b3628e9280e1301a0819ce5b27364caa" translate="yes" xml:space="preserve">
          <source>Callback function for opening socket (instead of socket(2)). Optionally, callback is able change the address or refuse to connect returning CURL_SOCKET_BAD. The callback should have type curl_opensocket_callback</source>
          <target state="translated">用于打开socket的回调函数(代替socket(2))。也可以选择回调函数来改变地址或者拒绝连接,返回CURL_SOCKET_BAD。回调函数的类型应该是curl_opensocket_callback。</target>
        </trans-unit>
        <trans-unit id="fa6c180b210d6c195ea47a0f5808f2e991c787e3" translate="yes" xml:space="preserve">
          <source>Callback function for seeking in the input stream</source>
          <target state="translated">用于在输入流中寻找的回调函数</target>
        </trans-unit>
        <trans-unit id="d4829fe836ac65e604efec860420d6bb34e163e7" translate="yes" xml:space="preserve">
          <source>Callback implementation user data</source>
          <target state="translated">回调实现用户数据</target>
        </trans-unit>
        <trans-unit id="7958bba34f83b3f0d9bec51f1aa784c3099f4330" translate="yes" xml:space="preserve">
          <source>Callback options.</source>
          <target state="translated">回调选项:</target>
        </trans-unit>
        <trans-unit id="2c70d267e735763e25416c3729426a88c83fd93c" translate="yes" xml:space="preserve">
          <source>Callback parameters</source>
          <target state="translated">回调参数</target>
        </trans-unit>
        <trans-unit id="83da71c0b0c98f854fd142c883ddfbc56d402d5a" translate="yes" xml:space="preserve">
          <source>Callback returns</source>
          <target state="translated">回调返回</target>
        </trans-unit>
        <trans-unit id="5277f74ec6b2c07897ae08c4150298f4a47bfee7" translate="yes" xml:space="preserve">
          <source>Callback routine requested an abort</source>
          <target state="translated">回调例程请求中止</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="9d7a88bd45dd2018e4f369390635318ba64e842f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad &lt;code&gt;opOpAssign&lt;/code&gt; call (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">在错误的 &lt;code&gt;opOpAssign&lt;/code&gt; 调用（会降低精度或尝试将负值转换为无符号类型的调用）时自动调用。</target>
        </trans-unit>
        <trans-unit id="7102900b536c87cd1ddcccfc7367f11bb9536bf4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast (one that loses precision or attempts to convert a negative value to an unsigned type). The source type is &lt;code&gt;Src&lt;/code&gt; and the destination type is &lt;code&gt;Dst&lt;/code&gt;.</source>
          <target state="translated">在转换错误时自动调用（该转换会导致精度下降或尝试将负值转换为无符号类型）。源类型为 &lt;code&gt;Src&lt;/code&gt; ，目标类型为 &lt;code&gt;Dst&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ced3e78029e52a33dba4c3dc622cbf4db610e5" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast from &lt;code&gt;src&lt;/code&gt; to type &lt;code&gt;Dst&lt;/code&gt; (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">在从 &lt;code&gt;src&lt;/code&gt; &lt;code&gt;Dst&lt;/code&gt; 转换为Dst类型时（错误的精度或试图将负值转换为无符号类型的类型）自动调用。</target>
        </trans-unit>
        <trans-unit id="1b890f532573803598c95ff0855037312602e65a" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bounds error.</source>
          <target state="translated">发生边界错误时自动调用。</target>
        </trans-unit>
        <trans-unit id="cec93f38cfc349e778449343568f595e85578df6" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of a erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), this hook issues &lt;code&gt;assert(0)&lt;/code&gt; which terminates the application.</source>
          <target state="translated">在进行相等性比较时自动调用。在比较错误的情况下（使带负号的负值看起来等于无符号的正值的那个），此钩子发出 &lt;code&gt;assert(0)&lt;/code&gt; 终止应用程序。</target>
        </trans-unit>
        <trans-unit id="0d9a0c46bb6698d633be1a9f6fd1250d9925d992" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of an Erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), writes a warning message to &lt;code&gt;stderr&lt;/code&gt; as a side effect.</source>
          <target state="translated">在进行相等性比较时自动调用。如果发生错误比较（一个使带负号的负值看起来等于无符号的正值的比较），则作为副作用将警告消息写入 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5f36c313c02bf2d55947333ca1b1ce5b5e726cd" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. Throws upon an erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value).</source>
          <target state="translated">在进行平等比较时自动调用。抛出一个错误的比较(使一个有符号的负值看起来等于一个无符号的正值)。</target>
        </trans-unit>
        <trans-unit id="482787b051181ec9851e392f48ceca8d8cc29f3f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then a warning message is printed to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">使用操作符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 之一进行比较时自动调用。如果比较是错误的（即，它将使有符号的负值看起来大于或等于无符号的正值），则将警告消息打印到 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f347895ce62ab753804db2ed8acefc457ef89fc4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then application is terminated with &lt;code&gt;assert(0)&lt;/code&gt;. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">使用操作符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 之一进行比较时自动调用。如果比较是错误的（即，它将使有符号的负值看起来大于或等于无符号的正值），则应用将以 &lt;code&gt;assert(0)&lt;/code&gt; 终止。否则，返回三态结果（如果 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 为正，如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 负，否则为 &lt;code&gt;0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fd9dee545de2de37ec8d225d3452d9b9db4a4de3" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), throws a &lt;code&gt;Throw.CheckFailure&lt;/code&gt; exception. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">使用操作符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 之一进行比较时自动调用。如果比较是错误的（即，它将使有符号的负值看起来大于或等于无符号的正值），则引发 &lt;code&gt;Throw.CheckFailure&lt;/code&gt; 异常。否则，返回三态结果（如果 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 为正，如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 负，否则为 &lt;code&gt;0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="288a3bb051cf2f7e5a316c4d4e70d5118f188801" translate="yes" xml:space="preserve">
          <source>Called automatically upon an overflow during a unary or binary operation.</source>
          <target state="translated">在一元或二元操作中发生溢出时自动调用。</target>
        </trans-unit>
        <trans-unit id="18ffd2396df8d946aeaff03367807e9289b502e5" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;accept&lt;/code&gt; when a new &lt;code&gt;Socket&lt;/code&gt; must be created for a new connection. To use a derived class, override this method and return an instance of your class. The returned &lt;code&gt;Socket&lt;/code&gt;'s handle must not be set; &lt;code&gt;Socket&lt;/code&gt; has a protected constructor &lt;code&gt;this()&lt;/code&gt; to use in this situation.</source>
          <target state="translated">当必须为新连接创建新的 &lt;code&gt;Socket&lt;/code&gt; 时，由 &lt;code&gt;accept&lt;/code&gt; 调用。要使用派生类，请重写此方法并返回您的类的实例。返回的 &lt;code&gt;Socket&lt;/code&gt; 的句柄不能设置。在这种情况下， &lt;code&gt;Socket&lt;/code&gt; 具有受保护的构造函数 &lt;code&gt;this()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b54f1e19b12e53615e8a653c409ba5ab2951a872" translate="yes" xml:space="preserve">
          <source>Called by D code to throw an exception via</source>
          <target state="translated">被D代码调用,以通过</target>
        </trans-unit>
        <trans-unit id="1ca7f5a39bbf37ff1a678bd1aa4c79aba11959d4" translate="yes" xml:space="preserve">
          <source>Called by SQLite to clean up pUser</source>
          <target state="translated">被SQLite调用来清理pUser。</target>
        </trans-unit>
        <trans-unit id="9743db8f1711c6b311db6267994885195b8a6347" translate="yes" xml:space="preserve">
          <source>Called by libcurl whenever the library detects a change in the maximum number of milliseconds the app is allowed to wait before curl_multi_socket() or curl_multi_perform() must be called (to allow libcurl's timed events to take place).</source>
          <target state="translated">每当库检测到应用程序在调用curl_multi_socket()或curl_multi_perform()之前允许等待的最大毫秒数发生变化时,就会被libcurl调用(以允许libcurl的定时事件发生)。</target>
        </trans-unit>
        <trans-unit id="3edd2c76a126518315d7a71140c73140e3fc8324" translate="yes" xml:space="preserve">
          <source>Called during runtime initialization to initialize a GC instance of given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">在运行时初始化期间调用，以初始化给定 &lt;code&gt;name&lt;/code&gt; 的GC实例。</target>
        </trans-unit>
        <trans-unit id="6980b4453fbc6893945f9512aa33baa854c12d55" translate="yes" xml:space="preserve">
          <source>Called from back end.</source>
          <target state="translated">从后端调用。</target>
        </trans-unit>
        <trans-unit id="f90881b5eb5e600ad18d60ab2849afead809fc76" translate="yes" xml:space="preserve">
          <source>Called once per thread; returns array of thread local storage ranges</source>
          <target state="translated">每个线程调用一次;返回线程本地存储范围的数组。</target>
        </trans-unit>
        <trans-unit id="7a912bc6a899a5bd4ea502581245c2ef16bd2966" translate="yes" xml:space="preserve">
          <source>Called when fibers switch contexts.</source>
          <target state="translated">当光纤切换上下文时调用。</target>
        </trans-unit>
        <trans-unit id="c0acd999c318ee36079d9ad700960738ccee34ac" translate="yes" xml:space="preserve">
          <source>Called when setting a version identifier, e.g. &lt;code&gt;-version=identifier&lt;/code&gt; parameter to the compiler or &lt;code&gt;version = Foo&lt;/code&gt; in user code.</source>
          <target state="translated">设置版本标识符时调用，例如在编译器中使用 &lt;code&gt;-version=identifier&lt;/code&gt; 参数或用户代码中的 &lt;code&gt;version = Foo&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="495dea06203f25ae26116f2f5772a696918832bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#reset&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; will reset this to &lt;code&gt;Duration.zero&lt;/code&gt;.</source>
          <target state="translated">调用&lt;a href=&quot;#reset&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;将其重置为 &lt;code&gt;Duration.zero&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f23a63a5505f1213693ee8224d96b5310cf3183b" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#kill&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt; with the resulting &lt;code&gt;Pid&lt;/code&gt; is invalid.</source>
          <target state="translated">用生成的 &lt;code&gt;Pid&lt;/code&gt; 调用&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#kill&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt;无效。</target>
        </trans-unit>
        <trans-unit id="796201301481a494676b87bd22f58df79f6f3bdb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;printf()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69ccd3a1a7e462d569968184a6624c2a8f6e037" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;reopen&lt;/code&gt; with a &lt;code&gt;null&lt;/code&gt;&lt;code&gt;name&lt;/code&gt; is not implemented in all C runtimes.</source>
          <target state="translated">并非在所有C运行时中都以 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; 调用 &lt;code&gt;reopen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a670c32e5ff77bac0fbdbb4ed6c86d3156f5f82" translate="yes" xml:space="preserve">
          <source>Calling C Functions</source>
          <target state="translated">调用C函数</target>
        </trans-unit>
        <trans-unit id="2a58b71a9eba354c8a2762dcf96889501c4c8b2f" translate="yes" xml:space="preserve">
          <source>Calling C++ Global Functions from D</source>
          <target state="translated">从D中调用C++全局函数</target>
        </trans-unit>
        <trans-unit id="0af92a8a9a70b3aa97a6e09d334eff695960b293" translate="yes" xml:space="preserve">
          <source>Calling CTFE-able functions or using manifest constants is also possible.</source>
          <target state="translated">也可以调用CTFE的函数或使用manifest常量。</target>
        </trans-unit>
        <trans-unit id="ab9616e4fb5ac458c376db23b38a3a4f41bdffa3" translate="yes" xml:space="preserve">
          <source>Calling Global D Functions From C++</source>
          <target state="translated">从C++中调用全局D函数</target>
        </trans-unit>
        <trans-unit id="011de1cd8c5a8313b4819150b58f7b77ffe1686b" translate="yes" xml:space="preserve">
          <source>Calling an Instance Method</source>
          <target state="translated">调用实例方法</target>
        </trans-unit>
        <trans-unit id="882cd8e97a7e6dec1b20f7ffc308265e42981f07" translate="yes" xml:space="preserve">
          <source>Calling an Objective-C instance method uses the same syntax as calling regular D methods:</source>
          <target state="translated">调用Objective-C实例方法与调用普通D方法使用相同的语法。</target>
        </trans-unit>
        <trans-unit id="2837bac68cbbca90ef92df0ecb7045b8bad05e30" translate="yes" xml:space="preserve">
          <source>Calling any system functions.</source>
          <target state="translated">调用任何系统功能。</target>
        </trans-unit>
        <trans-unit id="99afec36350160ba55067caa792fb170d47da7f2" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the @nogc-ness, i.e. if we're in a @nogc function we can only call other @nogc functions. Returns true if error occurs.</source>
          <target state="translated">调用函数f.检查@nogc-ness,即如果我们在一个@nogc函数中,只能调用其他@nogc函数。如果发生错误则返回true。</target>
        </trans-unit>
        <trans-unit id="889558fe1d6b373ebfb4108727201ca1efea7bd9" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the purity, i.e. if we're in a pure function we can only call other pure functions. Returns true if error occurs.</source>
          <target state="translated">调用函数f,检查纯度,即如果我们在一个纯函数中,只能调用其他纯函数。如果发生错误则返回true。</target>
        </trans-unit>
        <trans-unit id="9d07dff2f17d03cbf0372862de2a911c37b1df31" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the safety, i.e. if we're in a @safe function we can only call @safe or @trusted functions. Returns true if error occurs.</source>
          <target state="translated">调用函数f.检查安全,即如果我们在@safe函数中,我们只能调用@safe或@trusted函数。如果发生错误则返回true。</target>
        </trans-unit>
        <trans-unit id="49f72934b9748e8925ba7a574cd2caf074e942d5" translate="yes" xml:space="preserve">
          <source>Calling printf()</source>
          <target state="translated">调用printf()</target>
        </trans-unit>
        <trans-unit id="06859dbd6f7a9d0b1a468c855675188601e16f52" translate="yes" xml:space="preserve">
          <source>Calling this function sets a flag indicating that this struct is no longer worker-local, and attempting to use the &lt;code&gt;get&lt;/code&gt; method again will result in an assertion failure if assertions are enabled.</source>
          <target state="translated">调用此函数将设置一个标志，指示该结构不再是本地工作人员，并且如果启用断言，则再次尝试使用 &lt;code&gt;get&lt;/code&gt; 方法将导致断言失败。</target>
        </trans-unit>
        <trans-unit id="c5e417ef005e02e78fdb802550dfe5fd2fa097a5" translate="yes" xml:space="preserve">
          <source>Calling this function with &lt;code&gt;blocking = true&lt;/code&gt; from a worker thread that is a member of the same &lt;code&gt;TaskPool&lt;/code&gt; that &lt;code&gt;finish&lt;/code&gt; is being called on will result in a deadlock.</source>
          <target state="translated">调用这个函数 &lt;code&gt;blocking = true&lt;/code&gt; 从工作线程相同的成员 &lt;code&gt;TaskPool&lt;/code&gt; 即 &lt;code&gt;finish&lt;/code&gt; 正在呼吁将导致死锁。</target>
        </trans-unit>
        <trans-unit id="a483b09288907bf0c6892b8a0c3a3688580a1534" translate="yes" xml:space="preserve">
          <source>Calling this function, and then using references to data located after the given array results in undefined behavior.</source>
          <target state="translated">调用这个函数,然后使用位于给定数组之后的数据引用,会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="0a48762ee3e2f7b163567b2b8c2bdc321fb3d29c" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt; for the file handle.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt;作为文件句柄。</target>
        </trans-unit>
        <trans-unit id="5fa582845b2a8965acb06e6a0955d839742fab8a" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt; for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt;作为文件句柄。分别从输入数组的大小和类型推断要读取的项目数和每个项目的大小。</target>
        </trans-unit>
        <trans-unit id="4204f336078b400c2ca8218f3dc707eed9fc8eef" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt; for the file handle to move its position indicator.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt;来使文件句柄移动其位置指示器。</target>
        </trans-unit>
        <trans-unit id="b841aa017960fa21330d3bce71d1341f08261fc1" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt; for the managed file handle.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt;作为托管文件句柄。</target>
        </trans-unit>
        <trans-unit id="19416b73e0b0cfe1706209f1904f9557babb3844" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt; for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the buffer could not be written in its entirety.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt;作为文件句柄。分别从输入数组的大小和类型推断要写入的项目数和每个项目的大小。如果无法完整写入缓冲区，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="b50971f4c5e8a0e45c73e7c7c90d36d61fddcb7f" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;rewind&lt;/a&gt; for the file handle.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;倒带&lt;/a&gt;文件句柄。</target>
        </trans-unit>
        <trans-unit id="6954ffddc60a249c70b2b20272f1b59673a22e6b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt; for the file handle.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt;作为文件句柄。</target>
        </trans-unit>
        <trans-unit id="660af3415b8af8c796363c6a336c94f83d470574" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; (as it must be called or copied in any function overriding &lt;code&gt;newScope&lt;/code&gt;), then set the &lt;code&gt;Scope&lt;/code&gt;'s depdecl.</source>
          <target state="translated">调用 &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; （因为必须在覆盖 &lt;code&gt;newScope&lt;/code&gt; 的任何函数中调用或复制它），然后设置 &lt;code&gt;Scope&lt;/code&gt; 的depdecl。</target>
        </trans-unit>
        <trans-unit id="ea66981f1c839cec218fd677425515ff882faad6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;free(b.ptr)&lt;/code&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">在Posix上调用 &lt;code&gt;free(b.ptr)&lt;/code&gt; ，在Windows 上调用__aligned_free &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e076da4834d8b045458f6ec7dd1c5d3b78bd298c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;impl.deallocateAll()&lt;/code&gt; and returns the result if defined, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;impl.deallocateAll()&lt;/code&gt; 并返回结果（如果已定义），否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b0309269b86732c6de69ae225028495fc3e76bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order, stopping when either range has been exhausted.</source>
          <target state="translated">呼叫 &lt;code&gt;move(a, b)&lt;/code&gt; 对每个元件 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;src&lt;/code&gt; 和相应的元件 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;tgt&lt;/code&gt; ，在增加的顺序，当任一范围已经耗尽停止。</target>
        </trans-unit>
        <trans-unit id="b3aff67db2952371a04e1469cf552b2bafe5ed21" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order.</source>
          <target state="translated">呼叫 &lt;code&gt;move(a, b)&lt;/code&gt; 对每个元件 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;src&lt;/code&gt; 和相应的元件 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;tgt&lt;/code&gt; ，按递增顺序。</target>
        </trans-unit>
        <trans-unit id="9326ff35ce625813cb6e134a6874955a7343c986" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;popBack&lt;/code&gt; for all controlled ranges.</source>
          <target state="translated">为所有受控范围调用 &lt;code&gt;popBack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cb6a5ebd9c3d585d565184c781a892ebfa3d0e5" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol.</source>
          <target state="translated">对每个Dsymbol调用dg(Dsymbol *sym)。</target>
        </trans-unit>
        <trans-unit id="f0ea91146057c0154bb8b4caec2606cab70e289d" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol. If dg returns !=0, stops and returns that value else returns 0.</source>
          <target state="translated">对每个Dsymbol调用dg(Dsymbol *sym)。如果 dg 返回 !=0,则停止并返回该值,否则返回 0。</target>
        </trans-unit>
        <trans-unit id="20447109fe962cd134aaca38e701f9a14ee5ab9e" translate="yes" xml:space="preserve">
          <source>Calls the destructor &lt;code&gt;~this()&lt;/code&gt; for the object referred to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a class or interface reference) or for the object pointed to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a pointer to a &lt;code&gt;struct&lt;/code&gt;). Arrays of structs call the destructor, if defined, for each element in the array. If no destructor is defined, this step has no effect.</source>
          <target state="translated">为 &lt;code&gt;x&lt;/code&gt; 引用的对象（如果 &lt;code&gt;x&lt;/code&gt; 是类或接口引用）或 &lt;code&gt;x&lt;/code&gt; 指向的对象（如果 &lt;code&gt;x&lt;/code&gt; 是指向 &lt;code&gt;struct&lt;/code&gt; 的指针 &lt;code&gt;~this()&lt;/code&gt; 调用析构函数〜this（）。结构数组为数组中的每个元素调用析构函数（如果已定义）。如果未定义析构函数，则此步骤无效。</target>
        </trans-unit>
        <trans-unit id="d91be267ab03b3c9611f9cbcd4786308f2144fc6" translate="yes" xml:space="preserve">
          <source>Calls to functions with &lt;code&gt;extern(D)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;linkage&lt;/a&gt; (which is the default linkage) are evaluated in the following order: first, if necessary, the address of the function to call is evaluated (e.g. in the case of a computed function pointer or delegate). Then, arguments are evaluated left to right. Finally, transfer is passed to the function. Example:</source>
          <target state="translated">具有 &lt;code&gt;extern(D)&lt;/code&gt; &lt;a href=&quot;attribute#linkage&quot;&gt;链接&lt;/a&gt;（默认链接）的函数的调用按以下顺序进行评估：首先，如有必要，将评估要调用的函数的地址（例如，在使用计算函数指针或委托的情况下） 。然后，从左到右评估参数。最后，将传递传递给函数。例：</target>
        </trans-unit>
        <trans-unit id="0645e6f6a8a53952c04e63653f8086d201146bb8" translate="yes" xml:space="preserve">
          <source>Calls to the free standing log functions are not directly forwarded to the global &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;sharedLog&lt;/code&gt;. Actually, a thread local &lt;code&gt;Logger&lt;/code&gt; of type &lt;code&gt;StdForwardLogger&lt;/code&gt; processes the log call and then, by default, forwards the created &lt;code&gt;Logger.LogEntry&lt;/code&gt; to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The thread local &lt;code&gt;Logger&lt;/code&gt; is accessible by the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; property. This property allows to assign user defined &lt;code&gt;Logger&lt;/code&gt;. The default &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt; is &lt;code&gt;LogLevel.all&lt;/code&gt; and it will therefore forward all messages to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; can be used to filter log calls before they reach the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">对独立日志功能的调用不会直接转发到全局 &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;sharedLog&lt;/code&gt; 。实际上，类型为 &lt;code&gt;StdForwardLogger&lt;/code&gt; 的线程本地 &lt;code&gt;Logger&lt;/code&gt; 处理该日志调用，然后默认情况下将创建的 &lt;code&gt;Logger.LogEntry&lt;/code&gt; 转发到 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 。线程本地 &lt;code&gt;Logger&lt;/code&gt; 可通过 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 属性访问。此属性允许分配用户定义的 &lt;code&gt;Logger&lt;/code&gt; 。默认 &lt;code&gt;LogLevel&lt;/code&gt; 中的 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 是 &lt;code&gt;LogLevel.all&lt;/code&gt; ，因此它会转发到所有消息 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 。该 &lt;code&gt;LogLevel&lt;/code&gt; 的了的 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 可在到达之前，用于过滤日志调用 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb904d86116e0af2b9834a7896df4545d587c42c" translate="yes" xml:space="preserve">
          <source>Can also assign class values</source>
          <target state="translated">也可以分配类值</target>
        </trans-unit>
        <trans-unit id="0e9fa73b910a6a2eb1eaa95a1ab5ac09bd2a00f0" translate="yes" xml:space="preserve">
          <source>Can be called from either the driver or a &lt;code&gt;debug = Ident;&lt;/code&gt; statement. Unlike version identifier, there isn't any reserved debug identifier so no validation takes place.</source>
          <target state="translated">可以从驱动程序或 &lt;code&gt;debug = Ident;&lt;/code&gt; 调用= Ident; 声明。与版本标识符不同，没有任何保留的调试标识符，因此不会进行验证。</target>
        </trans-unit>
        <trans-unit id="38f77fd06cc4025566434eff583d8ad55911f526" translate="yes" xml:space="preserve">
          <source>Can be overridden to support other addresses.</source>
          <target state="translated">可以覆盖支持其他地址。</target>
        </trans-unit>
        <trans-unit id="b93c4ede92c61cd906a3c26c9c976c09eb1f2fc5" translate="yes" xml:space="preserve">
          <source>Can start enumeration from a negative position:</source>
          <target state="translated">可以从负数位置开始列举。</target>
        </trans-unit>
        <trans-unit id="9a5600ddf1629b08398131936e3e9652bd1d2e46" translate="yes" xml:space="preserve">
          <source>Can variable be read and written by CTFE?</source>
          <target state="translated">变量可以被CTFE读取和写入吗?</target>
        </trans-unit>
        <trans-unit id="3b92458a5ee7b262130f2150d91ab4bffe0cab98" translate="yes" xml:space="preserve">
          <source>Can't run semantic on s now, try again later.</source>
          <target state="translated">现在不能在s上运行语义,以后再试。</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="77dfd2135f4db726c47299bb55be26f7f4525a46" translate="yes" xml:space="preserve">
          <source>Cancel</source>
          <target state="translated">Cancel</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">取消自动延期加载</target>
        </trans-unit>
        <trans-unit id="33b8203d640b9445058eff13b7f608ffa2a1d260" translate="yes" xml:space="preserve">
          <source>Cannot access &lt;code&gt;__gshared&lt;/code&gt; variables.</source>
          <target state="translated">无法访问 &lt;code&gt;__gshared&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="23679ec318316b42991fb0add8c6df84610db970" translate="yes" xml:space="preserve">
          <source>Cannot access unions that have pointers or references overlapping with other types.</source>
          <target state="translated">不能访问有指针或引用与其他类型重叠的联合体。</target>
        </trans-unit>
        <trans-unit id="486e3c068e9f84acb903fe338c21a7a8da40f7e4" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for class or interface references.</source>
          <target state="translated">不能将 &lt;code&gt;void&lt;/code&gt; 初始化程序用于类或接口引用。</target>
        </trans-unit>
        <trans-unit id="71a9611e8c1a236df296e1967a0f6238ddd70798" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for pointers.</source>
          <target state="translated">不能将 &lt;code&gt;void&lt;/code&gt; 初始化程序用于指针。</target>
        </trans-unit>
        <trans-unit id="774c0fbc4f368f6c2081f7a0dddc8b68729cb7f6" translate="yes" xml:space="preserve">
          <source>Canonical decomposition. The result is canonically equivalent sequence.</source>
          <target state="translated">规范分解。结果是规范的等价序列。</target>
        </trans-unit>
        <trans-unit id="aae48ee7b1f403f38486b8bf47778fda77282b5f" translate="yes" xml:space="preserve">
          <source>Canonical name, when &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; 时的规范名称。</target>
        </trans-unit>
        <trans-unit id="ca2d0802f87ef08825202a1ca29c54992dad17b0" translate="yes" xml:space="preserve">
          <source>Capabilities of the CPU the program is running on.</source>
          <target state="translated">程序运行的CPU的能力。</target>
        </trans-unit>
        <trans-unit id="7e1973f266a216415dc191028046ea7f74365eb7" translate="yes" xml:space="preserve">
          <source>Capacity desired. This constructor is defined only if &lt;code&gt; ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;.</source>
          <target state="translated">所需容量。仅当 &lt;code&gt; ParentAllocator&lt;/code&gt; 不是 &lt;code&gt;NullAllocator&lt;/code&gt; 时,才定义此构造函数。</target>
        </trans-unit>
        <trans-unit id="70603ccef126aa6da95612288168a613c4bc83f0" translate="yes" xml:space="preserve">
          <source>Capitalize a the first character of a ASCII string.</source>
          <target state="translated">ASCII字符串的第一个字符大写。</target>
        </trans-unit>
        <trans-unit id="7bac59f23d8a421d02552a2b75009a6de4d133eb" translate="yes" xml:space="preserve">
          <source>Capitalize an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; or string, meaning convert the first character to upper case and subsequent characters to lower case.</source>
          <target state="translated">将&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;或字符串大写，这意味着将第一个字符转换为大写，将后续字符转换为小写。</target>
        </trans-unit>
        <trans-unit id="d87b28abafacc3e31f8a5ef814dc1a89c95adc81" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of &lt;code&gt;s&lt;/code&gt; and convert the rest of &lt;code&gt;s&lt;/code&gt; to lowercase.</source>
          <target state="translated">大写的第一个字符 &lt;code&gt;s&lt;/code&gt; 和其余转换 &lt;code&gt;s&lt;/code&gt; 为小写。</target>
        </trans-unit>
        <trans-unit id="63beb67c34339e7c0d71b7c05343dfc0c5c06706" translate="yes" xml:space="preserve">
          <source>Captures a range state.</source>
          <target state="translated">捕获一个范围状态。</target>
        </trans-unit>
        <trans-unit id="6e0d5cedfdd10366517f607a93eeeef9b4785a51" translate="yes" xml:space="preserve">
          <source>Carian</source>
          <target state="translated">Carian</target>
        </trans-unit>
        <trans-unit id="df10067f5a8780a3c7f1ce6b060b8d78df100b22" translate="yes" xml:space="preserve">
          <source>Carriage return</source>
          <target state="translated">回程车</target>
        </trans-unit>
        <trans-unit id="b94582323a02af8750c89d9914ff8a094fbada5b" translate="yes" xml:space="preserve">
          <source>Carriage return (U+000D).</source>
          <target state="translated">回车(U+000D)。</target>
        </trans-unit>
        <trans-unit id="9254c4bba00f5ff69304a7921d3118fcbac7e6b8" translate="yes" xml:space="preserve">
          <source>Case</source>
          <target state="translated">Case</target>
        </trans-unit>
        <trans-unit id="af7c0d9ee5c8a6c4478105142a141d1bad096c35" translate="yes" xml:space="preserve">
          <source>Case expressions must all evaluate to distinct values. Const or immutable variables must all have different names. If they share a value, the first case statement with that value gets control. There must be exactly one default statement.</source>
          <target state="translated">案例表达式必须全部计算为不同的值。Const或不可变的变量必须都有不同的名字。如果它们共享一个值,则第一个具有该值的case语句获得控制权。必须只有一个缺省语句。</target>
        </trans-unit>
        <trans-unit id="be29d0c965453b901d4ad20bdc8e2ddd09f27c5c" translate="yes" xml:space="preserve">
          <source>Case insensitive matching.</source>
          <target state="translated">不区分大小写的匹配。</target>
        </trans-unit>
        <trans-unit id="b632747e3a93dfa45ef0653a66ab6ac246268230" translate="yes" xml:space="preserve">
          <source>Case statements and default statements associated with the switch can be nested within block statements; they do not have to be in the outermost block. For example, this is allowed:</source>
          <target state="translated">与开关相关的案例语句和默认语句可以嵌套在块语句中,它们不一定要在最外层的块中。例如,这是允许的。</target>
        </trans-unit>
        <trans-unit id="4830655a69813534d85f86f1ac7683b83fc06b02" translate="yes" xml:space="preserve">
          <source>Case-insensitive find of a string</source>
          <target state="translated">不区分大小写的字符串查找</target>
        </trans-unit>
        <trans-unit id="22a0daee669e27ee86078432c6d32a4c0da14fe0" translate="yes" xml:space="preserve">
          <source>Case-insensitive string comparison (&lt;a href=&quot;#sicmp&quot;&gt;&lt;code&gt;sicmp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#icmp&quot;&gt;&lt;code&gt;icmp&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">不区分大小写的字符串比较（&lt;a href=&quot;#sicmp&quot;&gt; &lt;code&gt;sicmp&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#icmp&quot;&gt; &lt;code&gt;icmp&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dc02e22f8ccf2c7182decb6993c9ab41402098ce" translate="yes" xml:space="preserve">
          <source>Case-sensitivity of the comparison.</source>
          <target state="translated">比较的案例敏感度。</target>
        </trans-unit>
        <trans-unit id="8647c28bed14fb487e34d3da55fb4ace9c3a88fa" translate="yes" xml:space="preserve">
          <source>CaseRangeStatement</source>
          <target state="translated">CaseRangeStatement</target>
        </trans-unit>
        <trans-unit id="f31bf93714d4f8de709a473ac493e8917fd94741" translate="yes" xml:space="preserve">
          <source>CaseSensitive &lt;code&gt;cs&lt;/code&gt;</source>
          <target state="translated">区分大小写的 &lt;code&gt;cs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82cbdef9815d26de04f79b63bed3258b574ec1e5" translate="yes" xml:space="preserve">
          <source>CaseStatements* &lt;strong id=&quot;cases&quot;&gt;cases&lt;/strong&gt;;</source>
          <target state="translated">CaseStatements * &lt;strong id=&quot;cases&quot;&gt;案例&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="93e81c6075ed3230ff50ed8c47578708810401aa" translate="yes" xml:space="preserve">
          <source>Case_Ignorable</source>
          <target state="translated">Case_Ignorable</target>
        </trans-unit>
        <trans-unit id="744f1d9b60891d9266196d1c3e78b1d6da592b82" translate="yes" xml:space="preserve">
          <source>Cased</source>
          <target state="translated">Cased</target>
        </trans-unit>
        <trans-unit id="f3d4dffe4c9ebac969ee4f02157e5740619b3299" translate="yes" xml:space="preserve">
          <source>Casing</source>
          <target state="translated">Casing</target>
        </trans-unit>
        <trans-unit id="fdce1732b6c6c14b93a5e9a8f896d5e70598b645" translate="yes" xml:space="preserve">
          <source>Cast Expressions</source>
          <target state="translated">铸造表情</target>
        </trans-unit>
        <trans-unit id="1be1f5579be197b60f4cbccf065fa7be7bb581e6" translate="yes" xml:space="preserve">
          <source>Cast Operator Overloading</source>
          <target state="translated">铸件操作人员超载</target>
        </trans-unit>
        <trans-unit id="5a95ed2864a76fc66062c5a7f51b3cb5c4d55c8a" translate="yes" xml:space="preserve">
          <source>Cast Operators</source>
          <target state="translated">铸造操作员</target>
        </trans-unit>
        <trans-unit id="ca826936bee948f2eb775d1f8e1ae92d516c0afe" translate="yes" xml:space="preserve">
          <source>Cast is not necessary if the type of the variable is inferred. See the example below.</source>
          <target state="translated">如果变量的类型是推断出来的,则不需要Cast。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="25e55b52ee2f3dc95810f24ff7dd2b0e1de46b08" translate="yes" xml:space="preserve">
          <source>CastExpression</source>
          <target state="translated">CastExpression</target>
        </trans-unit>
        <trans-unit id="f137db9c32541b4a024e2e40ec97ea3e4571d7c9" translate="yes" xml:space="preserve">
          <source>Casting a class object to an interface consists of adding the offset of the interface's corresponding vptr to the address of the base of the object. Casting an interface ptr back to the class type it came from involves getting the correct offset to subtract from it from the object.Interface entry at vtbl[0]. Adjustor thunks are created and pointers to them stored in the method entries in the vtbl[] in order to set the this pointer to the start of the object instance corresponding to the implementing method.</source>
          <target state="translated">将一个类对象投向一个接口,包括将接口对应的vptr的偏移量加到对象的基地址上。将一个接口ptr投回它来自的类类型,涉及到从对象中得到正确的偏移量来减去它.接口条目在vtbl[0]。创建调整器thunks,并将其指针存储在vtbl[]的方法条目中,以便将该指针设置为对应于实现方法的对象实例的开始。</target>
        </trans-unit>
        <trans-unit id="2be16817be1151d2bfd103342ffb9b83c9bc8eec" translate="yes" xml:space="preserve">
          <source>Casting a dynamic array to another dynamic array is done only if the array lengths multiplied by the element sizes match. The cast is done as a type paint, with the array length adjusted to match any change in element size. If there's not a match, a runtime error is generated.</source>
          <target state="translated">只有当一个动态数组的长度乘以元素大小匹配时,才会将一个动态数组投射到另一个动态数组。投放是以类型画的方式进行的,并调整数组长度以匹配元素大小的任何变化。如果不匹配,会产生一个运行时错误。</target>
        </trans-unit>
        <trans-unit id="16edfc7539440dbdc02f7a14941c4d5ef8ef9a5e" translate="yes" xml:space="preserve">
          <source>Casting a floating point literal from one type to another changes its type, but internally it is retained at full precision for the purposes of constant folding.</source>
          <target state="translated">将一个浮点文字从一个类型投向另一个类型,会改变它的类型,但在内部会保留全精度,以达到不断折叠的目的。</target>
        </trans-unit>
        <trans-unit id="11324dd9fa7b8d9c53df605d6416fafef2a68188" translate="yes" xml:space="preserve">
          <source>Casting a floating point value to an integral type is the equivalent of converting to an integer using truncation.</source>
          <target state="translated">将浮点值转为积分类型相当于用截断法转换为整数。</target>
        </trans-unit>
        <trans-unit id="f259cd40444c3107ae944acf4631f694eae6b61d" translate="yes" xml:space="preserve">
          <source>Casting a pointer type to and from a class type is done as a type paint (i.e. a reinterpret cast).</source>
          <target state="translated">将一个指针类型投向一个类类型和从一个类类型投向一个类类型,是作为一个类型画来完成的(即重新解释投向)。</target>
        </trans-unit>
        <trans-unit id="67471401dacb96c319b67d90467f1e1ec414ef57" translate="yes" xml:space="preserve">
          <source>Casting a value</source>
          <target state="translated">投放一个值</target>
        </trans-unit>
        <trans-unit id="c6340b2b57764ca857638ab68adda2ab272e357c" translate="yes" xml:space="preserve">
          <source>Casting an expression to &lt;code&gt;void&lt;/code&gt; type is allowed to mark that the result is unused. On &lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement&lt;/i&gt;&lt;/a&gt;, it could be used properly to avoid &quot;has no effect&quot; error.</source>
          <target state="translated">将表达式强制转换为 &lt;code&gt;void&lt;/code&gt; 类型可以标记未使用的结果。在&lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement上&lt;/i&gt;&lt;/a&gt;，可以正确使用它来避免&amp;ldquo;没有效果&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="01335a9c442d0255ed0b8bd54d5bf5a26e8b8dab" translate="yes" xml:space="preserve">
          <source>Casting operator to integral, &lt;code&gt;bool&lt;/code&gt;, or floating point type. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpCast&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt;. Otherwise, casting to &lt;code&gt;bool&lt;/code&gt; yields &lt;code&gt; get != 0&lt;/code&gt; and casting to another integral that can represent all values of &lt;code&gt;T&lt;/code&gt; returns &lt;code&gt;get&lt;/code&gt; promoted to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">将运算符 &lt;code&gt;bool&lt;/code&gt; 转换为整型，布尔型或浮点型。如果 &lt;code&gt;Hook&lt;/code&gt; 定义了 &lt;code&gt;hookOpCast&lt;/code&gt; ，则调用将立即返回 &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; 。否则，铸造 &lt;code&gt;bool&lt;/code&gt; 的产量 &lt;code&gt; get != 0&lt;/code&gt; ，铸造到另一个不可或缺的，可以代表所有值 &lt;code&gt;T&lt;/code&gt; 的回报 &lt;code&gt;get&lt;/code&gt; 提升到 &lt;code&gt;U&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="563db6d9dd42954287b5cda42119295bd4e28aa4" translate="yes" xml:space="preserve">
          <source>Casting pointers to non-pointers and vice versa is allowed.</source>
          <target state="translated">允许将指针投向非指针,反之亦然。</target>
        </trans-unit>
        <trans-unit id="e8c8325b9ae374bf1edc7d50c4d5a016a9981e5a" translate="yes" xml:space="preserve">
          <source>Casting to a &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; replaces the qualifiers to the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;强制&lt;/i&gt;&lt;/a&gt;转换为&lt;i&gt;CastQual会将限定符&lt;/i&gt;替换为&lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="3d98bf7b9cde5141dc8af74c8c9759ef593ae47b" translate="yes" xml:space="preserve">
          <source>Casting to/from &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; may break type system guarantees. Use with care.</source>
          <target state="translated">从 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;immutable&lt;/code&gt; 类型进行转换可能会破坏类型的系统保证。小心使用。</target>
        </trans-unit>
        <trans-unit id="b02f79fb40c6ba2556a5ea0081aed386869f0012" translate="yes" xml:space="preserve">
          <source>Casting with no &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; or &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; removes any top level &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;inout&lt;/code&gt; type modifiers from the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">没有&lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt;或&lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual的强制&lt;/i&gt;&lt;/a&gt;&lt;i&gt;类型&lt;/i&gt;&lt;i&gt;转换&lt;/i&gt;会从&lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;的类型中删除任何顶级 &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;immutable&lt;/code&gt; ， &lt;code&gt;shared&lt;/code&gt; 或 &lt;code&gt;inout&lt;/code&gt; 类型修饰符。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="5591322bc1301d82b541b6b5ad169c351dc74a45" translate="yes" xml:space="preserve">
          <source>Casts a mutable array to an immutable array in an idiomatic manner. Technically, &lt;code&gt;assumeUnique&lt;/code&gt; just inserts a cast, but its name documents assumptions on the part of the caller. &lt;code&gt;assumeUnique(arr)&lt;/code&gt; should only be called when there are no more active mutable aliases to elements of &lt;code&gt; arr&lt;/code&gt;. To strengthen this assumption, &lt;code&gt;assumeUnique(arr)&lt;/code&gt; also clears &lt;code&gt;arr&lt;/code&gt; before returning. Essentially &lt;code&gt; assumeUnique(arr)&lt;/code&gt; indicates commitment from the caller that there is no more mutable access to any of &lt;code&gt;arr&lt;/code&gt;'s elements (transitively), and that all future accesses will be done through the immutable array returned by &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">以惯用方式将可变数组转换为不可变数组。从技术上讲， &lt;code&gt;assumeUnique&lt;/code&gt; 只是插入一个强制转换，但是其名称记录了调用方的假设。仅当不再存在 &lt;code&gt; arr&lt;/code&gt; 元素的活动可变别名时，才应调用 &lt;code&gt;assumeUnique(arr)&lt;/code&gt; 。为了加强这一假设，假定 &lt;code&gt;assumeUnique(arr)&lt;/code&gt; 在返回之前也清除了 &lt;code&gt;arr&lt;/code&gt; 。本质上， &lt;code&gt; assumeUnique(arr)&lt;/code&gt; 指示调用方承诺不再（传递地）对 &lt;code&gt;arr&lt;/code&gt; 的任何元素进行可变访问，并且所有将来的访问都将通过 &lt;code&gt;assumeUnique&lt;/code&gt; 返回的不可变数组完成。</target>
        </trans-unit>
        <trans-unit id="96fd17cf1de8b408679f9b1db49477fb8f0c66b6" translate="yes" xml:space="preserve">
          <source>Casts that break the type system.</source>
          <target state="translated">打破类型体系的铸造。</target>
        </trans-unit>
        <trans-unit id="bc260f3af1fc6e8bf46c5b8f8a854fbc6153096b" translate="yes" xml:space="preserve">
          <source>Cat Expressions</source>
          <target state="translated">猫的表情</target>
        </trans-unit>
        <trans-unit id="a953a29fa47d85867e2fab2716c48cee491dd470" translate="yes" xml:space="preserve">
          <source>CatExpression</source>
          <target state="translated">CatExpression</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="d3ce6d6c33d89c5cd835012c244acc4d8b858a0e" translate="yes" xml:space="preserve">
          <source>CatchParameter</source>
          <target state="translated">CatchParameter</target>
        </trans-unit>
        <trans-unit id="5e59a1d3b6be9c8f0e29f469cc4ebfb54cc7e205" translate="yes" xml:space="preserve">
          <source>Catches</source>
          <target state="translated">Catches</target>
        </trans-unit>
        <trans-unit id="f1645524550ec6b1dbf604c910de525c1199c393" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned and &lt;code&gt;result&lt;/code&gt; is set to the result of the expression.</source>
          <target state="translated">捕获并返回从给定表达式引发的异常。如果未引发任何异常，则返回null并将 &lt;code&gt;result&lt;/code&gt; 设置为表达式的结果。</target>
        </trans-unit>
        <trans-unit id="040c55a2a9c3c731e36a7abc0e21f539bc1f80a5" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">捕获并返回从给定表达式引发的异常。如果没有引发异常，则返回null。 &lt;code&gt;E&lt;/code&gt; 可以是 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d90ffac3b749155c40310e22300174e6246501c0" translate="yes" xml:space="preserve">
          <source>Catches the exception thrown from the given expression and returns the msg property of that exception. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">捕获从给定表达式引发的异常，并返回该异常的msg属性。如果没有引发异常，则返回null。 &lt;code&gt;E&lt;/code&gt; 可以是 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73a0dfe4cefda0d8bb54b75566ce6c7751cb0769" translate="yes" xml:space="preserve">
          <source>Catching C++ Class Objects</source>
          <target state="translated">捕捉C++类对象</target>
        </trans-unit>
        <trans-unit id="df7467bf765f309d90be05cf8631fc4bacfe7590" translate="yes" xml:space="preserve">
          <source>Categories of types</source>
          <target state="translated">类型类别</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="729cda91611ce285ba0ef14cc4efdd486065b7fa" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an</source>
          <target state="translated">导致汇编器发出NOP指令,以对齐下一条汇编器指令。</target>
        </trans-unit>
        <trans-unit id="147c8bbdbf1f140f88bd53dffd29cf82c9997a05" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an even boundary.</source>
          <target state="translated">使汇编器发出NOP指令,将下一条汇编器指令对准偶数边界。</target>
        </trans-unit>
        <trans-unit id="70c5dda624176ab62b854d62901ed2b2ed8a9f72" translate="yes" xml:space="preserve">
          <source>Causes the compiler to not generate the function prolog and epilog sequences. This means such is the responsibility of inline assembly programmer, and is normally used when the entire function is to be written in assembler.</source>
          <target state="translated">导致编译器不生成函数的prolog和epilog序列。这意味着这种情况是内联汇编程序员的责任,通常在整个函数要用汇编程序编写时使用。</target>
        </trans-unit>
        <trans-unit id="1fd6a880ee16bb33003559b204f8a2cff5a9e90c" translate="yes" xml:space="preserve">
          <source>Cc</source>
          <target state="translated">Cc</target>
        </trans-unit>
        <trans-unit id="51f00921e108b6ca8be5e3997778036a6ec831aa" translate="yes" xml:space="preserve">
          <source>Cells in the delimiter row contain hyphens (&lt;code&gt;-&lt;/code&gt;) and optional colons (&lt;code&gt;:&lt;/code&gt;). A &lt;code&gt;:&lt;/code&gt; to the left of the hyphens creates a left-aligned column, a &lt;code&gt;:&lt;/code&gt; to the right of the hyphens creates a right-aligned column (like the example above), and &lt;code&gt;:&lt;/code&gt;'s on both sides of the hyphens create a center-aligned column.</source>
          <target state="translated">定界符行中单元格中包含连字符（ &lt;code&gt;-&lt;/code&gt; ）和可选的冒号（ &lt;code&gt;:&lt;/code&gt; ）。连字符左侧的A &lt;code&gt;:&lt;/code&gt; 创建一个左对齐的列，连字符右侧的a &lt;code&gt;:&lt;/code&gt; 创建一个右对齐的列（如上面的示例），而连字符两侧的 &lt;code&gt;:&lt;/code&gt; 都创建一个中心-对齐的列。</target>
        </trans-unit>
        <trans-unit id="20b2af77551ab62ecafee8361a6775168a8911be" translate="yes" xml:space="preserve">
          <source>Centaur Isiah = VIA Nano (family 6, model F) is an out-of-order core.</source>
          <target state="translated">Centaur Isiah=VIA Nano(家族6,型号F)是一个失序的核心。</target>
        </trans-unit>
        <trans-unit id="8408f82534bfffd0ab07188fc9d719f71130e4e0" translate="yes" xml:space="preserve">
          <source>Center &lt;code&gt;s&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;s&lt;/code&gt; doesn't fill.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 在字段 &lt;code&gt;width&lt;/code&gt; 居中字符宽。 &lt;code&gt;fillChar&lt;/code&gt; 是将用于填充 &lt;code&gt;s&lt;/code&gt; 不会填充的字段中的字符的字符。</target>
        </trans-unit>
        <trans-unit id="4e74b6056afd83cbdf235c0e1e1aa022d7643f34" translate="yes" xml:space="preserve">
          <source>Center justify &lt;code&gt;r&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;r&lt;/code&gt; doesn't fill.</source>
          <target state="translated">在字段 &lt;code&gt;width&lt;/code&gt; 字符宽度居中对齐 &lt;code&gt;r&lt;/code&gt; 。 &lt;code&gt;fillChar&lt;/code&gt; 是将用于填充 &lt;code&gt;r&lt;/code&gt; 未填充的字段中的字符的字符。</target>
        </trans-unit>
        <trans-unit id="fb14d77020e4dbef1a189a81fe3dbc04509cb2d1" translate="yes" xml:space="preserve">
          <source>Certain alphabets like German and Greek have no 1:1 upper-lower mapping. Use overload of toUpper which takes full string instead.</source>
          <target state="translated">某些字母,如德语和希腊语,没有1:1的上下层映射。使用toUpper的重载,它可以取全字符串代替。</target>
        </trans-unit>
        <trans-unit id="64a2e3e9bc5b4cd297d23de932339bb6c474455f" translate="yes" xml:space="preserve">
          <source>Cf</source>
          <target state="translated">Cf</target>
        </trans-unit>
        <trans-unit id="70b3ae21ee59942a0d41812e09cc5d908774f36f" translate="yes" xml:space="preserve">
          <source>Chain multiple calls to ifThrown, each capturing errors from the entire preceding expression.</source>
          <target state="translated">对ifThrown进行多次链式调用,每次调用都会从前面的整个表达式中捕获错误。</target>
        </trans-unit>
        <trans-unit id="6a803e5d1d5407c176b6adb93c4ec23f4ef3c32f" translate="yes" xml:space="preserve">
          <source>Chakma</source>
          <target state="translated">Chakma</target>
        </trans-unit>
        <trans-unit id="5e052ac9c7fd6c9d46817ea48b907dbb7047ae81" translate="yes" xml:space="preserve">
          <source>Cham</source>
          <target state="translated">Cham</target>
        </trans-unit>
        <trans-unit id="c94dac697486986e71af2c37242755c0937be074" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and POSIX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458b3d4cc82936041a171ad6f7ca77493ddeb2bd" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and Posix.</source>
          <target state="translated">将目录更改为 &lt;code&gt;pathname&lt;/code&gt; 。与Windows和Posix 上的 &lt;code&gt;cd&lt;/code&gt; 等效。</target>
        </trans-unit>
        <trans-unit id="6f314cb3c24c1c8ee48dc8abfd534cc520363d6c" translate="yes" xml:space="preserve">
          <source>Change match (fnmatch-like) callback for wildcard matching</source>
          <target state="translated">改变匹配(类似fnmatch)的回调,用于通配符匹配。</target>
        </trans-unit>
        <trans-unit id="e8304f2bae085deed1b3c8125f9fa43407a675db" translate="yes" xml:space="preserve">
          <source>Change the IEEE754 floating-point rounding mode and the floating-point hardware exceptions.</source>
          <target state="translated">改变IEEE754浮点运算模式和浮点硬件异常。</target>
        </trans-unit>
        <trans-unit id="9f333c0a78429177429051909d1f599b48a73b54" translate="yes" xml:space="preserve">
          <source>Change the floating-point hardware rounding mode</source>
          <target state="translated">改变浮点硬件取整模式</target>
        </trans-unit>
        <trans-unit id="3d9d32d43390d1a2629123edfc32deb49f461b6a" translate="yes" xml:space="preserve">
          <source>Change the key on an open database. If the current database is not encrypted, this routine will encrypt it. If pNew == 0 or nNew == 0, the database is decrypted.</source>
          <target state="translated">更改打开的数据库的密钥。如果当前数据库没有加密,这个例程将对其进行加密。如果pNew ==0或nNew ==0,数据库将被解密。</target>
        </trans-unit>
        <trans-unit id="5ba310a0f8acd1b8bbbdaa00b70d0bff2f5990f6" translate="yes" xml:space="preserve">
          <source>Change this function so the caller doesn't have to be aware of this issue. Either return by value and expect the caller to always check the base ptr as an indication of whether the struct is valid, or set the BlkInfo as a side-effect and return a bool to indicate success.</source>
          <target state="translated">修改这个函数,使调用者不必意识到这个问题。要么按值返回,并期望调用者总是检查base ptr作为结构是否有效的指示,要么将BlkInfo设置为副作用,并返回一个bool表示成功。</target>
        </trans-unit>
        <trans-unit id="e7d3b1db7f0a311580f3e633ae63903d1a427f37" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; arguments are not propagated to the call site, only to &lt;code&gt;args&lt;/code&gt; in this struct.</source>
          <target state="translated">对 &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 参数的更改不会传播到调用站点，而只会传播到此结构中的 &lt;code&gt;args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c06a1392ead6cea3258d7b832ab861bbcb2d0e3" translate="yes" xml:space="preserve">
          <source>Changing the rounding mode in the middle of a function can interfere with optimizations of floating point expressions, as the optimizer assumes that the rounding mode does not change. It is best to change the rounding mode only at the beginning of the function, and keep it until the function returns. It is also best to add the line:</source>
          <target state="translated">在函数中间改变四舍五入模式会干扰浮点表达式的优化,因为优化器假定四舍五入模式不会改变。最好只在函数开始时改变四舍五入模式,并保持到函数返回。也最好加上这一行。</target>
        </trans-unit>
        <trans-unit id="0f9ba953e35135a3f8ec268817cc92f2557202a9" translate="yes" xml:space="preserve">
          <source>Char</source>
          <target state="translated">Char</target>
        </trans-unit>
        <trans-unit id="c6b74142b3b389f15ac5cd805f70960cc3a1abf0" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">字符[] &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d66a912fb521a267fef61e2619d881aa8e9c5935" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">炭[] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516088a32b97fe8b60ae41af7a9da5ea8c8b89b1" translate="yes" xml:space="preserve">
          <source>Character Entities</source>
          <target state="translated">字符实体</target>
        </trans-unit>
        <trans-unit id="669b19e596ff87d2ed122a5266e7aff0c3d614e2" translate="yes" xml:space="preserve">
          <source>Character Literals</source>
          <target state="translated">字符</target>
        </trans-unit>
        <trans-unit id="2760308a0f6d1684065a6510212e96dc91848ae1" translate="yes" xml:space="preserve">
          <source>Character Set</source>
          <target state="translated">字符集</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">角色类</target>
        </trans-unit>
        <trans-unit id="ad3c933b2dd70972eec55e516f2ae9ffae669d0e" translate="yes" xml:space="preserve">
          <source>Character classification by category and common properties: &lt;a href=&quot;#isAlpha&quot;&gt;&lt;code&gt;isAlpha&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="translated">按类别和常见属性对字符进行分类：&lt;a href=&quot;#isAlpha&quot;&gt; &lt;code&gt;isAlpha&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; &lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="1ef00f56499c816e60a9c87369bcd2210570f41d" translate="yes" xml:space="preserve">
          <source>Character input ranges</source>
          <target state="translated">字符输入范围</target>
        </trans-unit>
        <trans-unit id="133c67a5c003572ca8daaddcc62800905a7a14d7" translate="yes" xml:space="preserve">
          <source>Character literals are a single character or escape sequence enclosed by single quotes.</source>
          <target state="translated">字符是由单引号括起来的单个字符或转义序列。</target>
        </trans-unit>
        <trans-unit id="aa8ec24f3290e6543c77a63504c45b69a0237e5a" translate="yes" xml:space="preserve">
          <source>Character literals are single characters and resolve to one of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;. If the literal is a &lt;code&gt;\u&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;wchar&lt;/code&gt;. If the literal is a &lt;code&gt;\U&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;dchar&lt;/code&gt;. Otherwise, it resolves to the type with the smallest size it will fit into.</source>
          <target state="translated">字符文字是单个字符，并且解析为 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;wchar&lt;/code&gt; 或 &lt;code&gt;dchar&lt;/code&gt; 类型之一。如果文字是 &lt;code&gt;\u&lt;/code&gt; 转义序列，则解析为 &lt;code&gt;wchar&lt;/code&gt; 类型。如果文字是 &lt;code&gt;\U&lt;/code&gt; 转义序列，则解析为 &lt;code&gt;dchar&lt;/code&gt; 类型。否则，它将解析为将适合的最小大小的类型。</target>
        </trans-unit>
        <trans-unit id="3748669139d2553c2dce70085bc8d87e3b65bf04" translate="yes" xml:space="preserve">
          <source>Character to insert between digits.</source>
          <target state="translated">要在数字之间插入的字符。</target>
        </trans-unit>
        <trans-unit id="b03707df5e411692fe21adde8672bde4c3d712ec" translate="yes" xml:space="preserve">
          <source>Character traits classes specify character properties and provide specific semantics for certain operations on characters and sequences of characters.</source>
          <target state="translated">字符特征类规定了字符属性,并为字符和字符序列的某些操作提供特定的语义。</target>
        </trans-unit>
        <trans-unit id="7d08e774321e793244bcf20b89151a8c5636ee9d" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">每行的字符类型，默认为 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3ea2c19a4eb8af5f3f4d555aac37a5f0f405718" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;immutable char&lt;/code&gt;.</source>
          <target state="translated">每行的字符类型，默认为 &lt;code&gt;immutable char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fe23e4b9b84f174b905f70c10737ea338eb6786" translate="yes" xml:space="preserve">
          <source>Characters and Entities</source>
          <target state="translated">人物和实体</target>
        </trans-unit>
        <trans-unit id="407259c6fa72a57c5df67c0a931d6eaafa218825" translate="yes" xml:space="preserve">
          <source>Characters and Escape Macros</source>
          <target state="translated">字符和转义宏</target>
        </trans-unit>
        <trans-unit id="e688823a84fa6f43670fb82f99c26f690e6bccb5" translate="yes" xml:space="preserve">
          <source>Cheat Sheet</source>
          <target state="translated">小抄</target>
        </trans-unit>
        <trans-unit id="98fea9560fa564556454626729a76607af1a8cca" translate="yes" xml:space="preserve">
          <source>Check access to d for expression e.d Returns true if the declaration is not accessible.</source>
          <target state="translated">检查对表达式e.d的访问情况 如果声明不可访问,则返回true。</target>
        </trans-unit>
        <trans-unit id="992d8a3514d4f8fb1a7565ecd89e7c7459b088b7" translate="yes" xml:space="preserve">
          <source>Check access to package/module &lt;code&gt;p&lt;/code&gt; from scope &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">检查从范围 &lt;code&gt;sc&lt;/code&gt; 对包/模块 &lt;code&gt;p&lt;/code&gt; 的访问。</target>
        </trans-unit>
        <trans-unit id="eda17044e9450b32ce8d657d8c476e2e931877a8" translate="yes" xml:space="preserve">
          <source>Check an entire XML document for well-formedness</source>
          <target state="translated">检查整个XML文档的格式良好性。</target>
        </trans-unit>
        <trans-unit id="d970e5fd0eca0560f8d7376c859148711be4729a" translate="yes" xml:space="preserve">
          <source>Check for special enum names.</source>
          <target state="translated">检查特殊的枚举名。</target>
        </trans-unit>
        <trans-unit id="2d3f64068fd53c1e2cf2c76775f8f8fabfefbbfd" translate="yes" xml:space="preserve">
          <source>Check for unsafe access in @safe code: 1. read overlapped pointers 2. write misaligned pointers 3. write overlapped storage classes Print error if unsafe.</source>
          <target state="translated">检查@安全代码中的不安全访问。1.读取重叠的指针 2.写入错误对齐的指针 3.写入重叠的存储类 如果不安全则打印错误。</target>
        </trans-unit>
        <trans-unit id="7c0bee715813745db32b38bbccf3a069246cf610" translate="yes" xml:space="preserve">
          <source>Check given aggregate actually has an identity opAssign or not.</source>
          <target state="translated">检查给定的集合是否真的有一个身份的opAssign。</target>
        </trans-unit>
        <trans-unit id="3858f175449bae14406b7154904a8462b908a3ad" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;this&lt;/code&gt; is in the null state.</source>
          <target state="translated">检查 &lt;code&gt;this&lt;/code&gt; 是否处于空状态。</target>
        </trans-unit>
        <trans-unit id="076573205d4206fc69ab2dc4fcc4e09a0f119e4b" translate="yes" xml:space="preserve">
          <source>Check if a symbol is visible from a given scope without taking into account the most visible overload.</source>
          <target state="translated">检查一个符号是否从给定的作用域可见,而不考虑最可见的过载。</target>
        </trans-unit>
        <trans-unit id="62479c6f09569fa4521b5d1a5251de698f6fa595" translate="yes" xml:space="preserve">
          <source>Check if an &lt;code&gt;alias this&lt;/code&gt; is deprecated</source>
          <target state="translated">检查是否不建议使用 &lt;code&gt;alias this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2bab44045df4b9981599697a77f678e9b3ebdf8e" translate="yes" xml:space="preserve">
          <source>Check if any elements exist in the container. Returns &lt;code&gt;false&lt;/code&gt; if at least one element exists.</source>
          <target state="translated">检查容器中是否存在任何元素。如果存在至少一个元素，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eee93ccff6c0e0b4aa6087370d984e43f3308e9" translate="yes" xml:space="preserve">
          <source>Check if the file the &lt;code&gt;path&lt;/code&gt; points to exists</source>
          <target state="translated">检查 &lt;code&gt;path&lt;/code&gt; 指向的文件是否存在</target>
        </trans-unit>
        <trans-unit id="7ac10cbe580bb712b906c15722c15b6e0026c3e6" translate="yes" xml:space="preserve">
          <source>Check if the function &lt;code&gt;F&lt;/code&gt; is calleable in a &lt;code&gt;nothrow&lt;/code&gt; scope.</source>
          <target state="translated">检查功能 &lt;code&gt;F&lt;/code&gt; 处于calleable &lt;code&gt;nothrow&lt;/code&gt; 范围。</target>
        </trans-unit>
        <trans-unit id="64f568a0788eaf3c104e4f61c0874d4d74f59f4e" translate="yes" xml:space="preserve">
          <source>Check if the last template parameter is a tuple one, and returns it if so, else returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">检查最后一个模板参数是否为元组，如果是，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="188659108f60184522d74ac9e6ab3f12baec9896" translate="yes" xml:space="preserve">
          <source>Check if the type &lt;code&gt;T&lt;/code&gt;'s postblit is called in nothrow, if it exist</source>
          <target state="translated">检查类型 &lt;code&gt;T&lt;/code&gt; 的postblit是否在nothrow中调用（如果存在）</target>
        </trans-unit>
        <trans-unit id="af7a4c6a5c2ba8859b2cd5a292e2e803c480f264" translate="yes" xml:space="preserve">
          <source>Check parameters and return type of D main() function. Issue error messages.</source>
          <target state="translated">检查D main()函数的参数和返回类型。发布错误信息。</target>
        </trans-unit>
        <trans-unit id="44068e2d631fa41db726b0ad86a2506b1696fdd4" translate="yes" xml:space="preserve">
          <source>Check struct constructor of the form &lt;code&gt;s.this(args)&lt;/code&gt;, by checking each &lt;code&gt;return&lt;/code&gt; parameter to see if it gets assigned to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">通过检查每个 &lt;code&gt;return&lt;/code&gt; 参数以查看是否将其分配给 &lt;code&gt;s&lt;/code&gt; ,从而检查 &lt;code&gt;s.this(args)&lt;/code&gt; 形式的struct构造函数。</target>
        </trans-unit>
        <trans-unit id="e9ca07e85195a45175df8f93c70295e0d597f076" translate="yes" xml:space="preserve">
          <source>Check that an email address conforms to RFCs 5321, 5322 and others.</source>
          <target state="translated">检查电子邮件地址是否符合RFC5321、5322等标准。</target>
        </trans-unit>
        <trans-unit id="96a4caea4b58f9a696a9fa2d9139cbc448939376" translate="yes" xml:space="preserve">
          <source>Check that the expression has a valid type. If not, generates an error &quot;... has no type&quot;.</source>
          <target state="translated">检查表达式是否有一个有效的类型。如果没有,则产生错误&quot;...没有类型&quot;。</target>
        </trans-unit>
        <trans-unit id="72c3f1230ce767eb6fa0da10917246e5895c0d26" translate="yes" xml:space="preserve">
          <source>Check that the expression has a valid value. If not, generates an error &quot;... has no value&quot;.</source>
          <target state="translated">检查表达式是否有有效值。如果没有,则产生错误&quot;......没有值&quot;。</target>
        </trans-unit>
        <trans-unit id="dcdeb8730ffac94e46f7144e685915d89bb60d12" translate="yes" xml:space="preserve">
          <source>Check that the function contains any closure. If it's @nogc, report suitable errors. This is mostly consistent with FuncDeclaration::needsClosure().</source>
          <target state="translated">检查该函数是否包含任何闭包。如果是@nogc,报告适当的错误。这与FuncDeclaration::needsClosure()基本一致。</target>
        </trans-unit>
        <trans-unit id="a439ace69e6b39c914e8a0f30a7839c881b0b42e" translate="yes" xml:space="preserve">
          <source>Check that the postblit is callable if t is an array of structs. Returns true if error happens.</source>
          <target state="translated">如果t是一个结构数组,检查postblit是否可以调用。如果发生错误,返回true。</target>
        </trans-unit>
        <trans-unit id="a636a07f4f3d9c05ce29614c151925a9aeb57b2d" translate="yes" xml:space="preserve">
          <source>Check that there are no uses of arrays without [].</source>
          <target state="translated">检查有没有使用不带[]的数组。</target>
        </trans-unit>
        <trans-unit id="0af7c63ae853953456799e62f8dd988319b13c2e" translate="yes" xml:space="preserve">
          <source>Check that this function type is properly resolved. If not, report &quot;forward reference error&quot; and return true.</source>
          <target state="translated">检查该函数类型是否正确解析。如果没有,报告 &quot;正向引用错误 &quot;并返回true。</target>
        </trans-unit>
        <trans-unit id="dc26a5cb1e94e18dd7bae9c48ba4424f2687029b" translate="yes" xml:space="preserve">
          <source>Check to see if constraint is satisfied.</source>
          <target state="translated">检查是否满足约束条件。</target>
        </trans-unit>
        <trans-unit id="2e9e70f18c437515a642e7710d6acf41c2b8a612" translate="yes" xml:space="preserve">
          <source>Check to see if declaration can be modified in this context (sc). Issue error if not.</source>
          <target state="translated">检查是否可以在此上下文(sc)中修改声明。如果不能,则发出错误。</target>
        </trans-unit>
        <trans-unit id="51115eb7becb93e1ed9565c740be9cbe2b13d39d" translate="yes" xml:space="preserve">
          <source>Check to see if this variable is actually in an enclosing function rather than the current one. Returns true if error occurs.</source>
          <target state="translated">检查这个变量是否在一个包围函数中,而不是在当前函数中。如果发生错误,返回true。</target>
        </trans-unit>
        <trans-unit id="c9e9e80b6fb0bcd2c2078fcf4d43cd2c78a6fad0" translate="yes" xml:space="preserve">
          <source>Check to see the aggregate type is nested and its context pointer is accessible from the current scope. Returns true if error occurs.</source>
          <target state="translated">检查集合类型是否嵌套,其上下文指针是否可以从当前作用域访问。如果发生错误,返回true。</target>
        </trans-unit>
        <trans-unit id="4f9c3759a0e90a57282f3d4825c0a253d6bfa729" translate="yes" xml:space="preserve">
          <source>Check type to see if it is based on a deprecated symbol.</source>
          <target state="translated">检查类型,看它是否基于废弃的符号。</target>
        </trans-unit>
        <trans-unit id="3bebff7bd9c6f992a862c3947845278a778590d5" translate="yes" xml:space="preserve">
          <source>Check whether a number is an integer power of two.</source>
          <target state="translated">检查一个数字是否是二的整数倍。</target>
        </trans-unit>
        <trans-unit id="68ee613e321cfb260a31b167d7e8362d6611b9ba" translate="yes" xml:space="preserve">
          <source>Check whether a thread was created by &lt;code&gt;createLowLevelThread&lt;/code&gt;.</source>
          <target state="translated">检查是否由 &lt;code&gt;createLowLevelThread&lt;/code&gt; 创建了线程。</target>
        </trans-unit>
        <trans-unit id="81773160380ee69dcc483492366b6c611e0a1eed" translate="yes" xml:space="preserve">
          <source>Check whether symbols &lt;code&gt;s&lt;/code&gt; is visible in &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">检查符号 &lt;code&gt;s&lt;/code&gt; 是否在 &lt;code&gt;mod&lt;/code&gt; 中可见。</target>
        </trans-unit>
        <trans-unit id="16a4ea9c15d653616cd1ab89eeb1d07e1733ed47" translate="yes" xml:space="preserve">
          <source>Check whether the expression allows RMW operations, error with rmw operator diagnostic if not. ex is the RHS expression, or NULL if ++/-- is used (for diagnostics) Returns true if error occurs.</source>
          <target state="translated">检查表达式是否允许进行RMW操作,如果不允许,则用rmw操作符诊断错误。ex是RHS表达式,如果使用++/--,则为NULL(用于诊断)如果发生错误,则返回true。</target>
        </trans-unit>
        <trans-unit id="c3f04bc3752d2690dd0208e77754d66e24067224" translate="yes" xml:space="preserve">
          <source>Check whether the given Unicode code point is valid.</source>
          <target state="translated">检查给定的Unicode码点是否有效。</target>
        </trans-unit>
        <trans-unit id="967bb865d76cb5dec46effc4ddf3db69dd7bd8b3" translate="yes" xml:space="preserve">
          <source>Check whether the tuple &lt;code&gt;T&lt;/code&gt; is a type tuple. A type tuple only contains types.</source>
          <target state="translated">检查元组 &lt;code&gt;T&lt;/code&gt; 是否为类型元组。类型元组仅包含类型。</target>
        </trans-unit>
        <trans-unit id="f2b123f344913046043c7f94d2d9417280390123" translate="yes" xml:space="preserve">
          <source>Check whether the tuple T is an expression tuple. An expression tuple only contains expressions.</source>
          <target state="translated">检查元组T是否是一个表达式元组。表达式元组只包含表达式。</target>
        </trans-unit>
        <trans-unit id="5374967cf17045f818df69f4c4da8c46fb272364" translate="yes" xml:space="preserve">
          <source>Check whether the type t representation relies on one or more the template parameters.</source>
          <target state="translated">检查t类型的表示是否依赖于一个或多个模板参数。</target>
        </trans-unit>
        <trans-unit id="a81260a4f45c118b1ea3d76244c3549c2710e64e" translate="yes" xml:space="preserve">
          <source>CheckDns &lt;code&gt;checkDNS&lt;/code&gt;</source>
          <target state="translated">CheckDns &lt;code&gt;checkDNS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5ad7d1dc4c316626ec88560f3cf3f5028c21c54" translate="yes" xml:space="preserve">
          <source>CheckException &lt;strong id=&quot;err&quot;&gt;err&lt;/strong&gt;;</source>
          <target state="translated">CheckException &lt;strong id=&quot;err&quot;&gt;err&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="102c409f892dccfa7ef03ae04285bb95f236e32f" translate="yes" xml:space="preserve">
          <source>CheckException if the document is not well formed  CheckException's toString() method will yield the complete hierarchy of parse failure (the XML equivalent of a stack trace), giving the line and column number of every failure at every level.</source>
          <target state="translated">如果文档没有很好的形成,CheckException的toString()方法将产生解析失败的完整层次结构(相当于XML的堆栈跟踪),给出每一级失败的行号和列号。</target>
        </trans-unit>
        <trans-unit id="bada63007fff0aeaf5219e5a4263f3c5062820f1" translate="yes" xml:space="preserve">
          <source>Checked integral type wraps an integral &lt;code&gt;T&lt;/code&gt; and customizes its behavior with the help of a &lt;code&gt;Hook&lt;/code&gt; type. The type wrapped must be one of the predefined integrals (unqualified), or another instance of &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">Checked整数类型包装整数 &lt;code&gt;T&lt;/code&gt; 并借助 &lt;code&gt;Hook&lt;/code&gt; 类型自定义其行为。包装的类型必须是预定义的整数之一（不合格），或者是 &lt;code&gt;Checked&lt;/code&gt; 的另一个实例。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
