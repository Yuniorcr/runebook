<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="33ed59cb9cc5ad4f51c71cb705b6c66305c4ea95" translate="yes" xml:space="preserve">
          <source>Associative Array Example: counting Tuples</source>
          <target state="translated">关联数组示例:计算图元组</target>
        </trans-unit>
        <trans-unit id="66110798d937132b8b4c69b6c86f490e42147357" translate="yes" xml:space="preserve">
          <source>Associative Array Example: word count</source>
          <target state="translated">关联数组示例:字数</target>
        </trans-unit>
        <trans-unit id="62a00c8d718bd407e11a04d361c97fd9304d9228" translate="yes" xml:space="preserve">
          <source>Associative Array Literals</source>
          <target state="translated">关联阵列文字</target>
        </trans-unit>
        <trans-unit id="8cd02aabb1cb92301b44ecacb4a3476fbc048ed6" translate="yes" xml:space="preserve">
          <source>Associative Array Properties</source>
          <target state="translated">关联数组属性</target>
        </trans-unit>
        <trans-unit id="ac6bb05c1566d531b5e617bff01417f7eeacaa8d" translate="yes" xml:space="preserve">
          <source>Associative Arrays</source>
          <target state="translated">关联数组</target>
        </trans-unit>
        <trans-unit id="b6a88997c71f98db7849444ee105aa1b9e104461" translate="yes" xml:space="preserve">
          <source>Associative array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">关联数组的文字将被分配到GC堆上。检查它的元素,看看是否有任何元素会在堆上逃逸。</target>
        </trans-unit>
        <trans-unit id="2cdd3f26aaf9ed2ca50e34f9cba8cec0e214e787" translate="yes" xml:space="preserve">
          <source>Associative array literals</source>
          <target state="translated">关联数组文字</target>
        </trans-unit>
        <trans-unit id="aa59b9862478a41dd5f1d43314d8d4fd2f36cfac" translate="yes" xml:space="preserve">
          <source>Associative array literals are a comma-separated list of</source>
          <target state="translated">关联数组字元是一个以逗号分隔的列表,其中包括</target>
        </trans-unit>
        <trans-unit id="f1464f4beecb9ccd1b6cd79f0d3fdebe26677ef6" translate="yes" xml:space="preserve">
          <source>Associative array of attributes</source>
          <target state="translated">属性的关联数组</target>
        </trans-unit>
        <trans-unit id="1c3256b0ab3483fa8604ecf1ce16a782f56f85d2" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is printed by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="translated">关联数组到字符串的转换。通过调用 &lt;code&gt;to!T&lt;/code&gt; 来打印每个元素。</target>
        </trans-unit>
        <trans-unit id="a0cf74a282aed4f93bc7369a99f5541139720753" translate="yes" xml:space="preserve">
          <source>Associative arrays</source>
          <target state="translated">关联数组</target>
        </trans-unit>
        <trans-unit id="b7b195035b64b57f923bdef12ca24604e56d713e" translate="yes" xml:space="preserve">
          <source>Associative arrays are declared by placing the</source>
          <target state="translated">关联数组的声明是通过将</target>
        </trans-unit>
        <trans-unit id="e2e6b379c645fab1d146e1f88662672372565c42" translate="yes" xml:space="preserve">
          <source>Associative arrays are formatted by using &lt;code&gt;':'&lt;/code&gt; and &lt;code&gt;&quot;, &quot;&lt;/code&gt; as separators, and enclosed by &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;.</source>
          <target state="translated">关联数组使用 &lt;code&gt;':'&lt;/code&gt; 和 &lt;code&gt;&quot;, &quot;&lt;/code&gt; 作为分隔符进行格式化，并用 &lt;code&gt;'['&lt;/code&gt; 和 &lt;code&gt;']'&lt;/code&gt; 括起来。</target>
        </trans-unit>
        <trans-unit id="578b6958d55efc32eb2164f95c40c985b159a3d3" translate="yes" xml:space="preserve">
          <source>Associative arrays are initialized to having 0 elements.</source>
          <target state="translated">关联数组被初始化为0个元素。</target>
        </trans-unit>
        <trans-unit id="1f9ac76e68b33aa5367eaec796765ac41035935d" translate="yes" xml:space="preserve">
          <source>Associative arrays are returned in EAX.</source>
          <target state="translated">关联数组在EAX中返回。</target>
        </trans-unit>
        <trans-unit id="5ca5da5a3d3a14509f014f2f90e91f3a2f1bc8b9" translate="yes" xml:space="preserve">
          <source>Associative arrays consist of a pointer to an opaque, implementation defined type.</source>
          <target state="translated">关联数组由指向一个不透明的、实现定义的类型的指针组成。</target>
        </trans-unit>
        <trans-unit id="4b7aaeec3338d91fc185c073ff6aea7f4aaaf1d1" translate="yes" xml:space="preserve">
          <source>Associative arrays have an index that is not necessarily an integer, and can be sparsely populated. The index for an associative array is called the</source>
          <target state="translated">关联数组的索引不一定是整数,可以是稀疏的。关联数组的索引称为</target>
        </trans-unit>
        <trans-unit id="24b2b993b7d8aa8b139deca02db3001c61ba8f93" translate="yes" xml:space="preserve">
          <source>Associative arrays have unique keys. If r contains duplicate keys, then the result will contain the value of the last pair for that key in r.</source>
          <target state="translated">关联数组有唯一的键。如果r中包含重复的键,那么结果将包含r中该键的最后一对值。</target>
        </trans-unit>
        <trans-unit id="7140c60dcf97eae1fd241925dc294e9b664ccf47" translate="yes" xml:space="preserve">
          <source>Associativity and Commutativity</source>
          <target state="translated">关联性和共通性</target>
        </trans-unit>
        <trans-unit id="d4afb493c09c81bc22adc7df22495a98eac06f94" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt;. Then &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; leaves &lt;code&gt;a&lt;/code&gt; unchanged and returns &lt;code&gt;false&lt;/code&gt;, whereas &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to refer to &lt;code&gt;&quot;ah&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">假设 &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt; 。然后 &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; 留下 &lt;code&gt;a&lt;/code&gt; 不变并返回 &lt;code&gt;false&lt;/code&gt; ，而 &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; 前进 &lt;code&gt;a&lt;/code&gt; 指 &lt;code&gt;&quot;ah&quot;&lt;/code&gt; ，并返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c94a2c42cde8321b948dff42533f346ec9014aea" translate="yes" xml:space="preserve">
          <source>Assume that it is safe to append to this array. Appends made to this array after calling this function may append in place, even if the array was a slice of a larger array to begin with.</source>
          <target state="translated">假设对这个数组进行追加是安全的。在调用此函数后,对这个数组的追加可能会在原地追加,即使这个数组一开始就是一个更大数组的片断。</target>
        </trans-unit>
        <trans-unit id="3954f2a28b82752323144cbb88151e77e6d01da9" translate="yes" xml:space="preserve">
          <source>Assume the given array of integers &lt;code&gt;arr&lt;/code&gt; is a well-formed UTF string and return it typed as a UTF string.</source>
          <target state="translated">假设给定的整数数组 &lt;code&gt;arr&lt;/code&gt; 是格式正确的UTF字符串，然后将其返回为UTF字符串。</target>
        </trans-unit>
        <trans-unit id="24e62b25f8e7aaa35a775d4bc9ee591164888166" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To keep the checking costs low, the cost is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) in release mode (no checks for sorted-ness are performed). In debug mode, a few random elements of &lt;code&gt;r&lt;/code&gt; are checked for sorted-ness. The size of the sample is proportional &amp;Omicron;(&lt;code&gt;log(r.length)&lt;/code&gt;). That way, checking has no effect on the complexity of subsequent operations specific to sorted ranges (such as binary search). The probability of an arbitrary unsorted range failing the test is very high (however, an almost-sorted range is likely to pass it). To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">假定 &lt;code&gt;r&lt;/code&gt; 由谓词排序 &lt;code&gt;pred&lt;/code&gt; ，并返回相应的 &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; 具有 &lt;code&gt;r&lt;/code&gt; 作为支撑。为了保持较低的检查成本，在发布模式下，成本为〇（ &lt;code&gt;1&lt;/code&gt; ）（不执行分类检查）。在调试模式下，将检查 &lt;code&gt;r&lt;/code&gt; 的几个随机元素的排序度。样本的大小成比例&amp;Omicron;（ &lt;code&gt;log(r.length)&lt;/code&gt; ）。这样，检查不会影响特定于已排序范围的后续操作的复杂性（例如二进制搜索）。任意未排序范围未通过测试的可能性非常高（但是，几乎排序的范围很可能会通过测试）。以成本〇（ &lt;code&gt;n&lt;/code&gt; ），请使用&lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt; &lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f92de52d34809fb9f9b5a422d22d2bd3f403b63b" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;T&lt;/code&gt; is an unqualified type, the graph below illustrates how qualifiers combine (combinations with &lt;code&gt;immutable&lt;/code&gt; are omitted). For each node, applying the qualifier labeling the edge leads to the resulting type.</source>
          <target state="translated">假设 &lt;code&gt;T&lt;/code&gt; 是非限定类型，下图说明了限定符如何组合（省略了 &lt;code&gt;immutable&lt;/code&gt; 组合）。对于每个节点，应用标记边缘的限定符会导致生成类型。</target>
        </trans-unit>
        <trans-unit id="317581a22ccf8624556bdb31509c5c5a51feef3f" translate="yes" xml:space="preserve">
          <source>Assuming that pages are laid out consequently in one array at &lt;code&gt;pages&lt;/code&gt;, the pseudo-code is:</source>
          <target state="translated">假设因此将页面布置在 &lt;code&gt;pages&lt;/code&gt; 一个数组中，则伪代码为：</target>
        </trans-unit>
        <trans-unit id="7bfdbbc84ee0d35091e2296c00a0a25e1c9d7c15" translate="yes" xml:space="preserve">
          <source>Assuming the file was at /example/test.d, this will output:</source>
          <target state="translated">假设文件在/example/test.d,这将输出。</target>
        </trans-unit>
        <trans-unit id="4ade9724e5f6c8aea4d40d9c22982099c0a42498" translate="yes" xml:space="preserve">
          <source>Assuming the reverse meaning (i.e. &quot;ignoreTerminator&quot;) and inserting the wrong code compiles and runs with erroneous results.  After replacing the boolean parameter with an instantiation of &lt;code&gt;Flag&lt;/code&gt;, code calling &lt;code&gt;getLine&lt;/code&gt; can be easily read and understood even by people not fluent with the API:</source>
          <target state="translated">假定含义相反（即&amp;ldquo; ignoreTerminator&amp;rdquo;）并插入错误的代码，则会编译并运行，结果错误。用 &lt;code&gt;Flag&lt;/code&gt; 的实例替换boolean参数后，即使不熟练使用API​​的人也可以轻松阅读和理解调用 &lt;code&gt;getLine&lt;/code&gt; 的代码：</target>
        </trans-unit>
        <trans-unit id="8b593995c88f61a609044a01e37e8e4ccc22e065" translate="yes" xml:space="preserve">
          <source>Assumptions</source>
          <target state="translated">Assumptions</target>
        </trans-unit>
        <trans-unit id="875a558108f6180c117cd2a9851fbd31bf1ad357" translate="yes" xml:space="preserve">
          <source>At Least Alias</source>
          <target state="translated">至少是别名</target>
        </trans-unit>
        <trans-unit id="6a5e7ce73794fbffd33597afe29e6656f7606b48" translate="yes" xml:space="preserve">
          <source>At least one return statement, throw statement, or assert(0) expression is required if the function specifies a return type that is not void, unless the function contains inline assembler code.</source>
          <target state="translated">如果函数指定的返回类型不是void,则至少需要一个返回语句、抛出语句或assert(0)表达式,除非函数包含内联汇编器代码。</target>
        </trans-unit>
        <trans-unit id="90d61c89ed43af9a321f3f7948cd37fb3078855e" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. &lt;code&gt;Zip&lt;/code&gt; offers the lowest range facilities of all components, e.g. it offers random access iff all ranges offer random access, and also offers mutation and swapping if all ranges offer it. Due to this, &lt;code&gt;Zip&lt;/code&gt; is extremely powerful because it allows manipulating several ranges in lockstep.</source>
          <target state="translated">至少是一个输入范围。 &lt;code&gt;Zip&lt;/code&gt; 提供了所有组件中范围最低的工具，例如，如果所有范围都提供了随机访问权限，则它提供了随机访问；如果所有范围都提供了它，它也可以提供突变和交换功能。因此， &lt;code&gt;Zip&lt;/code&gt; 非常强大，因为它允许以锁步的方式操纵多个范围。</target>
        </trans-unit>
        <trans-unit id="bf82744118a56dc50e99bed95e0674d739012373" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. All other range primitives are given in the resulting range if &lt;code&gt;range&lt;/code&gt; has them. The exceptions are the bidirectional primitives, which are propagated only if &lt;code&gt;range&lt;/code&gt; has length.</source>
          <target state="translated">至少是一个输入范围。如果 &lt;code&gt;range&lt;/code&gt; 有其他所有范围原语，则在结果范围中给出它们。双向图元是唯一的例外，它们仅在 &lt;code&gt;range&lt;/code&gt; 具有长度时才传播。</target>
        </trans-unit>
        <trans-unit id="e9641b92bdebc39e62f8119a95b586fda5bb953c" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. If the range offers random access and &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt; offers them as well.</source>
          <target state="translated">至少是一个输入范围。如果范围提供随机访问和 &lt;code&gt;length&lt;/code&gt; ，则 &lt;code&gt;take&lt;/code&gt; 提供它们。</target>
        </trans-unit>
        <trans-unit id="b4f8bcff8fd004d35539b31be3e23eec00e83071" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. Range primitives such as bidirectionality and random access are given if the element type of &lt;code&gt;rr&lt;/code&gt; provides them.</source>
          <target state="translated">至少是一个输入范围。如果 &lt;code&gt;rr&lt;/code&gt; 的元素类型提供了范围原语，例​​如双向性和随机访问。</target>
        </trans-unit>
        <trans-unit id="ab81f7243697f45d24e88eac476807c5bafc54c5" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. The resulting range will adopt the range primitives of the underlying range as long as &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">至少是一个输入范围。只要&lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt;为 &lt;code&gt;true&lt;/code&gt; ，结果范围将采用基础范围的范围原语。</target>
        </trans-unit>
        <trans-unit id="13e0cdc536d3ebf98a18c0bc6152dede0a930dcf" translate="yes" xml:space="preserve">
          <source>At offset index into buffer, create nbytes of space by shifting upwards all data past index.</source>
          <target state="translated">在偏移索引进入缓冲区时,通过向上移动所有经过索引的数据来创造nbytes的空间。</target>
        </trans-unit>
        <trans-unit id="1427d1990cebaf6b24e9781e5fa4c566cf53ece6" translate="yes" xml:space="preserve">
          <source>At present, C++ exceptions cannot be caught in or thrown from D, and D exceptions cannot be caught in or thrown from C++. Additionally, objects in C++ stack frames are not guaranteed to be destroyed when unwinding the stack due to a D exception, and vice versa.</source>
          <target state="translated">目前,C++异常不能被D捕获或抛出,D异常也不能被C++捕获或抛出。另外,在因D异常而解除栈的时候,不能保证C++栈帧中的对象被销毁,反之亦然。</target>
        </trans-unit>
        <trans-unit id="79117be4a561837c4e341dc958c03f4b3575dace" translate="yes" xml:space="preserve">
          <source>Atomically increment the current count by one. This will notify one waiter, if there are any in the queue.</source>
          <target state="translated">原子化地将当前计数递增1。这将通知一个服务员,如果有队列中的服务员。</target>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">试图释放堆内存</target>
        </trans-unit>
        <trans-unit id="2d4188d946f5310d84944e1cbc16ca3404e12f5e" translate="yes" xml:space="preserve">
          <source>Attempt to write a readonly database</source>
          <target state="translated">试图写一个只读数据库</target>
        </trans-unit>
        <trans-unit id="bad2e7923396bd94563de54c8743dd18ec710863" translate="yes" xml:space="preserve">
          <source>Attempting to read a non-existent file.</source>
          <target state="translated">试图读取一个不存在的文件。</target>
        </trans-unit>
        <trans-unit id="cfc72cd8439fa8fc0153768ece769b118903087b" translate="yes" xml:space="preserve">
          <source>Attempting to write to a read-only file.</source>
          <target state="translated">试图向一个只读文件写入。</target>
        </trans-unit>
        <trans-unit id="619f7dc21d7be2451ba09a0a31590c696e32ea77" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">试图获取包围的mutex的读锁。如果能够在不阻塞的情况下获得锁,则获得锁并返回true。如果不能获得,则不获取锁,返回false。</target>
        </trans-unit>
        <trans-unit id="640457600821a8df2d538564c057e12d520f4905" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">试图获取包围的mutex上的写锁。如果能够在不阻塞的情况下获得锁,则获得锁并返回true。如果不能获得,则不获取锁,返回false。</target>
        </trans-unit>
        <trans-unit id="3b9757d22891fdb7b2db7ae0d5e59794d8111018" translate="yes" xml:space="preserve">
          <source>Attempts to cast Object o to class c. Returns o if successful, null if not.</source>
          <target state="translated">试图将Object o投向c类,如果成功则返回o,如果失败则返回null。</target>
        </trans-unit>
        <trans-unit id="fb9f33e63583d791ce38087ee972da2a9a91218e" translate="yes" xml:space="preserve">
          <source>Attempts to lock the specified file segment. If both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are zero, the entire file is locked.</source>
          <target state="translated">尝试锁定指定的文件段。如果 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;length&lt;/code&gt; 均为零，则整个文件将被锁定。</target>
        </trans-unit>
        <trans-unit id="25ad0c35f575b740f4d561c41e13284745953ceb" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host address as a human-readable string.</source>
          <target state="translated">试图以人类可读的字符串检索主机地址。</target>
        </trans-unit>
        <trans-unit id="0ee6b4fbb8496cdc7d0620d9b9ed398b895a55e3" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host name as a fully qualified domain name.</source>
          <target state="translated">试图将主机名作为一个完全合格的域名来检索。</target>
        </trans-unit>
        <trans-unit id="2288a588beafb785ffe5d4183be649edf540fac4" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the numeric port number as a string.</source>
          <target state="translated">试图以字符串形式检索数字端口号。</target>
        </trans-unit>
        <trans-unit id="f6c4cea55c8d840b0fc77f72a5e89fc5d0c7b734" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the service name as a string.</source>
          <target state="translated">试图以字符串形式检索服务名称。</target>
        </trans-unit>
        <trans-unit id="06a30d499359e73aad911822ebc036ba5b33b771" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the process associated with &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">尝试终止与 &lt;code&gt;pid&lt;/code&gt; 相关联的进程。</target>
        </trans-unit>
        <trans-unit id="5e521b72cd060c4862399350be7113a0bf337401" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution typing global memory. For example, if you pre-allocate memory in the DATA/TLS segment and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">注意：启用精确扫描需要稍微注意键入全局内存的情况。例如，如果您在DATA / TLS段中预先分配了内存，之后又将引用其他分配的对象实例放置到该内存中，则不得使用基本整数类型来保留空间。这样做将导致垃圾收集器无法检测到引用。相反，请使用将保守扫描该区域的数组类型。通常使用 &lt;code&gt;void*&lt;/code&gt; 是最好的选择，因为它还可以确保GC扫描的指针正确对齐。</target>
        </trans-unit>
        <trans-unit id="435469686dcf93332d214d0927042b6ab70eb76c" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution with type declarations. For example, if you reserve a buffer as part of a struct and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">注意：启用精确扫描需要在类型声明时稍加注意。例如，如果您将缓冲区保留为结构的一部分，然后将引用其他分配的引用的对象实例放置到此内存中，则不得使用基本整数类型来保留空间。这样做将导致垃圾收集器无法检测到引用。相反，请使用将保守扫描该区域的数组类型。通常使用 &lt;code&gt;void*&lt;/code&gt; 是最好的选择，因为它还可以确保GC扫描的指针正确对齐。</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="563889efc6708465a0f8d7b13b7a64dc9449be63" translate="yes" xml:space="preserve">
          <source>Attribute inference is not done for other functions, even if the function body is present.</source>
          <target state="translated">对于其他函数,即使函数体存在,也不会进行属性推断。</target>
        </trans-unit>
        <trans-unit id="fde0c64566e4280899df7f71f529a9c5822593d2" translate="yes" xml:space="preserve">
          <source>Attributed Unittests</source>
          <target state="translated">归属单位测试</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="3566d57f396227b960696c7c5f730c9617ce2ae9" translate="yes" xml:space="preserve">
          <source>Attributes are a way to modify one or more declarations. The general forms are:</source>
          <target state="translated">属性是修改一个或多个声明的一种方式。一般形式有:</target>
        </trans-unit>
        <trans-unit id="1a118fa9a5b31a61d074da7d6149cfba22d1f3ad" translate="yes" xml:space="preserve">
          <source>Authentication method as specified in &lt;a href=&quot;#AuthMethod&quot;&gt;&lt;code&gt;AuthMethod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#AuthMethod&quot;&gt; &lt;code&gt;AuthMethod&lt;/code&gt; 中&lt;/a&gt;指定的身份验证方法。</target>
        </trans-unit>
        <trans-unit id="1033f15759fcb47c36fb8ab321053fc3f1eca814" translate="yes" xml:space="preserve">
          <source>Authentication method equal to &lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt;&lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">等同于&lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt; &lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt; 的&lt;/a&gt;身份验证方法</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="66d5524bc6e9a905bcd8ad67ae1eb457c570b564" translate="yes" xml:space="preserve">
          <source>Authorization denied</source>
          <target state="translated">拒绝授权</target>
        </trans-unit>
        <trans-unit id="96526fc6efe098c9c6df94252412831b9ccb9466" translate="yes" xml:space="preserve">
          <source>Authors:</source>
          <target state="translated">Authors:</target>
        </trans-unit>
        <trans-unit id="ce0159a5518bc584a9e41b4b2690ef154fde135a" translate="yes" xml:space="preserve">
          <source>Auto Functions</source>
          <target state="translated">自动功能</target>
        </trans-unit>
        <trans-unit id="cac7a53f813ead2d8559f8bf1f813c3742d1564d" translate="yes" xml:space="preserve">
          <source>Auto Ref Functions</source>
          <target state="translated">自动参考功能</target>
        </trans-unit>
        <trans-unit id="5437bd3930e7f40ca7893e40f97b38d23c03f5fa" translate="yes" xml:space="preserve">
          <source>Auto functions have their return type inferred from any &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body.</source>
          <target state="translated">自动函数具有从函数主体中的任何&lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;推断出的返回类型。</target>
        </trans-unit>
        <trans-unit id="cec7110add8230fd3e3cee4a6982476165507102" translate="yes" xml:space="preserve">
          <source>Auto ref function can have explicit return type.</source>
          <target state="translated">Auto ref函数可以有明确的返回类型。</target>
        </trans-unit>
        <trans-unit id="1c98218626b244980716cf56d4d67cef842f3ffa" translate="yes" xml:space="preserve">
          <source>Auto ref functions infer their return type just as &lt;a href=&quot;#auto-functions&quot;&gt;auto functions&lt;/a&gt; do. In addition, they become &lt;a href=&quot;#ref-functions&quot;&gt;ref functions&lt;/a&gt; if all return expressions are lvalues, and it would not be a reference to a local or a parameter.</source>
          <target state="translated">自动引用函数会像&lt;a href=&quot;#auto-functions&quot;&gt;自动函数&lt;/a&gt;一样推断其返回类型。另外，如果所有返回表达式都是左值，它们将成为&lt;a href=&quot;#ref-functions&quot;&gt;ref函数&lt;/a&gt;，并且不会引用本地或参数。</target>
        </trans-unit>
        <trans-unit id="72dbdd4328b363da1dc721bef13390d325cb449b" translate="yes" xml:space="preserve">
          <source>Auto ref parameters can be combined with auto ref return attributes:</source>
          <target state="translated">自动参考参数可以与自动参考返回属性相结合。</target>
        </trans-unit>
        <trans-unit id="b60c388599c6393e9a67e964a642ad91629c903e" translate="yes" xml:space="preserve">
          <source>Auto start with constructor.</source>
          <target state="translated">用构造函数自动启动。</target>
        </trans-unit>
        <trans-unit id="efe7dcdfb00b164478f91903b1de63b3b45e9d2f" translate="yes" xml:space="preserve">
          <source>Auto-initialize the object</source>
          <target state="translated">自动初始化对象</target>
        </trans-unit>
        <trans-unit id="9d4560b6ff607cd4aecb5b5ff67e03b10904f66c" translate="yes" xml:space="preserve">
          <source>Autodecoding is enabled if this is set to true.</source>
          <target state="translated">如果设置为 &quot;true&quot;,则启用自动解码。</target>
        </trans-unit>
        <trans-unit id="360d06366226a26ec284df57dde94213ed2f94dc" translate="yes" xml:space="preserve">
          <source>Automatic input/output redirection using pipes</source>
          <target state="translated">使用管道自动输入/输出重定向。</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">自动加载静态链接的扩展</target>
        </trans-unit>
        <trans-unit id="d2178e65328973816c4ca61d0183a96480a9ed99" translate="yes" xml:space="preserve">
          <source>Available GC options are:</source>
          <target state="translated">现有的气相色谱仪选项有:</target>
        </trans-unit>
        <trans-unit id="e14fc18612f34181b225bea7665a50b7b0f96761" translate="yes" xml:space="preserve">
          <source>Available output formats:</source>
          <target state="translated">可用的输出格式:</target>
        </trans-unit>
        <trans-unit id="063d4770adfbdb2cd75f5fde3c562c12c1713762" translate="yes" xml:space="preserve">
          <source>Available parameters are: CURLFTPAUTH_DEFAULT - let libcurl decide CURLFTPAUTH_SSL - try &quot;AUTH SSL&quot; first, then TLS CURLFTPAUTH_TLS - try &quot;AUTH TLS&quot; first, then SSL</source>
          <target state="translated">可用的参数有 CURLFTPAUTH_DEFAULT-让libcurl决定 CURLFTPAUTH_SSL-先试 &quot;AUTH SSL&quot;,再试TLS CURLFTPAUTH_TLS-先试 &quot;AUTH TLS&quot;,再试SSL。</target>
        </trans-unit>
        <trans-unit id="463bce54270761ca786235a57251bca24f1dbc8b" translate="yes" xml:space="preserve">
          <source>Available space in bytes</source>
          <target state="translated">可用空间(单位:字节)</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="2be47cf0ea6736915b049bc8ea265c97a2606e56" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be a sign of poor decomposition of program structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains declarations needed by the other two.</source>
          <target state="translated">在可行的情况下避免周期性导入。它们可能是程序结构分解成独立模块的不良迹象。互相导入的两个模块通常可以重组为三个没有循环的模块,其中第三个模块包含其他两个模块所需的声明。</target>
        </trans-unit>
        <trans-unit id="aa042d5d9bad75e7a516100618f6fbb64a7728b7" translate="yes" xml:space="preserve">
          <source>Avoid dependence on byte order; i.e. whether the CPU is big-endian or little-endian.</source>
          <target state="translated">避免对字节顺序的依赖;即CPU是大字节还是小字节。</target>
        </trans-unit>
        <trans-unit id="87263cc0efbd41c932d10eec489a5a9fa53f4615" translate="yes" xml:space="preserve">
          <source>Avoid dependence on the size of a pointer or reference being the same size as a particular integral type.</source>
          <target state="translated">避免依赖指针或引用的大小与特定积分类型的大小相同。</target>
        </trans-unit>
        <trans-unit id="a5f3c22b10cd44ac8e47f76e9ce3358fd5ea5dbb" translate="yes" xml:space="preserve">
          <source>Avoid depending on the order of side effects in a computation that may get reordered by the compiler. For example:</source>
          <target state="translated">避免在计算中依赖副作用的顺序,因为这可能会被编译器重新排序。例如:</target>
        </trans-unit>
        <trans-unit id="07964cf6df89426658b50b243ee7036b1cf42153" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of classes with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">避免让类的公有字段与无量子发生变化,因为这样的话,无量子就无法验证公有接口。</target>
        </trans-unit>
        <trans-unit id="4d3d6af1490ba88616db8531edd7f4d34c56a495" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of structs with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">避免让结构的公有字段与不变量发生变化,因为这样的话,不变量无法验证公有接口。</target>
        </trans-unit>
        <trans-unit id="0209d0b0190d63b253227592d1649d56cf0d62a8" translate="yes" xml:space="preserve">
          <source>Avoid reliance on side effects in the invariant. as the invariant may or may not be executed.</source>
          <target state="translated">避免依赖不变式中的副作用.因为不变式可能会被执行,也可能不会被执行。</target>
        </trans-unit>
        <trans-unit id="9a2c3569f4cdef214baa0f7dccd251b7796ef000" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs as parameters or arguments to variadic functions.</source>
          <target state="translated">避免使用空结构作为变量函数的参数或参数。</target>
        </trans-unit>
        <trans-unit id="aa27a565a88b1217ee8242e278c52dfa4dc27415" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs when interfacing with C and C++ code.</source>
          <target state="translated">当与C和C++代码接口时,避免使用空结构。</target>
        </trans-unit>
        <trans-unit id="fa97dd47910ed157d733ff928c6533de2cbdb883" translate="yes" xml:space="preserve">
          <source>A|B</source>
          <target state="translated">A|B</target>
        </trans-unit>
        <trans-unit id="ee75ef351995c342c1fa5ff34f0c8888a0c4023e" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">乙 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed32df2c72f22e8029196feaab8d830b375f94a9" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;begin&lt;/code&gt;</source>
          <target state="translated">B &lt;code&gt;begin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9228bacbd6367d63160ad16de9da2a5dc0a4c8ac" translate="yes" xml:space="preserve">
          <source>B &lt;strong id=&quot;select&quot;&gt;select&lt;/strong&gt;(bool cond : false, A, B)(lazy A a, B b);</source>
          <target state="translated">B &lt;strong id=&quot;select&quot;&gt;选择&lt;/strong&gt;（bool cond：false，A，B）（懒惰A a，B b）;</target>
        </trans-unit>
        <trans-unit id="38af9591e3fb4695fab9bf9aa8e4b04997260819" translate="yes" xml:space="preserve">
          <source>BE stands for BlockExit.</source>
          <target state="translated">BE是BlockExit的缩写。</target>
        </trans-unit>
        <trans-unit id="f18291c5630b11c70838e02838757f776b664e5c" translate="yes" xml:space="preserve">
          <source>BE.xxxx</source>
          <target state="translated">BE.xxxx</target>
        </trans-unit>
        <trans-unit id="a8ac71a34c4bf8d47fcd34a3bb48e39638e1c9c2" translate="yes" xml:space="preserve">
          <source>BEL (alarm) character (U+0007).</source>
          <target state="translated">BEL(报警)字符(U+0007)。</target>
        </trans-unit>
        <trans-unit id="c4c51eeb133480a8ab13e2aac716dc1c49511996" translate="yes" xml:space="preserve">
          <source>BODY</source>
          <target state="translated">BODY</target>
        </trans-unit>
        <trans-unit id="4248a9b200b0703a243217afa7ea61bb6e9a6078" translate="yes" xml:space="preserve">
          <source>BOM</source>
          <target state="translated">BOM</target>
        </trans-unit>
        <trans-unit id="9e5d541d33dd4e690757280921ed4737bc5066d7" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;builtin&quot;&gt;builtin&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;builtin&quot;&gt;内置&lt;/strong&gt; BUILTIN ;</target>
        </trans-unit>
        <trans-unit id="e08e1bc55cdffceca473579010d3eed8f80f3da4" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt;(FuncDeclaration fd);</source>
          <target state="translated">BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt;（FuncDeclaration fd）;</target>
        </trans-unit>
        <trans-unit id="2ba208c7a57215fe25a2dc8edeb1eed6d80c323c" translate="yes" xml:space="preserve">
          <source>Back references</source>
          <target state="translated">后面的参考资料</target>
        </trans-unit>
        <trans-unit id="cc6aace08575981676ef15b08f05eb45989c65af" translate="yes" xml:space="preserve">
          <source>Back-end type seldom used directly by user code. Two commonly-used types using &lt;code&gt;VariantN&lt;/code&gt; are:</source>
          <target state="translated">用户代码很少直接使用后端类型。使用 &lt;code&gt;VariantN&lt;/code&gt; 的两种常用类型是：</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="59c009b9aac36256a825b962a8506069b93a0cd0" translate="yes" xml:space="preserve">
          <source>Backspace (U+0008).</source>
          <target state="translated">退格(U+0008)。</target>
        </trans-unit>
        <trans-unit id="cc460f6a8460cfc0b7f80f1ff3a6c734e2b3ea57" translate="yes" xml:space="preserve">
          <source>Backward.</source>
          <target state="translated">Backward.</target>
        </trans-unit>
        <trans-unit id="be7e10d1c5dd2ad77f6d5a617372a7bf013cb7bf" translate="yes" xml:space="preserve">
          <source>Bad</source>
          <target state="translated">Bad</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="a4ba5616fd448eeba2a0c6f11c812abe221ea915" translate="yes" xml:space="preserve">
          <source>Bamum Supplement</source>
          <target state="translated">Bamum补充剂</target>
        </trans-unit>
        <trans-unit id="8e0abbaab6b20b6084d656b5fa956a7ead91c3cf" translate="yes" xml:space="preserve">
          <source>Bare URLs</source>
          <target state="translated">裸露的URL</target>
        </trans-unit>
        <trans-unit id="f70b3222f4784cd8b2d7fa95c5e6ff653751d799" translate="yes" xml:space="preserve">
          <source>Bare URLs are sequences of characters that start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;, continue with one or more characters from the set of letters, digits and &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt;, and contain at least one period. URL recognition happens before all macro text substitution. The URL is wrapped in a &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; macro and is otherwise left untouched.</source>
          <target state="translated">裸URL是以 &lt;code&gt;http://&lt;/code&gt; 或 &lt;code&gt;https://&lt;/code&gt; 开头的字符序列，以字母，数字和 &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt; 一个或多个字符开头。，并且至少包含一个句点。URL识别发生在所有宏文本替换之前。该URL被包装在 &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; 宏中，否则保持不变。</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">基础类型</target>
        </trans-unit>
        <trans-unit id="cc110ca211bf143dd27dd71bfdb7b015a52cf91f" translate="yes" xml:space="preserve">
          <source>Base class construction is done by calling the base class constructor by the name &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">通过使用名称 &lt;code&gt;super&lt;/code&gt; 调用基类构造函数来完成基类构造：</target>
        </trans-unit>
        <trans-unit id="da5e0d7ff0c3f501f663124890a539611d14d952" translate="yes" xml:space="preserve">
          <source>Base class for synchronization errors.</source>
          <target state="translated">同步错误的基类。</target>
        </trans-unit>
        <trans-unit id="c38a7f6f1cb2f71a182073d464805a1edb6ea0e7" translate="yes" xml:space="preserve">
          <source>Base class for synchronization exceptions.</source>
          <target state="translated">同步异常的基类。</target>
        </trans-unit>
        <trans-unit id="672c3fd9686f0e99c9f798afb18e998c05c3a884" translate="yes" xml:space="preserve">
          <source>Base class for thread errors to be used for function inside GC when allocations are unavailable.</source>
          <target state="translated">当分配不可用时,用于GC内部函数的线程错误的基类。</target>
        </trans-unit>
        <trans-unit id="db07e1efbf8851dc009b2f7a1cf1562018684f57" translate="yes" xml:space="preserve">
          <source>Base class for thread exceptions.</source>
          <target state="translated">线程异常的基类。</target>
        </trans-unit>
        <trans-unit id="b0f6bbd9a7204a011357ddbe15da4f159805a9c3" translate="yes" xml:space="preserve">
          <source>Base classes are a list of these.</source>
          <target state="translated">基类是其中的一个列表。</target>
        </trans-unit>
        <trans-unit id="72c50689eae38c1c7d83b57fc2a2426479cefce2" translate="yes" xml:space="preserve">
          <source>Base exception thrown by &lt;code&gt;std.socket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.socket&lt;/code&gt; 抛出的基本异常。</target>
        </trans-unit>
        <trans-unit id="05df8270dbce2a852d75025619c0b4d03bd1da5f" translate="yes" xml:space="preserve">
          <source>BaseClass* &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt;;</source>
          <target state="translated">BaseClass * &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="22f60185c7bbe04f26adbe40ecfd3daf1c5e1e4a" translate="yes" xml:space="preserve">
          <source>Based on a design by Mikola Lysenko.</source>
          <target state="translated">根据Mikola Lysenko的设计。</target>
        </trans-unit>
        <trans-unit id="b9c44f636926230213ca4c58bc4bd5fa1a395472" translate="yes" xml:space="preserve">
          <source>Based on code written by Regan Heath</source>
          <target state="translated">基于Regan Heath编写的代码</target>
        </trans-unit>
        <trans-unit id="8a178898d54dc17c11ed3e0694b1794aa76cee7f" translate="yes" xml:space="preserve">
          <source>Based on ideas in Table 3.1 from &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt; Modern C++ Design&lt;/a&gt;, Andrei Alexandrescu (Addison-Wesley Professional, 2001)</source>
          <target state="translated">基于&lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt;Modern C ++ Design的&lt;/a&gt;表3.1中的思想，Andrei Alexandrescu（Addison-Wesley Professional，2001年）</target>
        </trans-unit>
        <trans-unit id="74c70ad4dc394c37a35d8a9a02d3bbf206c6a2c3" translate="yes" xml:space="preserve">
          <source>Baseok &lt;strong id=&quot;baseok&quot;&gt;baseok&lt;/strong&gt;;</source>
          <target state="translated">Baseok &lt;strong id=&quot;baseok&quot;&gt;baseok&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2958841f21ba5aab25e4b9de01c61072c4396f05" translate="yes" xml:space="preserve">
          <source>Basic (default)</source>
          <target state="translated">基本(默认)</target>
        </trans-unit>
        <trans-unit id="0376175c25ef469be8d7167b7c3f076d8a83135c" translate="yes" xml:space="preserve">
          <source>Basic Data Types</source>
          <target state="translated">基本数据类型</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">基本示例</target>
        </trans-unit>
        <trans-unit id="e19913977bf78df5f5b70c758a83b5ae4241e38e" translate="yes" xml:space="preserve">
          <source>Basic Latin</source>
          <target state="translated">基础拉丁语</target>
        </trans-unit>
        <trans-unit id="0c51e02cc99b54172f7d7ba26283b9a2651139e1" translate="yes" xml:space="preserve">
          <source>Basic Logging</source>
          <target state="translated">基本记录</target>
        </trans-unit>
        <trans-unit id="c1025054c73b30fcc4ab113e76ab64be203331d7" translate="yes" xml:space="preserve">
          <source>Basic SMTP protocol support.</source>
          <target state="translated">基本的SMTP协议支持。</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">基本类型</target>
        </trans-unit>
        <trans-unit id="bf25bdb7baac4ca40f143b32bfd463f5aa35f794" translate="yes" xml:space="preserve">
          <source>Basic and dumm visitor which implements a visit method for each AST node implemented in AST. This visitor is the parent of strict, transitive and permissive visitors.</source>
          <target state="translated">Basic 和 dumm 访客,它为 AST 中实现的每个 AST 节点实现了一个访问方法。这个访问者是严格的、转义的和允许的访问者的父类。</target>
        </trans-unit>
        <trans-unit id="da424bc11d72f3a523d822671599c05d2482dd43" translate="yes" xml:space="preserve">
          <source>Basic block control flow operators.</source>
          <target state="translated">基本的区块控制流程操作人员。</target>
        </trans-unit>
        <trans-unit id="55069311e393b3bc10e5288945ff6aebf4b60dce" translate="yes" xml:space="preserve">
          <source>Basic blocks: Basic blocks are a linked list of all the basic blocks in a function. startblock heads the list.</source>
          <target state="translated">基本块。基本区块是一个函数中所有基本区块的链接列表 startblock是列表的头。</target>
        </trans-unit>
        <trans-unit id="b015bc27621ab2a6e58582de340627d2513e110c" translate="yes" xml:space="preserve">
          <source>Basic data types are leaf types. Derived data types build on leaf types. User defined types are aggregates of basic and derived types.</source>
          <target state="translated">基本数据类型是叶子类型。派生数据类型建立在叶子类型的基础上。用户定义类型是基本类型和派生类型的集合。</target>
        </trans-unit>
        <trans-unit id="c76e778b9531849f5fdc3371b8bf8a9576ca93cb" translate="yes" xml:space="preserve">
          <source>Basic splitting with characters and numbers.</source>
          <target state="translated">用字符和数字进行基本分割。</target>
        </trans-unit>
        <trans-unit id="22d64c70202f0fd0175e71294c1f0654ef85c43d" translate="yes" xml:space="preserve">
          <source>Basic support for lock-free concurrent programming.</source>
          <target state="translated">基本支持无锁并发编程。</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="f3a7ec26a786494d0ab6bd615e7d7023643666db" translate="yes" xml:space="preserve">
          <source>Be wary of CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') attacks. &lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt; More info: &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&lt;/a&gt;</source>
          <target state="translated">警惕CWE-22：路径名对受限目录的不正确限制（&amp;ldquo;路径遍历&amp;rdquo;）攻击。&lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt;更多信息：&lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https&lt;/a&gt;：//www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating +来自+污染+来源</target>
        </trans-unit>
        <trans-unit id="0d9a6a84847309258cd9cad1f00b1d9b08270b36" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MultiwayMerge&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;MultiwayMerge&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;MultiwayMerge&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">因为 &lt;code&gt;MultiwayMerge&lt;/code&gt; 不分配额外的内存，所以它将保留 &lt;code&gt;ror&lt;/code&gt; 的修改。即， &lt;code&gt;MultiwayMerge&lt;/code&gt; 承担了 &lt;code&gt;ror&lt;/code&gt; 的所有权，并酌情交换和推进了它的元素。如果您希望 &lt;code&gt;ror&lt;/code&gt; 在调用后保留其内容，则可能希望将副本传递给 &lt;code&gt;MultiwayMerge&lt;/code&gt; （并可能在调用之间缓存副本）。</target>
        </trans-unit>
        <trans-unit id="34edc8e4b66b211204a07db61a02d64017fc4c94" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;largestPartialIntersection&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;largestPartialIntersection&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;largestPartialIntersection&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">由于 &lt;code&gt;largestPartialIntersection&lt;/code&gt; 不会分配额外的内存，因此将 &lt;code&gt;ror&lt;/code&gt; 保留为已修改状态。即， &lt;code&gt;largestPartialIntersection&lt;/code&gt; 承担 &lt;code&gt;ror&lt;/code&gt; 的所有权，并酌情交换和预付其元素。如果您希望 &lt;code&gt;ror&lt;/code&gt; 在调用后保留其内容，则可能希望将副本传递给 &lt;code&gt;largestPartialIntersection&lt;/code&gt; （并可能在调用之间缓存副本）。</target>
        </trans-unit>
        <trans-unit id="f9b6407740dfbc3c5fa141971e324ac38d1b4cc4" translate="yes" xml:space="preserve">
          <source>Because errors are unusual, execution of error handling code is not performance critical.</source>
          <target state="translated">因为错误是不寻常的,所以执行错误处理代码并不影响性能。</target>
        </trans-unit>
        <trans-unit id="1362358bff14273f0cd677a86a2f16a4032a69e1" translate="yes" xml:space="preserve">
          <source>Because immutable is transitive, data referred to by an immutable is also immutable:</source>
          <target state="translated">因为不可变是转义的,所以不可变所指的数据也是不可变的。</target>
        </trans-unit>
        <trans-unit id="37a897f3827c71e8379bebae37724c5759dd60a2" translate="yes" xml:space="preserve">
          <source>Because it doesn't return the value, this function is cheaper than &lt;code&gt;get&lt;/code&gt;. However, if you do need the value as well, you should just check the return of &lt;code&gt;get&lt;/code&gt; for &lt;code&gt;null&lt;/code&gt; instead of using this function first.</source>
          <target state="translated">因为它不返回值，所以此函数比 &lt;code&gt;get&lt;/code&gt; 便宜。但是，如果你确实需要的价值，以及，你应该检查返回 &lt;code&gt;get&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，而不是第一个使用此功能的。</target>
        </trans-unit>
        <trans-unit id="46a9674034fbe47581e972f1a85b13b8dd6bc584" translate="yes" xml:space="preserve">
          <source>Because modules are not part of C++, each function with C++ linkage in the global namespace must be globally unique within the program.</source>
          <target state="translated">因为模块不是C++的一部分,所以在全局命名空间中,每个带有C++链接的函数在程序中必须是全局唯一的。</target>
        </trans-unit>
        <trans-unit id="1a175b9174f2111e9e8065ab0dee738f3bde0af2" translate="yes" xml:space="preserve">
          <source>Because static arrays are passed to functions by value, a larger array can consume a lot of stack space. Use dynamic arrays instead.</source>
          <target state="translated">因为静态数组是通过值传递给函数的,所以较大的数组会消耗大量的栈空间。使用动态数组代替。</target>
        </trans-unit>
        <trans-unit id="f36468f4c3a8d99449e93cf621c400036ac04c35" translate="yes" xml:space="preserve">
          <source>Because the allocator does not reuse memory, any dangling references to deallocated memory will always result in deterministically crashing the process.</source>
          <target state="translated">因为分配器不重用内存,任何对deallocated内存的悬空引用总是会导致进程确定性地崩溃。</target>
        </trans-unit>
        <trans-unit id="d8c3a61715e6c076e516e2adb94c24e13d1a7e0e" translate="yes" xml:space="preserve">
          <source>Because the reduction is being performed in parallel, &lt;code&gt;functions&lt;/code&gt; must be associative. For notational simplicity, let # be an infix operator representing &lt;code&gt;functions&lt;/code&gt;. Then, (a # b) # c must equal a # (b # c). Floating point addition is not associative even though addition in exact arithmetic is. Summing floating point numbers using this function may give different results than summing serially. However, for many practical purposes floating point addition can be treated as associative.</source>
          <target state="translated">因为归约是并行执行的，所以 &lt;code&gt;functions&lt;/code&gt; 必须是关联的。为了简化符号，让＃为表示 &lt;code&gt;functions&lt;/code&gt; 的中缀运算符。然后，（a＃b）＃c必须等于＃（b＃c）。即使精确算术中的加法运算，浮点加法也不是关联的。使用此功能求和浮点数可能会得到与串行求和不同的结果。但是，出于许多实际目的，可以将浮点加法视为关联的。</target>
        </trans-unit>
        <trans-unit id="b6b9c971f1d02fbd8d1af3306f1013bb85ae0126" translate="yes" xml:space="preserve">
          <source>Because the validity of the day number depends on both on the year and month of which the day is occurring, take all three variables to validate the day.</source>
          <target state="translated">因为日号的有效性既取决于该日发生的年月日,所以取这三个变量来验证该日。</target>
        </trans-unit>
        <trans-unit id="04beefc07e753c0350f57ce75d35ae3795bc6efa" translate="yes" xml:space="preserve">
          <source>Because there are no units larger than years, there is no difference between adding and rolling years.</source>
          <target state="translated">因为没有大于年的单位,所以加年和滚年没有区别。</target>
        </trans-unit>
        <trans-unit id="8b9fa636d60436156ac4d9755dc04095e1b03ef6" translate="yes" xml:space="preserve">
          <source>Before the function actually returns, any objects with scope storage duration are destroyed, any enclosing finally clauses are executed, any scope(exit) statements are executed, any scope(success) statements are executed, and any enclosing synchronization objects are released.</source>
          <target state="translated">在函数实际返回之前,任何具有作用域存储持续时间的对象都会被销毁,任何包围性的最后子句都会被执行,任何 scope(exit)语句都会被执行,任何 scope(success)语句都会被执行,任何包围性的同步对象都会被释放。</target>
        </trans-unit>
        <trans-unit id="29b56d3b3ce732a418c6733f4aa512d819b9b955" translate="yes" xml:space="preserve">
          <source>Begins a full collection. While the meaning of this may change based on the garbage collector implementation, typical behavior is to scan all stack segments for roots, mark accessible memory blocks as alive, and then to reclaim free space. This action may need to suspend all running threads for at least part of the collection process.</source>
          <target state="translated">开始一个完整的收集。虽然这个含义可能会根据垃圾收集器的实现而改变,但典型的行为是扫描所有堆栈段的根,将可访问的内存块标记为有效,然后回收空闲空间。这个操作可能需要暂停所有正在运行的线程,至少在收集过程的一部分。</target>
        </trans-unit>
        <trans-unit id="a9290b213da7c41d3b9d381305e1a85dfd638ddf" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;#visit&quot;&gt;&lt;code&gt;visit&lt;/code&gt;&lt;/a&gt; but doesn't enforce that all types are handled by the visiting functions.</source>
          <target state="translated">表现为&lt;a href=&quot;#visit&quot;&gt; &lt;code&gt;visit&lt;/code&gt; &lt;/a&gt;但不强制所有类型都由访问功能处理。</target>
        </trans-unit>
        <trans-unit id="8671963c6358c10c30f0a9f60f5760e545d91151" translate="yes" xml:space="preserve">
          <source>Behaves like the identity function when args is empty.</source>
          <target state="translated">当args为空时,其行为与身份函数类似。</target>
        </trans-unit>
        <trans-unit id="f909782a90d0d82b3e7b38e26ebe9e00bc13126f" translate="yes" xml:space="preserve">
          <source>Being 100% compatible with C++ means more or less adding a fully functional C++ compiler front end to D. Anecdotal evidence suggests that writing such is a minimum of a 10 man-year project, essentially making a D compiler with such capability unimplementable. Other languages looking to hook up to C++ face the same problem, and the solutions have been:</source>
          <target state="translated">与C++100%兼容多少意味着要在D语言中加入一个全功能的C++编译器前端。传闻表明,编写这样的编译器至少是一个10人年的项目,基本上使得具有这种功能的D编译器无法实现。其他希望挂靠C++的语言也面临着同样的问题,解决的办法也有。</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="d6bc78c2edfd9a1e4a494692d443253b772c6030" translate="yes" xml:space="preserve">
          <source>Below here follows defines for the CURLOPT_IPRESOLVE option. If a host name resolves addresses using more than one IP protocol version, this option might be handy to force libcurl to use a specific IP version.</source>
          <target state="translated">下面是CURLOPT_IPRESOLVE选项的定义。如果一个主机名使用多个IP协议版本来解析地址,那么这个选项可以方便地强制libcurl使用特定的IP版本。</target>
        </trans-unit>
        <trans-unit id="8b8ee9a8f224bc381d10b9725300af6e8ad60b2f" translate="yes" xml:space="preserve">
          <source>Below is the table of names accepted by &lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt;&lt;code&gt;unicode.hangulSyllableType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下表是&lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt; &lt;code&gt;unicode.hangulSyllableType&lt;/code&gt; &lt;/a&gt;接受的名称表。</target>
        </trans-unit>
        <trans-unit id="f460beb4086eb83db26145c0c14bfc2836a2dd77" translate="yes" xml:space="preserve">
          <source>Below is the table with block names accepted by &lt;a href=&quot;#unicode.block&quot;&gt;&lt;code&gt;unicode.block&lt;/code&gt;&lt;/a&gt;. Note that the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; requires &quot;In&quot; to be prepended to the names of blocks so as to disambiguate scripts and blocks.</source>
          <target state="translated">下表是&lt;a href=&quot;#unicode.block&quot;&gt; &lt;code&gt;unicode.block&lt;/code&gt; &lt;/a&gt;接受的块名称表。请注意，速记版本&lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt;要求在块名称之前加上&amp;ldquo; In&amp;rdquo;，以消除脚本和块的歧义。</target>
        </trans-unit>
        <trans-unit id="c16ded473b8d6a501e3afbf1d6b1aaa3bb67b9a5" translate="yes" xml:space="preserve">
          <source>Below is the table with script names accepted by &lt;a href=&quot;#unicode.script&quot;&gt;&lt;code&gt;unicode.script&lt;/code&gt;&lt;/a&gt; and by the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">下表是&lt;a href=&quot;#unicode.script&quot;&gt; &lt;code&gt;unicode.script&lt;/code&gt; &lt;/a&gt;和速记版本&lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt;接受的脚本名称：</target>
        </trans-unit>
        <trans-unit id="5cce75cef6b6f1b3c31bc07730b294f2256592a7" translate="yes" xml:space="preserve">
          <source>Benchmark with two functions comparing.</source>
          <target state="translated">与两个函数比较的基准。</target>
        </trans-unit>
        <trans-unit id="aa8cbccdf814344c472fdc83108ce95f463d76c2" translate="yes" xml:space="preserve">
          <source>Benchmarks code for speed assessment and comparison.</source>
          <target state="translated">用于速度评估和比较的基准代码。</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="39b464ae10a3403acc76206ce3373cf277ad5588" translate="yes" xml:space="preserve">
          <source>Beta function</source>
          <target state="translated">Beta功能</target>
        </trans-unit>
        <trans-unit id="6cf60f60aed600fb3f70f4f199ce23160c46df50" translate="yes" xml:space="preserve">
          <source>Better C</source>
          <target state="translated">更好的C</target>
        </trans-unit>
        <trans-unit id="fa66737ffd71fbd94c99a79ae1d7c0f7a3f83f97" translate="yes" xml:space="preserve">
          <source>Bidi_Control</source>
          <target state="translated">Bidi_Control</target>
        </trans-unit>
        <trans-unit id="c1dd854953db9a48bc0d0ea0a3df0b423f22bafe" translate="yes" xml:space="preserve">
          <source>Bidirectional primitives. They are offered if &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt;.</source>
          <target state="translated">双向基元。如果 &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt; ,则提供它们。</target>
        </trans-unit>
        <trans-unit id="0fd2b2945fcece1d7de6dc41f877ba8c67c13689" translate="yes" xml:space="preserve">
          <source>Bidirectional range of elements</source>
          <target state="translated">元素的双向范围</target>
        </trans-unit>
        <trans-unit id="019ef9f3f8b5262d462588c43fd756f3913eee2d" translate="yes" xml:space="preserve">
          <source>Bidirectional range primitives. Provided only if both &lt;code&gt;hasSlicing!Source&lt;/code&gt; and &lt;code&gt;hasLength!Source&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">双向范围原语。仅当 &lt;code&gt;hasSlicing!Source&lt;/code&gt; 和 &lt;code&gt;hasLength!Source&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时才提供。</target>
        </trans-unit>
        <trans-unit id="71bfb07d0cb12b1ba4834790c7322d9de720c8a3" translate="yes" xml:space="preserve">
          <source>BidirectionalRange &lt;code&gt;range&lt;/code&gt;</source>
          <target state="translated">双向 &lt;code&gt;range&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="635846f5f8a3535fe06ebe7bdfb132d87f3a3a9b" translate="yes" xml:space="preserve">
          <source>Big endian byte order</source>
          <target state="translated">大恩迪安字节顺序</target>
        </trans-unit>
        <trans-unit id="880ccaf424d3d59837e9afca21d218a82696d56c" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;base&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;base&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15d8e19b48cf73cfcbd5673d000427a6c89fe0cf" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;dividend&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;dividend&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bf4e8892121a909f8719ff5ba16cf85f8324a8e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;divisor&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;divisor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9d72c5e7f7fec77eccf61954e6a190a6919e39" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;exponent&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;exponent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d09af76576312e7fbdeb58e15f85ddf03bdfeca" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;modulus&lt;/code&gt;</source>
          <target state="translated">大整数 &lt;code&gt;modulus&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6719bddb8d0310ee6d49cac219e4be2a60dd859e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;quotient&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;quotient&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6acf46d3f9c34c441344f4052f380185deff090a" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;remainder&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;remainder&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc0d6128e74b8ffa38299adc002109eff669779d" translate="yes" xml:space="preserve">
          <source>BigInt implements value semantics using copy-on-write. This means that assignment is cheap, but operations such as x++ will cause heap allocation. (But note that for most bigint operations, heap allocation is inevitable anyway.)</source>
          <target state="translated">BigInt使用copy-on-write实现了值语义。这意味着赋值很便宜,但x++等操作会造成堆分配。(但请注意,对于大多数bigint操作来说,无论如何,堆分配是不可避免的。)</target>
        </trans-unit>
        <trans-unit id="2ae987b3c8b155139b22a17dacfded40cd54d6e8" translate="yes" xml:space="preserve">
          <source>Binary Operator Overloading</source>
          <target state="translated">二进制运算符重载</target>
        </trans-unit>
        <trans-unit id="7ea3f10d7dc50a5d1d60c584be4ba66327be2344" translate="yes" xml:space="preserve">
          <source>Binary exponentiation</source>
          <target state="translated">二进制指数</target>
        </trans-unit>
        <trans-unit id="bc0e2dd063d01cb0a49d6952e1a447f5a0786666" translate="yes" xml:space="preserve">
          <source>Binary expressions except for &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt;, and &lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression&lt;/i&gt;&lt;/a&gt; are evaluated in lexical order (left-to-right). Example:</source>
          <target state="translated">除&lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;，&lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt;和&lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression&lt;/i&gt;&lt;/a&gt;之外的二进制表达式以词法顺序（从左到右）求值。例：</target>
        </trans-unit>
        <trans-unit id="3f59323ff0289ed186c342bdb4f9ade9bee4b594" translate="yes" xml:space="preserve">
          <source>Binary files: Number of bytes to offset from origin.</source>
          <target state="translated">二进制文件。从原点出发要偏移的字节数。</target>
        </trans-unit>
        <trans-unit id="5ec3f5b7c67a25b307ee5761394fbc7f85f5c4ec" translate="yes" xml:space="preserve">
          <source>Binary files: Position used as reference for the offset, must be one of &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt;, &lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt; or &lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt;.</source>
          <target state="translated">二进制文件：位置用作偏移参考，必须是一个&lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt;，&lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt;或&lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="710001c86b903db5ac28284015f70ad29d702165" translate="yes" xml:space="preserve">
          <source>Binary integers are a sequence of binary digits preceded by a &amp;lsquo;0b&amp;rsquo; or &amp;lsquo;0B&amp;rsquo;.</source>
          <target state="translated">二进制整数是由&amp;ldquo; 0b&amp;rdquo;或&amp;ldquo; 0B&amp;rdquo;开头的二进制数字序列。</target>
        </trans-unit>
        <trans-unit id="e30449766634fc47649993e043f53913e318f363" translate="yes" xml:space="preserve">
          <source>Binary operations: subtracting and intersecting flags</source>
          <target state="translated">二进制运算:减法和相交标志。</target>
        </trans-unit>
        <trans-unit id="5bc41f55b9ac5ad602ac2a15812f4fa17e719258" translate="yes" xml:space="preserve">
          <source>Binary predicate for determining equivalence of two elements.</source>
          <target state="translated">二元谓词,用于确定两个元素的等价性。</target>
        </trans-unit>
        <trans-unit id="1b5c4d6f642263934709007da433b44cfafe3dfa" translate="yes" xml:space="preserve">
          <source>Binary predicate that reverses the order of arguments, e.g., given &lt;code&gt;pred(a, b)&lt;/code&gt;, returns &lt;code&gt;pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">反转参数顺序的二进制谓词，例如，给定 &lt;code&gt;pred(a, b)&lt;/code&gt; ，返回 &lt;code&gt;pred(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3390f0873b37228eb9da1981c4edea13376f4ce4" translate="yes" xml:space="preserve">
          <source>Binary zero (NUL, U+0000).</source>
          <target state="translated">二进制零(NUL,U+0000)。</target>
        </trans-unit>
        <trans-unit id="f07c525c75d6754496cc9e553ac6cf1931c4d038" translate="yes" xml:space="preserve">
          <source>BinaryHeap!(Store, less) &lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt;(alias less = &quot;a &amp;lt; b&quot;, Store)(Store s, size_t initialSize = size_t.max);</source>
          <target state="translated">BinaryHeap！（Store，less）&lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt;（alias less =&amp;ldquo; a &amp;lt;b&amp;rdquo;，Store）（Store s，size_t initialSize = size_t.max）;</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">绑定值到准备好的报表</target>
        </trans-unit>
        <trans-unit id="29d9453c80dc53e32cc00f3280980ce7ea8a0687" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr)</source>
          <target state="translated">为::操作符delete(void*ptr)绑定。</target>
        </trans-unit>
        <trans-unit id="f7d97838adda037dd541956c0b38a3516ae36925" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr, const std::nothrow_t&amp;amp; tag)</source>
          <target state="translated">绑定:: operator delete（void * ptr，const std :: nothrow_t＆标签）</target>
        </trans-unit>
        <trans-unit id="9e8bd6d0542a61db39dc7370f4ff9f5bdec532e6" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count)</source>
          <target state="translated">绑定 ::operator new(std::size_t count)</target>
        </trans-unit>
        <trans-unit id="c9209fa1a437c94943e83fdcf912d410e070a043" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count, const std::nothrow_t&amp;amp;)</source>
          <target state="translated">绑定:: operator new（std :: size_t count，const std :: nothrow_t＆）</target>
        </trans-unit>
        <trans-unit id="c595af9a225910870bb198153cb9e584ec6c2237" translate="yes" xml:space="preserve">
          <source>Binds the internal state to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">将内部状态绑定到 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e718a122aa87d12e98c5f3055711cc94d264e1c" translate="yes" xml:space="preserve">
          <source>Bionic C runtime</source>
          <target state="translated">Bionic C运行时</target>
        </trans-unit>
        <trans-unit id="cec8cf9a0b27bd714792dac06606e5c1b0178367" translate="yes" xml:space="preserve">
          <source>Bit constructs</source>
          <target state="translated">位结构</target>
        </trans-unit>
        <trans-unit id="70402e7ad10ad5f2124d70b6b5dfed369e14c974" translate="yes" xml:space="preserve">
          <source>Bit decoding of the TargetOS</source>
          <target state="translated">TargetOS的比特解码</target>
        </trans-unit>
        <trans-unit id="da97ac52d02a77703c633362dd74456458d249b2" translate="yes" xml:space="preserve">
          <source>Bit fields are supported with the &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;bitfields&lt;/a&gt; template.</source>
          <target state="translated">位&lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;域&lt;/a&gt;模板支持位域。</target>
        </trans-unit>
        <trans-unit id="11ee76002d783da853ef20847f30176e5d03ae44" translate="yes" xml:space="preserve">
          <source>Bit flipping</source>
          <target state="translated">翻转位</target>
        </trans-unit>
        <trans-unit id="8f76655665dcf73e363d56fc2df9877070986357" translate="yes" xml:space="preserve">
          <source>Bit wise expressions perform a bitwise operation on their operands. Their operands must be integral types. First, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are done. Then, the bitwise operation is done.</source>
          <target state="translated">按位表达式对它们的操作数执行按位运算。它们的操作数必须是整数类型。首先，完成&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;常规的算术转换&lt;/a&gt;。然后，按位运算完成。</target>
        </trans-unit>
        <trans-unit id="0ab61da13a6c10abbc480c4a1c0747cb3baa6877" translate="yes" xml:space="preserve">
          <source>Bit-level manipulation facilities.</source>
          <target state="translated">位级操纵设施。</target>
        </trans-unit>
        <trans-unit id="d9eff8dc4264242a1ae12f932821b47da28a5cc7" translate="yes" xml:space="preserve">
          <source>Bitwise Expressions</source>
          <target state="translated">位元表达式</target>
        </trans-unit>
        <trans-unit id="df5079d347ee1e4244353fecfac2f5edf6b28c3c" translate="yes" xml:space="preserve">
          <source>Bitwise adapter over an integral type range. Consumes the range elements bit by bit, from the least significant bit to the most significant bit.</source>
          <target state="translated">在积分型范围内进行位式转换。从最小的有效位到最大的有效位,逐位消耗范围内的元素。</target>
        </trans-unit>
        <trans-unit id="9b504c7d294e8d9e76232c80318479234720041d" translate="yes" xml:space="preserve">
          <source>Bitwise rotate &lt;code&gt;value&lt;/code&gt; left (&lt;code&gt;rol&lt;/code&gt;) or right (&lt;code&gt;ror&lt;/code&gt;) by &lt;code&gt;count&lt;/code&gt; bit positions.</source>
          <target state="translated">按位旋转 &lt;code&gt;value&lt;/code&gt; 左（ &lt;code&gt;rol&lt;/code&gt; 或）右（ &lt;code&gt;ror&lt;/code&gt; 通过） &lt;code&gt;count&lt;/code&gt; 位的位置。</target>
        </trans-unit>
        <trans-unit id="8ac6960d99f504b227c089027d841f4e9c385375" translate="yes" xml:space="preserve">
          <source>Block Elements</source>
          <target state="translated">块状元素</target>
        </trans-unit>
        <trans-unit id="44f23b923d4c118ace9751471e8a32d3ddca275e" translate="yes" xml:space="preserve">
          <source>Block Statement</source>
          <target state="translated">块状声明</target>
        </trans-unit>
        <trans-unit id="7358e14919f4d134af66ef6ad913b5a7d1139ac8" translate="yes" xml:space="preserve">
          <source>Block comments can span multiple lines, but do not nest.</source>
          <target state="translated">块状注释可以跨越多行,但不要嵌套。</target>
        </trans-unit>
        <trans-unit id="7fbe37dc50c1260fc0044f00cb0158d89f4c81af" translate="yes" xml:space="preserve">
          <source>Block of memory to serve as support for the allocator. Memory must be larger than two words and word-aligned.</source>
          <target state="translated">作为分配器支持的内存块。内存必须大于两个字,且字数对齐。</target>
        </trans-unit>
        <trans-unit id="ae0016c0671df573a3221620d651641a4c8dfdcc" translate="yes" xml:space="preserve">
          <source>Block previously obtained by a call to &lt;code&gt;allocate&lt;/code&gt; against this allocator (&lt;code&gt;null&lt;/code&gt; is allowed).</source>
          <target state="translated">块先前由呼叫获得 &lt;code&gt;allocate&lt;/code&gt; 针对该分配器（ &lt;code&gt;null&lt;/code&gt; 是允许的）。</target>
        </trans-unit>
        <trans-unit id="3ccb689779e89b6ac603e18c3e2082f3bf5ed78f" translate="yes" xml:space="preserve">
          <source>Block to deallocate.</source>
          <target state="translated">块进行重新分配。</target>
        </trans-unit>
        <trans-unit id="8117bd427e84d25123d525df198441ce5a262ba4" translate="yes" xml:space="preserve">
          <source>BlockStatement</source>
          <target state="translated">BlockStatement</target>
        </trans-unit>
        <trans-unit id="1c575a00b6c6472431006e69a67cda683c681cb6" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator</source>
          <target state="translated">BookkeepingAllocator</target>
        </trans-unit>
        <trans-unit id="642b597338266fa6f0fcfa51d03f6363e4f3af1d" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator &lt;strong id=&quot;bkalloc&quot;&gt;bkalloc&lt;/strong&gt;;</source>
          <target state="translated">簿记&lt;strong id=&quot;bkalloc&quot;&gt;分配器bkalloc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="807b1864fdb6805b8347ae2bc9a6c20e8e44cbff" translate="yes" xml:space="preserve">
          <source>Boolean Operations</source>
          <target state="translated">布尔运算</target>
        </trans-unit>
        <trans-unit id="9a7bb38540335c853c8483b5f52966e014c86be1" translate="yes" xml:space="preserve">
          <source>Boolean flag set to true while the runtime is initialized.</source>
          <target state="translated">当运行时被初始化时,设置为true的布尔标志。</target>
        </trans-unit>
        <trans-unit id="919ba0f721b82028f799116e9733b52309e726b3" translate="yes" xml:space="preserve">
          <source>Boolean options</source>
          <target state="translated">布尔型选项</target>
        </trans-unit>
        <trans-unit id="401d2f1688a777ae0bc5be157d0d7272e332e127" translate="yes" xml:space="preserve">
          <source>Boolean values are printed as &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">布尔值打印为 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="105c6c86d7dd1b24e773395f017e7ee3c51ac8ff" translate="yes" xml:space="preserve">
          <source>Boost License 1.0</source>
          <target state="translated">Boost License 1.0</target>
        </trans-unit>
        <trans-unit id="e47a3386c7e74d205f749769164e9ef5c8040834" translate="yes" xml:space="preserve">
          <source>Boost Signals</source>
          <target state="translated">提升信号</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="5ba82cb02c720f3652f57a038e834a4bcc4c4c2f" translate="yes" xml:space="preserve">
          <source>Bopomofo Extended</source>
          <target state="translated">Bopomofo扩展版</target>
        </trans-unit>
        <trans-unit id="a60c93251f61201f166e2379b490f975956e31c4" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Algebraic&lt;/code&gt; and &lt;code&gt;Variant&lt;/code&gt; share &lt;code&gt; VariantN&lt;/code&gt;'s interface. (See their respective documentations below.)</source>
          <target state="translated">这两个 &lt;code&gt;Algebraic&lt;/code&gt; 和 &lt;code&gt;Variant&lt;/code&gt; 份额 &lt;code&gt; VariantN&lt;/code&gt; 的接口。（请参阅下面的相应文档。）</target>
        </trans-unit>
        <trans-unit id="6535ded07930e3ddda0a1fe0ceda88dc9ce33dfa" translate="yes" xml:space="preserve">
          <source>Both backward and forward.</source>
          <target state="translated">无论是后退还是前进。</target>
        </trans-unit>
        <trans-unit id="b8f7ae57cc9f0d657e03c01e9e4d98ba216ba14c" translate="yes" xml:space="preserve">
          <source>Both immutable and const are</source>
          <target state="translated">不可变和常量都是</target>
        </trans-unit>
        <trans-unit id="e6a3f4fd036b065b2e797530c76e1c67c7c891ad" translate="yes" xml:space="preserve">
          <source>Both isThis() and isNested() should return true if function needs a dual-context pointer, otherwise if isThis() returns true, isNested() should return false.</source>
          <target state="translated">如果函数需要一个双上下文指针,isThis()和isNested()都应该返回true,否则如果isThis()返回true,isNested()应该返回false。</target>
        </trans-unit>
        <trans-unit id="bf39d0ca68e0898427724a5e452ff23fb939fa46" translate="yes" xml:space="preserve">
          <source>Both rewrites are tried. If only one compiles, that one is taken. If they both resolve to the same function, the first rewrite is done. If they resolve to different functions, the best matching one is used. If they both match the same, but are different functions, an ambiguity error results.</source>
          <target state="translated">两个重写都试过了。如果只有一个被编译,则采用那个。如果它们都解析为同一个函数,则采用第一个重写。如果它们解析的是不同的函数,则使用匹配度最好的一个。如果它们都是相同的匹配,但是是不同的函数,那么就会产生歧义错误。</target>
        </trans-unit>
        <trans-unit id="0cd32d8791a4b901dbb6cc0f81dd64df4c40048e" translate="yes" xml:space="preserve">
          <source>Both the test and the return expressions are lazily evaluated.</source>
          <target state="translated">测试和返回表达式都会被懒惰地评估。</target>
        </trans-unit>
        <trans-unit id="171f0c459de342d1f54dbc2ce2646745cc4ebc56" translate="yes" xml:space="preserve">
          <source>Both variants are implemented as instantiations of the template &lt;a href=&quot;#Base64Impl&quot;&gt;&lt;code&gt;Base64Impl&lt;/code&gt;&lt;/a&gt;. Most users will not need to use this template directly; however, it can be used to create customized Base64 encodings, such as one that omits padding characters, or one that is safe to embed inside a regular expression.</source>
          <target state="translated">这两个变体都实现为模板&lt;a href=&quot;#Base64Impl&quot;&gt; &lt;code&gt;Base64Impl&lt;/code&gt; 的&lt;/a&gt;实例。大多数用户将不需要直接使用此模板。但是，它可以用于创建自定义的Base64编码，例如一种省略填充字符的编码，或者一种可以安全地嵌入到正则表达式中的编码。</target>
        </trans-unit>
        <trans-unit id="00d1805af0d734eef9db29bbdcf7d82b5d3e7f04" translate="yes" xml:space="preserve">
          <source>Box Drawing</source>
          <target state="translated">框图</target>
        </trans-unit>
        <trans-unit id="b8d28f7a363659e9c4b08c47130a0d8f80f5c106" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(binaryFun!pred, Range) &lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range needle)</source>
          <target state="translated">BoyerMooreFinder！（binaryFun！pred，范围）&lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，范围）（范围针）</target>
        </trans-unit>
        <trans-unit id="2a76fd949603813a813972f30d7b0eeea91480d5" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(pred, InputRange) &lt;code&gt;needle&lt;/code&gt;</source>
          <target state="translated">BoyerMooreFinder！（pred，InputRange） &lt;code&gt;needle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e5a99860d31900d36389daa3fa718de031554d4" translate="yes" xml:space="preserve">
          <source>Brahmi</source>
          <target state="translated">Brahmi</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="754a680c22eb1f9ecca61fac281a3f23b7fb9d29" translate="yes" xml:space="preserve">
          <source>Braille Patterns</source>
          <target state="translated">盲文图案</target>
        </trans-unit>
        <trans-unit id="b2fcd02a50371b93a9e3654260745ee0af90cca2" translate="yes" xml:space="preserve">
          <source>Break Statement</source>
          <target state="translated">休息声明</target>
        </trans-unit>
        <trans-unit id="76820814ec6d343b49333e574d3bb22a7fa8676a" translate="yes" xml:space="preserve">
          <source>Break and Continue out of Foreach</source>
          <target state="translated">从Foreach中断开并继续</target>
        </trans-unit>
        <trans-unit id="0a89343c3ed16b2574554e37596ef4b4facffb9f" translate="yes" xml:space="preserve">
          <source>Breaking from a parallel foreach loop via a break, labeled break, labeled continue, return or goto statement throws a &lt;code&gt;ParallelForeachError&lt;/code&gt;.  In the case of non-random access ranges, parallel foreach buffers lazily to an array of size &lt;code&gt;workUnitSize&lt;/code&gt; before executing the parallel portion of the loop. The exception is that, if a parallel foreach is executed over a range returned by &lt;code&gt;asyncBuf&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt;, the copying is elided and the buffers are simply swapped. In this case &lt;code&gt;workUnitSize&lt;/code&gt; is ignored and the work unit size is set to the buffer size of &lt;code&gt;range&lt;/code&gt;.  A memory barrier is guaranteed to be executed on exit from the loop, so that results produced by all threads are visible in the calling thread.  &lt;b&gt;Exception Handling&lt;/b&gt;:  When at least one exception is thrown from inside a parallel foreach loop, the submission of additional &lt;code&gt;Task&lt;/code&gt; objects is terminated as soon as possible, in a non-deterministic manner. All executing or enqueued work units are allowed to complete. Then, all exceptions that were thrown by any work unit are chained using &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The order of the exception chaining is non-deterministic.</source>
          <target state="translated">通过中断，标记为break，标记为continue，return或goto的语句从并行foreach循环中断，将抛出 &lt;code&gt;ParallelForeachError&lt;/code&gt; 。对于非随机访问范围，在执行循环的并行部分之前，将并行foreach缓冲区延迟为一个大小为 &lt;code&gt;workUnitSize&lt;/code&gt; 的数组。唯一的例外是，如果在 &lt;code&gt;asyncBuf&lt;/code&gt; 或 &lt;code&gt;map&lt;/code&gt; 返回的范围内执行了并行的foreach ，则复制被忽略，缓冲区被简单地交换。在这种情况下，将忽略 &lt;code&gt;workUnitSize&lt;/code&gt; 并将工作单位大小设置为 &lt;code&gt;range&lt;/code&gt; 的缓冲区大小。确保在退出循环时执行内存屏障，以便所有线程产生的结果在调用线程中可见。 &lt;b&gt;异常处理&lt;/b&gt;：当从并行的foreach循环内引发至少一个异常时，其他 &lt;code&gt;Task&lt;/code&gt; 对象的提交将以不确定性方式尽快终止。允许所有执行或排队的工作单元完成。然后，使用 &lt;code&gt;Throwable.next&lt;/code&gt; 将所有工作单元抛出的所有异常链接在一起并重新抛出。异常链接的顺序是不确定的。</target>
        </trans-unit>
        <trans-unit id="9d3201041918654fbf75089e070856aa79ebc523" translate="yes" xml:space="preserve">
          <source>Breaks x into an integral part and a fractional part, each of which has the same sign as x. The integral part is stored in i.</source>
          <target state="translated">将x分解为一个积分部分和一个小数部分,每个小数部分都与x具有相同的符号。</target>
        </trans-unit>
        <trans-unit id="4324d0ed28641cb58b631967da3876548c2a70ef" translate="yes" xml:space="preserve">
          <source>Bring leaves to common type.</source>
          <target state="translated">把叶子带到普通型。</target>
        </trans-unit>
        <trans-unit id="399d0f0935a4fd7e2adf0462c69b1578bb0496b9" translate="yes" xml:space="preserve">
          <source>Buffer &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">缓冲 &lt;code&gt;buffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="535393fe6f448d36dc112ebfa2c4ec8acdaebcaa" translate="yes" xml:space="preserve">
          <source>Buffer to receive error messages in, must be at least CURL_ERROR_SIZE bytes big. If this is not used, error messages go to stderr instead:</source>
          <target state="translated">接收错误信息的缓冲区,必须至少是CURL_ERROR_SIZE字节大。如果没有使用这个选项,错误信息就会进入stderr。</target>
        </trans-unit>
        <trans-unit id="303f92df69f201e44e4c0ca1825e2e280d1f0c91" translate="yes" xml:space="preserve">
          <source>Buffer to structure as a free list. If &lt;code&gt;ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, the buffer is assumed to be allocated by &lt;code&gt;parent&lt;/code&gt; and will be freed in the destructor.</source>
          <target state="translated">缓冲区构造为自由列表。如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 不是 &lt;code&gt;NullAllocator&lt;/code&gt; ，则假定该缓冲区由 &lt;code&gt;parent&lt;/code&gt; 分配，并将在析构函数中释放。</target>
        </trans-unit>
        <trans-unit id="c05d2a8029044c4c4e57f66bbd40a3eac5b198a2" translate="yes" xml:space="preserve">
          <source>Buffer to write the escaped path to</source>
          <target state="translated">写入转义路径的缓冲区</target>
        </trans-unit>
        <trans-unit id="c083c9d2a3d468528bb5dd1cebdd4400312c43c2" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is enlarged if necessary, then set to the slice exactly containing the line.</source>
          <target state="translated">buf在必要时被放大,然后设置为包含行的片断。</target>
        </trans-unit>
        <trans-unit id="7ab4ac68db7c219824ba8029fe0a1e0d5e5c01c5" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is resized as necessary.</source>
          <target state="translated">缓冲区用于存储产生的行数据。buf根据需要调整大小。</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="80432fb4403119d7fa36b39cc0581f74363b7507" translate="yes" xml:space="preserve">
          <source>Bugs:</source>
          <target state="translated">Bugs:</target>
        </trans-unit>
        <trans-unit id="e543d61d1db526d2c201a9150a8eeb4f6a08a7bb" translate="yes" xml:space="preserve">
          <source>Bugzilla 2137</source>
          <target state="translated">Bugzilla 2137</target>
        </trans-unit>
        <trans-unit id="d957a3ddca24bb7ba3415ed5d23a475def657008" translate="yes" xml:space="preserve">
          <source>Bugzilla 592</source>
          <target state="translated">Bugzilla 592</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="e4ce8210e89bb0abea338092bae131b54bcd5ff1" translate="yes" xml:space="preserve">
          <source>Build __xopCmp for TypeInfo_Struct static bool __xopCmp(ref const S p, ref const S q) { return p.opCmp(q); }</source>
          <target state="translated">为TypeInfo_Struct构建__xopCmp static bool __xopCmp(ref const S p,ref const S q){return p.opCmp(q);}。</target>
        </trans-unit>
        <trans-unit id="f3d924ea22f0f293cf6f3ebfcd84f23fb87ecdc9" translate="yes" xml:space="preserve">
          <source>Build __xopEquals for TypeInfo_Struct static bool __xopEquals(ref const S p, ref const S q) { return p == q; }</source>
          <target state="translated">为TypeInfo_Struct构建__xopEquals static bool __xopEquals(ref const S p,ref const S q){return p ==q;}。</target>
        </trans-unit>
        <trans-unit id="edd21187462263909c4e5bccda552a4211a055ce" translate="yes" xml:space="preserve">
          <source>Build _xtoHash for non-bitwise hashing static hash_t xtoHash(ref const S p) nothrow @trusted;</source>
          <target state="translated">建立 _xtoHash 来进行非位元哈希静态哈希_t xtoHash(ref const S p)nothrow @trusted;</target>
        </trans-unit>
        <trans-unit id="02755102e393b0ceee36f18acf3cd4f3a97f903b" translate="yes" xml:space="preserve">
          <source>Build a list out of the null-terminated argument list.</source>
          <target state="translated">从空端参数列表中建立一个列表。</target>
        </trans-unit>
        <trans-unit id="8926cd9ddf0e4003036d0a204fc3589b6f556c48" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to copy the value of e into.</source>
          <target state="translated">建立一个临时变量来复制e的值。</target>
        </trans-unit>
        <trans-unit id="7126b83ecb05ac49ee0d9a4bfd7fa2c9443a5db6" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to extract e's evaluation, if e is not trivial.</source>
          <target state="translated">建立一个临时变量来提取e的评价,如果e不是琐碎的。</target>
        </trans-unit>
        <trans-unit id="5f0947173a3022e64a66ace8a16da7bd0953de0d" translate="yes" xml:space="preserve">
          <source>Build opAssign for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;struct&lt;/code&gt; 构建opAssign 。</target>
        </trans-unit>
        <trans-unit id="bd267126bb39bb406bc3a0c8c87a8165b825fa2e" translate="yes" xml:space="preserve">
          <source>Build opEquals for struct. const bool opEquals(const S s) { ... }</source>
          <target state="translated">const bool opEquals(const S s){...}</target>
        </trans-unit>
        <trans-unit id="6dd999e7845d7581c295f9165da47448ffe76f29" translate="yes" xml:space="preserve">
          <source>Build scoped variables and reference-counted types.</source>
          <target state="translated">建立范围变量和引用计数类型。</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="e777aa2ee0a1277f1927115dd56047ae99acaf63" translate="yes" xml:space="preserve">
          <source>Building Blocks</source>
          <target state="translated">构建模块</target>
        </trans-unit>
        <trans-unit id="3f334616286956fcb816046552d7f9bf1acd6341" translate="yes" xml:space="preserve">
          <source>Building block functions, they translate to a single x87 instruction.</source>
          <target state="translated">构件函数,它们转化为一条x87指令。</target>
        </trans-unit>
        <trans-unit id="5d7f3504504044d481b2cb93792c53ee903721c6" translate="yes" xml:space="preserve">
          <source>Building blocks</source>
          <target state="translated">构建模块</target>
        </trans-unit>
        <trans-unit id="39c609d88be88f825074ec54ab9e12948dadee89" translate="yes" xml:space="preserve">
          <source>Building contract support into the language makes for:</source>
          <target state="translated">在语言中建立合同支持,使。</target>
        </trans-unit>
        <trans-unit id="e5d9a44c338285ef0b2cf2cbe5abd6d13da4bd15" translate="yes" xml:space="preserve">
          <source>Builds a &lt;code&gt;Trie&lt;/code&gt; with typically optimal speed-size trade-off and wraps it into a delegate of the following type: &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt;.</source>
          <target state="translated">构建通常具有最佳速度大小权衡的 &lt;code&gt;Trie&lt;/code&gt; ，并将其包装为以下类型的 &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt; ：bool Representative（dchar ch）。</target>
        </trans-unit>
        <trans-unit id="0ddd9b5faf4e195f0b71766badf13e8513590fa7" translate="yes" xml:space="preserve">
          <source>Builds an index of the top elements of a range.</source>
          <target state="translated">建立一个范围内顶级元素的索引。</target>
        </trans-unit>
        <trans-unit id="8ac6cb76b75c220d2577581173ee0a6d992a81d1" translate="yes" xml:space="preserve">
          <source>Builds an object. Usually this is invoked indirectly by using the &lt;a href=&quot;#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">建立一个对象。通常，这是通过使用&lt;a href=&quot;#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;函数间接调用的。</target>
        </trans-unit>
        <trans-unit id="12e943a67bf614d76638933b655f13c408534085" translate="yes" xml:space="preserve">
          <source>Built-in mathematical intrinsics.</source>
          <target state="translated">内置数学本体。</target>
        </trans-unit>
        <trans-unit id="393ada6b17ede7fe1acbc7b82bec2f4e8c1c04b5" translate="yes" xml:space="preserve">
          <source>Built-in postfix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to lambda invocations as follows: &lt;code&gt;expr++&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt;, and &lt;code&gt;expr--&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt;. Therefore, the result of postfix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is an rvalue just before the side effect has been effected.</source>
          <target state="translated">内置postfix一元表达式 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的评估方式如下：将它们降低（重写）为lambda调用： &lt;code&gt;expr++&lt;/code&gt; 变为 &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt; ，而 &lt;code&gt;expr--&lt;/code&gt; 变为 &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt; 。因此，后缀 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的结果是在产生副作用之前的右值。</target>
        </trans-unit>
        <trans-unit id="140a63c50a697c2475ba756ea1b637cf7b49226e" translate="yes" xml:space="preserve">
          <source>Built-in prefix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to assignments as follows: &lt;code&gt;++expr&lt;/code&gt; becomes &lt;code&gt;((expr) += 1)&lt;/code&gt;, and &lt;code&gt;--expr&lt;/code&gt; becomes &lt;code&gt;((expr) -= 1)&lt;/code&gt;. Therefore, the result of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is the lvalue after the side effect has been effected.</source>
          <target state="translated">内置前缀一元表达式 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 被评价为，如果降低（重写）到分配如下： &lt;code&gt;++expr&lt;/code&gt; 变为 &lt;code&gt;((expr) += 1)&lt;/code&gt; ，和 &lt;code&gt;--expr&lt;/code&gt; 变为 &lt;code&gt;((expr) -= 1)&lt;/code&gt; 。因此，前缀 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的结果是副作用产生后的左值。</target>
        </trans-unit>
        <trans-unit id="f4ef630934a7f1267240a157c0264f348c4dadf3" translate="yes" xml:space="preserve">
          <source>Built-in threading (e.g. &lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt;&lt;code&gt;core.thread&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">内置线程（例如&lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt; &lt;code&gt;core.thread&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="738019c18e7d3c678f51b2d2bb9de596778335f1" translate="yes" xml:space="preserve">
          <source>Builtin SIMD intrinsics</source>
          <target state="translated">内建SIMD固有功能</target>
        </trans-unit>
        <trans-unit id="809be9a33e4a381b76b3f2392efbde90e7cac474" translate="yes" xml:space="preserve">
          <source>Builtin mathematical intrinsics</source>
          <target state="translated">内置的数学本质</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="aee13f098c3fbc98d67893709d2f60dddc7f25f1" translate="yes" xml:space="preserve">
          <source>But the precision of &lt;code&gt;StopWatch&lt;/code&gt; differs from system to system. It is impossible to for it to be the same from system to system since the precision of the system clock varies from system to system, and other system-dependent and situation-dependent stuff (such as the overhead of a context switch between threads) can also affect &lt;code&gt;StopWatch&lt;/code&gt;'s accuracy.</source>
          <target state="translated">但是 &lt;code&gt;StopWatch&lt;/code&gt; 的精度因系统而异。由于系统时钟的精度因系统而异，因此不可能在系统之间保持相同，并且其他与系统有关和与情况有关的内容（例如线程之间的上下文切换的开销）可以也影响 &lt;code&gt;StopWatch&lt;/code&gt; 的准确性。</target>
        </trans-unit>
        <trans-unit id="768690cb6415ff721efd279bcb993c49ad663947" translate="yes" xml:space="preserve">
          <source>But, if one context is indirectly accessible from other context, it is allowed.</source>
          <target state="translated">但是,如果一个上下文可以从其他上下文间接访问,是允许的。</target>
        </trans-unit>
        <trans-unit id="e45921646718dbb6e00896e143e95be14de95c04" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because those names can have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. All lower case package and module names will minimize problems moving projects between dissimilar file systems.</source>
          <target state="translated">按照惯例,包名和模块名都是小写的,这是因为这些名称与操作系统的目录和文件名有一一对应的关系,而许多文件系统不区分大小写。这是因为这些名称可以与操作系统的目录和文件名有一对一的对应关系,而许多文件系统是不区分大小写的。所有小写的包名和模块名可以最大限度地减少在不同文件系统之间移动项目的问题。</target>
        </trans-unit>
        <trans-unit id="2f986e628567a153d5373360f16e912e237bc63a" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;StoppingPolicy&lt;/code&gt; is set to &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;StoppingPolicy&lt;/code&gt; 设置为 &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c8a76e2827ccb54962a847a022109fb17e84070" translate="yes" xml:space="preserve">
          <source>By default a request has it's &quot;User-Agent&quot; field set to &lt;a href=&quot;#%20defaultUserAgent&quot;&gt;&lt;code&gt; defaultUserAgent&lt;/code&gt;&lt;/a&gt; even if &lt;code&gt;setUserAgent&lt;/code&gt; was never called. Pass an empty string to suppress the &quot;User-Agent&quot; field altogether.</source>
          <target state="translated">默认情况下，即使从未调用过 &lt;code&gt;setUserAgent&lt;/code&gt; ，请求的&amp;ldquo; User-Agent&amp;rdquo;字段仍设置为&lt;a href=&quot;#%20defaultUserAgent&quot;&gt; &lt;code&gt; defaultUserAgent&lt;/code&gt; &lt;/a&gt;。传递一个空字符串以完全禁止&amp;ldquo; User-Agent&amp;rdquo;字段。</target>
        </trans-unit>
        <trans-unit id="478b0d271a29c1d5ae05535cd04bb959cef13353" translate="yes" xml:space="preserve">
          <source>By default an &lt;code&gt;Error&lt;/code&gt; will be thrown.</source>
          <target state="translated">默认情况下，将引发 &lt;code&gt;Error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6de89d666cfcbf1e2d91df4f90cb3d04defa9a2" translate="yes" xml:space="preserve">
          <source>By default four &lt;code&gt;Logger&lt;/code&gt; implementations are given. The &lt;code&gt;FileLogger&lt;/code&gt; logs data to files. It can also be used to log to &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; as these devices are files as well. A &lt;code&gt;Logger&lt;/code&gt; that logs to &lt;code&gt;stdout&lt;/code&gt; can therefore be created by &lt;code&gt;new FileLogger(stdout)&lt;/code&gt;. The &lt;code&gt;MultiLogger&lt;/code&gt; is basically an associative array of &lt;code&gt;string&lt;/code&gt;s to &lt;code&gt;Logger&lt;/code&gt;. It propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;ArrayLogger&lt;/code&gt; contains an array of &lt;code&gt;Logger&lt;/code&gt; and also propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;NullLogger&lt;/code&gt; does not do anything. It will never log a message and will never throw on a log call with &lt;code&gt;LogLevel&lt;/code&gt;&lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">默认情况下，给出了四个 &lt;code&gt;Logger&lt;/code&gt; 实现。该 &lt;code&gt;FileLogger&lt;/code&gt; 记录的数据文件。由于这些设备也是文件，因此它也可以用于登录到 &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 。甲 &lt;code&gt;Logger&lt;/code&gt; 即日志 &lt;code&gt;stdout&lt;/code&gt; ，因此可以通过创建 &lt;code&gt;new FileLogger(stdout)&lt;/code&gt; 。所述 &lt;code&gt;MultiLogger&lt;/code&gt; 基本上是一个关联数组 &lt;code&gt;string&lt;/code&gt; s到 &lt;code&gt;Logger&lt;/code&gt; 。它将日志调用传播到其存储的 &lt;code&gt;Logger&lt;/code&gt; 。所述 &lt;code&gt;ArrayLogger&lt;/code&gt; 包含的阵列 &lt;code&gt;Logger&lt;/code&gt; ，并且还传播日志调用到其存储的 &lt;code&gt;Logger&lt;/code&gt; 。的 &lt;code&gt;NullLogger&lt;/code&gt; 不执行任何操作。它永远不会记录消息，也永远不会引发 &lt;code&gt;LogLevel&lt;/code&gt; &lt;code&gt;error&lt;/code&gt; 的日志调用。</target>
        </trans-unit>
        <trans-unit id="4ef4ca6979d9539ab9bd7cee842dec5c1148639b" translate="yes" xml:space="preserve">
          <source>By default it is conservatively assumed that allocated memory may be &lt;code&gt;cast&lt;/code&gt; to &lt;code&gt;shared&lt;/code&gt;, passed across threads, and deallocated in a different thread than the one that allocated it. If that's not the case, there are two options. First, &lt;code&gt;immutableShared&lt;/code&gt; means the memory is allocated for &lt;code&gt;immutable&lt;/code&gt; data and will be deallocated in the same thread it was allocated in. Second, &lt;code&gt;threadLocal&lt;/code&gt; means the memory is not to be shared across threads at all. The two flags cannot be simultaneously present.</source>
          <target state="translated">默认情况下，保守地假设分配的内存可以 &lt;code&gt;cast&lt;/code&gt; 为 &lt;code&gt;shared&lt;/code&gt; ，跨线程传递，并在与分配内存的线程不同的线程中释放。如果不是这种情况，则有两个选择。首先， &lt;code&gt;immutableShared&lt;/code&gt; 表示为 &lt;code&gt;immutable&lt;/code&gt; 数据分配了内存，并将在分配该内存的同一线程中将其释放。其次， &lt;code&gt;threadLocal&lt;/code&gt; 表示根本不跨线程共享内存。这两个标志不能同时出现。</target>
        </trans-unit>
        <trans-unit id="6f5b3a15a485cfab1e5a75e1fa6e376cde7fb92a" translate="yes" xml:space="preserve">
          <source>By default options are case-insensitive. You can change that behavior by passing &lt;code&gt;getopt&lt;/code&gt; the &lt;code&gt;caseSensitive&lt;/code&gt; directive like this:</source>
          <target state="translated">默认情况下，选项不区分大小写。你可以通过改变这种行为 &lt;code&gt;getopt&lt;/code&gt; 的 &lt;code&gt;caseSensitive&lt;/code&gt; 指令是这样的：</target>
        </trans-unit>
        <trans-unit id="dbec3e9c45747840b24455eb80ba1df0a750e9ae" translate="yes" xml:space="preserve">
          <source>By default the garbage collector uses all available CPU cores to mark the heap.</source>
          <target state="translated">默认情况下,垃圾收集器使用所有可用的CPU核来标记堆。</target>
        </trans-unit>
        <trans-unit id="b8fa023c2d92a0d81832e9bd89d175d5927659d9" translate="yes" xml:space="preserve">
          <source>By default, GC options can only be passed on the command line of the program to run, e.g.</source>
          <target state="translated">默认情况下,GC选项只能在程序运行的命令行中传递,如</target>
        </trans-unit>
        <trans-unit id="8b24a9b44aee4758b90d689774f561a91ccfd9f7" translate="yes" xml:space="preserve">
          <source>By default, a string literal is typed as a dynamic array, but the element count is known at compile time. So all string literals can be implicitly converted to static array types.</source>
          <target state="translated">默认情况下,字符串文字是作为动态数组类型的,但元素数在编译时是已知的。所以,所有的字符串文字都可以隐式转换为静态数组类型。</target>
        </trans-unit>
        <trans-unit id="8bdaa68e3c22ff7ff0194a0456f12cfccad4e7b3" translate="yes" xml:space="preserve">
          <source>By default, an array literal is typed as a dynamic array, but the element count is known at compile time. So all array literals can be implicitly converted to static array types.</source>
          <target state="translated">默认情况下,一个数组的文字是以动态数组的方式进行类型化的,但元素数在编译时是已知的。所以,所有的数组文字都可以隐式转换为静态数组类型。</target>
        </trans-unit>
        <trans-unit id="22091b5b2cb326fb7704d38d801e2ea343fe0a4b" translate="yes" xml:space="preserve">
          <source>By default, imports are</source>
          <target state="translated">默认情况下,进口是</target>
        </trans-unit>
        <trans-unit id="f143feea6dee31aa56bf9053dddf3e0e772b7f34" translate="yes" xml:space="preserve">
          <source>By default, non-immutable global declarations reside in thread local storage. When a global variable is marked with the &lt;code&gt;__gshared&lt;/code&gt; attribute, its value is shared across all threads.</source>
          <target state="translated">默认情况下，不可更改的全局声明驻留在线程本地存储中。当使用 &lt;code&gt;__gshared&lt;/code&gt; 属性标记全局变量时，其值将在所有线程之间共享。</target>
        </trans-unit>
        <trans-unit id="079ae70c5ecf861c3729c19e224c7956b1bb4ed1" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;#execute&quot;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt; functions will capture child processes' both stdout and stderr. This can be undesirable if the standard output is to be processed or otherwise used by the invoking program, as &lt;code&gt;execute&lt;/code&gt;'s result would then contain a mix of output and warning/error messages.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;#execute&quot;&gt; &lt;code&gt;execute&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt;函数将捕获子进程的stdout和stderr。如果要处理标准输出或调用程序以其他方式使用标准输出，则这可能是不希望的，因为 &lt;code&gt;execute&lt;/code&gt; 的结果将包含输出和警告/错误消息的混合。</target>
        </trans-unit>
        <trans-unit id="5c5dc33ccdd6fb02e11d57deb9c037003d388703" translate="yes" xml:space="preserve">
          <source>By default, the above will print:</source>
          <target state="translated">默认情况下,上述内容会被打印出来。</target>
        </trans-unit>
        <trans-unit id="2a431b7902a6f8a61040ea86e57ea9fd88c07b45" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the environment of the parent process, along with any additional variables specified in the &lt;code&gt;env&lt;/code&gt; parameter. If the same variable exists in both the parent's environment and in &lt;code&gt;env&lt;/code&gt;, the latter takes precedence.</source>
          <target state="translated">默认情况下，子进程会继承父进程的环境以及 &lt;code&gt;env&lt;/code&gt; 参数中指定的任何其他变量。如果在父级环境和 &lt;code&gt;env&lt;/code&gt; 中都存在相同的变量，则后者优先。</target>
        </trans-unit>
        <trans-unit id="00f97c90e4779d49bd0154dcbe3ccd270b7c1a5c" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the parent's environment, and any environment variables passed to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; will be added to it. If this flag is set, the only variables in the child process' environment will be those given to spawnProcess.</source>
          <target state="translated">默认情况下，子进程会继承父进程的环境，并且传递给&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; 的&lt;/a&gt;所有环境变量都将添加到其中。如果设置了此标志，则子进程环境中唯一的变量将是赋予spawnProcess的变量。</target>
        </trans-unit>
        <trans-unit id="164f65e6c4e1ffea6984f3be9b15c6fd4fcd5bd7" translate="yes" xml:space="preserve">
          <source>By default, the return type is time_t (which is normally an alias for int on 32-bit systems and long on 64-bit systems), but if a different size is required than either int or long can be passed as a template argument to get the desired size.</source>
          <target state="translated">默认情况下,返回类型是time_t(通常在32位系统上是int的别名,在64位系统上是long的别名),但如果需要不同的大小,可以将int或long作为模板参数传递,以获得所需的大小。</target>
        </trans-unit>
        <trans-unit id="887970dcbfc9d8811c8813f736813ed286b7d258" translate="yes" xml:space="preserve">
          <source>By default, the rounding mode is roundToNearest and all hardware exceptions are disabled. For most applications, debugging is easier if the</source>
          <target state="translated">默认情况下,四舍五入模式是roundToNearest,所有硬件异常都被禁用。对于大多数应用程序来说,如果在应用程序中使用</target>
        </trans-unit>
        <trans-unit id="6e33332413c374faf23d6382e0a46b9fcaf1aadb" translate="yes" xml:space="preserve">
          <source>By definition, empty ranges are matched fully and if &lt;code&gt;needles&lt;/code&gt; contains an empty range, &lt;code&gt;skipOver&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">根据定义，空范围将完全匹配，并且如果 &lt;code&gt;needles&lt;/code&gt; 包含空范围，则 &lt;code&gt;skipOver&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10ce83358e38997bfd068876bacbbbb4077fd36b" translate="yes" xml:space="preserve">
          <source>By definition, if a pre contract fails, then the function received bad parameters. If a post contract fails, then there is a bug in the function. In either case, an &lt;code&gt;assert&lt;/code&gt; statement within the corresponding &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; block will throw an &lt;code&gt;AssertError&lt;/code&gt;.</source>
          <target state="translated">根据定义，如果预合同失败，则该函数接收到错误的参数。如果后期合同失败，则该函数中存在错误。无论哪种情况，相应 &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;out&lt;/code&gt; 块中的 &lt;code&gt;assert&lt;/code&gt; 语句都将引发 &lt;code&gt;AssertError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb96c2ff58da640b614e1d83a03d1ae961343b00" translate="yes" xml:space="preserve">
          <source>By fixing &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789&lt;/a&gt; opEquals is changed to be never implicitly generated. Now, struct objects comparison s1 == s2 is translated to: s1.tupleof == s2.tupleof to calculate structural equality. See EqualExp.op_overload.</source>
          <target state="translated">通过修复&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789，opEquals&lt;/a&gt;更改为从不隐式生成。现在，将结构对象比较s1 == s2转换为：s1.tupleof == s2.tupleof以计算结构相等性。请参阅EqualExp.op_overload。</target>
        </trans-unit>
        <trans-unit id="aac8d772d9fb45f1ebe981cf3bff581d81f0a9a1" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;std_utf#byUTF&quot;&gt;&lt;code&gt;std.utf.byUTF&lt;/code&gt;&lt;/a&gt; and its aliases, GC allocations via auto-decoding and thrown exceptions can be avoided, making &lt;code&gt;icmp&lt;/code&gt;&lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt;.</source>
          <target state="translated">通过使用&lt;a href=&quot;std_utf#byUTF&quot;&gt; &lt;code&gt;std.utf.byUTF&lt;/code&gt; &lt;/a&gt;及其别名，可以避免通过自动解码和引发异常来进行GC分配，从而使 &lt;code&gt;icmp&lt;/code&gt; &lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc291c2891b81ab141f345fa0230adb20fd10cd9" translate="yes" xml:space="preserve">
          <source>Byte order endianness.</source>
          <target state="translated">字节顺序endianness。</target>
        </trans-unit>
        <trans-unit id="1eb54b97f13d87edcd6a934d982b6f81fb1b387f" translate="yes" xml:space="preserve">
          <source>Byte order, least significant first</source>
          <target state="translated">字节顺序,最不重要的第一个</target>
        </trans-unit>
        <trans-unit id="b59f4e1ab4662646945739f875a2dc8274ccd34b" translate="yes" xml:space="preserve">
          <source>Byte order, most significant first</source>
          <target state="translated">字节顺序,最重要的第一个</target>
        </trans-unit>
        <trans-unit id="0c1f86b6eef786b75f48b5164472c5f379f29825" translate="yes" xml:space="preserve">
          <source>Byte value in hexadecimal, where</source>
          <target state="translated">十六进制的字节值,其中</target>
        </trans-unit>
        <trans-unit id="f4e5cf625ea1bf16e64b237498429dc72e94863d" translate="yes" xml:space="preserve">
          <source>Byte value in octal.</source>
          <target state="translated">字节值以八进制表示。</target>
        </trans-unit>
        <trans-unit id="a58fed109fdbc425c9e3e299c4f472aa1e81b9e2" translate="yes" xml:space="preserve">
          <source>Bytes (not items) to be allocated for the free list. Memory will be allocated during construction and deallocated in the destructor.</source>
          <target state="translated">要分配给自由列表的字节(不是项目)。内存将在构造过程中分配,并在反构造器中重新分配。</target>
        </trans-unit>
        <trans-unit id="b2e625cfca365b6f5ed6d88821a2c881a6679253" translate="yes" xml:space="preserve">
          <source>Bytes to allocate</source>
          <target state="translated">要分配的字节数</target>
        </trans-unit>
        <trans-unit id="2eadc64c1cdbc5d6ca752a0b38f5f0a02d05c4b1" translate="yes" xml:space="preserve">
          <source>Bytes to allocate using &lt;code&gt;ParentAllocator&lt;/code&gt;. This constructor is only defined If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;parent.allocate(n)&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the region will be initialized as empty (correctly initialized but unable to allocate).</source>
          <target state="translated">使用 &lt;code&gt;ParentAllocator&lt;/code&gt; 分配的字节。仅当 &lt;code&gt;ParentAllocator&lt;/code&gt; 与&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt;不同时才定义此构造函数。如果 &lt;code&gt;parent.allocate(n)&lt;/code&gt; 返回 &lt;code&gt;null&lt;/code&gt; ，则该区域将被初始化为空（正确初始化但无法分配）。</target>
        </trans-unit>
        <trans-unit id="d3fc47eb5e867c1a90c1c6140022201511e39c13" translate="yes" xml:space="preserve">
          <source>Byzantine Musical Symbols</source>
          <target state="translated">拜占庭音乐符号</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="91ab2886a8945715f467ad2616dd5309295ba114" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">&amp;ccedil; &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="922a6aa3cb89e34ea72fe9d27effc2df259df392" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;create&lt;/code&gt;</source>
          <target state="translated">C &lt;code&gt;create&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9652018eda95d6aa3dab8e093571b39cf52c2264" translate="yes" xml:space="preserve">
          <source>C ABI</source>
          <target state="translated">C ABI</target>
        </trans-unit>
        <trans-unit id="f824a58327e609cd9fdba23fe1a3c84c364898ea" translate="yes" xml:space="preserve">
          <source>C code can correspondingly call D functions, if the D functions use an attribute that is compatible with the C compiler, most likely the extern (C):</source>
          <target state="translated">C代码可以相应地调用D函数,如果D函数使用了与C编译器兼容的属性,很可能是extern(C)。</target>
        </trans-unit>
        <trans-unit id="0ffb7f8837c1a11eeb25850dd4e1e4ef9b573509" translate="yes" xml:space="preserve">
          <source>C code explicitly manages memory with calls to &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc()&lt;/a&gt; and &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free()&lt;/a&gt;. D allocates memory using the D garbage collector, so no explicit frees are necessary.</source>
          <target state="translated">C代码通过调用&lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc（）&lt;/a&gt;和&lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free（）&lt;/a&gt;显式管理内存。D使用D垃圾回收器分配内存，因此不需要显式的释放。</target>
        </trans-unit>
        <trans-unit id="d221b852c9ebec0058ed069c0351edaaeb33622d" translate="yes" xml:space="preserve">
          <source>C code often adjusts the alignment and packing of struct members with a command line switch or with various implementation specific #pragmas. D supports explicit alignment attributes that correspond to the C compiler's rules. Check what alignment the C code is using, and explicitly set it for the D struct declaration.</source>
          <target state="translated">C代码经常通过命令行开关或各种特定的实现#语法来调整结构成员的对齐和打包。D支持显式的对齐属性,对应C编译器的规则。检查C代码使用的是什么对齐方式,并对D结构声明进行显式设置。</target>
        </trans-unit>
        <trans-unit id="ad0081e0fe0dd4d8c8faa110d448e18b099251c6" translate="yes" xml:space="preserve">
          <source>C function calling conventions are specified by:</source>
          <target state="translated">C函数的调用惯例由以下规定。</target>
        </trans-unit>
        <trans-unit id="7bbdeb583f7af40df326e5ef45b5341310bfa3a8" translate="yes" xml:space="preserve">
          <source>C functions can be called directly from D. There is no need for wrapper functions, argument swizzling, and the C functions do not need to be put into a separate DLL.</source>
          <target state="translated">C函数可以直接从D中调用,不需要封装函数、参数swizzling,也不需要将C函数放入单独的DLL中。</target>
        </trans-unit>
        <trans-unit id="391732c6d45f595037ed6d3acf61093990d2af4d" translate="yes" xml:space="preserve">
          <source>C functions cannot be overloaded with another C function with the same name.</source>
          <target state="translated">C函数不能与另一个同名的C函数重载。</target>
        </trans-unit>
        <trans-unit id="5f547f273af63b8119db89b56d4a8680c878d370" translate="yes" xml:space="preserve">
          <source>C globals can be accessed directly from D. C globals have the C naming convention, and so must be in an &lt;code&gt;extern (C)&lt;/code&gt; block. Use the &lt;code&gt;extern&lt;/code&gt; storage class to indicate that the global is allocated in the C code, not the D code. C globals default to being in global, not thread local, storage. To reference global storage from D, use the &lt;code&gt;__gshared&lt;/code&gt; storage class.</source>
          <target state="translated">可以从D直接访问C全局变量。C全局变量具有C命名约定，因此必须位于 &lt;code&gt;extern (C)&lt;/code&gt; 块中。使用 &lt;code&gt;extern&lt;/code&gt; 存储类指示全局变量是在C代码而不是D代码中分配的。C全局变量默认为全局存储，而不是线程本地存储。要从D引用全局存储，请使用 &lt;code&gt;__gshared&lt;/code&gt; 存储类。</target>
        </trans-unit>
        <trans-unit id="088f42af395914ff1b11b211001ff8dc3bfb47de" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.initialize, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.initialize的C接口,返回1/0而不是bool。</target>
        </trans-unit>
        <trans-unit id="dc4b969769a12fb03185e79820cbdb1188eba5a6" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.loadLibrary</source>
          <target state="translated">Runtime.loadLibrary的C接口</target>
        </trans-unit>
        <trans-unit id="1ba4ae2523a2983e2479e8220f1eed45cabbda41" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.terminate, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.terminate的C接口,返回1/0而不是bool。</target>
        </trans-unit>
        <trans-unit id="8ebac48238568ab95c4c5ad69ed5cd780269c53c" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.unloadLibrary, returns 1/0 instead of bool</source>
          <target state="translated">Runtime.unloadLibrary的C接口,返回1/0而不是bool。</target>
        </trans-unit>
        <trans-unit id="86cf735b5a9e30aaa5f0fee060cea7d39ebc4f60" translate="yes" xml:space="preserve">
          <source>C library routines. See callclib().</source>
          <target state="translated">C库例程。参见 callclib()。</target>
        </trans-unit>
        <trans-unit id="c1ff5ead3c46826c14b71159d580aef25ffbf060" translate="yes" xml:space="preserve">
          <source>C name mangling is done by adding a prefix on some platforms.</source>
          <target state="translated">在一些平台上,C名的混搭是通过添加前缀来实现的。</target>
        </trans-unit>
        <trans-unit id="126f7b78af09df06aa9df51a74fef4005eae1de9" translate="yes" xml:space="preserve">
          <source>C style variadic function</source>
          <target state="translated">C式变函数</target>
        </trans-unit>
        <trans-unit id="dd58d1bb166ddedbf2d0eda882e81a02524b0fbc" translate="yes" xml:space="preserve">
          <source>C#'s &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;embedded XML&lt;/a&gt;</source>
          <target state="translated">C＃的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;嵌入式XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd0548c5e650e5d6686abc5b2a04b9371833fa90" translate="yes" xml:space="preserve">
          <source>C's printf() and Strings</source>
          <target state="translated">C语言中的printf()和Strings</target>
        </trans-unit>
        <trans-unit id="4f540b0aaef1641b1d80a5208b7c055e606bf72a" translate="yes" xml:space="preserve">
          <source>C++ Interfaces</source>
          <target state="translated">C++接口</target>
        </trans-unit>
        <trans-unit id="f1642c1a4e4dce54c68aa20addb027e83adf0715" translate="yes" xml:space="preserve">
          <source>C++ Namespaces</source>
          <target state="translated">C++命名空间</target>
        </trans-unit>
        <trans-unit id="c5cb41022921444e105840eeb5b0879ab0ff1d75" translate="yes" xml:space="preserve">
          <source>C++ Support</source>
          <target state="translated">C++支持</target>
        </trans-unit>
        <trans-unit id="f9f27585ae5da3fc2a761861b44ded6adf3015ec" translate="yes" xml:space="preserve">
          <source>C++ Templates</source>
          <target state="translated">C++模板</target>
        </trans-unit>
        <trans-unit id="7e28b0c0a074b69119fdaf750d5061c6c3eed943" translate="yes" xml:space="preserve">
          <source>C++ allows a struct to inherit from a base struct. This is done in D using &lt;code&gt;alias this&lt;/code&gt;:</source>
          <target state="translated">C ++允许结构从基本结构继承。这是使用 &lt;code&gt;alias this&lt;/code&gt; 在D中完成的：</target>
        </trans-unit>
        <trans-unit id="270c92d90f5419eb56fc78a11ccc1e3fb6e75988" translate="yes" xml:space="preserve">
          <source>C++ and D follow different rules for function overloading. D source code, even when calling &lt;code&gt;extern (C++)&lt;/code&gt; functions, will still follow D overloading rules.</source>
          <target state="translated">C ++和D遵循不同的函数重载规则。即使调用 &lt;code&gt;extern (C++)&lt;/code&gt; 函数，D源代码仍将遵循D重载规则。</target>
        </trans-unit>
        <trans-unit id="b9777d8f776f92bf25e9cab083b49833d4a402d3" translate="yes" xml:space="preserve">
          <source>C++ class</source>
          <target state="translated">C++类</target>
        </trans-unit>
        <trans-unit id="bc6ef19080a44be47740e7c8ef1fb2da8b514001" translate="yes" xml:space="preserve">
          <source>C++ classes can be declared in D by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; declarations. &lt;code&gt;extern (C++)&lt;/code&gt; interfaces have the same restrictions as D interfaces, which means that Multiple Inheritance is supported to the extent that only one base class can have member fields.</source>
          <target state="translated">可以通过在 &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;interface&lt;/code&gt; 声明中使用 &lt;code&gt;extern (C++)&lt;/code&gt; 属性在D中声明C ++类。 &lt;code&gt;extern (C++)&lt;/code&gt; 接口具有与D接口相同的限制，这意味着在仅一个基类可以具有成员字段的程度上，支持多重继承。</target>
        </trans-unit>
        <trans-unit id="2696fbb29a2404060229a5c0ef4dcf0d930ebf5a" translate="yes" xml:space="preserve">
          <source>C++ code explicitly manages memory with calls to &lt;code&gt;::operator new()&lt;/code&gt; and &lt;code&gt;::operator delete()&lt;/code&gt;. D's &lt;code&gt;new&lt;/code&gt; operator allocates memory using the D garbage collector, so no explicit delete is necessary. D's &lt;code&gt;new&lt;/code&gt; operator is not compatible with C++'s &lt;code&gt;::operator new&lt;/code&gt; and &lt;code&gt;::operator delete&lt;/code&gt;. Attempting to allocate memory with D's &lt;code&gt;new&lt;/code&gt; and deallocate with C++ &lt;code&gt;::operator delete&lt;/code&gt; will result in miserable failure.</source>
          <target state="translated">C ++代码通过调用 &lt;code&gt;::operator new()&lt;/code&gt; 和 &lt;code&gt;::operator delete()&lt;/code&gt; 显式管理内存。D的 &lt;code&gt;new&lt;/code&gt; 运算符使用D垃圾收集器分配内存，因此不需要显式删除。D的 &lt;code&gt;new&lt;/code&gt; 运算符与C ++的 &lt;code&gt;::operator new&lt;/code&gt; 和 &lt;code&gt;::operator delete&lt;/code&gt; 不兼容。尝试使用D的 &lt;code&gt;new&lt;/code&gt; 分配内存，并使用C ++ &lt;code&gt;::operator delete&lt;/code&gt; 取消分配内存将导致惨痛的失败。</target>
        </trans-unit>
        <trans-unit id="bc28c8a3178ea35aefa2bc7cad45f485c5c7f436" translate="yes" xml:space="preserve">
          <source>C++ constructors, copy constructors, move constructors and destructors cannot be called directly in D code, and D constructors, postblit operators and destructors cannot be directly exported to C++ code. Interoperation of types with these special operators is possible by either 1) disabling the operator in the client language and only using it in the host language, or 2) faithfully reimplementing the operator in the client language. With the latter approach, care needs to be taken to ensure observable semantics remain the same with both implementations, which can be difficult, or in some edge cases impossible, due to differences in how the operators work in the two languages. For example, in D all objects are movable and there is no move constructor.</source>
          <target state="translated">在D代码中不能直接调用C++构造函数、复制构造函数、移动构造函数和破坏函数,D构造函数、后置运算符和破坏函数也不能直接导出到C++代码中。类型与这些特殊运算符的互操作可以通过以下两种方式实现:1)在客户端语言中禁用该运算符,只在宿主语言中使用;2)在客户端语言中忠实地重新实现该运算符。采用后一种方法,需要注意确保两种实现的可观察语义保持一致,由于两种语言中操作符的工作方式不同,这可能是困难的,或者在某些边缘情况下是不可能的。例如,在D语言中,所有对象都是可移动的,而且没有移动构造函数。</target>
        </trans-unit>
        <trans-unit id="7201ae364cc48822a82b73b893189a5dd94aef18" translate="yes" xml:space="preserve">
          <source>C++ function and type templates can be bound by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on a function or type template declaration.</source>
          <target state="translated">可以通过在函数或类型模板声明上使用 &lt;code&gt;extern (C++)&lt;/code&gt; 属性来绑定C ++函数和类型模板。</target>
        </trans-unit>
        <trans-unit id="b5593ddf6c58f1012fa7ffeb46813794152a771a" translate="yes" xml:space="preserve">
          <source>C++ global functions, including those in namespaces, can be declared and called in D, or defined in D and called in C++.</source>
          <target state="translated">C++全局函数,包括命名空间中的函数,可以在D中声明和调用,也可以在D中定义,在C++中调用。</target>
        </trans-unit>
        <trans-unit id="4e9e4356221d1ee2aa897fff7328f9ee52314134" translate="yes" xml:space="preserve">
          <source>C++ interfaces are interfaces declared with C++ linkage:</source>
          <target state="translated">C++接口是用C++连接方式声明的接口。</target>
        </trans-unit>
        <trans-unit id="5099e4c841655b922a765e68cbf8aefc57d5356e" translate="yes" xml:space="preserve">
          <source>C++ namespace this symbol belongs to</source>
          <target state="translated">这个符号所属的C++命名空间</target>
        </trans-unit>
        <trans-unit id="c6f5200183cdf7ce197fbb3bc50824c16c47152a" translate="yes" xml:space="preserve">
          <source>C++ reference:</source>
          <target state="translated">C++参考。</target>
        </trans-unit>
        <trans-unit id="912b136567cd7cbd9fc8f323d5606bbe39d07750" translate="yes" xml:space="preserve">
          <source>C++ symbols that reside in namespaces can be accessed from D. A &lt;a href=&quot;attribute#namespace&quot;&gt;namespace&lt;/a&gt; can be added to the &lt;code&gt;extern (C++)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;LinkageAttribute&lt;/a&gt;:</source>
          <target state="translated">可以从D访问位于名称空间中的C ++符号。可以将&lt;a href=&quot;attribute#namespace&quot;&gt;名称空间&lt;/a&gt;添加到 &lt;code&gt;extern (C++)&lt;/code&gt; &lt;a href=&quot;attribute#linkage&quot;&gt;LinkageAttribute中&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="2f98b3c489784aabeb7da68a1d1411495ec51290" translate="yes" xml:space="preserve">
          <source>C++'s make_shared</source>
          <target state="translated">C++的make_shared</target>
        </trans-unit>
        <trans-unit id="588f44e70bf472a1f45f7efcfa562168c8457c0a" translate="yes" xml:space="preserve">
          <source>C-style Variadic Functions</source>
          <target state="translated">C-style Variadic Functions</target>
        </trans-unit>
        <trans-unit id="d5ccb24bc3ad9fc7c10cfe2824e9cb190ac91f9d" translate="yes" xml:space="preserve">
          <source>C-style array, function pointer and pointer to array declarations are deprecated:</source>
          <target state="translated">C-风格的数组、函数指针和数组指针的声明已被废弃。</target>
        </trans-unit>
        <trans-unit id="f0848a8145c311481df53130b777fe467332d312" translate="yes" xml:space="preserve">
          <source>C-style octal integer notation was deemed too easy to mix up with decimal notation; it is only fully supported in string literals. D still supports octal integer literals interpreted at compile time through the &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt;&lt;code&gt;std.conv.octal&lt;/code&gt;&lt;/a&gt; template, as in &lt;code&gt;octal!167&lt;/code&gt;.</source>
          <target state="translated">C风格的八进制整数表示法被认为太容易与十进制表示法混淆；它仅在字符串文字中完全受支持。D仍然支持在编译时通过&lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt; &lt;code&gt;std.conv.octal&lt;/code&gt; &lt;/a&gt;模板解释的八进制整数文字，如 &lt;code&gt;octal!167&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="9adf55a50113afd886edb1cbfcea7b8ecf56ed5e" translate="yes" xml:space="preserve">
          <source>C-style semantics on pointer arithmetic are strictly enforced. Pointer arithmetic is permitted only on pointers which point to static or dynamic array elements. Such pointers must point to an element of the array, or to the first element past the array. Pointer arithmetic is completely forbidden on pointers which are null, or which point to a non-array.</source>
          <target state="translated">指针运算的C式语义被严格执行。指针运算只允许在指向静态或动态数组元素的指针上进行。这样的指针必须指向数组中的一个元素,或者指向数组过去的第一个元素。指针算术完全禁止指向空或指向非数组的指针。</target>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="translated">C式变函数</target>
        </trans-unit>
        <trans-unit id="77ba44bb9e589c769fa658f005333eee147a4900" translate="yes" xml:space="preserve">
          <source>C-style variadic functions cannot be marked as &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">C风格的可变参数不能标记为 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ddb858f8a20b16ac93e15adcc78e42ffbd8db66" translate="yes" xml:space="preserve">
          <source>C-style variadic functions match the C calling convention for variadic functions, and is most useful for calling C library functions like &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">C风格的可变参数函数与可变参数函数的C调用约定匹配，并且对于调用诸如 &lt;code&gt;printf&lt;/code&gt; 之类的C库函数最有用。</target>
        </trans-unit>
        <trans-unit id="8818f4ee4a0e406f4fe10b1e03aebaf4d71f3819" translate="yes" xml:space="preserve">
          <source>C1 &lt;code&gt;next&lt;/code&gt;</source>
          <target state="translated">C1 &lt;code&gt;next&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30212c965112a877f52f60d83e8ff113ef1b3f96" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;path&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9089e6f07372bce6e832f5f650cb3e7c0c621e3b" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4aa0499528f63537a98f340c34d4972647df60e5" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;suffix&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;suffix&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c459d7b347295856b421ffb8792a1964353bfe70" translate="yes" xml:space="preserve">
          <source>C1[] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt;(C1, C2, C3, C4 = immutable(char))(C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null);</source>
          <target state="translated">C1 [] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt;（C1，C2，C3，C4 =不可变（字符））（C1 [] str，const（C2）[]从，const（C3）[]到，const（C4）[]修饰符= null） ;</target>
        </trans-unit>
        <trans-unit id="a0d01d3baedb5ae97bde5874c2012010c575e84c" translate="yes" xml:space="preserve">
          <source>C2 &lt;code&gt;empty&lt;/code&gt;</source>
          <target state="translated">C2 &lt;code&gt;empty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8e1804fe922cd90750831c2c298d54a222ba628" translate="yes" xml:space="preserve">
          <source>C2[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C2 [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b7d328ba78816f38f975bb5147f4c05534a9bc5" translate="yes" xml:space="preserve">
          <source>CAPI3REF</source>
          <target state="translated">CAPI3REF</target>
        </trans-unit>
        <trans-unit id="bd963590f78aa017d53387443be555aa971b1144" translate="yes" xml:space="preserve">
          <source>CData &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">CData &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afdd392374481b4db6ac2ce43fdc87d5888fe7e3" translate="yes" xml:space="preserve">
          <source>CDataException if the segment body is illegal (contains &quot;]]&amp;gt;&quot;)</source>
          <target state="translated">CDataException如果段主体是非法的（包含&amp;ldquo;]]&amp;gt;&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="3061e575e355c19788f22cb3d62aa0cd47f40e40" translate="yes" xml:space="preserve">
          <source>CData[] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;cdatas&quot;&gt;CData&lt;/strong&gt; [] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="92b00c2e72a02d322e30292a494b0f77de93d540" translate="yes" xml:space="preserve">
          <source>CJK Compatibility</source>
          <target state="translated">中日韩兼容性</target>
        </trans-unit>
        <trans-unit id="24dc7006e4bfb5dae3e8ea7f01d766f357b0514b" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Forms</source>
          <target state="translated">中日韩兼容表格</target>
        </trans-unit>
        <trans-unit id="28610435f9d6e37ccd13448891ef635456bc6798" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs</source>
          <target state="translated">中日韩的兼容性理念图</target>
        </trans-unit>
        <trans-unit id="3a3044d64bf35123af4c2034c39688d2f85c3b7d" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs Supplement</source>
          <target state="translated">中日韩兼容表意文字补充资料</target>
        </trans-unit>
        <trans-unit id="56398f3cc299fcadc8172ed7743fcc8d6604a2b2" translate="yes" xml:space="preserve">
          <source>CJK Radicals Supplement</source>
          <target state="translated">中日韩激进主义补充剂</target>
        </trans-unit>
        <trans-unit id="c80daba1e9c50935dee4c69ef20e42e31a63bfcb" translate="yes" xml:space="preserve">
          <source>CJK Strokes</source>
          <target state="translated">中日韩笔画</target>
        </trans-unit>
        <trans-unit id="41d774013768fc4cae9cda6ce11ff4062ab10d65" translate="yes" xml:space="preserve">
          <source>CJK Symbols and Punctuation</source>
          <target state="translated">中日韩的符号和标点符号</target>
        </trans-unit>
        <trans-unit id="a8e25b3246b6d0e0fa06fb72ba766979769141a7" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs</source>
          <target state="translated">中日韩统一表意文字</target>
        </trans-unit>
        <trans-unit id="6370cdf4d714b545f5b7bf4ee34e57e56e359487" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension A</source>
          <target state="translated">中日韩统一表意文字扩展A</target>
        </trans-unit>
        <trans-unit id="a1724e7543e72f713653f623821483898403f1d0" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension B</source>
          <target state="translated">中日韩统一表意文字扩展部分B</target>
        </trans-unit>
        <trans-unit id="71e4356045ae7c85afc88a13e5be97e037f502d4" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension C</source>
          <target state="translated">中日韩统一表意文字扩展C</target>
        </trans-unit>
        <trans-unit id="de4f53e7b0971e7c4fd9b6b5639b6d9d3d564380" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension D</source>
          <target state="translated">中日韩统一表意文字扩展D</target>
        </trans-unit>
        <trans-unit id="df31bd94e79946dcd6e346825f4e84b5f0358f50" translate="yes" xml:space="preserve">
          <source>CLI flag without leading &lt;code&gt;-&lt;/code&gt;, e.g. &lt;code&gt;color&lt;/code&gt;</source>
          <target state="translated">没有前导 &lt;code&gt;-&lt;/code&gt; 的 CLI标志，例如 &lt;code&gt;color&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d78b798fee78a64b81d6899e06efc15c1dccde51" translate="yes" xml:space="preserve">
          <source>COM Interfaces</source>
          <target state="translated">COM接口</target>
        </trans-unit>
        <trans-unit id="154721c66d149bb61466c03b8ff3861e25ef38c7" translate="yes" xml:space="preserve">
          <source>COM classes and C++ classes</source>
          <target state="translated">COM类和C++类</target>
        </trans-unit>
        <trans-unit id="ae337737f416d275254734defda66541f870f22e" translate="yes" xml:space="preserve">
          <source>COMPILER INTERFACE /////////////////////</source>
          <target state="translated">汇编器接口 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="0af12e3ea89b844b314d17c7e3f7bac655ebd0c7" translate="yes" xml:space="preserve">
          <source>CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt;;</source>
          <target state="translated">CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="95fe9c2b68a6150c2538241de478d073b3c01eb6" translate="yes" xml:space="preserve">
          <source>CPU architectures supported -mcpu=id</source>
          <target state="translated">支持的CPU架构 -mcpu=id</target>
        </trans-unit>
        <trans-unit id="73c7fc0f09e167cc17d6e2ae64cdb2bc100ca9d7" translate="yes" xml:space="preserve">
          <source>CPUs often support specialized vector types and vector operations (a.k.a.</source>
          <target state="translated">CPU通常支持专门的向量类型和向量运算(又称 &quot;向量运算&quot;)。</target>
        </trans-unit>
        <trans-unit id="bf887172139520e2ce3c00abdb93ee2e9fd86211" translate="yes" xml:space="preserve">
          <source>CRC32 of data</source>
          <target state="translated">数据的CRC32</target>
        </trans-unit>
        <trans-unit id="764a2bd592ab90f526cba7f18836f8fb323c69e5" translate="yes" xml:space="preserve">
          <source>CRC64-ECMA of data</source>
          <target state="translated">CRC64-ECMA的数据</target>
        </trans-unit>
        <trans-unit id="de219addfefcc2e27f49a3ca6fa5a51d3de19ec6" translate="yes" xml:space="preserve">
          <source>CRC64-ISO of data</source>
          <target state="translated">CRC64-数据的ISO</target>
        </trans-unit>
        <trans-unit id="91d96d88652e57b949051060aed04c0c7a55db68" translate="yes" xml:space="preserve">
          <source>CRCs are usually printed with the MSB first. When using &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt; the result will be in an unexpected order. Use &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt;'s optional order parameter to specify decreasing order for the correct result. The &lt;a href=&quot;#crcHexString&quot;&gt;&lt;code&gt;crcHexString&lt;/code&gt;&lt;/a&gt; alias can also be used for this purpose.</source>
          <target state="translated">CRC通常是首先用MSB打印的。当使用&lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; 时&lt;/a&gt;，结果将出现意外的顺序。使用&lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; &lt;/a&gt;的可选order参数为正确的结果指定降序。该&lt;a href=&quot;#crcHexString&quot;&gt; &lt;code&gt;crcHexString&lt;/code&gt; &lt;/a&gt;别名也可以用于此目的。</target>
        </trans-unit>
        <trans-unit id="20226dce447690b9ec8699b49af5230d49691790" translate="yes" xml:space="preserve">
          <source>CRL file</source>
          <target state="translated">CRL文件</target>
        </trans-unit>
        <trans-unit id="9d1c93dd97d25f4c239981585e218bded30a91de" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a402cf31f9cf0e6b5b8a55752e348488f03f726b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9864028d4f462263a4ffef0bfb1252c98316a14b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;csx&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;csx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d8934fa932e57010a67e3ca78ffd8b25af059e9" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6cb8e5d0c4fc4c6db7f22e70f099ed917c02dc9a" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ef70b18a1d95d31d7157c61d4106f2015fb5f903" translate="yes" xml:space="preserve">
          <source>CTFE</source>
          <target state="translated">CTFE</target>
        </trans-unit>
        <trans-unit id="f226c00a4d670c28c9ce96128a908ed75e3c4fc6" translate="yes" xml:space="preserve">
          <source>CTFE Sanity Checks</source>
          <target state="translated">CTFE安全检查</target>
        </trans-unit>
        <trans-unit id="bcdc8bcedfff54c513bf8524b5ea04b31a01d40f" translate="yes" xml:space="preserve">
          <source>CTFE is not supported.</source>
          <target state="translated">不支持CTFE。</target>
        </trans-unit>
        <trans-unit id="2e8b7f100028e56862c1d736efc547af30992b6b" translate="yes" xml:space="preserve">
          <source>CTFE is subject to the following restrictions:</source>
          <target state="translated">CTFE受以下限制:</target>
        </trans-unit>
        <trans-unit id="5cbcfb039635320e7ff7d8feb659fe88d90d6d53" translate="yes" xml:space="preserve">
          <source>CTFE-able expression, resolving to &lt;code&gt;TupleExp&lt;/code&gt; or &lt;code&gt;StringExp&lt;/code&gt;</source>
          <target state="translated">支持CTFE的表达式，解析为 &lt;code&gt;TupleExp&lt;/code&gt; 或 &lt;code&gt;StringExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da921efe49d919390e46ee7013dc94409e0427b9" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURL * &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt;（CURL * curl）;</target>
        </trans-unit>
        <trans-unit id="f3df3af8e49ed4cabb82ec3eb374069c299119bb" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt;();</source>
          <target state="translated">CURL * &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="6751502e2bc0440a5e6927ebe6c763c9fb33f615" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt;;</source>
          <target state="translated">CURL * &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="828fa48577f41dee0175a07d2bcd99aa7917b639" translate="yes" xml:space="preserve">
          <source>CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error instead of a memory allocation error if CURL_DOES_CONVERSIONS is defined</source>
          <target state="translated">如果定义了CURL_DOES_CONVERSIONS,CURLE_OUT_OF_MEMORY有时会显示一个转换错误,而不是内存分配错误。</target>
        </trans-unit>
        <trans-unit id="2ab51649023b66c808197a6d0ba638e7d65bf9da" translate="yes" xml:space="preserve">
          <source>CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt;(curl_httppost** httppost, curl_httppost** last_post, ...);</source>
          <target state="translated">CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt;（curl_httppost ** httppost，curl_httppost ** last_post，...）;</target>
        </trans-unit>
        <trans-unit id="ee42c010a41bbc2d374ffe159f6514f8ff046b0e" translate="yes" xml:space="preserve">
          <source>CURLINFO_RESPONSE_CODE is the new name for the option previously known as CURLINFO_HTTP_CODE</source>
          <target state="translated">CURLINFO_RESPONSE_CODE是以前称为CURLINFO_HTTP_CODE的选项的新名称。</target>
        </trans-unit>
        <trans-unit id="32ad7575f66b5734a63076c0cb3d75f3884da653" translate="yes" xml:space="preserve">
          <source>CURLM error code.</source>
          <target state="translated">CURLM错误代码。</target>
        </trans-unit>
        <trans-unit id="99dd99b527ed789fcfbdfc456b2eb941ef204be1" translate="yes" xml:space="preserve">
          <source>CURLM* &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt;();</source>
          <target state="translated">CURLM * &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="3b90f598cb268ee4dc09f1ac996362f90296018c" translate="yes" xml:space="preserve">
          <source>CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt;;</source>
          <target state="translated">CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1999612ad18366624e0d0b2cd56012c1afc025b3" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt;（CURLM * multi_handle，CURL * curl_handle）;</target>
        </trans-unit>
        <trans-unit id="22a1019ea56e4dab3fcad53491bac13d0d8af5fb" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t sockfd, void* sockp);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt;（CURLM * multi_handle，curl_socket_t sockfd，void * sockp）;</target>
        </trans-unit>
        <trans-unit id="25a2804bd3b7261884e99b1fc524c94a8f152120" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt;(CURLM* multi_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt;（CURLM * multi_handle）;</target>
        </trans-unit>
        <trans-unit id="0d7d7eae82011af95f4a6e15b19e86d79b7d077b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt;(CURLM* multi_handle, fd_set* read_fd_set, fd_set* write_fd_set, fd_set* exc_fd_set, int* max_fd);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt;（CURLM * multi_handle，fd_set * read_fd_set，fd_set * write_fd_set，fd_set * exc_fd_set，int * max_fd）;</target>
        </trans-unit>
        <trans-unit id="811b3bdcf0c9e88ad95fd7b9e1e9194bc510f1d4" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt;（CURLM * multi_handle，int * running_handles）;</target>
        </trans-unit>
        <trans-unit id="cdc21e6a79fac27e25ab2401a2231a5159d42fa2" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt;（CURLM * multi_handle，CURL * curl_handle）;</target>
        </trans-unit>
        <trans-unit id="b77796e4441642019f5f0ee725e2d2ccbaf79203" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt;(CURLM* multi_handle, CURLMoption option, ...);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt;（CURLM * multi_handle，CURLMoption选项，...）;</target>
        </trans-unit>
        <trans-unit id="a09fadf338e9129df789fdea317e027aaed23a5b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt;（CURLM * multi_handle，curl_socket_t s，int * running_handles）;</target>
        </trans-unit>
        <trans-unit id="ff40633804853059e167a117757dc66453ca66ad" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int ev_bitmask, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt;（CURLM * multi_handle，curl_socket_t s，int ev_bitmask，int * running_handles）;</target>
        </trans-unit>
        <trans-unit id="2466194fef4d1ee2ade6e8ccdeda99a667524258" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt;（CURLM * multi_handle，int * running_handles）;</target>
        </trans-unit>
        <trans-unit id="11ebb04cdf64624f9d24ec68ab137e1aca46350a" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt;(CURLM* multi_handle, c_long* milliseconds);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt;（CURLM * multi_handle，c_long *毫秒）;</target>
        </trans-unit>
        <trans-unit id="78c7684a9c1f8b1ac34050129574ece72e711bdd" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.</source>
          <target state="translated">CURLMcode类型,一般多错误代码。</target>
        </trans-unit>
        <trans-unit id="4dc759c2b4e3bdbdc1edda0576bc41603b22a66f" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.  tmp decl</source>
          <target state="translated">CURLMcode类型,一般多错误代码。 tmp decl</target>
        </trans-unit>
        <trans-unit id="8b52c35c36f45f74e7316bea0caa3ca7b9817c93" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code. &lt;em&gt;NOTE&lt;/em&gt; that this only returns errors etc regarding the whole multi stack. There might still have occurred problems on invidual transfers even when this returns OK.</source>
          <target state="translated">CURLMcode类型，常规的多错误代码。&lt;em&gt;注意&lt;/em&gt;，这只会返回关于整个多堆栈的错误等。即使返回&amp;ldquo;确定&amp;rdquo;，仍可能在个人传输上出现问题。</target>
        </trans-unit>
        <trans-unit id="24871c0c35a14246d94f5b601f5067185618ba89" translate="yes" xml:space="preserve">
          <source>CURLMsg* &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt;(CURLM* multi_handle, int* msgs_in_queue);</source>
          <target state="translated">CURLMsg * &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt;（CURLM * multi_handle，int * msgs_in_queue）;</target>
        </trans-unit>
        <trans-unit id="af2fa369dcf8fd4fae6663dacfb6660f7d91238e" translate="yes" xml:space="preserve">
          <source>CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options</source>
          <target state="translated">CURLPROTO_定义的是CURLOPT_*PROTOCOLS选项。</target>
        </trans-unit>
        <trans-unit id="d2e3b588ca39c50e2dd064cfebdc4915a19704fb" translate="yes" xml:space="preserve">
          <source>CURLSH* &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt;();</source>
          <target state="translated">CURLSH * &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="0cd2315c9c925b9d61d4c461b411526f237b821b" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt;(CURLSH*);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt;（CURLSH *）;</target>
        </trans-unit>
        <trans-unit id="c12fc1ef3ac28f47fb0a0bb249fb914036edd5d6" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt;(CURLSH*, CURLSHoption option, ...);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt;（CURLSH *，CURLSHoption选项，...）;</target>
        </trans-unit>
        <trans-unit id="80c9a3afaa37cabae0ead42d1ea2a983b4448ab3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_ILLEGAL_ARRAY if an illegal option is used in an array</source>
          <target state="translated">如果在数组中使用了非法的选项,那么CURL_FORMADD_ILLEGAL_ARRAY。</target>
        </trans-unit>
        <trans-unit id="237caace3d00237f9fad71d5fdcb4b423276a5aa" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_INCOMPLETE if the some FormInfo is not complete (or error)</source>
          <target state="translated">CURL_FORMADD_INCOMPLETE,如果某些FormInfo不完整(或错误)。</target>
        </trans-unit>
        <trans-unit id="16321db303d4490b9645491e5cfe20deb293518b" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if a curl_httppost struct cannot be allocated</source>
          <target state="translated">CURL_FORMADD_MEMORY,如果一个curl_httppost结构不能被分配的话</target>
        </trans-unit>
        <trans-unit id="468f4fa1bb410d0fd70e03f6a5dce8bd45ccdbe3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if some allocation for string copying failed.</source>
          <target state="translated">CURL_FORMADD_MEMORY如果字符串复制的分配失败。</target>
        </trans-unit>
        <trans-unit id="244588782f153f2f49d14b88a76a4b1567aa1f97" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the FormInfo allocation fails</source>
          <target state="translated">如果FormInfo分配失败,则CURL_FORMADD_MEMORY。</target>
        </trans-unit>
        <trans-unit id="21b7579474f488d4369aa40ec4d89dc3bb5304c5" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the allocation of a FormInfo struct failed</source>
          <target state="translated">如果FormInfo结构的分配失败,CURL_FORMADD_MEMORY。</target>
        </trans-unit>
        <trans-unit id="f486f564c902d8b166b922ce6666a103809fa080" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_NULL if a null pointer was given for a char</source>
          <target state="translated">CURL_FORMADD_NULL,如果一个char的指针为null的话。</target>
        </trans-unit>
        <trans-unit id="03c087c14e47ce05c5a730cee27884e0f0271510" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OK on success</source>
          <target state="translated">CURL_FORMADD_OK在成功后,会有一个新的版本。</target>
        </trans-unit>
        <trans-unit id="657acce1995ce0c4c4cc9704302fc40b3180ce0c" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OPTION_TWICE if one option is given twice for one Form</source>
          <target state="translated">CURL_FORMADD_OPTION_TWICE,如果一个表单中的一个选项被赋予两次,那么CURL_FORMADD_OPTION_TWICE就会出现。</target>
        </trans-unit>
        <trans-unit id="fb231ca0da85a5247735b55bae68726897d51402" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used</source>
          <target state="translated">如果使用了未知的选项,那么CURL_FORMADD_UNKNOWN_OPTION。</target>
        </trans-unit>
        <trans-unit id="c1c36583a3bee413dd4d6eabaaf03906540af6c8" translate="yes" xml:space="preserve">
          <source>CURL_LOCK_DATA_SHARE is used internally to say that the locking is just made to change the internal state of the share itself.</source>
          <target state="translated">CURL_LOCK_DATA_SHARE内部使用的是说,锁定只是为了改变共享本身的内部状态。</target>
        </trans-unit>
        <trans-unit id="08d333ae982f2ab5fd05c92959c9f03604998f78" translate="yes" xml:space="preserve">
          <source>CURL_VERSION</source>
          <target state="translated">CURL_VERSION</target>
        </trans-unit>
        <trans-unit id="311de4a4e55e22b4fb916aea606488f2810807f6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt;(CURL* curl, CURLINFO info, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt;（CURL * curl，CURLINFO info，...）;</target>
        </trans-unit>
        <trans-unit id="732ee216b7a86b2068f3e21e26d039d5ff87d0a6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt;(CURL* handle, int bitmask);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt;（CURL *句柄，int位掩码）；</target>
        </trans-unit>
        <trans-unit id="743291b335af5fe8701249accd883cdee309abc2" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt;（CURL * curl）;</target>
        </trans-unit>
        <trans-unit id="5ef9ed35887a97572c7e153166cf3c37d4499135" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt;（CURL * curl，void * buffer，size_t buflen，size_t * n）;</target>
        </trans-unit>
        <trans-unit id="03f5e5216a441a870631a8ebbf1324f0d53aad46" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt;（CURL * curl，void * buffer，size_t buflen，size_t * n）;</target>
        </trans-unit>
        <trans-unit id="c2267b7c0b6dd8f394f4e53f9877924630091aa4" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt;(CURL* curl, CURLoption option, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt;（CURL * curl，CURLoption选项，...）;</target>
        </trans-unit>
        <trans-unit id="856a997055fde5b0daa6466669272d7c21200826" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt;(c_long flags);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt;（c_long标志）;</target>
        </trans-unit>
        <trans-unit id="ad44c3dd1dc580f2f09873c3d8bc4b0f2c99e680" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt;(c_long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt;（c_long标志，curl_malloc_callback m，curl_free_callback f，curl_realloc_callback r，curl_strdup_callback s，curl_calloc_callback c）;</target>
        </trans-unit>
        <trans-unit id="47d9bbe805f8580c705596e7003de4a50cbc2583" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;result&quot;&gt;result&lt;/strong&gt;;</source>
          <target state="translated">CURLcode &lt;strong id=&quot;result&quot;&gt;结果&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="304f1ec0769d4c548febbdf47625f266fdcfab5b" translate="yes" xml:space="preserve">
          <source>CURLformoption &lt;strong id=&quot;option&quot;&gt;option&lt;/strong&gt;;</source>
          <target state="translated">CURLformoption &lt;strong id=&quot;option&quot;&gt;选项&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="a4c24fe1a70e51826ba9ae7c30e20cd7e2a29828" translate="yes" xml:space="preserve">
          <source>CURLversion &lt;strong id=&quot;age&quot;&gt;age&lt;/strong&gt;;</source>
          <target state="translated">CURLversion &lt;strong id=&quot;age&quot;&gt;年龄&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b4a140e494ddd4ae40e04aab42088b88b1becbfe" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;buf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afe63bc0735098979cb97ac441f55ea9bf41ba0b" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bacd88197768daee4b3de506c5c3a95e5a62751a" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f06ae80fea6ce71846e64d1060826cd17e855a35" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7150792a1546098dee35fe7a98fdfc975256a790" translate="yes" xml:space="preserve">
          <source>Cache size and behaviour</source>
          <target state="translated">缓存大小和行为</target>
        </trans-unit>
        <trans-unit id="f800f99aa3df3800502bbb36ab972cc0eb0d5c0b" translate="yes" xml:space="preserve">
          <source>CacheInfo[5] &lt;strong id=&quot;datacache&quot;&gt;datacache&lt;/strong&gt;;</source>
          <target state="translated">CacheInfo [5]数据&lt;strong id=&quot;datacache&quot;&gt;缓存&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="6bcc4b116e2d06311b0fc9927d035dbff820590a" translate="yes" xml:space="preserve">
          <source>Calculate and return</source>
          <target state="translated">计算和返回</target>
        </trans-unit>
        <trans-unit id="3d6ed85fb2e3f634e358f0719e27875d435ea774" translate="yes" xml:space="preserve">
          <source>Calculate built-in properties which just the type is necessary.</source>
          <target state="translated">计算只需要类型的内置属性。</target>
        </trans-unit>
        <trans-unit id="a4aa52fc673bba9caf0d9f71c29d0ae6f9877456" translate="yes" xml:space="preserve">
          <source>Calculate field[i].overlapped and overlapUnsafe, and check that all of explicit field initializers have unique memory space on instance.</source>
          <target state="translated">计算field[i].overlapped和overlapUnsafe,并检查所有显式字段初始化器在实例上是否有唯一的内存空间。</target>
        </trans-unit>
        <trans-unit id="5c68d55b4c8ec705956e2d8e0515e64b113840ed" translate="yes" xml:space="preserve">
          <source>Calculate the base-10 logarithm of x.</source>
          <target state="translated">计算x的10次方对数。</target>
        </trans-unit>
        <trans-unit id="aa77a0a0c44f9dd6e1b336ed64c758b221d1485c" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence ending one code unit before &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">计算在 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;index&lt;/code&gt; 之前一个代码单元结束的UTF序列的长度。</target>
        </trans-unit>
        <trans-unit id="14c2e14715fa06b8f138716be37c507138d963e7" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence starting at &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">计算开始于UTF序列的长度 &lt;code&gt;index&lt;/code&gt; 在 &lt;code&gt;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e12b3a821d4bde6f6cb14b1be6565da8f2b8ddac" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x.</source>
          <target state="translated">计算x的自然对数。</target>
        </trans-unit>
        <trans-unit id="a30b6367e2a4061ed4b790ec3600b0de931f9e1f" translate="yes" xml:space="preserve">
          <source>Calculate the next largest floating point value after x.</source>
          <target state="translated">计算x之后的下一个最大浮点值。</target>
        </trans-unit>
        <trans-unit id="b9c742d632c337bd8cbf69961edcf3221964c540" translate="yes" xml:space="preserve">
          <source>Calculate the next smallest floating point value before x.</source>
          <target state="translated">计算x之前的下一个最小的浮点值。</target>
        </trans-unit>
        <trans-unit id="018fa0870c360e2cac7a8c4bc28e389efc5f1613" translate="yes" xml:space="preserve">
          <source>Calculate the remainder x REM y, following IEC 60559.</source>
          <target state="translated">按照IEC 60559的规定,计算余量x REM y。</target>
        </trans-unit>
        <trans-unit id="3fba25e1430b0ae9ada9b4efe1168d1151f49b29" translate="yes" xml:space="preserve">
          <source>Calculates 2&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">计算2 &lt;sup&gt;x&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="63c1fbfad55eb2f0634d2925033191320d7fe148" translate="yes" xml:space="preserve">
          <source>Calculates e&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">计算e &lt;sup&gt;x&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="552f818572293e7e3df3d8078e1d8502861c8778" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number</source>
          <target state="translated">计算一个数字的绝对值</target>
        </trans-unit>
        <trans-unit id="8be2a6f70202c3264162991c74bed6c4baae9236" translate="yes" xml:space="preserve">
          <source>Calculates the arc cosine of x, returning a value ranging from 0 to &amp;pi;.</source>
          <target state="translated">计算x的反余弦值，返回值范围为0到&amp;pi;。</target>
        </trans-unit>
        <trans-unit id="d946a27b03ca4cac969d0047946f4fc66affc0fa" translate="yes" xml:space="preserve">
          <source>Calculates the arc sine of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">计算x的反正弦值，返回-&amp;pi;/ 2到&amp;pi;/ 2的值。</target>
        </trans-unit>
        <trans-unit id="d9e1b5526d250f5e8ab8ddc83903cc95d1cc029a" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">计算x的反正切值，返回值介于-&amp;pi;/ 2到&amp;pi;/ 2之间。</target>
        </trans-unit>
        <trans-unit id="3783817bf938b83309854c6205d56ee4a302e644" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of y / x, returning a value ranging from -&amp;pi; to &amp;pi;.</source>
          <target state="translated">计算y / x的反正切，返回-&amp;pi;到&amp;pi;的值。</target>
        </trans-unit>
        <trans-unit id="e1c3e20fd2cd7d94fdcf1efca206597755351a82" translate="yes" xml:space="preserve">
          <source>Calculates the base-2 logarithm of x: log&lt;sub&gt;2&lt;/sub&gt;x</source>
          <target state="translated">计算x的以2为底的对数：log &lt;sub&gt;2&lt;/sub&gt; x</target>
        </trans-unit>
        <trans-unit id="ba562ff7e573b706f15ed8cff069704fa53ed5ac" translate="yes" xml:space="preserve">
          <source>Calculates the cube root of x.</source>
          <target state="translated">计算x的立方根。</target>
        </trans-unit>
        <trans-unit id="c6b3ccb038ca0414c5d73b25ada62fdde6188a5c" translate="yes" xml:space="preserve">
          <source>Calculates the hash value of &lt;code&gt;arg&lt;/code&gt; with an optional &lt;code&gt;seed&lt;/code&gt; initial value. The result might not be equal to &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt;.</source>
          <target state="translated">用可选的 &lt;code&gt;seed&lt;/code&gt; 初始值计算 &lt;code&gt;arg&lt;/code&gt; 的哈希值。结果可能不等于 &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6077e40f1d7c6b4630a9eabd54e9cc9ad6cdbbd5" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic cosine of x.</source>
          <target state="translated">计算x的双曲余弦。</target>
        </trans-unit>
        <trans-unit id="c3be2955cec737e95210a83c0153e5a7b26737f0" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic sine of x.</source>
          <target state="translated">计算x的双曲正弦。</target>
        </trans-unit>
        <trans-unit id="836a3048b7c344efad04edc701d9a39358e4ddc2" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic tangent of x.</source>
          <target state="translated">计算x的双曲正切。</target>
        </trans-unit>
        <trans-unit id="26863b4aef8c0a694cd2e723d6778f9f04e7eb52" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic cosine of x.</source>
          <target state="translated">计算x的反双曲余弦。</target>
        </trans-unit>
        <trans-unit id="c627e3b3df39ce6438ba816e8a109c0ffed6f76d" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic sine of x.</source>
          <target state="translated">计算x的反双曲正弦。</target>
        </trans-unit>
        <trans-unit id="8af98eaa49794884fefd803885cf1f1893246ddf" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic tangent of x, returning a value from ranging from -1 to 1.</source>
          <target state="translated">计算x的反双曲正切,返回一个从-1到1的值。</target>
        </trans-unit>
        <trans-unit id="5c5618c4bbf47d472509dd6366443a216865a98d" translate="yes" xml:space="preserve">
          <source>Calculates the length needed to store the encoded string corresponding to an input of the given length.</source>
          <target state="translated">计算与给定长度的输入对应的编码字符串所需的存储长度。</target>
        </trans-unit>
        <trans-unit id="027e373dfea678dcf40ffef9e131551d07153fd8" translate="yes" xml:space="preserve">
          <source>Calculates the length of the hypotenuse of a right-angled triangle with sides of length x and y. The hypotenuse is the value of the square root of the sums of the squares of x and y:</source>
          <target state="translated">计算边长为x和y的直角三角形的斜边长度。斜边是x和y的平方根之和的值。</target>
        </trans-unit>
        <trans-unit id="49efa739aec865cfda8564b9080c48989d5e33a7" translate="yes" xml:space="preserve">
          <source>Calculates the natural logarithm of 1 + x.</source>
          <target state="translated">计算1+x的自然对数。</target>
        </trans-unit>
        <trans-unit id="2c06de5b0b0a99a9dfc2d0912c58bdadc98082d6" translate="yes" xml:space="preserve">
          <source>Calculates the next representable value after x in the direction of y.</source>
          <target state="translated">计算x之后沿y方向的下一个可表示值。</target>
        </trans-unit>
        <trans-unit id="3754c2ce035cf1b13a7cd37e615749fb652610b4" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer using the X86 SSE4 POPCNT instruction. POPCNT is not available on all X86 CPUs.</source>
          <target state="translated">使用X86 SSE4 POPCNT指令计算整数中的设置位数。POPCNT并非在所有X86 CPU上都可用。</target>
        </trans-unit>
        <trans-unit id="06d72e9a8ced5d5423191cc63ca6b46b4610af0d" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer.</source>
          <target state="translated">计算整数中设置的位数。</target>
        </trans-unit>
        <trans-unit id="9a6eed62af9d1a47c1ab6bc79899d39e32a6483a" translate="yes" xml:space="preserve">
          <source>Calculates the remainder from the calculation x/y.</source>
          <target state="translated">计算x/y计算的余数。</target>
        </trans-unit>
        <trans-unit id="fe24886c3219456f2196eb244fb852afd4fb56a9" translate="yes" xml:space="preserve">
          <source>Calculates the value of the natural logarithm base (e) raised to the power of x, minus 1.</source>
          <target state="translated">计算自然对数基数(e)提高到x的幂,减1的值。</target>
        </trans-unit>
        <trans-unit id="b6f6cce6873a9a6bb919b268ff433dd1e133a874" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;y&lt;/sup&gt;.</source>
          <target state="translated">计算x &lt;sup&gt;y&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="801ce4a0b5aa9b661ade0819332605cc7b1ae809" translate="yes" xml:space="preserve">
          <source>Call each of the connected slots, passing the argument(s) i to them. Nested call will be ignored.</source>
          <target state="translated">调用每个连接的插槽,将参数i传递给它们。嵌套调用将被忽略。</target>
        </trans-unit>
        <trans-unit id="5f9f4deb84100f6aec181820d5a751140cd068c1" translate="yes" xml:space="preserve">
          <source>Call this after printing out fatal error messages to clean up and exit the compiler.</source>
          <target state="translated">在打印出致命的错误信息后调用此功能来清理并退出编译器。</target>
        </trans-unit>
        <trans-unit id="f75e5681020d520d2c6f752e809e81b0c81a85b8" translate="yes" xml:space="preserve">
          <source>CallExp &lt;code&gt;ce&lt;/code&gt;</source>
          <target state="translated">CallExp &lt;code&gt;ce&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf7b36d93b4e5475d0f1769a4ea2f0934f697c5" translate="yes" xml:space="preserve">
          <source>Callback for each received StatusLine.</source>
          <target state="translated">对每个收到的状态线进行回调。</target>
        </trans-unit>
        <trans-unit id="f3869aa6b3628e9280e1301a0819ce5b27364caa" translate="yes" xml:space="preserve">
          <source>Callback function for opening socket (instead of socket(2)). Optionally, callback is able change the address or refuse to connect returning CURL_SOCKET_BAD. The callback should have type curl_opensocket_callback</source>
          <target state="translated">用于打开socket的回调函数(代替socket(2))。也可以选择回调函数来改变地址或者拒绝连接,返回CURL_SOCKET_BAD。回调函数的类型应该是curl_opensocket_callback。</target>
        </trans-unit>
        <trans-unit id="fa6c180b210d6c195ea47a0f5808f2e991c787e3" translate="yes" xml:space="preserve">
          <source>Callback function for seeking in the input stream</source>
          <target state="translated">用于在输入流中寻找的回调函数</target>
        </trans-unit>
        <trans-unit id="d4829fe836ac65e604efec860420d6bb34e163e7" translate="yes" xml:space="preserve">
          <source>Callback implementation user data</source>
          <target state="translated">回调实现用户数据</target>
        </trans-unit>
        <trans-unit id="7958bba34f83b3f0d9bec51f1aa784c3099f4330" translate="yes" xml:space="preserve">
          <source>Callback options.</source>
          <target state="translated">回调选项:</target>
        </trans-unit>
        <trans-unit id="2c70d267e735763e25416c3729426a88c83fd93c" translate="yes" xml:space="preserve">
          <source>Callback parameters</source>
          <target state="translated">回调参数</target>
        </trans-unit>
        <trans-unit id="83da71c0b0c98f854fd142c883ddfbc56d402d5a" translate="yes" xml:space="preserve">
          <source>Callback returns</source>
          <target state="translated">回调返回</target>
        </trans-unit>
        <trans-unit id="5277f74ec6b2c07897ae08c4150298f4a47bfee7" translate="yes" xml:space="preserve">
          <source>Callback routine requested an abort</source>
          <target state="translated">回调例程请求中止</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="9d7a88bd45dd2018e4f369390635318ba64e842f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad &lt;code&gt;opOpAssign&lt;/code&gt; call (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">在错误的 &lt;code&gt;opOpAssign&lt;/code&gt; 调用（会降低精度或尝试将负值转换为无符号类型的调用）时自动调用。</target>
        </trans-unit>
        <trans-unit id="7102900b536c87cd1ddcccfc7367f11bb9536bf4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast (one that loses precision or attempts to convert a negative value to an unsigned type). The source type is &lt;code&gt;Src&lt;/code&gt; and the destination type is &lt;code&gt;Dst&lt;/code&gt;.</source>
          <target state="translated">在转换错误时自动调用（该转换会导致精度下降或尝试将负值转换为无符号类型）。源类型为 &lt;code&gt;Src&lt;/code&gt; ，目标类型为 &lt;code&gt;Dst&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ced3e78029e52a33dba4c3dc622cbf4db610e5" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast from &lt;code&gt;src&lt;/code&gt; to type &lt;code&gt;Dst&lt;/code&gt; (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">在从 &lt;code&gt;src&lt;/code&gt; &lt;code&gt;Dst&lt;/code&gt; 转换为Dst类型时（错误的精度或试图将负值转换为无符号类型的类型）自动调用。</target>
        </trans-unit>
        <trans-unit id="1b890f532573803598c95ff0855037312602e65a" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bounds error.</source>
          <target state="translated">发生边界错误时自动调用。</target>
        </trans-unit>
        <trans-unit id="cec93f38cfc349e778449343568f595e85578df6" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of a erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), this hook issues &lt;code&gt;assert(0)&lt;/code&gt; which terminates the application.</source>
          <target state="translated">在进行相等性比较时自动调用。在比较错误的情况下（使带负号的负值看起来等于无符号的正值的那个），此钩子发出 &lt;code&gt;assert(0)&lt;/code&gt; 终止应用程序。</target>
        </trans-unit>
        <trans-unit id="0d9a0c46bb6698d633be1a9f6fd1250d9925d992" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of an Erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), writes a warning message to &lt;code&gt;stderr&lt;/code&gt; as a side effect.</source>
          <target state="translated">在进行相等性比较时自动调用。如果发生错误比较（一个使带负号的负值看起来等于无符号的正值的比较），则作为副作用将警告消息写入 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5f36c313c02bf2d55947333ca1b1ce5b5e726cd" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. Throws upon an erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value).</source>
          <target state="translated">在进行平等比较时自动调用。抛出一个错误的比较(使一个有符号的负值看起来等于一个无符号的正值)。</target>
        </trans-unit>
        <trans-unit id="482787b051181ec9851e392f48ceca8d8cc29f3f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then a warning message is printed to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">使用操作符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 之一进行比较时自动调用。如果比较是错误的（即，它将使有符号的负值看起来大于或等于无符号的正值），则将警告消息打印到 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f347895ce62ab753804db2ed8acefc457ef89fc4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then application is terminated with &lt;code&gt;assert(0)&lt;/code&gt;. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">使用操作符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 之一进行比较时自动调用。如果比较是错误的（即，它将使有符号的负值看起来大于或等于无符号的正值），则应用将以 &lt;code&gt;assert(0)&lt;/code&gt; 终止。否则，返回三态结果（如果 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 为正，如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 负，否则为 &lt;code&gt;0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fd9dee545de2de37ec8d225d3452d9b9db4a4de3" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), throws a &lt;code&gt;Throw.CheckFailure&lt;/code&gt; exception. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">使用操作符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;=&lt;/code&gt; 之一进行比较时自动调用。如果比较是错误的（即，它将使有符号的负值看起来大于或等于无符号的正值），则引发 &lt;code&gt;Throw.CheckFailure&lt;/code&gt; 异常。否则，返回三态结果（如果 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 为正，如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 负，否则为 &lt;code&gt;0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="288a3bb051cf2f7e5a316c4d4e70d5118f188801" translate="yes" xml:space="preserve">
          <source>Called automatically upon an overflow during a unary or binary operation.</source>
          <target state="translated">在一元或二元操作中发生溢出时自动调用。</target>
        </trans-unit>
        <trans-unit id="18ffd2396df8d946aeaff03367807e9289b502e5" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;accept&lt;/code&gt; when a new &lt;code&gt;Socket&lt;/code&gt; must be created for a new connection. To use a derived class, override this method and return an instance of your class. The returned &lt;code&gt;Socket&lt;/code&gt;'s handle must not be set; &lt;code&gt;Socket&lt;/code&gt; has a protected constructor &lt;code&gt;this()&lt;/code&gt; to use in this situation.</source>
          <target state="translated">当必须为新连接创建新的 &lt;code&gt;Socket&lt;/code&gt; 时，由 &lt;code&gt;accept&lt;/code&gt; 调用。要使用派生类，请重写此方法并返回您的类的实例。返回的 &lt;code&gt;Socket&lt;/code&gt; 的句柄不能设置。在这种情况下， &lt;code&gt;Socket&lt;/code&gt; 具有受保护的构造函数 &lt;code&gt;this()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b54f1e19b12e53615e8a653c409ba5ab2951a872" translate="yes" xml:space="preserve">
          <source>Called by D code to throw an exception via</source>
          <target state="translated">被D代码调用,以通过</target>
        </trans-unit>
        <trans-unit id="1ca7f5a39bbf37ff1a678bd1aa4c79aba11959d4" translate="yes" xml:space="preserve">
          <source>Called by SQLite to clean up pUser</source>
          <target state="translated">被SQLite调用来清理pUser。</target>
        </trans-unit>
        <trans-unit id="9743db8f1711c6b311db6267994885195b8a6347" translate="yes" xml:space="preserve">
          <source>Called by libcurl whenever the library detects a change in the maximum number of milliseconds the app is allowed to wait before curl_multi_socket() or curl_multi_perform() must be called (to allow libcurl's timed events to take place).</source>
          <target state="translated">每当库检测到应用程序在调用curl_multi_socket()或curl_multi_perform()之前允许等待的最大毫秒数发生变化时,就会被libcurl调用(以允许libcurl的定时事件发生)。</target>
        </trans-unit>
        <trans-unit id="3edd2c76a126518315d7a71140c73140e3fc8324" translate="yes" xml:space="preserve">
          <source>Called during runtime initialization to initialize a GC instance of given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">在运行时初始化期间调用，以初始化给定 &lt;code&gt;name&lt;/code&gt; 的GC实例。</target>
        </trans-unit>
        <trans-unit id="6980b4453fbc6893945f9512aa33baa854c12d55" translate="yes" xml:space="preserve">
          <source>Called from back end.</source>
          <target state="translated">从后端调用。</target>
        </trans-unit>
        <trans-unit id="f90881b5eb5e600ad18d60ab2849afead809fc76" translate="yes" xml:space="preserve">
          <source>Called once per thread; returns array of thread local storage ranges</source>
          <target state="translated">每个线程调用一次;返回线程本地存储范围的数组。</target>
        </trans-unit>
        <trans-unit id="7a912bc6a899a5bd4ea502581245c2ef16bd2966" translate="yes" xml:space="preserve">
          <source>Called when fibers switch contexts.</source>
          <target state="translated">当光纤切换上下文时调用。</target>
        </trans-unit>
        <trans-unit id="c0acd999c318ee36079d9ad700960738ccee34ac" translate="yes" xml:space="preserve">
          <source>Called when setting a version identifier, e.g. &lt;code&gt;-version=identifier&lt;/code&gt; parameter to the compiler or &lt;code&gt;version = Foo&lt;/code&gt; in user code.</source>
          <target state="translated">设置版本标识符时调用，例如在编译器中使用 &lt;code&gt;-version=identifier&lt;/code&gt; 参数或用户代码中的 &lt;code&gt;version = Foo&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="495dea06203f25ae26116f2f5772a696918832bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#reset&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; will reset this to &lt;code&gt;Duration.zero&lt;/code&gt;.</source>
          <target state="translated">调用&lt;a href=&quot;#reset&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;将其重置为 &lt;code&gt;Duration.zero&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f23a63a5505f1213693ee8224d96b5310cf3183b" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#kill&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt; with the resulting &lt;code&gt;Pid&lt;/code&gt; is invalid.</source>
          <target state="translated">用生成的 &lt;code&gt;Pid&lt;/code&gt; 调用&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#kill&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt;无效。</target>
        </trans-unit>
        <trans-unit id="e69ccd3a1a7e462d569968184a6624c2a8f6e037" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;reopen&lt;/code&gt; with a &lt;code&gt;null&lt;/code&gt;&lt;code&gt;name&lt;/code&gt; is not implemented in all C runtimes.</source>
          <target state="translated">并非在所有C运行时中都以 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; 调用 &lt;code&gt;reopen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a670c32e5ff77bac0fbdbb4ed6c86d3156f5f82" translate="yes" xml:space="preserve">
          <source>Calling C Functions</source>
          <target state="translated">调用C函数</target>
        </trans-unit>
        <trans-unit id="2a58b71a9eba354c8a2762dcf96889501c4c8b2f" translate="yes" xml:space="preserve">
          <source>Calling C++ Global Functions from D</source>
          <target state="translated">从D中调用C++全局函数</target>
        </trans-unit>
        <trans-unit id="0af92a8a9a70b3aa97a6e09d334eff695960b293" translate="yes" xml:space="preserve">
          <source>Calling CTFE-able functions or using manifest constants is also possible.</source>
          <target state="translated">也可以调用CTFE的函数或使用manifest常量。</target>
        </trans-unit>
        <trans-unit id="ab9616e4fb5ac458c376db23b38a3a4f41bdffa3" translate="yes" xml:space="preserve">
          <source>Calling Global D Functions From C++</source>
          <target state="translated">从C++中调用全局D函数</target>
        </trans-unit>
        <trans-unit id="011de1cd8c5a8313b4819150b58f7b77ffe1686b" translate="yes" xml:space="preserve">
          <source>Calling an Instance Method</source>
          <target state="translated">调用实例方法</target>
        </trans-unit>
        <trans-unit id="882cd8e97a7e6dec1b20f7ffc308265e42981f07" translate="yes" xml:space="preserve">
          <source>Calling an Objective-C instance method uses the same syntax as calling regular D methods:</source>
          <target state="translated">调用Objective-C实例方法与调用普通D方法使用相同的语法。</target>
        </trans-unit>
        <trans-unit id="2837bac68cbbca90ef92df0ecb7045b8bad05e30" translate="yes" xml:space="preserve">
          <source>Calling any system functions.</source>
          <target state="translated">调用任何系统功能。</target>
        </trans-unit>
        <trans-unit id="99afec36350160ba55067caa792fb170d47da7f2" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the @nogc-ness, i.e. if we're in a @nogc function we can only call other @nogc functions. Returns true if error occurs.</source>
          <target state="translated">调用函数f.检查@nogc-ness,即如果我们在一个@nogc函数中,只能调用其他@nogc函数。如果发生错误则返回true。</target>
        </trans-unit>
        <trans-unit id="889558fe1d6b373ebfb4108727201ca1efea7bd9" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the purity, i.e. if we're in a pure function we can only call other pure functions. Returns true if error occurs.</source>
          <target state="translated">调用函数f,检查纯度,即如果我们在一个纯函数中,只能调用其他纯函数。如果发生错误则返回true。</target>
        </trans-unit>
        <trans-unit id="9d07dff2f17d03cbf0372862de2a911c37b1df31" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the safety, i.e. if we're in a @safe function we can only call @safe or @trusted functions. Returns true if error occurs.</source>
          <target state="translated">调用函数f.检查安全,即如果我们在@safe函数中,我们只能调用@safe或@trusted函数。如果发生错误则返回true。</target>
        </trans-unit>
        <trans-unit id="49f72934b9748e8925ba7a574cd2caf074e942d5" translate="yes" xml:space="preserve">
          <source>Calling printf()</source>
          <target state="translated">调用printf()</target>
        </trans-unit>
        <trans-unit id="06859dbd6f7a9d0b1a468c855675188601e16f52" translate="yes" xml:space="preserve">
          <source>Calling this function sets a flag indicating that this struct is no longer worker-local, and attempting to use the &lt;code&gt;get&lt;/code&gt; method again will result in an assertion failure if assertions are enabled.</source>
          <target state="translated">调用此函数将设置一个标志，指示该结构不再是本地工作人员，并且如果启用断言，则再次尝试使用 &lt;code&gt;get&lt;/code&gt; 方法将导致断言失败。</target>
        </trans-unit>
        <trans-unit id="c5e417ef005e02e78fdb802550dfe5fd2fa097a5" translate="yes" xml:space="preserve">
          <source>Calling this function with &lt;code&gt;blocking = true&lt;/code&gt; from a worker thread that is a member of the same &lt;code&gt;TaskPool&lt;/code&gt; that &lt;code&gt;finish&lt;/code&gt; is being called on will result in a deadlock.</source>
          <target state="translated">调用这个函数 &lt;code&gt;blocking = true&lt;/code&gt; 从工作线程相同的成员 &lt;code&gt;TaskPool&lt;/code&gt; 即 &lt;code&gt;finish&lt;/code&gt; 正在呼吁将导致死锁。</target>
        </trans-unit>
        <trans-unit id="a483b09288907bf0c6892b8a0c3a3688580a1534" translate="yes" xml:space="preserve">
          <source>Calling this function, and then using references to data located after the given array results in undefined behavior.</source>
          <target state="translated">调用这个函数,然后使用位于给定数组之后的数据引用,会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="0a48762ee3e2f7b163567b2b8c2bdc321fb3d29c" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt; for the file handle.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt;作为文件句柄。</target>
        </trans-unit>
        <trans-unit id="5fa582845b2a8965acb06e6a0955d839742fab8a" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt; for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt;作为文件句柄。分别从输入数组的大小和类型推断要读取的项目数和每个项目的大小。</target>
        </trans-unit>
        <trans-unit id="4204f336078b400c2ca8218f3dc707eed9fc8eef" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt; for the file handle to move its position indicator.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt;来使文件句柄移动其位置指示器。</target>
        </trans-unit>
        <trans-unit id="b841aa017960fa21330d3bce71d1341f08261fc1" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt; for the managed file handle.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt;作为托管文件句柄。</target>
        </trans-unit>
        <trans-unit id="19416b73e0b0cfe1706209f1904f9557babb3844" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt; for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the buffer could not be written in its entirety.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt;作为文件句柄。分别从输入数组的大小和类型推断要写入的项目数和每个项目的大小。如果无法完整写入缓冲区，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="b50971f4c5e8a0e45c73e7c7c90d36d61fddcb7f" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;rewind&lt;/a&gt; for the file handle.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;倒带&lt;/a&gt;文件句柄。</target>
        </trans-unit>
        <trans-unit id="6954ffddc60a249c70b2b20272f1b59673a22e6b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt; for the file handle.</source>
          <target state="translated">调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt;作为文件句柄。</target>
        </trans-unit>
        <trans-unit id="660af3415b8af8c796363c6a336c94f83d470574" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; (as it must be called or copied in any function overriding &lt;code&gt;newScope&lt;/code&gt;), then set the &lt;code&gt;Scope&lt;/code&gt;'s depdecl.</source>
          <target state="translated">调用 &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; （因为必须在覆盖 &lt;code&gt;newScope&lt;/code&gt; 的任何函数中调用或复制它），然后设置 &lt;code&gt;Scope&lt;/code&gt; 的depdecl。</target>
        </trans-unit>
        <trans-unit id="ea66981f1c839cec218fd677425515ff882faad6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;free(b.ptr)&lt;/code&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">在Posix上调用 &lt;code&gt;free(b.ptr)&lt;/code&gt; ，在Windows 上调用__aligned_free &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e076da4834d8b045458f6ec7dd1c5d3b78bd298c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;impl.deallocateAll()&lt;/code&gt; and returns the result if defined, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;impl.deallocateAll()&lt;/code&gt; 并返回结果（如果已定义），否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b0309269b86732c6de69ae225028495fc3e76bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order, stopping when either range has been exhausted.</source>
          <target state="translated">呼叫 &lt;code&gt;move(a, b)&lt;/code&gt; 对每个元件 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;src&lt;/code&gt; 和相应的元件 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;tgt&lt;/code&gt; ，在增加的顺序，当任一范围已经耗尽停止。</target>
        </trans-unit>
        <trans-unit id="b3aff67db2952371a04e1469cf552b2bafe5ed21" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order.</source>
          <target state="translated">呼叫 &lt;code&gt;move(a, b)&lt;/code&gt; 对每个元件 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;src&lt;/code&gt; 和相应的元件 &lt;code&gt;b&lt;/code&gt; 中 &lt;code&gt;tgt&lt;/code&gt; ，按递增顺序。</target>
        </trans-unit>
        <trans-unit id="9326ff35ce625813cb6e134a6874955a7343c986" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;popBack&lt;/code&gt; for all controlled ranges.</source>
          <target state="translated">为所有受控范围调用 &lt;code&gt;popBack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cb6a5ebd9c3d585d565184c781a892ebfa3d0e5" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol.</source>
          <target state="translated">对每个Dsymbol调用dg(Dsymbol *sym)。</target>
        </trans-unit>
        <trans-unit id="f0ea91146057c0154bb8b4caec2606cab70e289d" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol. If dg returns !=0, stops and returns that value else returns 0.</source>
          <target state="translated">对每个Dsymbol调用dg(Dsymbol *sym)。如果 dg 返回 !=0,则停止并返回该值,否则返回 0。</target>
        </trans-unit>
        <trans-unit id="20447109fe962cd134aaca38e701f9a14ee5ab9e" translate="yes" xml:space="preserve">
          <source>Calls the destructor &lt;code&gt;~this()&lt;/code&gt; for the object referred to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a class or interface reference) or for the object pointed to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a pointer to a &lt;code&gt;struct&lt;/code&gt;). Arrays of structs call the destructor, if defined, for each element in the array. If no destructor is defined, this step has no effect.</source>
          <target state="translated">为 &lt;code&gt;x&lt;/code&gt; 引用的对象（如果 &lt;code&gt;x&lt;/code&gt; 是类或接口引用）或 &lt;code&gt;x&lt;/code&gt; 指向的对象（如果 &lt;code&gt;x&lt;/code&gt; 是指向 &lt;code&gt;struct&lt;/code&gt; 的指针 &lt;code&gt;~this()&lt;/code&gt; 调用析构函数〜this（）。结构数组为数组中的每个元素调用析构函数（如果已定义）。如果未定义析构函数，则此步骤无效。</target>
        </trans-unit>
        <trans-unit id="d91be267ab03b3c9611f9cbcd4786308f2144fc6" translate="yes" xml:space="preserve">
          <source>Calls to functions with &lt;code&gt;extern(D)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;linkage&lt;/a&gt; (which is the default linkage) are evaluated in the following order: first, if necessary, the address of the function to call is evaluated (e.g. in the case of a computed function pointer or delegate). Then, arguments are evaluated left to right. Finally, transfer is passed to the function. Example:</source>
          <target state="translated">具有 &lt;code&gt;extern(D)&lt;/code&gt; &lt;a href=&quot;attribute#linkage&quot;&gt;链接&lt;/a&gt;（默认链接）的函数的调用按以下顺序进行评估：首先，如有必要，将评估要调用的函数的地址（例如，在使用计算函数指针或委托的情况下） 。然后，从左到右评估参数。最后，将传递传递给函数。例：</target>
        </trans-unit>
        <trans-unit id="0645e6f6a8a53952c04e63653f8086d201146bb8" translate="yes" xml:space="preserve">
          <source>Calls to the free standing log functions are not directly forwarded to the global &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;sharedLog&lt;/code&gt;. Actually, a thread local &lt;code&gt;Logger&lt;/code&gt; of type &lt;code&gt;StdForwardLogger&lt;/code&gt; processes the log call and then, by default, forwards the created &lt;code&gt;Logger.LogEntry&lt;/code&gt; to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The thread local &lt;code&gt;Logger&lt;/code&gt; is accessible by the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; property. This property allows to assign user defined &lt;code&gt;Logger&lt;/code&gt;. The default &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt; is &lt;code&gt;LogLevel.all&lt;/code&gt; and it will therefore forward all messages to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; can be used to filter log calls before they reach the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">对独立日志功能的调用不会直接转发到全局 &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;sharedLog&lt;/code&gt; 。实际上，类型为 &lt;code&gt;StdForwardLogger&lt;/code&gt; 的线程本地 &lt;code&gt;Logger&lt;/code&gt; 处理该日志调用，然后默认情况下将创建的 &lt;code&gt;Logger.LogEntry&lt;/code&gt; 转发到 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 。线程本地 &lt;code&gt;Logger&lt;/code&gt; 可通过 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 属性访问。此属性允许分配用户定义的 &lt;code&gt;Logger&lt;/code&gt; 。默认 &lt;code&gt;LogLevel&lt;/code&gt; 中的 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 是 &lt;code&gt;LogLevel.all&lt;/code&gt; ，因此它会转发到所有消息 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 。该 &lt;code&gt;LogLevel&lt;/code&gt; 的了的 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 可在到达之前，用于过滤日志调用 &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb904d86116e0af2b9834a7896df4545d587c42c" translate="yes" xml:space="preserve">
          <source>Can also assign class values</source>
          <target state="translated">也可以分配类值</target>
        </trans-unit>
        <trans-unit id="0e9fa73b910a6a2eb1eaa95a1ab5ac09bd2a00f0" translate="yes" xml:space="preserve">
          <source>Can be called from either the driver or a &lt;code&gt;debug = Ident;&lt;/code&gt; statement. Unlike version identifier, there isn't any reserved debug identifier so no validation takes place.</source>
          <target state="translated">可以从驱动程序或 &lt;code&gt;debug = Ident;&lt;/code&gt; 调用= Ident; 声明。与版本标识符不同，没有任何保留的调试标识符，因此不会进行验证。</target>
        </trans-unit>
        <trans-unit id="38f77fd06cc4025566434eff583d8ad55911f526" translate="yes" xml:space="preserve">
          <source>Can be overridden to support other addresses.</source>
          <target state="translated">可以覆盖支持其他地址。</target>
        </trans-unit>
        <trans-unit id="b93c4ede92c61cd906a3c26c9c976c09eb1f2fc5" translate="yes" xml:space="preserve">
          <source>Can start enumeration from a negative position:</source>
          <target state="translated">可以从负数位置开始列举。</target>
        </trans-unit>
        <trans-unit id="9a5600ddf1629b08398131936e3e9652bd1d2e46" translate="yes" xml:space="preserve">
          <source>Can variable be read and written by CTFE?</source>
          <target state="translated">变量可以被CTFE读取和写入吗?</target>
        </trans-unit>
        <trans-unit id="3b92458a5ee7b262130f2150d91ab4bffe0cab98" translate="yes" xml:space="preserve">
          <source>Can't run semantic on s now, try again later.</source>
          <target state="translated">现在不能在s上运行语义,以后再试。</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="77dfd2135f4db726c47299bb55be26f7f4525a46" translate="yes" xml:space="preserve">
          <source>Cancel</source>
          <target state="translated">Cancel</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">取消自动延期加载</target>
        </trans-unit>
        <trans-unit id="33b8203d640b9445058eff13b7f608ffa2a1d260" translate="yes" xml:space="preserve">
          <source>Cannot access &lt;code&gt;__gshared&lt;/code&gt; variables.</source>
          <target state="translated">无法访问 &lt;code&gt;__gshared&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="23679ec318316b42991fb0add8c6df84610db970" translate="yes" xml:space="preserve">
          <source>Cannot access unions that have pointers or references overlapping with other types.</source>
          <target state="translated">不能访问有指针或引用与其他类型重叠的联合体。</target>
        </trans-unit>
        <trans-unit id="486e3c068e9f84acb903fe338c21a7a8da40f7e4" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for class or interface references.</source>
          <target state="translated">不能将 &lt;code&gt;void&lt;/code&gt; 初始化程序用于类或接口引用。</target>
        </trans-unit>
        <trans-unit id="71a9611e8c1a236df296e1967a0f6238ddd70798" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for pointers.</source>
          <target state="translated">不能将 &lt;code&gt;void&lt;/code&gt; 初始化程序用于指针。</target>
        </trans-unit>
        <trans-unit id="774c0fbc4f368f6c2081f7a0dddc8b68729cb7f6" translate="yes" xml:space="preserve">
          <source>Canonical decomposition. The result is canonically equivalent sequence.</source>
          <target state="translated">规范分解。结果是规范的等价序列。</target>
        </trans-unit>
        <trans-unit id="aae48ee7b1f403f38486b8bf47778fda77282b5f" translate="yes" xml:space="preserve">
          <source>Canonical name, when &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; is used.</source>
          <target state="translated">使用 &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; 时的规范名称。</target>
        </trans-unit>
        <trans-unit id="ca2d0802f87ef08825202a1ca29c54992dad17b0" translate="yes" xml:space="preserve">
          <source>Capabilities of the CPU the program is running on.</source>
          <target state="translated">程序运行的CPU的能力。</target>
        </trans-unit>
        <trans-unit id="7e1973f266a216415dc191028046ea7f74365eb7" translate="yes" xml:space="preserve">
          <source>Capacity desired. This constructor is defined only if &lt;code&gt; ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;.</source>
          <target state="translated">所需容量。仅当 &lt;code&gt; ParentAllocator&lt;/code&gt; 不是 &lt;code&gt;NullAllocator&lt;/code&gt; 时,才定义此构造函数。</target>
        </trans-unit>
        <trans-unit id="70603ccef126aa6da95612288168a613c4bc83f0" translate="yes" xml:space="preserve">
          <source>Capitalize a the first character of a ASCII string.</source>
          <target state="translated">ASCII字符串的第一个字符大写。</target>
        </trans-unit>
        <trans-unit id="7bac59f23d8a421d02552a2b75009a6de4d133eb" translate="yes" xml:space="preserve">
          <source>Capitalize an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; or string, meaning convert the first character to upper case and subsequent characters to lower case.</source>
          <target state="translated">将&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;或字符串大写，这意味着将第一个字符转换为大写，将后续字符转换为小写。</target>
        </trans-unit>
        <trans-unit id="d87b28abafacc3e31f8a5ef814dc1a89c95adc81" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of &lt;code&gt;s&lt;/code&gt; and convert the rest of &lt;code&gt;s&lt;/code&gt; to lowercase.</source>
          <target state="translated">大写的第一个字符 &lt;code&gt;s&lt;/code&gt; 和其余转换 &lt;code&gt;s&lt;/code&gt; 为小写。</target>
        </trans-unit>
        <trans-unit id="63beb67c34339e7c0d71b7c05343dfc0c5c06706" translate="yes" xml:space="preserve">
          <source>Captures a range state.</source>
          <target state="translated">捕获一个范围状态。</target>
        </trans-unit>
        <trans-unit id="6e0d5cedfdd10366517f607a93eeeef9b4785a51" translate="yes" xml:space="preserve">
          <source>Carian</source>
          <target state="translated">Carian</target>
        </trans-unit>
        <trans-unit id="df10067f5a8780a3c7f1ce6b060b8d78df100b22" translate="yes" xml:space="preserve">
          <source>Carriage return</source>
          <target state="translated">回程车</target>
        </trans-unit>
        <trans-unit id="b94582323a02af8750c89d9914ff8a094fbada5b" translate="yes" xml:space="preserve">
          <source>Carriage return (U+000D).</source>
          <target state="translated">回车(U+000D)。</target>
        </trans-unit>
        <trans-unit id="9254c4bba00f5ff69304a7921d3118fcbac7e6b8" translate="yes" xml:space="preserve">
          <source>Case</source>
          <target state="translated">Case</target>
        </trans-unit>
        <trans-unit id="af7c0d9ee5c8a6c4478105142a141d1bad096c35" translate="yes" xml:space="preserve">
          <source>Case expressions must all evaluate to distinct values. Const or immutable variables must all have different names. If they share a value, the first case statement with that value gets control. There must be exactly one default statement.</source>
          <target state="translated">案例表达式必须全部计算为不同的值。Const或不可变的变量必须都有不同的名字。如果它们共享一个值,则第一个具有该值的case语句获得控制权。必须只有一个缺省语句。</target>
        </trans-unit>
        <trans-unit id="be29d0c965453b901d4ad20bdc8e2ddd09f27c5c" translate="yes" xml:space="preserve">
          <source>Case insensitive matching.</source>
          <target state="translated">不区分大小写的匹配。</target>
        </trans-unit>
        <trans-unit id="b632747e3a93dfa45ef0653a66ab6ac246268230" translate="yes" xml:space="preserve">
          <source>Case statements and default statements associated with the switch can be nested within block statements; they do not have to be in the outermost block. For example, this is allowed:</source>
          <target state="translated">与开关相关的案例语句和默认语句可以嵌套在块语句中,它们不一定要在最外层的块中。例如,这是允许的。</target>
        </trans-unit>
        <trans-unit id="4830655a69813534d85f86f1ac7683b83fc06b02" translate="yes" xml:space="preserve">
          <source>Case-insensitive find of a string</source>
          <target state="translated">不区分大小写的字符串查找</target>
        </trans-unit>
        <trans-unit id="22a0daee669e27ee86078432c6d32a4c0da14fe0" translate="yes" xml:space="preserve">
          <source>Case-insensitive string comparison (&lt;a href=&quot;#sicmp&quot;&gt;&lt;code&gt;sicmp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#icmp&quot;&gt;&lt;code&gt;icmp&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">不区分大小写的字符串比较（&lt;a href=&quot;#sicmp&quot;&gt; &lt;code&gt;sicmp&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#icmp&quot;&gt; &lt;code&gt;icmp&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dc02e22f8ccf2c7182decb6993c9ab41402098ce" translate="yes" xml:space="preserve">
          <source>Case-sensitivity of the comparison.</source>
          <target state="translated">比较的案例敏感度。</target>
        </trans-unit>
        <trans-unit id="8647c28bed14fb487e34d3da55fb4ace9c3a88fa" translate="yes" xml:space="preserve">
          <source>CaseRangeStatement</source>
          <target state="translated">CaseRangeStatement</target>
        </trans-unit>
        <trans-unit id="f31bf93714d4f8de709a473ac493e8917fd94741" translate="yes" xml:space="preserve">
          <source>CaseSensitive &lt;code&gt;cs&lt;/code&gt;</source>
          <target state="translated">区分大小写的 &lt;code&gt;cs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82cbdef9815d26de04f79b63bed3258b574ec1e5" translate="yes" xml:space="preserve">
          <source>CaseStatements* &lt;strong id=&quot;cases&quot;&gt;cases&lt;/strong&gt;;</source>
          <target state="translated">CaseStatements * &lt;strong id=&quot;cases&quot;&gt;案例&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="93e81c6075ed3230ff50ed8c47578708810401aa" translate="yes" xml:space="preserve">
          <source>Case_Ignorable</source>
          <target state="translated">Case_Ignorable</target>
        </trans-unit>
        <trans-unit id="744f1d9b60891d9266196d1c3e78b1d6da592b82" translate="yes" xml:space="preserve">
          <source>Cased</source>
          <target state="translated">Cased</target>
        </trans-unit>
        <trans-unit id="f3d4dffe4c9ebac969ee4f02157e5740619b3299" translate="yes" xml:space="preserve">
          <source>Casing</source>
          <target state="translated">Casing</target>
        </trans-unit>
        <trans-unit id="fdce1732b6c6c14b93a5e9a8f896d5e70598b645" translate="yes" xml:space="preserve">
          <source>Cast Expressions</source>
          <target state="translated">铸造表情</target>
        </trans-unit>
        <trans-unit id="1be1f5579be197b60f4cbccf065fa7be7bb581e6" translate="yes" xml:space="preserve">
          <source>Cast Operator Overloading</source>
          <target state="translated">铸件操作人员超载</target>
        </trans-unit>
        <trans-unit id="5a95ed2864a76fc66062c5a7f51b3cb5c4d55c8a" translate="yes" xml:space="preserve">
          <source>Cast Operators</source>
          <target state="translated">铸造操作员</target>
        </trans-unit>
        <trans-unit id="ca826936bee948f2eb775d1f8e1ae92d516c0afe" translate="yes" xml:space="preserve">
          <source>Cast is not necessary if the type of the variable is inferred. See the example below.</source>
          <target state="translated">如果变量的类型是推断出来的,则不需要Cast。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="25e55b52ee2f3dc95810f24ff7dd2b0e1de46b08" translate="yes" xml:space="preserve">
          <source>CastExpression</source>
          <target state="translated">CastExpression</target>
        </trans-unit>
        <trans-unit id="f137db9c32541b4a024e2e40ec97ea3e4571d7c9" translate="yes" xml:space="preserve">
          <source>Casting a class object to an interface consists of adding the offset of the interface's corresponding vptr to the address of the base of the object. Casting an interface ptr back to the class type it came from involves getting the correct offset to subtract from it from the object.Interface entry at vtbl[0]. Adjustor thunks are created and pointers to them stored in the method entries in the vtbl[] in order to set the this pointer to the start of the object instance corresponding to the implementing method.</source>
          <target state="translated">将一个类对象投向一个接口,包括将接口对应的vptr的偏移量加到对象的基地址上。将一个接口ptr投回它来自的类类型,涉及到从对象中得到正确的偏移量来减去它.接口条目在vtbl[0]。创建调整器thunks,并将其指针存储在vtbl[]的方法条目中,以便将该指针设置为对应于实现方法的对象实例的开始。</target>
        </trans-unit>
        <trans-unit id="2be16817be1151d2bfd103342ffb9b83c9bc8eec" translate="yes" xml:space="preserve">
          <source>Casting a dynamic array to another dynamic array is done only if the array lengths multiplied by the element sizes match. The cast is done as a type paint, with the array length adjusted to match any change in element size. If there's not a match, a runtime error is generated.</source>
          <target state="translated">只有当一个动态数组的长度乘以元素大小匹配时,才会将一个动态数组投射到另一个动态数组。投放是以类型画的方式进行的,并调整数组长度以匹配元素大小的任何变化。如果不匹配,会产生一个运行时错误。</target>
        </trans-unit>
        <trans-unit id="16edfc7539440dbdc02f7a14941c4d5ef8ef9a5e" translate="yes" xml:space="preserve">
          <source>Casting a floating point literal from one type to another changes its type, but internally it is retained at full precision for the purposes of constant folding.</source>
          <target state="translated">将一个浮点文字从一个类型投向另一个类型,会改变它的类型,但在内部会保留全精度,以达到不断折叠的目的。</target>
        </trans-unit>
        <trans-unit id="11324dd9fa7b8d9c53df605d6416fafef2a68188" translate="yes" xml:space="preserve">
          <source>Casting a floating point value to an integral type is the equivalent of converting to an integer using truncation.</source>
          <target state="translated">将浮点值转为积分类型相当于用截断法转换为整数。</target>
        </trans-unit>
        <trans-unit id="f259cd40444c3107ae944acf4631f694eae6b61d" translate="yes" xml:space="preserve">
          <source>Casting a pointer type to and from a class type is done as a type paint (i.e. a reinterpret cast).</source>
          <target state="translated">将一个指针类型投向一个类类型和从一个类类型投向一个类类型,是作为一个类型画来完成的(即重新解释投向)。</target>
        </trans-unit>
        <trans-unit id="67471401dacb96c319b67d90467f1e1ec414ef57" translate="yes" xml:space="preserve">
          <source>Casting a value</source>
          <target state="translated">投放一个值</target>
        </trans-unit>
        <trans-unit id="c6340b2b57764ca857638ab68adda2ab272e357c" translate="yes" xml:space="preserve">
          <source>Casting an expression to &lt;code&gt;void&lt;/code&gt; type is allowed to mark that the result is unused. On &lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement&lt;/i&gt;&lt;/a&gt;, it could be used properly to avoid &quot;has no effect&quot; error.</source>
          <target state="translated">将表达式强制转换为 &lt;code&gt;void&lt;/code&gt; 类型可以标记未使用的结果。在&lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement上&lt;/i&gt;&lt;/a&gt;，可以正确使用它来避免&amp;ldquo;没有效果&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="01335a9c442d0255ed0b8bd54d5bf5a26e8b8dab" translate="yes" xml:space="preserve">
          <source>Casting operator to integral, &lt;code&gt;bool&lt;/code&gt;, or floating point type. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpCast&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt;. Otherwise, casting to &lt;code&gt;bool&lt;/code&gt; yields &lt;code&gt; get != 0&lt;/code&gt; and casting to another integral that can represent all values of &lt;code&gt;T&lt;/code&gt; returns &lt;code&gt;get&lt;/code&gt; promoted to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">将运算符 &lt;code&gt;bool&lt;/code&gt; 转换为整型，布尔型或浮点型。如果 &lt;code&gt;Hook&lt;/code&gt; 定义了 &lt;code&gt;hookOpCast&lt;/code&gt; ，则调用将立即返回 &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; 。否则，铸造 &lt;code&gt;bool&lt;/code&gt; 的产量 &lt;code&gt; get != 0&lt;/code&gt; ，铸造到另一个不可或缺的，可以代表所有值 &lt;code&gt;T&lt;/code&gt; 的回报 &lt;code&gt;get&lt;/code&gt; 提升到 &lt;code&gt;U&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="563db6d9dd42954287b5cda42119295bd4e28aa4" translate="yes" xml:space="preserve">
          <source>Casting pointers to non-pointers and vice versa is allowed.</source>
          <target state="translated">允许将指针投向非指针,反之亦然。</target>
        </trans-unit>
        <trans-unit id="e8c8325b9ae374bf1edc7d50c4d5a016a9981e5a" translate="yes" xml:space="preserve">
          <source>Casting to a &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; replaces the qualifiers to the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;强制&lt;/i&gt;&lt;/a&gt;转换为&lt;i&gt;CastQual会将限定符&lt;/i&gt;替换为&lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="3d98bf7b9cde5141dc8af74c8c9759ef593ae47b" translate="yes" xml:space="preserve">
          <source>Casting to/from &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; may break type system guarantees. Use with care.</source>
          <target state="translated">从 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;immutable&lt;/code&gt; 类型进行转换可能会破坏类型的系统保证。小心使用。</target>
        </trans-unit>
        <trans-unit id="b02f79fb40c6ba2556a5ea0081aed386869f0012" translate="yes" xml:space="preserve">
          <source>Casting with no &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; or &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; removes any top level &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;inout&lt;/code&gt; type modifiers from the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">没有&lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt;或&lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual的强制&lt;/i&gt;&lt;/a&gt;&lt;i&gt;类型&lt;/i&gt;&lt;i&gt;转换&lt;/i&gt;会从&lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;的类型中删除任何顶级 &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;immutable&lt;/code&gt; ， &lt;code&gt;shared&lt;/code&gt; 或 &lt;code&gt;inout&lt;/code&gt; 类型修饰符。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="5591322bc1301d82b541b6b5ad169c351dc74a45" translate="yes" xml:space="preserve">
          <source>Casts a mutable array to an immutable array in an idiomatic manner. Technically, &lt;code&gt;assumeUnique&lt;/code&gt; just inserts a cast, but its name documents assumptions on the part of the caller. &lt;code&gt;assumeUnique(arr)&lt;/code&gt; should only be called when there are no more active mutable aliases to elements of &lt;code&gt; arr&lt;/code&gt;. To strengthen this assumption, &lt;code&gt;assumeUnique(arr)&lt;/code&gt; also clears &lt;code&gt;arr&lt;/code&gt; before returning. Essentially &lt;code&gt; assumeUnique(arr)&lt;/code&gt; indicates commitment from the caller that there is no more mutable access to any of &lt;code&gt;arr&lt;/code&gt;'s elements (transitively), and that all future accesses will be done through the immutable array returned by &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">以惯用方式将可变数组转换为不可变数组。从技术上讲， &lt;code&gt;assumeUnique&lt;/code&gt; 只是插入一个强制转换，但是其名称记录了调用方的假设。仅当不再存在 &lt;code&gt; arr&lt;/code&gt; 元素的活动可变别名时，才应调用 &lt;code&gt;assumeUnique(arr)&lt;/code&gt; 。为了加强这一假设，假定 &lt;code&gt;assumeUnique(arr)&lt;/code&gt; 在返回之前也清除了 &lt;code&gt;arr&lt;/code&gt; 。本质上， &lt;code&gt; assumeUnique(arr)&lt;/code&gt; 指示调用方承诺不再（传递地）对 &lt;code&gt;arr&lt;/code&gt; 的任何元素进行可变访问，并且所有将来的访问都将通过 &lt;code&gt;assumeUnique&lt;/code&gt; 返回的不可变数组完成。</target>
        </trans-unit>
        <trans-unit id="96fd17cf1de8b408679f9b1db49477fb8f0c66b6" translate="yes" xml:space="preserve">
          <source>Casts that break the type system.</source>
          <target state="translated">打破类型体系的铸造。</target>
        </trans-unit>
        <trans-unit id="bc260f3af1fc6e8bf46c5b8f8a854fbc6153096b" translate="yes" xml:space="preserve">
          <source>Cat Expressions</source>
          <target state="translated">猫的表情</target>
        </trans-unit>
        <trans-unit id="a953a29fa47d85867e2fab2716c48cee491dd470" translate="yes" xml:space="preserve">
          <source>CatExpression</source>
          <target state="translated">CatExpression</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="d3ce6d6c33d89c5cd835012c244acc4d8b858a0e" translate="yes" xml:space="preserve">
          <source>CatchParameter</source>
          <target state="translated">CatchParameter</target>
        </trans-unit>
        <trans-unit id="5e59a1d3b6be9c8f0e29f469cc4ebfb54cc7e205" translate="yes" xml:space="preserve">
          <source>Catches</source>
          <target state="translated">Catches</target>
        </trans-unit>
        <trans-unit id="f1645524550ec6b1dbf604c910de525c1199c393" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned and &lt;code&gt;result&lt;/code&gt; is set to the result of the expression.</source>
          <target state="translated">捕获并返回从给定表达式引发的异常。如果未引发任何异常，则返回null并将 &lt;code&gt;result&lt;/code&gt; 设置为表达式的结果。</target>
        </trans-unit>
        <trans-unit id="040c55a2a9c3c731e36a7abc0e21f539bc1f80a5" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">捕获并返回从给定表达式引发的异常。如果没有引发异常，则返回null。 &lt;code&gt;E&lt;/code&gt; 可以是 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d90ffac3b749155c40310e22300174e6246501c0" translate="yes" xml:space="preserve">
          <source>Catches the exception thrown from the given expression and returns the msg property of that exception. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">捕获从给定表达式引发的异常，并返回该异常的msg属性。如果没有引发异常，则返回null。 &lt;code&gt;E&lt;/code&gt; 可以是 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73a0dfe4cefda0d8bb54b75566ce6c7751cb0769" translate="yes" xml:space="preserve">
          <source>Catching C++ Class Objects</source>
          <target state="translated">捕捉C++类对象</target>
        </trans-unit>
        <trans-unit id="df7467bf765f309d90be05cf8631fc4bacfe7590" translate="yes" xml:space="preserve">
          <source>Categories of types</source>
          <target state="translated">类型类别</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="729cda91611ce285ba0ef14cc4efdd486065b7fa" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an</source>
          <target state="translated">导致汇编器发出NOP指令,以对齐下一条汇编器指令。</target>
        </trans-unit>
        <trans-unit id="147c8bbdbf1f140f88bd53dffd29cf82c9997a05" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an even boundary.</source>
          <target state="translated">使汇编器发出NOP指令,将下一条汇编器指令对准偶数边界。</target>
        </trans-unit>
        <trans-unit id="70c5dda624176ab62b854d62901ed2b2ed8a9f72" translate="yes" xml:space="preserve">
          <source>Causes the compiler to not generate the function prolog and epilog sequences. This means such is the responsibility of inline assembly programmer, and is normally used when the entire function is to be written in assembler.</source>
          <target state="translated">导致编译器不生成函数的prolog和epilog序列。这意味着这种情况是内联汇编程序员的责任,通常在整个函数要用汇编程序编写时使用。</target>
        </trans-unit>
        <trans-unit id="1fd6a880ee16bb33003559b204f8a2cff5a9e90c" translate="yes" xml:space="preserve">
          <source>Cc</source>
          <target state="translated">Cc</target>
        </trans-unit>
        <trans-unit id="51f00921e108b6ca8be5e3997778036a6ec831aa" translate="yes" xml:space="preserve">
          <source>Cells in the delimiter row contain hyphens (&lt;code&gt;-&lt;/code&gt;) and optional colons (&lt;code&gt;:&lt;/code&gt;). A &lt;code&gt;:&lt;/code&gt; to the left of the hyphens creates a left-aligned column, a &lt;code&gt;:&lt;/code&gt; to the right of the hyphens creates a right-aligned column (like the example above), and &lt;code&gt;:&lt;/code&gt;'s on both sides of the hyphens create a center-aligned column.</source>
          <target state="translated">定界符行中单元格中包含连字符（ &lt;code&gt;-&lt;/code&gt; ）和可选的冒号（ &lt;code&gt;:&lt;/code&gt; ）。连字符左侧的A &lt;code&gt;:&lt;/code&gt; 创建一个左对齐的列，连字符右侧的a &lt;code&gt;:&lt;/code&gt; 创建一个右对齐的列（如上面的示例），而连字符两侧的 &lt;code&gt;:&lt;/code&gt; 都创建一个中心-对齐的列。</target>
        </trans-unit>
        <trans-unit id="20b2af77551ab62ecafee8361a6775168a8911be" translate="yes" xml:space="preserve">
          <source>Centaur Isiah = VIA Nano (family 6, model F) is an out-of-order core.</source>
          <target state="translated">Centaur Isiah=VIA Nano(家族6,型号F)是一个失序的核心。</target>
        </trans-unit>
        <trans-unit id="8408f82534bfffd0ab07188fc9d719f71130e4e0" translate="yes" xml:space="preserve">
          <source>Center &lt;code&gt;s&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;s&lt;/code&gt; doesn't fill.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 在字段 &lt;code&gt;width&lt;/code&gt; 居中字符宽。 &lt;code&gt;fillChar&lt;/code&gt; 是将用于填充 &lt;code&gt;s&lt;/code&gt; 不会填充的字段中的字符的字符。</target>
        </trans-unit>
        <trans-unit id="4e74b6056afd83cbdf235c0e1e1aa022d7643f34" translate="yes" xml:space="preserve">
          <source>Center justify &lt;code&gt;r&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;r&lt;/code&gt; doesn't fill.</source>
          <target state="translated">在字段 &lt;code&gt;width&lt;/code&gt; 字符宽度居中对齐 &lt;code&gt;r&lt;/code&gt; 。 &lt;code&gt;fillChar&lt;/code&gt; 是将用于填充 &lt;code&gt;r&lt;/code&gt; 未填充的字段中的字符的字符。</target>
        </trans-unit>
        <trans-unit id="fb14d77020e4dbef1a189a81fe3dbc04509cb2d1" translate="yes" xml:space="preserve">
          <source>Certain alphabets like German and Greek have no 1:1 upper-lower mapping. Use overload of toUpper which takes full string instead.</source>
          <target state="translated">某些字母,如德语和希腊语,没有1:1的上下层映射。使用toUpper的重载,它可以取全字符串代替。</target>
        </trans-unit>
        <trans-unit id="64a2e3e9bc5b4cd297d23de932339bb6c474455f" translate="yes" xml:space="preserve">
          <source>Cf</source>
          <target state="translated">Cf</target>
        </trans-unit>
        <trans-unit id="70b3ae21ee59942a0d41812e09cc5d908774f36f" translate="yes" xml:space="preserve">
          <source>Chain multiple calls to ifThrown, each capturing errors from the entire preceding expression.</source>
          <target state="translated">对ifThrown进行多次链式调用,每次调用都会从前面的整个表达式中捕获错误。</target>
        </trans-unit>
        <trans-unit id="6a803e5d1d5407c176b6adb93c4ec23f4ef3c32f" translate="yes" xml:space="preserve">
          <source>Chakma</source>
          <target state="translated">Chakma</target>
        </trans-unit>
        <trans-unit id="5e052ac9c7fd6c9d46817ea48b907dbb7047ae81" translate="yes" xml:space="preserve">
          <source>Cham</source>
          <target state="translated">Cham</target>
        </trans-unit>
        <trans-unit id="458b3d4cc82936041a171ad6f7ca77493ddeb2bd" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and Posix.</source>
          <target state="translated">将目录更改为 &lt;code&gt;pathname&lt;/code&gt; 。与Windows和Posix 上的 &lt;code&gt;cd&lt;/code&gt; 等效。</target>
        </trans-unit>
        <trans-unit id="6f314cb3c24c1c8ee48dc8abfd534cc520363d6c" translate="yes" xml:space="preserve">
          <source>Change match (fnmatch-like) callback for wildcard matching</source>
          <target state="translated">改变匹配(类似fnmatch)的回调,用于通配符匹配。</target>
        </trans-unit>
        <trans-unit id="e8304f2bae085deed1b3c8125f9fa43407a675db" translate="yes" xml:space="preserve">
          <source>Change the IEEE754 floating-point rounding mode and the floating-point hardware exceptions.</source>
          <target state="translated">改变IEEE754浮点运算模式和浮点硬件异常。</target>
        </trans-unit>
        <trans-unit id="9f333c0a78429177429051909d1f599b48a73b54" translate="yes" xml:space="preserve">
          <source>Change the floating-point hardware rounding mode</source>
          <target state="translated">改变浮点硬件取整模式</target>
        </trans-unit>
        <trans-unit id="3d9d32d43390d1a2629123edfc32deb49f461b6a" translate="yes" xml:space="preserve">
          <source>Change the key on an open database. If the current database is not encrypted, this routine will encrypt it. If pNew == 0 or nNew == 0, the database is decrypted.</source>
          <target state="translated">更改打开的数据库的密钥。如果当前数据库没有加密,这个例程将对其进行加密。如果pNew ==0或nNew ==0,数据库将被解密。</target>
        </trans-unit>
        <trans-unit id="5ba310a0f8acd1b8bbbdaa00b70d0bff2f5990f6" translate="yes" xml:space="preserve">
          <source>Change this function so the caller doesn't have to be aware of this issue. Either return by value and expect the caller to always check the base ptr as an indication of whether the struct is valid, or set the BlkInfo as a side-effect and return a bool to indicate success.</source>
          <target state="translated">修改这个函数,使调用者不必意识到这个问题。要么按值返回,并期望调用者总是检查base ptr作为结构是否有效的指示,要么将BlkInfo设置为副作用,并返回一个bool表示成功。</target>
        </trans-unit>
        <trans-unit id="e7d3b1db7f0a311580f3e633ae63903d1a427f37" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; arguments are not propagated to the call site, only to &lt;code&gt;args&lt;/code&gt; in this struct.</source>
          <target state="translated">对 &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 参数的更改不会传播到调用站点，而只会传播到此结构中的 &lt;code&gt;args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c06a1392ead6cea3258d7b832ab861bbcb2d0e3" translate="yes" xml:space="preserve">
          <source>Changing the rounding mode in the middle of a function can interfere with optimizations of floating point expressions, as the optimizer assumes that the rounding mode does not change. It is best to change the rounding mode only at the beginning of the function, and keep it until the function returns. It is also best to add the line:</source>
          <target state="translated">在函数中间改变四舍五入模式会干扰浮点表达式的优化,因为优化器假定四舍五入模式不会改变。最好只在函数开始时改变四舍五入模式,并保持到函数返回。也最好加上这一行。</target>
        </trans-unit>
        <trans-unit id="0f9ba953e35135a3f8ec268817cc92f2557202a9" translate="yes" xml:space="preserve">
          <source>Char</source>
          <target state="translated">Char</target>
        </trans-unit>
        <trans-unit id="c6b74142b3b389f15ac5cd805f70960cc3a1abf0" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">字符[] &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d66a912fb521a267fef61e2619d881aa8e9c5935" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">炭[] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516088a32b97fe8b60ae41af7a9da5ea8c8b89b1" translate="yes" xml:space="preserve">
          <source>Character Entities</source>
          <target state="translated">字符实体</target>
        </trans-unit>
        <trans-unit id="669b19e596ff87d2ed122a5266e7aff0c3d614e2" translate="yes" xml:space="preserve">
          <source>Character Literals</source>
          <target state="translated">字符</target>
        </trans-unit>
        <trans-unit id="2760308a0f6d1684065a6510212e96dc91848ae1" translate="yes" xml:space="preserve">
          <source>Character Set</source>
          <target state="translated">字符集</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">角色类</target>
        </trans-unit>
        <trans-unit id="ad3c933b2dd70972eec55e516f2ae9ffae669d0e" translate="yes" xml:space="preserve">
          <source>Character classification by category and common properties: &lt;a href=&quot;#isAlpha&quot;&gt;&lt;code&gt;isAlpha&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="translated">按类别和常见属性对字符进行分类：&lt;a href=&quot;#isAlpha&quot;&gt; &lt;code&gt;isAlpha&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; &lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="1ef00f56499c816e60a9c87369bcd2210570f41d" translate="yes" xml:space="preserve">
          <source>Character input ranges</source>
          <target state="translated">字符输入范围</target>
        </trans-unit>
        <trans-unit id="133c67a5c003572ca8daaddcc62800905a7a14d7" translate="yes" xml:space="preserve">
          <source>Character literals are a single character or escape sequence enclosed by single quotes.</source>
          <target state="translated">字符是由单引号括起来的单个字符或转义序列。</target>
        </trans-unit>
        <trans-unit id="aa8ec24f3290e6543c77a63504c45b69a0237e5a" translate="yes" xml:space="preserve">
          <source>Character literals are single characters and resolve to one of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;. If the literal is a &lt;code&gt;\u&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;wchar&lt;/code&gt;. If the literal is a &lt;code&gt;\U&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;dchar&lt;/code&gt;. Otherwise, it resolves to the type with the smallest size it will fit into.</source>
          <target state="translated">字符文字是单个字符，并且解析为 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;wchar&lt;/code&gt; 或 &lt;code&gt;dchar&lt;/code&gt; 类型之一。如果文字是 &lt;code&gt;\u&lt;/code&gt; 转义序列，则解析为 &lt;code&gt;wchar&lt;/code&gt; 类型。如果文字是 &lt;code&gt;\U&lt;/code&gt; 转义序列，则解析为 &lt;code&gt;dchar&lt;/code&gt; 类型。否则，它将解析为将适合的最小大小的类型。</target>
        </trans-unit>
        <trans-unit id="3748669139d2553c2dce70085bc8d87e3b65bf04" translate="yes" xml:space="preserve">
          <source>Character to insert between digits.</source>
          <target state="translated">要在数字之间插入的字符。</target>
        </trans-unit>
        <trans-unit id="b03707df5e411692fe21adde8672bde4c3d712ec" translate="yes" xml:space="preserve">
          <source>Character traits classes specify character properties and provide specific semantics for certain operations on characters and sequences of characters.</source>
          <target state="translated">字符特征类规定了字符属性,并为字符和字符序列的某些操作提供特定的语义。</target>
        </trans-unit>
        <trans-unit id="7d08e774321e793244bcf20b89151a8c5636ee9d" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">每行的字符类型，默认为 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3ea2c19a4eb8af5f3f4d555aac37a5f0f405718" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;immutable char&lt;/code&gt;.</source>
          <target state="translated">每行的字符类型，默认为 &lt;code&gt;immutable char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fe23e4b9b84f174b905f70c10737ea338eb6786" translate="yes" xml:space="preserve">
          <source>Characters and Entities</source>
          <target state="translated">人物和实体</target>
        </trans-unit>
        <trans-unit id="407259c6fa72a57c5df67c0a931d6eaafa218825" translate="yes" xml:space="preserve">
          <source>Characters and Escape Macros</source>
          <target state="translated">字符和转义宏</target>
        </trans-unit>
        <trans-unit id="e688823a84fa6f43670fb82f99c26f690e6bccb5" translate="yes" xml:space="preserve">
          <source>Cheat Sheet</source>
          <target state="translated">小抄</target>
        </trans-unit>
        <trans-unit id="98fea9560fa564556454626729a76607af1a8cca" translate="yes" xml:space="preserve">
          <source>Check access to d for expression e.d Returns true if the declaration is not accessible.</source>
          <target state="translated">检查对表达式e.d的访问情况 如果声明不可访问,则返回true。</target>
        </trans-unit>
        <trans-unit id="992d8a3514d4f8fb1a7565ecd89e7c7459b088b7" translate="yes" xml:space="preserve">
          <source>Check access to package/module &lt;code&gt;p&lt;/code&gt; from scope &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">检查从范围 &lt;code&gt;sc&lt;/code&gt; 对包/模块 &lt;code&gt;p&lt;/code&gt; 的访问。</target>
        </trans-unit>
        <trans-unit id="eda17044e9450b32ce8d657d8c476e2e931877a8" translate="yes" xml:space="preserve">
          <source>Check an entire XML document for well-formedness</source>
          <target state="translated">检查整个XML文档的格式良好性。</target>
        </trans-unit>
        <trans-unit id="d970e5fd0eca0560f8d7376c859148711be4729a" translate="yes" xml:space="preserve">
          <source>Check for special enum names.</source>
          <target state="translated">检查特殊的枚举名。</target>
        </trans-unit>
        <trans-unit id="2d3f64068fd53c1e2cf2c76775f8f8fabfefbbfd" translate="yes" xml:space="preserve">
          <source>Check for unsafe access in @safe code: 1. read overlapped pointers 2. write misaligned pointers 3. write overlapped storage classes Print error if unsafe.</source>
          <target state="translated">检查@安全代码中的不安全访问。1.读取重叠的指针 2.写入错误对齐的指针 3.写入重叠的存储类 如果不安全则打印错误。</target>
        </trans-unit>
        <trans-unit id="7c0bee715813745db32b38bbccf3a069246cf610" translate="yes" xml:space="preserve">
          <source>Check given aggregate actually has an identity opAssign or not.</source>
          <target state="translated">检查给定的集合是否真的有一个身份的opAssign。</target>
        </trans-unit>
        <trans-unit id="3858f175449bae14406b7154904a8462b908a3ad" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;this&lt;/code&gt; is in the null state.</source>
          <target state="translated">检查 &lt;code&gt;this&lt;/code&gt; 是否处于空状态。</target>
        </trans-unit>
        <trans-unit id="076573205d4206fc69ab2dc4fcc4e09a0f119e4b" translate="yes" xml:space="preserve">
          <source>Check if a symbol is visible from a given scope without taking into account the most visible overload.</source>
          <target state="translated">检查一个符号是否从给定的作用域可见,而不考虑最可见的过载。</target>
        </trans-unit>
        <trans-unit id="62479c6f09569fa4521b5d1a5251de698f6fa595" translate="yes" xml:space="preserve">
          <source>Check if an &lt;code&gt;alias this&lt;/code&gt; is deprecated</source>
          <target state="translated">检查是否不建议使用 &lt;code&gt;alias this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2bab44045df4b9981599697a77f678e9b3ebdf8e" translate="yes" xml:space="preserve">
          <source>Check if any elements exist in the container. Returns &lt;code&gt;false&lt;/code&gt; if at least one element exists.</source>
          <target state="translated">检查容器中是否存在任何元素。如果存在至少一个元素，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eee93ccff6c0e0b4aa6087370d984e43f3308e9" translate="yes" xml:space="preserve">
          <source>Check if the file the &lt;code&gt;path&lt;/code&gt; points to exists</source>
          <target state="translated">检查 &lt;code&gt;path&lt;/code&gt; 指向的文件是否存在</target>
        </trans-unit>
        <trans-unit id="7ac10cbe580bb712b906c15722c15b6e0026c3e6" translate="yes" xml:space="preserve">
          <source>Check if the function &lt;code&gt;F&lt;/code&gt; is calleable in a &lt;code&gt;nothrow&lt;/code&gt; scope.</source>
          <target state="translated">检查功能 &lt;code&gt;F&lt;/code&gt; 处于calleable &lt;code&gt;nothrow&lt;/code&gt; 范围。</target>
        </trans-unit>
        <trans-unit id="64f568a0788eaf3c104e4f61c0874d4d74f59f4e" translate="yes" xml:space="preserve">
          <source>Check if the last template parameter is a tuple one, and returns it if so, else returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">检查最后一个模板参数是否为元组，如果是，则返回它，否则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="188659108f60184522d74ac9e6ab3f12baec9896" translate="yes" xml:space="preserve">
          <source>Check if the type &lt;code&gt;T&lt;/code&gt;'s postblit is called in nothrow, if it exist</source>
          <target state="translated">检查类型 &lt;code&gt;T&lt;/code&gt; 的postblit是否在nothrow中调用（如果存在）</target>
        </trans-unit>
        <trans-unit id="af7a4c6a5c2ba8859b2cd5a292e2e803c480f264" translate="yes" xml:space="preserve">
          <source>Check parameters and return type of D main() function. Issue error messages.</source>
          <target state="translated">检查D main()函数的参数和返回类型。发布错误信息。</target>
        </trans-unit>
        <trans-unit id="44068e2d631fa41db726b0ad86a2506b1696fdd4" translate="yes" xml:space="preserve">
          <source>Check struct constructor of the form &lt;code&gt;s.this(args)&lt;/code&gt;, by checking each &lt;code&gt;return&lt;/code&gt; parameter to see if it gets assigned to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">通过检查每个 &lt;code&gt;return&lt;/code&gt; 参数以查看是否将其分配给 &lt;code&gt;s&lt;/code&gt; ,从而检查 &lt;code&gt;s.this(args)&lt;/code&gt; 形式的struct构造函数。</target>
        </trans-unit>
        <trans-unit id="e9ca07e85195a45175df8f93c70295e0d597f076" translate="yes" xml:space="preserve">
          <source>Check that an email address conforms to RFCs 5321, 5322 and others.</source>
          <target state="translated">检查电子邮件地址是否符合RFC5321、5322等标准。</target>
        </trans-unit>
        <trans-unit id="96a4caea4b58f9a696a9fa2d9139cbc448939376" translate="yes" xml:space="preserve">
          <source>Check that the expression has a valid type. If not, generates an error &quot;... has no type&quot;.</source>
          <target state="translated">检查表达式是否有一个有效的类型。如果没有,则产生错误&quot;...没有类型&quot;。</target>
        </trans-unit>
        <trans-unit id="72c3f1230ce767eb6fa0da10917246e5895c0d26" translate="yes" xml:space="preserve">
          <source>Check that the expression has a valid value. If not, generates an error &quot;... has no value&quot;.</source>
          <target state="translated">检查表达式是否有有效值。如果没有,则产生错误&quot;......没有值&quot;。</target>
        </trans-unit>
        <trans-unit id="dcdeb8730ffac94e46f7144e685915d89bb60d12" translate="yes" xml:space="preserve">
          <source>Check that the function contains any closure. If it's @nogc, report suitable errors. This is mostly consistent with FuncDeclaration::needsClosure().</source>
          <target state="translated">检查该函数是否包含任何闭包。如果是@nogc,报告适当的错误。这与FuncDeclaration::needsClosure()基本一致。</target>
        </trans-unit>
        <trans-unit id="a439ace69e6b39c914e8a0f30a7839c881b0b42e" translate="yes" xml:space="preserve">
          <source>Check that the postblit is callable if t is an array of structs. Returns true if error happens.</source>
          <target state="translated">如果t是一个结构数组,检查postblit是否可以调用。如果发生错误,返回true。</target>
        </trans-unit>
        <trans-unit id="a636a07f4f3d9c05ce29614c151925a9aeb57b2d" translate="yes" xml:space="preserve">
          <source>Check that there are no uses of arrays without [].</source>
          <target state="translated">检查有没有使用不带[]的数组。</target>
        </trans-unit>
        <trans-unit id="0af7c63ae853953456799e62f8dd988319b13c2e" translate="yes" xml:space="preserve">
          <source>Check that this function type is properly resolved. If not, report &quot;forward reference error&quot; and return true.</source>
          <target state="translated">检查该函数类型是否正确解析。如果没有,报告 &quot;正向引用错误 &quot;并返回true。</target>
        </trans-unit>
        <trans-unit id="dc26a5cb1e94e18dd7bae9c48ba4424f2687029b" translate="yes" xml:space="preserve">
          <source>Check to see if constraint is satisfied.</source>
          <target state="translated">检查是否满足约束条件。</target>
        </trans-unit>
        <trans-unit id="2e9e70f18c437515a642e7710d6acf41c2b8a612" translate="yes" xml:space="preserve">
          <source>Check to see if declaration can be modified in this context (sc). Issue error if not.</source>
          <target state="translated">检查是否可以在此上下文(sc)中修改声明。如果不能,则发出错误。</target>
        </trans-unit>
        <trans-unit id="51115eb7becb93e1ed9565c740be9cbe2b13d39d" translate="yes" xml:space="preserve">
          <source>Check to see if this variable is actually in an enclosing function rather than the current one. Returns true if error occurs.</source>
          <target state="translated">检查这个变量是否在一个包围函数中,而不是在当前函数中。如果发生错误,返回true。</target>
        </trans-unit>
        <trans-unit id="c9e9e80b6fb0bcd2c2078fcf4d43cd2c78a6fad0" translate="yes" xml:space="preserve">
          <source>Check to see the aggregate type is nested and its context pointer is accessible from the current scope. Returns true if error occurs.</source>
          <target state="translated">检查集合类型是否嵌套,其上下文指针是否可以从当前作用域访问。如果发生错误,返回true。</target>
        </trans-unit>
        <trans-unit id="4f9c3759a0e90a57282f3d4825c0a253d6bfa729" translate="yes" xml:space="preserve">
          <source>Check type to see if it is based on a deprecated symbol.</source>
          <target state="translated">检查类型,看它是否基于废弃的符号。</target>
        </trans-unit>
        <trans-unit id="3bebff7bd9c6f992a862c3947845278a778590d5" translate="yes" xml:space="preserve">
          <source>Check whether a number is an integer power of two.</source>
          <target state="translated">检查一个数字是否是二的整数倍。</target>
        </trans-unit>
        <trans-unit id="68ee613e321cfb260a31b167d7e8362d6611b9ba" translate="yes" xml:space="preserve">
          <source>Check whether a thread was created by &lt;code&gt;createLowLevelThread&lt;/code&gt;.</source>
          <target state="translated">检查是否由 &lt;code&gt;createLowLevelThread&lt;/code&gt; 创建了线程。</target>
        </trans-unit>
        <trans-unit id="81773160380ee69dcc483492366b6c611e0a1eed" translate="yes" xml:space="preserve">
          <source>Check whether symbols &lt;code&gt;s&lt;/code&gt; is visible in &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">检查符号 &lt;code&gt;s&lt;/code&gt; 是否在 &lt;code&gt;mod&lt;/code&gt; 中可见。</target>
        </trans-unit>
        <trans-unit id="16a4ea9c15d653616cd1ab89eeb1d07e1733ed47" translate="yes" xml:space="preserve">
          <source>Check whether the expression allows RMW operations, error with rmw operator diagnostic if not. ex is the RHS expression, or NULL if ++/-- is used (for diagnostics) Returns true if error occurs.</source>
          <target state="translated">检查表达式是否允许进行RMW操作,如果不允许,则用rmw操作符诊断错误。ex是RHS表达式,如果使用++/--,则为NULL(用于诊断)如果发生错误,则返回true。</target>
        </trans-unit>
        <trans-unit id="c3f04bc3752d2690dd0208e77754d66e24067224" translate="yes" xml:space="preserve">
          <source>Check whether the given Unicode code point is valid.</source>
          <target state="translated">检查给定的Unicode码点是否有效。</target>
        </trans-unit>
        <trans-unit id="967bb865d76cb5dec46effc4ddf3db69dd7bd8b3" translate="yes" xml:space="preserve">
          <source>Check whether the tuple &lt;code&gt;T&lt;/code&gt; is a type tuple. A type tuple only contains types.</source>
          <target state="translated">检查元组 &lt;code&gt;T&lt;/code&gt; 是否为类型元组。类型元组仅包含类型。</target>
        </trans-unit>
        <trans-unit id="f2b123f344913046043c7f94d2d9417280390123" translate="yes" xml:space="preserve">
          <source>Check whether the tuple T is an expression tuple. An expression tuple only contains expressions.</source>
          <target state="translated">检查元组T是否是一个表达式元组。表达式元组只包含表达式。</target>
        </trans-unit>
        <trans-unit id="5374967cf17045f818df69f4c4da8c46fb272364" translate="yes" xml:space="preserve">
          <source>Check whether the type t representation relies on one or more the template parameters.</source>
          <target state="translated">检查t类型的表示是否依赖于一个或多个模板参数。</target>
        </trans-unit>
        <trans-unit id="a81260a4f45c118b1ea3d76244c3549c2710e64e" translate="yes" xml:space="preserve">
          <source>CheckDns &lt;code&gt;checkDNS&lt;/code&gt;</source>
          <target state="translated">CheckDns &lt;code&gt;checkDNS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5ad7d1dc4c316626ec88560f3cf3f5028c21c54" translate="yes" xml:space="preserve">
          <source>CheckException &lt;strong id=&quot;err&quot;&gt;err&lt;/strong&gt;;</source>
          <target state="translated">CheckException &lt;strong id=&quot;err&quot;&gt;err&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="102c409f892dccfa7ef03ae04285bb95f236e32f" translate="yes" xml:space="preserve">
          <source>CheckException if the document is not well formed  CheckException's toString() method will yield the complete hierarchy of parse failure (the XML equivalent of a stack trace), giving the line and column number of every failure at every level.</source>
          <target state="translated">如果文档没有很好的形成,CheckException的toString()方法将产生解析失败的完整层次结构(相当于XML的堆栈跟踪),给出每一级失败的行号和列号。</target>
        </trans-unit>
        <trans-unit id="bada63007fff0aeaf5219e5a4263f3c5062820f1" translate="yes" xml:space="preserve">
          <source>Checked integral type wraps an integral &lt;code&gt;T&lt;/code&gt; and customizes its behavior with the help of a &lt;code&gt;Hook&lt;/code&gt; type. The type wrapped must be one of the predefined integrals (unqualified), or another instance of &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">Checked整数类型包装整数 &lt;code&gt;T&lt;/code&gt; 并借助 &lt;code&gt;Hook&lt;/code&gt; 类型自定义其行为。包装的类型必须是预定义的整数之一（不合格），或者是 &lt;code&gt;Checked&lt;/code&gt; 的另一个实例。</target>
        </trans-unit>
        <trans-unit id="b9f346ef13e859da0e17906bab43906e87f9f1a9" translate="yes" xml:space="preserve">
          <source>Checked integral types.</source>
          <target state="translated">检查了整体类型。</target>
        </trans-unit>
        <trans-unit id="3d046d9a56e84f129ac9c3b934c854cf8cc1eede" translate="yes" xml:space="preserve">
          <source>Checked!(T, Hook) &lt;strong id=&quot;checked&quot;&gt;checked&lt;/strong&gt;(Hook = Abort, T)(const T value)</source>
          <target state="translated">（T，Hook）已&lt;strong id=&quot;checked&quot;&gt;检查&lt;/strong&gt;（Hook = Abort，T）（常量T值）</target>
        </trans-unit>
        <trans-unit id="3a56e907097859f145f7eb967d0d6aafc8e25d7a" translate="yes" xml:space="preserve">
          <source>Checked!(T, WithNaN) &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">已检查！（T，WithNaN） &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8b00f7fe2c53994a3c2e16e9fff90f46c54af6d" translate="yes" xml:space="preserve">
          <source>Checkpoint a database</source>
          <target state="translated">检查点数据库</target>
        </trans-unit>
        <trans-unit id="d455be643c887ed2e33c7fa95c88c9c55b8bf01c" translate="yes" xml:space="preserve">
          <source>Checks are being emitted for &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;s</source>
          <target state="translated">检查正在发射用于&lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;小号</target>
        </trans-unit>
        <trans-unit id="7ae407b40a2f1ca0a962e37bda159883f242864f" translate="yes" xml:space="preserve">
          <source>Checks for UDAs on the aggregate symbol itself</source>
          <target state="translated">检查集合符号本身的UDA。</target>
        </trans-unit>
        <trans-unit id="91354966f9286424721ec9c11117e66f02deb883" translate="yes" xml:space="preserve">
          <source>Checks for equality between this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; and the given &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">检查此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;与给定的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;之间是否相等。</target>
        </trans-unit>
        <trans-unit id="41f80afca0aca27fb1227fb2783c707494f14534" translate="yes" xml:space="preserve">
          <source>Checks for mismatching modifiers between &lt;code&gt;lhsMod&lt;/code&gt; and &lt;code&gt;rhsMod&lt;/code&gt; and prints the mismatching modifiers to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">检查 &lt;code&gt;lhsMod&lt;/code&gt; 和 &lt;code&gt;rhsMod&lt;/code&gt; 之间的不匹配修饰符，并将不匹配修饰符输出到 &lt;code&gt;buf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1c54b7f70f2d7dcba8602a7148aa409d68cfd95" translate="yes" xml:space="preserve">
          <source>Checks for the existence of a package.d to set isPkgMod appropriately if isPkgMod == PKG.unknown</source>
          <target state="translated">如果isPkgMod ==PKG.unknown,则检查是否存在一个package.d,以适当地设置isPkgMod。</target>
        </trans-unit>
        <trans-unit id="93f909b0c91d05388ffc9701f547779940f4af50" translate="yes" xml:space="preserve">
          <source>Checks if</source>
          <target state="translated">检查是否</target>
        </trans-unit>
        <trans-unit id="fc3b0d143e6cc80d04881cd701b750744c2dc00b" translate="yes" xml:space="preserve">
          <source>Checks if a value is among a set of values, e.g. &lt;code&gt;if (v.among(1, 2, 3)) // &lt;/code&gt;v&lt;code&gt; is 1, 2 or 3&lt;/code&gt;</source>
          <target state="translated">检查一个值是否在一组值中，例如 &lt;code&gt;if (v.among(1, 2, 3)) // &lt;/code&gt; v &lt;code&gt; is 1, 2 or 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c267ca37e5703f72794d1240b1acbb9cca14995" translate="yes" xml:space="preserve">
          <source>Checks if an &lt;a href=&quot;#AliasSeq&quot;&gt;&lt;code&gt;AliasSeq&lt;/code&gt;&lt;/a&gt; is sorted according to &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">检查&lt;a href=&quot;#AliasSeq&quot;&gt; &lt;code&gt;AliasSeq&lt;/code&gt; &lt;/a&gt;是否根据 &lt;code&gt;cmp&lt;/code&gt; 排序。</target>
        </trans-unit>
        <trans-unit id="73214c70371a5d58586ec872bc8be088ccd2fe8d" translate="yes" xml:space="preserve">
          <source>Checks if both ranges are permutations of each other.</source>
          <target state="translated">检查两个范围是否是彼此的排列组合。</target>
        </trans-unit>
        <trans-unit id="f3bc0ac6ddb23e50ce7a6b35ff0d100ba52bb65c" translate="yes" xml:space="preserve">
          <source>Checks if pkg is a sub-package of this</source>
          <target state="translated">检查 pkg 是否是这个包的子包。</target>
        </trans-unit>
        <trans-unit id="de380b72169766e3bc2056b6702adc831654ea3d" translate="yes" xml:space="preserve">
          <source>Checks if the final segments of two arrays refer to the same place in memory.</source>
          <target state="translated">检查两个数组的最后一段是否指向内存中的同一位置。</target>
        </trans-unit>
        <trans-unit id="922c914c67ac4f89ae28a039917cecb568914ebf" translate="yes" xml:space="preserve">
          <source>Checks if the given range ends with (one of) the given needle(s). The reciprocal of &lt;code&gt;startsWith&lt;/code&gt;.</source>
          <target state="translated">检查给定范围是否以给定针头（之一）结尾。 &lt;code&gt;startsWith&lt;/code&gt; 的倒数。</target>
        </trans-unit>
        <trans-unit id="82ecdaae8fa51f0373d5c72994edf3db1fb3d193" translate="yes" xml:space="preserve">
          <source>Checks if the initial segments of two arrays refer to the same place in memory.</source>
          <target state="translated">检查两个数组的初始段是否指向内存中的同一位置。</target>
        </trans-unit>
        <trans-unit id="82f5a929497edacf0f834d2b14872945ce21c9e0" translate="yes" xml:space="preserve">
          <source>Checks if the two ranges have the same number of elements. This function is optimized to always take advantage of the &lt;code&gt;length&lt;/code&gt; member of either range if it exists.</source>
          <target state="translated">检查两个范围是否具有相同数量的元素。该函数经过优化，可以始终利用任一范围的 &lt;code&gt;length&lt;/code&gt; 成员（如果存在）。</target>
        </trans-unit>
        <trans-unit id="062799729dfffce6238995dbd50b05d58dc3f7e8" translate="yes" xml:space="preserve">
          <source>Checks that the given file or directory name is valid.</source>
          <target state="translated">检查给定的文件或目录名称是否有效。</target>
        </trans-unit>
        <trans-unit id="d27c0f548abb76a4596a54ad7418e7f7fc762d7c" translate="yes" xml:space="preserve">
          <source>Checks to see if &lt;code&gt;str&lt;/code&gt; is well-formed unicode or not.</source>
          <target state="translated">检查 &lt;code&gt;str&lt;/code&gt; 是否为格式正确的unicode。</target>
        </trans-unit>
        <trans-unit id="f34bde45b70b49a2f480574578c1aa032b15dc5b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;os&lt;/code&gt; is the current &lt;a href=&quot;#TargetOS&quot;&gt;&lt;code&gt;TargetOS&lt;/code&gt;&lt;/a&gt;. For &lt;code&gt;TargetOS.all&lt;/code&gt; it will always return true.</source>
          <target state="translated">检查 &lt;code&gt;os&lt;/code&gt; 是否是当前的&lt;a href=&quot;#TargetOS&quot;&gt; &lt;code&gt;TargetOS&lt;/code&gt; &lt;/a&gt;。对于 &lt;code&gt;TargetOS.all&lt;/code&gt; ，它将始终返回true。</target>
        </trans-unit>
        <trans-unit id="c8b948df59e14c40567ac47254a4d5c81976e17a" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;path&lt;/code&gt; is a valid path.</source>
          <target state="translated">检查 &lt;code&gt;path&lt;/code&gt; 是否为有效路径。</target>
        </trans-unit>
        <trans-unit id="dfec60ca2a2292ac998b0be0f2e72d965e16f264" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;r&lt;/code&gt; has &quot;balanced parentheses&quot;, i.e. all instances of &lt;code&gt;lPar&lt;/code&gt; are closed by corresponding instances of &lt;code&gt;rPar&lt;/code&gt;. The parameter &lt;code&gt;maxNestingLevel&lt;/code&gt; controls the nesting level allowed. The most common uses are the default or &lt;code&gt;0&lt;/code&gt;. In the latter case, no nesting is allowed.</source>
          <target state="translated">检查是否 &lt;code&gt;r&lt;/code&gt; 具有&amp;ldquo;平衡括号&amp;rdquo;，即所有实例 &lt;code&gt;lPar&lt;/code&gt; 由相应的实例关闭 &lt;code&gt;rPar&lt;/code&gt; 。参数 &lt;code&gt;maxNestingLevel&lt;/code&gt; 控制所允许的嵌套级别。最常见的用法是default或 &lt;code&gt;0&lt;/code&gt; 。在后一种情况下，不允许嵌套。</target>
        </trans-unit>
        <trans-unit id="77f07080dfad28c7957c689895a88f5ad1226a0f" translate="yes" xml:space="preserve">
          <source>Checks whether a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; is sorted according to the comparison operation &lt;code&gt;less&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;) evaluations of &lt;code&gt;less&lt;/code&gt;.</source>
          <target state="translated">检查是否根据 &lt;code&gt;less&lt;/code&gt; 的比较操作对&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前进范围&lt;/a&gt;进行了排序。执行&amp;Omicron;（ &lt;code&gt;r.length&lt;/code&gt; ）的评价 &lt;code&gt;less&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17bdba71f684446d0078a53b44634a2483390259" translate="yes" xml:space="preserve">
          <source>Checks whether a function has the given attributes attached.</source>
          <target state="translated">检查函数是否有附加的属性。</target>
        </trans-unit>
        <trans-unit id="0f264f7871383b6deeb7f79fa3f8bb65dab34fc2" translate="yes" xml:space="preserve">
          <source>Checks whether a given source object contains pointers or references to a given target object.</source>
          <target state="translated">检查给定源对象是否包含指向给定目标对象的指针或引用。</target>
        </trans-unit>
        <trans-unit id="90ef69351101a70d883b1cc5e529cfe98f43fdde" translate="yes" xml:space="preserve">
          <source>Checks whether the allocator is responsible for the allocation of &lt;code&gt;b&lt;/code&gt;. It does a simple &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) range check. &lt;code&gt;b&lt;/code&gt; should be a buffer either allocated with &lt;code&gt;this&lt;/code&gt; or obtained through other means.</source>
          <target state="translated">检查分配器是否负责 &lt;code&gt;b&lt;/code&gt; 的分配。它执行简单的&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）范围检查。 &lt;code&gt;b&lt;/code&gt; 应该是 &lt;code&gt;this&lt;/code&gt; 分配的缓冲区或通过其他方式获得的缓冲区。</target>
        </trans-unit>
        <trans-unit id="54585d85d511f32526e9e2026456069b0e4b7e33" translate="yes" xml:space="preserve">
          <source>Checks whether the digest has a &lt;code&gt;blockSize&lt;/code&gt; member, which contains the digest's internal block size in bits. It is primarily used by &lt;a href=&quot;std_digest_hmac#HMAC&quot;&gt;&lt;code&gt;std.digest.hmac.HMAC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">检查摘要是否具有 &lt;code&gt;blockSize&lt;/code&gt; 成员，该成员包含摘要的内部块大小（以位为单位）。它主要由&lt;a href=&quot;std_digest_hmac#HMAC&quot;&gt; &lt;code&gt;std.digest.hmac.HMAC&lt;/code&gt; 使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="596a607c7dae9e909d8aa4bbcb358bbecdcb85a4" translate="yes" xml:space="preserve">
          <source>Checks whether the given &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; starts with (one of) the given needle(s) or, if no needles are given, if its front element fulfils predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">检查给定的&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;是否以给定的针（中的一个）开始，或者如果没有给定的针，则其前元素是否满足谓词 &lt;code&gt;pred&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efccb1331db4295c7feab2a66a6d3d82d986e9c3" translate="yes" xml:space="preserve">
          <source>Checks whether the target supports a vector type.</source>
          <target state="translated">检查目标是否支持向量类型。</target>
        </trans-unit>
        <trans-unit id="a42d0788409e166459e51db8b3218d5314bd1d1f" translate="yes" xml:space="preserve">
          <source>Checks whether the target supports the given operation for vectors.</source>
          <target state="translated">检查目标是否支持向量的操作。</target>
        </trans-unit>
        <trans-unit id="442e16f850c6d48d620dd486822aeb8ada3b125a" translate="yes" xml:space="preserve">
          <source>Checks whether type is a vendor-specific fundamental type.</source>
          <target state="translated">确认类型是否是厂商特定的基本类型。</target>
        </trans-unit>
        <trans-unit id="6927568c692c1534ead0f5a190223a7149662ac5" translate="yes" xml:space="preserve">
          <source>Cherokee</source>
          <target state="translated">Cherokee</target>
        </trans-unit>
        <trans-unit id="5b29ec40fe722116395b446baa3ca821a172b9e2" translate="yes" xml:space="preserve">
          <source>Choose one of multiple ranges at runtime.</source>
          <target state="translated">在运行时从多个范围中选择一个。</target>
        </trans-unit>
        <trans-unit id="0bffc7533a173c7dee535e7316e44257ed38a803" translate="yes" xml:space="preserve">
          <source>Choose one of two ranges at runtime depending on a Boolean condition.</source>
          <target state="translated">在运行时根据布尔条件从两个范围中选择一个。</target>
        </trans-unit>
        <trans-unit id="5544515d81b65f896e82120e57ec6fa91d774f56" translate="yes" xml:space="preserve">
          <source>Chooses all &lt;code&gt;byteXxx&lt;/code&gt; flags.</source>
          <target state="translated">选择所有 &lt;code&gt;byteXxx&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="6438169cea15a58e629d9074302588f2e1950054" translate="yes" xml:space="preserve">
          <source>Chooses all &lt;code&gt;numXxx&lt;/code&gt; flags.</source>
          <target state="translated">选择所有 &lt;code&gt;numXxx&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="c672631dbe7d09bcec68adc7f3844fea3aee543f" translate="yes" xml:space="preserve">
          <source>Chooses one of several ranges at runtime based on an index.</source>
          <target state="translated">在运行时根据索引选择几个范围中的一个。</target>
        </trans-unit>
        <trans-unit id="4155ddaaa02a43e8c79a78caa5873e37eb151cb9" translate="yes" xml:space="preserve">
          <source>Chooses one of two ranges at runtime based on a boolean condition.</source>
          <target state="translated">在运行时根据布尔条件选择两个范围中的一个。</target>
        </trans-unit>
        <trans-unit id="664b0f4761a82a8eae267ec54d633d690bb844d2" translate="yes" xml:space="preserve">
          <source>Choosing &lt;code&gt;stackSize&lt;/code&gt; is as always a compromise. Too small a size exhausts the stack storage after a few allocations, after which there are no gains over the backup allocator. Too large a size increases the stack consumed by the thread and may end up worse off because it explores cold portions of the stack.</source>
          <target state="translated">与以往一样，选择 &lt;code&gt;stackSize&lt;/code&gt; 是一种妥协。太小的大小会在分配几次之后耗尽堆栈存储空间，在此之后，备份分配器将无法获得任何收益。太大的大小会增加线程消耗的堆栈，并且可能会变得更糟，因为它会探索堆栈的较冷部分。</target>
        </trans-unit>
        <trans-unit id="c9814b18eaeb245f343a07d23b55d5cc756f226e" translate="yes" xml:space="preserve">
          <source>Christopher E. Miller, &lt;a href=&quot;http://klickverbot.at&quot;&gt;David Nadlinger&lt;/a&gt;, &lt;a href=&quot;http://thecybershadow.net&quot;&gt;Vladimir Panteleev&lt;/a&gt;</source>
          <target state="translated">克里斯托弗&amp;middot;米勒，&lt;a href=&quot;http://klickverbot.at&quot;&gt;大卫&amp;middot;纳德林格&lt;/a&gt;，&lt;a href=&quot;http://thecybershadow.net&quot;&gt;弗拉基米尔&amp;middot;潘捷列夫&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef1a7c430ea76a914142ae9383408af4814b11d3" translate="yes" xml:space="preserve">
          <source>Chunk size</source>
          <target state="translated">块度</target>
        </trans-unit>
        <trans-unit id="de7daf1e8f3f4e94d6cfd35d20241f9683bce14b" translate="yes" xml:space="preserve">
          <source>Chunks an input range into subranges of equivalent adjacent elements. In other languages this is often called &lt;code&gt;partitionBy&lt;/code&gt;, &lt;code&gt;groupBy&lt;/code&gt; or &lt;code&gt;sliceWhen&lt;/code&gt;.</source>
          <target state="translated">将输入范围划分为等效相邻元素的子范围。在其他语言中，这通常称为 &lt;code&gt;partitionBy&lt;/code&gt; ， &lt;code&gt;groupBy&lt;/code&gt; 或 &lt;code&gt;sliceWhen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91ca4cec373000b1433d0ca1c64ba6f2c759ab69" translate="yes" xml:space="preserve">
          <source>Chunks!Source &lt;strong id=&quot;chunks&quot;&gt;chunks&lt;/strong&gt;(Source)(Source source, size_t chunkSize)</source>
          <target state="translated">源&lt;strong id=&quot;chunks&quot;&gt;块&lt;/strong&gt;（源）（源源，size_t chunkSize）</target>
        </trans-unit>
        <trans-unit id="f715fee1f757a55e2f3373ac010b13257f33e0d8" translate="yes" xml:space="preserve">
          <source>Clamps a value into the given bounds.</source>
          <target state="translated">在给定的范围内夹住一个值。</target>
        </trans-unit>
        <trans-unit id="383b1d065b22448681cc3efc5daa12ef6fd55601" translate="yes" xml:space="preserve">
          <source>Class Allocators</source>
          <target state="translated">类分配器</target>
        </trans-unit>
        <trans-unit id="980dc71fd708724fc917e76399e0f97f54ca4455" translate="yes" xml:space="preserve">
          <source>Class Deallocators</source>
          <target state="translated">类分配器</target>
        </trans-unit>
        <trans-unit id="9293e27da3b0684ddaaea3289920ae977e68c4b8" translate="yes" xml:space="preserve">
          <source>Class Invariant</source>
          <target state="translated">班级不变性</target>
        </trans-unit>
        <trans-unit id="2459ca9a523f95a794bce603404c5263b4256290" translate="yes" xml:space="preserve">
          <source>Class Invariants</source>
          <target state="translated">类不变量</target>
        </trans-unit>
        <trans-unit id="1df27dbdacaa899d3c423178002cc7aabfcb82bd" translate="yes" xml:space="preserve">
          <source>Class Object Layout</source>
          <target state="translated">类对象布局</target>
        </trans-unit>
        <trans-unit id="bce80736a23f07ec5379dd12c4e62a76fe4c9654" translate="yes" xml:space="preserve">
          <source>Class Properties</source>
          <target state="translated">班级属性</target>
        </trans-unit>
        <trans-unit id="31462d21de7565b81dba4582baea30b63d17330c" translate="yes" xml:space="preserve">
          <source>Class comparisons</source>
          <target state="translated">类别比较</target>
        </trans-unit>
        <trans-unit id="004e7955e2bb1bee0b58b1c03a6c08f676e86914" translate="yes" xml:space="preserve">
          <source>Class for exceptions thrown by &lt;code&gt;Socket.accept&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Socket.accept&lt;/code&gt; 引发的异常的类。</target>
        </trans-unit>
        <trans-unit id="0dd0234ce9a3827209b58ef80d34ea3eb2ef98d9" translate="yes" xml:space="preserve">
          <source>Class for exceptions thrown from an &lt;code&gt;Address&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;Address&lt;/code&gt; 抛出的异常的类。</target>
        </trans-unit>
        <trans-unit id="f8cabad72b7cf81c1a9e42e92f24fcecebecdd13" translate="yes" xml:space="preserve">
          <source>Class for exceptions thrown from an &lt;code&gt;InternetHost&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;InternetHost&lt;/code&gt; 引发的异常的类。</target>
        </trans-unit>
        <trans-unit id="d5db95106b80e21b18e83bc22b84105ca9ec0f70" translate="yes" xml:space="preserve">
          <source>Class for parsing an XML Document.</source>
          <target state="translated">用于解析XML文档的类。</target>
        </trans-unit>
        <trans-unit id="fd21b41b841c440b515f1b7977af0ee6dfc40b2f" translate="yes" xml:space="preserve">
          <source>Class for parsing an XML element.</source>
          <target state="translated">用于解析XML元素的类。</target>
        </trans-unit>
        <trans-unit id="a44a999e4ee22e0e38e93a6feafd39bd8662867c" translate="yes" xml:space="preserve">
          <source>Class info, type info, and module info</source>
          <target state="translated">类信息、类型信息和模块信息</target>
        </trans-unit>
        <trans-unit id="00e4305e03e0dd23aa189c7dfb11b275650b4811" translate="yes" xml:space="preserve">
          <source>Class interface</source>
          <target state="translated">类接口</target>
        </trans-unit>
        <trans-unit id="d131c8c89307df58eaa35092ddaf0d9ccbded6f4" translate="yes" xml:space="preserve">
          <source>Class invariants are inherited, that is, any class invariant is implicitly in addition to the invariants of its base classes.</source>
          <target state="translated">类的不变量是继承的,也就是说,任何一个类的不变量都是隐含在其基类的不变量之外的。</target>
        </trans-unit>
        <trans-unit id="96f7dd120edececc37360a6e411b5d487475d92f" translate="yes" xml:space="preserve">
          <source>Class members are always accessed with the . operator.</source>
          <target state="translated">类成员总是用.操作符访问。</target>
        </trans-unit>
        <trans-unit id="370a9bbed207ceee9d084543596997d531d9a330" translate="yes" xml:space="preserve">
          <source>Class references are considered pointers that are subject to &lt;code&gt;scope&lt;/code&gt;.</source>
          <target state="translated">类引用被认为是受 &lt;code&gt;scope&lt;/code&gt; 约束的指针。</target>
        </trans-unit>
        <trans-unit id="423af25d1c1b0ece97d135bd94f87785f1d1b081" translate="yes" xml:space="preserve">
          <source>Class representing a Character Data section</source>
          <target state="translated">代表字符数据部分的类</target>
        </trans-unit>
        <trans-unit id="af34b125b6fdaf2e164cb16e24345f12dba81970" translate="yes" xml:space="preserve">
          <source>Class representing a Processing Instruction section</source>
          <target state="translated">代表处理指令部分的类</target>
        </trans-unit>
        <trans-unit id="f768c4c1669315ae2806f02f66c55aa9730651bb" translate="yes" xml:space="preserve">
          <source>Class representing a comment</source>
          <target state="translated">代表评论的类</target>
        </trans-unit>
        <trans-unit id="be60f698a1c1d4833c13a3027790690d573ab935" translate="yes" xml:space="preserve">
          <source>Class representing a text (aka Parsed Character Data) section</source>
          <target state="translated">代表文本(也就是解析字符数据)部分的类。</target>
        </trans-unit>
        <trans-unit id="d71c9bec3d378a3193b92288d2a3d4f39af4d514" translate="yes" xml:space="preserve">
          <source>Class representing an XML Instruction section</source>
          <target state="translated">代表XML指令部分的类</target>
        </trans-unit>
        <trans-unit id="18bdedb4191bb66909c3afbec32afb00a0671f2d" translate="yes" xml:space="preserve">
          <source>Class representing an XML document.</source>
          <target state="translated">代表一个XML文档的类。</target>
        </trans-unit>
        <trans-unit id="b824acd16fc71bc2cc584e5d63675cb399574fdb" translate="yes" xml:space="preserve">
          <source>Class representing an XML element.</source>
          <target state="translated">代表一个XML元素的类。</target>
        </trans-unit>
        <trans-unit id="2e4077efbfeca1ecea84c2841a1e337531e07230" translate="yes" xml:space="preserve">
          <source>Class representing an XML tag.</source>
          <target state="translated">代表一个XML标签的类。</target>
        </trans-unit>
        <trans-unit id="3eca99d66e1692913774b276a72eb2d9c5a613f4" translate="yes" xml:space="preserve">
          <source>Class that holds an expression in a Dsymbol wraper. This is not an AST node, but a class used to pass an expression as a function parameter of type Dsymbol.</source>
          <target state="translated">在Dsymbol包装器中保存表达式的类。这不是一个AST节点,而是一个用来传递表达式作为Dsymbol类型函数参数的类。</target>
        </trans-unit>
        <trans-unit id="fd66f846be164f5572f2b91a4e8cf668edcb8a5f" translate="yes" xml:space="preserve">
          <source>Class that implements the &lt;code&gt;InputRange&lt;/code&gt; interface and wraps the input range methods in virtual functions.</source>
          <target state="translated">实现 &lt;code&gt;InputRange&lt;/code&gt; 接口并将输入范围方法包装在虚函数中的类。</target>
        </trans-unit>
        <trans-unit id="7a5fb94e691e67e69c8178bf66e0bfcda94440d4" translate="yes" xml:space="preserve">
          <source>Class that implements the &lt;code&gt;OutputRange&lt;/code&gt; interface and wraps the &lt;code&gt;put&lt;/code&gt; methods in virtual functions.</source>
          <target state="translated">实现 &lt;code&gt;OutputRange&lt;/code&gt; 接口并将 &lt;code&gt;put&lt;/code&gt; 方法包装在虚函数中的类。</target>
        </trans-unit>
        <trans-unit id="6f02b7cdf3a27dfb668a50be53f3c4a25b5410c5" translate="yes" xml:space="preserve">
          <source>ClassDeclaration</source>
          <target state="translated">ClassDeclaration</target>
        </trans-unit>
        <trans-unit id="e227e5b1defef4ae4a1612e580a4b6e31545ba58" translate="yes" xml:space="preserve">
          <source>ClassDeclaration &lt;code&gt;cd&lt;/code&gt;</source>
          <target state="translated">类声明 &lt;code&gt;cd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88d2f59bfb7ba6b0443204d9f4aa0913667339b9" translate="yes" xml:space="preserve">
          <source>ClassDeclaration &lt;strong id=&quot;classDeclaration&quot;&gt;classDeclaration&lt;/strong&gt;;</source>
          <target state="translated">ClassDeclaration &lt;strong id=&quot;classDeclaration&quot;&gt;classDeclaration&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="922055dec836bd4265fccad1b410b15255aed28c" translate="yes" xml:space="preserve">
          <source>ClassDeclaration &lt;strong id=&quot;metaclass&quot;&gt;metaclass&lt;/strong&gt;;</source>
          <target state="translated">ClassDeclaration &lt;strong id=&quot;metaclass&quot;&gt;元类&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ed3cf94875958c0b64c8f17bbe32c5545117a531" translate="yes" xml:space="preserve">
          <source>ClassDeclaration if found, null if not</source>
          <target state="translated">如果找到ClassDeclaration,则为null</target>
        </trans-unit>
        <trans-unit id="0193a1974eb2b77a25fbe296ffc8a9c0fc9032a5" translate="yes" xml:space="preserve">
          <source>ClassInfo &lt;strong id=&quot;getClassInfo&quot;&gt;getClassInfo&lt;/strong&gt;(_Unwind_Exception* exceptionObject, const(ubyte)* currentLsd);</source>
          <target state="translated">ClassInfo &lt;strong id=&quot;getClassInfo&quot;&gt;getClassInfo&lt;/strong&gt;（_Unwind_Exception * exceptionObject，const（ubyte）* currentLsd）;</target>
        </trans-unit>
        <trans-unit id="082cd7ff80693ec8dbf6e94d67e626c8eb7acf74" translate="yes" xml:space="preserve">
          <source>ClassInvariant</source>
          <target state="translated">ClassInvariant</target>
        </trans-unit>
        <trans-unit id="931763918b2d001bdeb9a0167eeecd1b1464e45f" translate="yes" xml:space="preserve">
          <source>ClassKind &lt;strong id=&quot;classKind&quot;&gt;classKind&lt;/strong&gt;;</source>
          <target state="translated">ClassKind &lt;strong id=&quot;classKind&quot;&gt;classKind&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="91e40f8e856e33a510bdbf85b94648241eeb6d72" translate="yes" xml:space="preserve">
          <source>ClassTemplateDeclaration</source>
          <target state="translated">ClassTemplateDeclaration</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="88928400c233ae410eba0ed5ea1d5d957388cae0" translate="yes" xml:space="preserve">
          <source>Classes and functions for creating and parsing XML</source>
          <target state="translated">用于创建和解析XML的类和函数。</target>
        </trans-unit>
        <trans-unit id="e64d39090ae91d34137788357a6ca17b0e59eef2" translate="yes" xml:space="preserve">
          <source>Classes and functions for handling and transcoding between various encodings.</source>
          <target state="translated">用于处理和转码各种编码的类和函数。</target>
        </trans-unit>
        <trans-unit id="94ee5f9cdf031a9bf96906a438e53b06b5e364d3" translate="yes" xml:space="preserve">
          <source>Classes and unions never have elaborate assignments.</source>
          <target state="translated">班级和工会从来没有精心布置过作业。</target>
        </trans-unit>
        <trans-unit id="9cf9cc918357cc355736633df26f1b2a1c76d306" translate="yes" xml:space="preserve">
          <source>Classes and unions never have elaborate copy constructors.</source>
          <target state="translated">类和联合体从来没有精心设计的复制构造函数。</target>
        </trans-unit>
        <trans-unit id="531947ccb13d84d3c9d91ba0159960b4ae281773" translate="yes" xml:space="preserve">
          <source>Classes and unions never have elaborate destructors, even though classes may define &lt;code&gt;~this()&lt;/code&gt;.</source>
          <target state="translated">即使类可以定义 &lt;code&gt;~this()&lt;/code&gt; ，类和联合也从来没有复杂的析构函数。</target>
        </trans-unit>
        <trans-unit id="061681876af68eae00bc697b791a9edd12ded2c6" translate="yes" xml:space="preserve">
          <source>Classes and unions never have elaborate move semantics.</source>
          <target state="translated">类和联合体从来没有详细的移动语义。</target>
        </trans-unit>
        <trans-unit id="b757232012d9216b3c6a4071538b9dc9ae16e888" translate="yes" xml:space="preserve">
          <source>Classes are programmer defined types. Support for classes are what make D an object oriented language, giving it encapsulation, inheritance, and polymorphism. D classes support the single inheritance paradigm, extended by adding support for interfaces. Class objects are instantiated by reference only.</source>
          <target state="translated">类是程序员定义的类型。对类的支持是D语言成为面向对象语言的原因,使其具有封装、继承和多态性。D类支持单一继承范式,通过增加对接口的支持来扩展。类对象只能通过引用来实例化。</target>
        </trans-unit>
        <trans-unit id="64beae7795db165495c04ccd743e7e2188a737f0" translate="yes" xml:space="preserve">
          <source>Classes become abstract if any of its virtual member functions are declared abstract or if they are defined within an abstract attribute. Note that an abstract class may also contain non-virtual member functions.</source>
          <target state="translated">如果类的任何虚拟成员函数被声明为抽象的,或者它们被定义在一个抽象属性中,那么类就成为抽象的。注意,一个抽象类也可以包含非虚拟成员函数。</target>
        </trans-unit>
        <trans-unit id="13447880a16527416e427574ff84252582f7e516" translate="yes" xml:space="preserve">
          <source>Classes can be used as the</source>
          <target state="translated">类可以作为</target>
        </trans-unit>
        <trans-unit id="80f7ca9d259d3ef3e97f57bc1d7cca827ec1caa6" translate="yes" xml:space="preserve">
          <source>Classes consist of:</source>
          <target state="translated">班级包括:</target>
        </trans-unit>
        <trans-unit id="282ae17a602326eef034194b26fb43aa7fe0fc9d" translate="yes" xml:space="preserve">
          <source>Classes defined within an abstract attribute or with abstract member functions cannot be instantiated directly. They can only be instantiated as a base class of another, non-abstract, class.</source>
          <target state="translated">在抽象属性中定义的类或具有抽象成员函数的类不能直接被实例化,它们只能作为另一个非抽象类的基类被实例化。它们只能被实例化为另一个非抽象类的基类。</target>
        </trans-unit>
        <trans-unit id="f1d8e8c29e8bdc647b741d3f95fb6db5ee347a64" translate="yes" xml:space="preserve">
          <source>Classes derived from COM interfaces are COM classes.</source>
          <target state="translated">从COM接口派生的类是COM类。</target>
        </trans-unit>
        <trans-unit id="bd620604c65cda121c2c3178e92377099e03939c" translate="yes" xml:space="preserve">
          <source>Classes that inherit from an interface may not override final or static interface member functions.</source>
          <target state="translated">继承自接口的类不能覆盖最终或静态接口成员函数。</target>
        </trans-unit>
        <trans-unit id="5d1fce9e58eb73d5ee27c4db7d0cde0cfef20fab" translate="yes" xml:space="preserve">
          <source>Classic Visitor class which implements visit methods for all the AST nodes present in the compiler. The visit methods for AST nodes created at parse time are inherited while the visiting methods for AST nodes created at semantic time are implemented.</source>
          <target state="translated">经典的Visitor类,它为编译器中存在的所有AST节点实现了访问方法。在解析时创建的AST节点的访问方法是继承的,而在语义时创建的AST节点的访问方法是实现的。</target>
        </trans-unit>
        <trans-unit id="ec46bc29fc953e9c5d20d1293a749b2d318b26db" translate="yes" xml:space="preserve">
          <source>Classics</source>
          <target state="translated">Classics</target>
        </trans-unit>
        <trans-unit id="94c2a3189e7f7885455350c4c7a8df2d0d6ad1d1" translate="yes" xml:space="preserve">
          <source>Classification</source>
          <target state="translated">Classification</target>
        </trans-unit>
        <trans-unit id="f7e62460bb760d585edcc42972294b3355a88236" translate="yes" xml:space="preserve">
          <source>Classsym* &lt;strong id=&quot;fake_classsym&quot;&gt;fake_classsym&lt;/strong&gt;(Identifier id);</source>
          <target state="translated">Classsym * &lt;strong id=&quot;fake_classsym&quot;&gt;fake_classsym&lt;/strong&gt;（标识符ID）;</target>
        </trans-unit>
        <trans-unit id="c24c0db0ec6dd19513d073595d928b550d95b320" translate="yes" xml:space="preserve">
          <source>Cleans up and removes a whole multi stack. It does not free or touch any individual easy handles in any way. We need to define in what state those handles will be if this function is called in the middle of a transfer.</source>
          <target state="translated">清理和去除整个多叠。它不会以任何方式释放或触及任何单个的简易句柄。我们需要定义如果这个函数在传输过程中被调用,这些句柄将处于什么状态。</target>
        </trans-unit>
        <trans-unit id="74435379a09fe369f083f9d7cb1588b2c142f5b0" translate="yes" xml:space="preserve">
          <source>Cleans up this ThreadInfo.</source>
          <target state="translated">清理这个ThreadInfo。</target>
        </trans-unit>
        <trans-unit id="2978244ea1d5b187c301c21366eda9dedde71b7e" translate="yes" xml:space="preserve">
          <source>Clear a pointer option.</source>
          <target state="translated">清除一个指针选项。</target>
        </trans-unit>
        <trans-unit id="e034f5a3aa872aabba7dcb11d326d687c4332626" translate="yes" xml:space="preserve">
          <source>Clear a pointer option. Does not raise an exception if the underlying libcurl does not support the option. Use sparingly.</source>
          <target state="translated">清除一个指针选项。如果底层libcurl不支持该选项,不会引发异常。尽量少用。</target>
        </trans-unit>
        <trans-unit id="a9d817365eb86e6681481b253301a6c9352b3cc8" translate="yes" xml:space="preserve">
          <source>Clear all commands send to ftp server.</source>
          <target state="translated">清除所有发送到ftp服务器的命令。</target>
        </trans-unit>
        <trans-unit id="aabfad8a5b74b09b0c1a45cf20e29c1bc3b34566" translate="yes" xml:space="preserve">
          <source>Clear all cookies.</source>
          <target state="translated">清除所有cookies。</target>
        </trans-unit>
        <trans-unit id="959b909eeb5ade07f369e65c6d34109729b67e12" translate="yes" xml:space="preserve">
          <source>Clear all outgoing headers.</source>
          <target state="translated">清理所有出站头。</target>
        </trans-unit>
        <trans-unit id="266e66f0d3d6904b779ec3d759be8309dd9c6a30" translate="yes" xml:space="preserve">
          <source>Clear session cookies.</source>
          <target state="translated">清除会话cookies。</target>
        </trans-unit>
        <trans-unit id="8fc5d7d65b7fdfd82eecfa31a9a25b3fac8d53e4" translate="yes" xml:space="preserve">
          <source>Clear the data in the buffer</source>
          <target state="translated">清除缓冲区中的数据</target>
        </trans-unit>
        <trans-unit id="aa6bcffd4a89f4241729474f1c06cc264b136f23" translate="yes" xml:space="preserve">
          <source>Clears the TZ environment variable.</source>
          <target state="translated">清除TZ环境变量。</target>
        </trans-unit>
        <trans-unit id="bf4e8edf5ce7d61a0c02a57350749b31964ea588" translate="yes" xml:space="preserve">
          <source>Clears the heap by detaching it from the underlying store.</source>
          <target state="translated">通过从底层存储中分离出堆来清除堆。</target>
        </trans-unit>
        <trans-unit id="85a1162bfefbbee36bd8acce0b24bc3c4f0d6476" translate="yes" xml:space="preserve">
          <source>Clears the heap. Returns the portion of the store from &lt;code&gt;0&lt;/code&gt; up to &lt;code&gt;length&lt;/code&gt;, which satisfies the &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;heap property&lt;/a&gt;.</source>
          <target state="translated">清除堆。返回存储量从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;length&lt;/code&gt; 的部分，该部分满足&lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;heap属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87154787f8eca1558e3d9985e8d82cb0474f80d3" translate="yes" xml:space="preserve">
          <source>Clears the managed array. This allows the elements of the array to be reused for appending.</source>
          <target state="translated">清空被管理的数组。这允许数组中的元素被重复使用以进行追加。</target>
        </trans-unit>
        <trans-unit id="7cc6960537f814063b8ae6e19a6580b4b9426a39" translate="yes" xml:space="preserve">
          <source>Clears the specified bits for the memory references by p. If p references memory not originally allocated by this garbage collector, points to the interior of a memory block, or if p is null, no action will be performed.</source>
          <target state="translated">清除p对内存引用的指定位,如果p引用的内存不是这个垃圾收集器最初分配的,指向内存块的内部,或者p为空,则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="d692c2c202249e9e4fe0069f00e6bff039f0c2b5" translate="yes" xml:space="preserve">
          <source>Close A BLOB Handle</source>
          <target state="translated">关闭一个BLOB手柄</target>
        </trans-unit>
        <trans-unit id="c2fcec962038b6d876aef882b5671cadf0a6a473" translate="yes" xml:space="preserve">
          <source>Close similarity with StructDeclaration::buildPostBlit(), and the ordering changes (runs backward instead of forwards).</source>
          <target state="translated">与StructDeclaration::buildPostBlit()的相似度很高,但顺序发生了变化(向后而不是向前运行)。</target>
        </trans-unit>
        <trans-unit id="abc1e6908fffa951befef872f924ffd37a933a94" translate="yes" xml:space="preserve">
          <source>Close_Punctuation</source>
          <target state="translated">Close_Punctuation</target>
        </trans-unit>
        <trans-unit id="111445e87ccfca2b4a774d56d32be272bb8db6b1" translate="yes" xml:space="preserve">
          <source>Closes both ends of the pipe.</source>
          <target state="translated">关闭管道的两端。</target>
        </trans-unit>
        <trans-unit id="f1ceaea1ade786b6daac7b066c7f274b9fd722f8" translate="yes" xml:space="preserve">
          <source>Closing A Database Connection</source>
          <target state="translated">关闭数据库连接</target>
        </trans-unit>
        <trans-unit id="749585ff38f67fad5e857de1d450982c56ce1960" translate="yes" xml:space="preserve">
          <source>Closing a file will release all locks associated with the file. On POSIX, even locks acquired via a different &lt;code&gt;File&lt;/code&gt; will be released as well.</source>
          <target state="translated">关闭文件将释放与该文件关联的所有锁。在POSIX上，即使通过其他 &lt;code&gt;File&lt;/code&gt; 获取的锁也将被释放。</target>
        </trans-unit>
        <trans-unit id="63c1d27a07661bae4b5bbb559006eaa3661d7c60" translate="yes" xml:space="preserve">
          <source>Closures are implemented by taking the local variables that need to survive the scope of the function, and copying them into a gc allocated chuck of memory. That chunk, called the closure here, is inserted into the linked list of stack frames instead of the usual stack frame.</source>
          <target state="translated">闭包的实现方式是将需要在函数范围内存活的局部变量,复制到一个gc分配的内存小块中。这块内存,在这里称为闭包,被插入到链接的栈框架列表中,而不是通常的栈框架中。</target>
        </trans-unit>
        <trans-unit id="c9b2ef049e2a57bda63fd1cc78251ce6a2187e99" translate="yes" xml:space="preserve">
          <source>Cn</source>
          <target state="translated">Cn</target>
        </trans-unit>
        <trans-unit id="8d39b08893191a61de5487a71b3ae48e722dc4dc" translate="yes" xml:space="preserve">
          <source>Co</source>
          <target state="translated">Co</target>
        </trans-unit>
        <trans-unit id="3b89922ff6533757df55cb947df36b1820f7780e" translate="yes" xml:space="preserve">
          <source>Coalescing is carried during deallocation.</source>
          <target state="translated">在分配过程中进行凝聚。</target>
        </trans-unit>
        <trans-unit id="ae47022506f14b1edf01e25a19bb75021f3dfd6b" translate="yes" xml:space="preserve">
          <source>Code Generator State</source>
          <target state="translated">代码生成器状态</target>
        </trans-unit>
        <trans-unit id="61eac493399c61900e3b0a3c302c25c90df00dd5" translate="yes" xml:space="preserve">
          <source>Code Snippet</source>
          <target state="translated">代码片段</target>
        </trans-unit>
        <trans-unit id="ca4bf5763a8f4b0c77b0483fb046442fb68b4bcf" translate="yes" xml:space="preserve">
          <source>Code calling &lt;code&gt;getLine&lt;/code&gt; (usually far away from its definition) can't be understood without looking at the documentation, even by users familiar with the API:</source>
          <target state="translated">不查看文档就无法理解调用 &lt;code&gt;getLine&lt;/code&gt; 的代码（通常远离其定义），即使是熟悉API的用户也无法理解：</target>
        </trans-unit>
        <trans-unit id="81c9c017895b738c0e50ae9184f9f1e3b2468977" translate="yes" xml:space="preserve">
          <source>Code data type</source>
          <target state="translated">代码数据类型</target>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes" xml:space="preserve">
          <source>Code generation</source>
          <target state="translated">代码生成</target>
        </trans-unit>
        <trans-unit id="f2a3cebabe66438483aac9c32717824f44b75d4c" translate="yes" xml:space="preserve">
          <source>Code that defines allocators shareable across threads ultimately implements the &lt;a href=&quot;#ISharedAllocator&quot;&gt;&lt;code&gt;ISharedAllocator&lt;/code&gt;&lt;/a&gt; interface, possibly by using &lt;a href=&quot;#CSharedAllocatorImpl&quot;&gt;&lt;code&gt;CSharedAllocatorImpl&lt;/code&gt;&lt;/a&gt; below, and then build a &lt;code&gt;RCISharedAllocator&lt;/code&gt; out of this.</source>
          <target state="translated">代码定义分配器跨线程共享的最终实现&lt;a href=&quot;#ISharedAllocator&quot;&gt; &lt;code&gt;ISharedAllocator&lt;/code&gt; &lt;/a&gt;接口，可能通过使用&lt;a href=&quot;#CSharedAllocatorImpl&quot;&gt; &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; &lt;/a&gt;下面，然后生成一个 &lt;code&gt;RCISharedAllocator&lt;/code&gt; 出于此。</target>
        </trans-unit>
        <trans-unit id="2ce7d7f9589694e248dfd5c203d7de9947b03c60" translate="yes" xml:space="preserve">
          <source>Code that defines allocators ultimately implements the &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt; interface, possibly by using &lt;a href=&quot;#CAllocatorImpl&quot;&gt;&lt;code&gt;CAllocatorImpl&lt;/code&gt;&lt;/a&gt; below, and then build a &lt;code&gt;RCIAllocator&lt;/code&gt; out of this.</source>
          <target state="translated">代码定义分配器最终实现&lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; &lt;/a&gt;接口，可能通过使用&lt;a href=&quot;#CAllocatorImpl&quot;&gt; &lt;code&gt;CAllocatorImpl&lt;/code&gt; &lt;/a&gt;下面，然后生成一个 &lt;code&gt;RCIAllocator&lt;/code&gt; 出于此。</target>
        </trans-unit>
        <trans-unit id="648d49ad8e99c3fb1b22ef73fd685d72f38f47f8" translate="yes" xml:space="preserve">
          <source>CodePoints!E &lt;strong id=&quot;codePoints&quot;&gt;codePoints&lt;/strong&gt;(E)(immutable(E)[] s);</source>
          <target state="translated">Codepoints！E &lt;strong id=&quot;codePoints&quot;&gt;codePoints&lt;/strong&gt;（E）（immutable（E）[] s）;</target>
        </trans-unit>
        <trans-unit id="e056cd1238b78a879d641cec9ec7096771e7f154" translate="yes" xml:space="preserve">
          <source>CodeUnits!E &lt;strong id=&quot;codeUnits&quot;&gt;codeUnits&lt;/strong&gt;(E)(dchar c);</source>
          <target state="translated">CodeUnits！E &lt;strong id=&quot;codeUnits&quot;&gt;codeUnits&lt;/strong&gt;（E）（dchar c）;</target>
        </trans-unit>
        <trans-unit id="9e5e2fb2ae8d76c3506f723e7bf1081e039cf3b0" translate="yes" xml:space="preserve">
          <source>CodepointSet &lt;strong id=&quot;parseSet&quot;&gt;parseSet&lt;/strong&gt;(Range)(ref Range range, bool casefold = false)</source>
          <target state="translated">CodepointSet &lt;strong id=&quot;parseSet&quot;&gt;parseSet&lt;/strong&gt;（范围）（参考文献范围的范围，布尔casefold =假）</target>
        </trans-unit>
        <trans-unit id="ab22b1cbc13995ba1b3b200e55dcfdd0544bb677" translate="yes" xml:space="preserve">
          <source>CodepointTrie is the type of Trie as generated by codepointTrie function.</source>
          <target state="translated">CodepointTrie是由codepointTrie函数生成的Trie类型。</target>
        </trans-unit>
        <trans-unit id="f4676db78e987928a98e39c01c3be6dce486eb6b" translate="yes" xml:space="preserve">
          <source>Codeview 4 stuff See &quot;Microsoft Symbol and Type OMF&quot; document</source>
          <target state="translated">Codeview 4的东西 请看 &quot;微软符号和类型OMF &quot;文档。</target>
        </trans-unit>
        <trans-unit id="5703d432c480d27062f281f688e79056c7ad8ff5" translate="yes" xml:space="preserve">
          <source>Codeview Debugger Extensions</source>
          <target state="translated">Codeview调试器扩展</target>
        </trans-unit>
        <trans-unit id="f2ac091ea616d198f2fcdf2fa7fca9b23cc03ae8" translate="yes" xml:space="preserve">
          <source>Codeview OEM Extensions for D</source>
          <target state="translated">Codeview D的OEM扩展</target>
        </trans-unit>
        <trans-unit id="1e254a056c86801f8b560ebd071943f8829e763e" translate="yes" xml:space="preserve">
          <source>Collation Needed Callbacks</source>
          <target state="translated">整理需要的回调</target>
        </trans-unit>
        <trans-unit id="6fe1d0f55b0a1f3b24dadd046f77aad5b501d708" translate="yes" xml:space="preserve">
          <source>Collect all instance fields, then determine instance size.</source>
          <target state="translated">收集所有实例字段,然后确定实例大小。</target>
        </trans-unit>
        <trans-unit id="12bbc9c399cd5560e95d3b021061d86be8bc2a9c" translate="yes" xml:space="preserve">
          <source>Collect certificate chain info and allow it to get retrievable with CURLINFO_CERTINFO after the transfer is complete. (Unfortunately) only working with OpenSSL-powered builds.</source>
          <target state="translated">收集证书链信息,并允许它在传输完成后通过CURLINFO_CERTINFO进行检索。(遗憾的是)只适用于OpenSSL驱动的构建。</target>
        </trans-unit>
        <trans-unit id="468b13f09989b44757225ef38e66278a68977e9f" translate="yes" xml:space="preserve">
          <source>Collect statistics about any other allocator.</source>
          <target state="translated">收集任何其他分配器的统计数据。</target>
        </trans-unit>
        <trans-unit id="051496a97d15089d5729a697772eef84032a0d1c" translate="yes" xml:space="preserve">
          <source>CollectHandler &lt;code&gt;h&lt;/code&gt;</source>
          <target state="translated">CollectHandler &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26184bfd23f5e4f04f870a87cbb3381399308c03" translate="yes" xml:space="preserve">
          <source>CollectHandler &lt;strong id=&quot;rt_getCollectHandler&quot;&gt;rt_getCollectHandler&lt;/strong&gt;();</source>
          <target state="translated">CollectHandler &lt;strong id=&quot;rt_getCollectHandler&quot;&gt;rt_getCollectHandler&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="9e011708a38de006c0934dcad91ea7104a3760e9" translate="yes" xml:space="preserve">
          <source>Collection of declarations that stores foreach index variables in a local symbol table. Other symbols declared within are forwarded to another scope, like:</source>
          <target state="translated">在本地符号表中存储foreach索引变量的声明集合。在里面声明的其他符号会被转发到另一个作用域,比如。</target>
        </trans-unit>
        <trans-unit id="4550137c5d8ee30c9c444e2275bc095775ae9fd8" translate="yes" xml:space="preserve">
          <source>Collection of typical and useful prebuilt allocators using the given components. User code would typically import this module and use its facilities, or import individual heap building blocks and assemble them.</source>
          <target state="translated">使用给定组件的典型和有用的预制分配器的集合。用户代码通常会导入这个模块并使用它的设施,或者导入单个的堆构件并进行组装。</target>
        </trans-unit>
        <trans-unit id="ef19b0ece05a3462504233adba544b8b5a08b828" translate="yes" xml:space="preserve">
          <source>Colloquially known as the average, &lt;code&gt;mean([1, 2, 3])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">俗称平均值， &lt;code&gt;mean([1, 2, 3])&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb3df2ba2c8c0867352fa9e3671ba7ae4fd30398" translate="yes" xml:space="preserve">
          <source>Color highlighting to classify messages</source>
          <target state="translated">彩色高亮显示,对信息进行分类</target>
        </trans-unit>
        <trans-unit id="cfbfc51b4b3062caab10bcf86299598910467bc8" translate="yes" xml:space="preserve">
          <source>Column Names In A Result Set</source>
          <target state="translated">结果集中的列名</target>
        </trans-unit>
        <trans-unit id="17e28d0308aeca3705368383ac8a754a55a1f9cb" translate="yes" xml:space="preserve">
          <source>Column number at which parse failure occurred</source>
          <target state="translated">发生解析失败的列号</target>
        </trans-unit>
        <trans-unit id="8802a6119729c5dbcd1a4a6fccd2dd26ff860c9c" translate="yes" xml:space="preserve">
          <source>Combine a &lt;code&gt;path&lt;/code&gt; and a file &lt;code&gt;name&lt;/code&gt;</source>
          <target state="translated">结合 &lt;code&gt;path&lt;/code&gt; 和文件 &lt;code&gt;name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98f6dcf6f609fca2856f9333b52c621a46631536" translate="yes" xml:space="preserve">
          <source>Combine e1 and e2 by CommaExp if both are not NULL.</source>
          <target state="translated">如果e1和e2都不是NULL,则用CommaExp合并。</target>
        </trans-unit>
        <trans-unit id="c26362babef999f12a51b76dac746d90b76964fd" translate="yes" xml:space="preserve">
          <source>Combine two document comments into one, separated by an extra newline if newParagraph is true.</source>
          <target state="translated">将两个文档注释合并为一个,如果newParagraph为真,则用一个额外的新行分隔。</target>
        </trans-unit>
        <trans-unit id="edc044e8199855a2b041cea713a198a580a2531b" translate="yes" xml:space="preserve">
          <source>Combine types.</source>
          <target state="translated">结合类型。</target>
        </trans-unit>
        <trans-unit id="25346b872edf3bfe2419bf590c58043497a9e602" translate="yes" xml:space="preserve">
          <source>Combines all flags above.</source>
          <target state="translated">综合以上所有旗帜。</target>
        </trans-unit>
        <trans-unit id="74c07f7ae306b9dd4da07ceabcc403719eb0b180" translate="yes" xml:space="preserve">
          <source>Combines one or more path segments.</source>
          <target state="translated">组合一个或多个路径段。</target>
        </trans-unit>
        <trans-unit id="f83b8c4f6b0762b14b6a3f2a338c87fcd58c0b18" translate="yes" xml:space="preserve">
          <source>Combines several template predicates using logical AND, i.e. constructs a new predicate which evaluates to true for a given input T if and only if all of the passed predicates are true for T.</source>
          <target state="translated">使用逻辑AND组合多个模板谓词,即构造一个新的谓词,如果且仅当所有传递的谓词对T为真时,该谓词对给定输入T的评价为真。</target>
        </trans-unit>
        <trans-unit id="aba602ae0d3fbfaf1b1e3b80dab8046665c5745f" translate="yes" xml:space="preserve">
          <source>Combines several template predicates using logical OR, i.e. constructs a new predicate which evaluates to true for a given input T if and only at least one of the passed predicates is true for T.</source>
          <target state="translated">使用逻辑OR组合多个模板谓词,即构造一个新的谓词,对于给定的输入T,如果且仅有一个传递的谓词为真,则该谓词评价为真。</target>
        </trans-unit>
        <trans-unit id="b31cc4ba9ad95a280e295db305a32838ab4494f4" translate="yes" xml:space="preserve">
          <source>Combines the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_datetime_date#TimeOfDay&quot;&gt;&lt;code&gt;std.datetime.date.TimeOfDay&lt;/code&gt;&lt;/a&gt; structs to give an object which holds both the date and the time. It is optimized for calendar-based operations and has no concept of time zone. For an object which is optimized for time operations based on the system time, use &lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt;&lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt;&lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt;&lt;/a&gt; has a concept of time zone and has much higher precision (hnsecs). &lt;code&gt;DateTime&lt;/code&gt; is intended primarily for calendar-based uses rather than precise time operations.</source>
          <target state="translated">组合&lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;std_datetime_date#TimeOfDay&quot;&gt; &lt;code&gt;std.datetime.date.TimeOfDay&lt;/code&gt; &lt;/a&gt;结构以提供同时包含日期和时间的对象。它针对基于日历的操作进行了优化，并且没有时区的概念。对于基于系统时间针对时间操作进行了优化的对象，请使用&lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt; &lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt; &lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt; &lt;/a&gt;具有时区的概念，并且精度更高（hnsecs）。 &lt;code&gt;DateTime&lt;/code&gt; 主要用于基于日历的用途，而不是精确的时间操作。</target>
        </trans-unit>
        <trans-unit id="b348c9883d7a65f18c195bae42b3350c1cfcc257" translate="yes" xml:space="preserve">
          <source>Combines things into output file name for .html and .di files.</source>
          <target state="translated">将东西组合成.html和.di文件的输出文件名。</target>
        </trans-unit>
        <trans-unit id="1cb6816f0f4c743f4be34cb8f1005b8dc4a5dbab" translate="yes" xml:space="preserve">
          <source>Combining Diacritical Marks</source>
          <target state="translated">组合双音符</target>
        </trans-unit>
        <trans-unit id="7bbd088f443b08f8c69b5507dfb474b887bed2d3" translate="yes" xml:space="preserve">
          <source>Combining Diacritical Marks Supplement</source>
          <target state="translated">合并双音符补编</target>
        </trans-unit>
        <trans-unit id="89777baa8157a4e8e953c3fa634c48e0c8258bcc" translate="yes" xml:space="preserve">
          <source>Combining Diacritical Marks for Symbols</source>
          <target state="translated">组合符号的重音符号。</target>
        </trans-unit>
        <trans-unit id="d0f9b6a69c0d912d5ea6af9438228b3d2f3751e4" translate="yes" xml:space="preserve">
          <source>Combining Half Marks</source>
          <target state="translated">合并半分</target>
        </trans-unit>
        <trans-unit id="33e7a69b870095426b74829cdf476d33798ed00e" translate="yes" xml:space="preserve">
          <source>Combining Qualifiers</source>
          <target state="translated">组合限定词</target>
        </trans-unit>
        <trans-unit id="6b7ee24a290e7c102397f117a90975aafc87fb59" translate="yes" xml:space="preserve">
          <source>Comma Separated Values provide a simple means to transfer and store tabular data. It has been common for programs to use their own variant of the CSV format. This parser will loosely follow the &lt;a href=&quot;http://tools.ietf.org/html/rfc4180&quot;&gt;RFC-4180&lt;/a&gt;. CSV input should adhere to the following criteria (differences from RFC-4180 in parentheses):</source>
          <target state="translated">逗号分隔值提供了一种简单的方式来传输和存储表格数据。程序通常使用自己的CSV格式变体。该解析器将宽松地遵循&lt;a href=&quot;http://tools.ietf.org/html/rfc4180&quot;&gt;RFC-4180&lt;/a&gt;。CSV输入应遵循以下标准（括号中的RFC-4180与RFC-4180的区别）：</target>
        </trans-unit>
        <trans-unit id="ad7bdcc128a60763ff9cb8c0be38b2ccf8b45812" translate="yes" xml:space="preserve">
          <source>Comma separated list of hostnames defining no-proxy zones. These should match both hostnames directly, and hostnames within a domain. For example, local.com will match local.com and www.local.com, but NOT notlocal.com or www.notlocal.com. For compatibility with other implementations of this, .local.com will be considered to be the same as local.com. A single * is the only valid wildcard, and effectively disables the use of proxy.</source>
          <target state="translated">逗号分隔的定义无代理区的主机名列表。这些主机名既要直接匹配主机名,也要匹配域内的主机名。例如,local.com 将匹配 local.com 和 www.local.com,但不匹配 notlocal.com 或 www.notlocal.com。为了与其他实现的兼容性,.local.com将被视为与local.com相同。单一的*是唯一有效的通配符,并且有效地禁止使用代理。</target>
        </trans-unit>
        <trans-unit id="f6fe35e209171bf42b301a97ecb399ad5a56cfaf" translate="yes" xml:space="preserve">
          <source>Command line</source>
          <target state="translated">命令行</target>
        </trans-unit>
        <trans-unit id="5663b86338bee23174b52b5ba46d8c32b58f8344" translate="yes" xml:space="preserve">
          <source>Command line arguments</source>
          <target state="translated">命令行参数</target>
        </trans-unit>
        <trans-unit id="b7387b33d51887468652e802f6afcaeeac9763ce" translate="yes" xml:space="preserve">
          <source>Command line options starting with &quot;--DRT-&quot; are filtered out before calling main, so the program will not see them. They are still available via &lt;code&gt;rt_args&lt;/code&gt;.</source>
          <target state="translated">以&amp;ldquo; --DRT-&amp;rdquo;开头的命令行选项在调用main之前已被滤除，因此程序将看不到它们。它们仍然可以通过 &lt;code&gt;rt_args&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="66903ceee41d5ef93421296e69bd6bc51f61efb5" translate="yes" xml:space="preserve">
          <source>Comment &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">评论 &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e06489a89cedf711af9607db1d687967d2faf01" translate="yes" xml:space="preserve">
          <source>Comment below is from curlbuild.h:</source>
          <target state="translated">以下评论来自curlbuild.h。</target>
        </trans-unit>
        <trans-unit id="7f9ff34af4b665bfb574ac85235f0f1cf4635d35" translate="yes" xml:space="preserve">
          <source>CommentException if the comment body is illegal (contains &quot;--&quot; or exactly equals &quot;-&quot;)</source>
          <target state="translated">CommentException如果评论体是非法的(包含&quot;--&quot;或完全等于&quot;--&quot;)。</target>
        </trans-unit>
        <trans-unit id="4264255f1057eb8725699e53f5d3e7b96386a8eb" translate="yes" xml:space="preserve">
          <source>Comment[] &lt;strong id=&quot;comments&quot;&gt;comments&lt;/strong&gt;;</source>
          <target state="translated">评论[] &lt;strong id=&quot;comments&quot;&gt;评论&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="f8e4ca873b869b2ec1ff4daac61440fd8ce0e0ee" translate="yes" xml:space="preserve">
          <source>Comments cannot be used as token concatenators, for example, &lt;code&gt;abc/**/def&lt;/code&gt; is two tokens, &lt;code&gt;abc&lt;/code&gt; and &lt;code&gt;def&lt;/code&gt;, not one &lt;code&gt;abcdef&lt;/code&gt; token.</source>
          <target state="translated">注释不能用作令牌串联器，例如， &lt;code&gt;abc/**/def&lt;/code&gt; 是两个令牌 &lt;code&gt;abc&lt;/code&gt; 和 &lt;code&gt;def&lt;/code&gt; ，而不是一个 &lt;code&gt;abcdef&lt;/code&gt; 令牌。</target>
        </trans-unit>
        <trans-unit id="ffc61bb49c86bffaff083a2ed5fcbad20841a45a" translate="yes" xml:space="preserve">
          <source>Commit And Rollback Notification Callbacks</source>
          <target state="translated">提交和回滚通知回调</target>
        </trans-unit>
        <trans-unit id="7de90a65241a6cdbd9ade485d777715d99285a1e" translate="yes" xml:space="preserve">
          <source>Common</source>
          <target state="translated">Common</target>
        </trans-unit>
        <trans-unit id="d5f7712570de637ff2bff7b7aca4d031bb1ee21d" translate="yes" xml:space="preserve">
          <source>Common Indic Number Forms</source>
          <target state="translated">常见的印号表格</target>
        </trans-unit>
        <trans-unit id="b01bd9f5938cc4dfaf1079b1a8c35dbfb98a3ba0" translate="yes" xml:space="preserve">
          <source>Common approaches such as hash-tables or binary search over sorted code point intervals (as in &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;) are insufficient. Hash-tables have enormous memory footprint and binary search over intervals is not fast enough for some heavy-duty algorithms.</source>
          <target state="translated">普通方法，如哈希表或过排序代码点间隔二进制搜索（如在&lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt;）是不够的。哈希表具有巨大的内存占用空间，并且在某些时间间隔内进行二进制搜索对于某些重型算法而言还不够快。</target>
        </trans-unit>
        <trans-unit id="a32dd588a7041c6270a2514d02c733a9073d9c8d" translate="yes" xml:space="preserve">
          <source>Common case for setting integer and boolean options.</source>
          <target state="translated">设置整数和布尔选项的常见情况。</target>
        </trans-unit>
        <trans-unit id="cfa4873432fa4d4b23cf20cc5198f21c85152d5f" translate="yes" xml:space="preserve">
          <source>Common case of getting integer and boolean options.</source>
          <target state="translated">获取整数和布尔选项的常见情况。</target>
        </trans-unit>
        <trans-unit id="a72840f8f3c4385179a2e1cf4bebd6d9b76a472a" translate="yes" xml:space="preserve">
          <source>Common code for writing containers.</source>
          <target state="translated">编写容器的常用代码。</target>
        </trans-unit>
        <trans-unit id="437c2f93da603a10ceee0ebf4f1919d2974c2022" translate="yes" xml:space="preserve">
          <source>Common qualifier of the two type qualifiers</source>
          <target state="translated">两种类型限定词的共同限定词</target>
        </trans-unit>
        <trans-unit id="89b171c2ecd63cf0a35ea222440907368f9360a4" translate="yes" xml:space="preserve">
          <source>Common uses of &lt;code&gt;FreeTree&lt;/code&gt; include:</source>
          <target state="translated">&lt;code&gt;FreeTree&lt;/code&gt; 的常见用途包括：</target>
        </trans-unit>
        <trans-unit id="92e85a9032d0518091b64099c3e63f685bc8df63" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;cosineSimilarity&quot;&gt;cosineSimilarity&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType！（ElementType！Range1，ElementType！Range2）&lt;strong id=&quot;cosineSimilarity&quot;&gt;余弦相似度&lt;/strong&gt;（Range1，Range2）（Range1 a，Range2 b）</target>
        </trans-unit>
        <trans-unit id="ab52ba0cfbd974531b75cec838a9576c7724e23a" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType！（ElementType！Range1，ElementType！Range2）&lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;（Range1，Range2）（Range1 a，Range2 b）</target>
        </trans-unit>
        <trans-unit id="78c516be482530cc1f87a2e85f9f687667bad396" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;euclideanDistance&quot;&gt;euclideanDistance&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType！（ElementType！Range1，ElementType！Range2）&lt;strong id=&quot;euclideanDistance&quot;&gt;euclideanDistance&lt;/strong&gt;（Range1，Range2）（Range1 a，Range2 b）</target>
        </trans-unit>
        <trans-unit id="8b31f84db6c6a02bc762e2196d7797a3ccad082e" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;euclideanDistance&quot;&gt;euclideanDistance&lt;/strong&gt;(Range1, Range2, F)(Range1 a, Range2 b, F limit)</source>
          <target state="translated">CommonType！（ElementType！Range1，ElementType！Range2）&lt;strong id=&quot;euclideanDistance&quot;&gt;euclideanDistance&lt;/strong&gt;（Range1，Range2，F）（Range1a，Range2b，F限制）</target>
        </trans-unit>
        <trans-unit id="99490d0eb9c15796c0e0ff22de9c774a74b4f439" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;jensenShannonDivergence&quot;&gt;jensenShannonDivergence&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType！（ElementType！Range1，ElementType！Range2）&lt;strong id=&quot;jensenShannonDivergence&quot;&gt;jensenShannonDivergence&lt;/strong&gt;（Range1，Range2）（Range1 a，Range2 b）</target>
        </trans-unit>
        <trans-unit id="39e238fe92f1abc74d373ce3196f749befb03cf0" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;jensenShannonDivergence&quot;&gt;jensenShannonDivergence&lt;/strong&gt;(Range1, Range2, F)(Range1 a, Range2 b, F limit)</source>
          <target state="translated">CommonType！（ElementType！Range1，ElementType！Range2）&lt;strong id=&quot;jensenShannonDivergence&quot;&gt;jensenShannonDivergence&lt;/strong&gt;（Range1，Range2，F）（&lt;strong id=&quot;jensenShannonDivergence&quot;&gt;Range1a&lt;/strong&gt;，&lt;strong id=&quot;jensenShannonDivergence&quot;&gt;Range2b&lt;/strong&gt;，F限制）</target>
        </trans-unit>
        <trans-unit id="2b63f6969cbcdac3dc164e1220875639e9d0d85f" translate="yes" xml:space="preserve">
          <source>CommonType!(ElementType!Range1, ElementType!Range2) &lt;strong id=&quot;kullbackLeiblerDivergence&quot;&gt;kullbackLeiblerDivergence&lt;/strong&gt;(Range1, Range2)(Range1 a, Range2 b)</source>
          <target state="translated">CommonType！（ElementType！Range1，ElementType！Range2）&lt;strong id=&quot;kullbackLeiblerDivergence&quot;&gt;kullbackLeiblerDivergence&lt;/strong&gt;（Range1，Range2）（Range1 a，Range2 b）</target>
        </trans-unit>
        <trans-unit id="482d9be28df1e9221b752743fa47c81f861b6eb6" translate="yes" xml:space="preserve">
          <source>CommonType!(F1, F2) &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;(F1, F2)(in F1[] avector, in F2[] bvector);</source>
          <target state="translated">（F1，F2）点&lt;strong id=&quot;dotProduct&quot;&gt;积&lt;/strong&gt;（F1，F2）（在F1 [] avector中，在F2 [] bvector中）;</target>
        </trans-unit>
        <trans-unit id="59567896c72bea971e25cca00ca5982b60db700d" translate="yes" xml:space="preserve">
          <source>CommonType!(T, Ts) &lt;strong id=&quot;either&quot;&gt;either&lt;/strong&gt;(alias pred = (a) =&amp;gt; a, T, Ts...)(T first, lazy Ts alternatives)</source>
          <target state="translated">CommonType！（T，TS）&lt;strong id=&quot;either&quot;&gt;或者&lt;/strong&gt;（别名预计值=（A）=&amp;gt; A，T，TS ...）（T第一，懒惰TS的替代品）</target>
        </trans-unit>
        <trans-unit id="5c4c8f5d8b8482e06dd925b14fcab2c3af9acffc" translate="yes" xml:space="preserve">
          <source>CommonType!(T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;(E : Throwable = Exception, T1, T2)(lazy scope T1 expression, lazy scope T2 errorHandler);</source>
          <target state="translated">（T1，T2）&lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;（E：Throwable = Exception，T1，T2）（惰性作用域T1表达式，惰性作用域T2 errorHandler）;</target>
        </trans-unit>
        <trans-unit id="2d94d685f738626c2b0f123b65566e240d54d753" translate="yes" xml:space="preserve">
          <source>CommonType!(T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;(E : Throwable, T1, T2)(lazy scope T1 expression, scope T2 delegate(E) errorHandler);</source>
          <target state="translated">（T1，T2）&lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;（E：Throwable，T1，T2）（惰性作用域T1表达式，作用域T2委托（E）errorHandler）;</target>
        </trans-unit>
        <trans-unit id="106770f05acf1293b31c427d84352126dc825e9c" translate="yes" xml:space="preserve">
          <source>CommonType!(T1, T2) &lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;(T1, T2)(lazy scope T1 expression, scope T2 delegate(Exception) errorHandler);</source>
          <target state="translated">（T1，T2）&lt;strong id=&quot;ifThrown&quot;&gt;ifThrown&lt;/strong&gt;（T1，T2）（惰性作用域T1表达式，作用域T2委托（Exception）errorHandler）;</target>
        </trans-unit>
        <trans-unit id="d21cc02f1aab33002c403671fdd746279f33b65d" translate="yes" xml:space="preserve">
          <source>Communication semantics</source>
          <target state="translated">通信语义</target>
        </trans-unit>
        <trans-unit id="f24e56471fa8b175056938019fdeefa50ef168a7" translate="yes" xml:space="preserve">
          <source>Compare Expressions</source>
          <target state="translated">比较表达式</target>
        </trans-unit>
        <trans-unit id="caa535ca46ced3c4b33a96aab608929abbb4fdf9" translate="yes" xml:space="preserve">
          <source>Compare proposed template instantiation with existing template instantiation. Note that this is not commutative because of the auto ref check.</source>
          <target state="translated">比较建议的模板实例化和现有的模板实例化。请注意,由于自动参考检查的原因,这不是换算的。</target>
        </trans-unit>
        <trans-unit id="2c7808fae6354fb79882d9e3894f49385a385060" translate="yes" xml:space="preserve">
          <source>Compare two complex floating point numbers, x and y.</source>
          <target state="translated">比较两个复杂的浮点数,x和y。</target>
        </trans-unit>
        <trans-unit id="4b589fbc23973e0904ddeba8f483e18ded8c6fc2" translate="yes" xml:space="preserve">
          <source>Compare two lists using the comparison function fp. The comparison function is the same as used for qsort().</source>
          <target state="translated">使用比较函数fp比较两个列表。比较函数与qsort()使用的函数相同。</target>
        </trans-unit>
        <trans-unit id="53048e0cd3f3523910efe523391cf85f13b1f561" translate="yes" xml:space="preserve">
          <source>Compare two lists.</source>
          <target state="translated">比较两个名单。</target>
        </trans-unit>
        <trans-unit id="ec1ea853fba43ebac35e9589bc1b5421280f317a" translate="yes" xml:space="preserve">
          <source>Compare two name according to the platform's rules (case sensitive or not)</source>
          <target state="translated">根据平台的规则比较两个名字(区分大小写)。</target>
        </trans-unit>
        <trans-unit id="470f25e165e645b09541078696ae4bb01732c4b6" translate="yes" xml:space="preserve">
          <source>Compare two slices for equality, in a case-insensitive way</source>
          <target state="translated">比较两片是否平等,要分清大小写。</target>
        </trans-unit>
        <trans-unit id="a3b2aaa9a2feba60d75ca35ce0d9eaf6a325e5cf" translate="yes" xml:space="preserve">
          <source>Compare with another Object obj.</source>
          <target state="translated">与另一个Object obj比较。</target>
        </trans-unit>
        <trans-unit id="269cc9dfce30ec1e7d235e3871e31eeb2e9ea313" translate="yes" xml:space="preserve">
          <source>Compares 2 lambda functions described by their serialization.</source>
          <target state="translated">比较2个由其序列化描述的lambda函数。</target>
        </trans-unit>
        <trans-unit id="3514fc794b1b84ff2dcda58da47639190d167244" translate="yes" xml:space="preserve">
          <source>Compares &lt;code&gt;this&lt;/code&gt; against &lt;code&gt;rhs&lt;/code&gt; for equality. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpEquals&lt;/code&gt;, the function forwards to &lt;code&gt; hook.hookOpEquals(get, rhs)&lt;/code&gt;. Otherwise, the result of the built-in operation &lt;code&gt;get == rhs&lt;/code&gt; is returned.</source>
          <target state="translated">将 &lt;code&gt;this&lt;/code&gt; 与 &lt;code&gt;rhs&lt;/code&gt; 比较是否相等。如果 &lt;code&gt;Hook&lt;/code&gt; 定义了 &lt;code&gt;hookOpEquals&lt;/code&gt; ，则该函数将转发到 &lt;code&gt; hook.hookOpEquals(get, rhs)&lt;/code&gt; 。否则，将返回内置操作 &lt;code&gt;get == rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="834d94035a6f955e584fb4c7ba4b567912fa0d8a" translate="yes" xml:space="preserve">
          <source>Compares &lt;code&gt;this&lt;/code&gt; against &lt;code&gt;rhs&lt;/code&gt; for ordering. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpCmp&lt;/code&gt;, the function forwards to &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt;. Otherwise, the result of the built-in comparison operation is returned.</source>
          <target state="translated">将 &lt;code&gt;this&lt;/code&gt; 与 &lt;code&gt;rhs&lt;/code&gt; 比较以进行订购。如果 &lt;code&gt;Hook&lt;/code&gt; 定义了 &lt;code&gt;hookOpCmp&lt;/code&gt; ，则该函数将转发到 &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; 。否则，将返回内置比较操作的结果。</target>
        </trans-unit>
        <trans-unit id="8d72cb06967d76ad2315bc14800e16c84c791ad4" translate="yes" xml:space="preserve">
          <source>Compares file names and returns</source>
          <target state="translated">比较文件名并返回</target>
        </trans-unit>
        <trans-unit id="ed50f74df59a0142ddc654a4239b67d9a76c7149" translate="yes" xml:space="preserve">
          <source>Compares filename characters.</source>
          <target state="translated">比较文件名字符。</target>
        </trans-unit>
        <trans-unit id="2249aabcb1e96260d3051f1dca27aa7ab8ce5589" translate="yes" xml:space="preserve">
          <source>Compares ranges for element-by-element equality, e.g. &lt;code&gt;equal([1, 2, 3], [1.0, 2.0, 3.0])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">比较元素相等范围，例如 &lt;code&gt;equal([1, 2, 3], [1.0, 2.0, 3.0])&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffefd591caadf7c9238108ca12da950ac2e6a35f" translate="yes" xml:space="preserve">
          <source>Compares this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; with the given &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;与给定&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 进行比较&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15738864f6cafc73bd814277cd09c013ecd311e3" translate="yes" xml:space="preserve">
          <source>Compares this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; with the given &lt;code&gt;DateTime.&lt;/code&gt;.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;与给定的 &lt;code&gt;DateTime.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="689160a534f49b2dda3e4266c47b5941a7703870" translate="yes" xml:space="preserve">
          <source>Compares this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; with the given &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;与给定的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 进行比较&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8165c8a402fda4e1a1b6bfe46a9433cba2d560d" translate="yes" xml:space="preserve">
          <source>Compares this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; with the given &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;与给定的&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 进行比较&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe6b91ee80ba217913bf0d3b49282d731578146c" translate="yes" xml:space="preserve">
          <source>Compares this &lt;code&gt;Duration&lt;/code&gt; with the given &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">比较此 &lt;code&gt;Duration&lt;/code&gt; 与给定的 &lt;code&gt;Duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59460af8f5d8d95384b897b17a23456d8cbca065" translate="yes" xml:space="preserve">
          <source>Compares this MonoTime with the given MonoTime.</source>
          <target state="translated">将此MonoTime与给定的MonoTime进行比较。</target>
        </trans-unit>
        <trans-unit id="61073ed6151d4099d5b99ce170507850bbec3a0f" translate="yes" xml:space="preserve">
          <source>Compares two CDatas</source>
          <target state="translated">比较两个CDatas</target>
        </trans-unit>
        <trans-unit id="2feed28735d9cb020838db7c34238164751ec4e9" translate="yes" xml:space="preserve">
          <source>Compares two CDatas for equality</source>
          <target state="translated">比较两个CDatas是否平等</target>
        </trans-unit>
        <trans-unit id="cf953c71e71cad559a1b6f41099f639fc4b7a9a7" translate="yes" xml:space="preserve">
          <source>Compares two Documents</source>
          <target state="translated">比较两个文件</target>
        </trans-unit>
        <trans-unit id="155a80b4bbc808c799aa0f116b685c5ba6a2b770" translate="yes" xml:space="preserve">
          <source>Compares two Documents for equality</source>
          <target state="translated">对两份文件进行平等比较</target>
        </trans-unit>
        <trans-unit id="71867a59aab2e3bc4e1f645998ccc58f3385b507" translate="yes" xml:space="preserve">
          <source>Compares two Elements</source>
          <target state="translated">比较两个元素</target>
        </trans-unit>
        <trans-unit id="1c6b132b2fbac57463697b6c1796a4b2c009f21e" translate="yes" xml:space="preserve">
          <source>Compares two Elements for equality</source>
          <target state="translated">比较两个元素是否平等</target>
        </trans-unit>
        <trans-unit id="1de75b0a506aa6ed853b26b0a46cd0641566a633" translate="yes" xml:space="preserve">
          <source>Compares two Tags</source>
          <target state="translated">比较两个标签</target>
        </trans-unit>
        <trans-unit id="1c8a71eb2f93f8e19bd6763d1b05643346323e21" translate="yes" xml:space="preserve">
          <source>Compares two Tags for equality</source>
          <target state="translated">比较两个标签是否平等</target>
        </trans-unit>
        <trans-unit id="5b4c697a2d7145b631ee5e772ec59f8a1f518990" translate="yes" xml:space="preserve">
          <source>Compares two XML instructions</source>
          <target state="translated">比较两条XML指令</target>
        </trans-unit>
        <trans-unit id="d3f58d3dea043b6d22fc6cc7d29ac43c66b365bd" translate="yes" xml:space="preserve">
          <source>Compares two XML instructions for equality</source>
          <target state="translated">比较两个XML指令是否平等</target>
        </trans-unit>
        <trans-unit id="a047b0e437993116e7c77e0618c976828560c65e" translate="yes" xml:space="preserve">
          <source>Compares two comments</source>
          <target state="translated">比较两个评论</target>
        </trans-unit>
        <trans-unit id="5f0ccb1455dbbca2718693f6457fa9a0e4ab0a7e" translate="yes" xml:space="preserve">
          <source>Compares two comments for equality</source>
          <target state="translated">比较两份意见是否平等</target>
        </trans-unit>
        <trans-unit id="5cfb7b733711f89793eb5d1c213b36ce5b8619ff" translate="yes" xml:space="preserve">
          <source>Compares two instances for &amp;lt;, ==, or &amp;gt;.</source>
          <target state="translated">比较&amp;lt;，==或&amp;gt;的两个实例。</target>
        </trans-unit>
        <trans-unit id="8f551041ef1a130ca32a1c918d060ad148571f0b" translate="yes" xml:space="preserve">
          <source>Compares two instances for equality.</source>
          <target state="translated">比较两个实例是否平等。</target>
        </trans-unit>
        <trans-unit id="899d53ea8150068dbb59e10d9add2e1cdebde76c" translate="yes" xml:space="preserve">
          <source>Compares two processing instructions</source>
          <target state="translated">比较两个处理指令</target>
        </trans-unit>
        <trans-unit id="4f39f88ab522977bdc2f3dff102f72d43f0f9cc9" translate="yes" xml:space="preserve">
          <source>Compares two processing instructions for equality</source>
          <target state="translated">对两个处理指令进行平等比较</target>
        </trans-unit>
        <trans-unit id="8d5d39ab88f4f47308cef4f47f2b602afa70b300" translate="yes" xml:space="preserve">
          <source>Compares two ranges for equality, as defined by predicate &lt;code&gt;pred&lt;/code&gt; (which is &lt;code&gt;==&lt;/code&gt; by default).</source>
          <target state="translated">比较两个范围的相等性，如谓词 &lt;code&gt;pred&lt;/code&gt; 所定义（默认情况下 &lt;code&gt;==&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f81d47748b180086bf89fb2bd5331b855132ca4a" translate="yes" xml:space="preserve">
          <source>Compares two ranges for equality. The ranges may have different element types, as long as &lt;code&gt;pred(r1.front, r2.front)&lt;/code&gt; evaluates to &lt;code&gt;bool&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">比较两个范围是否相等。范围可以具有不同的元素类型，只要 &lt;code&gt;pred(r1.front, r2.front)&lt;/code&gt; 评估为 &lt;code&gt;bool&lt;/code&gt; 即可。执行 &lt;code&gt;pred&lt;/code&gt; 的 &amp;Omicron;（ &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ）个评估。</target>
        </trans-unit>
        <trans-unit id="248fdeb67d5d8ff8dea5a626cacfd8c772e6ff5b" translate="yes" xml:space="preserve">
          <source>Compares two text sections</source>
          <target state="translated">比较两个文本部分</target>
        </trans-unit>
        <trans-unit id="aea8d87c28bd8f8f4e53228c798c86d39471182a" translate="yes" xml:space="preserve">
          <source>Compares two text sections for equality</source>
          <target state="translated">对两个文本部分进行平等比较</target>
        </trans-unit>
        <trans-unit id="b96961131f8b2d56c0afdc08b9dfc3f261ece799" translate="yes" xml:space="preserve">
          <source>Compares two time unit strings at compile time. &lt;code&gt;&quot;years&quot;&lt;/code&gt; are the largest units and &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; are the smallest.</source>
          <target state="translated">在编译时比较两个时间单位字符串。 &lt;code&gt;&quot;years&quot;&lt;/code&gt; 是最大的单位， &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; 是最小的单位。</target>
        </trans-unit>
        <trans-unit id="73cfa7cb938dfbb7800d8b2d717f330ee6a481ac" translate="yes" xml:space="preserve">
          <source>Compares two time unit strings. &lt;code&gt;&quot;years&quot;&lt;/code&gt; are the largest units and &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; are the smallest.</source>
          <target state="translated">比较两个时间单位字符串。 &lt;code&gt;&quot;years&quot;&lt;/code&gt; 是最大的单位， &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; 是最小的单位。</target>
        </trans-unit>
        <trans-unit id="736528f0c2f124578ad75bec18127fa0c5d8df06" translate="yes" xml:space="preserve">
          <source>Compares two trees for equality.</source>
          <target state="translated">比较两棵树是否平等。</target>
        </trans-unit>
        <trans-unit id="8ea391c8d4e8b1e4cad6bceeb3d88e880c28dcc6" translate="yes" xml:space="preserve">
          <source>Compares with another InternetAddress of same type for equality</source>
          <target state="translated">与另一个相同类型的InternetAddress进行比较,以实现平等。</target>
        </trans-unit>
        <trans-unit id="49cdf7c2ab546d5587c6ee0331c985ef36d21ae1" translate="yes" xml:space="preserve">
          <source>Compares with another Item of same type</source>
          <target state="translated">与同类型的其他项目进行比较</target>
        </trans-unit>
        <trans-unit id="feedb86ff0053ef1f5bbf048b43463a97c30f866" translate="yes" xml:space="preserve">
          <source>Compares with another Item of same type for equality</source>
          <target state="translated">与另一个相同类型的项目进行平等比较。</target>
        </trans-unit>
        <trans-unit id="aa1d4e3fc8af232a8529a23e0a4021de49404caa" translate="yes" xml:space="preserve">
          <source>Comparing D Immutable and Const with C++ Const</source>
          <target state="translated">D Immutable和Const与C++Const的比较</target>
        </trans-unit>
        <trans-unit id="1cddc2b857fb24fec592019a977ade46bd8e0d9d" translate="yes" xml:space="preserve">
          <source>ComparingBenchmarkResult &lt;strong id=&quot;comparingBenchmark&quot;&gt;comparingBenchmark&lt;/strong&gt;(alias baseFunc, alias targetFunc, int times = 4095)();</source>
          <target state="translated">ComparingBenchmarkResult &lt;strong id=&quot;comparingBenchmark&quot;&gt;comparingBenchmark&lt;/strong&gt;（别名baseFunc，别名targetFunc，INT次= 4095）（）;</target>
        </trans-unit>
        <trans-unit id="2dfcf898a3bd4e011123eee87384ecb67d0919d4" translate="yes" xml:space="preserve">
          <source>Comparison</source>
          <target state="translated">Comparison</target>
        </trans-unit>
        <trans-unit id="d674be464fc3dfa9b4b4dc25d1b812f36bad0d19" translate="yes" xml:space="preserve">
          <source>Comparison for equality used by the &quot;==&quot; and &quot;!=&quot; operators.</source>
          <target state="translated">比较&quot;==&quot;和&quot;!=&quot;运算符所使用的平等。</target>
        </trans-unit>
        <trans-unit id="9b6db5f546098b8351c2a295c7a744c7f9c5b1f3" translate="yes" xml:space="preserve">
          <source>Comparison for equality.</source>
          <target state="translated">为平等而比较。</target>
        </trans-unit>
        <trans-unit id="27f31591aeeb71d8072850ad96cfcf618bb9c4b6" translate="yes" xml:space="preserve">
          <source>Comparison for equality. Two &lt;code&gt;Tuple&lt;/code&gt;s are considered equal &lt;b&gt;iff&lt;/b&gt; they fulfill the following criteria:</source>
          <target state="translated">比较平等。&lt;b&gt;如果&lt;/b&gt;满足以下条件，则认为两个 &lt;code&gt;Tuple&lt;/code&gt; 相等：&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="acd5826889c075fa96051d4ba9ec6abdd7e93115" translate="yes" xml:space="preserve">
          <source>Comparison for ordering.</source>
          <target state="translated">比较,以便订购。</target>
        </trans-unit>
        <trans-unit id="77915f2fa8db68346e105b6be7363156bb2e830c" translate="yes" xml:space="preserve">
          <source>Comparison is based on &lt;code&gt;char&lt;/code&gt; and does not do decoding. As a result, it's only really accurate for plain ASCII strings.</source>
          <target state="translated">比较基于 &lt;code&gt;char&lt;/code&gt; ，不进行解码。结果，它仅对于纯ASCII字符串才真正准确。</target>
        </trans-unit>
        <trans-unit id="50830d36fb34a645e85fdd460f20e839e99c57c9" translate="yes" xml:space="preserve">
          <source>Comparison operations are rewritten as follows:</source>
          <target state="translated">比较操作重写如下。</target>
        </trans-unit>
        <trans-unit id="4a8724559a94ef0fe371c3295abbffe07e7c73b1" translate="yes" xml:space="preserve">
          <source>Compatibility decomposition is a &lt;b&gt;lossy&lt;/b&gt; conversion, typically suitable only for fuzzy matching and internal processing.</source>
          <target state="translated">兼容性分解是&lt;b&gt;有损&lt;/b&gt;转换，通常仅适用于模糊匹配和内部处理。</target>
        </trans-unit>
        <trans-unit id="d515317076de8e82a7df9a5583ce6d1adb904fdc" translate="yes" xml:space="preserve">
          <source>Compatibility decomposition. The result is compatibility equivalent sequence.</source>
          <target state="translated">兼容性分解。结果是兼容性等价序列。</target>
        </trans-unit>
        <trans-unit id="47f75260822181977396612d26a17c9f895fd067" translate="yes" xml:space="preserve">
          <source>Compexity</source>
          <target state="translated">Compexity</target>
        </trans-unit>
        <trans-unit id="899c4bbe236b40b7f4f386ca0e1d495afd2b9909" translate="yes" xml:space="preserve">
          <source>Compile Time Disabling of &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 编译时禁用</target>
        </trans-unit>
        <trans-unit id="9601f2a530e239754089111cdf22a63d09d0da03" translate="yes" xml:space="preserve">
          <source>Compile Time Function Execution (CTFE)</source>
          <target state="translated">编译时函数执行(CTFE)</target>
        </trans-unit>
        <trans-unit id="111b991b8bd8902ab908d279507dbc2567386414" translate="yes" xml:space="preserve">
          <source>Compile regular expression pattern for the later execution.</source>
          <target state="translated">编译正则表达式模式,以便以后执行。</target>
        </trans-unit>
        <trans-unit id="277fb4d7b34b839316a7f89f2653d3a761832e8c" translate="yes" xml:space="preserve">
          <source>Compile regular expression using CTFE and generate optimized native machine code for matching it.</source>
          <target state="translated">使用CTFE编译正则表达式,并生成优化的本地机器代码进行匹配。</target>
        </trans-unit>
        <trans-unit id="f7f33f2933c6141df88a84f55a23e09ba130a02f" translate="yes" xml:space="preserve">
          <source>Compile the MixinType, returning the type AST.</source>
          <target state="translated">编译MixinType,返回AST类型。</target>
        </trans-unit>
        <trans-unit id="c8149cd52fe785ecf8f59126442a4f04b3761167" translate="yes" xml:space="preserve">
          <source>Compile-Time Authorization Callbacks</source>
          <target state="translated">编译时的授权回调</target>
        </trans-unit>
        <trans-unit id="5ce286997996977a2b237b29a86f8db1efc35204" translate="yes" xml:space="preserve">
          <source>Compile-Time Library Version Numbers</source>
          <target state="translated">编译时库版本号</target>
        </trans-unit>
        <trans-unit id="c1beaf7d1ab6d20b70616c28d06d81210d112960" translate="yes" xml:space="preserve">
          <source>Compile-time values</source>
          <target state="translated">编译时值</target>
        </trans-unit>
        <trans-unit id="31fa1f41f5b6804e8b506439e0a320efb83fde36" translate="yes" xml:space="preserve">
          <source>CompiledCtfeFunctionPimpl &lt;strong id=&quot;ctfeCode&quot;&gt;ctfeCode&lt;/strong&gt;;</source>
          <target state="translated">CompiledCtfeFunctionPimpl &lt;strong id=&quot;ctfeCode&quot;&gt;ctfeCode&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="7ab8d68f763422663c5a51a1109f0f26969187ef" translate="yes" xml:space="preserve">
          <source>Compiler Checks</source>
          <target state="translated">编译器检查</target>
        </trans-unit>
        <trans-unit id="dae36f6f6064ffef1e1754fc1a3db46d87b57e16" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the &lt;a href=&quot;http://www.dlang.org&quot;&gt;D programming language&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.dlang.org&quot;&gt;D编程语言的&lt;/a&gt;编译器实现</target>
        </trans-unit>
        <trans-unit id="14f91068413d32dc45e209e13c1a52a0c98a2adc" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the &lt;a href=&quot;http://www.dlang.org&quot;&gt;D programming language&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.dlang.org&quot;&gt;D编程语言的&lt;/a&gt;编译器实现。</target>
        </trans-unit>
        <trans-unit id="638d4fafd817156b7a7b919c2d357c7a4e40fecd" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the &lt;a href=&quot;http://www.dlang.org&quot;&gt;D programming language&lt;/a&gt;. Entry point for DMD.</source>
          <target state="translated">&lt;a href=&quot;http://www.dlang.org&quot;&gt;D编程语言的&lt;/a&gt;编译器实现。DMD的入口点。</target>
        </trans-unit>
        <trans-unit id="cb9f3472430d511bc2a1cab99cbca60b61a1a542" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the &lt;a href=&quot;http://www.dlang.org&quot;&gt;D programming language&lt;/a&gt;. Utility functions for DMD.</source>
          <target state="translated">&lt;a href=&quot;http://www.dlang.org&quot;&gt;D编程语言的&lt;/a&gt;编译器实现。DMD的实用程序功能。</target>
        </trans-unit>
        <trans-unit id="a308cc3158cc4a66d0a8f5bf6d0eff2374e034a3" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the D programming language &lt;a href=&quot;http://dlang.org&quot;&gt;http://dlang.org&lt;/a&gt;</source>
          <target state="translated">D编程语言的编译器实现&lt;a href=&quot;http://dlang.org&quot;&gt;http://dlang.org&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1d6503c070a457a61fda17f2153cd21a3084d96" translate="yes" xml:space="preserve">
          <source>Compiler implementation of the D programming language &lt;a href=&quot;http://dlang.org&quot;&gt;http://dlang.org&lt;/a&gt; This file is not shared with other compilers which use the DMD front-end.</source>
          <target state="translated">D编程语言&lt;a href=&quot;http://dlang.org&quot;&gt;http://dlang.org的&lt;/a&gt;编译器实现。此文件不与使用DMD前端的其他编译器共享。</target>
        </trans-unit>
        <trans-unit id="67b78e834ccfc3fb4d626c14e19e68b2f93a8064" translate="yes" xml:space="preserve">
          <source>Compiler vendor could not be detected</source>
          <target state="translated">无法检测到编译器供应商</target>
        </trans-unit>
        <trans-unit id="4dcbf24d21d00f4926da34a218b3790f5b4e8f04" translate="yes" xml:space="preserve">
          <source>Compiler vendor specific versions can be predefined if the trademarked vendor identifier prefixes it, as in:</source>
          <target state="translated">如果有商标的供应商标识符前缀,可以预定义编译器特定的版本,如:。</target>
        </trans-unit>
        <trans-unit id="9879770228628f9210415d896412d02eb35c7ccc" translate="yes" xml:space="preserve">
          <source>Compiler vendor string</source>
          <target state="translated">编译器供应商字符串</target>
        </trans-unit>
        <trans-unit id="89ab065950932906f0c70953836cc3d876a0f5c7" translate="yes" xml:space="preserve">
          <source>Compiler version as an integer</source>
          <target state="translated">编译版本为整数</target>
        </trans-unit>
        <trans-unit id="7bfb67af50943c68cc8db4a086f448c070c20b10" translate="yes" xml:space="preserve">
          <source>Compiling An SQL Statement</source>
          <target state="translated">编译SQL语句</target>
        </trans-unit>
        <trans-unit id="6f279773bb3b6d94a13d70e62a02f07420245fdd" translate="yes" xml:space="preserve">
          <source>Compiling the two files, the first with a C++ compiler, the second with a D compiler, linking them together, and then running it yields:</source>
          <target state="translated">编译这两个文件,第一个文件用C++编译器编译,第二个文件用D编译器编译,把它们连接在一起,然后运行就可以得到。</target>
        </trans-unit>
        <trans-unit id="e44e982f24d61ce8d41fc7d68d07e93d8ea91560" translate="yes" xml:space="preserve">
          <source>Compiling, linking, and running produces the output:</source>
          <target state="translated">编译、链接、运行后产生输出。</target>
        </trans-unit>
        <trans-unit id="364056731803da7d64b4bd1e1c06e2898671284f" translate="yes" xml:space="preserve">
          <source>Complement Expressions</source>
          <target state="translated">补充表达式</target>
        </trans-unit>
        <trans-unit id="13fa3d3fb38078f1c48463c71e72cdb5396d3061" translate="yes" xml:space="preserve">
          <source>Complement the list of characters in &lt;code&gt;from&lt;/code&gt;</source>
          <target state="translated">补字符的列表 &lt;code&gt;from&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28e3cfba20327bd23ec2cb2a7627c4989a6658fd" translate="yes" xml:space="preserve">
          <source>ComplementExpression</source>
          <target state="translated">ComplementExpression</target>
        </trans-unit>
        <trans-unit id="f8ad3ce6091208da960c4f9ee62d22e28a03304d" translate="yes" xml:space="preserve">
          <source>Complementary error function</source>
          <target state="translated">互补误差函数</target>
        </trans-unit>
        <trans-unit id="60272d7a34e9d3443f3926aeffc1c58edec5ebed" translate="yes" xml:space="preserve">
          <source>Completes in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) steps for ranges that support slicing and have length. Completes in &amp;Omicron;(&lt;code&gt;range.length&lt;/code&gt;) time for all other ranges.</source>
          <target state="translated">对于支持切片并具有长度的范围，以&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）步骤完成。对于所有其他范围，以&amp;Omicron;（ &lt;code&gt;range.length&lt;/code&gt; ）时间完成。</target>
        </trans-unit>
        <trans-unit id="c324110011c7213010b1b0d05dbf1729490872c8" translate="yes" xml:space="preserve">
          <source>Complex!F[] &lt;strong id=&quot;fft&quot;&gt;fft&lt;/strong&gt;(F = double, R)(R range);</source>
          <target state="translated">F！] &lt;strong id=&quot;fft&quot;&gt;fft&lt;/strong&gt;（F = double，R）（R范围）;</target>
        </trans-unit>
        <trans-unit id="26f92c913e85906bb3fdfd3ea8f70b3edc75f349" translate="yes" xml:space="preserve">
          <source>Complex!F[] &lt;strong id=&quot;inverseFft&quot;&gt;inverseFft&lt;/strong&gt;(F = double, R)(R range);</source>
          <target state="translated">F！] &lt;strong id=&quot;inverseFft&quot;&gt;inverseFft&lt;/strong&gt;（F = double，R）（R范围）;</target>
        </trans-unit>
        <trans-unit id="9bcb9bd086a1d4b769b555d5e43ad8175d34e8e1" translate="yes" xml:space="preserve">
          <source>Complex!T &lt;code&gt;z&lt;/code&gt;</source>
          <target state="translated">复杂的T！ &lt;code&gt;z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f564777ac40c723997c5eed12787c64f393c6531" translate="yes" xml:space="preserve">
          <source>Complexity</source>
          <target state="translated">Complexity</target>
        </trans-unit>
        <trans-unit id="47da6f0838f083d3a01f384d483b468a305c5a2c" translate="yes" xml:space="preserve">
          <source>Compose</source>
          <target state="translated">Compose</target>
        </trans-unit>
        <trans-unit id="95aa63ea8e2a3bfd87e37ac5a85ae9bd67fcad2c" translate="yes" xml:space="preserve">
          <source>Composes passed-in functions &lt;code&gt;fun[0], fun[1], ...&lt;/code&gt;.</source>
          <target state="translated">组成传入的功能 &lt;code&gt;fun[0], fun[1], ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c30048c94daf4d26e828fea1daf807749cf7065" translate="yes" xml:space="preserve">
          <source>Composite allocators involving nested instantiations of &lt;code&gt;Segregator&lt;/code&gt; make it difficult to access individual sub-allocators stored within. &lt;code&gt; allocatorForSize&lt;/code&gt; simplifies the task by supplying the allocator nested inside a &lt;code&gt;Segregator&lt;/code&gt; that is responsible for a specific size &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">涉及到 &lt;code&gt;Segregator&lt;/code&gt; 的嵌套实例化的复合分配器使访问存储在其中的各个子分配器变得困难。 &lt;code&gt; allocatorForSize&lt;/code&gt; 通过提供嵌套在负责特定大小 &lt;code&gt;s&lt;/code&gt; 的 &lt;code&gt;Segregator&lt;/code&gt; 中的分配器来简化任务。</target>
        </trans-unit>
        <trans-unit id="34ec312f3176cda38964288e354f29e0c4b397f3" translate="yes" xml:space="preserve">
          <source>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;, then adapt the composed allocator to &lt;code&gt;IAllocator&lt;/code&gt; (possibly by using &lt;a href=&quot;#CAllocatorImpl&quot;&gt;&lt;code&gt;CAllocatorImpl&lt;/code&gt;&lt;/a&gt; below).</source>
          <target state="translated">由于动态接口的灵活性以及级联的多个调用导致的效率低下，因此不建议在此级别上分配分配器。取而代之的是，使用&lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; 中&lt;/a&gt;定义的静态接口组成分配器，然后将组合的分配器修改为 &lt;code&gt;IAllocator&lt;/code&gt; （可能使用下面的&lt;a href=&quot;#CAllocatorImpl&quot;&gt; &lt;code&gt;CAllocatorImpl&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
