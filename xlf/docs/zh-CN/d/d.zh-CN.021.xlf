<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="4f7fc9a2d05fa0c5c4b7879d385797376ea8299d" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;IAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built allocator type to &lt;code&gt;IAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">用 &lt;code&gt;Allocator&lt;/code&gt; 实现 &lt;code&gt;IAllocator&lt;/code&gt; 。这 &lt;code&gt;IAllocator&lt;/code&gt; 静态构建的分配器类型改编为IAllocator，该类型可以由非模板代码直接使用。</target>
        </trans-unit>
        <trans-unit id="fafacd0c4afbb4ff4bf1edadf17fafe457e3c87e" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;ISharedAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built, shareable across threads, allocator type to &lt;code&gt;ISharedAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">使用 &lt;code&gt;Allocator&lt;/code&gt; 实现 &lt;code&gt;ISharedAllocator&lt;/code&gt; 。这使静态构建的，可跨线程共享的分配器类型适应 &lt;code&gt;ISharedAllocator&lt;/code&gt; ，该类型可由非模板代码直接使用。</target>
        </trans-unit>
        <trans-unit id="bcbaffe82dd8f12aeaf4d1ff9d3011fef84404a6" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendT&lt;/code&gt; and &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;_d_arrayappendT&lt;/code&gt; 和 &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10e497f26133fe54aedbc1b0186f76a3533b685" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; and &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; 和 &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7db4a8478e7cad025fd1104c777c36390076d0e1" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraycatnTX&lt;/code&gt; and &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;_d_arraycatnTX&lt;/code&gt; 和 &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abbaa69f0e232671973ab5e6491f136e6a29871" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; and &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; 和 &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f9ad487b035fc97c0af04b8b66abb8578971a5f" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt; red-black tree&lt;/a&gt; container.</source>
          <target state="translated">实现一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;红黑树&lt;/a&gt;容器。</target>
        </trans-unit>
        <trans-unit id="8e7df8ae1e56f997a5b65b6b6877c23f0d64f3a3" translate="yes" xml:space="preserve">
          <source>Implementation of alloca() standard C routine.</source>
          <target state="translated">alloca()标准C例程的实现。</target>
        </trans-unit>
        <trans-unit id="1784dc78d2b897ccf07f36701bfc5665f7a4b791" translate="yes" xml:space="preserve">
          <source>Implementation of array assignment support routines.</source>
          <target state="translated">数组赋值支持例程的实现。</target>
        </trans-unit>
        <trans-unit id="a39c70c382be4565515493d462dbbec04eaf7781" translate="yes" xml:space="preserve">
          <source>Implementation of array copy support routines.</source>
          <target state="translated">数组复制支持例程的实现。</target>
        </trans-unit>
        <trans-unit id="0bdc6417eff40a113a2fe81fc65ab41a4dcaba32" translate="yes" xml:space="preserve">
          <source>Implementation of associative arrays.</source>
          <target state="translated">关联数组的实现。</target>
        </trans-unit>
        <trans-unit id="07784c9ff6fc80ea8be9db66531869c595761785" translate="yes" xml:space="preserve">
          <source>Implementation of code coverage analyzer.</source>
          <target state="translated">实现代码覆盖率分析器。</target>
        </trans-unit>
        <trans-unit id="fad1778f18239a1620ff2a279ed8dce89c92aba4" translate="yes" xml:space="preserve">
          <source>Implementation of dynamic array property support routines.</source>
          <target state="translated">动态数组属性支持例程的实现。</target>
        </trans-unit>
        <trans-unit id="1c44b949de0c9066379af30ba926638e5089c3a0" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines for Win32.</source>
          <target state="translated">实现Win32的异常处理支持例程。</target>
        </trans-unit>
        <trans-unit id="7d3ce3a8f354f9946b2098d37781419df42c1fa9" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines.</source>
          <target state="translated">异常处理支持例程的实现。</target>
        </trans-unit>
        <trans-unit id="4262710c1f4443ad04091f6eaee82248c8735a23" translate="yes" xml:space="preserve">
          <source>Implementation of invariant support routines.</source>
          <target state="translated">实现不变的支持例程。</target>
        </trans-unit>
        <trans-unit id="3dad8ae42692f0a5067da5335623cc0faae36caa" translate="yes" xml:space="preserve">
          <source>Implementation of standard Base64 encoding.</source>
          <target state="translated">实现标准Base64编码。</target>
        </trans-unit>
        <trans-unit id="8bb4407a3328a42063117ac1cd37abce98147582" translate="yes" xml:space="preserve">
          <source>Implementation of support routines for synchronized blocks.</source>
          <target state="translated">实现同步块的支持例程。</target>
        </trans-unit>
        <trans-unit id="36a7e10f19e92847926357311b55d0e017f473ef" translate="yes" xml:space="preserve">
          <source>Implementations are free to assume that GC pointers are only stored on word boundaries. Unaligned pointers may be ignored entirely.</source>
          <target state="translated">实现可以自由假设GC指针只存储在字的边界上。不对齐的指针可以完全忽略。</target>
        </trans-unit>
        <trans-unit id="a8c2ed8c7bf790ca62a6ccc79e874d26201eb456" translate="yes" xml:space="preserve">
          <source>Implementations are free to run collections at any point. It is, however, recommendable to only do so when an allocation attempt happens and there is insufficient memory available.</source>
          <target state="translated">实现可以在任何时候自由运行集合。然而,建议只有在发生分配尝试且可用内存不足时才这样做。</target>
        </trans-unit>
        <trans-unit id="7bedeb01a44e9992494ae61fc2e61ab874f0844b" translate="yes" xml:space="preserve">
          <source>Implementations are free to scan the non-root heap in a precise manner, so that fields of types like &lt;code&gt;float&lt;/code&gt; will not be considered relevant when scanning the heap. Thus, casting a GC pointer to an integral type (e.g. &lt;code&gt;size_t&lt;/code&gt;) and storing it in a field of that type inside the GC heap may mean that it will not be recognized if the memory block was allocated with precise type info or with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">实现可以自由地以精确的方式扫描非根堆，因此在扫描堆时，像 &lt;code&gt;float&lt;/code&gt; 这样的类型的字段将不被视为相关。因此，将GC指针强制转换为整数类型（例如 &lt;code&gt;size_t&lt;/code&gt; ）并将其存储在GC堆内的该类型的字段中可能意味着，如果使用精确的类型信息或 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; 分配了内存块，则无法识别该指针。 BlkAttr。NO_SCAN属性。</target>
        </trans-unit>
        <trans-unit id="3fe2d13e1a38447a1ccf3bcf63459da389a3bd8d" translate="yes" xml:space="preserve">
          <source>Implementations may restrict the file name in order to avoid directory traversal security vulnerabilities. A possible restriction might be to disallow any path components in the file name.</source>
          <target state="translated">实现可以限制文件名,以避免目录遍历的安全漏洞。一个可能的限制是不允许文件名中包含任何路径成分。</target>
        </trans-unit>
        <trans-unit id="41da860cb79fe7312e55548bf43ef9ac07ff278f" translate="yes" xml:space="preserve">
          <source>Implementations must diagnose an error for unrecognized</source>
          <target state="translated">实施时必须对未识别的</target>
        </trans-unit>
        <trans-unit id="007c721ddd0f22de039d1ec5d207cce979d8d6f0" translate="yes" xml:space="preserve">
          <source>Implementations must support interior pointers. That is, if the only reference to a GC-managed memory block points into the middle of the block rather than the beginning (for example), the GC must consider the memory block live. The exception to this rule is when a memory block is allocated with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; attribute; it is the user's responsibility to make sure such memory blocks have a proper pointer to them when they should be considered live.</source>
          <target state="translated">实现必须支持内部指针。也就是说，如果仅对GC管理的内存块的引用指向该块的中间而不是开头（例如），则GC必须考虑该内存块处于活动状态。该规则的例外情况是当使用 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; 分配了内存块时。NO_INTERIOR属性；用户有责任在应认为这些内存块处于活动状态时确保它们具有正确的指针。</target>
        </trans-unit>
        <trans-unit id="db108dbc2de097787f6ddeb0832f02909642f907" translate="yes" xml:space="preserve">
          <source>Implementations of D on different architectures, however, are free to innovate upon the memory model, function call/return conventions, argument passing conventions, etc.</source>
          <target state="translated">然而,D在不同架构上的实现,可以在内存模型、函数调用/返回约定、参数传递约定等方面自由创新。</target>
        </trans-unit>
        <trans-unit id="d7a03fc44da9f306060241398ee57db5f3a7d7aa" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; and &lt;code&gt;pthread_condition&lt;/code&gt; on Posix and &lt;code&gt;CreateEvent&lt;/code&gt; and &lt;code&gt;SetEvent&lt;/code&gt; on Windows.</source>
          <target state="translated">在Posix上使用 &lt;code&gt;pthread_mutex&lt;/code&gt; 和 &lt;code&gt;pthread_condition&lt;/code&gt; 以及在Windows 上使用 &lt;code&gt;CreateEvent&lt;/code&gt; 和 &lt;code&gt;SetEvent&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="9e4c63b7ecbb7ff73a2154a224607de77b4347f8" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; on Posix and &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; on Windows.</source>
          <target state="translated">在Posix 上使用 &lt;code&gt;pthread_mutex&lt;/code&gt; 和Windows 上使用 &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; 实施。</target>
        </trans-unit>
        <trans-unit id="cf9e08c7271694a3ffd216903295953184c6b554" translate="yes" xml:space="preserve">
          <source>Implementing a Scheduler allows the concurrency mechanism used by this module to be customized according to different needs. By default, a call to spawn will create a new kernel thread that executes the supplied routine and terminates when finished. But it is possible to create Schedulers that reuse threads, that multiplex Fibers (coroutines) across a single thread, or any number of other approaches. By making the choice of Scheduler a user-level option, std.concurrency may be used for far more types of application than if this behavior were predefined.</source>
          <target state="translated">实现Scheduler后,可以根据不同的需求定制本模块使用的并发机制。默认情况下,调用 spawn 会创建一个新的内核线程,执行所提供的例程,并在完成后终止。但是可以创建重用线程的Scheduler,在一个线程上复用Fibers(coroutine),或者其他任何数量的方法。通过将Scheduler的选择作为用户级选项,std.concurrency可以用于更多类型的应用,而不是预定义的行为。</target>
        </trans-unit>
        <trans-unit id="b264d3336b750c35148a8818568f62fa13927441" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in integers.</source>
          <target state="translated">实现 &lt;code&gt;BigInt&lt;/code&gt; 与 &lt;code&gt;BigInt&lt;/code&gt; 或 &lt;code&gt;BigInt&lt;/code&gt; 与内置整数的三向比较。</target>
        </trans-unit>
        <trans-unit id="743a0f20b096bcb05c253ba31f822dbd89e201db" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in numeric types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4e8dcbc761da7358b8c9aa098a3c08bb0a396c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integer types.</source>
          <target state="translated">与其他 &lt;code&gt;BigInt&lt;/code&gt; 和内置整数类型一起实现 &lt;code&gt;BigInt&lt;/code&gt; 相等性测试。</target>
        </trans-unit>
        <trans-unit id="e054a06d7d946c45c195d9bbf3b1556b4724d8bb" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in numeric types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca26966771a4b63b83cfa749d58cb4c74bd1074" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; unary operators.</source>
          <target state="translated">实现 &lt;code&gt;BigInt&lt;/code&gt; 一元运算符。</target>
        </trans-unit>
        <trans-unit id="6a3cb51c99d7f39233c1830869fb1b564b310297" translate="yes" xml:space="preserve">
          <source>Implements a &quot;tee&quot; style pipe, wrapping an input range so that elements of the range can be passed to a provided function or &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt; as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to &lt;code&gt;front&lt;/code&gt; or &lt;code&gt;popFront&lt;/code&gt;, or diverting the elements of a range into an auxiliary &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现一个&amp;ldquo; tee&amp;rdquo;样式的管道，包装一个输入范围，以便该范围元素可以在迭代时传递到提供的函数或&lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt;。这对于打印一长串范围代码中的中间值，在对 &lt;code&gt;front&lt;/code&gt; 或 &lt;code&gt;popFront&lt;/code&gt; 的每次调用中执行带有副作用的某些操作，或将范围的元素转移到辅助&lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; 中很有用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edd807624e1eff53b60fc0fdcb84a1a01a914908" translate="yes" xml:space="preserve">
          <source>Implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; container on top of a given random-access range type (usually &lt;code&gt;T[]&lt;/code&gt;) or a random-access container type (usually &lt;code&gt;Array!T&lt;/code&gt;). The documentation of &lt;code&gt;BinaryHeap&lt;/code&gt; will refer to the underlying range or container as the</source>
          <target state="translated">在给定的随机访问范围类型（​​通常为 &lt;code&gt;T[]&lt;/code&gt; ）或随机访问容器类型（通常为 &lt;code&gt;Array!T&lt;/code&gt; ）的顶部实现一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;二进制堆&lt;/a&gt;容器。 &lt;code&gt;BinaryHeap&lt;/code&gt; 的文档将基础范围或容器称为</target>
        </trans-unit>
        <trans-unit id="826e19cc42c27271edbc14035290489f9b886abe" translate="yes" xml:space="preserve">
          <source>Implements a doubly-linked list.</source>
          <target state="translated">执行双链路列表。</target>
        </trans-unit>
        <trans-unit id="6c4a9e8241b5f111ea434df2fe96c036c8c94979" translate="yes" xml:space="preserve">
          <source>Implements a narrowing remainder operation with built-in integer types.</source>
          <target state="translated">实现了一个内置整数类型的缩小余数操作。</target>
        </trans-unit>
        <trans-unit id="27ed74a2d7c34a4b3c0b18b681929b4fe9236374" translate="yes" xml:space="preserve">
          <source>Implements a parallel foreach loop over a range. This works by implicitly creating and submitting one &lt;code&gt;Task&lt;/code&gt; to the &lt;code&gt;TaskPool&lt;/code&gt; for each worker thread. A work unit is a set of consecutive elements of &lt;code&gt;range&lt;/code&gt; to be processed by a worker thread between communication with any other thread. The number of elements processed per work unit is controlled by the &lt;code&gt;workUnitSize&lt;/code&gt; parameter. Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit. Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger &lt;code&gt;workUnitSize&lt;/code&gt; should be. For very expensive loop bodies, &lt;code&gt;workUnitSize&lt;/code&gt; should be 1. An overload that chooses a default work unit size is also available.</source>
          <target state="translated">在一个范围内实现并行的foreach循环。这可以通过为每个工作线程隐式创建一个 &lt;code&gt;Task&lt;/code&gt; 并将其提交到 &lt;code&gt;TaskPool&lt;/code&gt; 来实现。工作单元是工作线程与任何其他线程之间进行通信时要处理的 &lt;code&gt;range&lt;/code&gt; 连续元素。每个工作单元处理的元素数由 &lt;code&gt;workUnitSize&lt;/code&gt; 参数控制。较小的工作单元可提供更好的负载平衡，但是较大的工作单元可避免与其他线程频繁通信以获取下一个工作单元的开销。在修改范围的情况下，大型工作单位还可以避免错误共享。循环的一次迭代花费的时间越 &lt;code&gt;workUnitSize&lt;/code&gt; 越大应该。对于非常昂贵的循环体， &lt;code&gt;workUnitSize&lt;/code&gt; 应该为1。还可以选择默认工作单元大小的重载。</target>
        </trans-unit>
        <trans-unit id="826fe4a31de6fc5bfd32223112c616b546ef30ea" translate="yes" xml:space="preserve">
          <source>Implements a simple and fast singly-linked list. It can be used as a stack.</source>
          <target state="translated">实现一个简单快速的单链路列表。它可以作为一个堆栈使用。</target>
        </trans-unit>
        <trans-unit id="1e7f8a9f41236aa959250c83a21042416cfb7001" translate="yes" xml:space="preserve">
          <source>Implements an output range that appends data to an array. This is recommended over &lt;code&gt;array ~= data&lt;/code&gt; when appending many elements because it is more efficient. &lt;code&gt;Appender&lt;/code&gt; maintains its own array metadata locally, so it can avoid global locking for each append where &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; is non-zero.</source>
          <target state="translated">实现将数据追加到数组的输出范围。在附加许多元素时，建议在 &lt;code&gt;array ~= data&lt;/code&gt; ，因为这样做效率更高。 &lt;code&gt;Appender&lt;/code&gt; 会在本地维护自己的数组元数据，因此可以避免&lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;不为零的每个追加的全局锁定。</target>
        </trans-unit>
        <trans-unit id="eb1006ae1765bc7db00ba2578ee369f0e577a7bc" translate="yes" xml:space="preserve">
          <source>Implements assignment operators from built-in integers of the form &lt;code&gt;BigInt op= integer&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;BigInt op= integer&lt;/code&gt; 形式的内置整数实现赋值运算符。</target>
        </trans-unit>
        <trans-unit id="a6bf741a9ca55b772fcf287918db9b994810ba0a" translate="yes" xml:space="preserve">
          <source>Implements assignment operators of the form &lt;code&gt;BigInt op= BigInt&lt;/code&gt;.</source>
          <target state="translated">实现形式为 &lt;code&gt;BigInt op= BigInt&lt;/code&gt; 赋值运算符。</target>
        </trans-unit>
        <trans-unit id="e1ea709e7bbd408cd7bf94a6f215f7f14ae10aa2" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integers.</source>
          <target state="translated">在 &lt;code&gt;BigInt&lt;/code&gt; 和内置整数之间实现二进制运算符。</target>
        </trans-unit>
        <trans-unit id="df47e55b92aed2a9c5b877779b4fc9382af7ea1f" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;BigInt&lt;/code&gt; 之间实现二进制运算符。</target>
        </trans-unit>
        <trans-unit id="c38b2eea1063f17593adb5371b20a04e888bc589" translate="yes" xml:space="preserve">
          <source>Implements casting to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">农具铸造 &lt;code&gt;bool&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="6ee42dc119af151bac3c17e9bd85af0bb4e977a1" translate="yes" xml:space="preserve">
          <source>Implements casting to floating point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612c7a1e4ee8aa3a5eb36e62f5d1886edb7c32a6" translate="yes" xml:space="preserve">
          <source>Implements casting to integer types.</source>
          <target state="translated">实现对整数类型的转换。</target>
        </trans-unit>
        <trans-unit id="d027822363fbfc370a577e3a5cc7b4b903013cad" translate="yes" xml:space="preserve">
          <source>Implements casting to/from qualified &lt;code&gt;BigInt&lt;/code&gt;'s.</source>
          <target state="translated">实现与合格 &lt;code&gt;BigInt&lt;/code&gt; 之间的转换。</target>
        </trans-unit>
        <trans-unit id="ff4cc4fdb32d0e79c9536f6d66d8396bbf61c41a" translate="yes" xml:space="preserve">
          <source>Implements common functionality for StaticForeachDeclaration and StaticForeachStatement This performs the necessary lowerings before dmd.statementsem.makeTupleForeach can be used to expand the corresponding &lt;code&gt;static foreach&lt;/code&gt; declaration or statement.</source>
          <target state="translated">实现StaticForeachDeclaration和StaticForeachStatement的通用功能在执行dmd.statementsem.makeTupleForeach可以用来扩展相应的 &lt;code&gt;static foreach&lt;/code&gt; 声明或语句之前，此步骤将执行必要的降低操作。</target>
        </trans-unit>
        <trans-unit id="33e291a05be91fd5868ef9b486e72f36172b61e4" translate="yes" xml:space="preserve">
          <source>Implements functionality to read Comma Separated Values and its variants from an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">工具的功能来读取逗号分隔值和它的变体从&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;的 &lt;code&gt;dchar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78fb12359a92b10736f7ddffd604a688feb1037" translate="yes" xml:space="preserve">
          <source>Implements logging facilities.</source>
          <target state="translated">实施伐木设施。</target>
        </trans-unit>
        <trans-unit id="1c9526ff0c5c9d17f08ea2d94e25202e075b8278" translate="yes" xml:space="preserve">
          <source>Implements low-level time primitives.</source>
          <target state="translated">实现低级时间基元。</target>
        </trans-unit>
        <trans-unit id="f10aa3fdc814d436934036f8b3d2932b2c1a116c" translate="yes" xml:space="preserve">
          <source>Implements mixin types.</source>
          <target state="translated">执行混合类型。</target>
        </trans-unit>
        <trans-unit id="5720cf3a68f9171f96627020e4e3f8a88a48971a" translate="yes" xml:space="preserve">
          <source>Implements operators with built-in integers on the left-hand side and &lt;code&gt;BigInt&lt;/code&gt; on the right-hand side.</source>
          <target state="translated">用左侧的内置整数和右侧的 &lt;code&gt;BigInt&lt;/code&gt; 实现运算符。</target>
        </trans-unit>
        <trans-unit id="7e5de803b2338c86b3532da481b13f228f6a981e" translate="yes" xml:space="preserve">
          <source>Implements routines related to exceptions.</source>
          <target state="translated">执行与异常相关的例程。</target>
        </trans-unit>
        <trans-unit id="f320bc582113b4cafa3cdb495549c72756dd174e" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; (unary and binary), &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">器具饱和度为运营商 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; （一元和二元）， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;^^&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12ddcd2c7713838aaff094e0d8442224022b567f" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This hook is called if the result of the binary operation does not fit in &lt;code&gt;Lhs&lt;/code&gt; without loss of information or a change in sign.</source>
          <target state="translated">为运算符 &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; ， &lt;code&gt;*=&lt;/code&gt; ， &lt;code&gt;/=&lt;/code&gt; ， &lt;code&gt;%=&lt;/code&gt; ， &lt;code&gt;^^=&lt;/code&gt; ， &lt;code&gt;&amp;amp;=&lt;/code&gt; ， &lt;code&gt;|=&lt;/code&gt; ， &lt;code&gt;^=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 实现饱和。如果二进制运算的结果不适合 &lt;code&gt;Lhs&lt;/code&gt; 而不会丢失信息或更改符号，则调用此钩子。</target>
        </trans-unit>
        <trans-unit id="be45676fa18a18d1d8737b834959d03a5f13376c" translate="yes" xml:space="preserve">
          <source>Implements the 'common' IEEE CRC32 variant (LSB-first order, Initial value uint.max, complement result)</source>
          <target state="translated">实施 &quot;常见的 &quot;IEEE CRC32变体(LSB-first order,初始值uint.max,补码结果)</target>
        </trans-unit>
        <trans-unit id="c54fb55bf997400be69c40f0614b3e9b7db9616f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;secant method&lt;/a&gt; for finding a root of the function &lt;code&gt;fun&lt;/code&gt; starting from points &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (ideally close to the root). &lt;code&gt;Num&lt;/code&gt; may be &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;割线方法&lt;/a&gt;，以从 &lt;code&gt;[xn_1, x_n]&lt;/code&gt; 点开始（理想地靠近根）找到函数 &lt;code&gt;fun&lt;/code&gt; 的根。 &lt;code&gt;Num&lt;/code&gt; 可以是 &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 或 &lt;code&gt;real&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b80a316e588d021f8c65a6036707b88ad521159" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;OutputRange&lt;/code&gt; interface for all types E and wraps the &lt;code&gt;put&lt;/code&gt; method for each type &lt;code&gt;E&lt;/code&gt; in a virtual function.</source>
          <target state="translated">为所有类型E 实现 &lt;code&gt;OutputRange&lt;/code&gt; 接口，并在虚拟函数中包装每种类型 &lt;code&gt;E&lt;/code&gt; 的 &lt;code&gt;put&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="09d37307ce6ae6ae1585ab5db7a54050805cc742" translate="yes" xml:space="preserve">
          <source>Implements the MurmurHash3 functions. You can specify the &lt;code&gt;size&lt;/code&gt; of the hash in bit. For 128 bit hashes you can specify whether to optimize for 32 or 64 bit architectures. If you don't specify the &lt;code&gt;opt&lt;/code&gt; value it will select the fastest version of the host platform.</source>
          <target state="translated">实现MurmurHash3函数。您可以按位指定哈希的 &lt;code&gt;size&lt;/code&gt; 。对于128位哈希，您可以指定是针对32位架构还是64位架构进行优化。如果不指定 &lt;code&gt;opt&lt;/code&gt; 值，它将选择主机平台的最快版本。</target>
        </trans-unit>
        <trans-unit id="7ab18d84fa65349ea46fc1a23e6ee0555763f6a9" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json arrays.</source>
          <target state="translated">为json数组实现foreach &lt;code&gt;opApply&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="45e448d8088d50f1f95bb79e479da8d5a8f8521b" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json objects.</source>
          <target state="translated">为json对象实现foreach &lt;code&gt;opApply&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="c7b156318387d032d75e77a645f93fbb91cfe8d1" translate="yes" xml:space="preserve">
          <source>Implements the higher order filter function. The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">实现高阶过滤器功能。谓词传递给&lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt;，可以接受字符串，也可以通过 &lt;code&gt;pred(element)&lt;/code&gt; 执行的任何可调用对象。</target>
        </trans-unit>
        <trans-unit id="881b721a1385bc8ef11d90c4f0aac7e1c9f98dea" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor.</source>
          <target state="translated">器具的谐音功能（也称为 &lt;code&gt;accumulate&lt;/code&gt; ， &lt;code&gt;compress&lt;/code&gt; ， &lt;code&gt;inject&lt;/code&gt; ，或 &lt;code&gt;foldl&lt;/code&gt; ）存在于功能性香料各种编程语言。</target>
        </trans-unit>
        <trans-unit id="2de496f11d0a61e3ec35b13526a647a0eda0aa53" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. The call &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;fold!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">器具的谐音功能（也称为 &lt;code&gt;accumulate&lt;/code&gt; ， &lt;code&gt;compress&lt;/code&gt; ， &lt;code&gt;inject&lt;/code&gt; ，或 &lt;code&gt;foldl&lt;/code&gt; ）存在于功能性香料各种编程语言。调用 &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; 首先将 &lt;code&gt;seed&lt;/code&gt; 分配给内部变量 &lt;code&gt;result&lt;/code&gt; ，也称为累加器。然后，对于每个元件 &lt;code&gt;x&lt;/code&gt; 中 &lt;code&gt;range&lt;/code&gt; ， &lt;code&gt;result = fun(result, x)&lt;/code&gt; 被评估。最后，返回 &lt;code&gt;result&lt;/code&gt; 。单参数版本 &lt;code&gt;fold!(fun)(range)&lt;/code&gt; 的工作原理类似，但是它使用范围的第一个元素作为种子（范围必须为非空）。</target>
        </trans-unit>
        <trans-unit id="3a102abac10f402f998c7a93f6d1ecbc38ae5d29" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. There is also &lt;a href=&quot;#fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; which does the same thing but with the opposite parameter order. The call &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">器具的谐音功能（也称为 &lt;code&gt;accumulate&lt;/code&gt; ， &lt;code&gt;compress&lt;/code&gt; ， &lt;code&gt;inject&lt;/code&gt; ，或 &lt;code&gt;foldl&lt;/code&gt; ）存在于功能性香料各种编程语言。也有&lt;a href=&quot;#fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;功能相同但参数顺序相反的折叠。调用 &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; 首先将 &lt;code&gt;seed&lt;/code&gt; 分配给内部变量 &lt;code&gt;result&lt;/code&gt; ，也称为累加器。然后，对于每个元件 &lt;code&gt;x&lt;/code&gt; 中 &lt;code&gt;range&lt;/code&gt; ， &lt;code&gt;result = fun(result, x)&lt;/code&gt; 被评估。最后，返回 &lt;code&gt;result&lt;/code&gt; 。一参数版本 &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; 工作原理类似，但是它将范围的第一个元素用作种子（范围必须为非空）。</target>
        </trans-unit>
        <trans-unit id="d222f5f35083b3fe479ec859b88f2b5c2d29bc99" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;transform&lt;/code&gt;) present in many languages of functional flavor. The call &lt;code&gt;map!(fun)(range)&lt;/code&gt; returns a range of which elements are obtained by applying &lt;code&gt;fun(a)&lt;/code&gt; left to right for all elements &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. The original ranges are not changed. Evaluation is done lazily.</source>
          <target state="translated">实现许多功能丰富的语言中存在的同音异义功能（也称为 &lt;code&gt;transform&lt;/code&gt; ）。调用 &lt;code&gt;map!(fun)(range)&lt;/code&gt; 返回一个范围，该范围是通过对 &lt;code&gt;range&lt;/code&gt; 中的所有元素 &lt;code&gt;a&lt;/code&gt; 从左至右应用 &lt;code&gt;fun(a)&lt;/code&gt; 来获得的。原始范围不变。评估是懒惰的。</target>
        </trans-unit>
        <trans-unit id="38aa73eed2ebaa6990e6725195bf642f0bb7894e" translate="yes" xml:space="preserve">
          <source>Implements the most derived interface that &lt;code&gt;R&lt;/code&gt; works with and wraps all relevant range primitives in virtual functions. If &lt;code&gt;R&lt;/code&gt; is already derived from the &lt;code&gt;InputRange&lt;/code&gt; interface, aliases itself away.</source>
          <target state="translated">实现 &lt;code&gt;R&lt;/code&gt; 使用的最派生接口，并将所有相关范围原语包装在虚函数中。如果 &lt;code&gt;R&lt;/code&gt; 已经从 &lt;code&gt;InputRange&lt;/code&gt; 接口派生，则将其自身别名掉。</target>
        </trans-unit>
        <trans-unit id="0aed3bb7204f0f1333835ef5bde3ef0b25325996" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;back&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.back&lt;/code&gt; is equivalent to &lt;code&gt;back(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;back&lt;/code&gt; automatically returns the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">实现了范围接口原语 &lt;code&gt;back&lt;/code&gt; 为内置阵列。由于非成员函数可以使用点符号用第一个参数调用，因此 &lt;code&gt;array.back&lt;/code&gt; 等效于 &lt;code&gt;back(array)&lt;/code&gt; 。对于&lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;窄字符串&lt;/a&gt;， &lt;code&gt;back&lt;/code&gt; 自动返回最后一个&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;代码点&lt;/a&gt;作为 &lt;code&gt;dchar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b532541671d15b35cef77598c086f1da87e05be3" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;empty&lt;/code&gt; for types that obey &lt;a href=&quot;#hasLength&quot;&gt;&lt;code&gt;hasLength&lt;/code&gt;&lt;/a&gt; property and for narrow strings. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;a.empty&lt;/code&gt; is equivalent to &lt;code&gt;empty(a)&lt;/code&gt;.</source>
          <target state="translated">对于遵循&lt;a href=&quot;#hasLength&quot;&gt; &lt;code&gt;hasLength&lt;/code&gt; &lt;/a&gt;属性的类型和窄字符串，将range接口原语实现为 &lt;code&gt;empty&lt;/code&gt; 。由于可以使用点表示法使用第一个参数调用非成员函数，因此 &lt;code&gt;a.empty&lt;/code&gt; 等效于 &lt;code&gt;empty(a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62d00f3658d0160b41b82721ed86515030421a62" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;front&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.front&lt;/code&gt; is equivalent to &lt;code&gt;front(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;front&lt;/code&gt; automatically returns the first &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">实现了范围接口原语 &lt;code&gt;front&lt;/code&gt; 为内置阵列。由于非成员函数可以使用点符号用第一个参数调用，因此 &lt;code&gt;array.front&lt;/code&gt; 等效于 &lt;code&gt;front(array)&lt;/code&gt; 。对于&lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;窄字符串&lt;/a&gt;， &lt;code&gt;front&lt;/code&gt; 自动将第一个&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;代码点&lt;/a&gt;作为 &lt;code&gt;dchar&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="c1778775edc47d955b8410b9303b511a8ed36740" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popBack&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popBack&lt;/code&gt; is equivalent to &lt;code&gt;popBack(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically eliminates the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt;.</source>
          <target state="translated">为内置数组实现范围接口原语 &lt;code&gt;popBack&lt;/code&gt; 。由于可以使用点符号使用第一个参数来调用非成员函数， &lt;code&gt;array.popBack&lt;/code&gt; 等效于 &lt;code&gt;popBack(array)&lt;/code&gt; 。对于&lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;窄字符串&lt;/a&gt;， &lt;code&gt;popFront&lt;/code&gt; 会自动消除最后一个&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;代码点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32e1749a7e79cab97db7229f8dfe1c2b12d27951" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popFront&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popFront&lt;/code&gt; is equivalent to &lt;code&gt;popFront(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically advances to the next code point.</source>
          <target state="translated">为内置数组实现range接口原语 &lt;code&gt;popFront&lt;/code&gt; 。由于可以使用点符号使用第一个参数来调用非成员函数， &lt;code&gt;array.popFront&lt;/code&gt; 等效于 &lt;code&gt;popFront(array)&lt;/code&gt; 。对于&lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;窄字符串&lt;/a&gt;， &lt;code&gt;popFront&lt;/code&gt; 会自动前进到下一个代码点。</target>
        </trans-unit>
        <trans-unit id="75f6fe2cdac67a27b3428234729f0d9dae7b1837" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;save&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.save&lt;/code&gt; is equivalent to &lt;code&gt;save(array)&lt;/code&gt;. The function does not duplicate the content of the array, it simply returns its argument.</source>
          <target state="translated">为内置数组实现范围接口原语 &lt;code&gt;save&lt;/code&gt; 。由于非成员函数可以使用点符号用第一个参数调用，因此 &lt;code&gt;array.save&lt;/code&gt; 等效于 &lt;code&gt;save(array)&lt;/code&gt; 。该函数不复制数组的内容，它仅返回其参数。</target>
        </trans-unit>
        <trans-unit id="06c2dee18ee47dea8267fe70942f5db5533167e2" translate="yes" xml:space="preserve">
          <source>Implicit Base Class Construction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03be7c6392b5500acdd65ba4a7628363c1860d1b" translate="yes" xml:space="preserve">
          <source>Implicit Conversion of Reference Types</source>
          <target state="translated">参考类型的隐式转换</target>
        </trans-unit>
        <trans-unit id="65a63aa075b83c2fd9eb74a28a95e05ff02e65a6" translate="yes" xml:space="preserve">
          <source>Implicit Conversions</source>
          <target state="translated">隐性转换</target>
        </trans-unit>
        <trans-unit id="ef12fa614b38d413fd2518958b3a056d17777c92" translate="yes" xml:space="preserve">
          <source>Implicit Copy Constructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625a5d30e95ccd8e77f05af4dd624ce180fd702c" translate="yes" xml:space="preserve">
          <source>Implicit Nesting</source>
          <target state="translated">隐性嵌套</target>
        </trans-unit>
        <trans-unit id="341437e8c6d229adb9641f4f980b4bd232dec666" translate="yes" xml:space="preserve">
          <source>Implicit Qualifier Conversions</source>
          <target state="translated">隐性限定词转换</target>
        </trans-unit>
        <trans-unit id="e71105f02c13309129677ece5605a0283f9f1fad" translate="yes" xml:space="preserve">
          <source>Implicit Type Inference</source>
          <target state="translated">隐式类型推断</target>
        </trans-unit>
        <trans-unit id="849cfc1637b33ec7b03284c956943ea3a6ee1ec6" translate="yes" xml:space="preserve">
          <source>Implicit conversions are used to automatically convert types as required.</source>
          <target state="translated">隐式转换用于根据需要自动转换类型。</target>
        </trans-unit>
        <trans-unit id="16ca50dfa8d5e344f045161409c8efa6033ef01d" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue, like &lt;code&gt;toString&lt;/code&gt;, but also passes</source>
          <target state="translated">在此JSONValue上隐式调用 &lt;code&gt;toJSON&lt;/code&gt; ，例如 &lt;code&gt;toString&lt;/code&gt; ，但也传递</target>
        </trans-unit>
        <trans-unit id="61b604cd0d4af75ee155d0f29fe03ab209cdf393" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue.</source>
          <target state="translated">在此JSONValue上隐式调用 &lt;code&gt;toJSON&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe09202f421258205fc0af0f7cc90ba8af70d44d" translate="yes" xml:space="preserve">
          <source>Import Declaration</source>
          <target state="translated">进口申报</target>
        </trans-unit>
        <trans-unit id="07b4de4b6291e3b54e69fe2f2020c76048ffb706" translate="yes" xml:space="preserve">
          <source>Import Expressions</source>
          <target state="translated">导入表达式</target>
        </trans-unit>
        <trans-unit id="9633d9e6ebf62f84de8d5fc4824a9ee44e1f1708" translate="yes" xml:space="preserve">
          <source>Import declarations may be used at any scope. For example:</source>
          <target state="translated">导入声明可以在任何作用域使用。例如:</target>
        </trans-unit>
        <trans-unit id="e0559377cfba6b8aed12863122b1b2dcc118cb64" translate="yes" xml:space="preserve">
          <source>ImportDeclaration</source>
          <target state="translated">ImportDeclaration</target>
        </trans-unit>
        <trans-unit id="015ce9a6eb4a1d7698028975a16c0fe2ee6d7aa2" translate="yes" xml:space="preserve">
          <source>Improve behavior of allocators sensitive to allocation sizes, such as &lt;code&gt;FreeList&lt;/code&gt; and &lt;code&gt;FreeTree&lt;/code&gt;. Rounding allocation requests up makes for smaller free lists/trees at the cost of slack memory (internal fragmentation).</source>
          <target state="translated">改善对分配大小敏感的分配器的行为，例如 &lt;code&gt;FreeList&lt;/code&gt; 和 &lt;code&gt;FreeTree&lt;/code&gt; 。四舍五入的分配请求以较小的空闲列表/树为代价，这以空闲内存（内部碎片）为代价。</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="dcd96af0868ef4c663e6ad3dcef261c5095893f1" translate="yes" xml:space="preserve">
          <source>In C, arrays are passed to functions as pointers even if the function prototype says its an array. In D, static arrays are passed by value, not by reference. Thus, the function prototype must be adjusted to match what C expects.</source>
          <target state="translated">在C中,数组作为指针传递给函数,即使函数原型说它是一个数组。在D中,静态数组是通过值来传递的,而不是通过引用。因此,必须调整函数原型以符合C语言的要求。</target>
        </trans-unit>
        <trans-unit id="fb107b811fc18be0d73632390771a7270ede12ef" translate="yes" xml:space="preserve">
          <source>In Expressions</source>
          <target state="translated">在表达式中</target>
        </trans-unit>
        <trans-unit id="98ab2686a50e4805c42c072cadd55e7f182ad96a" translate="yes" xml:space="preserve">
          <source>In a Windows DLL, if this function is called via DllMain with argument DLL_PROCESS_DETACH, the thread is terminated forcefully without proper cleanup as a deadlock would happen otherwise.</source>
          <target state="translated">在Windows DLL中,如果这个函数通过DllMain调用,并带有参数DLL_PROCESS_DETACH,那么这个线程就会在没有适当清理的情况下被强行终止,否则会发生死锁。</target>
        </trans-unit>
        <trans-unit id="31b5ad319495b8bf3a1c002a8507f2abf1208f6d" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegate constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegate constructor.</source>
          <target state="translated">在构造函数主体中，如果调用了委托构造函数，则所有字段分配均视为分配。否则，字段分配的第一个实例是其初始化，并且将 &lt;code&gt;field = expression&lt;/code&gt; 形式的分配视为等同于 &lt;code&gt;typeof(field)(expression)&lt;/code&gt; 。可以在初始化或使用委托构造函数构造之前读取字段的值。</target>
        </trans-unit>
        <trans-unit id="82d94abd1d805c86540567d8cc1718b097222bf0" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegating constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegating constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b4b4504d8850da0fbabfc52a3239ec3b0e0a33" translate="yes" xml:space="preserve">
          <source>In a constructor body, the first instance of field assignment is its initialization.</source>
          <target state="translated">在构造函数体中,字段赋值的第一个实例是其初始化。</target>
        </trans-unit>
        <trans-unit id="3c66c503e379c4155d015b11fbc1dc5940286649" translate="yes" xml:space="preserve">
          <source>In a declaration declaring multiple symbols, all the declarations must be of the same type:</source>
          <target state="translated">在声明多个符号的声明中,所有的声明必须是相同的类型。</target>
        </trans-unit>
        <trans-unit id="9e9fe9946b014b42fb5205022b5c12ede51b25c5" translate="yes" xml:space="preserve">
          <source>In a typical application, you might also want to consider using a non-blocking socket instead of setting a timeout on a blocking one.</source>
          <target state="translated">在典型的应用中,你可能还想考虑使用一个非阻塞的套接字,而不是在阻塞的套接字上设置超时。</target>
        </trans-unit>
        <trans-unit id="190918005b49f5fd22012e2b51e50c26bb8bb06b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#Variant&quot;&gt;&lt;code&gt;Variant&lt;/code&gt;&lt;/a&gt;, this module also defines the &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; type constructor. Unlike &lt;code&gt;Variant&lt;/code&gt;, &lt;code&gt;Algebraic&lt;/code&gt; only allows a finite set of types, which are specified in the instantiation (e.g. &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; may only hold an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;).</source>
          <target state="translated">除了&lt;a href=&quot;#Variant&quot;&gt; &lt;code&gt;Variant&lt;/code&gt; 之外&lt;/a&gt;，此模块还定义了&lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt;类型的构造函数。与 &lt;code&gt;Variant&lt;/code&gt; 不同， &lt;code&gt;Algebraic&lt;/code&gt; 只允许在实例化中指定的一组有限类型（例如， &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; 只能容纳 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bd56298f652baf17103962e16813e3a6aed52cf4" translate="yes" xml:space="preserve">
          <source>In addition to convenience, these functions are slightly more efficient than manually creating an Fft object for a single use, as the Fft object is deterministically destroyed before these functions return.</source>
          <target state="translated">除了方便之外,这些函数比手动创建一个单次使用的Fft对象效率更高一些,因为Fft对象在这些函数返回之前就被确定地销毁了。</target>
        </trans-unit>
        <trans-unit id="570c956c4c6e2dbde87f61ff5e2c49153a8df2e6" translate="yes" xml:space="preserve">
          <source>In addition to random number generators, this module features distributions, which skew a generator's output statistical distribution in various ways. So far the uniform distribution for integers and real numbers have been implemented.</source>
          <target state="translated">除了随机数生成器外,这个模块还具有分布的功能,分布以各种方式倾斜生成器的输出统计分布。到目前为止,整数和实数的均匀分布已经实现。</target>
        </trans-unit>
        <trans-unit id="5295840dbe23153fe2e689d001aa6ebadfba5f26" translate="yes" xml:space="preserve">
          <source>In addition, --DRT-gcopt=help will show the list of options and their current settings.</source>
          <target state="translated">此外,--DRT-gcopt=help将显示选项列表及其当前设置。</target>
        </trans-unit>
        <trans-unit id="b2fcea4fb949d2ee554c72114c12b58084a4d18d" translate="yes" xml:space="preserve">
          <source>In addition, the data &lt;code&gt;callerSize&lt;/code&gt;, &lt;code&gt;callerModule&lt;/code&gt;, &lt;code&gt;callerFile&lt;/code&gt;, &lt;code&gt;callerLine&lt;/code&gt;, and &lt;code&gt;callerTime&lt;/code&gt; is associated with each specific allocation. This data prefixes each allocation.</source>
          <target state="translated">另外，数据 &lt;code&gt;callerSize&lt;/code&gt; ， &lt;code&gt;callerModule&lt;/code&gt; ， &lt;code&gt;callerFile&lt;/code&gt; ， &lt;code&gt;callerLine&lt;/code&gt; 和 &lt;code&gt;callerTime&lt;/code&gt; 与每个特定分配相关联。该数据为每个分配加上前缀。</target>
        </trans-unit>
        <trans-unit id="8bb9d27fa1cfa7a17c0f438e8ee45a8ac856bdb5" translate="yes" xml:space="preserve">
          <source>In algorithms partitioning ranges in two, preserve relative ordering of elements only to the left of the partition point.</source>
          <target state="translated">在将范围一分为二的算法中,只在分割点的左边保留元素的相对排序。</target>
        </trans-unit>
        <trans-unit id="a4c7a53fdd584b663429b65ac4f17edc28d07354" translate="yes" xml:space="preserve">
          <source>In all cases the function returns the built-in result of &lt;code&gt;lhs == rhs&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，该函数都会返回 &lt;code&gt;lhs == rhs&lt;/code&gt; 的内置结果。</target>
        </trans-unit>
        <trans-unit id="a66898347b51f7c1d0527a1edb8a6b3cf367a27a" translate="yes" xml:space="preserve">
          <source>In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. &lt;code&gt;ulong&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt;) tracks the zero-based number of the current line.</source>
          <target state="translated">在所有情况下，都接受两个符号的版本，在这种情况下，第一个符号（整数类型，例如 &lt;code&gt;ulong&lt;/code&gt; 或 &lt;code&gt;uint&lt;/code&gt; ）跟踪当前行的从零开始的数字。</target>
        </trans-unit>
        <trans-unit id="fb219f6585d8061af3f052a290762bb948e1e8d6" translate="yes" xml:space="preserve">
          <source>In all cases, returns &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt;. The result is not autocorrected in case of an erroneous comparison.</source>
          <target state="translated">在所有情况下，返回 &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt; 。如果比较错误，则结果不会自动校正。</target>
        </trans-unit>
        <trans-unit id="cb4bca7a9dd4559557c8f7c4ee56255838258c7f" translate="yes" xml:space="preserve">
          <source>In all cases, the concatenation of the returned ranges spans the entire &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，返回范围的串联都跨越整个 &lt;code&gt;haystack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fac8533d039fb2ca10f37bea36476dc0de1df00b" translate="yes" xml:space="preserve">
          <source>In all other cases, a simple element by element addition is done.</source>
          <target state="translated">在其他情况下,都要进行简单的逐个元素加法。</target>
        </trans-unit>
        <trans-unit id="394148797f50691adb9a270f990a5eaca722863e" translate="yes" xml:space="preserve">
          <source>In all other cases, the built-in behavior is carried out.</source>
          <target state="translated">在所有其他情况下,都会执行内置行为。</target>
        </trans-unit>
        <trans-unit id="b68e1d58907e07140ccd3efadbc43c332f170e2d" translate="yes" xml:space="preserve">
          <source>In all other respects this function works just like &lt;code&gt;spawnProcess&lt;/code&gt;. Please refer to the &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; documentation for descriptions of the other function parameters, the return value and any exceptions that may be thrown.</source>
          <target state="translated">在所有其他方面，此功能都像 &lt;code&gt;spawnProcess&lt;/code&gt; 一样工作。请参考&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;文档以获取其他函数参数，返回值以及可能引发的任何异常的描述。</target>
        </trans-unit>
        <trans-unit id="1cc108da5c2c3788f98a6edf95e1a63a36afb311" translate="yes" xml:space="preserve">
          <source>In all string literal forms, an &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; is regarded as a single &lt;code&gt;\n&lt;/code&gt; character.</source>
          <target state="translated">在所有字符串文字形式中，&lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;被视为单个 &lt;code&gt;\n&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="60b9a383afd7a0fd8bdda37a3d66b0a2bbb686e7" translate="yes" xml:space="preserve">
          <source>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc.</source>
          <target state="translated">在所有其他方面,这些方法和其他方法一样。它们可以是静态的,有不同的联系,有自己的地址,等等。</target>
        </trans-unit>
        <trans-unit id="4560285d4cfc645e0ef24ee3db5890ff1443ed09" translate="yes" xml:space="preserve">
          <source>In both C++ and D, if a struct has zero fields, the struct still has a size of 1 byte. But, in C++ if the struct with zero fields is used as a base struct, its size is zero (called the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt;). There are two methods for emulating this behavior in D. The first forwards references to a function returning a faked reference to the base:</source>
          <target state="translated">在C ++和D中，如果一个结构具有零个字段，则该结构的大小仍为1个字节。但是，在C ++中，如果将具有零字段的结构用作基础结构，则其大小为零（称为&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;空基础优化&lt;/a&gt;）。有两种方法可以在D中模拟此行为。第一种方法是转发对函数的引用，该函数会将伪造的引用返回给基数：</target>
        </trans-unit>
        <trans-unit id="b076421b0fbcae191c5dc3ef2368683aca391393" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier starting with &lt;code&gt; &quot;%(&quot;&lt;/code&gt; and ending with &lt;code&gt;&quot;%)&quot;&lt;/code&gt;, &lt;code&gt;_nested&lt;/code&gt; contains the string contained within the two separators.</source>
          <target state="translated">对于复合格式说明符，其开头为 &lt;code&gt; &quot;%(&quot;&lt;/code&gt; ，结尾为 &lt;code&gt;&quot;%)&quot;&lt;/code&gt; ，则 &lt;code&gt;_nested&lt;/code&gt; 包含两个分隔符中包含的字符串。</target>
        </trans-unit>
        <trans-unit id="b3a4dc18e455dc36e9fd73a88e062b9df8c0d722" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier, &lt;code&gt;_sep&lt;/code&gt; contains the string positioning after &lt;code&gt;&quot;%|&quot;&lt;/code&gt;. &lt;code&gt;sep is null&lt;/code&gt; means no separator else &lt;code&gt;sep.empty&lt;/code&gt; means 0 length separator.</source>
          <target state="translated">对于复合格式说明符， &lt;code&gt;_sep&lt;/code&gt; 包含字符串在 &lt;code&gt;&quot;%|&quot;&lt;/code&gt; 之后的位置 。 &lt;code&gt;sep is null&lt;/code&gt; 表示没有分隔符，否则 &lt;code&gt;sep.empty&lt;/code&gt; 表示长度为0的分隔符。</target>
        </trans-unit>
        <trans-unit id="c172129354e9ba73756e23e6e1f6e0e605a52cb9" translate="yes" xml:space="preserve">
          <source>In case of a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; nothing will happen.</source>
          <target state="translated">如果出现带有 &lt;code&gt;LogLevel.fatal&lt;/code&gt; 的日志消息，则不会发生任何事情。</target>
        </trans-unit>
        <trans-unit id="3ebef375cea9cd0eca25afb26b6d5c11eab7f3f0" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果发生I / O错误， &lt;code&gt;StdioException&lt;/code&gt; 引发StdioException。</target>
        </trans-unit>
        <trans-unit id="39a07628e75ba54420c0ee35d2d7947fae3e6e95" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;a href=&quot;#StdioException&quot;&gt;&lt;code&gt;StdioException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果发生I / O错误，则抛出&lt;a href=&quot;#StdioException&quot;&gt; &lt;code&gt;StdioException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c94ce1719c011e5c08b47d8a880eaa8ed1ab504" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">如果发生I / O错误，则抛出 &lt;code&gt;StdioException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="072442afd2ab0da30ef9131acbdaeefa3c16749b" translate="yes" xml:space="preserve">
          <source>In case you want to only enable bundling for some of the parameters, bundling can be turned off with &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt;.</source>
          <target state="translated">如果只想对某些参数启用捆绑，则可以使用 &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt; 关闭捆绑。</target>
        </trans-unit>
        <trans-unit id="01d85046192eeac78a5da365dc7670fdea8d6e86" translate="yes" xml:space="preserve">
          <source>In cases where producing the replacement is the ultimate goal &lt;a href=&quot;#replaceFirstInto&quot;&gt;&lt;code&gt;replaceFirstInto&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAllInto&quot;&gt;&lt;code&gt;replaceAllInto&lt;/code&gt;&lt;/a&gt; could come in handy as functions that avoid allocations even for replacement.</source>
          <target state="translated">在产生替换是最终目标的情况下，&lt;a href=&quot;#replaceFirstInto&quot;&gt; &lt;code&gt;replaceFirstInto&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#replaceAllInto&quot;&gt; &lt;code&gt;replaceAllInto&lt;/code&gt; &lt;/a&gt;可以派上用场，因为这些函数即使在替换时也可以避免分配。</target>
        </trans-unit>
        <trans-unit id="e6177e81e2c8557108ce3bebc0ad228b2a46f372" translate="yes" xml:space="preserve">
          <source>In cases where the operand size is ambiguous, as in:</source>
          <target state="translated">在操作数大小不明确的情况下,如:。</target>
        </trans-unit>
        <trans-unit id="a7faf0c1f2db2bcd1f30944e523bc6e5d4329044" translate="yes" xml:space="preserve">
          <source>In cases where the string in question is already normalized, it is returned unmodified and no memory allocation happens.</source>
          <target state="translated">在相关字符串已经归一化的情况下,会不加修改地返回,不会发生内存分配。</target>
        </trans-unit>
        <trans-unit id="b91258a55b8ef08cfea19b1e402c52c62c5ef260" translate="yes" xml:space="preserve">
          <source>In debug mode &lt;code&gt;AssertError&lt;/code&gt;, when the result is not a well-formed UTF string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2d083ad99e82982be1c8520585485c563982d6" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;__delete(x)&lt;/code&gt; returns with no effect if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. Otherwise, it performs the following actions in sequence:</source>
          <target state="translated">详细地，如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则 &lt;code&gt;__delete(x)&lt;/code&gt; 返回无效。否则，它将按顺序执行以下操作：</target>
        </trans-unit>
        <trans-unit id="1a253df89cf875b96f6b0b99a704c14478bd5687" translate="yes" xml:space="preserve">
          <source>In effect &lt;code&gt;takeOne(r)&lt;/code&gt; is somewhat equivalent to &lt;code&gt;take(r, 1)&lt;/code&gt; but in certain interfaces it is important to know statically that the range may only have at most one element.</source>
          <target state="translated">实际上， &lt;code&gt;takeOne(r)&lt;/code&gt; 在某种程度上等同于 &lt;code&gt;take(r, 1)&lt;/code&gt; 但在某些接口中，重要的是要静态地知道该范围最多只能包含一个元素。</target>
        </trans-unit>
        <trans-unit id="c7e90e95cc2e5d025786e563cb98d86e57f261c9" translate="yes" xml:space="preserve">
          <source>In either case, the content of the buffer is reused across calls. That means &lt;code&gt;front&lt;/code&gt; will not persist after &lt;code&gt;popFront&lt;/code&gt; is called, so if retention is needed, the caller must copy its contents (e.g. by calling &lt;code&gt;buffer.dup&lt;/code&gt;).  In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  With the mentioned limitations, &lt;code&gt;byChunk&lt;/code&gt; works with any algorithm compatible with input ranges.</source>
          <target state="translated">无论哪种情况，缓冲区的内容都会在调用之间重用。这意味着 &lt;code&gt;front&lt;/code&gt; 后将不会保留 &lt;code&gt;popFront&lt;/code&gt; 被调用，所以如果需要保存，调用者必须复制的内容（例如，通过调用 &lt;code&gt;buffer.dup&lt;/code&gt; ）。在上面的示例中，对于所有迭代， &lt;code&gt;buffer.length&lt;/code&gt; 为4096（最后一次除外），在这种情况下， &lt;code&gt;buffer.length&lt;/code&gt; 可能小于4096（但始终大于零）。由于上述限制， &lt;code&gt;byChunk&lt;/code&gt; 可以与任何与输入范围兼容的算法一起使用。</target>
        </trans-unit>
        <trans-unit id="8ec7633257f9bdb307965ba1607259244c489e1d" translate="yes" xml:space="preserve">
          <source>In free list mode, &lt;code&gt;KRRegion&lt;/code&gt; embeds a free blocks list onto the chunk of memory. The free list is circular, coalesced, and sorted by address at all times. Allocations and deallocations take time proportional to the number of previously deallocated blocks. (In practice the cost may be lower, e.g. if memory is deallocated in reverse order of allocation, all operations take constant time.) Memory utilization is good (small control structure and no per-allocation overhead). The disadvantages of freelist mode include proneness to fragmentation, a minimum allocation size of two words, and linear worst-case allocation and deallocation times.</source>
          <target state="translated">在空闲列表模式下， &lt;code&gt;KRRegion&lt;/code&gt; 将空闲块列表嵌入到内存块中。空闲列表是循环的，合并的，并始终按地址排序。分配和解除分配所花费的时间与先前解除分配的块数成正比。 （实际上，成本可能较低，例如，如果以分配的相反顺序释放内存，则所有操作都将花费恒定的时间。）内存利用率良好（控制结构小且无按分配开销）。自由列表模式的缺点包括易于碎片化，两个单词的最小分配大小以及线性最坏情况分配和释放时间。</target>
        </trans-unit>
        <trans-unit id="cdf7807c516e1443dffb3bd59e60f6a917c9df07" translate="yes" xml:space="preserve">
          <source>In function scopes, imported symbols only become visible after the import declaration lexically appears in the function body. In other words, imported symbols at function scope cannot be forward referenced.</source>
          <target state="translated">在函数作用域中,导入的符号只有在导入声明以词法出现在函数体中之后才会显现。换句话说,在函数作用域的导入符号不能被前向引用。</target>
        </trans-unit>
        <trans-unit id="c0383119e4652a168035af7434f3705bce886b19" translate="yes" xml:space="preserve">
          <source>In functional programming languages this is typically called &lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;scanl&lt;/code&gt;, &lt;code&gt;scanLeft&lt;/code&gt; or &lt;code&gt;reductions&lt;/code&gt;.</source>
          <target state="translated">在函数式编程语言中，这通常被称为 &lt;code&gt;scan&lt;/code&gt; ， &lt;code&gt;scanl&lt;/code&gt; ， &lt;code&gt;scanLeft&lt;/code&gt; 或 &lt;code&gt;reductions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fb398e80e5a7daebe5fe79cc756231990bf0b4c" translate="yes" xml:space="preserve">
          <source>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag). Otherwise, they may become &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombies&lt;/a&gt;&quot; &amp;ndash; processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them.</source>
          <target state="translated">通常，除非退出该进程时已将其视为已分离（使用 &lt;code&gt;Config.detached&lt;/code&gt; 标志生成），否则在退出父进程之前，应始终等待子进程终止。否则，它们可能会变成&amp;ldquo; &lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;僵尸&lt;/a&gt; &amp;rdquo;，即已消失的进程，但仍占据OS进程表中的插槽。您不应也不应该等待分离的进程，因为您不拥有它们。</target>
        </trans-unit>
        <trans-unit id="2a9fd3d1c20814161b33ee0afa7c06fcf185414e" translate="yes" xml:space="preserve">
          <source>In general periodically 'reseeding' a PRNG does not improve its quality and in some cases may harm it. For an extreme example the Mersenne Twister has &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; distinct states but after &lt;code&gt;seed(uint)&lt;/code&gt; is called it can only be in one of &lt;code&gt;2 ^^ 32&lt;/code&gt; distinct states regardless of how excellent the source of entropy is.</source>
          <target state="translated">通常，定期&amp;ldquo;重新播种&amp;rdquo; PRNG不会提高其质量，在某些情况下可能会损害它。举一个极端的例子，梅森扭转者有 &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; 不同的状态，但是在调用 &lt;code&gt;seed(uint)&lt;/code&gt; 之后，无论熵的来源多么出色，它只能处于 &lt;code&gt;2 ^^ 32&lt;/code&gt; 个不同的状态之一。</target>
        </trans-unit>
        <trans-unit id="fc32a5290aa168583cf02dd9b13039ee5589d851" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#isValidPath&quot;&gt;&lt;code&gt;isValidPath&lt;/code&gt;&lt;/a&gt; functions to check this.</source>
          <target state="translated">通常，此模块中的功能假定输入路径格式正确。（也就是说，它们不应包含无效字符，它们应遵循文件系统的路径格式等。）在格式错误的路径上调用函数的结果是不确定的。当路径或文件名可能无效时（例如，当用户输入了路径或文件名时），有时可能希望使用&lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#isValidPath&quot;&gt; &lt;code&gt;isValidPath&lt;/code&gt; &lt;/a&gt;函数进行检查。</target>
        </trans-unit>
        <trans-unit id="7566506eebd3c530fd7b49f9458b9e3829cd9289" translate="yes" xml:space="preserve">
          <source>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</source>
          <target state="translated">在很多情况下,调用sizeof()不能直接用于获取数据类型大小,因为支持交叉编译,最终会使用主机大小而不是目标大小。</target>
        </trans-unit>
        <trans-unit id="35dd64591779170e8008d349dad053c6fa8f2446" translate="yes" xml:space="preserve">
          <source>In nested</source>
          <target state="translated">嵌套式</target>
        </trans-unit>
        <trans-unit id="8575ac5b58d78f8ffa7cfeed41b65f5b48950967" translate="yes" xml:space="preserve">
          <source>In older versions of Phobos, it used to be possible to write:</source>
          <target state="translated">在Phobos的旧版本中,以前可以写。</target>
        </trans-unit>
        <trans-unit id="2e095fc6159a0d37540c3fe665eef32c69ad9690" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;Logger&lt;/code&gt; must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的所述的 &lt;code&gt;Logger&lt;/code&gt; 必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="60952b4bdab4bfb5f5a8d1d83bb07430530eeffe" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; add the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的所述的 &lt;code&gt;sharedLog&lt;/code&gt; 必须大于或等于 &lt;code&gt;defaultLogLevel&lt;/code&gt; 添加传递必须的条件 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e11fddcd19d6f16f616c57c6e260430b0f9d9a4" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的所述的 &lt;code&gt;sharedLog&lt;/code&gt; 必须大于或等于 &lt;code&gt;defaultLogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f8c65e46c163f6fc77fddc2b9a77d78f4961ef7" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了处理数据，日志调用的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;sharedLog&lt;/code&gt; 和 &lt;code&gt;defaultLogLevel&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，另外，传递的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed49a17d9874b268342f0db2f71435916af05001" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的日志呼叫必须大于或等于所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;sharedLog&lt;/code&gt; 和 &lt;code&gt;defaultLogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c93e7b85e99ec02f5d168562dae2b831dda8259" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的日志呼叫必须大于或等于所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;sharedLog&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f87139f757185970527b89c7ad28046b560c58f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了处理数据，日志调用的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;defaultLogLevel&lt;/code&gt; ,另外，传递的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a54f9edb0000f15c332443c24f6eb668c55c8501" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">为了处理数据，日志调用的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;defaultLogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14b107fabc6c81ab2222b96dfa0c1ecd6dfba19f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed, the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了要处理的数据，所述 &lt;code&gt;LogLevel&lt;/code&gt; 日志呼叫必须大于或等于所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;sharedLog&lt;/code&gt; 和 &lt;code&gt;defaultLogLevel&lt;/code&gt; ; 另外，通过的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bb3ac7d5c9d6c962a9241e9025396626aa9beb6" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;sharedLog&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。另外，该 &lt;code&gt;LogLevel&lt;/code&gt; 的必须大于或等于比所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;stdSharedLogger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79abe30476f4ca10a8c01c609e3f868cb8a10f27" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;. If a condition is given, it must evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。另外，该 &lt;code&gt;LogLevel&lt;/code&gt; 的必须大于或等于比所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;stdSharedLogger&lt;/code&gt; 。如果给出条件，则必须评估为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18e494163438a3079c18b40fa80b56a34c4d5c22" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录生成的日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; ,此外，传递的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2b84c1fc96a4a1e141069ab63dfce487512e519" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the passed condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录生成的日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; ,此外，传递的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c8530a345a9b66847038330015135156125389c" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; ，并且条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20b9f3f3bdcf58be250caee88b15a55353fecc84" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41a290703568517f05854f40487a48abaf094d9a" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息，使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; ，并且条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61c93a13b86326686a55e702c7620856cee5be12" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息，使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9091984c8dee40a3793a920b8fc726ff3fb2b605" translate="yes" xml:space="preserve">
          <source>In order to be usable as an allocator, a type should implement the following methods with their respective semantics. Only &lt;code&gt;alignment&lt;/code&gt; and &lt;code&gt;allocate&lt;/code&gt; are required. If any of the other methods is missing, the allocator is assumed to not have that capability (for example some allocators do not offer manual deallocation of memory). Allocators should NOT implement unsupported methods to always fail. For example, an allocator that lacks the capability to implement &lt;code&gt;alignedAllocate&lt;/code&gt; should not define it at all (as opposed to defining it to always return &lt;code&gt;null&lt;/code&gt; or throw an exception). The missing implementation statically informs other components about the allocator's capabilities and allows them to make design decisions accordingly.</source>
          <target state="translated">为了可用作分配器，类型应使用其各自的语义实现以下方法。仅需要 &lt;code&gt;alignment&lt;/code&gt; 和 &lt;code&gt;allocate&lt;/code&gt; 。如果缺少任何其他方法，则认为分配器不具备该功能（例如，某些分配器不提供对内存的手动重新分配）。分配者不应实施不受支持的方法，以使其始终失败。例如，缺乏实现 &lt;code&gt;alignedAllocate&lt;/code&gt; 功能的分配器根本不应定义它（与将其定义为始终返回 &lt;code&gt;null&lt;/code&gt; 或引发异常相反）。缺少的实现将分配器的功能静态通知其他组件，并允许它们相应地做出设计决策。</target>
        </trans-unit>
        <trans-unit id="6dda110f1f25b5663505eb11f44cd82e44a8c31d" translate="yes" xml:space="preserve">
          <source>In order to determine if an object &lt;code&gt;o&lt;/code&gt; is an instance of a class &lt;code&gt;B&lt;/code&gt; use a cast:</source>
          <target state="translated">为了确定对象 &lt;code&gt;o&lt;/code&gt; 是否是 &lt;code&gt;B&lt;/code&gt; 类的实例，请使用强制转换：</target>
        </trans-unit>
        <trans-unit id="1e18ff30e3740b378cdaf28cc4934f896ccbee30" translate="yes" xml:space="preserve">
          <source>In order to disable logging at compile time, pass &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; as a version argument to the &lt;code&gt;D&lt;/code&gt; compiler when compiling your program code. This will disable all logging functionality. Specific &lt;code&gt;LogLevel&lt;/code&gt; can be disabled at compile time as well. In order to disable logging with the &lt;code&gt;trace&lt;/code&gt;&lt;code&gt;LogLevel&lt;/code&gt; pass &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; as a version. The following table shows which version statement disables which &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">为了在编译时禁用日志记录，请在编译程序代码时将 &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; 作为版本参数传递给 &lt;code&gt;D&lt;/code&gt; 编译器。这将禁用所有日志记录功能。也可以在编译时禁用特定的 &lt;code&gt;LogLevel&lt;/code&gt; 。为了禁用 &lt;code&gt;trace&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; 的日志记录，请将 &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; 作为版本传递。下表显示了哪个版本语句禁用了哪个 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a77a52d87761074b435f02e38ba4ed22e517df1c" translate="yes" xml:space="preserve">
          <source>In order to do put the length at the front, we have to provide 16 bytes buffer space in case the block has to be aligned properly. In x86, certain SSE instructions will only work if the data is 16-byte aligned. In addition, we need the sentinel byte to prevent accidental pointers to the next block. Because of the extra overhead, we only do this for page size and above, where the overhead is minimal compared to the block size.</source>
          <target state="translated">为了做到把长度放在前面,我们必须提供16个字节的缓冲空间,以防块必须正确对齐。在x86中,某些SSE指令只有在数据是16字节对齐的情况下才会工作。此外,我们还需要哨兵字节来防止意外指向下一个块。由于额外的开销,我们只在页大小及以上的情况下这样做,与块大小相比,开销很小。</target>
        </trans-unit>
        <trans-unit id="0cc93ffa6b67fa20835799cad3635970d48f4206" translate="yes" xml:space="preserve">
          <source>In order to work, &lt;code&gt;FallbackAllocator&lt;/code&gt; requires that &lt;code&gt;Primary&lt;/code&gt; defines the &lt;code&gt;owns&lt;/code&gt; method. This is needed in order to decide which allocator was responsible for a given allocation.</source>
          <target state="translated">为了工作， &lt;code&gt;FallbackAllocator&lt;/code&gt; 要求 &lt;code&gt;Primary&lt;/code&gt; 定义了 &lt;code&gt;owns&lt;/code&gt; 方法。为了确定哪个分配器负责给定分配，这是必需的。</target>
        </trans-unit>
        <trans-unit id="3cb2dd17fb05bd389b6b34ea2ea85ffe8dc6328a" translate="yes" xml:space="preserve">
          <source>In other words, casting literal expression will change the literal type.</source>
          <target state="translated">换句话说,铸造字面表达式将改变字面类型。</target>
        </trans-unit>
        <trans-unit id="675933f346891ba4fb04a779eea3dd5e21b2c0bb" translate="yes" xml:space="preserve">
          <source>In previous versions of Phobos, this was known as &lt;code&gt;TypeTuple&lt;/code&gt;.</source>
          <target state="translated">在以前的Phobos版本中，这称为 &lt;code&gt;TypeTuple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26154800831f1a5ff6a19e1167b2ddcacfdb1c76" translate="yes" xml:space="preserve">
          <source>In principle, only thrown objects derived from this class are safe to catch inside a &lt;code&gt;catch&lt;/code&gt; block. Thrown objects not derived from Exception represent runtime errors that should not be caught, as certain runtime guarantees may not hold, making it unsafe to continue program execution.</source>
          <target state="translated">原则上，只有派生自此类的对象才能安全地捕获在 &lt;code&gt;catch&lt;/code&gt; 块内。不是从Exception派生的抛出对象表示不应捕获的运行时错误，因为某些运行时保证可能不成立，因此继续执行程序是不安全的。</target>
        </trans-unit>
        <trans-unit id="0b93464d0fbabeded10a475db02ab91f9147bd5b" translate="yes" xml:space="preserve">
          <source>In principle, this is the name of the local time zone. However, this always returns the empty string. This is because time zones cannot be uniquely identified by the attributes given by the OS (such as the &lt;code&gt;stdName&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt;), and neither Posix systems nor Windows systems provide an easy way to get the TZ Database name of the local time zone.</source>
          <target state="translated">原则上，这是本地时区的名称。但是，这总是返回空字符串。这是因为时区无法由操作系统提供的属性（例如 &lt;code&gt;stdName&lt;/code&gt; 和 &lt;code&gt;dstName&lt;/code&gt; ）唯一地标识，并且Posix系统和Windows系统都没有提供获取本地时区的TZ数据库名称的简便方法。</target>
        </trans-unit>
        <trans-unit id="0b9fb0301ede6ae1f71c55d50ab376078de554f8" translate="yes" xml:space="preserve">
          <source>In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'.</source>
          <target state="translated">在单行模式下,匹配任何字符,否则匹配除&quot;\n &quot;和&quot;\r &quot;以外的任何字符。否则它将匹配除&quot;/n &quot;和&quot;/r &quot;以外的任何字符。</target>
        </trans-unit>
        <trans-unit id="77c1db69e3f99eb322088fa8127b36e0134ab790" translate="yes" xml:space="preserve">
          <source>In some date calculations, adding months or years can cause the date to fall on a day of the month which is not valid (e.g. February 29th 2001 or June 31st 2000). If overflow is allowed (as is the default), then the month will be incremented accordingly (so, February 29th 2001 would become March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow is not allowed, then the day will be adjusted to the last valid day in that month (so, February 29th 2001 would become February 28th 2001 and June 31st 2000 would become June 30th 2000).</source>
          <target state="translated">在某些日期计算中,添加月份或年份可能会导致日期落在月份的某一天,而这一天是无效的(例如2001年2月29日或2000年6月31日)。如果允许溢出(默认情况下),那么月份将相应地递增(因此,2001年2月29日将成为2001年3月1日,2000年6月31日将成为2000年7月1日)。如果不允许溢出,那么日期将被调整到该月的最后一天(因此,2001年2月29日将成为2001年2月28日,2000年6月31日将成为2000年6月30日)。</target>
        </trans-unit>
        <trans-unit id="0f7765db47c238a56000c8a0537e8a769de4649d" translate="yes" xml:space="preserve">
          <source>In std.datetime, it is also used as the result of various arithmetic operations on time points.</source>
          <target state="translated">在std.datetime中,它也被用作对时间点进行各种算术运算的结果。</target>
        </trans-unit>
        <trans-unit id="9d8f072b0ee81fd114d71e25f9472d419503fd30" translate="yes" xml:space="preserve">
          <source>In the above situations the errors do not contain line numbers because the errors are regarding generated code.</source>
          <target state="translated">在上述情况下,错误不包含行号,因为错误是关于生成的代码。</target>
        </trans-unit>
        <trans-unit id="83c0d2545855dad1e2136f8a2d0797213523dbd3" translate="yes" xml:space="preserve">
          <source>In the case above, the element at slot &lt;code&gt;1&lt;/code&gt; is removed, but replaced with the last element of the range. Taking advantage of the relaxation of the stability requirement, &lt;code&gt;remove&lt;/code&gt; moved elements from the end of the array over the slots to be removed. This way there is less data movement to be done which improves the execution time of the function.</source>
          <target state="translated">在上述情况下，插槽 &lt;code&gt;1&lt;/code&gt; 中的元素已删除，但被范围中的最后一个元素替换。利用放宽稳定性要求的方法，从要移除的插槽上方的阵列末端 &lt;code&gt;remove&lt;/code&gt; 移动的元素。这样，减少了要执行的数据移动，从而缩短了函数的执行时间。</target>
        </trans-unit>
        <trans-unit id="d1310273f42b4567d006ba733761bffcc94a7323" translate="yes" xml:space="preserve">
          <source>In the case of multisets, considering that element &lt;code&gt;a&lt;/code&gt; appears &lt;code&gt;x&lt;/code&gt; times in &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; times and &lt;code&gt;r2&lt;/code&gt;, the number of occurences of &lt;code&gt;a&lt;/code&gt; in the resulting range is going to be &lt;code&gt;x-y&lt;/code&gt; if x &amp;gt; y or 0 otherwise.</source>
          <target state="translated">在多集的情况下，考虑到元件 &lt;code&gt;a&lt;/code&gt; 出现 &lt;code&gt;x&lt;/code&gt; 在时间 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 倍和 &lt;code&gt;r2&lt;/code&gt; ，的出现次数的数量 &lt;code&gt;a&lt;/code&gt; 在所得的范围将是 &lt;code&gt;x-y&lt;/code&gt; 如果X&amp;gt; Y，否则为0。</target>
        </trans-unit>
        <trans-unit id="574341dd05f59907247dd44e449ed7bd5386146b" translate="yes" xml:space="preserve">
          <source>In the case of multisets, the range with the minimum number of occurences of a given element, propagates the number of occurences of this element to the resulting range.</source>
          <target state="translated">在多集的情况下,给定元素出现次数最少的范围,将这个元素的出现次数传播到结果范围。</target>
        </trans-unit>
        <trans-unit id="c31bb38a42ef0f5a89fce05942de3e9a5d76ab7c" translate="yes" xml:space="preserve">
          <source>In the case of the monotonic time, &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; is templatized on &lt;code&gt;ClockType&lt;/code&gt;, whereas with &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;, its a runtime argument, since in the case of the monotonic time, the type of the clock affects the resolution of a &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; object, whereas with &lt;a href=&quot;std_datetime#SysTime&quot;&gt;&lt;code&gt;std.datetime.SysTime&lt;/code&gt;&lt;/a&gt;, its resolution is always hecto-nanoseconds regardless of the source of the time.</source>
          <target state="translated">在的单调时间的情况下，&lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;被模板化上 &lt;code&gt;ClockType&lt;/code&gt; ，而用 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; ，其运行时的参数，因为在的单调时间的情况下，时钟的类型会影响一个的分辨率&lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;对象，而使用&lt;a href=&quot;std_datetime#SysTime&quot;&gt; &lt;code&gt;std.datetime.SysTime&lt;/code&gt; 时&lt;/a&gt;，其分辨率始终为十进制纳秒，而与时间来源无关。</target>
        </trans-unit>
        <trans-unit id="48d19d43ba624ca8d4f15f601b46da39df170632" translate="yes" xml:space="preserve">
          <source>In the corresponding D code, &lt;code&gt;foo&lt;/code&gt; is declared as having C++ linkage and function calling conventions:</source>
          <target state="translated">在相应的D代码中， &lt;code&gt;foo&lt;/code&gt; 被声明为具有C ++链接和函数调用约定：</target>
        </trans-unit>
        <trans-unit id="c2859b376d9322070e57e0df9e0b545f1ad11ef9" translate="yes" xml:space="preserve">
          <source>In the current function, we are calling 'this' function. 1. Check to see if the current function can call 'this' function, issue error if not. 2. If the current function is not the parent of 'this' function, then add the current function to the list of siblings of 'this' function. 3. If the current function is a literal, and it's accessing an uplevel scope, then mark it as a delegate. Returns true if error occurs.</source>
          <target state="translated">在当前函数中,我们调用的是'this'函数。1.检查当前函数是否可以调用'this'函数,如果不可以,发出错误。2.如果当前函数不是'this'函数的父函数,则将当前函数加入到'this'函数的兄弟姐妹列表中。3.如果当前函数是一个文字,并且它正在访问一个上级作用域,那么将其标记为委托。如果发生错误,则返回true。</target>
        </trans-unit>
        <trans-unit id="27341e1e33d3f1a9c524981309a60954fc820a69" translate="yes" xml:space="preserve">
          <source>In the example above, &quot;--foo&quot; and &quot;--bar&quot; are recognized, but &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;, etc. are rejected. The directive is active until the end of &lt;code&gt;getopt&lt;/code&gt;, or until the converse directive &lt;code&gt;caseInsensitive&lt;/code&gt; is encountered:</source>
          <target state="translated">在上面的示例中，识别了&amp;ldquo; --foo&amp;rdquo;和&amp;ldquo; --bar&amp;rdquo;，但是拒绝了&amp;ldquo; --Foo&amp;rdquo;，&amp;ldquo;-Bar&amp;rdquo;，&amp;ldquo;-FOo&amp;rdquo;，&amp;ldquo;-bAr&amp;rdquo;等。该指令一直有效，直到 &lt;code&gt;getopt&lt;/code&gt; 结束或遇到相反的指令 &lt;code&gt;caseInsensitive&lt;/code&gt; 为止：</target>
        </trans-unit>
        <trans-unit id="7dcfec5a000e233202dfdaec8aa04adf1d224016" translate="yes" xml:space="preserve">
          <source>In the first form, they are enclosed between &lt;code&gt;r&quot;&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt;. All characters between the &lt;code&gt;r&quot;&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; are part of the string. There are no escape sequences inside wysiwyg strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dfbc2e24539434e62842bac389911ff9852ba28" translate="yes" xml:space="preserve">
          <source>In the graph above, any directed path is a legal implicit conversion. No other qualifier combinations than the ones shown is valid. If a directed path exists between two sets of qualifiers, the types thus qualified are called &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;. The same information is shown below in tabular format:</source>
          <target state="translated">在上图中，任何有向路径都是合法的隐式转换。除显示的限定符组合外，没有其他限定符组合是有效的。如果两组限定词之间存在定向路径，则这样限定的类型称为&lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;。下面以表格形式显示了相同的信息：</target>
        </trans-unit>
        <trans-unit id="02f036d56e5b0f17d6cada283807ab6e4a45c16d" translate="yes" xml:space="preserve">
          <source>In the second step, path components are compared using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">在第二步中，使用 &lt;code&gt;filenameCmp!cs&lt;/code&gt; 比较路径组件，其中 &lt;code&gt;cs&lt;/code&gt; 是一个可选的模板参数，用于确定比较是否区分大小写。有关详细信息，请参见&lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="e25b68a7396b82d8e5f58fe981088b3bb4f8c195" translate="yes" xml:space="preserve">
          <source>In the special case where only a single function is provided (&lt;code&gt;F.length == 1&lt;/code&gt;), adjoin simply aliases to the single passed function (&lt;code&gt;F[0]&lt;/code&gt;).</source>
          <target state="translated">在仅提供单个函数的特殊情况下（ &lt;code&gt;F.length == 1&lt;/code&gt; ），仅将别名附加到单个传递的函数（ &lt;code&gt;F[0]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0d9fe9a61d26a09ceb6b95fd6ad82498884dadd5" translate="yes" xml:space="preserve">
          <source>In the table below, the &lt;b&gt;exact alias&lt;/b&gt;es are types of exactly the specified number of bits. The &lt;b&gt;at least alias&lt;/b&gt;es are at least the specified number of bits large, and can be larger. The &lt;b&gt;fast alias&lt;/b&gt;es are the fastest integral type supported by the processor that is at least as wide as the specified number of bits.</source>
          <target state="translated">在下表中，&lt;b&gt;确切的别名&lt;/b&gt; es恰好是指定位数的类型。所述&lt;b&gt;至少别名&lt;/b&gt; ES是至少大位的指定数量，并且可以更大。的&lt;b&gt;快速别名&lt;/b&gt; ES是由至少一样宽的比特的指定数目的处理器支持的最快的整数类型。</target>
        </trans-unit>
        <trans-unit id="2b57bd98576c6b47e51f692ed2880671dfdcaf21" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;myAllocator&lt;/code&gt; does not obey the &lt;code&gt;IAllocator&lt;/code&gt; interface, but implements its primitives so it can work with &lt;code&gt;makeArray&lt;/code&gt; by means of duck typing.  One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through &lt;code&gt;IAllocator&lt;/code&gt;. An important rule of thumb is: &quot;assemble allocator first, adapt to &lt;code&gt;IAllocator&lt;/code&gt; after&quot;. A good allocator implements intricate logic by means of template assembly, and gets wrapped with &lt;code&gt;IAllocator&lt;/code&gt; (usually by means of &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt;) only once, at client level.</source>
          <target state="translated">在这种情况下， &lt;code&gt;myAllocator&lt;/code&gt; 不遵循 &lt;code&gt;IAllocator&lt;/code&gt; 接口，但是实现了其原语，因此可以通过鸭子类型与 &lt;code&gt;makeArray&lt;/code&gt; 一起使用。关于此设置要注意的一件事是，静态类型的组合分配器几乎总是比通过 &lt;code&gt;IAllocator&lt;/code&gt; 的分配器更快。一个重要的经验法则是：&amp;ldquo;先组装分配器，然后再适应 &lt;code&gt;IAllocator&lt;/code&gt; &amp;rdquo;。一个好的分配器通过模板组装来实现复杂的逻辑，并在客户端级别仅使用 &lt;code&gt;IAllocator&lt;/code&gt; （通常是通过&lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; &lt;/a&gt;）进行包装。</target>
        </trans-unit>
        <trans-unit id="0dbb9df98ee1772b091a23269b418c611c6689cc" translate="yes" xml:space="preserve">
          <source>In this case, the slots at positions 1, 3, 4, and 9 are removed from the array.</source>
          <target state="translated">在这种情况下,位置1、3、4和9的插槽被从阵列中移除。</target>
        </trans-unit>
        <trans-unit id="abbca933ccd59e3aed3eca6e5f8800c940d98fda" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;input&lt;/code&gt; will only be read and no reference to it will be kept around, while &lt;code&gt;count&lt;/code&gt; will be read and written to, and &lt;code&gt;errno&lt;/code&gt; will be set to a value from within the function. This approach gives a semantic meaning to the parameters and allows the compiler to potentially optimize the generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea7dd88fb0b01ff371e8dd1a464cf7603046447" translate="yes" xml:space="preserve">
          <source>In this example, the argument &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; gets bind to &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; gets bind to &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5961fb400c229a03dfc935fa996c5fe8fc78fdb9" translate="yes" xml:space="preserve">
          <source>In this implementation both arguments must be positive. The integral is evaluated by either a power series or continued fraction expansion, depending on the relative values of a and x.</source>
          <target state="translated">在这个实现中,两个参数都必须是正值。根据a和x的相对值,积分通过幂级数或持续分数展开来评估。</target>
        </trans-unit>
        <trans-unit id="bd2e85eebf3596f12832975a35b8c3545510433f" translate="yes" xml:space="preserve">
          <source>In this situation, the assignemnts are actual assign expressions (&lt;code&gt;opAssign&lt;/code&gt; is used if defined).</source>
          <target state="translated">在这种情况下，分配对象是实际的分配表达式（如果已定义，则使用 &lt;code&gt;opAssign&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cecc30a8b51b4071bb5efaef87b2c1dec1a96284" translate="yes" xml:space="preserve">
          <source>In this table &quot;doPut&quot; is a method that places &lt;code&gt;e&lt;/code&gt; into &lt;code&gt;r&lt;/code&gt;, using the correct primitive: &lt;code&gt;r.put(e)&lt;/code&gt; if &lt;code&gt;R&lt;/code&gt; defines &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;r.front = e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is an input range (followed by &lt;code&gt;r.popFront()&lt;/code&gt;), or &lt;code&gt;r(e)&lt;/code&gt; otherwise.</source>
          <target state="translated">在此表中，&amp;ldquo; doPut&amp;rdquo;是使用正确的原语将 &lt;code&gt;e&lt;/code&gt; 放入 &lt;code&gt;r&lt;/code&gt; 的方法：如果 &lt;code&gt;R&lt;/code&gt; 定义了 &lt;code&gt;put&lt;/code&gt; ，则 &lt;code&gt;r.put(e)&lt;/code&gt; ，如果 &lt;code&gt;r&lt;/code&gt; 是输入范围，则 &lt;code&gt;r.front = e&lt;/code&gt; （后跟 &lt;code&gt;r.popFront()&lt;/code&gt; )），否则返回 &lt;code&gt;r(e)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a8b5c14dc9548c1a490e9d5960a9feca99259a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were a function.</source>
          <target state="translated">这样一来,一个结构体或类对象就可以像一个函数一样行事。</target>
        </trans-unit>
        <trans-unit id="17982ced0afda199d35d40c9d0672932dd55162a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were an array.</source>
          <target state="translated">通过这种方式,一个结构体或类对象可以像数组一样行为。</target>
        </trans-unit>
        <trans-unit id="86f8f90c18dbc0f9d343ef02fb0a4cd117e4553c" translate="yes" xml:space="preserve">
          <source>In user code. This class also provides means to add version identifier to the list of global (cross module) identifiers.</source>
          <target state="translated">在用户代码中。该类还提供了将版本标识符添加到全局(跨模块)标识符列表中的方法。</target>
        </trans-unit>
        <trans-unit id="bdee4d1acbdd89d7f24aebad7aeee092188b3727" translate="yes" xml:space="preserve">
          <source>In, Out and Inheritance</source>
          <target state="translated">进、出和继承</target>
        </trans-unit>
        <trans-unit id="783253f63cea9c514d69689860a1ae050327457b" translate="yes" xml:space="preserve">
          <source>In-order Pentium (Pentium1, PMMX, Atom)</source>
          <target state="translated">按顺序排列的奔腾(Pentium1,PMMX,Atom)</target>
        </trans-unit>
        <trans-unit id="7d5a97d89ad4a3be9582069b3310a6d0aee11430" translate="yes" xml:space="preserve">
          <source>InExpression</source>
          <target state="translated">InExpression</target>
        </trans-unit>
        <trans-unit id="6b952134a590c37c3cd245f783f0cab0b35e154b" translate="yes" xml:space="preserve">
          <source>Include all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; options.</source>
          <target state="translated">包括所有&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="21d63116a735028b1065c53175a7201eb75a690c" translate="yes" xml:space="preserve">
          <source>Include none of the above options.</source>
          <target state="translated">不包括上述任何选项。</target>
        </trans-unit>
        <trans-unit id="7fb47f835a97695060fa50d3d9efcf9e0fff9c84" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds (100 ns)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (microseconds), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;months&quot;&lt;/code&gt;, and &lt;code&gt;&quot;years&quot;&lt;/code&gt;</source>
          <target state="translated">包括 &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; （百纳秒（100 ns））， &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; （微秒）， &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; （毫秒）， &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; ， &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; ， &lt;code&gt;&quot;hours&quot;&lt;/code&gt; ， &lt;code&gt;&quot;days&quot;&lt;/code&gt; ， &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; ， &lt;code&gt;&quot;months&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;years&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660485a4ef4f2ea299a5049e5e7f68faa3ac9dd9" translate="yes" xml:space="preserve">
          <source>Includes characters a, b, c, ..., z.</source>
          <target state="translated">包括字符a,b,c,...,z。</target>
        </trans-unit>
        <trans-unit id="e622b4457bdf3ceb03f6cf725fab2a67de905818" translate="yes" xml:space="preserve">
          <source>Incomplete beta integral</source>
          <target state="translated">不完全β积分</target>
        </trans-unit>
        <trans-unit id="861a53fcf5c388edd7cf46ce6d95a43e95f0e787" translate="yes" xml:space="preserve">
          <source>Incomplete gamma integral and its complement</source>
          <target state="translated">不完全伽马积分及其补码。</target>
        </trans-unit>
        <trans-unit id="2f08d5bb658237cd92aa5a4432cb1cfef1a4c7b1" translate="yes" xml:space="preserve">
          <source>Incorporate &lt;code&gt;element_count&lt;/code&gt; and finalizes the hash.</source>
          <target state="translated">合并 &lt;code&gt;element_count&lt;/code&gt; 并完成哈希。</target>
        </trans-unit>
        <trans-unit id="d8c996a9761aab171974108da093507dfd302c9b" translate="yes" xml:space="preserve">
          <source>Increases the reference count of the concrete class that implements this interface.</source>
          <target state="translated">增加实现该接口的具体类的引用次数。</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="6179063ceb022e0b005a77ad50121ce42a8f12e0" translate="yes" xml:space="preserve">
          <source>Incremental options.</source>
          <target state="translated">递增式选择。</target>
        </trans-unit>
        <trans-unit id="84205e80c2673222d26cbdde35ee1f4333d1b71b" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;numOwns&lt;/code&gt; (per instance and and per call) and forwards to &lt;code&gt; parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">递增 &lt;code&gt;numOwns&lt;/code&gt; （按实例和按调用）并转发给 &lt;code&gt; parent.owns(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddaf57d4b4048098b5dfe8043020c47a13b32e0a" translate="yes" xml:space="preserve">
          <source>Independent of the parameter this Logger will never log a message.</source>
          <target state="translated">与参数无关,该记录仪永远不会记录消息。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="699dc9f4598bf2c18561d09ccbeb25728c70494b" translate="yes" xml:space="preserve">
          <source>Index Assignment Operator Overloading</source>
          <target state="translated">索引赋值运算符超载</target>
        </trans-unit>
        <trans-unit id="71c97279cf83fc58467572ececa55bdae6e798a5" translate="yes" xml:space="preserve">
          <source>Index Expressions</source>
          <target state="translated">索引表达式</target>
        </trans-unit>
        <trans-unit id="d1893a899240a1b591d897768bc60814a476fa87" translate="yes" xml:space="preserve">
          <source>Index Name NULL</source>
          <target state="translated">索引名称 NULL</target>
        </trans-unit>
        <trans-unit id="e71ed4c87a94b38c5cecf345cf992053ca3a47d3" translate="yes" xml:space="preserve">
          <source>Index Name Table Name</source>
          <target state="translated">索引名称 表名</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">一个给定名称的参数的索引</target>
        </trans-unit>
        <trans-unit id="bfb09c98cfaf2d55de0462489f758021e1b3f471" translate="yes" xml:space="preserve">
          <source>Index Op Assignment Operator Overloading</source>
          <target state="translated">索引运算符赋值运算符超载</target>
        </trans-unit>
        <trans-unit id="49fe544cd53fba1ec8f72994e8cce9d496cf27f3" translate="yes" xml:space="preserve">
          <source>Index Operator Overloading</source>
          <target state="translated">指数运算符超载</target>
        </trans-unit>
        <trans-unit id="a3b9e1c8a8784dafb7f4615ab228a307d1e4a762" translate="yes" xml:space="preserve">
          <source>Index of the argument for positional parameters, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">位置参数的参数索引，从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;ubyte.max&lt;/code&gt; 。（ &lt;code&gt;0&lt;/code&gt; 表示未使用）。</target>
        </trans-unit>
        <trans-unit id="c34e327ac8e45e062b5805d3beb7a3e4caec8300" translate="yes" xml:space="preserve">
          <source>Index of the last argument for positional parameter range, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">位置参数范围（从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;ubyte.max&lt;/code&gt; )的最后一个参数的索引。（ &lt;code&gt;0&lt;/code&gt; 表示未使用）。</target>
        </trans-unit>
        <trans-unit id="235d469a267eec1b21cb41bd835ec761b3be5b4a" translate="yes" xml:space="preserve">
          <source>Index of the maximal element of a range. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">范围的最大元素的索引。 &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25975946b5389d6cd4927c54b6079d61210dbf05" translate="yes" xml:space="preserve">
          <source>Index of the minimal element of a range. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">范围的最小元素的索引。 &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71356bb2f5e6c2c37298a92b0fcb4df5af1fdc19" translate="yes" xml:space="preserve">
          <source>Index value to set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04ef38d2ddc39bb1db51cbf56276c8f962441c1" translate="yes" xml:space="preserve">
          <source>IndexExpression</source>
          <target state="translated">IndexExpression</target>
        </trans-unit>
        <trans-unit id="3b15c071f8f2a9b03d20f13f4ee4fa47f96aaf8d" translate="yes" xml:space="preserve">
          <source>Indexed!(Source, Indices) &lt;strong id=&quot;indexed&quot;&gt;indexed&lt;/strong&gt;(Source, Indices)(Source source, Indices indices);</source>
          <target state="translated">索引！（来源，指数）&lt;strong id=&quot;indexed&quot;&gt;索引&lt;/strong&gt;（来源，指数）（来源，指数）;</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="76508adf7decca48f64672d4079c15326fbc39f8" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">索引和切片操作。仅在 &lt;code&gt;hasSlicing!Source&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时提供。</target>
        </trans-unit>
        <trans-unit id="74036ccb3b85a0419f22323e1fac3915c3caf378" translate="yes" xml:space="preserve">
          <source>Indexing operators yielding or modifyng the value at the specified index.</source>
          <target state="translated">在指定的索引处产生或修改值的索引运算符。</target>
        </trans-unit>
        <trans-unit id="6d2692938b71d76efadfb2cea1bb4a83352f988a" translate="yes" xml:space="preserve">
          <source>Indexing, slicing and bidirectional operations and range primitives. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">索引，切片和双向操作以及范围原语。仅在 &lt;code&gt;hasSlicing!Source&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时提供。</target>
        </trans-unit>
        <trans-unit id="f85958353bf4bfb31d66cc4f95a9358b5bedf1c3" translate="yes" xml:space="preserve">
          <source>Indicates a direction in time. One example of its use is &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#expand&quot;&gt;&lt;code&gt;expand&lt;/code&gt;&lt;/a&gt; function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</source>
          <target state="translated">指示时间方向。其用法的一个示例是&lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;#expand&quot;&gt; &lt;code&gt;expand&lt;/code&gt; &lt;/a&gt;函数，该函数使用该函数指示该间隔是应向后（扩展为过去），向前（扩展为将来）还是同时扩展两者。</target>
        </trans-unit>
        <trans-unit id="89b0fbd07a7b5dbf8da4ba701f1805d8565d86bb" translate="yes" xml:space="preserve">
          <source>Indicates if a nested aggregate prevents or not a function to be inlined. It's used to compute the cost but also to avoid a copy of the aggregate while the inliner processes.</source>
          <target state="translated">表示嵌套的集合是否阻止或不阻止一个函数被内联。它用于计算成本,但也用于在内联器处理时,避免对集合进行复制。</target>
        </trans-unit>
        <trans-unit id="a10ebf2fd0a4ff0f019e4879f48fae2f4e5a0b0d" translate="yes" xml:space="preserve">
          <source>Indicates that the managed memory space be minimized by returning free physical memory to the operating system. The amount of free memory returned depends on the allocator design and on program behavior.</source>
          <target state="translated">表示通过将空闲的物理内存返回给操作系统,使管理的内存空间最小化。返回的空闲内存量取决于分配器设计和程序行为。</target>
        </trans-unit>
        <trans-unit id="4ec109e112fc6bfd6a9d0109f56e7e7967df8488" translate="yes" xml:space="preserve">
          <source>Indicates the checking state of various contracts.</source>
          <target state="translated">表示各种合同的检查状态。</target>
        </trans-unit>
        <trans-unit id="cb18c8046fd7efef0dda1d752fd5c6ff22b02f5d" translate="yes" xml:space="preserve">
          <source>Indicates the kind of scan being performed by &lt;code&gt;thread_scanAllType&lt;/code&gt;.</source>
          <target state="translated">指示 &lt;code&gt;thread_scanAllType&lt;/code&gt; 执行的扫描类型。</target>
        </trans-unit>
        <trans-unit id="8f13413a46338bc9d77efe386dd1970d9c61578f" translate="yes" xml:space="preserve">
          <source>Indicates the type of a &lt;code&gt;JSONValue&lt;/code&gt;.</source>
          <target state="translated">指示 &lt;code&gt;JSONValue&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="ee35c8aada8a6aa7b7217bd768effeae4d28769f" translate="yes" xml:space="preserve">
          <source>Indicates whether &lt;code&gt;T&lt;/code&gt; is a file handle, i.e. the type is implicitly convertable to &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; or a pointer to a &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt;&lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示 &lt;code&gt;T&lt;/code&gt; 是文件句柄，即类型可以隐式转换为&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;还是指向&lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt; &lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt; &lt;/a&gt;的指针。</target>
        </trans-unit>
        <trans-unit id="16f0af9200309c4bcede9c6bd76aa0d14467a310" translate="yes" xml:space="preserve">
          <source>Indicates whether an address has been marked by the GC.</source>
          <target state="translated">表示地址是否已被GC标记。</target>
        </trans-unit>
        <trans-unit id="c7fabc24fed84961bce8996fe0ecd1e5cdad5e83" translate="yes" xml:space="preserve">
          <source>Indicates whether the comparisons are case sensitive.</source>
          <target state="translated">表示比较是否区分大小写。</target>
        </trans-unit>
        <trans-unit id="f7d28431fd9c9c5871085a5497dc7e6e1e0cf415" translate="yes" xml:space="preserve">
          <source>Indicates which contracts should be checked or not.</source>
          <target state="translated">表示哪些合同应予检查或不检查。</target>
        </trans-unit>
        <trans-unit id="4243a1f947d3219fb4149e60971ece346868e5f0" translate="yes" xml:space="preserve">
          <source>Individual characters (&lt;code&gt;char, &lt;/code&gt;wchar&lt;code&gt;, or &lt;/code&gt;dchar`) are formatted as Unicode characters with &lt;code&gt;%s&lt;/code&gt; and as integers with integral-specific format specs.</source>
          <target state="translated">各个字符（ &lt;code&gt;char, &lt;/code&gt; wchar &lt;code&gt;, or &lt;/code&gt; dchar`）的格式为带有 &lt;code&gt;%s&lt;/code&gt; 的 Unicode字符，以及具有整数特定格式的规范的整数。</target>
        </trans-unit>
        <trans-unit id="29597351771a3ef19075a67f20ee90c6ad63bea0" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not.</source>
          <target state="translated">使用 &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; 比较单个字符，其中 &lt;code&gt;cs&lt;/code&gt; 是一个可选的模板参数，确定比较是否区分大小写。</target>
        </trans-unit>
        <trans-unit id="49226687980b9cd956057b7a38e24b4e2409b256" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCharCmp&quot;&gt;&lt;code&gt;filenameCharCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">使用 &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; 比较单个字符，其中 &lt;code&gt;cs&lt;/code&gt; 是一个可选的模板参数，确定比较是否区分大小写。有关详细信息，请参见&lt;a href=&quot;#filenameCharCmp&quot;&gt; &lt;code&gt;filenameCharCmp&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="e1f361f1f9ae5992659047882bc5221a903aebb0" translate="yes" xml:space="preserve">
          <source>Individual field in the Ctor with information about its callees and location.</source>
          <target state="translated">Ctor中的单个字段,包含其被叫人和位置的信息。</target>
        </trans-unit>
        <trans-unit id="2112ae8639e7801d8cfbbdd81cd2583bb2a4a9cd" translate="yes" xml:space="preserve">
          <source>Individual tests are specified in the unit test using &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;. Unlike</source>
          <target state="translated">单个测试在使用&lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;的单元测试中指定。不像</target>
        </trans-unit>
        <trans-unit id="a1c45f8b0cd8cbcf6f1e93b6a635fb2a38dc40f6" translate="yes" xml:space="preserve">
          <source>Inequality is defined as the logical negation of equality.</source>
          <target state="translated">不平等是指平等的逻辑否定。</target>
        </trans-unit>
        <trans-unit id="65b109f015e153776d80b153da2023fd8d163d9f" translate="yes" xml:space="preserve">
          <source>Infinite ranges are compatible, provided the parameter &lt;code&gt;upTo&lt;/code&gt; is specified, in which case the implementation simply returns upTo.</source>
          <target state="translated">如果指定了参数 &lt;code&gt;upTo&lt;/code&gt; ,则无限范围是兼容的，在这种情况下，实现仅返回upTo。</target>
        </trans-unit>
        <trans-unit id="cc80f798db63ecb0ec11198be5af2b60c15e0345" translate="yes" xml:space="preserve">
          <source>Infinite ranges with slicing support must return an instance of &lt;a href=&quot;std_range#Take&quot;&gt;&lt;code&gt;std.range.Take&lt;/code&gt;&lt;/a&gt; when sliced with a specific lower and upper bound (see &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt;); &lt;code&gt;handle&lt;/code&gt; deals with this by &lt;code&gt;take&lt;/code&gt;ing 0 from the return value of the handler function and returning that when an exception is caught.</source>
          <target state="translated">具有切片支持的无限范围必须返回&lt;a href=&quot;std_range#Take&quot;&gt; &lt;code&gt;std.range.Take&lt;/code&gt; &lt;/a&gt;的实例，并在切片时具有特定的上下限（请参见&lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt;）； &lt;code&gt;handle&lt;/code&gt; 通过从处理函数的返回值中 &lt;code&gt;take&lt;/code&gt; 0并在捕获到异常时返回该值来处理此问题。</target>
        </trans-unit>
        <trans-unit id="27d9e5c1d05febee114a9f9e51dbec3780887c9a" translate="yes" xml:space="preserve">
          <source>Infiniteness of the wrapped range is not propagated.  Length is not propagated in the case of non-random access ranges.</source>
          <target state="translated">包裹范围的无限性不被传播,在非随机访问范围中,长度不被传播。在非随机访问范围的情况下,不传播长度。</target>
        </trans-unit>
        <trans-unit id="193bbd547918874dedb7a8a3d593f29b74828e01" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a POSIX system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266086404e3edd52081be68722aa77ff6a65cf70" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a Posix system.</source>
          <target state="translated">文件的信息,类似于Posix系统中的统计信息。</target>
        </trans-unit>
        <trans-unit id="cd1b541e2d202e9ed7863df5d539d80a14d92db1" translate="yes" xml:space="preserve">
          <source>Information about an interface. When an object is accessed via an interface, an Interface* appears as the first entry in its vtbl.</source>
          <target state="translated">关于接口的信息。当一个对象通过接口被访问时,接口*将作为其vtbl的第一个条目出现。</target>
        </trans-unit>
        <trans-unit id="cea2e687310e3b71b249c28a49288e9fd3bfa210" translate="yes" xml:space="preserve">
          <source>Information about an option.</source>
          <target state="translated">关于一个选项的信息。</target>
        </trans-unit>
        <trans-unit id="e073c50eee2c368b573895c98fb35595e9133239" translate="yes" xml:space="preserve">
          <source>Information about errors should be logged with this level.</source>
          <target state="translated">有关错误的信息应与本级进行记录。</target>
        </trans-unit>
        <trans-unit id="928345681d20aa3d2b01bea36a816d52c33a48de" translate="yes" xml:space="preserve">
          <source>Information about the dynamic type of the class</source>
          <target state="translated">类的动态类型信息</target>
        </trans-unit>
        <trans-unit id="dc5ebb2696c4fafd1bdd1b19b9d403757258f4ad" translate="yes" xml:space="preserve">
          <source>Information about the error.</source>
          <target state="translated">关于错误的信息。</target>
        </trans-unit>
        <trans-unit id="b7329bd16608fcee8af0c9e3dcd5b29f7f17343f" translate="yes" xml:space="preserve">
          <source>Information about the target operating system, environment, and CPU.</source>
          <target state="translated">关于目标操作系统、环境和CPU的信息。</target>
        </trans-unit>
        <trans-unit id="ceccba3653730142ed262183682108d6a4b114f3" translate="yes" xml:space="preserve">
          <source>Information gathered about externally defined template member functions, member data, and member classes.</source>
          <target state="translated">收集外部定义的模板成员函数、成员数据和成员类的信息。</target>
        </trans-unit>
        <trans-unit id="908b94b8c3e2309d82de3bc12b0083b2f0550dd4" translate="yes" xml:space="preserve">
          <source>Information gathered about nested class friends.</source>
          <target state="translated">收集了嵌套类朋友的信息。</target>
        </trans-unit>
        <trans-unit id="7a43d043ba9567583c6e384e6e0ac879da254eab" translate="yes" xml:space="preserve">
          <source>Information gathered about nested explicit specializations.</source>
          <target state="translated">收集到的关于嵌套式显式专业化的信息。</target>
        </trans-unit>
        <trans-unit id="464dcc7e55ca0baa3461154f3221489d53fa204b" translate="yes" xml:space="preserve">
          <source>Information gathered about primary member template explicit specialization.</source>
          <target state="translated">收集到的主要成员模板明确专业化的信息。</target>
        </trans-unit>
        <trans-unit id="8bc70f913f6ebe36fcb59b26b1c9b07d1f380466" translate="yes" xml:space="preserve">
          <source>Information regarding the allocated memory block or BlkInfo.init on error.</source>
          <target state="translated">有关分配的内存块或BlkInfo.init错误时的信息。</target>
        </trans-unit>
        <trans-unit id="1675fcfc1cf455d10d63328190309be0fe262d03" translate="yes" xml:space="preserve">
          <source>Information regarding the memory block referenced by p or BlkInfo.init on error.</source>
          <target state="translated">关于p或BlkInfo.init错误时引用的内存块的信息。</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">初始值</target>
        </trans-unit>
        <trans-unit id="97e0f0f5459c7f9a8a0eadb6d21739e1c19dd524" translate="yes" xml:space="preserve">
          <source>Initial_Punctuation</source>
          <target state="translated">Initial_Punctuation</target>
        </trans-unit>
        <trans-unit id="e3e40f7638a489f11f1de06365e82209954d82d0" translate="yes" xml:space="preserve">
          <source>Initialization hook, called FROM each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">初始化钩子,from每个线程调用。对模块初始化状态不应做任何假设。</target>
        </trans-unit>
        <trans-unit id="a459dff3012da591453989e5860a6fd825f63ce3" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="translated">Initialize</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">初始化 SQLite 库</target>
        </trans-unit>
        <trans-unit id="748256c78e345ebbc504f121b03e80be2a80bbca" translate="yes" xml:space="preserve">
          <source>Initialize a TOK.cantExpression Expression.</source>
          <target state="translated">初始化一个TOK.cantExpression表达式。</target>
        </trans-unit>
        <trans-unit id="e6d6bffc11d0689a05cff44169b6e949eafbef76" translate="yes" xml:space="preserve">
          <source>Initialize ap. parmn should be the last named parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27911a1150c0c1d2144b25e270682254f6dac63a" translate="yes" xml:space="preserve">
          <source>Initialize config variables.</source>
          <target state="translated">初始化配置变量。</target>
        </trans-unit>
        <trans-unit id="cbe2f6d3df93f8e15ce05f5a1f98cda2b20db74a" translate="yes" xml:space="preserve">
          <source>Initialize druntime. If a C program wishes to call D code, and there's no D main(), then it must call rt_init() and rt_term().</source>
          <target state="translated">初始化druntime。如果一个C程序想调用D代码,而没有D主(),那么它必须调用rt_init()和rt_term()。</target>
        </trans-unit>
        <trans-unit id="8eb8be79e89fc0c011f24c39ee8771af00f563f7" translate="yes" xml:space="preserve">
          <source>Initialize for inferring the attributes of this function.</source>
          <target state="translated">初始化,用于推断该函数的属性。</target>
        </trans-unit>
        <trans-unit id="f721b948f9c83247c02645e5eb12893bfb899d86" translate="yes" xml:space="preserve">
          <source>Initialize list package.</source>
          <target state="translated">初始化列表包。</target>
        </trans-unit>
        <trans-unit id="de4ea7df574920c39fb3c6bd0386ce6a9cd8fd5d" translate="yes" xml:space="preserve">
          <source>Initialize the Objective-C string using a C string.</source>
          <target state="translated">使用C字符串初始化Objective-C字符串。</target>
        </trans-unit>
        <trans-unit id="ef4109d3528796628f6b2a0029715405248a578e" translate="yes" xml:space="preserve">
          <source>Initialize the Target</source>
          <target state="translated">初始化目标</target>
        </trans-unit>
        <trans-unit id="0980ce942938201d58c731edfd7b47e45dd9efe7" translate="yes" xml:space="preserve">
          <source>Initialize the dual-context array with the context pointers.</source>
          <target state="translated">用上下文指针初始化双上下文数组。</target>
        </trans-unit>
        <trans-unit id="8e023ffe90e1164684f46dc5edc97859a5680a5f" translate="yes" xml:space="preserve">
          <source>Initialize the hidden aggregate member, vthis, with the context pointer.</source>
          <target state="translated">用上下文指针初始化隐藏的聚合成员vthis。</target>
        </trans-unit>
        <trans-unit id="59c6a3b95f9730ad20a9c9db67ee73fd2a6949c4" translate="yes" xml:space="preserve">
          <source>Initialize the instance by creating a working curl handle.</source>
          <target state="translated">通过创建一个工作的curl句柄来初始化实例。</target>
        </trans-unit>
        <trans-unit id="1a30f56d1770a9dcc7fd0bb681a1c06b14ad9d91" translate="yes" xml:space="preserve">
          <source>Initialize the memory allocator</source>
          <target state="translated">初始化内存分配器</target>
        </trans-unit>
        <trans-unit id="494a02556f310d47be7c5338d8f5523416a42a2e" translate="yes" xml:space="preserve">
          <source>Initialize with a message and an error code.</source>
          <target state="translated">用信息和错误代码初始化。</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="51bf015ae2898049c8dda3ee0d3b48d0b0503aac" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;init&lt;/code&gt;</source>
          <target state="translated">初始化器 &lt;code&gt;init&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b1d1b30aa70eb127392afc002aaf56ef13eddf1" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;inx&lt;/code&gt;</source>
          <target state="translated">初始化器 &lt;code&gt;inx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376a8ae3746f3bef7e7c198b9b11401e24b7d25c" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Initializer init, Scope* sc);</source>
          <target state="translated">初始化程序&lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;（Initializer init，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="d8d2abfa30e5c4556b8e2c9d2dc62e742af966eb" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;(Initializer init, Scope* sc, Type t, NeedInterpret needInterpret);</source>
          <target state="translated">Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;（Initializer init，Scope * sc，Type t，NeedInterpret needInterpret）;</target>
        </trans-unit>
        <trans-unit id="88abdada1a9385d97517a707f4ab8a5f5a3e696d" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt;(Initializer inx);</source>
          <target state="translated">初始化&lt;strong id=&quot;syntaxCopy&quot;&gt;语法&lt;/strong&gt;（Initializer inx）;</target>
        </trans-unit>
        <trans-unit id="c33131a57d387e740aae854652440535c3dd0652" translate="yes" xml:space="preserve">
          <source>Initializer AST node</source>
          <target state="translated">初始化器AST节点</target>
        </trans-unit>
        <trans-unit id="14b021ae9bb3f976f77030248590d743674ec1b8" translate="yes" xml:space="preserve">
          <source>Initializer AST to copy</source>
          <target state="translated">要复制的AST初始化器</target>
        </trans-unit>
        <trans-unit id="3121cafc28fbd2cff06107236c3142ae39ff3c9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RefCounted&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;. The template parameter &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;RefCounted&lt;/code&gt; is inferred from &lt;code&gt;val&lt;/code&gt;. This function can be used to move non-copyable values to the heap. It also disables the &lt;code&gt;autoInit&lt;/code&gt; option of &lt;code&gt;RefCounted&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;val&lt;/code&gt; 初始化 &lt;code&gt;RefCounted&lt;/code&gt; 。模板参数 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;RefCounted&lt;/code&gt; 是从推断 &lt;code&gt;val&lt;/code&gt; 。此函数可用于将不可复制的值移动到堆。它还禁用 &lt;code&gt;RefCounted&lt;/code&gt; 的 &lt;code&gt;autoInit&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="5840e1604b436855e9916e7392a48763951eabf0" translate="yes" xml:space="preserve">
          <source>Initializes a barrier object which releases threads in groups of limit in size.</source>
          <target state="translated">初始化一个屏障对象,该对象在大小限制的组中释放线程。</target>
        </trans-unit>
        <trans-unit id="e7d8f005a4914e6f92d821d5b224a6bd9e5c292c" translate="yes" xml:space="preserve">
          <source>Initializes a condition object which is associated with the supplied mutex object.</source>
          <target state="translated">初始化一个与所提供的mutex对象相关联的条件对象。</target>
        </trans-unit>
        <trans-unit id="2e831c2f248c0c0989af9f49fabed81c26839fd7" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a dynamic D function.</source>
          <target state="translated">初始化一个与动态D函数相关联的光纤对象。</target>
        </trans-unit>
        <trans-unit id="af50363b8f7b4155835b77141de6a5c61fdd71a0" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a static D function.</source>
          <target state="translated">初始化一个光纤对象,它与一个静态D函数相关联。</target>
        </trans-unit>
        <trans-unit id="45f928a2b81b560a0de6c9239785399cedf0251c" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a dynamic D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">初始化一个与动态D函数相关联的生成器对象。该函数将被调用一次,以准备迭代的范围。</target>
        </trans-unit>
        <trans-unit id="d0a92e3c77360cd0a21c46127be86aca1b90b608" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a static D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">初始化一个生成器对象,该对象与一个静态D函数相关联。该函数将被调用一次,以准备迭代的范围。</target>
        </trans-unit>
        <trans-unit id="d3728c381d3549c70b43d294cf94f34b914968b0" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object and sets it as the monitor for &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">初始化一个互斥对象，并将其设置为 &lt;code&gt;obj&lt;/code&gt; 的监视器。</target>
        </trans-unit>
        <trans-unit id="3a70c8975cc02255930db5c1532e070f13d983d9" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object.</source>
          <target state="translated">初始化一个mutex对象。</target>
        </trans-unit>
        <trans-unit id="dc21cd96d7c298b730677d5fadf1f39d6fcdc2a3" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex object with the supplied policy.</source>
          <target state="translated">用提供的策略初始化一个读/写mutex对象。</target>
        </trans-unit>
        <trans-unit id="1bf7bde2d0e1b4605f5fcc7cecf50b8041c0ee33" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex reader proxy object.</source>
          <target state="translated">初始化一个读/写mutex阅读器代理对象。</target>
        </trans-unit>
        <trans-unit id="cac251d6ab6ce4228fd76b8f664aca1fdce466aa" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex writer proxy object.</source>
          <target state="translated">初始化一个读/写mutex写代理对象。</target>
        </trans-unit>
        <trans-unit id="e9c3d0e482ee4665047c01099490677dcee2bdf1" translate="yes" xml:space="preserve">
          <source>Initializes a semaphore object with the specified initial count.</source>
          <target state="translated">用指定的初始计数初始化一个旗语对象。</target>
        </trans-unit>
        <trans-unit id="b08f976531720c8d331b9fd2fe472f259a01f7f8" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a dynamic D function.</source>
          <target state="translated">初始化一个与动态D函数相关联的线程对象。</target>
        </trans-unit>
        <trans-unit id="6feddfb754d931f52971603d63763097e08f646e" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a static D function.</source>
          <target state="translated">初始化一个线程对象,该对象与一个静态D函数相关联。</target>
        </trans-unit>
        <trans-unit id="02e85d0a8c0d02c068e1d5736a1954b12b36920b" translate="yes" xml:space="preserve">
          <source>Initializes all elements of &lt;code&gt;range&lt;/code&gt; with their &lt;code&gt;.init&lt;/code&gt; value. Assumes that the elements of the range are uninitialized.</source>
          <target state="translated">初始化的所有元素 &lt;code&gt;range&lt;/code&gt; 与他们 &lt;code&gt;.init&lt;/code&gt; 值。假定范围的元素未初始化。</target>
        </trans-unit>
        <trans-unit id="472c952e25298d18516b57e8e37279e00d61a5fe" translate="yes" xml:space="preserve">
          <source>Initializes an event object. Does nothing if the event is already initialized.</source>
          <target state="translated">初始化一个事件对象。如果事件已经被初始化,则不做任何操作。</target>
        </trans-unit>
        <trans-unit id="eaf4287ba6b011331efecfcdf502db022ed8e9d5" translate="yes" xml:space="preserve">
          <source>Initializes each element of &lt;code&gt;range&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. Assumes that the elements of the range are uninitialized. This is of interest for structs that define copy constructors (for all other types, &lt;a href=&quot;#fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt; and uninitializedFill are equivalent).</source>
          <target state="translated">使用 &lt;code&gt;value&lt;/code&gt; 初始化 &lt;code&gt;range&lt;/code&gt; 的每个元素。假定范围的元素未初始化。这对于定义副本构造函数的结构很有用（对于所有其他类型，&lt;a href=&quot;#fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt;和uninitializedFill是等效的）。</target>
        </trans-unit>
        <trans-unit id="fc7f0006265d50c993eca80b0dee1e88b813e83a" translate="yes" xml:space="preserve">
          <source>Initializes the Symbol s with the contents of the exception handler table.</source>
          <target state="translated">用异常处理表的内容初始化Symbol s。</target>
        </trans-unit>
        <trans-unit id="ce7db86ae90730cf95765268d14c3efeca306d1a" translate="yes" xml:space="preserve">
          <source>Initializes the digest.</source>
          <target state="translated">初始化摘要。</target>
        </trans-unit>
        <trans-unit id="7cc4cbbc423778a9b3a1d152d6911455078c9956" translate="yes" xml:space="preserve">
          <source>Initializes the runtime. This call is to be used in instances where the standard program initialization process is not executed. This is most often in shared libraries or in libraries linked to a C program. If the runtime was already successfully initialized this returns true. Each call to initialize must be paired by a call to &lt;a href=&quot;#terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">初始化运行时。此调用将在未执行标准程序初始化过程的情况下使用。这通常是在共享库或链接到C程序的库中。如果运行时已经成功初始化，则返回true。每个初始化调用必须与一个&lt;a href=&quot;#terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt;调用配对。</target>
        </trans-unit>
        <trans-unit id="fd011618a7d780c02099be5bb857d574a889ced4" translate="yes" xml:space="preserve">
          <source>Initializes the thread module. This function must be called by the garbage collector on startup and before any other thread routines are called.</source>
          <target state="translated">初始化线程模块。这个函数必须在启动时和其他线程例程被调用之前被垃圾收集器调用。</target>
        </trans-unit>
        <trans-unit id="f7bf172cc09f5d408e5dbadd459ffc810fa40735" translate="yes" xml:space="preserve">
          <source>Initializes this object.</source>
          <target state="translated">初始化这个对象。</target>
        </trans-unit>
        <trans-unit id="330d0782e4b98319bc9e2fabb58b097370cccd48" translate="yes" xml:space="preserve">
          <source>Initializes var with the lazy init value in a thread-safe manner.</source>
          <target state="translated">以线程安全的方式用懒惰的init值初始化var。</target>
        </trans-unit>
        <trans-unit id="357baf1e97067fcd6c5956ff04a8aafd59f2e20c" translate="yes" xml:space="preserve">
          <source>Initializing a field more than once is an error:</source>
          <target state="translated">初始化一个字段一次以上是错误的。</target>
        </trans-unit>
        <trans-unit id="7b6a85ba00f40263892051680251fc88efc22b1f" translate="yes" xml:space="preserve">
          <source>Initially, &lt;code&gt;KRRegion&lt;/code&gt; starts in &quot;region&quot; mode: allocations are served from the memory chunk in a region fashion. Thus, as long as there is enough memory left, &lt;code&gt;KRRegion.allocate&lt;/code&gt; has the performance profile of a region allocator. Deallocation inserts (in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time) the deallocated blocks in an unstructured freelist, which is not read in region mode.</source>
          <target state="translated">最初， &lt;code&gt;KRRegion&lt;/code&gt; 以&amp;ldquo;区域&amp;rdquo;模式启动：以区域方式从内存块提供分配。因此，只要还有足够的内存， &lt;code&gt;KRRegion.allocate&lt;/code&gt; 就会具有区域分配器的性能概况。解除分配在非结构化的空闲列表中插入（在&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）时间内）被解除分配的块，该列表在区域模式下不被读取。</target>
        </trans-unit>
        <trans-unit id="6bcf5b308aa4ed1bdc1fe48856a7ba75e0842648" translate="yes" xml:space="preserve">
          <source>Initiate a search for all non-overlapping matches to the pattern &lt;code&gt;re&lt;/code&gt; in the given &lt;code&gt;input&lt;/code&gt;. The result is a lazy range of matches generated as they are encountered in the input going left to right.</source>
          <target state="translated">在给定 &lt;code&gt;input&lt;/code&gt; 搜索与模式 &lt;code&gt;re&lt;/code&gt; 的所有非重叠匹配。结果是在输入中从左到右遇到匹配时产生的延迟匹配范围。</target>
        </trans-unit>
        <trans-unit id="39a92c1c48ec637efb7a0a17e58b57967f5754ea" translate="yes" xml:space="preserve">
          <source>Initiate the shutdown</source>
          <target state="translated">开始关闭</target>
        </trans-unit>
        <trans-unit id="505f260038380736b5ec292da3beb645bc7a02ab" translate="yes" xml:space="preserve">
          <source>Inline Assembler</source>
          <target state="translated">内联装配机</target>
        </trans-unit>
        <trans-unit id="e8c0903b87db76a205d27b465bff8acf36d3a3fc" translate="yes" xml:space="preserve">
          <source>Inline Code</source>
          <target state="translated">内联代码</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="0e581275df3e295be9dbef35d1d241b50ed09352" translate="yes" xml:space="preserve">
          <source>Inline Links</source>
          <target state="translated">内联链接</target>
        </trans-unit>
        <trans-unit id="e928c83ba27af9a3e30934913f4f5025c9156467" translate="yes" xml:space="preserve">
          <source>Inline Status</source>
          <target state="translated">在线状态</target>
        </trans-unit>
        <trans-unit id="2a9bcb6f0852ea225d7f231f321da701f1352c4f" translate="yes" xml:space="preserve">
          <source>Inline assembler can be used to access hardware directly:</source>
          <target state="translated">内联汇编器可以用来直接访问硬件。</target>
        </trans-unit>
        <trans-unit id="79759f20677d34f63a3ad16ca748c0357029c9ef" translate="yes" xml:space="preserve">
          <source>Inline assembler implementation for DMD.</source>
          <target state="translated">DMD的内联汇编器实现。</target>
        </trans-unit>
        <trans-unit id="8bb9331db9f6ba0e169e23c73a72b91ef379fcfb" translate="yes" xml:space="preserve">
          <source>Inline assembler is supported with the asm statement:</source>
          <target state="translated">用asm语句支持内联汇编器。</target>
        </trans-unit>
        <trans-unit id="30bd67072a99e7f0e67136dac69a9f97d8fe06e6" translate="yes" xml:space="preserve">
          <source>Inline code can be written between backtick characters (`), similarly to the syntax used on GitHub, Reddit, Stack Overflow, and other websites. Both the opening and closing ` character must appear on the same line to trigger this behavior.</source>
          <target state="translated">内联代码可以写在回车字符(`)之间,类似于GitHub、Reddit、Stack Overflow和其他网站上使用的语法。开头和结尾的`字符必须出现在同一行才能触发这种行为。</target>
        </trans-unit>
        <trans-unit id="3a0d3f2169904e16efc469dbb314be7e91a83d62" translate="yes" xml:space="preserve">
          <source>Inline-style links enclose link text in square brackets and the link URL in parentheses. Like reference links, the URL may optionally be followed by title text wrapped in single or double quotes, or in parentheses:</source>
          <target state="translated">内联式链接将链接文本放在方括号内,链接URL放在括号内。像参考链接一样,URL后面可以选择用单引号或双引号包裹的标题文本,或者用括号表示。</target>
        </trans-unit>
        <trans-unit id="59987901b798d3774e680b1f2e942cf43901da46" translate="yes" xml:space="preserve">
          <source>InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78d80e54409073effd7ab616e62a68493fee350d" translate="yes" xml:space="preserve">
          <source>Inout Functions</source>
          <target state="translated">输入输出功能</target>
        </trans-unit>
        <trans-unit id="e8e7165f5b963e02cdaf54a8eb17befc2421e96a" translate="yes" xml:space="preserve">
          <source>Inout types can be implicitly converted to const or inout const, but to nothing else. Other types cannot be implicitly converted to inout. Casting to or from inout is not allowed in @safe functions.</source>
          <target state="translated">Inout类型可以隐式转换为const或inout const,但不能转换为其他类型。其他类型不能隐式转换为inout。在@safe函数中不允许向inout类型投掷或从inout类型投掷。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">输入阵列。</target>
        </trans-unit>
        <trans-unit id="805a8fb36fe255b6fb65ad6afc87bb5c87d77739" translate="yes" xml:space="preserve">
          <source>Input range primitives.</source>
          <target state="translated">输入范围基元。</target>
        </trans-unit>
        <trans-unit id="2b5a3aca97f7c0ee924c45da0b642efd3933bcec" translate="yes" xml:space="preserve">
          <source>Input range primitives. Always present.</source>
          <target state="translated">输入范围基元。始终存在。</target>
        </trans-unit>
        <trans-unit id="3ea0015c09b13077d49706cf98824e19781f5a6d" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;front&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;front&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea0417fdf24ea467e5d4948e4d2f763b6a7eef2b" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">输入范围 &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="263a897da5a7d45d98fac35624cdf4deb7cf4411" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8a5a20feb07807120b419370d56d0cc41af44e6" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;seq&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;seq&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ac91ede8a06926e9fd7701df246ece786ebf98" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, Element)(InputRange haystack, scope Element needle)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;查找&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，InputRange，元素）（InputRange干草堆，范围Element针）</target>
        </trans-unit>
        <trans-unit id="62294650ad3440bbcc9dfa642f50ca9b106dfc41" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred, InputRange)(InputRange haystack)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;查找&lt;/strong&gt;（别名pred，InputRange）（InputRange干草堆）</target>
        </trans-unit>
        <trans-unit id="cd55b74bf8e8c901c82e7777b6c9deb713ab8571" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, ForwardRange)(InputRange seq, ForwardRange choices)</source>
          <target state="translated">InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，InputRange，ForwardRange）（InputRange seq，ForwardRange选择）</target>
        </trans-unit>
        <trans-unit id="215e5e329de1e54df130b5fa8c6b834e564f901b" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;r1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249ee449e0f4478b44dc1191e22438bd70e851a5" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;src&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c677621d3536f932357d78e1812f103084e329df" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71bdacf44f1217f068320302c2f0ee3826890d58" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;tgt&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;tgt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26853b5826e342866783ec6125630078fcc1a0ef" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;（InputRange1，InputRange2）（InputRange1 src，InputRange2 tgt）</target>
        </trans-unit>
        <trans-unit id="a6d9a6e40c7583de17b5334cea373d1a6f012a01" translate="yes" xml:space="preserve">
          <source>InputRangeObject!R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;(R)(R range)</source>
          <target state="translated">InputRangeObject！R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;（R）（R范围）</target>
        </trans-unit>
        <trans-unit id="54690a68ec01cec2015c43085af22e3b7ee1fd11" translate="yes" xml:space="preserve">
          <source>Inscriptional Pahlavi</source>
          <target state="translated">巴列维铭文</target>
        </trans-unit>
        <trans-unit id="fef5264f6a30e6dcae96d08ee848ad4b86a2a3a3" translate="yes" xml:space="preserve">
          <source>Inscriptional Parthian</source>
          <target state="translated">铭文的帕提亚人</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="3c215b42cade3b7a8b98554cb505256252393b54" translate="yes" xml:space="preserve">
          <source>Insert a backtick</source>
          <target state="translated">插入一个支点</target>
        </trans-unit>
        <trans-unit id="138a4c6393efa857920b23a60fdca2a6694f91d0" translate="yes" xml:space="preserve">
          <source>Insert a dollar sign</source>
          <target state="translated">插入一个美元符号</target>
        </trans-unit>
        <trans-unit id="cecb3ad08db064401b3027bd8bdfecfd625474f6" translate="yes" xml:space="preserve">
          <source>Insert a left parenthesis</source>
          <target state="translated">插入一个左括号</target>
        </trans-unit>
        <trans-unit id="cbdb76fffabdf5eb3b5ae5b2ff4c5c2a9ba7b666" translate="yes" xml:space="preserve">
          <source>Insert a line feed (newline)</source>
          <target state="translated">插入一个换行符(换行)。</target>
        </trans-unit>
        <trans-unit id="c0306b572d5a694e3a6dd42bca0200f018f85238" translate="yes" xml:space="preserve">
          <source>Insert a range of elements in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">在容器中插入一个元素的范围。请注意,这不会使当前迭代容器的任何范围无效。</target>
        </trans-unit>
        <trans-unit id="1a917cf9fad45f42c5f9d737b6e96f9575d41832" translate="yes" xml:space="preserve">
          <source>Insert a right parenthesis</source>
          <target state="translated">插入一个右括号</target>
        </trans-unit>
        <trans-unit id="327083c1ff82497e1f646caa621a2ae2d82389b4" translate="yes" xml:space="preserve">
          <source>Insert a single element in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">在容器中插入一个单一元素。注意,这不会使当前迭代容器的任何范围无效。</target>
        </trans-unit>
        <trans-unit id="42c8592347a2b25e78dc2c81426ea39331669868" translate="yes" xml:space="preserve">
          <source>Insert current item from the source into the target.</source>
          <target state="translated">将当前项目从源项目插入到目标项目中。</target>
        </trans-unit>
        <trans-unit id="d776dcf131b9f5a24feff6fc21b29e6dcf5da88f" translate="yes" xml:space="preserve">
          <source>Insert finally block calls when doing a goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for EH_DWARF exception unwinding.</source>
          <target state="translated">插入finally块调用时,从try块里面做一个goto到外面。在生成块之后完成,因为这样我们就知道了图的所有边,但在计算Bpred的之前。只适用于EH_DWARF异常解除。</target>
        </trans-unit>
        <trans-unit id="5471bf7c7cfa66ea6e595c4758d088cf1cff366e" translate="yes" xml:space="preserve">
          <source>Insert gotos to finally blocks when doing a return or goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for functions with no exception handling. Very similar to insertFinallyBlockCalls().</source>
          <target state="translated">在做返回或从try block里面的goto到外面的时候,插入goto到finally blocks。在生成块之后完成,因为这样我们就知道了图的所有边,但在计算Bpred之前。只适用于没有异常处理的函数。与insertFinallyBlockCalls()非常相似。</target>
        </trans-unit>
        <trans-unit id="dac79eb40ab7303630f93c4973c9239f694c7c19" translate="yes" xml:space="preserve">
          <source>Insert item into list at nth position.</source>
          <target state="translated">在列表的第n位插入项目。</target>
        </trans-unit>
        <trans-unit id="e157f7049edabd9484326a29b8f9b52a72eaeb25" translate="yes" xml:space="preserve">
          <source>Inserted in place of invalid UTF sequences.</source>
          <target state="translated">在无效的UTF序列的位置插入。</target>
        </trans-unit>
        <trans-unit id="143f825d20ba520107ed764caaeba3c49e097300" translate="yes" xml:space="preserve">
          <source>Inserting if not present</source>
          <target state="translated">如果没有,则插入</target>
        </trans-unit>
        <trans-unit id="30a6615838d01663d72779532f25d77de2451cfa" translate="yes" xml:space="preserve">
          <source>Insertion failed because database is full</source>
          <target state="translated">插入失败,因为数据库已满</target>
        </trans-unit>
        <trans-unit id="20cdd78769ce43b7cb858f988154e98a6f228025" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime may be turned off with a compiler switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;code&gt;-boundscheck&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用编译器switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt; &lt;code&gt;-boundscheck&lt;/code&gt; &lt;/a&gt;关闭运行时数组边界检查代码的插入。</target>
        </trans-unit>
        <trans-unit id="4bdc47adb0591faa30b8ba1f2040d211a501160c" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime should be turned on and off with a compile time switch.</source>
          <target state="translated">在运行时插入数组边界检查代码应该通过编译时的开关来开启和关闭。</target>
        </trans-unit>
        <trans-unit id="0fe401e132558c29c269b7fd6cffd6a1dc02d7db" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; (which must be an input range or any number of implicitly convertible items) in &lt;code&gt;array&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;pos&lt;/code&gt; 位置的 &lt;code&gt;array&lt;/code&gt; 中插入 &lt;code&gt;stuff&lt;/code&gt; （必须是输入范围或任意数量的隐式可转换项）。</target>
        </trans-unit>
        <trans-unit id="ccbf9d19e58cf1e67a852d50890252788f63b174" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a non-empty range previously extracted from this container.</source>
          <target state="translated">在范围 &lt;code&gt;r&lt;/code&gt; 之后插入 &lt;code&gt;stuff&lt;/code&gt; ，该范围必须是先前从此容器提取的非空范围。</target>
        </trans-unit>
        <trans-unit id="bbcf5a5de0747fda77b1e1e1643549b4e06e5bb8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a range previously extracted from this container. Given that all ranges for a list end at the end of the list, this function essentially appends to the list and uses &lt;code&gt;r&lt;/code&gt; as a potentially fast way to reach the last node in the list. Ideally &lt;code&gt;r&lt;/code&gt; is positioned near or at the last element of the list.</source>
          <target state="translated">在范围 &lt;code&gt;r&lt;/code&gt; 之后插入 &lt;code&gt;stuff&lt;/code&gt; ，该范围必须是先前从此容器提取的范围。假定列表的所有范围都在列表的末尾，则此函数实质上会追加到列表，并使用 &lt;code&gt;r&lt;/code&gt; 作为到达列表中最后一个节点的潜在快速方法。理想情况下， &lt;code&gt;r&lt;/code&gt; 位于列表的最后一个元素附近或该列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="6f06bb00c64490bdfd0684d68ce1e50ed8931cf5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">在范围 &lt;code&gt;r&lt;/code&gt; 之前，之后或取而代之地插入 &lt;code&gt;stuff&lt;/code&gt; ，该范围必须是先前从此数组中提取的有效范围。 &lt;code&gt;stuff&lt;/code&gt; 可以是可转换的值 &lt;code&gt;T&lt;/code&gt; 或可转换为一定范围的对象 &lt;code&gt;T&lt;/code&gt; 。稳定版本和非稳定版本的行为相同，并保证遍历数组的范围永远不会无效。</target>
        </trans-unit>
        <trans-unit id="f08fcf4de04b5d69b89946f0b954703523fa90fc" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">在范围 &lt;code&gt;r&lt;/code&gt; 之前，之后或取而代之地插入 &lt;code&gt;stuff&lt;/code&gt; ，该范围必须是先前从此数组中提取的有效范围。 &lt;code&gt;stuff&lt;/code&gt; 可以转换为一个值 &lt;code&gt;bool&lt;/code&gt; 的或可转换为一定范围的对象 &lt;code&gt;bool&lt;/code&gt; 的。稳定版本和非稳定版本的行为相同，并保证遍历数组的范围永远不会无效。</target>
        </trans-unit>
        <trans-unit id="dcb7963cdc25fdee24c788729e6be8dd4f7e3c27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">将 &lt;code&gt;stuff&lt;/code&gt; 插入容器的前面。 &lt;code&gt;stuff&lt;/code&gt; 可以是可转换的值 &lt;code&gt;T&lt;/code&gt; 或可转换为一定范围的对象 &lt;code&gt;T&lt;/code&gt; 。稳定版本的行为相同，但是保证在容器上进行迭代的范围永远不会失效。</target>
        </trans-unit>
        <trans-unit id="70b0bd082af545b88841219b95946def84b1bde5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front/back of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">将 &lt;code&gt;stuff&lt;/code&gt; 插入容器的前面/后面。 &lt;code&gt;stuff&lt;/code&gt; 可以是可转换的值 &lt;code&gt;T&lt;/code&gt; 或可转换为一定范围的对象 &lt;code&gt;T&lt;/code&gt; 。稳定版本的行为相同，但是保证在容器上进行迭代的范围永远不会失效。</target>
        </trans-unit>
        <trans-unit id="98d4bdcdc44b42cf7f92f1b1fa3789c2aceb532f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the back of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;c&lt;/code&gt; 的后面插入 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="314547f0dd75063020e998c66bb1c080e7cc353d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the front of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;c&lt;/code&gt; 的前面插入 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b4118de001ef07d96ca9dc875bb736525602b3c" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the store. If the underlying store is a range and &lt;code&gt;length == capacity&lt;/code&gt;, throws an exception.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 插入商店。如果基础存储区是range和 &lt;code&gt;length == capacity&lt;/code&gt; ，则抛出异常。</target>
        </trans-unit>
        <trans-unit id="7a861229c3ddec4f67c4aba3fc949701aaf45a21" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;c&lt;/code&gt; at a position (or positions) chosen by &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">插入件 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;c&lt;/code&gt; 在由所选择的位置（或位置） &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="804f9143c06ffa0aedcfc5172722337eadf6df16" translate="yes" xml:space="preserve">
          <source>Inserts a blank line.</source>
          <target state="translated">插入一个空行。</target>
        </trans-unit>
        <trans-unit id="7a0447d3d52b9161fad5aa788df5312d0c9f70f2" translate="yes" xml:space="preserve">
          <source>Inserts a comment in the output.</source>
          <target state="translated">在输出中插入注释。</target>
        </trans-unit>
        <trans-unit id="7a683c9546bcec22da2c836a994b3f342b2d3aa0" translate="yes" xml:space="preserve">
          <source>Inserts a full load/store memory fence (on platforms that need it). This ensures that all loads and stores before a call to this function are executed before any loads and stores after the call.</source>
          <target state="translated">插入一个完整的加载/存储内存栅栏(在需要它的平台上)。这确保了在调用该函数之前的所有加载和存储都在调用之后的任何加载和存储之前执行。</target>
        </trans-unit>
        <trans-unit id="a94c7ccab5212d83d09585607543df4cd0d7b0e8" translate="yes" xml:space="preserve">
          <source>Inserts a separator between overloads of a given name.</source>
          <target state="translated">在给定名称的重载之间插入一个分隔符。</target>
        </trans-unit>
        <trans-unit id="aa15c23194538bcbb65217c20c49d6e178298d1b" translate="yes" xml:space="preserve">
          <source>Inserts inline code.</source>
          <target state="translated">插入内联代码。</target>
        </trans-unit>
        <trans-unit id="be7c29e597d6483bb5cc792a0734c8430284107e" translate="yes" xml:space="preserve">
          <source>Inserts into an existing array at a given position.</source>
          <target state="translated">在给定的位置插入一个现有的数组中。</target>
        </trans-unit>
        <trans-unit id="b2e6a38a54ba983c83824eb96e11fa99e1fb236e" translate="yes" xml:space="preserve">
          <source>Inserts the separator symbols ',' every</source>
          <target state="translated">每隔一段时间就插入分隔符','。</target>
        </trans-unit>
        <trans-unit id="801258f3c2858353c18f16295039e48c4b8fb913" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">将指定的元素插入数组的后面。 &lt;code&gt;stuff&lt;/code&gt; 可以是可转换的值 &lt;code&gt;T&lt;/code&gt; 或可转换为一定范围的对象 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14cde1bdd1549aef1d369341e6d66efc2807a4bc" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">将指定的元素插入数组的后面。 &lt;code&gt;stuff&lt;/code&gt; 可以转换为一个值 &lt;code&gt;bool&lt;/code&gt; 的或可转换为一定范围的对象 &lt;code&gt;bool&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="1d605a6236091ada3048879c73c926d0efb2298d" translate="yes" xml:space="preserve">
          <source>Inside a compound format specifier, strings and characters are escaped automatically. To avoid this behavior, add &lt;b&gt;'-'&lt;/b&gt; flag to &lt;code&gt;&quot;%(&quot;&lt;/code&gt;.</source>
          <target state="translated">在复合格式说明符中，字符串和字符会自动转义。为避免此行为，请在&lt;b&gt;' &lt;/b&gt; &lt;code&gt;&quot;%(&quot;&lt;/code&gt; 添加&lt;b&gt;'-'&lt;/b&gt;标志。</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">实例变量</target>
        </trans-unit>
        <trans-unit id="6dcf70f56aa9632f46bb219a5e2ab80717bd81f1" translate="yes" xml:space="preserve">
          <source>Instance shared by all callers.</source>
          <target state="translated">实例由所有调用者共享。</target>
        </trans-unit>
        <trans-unit id="1d560aaea91ff74c40b9ba925224eb2e9cab5714" translate="yes" xml:space="preserve">
          <source>Instances of class objects are created with a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">类对象的实例是使用&lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;创建的：</target>
        </trans-unit>
        <trans-unit id="0e15b22639879009392385cbbbd0e07778e511d1" translate="yes" xml:space="preserve">
          <source>Instances of this object are constructed via calls to &lt;code&gt;regex&lt;/code&gt;. This is an intended form for caching and storage of frequently used regular expressions.</source>
          <target state="translated">通过调用 &lt;code&gt;regex&lt;/code&gt; 构造此对象的实例。这是用于缓存和存储常用正则表达式的预期形式。</target>
        </trans-unit>
        <trans-unit id="9c373dca3c1b04cc6629e642fffbe62b3a9fe4e5" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;DebugCondition&lt;/code&gt;</source>
          <target state="translated">实例化一个新的 &lt;code&gt;DebugCondition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3822674a7468f752517c5bf52d226dd0137e7bff" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;VersionCondition&lt;/code&gt;</source>
          <target state="translated">实例化一个新的 &lt;code&gt;VersionCondition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="152f1a2b9d65da1e9f82b24f153f213ef690987a" translate="yes" xml:space="preserve">
          <source>Instantiates the given template with the given parameters.</source>
          <target state="translated">用给定的参数实例化给定的模板。</target>
        </trans-unit>
        <trans-unit id="4a327f215e80d73f8ee4464a28c7b7c009445a31" translate="yes" xml:space="preserve">
          <source>Instantiation Scope</source>
          <target state="translated">实例范围</target>
        </trans-unit>
        <trans-unit id="93486e626687f1b1676b1b49e1fd6518a0b454b0" translate="yes" xml:space="preserve">
          <source>Instantiation information</source>
          <target state="translated">实例信息</target>
        </trans-unit>
        <trans-unit id="dac2b060e0095872817c2470eb8b53d6b6180adb" translate="yes" xml:space="preserve">
          <source>Instatiates a new function call expression</source>
          <target state="translated">实行一个新的函数调用表达式</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="a0905dbb5b366516614f7115449ef89eac51f289" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to not use any signal/alarm handlers, even when using timeouts. This option is useful for multi-threaded applications. See libcurl-the-guide for more background information.</source>
          <target state="translated">指示libcurl不使用任何信号/警报处理程序,即使是在使用超时的情况下。这个选项对多线程应用程序很有用。更多背景信息请参见libcurl-the-guide。</target>
        </trans-unit>
        <trans-unit id="93df39339f21a04f493609200c104dc46ba84fa9" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to use a smaller receive buffer</source>
          <target state="translated">指示libcurl使用较小的接收缓冲区。</target>
        </trans-unit>
        <trans-unit id="4e856d175354403c672463be1daf8914ce0f2b64" translate="yes" xml:space="preserve">
          <source>Instruct the thread module, when initialized, to use a different set of signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads. This function should be called at most once, prior to thread_init(). This function is Posix-only.</source>
          <target state="translated">指示线程模块在初始化时,除了SIGUSR1和SIGUSR2之外,使用一组不同的信号来暂停和恢复线程。这个函数最多调用一次,在 thread_init()之前。这个函数只适用于Posix。</target>
        </trans-unit>
        <trans-unit id="343c620df1e3c7f2cdd388f70e9f17931e72b6e0" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file suitable for input to a linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea729c0363a2bc9c76992c1a2e2bf3e5220ecc9e" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file, suitable for input to a linker.</source>
          <target state="translated">从目标架构中选择指令来实现程序的语义。典型的结果将是一个对象文件,适合输入到链接器。</target>
        </trans-unit>
        <trans-unit id="0b8c19f21525eb789fb435ee348ba111db6200af" translate="yes" xml:space="preserve">
          <source>Int &lt;code&gt;n&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492ad7a25e9093c89a88ab9eae0481a3d6d480b5" translate="yes" xml:space="preserve">
          <source>IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;(Expression e);</source>
          <target state="translated">IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;（式E）;</target>
        </trans-unit>
        <trans-unit id="562d27265f4183bba6926e62be0c6ce57f7e2097" translate="yes" xml:space="preserve">
          <source>Integer Literals</source>
          <target state="translated">整数字数</target>
        </trans-unit>
        <trans-unit id="bd777b837ba4f419f4b02435e27128be81023ef2" translate="yes" xml:space="preserve">
          <source>Integer Promotions</source>
          <target state="translated">整数促销</target>
        </trans-unit>
        <trans-unit id="9568ecb6786424f8ca136701942b4f686fc642d2" translate="yes" xml:space="preserve">
          <source>Integer Promotions are conversions of the following types:</source>
          <target state="translated">整数促销是以下类型的转换。</target>
        </trans-unit>
        <trans-unit id="db47076f1ac16cea001c1edc5817f57fa5127f93" translate="yes" xml:space="preserve">
          <source>Integer Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong) ['+'|'-']digit(s)[U|L|UL]</source>
          <target state="translated">整数整数。(byte,ubyte,short,ushort,int,uint,long,and ulong)['+''|'-']数字(s)[U|L|UL]。</target>
        </trans-unit>
        <trans-unit id="2c1da0fff670105eb87d89c45a8168527ceeec25" translate="yes" xml:space="preserve">
          <source>Integer comparison operators</source>
          <target state="translated">整数比较运算符</target>
        </trans-unit>
        <trans-unit id="b5ccca1ae24a500cd1c22e7e4ca7606c1848c22a" translate="yes" xml:space="preserve">
          <source>Integer comparisons</source>
          <target state="translated">整数比较</target>
        </trans-unit>
        <trans-unit id="343b406e188c4782bf6c33cf9f047756fbc9ecb9" translate="yes" xml:space="preserve">
          <source>Integer comparisons happen when both operands are integral types.</source>
          <target state="translated">整数比较发生在两个操作数都是积分类型时。</target>
        </trans-unit>
        <trans-unit id="adcbb9dbe2818c1f42e7e40cd4eb69ffc2847624" translate="yes" xml:space="preserve">
          <source>Integer values cannot be implicitly converted to another type that cannot represent the integer bit pattern after integral promotion. For example:</source>
          <target state="translated">整数值在积分推广后,不能隐性地转换为另一种不能表示整数位模式的类型。例如:</target>
        </trans-unit>
        <trans-unit id="2745c9287a60962527a82479b71c8fcdcdfee9b5" translate="yes" xml:space="preserve">
          <source>IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt;(int v)();</source>
          <target state="translated">IntegerExp &lt;strong id=&quot;literal&quot;&gt;文字&lt;/strong&gt;（int v）（）;</target>
        </trans-unit>
        <trans-unit id="9ef2cfdc220f6cdcf3fe63e63ff8a17f54977fca" translate="yes" xml:space="preserve">
          <source>IntegerExpression</source>
          <target state="translated">IntegerExpression</target>
        </trans-unit>
        <trans-unit id="17c52e79fc66bb6ecd61f1fe24bcec43e30c42c1" translate="yes" xml:space="preserve">
          <source>IntegerLiteral</source>
          <target state="translated">IntegerLiteral</target>
        </trans-unit>
        <trans-unit id="36d10f6bb46fb8657ec9f18b1e3a960789ae3c76" translate="yes" xml:space="preserve">
          <source>Integers (that may be constant-folded).</source>
          <target state="translated">整数(可以是恒定的倍数)。</target>
        </trans-unit>
        <trans-unit id="f69d4a47975b227c4173e0f25508229d914b2ec7" translate="yes" xml:space="preserve">
          <source>Integers and floating point values can be implicitly converted to their vector equivalents:</source>
          <target state="translated">整数和浮点值可以隐式转换为它们的向量等值。</target>
        </trans-unit>
        <trans-unit id="85eae330c4b91b44cc2722cee1dc4a35c6511dee" translate="yes" xml:space="preserve">
          <source>Integers can be immediately followed by one &amp;lsquo;L&amp;rsquo; or one of &amp;lsquo;u&amp;rsquo; or &amp;lsquo;U&amp;rsquo; or both. Note that there is no &amp;lsquo;l&amp;rsquo; suffix.</source>
          <target state="translated">整数后面可以紧跟一个'L'或'u'或'U'之一或两者。请注意，没有后缀&amp;ldquo; l&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="78c49e8c1cc448a9049ab277bc8754ecd4237b78" translate="yes" xml:space="preserve">
          <source>Integers can be specified in decimal, binary, or hexadecimal.</source>
          <target state="translated">整数可以用十进制、二进制或十六进制指定。</target>
        </trans-unit>
        <trans-unit id="8c9a0e4fb0cc2adedee60f3111a26afca3f7a640" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters to improve readability, and which are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0a498505f60eef0691bff5f687040cecb8e8a2" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">整数可以包含嵌入的&amp;ldquo; _&amp;rdquo;字符，这些字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="e97fd09a5e159320944c7a6e53ff8dac7ae91693" translate="yes" xml:space="preserve">
          <source>Integral arithmetic operators operate on fixed width types. Results that are not representable in those fixed widths are silently truncated to fit. This module offers integral arithmetic primitives that produce the same results, but set an 'overflow' flag when such truncation occurs. The setting is sticky, meaning that numerous operations can be cascaded and then the flag need only be checked at the end. Whether the operation is signed or unsigned is indicated by an 's' or 'u' suffix, respectively. While this could be achieved without such suffixes by using overloading on the signedness of the types, the suffix makes it clear which is happening without needing to examine the types.</source>
          <target state="translated">积分算术运算符在固定宽度类型上操作。在这些固定宽度中无法表示的结果会被默默截断以适应。该模块提供了可产生相同结果的积分算术基元,但在发生此类截断时,会设置一个 &quot;溢出 &quot;标志。该设置是粘性的,这意味着可以级联许多运算,然后只需要在最后检查标志。操作是有符号的还是无符号的,分别用's'或'u'后缀表示。虽然没有这种后缀也可以通过对类型的签名性使用重载来实现,但后缀可以让人清楚地知道发生了哪种情况,而不需要检查类型。</target>
        </trans-unit>
        <trans-unit id="6c054c378c65fd28ca92392142534a3f43340caf" translate="yes" xml:space="preserve">
          <source>Integral ranges</source>
          <target state="translated">整数范围</target>
        </trans-unit>
        <trans-unit id="3c327fe3bc8ca1ef616b394085c0f88695904ee8" translate="yes" xml:space="preserve">
          <source>Integral types will remain the same sizes between 32 and 64 bit code.</source>
          <target state="translated">积分类型在32位和64位代码之间将保持相同的大小。</target>
        </trans-unit>
        <trans-unit id="58ee21eb085c257d8a08439c9aa7bd9d6570255b" translate="yes" xml:space="preserve">
          <source>Integrals</source>
          <target state="translated">Integrals</target>
        </trans-unit>
        <trans-unit id="304d073445766b9e99ba6213d6788d69fbbe285d" translate="yes" xml:space="preserve">
          <source>Integrals are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">积分的格式类似于&lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20aeee70fc77c214f263c77b05117e3b20686b33" translate="yes" xml:space="preserve">
          <source>Intel Atom 230/330 (family 6, model 0x1C) is an in-order core.</source>
          <target state="translated">英特尔Atom 230/330(家族6,型号0x1C)是一款内购核心。</target>
        </trans-unit>
        <trans-unit id="25a734a01cad152ff48222d53e7362444f3ac6cd" translate="yes" xml:space="preserve">
          <source>Intel NetBurst (Pentium 4, Pentium D).</source>
          <target state="translated">英特尔NetBurst(奔腾4、奔腾D)。</target>
        </trans-unit>
        <trans-unit id="40d218fe001ffffff82fbf964a99f28c6e816245" translate="yes" xml:space="preserve">
          <source>Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</source>
          <target state="translated">英特尔P6(PentiumPro、PII、PIII、PM、Core、Core2)。</target>
        </trans-unit>
        <trans-unit id="ffc1549d5dca52e99aa4ab17a1e6e08f96cd5245" translate="yes" xml:space="preserve">
          <source>Intel and AMD 32-bit processors</source>
          <target state="translated">英特尔和AMD 32位处理器</target>
        </trans-unit>
        <trans-unit id="3eaebee622e08211c80a68d4d6c79b54e2adb573" translate="yes" xml:space="preserve">
          <source>Intel and AMD 64-bit processors</source>
          <target state="translated">英特尔和AMD 64位处理器</target>
        </trans-unit>
        <trans-unit id="d9d20cde548a0781b6cf33434f83eb6eb5ef95f8" translate="yes" xml:space="preserve">
          <source>Intended as the range equivalent of the Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt; utility. When the length of &lt;code&gt;range&lt;/code&gt; is less than or equal to &lt;code&gt;_n&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; is returned as-is.</source>
          <target state="translated">目的是与Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt;实用程序等效的范围。当 &lt;code&gt;range&lt;/code&gt; 的长度小于或等于 &lt;code&gt;_n&lt;/code&gt; 时，将按原样返回 &lt;code&gt;range&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="d88c1e8acf6c80eddca147502d3048d176708e8b" translate="yes" xml:space="preserve">
          <source>Interface for a bidirectional range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;E&lt;/code&gt; 的双向范围的接口。</target>
        </trans-unit>
        <trans-unit id="d0e1da15b0eee348c354776c7e919fb0b891bd0d" translate="yes" xml:space="preserve">
          <source>Interface for a finite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;E&lt;/code&gt; 的有限随机访问范围的接口。</target>
        </trans-unit>
        <trans-unit id="7a634a284850ac6bc64c6899e29c994e3e0d76a1" translate="yes" xml:space="preserve">
          <source>Interface for a forward range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;E&lt;/code&gt; 的正向范围的接口。</target>
        </trans-unit>
        <trans-unit id="9a821a67cbe42a25dc97be41d2bf278fa2b3f8d9" translate="yes" xml:space="preserve">
          <source>Interface for an infinite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;E&lt;/code&gt; 的无限随机访问范围的接口。</target>
        </trans-unit>
        <trans-unit id="c9d0cf57e850156d9f049479c7169bad62b9af52" translate="yes" xml:space="preserve">
          <source>Interface for an output range of type &lt;code&gt;E&lt;/code&gt;. Usage is similar to the &lt;code&gt;InputRange&lt;/code&gt; interface and descendants.</source>
          <target state="translated">类型为 &lt;code&gt;E&lt;/code&gt; 的输出范围的接口。用法类似于 &lt;code&gt;InputRange&lt;/code&gt; 接口及其后代。</target>
        </trans-unit>
        <trans-unit id="9460943add2d33f93432076ae984835cefe527f7" translate="yes" xml:space="preserve">
          <source>Interface for diagnostic reporting.</source>
          <target state="translated">诊断报告的接口。</target>
        </trans-unit>
        <trans-unit id="3a1df4ab19b1c423cdf62882763fa74c4af37e82" translate="yes" xml:space="preserve">
          <source>Interface member functions can have contracts even though there is no body for the function. The contracts are inherited by any class member function that implements that interface member function.</source>
          <target state="translated">接口成员函数即使没有函数主体,也可以有合同。这些合同被任何实现该接口成员函数的类成员函数继承。</target>
        </trans-unit>
        <trans-unit id="f3be3896196c198c957ce4d700b0918b399182de" translate="yes" xml:space="preserve">
          <source>Interface to C++</source>
          <target state="translated">与C++的接口</target>
        </trans-unit>
        <trans-unit id="d7b35a8578bedf4b2033b8a1d3efb36b51c26426" translate="yes" xml:space="preserve">
          <source>Interface to ODBC C library.</source>
          <target state="translated">ODBC C库的接口。</target>
        </trans-unit>
        <trans-unit id="621522c8d929097b62eb853aff27378218dcc932" translate="yes" xml:space="preserve">
          <source>Interface to OS-specific allocators that support specifying alignment: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt;&lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt;&lt;code&gt;__aligned_xxx&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">与支持指定对齐方式的特定于操作系统的分配器的接口：Posix 上的&lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt;和Windows 上的&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_xxx&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da8580df0429b0473e5e3791367530334b73829e" translate="yes" xml:space="preserve">
          <source>Interface to SQLite C library.</source>
          <target state="translated">SQLite C库的接口。</target>
        </trans-unit>
        <trans-unit id="7de306419630810feb8071066cf5e31bb55e01fb" translate="yes" xml:space="preserve">
          <source>Interface to libcurl C library.</source>
          <target state="translated">libcurl C库的接口。</target>
        </trans-unit>
        <trans-unit id="f42fa13806030306bbca72d2c1d02ced3c60299a" translate="yes" xml:space="preserve">
          <source>Interface to the C linked list type.</source>
          <target state="translated">C链接列表类型的接口。</target>
        </trans-unit>
        <trans-unit id="e3744c2b6a83f2ded743b60e48109853d6af0029" translate="yes" xml:space="preserve">
          <source>Interface to zlib C library.</source>
          <target state="translated">zlib C库的接口。</target>
        </trans-unit>
        <trans-unit id="0e4b1bcf55c79cee225ecf64df995188b37f85a9" translate="yes" xml:space="preserve">
          <source>Interface[] &lt;strong id=&quot;interfaces&quot;&gt;interfaces&lt;/strong&gt;;</source>
          <target state="translated">Interface [] &lt;strong id=&quot;interfaces&quot;&gt;接口&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="87ef706c8b2c0856ee57ff234b67b63ee3440c74" translate="yes" xml:space="preserve">
          <source>Interfaces can be inherited and functions overridden:</source>
          <target state="translated">接口可以被继承,功能可以被重写。</target>
        </trans-unit>
        <trans-unit id="5c38dbc7db84c5be19893f9ea37a5e4e03b244d7" translate="yes" xml:space="preserve">
          <source>Interfaces can be reimplemented in derived classes:</source>
          <target state="translated">接口可以在派生类中重新实现。</target>
        </trans-unit>
        <trans-unit id="5c369ab8b0d4a9f58e24c8d22b04e27527c78058" translate="yes" xml:space="preserve">
          <source>Interfaces can have function templates in the members. All instantiated functions are implicitly &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">接口的成员中可以具有功能模板。所有实例化的函数都是隐式 &lt;code&gt;final&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdf123e52e487e317a85601aa2c062c8ae21bd83" translate="yes" xml:space="preserve">
          <source>Interfaces cannot derive from classes; only from other interfaces. Classes cannot derive from an interface multiple times.</source>
          <target state="translated">接口不能从类派生,只能从其他接口派生。类不能多次从一个接口派生。</target>
        </trans-unit>
        <trans-unit id="233b20e42a18eec431d3cd18cbd18fa45bf5e124" translate="yes" xml:space="preserve">
          <source>Interfaces describe a list of functions that a class that inherits from the interface must implement. A class that implements an interface can be converted to a reference to that interface.</source>
          <target state="translated">接口描述了继承自接口的类必须实现的功能列表。实现接口的类可以转换为对该接口的引用。</target>
        </trans-unit>
        <trans-unit id="c99b66b1687d267b80c156d483b9207e87aa2612" translate="yes" xml:space="preserve">
          <source>Interfaces to extend FTS5.</source>
          <target state="translated">扩展FTS5的接口。</target>
        </trans-unit>
        <trans-unit id="737865cc9d40029ada2522214f2743a9901cb1cf" translate="yes" xml:space="preserve">
          <source>Interfaces with Contracts</source>
          <target state="translated">与合同的接口</target>
        </trans-unit>
        <trans-unit id="772a604c8c3d9a084a30e26beb308940804e19fb" translate="yes" xml:space="preserve">
          <source>Interfacing Garbage Collected Objects With Foreign Code</source>
          <target state="translated">将垃圾收集的对象与外部代码对接。</target>
        </trans-unit>
        <trans-unit id="acbc7801b292b22fd84bb969c2c0f9ee879becf9" translate="yes" xml:space="preserve">
          <source>Interfacing to C</source>
          <target state="translated">与C的接口</target>
        </trans-unit>
        <trans-unit id="00b1220db63301a90c567b7096023b21f5a7b981" translate="yes" xml:space="preserve">
          <source>Interfacing to C++</source>
          <target state="translated">与C++的接口</target>
        </trans-unit>
        <trans-unit id="3f32265411f24516436989da79a8b9c2fd589ebb" translate="yes" xml:space="preserve">
          <source>Interfacing to Objective-C</source>
          <target state="translated">与Objective-C的接口</target>
        </trans-unit>
        <trans-unit id="e66a4ffa477a1f7eb282b4a707de158b622e6eab" translate="yes" xml:space="preserve">
          <source>Interfacing with C++</source>
          <target state="translated">与C++的接口</target>
        </trans-unit>
        <trans-unit id="bbe037479f31c550dbeec51a4592f398993011e6" translate="yes" xml:space="preserve">
          <source>Internal attributes. Bit 1 is set, if the member is apparently in binary format and bit 2 is set, if each record is preceded by the length of the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d3004e718ad2e15676793a202fef50196ce165" translate="yes" xml:space="preserve">
          <source>Internal logic error in SQLite</source>
          <target state="translated">SQLite中的内部逻辑错误</target>
        </trans-unit>
        <trans-unit id="d5242b6068ce3aa3e94925e147e46c817b1e87d1" translate="yes" xml:space="preserve">
          <source>Internal use only</source>
          <target state="translated">仅供内部使用</target>
        </trans-unit>
        <trans-unit id="dcfe56ee50b5246e8fc3d1efd71bcc80c9c2cbd3" translate="yes" xml:space="preserve">
          <source>International Domain Names support</source>
          <target state="translated">国际域名支持</target>
        </trans-unit>
        <trans-unit id="1c9eb8fe39b663da62bd55d532bbc1d6dc4480d5" translate="yes" xml:space="preserve">
          <source>Internet Control Message Protocol</source>
          <target state="translated">互联网控制信息协议</target>
        </trans-unit>
        <trans-unit id="4f4f826bb57cdd671bbd6bb81ae23885f0d13165" translate="yes" xml:space="preserve">
          <source>Internet Control Message Protocol level</source>
          <target state="translated">互联网控制信息协议级别</target>
        </trans-unit>
        <trans-unit id="1eadf3559d5760f57d825a20ef7a765cc6fff6a8" translate="yes" xml:space="preserve">
          <source>Internet Group Management Protocol</source>
          <target state="translated">互联网组管理协议</target>
        </trans-unit>
        <trans-unit id="486a00bfbd24a5012797e69fc29110b48c224e56" translate="yes" xml:space="preserve">
          <source>Internet Group Management Protocol level</source>
          <target state="translated">互联网小组管理协议级别</target>
        </trans-unit>
        <trans-unit id="ccfc6a40d215b229ecf5eb8e225cff288aef8d60" translate="yes" xml:space="preserve">
          <source>Internet Protocol version 4</source>
          <target state="translated">第四版互联网协议</target>
        </trans-unit>
        <trans-unit id="8f31285e4d3c0d1160715ca496686f163954b9a4" translate="yes" xml:space="preserve">
          <source>Internet Protocol version 4 level</source>
          <target state="translated">因特网协议第4版</target>
        </trans-unit>
        <trans-unit id="8b3f601b89a80177e18ecc46b747bb6d436f1059" translate="yes" xml:space="preserve">
          <source>Internet Protocol version 6</source>
          <target state="translated">互联网协议第六版</target>
        </trans-unit>
        <trans-unit id="a1072e310be98411b8cd11656cb7bff695706b85" translate="yes" xml:space="preserve">
          <source>Internet Protocol version 6 level</source>
          <target state="translated">互联网协议第6版</target>
        </trans-unit>
        <trans-unit id="93cc60f22833d45c27c517bcc4c0654c96515575" translate="yes" xml:space="preserve">
          <source>Interprets variadic argument list &lt;code&gt;args&lt;/code&gt;, formats them according to &lt;code&gt;fmt&lt;/code&gt;, and sends the resulting characters to &lt;code&gt;w&lt;/code&gt;. The encoding of the output is the same as &lt;code&gt;Char&lt;/code&gt;. The type &lt;code&gt;Writer&lt;/code&gt; must satisfy &lt;code&gt;&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;std.range.primitives.isOutputRange&lt;/a&gt;!(Writer, Char)&lt;/code&gt;.</source>
          <target state="translated">解释可变参数列表 &lt;code&gt;args&lt;/code&gt; ，根据 &lt;code&gt;fmt&lt;/code&gt; 格式化它们，并将结果字符发送到 &lt;code&gt;w&lt;/code&gt; 。输出的编码与 &lt;code&gt;Char&lt;/code&gt; 相同。 &lt;code&gt;Writer&lt;/code&gt; 类型必须满足 &lt;code&gt;&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;std.range.primitives.isOutputRange&lt;/a&gt;!(Writer, Char)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">中断一个长期运行的查询</target>
        </trans-unit>
        <trans-unit id="3d60c3309aeba9fb9a2d2efeac2160bd862157e8" translate="yes" xml:space="preserve">
          <source>Interval &lt;code&gt;interval&lt;/code&gt;</source>
          <target state="translated">间隔 &lt;code&gt;interval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6fe01334021f703c84b5da0607e6be23e76dade" translate="yes" xml:space="preserve">
          <source>Interval &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">间隔 &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b5f0564cad1e60053ec849638012d9696df2ed9" translate="yes" xml:space="preserve">
          <source>Interval option specifier for &lt;code&gt;until&lt;/code&gt; (below) and others.</source>
          <target state="translated">&lt;code&gt;until&lt;/code&gt; （以下）和其他的间隔选项说明符。</target>
        </trans-unit>
        <trans-unit id="52111c85baee81db8b2b3521d90bcf690e303a6e" translate="yes" xml:space="preserve">
          <source>Interval!TP &lt;code&gt;interval&lt;/code&gt;</source>
          <target state="translated">间隔！TP &lt;code&gt;interval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b37eedf146eb2ebd5bc1c25708b31f56d1fc371d" translate="yes" xml:space="preserve">
          <source>IntervalRange &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">IntervalRange &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="607b0ac46a2df5a924b307d562abd8e57ec9ce2f" translate="yes" xml:space="preserve">
          <source>Intervals and Ranges of Time</source>
          <target state="translated">时间的间隔和范围</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1fb7463147331b617ca5303fd1b3438ad66cc4fc" translate="yes" xml:space="preserve">
          <source>Introduction to std.datetime</source>
          <target state="translated">std.datetime介绍</target>
        </trans-unit>
        <trans-unit id="b3b4d20d3dfe4ef78d0bf43a93aa7f57bae176c5" translate="yes" xml:space="preserve">
          <source>Introspection</source>
          <target state="translated">Introspection</target>
        </trans-unit>
        <trans-unit id="a20a3e7ab504a9565c6aedca53d4fdbe5513a566" translate="yes" xml:space="preserve">
          <source>Invalid State</source>
          <target state="translated">无效状态</target>
        </trans-unit>
        <trans-unit id="a1bff97e3a0d9f8589413296b0f1e0569f71930c" translate="yes" xml:space="preserve">
          <source>Invalid file name.</source>
          <target state="translated">无效的文件名。</target>
        </trans-unit>
        <trans-unit id="a6eb263d63885ee3d552ee7aff55324ad0e9ead4" translate="yes" xml:space="preserve">
          <source>Invalidates when this Grapheme leaves the scope, attempts to use it then would lead to memory corruption.</source>
          <target state="translated">当该Grapheme离开作用域时无效,试图使用它将导致内存损坏。</target>
        </trans-unit>
        <trans-unit id="3c6f0311284e9216efb54d8e9865ea4fdb6fb5cc" translate="yes" xml:space="preserve">
          <source>Invariant blocks should contain &lt;code&gt;assert&lt;/code&gt; expressions, and should throw &lt;code&gt;AssertError&lt;/code&gt;s when they fail. Since DMD version 2.081.0, invariants can also be written as expression statements, with &lt;code&gt;assert&lt;/code&gt; implied:</source>
          <target state="translated">不变块应包含 &lt;code&gt;assert&lt;/code&gt; 表达式，并在失败时抛出 &lt;code&gt;AssertError&lt;/code&gt; 。从DMD 2.081.0版开始，不变量也可以写为表达式语句，并带有 &lt;code&gt;assert&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1601557f501dcc1665159d7c25e7f800b4c4d376" translate="yes" xml:space="preserve">
          <source>Invariant checks.</source>
          <target state="translated">不变的检查。</target>
        </trans-unit>
        <trans-unit id="3390616cafac7ff314d6aadaf20e48034cbb3314" translate="yes" xml:space="preserve">
          <source>Invariants</source>
          <target state="translated">Invariants</target>
        </trans-unit>
        <trans-unit id="aaafc5af09fec54c46e5ca35204284fae32a4ed8" translate="yes" xml:space="preserve">
          <source>Invariants are implicitly &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">不变式是隐式 &lt;code&gt;const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="552014b091503ffa5bb90ba68ad234e50e75c24c" translate="yes" xml:space="preserve">
          <source>Invariants are used to specify characteristics of a class or struct that must always be true (except while executing a member function). For example, a class representing a date might have an invariant that the day must be 1..31 and the hour must be 0..23:</source>
          <target state="translated">不变量用于指定一个类或结构的特性,这些特性必须始终为真(除了执行成员函数时)。例如,一个表示日期的类可能有一个不变式,即日期必须是1...31,小时必须是0...23。</target>
        </trans-unit>
        <trans-unit id="4d6016fe71d03226948598f177a7e24383a6ccfb" translate="yes" xml:space="preserve">
          <source>Inverse FFT that allows a user-supplied buffer to be provided. The buffer must be a random access range with slicing, and its elements must be some complex-like type.</source>
          <target state="translated">反向FFT,允许提供用户提供的缓冲区。缓冲区必须是带有分片的随机访问范围,其元素必须是一些类似于复数的类型。</target>
        </trans-unit>
        <trans-unit id="8f589f4c2f971c6116b057e5c215d537ca7cb43e" translate="yes" xml:space="preserve">
          <source>Inverse of Normal distribution function</source>
          <target state="translated">正态分布函数的倒数</target>
        </trans-unit>
        <trans-unit id="eef79ffda3ceb35fae03bd8ea406fdd1ab0607fb" translate="yes" xml:space="preserve">
          <source>Inverse of Standard normal distribution function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03358c4f54ce52294e142183e933b46fcb8b9f4" translate="yes" xml:space="preserve">
          <source>Inverse of complemented incomplete gamma integral</source>
          <target state="translated">补全不完全伽马积分的倒数。</target>
        </trans-unit>
        <trans-unit id="9bc72f0d8f316fcee653be902a9618f6a8a72f2c" translate="yes" xml:space="preserve">
          <source>Inverse of incomplete beta integral</source>
          <target state="translated">不完全β积分的倒数</target>
        </trans-unit>
        <trans-unit id="5f54f70c78f3db6ca340241c50fe53fee043bc4b" translate="yes" xml:space="preserve">
          <source>Inverse of the Log Minus Digamma function</source>
          <target state="translated">对数减去Digamma函数的反演。</target>
        </trans-unit>
        <trans-unit id="8f85e13b0d42fd1b4a5a865686a2d49695460bb5" translate="yes" xml:space="preserve">
          <source>Invoking the program with &quot;--output=myfile.txt --output=yourfile.txt&quot; or &quot;--output myfile.txt --output yourfile.txt&quot; will set &lt;code&gt;outputFiles&lt;/code&gt; to &lt;code&gt;[ &quot;myfile.txt&quot;, &quot;yourfile.txt&quot; ]&lt;/code&gt;.  Alternatively you can set &lt;a href=&quot;#arraySep&quot;&gt;&lt;code&gt;arraySep&lt;/code&gt;&lt;/a&gt; as the element separator:</source>
          <target state="translated">使用&amp;ldquo; --output = myfile.txt --output = yourfile.txt&amp;rdquo;或&amp;ldquo; --output myfile.txt --output yourfile.txt&amp;rdquo;调用程序会将 &lt;code&gt;outputFiles&lt;/code&gt; 设置为 &lt;code&gt;[ &quot;myfile.txt&quot;, &quot;yourfile.txt&quot; ]&lt;/code&gt; 。另外，您可以将&lt;a href=&quot;#arraySep&quot;&gt; &lt;code&gt;arraySep&lt;/code&gt; &lt;/a&gt;设置为元素分隔符：</target>
        </trans-unit>
        <trans-unit id="046f12a723835d1e4a1306bab5174447eb70771f" translate="yes" xml:space="preserve">
          <source>Invoking the program with &quot;--output=myfile.txt --output=yourfile.txt&quot; or &quot;--output myfile.txt --output yourfile.txt&quot; will set &lt;code&gt;outputFiles&lt;/code&gt; to &lt;code&gt;[ &quot;myfile.txt&quot;, &quot;yourfile.txt&quot; ]&lt;/code&gt;.  Alternatively you can set &lt;a href=&quot;#arraySep&quot;&gt;&lt;code&gt;arraySep&lt;/code&gt;&lt;/a&gt; to allow multiple elements in one parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d20fac3714b4db9127e8efa778c74b54cd4e0b" translate="yes" xml:space="preserve">
          <source>Invoking the program with &quot;--output=myfile.txt&quot; or &quot;--output myfile.txt&quot; will set &lt;code&gt;outputFile&lt;/code&gt; to &quot;myfile.txt&quot;. If you want to pass a string containing spaces, you need to use the quoting that is appropriate to your shell, e.g. --output='my file.txt'.</source>
          <target state="translated">使用&amp;ldquo; --output = myfile.txt&amp;rdquo;或&amp;ldquo; --output myfile.txt&amp;rdquo;调用程序会将 &lt;code&gt;outputFile&lt;/code&gt; 设置为&amp;ldquo; myfile.txt&amp;rdquo;。如果要传递包含空格的字符串，则需要使用适合您的shell的引号，例如--output ='my file.txt'。</target>
        </trans-unit>
        <trans-unit id="93d64dcdad645b5a71f4e6d58798c14d358623b2" translate="yes" xml:space="preserve">
          <source>Invoking the program with &quot;--paranoid --paranoid --paranoid&quot; will set &lt;code&gt; paranoid&lt;/code&gt; to 3. Note that an incremental option never expects a parameter, e.g., in the command line &quot;--paranoid 42 --paranoid&quot;, the &quot;42&quot; does not set &lt;code&gt;paranoid&lt;/code&gt; to 42; instead, &lt;code&gt;paranoid&lt;/code&gt; is set to 2 and &quot;42&quot; is not considered as part of the normal program arguments.</source>
          <target state="translated">使用&amp;ldquo; --paranoid --paranoid --paranoid&amp;rdquo;调用程序会将 &lt;code&gt; paranoid&lt;/code&gt; 设置为3。请注意，增量选项从不期望参数，例如，在命令行&amp;ldquo; --paranoid 42 --paranoid&amp;rdquo;中，&amp;ldquo; 42&amp;rdquo; &amp;ldquo;不会将 &lt;code&gt;paranoid&lt;/code&gt; 设置为42；取而代之的是， &lt;code&gt;paranoid&lt;/code&gt; 设置为2，并且&amp;ldquo; 42&amp;rdquo;不被视为普通程序参数的一部分。</target>
        </trans-unit>
        <trans-unit id="8b6eaac5b877b952f6bcf72430619aedf647b1a8" translate="yes" xml:space="preserve">
          <source>Invoking the program with e.g. &quot;--tune=alpha=0.5 --tune beta=0.6&quot; will set &lt;code&gt;tuningParms&lt;/code&gt; to [ &quot;alpha&quot; : 0.5, &quot;beta&quot; : 0.6 ].  Alternatively you can set &lt;a href=&quot;#arraySep&quot;&gt;&lt;code&gt;arraySep&lt;/code&gt;&lt;/a&gt; as the element separator:</source>
          <target state="translated">以&amp;ldquo; --tune = alpha = 0.5 --tune beta = 0.6&amp;rdquo;调用程序会将 &lt;code&gt;tuningParms&lt;/code&gt; 设置为[&amp;ldquo; alpha&amp;rdquo;：0.5，&amp;ldquo; beta&amp;rdquo;：0.6]。另外，您可以将&lt;a href=&quot;#arraySep&quot;&gt; &lt;code&gt;arraySep&lt;/code&gt; &lt;/a&gt;设置为元素分隔符：</target>
        </trans-unit>
        <trans-unit id="a51b807dff53b59ce17fa8ba3b4efb7c37298356" translate="yes" xml:space="preserve">
          <source>Is 'this' a pointer to a static array holding two contexts.</source>
          <target state="translated">'this'是一个指针,指向一个静态数组,里面有两个上下文。</target>
        </trans-unit>
        <trans-unit id="d4f04607ce8bc35a535f2eafaf232f2ae5e08636" translate="yes" xml:space="preserve">
          <source>Is 3DNow prefetch supported?</source>
          <target state="translated">是否支持3DNow预取?</target>
        </trans-unit>
        <trans-unit id="c1091b8fd8404cafbdd2e1da298b3c08898531c9" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;From&lt;/code&gt; implicitly convertible to &lt;code&gt;To&lt;/code&gt;?</source>
          <target state="translated">是 &lt;code&gt;From&lt;/code&gt; 隐式转换为 &lt;code&gt;To&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="6527c515f699697a6d232a689619fd938ee60f0e" translate="yes" xml:space="preserve">
          <source>Is AES supported</source>
          <target state="translated">是否支持AES</target>
        </trans-unit>
        <trans-unit id="a8cd9e904825556bf96828e0f6d502417a5ff971" translate="yes" xml:space="preserve">
          <source>Is AMD 3DNOW Ext supported?</source>
          <target state="translated">是否支持AMD 3DNOW Ext?</target>
        </trans-unit>
        <trans-unit id="cefb7da98db99e806ecf4f9d16aa97f479cb52ce" translate="yes" xml:space="preserve">
          <source>Is AMD 3DNOW supported?</source>
          <target state="translated">是否支持AMD 3DNOW?</target>
        </trans-unit>
        <trans-unit id="3467fc8e189fda3cf33326fc0d09e8bdf079f9fb" translate="yes" xml:space="preserve">
          <source>Is AVX supported</source>
          <target state="translated">是否支持AVX</target>
        </trans-unit>
        <trans-unit id="780bb1bc188e3b5539f81c0d650a1e7ddcd84502" translate="yes" xml:space="preserve">
          <source>Is AVX2 supported</source>
          <target state="translated">是否支持AVX2</target>
        </trans-unit>
        <trans-unit id="930e8f6c9f8db481832b42bf5d22e519ab0e0ba7" translate="yes" xml:space="preserve">
          <source>Is Dsymbol a variable that contains pointers?</source>
          <target state="translated">Dsymbol是一个包含指针的变量吗?</target>
        </trans-unit>
        <trans-unit id="f393ec53178029468d90ccfedc6fdafe870ef6c6" translate="yes" xml:space="preserve">
          <source>Is FMA supported</source>
          <target state="translated">是否支持金融市场管理局</target>
        </trans-unit>
        <trans-unit id="926d3c2bb40647642867740cf289a55c2684c607" translate="yes" xml:space="preserve">
          <source>Is FP16C supported</source>
          <target state="translated">是否支持FP16C</target>
        </trans-unit>
        <trans-unit id="a75e00d20bd98c427350c031bd2576f677c9bc19" translate="yes" xml:space="preserve">
          <source>Is HLE (hardware lock elision) supported</source>
          <target state="translated">是否支持HLE(硬件锁定删除)?</target>
        </trans-unit>
        <trans-unit id="5c63067c0b3183b5f4abc564381bb25d3d1231a7" translate="yes" xml:space="preserve">
          <source>Is LZCNT supported?</source>
          <target state="translated">是否支持LZCNT?</target>
        </trans-unit>
        <trans-unit id="80343d68528e1f0d53f3a2e549cd71634470e6e5" translate="yes" xml:space="preserve">
          <source>Is MMX supported?</source>
          <target state="translated">是否支持MMX?</target>
        </trans-unit>
        <trans-unit id="114c091c0c22495cd9a32fec40491702ce24f441" translate="yes" xml:space="preserve">
          <source>Is POPCNT supported?</source>
          <target state="translated">是否支持POPCNT?</target>
        </trans-unit>
        <trans-unit id="092c9f81639a5605a53fbcf69c7be6aa88dbd446" translate="yes" xml:space="preserve">
          <source>Is RTM (restricted transactional memory) supported</source>
          <target state="translated">是否支持RTM(受限事务性内存)?</target>
        </trans-unit>
        <trans-unit id="24109cfc7f69bcaf97712b43c58ddf2b22ea3c9a" translate="yes" xml:space="preserve">
          <source>Is SHA supported</source>
          <target state="translated">是否支持SHA</target>
        </trans-unit>
        <trans-unit id="3511bb1b8685cb3d3a378cd1f674c89a05416048" translate="yes" xml:space="preserve">
          <source>Is SSE supported?</source>
          <target state="translated">是否支持SSE?</target>
        </trans-unit>
        <trans-unit id="d33bcfafec9efc7ddbbfe4306ce2e227725bf3cf" translate="yes" xml:space="preserve">
          <source>Is SSE2 supported?</source>
          <target state="translated">是否支持SSE2?</target>
        </trans-unit>
        <trans-unit id="2b949ad5258cac339f8f205f2bc83cc9e9a30c77" translate="yes" xml:space="preserve">
          <source>Is SSE3 supported?</source>
          <target state="translated">是否支持SSE3?</target>
        </trans-unit>
        <trans-unit id="56ee911e8f809a3ad52a479f6bd11d4cb88c2a3b" translate="yes" xml:space="preserve">
          <source>Is SSE4.1 supported?</source>
          <target state="translated">是否支持SSE4.1?</target>
        </trans-unit>
        <trans-unit id="799b3ec53e6f94a6529a4281676d281ef3e42b2d" translate="yes" xml:space="preserve">
          <source>Is SSE4.2 supported?</source>
          <target state="translated">是否支持SSE4.2?</target>
        </trans-unit>
        <trans-unit id="a2be34e3269af3486a23b7806de85c13596ee981" translate="yes" xml:space="preserve">
          <source>Is SSE4a supported?</source>
          <target state="translated">是否支持SSE4a?</target>
        </trans-unit>
        <trans-unit id="529c14236ce5d57c81f18ee3d3a4955d0294b830" translate="yes" xml:space="preserve">
          <source>Is SSSE3 supported?</source>
          <target state="translated">是否支持SSSE3?</target>
        </trans-unit>
        <trans-unit id="404210ae982e5f7c6d767bb288604a99c837412d" translate="yes" xml:space="preserve">
          <source>Is SYSENTER/SYSEXIT supported?</source>
          <target state="translated">是否支持SYSENTER/SYSEXIT?</target>
        </trans-unit>
        <trans-unit id="450d6103658425cd9504ee4df7c88ea3022b9390" translate="yes" xml:space="preserve">
          <source>Is VEX-Encoded AES supported</source>
          <target state="translated">是否支持VEX-编码AES</target>
        </trans-unit>
        <trans-unit id="090d249f369062f8bff47b9ddec54f12692fd4a6" translate="yes" xml:space="preserve">
          <source>Is cmov supported?</source>
          <target state="translated">是否支持cmov?</target>
        </trans-unit>
        <trans-unit id="4682b61ccc8c6c8dc42bb1758c22ede1faa7aa70" translate="yes" xml:space="preserve">
          <source>Is cmpxchg8b supported?</source>
          <target state="translated">是否支持cmpxchg8b?</target>
        </trans-unit>
        <trans-unit id="4c79a0ed65f9de836b7df77c8ebe47ee651df5f2" translate="yes" xml:space="preserve">
          <source>Is fxsave/fxrstor supported?</source>
          <target state="translated">是否支持fxsave/fxrstor?</target>
        </trans-unit>
        <trans-unit id="10bf6a2965400ad25296374bbb8440c96335239a" translate="yes" xml:space="preserve">
          <source>Is hyperthreading supported?</source>
          <target state="translated">是否支持超线程?</target>
        </trans-unit>
        <trans-unit id="a5f2a790fe86ca51a7f46c97943c8a348c7f5979" translate="yes" xml:space="preserve">
          <source>Is pclmulqdq supported</source>
          <target state="translated">是否支持pclmulqdq</target>
        </trans-unit>
        <trans-unit id="2a6a47b81fa80057015751ef0056cd96c0603472" translate="yes" xml:space="preserve">
          <source>Is rdrand supported</source>
          <target state="translated">是否支持rdrand</target>
        </trans-unit>
        <trans-unit id="6f50c3df0513611496a720e7e34cdb66b04a1e3a" translate="yes" xml:space="preserve">
          <source>Is rdseed supported</source>
          <target state="translated">是否支持rdseed</target>
        </trans-unit>
        <trans-unit id="1b5795edb49e0d328ee0397e5dce20a3f8b369c8" translate="yes" xml:space="preserve">
          <source>Is rdtsc supported?</source>
          <target state="translated">是否支持rdtsc?</target>
        </trans-unit>
        <trans-unit id="dfd22e079be218467567ed6e211af022226073d8" translate="yes" xml:space="preserve">
          <source>Is the binary representation of x identical to y?</source>
          <target state="translated">x的二进制表示是否与y相同?</target>
        </trans-unit>
        <trans-unit id="a87a317711c3473ef594a6e7226a2007eeb63603" translate="yes" xml:space="preserve">
          <source>Is this Object an error?</source>
          <target state="translated">这个对象是个错误吗?</target>
        </trans-unit>
        <trans-unit id="c56d42e2850dbb730db38fb3fb842af85b06b699" translate="yes" xml:space="preserve">
          <source>Is this an IA64 (Itanium) processor?</source>
          <target state="translated">这是IA64(Itanium)处理器吗?</target>
        </trans-unit>
        <trans-unit id="590cbb39e0a9b8c9390941a2aa58bbc453391eef" translate="yes" xml:space="preserve">
          <source>Is this an Intel64 or AMD 64?</source>
          <target state="translated">这是Intel64还是AMD64?</target>
        </trans-unit>
        <trans-unit id="d0d49c2fad2d9f63ec74430d77ec2053e17a49b3" translate="yes" xml:space="preserve">
          <source>Is vpclmulqdq supported</source>
          <target state="translated">是否支持vpclmulqdq?</target>
        </trans-unit>
        <trans-unit id="08035875f56e0a7aaa6e8c7ee6e9504e25d6cf00" translate="yes" xml:space="preserve">
          <source>IsExpression</source>
          <target state="translated">IsExpression</target>
        </trans-unit>
        <trans-unit id="eee32f816f5a7cde2bef5f55991e6f12cf112eeb" translate="yes" xml:space="preserve">
          <source>IsExpression can evaluate the specified type speculatively, and even if it instantiates any symbols, they are normally unnecessary for the final executable. However, if those symbols leak to the actual code, compiler should remark them as non-speculative to generate their code and link to the final executable.</source>
          <target state="translated">IsExpression可以推测性地评估指定的类型,即使它实例化了任何符号,这些符号对于最终的可执行文件来说通常是不必要的。但是,如果这些符号泄漏到实际代码中,编译器应该将它们注释为非投机性的,以生成它们的代码并链接到最终的可执行文件。</target>
        </trans-unit>
        <trans-unit id="49ab23d851863d880110f3e4fecbd30226e2ce4e" translate="yes" xml:space="preserve">
          <source>IsMarkedDg &lt;code&gt;isMarked&lt;/code&gt;</source>
          <target state="translated">IsMarkedDg &lt;code&gt;isMarked&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb1dcbf5199bd4639373c8360fb756c6fa15a754" translate="yes" xml:space="preserve">
          <source>Issue an error if an attempt to call a disabled method is made</source>
          <target state="translated">如果试图调用一个被禁用的方法,会发出一个错误。</target>
        </trans-unit>
        <trans-unit id="4d017c10e9874a730f28063522651ca1ebea765b" translate="yes" xml:space="preserve">
          <source>Issuer certificate</source>
          <target state="translated">签发人证书</target>
        </trans-unit>
        <trans-unit id="4fe343344c692492a360f8a89fee5b22e51d1c7a" translate="yes" xml:space="preserve">
          <source>Issuing individual checked operations is flexible and efficient but often tedious. The &lt;a href=&quot;#Checked&quot;&gt;&lt;code&gt;Checked&lt;/code&gt;&lt;/a&gt; facility offers encapsulated integral wrappers that do all checking internally and have configurable behavior upon erroneous results. For example, &lt;code&gt;Checked!int&lt;/code&gt; is a type that behaves like &lt;code&gt;int&lt;/code&gt; but aborts execution immediately whenever involved in an operation that produces the arithmetically wrong result. The accompanying convenience function &lt;a href=&quot;#checked&quot;&gt;&lt;code&gt;checked&lt;/code&gt;&lt;/a&gt; uses type deduction to convert a value &lt;code&gt;x&lt;/code&gt; of integral type &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;Checked!T&lt;/code&gt; by means of &lt;code&gt;checked(x)&lt;/code&gt;. For example:</source>
          <target state="translated">发出单个已检查的操作既灵活又高效，但通常很乏味。在&lt;a href=&quot;#Checked&quot;&gt; &lt;code&gt;Checked&lt;/code&gt; &lt;/a&gt;工厂报价封装整体封装在内部完成所有检查，并有在错误的结果可配置的行为。例如， &lt;code&gt;Checked!int&lt;/code&gt; 是一种行为类似于 &lt;code&gt;int&lt;/code&gt; 的类型，但是每当涉及产生算术错误结果的操作时，其立即中止执行。随附的便捷功能&lt;a href=&quot;#checked&quot;&gt; &lt;code&gt;checked&lt;/code&gt; &lt;/a&gt;使用类型推导，通过 &lt;code&gt;checked(x)&lt;/code&gt; 将整数 &lt;code&gt;T&lt;/code&gt; 的值 &lt;code&gt;x&lt;/code&gt; 转换为 &lt;code&gt;Checked!T&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="b6e2e0208dac0f7f4751f05b1125349dc8d7c5b3" translate="yes" xml:space="preserve">
          <source>It advances the input to the position following the conversion.</source>
          <target state="translated">它将输入推进到转换后的位置。</target>
        </trans-unit>
        <trans-unit id="46166dd58ab2730e4524ad59d57d2593327727bb" translate="yes" xml:space="preserve">
          <source>It also provides a faster, low level API working with data of size &lt;code&gt;Element.sizeof&lt;/code&gt;:</source>
          <target state="translated">它还提供了一个更快的低级API，可处理 &lt;code&gt;Element.sizeof&lt;/code&gt; 大小的数据：</target>
        </trans-unit>
        <trans-unit id="6d3cceeb2328306e2f02f11a51f27695f47f4e9b" translate="yes" xml:space="preserve">
          <source>It also provides number of templates that test for various range capabilities:</source>
          <target state="translated">它还提供了许多测试各种范围能力的模板。</target>
        </trans-unit>
        <trans-unit id="5bbf72a08a99011dd111dd6ad452e903cd2d15d9" translate="yes" xml:space="preserve">
          <source>It also works with &lt;code&gt;@property&lt;/code&gt; functions:</source>
          <target state="translated">它也可以与 &lt;code&gt;@property&lt;/code&gt; 函数一起使用：</target>
        </trans-unit>
        <trans-unit id="388df630c47cc2e867f2d3350d1778d5f83b482f" translate="yes" xml:space="preserve">
          <source>It can be used to conditionally compile declarations, not just statements.</source>
          <target state="translated">它可以用来有条件地编译声明,而不仅仅是语句。</target>
        </trans-unit>
        <trans-unit id="0a01fcab203354384dc4d73ca3e1bd07777c3122" translate="yes" xml:space="preserve">
          <source>It can only be used once in a method declaration</source>
          <target state="translated">它在方法声明中只能使用一次。</target>
        </trans-unit>
        <trans-unit id="0dae2f02f995eb1175253988c98f27cbe75176d3" translate="yes" xml:space="preserve">
          <source>It cannot be attached to a method or constructor that is a template</source>
          <target state="translated">它不能被附加到作为模板的方法或构造函数上。</target>
        </trans-unit>
        <trans-unit id="0bbe25588da1b447488b6253a7ca8c0b345decd4" translate="yes" xml:space="preserve">
          <source>It cannot be the argument to &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不能说是&lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b94459fe2cd15aac6dbdf1ba866c322026a497f" translate="yes" xml:space="preserve">
          <source>It defines the bidirectional and forward range primitives for arrays: &lt;a href=&quot;#empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#front&quot;&gt;&lt;code&gt;front&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#back&quot;&gt;&lt;code&gt;back&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#popFront&quot;&gt;&lt;code&gt;popFront&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#popBack&quot;&gt;&lt;code&gt;popBack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它为数组定义了双向和正向范围原语：&lt;a href=&quot;#empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#front&quot;&gt; &lt;code&gt;front&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#back&quot;&gt; &lt;code&gt;back&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#popFront&quot;&gt; &lt;code&gt;popFront&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#popBack&quot;&gt; &lt;code&gt;popBack&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#save&quot;&gt; &lt;code&gt;save&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65ecf79245a02b6d2395f79fbb54723afe4759a9" translate="yes" xml:space="preserve">
          <source>It derives from the interface &lt;code&gt;core.stdc.windows.com.IUnknown&lt;/code&gt;.</source>
          <target state="translated">它源自 &lt;code&gt;core.stdc.windows.com.IUnknown&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="b7a236332866cc1e66837407aa52f7caefef2e68" translate="yes" xml:space="preserve">
          <source>It does keep: live connections, the Session ID cache, the DNS cache and the cookies.</source>
          <target state="translated">它确实保留了:实时连接,会话ID缓存,DNS缓存和cookies。</target>
        </trans-unit>
        <trans-unit id="ab575c8162460ca1f250ddf0805e589cdd4d4f98" translate="yes" xml:space="preserve">
          <source>It does not exhibit undefined behavior for any input. It returns either a valid pointer, which is safe, or &lt;code&gt;null&lt;/code&gt; which is also safe. It returns a pointer to a fresh allocation, so it cannot introduce any unsafe aliasing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4fef0b32a7281d59a31a40d6f87fe5bfa58814" translate="yes" xml:space="preserve">
          <source>It does not introduce a new scope even if &lt;code&gt;{ }&lt;/code&gt; are used for conditionally compiled statements.</source>
          <target state="translated">即使将 &lt;code&gt;{ }&lt;/code&gt; 用于有条件编译的语句，它也不会引入新的作用域。</target>
        </trans-unit>
        <trans-unit id="a5f6a69aa258b6687ed9d04070e059ea5562bf0a" translate="yes" xml:space="preserve">
          <source>It does not repeat information that the compiler already knows from parsing the code.</source>
          <target state="translated">它不会重复编译器从解析代码中已经知道的信息。</target>
        </trans-unit>
        <trans-unit id="7398e9c5d59f69e46f788c84807092237aa5e4d5" translate="yes" xml:space="preserve">
          <source>It does not throw if it could not convert the entire input.</source>
          <target state="translated">如果它不能转换整个输入,它不会抛出。</target>
        </trans-unit>
        <trans-unit id="2873a218fbe5af0054d62beddeb0e65fcfb61635" translate="yes" xml:space="preserve">
          <source>It doesn't rely on embedded HTML, as such will impede extraction and formatting for other purposes.</source>
          <target state="translated">它不依赖于嵌入的HTML,因此会阻碍其他目的的提取和格式化。</target>
        </trans-unit>
        <trans-unit id="a1aba479bf876b78d7763f04b36ad2a837b806ed" translate="yes" xml:space="preserve">
          <source>It eliminates the need for IDL (interface description language) as a separate language.</source>
          <target state="translated">它省去了IDL(接口描述语言)作为一种单独的语言。</target>
        </trans-unit>
        <trans-unit id="9be52d2dd0c55abff440ef5dc05f4f1413d2dc2c" translate="yes" xml:space="preserve">
          <source>It fits in EAX.</source>
          <target state="translated">它适合EAX。</target>
        </trans-unit>
        <trans-unit id="5c9e2828459632652d41e10b6eaced3e8290b5c9" translate="yes" xml:space="preserve">
          <source>It indicates if a statement does transfer control to another block. A block is a sequence of statements enclosed in { }</source>
          <target state="translated">它表示一条语句是否将控制权转移到另一个块。一个代码块是由{}括起来的一系列语句组成的。</target>
        </trans-unit>
        <trans-unit id="b4f712b66715ddaa764c3d26a22ac83adf4c4dc7" translate="yes" xml:space="preserve">
          <source>It is acceptable for an implementation to store bit flags into pointer values and GC-managed memory blocks, so long as such a trick is not visible to the application. In practice, this means that only a stop-the-world collector can do this.</source>
          <target state="translated">对于一个实现来说,将位标志存储到指针值和GC管理的内存块中是可以接受的,只要这样的技巧对应用程序来说是不可见的。在实践中,这意味着只有停止世界收集器才能这样做。</target>
        </trans-unit>
        <trans-unit id="6213c9975eabd46633dd5a1abb7787690a6d9654" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;override&lt;/code&gt; the three methods &lt;code&gt;beginLogMsg&lt;/code&gt;, &lt;code&gt;logMsgPart&lt;/code&gt; and &lt;code&gt;finishLogMsg&lt;/code&gt; together, this option gives more flexibility.</source>
          <target state="translated">也可以一起 &lt;code&gt;override&lt;/code&gt; &lt;code&gt;beginLogMsg&lt;/code&gt; ， &lt;code&gt;logMsgPart&lt;/code&gt; 和 &lt;code&gt;finishLogMsg&lt;/code&gt; 这三种方法，此选项提供了更大的灵活性。</target>
        </trans-unit>
        <trans-unit id="62c19d777ce9c9b0fe6e64b8266c59dbe78a3247" translate="yes" xml:space="preserve">
          <source>It is also possible to indirectly interface with C++ code, either through a &lt;a href=&quot;interfacetoc&quot;&gt;C interface&lt;/a&gt; or a COM interface.</source>
          <target state="translated">也可以通过&lt;a href=&quot;interfacetoc&quot;&gt;C接口&lt;/a&gt;或COM接口与C ++代码间接接口。</target>
        </trans-unit>
        <trans-unit id="d898d765860a5d45edda7c7ed8509568c1f68566" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; cannot be implicitly converted to a boolean type or if it cannot be evaluated at compile time.</source>
          <target state="translated">如果无法将&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;隐式转换为布尔类型，或者无法在编译时对其进行评估，则会出现错误。</target>
        </trans-unit>
        <trans-unit id="86e5855ead30ccc2c8c56869cbcf6e5f74be6875" translate="yes" xml:space="preserve">
          <source>It is an error if any</source>
          <target state="translated">如果有以下情况,则为错误</target>
        </trans-unit>
        <trans-unit id="a81c091005be4792f067f57e1989fc7c8d13b625" translate="yes" xml:space="preserve">
          <source>It is an error to compare objects if one is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;null&lt;/code&gt; 则比较对象是错误的。</target>
        </trans-unit>
        <trans-unit id="50b2fd8434663e2c4ccea539ac2a01804fab3bbd" translate="yes" xml:space="preserve">
          <source>It is an error to declare a local variable that hides another local variable in the same function:</source>
          <target state="translated">在同一个函数中声明一个局部变量隐藏另一个局部变量是一个错误。</target>
        </trans-unit>
        <trans-unit id="deced31ce7ffb700a549b08afe6a6138a69db040" translate="yes" xml:space="preserve">
          <source>It is an error to have a local variable and a label with the same name.</source>
          <target state="translated">如果一个局部变量和一个标签的名称相同,这是一个错误。</target>
        </trans-unit>
        <trans-unit id="b508914e98b3adb1d20ab50fa10434c25d029458" translate="yes" xml:space="preserve">
          <source>It is an error to have one operand be signed and the other unsigned for a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt; expression. Use casts to make both operands signed or both operands unsigned.</source>
          <target state="translated">为 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; 表达式对一个操作数进行签名而对另一个操作数进行无符号签名是错误的。使用强制转换使两个操作数都带符号或使两个操作数都无符号。</target>
        </trans-unit>
        <trans-unit id="f0e09315dbb83014f54364159107933f95171232" translate="yes" xml:space="preserve">
          <source>It is an error to index an array with an index that is less than 0 or greater than or equal to the array length. If an index is out of bounds, a RangeError exception is raised if detected at runtime, and an error if detected at compile time. A program may not rely on array bounds checking happening, for example, the following program is incorrect:</source>
          <target state="translated">如果一个数组的索引小于0或大于或等于数组的长度,则是一个错误。如果索引出界,如果在运行时检测到,会引发RangeError异常,如果在编译时检测到,会引发错误。一个程序可能不依赖于数组边界检查发生,例如,下面的程序是不正确的。</target>
        </trans-unit>
        <trans-unit id="f64a85acc1469fbd56318c719228c9c1fe16bf9c" translate="yes" xml:space="preserve">
          <source>It is an error to return the address of or a reference to a local variable.</source>
          <target state="translated">返回一个局部变量的地址或引用是错误的。</target>
        </trans-unit>
        <trans-unit id="b4576fb929afa6bbf00d340772ed152adcae3cb1" translate="yes" xml:space="preserve">
          <source>It is an error to use a local variable without first assigning it a value. The implementation may not always be able to detect these cases. Other language compilers sometimes issue a warning for this, but since it is always a bug, it should be an error.</source>
          <target state="translated">在没有给局部变量赋值的情况下使用局部变量是错误的。实现可能并不总是能够检测到这些情况。其他语言编译器有时会为此发出警告,但由于它总是一个错误,所以应该是一个错误。</target>
        </trans-unit>
        <trans-unit id="1caf8aa0590016aadf8cff449e680fd2d8713321" translate="yes" xml:space="preserve">
          <source>It is defined to be exactly the reverse order that static construction was performed in. Static destructors for individual modules will only be run if the corresponding static constructor successfully completed.</source>
          <target state="translated">它被定义为完全按照静态构造的相反顺序进行。只有当相应的静态构造函数成功完成时,各个模块的静态析构函数才会被运行。</target>
        </trans-unit>
        <trans-unit id="2c2f3bba7f5994912f6b95d05cb1814084516245" translate="yes" xml:space="preserve">
          <source>It is easy to make the error handling source code look good.</source>
          <target state="translated">很容易让错误处理的源码变得好看。</target>
        </trans-unit>
        <trans-unit id="d6ed05c87a248603343b54bb16aa1fab9bfe8f53" translate="yes" xml:space="preserve">
          <source>It is here to allow the deprecated behavior from the original algorithm until people have fixed their code.</source>
          <target state="translated">在这里,它是为了在人们修复他们的代码之前,允许原算法的废弃行为。</target>
        </trans-unit>
        <trans-unit id="401996678962e7e20129e6958a7d5a0d314109af" translate="yes" xml:space="preserve">
          <source>It is illegal for a</source>
          <target state="translated">以下行为是非法的:</target>
        </trans-unit>
        <trans-unit id="37d2d71b2b05147b31590276dc23d6c43bb3d76c" translate="yes" xml:space="preserve">
          <source>It is illegal for constructors to mutually call each other.</source>
          <target state="translated">构造者之间相互调用是违法的。</target>
        </trans-unit>
        <trans-unit id="2b7e7cafd673ed4d2e6ef523c1c9b32587567990" translate="yes" xml:space="preserve">
          <source>It is illegal to forward reference a debug specification:</source>
          <target state="translated">转发引用调试规范是非法的。</target>
        </trans-unit>
        <trans-unit id="f53c060570ada118f69ba3973c4ac1d18651ca16" translate="yes" xml:space="preserve">
          <source>It is illegal to refer to &lt;code&gt;this&lt;/code&gt; implicitly or explicitly prior to making a delegate constructor call.</source>
          <target state="translated">它是非法引用 &lt;code&gt;this&lt;/code&gt; 之前或明或暗地以做委托构造函数调用。</target>
        </trans-unit>
        <trans-unit id="c3a1d31a8a612fca4298b4ba24a642e4106f58bc" translate="yes" xml:space="preserve">
          <source>It is illegal to refer to &lt;code&gt;this&lt;/code&gt; implicitly or explicitly prior to making a delegating constructor call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c179728399bb4a33e4e07c739bc7e79b3958a176" translate="yes" xml:space="preserve">
          <source>It is implemented as a compiler intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335e107a42af5a98628c149f6e1b4ca0b49e01e5" translate="yes" xml:space="preserve">
          <source>It is important to make sure that, if &lt;code&gt;opApply&lt;/code&gt; catches any exceptions, that those exceptions did not originate from the delegate passed to</source>
          <target state="translated">重要的是，如果 &lt;code&gt;opApply&lt;/code&gt; 捕获到任何异常，请确保这些异常不是源自传递给的委托。</target>
        </trans-unit>
        <trans-unit id="79663ac4e329be90782f60edf1e6177dca459550" translate="yes" xml:space="preserve">
          <source>It is important to note that as the resultant range is evaluated lazily, in the case of the version of &lt;code&gt;tee&lt;/code&gt; that takes a function, the function will not actually be executed until the range is &quot;walked&quot; using functions that evaluate ranges, such as &lt;a href=&quot;std_array#array&quot;&gt;&lt;code&gt;std.array.array&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_algorithm_iteration#fold&quot;&gt;&lt;code&gt;std.algorithm.iteration.fold&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">重要的是要注意，由于对结果范围的计算是延迟的，因此在使用带有函数的 &lt;code&gt;tee&lt;/code&gt; 版本的情况下，直到使用计算范围的函数（例如&lt;a href=&quot;std_array#array&quot;&gt; &lt;code&gt;std.array.array&lt;/code&gt; &lt;/a&gt;）&amp;ldquo;遍历&amp;rdquo;范围时，该函数才会实际执行.array.array或&lt;a href=&quot;std_algorithm_iteration#fold&quot;&gt; &lt;code&gt;std.algorithm.iteration.fold&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd820e0e37cf31d63e1d31e908c7138e4dab72e2" translate="yes" xml:space="preserve">
          <source>It is important to use the right version identifier for the right purpose. For example, use the vendor identifier when using a vendor specific feature. Use the operating system identifier when using an operating system specific feature, etc.</source>
          <target state="translated">为正确的目的使用正确的版本标识符很重要。例如,在使用供应商的特定功能时,请使用供应商标识符。当使用操作系统的特定功能时,请使用操作系统标识符,等等。</target>
        </trans-unit>
        <trans-unit id="f2a8e8ef94cccc304c27c70467bf612cabf2c765" translate="yes" xml:space="preserve">
          <source>It is inevitable that the D language will evolve over time. Therefore, the version identifier namespace beginning with &quot;D_&quot; is reserved for identifiers indicating D language specification or new feature conformance. Further, all identifiers derived from the ones listed above by appending any character(s) are reserved. This means that e.g. &lt;code&gt;ARM_foo&lt;/code&gt; and &lt;code&gt;Windows_bar&lt;/code&gt; are reserved while &lt;code&gt;foo_ARM&lt;/code&gt; and &lt;code&gt;bar_Windows&lt;/code&gt; are not.</source>
          <target state="translated">D语言不可避免地会随着时间而发展。因此，以&amp;ldquo; D_&amp;rdquo;开头的版本标识符名称空间被保留用于表示D语言规范或新功能符合性的标识符。此外，保留通过附加任何字符从上面列出的标识符派生的所有标识符。这意味着，例如，保留了 &lt;code&gt;ARM_foo&lt;/code&gt; 和 &lt;code&gt;Windows_bar&lt;/code&gt; ，而没有保留 &lt;code&gt;foo_ARM&lt;/code&gt; 和 &lt;code&gt;bar_Windows&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87b18dd6b84ff4211bbe466a6c57cc9ae711b259" translate="yes" xml:space="preserve">
          <source>It is lowered to:</source>
          <target state="translated">它降低到。</target>
        </trans-unit>
        <trans-unit id="f91d0be00faa70d257f22e2edf4d36bee26e53e0" translate="yes" xml:space="preserve">
          <source>It is not a 3 byte struct.</source>
          <target state="translated">它不是一个3字节结构。</target>
        </trans-unit>
        <trans-unit id="168bb789a8929c7fb4c3b7215efb1856903be685" translate="yes" xml:space="preserve">
          <source>It is not a floating point type.</source>
          <target state="translated">它不是浮点类型。</target>
        </trans-unit>
        <trans-unit id="19fdb6fcd666a00fa90a8ed40bb00013c2391043" translate="yes" xml:space="preserve">
          <source>It is not always obvious when the GC allocates memory, which in turn can trigger a collection, so the program can pause unexpectedly.</source>
          <target state="translated">当GC分配内存时,并不总是很明显,这又会触发一个集合,所以程序会意外地暂停。</target>
        </trans-unit>
        <trans-unit id="7cac6b46e927506f607254cff1ed6929147fa588" translate="yes" xml:space="preserve">
          <source>It is not an error if the return type does not contain any indirections.</source>
          <target state="translated">如果返回类型不包含任何内径,则不属于错误。</target>
        </trans-unit>
        <trans-unit id="981cc7a3cecab94e0dd1f8ddc96a87527d95e530" translate="yes" xml:space="preserve">
          <source>It is not necessary to do this inside a code section, or if the special character is not immediately followed by a # or a letter.</source>
          <target state="translated">在代码段内,或者如果特殊字符后面没有紧跟#或字母,则没有必要这样做。</target>
        </trans-unit>
        <trans-unit id="6319193259ecd329b1ff6f0a8e1c2a9fd8f24dd7" translate="yes" xml:space="preserve">
          <source>It is not possible to have both &lt;code&gt;return ref&lt;/code&gt; and &lt;code&gt;return scope&lt;/code&gt; semantics for the same parameter.</source>
          <target state="translated">同一参数不能同时具有 &lt;code&gt;return ref&lt;/code&gt; 和 &lt;code&gt;return scope&lt;/code&gt; 语义。</target>
        </trans-unit>
        <trans-unit id="e23f668bad211d08e2c969e706fb24d5b0e785ca" translate="yes" xml:space="preserve">
          <source>It is not possible to rename a file across different mount points or drives. On POSIX, the operation is atomic. That means, if &lt;code&gt;to&lt;/code&gt; already exists there will be no time period during the operation where &lt;code&gt;to&lt;/code&gt; is missing. See &lt;a href=&quot;http://man7.org/linux/man-pages/man2/rename.2.html&quot;&gt;manpage for rename&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443f05c094b69d1507e35079eeb79f6782e9920f" translate="yes" xml:space="preserve">
          <source>It is often necessary to deprecate a feature in a library, yet retain it for backwards compatibility. Such declarations can be marked as &lt;code&gt;deprecated&lt;/code&gt;, which means that the compiler can be instructed to produce an error if any code refers to deprecated declarations:</source>
          <target state="translated">通常有必要在库中弃用某个功能，但为了向后兼容而保留该功能。这些声明可以标记为 &lt;code&gt;deprecated&lt;/code&gt; ，这意味着如果任何代码引用了不推荐使用的声明，则可以指示编译器产生错误：</target>
        </trans-unit>
        <trans-unit id="899360132ed9309c950103047c7e2c814b318ec0" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#byLine&quot;&gt;&lt;code&gt;byLine&lt;/code&gt;&lt;/a&gt; and uses &lt;a href=&quot;std_format#formattedRead&quot;&gt;format&lt;/a&gt; under the hood.</source>
          <target state="translated">它与&lt;a href=&quot;#byLine&quot;&gt; &lt;code&gt;byLine&lt;/code&gt; &lt;/a&gt;相似，并在内部使用&lt;a href=&quot;std_format#formattedRead&quot;&gt;格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="717aec823e7fb6c544e08d1714d73ef54e5ff0b7" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to get or set the 16 bytes of a UUID directly.</source>
          <target state="translated">有时直接获取或设置UUID的16个字节是很有用的。</target>
        </trans-unit>
        <trans-unit id="d9604c47d97361773acea3965fa6498d863d32be" translate="yes" xml:space="preserve">
          <source>It is standardized - consistent usage makes it more useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea1205f3456f768018243f6d5512a314f402d18" translate="yes" xml:space="preserve">
          <source>It is straightforward to link C functions and libraries into D programs. But linking D functions and libraries into C programs is not straightforward.</source>
          <target state="translated">将C函数和库链接到D程序中是很直接的。但是将D函数和库链接到C程序中就不简单了。</target>
        </trans-unit>
        <trans-unit id="700ae48bba8932b3ce97ed7ab816d7e993a4eec8" translate="yes" xml:space="preserve">
          <source>It is therefore recommended to always construct containers using &lt;a href=&quot;std_container_util#make&quot;&gt;&lt;code&gt;std.container.util.make&lt;/code&gt;&lt;/a&gt;.  This is in fact necessary to put containers into another container. For example, to construct an &lt;code&gt;Array&lt;/code&gt; of ten empty &lt;code&gt;Array&lt;/code&gt;s, use the following that calls &lt;code&gt;make&lt;/code&gt; ten times.</source>
          <target state="translated">因此，建议始终使用&lt;a href=&quot;std_container_util#make&quot;&gt; &lt;code&gt;std.container.util.make&lt;/code&gt; &lt;/a&gt;构造容器。实际上这是将容器放入另一个容器中所必需的。例如，为了构建一个 &lt;code&gt;Array&lt;/code&gt; 十个空 &lt;code&gt;Array&lt;/code&gt; S，使用下面的呼叫 &lt;code&gt;make&lt;/code&gt; 十倍。</target>
        </trans-unit>
        <trans-unit id="c0f045f8d032f9691206ca37e7e3ca551f6091bd" translate="yes" xml:space="preserve">
          <source>It is used when representing a duration of time - such as how long to sleep with &lt;a href=&quot;core_thread#Thread.sleep&quot;&gt;&lt;code&gt;core.thread.Thread.sleep&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在表示持续时间时使用它，例如使用&lt;a href=&quot;core_thread#Thread.sleep&quot;&gt; &lt;code&gt;core.thread.Thread.sleep&lt;/code&gt; &lt;/a&gt;睡眠多长时间。</target>
        </trans-unit>
        <trans-unit id="4ee87bcd4e29687a5da201987c5dfb2a1c883353" translate="yes" xml:space="preserve">
          <source>It is useful for system programming and interfacing with C/C++, for example to allow for initialization of the runtime when loading a DSO, or as a simple replacement for &lt;code&gt;shared static this&lt;/code&gt; in &lt;a href=&quot;betterc&quot;&gt;betterC mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17dae53faa2b792c553146cb98e6c93618b8a4c" translate="yes" xml:space="preserve">
          <source>It looks good as embedded documentation, not just after it is extracted and processed.</source>
          <target state="translated">它作为嵌入式文档看起来很好,而不仅仅是在提取和处理之后。</target>
        </trans-unit>
        <trans-unit id="2f3af10aa872e5f155c2078162ede3e60918478c" translate="yes" xml:space="preserve">
          <source>It may seem like too small of a difference in time for the attacker to notice, but security researchers have shown that differences as small as &lt;a href=&quot;http://www.cs.rice.edu/~dwallach/pub/crosby-timing2009.pdf&quot;&gt; 20&amp;micro;s can be reliably distinguished&lt;/a&gt; even with network inconsistencies.</source>
          <target state="translated">对于攻击者来说，时间差异似乎太小了，但是安全研究人员表明，即使网络不一致，&lt;a href=&quot;http://www.cs.rice.edu/~dwallach/pub/crosby-timing2009.pdf&quot;&gt;也可以可靠地区分出20&amp;micro;s的&lt;/a&gt;差异。</target>
        </trans-unit>
        <trans-unit id="e6bd568b36725af76c85e86c49755d1465281c06" translate="yes" xml:space="preserve">
          <source>It must be evaluatable at compile time.</source>
          <target state="translated">它在编译时必须是可评估的。</target>
        </trans-unit>
        <trans-unit id="69ae13c3dc07d0583f5f9b4087b39b94ed079ad6" translate="yes" xml:space="preserve">
          <source>It must use the same tokens as the D language uses.</source>
          <target state="translated">它必须使用与D语言使用的令牌相同的令牌。</target>
        </trans-unit>
        <trans-unit id="849081081f66a4a05cbf4ef99fbb6b7ad19734c6" translate="yes" xml:space="preserve">
          <source>It only works with character ranges as input.</source>
          <target state="translated">它只适用于作为输入的字符范围。</target>
        </trans-unit>
        <trans-unit id="26c52ead977622939ef1b1062f122f932ed614a0" translate="yes" xml:space="preserve">
          <source>It provides access to various aspects of the module. It is not generated for betterC.</source>
          <target state="translated">它提供了对该模块各方面的访问。它不是为betterC生成的。</target>
        </trans-unit>
        <trans-unit id="f97c61fa3add53b120631d892e86b2c2046852a3" translate="yes" xml:space="preserve">
          <source>It provides basic range functionality by defining several templates for testing whether a given object is a range, and what kind of range it is:</source>
          <target state="translated">它提供了基本的范围功能,定义了几个模板,用于测试给定对象是否是一个范围,以及它是什么样的范围。</target>
        </trans-unit>
        <trans-unit id="ad6aacf59fb942f6e1cdc563ab119d5d18d3e55f" translate="yes" xml:space="preserve">
          <source>It provides more information to the compiler, enabling more error checking and possibly better code generation.</source>
          <target state="translated">它为编译器提供了更多的信息,使得更多的错误检查和可能更好的代码生成。</target>
        </trans-unit>
        <trans-unit id="6ba24c42088804a0d4be1a3309025dbeb98b12af" translate="yes" xml:space="preserve">
          <source>It should be possible for the user to use Doxygen or other documentation extractor if desired.</source>
          <target state="translated">如果需要,用户应该可以使用Doxygen或其他文档提取器。</target>
        </trans-unit>
        <trans-unit id="093b315d1b92cd8c4da60adb8a7239b6a8739b1d" translate="yes" xml:space="preserve">
          <source>It should look and feel different from code, so it won't be visually confused with code.</source>
          <target state="translated">它的外观和感觉应该与代码不同,所以不会在视觉上与代码混淆。</target>
        </trans-unit>
        <trans-unit id="ab78acfffc9bf5190ce6cb7b40dbee5c908a5208" translate="yes" xml:space="preserve">
          <source>It takes the input by reference. (This means that rvalues - such as string literals - are not accepted: use &lt;code&gt;to&lt;/code&gt; instead.)</source>
          <target state="translated">它通过引用获取输入。（这意味着右值-诸如字符串文字-不接受：使用 &lt;code&gt;to&lt;/code&gt; 代替）。</target>
        </trans-unit>
        <trans-unit id="e10cbd22ba1e750ba124936549407411b37b8cea" translate="yes" xml:space="preserve">
          <source>It takes three forms:</source>
          <target state="translated">它有三种形式。</target>
        </trans-unit>
        <trans-unit id="86760b7be00c051b6d56dcf51cea817312c47f73" translate="yes" xml:space="preserve">
          <source>It takes two forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050370d910aa58f3109ec31e86d6b4499d187cdf" translate="yes" xml:space="preserve">
          <source>It uses well defined standard rules of property name lookup. This includes fuzzy matching of names, so that 'White_Space', 'white-SpAce' and 'whitespace' are all considered equal and yield the same set of white space &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt;.</source>
          <target state="translated">它使用定义良好的属性名称查找标准规则。这包括名称的模糊匹配，以便将&amp;ldquo; White_Space&amp;rdquo;，&amp;ldquo; white-SpAce&amp;rdquo;和&amp;ldquo; whitespace&amp;rdquo;都视为相等，并产生相同的一组空白&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93a7b2f1dac61a8d7598e3760cd8188b02968b69" translate="yes" xml:space="preserve">
          <source>It will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the underlying data source is at least a forward range.</source>
          <target state="translated">这将是一个&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前进档&lt;/a&gt;，如果基础数据源是至少一个前进档。</target>
        </trans-unit>
        <trans-unit id="bd4418738e6a8629325161d7af1adb0f490b4209" translate="yes" xml:space="preserve">
          <source>It will not detect attempts to dereference &lt;code&gt;null&lt;/code&gt; pointers or possibly &lt;code&gt;null&lt;/code&gt; pointers. This is unworkable because there is no current method of annotating a type as a non-&lt;code&gt;null&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ade996eab3bb94cd2a7d5f8def981c1ae053558" translate="yes" xml:space="preserve">
          <source>It's also possible to &lt;code&gt;put&lt;/code&gt; any width strings or characters into narrow strings -- put does the conversion for you.  Note that putting the same width character as the target buffer type is &lt;code&gt;nothrow&lt;/code&gt;, but transcoding can throw a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">也可以 &lt;code&gt;put&lt;/code&gt; 任何宽度的字符串或字符放入狭窄的字符串中-进行转换。请注意，把相同的宽度字符作为目标缓冲器类型是 &lt;code&gt;nothrow&lt;/code&gt; ，但转码可以抛出一个&lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15967cde9e56b07a7f1c26d7a69e1a075aff9a00" translate="yes" xml:space="preserve">
          <source>It's based on existing D comment forms, so it is completely independent of parsers only interested in D code.</source>
          <target state="translated">它基于现有的D注释形式,所以它完全独立于只对D代码感兴趣的解析器。</target>
        </trans-unit>
        <trans-unit id="df30e895e5cea990b692a026e7012b1b8ed9990f" translate="yes" xml:space="preserve">
          <source>It's easy and natural to write, i.e. minimal reliance on &amp;lt;tags&amp;gt; and other clumsy forms one would never see in a finished document.</source>
          <target state="translated">编写起来既简单又自然，即对&amp;lt;tags&amp;gt;和其他笨拙的形式的依赖最小，这些形式在最终文档中是永远不会看到的。</target>
        </trans-unit>
        <trans-unit id="90363d2d1fd187921f9df756c4f8841ea45cbd8c" translate="yes" xml:space="preserve">
          <source>It's good software engineering practice to minimize gratuitous portability problems in the code. Techniques to minimize potential portability problems are:</source>
          <target state="translated">尽量减少代码中无偿的可移植性问题是良好的软件工程实践。尽量减少潜在的可移植性问题的技术有:</target>
        </trans-unit>
        <trans-unit id="676010a0cf026e4e46adb9fc97725347e3cf4b56" translate="yes" xml:space="preserve">
          <source>It's illegal to move a class instance even if you are sure there are no pointers to it. As such, it is illegal to move a scoped object.</source>
          <target state="translated">移动一个类的实例是非法的,即使你确定没有指向它的指针。因此,移动一个作用域对象是非法的。</target>
        </trans-unit>
        <trans-unit id="1d0ecd13133638bfea893649adf9f413f5146027" translate="yes" xml:space="preserve">
          <source>It's illegal to shift by the same or more bits than the size of the quantity being shifted:</source>
          <target state="translated">移位的位数与被移位的数量大小相同或更多是违法的。</target>
        </trans-unit>
        <trans-unit id="b5899aa25cbeb84be446d7f611f383682e9adef5" translate="yes" xml:space="preserve">
          <source>It's impossible to know from CommaExp.semantic if the result will be used, hence when there is a result (type != void), a deprecation message is always emitted. However, some construct can produce a result but won't use it (ExpStatement and for loop increment). Those should call this function to prevent unwanted deprecations to be emitted.</source>
          <target state="translated">从CommaExp.semantic中不可能知道结果是否会被使用,因此当有一个结果(类型 !=void)时,总是会发出一个废弃消息。然而,有些构造可以产生一个结果但不会使用它(ExpStatement和for循环增量)。这些构造应该调用这个函数来防止不需要的废弃信息被发出。</target>
        </trans-unit>
        <trans-unit id="87a902f7796c154f6adbb449196d8425bb687de6" translate="yes" xml:space="preserve">
          <source>It's not allowed to mark an overridden method with the attributes &lt;a href=&quot;attribute#disable&quot;&gt;&lt;code&gt;@disable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;attribute#deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;. To stop the compilation or to output the deprecation message, the compiler must be able to determine the target of the call, which can't be guaranteed when it is virtual.</source>
          <target state="translated">不允许使用&lt;a href=&quot;attribute#disable&quot;&gt; &lt;code&gt;@disable&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;attribute#deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;属性标记覆盖的方法。要停止编译或输出不赞成使用的消息，编译器必须能够确定调用的目标，如果是虚拟的则无法保证。</target>
        </trans-unit>
        <trans-unit id="06a4ac5a76e9f0b9bdc8fd8bfd509f3b58e40c69" translate="yes" xml:space="preserve">
          <source>It's not possible to create a Duration of months or years, because the variable number of days in a month or year makes it impossible to convert between months or years and smaller units without a specific date. So, nothing uses &lt;code&gt;Duration&lt;/code&gt;s when dealing with months or years. Rather, functions specific to months and years are defined. For instance, &lt;a href=&quot;std_datetime#Date&quot;&gt;&lt;code&gt;std.datetime.Date&lt;/code&gt;&lt;/a&gt; has &lt;code&gt;add!&quot;years&quot;&lt;/code&gt; and &lt;code&gt;add!&quot;months&quot;&lt;/code&gt; for adding years and months rather than creating a Duration of years or months and adding that to a &lt;a href=&quot;std_datetime#Date&quot;&gt;&lt;code&gt;std.datetime.Date&lt;/code&gt;&lt;/a&gt;. But Duration is used when dealing with weeks or smaller.</source>
          <target state="translated">无法创建几个月或几年的持续时间，因为一个月或一年中可变的天数使得无法在几个月或几年与更小的单位（没有特定日期）之间进行转换。因此，在处理几个月或几年时，不会使用 &lt;code&gt;Duration&lt;/code&gt; 。而是定义了特定于月份和年份的功能。例如，&lt;a href=&quot;std_datetime#Date&quot;&gt; &lt;code&gt;std.datetime.Date&lt;/code&gt; &lt;/a&gt;具有 &lt;code&gt;add!&quot;years&quot;&lt;/code&gt; 和 &lt;code&gt;add!&quot;months&quot;&lt;/code&gt; 用于添加年份和月份，而不是创建&lt;a href=&quot;std_datetime#Date&quot;&gt; &lt;code&gt;std.datetime.Date&lt;/code&gt; &lt;/a&gt;或几个月的Duration并将其添加到std.datetime.Date中。但是，持续时间用于处理数周或更短的时间。</target>
        </trans-unit>
        <trans-unit id="f254fe5e637e0412db399e1267f254c7da7a7960" translate="yes" xml:space="preserve">
          <source>It's not recommended to rely on the template parameters or the exact type of a current &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; set in &lt;code&gt;std.uni&lt;/code&gt;. The type and parameters may change when the standard allocators design is finalized. Use &lt;a href=&quot;#isCodepointSet&quot;&gt;&lt;code&gt;isCodepointSet&lt;/code&gt;&lt;/a&gt; with templates or just stick with the default alias &lt;a href=&quot;#CodepointSet&quot;&gt;&lt;code&gt;CodepointSet&lt;/code&gt;&lt;/a&gt; throughout the whole code base.</source>
          <target state="translated">不建议依赖模板参数或 &lt;code&gt;std.uni&lt;/code&gt; 中设置的当前&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;的确切类型。当标准分配器设计完成时，类型和参数可能会更改。使用&lt;a href=&quot;#isCodepointSet&quot;&gt; &lt;code&gt;isCodepointSet&lt;/code&gt; &lt;/a&gt;使用模板或只是坚持使用默认别名&lt;a href=&quot;#CodepointSet&quot;&gt; &lt;code&gt;CodepointSet&lt;/code&gt; &lt;/a&gt;在整个代码库。</target>
        </trans-unit>
        <trans-unit id="e42f2c0ae3ac2dbd97c749238e72a4938f4cb57d" translate="yes" xml:space="preserve">
          <source>It's possible that, due to greater use of temporaries and common subexpressions, optimized code may produce a more accurate answer than unoptimized code.</source>
          <target state="translated">有可能由于更多地使用了时序和常用的子表达式,优化后的代码可能会比未优化的代码产生更准确的答案。</target>
        </trans-unit>
        <trans-unit id="26bfc917d4c2808b47a0c439b2041bcf1d3ffe79" translate="yes" xml:space="preserve">
          <source>It's primarily of use when &lt;code&gt;MonoTime.ticksPerSecond&lt;/code&gt; is greater than hecto-nanosecond resolution, and an application needs a higher precision than hecto-nanoceconds.</source>
          <target state="translated">它主要用于 &lt;code&gt;MonoTime.ticksPerSecond&lt;/code&gt; 大于十亿分之一秒分辨率，并且应用程序需要比十进制秒级更高的精度。</target>
        </trans-unit>
        <trans-unit id="7493d4e3c56b61b05894f6661cfb0cba6fef7966" translate="yes" xml:space="preserve">
          <source>It's primarily used as the time zone in the result of &lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt;&lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">它主要用作&lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt; &lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;fromISOString&lt;/code&gt; ， &lt;code&gt;fromISOExtString&lt;/code&gt; 和 &lt;code&gt;fromSimpleString&lt;/code&gt; 的结果中的时区。</target>
        </trans-unit>
        <trans-unit id="5ddbad8c19d68bb5a701a60afd8d7c7541591bb5" translate="yes" xml:space="preserve">
          <source>It's recognized that an application may need further enhancements and extensions, such as less commonly known algorithms, or tailoring existing ones for region specific needs. To help users with building any extra functionality beyond the core primitives, the module provides:</source>
          <target state="translated">人们认识到,一个应用程序可能需要进一步的增强和扩展,如不太常见的算法,或根据区域的特定需求定制现有的算法。为了帮助用户建立核心基元以外的任何额外功能,该模块提供了:</target>
        </trans-unit>
        <trans-unit id="68d3d6d38586ab9e2cf36ecb94fa00a82cfe0680" translate="yes" xml:space="preserve">
          <source>It's the same as &lt;code&gt;TickDuration(0)&lt;/code&gt;, but it's provided to be consistent with &lt;code&gt;Duration&lt;/code&gt; and &lt;code&gt;FracSec&lt;/code&gt;, which provide &lt;code&gt;zero&lt;/code&gt; properties.</source>
          <target state="translated">它与 &lt;code&gt;TickDuration(0)&lt;/code&gt; 相同，但是提供了与 &lt;code&gt;Duration&lt;/code&gt; 和 &lt;code&gt;FracSec&lt;/code&gt; 一致，后者提供了 &lt;code&gt;zero&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="ea921a8a04c239de3776a66ccc556b8d1fa02438" translate="yes" xml:space="preserve">
          <source>It's the same as &lt;code&gt;TickDuration(0)&lt;/code&gt;, but it's provided to be consistent with &lt;code&gt;Duration&lt;/code&gt;, which provides a &lt;code&gt;zero&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fa71e6d58d5d0fca114db8f0a8c3a287da2aef" translate="yes" xml:space="preserve">
          <source>Itanium C++ ABI: Exception Handling ($Revision: 1.22 $)</source>
          <target state="translated">Itanium C++ABI:异常处理 ($Revision:1.22 $)</target>
        </trans-unit>
        <trans-unit id="9b3710c74713ad73b6fee6faa68d7c7089a3d821" translate="yes" xml:space="preserve">
          <source>Item in list for member initializer.</source>
          <target state="translated">成员初始化器列表中的项目。</target>
        </trans-unit>
        <trans-unit id="967e0f2ba10fa14510c5c3967d8f30ed26175886" translate="yes" xml:space="preserve">
          <source>Item[] &lt;strong id=&quot;items&quot;&gt;items&lt;/strong&gt;;</source>
          <target state="translated">Item [] &lt;strong id=&quot;items&quot;&gt;项目&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="bdc6a863777ef0dc2df1c117cbf561a6833206f4" translate="yes" xml:space="preserve">
          <source>Items to be read.</source>
          <target state="translated">有待宣读的项目:</target>
        </trans-unit>
        <trans-unit id="e3250ae0a20fa67a451aa0b4b6775210b20451c3" translate="yes" xml:space="preserve">
          <source>Items to write.</source>
          <target state="translated">要写的项目。</target>
        </trans-unit>
        <trans-unit id="7547deafe5aeaac079d28f1f346ec148fba5a3b0" translate="yes" xml:space="preserve">
          <source>Iterate a range of char, wchar, or dchars by code unit.</source>
          <target state="translated">按代码单位迭代char、wchar或dchars的范围。</target>
        </trans-unit>
        <trans-unit id="b1704652b324c3acc4164b27ffcc4b641b7725a9" translate="yes" xml:space="preserve">
          <source>Iterate a string by &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过&lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt;迭代字符串。</target>
        </trans-unit>
        <trans-unit id="6d5051ba4123d61c812f79621e111e7a827233fe" translate="yes" xml:space="preserve">
          <source>Iterate an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of characters by char type &lt;code&gt;C&lt;/code&gt; by encoding the elements of the range.</source>
          <target state="translated">通过编码字符&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;范围&lt;/a&gt; &lt;code&gt;C&lt;/code&gt; 的字符类型C来迭代输入范围的字符。</target>
        </trans-unit>
        <trans-unit id="2bcec762ed6378cddf8fe09a083a3077c9a309f0" translate="yes" xml:space="preserve">
          <source>Iterate an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of characters by char, wchar, or dchar. These aliases simply forward to &lt;a href=&quot;#byUTF&quot;&gt;&lt;code&gt;byUTF&lt;/code&gt;&lt;/a&gt; with the corresponding C argument.</source>
          <target state="translated">通过char，wchar或dchar 迭代字符的&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;。这些别名将使用相应的C参数简单地转发到&lt;a href=&quot;#byUTF&quot;&gt; &lt;code&gt;byUTF&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3f29e0c66209fcd4d3a0e0f7bfe84443ed9bfc8" translate="yes" xml:space="preserve">
          <source>Iterate multiple ranges in lockstep using a &lt;code&gt;foreach&lt;/code&gt; loop. In contrast to &lt;a href=&quot;#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; it allows reference access to its elements. If only a single range is passed in, the &lt;code&gt;Lockstep&lt;/code&gt; aliases itself away. If the ranges are of different lengths and &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; stop after the shortest range is empty. If the ranges are of different lengths and &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt;, throw an exception. &lt;code&gt;s&lt;/code&gt; may not be &lt;code&gt;StoppingPolicy.longest&lt;/code&gt;, and passing this will throw an exception.</source>
          <target state="translated">使用 &lt;code&gt;foreach&lt;/code&gt; 循环以锁步方式迭代多个范围。与&lt;a href=&quot;#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt;相反，它允许对其元素的引用访问。如果仅传递单个范围，则 &lt;code&gt;Lockstep&lt;/code&gt; 将使自己成为别名。如果范围的长度不同并且 &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; ，则在最短范围为空之后停止。如果范围的长度不同并且 &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt; ，则引发异常。 &lt;code&gt;s&lt;/code&gt; 可能不是 &lt;code&gt;StoppingPolicy.longest&lt;/code&gt; ，并通过这将抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="46f6cb646c6843f945d7da582e76018151566d41" translate="yes" xml:space="preserve">
          <source>Iterate over &lt;code&gt;range&lt;/code&gt; with an attached index variable.</source>
          <target state="translated">使用附加的索引变量遍历 &lt;code&gt;range&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6544d2b6a21967203cbbbbf85d9c93956a308c9" translate="yes" xml:space="preserve">
          <source>Iterate over all module infos.</source>
          <target state="translated">遍历所有模块信息。</target>
        </trans-unit>
        <trans-unit id="c6f1ecb57816d0f8ab8895d96ff555e6c40017b4" translate="yes" xml:space="preserve">
          <source>Iterate over ranges with windows</source>
          <target state="translated">在有窗口的范围内迭代</target>
        </trans-unit>
        <trans-unit id="0923c68159586a48770eb5eb395cea146e0dc546" translate="yes" xml:space="preserve">
          <source>Iterate several ranges in lockstep. The element type is a proxy tuple that allows accessing the current element in the &lt;code&gt;n&lt;/code&gt;th range by using &lt;code&gt;e[n]&lt;/code&gt;.</source>
          <target state="translated">逐步迭代几个范围。元素类型是一个代理元组，它允许使用 &lt;code&gt;e[n]&lt;/code&gt; 访问第 &lt;code&gt;n&lt;/code&gt; 个范围内的当前元素。</target>
        </trans-unit>
        <trans-unit id="cba848f6a93f568e8e0ff6bcad21ff094359be43" translate="yes" xml:space="preserve">
          <source>Iterate this dsymbol or members of this scoped dsymbol, then call &lt;code&gt;fp&lt;/code&gt; with the found symbol and &lt;code&gt;param&lt;/code&gt;.</source>
          <target state="translated">迭代此dsymbol或此作用域dsymbol的成员，然后使用找到的symbol和 &lt;code&gt;param&lt;/code&gt; 调用 &lt;code&gt;fp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="396a4c4a83adbfe93e36ca56c3db62aa4de33668" translate="yes" xml:space="preserve">
          <source>Iterates</source>
          <target state="translated">Iterates</target>
        </trans-unit>
        <trans-unit id="4c7657311c0985cf818bd71ba4e38315b188c160" translate="yes" xml:space="preserve">
          <source>Iterates a bidirectional range backwards.</source>
          <target state="translated">向后迭代一个双向的范围。</target>
        </trans-unit>
        <trans-unit id="81014f52c564f4b2a0a23cd199c9b45c770f9142" translate="yes" xml:space="preserve">
          <source>Iterates a bidirectional range backwards. The original range can be accessed by using the &lt;code&gt;source&lt;/code&gt; property. Applying retro twice to the same range yields the original range.</source>
          <target state="translated">向后迭代双向范围。可以使用 &lt;code&gt;source&lt;/code&gt; 属性访问原始范围。将Retro两次应用于相同范围会产生原始范围。</target>
        </trans-unit>
        <trans-unit id="031fd6a3f37b8f60999d9b1f8c51e96e07a5e012" translate="yes" xml:space="preserve">
          <source>Iterates a random-access range starting from a given point and progressively extending left and right from that point. If no initial point is given, iteration starts from the middle of the range. Iteration spans the entire range.</source>
          <target state="translated">迭代一个随机访问范围,从给定的点开始,并从该点向左和向右逐步扩展。如果没有给定的初始点,则从范围的中间开始迭代。迭代跨越整个范围。</target>
        </trans-unit>
        <trans-unit id="6155d3dc4b918ca7ad16f0811ad5e79c02bd03b2" translate="yes" xml:space="preserve">
          <source>Iterates a range with an attached index variable.</source>
          <target state="translated">迭代一个带有索引变量的范围。</target>
        </trans-unit>
        <trans-unit id="be520983ead745fdd9048145abd61e2d2031ef35" translate="yes" xml:space="preserve">
          <source>Iterates a range with stride</source>
          <target state="translated">迭代步幅</target>
        </trans-unit>
        <trans-unit id="0e3057ecac253c49baed9d03893907ec2f577311" translate="yes" xml:space="preserve">
          <source>Iterates over the unique elements in a range, which is assumed sorted.</source>
          <target state="translated">遍历一个范围内的唯一元素,并假定其已排序。</target>
        </trans-unit>
        <trans-unit id="e9d7e5b017841d823f90dd8b859e306591765919" translate="yes" xml:space="preserve">
          <source>Iterates range &lt;code&gt;r&lt;/code&gt; with stride &lt;code&gt;n&lt;/code&gt;. If the range is a random-access range, moves by indexing into the range; otherwise, moves by successive calls to &lt;code&gt;popFront&lt;/code&gt;. Applying stride twice to the same range results in a stride with a step that is the product of the two applications. It is an error for &lt;code&gt;n&lt;/code&gt; to be 0.</source>
          <target state="translated">用步长 &lt;code&gt;n&lt;/code&gt; 迭代范围 &lt;code&gt;r&lt;/code&gt; 。如果范围是随机访问范围，则通过索引进入范围；否则，通过连续调用 &lt;code&gt;popFront&lt;/code&gt; 来移动。将步幅两次应用到同一范围会导致步幅为两个应用程序的乘积。 &lt;code&gt;n&lt;/code&gt; 为0 是错误的。</target>
        </trans-unit>
        <trans-unit id="41c0b28ede291ea7f7566d122e863aa0f535dcba" translate="yes" xml:space="preserve">
          <source>Iterates the passed arguments and return the maximum value.</source>
          <target state="translated">迭代传递的参数并返回最大值。</target>
        </trans-unit>
        <trans-unit id="47523bd72a1e5bbe72f324aa44a743f2339e194c" translate="yes" xml:space="preserve">
          <source>Iterates the passed arguments and returns the maximum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1e12925acc4cdc52d701ccd76ee602a77fe86f" translate="yes" xml:space="preserve">
          <source>Iterates the passed arguments and returns the minimum value.</source>
          <target state="translated">迭代传递的参数并返回最小值。</target>
        </trans-unit>
        <trans-unit id="6f9bb1a3e40031f0788544f6e843a3b9b81f2f50" translate="yes" xml:space="preserve">
          <source>Iterates the passed range and returns the maximal element. A custom mapping function can be passed to &lt;code&gt;map&lt;/code&gt;. In other languages this is sometimes called &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="translated">迭代传递的范围并返回最大元素。可以将自定义映射功能传递给 &lt;code&gt;map&lt;/code&gt; 。在其他语言中，有时称为 &lt;code&gt;argmax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c4dd3d0ca41dc586c0601f5460e0bdf217d07ef" translate="yes" xml:space="preserve">
          <source>Iterates the passed range and returns the minimal element. A custom mapping function can be passed to &lt;code&gt;map&lt;/code&gt;. In other languages this is sometimes called &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="translated">迭代传递的范围并返回minimum元素。可以将自定义映射功能传递给 &lt;code&gt;map&lt;/code&gt; 。在其他语言中，有时称为 &lt;code&gt;argmin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac5030d77c55effd0702acc270731f6b899947c4" translate="yes" xml:space="preserve">
          <source>Iterates through a file a chunk at a time by using &lt;code&gt;foreach&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;foreach&lt;/code&gt; 一次遍历文件一大块。</target>
        </trans-unit>
        <trans-unit id="bda215d2193432c1605c2f94eab1dd86c59fc050" translate="yes" xml:space="preserve">
          <source>Iterates through the lines of a file by using &lt;code&gt;foreach&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;foreach&lt;/code&gt; 遍历文件的各行。</target>
        </trans-unit>
        <trans-unit id="00eca5d46e200a01deae26dbfef918eb9a307e2e" translate="yes" xml:space="preserve">
          <source>Iterating over &lt;code&gt;Lockstep&lt;/code&gt; in reverse and with an index is only possible when &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt;, in order to preserve indexes. If an attempt is made at iterating in reverse when &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt;, an exception will be thrown.</source>
          <target state="translated">仅当 &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt; 时，才可以反向并通过索引迭代 &lt;code&gt;Lockstep&lt;/code&gt; 以便保留索引。如果在 &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; 时尝试进行反向迭代，则将引发异常。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="7ab9c33240f90c018e5301ec386d9a17da67f57b" translate="yes" xml:space="preserve">
          <source>Iteratively joins all tracked threads. This function will block add, remove, and opApply until it completes.</source>
          <target state="translated">迭代加入所有被跟踪的线程。该函数将阻止添加、删除和操作应用,直到完成。</target>
        </trans-unit>
        <trans-unit id="ac5dbd0b8592025504a68619b35e97d48ae39f52" translate="yes" xml:space="preserve">
          <source>JSON type enumeration</source>
          <target state="translated">JSON类型枚举</target>
        </trans-unit>
        <trans-unit id="37261b1315c409df97253a04fdcad2ac04e9f2e5" translate="yes" xml:space="preserve">
          <source>JSON value node</source>
          <target state="translated">JSON值节点</target>
        </trans-unit>
        <trans-unit id="19b9988b5b0ebaf897665e22703721b63cd55e3f" translate="yes" xml:space="preserve">
          <source>JSONOptions &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">JSONOptions &lt;code&gt;options&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77047b2f2f7a1f46f4f773acebc94e1704d45d0a" translate="yes" xml:space="preserve">
          <source>JSONValue</source>
          <target state="translated">JSONValue</target>
        </trans-unit>
        <trans-unit id="6a908d3132e3f4771380420780f724bcb99aa35b" translate="yes" xml:space="preserve">
          <source>JSONValue &lt;strong id=&quot;parseJSON&quot;&gt;parseJSON&lt;/strong&gt;(T)(T json, JSONOptions options)</source>
          <target state="translated">JSONValue &lt;strong id=&quot;parseJSON&quot;&gt;parseJSON&lt;/strong&gt;（T）（T json，JSONOptions选项）</target>
        </trans-unit>
        <trans-unit id="ad2cc87635827ce36358659faec53896c2ffd9d7" translate="yes" xml:space="preserve">
          <source>JSONValue &lt;strong id=&quot;parseJSON&quot;&gt;parseJSON&lt;/strong&gt;(T)(T json, int maxDepth = -1, JSONOptions options = JSONOptions.none)</source>
          <target state="translated">JSONValue &lt;strong id=&quot;parseJSON&quot;&gt;parseJSON&lt;/strong&gt;（T）（T json，int maxDepth = -1，JSONOptions选项= JSONOptions.none）</target>
        </trans-unit>
        <trans-unit id="75fe8ccb746c12e5fc2263d91bcd2e2c2a1c8f7e" translate="yes" xml:space="preserve">
          <source>Jacob Carlborg</source>
          <target state="translated">Jacob Carlborg</target>
        </trans-unit>
        <trans-unit id="6e25ce2240148f400ce62910a8b1efe74e2c9a0e" translate="yes" xml:space="preserve">
          <source>Janice Caron</source>
          <target state="translated">Janice Caron</target>
        </trans-unit>
        <trans-unit id="7596e768bfc7370245a658fe8f76d22204852664" translate="yes" xml:space="preserve">
          <source>Java's &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/index.html&quot;&gt;Javadoc&lt;/a&gt;, probably the most well-known</source>
          <target state="translated">Java的&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/index.html&quot;&gt;Javadoc&lt;/a&gt;，可能是最著名的</target>
        </trans-unit>
        <trans-unit id="94e850a9fa9f98700106bfba6b5849640ea65567" translate="yes" xml:space="preserve">
          <source>JavaScript Object Notation</source>
          <target state="translated">JavaScript对象符号</target>
        </trans-unit>
        <trans-unit id="4d3bb51ea74dbb54d8ffaf04425ff843127f10a5" translate="yes" xml:space="preserve">
          <source>Javanese</source>
          <target state="translated">Javanese</target>
        </trans-unit>
        <trans-unit id="5094055d2217aa7321a9d7bed6ee4d5794505c17" translate="yes" xml:space="preserve">
          <source>Jeremie Pelletier, David Herberth</source>
          <target state="translated">Jeremie Pelletier,David Herberth.</target>
        </trans-unit>
        <trans-unit id="44f434a971d725063d7a2953337c698c7bac2ba2" translate="yes" xml:space="preserve">
          <source>Jesse Phillips</source>
          <target state="translated">Jesse Phillips</target>
        </trans-unit>
        <trans-unit id="8d398e7a2e7966fc969106c70e0482f689337c66" translate="yes" xml:space="preserve">
          <source>Johannes Pfau</source>
          <target state="translated">孔雀</target>
        </trans-unit>
        <trans-unit id="f46447d52bfcc376c589171fb6036cd3ae4a5810" translate="yes" xml:space="preserve">
          <source>Join a couple of functions into one that executes the original functions one after the other, using one function's result for the next function's argument.</source>
          <target state="translated">将几个函数连接成一个函数,一个接一个地执行原来的函数,用一个函数的结果作为下一个函数的参数。</target>
        </trans-unit>
        <trans-unit id="0d0c43aa8867e08f397e43a619a1f600ed8f6361" translate="yes" xml:space="preserve">
          <source>Join_Control</source>
          <target state="translated">Join_Control</target>
        </trans-unit>
        <trans-unit id="dcb5bf332c4e4981c7768b8555ac3e4b7690dc4e" translate="yes" xml:space="preserve">
          <source>Joins a couple of functions into one that executes the original functions independently and returns a tuple with all the results.</source>
          <target state="translated">将几个函数连接成一个函数,独立执行原函数,并返回一个包含所有结果的元组。</target>
        </trans-unit>
        <trans-unit id="aefc3c1587d67e993c50c46acea53d9b977ae451" translate="yes" xml:space="preserve">
          <source>Joins all non-daemon threads that are currently running. This is done by performing successive scans through the thread list until a scan consists of only daemon threads.</source>
          <target state="translated">加入当前正在运行的所有非守护进程线程。这是通过对线程列表进行连续扫描来实现的,直到一次扫描只包含守护进程线程。</target>
        </trans-unit>
        <trans-unit id="8bc86f684db60d70140fe1419b4325b73f7613a4" translate="yes" xml:space="preserve">
          <source>Jonas Drewsen. Some of the SMTP code contributed by Jimmy Cao.</source>
          <target state="translated">Jonas Drewsen。Jimmy Cao贡献的部分SMTP代码。</target>
        </trans-unit>
        <trans-unit id="2792f94184c6127be37b21bcdd8b46ecd91706c9" translate="yes" xml:space="preserve">
          <source>Jonathan M Davis</source>
          <target state="translated">Jonathan M Davis</target>
        </trans-unit>
        <trans-unit id="0729735c2be61b7d083c7452b2591194f6b9f3e4" translate="yes" xml:space="preserve">
          <source>Jonathan M. Davis &lt;a href=&quot;http://dconf.org/2015/talks/davis.html&quot;&gt;&lt;i&gt;Introduction to Ranges&lt;/i&gt;&lt;/a&gt; talk at DConf 2015 a vivid introduction from its core constructs to practical advice.</source>
          <target state="translated">乔纳森&amp;middot;戴维斯（Jonathan M.Davis）在DConf 2015上&lt;a href=&quot;http://dconf.org/2015/talks/davis.html&quot;&gt;&lt;i&gt;对Ranges&lt;/i&gt;&lt;/a&gt;进行了介绍，从核心结构到实用建议都做了生动的介绍。</target>
        </trans-unit>
        <trans-unit id="97dbaf8e8c4490a101cf7e3f174555f70aa1c17b" translate="yes" xml:space="preserve">
          <source>JsonFieldFlags &lt;strong id=&quot;tryParseJsonField&quot;&gt;tryParseJsonField&lt;/strong&gt;(const(char)* fieldName);</source>
          <target state="translated">JsonFieldFlags &lt;strong id=&quot;tryParseJsonField&quot;&gt;tryParseJsonField&lt;/strong&gt;（const（char）* fieldName）;</target>
        </trans-unit>
        <trans-unit id="2d8f6d6417b503e6fc00ddf97fea18ebdd19b03b" translate="yes" xml:space="preserve">
          <source>JsonFieldFlags.none on error, otherwise the JsonFieldFlags value corresponding to the given fieldName.</source>
          <target state="translated">错误时为JsonFieldFlags.none,否则为给定fieldName对应的JsonFieldFlags值。</target>
        </trans-unit>
        <trans-unit id="7426cf06bbe68f4942c2dee1dc1e5f14aacfb8fe" translate="yes" xml:space="preserve">
          <source>Julius C'ster</source>
          <target state="translated">Julius C'ster</target>
        </trans-unit>
        <trans-unit id="36a42ea8673555a38d9845c5a7215a17263890c6" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;Nullable!T&lt;/code&gt;, except that the null state is defined as a particular value. For example, &lt;code&gt;Nullable!(uint, uint.max)&lt;/code&gt; is an &lt;code&gt;uint&lt;/code&gt; that sets aside the value &lt;code&gt;uint.max&lt;/code&gt; to denote a null state. &lt;code&gt;Nullable!(T, nullValue)&lt;/code&gt; is more storage-efficient than &lt;code&gt;Nullable!T&lt;/code&gt; because it does not need to store an extra &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">就像 &lt;code&gt;Nullable!T&lt;/code&gt; 一样，除了将null状态定义为特定值。例如， &lt;code&gt;Nullable!(uint, uint.max)&lt;/code&gt; 是将值 &lt;code&gt;uint.max&lt;/code&gt; 留为表示空状态的 &lt;code&gt;uint&lt;/code&gt; 。 &lt;code&gt;Nullable!(T, nullValue)&lt;/code&gt; 比 &lt;code&gt;Nullable!T&lt;/code&gt; 具有更高的存储效率，因为它不需要存储额外的 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec9772fef62cdea0720dce405193ab48cbc57ed2" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;Nullable!T&lt;/code&gt;, except that the object refers to a value sitting elsewhere in memory. This makes assignments overwrite the initially assigned value. Internally &lt;code&gt;NullableRef!T&lt;/code&gt; only stores a pointer to &lt;code&gt;T&lt;/code&gt; (i.e., &lt;code&gt;Nullable!T.sizeof == (T*).sizeof&lt;/code&gt;).</source>
          <target state="translated">就像 &lt;code&gt;Nullable!T&lt;/code&gt; 一样，除了对象引用位于内存中其他位置的值。这使分配覆盖初始分配的值。内部 &lt;code&gt;NullableRef!T&lt;/code&gt; 仅存储指向 &lt;code&gt;T&lt;/code&gt; 的指针（即 &lt;code&gt;Nullable!T.sizeof == (T*).sizeof&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="63ea9136dd991394515bab1b8623b9c1fd950655" translate="yes" xml:space="preserve">
          <source>Just one &lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;Identifier&lt;/i&gt;&lt;/a&gt; is rewritten to &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">只有一个&lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;标识符&lt;/i&gt;&lt;/a&gt;被重写为&lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="89f6b4c092b16dc6948f25e1798098f47a9883d5" translate="yes" xml:space="preserve">
          <source>Just the range to fold over; or the range and one seed per function; or the range, one seed per function, and the work unit size</source>
          <target state="translated">只需将范围折叠过来;或将范围和每个函数的一个种子;或将范围、每个函数的一个种子和工作单元大小都折叠过来</target>
        </trans-unit>
        <trans-unit id="95821b707963ae42f0cd8570a73c7a770a76a918" translate="yes" xml:space="preserve">
          <source>K &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">K &lt;code&gt;key&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07f366da6fc6a861cbc87352b22ef074419fcb3a" translate="yes" xml:space="preserve">
          <source>Kai Nacke</source>
          <target state="translated">Kai Nacke</target>
        </trans-unit>
        <trans-unit id="35515824c39939c254cd4490c2c2aadbc065186f" translate="yes" xml:space="preserve">
          <source>Kai Nacke, Johannes Pfau, Nick Sabalausky</source>
          <target state="translated">Kai Nacke,Johannes Pfau,Nick Sabalausky</target>
        </trans-unit>
        <trans-unit id="ae170b17bf57b2dd3f07fcd95b9f2bb7e3b26355" translate="yes" xml:space="preserve">
          <source>Kaithi</source>
          <target state="translated">Kaithi</target>
        </trans-unit>
        <trans-unit id="557d6bd7caa0a06ffe47eadcbd352ca5b993f101" translate="yes" xml:space="preserve">
          <source>Kana Supplement</source>
          <target state="translated">Kana补充剂</target>
        </trans-unit>
        <trans-unit id="5c52b04b182fe59c46dbb680a685e8fae4abc9e4" translate="yes" xml:space="preserve">
          <source>Kanbun</source>
          <target state="translated">Kanbun</target>
        </trans-unit>
        <trans-unit id="765d8f89f8bd937afa34d37a8dd5511726f71e6c" translate="yes" xml:space="preserve">
          <source>Kangxi Radicals</source>
          <target state="translated">康熙激进派</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="26f11d685b82331f6a7c0ef049098224fd15a035" translate="yes" xml:space="preserve">
          <source>Karatsuba multiplication</source>
          <target state="translated">Karatsuba乘法</target>
        </trans-unit>
        <trans-unit id="6842e5a778887793f59acc2ef5454c8c1ea0e92d" translate="yes" xml:space="preserve">
          <source>Katakana</source>
          <target state="translated">Katakana</target>
        </trans-unit>
        <trans-unit id="d1397b6fcf2a880567c752fd0440900ff604ccd3" translate="yes" xml:space="preserve">
          <source>Katakana Phonetic Extensions</source>
          <target state="translated">片假名语音扩展</target>
        </trans-unit>
        <trans-unit id="3dd63971d3f2b16b51633181c1aec91223d8af19" translate="yes" xml:space="preserve">
          <source>Kayah Li</source>
          <target state="translated">Kayah Li</target>
        </trans-unit>
        <trans-unit id="75ee154fd513c399937f6b79a87ebbade8c7cadd" translate="yes" xml:space="preserve">
          <source>Kayah_Li</source>
          <target state="translated">Kayah_Li</target>
        </trans-unit>
        <trans-unit id="d74eee745944f149824eb2fa0740f7f9e756246b" translate="yes" xml:space="preserve">
          <source>Keep for backward binary compatibility. This function can be removed in the future.</source>
          <target state="translated">为了向后的二进制兼容而保留。这个功能将来可以删除。</target>
        </trans-unit>
        <trans-unit id="cefeb94879a4163ffc965d759c646922a56c39b1" translate="yes" xml:space="preserve">
          <source>Keep track of how often rt_init/rt_term were called.</source>
          <target state="translated">跟踪rt_init/rt_term的调用频率。</target>
        </trans-unit>
        <trans-unit id="36d88bb75bee3164971007d202183f35b6295316" translate="yes" xml:space="preserve">
          <source>KeepTerminator &lt;code&gt;keepTerminator&lt;/code&gt;</source>
          <target state="translated">KeepTerminator &lt;code&gt;keepTerminator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b4ac1ddd1c0236182fe28a432626c97133b74ac" translate="yes" xml:space="preserve">
          <source>Kenji Hara</source>
          <target state="translated">Kenji Hara</target>
        </trans-unit>
        <trans-unit id="74687127fcc3dc7bb5e761b8900f3a700141e5bf" translate="yes" xml:space="preserve">
          <source>KeyType</source>
          <target state="translated">KeyType</target>
        </trans-unit>
        <trans-unit id="1d89254a2bc78c1ff41c2f6767a0e00ee126b3bf" translate="yes" xml:space="preserve">
          <source>KeyValuePairs</source>
          <target state="translated">KeyValuePairs</target>
        </trans-unit>
        <trans-unit id="729e53c8eb86a949f666878c598d23f93a3545d7" translate="yes" xml:space="preserve">
          <source>Keys &lt;code&gt;keys&lt;/code&gt;</source>
          <target state="translated">按键 &lt;code&gt;keys&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26f0271fc4a5ffcc2bb5f4dbe3a1fa04013275ee" translate="yes" xml:space="preserve">
          <source>Keys are implementation defined, allowing relevant data for exotic targets. A reliable subset exists which are always available:</source>
          <target state="translated">钥匙是执行时定义的,允许为外来目标提供相关数据。有一个可靠的子集,可以随时使用。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="0abd7895cc895899e75b610526a33fbc51c32818" translate="yes" xml:space="preserve">
          <source>Keywords are reserved identifiers.</source>
          <target state="translated">关键词是保留的标识符。</target>
        </trans-unit>
        <trans-unit id="b6336831bbeb983ca82f9d4a77612af9bca7a91d" translate="yes" xml:space="preserve">
          <source>Kharoshthi</source>
          <target state="translated">Kharoshthi</target>
        </trans-unit>
        <trans-unit id="3db4bac2e32c1fd4c51c4ffc01f1ab523d35aa5f" translate="yes" xml:space="preserve">
          <source>Khmer</source>
          <target state="translated">Khmer</target>
        </trans-unit>
        <trans-unit id="8518bf9eb37b463a80281371ecf2cd1e0405096e" translate="yes" xml:space="preserve">
          <source>Khmer Symbols</source>
          <target state="translated">高棉符号</target>
        </trans-unit>
        <trans-unit id="1f207bb143ebf53a96f07da496ea625fd1ed3952" translate="yes" xml:space="preserve">
          <source>Kinds</source>
          <target state="translated">Kinds</target>
        </trans-unit>
        <trans-unit id="e86af5625d0fba3382c4196e55640871e3d19f3f" translate="yes" xml:space="preserve">
          <source>Kinds of Arrays</source>
          <target state="translated">阵列的种类</target>
        </trans-unit>
        <trans-unit id="63244e6f2aedb0bb8ad7366c81f1da96cdb83a3b" translate="yes" xml:space="preserve">
          <source>Klass</source>
          <target state="translated">Klass</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="a10f36f142913e26ae0e6f93a728d8bb0b212cf5" translate="yes" xml:space="preserve">
          <source>L &lt;code&gt;lhs&lt;/code&gt;</source>
          <target state="translated">大号 &lt;code&gt;lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f01127b628fe96840398c36b4cd22d12c73d39f" translate="yes" xml:space="preserve">
          <source>LDC (LLVM D Compiler) is the compiler</source>
          <target state="translated">LDC(LLVM D Compiler)是一种编译器。</target>
        </trans-unit>
        <trans-unit id="e59266bac956daa5032ba200109e96e1c5b1a2c0" translate="yes" xml:space="preserve">
          <source>LIBCURL_VERSION</source>
          <target state="translated">LIBCURL_VERSION</target>
        </trans-unit>
        <trans-unit id="ae21ee5993e6bb593834d6149c93b819f0663a8b" translate="yes" xml:space="preserve">
          <source>LIBCURL_VERSION_NUM</source>
          <target state="translated">LIBCURL_VERSION_NUM</target>
        </trans-unit>
        <trans-unit id="71ca01cf1a00a026c01e4f77e52bb217888eded6" translate="yes" xml:space="preserve">
          <source>LINK &lt;strong id=&quot;systemLinkage&quot;&gt;systemLinkage&lt;/strong&gt;();</source>
          <target state="translated">LINK &lt;strong id=&quot;systemLinkage&quot;&gt;systemLinkage&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="52700257cb800485676caed33f23e22b22745155" translate="yes" xml:space="preserve">
          <source>LLVM D Compiler (LDC)</source>
          <target state="translated">LLVM D编译器(LDC)</target>
        </trans-unit>
        <trans-unit id="447562b9012012a2aca5d204bad70095bfe8f420" translate="yes" xml:space="preserve">
          <source>LOOSE</source>
          <target state="translated">LOOSE</target>
        </trans-unit>
        <trans-unit id="a09b13dff976fe20f239fab7a59a35bde98835e6" translate="yes" xml:space="preserve">
          <source>LV</source>
          <target state="translated">LV</target>
        </trans-unit>
        <trans-unit id="33b636a601b7a02911b25e76cda4a549a1d9ebd1" translate="yes" xml:space="preserve">
          <source>LVT</source>
          <target state="translated">LVT</target>
        </trans-unit>
        <trans-unit id="15d9300627a09b46f74a6b87395d2a7f3411cc88" translate="yes" xml:space="preserve">
          <source>LVT_Syllable</source>
          <target state="translated">LVT_Syllable</target>
        </trans-unit>
        <trans-unit id="2cfbfa4fc186833e1d17b39a6ed4758a215c22ac" translate="yes" xml:space="preserve">
          <source>LV_Syllable</source>
          <target state="translated">LV_Syllable</target>
        </trans-unit>
        <trans-unit id="ba218d1261bfead2f97e926079c3ae7568071bf0" translate="yes" xml:space="preserve">
          <source>Label* &lt;code&gt;label&lt;/code&gt;</source>
          <target state="translated">标签* &lt;code&gt;label&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b86e48b918e6b8af7eaccee49db2cecb08b3997" translate="yes" xml:space="preserve">
          <source>Label** &lt;strong id=&quot;lookupLabel&quot;&gt;lookupLabel&lt;/strong&gt;(Statement s);</source>
          <target state="translated">标签** &lt;strong id=&quot;lookupLabel&quot;&gt;lookupLabel&lt;/strong&gt;（声明s）；</target>
        </trans-unit>
        <trans-unit id="2fc1ef0d8a8c6fb5a183e6dd4055bf2e2a000b0f" translate="yes" xml:space="preserve">
          <source>LabelDsymbol &lt;strong id=&quot;returnLabel&quot;&gt;returnLabel&lt;/strong&gt;;</source>
          <target state="translated">LabelDsymbol &lt;strong id=&quot;returnLabel&quot;&gt;returnLabel&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="57a27a2a11471faebdb082dca955aba4bf532df9" translate="yes" xml:space="preserve">
          <source>Labeled Statements</source>
          <target state="translated">标记的声明</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="55e451de0e70b249932cac7139c9b15e9f160538" translate="yes" xml:space="preserve">
          <source>Labels are in a name space independent of declarations, variables, types, etc. Even so, labels cannot have the same name as local declarations. The label name space is the body of the function they appear in. Label name spaces do not nest, i.e. a label inside a block statement is accessible from outside that block.</source>
          <target state="translated">标签在名称空间中与声明、变量、类型等无关。即便如此,标签也不能与本地声明同名。标签名称空间是它们出现的函数的主体。标签名空间不嵌套,即一个块语句内的标签可以从该块外部访问。</target>
        </trans-unit>
        <trans-unit id="8a1475fce73eed0441ef9a6cf5dea0d92a68de5f" translate="yes" xml:space="preserve">
          <source>Labels are in a separate scope, one per function.</source>
          <target state="translated">标签在一个单独的范围内,每个函数一个。</target>
        </trans-unit>
        <trans-unit id="ab80f546ab7aedd542b6f7cf9ec336e3c5a2f337" translate="yes" xml:space="preserve">
          <source>Labels in one function cannot be referenced from another function.</source>
          <target state="translated">一个函数中的标签不能从另一个函数中引用。</target>
        </trans-unit>
        <trans-unit id="1a3a859b8543db93b9d21e22a679ffb2ca537eef" translate="yes" xml:space="preserve">
          <source>Laboriously construct a C wrapper around the C++ code.</source>
          <target state="translated">费力地在C++代码周围构造一个C包装器。</target>
        </trans-unit>
        <trans-unit id="cab09d9adb98c17169fd258e9b9f83a3876c4fd1" translate="yes" xml:space="preserve">
          <source>Lambda</source>
          <target state="translated">Lambda</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="d0a6871f11875319701fa244442052fe3b8ba59b" translate="yes" xml:space="preserve">
          <source>Language changes listed by -revert</source>
          <target state="translated">按-revert列出的语言变化</target>
        </trans-unit>
        <trans-unit id="1086e1889ddc903c34fd68e5851b7ef08f6a0c1a" translate="yes" xml:space="preserve">
          <source>Language changes listed by -transition=id</source>
          <target state="translated">按-transition=id列出的语言变化。</target>
        </trans-unit>
        <trans-unit id="489e3618a7be2c6a60858c53fd8bf2fdf36a41ff" translate="yes" xml:space="preserve">
          <source>Language previews listed by -preview</source>
          <target state="translated">按-preview列出的语言预览</target>
        </trans-unit>
        <trans-unit id="c1439807deac3e6c9290cfd97415a4b15f4ba6c8" translate="yes" xml:space="preserve">
          <source>Lao</source>
          <target state="translated">Lao</target>
        </trans-unit>
        <trans-unit id="4ff311dd115963220443dbbe7f3cdc78b24cc17c" translate="yes" xml:space="preserve">
          <source>Largest &lt;code&gt;Duration&lt;/code&gt; possible.</source>
          <target state="translated">可能的最大 &lt;code&gt;Duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="441940b44967219249673ac5a62264158b9767e7" translate="yes" xml:space="preserve">
          <source>Largest &lt;code&gt;MonoTime&lt;/code&gt; possible.</source>
          <target state="translated">可能的最大 &lt;code&gt;MonoTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="775739b719ae1c33d45f0da7e4f74abc764e3ce2" translate="yes" xml:space="preserve">
          <source>Largest &lt;code&gt;TickDuration&lt;/code&gt; possible.</source>
          <target state="translated">最大可能的 &lt;code&gt;TickDuration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b80bfda35a980fed60097a392642bb35e7679260" translate="yes" xml:space="preserve">
          <source>Largest DBCONFIG</source>
          <target state="translated">最大的DBCONFIG</target>
        </trans-unit>
        <trans-unit id="2699f309b0e83a90516b2f64196c054cec645528" translate="yes" xml:space="preserve">
          <source>Largest TESTCTRL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9729c92038f752df4b88f1ce2cbf7fb4e98a3ff" translate="yes" xml:space="preserve">
          <source>Largest defined DBSTATUS</source>
          <target state="translated">最大的定义DBSTATUS</target>
        </trans-unit>
        <trans-unit id="4c5c4d623a7cc3fc731087c84c38ecf11ad36ff3" translate="yes" xml:space="preserve">
          <source>Largest enum member value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143fb511beaf582b174d9c4ff5835a52b94bef09" translate="yes" xml:space="preserve">
          <source>Largest generated value.</source>
          <target state="translated">产生的最大价值。</target>
        </trans-unit>
        <trans-unit id="031d120afc0f880f2e336a65b6264b1061756f53" translate="yes" xml:space="preserve">
          <source>Largest value of enum</source>
          <target state="translated">最大的枚举值</target>
        </trans-unit>
        <trans-unit id="5e59d0b67e13689490707955441acfa15678fa32" translate="yes" xml:space="preserve">
          <source>Lars Tandle Kyllingstad, &lt;a href=&quot;http://digitalmars.com&quot;&gt;Walter Bright&lt;/a&gt;, Grzegorz Adam Hankiewicz, Thomas K&amp;uuml;hne, &lt;a href=&quot;http://erdani.org&quot;&gt;Andrei Alexandrescu&lt;/a&gt;</source>
          <target state="translated">Lars Tandle Kyllingstad，&lt;a href=&quot;http://digitalmars.com&quot;&gt;Walter Bright&lt;/a&gt;，Grzegorz Adam Hankiewicz，ThomasK&amp;uuml;hne，&lt;a href=&quot;http://erdani.org&quot;&gt;Andrei Alexandrescu&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e48d65b433854a00aa3b58538c5d44f7ce276d66" translate="yes" xml:space="preserve">
          <source>Lars Tandle Kyllingstad, Don Clugston</source>
          <target state="translated">Lars Tandle Kyllingstad,Don Clugston.</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">最后一次插入Rowid</target>
        </trans-unit>
        <trans-unit id="0763072f970fe33cb40f56a506a18430c6e430bb" translate="yes" xml:space="preserve">
          <source>Last but not least, a desired string sorting order differs by culture and language and is usually nothing like code point for code point comparison. The natural order of strings is obtained by applying &lt;a href=&quot;http://www.unicode.org/reports/tr10/&quot;&gt;the Unicode collation algorithm&lt;/a&gt; that should be implemented in the standard library.</source>
          <target state="translated">最后但并非最不重要的一点是，所需的字符串排序顺序因文化和语言而异，通常与用于代码点比较的代码点不同。字符串的自然顺序是通过应用应在标准库中实现&lt;a href=&quot;http://www.unicode.org/reports/tr10/&quot;&gt;的Unicode排序规则算法&lt;/a&gt;获得的。</target>
        </trans-unit>
        <trans-unit id="cc6d1acb7397d0e5f9098c07f2c7d3aac9936d0e" translate="yes" xml:space="preserve">
          <source>LastExp</source>
          <target state="translated">LastExp</target>
        </trans-unit>
        <trans-unit id="e376b71fe7dd3dc385eba80f693a4c2924d5853c" translate="yes" xml:space="preserve">
          <source>Lastly, &lt;code&gt;x&lt;/code&gt; is set to &lt;code&gt;null&lt;/code&gt;. Any attempt to read or write the freed memory via other references will result in undefined behavior.</source>
          <target state="translated">最后， &lt;code&gt;x&lt;/code&gt; 设置为 &lt;code&gt;null&lt;/code&gt; 。通过其他引用读取或写入释放的内存的任何尝试都将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="9bde795b72be44b343c829314d764282997de688" translate="yes" xml:space="preserve">
          <source>Latin</source>
          <target state="translated">Latin</target>
        </trans-unit>
        <trans-unit id="82571d399af24c495758fdf2aafee5df861943f9" translate="yes" xml:space="preserve">
          <source>Latin Extended Additional</source>
          <target state="translated">拉丁语扩展版</target>
        </trans-unit>
        <trans-unit id="76afa1e916dcce2f445fbbe44abc694adfadc217" translate="yes" xml:space="preserve">
          <source>Latin Extended-A</source>
          <target state="translated">拉丁语扩展-A</target>
        </trans-unit>
        <trans-unit id="c4bc78ee217699a4bb7436be239e087264930a51" translate="yes" xml:space="preserve">
          <source>Latin Extended-B</source>
          <target state="translated">拉丁语扩展B</target>
        </trans-unit>
        <trans-unit id="204b4ebb9b53ee3348fc9e967c0acfd748bea9b0" translate="yes" xml:space="preserve">
          <source>Latin Extended-C</source>
          <target state="translated">拉丁语扩展C</target>
        </trans-unit>
        <trans-unit id="fbd8786d3fb197f080f06774e92557923807eec5" translate="yes" xml:space="preserve">
          <source>Latin Extended-D</source>
          <target state="translated">拉丁语扩展D</target>
        </trans-unit>
        <trans-unit id="7f209e08d16789fe763be5b66fed5e229156bc03" translate="yes" xml:space="preserve">
          <source>Latin-1 (ISO-8859-1) Entities</source>
          <target state="translated">拉丁文-1(ISO-8859-1)实体。</target>
        </trans-unit>
        <trans-unit id="f76f4a63a6de1f8fde56d0d52b8de3cc7681c7c6" translate="yes" xml:space="preserve">
          <source>Latin-1 Supplement</source>
          <target state="translated">拉丁文-1号补编</target>
        </trans-unit>
        <trans-unit id="ee2650a3acdca161fdd647691bd5c1914bdc316d" translate="yes" xml:space="preserve">
          <source>Layered Structure</source>
          <target state="translated">分层结构</target>
        </trans-unit>
        <trans-unit id="bfa939b4bde1628cdf49d14c2332ebb064d40ef2" translate="yes" xml:space="preserve">
          <source>Lazily computes all permutations of &lt;code&gt;r&lt;/code&gt; using &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap%27s_algorithm&quot;&gt;Heap's algorithm&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Heap%27s_algorithm&quot;&gt;Heap算法&lt;/a&gt;懒惰地计算 &lt;code&gt;r&lt;/code&gt; 的所有置换。</target>
        </trans-unit>
        <trans-unit id="7e2c1f0beaadd3254feecabea06e88d4b79b02dc" translate="yes" xml:space="preserve">
          <source>Lazily computes all permutations using Heap's algorithm.</source>
          <target state="translated">使用Heap的算法懒惰地计算所有的排列组合。</target>
        </trans-unit>
        <trans-unit id="107096b86eaeda16b3e3830aeea022c0ee83280a" translate="yes" xml:space="preserve">
          <source>Lazily computes the Cartesian product of two or more ranges. The product is a range of tuples of elements from each respective range.</source>
          <target state="translated">懒惰地计算两个或多个范围的笛卡尔积。乘积是每个范围内元素的元组范围。</target>
        </trans-unit>
        <trans-unit id="5ccd41e6fdf7bb2cc2caeff24d6524d188618f62" translate="yes" xml:space="preserve">
          <source>Lazily computes the difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt;. The two ranges are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. The element types of the two ranges must have a common type.</source>
          <target state="translated">延迟计算 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 之差。假定两个范围按 &lt;code&gt;less&lt;/code&gt; 排序。两个范围的元素类型必须具有共同的类型。</target>
        </trans-unit>
        <trans-unit id="11620253bf7b271db7d14cf8cdf8bc0f4e54e75c" translate="yes" xml:space="preserve">
          <source>Lazily computes the intersection of two or more &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input ranges&lt;/a&gt;&lt;code&gt;ranges&lt;/code&gt;. The ranges are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. The element types of the ranges must have a common type.</source>
          <target state="translated">惰性计算两个或多个&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt; &lt;code&gt;ranges&lt;/code&gt; 的交集。假定范围按 &lt;code&gt;less&lt;/code&gt; 排序。范围的元素类型必须具有公共类型。</target>
        </trans-unit>
        <trans-unit id="bcbe3c8fe89d00240758248fe29948f389fe9d2c" translate="yes" xml:space="preserve">
          <source>Lazily computes the intersection of two or more sorted ranges.</source>
          <target state="translated">懒惰地计算两个或多个排序范围的交点。</target>
        </trans-unit>
        <trans-unit id="e56317731f2e65960db359b60cd199fb81c6c36a" translate="yes" xml:space="preserve">
          <source>Lazily computes the set difference of two or more sorted ranges.</source>
          <target state="translated">懒惰地计算两个或多个排序范围的集合差。</target>
        </trans-unit>
        <trans-unit id="a7dc174d1b393408f652f2ee4cdbe7ec73d58a98" translate="yes" xml:space="preserve">
          <source>Lazily computes the symmetric difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt;, i.e. the elements that are present in exactly one of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt;. The two ranges are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;, and the output is also sorted by &lt;code&gt;less&lt;/code&gt;. The element types of the two ranges must have a common type.</source>
          <target state="translated">懒惰地计算的对称差 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; ，即，存在于中的恰好一个要素 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 。假定这两个范围按 &lt;code&gt;less&lt;/code&gt; 排序，并且输出也按 &lt;code&gt;less&lt;/code&gt; 排序。两个范围的元素类型必须具有共同的类型。</target>
        </trans-unit>
        <trans-unit id="0a833e31b29c15d5d10ff03efb2b971994c72b99" translate="yes" xml:space="preserve">
          <source>Lazily computes the symmetric set difference of two or more sorted ranges.</source>
          <target state="translated">懒惰地计算两个或多个排序范围的对称集差。</target>
        </trans-unit>
        <trans-unit id="f5e63bd3d07f55a5748e5c534c9595eca39053b0" translate="yes" xml:space="preserve">
          <source>Lazily generate identifier for template instance. This is because 75% of the ident's are never needed.</source>
          <target state="translated">懒得为模板实例生成标识符。这是因为75%的标识符是永远不需要的。</target>
        </trans-unit>
        <trans-unit id="3bb485042cec806e50ef44dfce159b1476065631" translate="yes" xml:space="preserve">
          <source>Lazily initializes the scope to forward to.</source>
          <target state="translated">懒惰地初始化要转发的作用域。</target>
        </trans-unit>
        <trans-unit id="a262d4d77393c41d08604edd8fd36f4b129d8a3e" translate="yes" xml:space="preserve">
          <source>Lazily iterates &lt;code&gt;range&lt;/code&gt; until the element &lt;code&gt;e&lt;/code&gt; for which &lt;code&gt;pred(e, sentinel)&lt;/code&gt; is true.</source>
          <target state="translated">懒惰地迭代 &lt;code&gt;range&lt;/code&gt; 直到 &lt;code&gt;pred(e, sentinel)&lt;/code&gt; 的元素 &lt;code&gt;e&lt;/code&gt; 为真。</target>
        </trans-unit>
        <trans-unit id="37fa2575de04d25ca5f4a9acbfb7307d51258f3c" translate="yes" xml:space="preserve">
          <source>Lazily iterates a range until a specific value is found.</source>
          <target state="translated">懒惰地迭代一个范围,直到找到一个特定的值。</target>
        </trans-unit>
        <trans-unit id="855e8fb90512662d24bc8780e84a525e1cbb91c5" translate="yes" xml:space="preserve">
          <source>Lazily iterates unique consecutive elements of the given range (functionality akin to the &lt;a href=&quot;http://wikipedia.org/wiki/Uniq&quot;&gt;uniq&lt;/a&gt; system utility). Equivalence of elements is assessed by using the predicate &lt;code&gt;pred&lt;/code&gt;, by default &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;. If the given range is bidirectional, &lt;code&gt;uniq&lt;/code&gt; also yields a &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt;.</source>
          <target state="translated">懒惰地迭代给定范围内的唯一连续元素（功能类似于&lt;a href=&quot;http://wikipedia.org/wiki/Uniq&quot;&gt;uniq&lt;/a&gt;系统实用程序）。元素的等效性通过使用谓词 &lt;code&gt;pred&lt;/code&gt; 来评估，默认情况下为 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 。谓词传递给&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;，可以接受字符串，也可以通过 &lt;code&gt;pred(element, element)&lt;/code&gt; 执行的任何可调用对象。如果给定范围是双向的，则 &lt;code&gt;uniq&lt;/code&gt; 也会产生&lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;双向范围&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dcd4c05189e44a024d61096cebf8a9000f337938" translate="yes" xml:space="preserve">
          <source>Lazily joins a range of ranges with a separator. The separator itself is a range. If a separator is not provided, then the ranges are joined directly without anything in between them (often called &lt;code&gt;flatten&lt;/code&gt; in other languages).</source>
          <target state="translated">懒惰地使用分隔符将一系列范围合并在一起。分隔符本身是一个范围。如果未提供分隔符，则范围将直接连接在一起，而在它们之间不包含任何内容（在其他语言中通常称为 &lt;code&gt;flatten&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="78adbed58b69c14bab88204b103552a98acd8b88" translate="yes" xml:space="preserve">
          <source>Lazily merges two or more sorted ranges.</source>
          <target state="translated">懒惰地合并两个或多个排序范围。</target>
        </trans-unit>
        <trans-unit id="3f0c45896cd5857d56956a33e01c9a444f7528d6" translate="yes" xml:space="preserve">
          <source>Lazily pads a range to a specified length by adding a given element to the back of the range.</source>
          <target state="translated">通过在范围的后面添加一个给定的元素,将一个范围懒散地垫到一个指定的长度。</target>
        </trans-unit>
        <trans-unit id="f494ee73f56475d2a1f3930ddb0e80428caf8a76" translate="yes" xml:space="preserve">
          <source>Lazily splits a range by a separator.</source>
          <target state="translated">懒洋洋地用分离器分割了一个范围。</target>
        </trans-unit>
        <trans-unit id="c63f40da4727f29b6b1fb052d750dd95793056b6" translate="yes" xml:space="preserve">
          <source>Lazily splits a range using an element or range as a separator. Separator ranges can be any narrow string type or sliceable range type.</source>
          <target state="translated">使用一个元素或范围作为分离器懒散地分割一个范围。分隔符范围可以是任何狭窄的字符串类型或可分片的范围类型。</target>
        </trans-unit>
        <trans-unit id="3ccf00e916575e9b3f08279417e858a27e23af9d" translate="yes" xml:space="preserve">
          <source>Lazily splits the character-based range &lt;code&gt;s&lt;/code&gt; into words, using whitespace as the delimiter.</source>
          <target state="translated">使用空格作为分隔符，将基于字符的范围 &lt;code&gt;s&lt;/code&gt; 懒惰地拆分为单词。</target>
        </trans-unit>
        <trans-unit id="3389a918428772f39da31b4076e337a04baf8333" translate="yes" xml:space="preserve">
          <source>Lazily takes only up to &lt;code&gt;n&lt;/code&gt; elements of a range. This is particularly useful when using with infinite ranges.</source>
          <target state="translated">懒惰地只接受范围中的 &lt;code&gt;n&lt;/code&gt; 个元素。在无限范围内使用时，这特别有用。</target>
        </trans-unit>
        <trans-unit id="36687985b7156a39c23148c62ffcfbac01df34ce" translate="yes" xml:space="preserve">
          <source>Lazily transform a range of &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;s to a range of code points.</source>
          <target state="translated">懒惰地变换的范围内&lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; s到的范围内的代码点。</target>
        </trans-unit>
        <trans-unit id="bd36508e59e756caeb78e5c935ff99c61bf50c57" translate="yes" xml:space="preserve">
          <source>Lazy Parameters</source>
          <target state="translated">懒惰参数</target>
        </trans-unit>
        <trans-unit id="9e98a803d8a3de17d9dde40743f7d0b0ef000790" translate="yes" xml:space="preserve">
          <source>Lazy Variadic Functions</source>
          <target state="translated">懒惰变函数</target>
        </trans-unit>
        <trans-unit id="4ee0307b3a4c3fedfc4c2c80cb3303a1c9f1efd0" translate="yes" xml:space="preserve">
          <source>Lazy decode</source>
          <target state="translated">懒人解码</target>
        </trans-unit>
        <trans-unit id="7734c6545eb4a90529d63e3a31cfe3c2fc1ac09d" translate="yes" xml:space="preserve">
          <source>Lazy parameters are currently, too restrictively, inferred by DMD to always throw even though they don't need to be. This makes it impossible to currently mark &lt;code&gt;either&lt;/code&gt; as &lt;code&gt;nothrow&lt;/code&gt;. See issue at &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=12647&quot;&gt;Bugzilla 12647&lt;/a&gt;.</source>
          <target state="translated">目前，DMD过于严格地限制了惰性参数，即使它们不是必需的，它们也总是抛出异常。这使得当前无法将 &lt;code&gt;either&lt;/code&gt; 标记为 &lt;code&gt;nothrow&lt;/code&gt; 。参见&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=12647&quot;&gt;Bugzilla 12647上的&lt;/a&gt;问题。</target>
        </trans-unit>
        <trans-unit id="f441e891a2a053fe381539b6eb7726b9bda63c2c" translate="yes" xml:space="preserve">
          <source>Lazy parameters are not considered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071289bb363736afa36a31dce99701fd42dd4a6b" translate="yes" xml:space="preserve">
          <source>Lazy range which is the concatenation of r1, r2 and ranges with path separators. The resulting element type is that of r1.</source>
          <target state="translated">懒惰范围是r1、r2和带路径分隔符的范围的连接。由此产生的元素类型是r1的类型。</target>
        </trans-unit>
        <trans-unit id="de2d83046e13537c5df1729e5a3946298fa16c44" translate="yes" xml:space="preserve">
          <source>Leading separators, trailing separators, or no separators.</source>
          <target state="translated">领先分离器、尾随分离器或无分离器。</target>
        </trans-unit>
        <trans-unit id="38895ec4492ad75a4a86c9ace4229f7786f0b3e2" translate="yes" xml:space="preserve">
          <source>Leading_Jamo</source>
          <target state="translated">Leading_Jamo</target>
        </trans-unit>
        <trans-unit id="fd94160d0aa2ea752c72468cd1b2add9485192dc" translate="yes" xml:space="preserve">
          <source>Leaving a pointer to it in the static data segment, as the garbage collector will scan the static data segment.</source>
          <target state="translated">在静态数据段中留下一个指向它的指针,因为垃圾收集器会扫描静态数据段。</target>
        </trans-unit>
        <trans-unit id="cfc4be551f2905e6978237e7d77f437233291957" translate="yes" xml:space="preserve">
          <source>Leaving a pointer to it on the stack (as a parameter or automatic variable), as the garbage collector will scan the stack.</source>
          <target state="translated">在堆栈上留下一个指向它的指针(作为参数或自动变量),因为垃圾收集器会扫描堆栈。</target>
        </trans-unit>
        <trans-unit id="378514d607275e8ee888d65cae8f24d7c6f45b02" translate="yes" xml:space="preserve">
          <source>Left bound of initial range of &lt;code&gt;f&lt;/code&gt; known to contain the root.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 的初始范围的左边界，已知包含根。</target>
        </trans-unit>
        <trans-unit id="bfaa1709061a514729de6e5c8f858f0bf2d27571" translate="yes" xml:space="preserve">
          <source>Left bound of initial range of f known to contain the minimum.</source>
          <target state="translated">已知f的初始范围的左界包含最小值。</target>
        </trans-unit>
        <trans-unit id="7a57a5cca8f620ef653afa4677312603d0eb35a4" translate="yes" xml:space="preserve">
          <source>Left justify &lt;code&gt;s&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;s&lt;/code&gt; doesn't fill.</source>
          <target state="translated">在字段 &lt;code&gt;width&lt;/code&gt; 字符中左对齐 &lt;code&gt;s&lt;/code&gt; 。 &lt;code&gt;fillChar&lt;/code&gt; 是将用于填充 &lt;code&gt;s&lt;/code&gt; 不会填充的字段中的字符的字符。</target>
        </trans-unit>
        <trans-unit id="e252b9f8988cde95614457fcc99883dd09f1324a" translate="yes" xml:space="preserve">
          <source>Left justify the result in the field. It overrides any 0 flag.</source>
          <target state="translated">左边的结果在字段中是合理的。它覆盖任何0标志。</target>
        </trans-unit>
        <trans-unit id="bf867e91cd944e7c2c4d6696d9a4bdcaa30b2078" translate="yes" xml:space="preserve">
          <source>Legacy module unit test handler</source>
          <target state="translated">遗留模块单元测试处理程序</target>
        </trans-unit>
        <trans-unit id="71c39ee5d287555af96dcd575a5c855e58330dd8" translate="yes" xml:space="preserve">
          <source>Lego-like pieces that can be used to assemble application-specific allocators. The real allocation smarts are occurring at this level. This layer is of interest to advanced applications that want to configure their own allocators. A good illustration of typical uses of these building blocks is module &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt;&lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt;&lt;/a&gt; which defines a collection of frequently- used preassembled allocator objects. The implementation and documentation entry point is &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;. By design, the primitives of the static interface have the same signatures as the &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt; primitives but are for the most part optional and driven by static introspection. The parameterized class &lt;a href=&quot;#CAllocatorImpl&quot;&gt;&lt;code&gt;CAllocatorImpl&lt;/code&gt;&lt;/a&gt; offers an immediate and useful means to package a static low-level allocator into an implementation of &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类似于乐高的零件，可用于组装特定于应用程序的分配器。真正的分配智能正在此级别上发生。该层对于想要配置自己的分配器的高级应用程序很重要。这些模块的典型用法的一个很好的例子是&lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt; &lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt; &lt;/a&gt;模块，该模块定义了一些常用的预组装分配器对象的集合。实现和文档入口点是&lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; &lt;/a&gt;。通过设计，静态接口的基元与&lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; &lt;/a&gt;基元具有相同的签名，但是在大多数情况下是可选的，并由静态自省驱动。参数化的类&lt;a href=&quot;#CAllocatorImpl&quot;&gt; &lt;code&gt;CAllocatorImpl&lt;/code&gt; &lt;/a&gt;提供了一种直接且有用的方法，将静态低级分配器打包到&lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; &lt;/a&gt;的实现中。</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="548a74b725f624c9fdb6b48fe948844ad4ba15cf" translate="yes" xml:space="preserve">
          <source>Length &amp;amp; Index</source>
          <target state="translated">长度和指数</target>
        </trans-unit>
        <trans-unit id="a8a261464d376ab7ec4d0aff6dd2a8ddccaf2ea4" translate="yes" xml:space="preserve">
          <source>Length of the source array.</source>
          <target state="translated">源数组的长度。</target>
        </trans-unit>
        <trans-unit id="fa58f0cd5f0d162bcdd0bb8e1a9f9fab638355f0" translate="yes" xml:space="preserve">
          <source>Length. Only if &lt;code&gt;hasLength!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">长度。仅当 &lt;code&gt;hasLength!Source&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时</target>
        </trans-unit>
        <trans-unit id="2932c65a2b38d62eb561a2ad9e13e95ab6d5d8aa" translate="yes" xml:space="preserve">
          <source>Lepcha</source>
          <target state="translated">Lepcha</target>
        </trans-unit>
        <trans-unit id="89c036bdcb0bbedc59d932a4fa7bc23acfe0d446" translate="yes" xml:space="preserve">
          <source>Let the application define a custom write method for RTP data</source>
          <target state="translated">让应用程序为RTP数据定义一个自定义的写法。</target>
        </trans-unit>
        <trans-unit id="937ea74e8f69c6f2d7124bc18246f8a660b1dec7" translate="yes" xml:space="preserve">
          <source>Let the application define custom chunk data pointer</source>
          <target state="translated">让应用程序定义自定义的分块数据指针。</target>
        </trans-unit>
        <trans-unit id="5e0bcf64b358e91eb969a7948fad248efcb9751a" translate="yes" xml:space="preserve">
          <source>Let the server initiate the shutdown</source>
          <target state="translated">让服务器启动关机</target>
        </trans-unit>
        <trans-unit id="a89a34ec4663e88cca1a7e3de00a3e3430d08014" translate="yes" xml:space="preserve">
          <source>Let's consider the file is ASCII encoded with LF EOL. In general case we should use</source>
          <target state="translated">让我们考虑一下文件是用LF EOL编码的ASCII码。在一般情况下,我们应该使用</target>
        </trans-unit>
        <trans-unit id="d07a72b4d32963582b6eae7916f61a4b8e60a331" translate="yes" xml:space="preserve">
          <source>Let's first make some observations and assumptions about errors:</source>
          <target state="translated">我们先对误差做一些观察和假设。</target>
        </trans-unit>
        <trans-unit id="ee14050617b7b58e17aabccd61c241ccdafc6379" translate="yes" xml:space="preserve">
          <source>Letter</source>
          <target state="translated">Letter</target>
        </trans-unit>
        <trans-unit id="9396bf9200a37a33be1f189b9b3f63cbfdb0cb05" translate="yes" xml:space="preserve">
          <source>Letter case specifier.</source>
          <target state="translated">字母大小写指定器。</target>
        </trans-unit>
        <trans-unit id="8ec2ddae534f2e9f786626d1461f045b3ea7a132" translate="yes" xml:space="preserve">
          <source>Letter_Number</source>
          <target state="translated">Letter_Number</target>
        </trans-unit>
        <trans-unit id="cfcd1e23ef9e122ab3fba825014a84415f49edb0" translate="yes" xml:space="preserve">
          <source>Letterlike Symbols</source>
          <target state="translated">字母状符号</target>
        </trans-unit>
        <trans-unit id="4ed7dbd610162ec2a8bbd97befecda7912a54468" translate="yes" xml:space="preserve">
          <source>Level 1 is fastest and the most memory hungry (a bit array).</source>
          <target state="translated">第1级是最快的,也是最耗内存的(一个位数组)。</target>
        </trans-unit>
        <trans-unit id="fc694144a5b7ef693cb1ee99fd99fa168f951953" translate="yes" xml:space="preserve">
          <source>Level 4 is the slowest and has the smallest footprint.</source>
          <target state="translated">4级是最慢的,占地面积最小。</target>
        </trans-unit>
        <trans-unit id="75bac2861cadd9b0f5864b4833944f933a0bf887" translate="yes" xml:space="preserve">
          <source>Level 4 stays very practical (being faster and more predictable) compared to using direct lookup on the &lt;code&gt;set&lt;/code&gt; itself.</source>
          <target state="translated">与在 &lt;code&gt;set&lt;/code&gt; 本身上使用直接查找相比，级别4保持非常实用（更快，更可预测）。</target>
        </trans-unit>
        <trans-unit id="8ad20abdb83c4a21d224a891c2b7c7c494f6fcf2" translate="yes" xml:space="preserve">
          <source>Lexical</source>
          <target state="translated">Lexical</target>
        </trans-unit>
        <trans-unit id="476ef6248b6dd64f9ad5670dee5d53dccca0f8e8" translate="yes" xml:space="preserve">
          <source>Lexical - documentation comments are identified and attached to tokens.</source>
          <target state="translated">词性--文件注释被识别并附在代币上。</target>
        </trans-unit>
        <trans-unit id="b605249a5e48b6c693e6ec1b2b1e13428184994b" translate="yes" xml:space="preserve">
          <source>Lexical Syntax</source>
          <target state="translated">词法</target>
        </trans-unit>
        <trans-unit id="6b297fc7c475ea0278237a59c66e5996eac30867" translate="yes" xml:space="preserve">
          <source>Lhs</source>
          <target state="translated">Lhs</target>
        </trans-unit>
        <trans-unit id="fc8137f8a9e13c5b635a4ba40e4e3901d90fcbaa" translate="yes" xml:space="preserve">
          <source>Lhs &lt;code&gt;lhs&lt;/code&gt;</source>
          <target state="translated">LHS &lt;code&gt;lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bdc1af0abe67308adf385d7cdcceabf9cb6ab55" translate="yes" xml:space="preserve">
          <source>Lhs &lt;strong id=&quot;hookOpCast&quot;&gt;hookOpCast&lt;/strong&gt;(Lhs, Rhs)(Rhs rhs);</source>
          <target state="translated">Lhs &lt;strong id=&quot;hookOpCast&quot;&gt;hookOpCast&lt;/strong&gt;（Lhs，Rhs）（Rhs rhs）;</target>
        </trans-unit>
        <trans-unit id="e40077902f44f1b09ccb2459863a81b02022efb2" translate="yes" xml:space="preserve">
          <source>Lhs &lt;strong id=&quot;onLowerBound&quot;&gt;onLowerBound&lt;/strong&gt;(Rhs, T)(Rhs rhs, T bound);</source>
          <target state="translated">Lhs &lt;strong id=&quot;onLowerBound&quot;&gt;onLowerBound&lt;/strong&gt;（Rhs，T）（Rhs rhs，T bound）;</target>
        </trans-unit>
        <trans-unit id="df063bf53c8e8cb3fd9aa4249d1fa6357775527c" translate="yes" xml:space="preserve">
          <source>Library used incorrectly</source>
          <target state="translated">图书馆使用错误</target>
        </trans-unit>
        <trans-unit id="de13bf1ab0b419f34cb1b3b43e094c84009a42db" translate="yes" xml:space="preserve">
          <source>License:</source>
          <target state="translated">License:</target>
        </trans-unit>
        <trans-unit id="a50ab4cf4ccadacece6a685a96a8d2bf5b03f087" translate="yes" xml:space="preserve">
          <source>Licensed under the Boost License 1.0.</source>
          <target state="translated">根据Boost许可证1.0授权。</target>
        </trans-unit>
        <trans-unit id="ee1ab8e4255c8f881c480d8d54bca4a8a2c24209" translate="yes" xml:space="preserve">
          <source>Lifetime Management</source>
          <target state="translated">终身管理</target>
        </trans-unit>
        <trans-unit id="e353dd7cee6d59762b4ca39b60327e65283ae7b3" translate="yes" xml:space="preserve">
          <source>Lifetime of Temporaries</source>
          <target state="translated">临时人员的寿命</target>
        </trans-unit>
        <trans-unit id="ec6b2b953ecf8f329d7e04b783de42bfc3652a53" translate="yes" xml:space="preserve">
          <source>Lifetimes</source>
          <target state="translated">Lifetimes</target>
        </trans-unit>
        <trans-unit id="4d7185d6c7e3e5b1495e2c640489530ecb9b7900" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#ReplaceType&quot;&gt;&lt;code&gt;ReplaceType&lt;/code&gt;&lt;/a&gt;, but does not perform replacement in types for which &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#ReplaceType&quot;&gt; &lt;code&gt;ReplaceType&lt;/code&gt; 类似&lt;/a&gt;，但不会在 &lt;code&gt;pred&lt;/code&gt; 评估为 &lt;code&gt;true&lt;/code&gt; 的类型中执行替换。</target>
        </trans-unit>
        <trans-unit id="ae0e0fae4102ad20e6be08ef2f2f1156324f621f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#safe-functions&quot;&gt;safe functions&lt;/a&gt;, trusted functions have &lt;a href=&quot;#safe-interfaces&quot;&gt;safe interfaces&lt;/a&gt;. Unlike safe functions, this is not enforced by restrictions on the function body. Instead, it is the responsibility of the programmer to ensure that the interface of a trusted function is safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd33998b0ace4c944f0efc3096535b923482d5ba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#soundexer&quot;&gt;&lt;code&gt;soundexer&lt;/code&gt;&lt;/a&gt;, but with different parameters and return value.</source>
          <target state="translated">类似于&lt;a href=&quot;#soundexer&quot;&gt; &lt;code&gt;soundexer&lt;/code&gt; &lt;/a&gt;，但具有不同的参数和返回值。</target>
        </trans-unit>
        <trans-unit id="2606b35e5c6c0f3c9d736f7c373c8b55857520eb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;contains&lt;/code&gt;, but the value is specified before the range.</source>
          <target state="translated">与 &lt;code&gt;contains&lt;/code&gt; 相似，但该值在范围之前指定。</target>
        </trans-unit>
        <trans-unit id="2b288cc6cc51f7928ab9ad8fe1740aac1c58fab0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;isSorted&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;values&lt;/code&gt; are ordered according to the comparison operation &lt;code&gt;less&lt;/code&gt;. Unlike &lt;code&gt;isSorted&lt;/code&gt;, takes values directly instead of structured in a range.</source>
          <target state="translated">与 &lt;code&gt;isSorted&lt;/code&gt; 一样，如果给定 &lt;code&gt;values&lt;/code&gt; 根据 &lt;code&gt;less&lt;/code&gt; 操作进行排序，则返回 &lt;code&gt;true&lt;/code&gt; 。与 &lt;code&gt;isSorted&lt;/code&gt; 不同，它直接获取值，而不是在范围内进行结构化。</target>
        </trans-unit>
        <trans-unit id="50325585f34ee66ce178dbad88dde192b85ee604" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;take&lt;/code&gt;, but assumes the given range actually has</source>
          <target state="translated">类似于 &lt;code&gt;take&lt;/code&gt; ，但假设给定范围实际上具有</target>
        </trans-unit>
        <trans-unit id="e27a10d2aabce008faa1b8b7ac1f936d6cc25877" translate="yes" xml:space="preserve">
          <source>Like aggregates and functions, manifest constant and variable declarations can have template parameters, providing there is an &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdaeb1b36bc514e26a308358d8185b3a8585d1b" translate="yes" xml:space="preserve">
          <source>Like bodies of &lt;a href=&quot;#ConditionalDeclaration&quot;&gt;&lt;i&gt;ConditionalDeclaration&lt;/i&gt;&lt;/a&gt;s, a &lt;code&gt;static foreach&lt;/code&gt; body does not introduce a new scope. Therefore, it can be used to generate declarations:</source>
          <target state="translated">像&lt;a href=&quot;#ConditionalDeclaration&quot;&gt;&lt;i&gt;ConditionalDeclaration&lt;/i&gt;&lt;/a&gt;的主体一样， &lt;code&gt;static foreach&lt;/code&gt; 主体不会引入新的作用域。因此，它可用于生成声明：</target>
        </trans-unit>
        <trans-unit id="596f012fcab74c7f7a0fbb5751d3954bb4881d08" translate="yes" xml:space="preserve">
          <source>Like findBestMatch, iterate possible template candidates, but just looks only the necessity of type inference.</source>
          <target state="translated">像findBestMatch一样,迭代可能的模板候选者,但只是看类型推理的必要性。</target>
        </trans-unit>
        <trans-unit id="8d23b1454364b12f21ad47d5ebb3ea9cdcdf0bab" translate="yes" xml:space="preserve">
          <source>Like in &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; family of functions there is an overload for the substitution guided by the &lt;code&gt;format&lt;/code&gt; string and the one with the user defined callback.</source>
          <target state="translated">就像在&lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt;函数系列中一样，由 &lt;code&gt;format&lt;/code&gt; 字符串和具有用户定义的回调的格式引导的替换操作有重载。</target>
        </trans-unit>
        <trans-unit id="fc66fa44d8868ee404a0494db572ba397dd68bd7" translate="yes" xml:space="preserve">
          <source>Like most parsers, it consumes its argument. This means:</source>
          <target state="translated">和大多数解析器一样,它也会消耗它的参数。这意味着:</target>
        </trans-unit>
        <trans-unit id="45079d6fbbbd7e92a8db7a1ac24f7a5f82b14899" translate="yes" xml:space="preserve">
          <source>Like xoff(), but returns handle with which to patch 'offset' value.</source>
          <target state="translated">类似于xoff(),但返回处理柄,用来修补 &quot;偏移 &quot;值。</target>
        </trans-unit>
        <trans-unit id="2e7f519163cff0e363c25131c1b51c316fcca76a" translate="yes" xml:space="preserve">
          <source>Likewise, declare a boolean &lt;code&gt;rt_envvars_enabled&lt;/code&gt; to enable configuration via the environment variable &lt;code&gt;DRT_GCOPT&lt;/code&gt;:</source>
          <target state="translated">同样，声明一个布尔值 &lt;code&gt;rt_envvars_enabled&lt;/code&gt; 以通过环境变量 &lt;code&gt;DRT_GCOPT&lt;/code&gt; 启用配置：</target>
        </trans-unit>
        <trans-unit id="05ceb7325c8a826b5f89f8751e8a978ab3c8670c" translate="yes" xml:space="preserve">
          <source>Likewise, declare a boolean rt_envvars_enabled to enable configuration via the environment variable &lt;code&gt;DRT_&lt;/code&gt; followed by the option name, e.g. &lt;code&gt;DRT_GCOPT&lt;/code&gt;:</source>
          <target state="translated">同样，声明一个布尔值rt_envvars_enabled，以通过环境变量 &lt;code&gt;DRT_&lt;/code&gt; 和选项名称（例如 &lt;code&gt;DRT_GCOPT&lt;/code&gt; )启用配置：</target>
        </trans-unit>
        <trans-unit id="0be788e5cd03f159b54ca8ea573d4290d5478fb0" translate="yes" xml:space="preserve">
          <source>Limbu</source>
          <target state="translated">Limbu</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f0b7d22c2b2095983184f3f1451012e2dda7ffbe" translate="yes" xml:space="preserve">
          <source>Limited function template instantiation for using fd.leastAsSpecialized()</source>
          <target state="translated">使用fd.LastAsSpecialized()的有限函数模板实例化。</target>
        </trans-unit>
        <trans-unit id="575a8a2e7f326685ced3cd6e4c6b6e3bf22c896a" translate="yes" xml:space="preserve">
          <source>Limiting a program to this subset of runtime features is useful when targeting constrained environments where the use of such features is not practical or possible.</source>
          <target state="translated">将程序限制在这个运行时特性的子集上,在针对受限制的环境时,当使用这些特性不实际或不可能时,是很有用的。</target>
        </trans-unit>
        <trans-unit id="94b2ecf33206fff8253255f672c5f85e4a9fb00a" translate="yes" xml:space="preserve">
          <source>Limits &amp;amp; machine dependent stuff.</source>
          <target state="translated">限制和机器相关的东西。</target>
        </trans-unit>
        <trans-unit id="79a87925d2fef04b39fdff35de5098824ce21fe8" translate="yes" xml:space="preserve">
          <source>Line comments terminate at the end of the line.</source>
          <target state="translated">行注释在行末终止。</target>
        </trans-unit>
        <trans-unit id="7f39a27437a342a87766f7dbc95e14bd677b6b05" translate="yes" xml:space="preserve">
          <source>Line inside of &lt;code&gt;file&lt;/code&gt; that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">名为 &lt;code&gt;_d_HookTraceImpl&lt;/code&gt; 的 &lt;code&gt;file&lt;/code&gt; 中的行</target>
        </trans-unit>
        <trans-unit id="9f11a4e0ac04365ef99741245ab0220d1dcbe4cc" translate="yes" xml:space="preserve">
          <source>Line number at which parse failure occurred</source>
          <target state="translated">发生解析失败的行号</target>
        </trans-unit>
        <trans-unit id="cafda09317daae42601c48fe90d8c9c7a0d5763e" translate="yes" xml:space="preserve">
          <source>Line separator (&lt;code&gt;'\n'&lt;/code&gt; by default).</source>
          <target state="translated">行分隔符（默认为 &lt;code&gt;'\n'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9062ccfc4d55904c6dc14247f7eba3c693cbc576" translate="yes" xml:space="preserve">
          <source>Line separator (&lt;code&gt;'\n'&lt;/code&gt; by default). Use &lt;a href=&quot;std_ascii#newline&quot;&gt;&lt;code&gt;std.ascii.newline&lt;/code&gt;&lt;/a&gt; for portability (unless the file was opened in text mode).</source>
          <target state="translated">行分隔符（默认为 &lt;code&gt;'\n'&lt;/code&gt; ）。使用&lt;a href=&quot;std_ascii#newline&quot;&gt; &lt;code&gt;std.ascii.newline&lt;/code&gt; &lt;/a&gt;进行可移植性（除非以文本模式打开文件）。</target>
        </trans-unit>
        <trans-unit id="562e54a009e2e7477315da16ad031e93fffe67de" translate="yes" xml:space="preserve">
          <source>Line terminator (by default, &lt;code&gt;'\n'&lt;/code&gt;).</source>
          <target state="translated">行终止符（默认为 &lt;code&gt;'\n'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="94351b3bdac97b327954428ec91bd94c19cb0065" translate="yes" xml:space="preserve">
          <source>Line terminator (by default, &lt;code&gt;'\n'&lt;/code&gt;). Use &lt;a href=&quot;std_ascii#newline&quot;&gt;&lt;code&gt;std.ascii.newline&lt;/code&gt;&lt;/a&gt; for portability (unless the file was opened in text mode).</source>
          <target state="translated">行终止符（默认为 &lt;code&gt;'\n'&lt;/code&gt; ）。使用&lt;a href=&quot;std_ascii#newline&quot;&gt; &lt;code&gt;std.ascii.newline&lt;/code&gt; &lt;/a&gt;进行可移植性（除非以文本模式打开文件）。</target>
        </trans-unit>
        <trans-unit id="5a4bacbb1e223a3267919fd0799232ddbd34aa37" translate="yes" xml:space="preserve">
          <source>Line_Separator</source>
          <target state="translated">Line_Separator</target>
        </trans-unit>
        <trans-unit id="e7df5d5ce001a36983b9d9236abbf093184cc21e" translate="yes" xml:space="preserve">
          <source>Linear B Ideograms</source>
          <target state="translated">线性B表意图</target>
        </trans-unit>
        <trans-unit id="3725027407be653f4f6f73e1060fa298f81067d5" translate="yes" xml:space="preserve">
          <source>Linear B Syllabary</source>
          <target state="translated">线性B教学大纲</target>
        </trans-unit>
        <trans-unit id="4aec3d1c77926be5858da9de4639f131c32b6290" translate="yes" xml:space="preserve">
          <source>Linear Congruential Engines</source>
          <target state="translated">线性共轭发动机</target>
        </trans-unit>
        <trans-unit id="2c0ea1ac864923255fd78db23ede4ab7573a54c1" translate="yes" xml:space="preserve">
          <source>Linear Congruential generator.</source>
          <target state="translated">线性共轭发生器。</target>
        </trans-unit>
        <trans-unit id="3835d6a4986ea73e86742e9a7f3ef9b58c7dcb04" translate="yes" xml:space="preserve">
          <source>Linear_B</source>
          <target state="translated">Linear_B</target>
        </trans-unit>
        <trans-unit id="f9c093b4e3f67b0f50e7c549106bb82a8bb17374" translate="yes" xml:space="preserve">
          <source>Lines of text that directly follow a quoted line are considered part of the quote:</source>
          <target state="translated">直接跟在被引用行后面的文字行被认为是引用的一部分。</target>
        </trans-unit>
        <trans-unit id="33ffd5e6d3f1a75027023ae7e4429a6fa5fe0802" translate="yes" xml:space="preserve">
          <source>Linger information for use with SocketOption.LINGER.</source>
          <target state="translated">Linger信息,用于SocketOption.LINGER。</target>
        </trans-unit>
        <trans-unit id="6efcfa4383191737a4fd58b78fbbf6afc2429322" translate="yes" xml:space="preserve">
          <source>Linger on close if unsent data is present</source>
          <target state="translated">如果有未发送的数据,则停留在关闭状态。</target>
        </trans-unit>
        <trans-unit id="aa29d5efd34035837a47ccdc40b4c4e6e767dff3" translate="yes" xml:space="preserve">
          <source>Linger time.</source>
          <target state="translated">滞留时间。</target>
        </trans-unit>
        <trans-unit id="c07936d974c4dc9cedda3fb3c4619d6d1e2130c2" translate="yes" xml:space="preserve">
          <source>Linkage Attribute</source>
          <target state="translated">链接属性</target>
        </trans-unit>
        <trans-unit id="5d5a19b223d7bf77f8ce49dd34f4ecf21571d14e" translate="yes" xml:space="preserve">
          <source>LinkageType</source>
          <target state="translated">LinkageType</target>
        </trans-unit>
        <trans-unit id="f89598da16ee5888741184d17b4b7e6268f1f50e" translate="yes" xml:space="preserve">
          <source>Linker directives are only supported for MS-COFF output.</source>
          <target state="translated">链接器指令只支持MS-COFF输出。</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="f14f99e5af534b7ca9839de375475b98445e0f1b" translate="yes" xml:space="preserve">
          <source>Links to D documentation generators</source>
          <target state="translated">D文件生成器的链接</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="609a0fb2d74c6bd2b8aaca86410e249f1dbed0f8" translate="yes" xml:space="preserve">
          <source>Linux also supports an abstract address namespace, in which addresses are independent of the file system. A socket address is abstract iff &lt;code&gt;path&lt;/code&gt; starts with a null byte (&lt;code&gt;'\0'&lt;/code&gt;). Null bytes in other positions of an abstract address are allowed and have no special meaning.</source>
          <target state="translated">Linux还支持抽象地址名称空间，其中地址独立于文件系统。套接字地址是抽象的，如果 &lt;code&gt;path&lt;/code&gt; 以空字节（ &lt;code&gt;'\0'&lt;/code&gt; ）开头。抽象地址其他位置的空字节是允许的，没有特殊含义。</target>
        </trans-unit>
        <trans-unit id="79f9578b547044b5676affbe3022bba5ca82f0a9" translate="yes" xml:space="preserve">
          <source>Linux, FreeBSD and OS X</source>
          <target state="translated">Linux、FreeBSD和OS X</target>
        </trans-unit>
        <trans-unit id="053354be10bdf27de5999e46f82f09929ff8e8ba" translate="yes" xml:space="preserve">
          <source>Linux,OpenBSD,Solaris-Only</source>
          <target state="translated">Linux,OpenBSD,Solaris-Only</target>
        </trans-unit>
        <trans-unit id="d5716bdcdebf98cda6d6ad1eefe71dfeb870afa8" translate="yes" xml:space="preserve">
          <source>Linux,OpenBSD-Only</source>
          <target state="translated">Linux,OpenBSD-Only</target>
        </trans-unit>
        <trans-unit id="5c60e74c7c3bd1691653556adba9eac9ee819b43" translate="yes" xml:space="preserve">
          <source>Linux-Only</source>
          <target state="translated">Linux-Only</target>
        </trans-unit>
        <trans-unit id="659c4d46f392b5779315d4148506c9ae066a3900" translate="yes" xml:space="preserve">
          <source>List is a complete package of functions to deal with singly linked lists of pointers or integers.</source>
          <target state="translated">List是一个完整的函数包,用于处理指针或整数的单链路列表。</target>
        </trans-unit>
        <trans-unit id="2169dc30c9f5d1a288648fed4339b09f7a36c11c" translate="yes" xml:space="preserve">
          <source>List items can include content like new paragraphs, headings, embedded code, or child list items. Simply indent the content to match the indent of the text after the list symbol:</source>
          <target state="translated">列表项可以包括新段落、标题、嵌入式代码或子列表项等内容。只需将内容缩进到与列表符号后的文本缩进一致即可。</target>
        </trans-unit>
        <trans-unit id="5b80c969520195f49a23d681c7e470ffeb2f8e58" translate="yes" xml:space="preserve">
          <source>List of Time Zones</source>
          <target state="translated">时区列表</target>
        </trans-unit>
        <trans-unit id="47f0d42b5eabb30594dcebf877a48158279b594c" translate="yes" xml:space="preserve">
          <source>List of non-inherited methods.</source>
          <target state="translated">非继承方法清单;</target>
        </trans-unit>
        <trans-unit id="58d70697d21566547884eb0d25632b01c5aa1e1d" translate="yes" xml:space="preserve">
          <source>List of other symbols and URLs to related items.</source>
          <target state="translated">其他符号和相关项目的URL列表。</target>
        </trans-unit>
        <trans-unit id="c518fb067439705f3ff5fa5b4a62b9be3afa31ae" translate="yes" xml:space="preserve">
          <source>Listen</source>
          <target state="translated">Listen</target>
        </trans-unit>
        <trans-unit id="a6d4e1cf6d50aec9a81f8621becb65e0c7bff808" translate="yes" xml:space="preserve">
          <source>Listen for an incoming connection. &lt;code&gt;bind&lt;/code&gt; must be called before you can &lt;code&gt;listen&lt;/code&gt;. The &lt;code&gt;backlog&lt;/code&gt; is a request of how many pending incoming connections are queued until &lt;code&gt;accept&lt;/code&gt;ed.</source>
          <target state="translated">监听传入的连接。必须先调用 &lt;code&gt;bind&lt;/code&gt; ,然后才能 &lt;code&gt;listen&lt;/code&gt; 。的 &lt;code&gt;backlog&lt;/code&gt; 是许多未决传入连接如何排队直到请求 &lt;code&gt;accept&lt;/code&gt; 编</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="b1c9beb2cd4d7b1946bcd4731626c18eb9ca18ed" translate="yes" xml:space="preserve">
          <source>Lists any known bugs.</source>
          <target state="translated">列出任何已知的错误。</target>
        </trans-unit>
        <trans-unit id="2b60e4e3728775ac5fb1376234a7439665441c9c" translate="yes" xml:space="preserve">
          <source>Lists exceptions thrown and under what circumstances they are thrown.</source>
          <target state="translated">列出抛出的异常以及在什么情况下抛出的异常。</target>
        </trans-unit>
        <trans-unit id="fb8d3829a5b09c1f096a8c468af41889c5c3afa6" translate="yes" xml:space="preserve">
          <source>Lists the author(s) of the declaration.</source>
          <target state="translated">列出声明的作者。</target>
        </trans-unit>
        <trans-unit id="a5b64a6325e7fd542159a3c84889b713d8f57a43" translate="yes" xml:space="preserve">
          <source>Lisu</source>
          <target state="translated">Lisu</target>
        </trans-unit>
        <trans-unit id="cbb1daff2df9ed745e8c2f602eb168c31d37c723" translate="yes" xml:space="preserve">
          <source>Literal backslash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eed1a889b6fdc57925d393d26612d90c4362fd7" translate="yes" xml:space="preserve">
          <source>Literal backslash: &lt;code&gt;\&lt;/code&gt;</source>
          <target state="translated">反斜线： &lt;code&gt;\&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="379a53a04ce7502b5938fbcc362e60ac11c2521f" translate="yes" xml:space="preserve">
          <source>Literal double-quote: &lt;code&gt;&quot;&lt;/code&gt;</source>
          <target state="translated">文字双引号： &lt;code&gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62a779e4049ed74f81ccd9b4787d528847e87647" translate="yes" xml:space="preserve">
          <source>Literal question mark: &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">文字问号： &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7496c0677fb192ed8cf7df54298bd439105963f" translate="yes" xml:space="preserve">
          <source>Literal single-quote: &lt;code&gt;'&lt;/code&gt;</source>
          <target state="translated">文字单引号： &lt;code&gt;'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="4f2ba44c3be0c8a5d7a4cbc08264bfdf2061b1ea" translate="yes" xml:space="preserve">
          <source>Literals do not match &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; parameters.</source>
          <target state="translated">文字与 &lt;code&gt;ref&lt;/code&gt; 或 &lt;code&gt;out&lt;/code&gt; 参数不匹配。</target>
        </trans-unit>
        <trans-unit id="131c60cf3a2f25a830939a99e6f47031b880a38c" translate="yes" xml:space="preserve">
          <source>Little endian byte order</source>
          <target state="translated">小恩迪字节顺序</target>
        </trans-unit>
        <trans-unit id="b0a1256f2ee331aeacbc004b22444b172a7f4623" translate="yes" xml:space="preserve">
          <source>Live Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91575e88330ca0a393b09df24c2f9572b830580f" translate="yes" xml:space="preserve">
          <source>Ll</source>
          <target state="translated">Ll</target>
        </trans-unit>
        <trans-unit id="aea4161c704cbae70375999c4bfe2ae3b29ed465" translate="yes" xml:space="preserve">
          <source>Lm</source>
          <target state="translated">Lm</target>
        </trans-unit>
        <trans-unit id="bb5cf318ffa3931019af265b70dc5e1329293274" translate="yes" xml:space="preserve">
          <source>Lo</source>
          <target state="translated">Lo</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">加载延长线</target>
        </trans-unit>
        <trans-unit id="fdd8edd214a1cae7f44b10e45c660af957f2b328" translate="yes" xml:space="preserve">
          <source>Load this module.</source>
          <target state="translated">加载这个模块。</target>
        </trans-unit>
        <trans-unit id="80b5c5da98b56af5e41eefd69e7fa8b2a9b575bf" translate="yes" xml:space="preserve">
          <source>Load unaligned vector from address. This is a compiler intrinsic.</source>
          <target state="translated">从地址加载未对齐向量。这是编译器的固有功能。</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">可加载的扩展通克</target>
        </trans-unit>
        <trans-unit id="8e0a262d18ece63c9f981e3d7fa4031b25837d39" translate="yes" xml:space="preserve">
          <source>Loads 'val' from memory and returns it. The memory barrier specified by 'ms' is applied to the operation, which is fully sequenced by default. Valid memory orders are MemoryOrder.raw, MemoryOrder.acq, and MemoryOrder.seq.</source>
          <target state="translated">从内存中加载'val'并返回。由'ms'指定的内存障碍被应用到操作中,默认情况下是完全排序的。有效的内存顺序是MemoryOrder.raw、MemoryOrder.acq和MemoryOrder.seq。</target>
        </trans-unit>
        <trans-unit id="7d13b1375e4f7756b923fbdcc4876658d18b6a55" translate="yes" xml:space="preserve">
          <source>Loads the source buffer from the given read result into &lt;code&gt;this.srcBuffer&lt;/code&gt;.</source>
          <target state="translated">将给定读取结果中的源缓冲区加载到 &lt;code&gt;this.srcBuffer&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f476477ef22d4251d73a1d30ca07cf1a34cf5284" translate="yes" xml:space="preserve">
          <source>Loc &lt;code&gt;loc&lt;/code&gt;</source>
          <target state="translated">Loc &lt;code&gt;loc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77785440d50120aa4076ce82e0ec9ab3821b96ba" translate="yes" xml:space="preserve">
          <source>Loc &lt;strong id=&quot;endloc&quot;&gt;endloc&lt;/strong&gt;;</source>
          <target state="translated">Loc &lt;strong id=&quot;endloc&quot;&gt;endloc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="a9aae3f07ee9e73ec7a53299b4ed9cc98dfe9890" translate="yes" xml:space="preserve">
          <source>Loc &lt;strong id=&quot;loc&quot;&gt;loc&lt;/strong&gt;;</source>
          <target state="translated">Loc &lt;strong id=&quot;loc&quot;&gt;loc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e7bda6f355468bf77617112c233388cb6f50302" translate="yes" xml:space="preserve">
          <source>Local Static Variables</source>
          <target state="translated">本地静态变量</target>
        </trans-unit>
        <trans-unit id="ff5148d6cff2251fbb44fa24ac71e87831f6949a" translate="yes" xml:space="preserve">
          <source>Local Variables</source>
          <target state="translated">本地变量</target>
        </trans-unit>
        <trans-unit id="5545f9d00ac24df06f6380d708b888c2531d70c7" translate="yes" xml:space="preserve">
          <source>Local communication</source>
          <target state="translated">当地通信</target>
        </trans-unit>
        <trans-unit id="ac3f517d85e8ae01e24937891c726f4900fea00c" translate="yes" xml:space="preserve">
          <source>Local data (i.e. CompileCtfeFunction*) for module dinterpret</source>
          <target state="translated">模块dinterpret的本地数据(即CompileCtfeFunction*)。</target>
        </trans-unit>
        <trans-unit id="9fb1bb63dc564bca6c7a5e9e93d9c43b4a80c6ce" translate="yes" xml:space="preserve">
          <source>Local endpoint &lt;code&gt;Address&lt;/code&gt;.</source>
          <target state="translated">本地端点 &lt;code&gt;Address&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9f3aff2a7b7305a6652f831edf8db6d7016ee1e" translate="yes" xml:space="preserve">
          <source>Local names</source>
          <target state="translated">当地名称</target>
        </trans-unit>
        <trans-unit id="be6a7350c875b8c9d9ccbb7b7de839744ca0d05e" translate="yes" xml:space="preserve">
          <source>Local port number to bind the socket to</source>
          <target state="translated">绑定到套接字的本地端口号</target>
        </trans-unit>
        <trans-unit id="e6b918332efc4d2c7cdd3b68e4cf1785c7f99f6d" translate="yes" xml:space="preserve">
          <source>Local sections on the stack</source>
          <target state="translated">堆栈上的局部区域</target>
        </trans-unit>
        <trans-unit id="a27f49b6ed675d7b78f3cdf3fe5896202b1d4d8a" translate="yes" xml:space="preserve">
          <source>Local variables in functions can be declared as static or &lt;code&gt;__gshared&lt;/code&gt; in which case they are statically allocated rather than being allocated on the stack. As such, their value persists beyond the exit of the function.</source>
          <target state="translated">函数中的局部变量可以声明为静态或 &lt;code&gt;__gshared&lt;/code&gt; ,在这种情况下，它们是静态分配的，而不是在堆栈上分配。这样，它们的值将持续存在，直到函数退出为止。</target>
        </trans-unit>
        <trans-unit id="d60a34babb78e25baf9b8dca57cc7a6a57f9a62c" translate="yes" xml:space="preserve">
          <source>Locates a dynamic library with the supplied library name and dynamically loads it into the caller's address space. If the library contains a D runtime it will be integrated with the current runtime.</source>
          <target state="translated">用提供的库名找到一个动态库,并将其动态加载到调用者的地址空间。如果库中包含一个D运行时,它将与当前的运行时集成。</target>
        </trans-unit>
        <trans-unit id="4aacb69957ad5cddfad921cdf6c0106c5bee9a10" translate="yes" xml:space="preserve">
          <source>Location information of the call</source>
          <target state="translated">呼叫的位置信息</target>
        </trans-unit>
        <trans-unit id="73ff6861f35f866aec7aeeb578457a4566a437cd" translate="yes" xml:space="preserve">
          <source>Location of deprecation</source>
          <target state="translated">废弃的地点</target>
        </trans-unit>
        <trans-unit id="57b91c66877cf6b374fbb1200642748e28d59b53" translate="yes" xml:space="preserve">
          <source>Location of error</source>
          <target state="translated">错误位置</target>
        </trans-unit>
        <trans-unit id="4fc6c901a903b2735a7904abeb7a095eb0c123e1" translate="yes" xml:space="preserve">
          <source>Location of the deprecation</source>
          <target state="translated">废弃的位置</target>
        </trans-unit>
        <trans-unit id="a6401740004452bbcf66d3042a6f5de680dddeba" translate="yes" xml:space="preserve">
          <source>Location of warning</source>
          <target state="translated">警示位置</target>
        </trans-unit>
        <trans-unit id="4b59a58b9ea59e25faf234bc5204489fb27642f9" translate="yes" xml:space="preserve">
          <source>Locks are not inherited by child processes.</source>
          <target state="translated">锁不被子进程继承。</target>
        </trans-unit>
        <trans-unit id="3a33487e1736bf9e6609b67ba3b4f3dff1091e2f" translate="yes" xml:space="preserve">
          <source>Locks created using &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;tryLock&lt;/code&gt; have the following properties:</source>
          <target state="translated">使用 &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;tryLock&lt;/code&gt; 创建的锁具有以下属性：</target>
        </trans-unit>
        <trans-unit id="1078bb655a08aae4699ba7fac16a102730785485" translate="yes" xml:space="preserve">
          <source>Locks the specified file segment. If the file segment is already locked by another process, waits until the existing lock is released. If both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are zero, the entire file is locked.</source>
          <target state="translated">锁定指定的文件段。如果文件段已被另一个进程锁定，请等待直到释放现有的锁定。如果 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;length&lt;/code&gt; 均为零，则整个文件将被锁定。</target>
        </trans-unit>
        <trans-unit id="4fdb3aa6c3fd683c9aaf2374307211453b556f8d" translate="yes" xml:space="preserve">
          <source>Lockstep!Ranges &lt;strong id=&quot;lockstep&quot;&gt;lockstep&lt;/strong&gt;(Ranges...)(Ranges ranges)</source>
          <target state="translated">Lockstep！Ranges &lt;strong id=&quot;lockstep&quot;&gt;lockstep&lt;/strong&gt;（Ranges ...）（范围）</target>
        </trans-unit>
        <trans-unit id="39496871de00ee058f37e6cbb0be193e3214e5e3" translate="yes" xml:space="preserve">
          <source>Lockstep!Ranges &lt;strong id=&quot;lockstep&quot;&gt;lockstep&lt;/strong&gt;(Ranges...)(Ranges ranges, StoppingPolicy s)</source>
          <target state="translated">Lockstep！Ranges &lt;strong id=&quot;lockstep&quot;&gt;lockstep&lt;/strong&gt;（Ranges ...）（Ranges range，StoppingPolicy s）</target>
        </trans-unit>
        <trans-unit id="fad1f4632354649775fa0e5d50b9164b567e59f6" translate="yes" xml:space="preserve">
          <source>Log Minus Digamma function</source>
          <target state="translated">对数减去Digamma功能</target>
        </trans-unit>
        <trans-unit id="2a6fa3a2602f79946a73d76e4d612ad28acdfb88" translate="yes" xml:space="preserve">
          <source>Log messages that describe fatal errors should use this level.</source>
          <target state="translated">描述致命错误的日志消息应该使用这个级别。</target>
        </trans-unit>
        <trans-unit id="9945a7ae687a5abee282c11e943964628be93a09" translate="yes" xml:space="preserve">
          <source>Log the string to stderr, this will print something like this in the terminal:</source>
          <target state="translated">将该字符串记录到stderr,这将在终端中打印出类似这样的内容。</target>
        </trans-unit>
        <trans-unit id="02b7320cd2ebcb2d92d9355bfdee38ca004f34cb" translate="yes" xml:space="preserve">
          <source>LogEntry &lt;code&gt;payload&lt;/code&gt;</source>
          <target state="translated">LogEntry &lt;code&gt;payload&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34c61f0216de15bd2af4a77e158df88206381def" translate="yes" xml:space="preserve">
          <source>LogEntry is a aggregation combining all information associated with a log message. This aggregation will be passed to the method writeLogMsg.</source>
          <target state="translated">LogEntry是结合了与日志消息相关的所有信息的聚合。这个聚合将被传递给方法writeLogMsg。</target>
        </trans-unit>
        <trans-unit id="74c012ac32756bbfd453a39643d2591c98930a80" translate="yes" xml:space="preserve">
          <source>LogLevel</source>
          <target state="translated">LogLevel</target>
        </trans-unit>
        <trans-unit id="46823fbe7f7dbcfd76f32da557302d10d151cb8a" translate="yes" xml:space="preserve">
          <source>LogLevel &lt;code&gt;ll&lt;/code&gt;</source>
          <target state="translated">LogLevel &lt;code&gt;ll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02c5d167afffbb7dbf4712fabfc250b90a1311bc" translate="yes" xml:space="preserve">
          <source>LogLevel &lt;code&gt;lv&lt;/code&gt;</source>
          <target state="translated">LogLevel &lt;code&gt;lv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecc9d7efba9afc89574f5d3bf86e3d7baaac302b" translate="yes" xml:space="preserve">
          <source>LogLevel &lt;strong id=&quot;logLevel&quot;&gt;logLevel&lt;/strong&gt;;</source>
          <target state="translated">LogLevel &lt;strong id=&quot;logLevel&quot;&gt;logLevel&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="4ed40fc6e5a5852438d7391404942ae2521d7f56" translate="yes" xml:space="preserve">
          <source>Logger &lt;code&gt;newLogger&lt;/code&gt;</source>
          <target state="translated">记录仪 &lt;code&gt;newLogger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28189bc68fa5c89294fb2f918a4e83d73a420934" translate="yes" xml:space="preserve">
          <source>Logger &lt;strong id=&quot;logger&quot;&gt;logger&lt;/strong&gt;;</source>
          <target state="translated">记录&lt;strong id=&quot;logger&quot;&gt;仪&lt;/strong&gt;记录&lt;strong id=&quot;logger&quot;&gt;仪&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="84c998ac72938ace2c01090c22dde31485e70020" translate="yes" xml:space="preserve">
          <source>Logging Fundamentals</source>
          <target state="translated">测井基础知识</target>
        </trans-unit>
        <trans-unit id="ff5d5c519f4c3bb77429911d9e4777ff8d9f0131" translate="yes" xml:space="preserve">
          <source>Logical negation</source>
          <target state="translated">逻辑否定</target>
        </trans-unit>
        <trans-unit id="92491dfcf77a677e2579a8fdd5849bc43c91a9a3" translate="yes" xml:space="preserve">
          <source>Logical_Order_Exception</source>
          <target state="translated">Logical_Order_Exception</target>
        </trans-unit>
        <trans-unit id="70560736acb9ecf186c4fe18c6fbf72b37079b60" translate="yes" xml:space="preserve">
          <source>Logs a part of the log message.</source>
          <target state="translated">记录部分日志信息。</target>
        </trans-unit>
        <trans-unit id="375bd085e65737a7ace18bd867e945918a24086b" translate="yes" xml:space="preserve">
          <source>Long form</source>
          <target state="translated">长表</target>
        </trans-unit>
        <trans-unit id="ff41efc01d76dc10a97a12c09a243b0ca354e0cf" translate="yes" xml:space="preserve">
          <source>Look 2 tokens ahead at value.</source>
          <target state="translated">在价值上看前面2个代币。</target>
        </trans-unit>
        <trans-unit id="afc94f6c3a556315eed1cb174ad15bb185dcbc4f" translate="yes" xml:space="preserve">
          <source>Look ahead at next token's value.</source>
          <target state="translated">展望下一个代币的价值。</target>
        </trans-unit>
        <trans-unit id="5622d20c099b662e6a0a373dd68292f6a0ba3406" translate="yes" xml:space="preserve">
          <source>Look at all the variables in this function that are referenced by nested functions, and determine if a closure needs to be created for them.</source>
          <target state="translated">查看这个函数中所有被嵌套函数引用的变量,并判断是否需要为它们创建一个闭包。</target>
        </trans-unit>
        <trans-unit id="654b5c9229aa50c7d6a646cb9a83a6131f5de84e" translate="yes" xml:space="preserve">
          <source>Look at the chain of inflight exceptions and pick the class type that'll be looked for in catch clauses.</source>
          <target state="translated">看一下机上异常的链子,然后选择在捕捉子句中寻找的类型。</target>
        </trans-unit>
        <trans-unit id="70c9a19c6fcf57b59739caeb1b4f8d412200e169" translate="yes" xml:space="preserve">
          <source>Look for GC-allocations</source>
          <target state="translated">寻找GC-分配</target>
        </trans-unit>
        <trans-unit id="20561c6b5a8c54db867f0cd788574c6f1aaba303" translate="yes" xml:space="preserve">
          <source>Look for bugs in constructing types.</source>
          <target state="translated">寻找构造类型的错误。</target>
        </trans-unit>
        <trans-unit id="d1a79a1301c397a748fd769d70432ac6b93cb4bc" translate="yes" xml:space="preserve">
          <source>Look for constructor declaration.</source>
          <target state="translated">寻找构造函数声明。</target>
        </trans-unit>
        <trans-unit id="55662975ec462a6b77f0e621733ca4e99a96109f" translate="yes" xml:space="preserve">
          <source>Look for member of the form: const(MemberInfo)[] getMembers(string); Returns NULL if not found</source>
          <target state="translated">查找表单中的成员:const(MemberInfo)[]getMembers(string);如果没有找到,返回NULL。</target>
        </trans-unit>
        <trans-unit id="a5ecbeff661b0c09d7052aed23032d114c945947" translate="yes" xml:space="preserve">
          <source>Look for references to variables in a scope enclosing the new function literal.</source>
          <target state="translated">在新函数字面意义所包围的作用域中查找对变量的引用。</target>
        </trans-unit>
        <trans-unit id="dca0eb22e1b34ba0a7ee58c95403fe1142a825cc" translate="yes" xml:space="preserve">
          <source>Look up classType in Action Table.</source>
          <target state="translated">在动作表中查找classType。</target>
        </trans-unit>
        <trans-unit id="bf6f8e6a744477193839c88af310acdab947187c" translate="yes" xml:space="preserve">
          <source>Look up identifier in symbol table.</source>
          <target state="translated">在符号表中查找标识符。</target>
        </trans-unit>
        <trans-unit id="6b1faf6e7e2ade4943d73b78287350be64b06d22" translate="yes" xml:space="preserve">
          <source>Looks for correct spelling. Currently only looks a 'distance' of one from the seed[]. This does an exhaustive search, so can potentially be very slow.</source>
          <target state="translated">寻找正确的拼写。目前只查找距离种子[]1的 &quot;距离&quot;。这将进行详尽的搜索,所以可能会很慢。</target>
        </trans-unit>
        <trans-unit id="e7ba5beab41b9fc718625eff0ab12ec104ab4ac0" translate="yes" xml:space="preserve">
          <source>Looks for undefined identifier s to see if it might be undefined because an import was not specified. Not meant to be a comprehensive list of names in each module, just the most common ones.</source>
          <target state="translated">寻找未定义的标识符,以确定是否因为没有指定导入而未定义。并不是要全面列出每个模块的名称,只是列出最常见的名称。</target>
        </trans-unit>
        <trans-unit id="b8a0d0e70a93b9315eed33e543f65f34ea9905b6" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;key&lt;/code&gt;; if it exists applies the &lt;code&gt;update&lt;/code&gt; delegate else evaluates the &lt;code&gt;create&lt;/code&gt; delegate and adds it to the associative array</source>
          <target state="translated">查找 &lt;code&gt;key&lt;/code&gt; ; 如果存在，则应用 &lt;code&gt;update&lt;/code&gt; 委托，否则评估 &lt;code&gt;create&lt;/code&gt; 委托并将其添加到关联数组</target>
        </trans-unit>
        <trans-unit id="f04ca992dc16f517e75024c08b7ac020854cbc1a" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;key&lt;/code&gt;; if it exists returns corresponding value else evaluates &lt;code&gt;value&lt;/code&gt;, adds it to the associative array and returns it.</source>
          <target state="translated">查找 &lt;code&gt;key&lt;/code&gt; ; 如果存在，则返回相应的值，否则求 &lt;code&gt;value&lt;/code&gt; ，将其添加到关联数组中并返回。</target>
        </trans-unit>
        <trans-unit id="c6a8bc0d3f8751a41d3178fa2ecd99ad6f8c6478" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;key&lt;/code&gt;; if it exists returns corresponding value else evaluates and returns &lt;code&gt;defVal&lt;/code&gt;.</source>
          <target state="translated">查找 &lt;code&gt;key&lt;/code&gt; ; 如果存在，则返回相应的值，否则求值并返回 &lt;code&gt;defVal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd483a2f65cbf5a83a8c5f6ad516313d73801935" translate="yes" xml:space="preserve">
          <source>Looks up key; if it exists applies the update callable else evaluates the create callable and adds it to the associative array</source>
          <target state="translated">查找key;如果存在,则应用update callable,否则评估create callable并将其添加到关联数组中。</target>
        </trans-unit>
        <trans-unit id="be2ee07f892035b2ec1c706668252bc84555ddb4" translate="yes" xml:space="preserve">
          <source>Looks up key; if it exists returns corresponding value else evaluates and returns defaultValue.</source>
          <target state="translated">查找key,如果存在则返回相应的值,否则评估并返回defaultValue。</target>
        </trans-unit>
        <trans-unit id="1875c1f85b6a7543e96c3d340bf104b96893e8d2" translate="yes" xml:space="preserve">
          <source>Looks up key; if it exists returns corresponding value else evaluates value, adds it to the associative array and returns it.</source>
          <target state="translated">查找键,如果存在则返回相应的值,否则评估值,将其添加到关联数组中并返回。</target>
        </trans-unit>
        <trans-unit id="2cc04a00b4346a66399ef51dd8da620552ded35a" translate="yes" xml:space="preserve">
          <source>Lookup *pkey in aa. Called only from implementation of (aa[key]) expressions when value is mutable.</source>
          <target state="translated">在aa中查找*pkey。当值是可突变的时,仅从(aa[key])表达式的实现中调用。</target>
        </trans-unit>
        <trans-unit id="5acb595c30bd73abf9112d17b6787c68f70f18a1" translate="yes" xml:space="preserve">
          <source>Lookup *pkey in aa. Called only from implementation of (aa[key]) expressions when value is not mutable.</source>
          <target state="translated">在aa中查找*pkey。当值不可变时,仅从(aa[key])表达式的实现中调用。</target>
        </trans-unit>
        <trans-unit id="791d64d6dd1c9c7807ef99641d73b8a3fa427ce6" translate="yes" xml:space="preserve">
          <source>Lookup *pkey in aa. Called only from implementation of (key in aa) expressions.</source>
          <target state="translated">在aa中查找*pkey。仅从(key in aa)表达式的实现中调用。</target>
        </trans-unit>
        <trans-unit id="2d5714819469c13b59fdfd000487590810a7c91a" translate="yes" xml:space="preserve">
          <source>Lookup *pkey in aa. Called only from implementation of require</source>
          <target state="translated">在aa中查找*pkey。仅在实现require</target>
        </trans-unit>
        <trans-unit id="488171ff26cd71419d21a0a9adfd632513f34bae" translate="yes" xml:space="preserve">
          <source>Lookup named submatch.</source>
          <target state="translated">查询名为子匹配。</target>
        </trans-unit>
        <trans-unit id="1b640962460641e4c30f8b4a0277ba5e6244fda9" translate="yes" xml:space="preserve">
          <source>Loop over the chain of Throwables.</source>
          <target state="translated">循环在可抛物链上。</target>
        </trans-unit>
        <trans-unit id="1a1cf7f9d7a7fa0e0c2b6385a443cec04154dd41" translate="yes" xml:space="preserve">
          <source>Low Surrogates</source>
          <target state="translated">低代用药</target>
        </trans-unit>
        <trans-unit id="48523acb4bcd854d9aa1ea2802e3b41bb7296532" translate="yes" xml:space="preserve">
          <source>Low level</source>
          <target state="translated">低水平</target>
        </trans-unit>
        <trans-unit id="b40b74c86ad687d5579e947e3f92577b31a5eda2" translate="yes" xml:space="preserve">
          <source>Low level bit manipulation.</source>
          <target state="translated">低级位操作。</target>
        </trans-unit>
        <trans-unit id="f2e86eaa57ddf3a17dd614f833e423ebc213f8c4" translate="yes" xml:space="preserve">
          <source>Low level messaging API for threads.</source>
          <target state="translated">线程的低级消息API。</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">数据库文件的低级控制</target>
        </trans-unit>
        <trans-unit id="89f7441b4ba65a8bf1a560585634d07db89e7fca" translate="yes" xml:space="preserve">
          <source>Low-level process creation</source>
          <target state="translated">低层次的流程创建</target>
        </trans-unit>
        <trans-unit id="2bd438fab42ba2532b308f2c0479c2cede33e8d9" translate="yes" xml:space="preserve">
          <source>Lower case letters</source>
          <target state="translated">小写字母</target>
        </trans-unit>
        <trans-unit id="3011ca9e161c4e7602061857963040cfcefd24e6" translate="yes" xml:space="preserve">
          <source>Lower level control over parsing CSV</source>
          <target state="translated">对CSV解析的低级控制</target>
        </trans-unit>
        <trans-unit id="b563fa15108a7c5ade041259f86d89b7a18d8930" translate="yes" xml:space="preserve">
          <source>Lowercase</source>
          <target state="translated">Lowercase</target>
        </trans-unit>
        <trans-unit id="abf8ce4a5f4a2b06b346bb8ef9b168681a52fab2" translate="yes" xml:space="preserve">
          <source>Lowercase_Letter</source>
          <target state="translated">Lowercase_Letter</target>
        </trans-unit>
        <trans-unit id="b7c7ce791998816ed0e71e16db0d586762b3248a" translate="yes" xml:space="preserve">
          <source>Lowest generated value (&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;c == 0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">最低的生成值（如果 &lt;code&gt;c == 0&lt;/code&gt; ，则为 &lt;code&gt;1&lt;/code&gt; ，否则为 &lt;code&gt;0&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="65a7ee0f0dd9333831b9dc305ef620113ec1e149" translate="yes" xml:space="preserve">
          <source>Lowest possible assignable &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">最低的可分配 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdd31e29a8533fa78639eaa1635910fd1573da09" translate="yes" xml:space="preserve">
          <source>LsdaResult</source>
          <target state="translated">LsdaResult</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
