<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="5957f81d5474beefa7065939b0cc1473131ad62e" translate="yes" xml:space="preserve">
          <source>The address cannot end with a backslash</source>
          <target state="translated">地址不能以反斜杠结束。</target>
        </trans-unit>
        <trans-unit id="884473b76201e4868789c53f5ad5333ae6e63e04" translate="yes" xml:space="preserve">
          <source>The address contains a character that is not allowed in a quoted pair</source>
          <target state="translated">地址包含一个不允许在引号对中出现的字符。</target>
        </trans-unit>
        <trans-unit id="8c9a5ff6c7f32f248ada10269768a9f567d3a6d9" translate="yes" xml:space="preserve">
          <source>The address is only valid according to the broad definition of RFC 5322. It is otherwise invalid</source>
          <target state="translated">该地址只有根据RFC 5322的广义定义才有效。否则无效。</target>
        </trans-unit>
        <trans-unit id="612f02a9ea5a91c0f5d3bab0d248e35b8e08d288" translate="yes" xml:space="preserve">
          <source>The address may not contain consecutive dots</source>
          <target state="translated">地址不能包含连续的点</target>
        </trans-unit>
        <trans-unit id="f2ec315916ee72c713d94760053a490c4200261c" translate="yes" xml:space="preserve">
          <source>The address of the destination variable.</source>
          <target state="translated">目标变量的地址。</target>
        </trans-unit>
        <trans-unit id="eb5d226a327a58219779ec6f85c14805039c0902" translate="yes" xml:space="preserve">
          <source>The address of the stack bottom.</source>
          <target state="translated">栈底的地址。</target>
        </trans-unit>
        <trans-unit id="6d486d434e5db9fa409133a5d2911ad3ba926ad2" translate="yes" xml:space="preserve">
          <source>The address of the stack top.</source>
          <target state="translated">栈顶的地址。</target>
        </trans-unit>
        <trans-unit id="573e0fdfafaaaa6327f4d3ad798c62e0ac496505" translate="yes" xml:space="preserve">
          <source>The address of the value to compare, and receives the prior value of &lt;code&gt;here&lt;/code&gt; as output.</source>
          <target state="translated">要比较的值的地址，并接收 &lt;code&gt;here&lt;/code&gt; 的优先值作为输出。</target>
        </trans-unit>
        <trans-unit id="100ae837312c2864dadfce5bae741844606a1fdc" translate="yes" xml:space="preserve">
          <source>The aggregate it is a member of, or null.</source>
          <target state="translated">它是一个成员的集合,或者为空。</target>
        </trans-unit>
        <trans-unit id="99842dfccac0d88c0dc49fd2be32200c326ae7be" translate="yes" xml:space="preserve">
          <source>The aggregate itself must not be resized, reallocated, free'd, reassigned or destructed while the foreach is iterating over the elements.</source>
          <target state="translated">当foreach在元素上迭代时,集合本身不能被调整大小、重新分配、free'd、重新分配或销毁。</target>
        </trans-unit>
        <trans-unit id="6dd852d4a388be331d9744743f8822707966e7c3" translate="yes" xml:space="preserve">
          <source>The aggregate must be loop invariant, meaning that elements to the aggregate cannot be added or removed from it in the &lt;a href=&quot;#NoScopeNonEmptyStatement&quot;&gt;&lt;i&gt;NoScopeNonEmptyStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">聚合必须是循环不变的，这意味着无法在&lt;a href=&quot;#NoScopeNonEmptyStatement&quot;&gt;&lt;i&gt;NoScopeNonEmptyStatement中&lt;/i&gt;&lt;/a&gt;添加或删除聚合中的&lt;i&gt;元素&lt;/i&gt;。</target>
        </trans-unit>
        <trans-unit id="a40360593993a6e7d8a1dd4dee1078680e89ae6d" translate="yes" xml:space="preserve">
          <source>The aggregate type to search</source>
          <target state="translated">要搜索的集合类型</target>
        </trans-unit>
        <trans-unit id="be4d7abfbf6a487ccbcd0c016363e65c1e7e3e7f" translate="yes" xml:space="preserve">
          <source>The aggregate/range bounds are evaluated at compile time and turned into a sequence of compile-time entities by evaluating corresponding code with a &lt;a href=&quot;statement#ForeachStatement&quot;&gt;&lt;i&gt;ForeachStatement&lt;/i&gt;&lt;/a&gt;/&lt;a href=&quot;statement#ForeachRangeStatement&quot;&gt;&lt;i&gt;ForeachRangeStatement&lt;/i&gt;&lt;/a&gt; at compile time. The body of the &lt;code&gt;static foreach&lt;/code&gt; is then copied a number of times that corresponds to the number of elements of the sequence. Within the i-th copy, the name of the &lt;code&gt;static foreach&lt;/code&gt; variable is bound to the i-th entry of the sequence, either as an &lt;code&gt;enum&lt;/code&gt; variable declaration (for constants) or an &lt;code&gt;alias&lt;/code&gt; declaration (for symbols). (In particular, &lt;code&gt;static foreach&lt;/code&gt; variables are never runtime variables.)</source>
          <target state="translated">聚合/范围边界在编译时评估，并通过在编译时使用&lt;a href=&quot;statement#ForeachStatement&quot;&gt;&lt;i&gt;ForeachStatement&lt;/i&gt;&lt;/a&gt; / &lt;a href=&quot;statement#ForeachRangeStatement&quot;&gt;&lt;i&gt;ForeachRangeStatement&lt;/i&gt;&lt;/a&gt;评估相应的代码将其转换为一系列编译时实体。然后，将 &lt;code&gt;static foreach&lt;/code&gt; 的主体复制多次，该次数对应于序列中元素的数量。在第i个副本中， &lt;code&gt;static foreach&lt;/code&gt; 变量的名称绑定到序列的第i个条目，作为 &lt;code&gt;enum&lt;/code&gt; 变量声明（对于常量）或 &lt;code&gt;alias&lt;/code&gt; 声明（对于符号）。 （特别是， &lt;code&gt;static foreach&lt;/code&gt; 变量永远不会是运行时变量。）</target>
        </trans-unit>
        <trans-unit id="7524e87df0e2bd2478aea3589a41e1a028d60509" translate="yes" xml:space="preserve">
          <source>The algorithm was designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel.</source>
          <target state="translated">该算法由Hans Dobbertin、Antoon Bosselaers和Bart Preneel设计。</target>
        </trans-unit>
        <trans-unit id="4c2bfa97d67b17e650534b7eef10e7ad4c0bcc79" translate="yes" xml:space="preserve">
          <source>The algorithm works as follows:</source>
          <target state="translated">该算法的工作原理如下:</target>
        </trans-unit>
        <trans-unit id="48a9b12ecf15252f0b5157732b6ca9173b4931d2" translate="yes" xml:space="preserve">
          <source>The aliases are:</source>
          <target state="translated">这些别名是:</target>
        </trans-unit>
        <trans-unit id="81631da16100dd8478c92e814bda7bbba00ac288" translate="yes" xml:space="preserve">
          <source>The aliases following this template create the public names of the log functions.</source>
          <target state="translated">本模板后面的别名创建了日志函数的公共名称。</target>
        </trans-unit>
        <trans-unit id="bcbe81e1130e17fc3109bc8509350a184b24f288" translate="yes" xml:space="preserve">
          <source>The aliases following this template create the public names of these log functions.</source>
          <target state="translated">该模板后面的别名创建了这些日志函数的公共名称。</target>
        </trans-unit>
        <trans-unit id="c567df7009dd19d930ebcb716790130e92399528" translate="yes" xml:space="preserve">
          <source>The alignment for the fields of an aggregate does not affect the alignment of the aggregate itself - that is affected by the alignment setting outside of the aggregate.</source>
          <target state="translated">聚合体字段的对齐方式不会影响聚合体本身的对齐方式--这是受聚合体外部的对齐方式设置影响的。</target>
        </trans-unit>
        <trans-unit id="f093103ea9ccde93c26257d52a8ebe06d2563d51" translate="yes" xml:space="preserve">
          <source>The alignment is a static constant equal to &lt;code&gt;platformAlignment&lt;/code&gt;, which ensures proper alignment for any D data type.</source>
          <target state="translated">对齐方式是等于 &lt;code&gt;platformAlignment&lt;/code&gt; 的静态常数，可以确保任何D数据类型的正确对齐方式。</target>
        </trans-unit>
        <trans-unit id="15ebd1ca8e45d31f001b9c11ace8a2913c42cd0b" translate="yes" xml:space="preserve">
          <source>The alignment offered is the minimum of the two allocators' alignment.</source>
          <target state="translated">提供的排列是两个分配器的最小排列。</target>
        </trans-unit>
        <trans-unit id="98d787b597dca14b1cd2aa32405fb6769c33f39f" translate="yes" xml:space="preserve">
          <source>The alignment offered is the same as &lt;code&gt;Allocator.alignment&lt;/code&gt;.</source>
          <target state="translated">提供的对齐方式与 &lt;code&gt;Allocator.alignment&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="2d9bcfc1fe50fa247260c84039c4e52f5cc8339c" translate="yes" xml:space="preserve">
          <source>The alignment offered is user-configurable statically through parameter &lt;code&gt;theAlignment&lt;/code&gt;, defaulted to &lt;code&gt;platformAlignment&lt;/code&gt;.</source>
          <target state="translated">用户可以通过参数 &lt;code&gt;theAlignment&lt;/code&gt; 静态配置其提供的对齐方式，默认为 &lt;code&gt;platformAlignment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55ae38068c659d6482341d5f2a9544d2084b247f" translate="yes" xml:space="preserve">
          <source>The alignment offered.</source>
          <target state="translated">提供的对准。</target>
        </trans-unit>
        <trans-unit id="0f037bbde370840fb51ae0cd55e297a5ad94c4c1" translate="yes" xml:space="preserve">
          <source>The alignment that is guaranteed to accommodate any D object allocation on the current platform.</source>
          <target state="translated">保证适应当前平台上任何D对象分配的走线。</target>
        </trans-unit>
        <trans-unit id="ffaeeba22bc74fcd6590cff49e1181655746149d" translate="yes" xml:space="preserve">
          <source>The allocated block looks like this for blocks &amp;lt; PAGESIZE:</source>
          <target state="translated">对于&amp;lt;PAGESIZE：的块，分配的块如下所示：</target>
        </trans-unit>
        <trans-unit id="1e6e16df97f3afd43394873bd1850208370d0247" translate="yes" xml:space="preserve">
          <source>The allocated block, or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">分配的块，或者为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d585ec1807a2dc496ab963634c47b6fc38f63ce" translate="yes" xml:space="preserve">
          <source>The allocated memory is aligned to the specified alignment &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">分配的内存与指定的对齐方式 &lt;code&gt;a&lt;/code&gt; 对齐。</target>
        </trans-unit>
        <trans-unit id="26fd1cc82ed45b7bca2ff3a406ac59e252c10871" translate="yes" xml:space="preserve">
          <source>The allocator used for getting the needed memory. It may be an object implementing the static interface for allocators, or an &lt;code&gt;IAllocator&lt;/code&gt; reference.</source>
          <target state="translated">用于获取所需内存的分配器。它可以是实现分配器静态接口或 &lt;code&gt;IAllocator&lt;/code&gt; 引用的对象。</target>
        </trans-unit>
        <trans-unit id="7a162642b55adf8c70cb72e78e6a91ca645573ee" translate="yes" xml:space="preserve">
          <source>The amount of time (as a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;) that it took to call each function &lt;code&gt;n&lt;/code&gt; times. The first value is the length of time that it took to call &lt;code&gt;fun[0]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. The second value is the length of time it took to call &lt;code&gt;fun[1]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. Etc.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 次调用每个函数所花费的时间（作为&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;）。第一个值是 &lt;code&gt;n&lt;/code&gt; 次调用 &lt;code&gt;fun[0]&lt;/code&gt; 花费的时间长度。第二个值是 &lt;code&gt;n&lt;/code&gt; 次调用 &lt;code&gt;fun[1]&lt;/code&gt; 花费的时间长度。等等。</target>
        </trans-unit>
        <trans-unit id="679e02f2df98ca53eb58d9358d749fc6899efa4f" translate="yes" xml:space="preserve">
          <source>The amount of time (as a &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) that it took to call each function &lt;code&gt;n&lt;/code&gt; times. The first value is the length of time that it took to call &lt;code&gt;fun[0]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. The second value is the length of time it took to call &lt;code&gt;fun[1]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. Etc.  Note that casting the TickDurations to &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s will make the results easier to deal with (and it may change in the future that benchmark will return an array of Durations rather than TickDurations).</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 次调用每个函数所花费的时间（作为&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）。第一个值是 &lt;code&gt;n&lt;/code&gt; 次调用 &lt;code&gt;fun[0]&lt;/code&gt; 花费的时间长度。第二个值是 &lt;code&gt;n&lt;/code&gt; 次调用 &lt;code&gt;fun[1]&lt;/code&gt; 花费的时间长度。等等，请注意，将TickDurations强制转换为&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;将使结果更易于处理（将来基准可能会返回一组Durations而不是TickDurations，这可能会改变）。</target>
        </trans-unit>
        <trans-unit id="5f2ab544dd26a15cec91af6687d533c4df3410af" translate="yes" xml:space="preserve">
          <source>The amount of time the offset from UTC is (negative is west of UTC, positive is east).</source>
          <target state="translated">与UTC的偏移量(负的是UTC的西边,正的是东边)。</target>
        </trans-unit>
        <trans-unit id="6ca92b99392b2201548ac94076929186c2729bd5" translate="yes" xml:space="preserve">
          <source>The argument</source>
          <target state="translated">争论</target>
        </trans-unit>
        <trans-unit id="95ad1044a61a4a355c884ad9c8beb68fea8cbf9e" translate="yes" xml:space="preserve">
          <source>The argument (or phase) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 的自变量（或相位）。</target>
        </trans-unit>
        <trans-unit id="c58aecc00ef7e3c30bc80ddf70bce576b8c7b76a" translate="yes" xml:space="preserve">
          <source>The argument count.</source>
          <target state="translated">论证数。</target>
        </trans-unit>
        <trans-unit id="d38f16231ac42e003a0a7d9c3c817f7a78c027ca" translate="yes" xml:space="preserve">
          <source>The argument is a symbol. The result is a string giving its protection level: &quot;public&quot;, &quot;private&quot;, &quot;protected&quot;, &quot;export&quot;, or &quot;package&quot;.</source>
          <target state="translated">参数是一个符号。结果是一个字符串,给出其保护级别。&quot;public&quot;,&quot;private&quot;,&quot;protected&quot;,&quot;export&quot;,或 &quot;package&quot;.</target>
        </trans-unit>
        <trans-unit id="b7bee920123d48f748fd063723855b9cdf7fc70e" translate="yes" xml:space="preserve">
          <source>The argument is a type. The result is an array of &lt;code&gt;size_t&lt;/code&gt; describing the memory used by an instance of the given type.</source>
          <target state="translated">参数是一种类型。结果是 &lt;code&gt;size_t&lt;/code&gt; 数组，描述给定类型的实例使用的内存。</target>
        </trans-unit>
        <trans-unit id="bd0d0e4c2f22549c04310e29901bafb6d89f2cbb" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;dg&lt;/code&gt; is &lt;code&gt;scope&lt;/code&gt;. To keep the data around after &lt;code&gt;dg&lt;/code&gt; exits, one has to copy it.</source>
          <target state="translated">&lt;code&gt;dg&lt;/code&gt; 的参数是 &lt;code&gt;scope&lt;/code&gt; 。要在 &lt;code&gt;dg&lt;/code&gt; 退出后保留数据，必须将其复制。</target>
        </trans-unit>
        <trans-unit id="d6506a51a0d81317d36c0b3931580ed4ae34e0c1" translate="yes" xml:space="preserve">
          <source>The arguments as a C array of strings.</source>
          <target state="translated">参数为一个C语言的字符串数组。</target>
        </trans-unit>
        <trans-unit id="9a539cbbe8582d8d5d90be89210dc5f77ab9a858" translate="yes" xml:space="preserve">
          <source>The arguments supplied when this process was started.</source>
          <target state="translated">该进程启动时提供的参数。</target>
        </trans-unit>
        <trans-unit id="afc42ff1b01f9fdceb0afc9990aeafdba8561cdc" translate="yes" xml:space="preserve">
          <source>The arguments the function was called with. Changes to &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; arguments will be visible here.</source>
          <target state="translated">调用函数的参数。对 &lt;code&gt;out&lt;/code&gt; 和 &lt;code&gt;ref&lt;/code&gt; 参数的更改将在此处可见。</target>
        </trans-unit>
        <trans-unit id="63025a0e656a03617731632fd0d058123f82e206" translate="yes" xml:space="preserve">
          <source>The array generated by &lt;code&gt;makeTransTable&lt;/code&gt; is &lt;code&gt;256&lt;/code&gt; elements long such that the index is equal to the ASCII character being replaced and the value is equal to the character that it's being replaced with. Note that translate does not decode any of the characters, so you can actually pass it Extended ASCII characters if you want to (ASCII only actually uses &lt;code&gt;128&lt;/code&gt; characters), but be warned that Extended ASCII characters are not valid Unicode and therefore will result in a &lt;code&gt;UTFException&lt;/code&gt; being thrown from most other Phobos functions.</source>
          <target state="translated">所产生的阵列 &lt;code&gt;makeTransTable&lt;/code&gt; 是 &lt;code&gt;256&lt;/code&gt; 个元件长，使得索引等于ASCII字符被替换并且该值等于它被替换为字符。请注意，translate不会解码任何字符，因此您可以根据需要实际传递它扩展ASCII字符（ASCII实际上仅使用 &lt;code&gt;128&lt;/code&gt; 个字符），但是要警告扩展ASCII字符不是有效的Unicode，因此会导致大多数其他Phobos函数都抛出了 &lt;code&gt;UTFException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e36bd34216b4fb890e4b17cc00a08b3fe10bf73" translate="yes" xml:space="preserve">
          <source>The array indexing and slicing operators are overloaded by implementing the &lt;code&gt;opIndex&lt;/code&gt;, &lt;code&gt;opSlice&lt;/code&gt;, and &lt;code&gt;opDollar&lt;/code&gt; methods. These may be combined to implement multidimensional arrays.</source>
          <target state="translated">数组索引和切片运算符通过实现 &lt;code&gt;opIndex&lt;/code&gt; ， &lt;code&gt;opSlice&lt;/code&gt; 和 &lt;code&gt;opDollar&lt;/code&gt; 方法而过载。这些可以组合以实现多维数组。</target>
        </trans-unit>
        <trans-unit id="1b2a7128d2d832c1302cb48d5006b21f210a2eeb" translate="yes" xml:space="preserve">
          <source>The array of &lt;code&gt;Statements&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if no flattening necessary</source>
          <target state="translated">的阵列 &lt;code&gt;Statements&lt;/code&gt; ，或 &lt;code&gt;null&lt;/code&gt; ，如果没有必要平坦化</target>
        </trans-unit>
        <trans-unit id="45a797de9ee37043ed5d9c3044ead0d769c8dfec" translate="yes" xml:space="preserve">
          <source>The array of allocators is publicly available for e.g. initialization and inspection.</source>
          <target state="translated">分配器的数组是公开的,如初始化和检查。</target>
        </trans-unit>
        <trans-unit id="78465f24447e3c88a59d9835a9423a9e3ebd4f18" translate="yes" xml:space="preserve">
          <source>The array of bits to iterate over</source>
          <target state="translated">迭代的比特数组</target>
        </trans-unit>
        <trans-unit id="4ca952de23045dd7d8a84c57a2dc3a2d3b262893" translate="yes" xml:space="preserve">
          <source>The array that &lt;code&gt;stuff&lt;/code&gt; will be inserted into.</source>
          <target state="translated">&lt;code&gt;stuff&lt;/code&gt; 将插入的数组。</target>
        </trans-unit>
        <trans-unit id="4321c353e1c32d604816547a52f50f3db51eff04" translate="yes" xml:space="preserve">
          <source>The array to cast to immutable.</source>
          <target state="translated">要投向不可变的数组。</target>
        </trans-unit>
        <trans-unit id="c1207d2a97f985ed8f1d6e838bce196b8c261949" translate="yes" xml:space="preserve">
          <source>The array to store the factorial number. The array is of size 21 as &lt;code&gt;ulong.max&lt;/code&gt; requires 21 digits in the factorial number system.</source>
          <target state="translated">存储阶乘数的数组。该数组的大小为21，因为 &lt;code&gt;ulong.max&lt;/code&gt; 在阶乘数系统中需要21位数字。</target>
        </trans-unit>
        <trans-unit id="2e58d1006cb20d5f3840c703c981f56532e89433" translate="yes" xml:space="preserve">
          <source>The array type to simulate</source>
          <target state="translated">要模拟的数组类型</target>
        </trans-unit>
        <trans-unit id="5eff91e039ba4d6d8d23f84bae72af3efca47e6c" translate="yes" xml:space="preserve">
          <source>The asm.js intermediate programming language</source>
          <target state="translated">asm.js中级编程语言。</target>
        </trans-unit>
        <trans-unit id="9e1495896a8171a6a847812d0360c297c1cf65a4" translate="yes" xml:space="preserve">
          <source>The assembled path.</source>
          <target state="translated">组装的路径。</target>
        </trans-unit>
        <trans-unit id="1e2b85b82e92a3856a1e1c2b72d37fa265091420" translate="yes" xml:space="preserve">
          <source>The assertion is independent from -release, by abort()ing. Regular assertions throw an AssertError and thus require an initialized GC, which might not be the case (yet or anymore) for the startup/shutdown code in this package (called by CRT ctors/dtors etc.).</source>
          <target state="translated">通过abort()ing,断言与-release无关。常规的断言会抛出一个AssertError,因此需要一个初始化的GC,对于这个包中的启动/关闭代码(被CRT ctors/dtors等调用)来说,可能不是这样的(现在还不是)。</target>
        </trans-unit>
        <trans-unit id="dd468c6bd7b4f24fe4681661a1f4c1bf9f53f209" translate="yes" xml:space="preserve">
          <source>The assignment character used in options with parameters (default '=').</source>
          <target state="translated">带参数的选项中使用的赋值字符(默认为'=')。</target>
        </trans-unit>
        <trans-unit id="d1cc08d2be4a1f3b1bcdb0c1a5ad7e06c61f4a9a" translate="yes" xml:space="preserve">
          <source>The assignment operator &lt;code&gt;=&lt;/code&gt; can be overloaded if the left hand side is a struct aggregate, and &lt;code&gt;opAssign&lt;/code&gt; is a member function of that aggregate.</source>
          <target state="translated">如果左侧是结构聚合，而 &lt;code&gt;opAssign&lt;/code&gt; 是该聚合的成员函数，则赋值运算符 &lt;code&gt;=&lt;/code&gt; 可以重载。</target>
        </trans-unit>
        <trans-unit id="9ca96b2dca99020e1c9332c4a525410f5467c7f8" translate="yes" xml:space="preserve">
          <source>The associated Tid or Tid.init if name is not registered.</source>
          <target state="translated">相关的Tid或Tid.init(如果名称未注册)。</target>
        </trans-unit>
        <trans-unit id="d2c138793e6130d41176963ee803d482cbf6ac55" translate="yes" xml:space="preserve">
          <source>The associative array to iterate over.</source>
          <target state="translated">迭代的关联数组。</target>
        </trans-unit>
        <trans-unit id="3f8e903e0ceb75b15c10ccad54194376c61bbba7" translate="yes" xml:space="preserve">
          <source>The associative array.</source>
          <target state="translated">关联数组。</target>
        </trans-unit>
        <trans-unit id="7878f31bd1a31b1a2cfd5e7a52ffdc7c9ecd24a9" translate="yes" xml:space="preserve">
          <source>The assumption is that &lt;code&gt;first&lt;/code&gt; comes before &lt;code&gt;second&lt;/code&gt; in the original text, usually meaning that the first is a starter.</source>
          <target state="translated">假定在原始文本中， &lt;code&gt;first&lt;/code&gt; 出现在 &lt;code&gt;second&lt;/code&gt; 之前，通常意味着第一个是启动器。</target>
        </trans-unit>
        <trans-unit id="61806db12d64abe42691b62a374e038f9ecaadda" translate="yes" xml:space="preserve">
          <source>The atomic module provides basic support for lock-free concurrent programming.</source>
          <target state="translated">原子模块为无锁并发编程提供了基本支持。</target>
        </trans-unit>
        <trans-unit id="75eef2eb2a8bfe31e731a278f35f0ceb7c55d5e5" translate="yes" xml:space="preserve">
          <source>The attack happens as follows:</source>
          <target state="translated">攻击的情况如下:</target>
        </trans-unit>
        <trans-unit id="f7c54a735163e7d571809eeacaa1471999099ee3" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached once to a method</source>
          <target state="translated">属性只能对一个方法附加一次。</target>
        </trans-unit>
        <trans-unit id="79ccd1c77d9bb55894eeaf0ddb5f8bb5f1442f97" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached to methods or constructors which have Objective-C linkage. That is, a method or a constructor in a class or interface declared as</source>
          <target state="translated">这个属性只能附加到有Objective-C链接的方法或构造函数上。也就是说,一个类或接口中的方法或构造函数被声明为</target>
        </trans-unit>
        <trans-unit id="9e6a8c7917aafe6dd89c5b3da037ce8ce791dcd0" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached to methods with Objective-C linkage</source>
          <target state="translated">该属性只能附加到具有Objective-C链接的方法上。</target>
        </trans-unit>
        <trans-unit id="0cc4b73eb5ab20f789654491f3d1669a5a798998" translate="yes" xml:space="preserve">
          <source>The attribute cannot be attached to a template method</source>
          <target state="translated">该属性不能附加到模板方法上。</target>
        </trans-unit>
        <trans-unit id="c3e58f213e4368a17eae0f25fdb580af5f953648" translate="yes" xml:space="preserve">
          <source>The attribute is defined in druntime in &lt;a href=&quot;https://dlang.org/phobos/core_attribute.html&quot;&gt;&lt;code&gt;core.attribute&lt;/code&gt;&lt;/a&gt; and aliased in &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;, meaning it will be implicitly imported. The attribute is only defined when the version identifier &lt;a href=&quot;#objc-version-identifier&quot;&gt;&lt;code&gt;D_ObjectiveC&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">该属性在core.attribute的druntime中定义，并在&lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt;中&lt;a href=&quot;https://dlang.org/phobos/core_attribute.html&quot;&gt; &lt;code&gt;core.attribute&lt;/code&gt; &lt;/a&gt;别名，这意味着它将被隐式导入。仅在启用版本标识符&lt;a href=&quot;#objc-version-identifier&quot;&gt; &lt;code&gt;D_ObjectiveC&lt;/code&gt; &lt;/a&gt;时定义该属性。</target>
        </trans-unit>
        <trans-unit id="96eac9336921a98926c132d1b4d9806462791d58" translate="yes" xml:space="preserve">
          <source>The attribute of the type name is not the same as the attribute of the variable:</source>
          <target state="translated">类型名的属性与变量的属性不一样。</target>
        </trans-unit>
        <trans-unit id="24cd99fe8bbe482a8a5a81e7f4b51e39455ae56f" translate="yes" xml:space="preserve">
          <source>The attributes (g, i, m, s and x accepted)</source>
          <target state="translated">属性(g、i、m、s和x接受)</target>
        </trans-unit>
        <trans-unit id="4ee39b3b86f5106a3fdc7e1ea7775bb7c85ac176" translate="yes" xml:space="preserve">
          <source>The attributes of the &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; are applied where the default expression is used.</source>
          <target state="translated">在使用默认表达式的情况下，将应用&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;的属性。</target>
        </trans-unit>
        <trans-unit id="06da5fd89d1e09344f5502c88832d0079ac5062c" translate="yes" xml:space="preserve">
          <source>The attributes of the file as a &lt;code&gt;uint&lt;/code&gt;.</source>
          <target state="translated">文件的属性为 &lt;code&gt;uint&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab103bac227f27736507e49db9f68f7e1c3bdf17" translate="yes" xml:space="preserve">
          <source>The background thread will buffer up to transmitBuffers number of chunks before is stops receiving data from network. When the main thread reads the chunks from the range it frees up buffers and allows for the background thread to receive more data from the network.</source>
          <target state="translated">后台线程在停止从网络接收数据之前,会缓冲到 transmitBuffers 的分块数量。当主线程从范围内读取chunks时,它可以释放缓冲区,允许后台线程从网络上接收更多的数据。</target>
        </trans-unit>
        <trans-unit id="2f49fc1ac2fa753eb385adebbde8c5e3739e3eb5" translate="yes" xml:space="preserve">
          <source>The background thread will buffer up to transmitBuffers number of lines before it stops receiving data from network. When the main thread reads the lines from the range it frees up buffers and allows for the background thread to receive more data from the network.</source>
          <target state="translated">后台线程在停止从网络接收数据之前,会缓冲到 transmitBuffers 的行数。当主线程从范围内读取行数时,会释放缓冲区,允许后台线程从网络接收更多数据。</target>
        </trans-unit>
        <trans-unit id="df002316032ff2e092a1cc3a410d04df468eda1d" translate="yes" xml:space="preserve">
          <source>The backslash character is not treated specially inside &lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt; strings.</source>
          <target state="translated">在&lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt;字符串中未对反斜杠字符进行特殊处理。</target>
        </trans-unit>
        <trans-unit id="a707c2f980ce4edb81a7e52be4d3486a20f75970" translate="yes" xml:space="preserve">
          <source>The barrier module provides a primitive for synchronizing the progress of a group of threads.</source>
          <target state="translated">屏障模块提供了一个用于同步一组线程进度的基元。</target>
        </trans-unit>
        <trans-unit id="0f16b21bd145c48ee38391d193636c622ee32ed4" translate="yes" xml:space="preserve">
          <source>The base address of the memory block referenced by p or null on error.</source>
          <target state="translated">p引用的内存块的基本地址,错误时为空。</target>
        </trans-unit>
        <trans-unit id="202abe43b53a16dc33ac200ec72cb69c866674c7" translate="yes" xml:space="preserve">
          <source>The base class for exceptions thrown by this module</source>
          <target state="translated">本模块抛出的异常的基类。</target>
        </trans-unit>
        <trans-unit id="1a2d8f5221992ec16fa6b9228ee8706ba1b5f8a3" translate="yes" xml:space="preserve">
          <source>The base class of all AST nodes.</source>
          <target state="translated">所有AST节点的基类。</target>
        </trans-unit>
        <trans-unit id="2c62b6527d85866989d96fc04ef66293021bf4e4" translate="yes" xml:space="preserve">
          <source>The base class of all errors that are safe to catch and handle.</source>
          <target state="translated">所有可以安全捕捉和处理的错误的基类。</target>
        </trans-unit>
        <trans-unit id="3d510f9f0a1f647c90ed3c0e84e9bc68e62fbef9" translate="yes" xml:space="preserve">
          <source>The base class of all thrown objects.</source>
          <target state="translated">所有抛出对象的基类。</target>
        </trans-unit>
        <trans-unit id="f59893c50b7d9f6fccbb634dce991efa1ec27e2a" translate="yes" xml:space="preserve">
          <source>The base class of all unrecoverable runtime errors.</source>
          <target state="translated">所有不可恢复的运行时错误的基类。</target>
        </trans-unit>
        <trans-unit id="2ae564b78fab59c5ea57c135e5d25f9a2f2f9e56" translate="yes" xml:space="preserve">
          <source>The base path to construct the relative path from.</source>
          <target state="translated">构建相对路径的基本路径。</target>
        </trans-unit>
        <trans-unit id="7b8c780a7aaf44d0ec25e2d71c9d91275146dbb5" translate="yes" xml:space="preserve">
          <source>The base ptr in this struct can be cleared asynchronously by the GC, so any use of the returned BlkInfo should copy it and then check the base ptr of the copy before actually using it.</source>
          <target state="translated">这个结构中的base ptr可以被GC异步清除,所以任何对返回的BlkInfo的使用都应该复制它,然后在实际使用它之前检查复制的base ptr。</target>
        </trans-unit>
        <trans-unit id="8690f4437635a1d2bf0002da1660f73ae69c67e5" translate="yes" xml:space="preserve">
          <source>The base type.</source>
          <target state="translated">基础类型:</target>
        </trans-unit>
        <trans-unit id="dbcf092daafa8f2354629e2a622f62afa3a72b3b" translate="yes" xml:space="preserve">
          <source>The basetype must be one of: byte[16],ubyte[16],short[8],ushort[8],int[4],uint[4],long[2],ulong[2],float[4],double[2] For AVX: byte[32],ubyte[32],short[16],ushort[16],int[8],uint[8],long[4],ulong[4],float[8],double[4]</source>
          <target state="translated">基准类型必须是以下之一:byte[16],ubyte[16],short[8],ushort[8],int[4],uint[4],long[2],ulong[2],float[4],double[2]对于AVX:byte[32],ubyte[32],short[16],ushort[16],int[8],uint[8],long[4],ulong[4],float[8],double[4)</target>
        </trans-unit>
        <trans-unit id="399482d1c370eb1ac5e16d0aa1eed3cdd1c42d74" translate="yes" xml:space="preserve">
          <source>The basic architecture of this module is that there are standalone functions, classes for constructing an XML document from scratch (Tag, Element and Document), and also classes for parsing a pre-existing XML file (ElementParser and DocumentParser). The parsing classes</source>
          <target state="translated">这个模块的基本架构是,有独立的函数,有从头开始构建XML文档的类(Tag、Element和Document),也有解析已有XML文件的类(ElementParser和DocumentParser)。解析类</target>
        </trans-unit>
        <trans-unit id="bd83f1731835a7762685d9b1b4c80ae22caa482b" translate="yes" xml:space="preserve">
          <source>The basic syntax shouldn't surprise experienced users of regular expressions. For an introduction to &lt;code&gt;std.regex&lt;/code&gt; see a &lt;a href=&quot;http://dlang.org/regular-expression.html&quot;&gt;short tour&lt;/a&gt; of the module API and its abilities.</source>
          <target state="translated">基本语法不应令有经验的正则表达式用户感到惊讶。有关 &lt;code&gt;std.regex&lt;/code&gt; 的介绍，请参见模块API及其功能的&lt;a href=&quot;http://dlang.org/regular-expression.html&quot;&gt;简短&lt;/a&gt;介绍。</target>
        </trans-unit>
        <trans-unit id="234f6e28893085e219de1f945a7e3dc32736e80c" translate="yes" xml:space="preserve">
          <source>The behavior executed when a message is sent to a full mailbox.</source>
          <target state="translated">当一个邮件被发送到一个完整的邮箱时执行的行为。</target>
        </trans-unit>
        <trans-unit id="ab5c4600b299e121274047c9c50598443a05a652" translate="yes" xml:space="preserve">
          <source>The behavior when a</source>
          <target state="translated">时的行为。</target>
        </trans-unit>
        <trans-unit id="10d232650e9a8e91839d30ef0b07aa3a7812c3ee" translate="yes" xml:space="preserve">
          <source>The behavior when the invariant does not hold is typically the same as for when &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;s fail.</source>
          <target state="translated">不变式不成立时的行为通常与&lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;失败时的行为相同。</target>
        </trans-unit>
        <trans-unit id="32c253b8b8075fafad7db46ce9573fe20079099e" translate="yes" xml:space="preserve">
          <source>The best way is to use std.stdio.writefln, which can handle D strings:</source>
          <target state="translated">最好的方法是使用std.stdio.writefln,它可以处理D字符串。</target>
        </trans-unit>
        <trans-unit id="074a4ed5e1cf5284566f4613af5758030a468edf" translate="yes" xml:space="preserve">
          <source>The beta function is defined as</source>
          <target state="translated">beta函数定义为</target>
        </trans-unit>
        <trans-unit id="776df6b9101ffe92329a9ec86d4f259d56f6f5cd" translate="yes" xml:space="preserve">
          <source>The binary heap induces structure over the underlying store such that accessing the largest element (by using the &lt;code&gt;front&lt;/code&gt; property) is a &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) operation and extracting it (by using the &lt;code&gt;removeFront()&lt;/code&gt; method) is done fast in &amp;Omicron;(&lt;code&gt;log n&lt;/code&gt;) time.</source>
          <target state="translated">二进制堆在底层存储上引发结构，因此访问最大元素（通过使用 &lt;code&gt;front&lt;/code&gt; 属性）是&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）操作，并在&amp;Omicron;（ &lt;code&gt;log n&lt;/code&gt; ）中快速完成对其的提取（通过使用 &lt;code&gt;removeFront()&lt;/code&gt; 方法）。时间。</target>
        </trans-unit>
        <trans-unit id="4c8ec4e4b9635f6e100188d75e888fd06cd8e192" translate="yes" xml:space="preserve">
          <source>The binary operator involved, e.g. &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">涉及的二进制运算符，例如 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d68c85a934ba6bb56625f3815258575a45ac4309" translate="yes" xml:space="preserve">
          <source>The binary operator ~ is the</source>
          <target state="translated">二进制运算符~是</target>
        </trans-unit>
        <trans-unit id="97c48bbd4c951e34df677fdb5ba8d5cff4f6b9ee" translate="yes" xml:space="preserve">
          <source>The binary predicate to compare the elements of the two ranges.</source>
          <target state="translated">二进制谓词来比较两个范围的元素。</target>
        </trans-unit>
        <trans-unit id="c0f1385da3c1b4c526f08c5b626218775066160e" translate="yes" xml:space="preserve">
          <source>The bit number of the first bit set. The return value is undefined if v is zero.</source>
          <target state="translated">设置的第一个位的位数。如果v为0,则返回值未定义。</target>
        </trans-unit>
        <trans-unit id="f465b8408295f09e1e80dc77dc9289f124c8a06a" translate="yes" xml:space="preserve">
          <source>The bitwise OR of the equivalent &lt;a href=&quot;#ParameterStorageClass&quot;&gt;&lt;code&gt;ParameterStorageClass&lt;/code&gt;&lt;/a&gt;&lt;code&gt;enum&lt;/code&gt;s.</source>
          <target state="translated">等效的&lt;a href=&quot;#ParameterStorageClass&quot;&gt; &lt;code&gt;ParameterStorageClass&lt;/code&gt; &lt;/a&gt; &lt;code&gt;enum&lt;/code&gt; 的按位或。</target>
        </trans-unit>
        <trans-unit id="4fdcc0b7027ad4b488f80691f340dd0dc77ff487" translate="yes" xml:space="preserve">
          <source>The block statement form is:</source>
          <target state="translated">块声明的形式是:</target>
        </trans-unit>
        <trans-unit id="dd4bbefc576334b8b13692b8e44bc6ee98e6f364" translate="yes" xml:space="preserve">
          <source>The body of the</source>
          <target state="translated">该机构的</target>
        </trans-unit>
        <trans-unit id="96cd6fd8f2e0864106740818ab2710f9f6ce82f8" translate="yes" xml:space="preserve">
          <source>The body of the constructor is executed.</source>
          <target state="translated">构造函数的主体被执行。</target>
        </trans-unit>
        <trans-unit id="6863a629a6b6532a62dd2be0fcf0c83cbe0ecc4b" translate="yes" xml:space="preserve">
          <source>The bool type is a byte-size type that can only hold the value &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">布尔类型是字节大小的类型，只能保留值 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="595a315b8710f1cdf54c5c5a89b18ff6fdc7c01a" translate="yes" xml:space="preserve">
          <source>The bound being violated</source>
          <target state="translated">被违反的约束</target>
        </trans-unit>
        <trans-unit id="58bf9949e91d1f67475ea8dd8dc1479acb9a7b6c" translate="yes" xml:space="preserve">
          <source>The buffer to store decoded result.</source>
          <target state="translated">储存解码结果的缓冲区。</target>
        </trans-unit>
        <trans-unit id="cbd8e18ccd6c72e47f49142b87596eb0b37a2753" translate="yes" xml:space="preserve">
          <source>The buffer to write to</source>
          <target state="translated">要写入的缓冲区</target>
        </trans-unit>
        <trans-unit id="d4158bf50efe732ca75d7c0746df60cf6a107caa" translate="yes" xml:space="preserve">
          <source>The built in properties &lt;code&gt;.sizeof&lt;/code&gt;, &lt;code&gt;.alignof&lt;/code&gt;, and &lt;code&gt;.mangleof&lt;/code&gt; may not be declared as fields or methods in structs, unions, classes or enums.</source>
          <target state="translated">内置属性 &lt;code&gt;.sizeof&lt;/code&gt; ， &lt;code&gt;.alignof&lt;/code&gt; 和 &lt;code&gt;.mangleof&lt;/code&gt; 不得在结构，联合，类或枚举中声明为字段或方法。</target>
        </trans-unit>
        <trans-unit id="cb37eb5828bb8f76b215ba701695af10297cc319" translate="yes" xml:space="preserve">
          <source>The built-in address-of operator (unary &lt;code&gt;&amp;amp;&lt;/code&gt;) may only be applied to lvalues.</source>
          <target state="translated">内置地址运算符（一元 &lt;code&gt;&amp;amp;&lt;/code&gt; ）只能应用于左值。</target>
        </trans-unit>
        <trans-unit id="01d529a280bedf8d2329f923f87f28d6d2414970" translate="yes" xml:space="preserve">
          <source>The built-in char types are any of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt; or &lt;code&gt;dchar&lt;/code&gt;, with or without qualifiers.</source>
          <target state="translated">内置的char类型是 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;wchar&lt;/code&gt; 或 &lt;code&gt;dchar&lt;/code&gt; 中的任何一个，带有或不带有限定符。</target>
        </trans-unit>
        <trans-unit id="26447929ba19118cb6719911318de883e533656a" translate="yes" xml:space="preserve">
          <source>The built-in string types are &lt;code&gt;Char[]&lt;/code&gt;, where &lt;code&gt;Char&lt;/code&gt; is any of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt; or &lt;code&gt;dchar&lt;/code&gt;, with or without qualifiers.</source>
          <target state="translated">内置的字符串类型为 &lt;code&gt;Char[]&lt;/code&gt; ，其中 &lt;code&gt;Char&lt;/code&gt; 是 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;wchar&lt;/code&gt; 或 &lt;code&gt;dchar&lt;/code&gt; 中的任何一个，带有或不带有限定符。</target>
        </trans-unit>
        <trans-unit id="985d41f10ebe09bea42e87e43e676a34b5b701c9" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gapWeightedSimilarity(s, t, 1)&lt;/code&gt; simply counts all of these matches and adds them up, returning 7.</source>
          <target state="translated">调用 &lt;code&gt;gapWeightedSimilarity(s, t, 1)&lt;/code&gt; 简单地计算所有这些匹配并将它们相加，返回7。</target>
        </trans-unit>
        <trans-unit id="9504202f5ac0a1e1b308309ee50027e163c8c607" translate="yes" xml:space="preserve">
          <source>The call above eliminated the gapped matches (&lt;code&gt;&quot;Hello&quot;, &quot;new&quot;&lt;/code&gt;), (&lt;code&gt;&quot;Hello&quot;, &quot;world&quot;&lt;/code&gt;), and (&lt;code&gt;&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;&lt;/code&gt;) from the tally. That leaves only 4 matches.</source>
          <target state="translated">上面的调用从计数中消除了空缺的匹配项（ &lt;code&gt;&quot;Hello&quot;, &quot;new&quot;&lt;/code&gt; ），（ &lt;code&gt;&quot;Hello&quot;, &quot;world&quot;&lt;/code&gt; ）和（ &lt;code&gt;&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;&lt;/code&gt; ）。那只剩下4场比赛。</target>
        </trans-unit>
        <trans-unit id="a0a65d3fa68c14100a930ea8ba7a95c4b2425c75" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;func()&lt;/code&gt; is ambiguous because Foo.func and Bar.func are in different scopes.</source>
          <target state="translated">由于Foo.func和Bar.func的作用域不同，因此对 &lt;code&gt;func()&lt;/code&gt; 的调用不明确。</target>
        </trans-unit>
        <trans-unit id="e538f3dd7f1bdd1b474917678b37be623289cdfe" translate="yes" xml:space="preserve">
          <source>The call will duplicate the array appropriately.  Note that checking for uniqueness during compilation is possible in certain cases, especially when a function is marked as a pure function. The following example does not need to call assumeUnique because the compiler can infer the uniqueness of the array in the pure function:</source>
          <target state="translated">调用会适当地复制数组。注意,在某些情况下,特别是当一个函数被标记为纯函数时,在编译过程中检查唯一性是可能的。下面的例子不需要调用 assumeUnique,因为编译器可以推断出纯函数中数组的唯一性。</target>
        </trans-unit>
        <trans-unit id="242f08d2b1a1a758366f7a48d7e4dad847e662cb" translate="yes" xml:space="preserve">
          <source>The callable that is called when a handled primitive throws a &lt;code&gt;Throwable&lt;/code&gt; of type &lt;code&gt;E&lt;/code&gt;. The handler must accept arguments of the form &lt;code&gt;E, ref IRange&lt;/code&gt; and its return value is used as the primitive's return value whenever &lt;code&gt;E&lt;/code&gt; is thrown. For &lt;code&gt;opIndex&lt;/code&gt;, the handler can optionally recieve a third argument; the index that caused the exception.</source>
          <target state="translated">当已处理原语抛出类型 &lt;code&gt;E&lt;/code&gt; 的 &lt;code&gt;Throwable&lt;/code&gt; 时调用的callable 。处理程序必须接受形式的参数 &lt;code&gt;E, ref IRange&lt;/code&gt; 每当它的返回值被用作原始的返回值 &lt;code&gt;E&lt;/code&gt; 被抛出。对于 &lt;code&gt;opIndex&lt;/code&gt; ，处理程序可以选择接收第三个参数；导致异常的索引。</target>
        </trans-unit>
        <trans-unit id="8595a4fb5e8942c865e60e579f4bc97ae9361768" translate="yes" xml:space="preserve">
          <source>The callable to apply on create.</source>
          <target state="translated">创建时要应用的可调用。</target>
        </trans-unit>
        <trans-unit id="9e7cb4c784340dbcc9223bb09fc5bd0008d15a78" translate="yes" xml:space="preserve">
          <source>The callable to apply on update.</source>
          <target state="translated">更新时应用的可调用。</target>
        </trans-unit>
        <trans-unit id="47f8d3d3341c2f3859f008d663d7d39abed383a3" translate="yes" xml:space="preserve">
          <source>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value .pauseRequest can be returned in order to pause the current request.</source>
          <target state="translated">回调返回读取到的字节。如果不是整个数组,请求将被中止。可以返回特殊值.pauseRequest来暂停当前的请求。</target>
        </trans-unit>
        <trans-unit id="7ff970a770b2ff7a8a51d3f9664a81966555d9c0" translate="yes" xml:space="preserve">
          <source>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value HTTP.pauseRequest can be returned in order to pause the current request.</source>
          <target state="translated">回调返回读取到的字节。如果不是整个数组,请求将被中止。为了暂停当前请求,可以返回特殊值HTTP.pauseRequest。</target>
        </trans-unit>
        <trans-unit id="8e149c07dded4d56d5080da41c572390f4d5c4e3" translate="yes" xml:space="preserve">
          <source>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value &lt;code&gt;.abortRequest&lt;/code&gt; can be returned in order to abort the current request. The special value &lt;code&gt;.pauseRequest&lt;/code&gt; can be returned in order to pause the current request.</source>
          <target state="translated">回调返回缓冲区中已填充并准备发送的元素数。可以返回特殊值 &lt;code&gt;.abortRequest&lt;/code&gt; 来中止当前请求。可以返回特殊值 &lt;code&gt;.pauseRequest&lt;/code&gt; ，以暂停当前请求。</target>
        </trans-unit>
        <trans-unit id="2137ada3ae84929eb868bf721851f3520aa621f8" translate="yes" xml:space="preserve">
          <source>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value &lt;code&gt;Curl.abortRequest&lt;/code&gt; can be returned in order to abort the current request. The special value &lt;code&gt;Curl.pauseRequest&lt;/code&gt; can be returned in order to pause the current request.</source>
          <target state="translated">回调返回缓冲区中已填充并准备发送的元素数。可以返回特殊值 &lt;code&gt;Curl.abortRequest&lt;/code&gt; 来中止当前请求。可以返回特殊值 &lt;code&gt;Curl.pauseRequest&lt;/code&gt; ，以暂停当前请求。</target>
        </trans-unit>
        <trans-unit id="559652851d8e835ca6e4e25200037a9b2b88d7e9" translate="yes" xml:space="preserve">
          <source>The callback returns the success state of the seeking &lt;a href=&quot;etc_c_curl#CurlSeek&quot;&gt;&lt;code&gt;etc.c.curl.CurlSeek&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">回调返回寻找&lt;a href=&quot;etc_c_curl#CurlSeek&quot;&gt; &lt;code&gt;etc.c.curl.CurlSeek&lt;/code&gt; &lt;/a&gt;的成功状态</target>
        </trans-unit>
        <trans-unit id="4f77b46c5f5f6357c24d9647b815993a85d323b8" translate="yes" xml:space="preserve">
          <source>The callback should return zero.</source>
          <target state="translated">回调应该返回零。</target>
        </trans-unit>
        <trans-unit id="bf29eeac01c5a4dd86a6df695ab4b58778a8d6c6" translate="yes" xml:space="preserve">
          <source>The callback will receive a header field key, value as parameter. The &lt;code&gt;const(char)[]&lt;/code&gt; arrays are not valid after the delegate has returned.</source>
          <target state="translated">回调将接收标头字段关键字，值作为参数。所述 &lt;code&gt;const(char)[]&lt;/code&gt; 阵列无效委托返回之后。</target>
        </trans-unit>
        <trans-unit id="0479a0d5e5b9b6df459258bae677881c90ce0ee0" translate="yes" xml:space="preserve">
          <source>The callee cleans the stack.</source>
          <target state="translated">受话人清理堆栈。</target>
        </trans-unit>
        <trans-unit id="969d6b1248484a0e1ba90ba5ae45f38dfe225ca5" translate="yes" xml:space="preserve">
          <source>The caller guarantees that there are no other live pointers to the passed memory block, still it might not be freed immediately by &lt;code&gt;realloc&lt;/code&gt;. The garbage collector can reclaim the memory block in a later collection if it is unused. If allocation fails, this function will throw an &lt;code&gt;OutOfMemoryError&lt;/code&gt;.</source>
          <target state="translated">调用方保证没有其他活动指针指向已传递的内存块，但仍可能不会被 &lt;code&gt;realloc&lt;/code&gt; 立即释放。垃圾回收器可以在以后的回收中回收未使用的内存块。如果分配失败，此函数将抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42c8382f8ef7fb6520cb3687eb152b34b852d9fc" translate="yes" xml:space="preserve">
          <source>The caller is expected to clean the stack. &lt;code&gt;_argptr&lt;/code&gt; is not passed, it is computed by the callee.</source>
          <target state="translated">呼叫者应清理堆栈。 &lt;code&gt;_argptr&lt;/code&gt; 未传递，它由被调用者计算。</target>
        </trans-unit>
        <trans-unit id="71f4f46b73c55f9c109f0c80b9ef8abbb104d1fb" translate="yes" xml:space="preserve">
          <source>The calling thread must be attached to the runtime.</source>
          <target state="translated">调用线程必须连接到运行时。</target>
        </trans-unit>
        <trans-unit id="958f07aa30dc8c63baec5ad6b7a6ab8de498d71d" translate="yes" xml:space="preserve">
          <source>The canonical name is returned in &lt;code&gt;canonicalName&lt;/code&gt; member in the first &lt;code&gt;AddressInfo&lt;/code&gt;.</source>
          <target state="translated">在第一个 &lt;code&gt;AddressInfo&lt;/code&gt; 中的 &lt;code&gt;canonicalName&lt;/code&gt; 成员中返回规范名称。</target>
        </trans-unit>
        <trans-unit id="5578f20f728ef7ea894f9c8485dc8375879fa1eb" translate="yes" xml:space="preserve">
          <source>The capacity of a slice may be impacted by operations on other slices.</source>
          <target state="translated">一个片子的容量可能会受到其他片子操作的影响。</target>
        </trans-unit>
        <trans-unit id="107b78d2e608ef92e8a7f001aab1e580890d2636" translate="yes" xml:space="preserve">
          <source>The capitalized string.</source>
          <target state="translated">大写的字符串。</target>
        </trans-unit>
        <trans-unit id="a02d900e092203fe7acb10d7253e6c7295d71b57" translate="yes" xml:space="preserve">
          <source>The case expressions cannot evaluate to a run time initialized value.</source>
          <target state="translated">案例表达式不能评估为运行时的初始化值。</target>
        </trans-unit>
        <trans-unit id="c660de992148409122dcd32983da08c9290b863c" translate="yes" xml:space="preserve">
          <source>The case expressions must all evaluate to a constant value or array, or a runtime initialized const or immutable variable of integral type. They must be implicitly convertible to the type of the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">案例表达式必须全部求值为常数值或数组，或运行时初始化的const或整数类型的不可变变量。它们必须隐式转换为Switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="5f4e6b9553e729310217386d882aa9d464ad3e08" translate="yes" xml:space="preserve">
          <source>The case expressions, &lt;a href=&quot;expression#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;, are a comma separated list of expressions.</source>
          <target state="translated">案例表达式&lt;a href=&quot;expression#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;是逗号分隔的表达式列表。</target>
        </trans-unit>
        <trans-unit id="5c065923e841d97029a1a1a23e3c446aaf97b033" translate="yes" xml:space="preserve">
          <source>The character that terminates a line</source>
          <target state="translated">终止一行的字符</target>
        </trans-unit>
        <trans-unit id="629001ed0c4dadc576ebea811f98cc1aed6e90df" translate="yes" xml:space="preserve">
          <source>The character to represent a comma in the specification</source>
          <target state="translated">规范中表示逗号的字符</target>
        </trans-unit>
        <trans-unit id="ec12026df227efabbda621551d1564e02d496853" translate="yes" xml:space="preserve">
          <source>The character to represent a quote in the specification</source>
          <target state="translated">在规格中表示引号的字符</target>
        </trans-unit>
        <trans-unit id="ed980b4c59776662298660727d4c9f56b2f99259" translate="yes" xml:space="preserve">
          <source>The character to test.</source>
          <target state="translated">要测试的角色。</target>
        </trans-unit>
        <trans-unit id="f806bb97e00ae2a4d1965414bf699f20536e139e" translate="yes" xml:space="preserve">
          <source>The character to use for filling excess space in the field</source>
          <target state="translated">用于填充字段中多余空间的字符。</target>
        </trans-unit>
        <trans-unit id="7954bf846b49b756c8f7adbc1f7bb59d31d8fe0f" translate="yes" xml:space="preserve">
          <source>The character-based range to be split. Must be a string, or a random-access range of character types.</source>
          <target state="translated">要分割的基于字符的范围。必须是一个字符串,或随机访问的字符类型范围。</target>
        </trans-unit>
        <trans-unit id="da430ad7582915a68166d7b59e0099addfd5c754" translate="yes" xml:space="preserve">
          <source>The characters to remove from the string.</source>
          <target state="translated">要从字符串中删除的字符。</target>
        </trans-unit>
        <trans-unit id="0bc92faf6490d5bb1265aa7a3286ff3cc0386eb8" translate="yes" xml:space="preserve">
          <source>The characters to replace with.</source>
          <target state="translated">的字符来代替。</target>
        </trans-unit>
        <trans-unit id="b24b1e6a036609d0af960c16ec68d51a3e145307" translate="yes" xml:space="preserve">
          <source>The characters to replace.</source>
          <target state="translated">要替换的字符。</target>
        </trans-unit>
        <trans-unit id="da530bf40507c33ab0ce7b6f55c2e0bfe50af65c" translate="yes" xml:space="preserve">
          <source>The choice of the normalization form depends on the particular use case. NFC is the best form for general text, since it's more compatible with strings converted from legacy encodings. NFKC is the preferred form for identifiers, especially where there are security concerns. NFD and NFKD are the most useful for internal processing.</source>
          <target state="translated">正则化形式的选择取决于特定的使用情况。NFC是一般文本的最佳形式,因为它与从传统编码转换而来的字符串更加兼容。NFKC是标识符的首选形式,特别是在有安全问题的情况下。NFD和NFKD对内部处理最有用。</target>
        </trans-unit>
        <trans-unit id="f5c734e10fd22e90551eca30f40d587d99f0c42a" translate="yes" xml:space="preserve">
          <source>The class allocator is not called if the instance is created on the stack.</source>
          <target state="translated">如果实例是在堆栈上创建的,则不调用类分配器。</target>
        </trans-unit>
        <trans-unit id="888d63439c91bbcddad644e4c7db9438fc2745dc" translate="yes" xml:space="preserve">
          <source>The class declaration this belongs to.</source>
          <target state="translated">这所属的类声明。</target>
        </trans-unit>
        <trans-unit id="9821e074c45da0757bbe913fb06d396a19d66ece" translate="yes" xml:space="preserve">
          <source>The class definition:</source>
          <target state="translated">类定义。</target>
        </trans-unit>
        <trans-unit id="6cd8612310d940ff26e5edb5b4fcdb1ec41c2ab8" translate="yes" xml:space="preserve">
          <source>The class destructor will be called when the result of &lt;code&gt;scoped()&lt;/code&gt; is itself destroyed.</source>
          <target state="translated">当 &lt;code&gt;scoped()&lt;/code&gt; 的结果本身被销毁时，将调用类析构函数。</target>
        </trans-unit>
        <trans-unit id="c93c7a1d79db5f0e6fcfb2d97ac7ab27199857e4" translate="yes" xml:space="preserve">
          <source>The code above is equivalent to:</source>
          <target state="translated">上述代码相当于:</target>
        </trans-unit>
        <trans-unit id="5b07f3ff2ae08c1115f9318187e98dfad8b61d12" translate="yes" xml:space="preserve">
          <source>The code below defines a scalable allocator consisting of 1 MB (or larger) blocks fetched from the garbage-collected heap. Each block is organized as a KR-style heap. More blocks are allocated and freed on a need basis.  This is the closest example to the allocator introduced in the K&amp;amp;R book. It should perform slightly better because instead of searching through one large free list, it searches through several shorter lists in LRU order. Also, it actually returns memory to the operating system when possible.</source>
          <target state="translated">下面的代码定义了一个可伸缩的分配器，该分配器由从垃圾回收堆中提取的1 MB（或更大）的块组成。每个块都组织为KR样式的堆。根据需要分配和释放更多块。这是最接近K＆R书中介绍的分配器的示例。它的性能应稍好一些，因为它不是按一个大的空闲列表搜索，而是按LRU顺序搜索几个较短的列表。另外，它实际上尽可能地将内存返回给操作系统。</target>
        </trans-unit>
        <trans-unit id="12ac0fdde9cbd45bcf0987afae5cbf0bd1ef3d0f" translate="yes" xml:space="preserve">
          <source>The code example below shows a simple implementation of a 2-dimensional array with overloaded indexing and slicing operators. The explanations of the various constructs employed are given in the sections following.</source>
          <target state="translated">下面的代码示例显示了一个带有重载索引和分片运算符的二维数组的简单实现。在下面的章节中对所使用的各种构造进行了解释。</target>
        </trans-unit>
        <trans-unit id="0ef6a79ff5d24e866faf6946cbbd2a6330b8fc2c" translate="yes" xml:space="preserve">
          <source>The code generated by these three functions is identical. To indicate that these can be one function, the inout type constructor is employed:</source>
          <target state="translated">这三个函数生成的代码是相同的。为了表示这些函数可以是一个函数,采用了inout类型构造函数。</target>
        </trans-unit>
        <trans-unit id="a7b0bdcbeba131b0b10ad17da0e5e625fbde9d3f" translate="yes" xml:space="preserve">
          <source>The code in the invariant may not call any public non-static members of the class or struct, either directly or indirectly. Doing so will result in a stack overflow, as the invariant will wind up being called in an infinitely recursive manner.</source>
          <target state="translated">不变式中的代码不能直接或间接调用类或结构的任何公共非静态成员。这样做会导致堆栈溢出,因为不变式会以无限递归的方式被调用。</target>
        </trans-unit>
        <trans-unit id="5567d3893a01342e1a0bc105518655a6faaaab38" translate="yes" xml:space="preserve">
          <source>The code that detects an error knows more about the error than the code that must recover from the error.</source>
          <target state="translated">检测错误的代码比必须从错误中恢复的代码更了解错误。</target>
        </trans-unit>
        <trans-unit id="820bb6ee9e6aba52c669ddd54299d0ca78f94c71" translate="yes" xml:space="preserve">
          <source>The code to implement this API is not available in the public release of SQLite.</source>
          <target state="translated">实现这个API的代码在SQLite的公开版本中是不可用的。</target>
        </trans-unit>
        <trans-unit id="0b173c608e91ac1dd9ab1e2ebbf859ba8dcba5c7" translate="yes" xml:space="preserve">
          <source>The comment form must match the D language comments.</source>
          <target state="translated">评论表必须与D语言评论相匹配。</target>
        </trans-unit>
        <trans-unit id="c27e68ae34b416356827d090284f419f63369dc7" translate="yes" xml:space="preserve">
          <source>The communication domain used to resolve an address.</source>
          <target state="translated">用于解析地址的通信域。</target>
        </trans-unit>
        <trans-unit id="a8ad0e630b8b0da66aee6c7edb8a63daad73619d" translate="yes" xml:space="preserve">
          <source>The comparison predicate</source>
          <target state="translated">比较谓词</target>
        </trans-unit>
        <trans-unit id="8236e0769cfa2f3f369ae0002ca893f3e532ba5d" translate="yes" xml:space="preserve">
          <source>The comparison to use.</source>
          <target state="translated">要用的比较。</target>
        </trans-unit>
        <trans-unit id="5dabbbc6b85984f7c631dd31a40e4692958581a7" translate="yes" xml:space="preserve">
          <source>The comparison value.</source>
          <target state="translated">比较值。</target>
        </trans-unit>
        <trans-unit id="1884ff0398391fb51645ddf67a895753f5f23bb8" translate="yes" xml:space="preserve">
          <source>The compile time length of &lt;code&gt;arr&lt;/code&gt; if it's known.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 的编译时间长度（如果已知）。</target>
        </trans-unit>
        <trans-unit id="20e21ca3ed0c66cb684853be4c9050ce61bc28b7" translate="yes" xml:space="preserve">
          <source>The compiler is free to assume the assert expression is true and optimize subsequent code accordingly.</source>
          <target state="translated">编译器可以自由假设断言表达式为真,并据此优化后续代码。</target>
        </trans-unit>
        <trans-unit id="7c2be101920c07dfed2a3b2ae4e783a017a150b5" translate="yes" xml:space="preserve">
          <source>The compiler lowers expressions of &lt;code&gt;cast(TTo[])TFrom[]&lt;/code&gt; to this implementation.</source>
          <target state="translated">编译器将 &lt;code&gt;cast(TTo[])TFrom[]&lt;/code&gt; 表达式降低为此实现。</target>
        </trans-unit>
        <trans-unit id="3119e558dc9b76ce9fd8e624bacd61cca8100ec6" translate="yes" xml:space="preserve">
          <source>The compiler makes the decision whether to inline a function or not. This decision may be controlled by &lt;a href=&quot;pragma#inline&quot;&gt;&lt;code&gt;pragma(inline)&lt;/code&gt;&lt;/a&gt;, assuming that the compiler implements it, which is not mandatory.</source>
          <target state="translated">编译器决定是否内联函数。假定编译器实现了该决定，则该决定可由&lt;a href=&quot;pragma#inline&quot;&gt; &lt;code&gt;pragma(inline)&lt;/code&gt; &lt;/a&gt;控制，这不是强制性的。</target>
        </trans-unit>
        <trans-unit id="291025563ce73c7bc11eafe0442e20ca4b9ab725" translate="yes" xml:space="preserve">
          <source>The compiler performs the following checks to enforce the correct usage of the &lt;code&gt;@selector&lt;/code&gt; attribute:</source>
          <target state="translated">编译器执行以下检查以强制正确使用 &lt;code&gt;@selector&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="634747431ffe30a4862ec872dad71a6eb253993f" translate="yes" xml:space="preserve">
          <source>The compiler will not give an error if the hidden function is disjoint, as far as overloading is concerned, from all the other virtual functions is the inheritance hierarchy.</source>
          <target state="translated">如果隐藏函数是不相干的,就重载而言,编译器不会给出一个错误,从所有其他虚拟函数是继承层次结构。</target>
        </trans-unit>
        <trans-unit id="7e55718066f0afe8bf9a0cce63044c7450d60879" translate="yes" xml:space="preserve">
          <source>The compiler will then know to use the symbols from std.datetime.stopwatch rather than the deprecated ones from std.datetime.package.</source>
          <target state="translated">编译器将知道使用std.datetime.stopwatch中的符号,而不是使用std.datetime.pack中的废弃符号。</target>
        </trans-unit>
        <trans-unit id="473d434a9b1e1fa3c3fa95983b0cf370022ebc41" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 的复共轭。</target>
        </trans-unit>
        <trans-unit id="0c3998eac6614ebf21d49abc1e3b482249568f18" translate="yes" xml:space="preserve">
          <source>The complex number with the given modulus and argument.</source>
          <target state="translated">给定模数和参数的复数。</target>
        </trans-unit>
        <trans-unit id="ffd55f19d01437a4948ba1ff58d0011690958c82" translate="yes" xml:space="preserve">
          <source>The concepts of &lt;a href=&quot;#Canonical%20equivalent&quot;&gt;canonical equivalent&lt;/a&gt; or &lt;a href=&quot;#Compatibility%20equivalent&quot;&gt;compatibility equivalent&lt;/a&gt; characters in the Unicode Standard make it necessary to have a full, formal definition of equivalence for Unicode strings. String equivalence is determined by a process called normalization, whereby strings are converted into forms which are compared directly for identity. This is the primary goal of the normalization process, see the function &lt;a href=&quot;#normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; to convert into any of the four defined forms.</source>
          <target state="translated">Unicode标准中的&lt;a href=&quot;#Canonical%20equivalent&quot;&gt;规范等效&lt;/a&gt;或&lt;a href=&quot;#Compatibility%20equivalent&quot;&gt;兼容等效&lt;/a&gt;字符的概念使得有必要对Unicode字符串具有完整的正式等效定义。字符串的等效性由称为规范化的过程确定，在此过程中，字符串将转换为直接比较其身份的形式。这是规范化过程的主要目标，请参见将&lt;a href=&quot;#normalize&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt;转换为四种定义形式中的任何一种的功能。</target>
        </trans-unit>
        <trans-unit id="2abedb352be4b4cad8d77bc09501301df20a32a4" translate="yes" xml:space="preserve">
          <source>The condition is satisfied if</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="2f916d19cc4604e724f8fa53e2900b77b6ea76e6" translate="yes" xml:space="preserve">
          <source>The condition is satisfied if &lt;code&gt;Type&lt;/code&gt; is semantically correct (it must be syntactically correct regardless).</source>
          <target state="translated">如果 &lt;code&gt;Type&lt;/code&gt; 在语义上正确（无论在语法上必须正确），则满足该条件。</target>
        </trans-unit>
        <trans-unit id="e653b278fd905a7f3ea022f157c287cd4a9f01c9" translate="yes" xml:space="preserve">
          <source>The condition module provides a primitive for synchronized condition checking.</source>
          <target state="translated">条件模块为同步条件检查提供了一个基元。</target>
        </trans-unit>
        <trans-unit id="6ccd24f12a395f85abd20793c28ab1014d198ff2" translate="yes" xml:space="preserve">
          <source>The condition must be &lt;code&gt;true&lt;/code&gt; for the data to be logged.</source>
          <target state="translated">对于要记录的数据，该条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f67746204d06208bb04d7be048bff0edfd1312d" translate="yes" xml:space="preserve">
          <source>The conditions for the two-range case are as follows:</source>
          <target state="translated">两种范围情况的条件如下:</target>
        </trans-unit>
        <trans-unit id="9db8141e8da442e0a29cf9a7252671c3c3646d9b" translate="yes" xml:space="preserve">
          <source>The config module contains utility routines and configuration information specific to this package.</source>
          <target state="translated">config模块包含了本软件包特有的实用程序和配置信息。</target>
        </trans-unit>
        <trans-unit id="25247015a813aa1799daef3d9f06262e98658698" translate="yes" xml:space="preserve">
          <source>The connection to use e.g. HTTP or FTP.</source>
          <target state="translated">要使用的连接,如HTTP或FTP。</target>
        </trans-unit>
        <trans-unit id="150a6335aad7ff29ac857e269ddb2bcb66d82956" translate="yes" xml:space="preserve">
          <source>The constructed &lt;code&gt;to&lt;/code&gt;</source>
          <target state="translated">构造 &lt;code&gt;to&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76163a15ff5da4a6811b7d818ac307640ccf574e" translate="yes" xml:space="preserve">
          <source>The constructor does not initialize the attributes. To initialize the attributes, you access the &lt;b&gt;attr&lt;/b&gt; member variable.</source>
          <target state="translated">构造函数不会初始化属性。要初始化属性，请访问&lt;b&gt;attr&lt;/b&gt;成员变量。</target>
        </trans-unit>
        <trans-unit id="bca7fb1c9668c6b5381caf14aec377df51a6a261" translate="yes" xml:space="preserve">
          <source>The constructor leaves the digest in an initialized state, so that this method only needs to be called if an unfinished digest is to be reused.</source>
          <target state="translated">构造函数使摘要处于初始化状态,因此只有当一个未完成的摘要要被重用时才需要调用这个方法。</target>
        </trans-unit>
        <trans-unit id="70a470b379ed3334099897b9dc79f34ba48d24b6" translate="yes" xml:space="preserve">
          <source>The content length in bytes of the ftp data.</source>
          <target state="translated">ftp数据的内容长度,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="d2356d15b14610202018dcbb7e4c8229b54b1b8a" translate="yes" xml:space="preserve">
          <source>The content length in bytes when using request that has content e.g. POST/PUT and not using chunked transfer. Is set as the &quot;Content-Length&quot; header. Set to ulong.max to reset to chunked transfer.</source>
          <target state="translated">当使用有内容的请求时,例如POST/PUT,不使用分块传输时的内容长度,以字节为单位。被设置为 &quot;Content-Length &quot;头。如果设置为ulong.max,则重置为分块传输。</target>
        </trans-unit>
        <trans-unit id="c5718211c764df7e99cb685b897ebad52a7de67a" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;buffer&lt;/code&gt; is reused across calls. In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 的内容可在调用之间重用。在上面的示例中，对于所有迭代， &lt;code&gt;buffer.length&lt;/code&gt; 为4096（最后一次除外），在这种情况下， &lt;code&gt;buffer.length&lt;/code&gt; 可能小于4096（但始终大于零）。如果发生I / O错误， &lt;code&gt;StdioException&lt;/code&gt; 引发StdioException。</target>
        </trans-unit>
        <trans-unit id="2138553c63d001080b141495fda74a55a8794df5" translate="yes" xml:space="preserve">
          <source>The content of an environment variable</source>
          <target state="translated">环境变量的内容</target>
        </trans-unit>
        <trans-unit id="5e9be2c8175e2abe02a707a8002878697ac86dfd" translate="yes" xml:space="preserve">
          <source>The contents of strings and comments are not tokenized. Consequently, comment openings occurring within a string do not begin a comment, and string delimiters within a comment do not affect the recognition of comment closings and nested &lt;code&gt;/+&lt;/code&gt; comment openings. With the exception of &lt;code&gt;/+&lt;/code&gt; occurring within a &lt;code&gt;/+&lt;/code&gt; comment, comment openings within a comment are ignored.</source>
          <target state="translated">字符串和注释的内容未标记。因此，出现在字符串内的注释开头不会开始注释，并且注释内的字符串定界符不会影响注释结尾和嵌套的 &lt;code&gt;/+&lt;/code&gt; 注释开头的识别。随着外 &lt;code&gt;/+&lt;/code&gt; 一个内发生 &lt;code&gt;/+&lt;/code&gt; 评论，评论中的评论开口被忽略。</target>
        </trans-unit>
        <trans-unit id="acc47ba92e60a8eb6a7f0995cfd09e1266cb2c0b" translate="yes" xml:space="preserve">
          <source>The convenient digest template allows for quick hashing of any data.</source>
          <target state="translated">方便的文摘模板允许任何数据的快速哈希。</target>
        </trans-unit>
        <trans-unit id="9df1871b1d5b6cf09ccc48d6467fcecce1d269f6" translate="yes" xml:space="preserve">
          <source>The converted associative array initializer or ErrorExp if &lt;code&gt;ai&lt;/code&gt; is not an associative array initializer.</source>
          <target state="translated">转换后的关联数组初始值设定项；如果 &lt;code&gt;ai&lt;/code&gt; 不是关联数组初始值设定项，则返回ErrorExp 。</target>
        </trans-unit>
        <trans-unit id="f43effea59b8beccdd892ba167ecb555ed8c79da" translate="yes" xml:space="preserve">
          <source>The copy constructor can be overloaded with different qualifiers applied to the parameter (copying from a qualified source) or to the copy constructor itself (copying to a qualified destination):</source>
          <target state="translated">复制构造函数可以通过不同的限定符重载应用于参数(从限定的源复制)或复制构造函数本身(复制到限定的目标)。</target>
        </trans-unit>
        <trans-unit id="190d6795cdd5f40388f14ac3afa87aeffbee0f68" translate="yes" xml:space="preserve">
          <source>The copy constructor is type checked as a normal constructor.</source>
          <target state="translated">复制构造函数与普通构造函数一样进行类型检查。</target>
        </trans-unit>
        <trans-unit id="8ce4fd58f0ef3f442e38a96e86e12b71ac036747" translate="yes" xml:space="preserve">
          <source>The corresponding argument is formatted in a manner consistent with its type:</source>
          <target state="translated">相应参数的格式与其类型一致。</target>
        </trans-unit>
        <trans-unit id="48e51bdf1a95a79ac6426f7eff677cbb11ecae43" translate="yes" xml:space="preserve">
          <source>The corresponding argument must be a character type.</source>
          <target state="translated">相应的参数必须是一个字符类型。</target>
        </trans-unit>
        <trans-unit id="0274ce33cba3929bfbdf7475c2fd6fc9d51d564e" translate="yes" xml:space="preserve">
          <source>The corresponding argument must be an integral type and is formatted as an integer. If the argument is a signed type and the</source>
          <target state="translated">相应的参数必须是一个积分类型,并且格式为整数。如果参数是有符号类型,并且</target>
        </trans-unit>
        <trans-unit id="0178a031a9f0514977acc39575ef4aaa0e2662a0" translate="yes" xml:space="preserve">
          <source>The corresponding lowercase letter, if &lt;code&gt;c&lt;/code&gt; is an uppercase ASCII character, otherwise &lt;code&gt;c&lt;/code&gt; itself.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是大写ASCII字符，则对应的小写字母，否则 &lt;code&gt;c&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="69cee4c45eeccc903fcf47055f5f19036cae6663" translate="yes" xml:space="preserve">
          <source>The corresponding unsigned numeric type for &lt;code&gt;T&lt;/code&gt; with the same type qualifiers.  If &lt;code&gt;T&lt;/code&gt; is not a integral or vector, a compile-time error is given.</source>
          <target state="translated">具有相同类型限定符的 &lt;code&gt;T&lt;/code&gt; 的对应的无符号数字类型。如果 &lt;code&gt;T&lt;/code&gt; 不是整数或向量，则给出编译时错误。</target>
        </trans-unit>
        <trans-unit id="65ac2725a8076a2b686ff66848f84c573dbad022" translate="yes" xml:space="preserve">
          <source>The corresponding uppercase letter, if &lt;code&gt;c&lt;/code&gt; is a lowercase ASCII character, otherwise &lt;code&gt;c&lt;/code&gt; itself.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是小写ASCII字符，则对应的大写字母，否则 &lt;code&gt;c&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="c9ce88bd48ff277e4bfb8bb20fde5641ab64da29" translate="yes" xml:space="preserve">
          <source>The coverage callback.</source>
          <target state="translated">覆盖率回调。</target>
        </trans-unit>
        <trans-unit id="fe4e5d3b2725d57149f74ea4401dddd72e356025" translate="yes" xml:space="preserve">
          <source>The created GC instance or &lt;code&gt;null&lt;/code&gt; if no factory for that name was registered</source>
          <target state="translated">创建的GC实例；如果未注册该名称的工厂，则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25c75bcefa05f1c507f7f1fc6ff9cd42539bbd75" translate="yes" xml:space="preserve">
          <source>The curl_easy_pause function pauses or unpauses transfers. Select the new state by setting the bitmask, use the convenience defines below.</source>
          <target state="translated">curl_easy_pause函数可以暂停或取消暂停传输。通过设置位掩码来选择新的状态,使用下面的方便定义。</target>
        </trans-unit>
        <trans-unit id="153bfd2d6b2d30ac140c40feedadba5366f389ef" translate="yes" xml:space="preserve">
          <source>The curl_easy_strerror function may be used to turn a CURLcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_easy_strerror函数可以用来将一个CURLcode值转化为等价的人类可读的错误字符串。这对于打印有意义的错误信息非常有用。</target>
        </trans-unit>
        <trans-unit id="e7d8cb9ade20ed61c82c1a60ebe359477845f192" translate="yes" xml:space="preserve">
          <source>The curl_multi_strerror function may be used to turn a CURLMcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_multi_strerror函数可以用来将一个CURLMcode值转化为等价的人类可读的错误字符串。这对于打印有意义的错误信息非常有用。</target>
        </trans-unit>
        <trans-unit id="8ac8c7edec906e82e20cff95e57160d4c2ae8742" translate="yes" xml:space="preserve">
          <source>The curl_share_strerror function may be used to turn a CURLSHcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_share_strerror函数可以用来将CURLSHcode值转化为等价的人类可读错误字符串。这对于打印有意义的错误信息非常有用。</target>
        </trans-unit>
        <trans-unit id="12b95a210f2fd732ae6323a477ee3db950ce1e48" translate="yes" xml:space="preserve">
          <source>The current capacity of this &lt;code&gt;SocketSet&lt;/code&gt;. The exact meaning of the return value varies from platform to platform.</source>
          <target state="translated">此 &lt;code&gt;SocketSet&lt;/code&gt; 的当前容量。返回值的确切含义因平台而异。</target>
        </trans-unit>
        <trans-unit id="b7e8d20bcf3e91b443f49906cb7f9c26202d7b33" translate="yes" xml:space="preserve">
          <source>The current chunk of encoded data.</source>
          <target state="translated">当前的编码数据块。</target>
        </trans-unit>
        <trans-unit id="5f09ff18e0bf3e3a50451c990acfd44da2f4d0cf" translate="yes" xml:space="preserve">
          <source>The current collect handler or null if none has been set.</source>
          <target state="translated">当前的收集处理程序,如果没有设置,则为空。</target>
        </trans-unit>
        <trans-unit id="ff00e2ec15ad157fa0acd49db009126af4219c9c" translate="yes" xml:space="preserve">
          <source>The current day of the week.</source>
          <target state="translated">当前一周的日子。</target>
        </trans-unit>
        <trans-unit id="5445bb4bc1730b9d0cce5b36844644b773e9edcb" translate="yes" xml:space="preserve">
          <source>The current decoded byte.</source>
          <target state="translated">当前解码的字节。</target>
        </trans-unit>
        <trans-unit id="d4f2882db12d78c2fc4e970047ad93065891fe53" translate="yes" xml:space="preserve">
          <source>The current directory for the parent process.</source>
          <target state="translated">父进程的当前目录。</target>
        </trans-unit>
        <trans-unit id="62615ccff9de65abffb1ae1e70b58ec0562e8494" translate="yes" xml:space="preserve">
          <source>The current encoded character.</source>
          <target state="translated">当前编码的字符。</target>
        </trans-unit>
        <trans-unit id="2bcc037a390d8689344ebfd625c83c159bbdaa3a" translate="yes" xml:space="preserve">
          <source>The current implementation is contained in and defined by &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/aaA.d&quot;&gt;rt/aaA.d&lt;/a&gt;.</source>
          <target state="translated">当前的实现包含在&lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/aaA.d&quot;&gt;rt / aaA.d中并由&lt;/a&gt;其定义。</target>
        </trans-unit>
        <trans-unit id="135564ffafda532e35fa0b7d48812ffee033cd42" translate="yes" xml:space="preserve">
          <source>The current implementation is optimized for little endian architectures. It will exhibit different results on big endian architectures and a slightly less uniform distribution.</source>
          <target state="translated">目前的实现是针对小恩迪安架构优化的。它将在大恩迪安架构上表现出不同的结果,并且分布略显不均匀。</target>
        </trans-unit>
        <trans-unit id="8b386bdee0746666a56a36200a693020a21530e4" translate="yes" xml:space="preserve">
          <source>The current legacy module unit tester handler or null if none has been set.</source>
          <target state="translated">当前遗留模块单元测试器处理程序,如果没有设置,则为空。</target>
        </trans-unit>
        <trans-unit id="8ef65e94b9168b0ff7203f6b263d0e8b2bd6eeac" translate="yes" xml:space="preserve">
          <source>The current module unit tester handler or null if none has been set.</source>
          <target state="translated">当前模块单元测试程序,如果没有设置,则为空。</target>
        </trans-unit>
        <trans-unit id="6f8938955ef3df10335744a73b91094b9fffec70" translate="yes" xml:space="preserve">
          <source>The current month of the year.</source>
          <target state="translated">年的当月。</target>
        </trans-unit>
        <trans-unit id="67943f85151903b71f2ef45fecfce18f374500bf" translate="yes" xml:space="preserve">
          <source>The current system tick. The number of ticks per second varies from system to system. &lt;code&gt;currSystemTick&lt;/code&gt; uses a monotonic clock, so it's intended for precision timing by comparing relative time values, not for getting the current system time.</source>
          <target state="translated">当前系统的滴答声。每秒的滴答声数量因系统而异。 &lt;code&gt;currSystemTick&lt;/code&gt; 使用单调时钟，因此旨在通过比较相对时间值进行精确计时，而不是获取当前系统时间。</target>
        </trans-unit>
        <trans-unit id="222a86bbae85929301dc215f9e9c008965d24955" translate="yes" xml:space="preserve">
          <source>The current time of the system's monotonic clock. This has no relation to the wall clock time, as the wall clock time can be adjusted (e.g. by NTP), whereas the monotonic clock always moves forward. The source of the monotonic time is system-specific.</source>
          <target state="translated">系统单调时钟的当前时间。这与挂钟时间没有关系,因为挂钟时间可以调整(例如通过NTP),而单调钟总是向前移动。单调时间的来源与系统有关。</target>
        </trans-unit>
        <trans-unit id="6d131b2d67d2e2d0708dd4d35e46ff7bb470d695" translate="yes" xml:space="preserve">
          <source>The current time zone of this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. It's internal time is always kept in UTC, so there are no conversion issues between time zones due to DST. Functions which return all or part of the time - such as hours - adjust the time to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone before returning.</source>
          <target state="translated">此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的当前时区。它的内部时间始终保存在UTC中，因此，由于DST，在各个时区之间没有转换问题。返回全部或部分时间（例如小时）的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;在返回之前将时间调整为此SysTime的时区。</target>
        </trans-unit>
        <trans-unit id="92e4138ca0558ee1a8d76b41157b476bc178803c" translate="yes" xml:space="preserve">
          <source>The current time zone of this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. Its internal time is always kept in UTC, so there are no conversion issues between time zones due to DST. Functions which return all or part of the time - such as hours - adjust the time to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone before returning.</source>
          <target state="translated">此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的当前时区。它的内部时间始终以UTC进行保存，因此，由于DST，在各个时区之间没有转换问题。返回全部或部分时间（例如小时）的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;在返回之前将时间调整为此SysTime的时区。</target>
        </trans-unit>
        <trans-unit id="73b94772e416a8ec2451e84a4f045bcf0b0bd2f8" translate="yes" xml:space="preserve">
          <source>The current trace handler or null if none has been set.</source>
          <target state="translated">当前的跟踪处理程序,如果没有设置,则为空。</target>
        </trans-unit>
        <trans-unit id="1168fa07ec5310179d0a7d8dd293fdee5d851995" translate="yes" xml:space="preserve">
          <source>The current version is MurmurHash3, which yields a 32-bit or 128-bit hash value. The older MurmurHash 1 and 2 are currently not supported.</source>
          <target state="translated">目前的版本是MurmurHash3,它可以产生一个32位或128位的哈希值。目前不支持旧版的MurmurHash1和2。</target>
        </trans-unit>
        <trans-unit id="f46d4edbe0670620eb95290f8f2a6487face97bc" translate="yes" xml:space="preserve">
          <source>The data caches. If there are fewer than 5 physical caches levels, the remaining levels are set to size_t.max (== entire memory space)</source>
          <target state="translated">的数据缓存。如果物理缓存级别少于5个,其余级别设置为size_t.max(==整个内存空间)。</target>
        </trans-unit>
        <trans-unit id="a6ef57ac8d9ec9aa6eaa6d13ed88211ab558ef56" translate="yes" xml:space="preserve">
          <source>The data is NOT copied by the library. Content-Type will default to application/octet-stream. Data is not converted or encoded by this method.</source>
          <target state="translated">数据不会被库复制。Content-Type将默认为application/octet-stream。此方法不对数据进行转换或编码。</target>
        </trans-unit>
        <trans-unit id="6bcbd37c2c2ac85eb1356e64319455a6bd36b26b" translate="yes" xml:space="preserve">
          <source>The data is NOT copied by the library. Content-Type will default to text/plain. Data is not converted or encoded by this method.</source>
          <target state="translated">数据不会被库复制。Content-Type将默认为text/plain。此方法不对数据进行转换或编码。</target>
        </trans-unit>
        <trans-unit id="cce9ef674e018900e5c73c744a07e56499cc18a7" translate="yes" xml:space="preserve">
          <source>The data is always shareable across threads. Even if the data is &lt;code&gt;const&lt;/code&gt;, the affix is modifiable by the same reasoning as for &lt;code&gt;immutable&lt;/code&gt;.</source>
          <target state="translated">数据始终在线程之间共享。即使数据为 &lt;code&gt;const&lt;/code&gt; ，后缀也可以通过与 &lt;code&gt;immutable&lt;/code&gt; 相同的理由进行修改。</target>
        </trans-unit>
        <trans-unit id="493973138a3d3f979064d5411c98ae5301a703dd" translate="yes" xml:space="preserve">
          <source>The data that is to be logged.</source>
          <target state="translated">要记录的数据。</target>
        </trans-unit>
        <trans-unit id="ca2344350b8df2bdd7d03df57b987d64c46b085c" translate="yes" xml:space="preserve">
          <source>The data that should be logged.</source>
          <target state="translated">应记录的数据。</target>
        </trans-unit>
        <trans-unit id="78b3f17895b8c6a1ec55d26a5815c6b3e2f691ad" translate="yes" xml:space="preserve">
          <source>The database disk image is malformed</source>
          <target state="translated">数据库磁盘映像已损坏</target>
        </trans-unit>
        <trans-unit id="99b3c2c49461425bf6cff4391127f75d483d0614" translate="yes" xml:space="preserve">
          <source>The database file is locked</source>
          <target state="translated">数据库文件被锁定</target>
        </trans-unit>
        <trans-unit id="5e44b1ae3d4ce260d0b6e54dfe79b9e83c8a047e" translate="yes" xml:space="preserve">
          <source>The database schema changed</source>
          <target state="translated">数据库模式改变</target>
        </trans-unit>
        <trans-unit id="8c85f90f34182d4804f085ae127ba5dcaa363aac" translate="yes" xml:space="preserve">
          <source>The date portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的日期部分。</target>
        </trans-unit>
        <trans-unit id="afe331c3b8358f5c9f6aa03d6d996e549edd7dd9" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">公历将此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;设置为的日期。</target>
        </trans-unit>
        <trans-unit id="4ae0c452a064fb3ca47b7a7c9701724ac4dce1ca" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">公历将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;时间设置为的日期。</target>
        </trans-unit>
        <trans-unit id="bd19a7c8e8386d921c721461757d18c3618278c9" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">公历设置该&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;时间的日期。</target>
        </trans-unit>
        <trans-unit id="0b0bd119a12bf4f397ebf472b36184d281c6821c" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">将此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 日期&lt;/a&gt;设置为的月份。</target>
        </trans-unit>
        <trans-unit id="5240ff1dc8c3d7350efab2ccc0dcbc8c48902add" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;设置为星期几。</target>
        </trans-unit>
        <trans-unit id="54dc94925cf86835f631cdafa18de7d7060f146b" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;设置为星期几。</target>
        </trans-unit>
        <trans-unit id="f06065ad9961deec3076217123d1f3724a43ad9e" translate="yes" xml:space="preserve">
          <source>The day of the week is ignored beyond verifying that it's a valid day of the week, as the day of the week can be inferred from the date. It is not checked whether the given day of the week matches the actual day of the week of the given date (though it is technically invalid per the spec if the day of the week doesn't match the actual day of the week of the given date).</source>
          <target state="translated">除了验证它是有效的星期几之外,星期几被忽略了,因为星期几可以从日期中推断出来。它不会检查给定的星期日是否与给定日期的实际星期日相吻合(尽管根据规范,如果星期日与给定日期的实际星期日不吻合,技术上是无效的)。</target>
        </trans-unit>
        <trans-unit id="5e854e19e24462bd8df16bbd3e656946dc758006" translate="yes" xml:space="preserve">
          <source>The day of the week to get the number of days to.</source>
          <target state="translated">的日子来获取天数,以。</target>
        </trans-unit>
        <trans-unit id="9b2b14b5c754fd8843dde38b4959242869b20add" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">今年来设置的一天，一年的一天，这个&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;是。</target>
        </trans-unit>
        <trans-unit id="ccf6b0017db205f1a9b8b83cdf38246cf64f3b0f" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">设置该&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的一年中的哪一天。</target>
        </trans-unit>
        <trans-unit id="8dcb327ec830e9013bbcabf4579c3b122dd13db5" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">设置系统时间是在一年中的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ca7f565ccafa6d910e84ff93887a8b0d0bb5eea" translate="yes" xml:space="preserve">
          <source>The day portion of the date.</source>
          <target state="translated">日的部分。</target>
        </trans-unit>
        <trans-unit id="5ad71e8507c7301863c1c60659bd8b3c6b7f0dc6" translate="yes" xml:space="preserve">
          <source>The day to validate.</source>
          <target state="translated">当天要验证。</target>
        </trans-unit>
        <trans-unit id="99ff0048fa491b367eccc6b67cb9b69f2ad2defa" translate="yes" xml:space="preserve">
          <source>The decimal value to convert into the factorial number system.</source>
          <target state="translated">要转换为阶乘数系统的小数值。</target>
        </trans-unit>
        <trans-unit id="112d499aea5e8fc601570782799d1151e557b4de" translate="yes" xml:space="preserve">
          <source>The declarations in a mixin are placed in a nested scope and then &amp;lsquo;imported&amp;rsquo; into the surrounding scope. If the name of a declaration in a mixin is the same as a declaration in the surrounding scope, the surrounding declaration overrides the mixin one:</source>
          <target state="translated">mixin中的声明放置在嵌套作用域中，然后&amp;ldquo;导入&amp;rdquo;到周围的作用域中。如果混合中的声明名称与周围范围中的声明相同，则周围的声明将覆盖混合中的声明：</target>
        </trans-unit>
        <trans-unit id="1c2cdcf3cf79afdc906fde394e5c2b865521f41b" translate="yes" xml:space="preserve">
          <source>The decoded string</source>
          <target state="translated">解码后的字符串</target>
        </trans-unit>
        <trans-unit id="945488b25e8ef473c0f2b20f9c6b8b8c99511eb5" translate="yes" xml:space="preserve">
          <source>The decoding of the current element in the input.</source>
          <target state="translated">输入中当前元素的解码。</target>
        </trans-unit>
        <trans-unit id="4f67de430c432c552831b7793db0a2c0326b2d16" translate="yes" xml:space="preserve">
          <source>The deduced type parameter for dynamic array and pointer arguments has an unqualified head:</source>
          <target state="translated">动态数组和指针参数的推导类型参数有一个非限定头。</target>
        </trans-unit>
        <trans-unit id="dc7258b7cd7137907e6fca7bf0fc234fc2e2ce18" translate="yes" xml:space="preserve">
          <source>The default &quot;User-Agent&quot; value send with a request. It has the form &quot;Phobos-std.net.curl/</source>
          <target state="translated">默认的 &quot;User-Agent &quot;值随请求一起发送,其形式为 &quot;Phobos-std.net.curl/&quot;。它的形式是 &quot;Phobos-std.net.curl/&quot;。</target>
        </trans-unit>
        <trans-unit id="7a46984a3f96d58aec5d4d9868c2110f34d995ba" translate="yes" xml:space="preserve">
          <source>The default (or most common) setting for the current platform. That is, &lt;code&gt;no&lt;/code&gt; on Windows and Mac OS X, and &lt;code&gt;yes&lt;/code&gt; on all POSIX systems except OS X (Linux, *BSD, etc.).</source>
          <target state="translated">当前平台的默认（或最常见）设置。也就是说， &lt;code&gt;no&lt;/code&gt; 在Windows和Mac OS X，以及 &lt;code&gt;yes&lt;/code&gt; 在除OS X（Linux操作系统，* BSD等），所有POSIX系统。</target>
        </trans-unit>
        <trans-unit id="87b0a2695d56ceaeb7eb9433e1d06841db861c10" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Logger&lt;/code&gt; will by default log to &lt;code&gt;stderr&lt;/code&gt; and has a default &lt;code&gt;LogLevel&lt;/code&gt; of &lt;code&gt;LogLevel.all&lt;/code&gt;. The default Logger can be accessed by using the property called &lt;code&gt;sharedLog&lt;/code&gt;. This property is a reference to the current default &lt;code&gt;Logger&lt;/code&gt;. This reference can be used to assign a new default &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">默认情况下，默认 &lt;code&gt;Logger&lt;/code&gt; 将记录到 &lt;code&gt;stderr&lt;/code&gt; ，并且默认 &lt;code&gt;LogLevel&lt;/code&gt; 为 &lt;code&gt;LogLevel.all&lt;/code&gt; 。可以使用称为 &lt;code&gt;sharedLog&lt;/code&gt; 的属性访问默认Logger 。此属性是对当前默认 &lt;code&gt;Logger&lt;/code&gt; 的引用。该参考可用于分配新的默认 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b72f9c3623b76d776ddcc9d314e5ca75b551f9a9" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;alignedReallocate&lt;/code&gt; function first attempts to use &lt;code&gt;expand&lt;/code&gt;. If &lt;code&gt;Allocator.expand&lt;/code&gt; is not defined or returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;alignedReallocate&lt;/code&gt; allocates a new block of memory of appropriate size and copies data from the old block to the new block. Finally, if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;alignedReallocate&lt;/code&gt; uses it to free the old memory block.</source>
          <target state="translated">默认的 &lt;code&gt;alignedReallocate&lt;/code&gt; 函数首先尝试使用 &lt;code&gt;expand&lt;/code&gt; 。如果未定义 &lt;code&gt;Allocator.expand&lt;/code&gt; 或返回 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;alignedReallocate&lt;/code&gt; 会分配一个适当大小的新内存块，并将数据从旧块复制到新块。最后，如果 &lt;code&gt;Allocator&lt;/code&gt; 定义了 &lt;code&gt;deallocate&lt;/code&gt; ，则 &lt;code&gt;alignedReallocate&lt;/code&gt; 将使用它释放旧的内存块。</target>
        </trans-unit>
        <trans-unit id="11d5f052dd46a2986ac861f2bb2c8694b1113749" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;reallocate&lt;/code&gt; function first attempts to use &lt;code&gt;expand&lt;/code&gt;. If &lt;code&gt;Allocator.expand&lt;/code&gt; is not defined or returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt; allocates a new block of memory of appropriate size and copies data from the old block to the new block. Finally, if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt; uses it to free the old memory block.</source>
          <target state="translated">默认的 &lt;code&gt;reallocate&lt;/code&gt; 函数首先尝试使用 &lt;code&gt;expand&lt;/code&gt; 。如果未定义 &lt;code&gt;Allocator.expand&lt;/code&gt; 或返回 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;reallocate&lt;/code&gt; 会分配一个适当大小的新内存块，并将数据从旧块复制到新块。最后，如果 &lt;code&gt;Allocator&lt;/code&gt; 定义了 &lt;code&gt;deallocate&lt;/code&gt; ，则 &lt;code&gt;reallocate&lt;/code&gt; 使用它释放旧的内存块。</target>
        </trans-unit>
        <trans-unit id="b4b278f4d2972020f4ba9b115cb1013b58d050b9" translate="yes" xml:space="preserve">
          <source>The default alignment is &lt;code&gt;platformAlignment&lt;/code&gt;.</source>
          <target state="translated">默认对齐方式是 &lt;code&gt;platformAlignment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86db8edf378862e012fa8f8fcf58a7d5108946ce" translate="yes" xml:space="preserve">
          <source>The default allocator.</source>
          <target state="translated">默认的分配器。</target>
        </trans-unit>
        <trans-unit id="84034aca41f128da43b408ac2e8f9758bed62159" translate="yes" xml:space="preserve">
          <source>The default constructor for the &lt;code&gt;NullLogger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NullLogger&lt;/code&gt; 的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="60dfda69676fc480f5f6faa42faf083636619c98" translate="yes" xml:space="preserve">
          <source>The default constructor for the &lt;code&gt;StdForwardLogger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StdForwardLogger&lt;/code&gt; 的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="44546e235ac407a00aa0d819574df31ac96d3e13" translate="yes" xml:space="preserve">
          <source>The default directory where the TZ Database files are stored. It's empty for Windows, since Windows doesn't have them. You can also use the TZDatabaseDir version to pass an arbitrary path at compile-time, rather than hard-coding it here. Android concatenates all time zone data into a single file called tzdata and stores it in the directory below.</source>
          <target state="translated">保存TZ数据库文件的默认目录。对于Windows来说,它是空的,因为Windows没有这些文件。你也可以使用TZDatabaseDir版本在编译时传递一个任意路径,而不是在这里硬编码。Android会将所有时区数据连接到一个名为tzdata的文件中,并将其存储在下面的目录中。</target>
        </trans-unit>
        <trans-unit id="8df16f51964aeebfe4bc3a051bf58dca3ecbc7ca" translate="yes" xml:space="preserve">
          <source>The default extension to use.</source>
          <target state="translated">要使用的默认扩展。</target>
        </trans-unit>
        <trans-unit id="85ad9abd95b264167c92cdc2a1adee2b573ef599" translate="yes" xml:space="preserve">
          <source>The default good size allocation is deduced as &lt;code&gt;n&lt;/code&gt; rounded up to the allocator's alignment.</source>
          <target state="translated">默认的良好大小分配推导出为 &lt;code&gt;n&lt;/code&gt; ,四舍五入到分配器的对齐方式。</target>
        </trans-unit>
        <trans-unit id="1b0fe911bc214b516e59012b05dd0e28695378c4" translate="yes" xml:space="preserve">
          <source>The default initializer is evaluated at compile time.</source>
          <target state="translated">默认的初始化器在编译时被评估。</target>
        </trans-unit>
        <trans-unit id="09875c3ec3c0432a38d2825c4ab0b5b1b8a97473" translate="yes" xml:space="preserve">
          <source>The default initializers are evaluated at compile time.</source>
          <target state="translated">默认的初始化器在编译时被评估。</target>
        </trans-unit>
        <trans-unit id="b315cb15ffa0ca81f8d98d7b66d415e4aa5dc1b4" translate="yes" xml:space="preserve">
          <source>The default initializers may not contain references to mutable data.</source>
          <target state="translated">默认初始化器可能不包含对可变数据的引用。</target>
        </trans-unit>
        <trans-unit id="198b7d1107c41684b20ca53736c0025d3ab9b73c" translate="yes" xml:space="preserve">
          <source>The default inline behavior is typically selectable with a compiler switch such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-inline&quot;&gt;&lt;em&gt;-inline&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">默认内联行为通常可以通过&lt;a href=&quot;https://dlang.org/dmd.html#switch-inline&quot;&gt;&lt;em&gt;-inline&lt;/em&gt;&lt;/a&gt;等编译器开关进行选择。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4be45be08a1c8c22dbb96c12305596159d25e0b" translate="yes" xml:space="preserve">
          <source>The default layout of the fields of a struct is an exact match with the</source>
          <target state="translated">结构体的字段的默认布局是与</target>
        </trans-unit>
        <trans-unit id="2f337be32b3aefecfcb4859e625057b7bd434d30" translate="yes" xml:space="preserve">
          <source>The default linkage for member functions of COM classes is &lt;code&gt;extern(System)&lt;/code&gt;.  Note that if you want to implement or override any base-class methods of D interfaces or classes (ones which do not inherit from &lt;code&gt;IUnknown&lt;/code&gt;), you have to explicitly mark them as having the &lt;code&gt;extern(D)&lt;/code&gt; linkage:</source>
          <target state="translated">COM类的成员函数的默认链接为 &lt;code&gt;extern(System)&lt;/code&gt; 。请注意，如果要实现或重写D接口或类的任何基类方法（不继承自 &lt;code&gt;IUnknown&lt;/code&gt; 的方法），则必须将它们明确标记为具有 &lt;code&gt;extern(D)&lt;/code&gt; 链接：</target>
        </trans-unit>
        <trans-unit id="7f4262f95c707a983226fca6d9fb6bf885e79c8c" translate="yes" xml:space="preserve">
          <source>The default namespaces (&lt;a href=&quot;#dnsNamespace&quot;&gt;&lt;code&gt;dnsNamespace&lt;/code&gt;&lt;/a&gt;, ...) defined by this module should be used when appropriate.</source>
          <target state="translated">在适当的情况下，应使用此模块定义的默认名称空间（&lt;a href=&quot;#dnsNamespace&quot;&gt; &lt;code&gt;dnsNamespace&lt;/code&gt; &lt;/a&gt;，...）。</target>
        </trans-unit>
        <trans-unit id="c2f98d39df30add62dee5880988c4ddc9def3c49" translate="yes" xml:space="preserve">
          <source>The default scheduling priority that is set for a thread. On systems where multiple scheduling policies are defined, this value represents the default priority for the scheduling policy of the process.</source>
          <target state="translated">为线程设置的默认调度优先级。在定义了多个调度策略的系统中,这个值代表进程的调度策略的默认优先级。</target>
        </trans-unit>
        <trans-unit id="39cb60f50514180fcf08c0496a2e6d58784782d0" translate="yes" xml:space="preserve">
          <source>The default seed value.</source>
          <target state="translated">默认的种子值。</target>
        </trans-unit>
        <trans-unit id="cd5dbb92220cc6a8e8b2d5783ecebaacc60df5fc" translate="yes" xml:space="preserve">
          <source>The default value of a &lt;code&gt;Checked!(X, WithNaN)&lt;/code&gt; is its NaN value, so care must be taken that all variables are explicitly initialized. Any arithmetic and logic operation involving at least on NaN becomes NaN itself. All of &lt;code&gt;a == b&lt;/code&gt;, &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;a &amp;gt; b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt;, &lt;code&gt;a &amp;gt;= b&lt;/code&gt; yield &lt;code&gt;false&lt;/code&gt; if at least one of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is NaN.</source>
          <target state="translated">&lt;code&gt;Checked!(X, WithNaN)&lt;/code&gt; 的默认值是它的NaN值，因此必须注意所有变量都被显式初始化。至少涉及NaN的任何算术和逻辑运算本身就是NaN。如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 中的至少一个是NaN ，则所有 &lt;code&gt;a == b&lt;/code&gt; ， &lt;code&gt;a &amp;lt; b&lt;/code&gt; ， &lt;code&gt;a &amp;gt; b&lt;/code&gt; ， &lt;code&gt;a &amp;lt;= b&lt;/code&gt; ， &lt;code&gt;a &amp;gt;= b&lt;/code&gt; 产生 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60336805f352e76f45059516632dd3aebf2bb4c8" translate="yes" xml:space="preserve">
          <source>The default value used for values not explicitly initialized. It is the NaN value, i.e. &lt;code&gt;T.min&lt;/code&gt; for signed integrals and &lt;code&gt;T.max&lt;/code&gt; for unsigned integrals.</source>
          <target state="translated">用于未显式初始化的值的默认值。这是NaN值，即 &lt;code&gt;T.min&lt;/code&gt; 签收积分和 &lt;code&gt;T.max&lt;/code&gt; 无符号积分。</target>
        </trans-unit>
        <trans-unit id="175f9e59ae6d8d45a5ecbc8d3bf95ccec9b46335" translate="yes" xml:space="preserve">
          <source>The default value.</source>
          <target state="translated">默认值。</target>
        </trans-unit>
        <trans-unit id="5298372926ef4a5550bf5eba62d1b79774021d32" translate="yes" xml:space="preserve">
          <source>The default way to configure the runtime is by passing command line arguments starting with &lt;code&gt;--DRT-&lt;/code&gt; and followed by the option name, e.g. &lt;code&gt;--DRT-gcopt&lt;/code&gt; to configure the GC. When command line parsing is enabled, command line options starting with &lt;code&gt;--DRT-&lt;/code&gt; are filtered out before calling main, so the program will not see them. They are still available via &lt;code&gt;rt_args()&lt;/code&gt;.</source>
          <target state="translated">配置运行时的默认方法是传递以 &lt;code&gt;--DRT-&lt;/code&gt; 开头的命令行参数，后接选项名称，例如 &lt;code&gt;--DRT-gcopt&lt;/code&gt; 来配置GC。启用命令行解析后，以 &lt;code&gt;--DRT-&lt;/code&gt; 开头的命令行选项在调用main之前会被滤除，因此程序将看不到它们。它们仍然可以通过 &lt;code&gt;rt_args()&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="ba1df5a4c503e2e5ff553646b53232a4dc9fad0b" translate="yes" xml:space="preserve">
          <source>The delegate or function having the currently held value as parameter is called with &lt;code&gt;variant&lt;/code&gt;'s current value. Visiting handlers are passed in the template parameter list. It is statically ensured that all held types of &lt;code&gt;variant&lt;/code&gt; are handled across all handlers. &lt;code&gt;visit&lt;/code&gt; allows delegates and static functions to be passed as parameters.</source>
          <target state="translated">将具有当前保留值作为参数的委托或函数与 &lt;code&gt;variant&lt;/code&gt; 的当前值一起调用。访问处理程序在模板参数列表中传递。静态确保所有持有的 &lt;code&gt;variant&lt;/code&gt; 类型都在所有处理程序中进行处理。 &lt;code&gt;visit&lt;/code&gt; 允许将委托和静态函数作为参数传递。</target>
        </trans-unit>
        <trans-unit id="2b6e50abb4f0914ce14cb54a228ba5c564bcd73a" translate="yes" xml:space="preserve">
          <source>The delegate to be called if the value evaluates to false.</source>
          <target state="translated">值为false时要调用的委托。</target>
        </trans-unit>
        <trans-unit id="95f480c7d2ae51400206ecb9e084d35ded98b8d3" translate="yes" xml:space="preserve">
          <source>The demangle module converts mangled D symbols to a representation similar to what would have existed in code.</source>
          <target state="translated">demangle模块将杂乱的D符号转换为类似于代码中的表示方式。</target>
        </trans-unit>
        <trans-unit id="48b3f69fad23d9b2d8c32fdb445562e4fbbe9924" translate="yes" xml:space="preserve">
          <source>The demangled name or the original string if the name is not a mangled D name.</source>
          <target state="translated">解除的名称或原始字符串,如果该名称不是一个杂乱的D名称。</target>
        </trans-unit>
        <trans-unit id="0cc17d9f531c72835705e440a701b890a1903124" translate="yes" xml:space="preserve">
          <source>The demangled type name or the original string if the name is not a mangled D type.</source>
          <target state="translated">拆解后的类型名称,如果名称不是拆解后的D类型,则为原始字符串。</target>
        </trans-unit>
        <trans-unit id="60c01151d0f392e7605b5a47b38d319dce929d2b" translate="yes" xml:space="preserve">
          <source>The description of this option</source>
          <target state="translated">该选项的说明</target>
        </trans-unit>
        <trans-unit id="f84ede836de109cb779bab9fc0b1fd8d408f2a87" translate="yes" xml:space="preserve">
          <source>The desired &lt;a href=&quot;#FunctionAttribute&quot;&gt;&lt;code&gt;FunctionAttribute&lt;/code&gt;&lt;/a&gt;s of the result type.</source>
          <target state="translated">结果类型的所需&lt;a href=&quot;#FunctionAttribute&quot;&gt; &lt;code&gt;FunctionAttribute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23d72f95e07dcbef384a7cb27da3b8ccb18812f3" translate="yes" xml:space="preserve">
          <source>The desired allocation size in bytes.</source>
          <target state="translated">所需的分配大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="9a65e8347e92f2a998eac03474e781c85ca96f7b" translate="yes" xml:space="preserve">
          <source>The desired extension size in bytes.</source>
          <target state="translated">所需的扩展大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="af2fe61e437d6dfeba930d32d765dbac31989651" translate="yes" xml:space="preserve">
          <source>The desired linkage of the result type.</source>
          <target state="translated">所需结果类型的链接。</target>
        </trans-unit>
        <trans-unit id="59cf426293fa685ffeb3c9d3c020fed48d5397c1" translate="yes" xml:space="preserve">
          <source>The desired size in bytes.</source>
          <target state="translated">所需大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="ac522378c8d7addb4cb9d53d5b7d048c9264b788" translate="yes" xml:space="preserve">
          <source>The destructor automatically closes the file as soon as no &lt;code&gt;File&lt;/code&gt; object refers to it anymore.</source>
          <target state="translated">一旦没有 &lt;code&gt;File&lt;/code&gt; 对象引用该析构函数，则该析构函数将自动关闭该文件。</target>
        </trans-unit>
        <trans-unit id="8c331e4eecbd8270b0e4ce21fab87b6858ba74cc" translate="yes" xml:space="preserve">
          <source>The destructor for the super class automatically gets called when the destructor ends. There is no way to call the super destructor explicitly.</source>
          <target state="translated">当超级类的destructor结束时,超级类的destructor会自动被调用。没有办法显式地调用超类的析构器。</target>
        </trans-unit>
        <trans-unit id="f6330e2ba0f0050af5f9f70cf0eec4389de5eb4b" translate="yes" xml:space="preserve">
          <source>The destructor is expected to release any resources held by the object.</source>
          <target state="translated">解构器将释放对象持有的任何资源。</target>
        </trans-unit>
        <trans-unit id="7159cd12fe27172c0a0982e4b8092e7e75f8821b" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。例如，滚动一个&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;一年的天数将获得完全相同的&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7c404d040d8fd24e8c117abcb04c6ad2d048280" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。例如，将&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;滚动一年的天数将获得完全相同的&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3c3c9ee3f68d7a39533f5e98688e28838282e6b" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; one year's worth of days gets the exact same &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。例如，将&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;滚动一年的时间可以获得完全相同的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24751c549ef6022fb5253fa2ab74c9f98d81a539" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. For instance, rolling a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; one hours's worth of minutes gets the exact same &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。例如，将&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;滚动一小时的分钟数将得到完全相同的&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8c7039887bf08601f56a0509005c2c5688e3ba7" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。滚动&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 12个月将获得完全相同的&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;。但是，由于每个月中天数的不同，天数仍然会受到影响。</target>
        </trans-unit>
        <trans-unit id="4c92275a7e175bacd3ce746d6adc1eff5f6f35c0" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。将&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;滚动12个月将获得完全相同的&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。但是，由于每个月中天数的不同，天数仍然会受到影响。</target>
        </trans-unit>
        <trans-unit id="bd425db182cd0598846f2e904965692d4bd6f1e2" translate="yes" xml:space="preserve">
          <source>The difference between rolling and adding is that rolling does not affect larger units. Rolling a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; 12 months gets the exact same &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. However, the days can still be affected due to the differing number of days in each month.</source>
          <target state="translated">滚动和添加之间的区别在于滚动不会影响较大的单元。滚动&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 12个月可获得完全相同的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;。但是，由于每个月中天数的不同，天数仍然会受到影响。</target>
        </trans-unit>
        <trans-unit id="9607cb254c58607b6f72a2ec85c44f16a7c46305" translate="yes" xml:space="preserve">
          <source>The difference between this version of &lt;code&gt;everyDuration&lt;/code&gt; and the version which just takes a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; is that this one also takes the number of years and months (along with an &lt;code&gt;AllowDayOverflow&lt;/code&gt; to indicate whether adding years and months should allow the days to overflow).</source>
          <target state="translated">此版本的 &lt;code&gt;everyDuration&lt;/code&gt; 和仅使用&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;的版本之间的区别在于，此版本还需要花费年数和月份数（以及 &lt;code&gt;AllowDayOverflow&lt;/code&gt; 来指示是否添加年数和月份是否应允许天数溢出） 。</target>
        </trans-unit>
        <trans-unit id="448504c864d4f8f6a21520c51c1f3e9b8a81d617" translate="yes" xml:space="preserve">
          <source>The digamma function is the logarithmic derivative of the gamma function.</source>
          <target state="translated">digamma函数是gamma函数的对数导数。</target>
        </trans-unit>
        <trans-unit id="df031407b714e9d3fe5339c97f81f1b5df587638" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 1st shift. Positive means left, negative means right.</source>
          <target state="translated">1档的方向和幅度。正表示左,负表示右。</target>
        </trans-unit>
        <trans-unit id="ac46a68fb5f59b21b538d08a263d443a6d4a88ba" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 2nd shift. Positive means left, negative means right.</source>
          <target state="translated">二档的方向和幅度。正表示左,负表示右。</target>
        </trans-unit>
        <trans-unit id="2f490894285820c4987bf19f75fcde524a0fa198" translate="yes" xml:space="preserve">
          <source>The direction and magnitude of the 3rd shift. Positive means left, negative means right.</source>
          <target state="translated">三档的方向和幅度。正表示左,负表示右。</target>
        </trans-unit>
        <trans-unit id="3c5a37562720e9b61ecfa6b8583112dc5d6824cf" translate="yes" xml:space="preserve">
          <source>The direction in time to expand the interval.</source>
          <target state="translated">在时间上扩大区间的方向。</target>
        </trans-unit>
        <trans-unit id="52fc8addeaa24de333c4f04db15ff317feeb8f10" translate="yes" xml:space="preserve">
          <source>The direction to iterate in. If passing the return value to &lt;code&gt;fwdRange&lt;/code&gt;, use &lt;code&gt;Direction.fwd&lt;/code&gt;. If passing it to &lt;code&gt;bwdRange&lt;/code&gt;, use &lt;code&gt;Direction.bwd&lt;/code&gt;.</source>
          <target state="translated">要迭代的方向。如果将返回值传递给 &lt;code&gt;fwdRange&lt;/code&gt; ，请使用 &lt;code&gt;Direction.fwd&lt;/code&gt; 。如果将其传递给 &lt;code&gt;bwdRange&lt;/code&gt; ，请使用 &lt;code&gt;Direction.bwd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae829e1bef022f58af3dfe6292cdbc4a3e16363d" translate="yes" xml:space="preserve">
          <source>The directories listed in the PATH environment variable.</source>
          <target state="translated">PATH环境变量中列出的目录。</target>
        </trans-unit>
        <trans-unit id="745a52fd17585cda122240a437ff94eb24ff53ba" translate="yes" xml:space="preserve">
          <source>The directory from which the application loaded.</source>
          <target state="translated">应用程序加载的目录。</target>
        </trans-unit>
        <trans-unit id="c70ca0dd7d389cc0f66b4748ce2158d5f654afbf" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TEMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TEMP&lt;/code&gt; 环境变量给定的目录。</target>
        </trans-unit>
        <trans-unit id="9ae0bd7ea20121e71f355b6ae61308dbc4fc4a8d" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TMP&lt;/code&gt; 环境变量给定的目录。</target>
        </trans-unit>
        <trans-unit id="daef8bc56ebc827befeb7f02e13c0987eaa60ed2" translate="yes" xml:space="preserve">
          <source>The directory given by the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;TMPDIR&lt;/code&gt; 环境变量给定的目录。</target>
        </trans-unit>
        <trans-unit id="d4eec1b6c0603738af374e4a976caa00a506fd85" translate="yes" xml:space="preserve">
          <source>The directory to iterate over. If empty, the current directory will be iterated.</source>
          <target state="translated">要迭代的目录。如果为空,则会遍历当前目录。</target>
        </trans-unit>
        <trans-unit id="98b1c4850f41f23860e357cb3645bbbb143947fc" translate="yes" xml:space="preserve">
          <source>The directory where the TZ Database files are located.</source>
          <target state="translated">TZ数据库文件所在的目录。</target>
        </trans-unit>
        <trans-unit id="5185a0b5ceb9f32e8b2ce8a938cb585e46dedffd" translate="yes" xml:space="preserve">
          <source>The directory where the TZ Database files are located. Because these files are not located on Windows systems, provide them and give their location here to use &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">TZ数据库文件所在的目录。由于这些文件不在Windows系统上，因此请提供它们并在此处指定位置以使用&lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b936f38c2f1aa54bd76a7cc62b14148166a642a" translate="yes" xml:space="preserve">
          <source>The disadvantages of &lt;code&gt;ContiguousFreeList&lt;/code&gt; over &lt;code&gt;FreeList&lt;/code&gt; are its pay upfront model (as opposed to &lt;code&gt;FreeList&lt;/code&gt;'s pay-as-you-go approach), and a hard limit on the number of nodes in the list. Thus, a large number of long- lived objects may occupy the entire block, making it unavailable for serving allocations from the free list. However, an absolute cap on the free list size may be beneficial.</source>
          <target state="translated">与 &lt;code&gt;FreeList&lt;/code&gt; 相比， &lt;code&gt;ContiguousFreeList&lt;/code&gt; 的缺点在于它的付费预付模型（与 &lt;code&gt;FreeList&lt;/code&gt; 的按需付费方式相对）和对列表中节点数的硬限制。因此，大量的长期对象可能会占据整个块，从而使其无法用于空闲列表中的服务分配。但是，对空闲列表大小的绝对上限可能是有益的。</target>
        </trans-unit>
        <trans-unit id="3b64019a956fdeb2b48af242389c7dfaf52e1521" translate="yes" xml:space="preserve">
          <source>The distinction is made in the semantic analysis pass.</source>
          <target state="translated">在语义分析关中进行了区分。</target>
        </trans-unit>
        <trans-unit id="d29faf2564401dd940d152dda18be8c2fa0d07a8" translate="yes" xml:space="preserve">
          <source>The document comment is a series of</source>
          <target state="translated">文件评论是一系列的</target>
        </trans-unit>
        <trans-unit id="e57c999ce3911b8c1791d1a7eb04e0490e4fee0b" translate="yes" xml:space="preserve">
          <source>The documentation comment processor includes a simple macro text preprocessor. When a &amp;amp;dollar;(</source>
          <target state="translated">文档注释处理器包括一个简单的宏文本预处理器。当一个＆dollar;（</target>
        </trans-unit>
        <trans-unit id="0f835ee5f6e2ea0040d44210ead7dc160306901a" translate="yes" xml:space="preserve">
          <source>The documentation comments can themselves be commented using the &amp;amp;dollar;&lt;code&gt;(DDOC_COMMENT comment text)&lt;/code&gt; syntax. These comments do not nest.</source>
          <target state="translated">文档注释本身可以使用＆dollar;进行注释。 &lt;code&gt;(DDOC_COMMENT comment text)&lt;/code&gt; 语法。这些注释不嵌套。</target>
        </trans-unit>
        <trans-unit id="ad9fa243a6cd23895dc3ad60e16a76e4b15cce21" translate="yes" xml:space="preserve">
          <source>The domain literal is not a valid RFC 5321 address literal</source>
          <target state="translated">域名文字不是有效的RFC 5321地址文字。</target>
        </trans-unit>
        <trans-unit id="e9bc2306173e1f523fc346c3259e214855410cc4" translate="yes" xml:space="preserve">
          <source>The domain literal is not a valid RFC 5321 address literal and it contains obsolete characters</source>
          <target state="translated">域名文字不是有效的RFC 5321地址文字,它包含过时的字符。</target>
        </trans-unit>
        <trans-unit id="9635c78033f40ef6473df58ddae1875249393348" translate="yes" xml:space="preserve">
          <source>The domain of definition is 0 &amp;lt;= x &amp;lt;= 1. In this implementation a and b are restricted to positive values. The integral from x to 1 may be obtained by the symmetry relation</source>
          <target state="translated">定义域为0 &amp;lt;= x &amp;lt;=1。在此实现中，a和b限制为正值。从x到1的积分可以通过对称关系获得</target>
        </trans-unit>
        <trans-unit id="7630f4b6e086656f20c44179d8d49a08885c5ad0" translate="yes" xml:space="preserve">
          <source>The domain part contains an element that is too long</source>
          <target state="translated">域名部分包含一个过长的元素。</target>
        </trans-unit>
        <trans-unit id="f9e782a18f0e80044819c477465949e037991e2b" translate="yes" xml:space="preserve">
          <source>The domain part is too long</source>
          <target state="translated">域名部分太长</target>
        </trans-unit>
        <trans-unit id="b4015656a3a26966f5bb779ad625cb099b930b1f" translate="yes" xml:space="preserve">
          <source>The domain part of the email address, that is, the part after the @ sign.</source>
          <target state="translated">电子邮件地址的域名部分,也就是@号之后的部分。</target>
        </trans-unit>
        <trans-unit id="bc43c1b6acb6b3f1be54a397e4365b408708f795" translate="yes" xml:space="preserve">
          <source>The drain of the data read.</source>
          <target state="translated">读取数据的消耗。</target>
        </trans-unit>
        <trans-unit id="d6c5fc3ceb4e2b528f0297088355338c6c888969" translate="yes" xml:space="preserve">
          <source>The duration from the starting point to the end point.</source>
          <target state="translated">从起点到终点的持续时间。</target>
        </trans-unit>
        <trans-unit id="13e96de5799e2b95c36e302f2857b76d002475c9" translate="yes" xml:space="preserve">
          <source>The duration to add to or subtract from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;或从中减去的持续时间。</target>
        </trans-unit>
        <trans-unit id="5de9a67b89b5b7a6e94e2e5ed705920f06e257b1" translate="yes" xml:space="preserve">
          <source>The duration to add to or subtract from this &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">要添加到此 &lt;code&gt;Duration&lt;/code&gt; 或从中减去的持续时间。</target>
        </trans-unit>
        <trans-unit id="045eb63ee5246a358977769376ebbddf4f7e79de" translate="yes" xml:space="preserve">
          <source>The duration to add to the time point passed to the delegate.</source>
          <target state="translated">要添加到传递给委托人的时间点的持续时间。</target>
        </trans-unit>
        <trans-unit id="f712fda6f39835e50109819b59fa2e17d776d88d" translate="yes" xml:space="preserve">
          <source>The duration to divide this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">该持续时间除以的 &lt;code&gt;Duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebebf2b9a88fc743bbefdf245fe1996fed62b5d4" translate="yes" xml:space="preserve">
          <source>The duration to expand the interval by.</source>
          <target state="translated">扩大间隔的持续时间。</target>
        </trans-unit>
        <trans-unit id="6b8d59a6b4eb6f151c22d18ab315e8905cbca345" translate="yes" xml:space="preserve">
          <source>The duration to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s fractional seconds to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的分数秒设置为的持续时间。</target>
        </trans-unit>
        <trans-unit id="10a00cd16c4e11d477797057c8547364622ecc0c" translate="yes" xml:space="preserve">
          <source>The duration to shift the interval by.</source>
          <target state="translated">要移动的时间间隔。</target>
        </trans-unit>
        <trans-unit id="b1c624813bb3a1615cc85c1ae1a0262dd3e649d6" translate="yes" xml:space="preserve">
          <source>The duration which separates each successive time point in the range.</source>
          <target state="translated">范围内每个连续时间点之间的持续时间。</target>
        </trans-unit>
        <trans-unit id="4aceca3575bedab7bdf950c54d8f75f4cd974c6c" translate="yes" xml:space="preserve">
          <source>The effect of this function, as well as the meaning of &lt;code&gt;codeOrSignal&lt;/code&gt;, is highly platform dependent. Details are given below. Common to all platforms is that this function only</source>
          <target state="translated">此功能的效果以及 &lt;code&gt;codeOrSignal&lt;/code&gt; 的含义在很大程度上取决于平台。细节在下面给出。所有平台的共同点是仅此功能</target>
        </trans-unit>
        <trans-unit id="b949a7d4d40b96549035bb1b9cabaaf6d915fa2c" translate="yes" xml:space="preserve">
          <source>The effect on &lt;code&gt;inp&lt;/code&gt; depends on the kind of function called:</source>
          <target state="translated">对 &lt;code&gt;inp&lt;/code&gt; 的影响取决于调用的函数类型：</target>
        </trans-unit>
        <trans-unit id="562dbad759d6f2a80acd12d273fe89562ff6f2e0" translate="yes" xml:space="preserve">
          <source>The element (or range) to be treated as the separator between range segments to be split.</source>
          <target state="translated">要处理的元素(或范围)作为要分割的范围段之间的分隔符。</target>
        </trans-unit>
        <trans-unit id="67f3be77d3c98017b171a56f0b2ef27d5b2a4614" translate="yes" xml:space="preserve">
          <source>The element at offset &lt;code&gt;1&lt;/code&gt; has been removed and the rest of the elements have shifted up to fill its place, however, the original array remains of the same length. This is because all functions in &lt;code&gt;std.algorithm&lt;/code&gt; only change</source>
          <target state="translated">偏移量为 &lt;code&gt;1&lt;/code&gt; 的元素已被删除，其余元素已上移以填充其位置，但是原始数组的长度保持不变。这是因为 &lt;code&gt;std.algorithm&lt;/code&gt; 中的所有功能都只会更改</target>
        </trans-unit>
        <trans-unit id="889dab60cf01b0f7421719ab37f1b28c9311efa0" translate="yes" xml:space="preserve">
          <source>The element corresponding with a left (opening) parenthesis.</source>
          <target state="translated">与左(开口)括号对应的元素。</target>
        </trans-unit>
        <trans-unit id="0932ed8af54392d39cf0d92fcbcc4890a1724cbd" translate="yes" xml:space="preserve">
          <source>The element corresponding with a right (closing) parenthesis.</source>
          <target state="translated">与右括号(闭合)相对应的元素。</target>
        </trans-unit>
        <trans-unit id="dedbb295326b4d3eda9e5e759f27bfe1c5ac6bc2" translate="yes" xml:space="preserve">
          <source>The element is assumed to contain text</source>
          <target state="translated">假设该元素包含文本</target>
        </trans-unit>
        <trans-unit id="8312cc74e186b12d4ed20f4003b6c04acdd49b6e" translate="yes" xml:space="preserve">
          <source>The element or a reference to the element at the specified index.</source>
          <target state="translated">元素或对指定索引的元素的引用。</target>
        </trans-unit>
        <trans-unit id="7131957f7eb94e306d342b5195eb84dc3e1e781f" translate="yes" xml:space="preserve">
          <source>The element or sub-range to count in the &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; 要计数的元素或子范围。</target>
        </trans-unit>
        <trans-unit id="7a38c4dc1b72acf54e9b103de60a08c5dad1c7f0" translate="yes" xml:space="preserve">
          <source>The element removed.</source>
          <target state="translated">删除的内容;</target>
        </trans-unit>
        <trans-unit id="f20b1e66abf934338028bfca19daea068ac238b3" translate="yes" xml:space="preserve">
          <source>The element searched for.</source>
          <target state="translated">搜索的元素。</target>
        </trans-unit>
        <trans-unit id="3af3bbcb06a3c010f8dd6e115df00414b2ef76c3" translate="yes" xml:space="preserve">
          <source>The element to match.</source>
          <target state="translated">要匹配的元素。</target>
        </trans-unit>
        <trans-unit id="bfcc76451138cf6e179bded66babeafecdbfe06a" translate="yes" xml:space="preserve">
          <source>The element to stop at.</source>
          <target state="translated">要素停在。</target>
        </trans-unit>
        <trans-unit id="b80bff8085fdd511cb9c4d9e05da48019bf3dd74" translate="yes" xml:space="preserve">
          <source>The element type for 32-bit implementation.</source>
          <target state="translated">32位实现的元素类型。</target>
        </trans-unit>
        <trans-unit id="218ef2dcaf3b3057dc646bab34be48640fa2fc83" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;Char[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">范围的元素类型将为 &lt;code&gt;Char[]&lt;/code&gt; 。范围原语可能在I / O错误时引发 &lt;code&gt;StdioException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8e0ad7d182f093115b2321024fb0d43eeab8ccb" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;ubyte[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">范围的元素类型将为 &lt;code&gt;ubyte[]&lt;/code&gt; 。范围原语可能在I / O错误时引发 &lt;code&gt;StdioException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146f6e63904487c6bc88a456ffe5bb5d872efab2" translate="yes" xml:space="preserve">
          <source>The element type of &lt;code&gt;R&lt;/code&gt;. &lt;code&gt;R&lt;/code&gt; does not have to be a range. The element type is determined as the type yielded by &lt;code&gt;r.front&lt;/code&gt; for an object &lt;code&gt;r&lt;/code&gt; of type &lt;code&gt;R&lt;/code&gt;. For example, &lt;code&gt;ElementType!(T[])&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T[]&lt;/code&gt; isn't a narrow string; if it is, the element type is &lt;code&gt;dchar&lt;/code&gt;. If &lt;code&gt;R&lt;/code&gt; doesn't have &lt;code&gt;front&lt;/code&gt;, &lt;code&gt;ElementType!R&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 的元素类型。 &lt;code&gt;R&lt;/code&gt; 不必是范围。元素类型确定为 &lt;code&gt;r.front&lt;/code&gt; 为类型 &lt;code&gt;R&lt;/code&gt; 的对象 &lt;code&gt;r&lt;/code&gt; 产生的类型。例如，如果 &lt;code&gt;T[]&lt;/code&gt; 不是窄字符串，则 &lt;code&gt;ElementType!(T[])&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; ；如果是，则元素类型为 &lt;code&gt;dchar&lt;/code&gt; 。如果 &lt;code&gt;R&lt;/code&gt; 不具有 &lt;code&gt;front&lt;/code&gt; ，则 &lt;code&gt;ElementType!R&lt;/code&gt; 为 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="242b60e2b158a7060db8baf4f6cc26e6d87af9f3" translate="yes" xml:space="preserve">
          <source>The element's CData items</source>
          <target state="translated">元素的CD数据项</target>
        </trans-unit>
        <trans-unit id="c3b9d2b70df47460f19754a079e90ba32c948935" translate="yes" xml:space="preserve">
          <source>The element's child elements</source>
          <target state="translated">该元素的子元素</target>
        </trans-unit>
        <trans-unit id="a931fa1a5c6e1ac62a1fb67480e5e8ac09b9bdb7" translate="yes" xml:space="preserve">
          <source>The element's comments</source>
          <target state="translated">该元素的注释</target>
        </trans-unit>
        <trans-unit id="a2b54c10854bacd9d44680700556c9e99d65c27d" translate="yes" xml:space="preserve">
          <source>The element's items</source>
          <target state="translated">该元素的项目</target>
        </trans-unit>
        <trans-unit id="585ede5c120291a9643e02011ada89b79cd9d6f7" translate="yes" xml:space="preserve">
          <source>The element's processing instructions</source>
          <target state="translated">元素的处理指令</target>
        </trans-unit>
        <trans-unit id="eb70f51eec72df5d60ca23b74395601f21da9c66" translate="yes" xml:space="preserve">
          <source>The element's text items</source>
          <target state="translated">元素的文本项</target>
        </trans-unit>
        <trans-unit id="e5bc2ae39e4f9e29954c5367c1c69157fdd19e00" translate="yes" xml:space="preserve">
          <source>The email address to check</source>
          <target state="translated">检查的电子邮件地址</target>
        </trans-unit>
        <trans-unit id="48e5305233fe3d75b0443ee1f50818a6d648fd6c" translate="yes" xml:space="preserve">
          <source>The email status code</source>
          <target state="translated">邮件状态代码</target>
        </trans-unit>
        <trans-unit id="4346e3e9e5e3a95198a31c78de02c8e03150e933" translate="yes" xml:space="preserve">
          <source>The encoded string</source>
          <target state="translated">编码后的字符串</target>
        </trans-unit>
        <trans-unit id="381ff9274ef41642af8e81eebffce945d9f4f6ee" translate="yes" xml:space="preserve">
          <source>The encoding element type of &lt;code&gt;R&lt;/code&gt;. For narrow strings (&lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt; and their qualified variants including &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;wstring&lt;/code&gt;), &lt;code&gt;ElementEncodingType&lt;/code&gt; is the character type of the string. For all other types, &lt;code&gt;ElementEncodingType&lt;/code&gt; is the same as &lt;code&gt;ElementType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 的编码元素类型。对于窄字符串（ &lt;code&gt;char[]&lt;/code&gt; ， &lt;code&gt;wchar[]&lt;/code&gt; 及其限定的变体，包括 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;wstring&lt;/code&gt; ）， &lt;code&gt;ElementEncodingType&lt;/code&gt; 是字符串的字符类型。对于所有其他类型， &lt;code&gt;ElementEncodingType&lt;/code&gt; 与 &lt;code&gt;ElementType&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8ddaa2a73311c2a472b8bde0c140d7d16072aef8" translate="yes" xml:space="preserve">
          <source>The end point of the interval. It is excluded from the interval.</source>
          <target state="translated">区间的终点。它被排除在区间之外。</target>
        </trans-unit>
        <trans-unit id="3045098b74bc924c86c93e1e08406b98332239d1" translate="yes" xml:space="preserve">
          <source>The endianness that the bytes are assumed to be in.</source>
          <target state="translated">字节的字节数。</target>
        </trans-unit>
        <trans-unit id="d625680f2f5053e8d89e9dc8332e606f7d3ff5c0" translate="yes" xml:space="preserve">
          <source>The endianness that the program was compiled for.</source>
          <target state="translated">编制程序的目的。</target>
        </trans-unit>
        <trans-unit id="2c31e59fa05bc473d51ba9ff8b1fbea71679f185" translate="yes" xml:space="preserve">
          <source>The endianness to write the bytes in.</source>
          <target state="translated">写入字节的字节数。</target>
        </trans-unit>
        <trans-unit id="598292bc5270606189fdedc665ef492ceced68f0" translate="yes" xml:space="preserve">
          <source>The entire random number library architecture is derived from the excellent &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C++0X&lt;/a&gt; random number facility proposed by Jens Maurer and contributed to by researchers at the Fermi laboratory (excluding Xorshift).</source>
          <target state="translated">整个随机数库的体系结构均由Jens Maurer提出的出色的&lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C ++ 0X&lt;/a&gt;随机数工具派生而成，并由费米实验室的研究人员（不包括Xorshift）提供。</target>
        </trans-unit>
        <trans-unit id="888201d962022c79856dc1d83803a781978d38cd" translate="yes" xml:space="preserve">
          <source>The equality and inequality operators are treated separately because while practically all user-defined types can be compared for equality, only a subset of types have a meaningful ordering. For example, while it makes sense to determine if two RGB color vectors are equal, it is not meaningful to say that one color is greater than another, because colors do not have an ordering. Thus, one would define &lt;code&gt;opEquals&lt;/code&gt; for a &lt;code&gt;Color&lt;/code&gt; type, but not &lt;code&gt;opCmp&lt;/code&gt;.</source>
          <target state="translated">对等号和不等号运算符进行单独处理，因为尽管实际上可以比较所有用户定义的类型的相等性，但只有类型的子集具有有意义的顺序。例如，虽然确定两个RGB颜色向量是否相等是有意义的，但是说一种颜色大于另一种颜色是没有意义的，因为颜色没有排序。因此，可以为 &lt;code&gt;Color&lt;/code&gt; 类型定义 &lt;code&gt;opEquals&lt;/code&gt; ，而不是 &lt;code&gt;opCmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b1ab6f47e6e402fb3a24bfb9f554e1d0036e9f7" translate="yes" xml:space="preserve">
          <source>The equivalent of member function pointers can be constructed using anonymous lambda functions:</source>
          <target state="translated">成员函数指针的等价物可以使用匿名lambda函数来构造。</target>
        </trans-unit>
        <trans-unit id="b934e5ce8d172dbc9fefc885ad8f4ba875129f8a" translate="yes" xml:space="preserve">
          <source>The error message incase &lt;code&gt;version != D_TypeInfo&lt;/code&gt;</source>
          <target state="translated">错误消息， &lt;code&gt;version != D_TypeInfo&lt;/code&gt; 万一！= D_TypeInfo</target>
        </trans-unit>
        <trans-unit id="74494fb82c47edd9793007790b8ec76ed5efb325" translate="yes" xml:space="preserve">
          <source>The error message to put in the exception if it is thrown.</source>
          <target state="translated">如果抛出异常,要在异常中加入错误信息。</target>
        </trans-unit>
        <trans-unit id="ac179c7a25f054b9a84b196608bf4de9e907b671" translate="yes" xml:space="preserve">
          <source>The error number.</source>
          <target state="translated">错误编号。</target>
        </trans-unit>
        <trans-unit id="bb2bfcd8d277ad988cd58683c68c61867529b4d8" translate="yes" xml:space="preserve">
          <source>The escape sequences listed in &lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt;中列出的转义序列为：</target>
        </trans-unit>
        <trans-unit id="813068399b629e54556fe2331c136edacd43967a" translate="yes" xml:space="preserve">
          <source>The escapes section is a series of substitutions which replace special characters with a string. It's useful when the output format requires escaping of certain characters, for example in HTML &lt;b&gt;&amp;amp;&lt;/b&gt; should be escaped with &lt;b&gt;&amp;amp;amp;&lt;/b&gt;.</source>
          <target state="translated">转义部分是一系列替换，用字符串替换特殊字符。当输出格式要求转义某些字符（例如以HTML格式转义）&lt;b&gt;并&lt;/b&gt;应使用&lt;b&gt;＆amp;&lt;/b&gt;转义时，此功能很有用&lt;b&gt;。&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="75a80775312b743d79dc5f0458ad6638745e66ff" translate="yes" xml:space="preserve">
          <source>The event handler that gets called to inform of upload/download progress.</source>
          <target state="translated">用于通知上传/下载进度的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="28ee4bbd0a86e9401b5c283e4626c6777888197c" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending.</source>
          <target state="translated">当需要发送数据时被调用的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="ec0b1eb03ea092eed8857727c86d04dbd3bf6621" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending. The length of the &lt;code&gt;void[]&lt;/code&gt; specifies the maximum number of bytes that can be sent.</source>
          <target state="translated">需要发送数据时调用的事件处理程序。 &lt;code&gt;void[]&lt;/code&gt; 的长度指定可以发送的最大字节数。</target>
        </trans-unit>
        <trans-unit id="c126a38e12f3ea900a6ea7dfdda2e34138f69566" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the curl backend needs to seek the data to be sent.</source>
          <target state="translated">当curl后端需要寻找要发送的数据时被调用的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="c7e1c85c7ca7e98c1826ed981521b324453ed7c7" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the net socket has been created but a &lt;code&gt;connect()&lt;/code&gt; call has not yet been done. This makes it possible to set misc. socket options.</source>
          <target state="translated">创建网络套接字但尚未完成 &lt;code&gt;connect()&lt;/code&gt; 调用时将调用的事件处理程序。这样就可以设置misc。套接字选项。</target>
        </trans-unit>
        <trans-unit id="02f312ca0b7e961f5a4f5917e4aa7edb41e07360" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data.</source>
          <target state="translated">接收传入数据的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="b87e0289d3effbf7cf04a5f7cfbfced82cc1d3d4" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data. Be sure to copy the incoming ubyte[] since it is not guaranteed to be valid after the callback returns.</source>
          <target state="translated">接收传入数据的事件处理程序。一定要复制传入的ubyte[],因为在回调返回后不能保证它是有效的。</target>
        </trans-unit>
        <trans-unit id="4c604b49f0361c7bde910df7da9e4d17ed0e24e3" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming headers for protocols that uses headers.</source>
          <target state="translated">接收使用头文件的协议的传入头文件的事件处理程序。</target>
        </trans-unit>
        <trans-unit id="52a6be95e3d2f965951f9ddade7c43108c67742d" translate="yes" xml:space="preserve">
          <source>The event module provides a primitive for lightweight signaling of other threads (emulating Windows events on Posix)</source>
          <target state="translated">事件模块为其他线程的轻量级信号传递提供了一个基元(在Posix上模拟Windows事件)</target>
        </trans-unit>
        <trans-unit id="76cbd20f024df6b80d67a632d5c0a1a01fd91d83" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOExtString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">确切的格式与 &lt;code&gt;toISOExtString&lt;/code&gt; 中的描述完全相同，不同之处在于允许尾随零-包括小数秒和全零。但是，小数点后面没有任何小数点是无效的。同样，虽然&lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; 绝不&lt;/a&gt;会在小数秒内生成超过7位数字的字符串（因为这是百赫纳秒精度的限制），但它会允许超过7位数字以便从其他精度更高的源读取字符串（但是，任何超过7的数字都将被截断）。</target>
        </trans-unit>
        <trans-unit id="dbfdac6af98f1a47c12d787fa314f16848732e36" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOString&quot;&gt;&lt;code&gt;toISOString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">确切的格式与 &lt;code&gt;toISOString&lt;/code&gt; 中的描述完全相同，不同之处在于允许尾随零-包括小数点全为零。但是，小数点后面没有任何小数点是无效的。同样，尽管&lt;a href=&quot;#toISOString&quot;&gt; &lt;code&gt;toISOString&lt;/code&gt; &lt;/a&gt;绝不会在小数秒内生成超过7位数字的字符串（因为这是十进制纳秒精度的限制），但它将允许超过7位数字以便从其他精度更高的源读取字符串（但是，任何超过7的数字都将被截断）。</target>
        </trans-unit>
        <trans-unit id="8035aabeb60ff48fad9d3507168fac10a852f522" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toSimpleString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toSimpleString&quot;&gt;&lt;code&gt;toSimpleString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">确切的格式与 &lt;code&gt;toSimpleString&lt;/code&gt; 中的描述完全相同，不同之处在于允许尾随零-包括小数秒和全零。但是，小数点后面没有任何小数点是无效的。此外，虽然&lt;a href=&quot;#toSimpleString&quot;&gt; &lt;code&gt;toSimpleString&lt;/code&gt; 绝不&lt;/a&gt;会在小数秒内生成超过7位数字的字符串（因为这是百赫纳秒精度的限制），但它将允许超过7位数字以便从其他精度更高的源读取字符串（但是，任何超过7的数字都将被截断）。</target>
        </trans-unit>
        <trans-unit id="65836ccc655a37d33dfc806f525851b4dc381228" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged pointer in the struct A. The pointer is of type &lt;code&gt;uint*&lt;/code&gt; as specified by the first argument, and is named x, as specified by the second argument.</source>
          <target state="translated">上面的示例在结构A中创建了一个带标记的指针。该指针的类型为 &lt;code&gt;uint*&lt;/code&gt; （由第一个参数指定），并被命名为x（由第二个参数指定）。</target>
        </trans-unit>
        <trans-unit id="a8289a8de27bbcdd9e4b7b9885e6899b4349a782" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged reference to an Object in the struct A. This expects the same parameters as &lt;code&gt;taggedPointer&lt;/code&gt;, except the first argument which must be a class type instead of a pointer type.</source>
          <target state="translated">上面的示例在结构A中创建对Object的带标记的引用。除了第一个参数必须是类类型而不是指针类型之外，它期望的参数与 &lt;code&gt;taggedPointer&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="95c0102684861c4577b62ad69eb70ff34b2390d6" translate="yes" xml:space="preserve">
          <source>The example above wreaks havoc on client code because it is modifying arrays that callers considered immutable. To obtain an immutable array from the writable array &lt;code&gt;buffer&lt;/code&gt;, replace the last line with:</source>
          <target state="translated">上面的示例对客户端代码造成了严重破坏，因为它正在修改调用者认为不可变的数组。要从可写数组 &lt;code&gt;buffer&lt;/code&gt; 获取不可变数组，请将最后一行替换为：</target>
        </trans-unit>
        <trans-unit id="399a22d99c9e7b3b5ee30ddef81ec062aec6bdce" translate="yes" xml:space="preserve">
          <source>The example below features an allocator modeled after &lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt;, which uses a battery of free-list allocators spaced so as to keep internal fragmentation to a minimum. The &lt;code&gt;FList&lt;/code&gt; definitions specify no bounds for the freelist because the &lt;code&gt;Segregator&lt;/code&gt; does all size selection in advance.</source>
          <target state="translated">下面的示例以&lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt;建模，分配器使用了一系列自由列表分配器，这些分配器以一定间隔隔开，以使内部碎片最小化。该 &lt;code&gt;FList&lt;/code&gt; 定义，因为该指定空闲列表没有界限 &lt;code&gt;Segregator&lt;/code&gt; 做事先所有的尺寸选择。</target>
        </trans-unit>
        <trans-unit id="03c82011a176c73b7fd2e55e8d4ca5d5e5bc2671" translate="yes" xml:space="preserve">
          <source>The example sets a new &lt;code&gt;FileLogger&lt;/code&gt; as new &lt;code&gt;sharedLog&lt;/code&gt;.  If at some point you want to use the original default logger again, you can use &lt;code&gt;sharedLog = null;&lt;/code&gt;. This will put back the original.</source>
          <target state="translated">该示例将一个新的 &lt;code&gt;FileLogger&lt;/code&gt; 设置为新的 &lt;code&gt;sharedLog&lt;/code&gt; 。如果您想再次使用原始的默认记录器，则可以使用 &lt;code&gt;sharedLog = null;&lt;/code&gt; 。这将放回原件。</target>
        </trans-unit>
        <trans-unit id="ad582bc954e72accfcbe7e749d32e98547d0b17c" translate="yes" xml:space="preserve">
          <source>The exception module defines all system-level exceptions and provides a mechanism to alter system-level error handling.</source>
          <target state="translated">异常模块定义了所有系统级的异常,并提供了一个改变系统级错误处理的机制。</target>
        </trans-unit>
        <trans-unit id="7a6c8dd2c388cd128d91f81fff3c160065b3f34b" translate="yes" xml:space="preserve">
          <source>The exception thrown during finalization.</source>
          <target state="translated">在定稿时抛出的异常。</target>
        </trans-unit>
        <trans-unit id="9e6c1b1caa6f537b3b32ae230a3319f2a84949f0" translate="yes" xml:space="preserve">
          <source>The exception to throw if the value evaluates to false.</source>
          <target state="translated">当值为false时要抛出的异常。</target>
        </trans-unit>
        <trans-unit id="cbc3d84209a76290f33343978e317c76e214fa4c" translate="yes" xml:space="preserve">
          <source>The exponent is negative and the factor is one, i.e., output[j] := sum[ exp(-2 PI i j k / N) input[k] ].</source>
          <target state="translated">指数为负,因数为一,即输出[j]:=sum[exp(-2 PI i j k/N)input[k]]。</target>
        </trans-unit>
        <trans-unit id="08786360cdc12838546c00b5767cf2cab959b50c" translate="yes" xml:space="preserve">
          <source>The exponent is positive and the factor is 1/N, i.e., output[j] := (1 / N) sum[ exp(+2 PI i j k / N) input[k] ].</source>
          <target state="translated">指数为正,因数为1/N,即输出[j]:=(1/N)sum[exp(+2 PI i j k/N)input[k]]。</target>
        </trans-unit>
        <trans-unit id="c871c5d07aafe7ec6925f7e7fae1500b032e2b52" translate="yes" xml:space="preserve">
          <source>The expression and the errorHandler must have a common type they can both be implicitly casted to, and that type will be the type of the compound expression.</source>
          <target state="translated">表达式和errorHandler必须有一个共同的类型,它们都可以隐式地投向,这个类型将是复合表达式的类型。</target>
        </trans-unit>
        <trans-unit id="34375c5ee3f5635a2e38da6b0e76fc609894c573" translate="yes" xml:space="preserve">
          <source>The expression asserted not to throw.</source>
          <target state="translated">表示断言不扔。</target>
        </trans-unit>
        <trans-unit id="940dd3375faca27ce190b8fb03def99092a3aab1" translate="yes" xml:space="preserve">
          <source>The expression form is:</source>
          <target state="translated">表达形式为:</target>
        </trans-unit>
        <trans-unit id="cc54de17f165e5e9a2ba7fa962f4eecaa39f90b2" translate="yes" xml:space="preserve">
          <source>The expression is evaluated.</source>
          <target state="translated">该表达式已被评估。</target>
        </trans-unit>
        <trans-unit id="22a556158ebfbc64522a677428ab0391c34f8183" translate="yes" xml:space="preserve">
          <source>The expression that copy constructs or moves the value.</source>
          <target state="translated">复制构造或移动值的表达式。</target>
        </trans-unit>
        <trans-unit id="91f707cf0e8e3128051036fb96ff3b7693733b1d" translate="yes" xml:space="preserve">
          <source>The expression to resolve as type or symbol.</source>
          <target state="translated">要解析为类型或符号的表达式。</target>
        </trans-unit>
        <trans-unit id="29c4204e99277952fc7a54ab66543bc42d61a803" translate="yes" xml:space="preserve">
          <source>The expression to run and return its result.</source>
          <target state="translated">要运行的表达式并返回其结果。</target>
        </trans-unit>
        <trans-unit id="92d0bb2bd94dd52b7503e678d48be02f028860ef" translate="yes" xml:space="preserve">
          <source>The expression to test.</source>
          <target state="translated">要测试的表达方式。</target>
        </trans-unit>
        <trans-unit id="3ba5f3fe8e3c4ad3783ea96faee9ce1e4526ddb4" translate="yes" xml:space="preserve">
          <source>The expression which may throw an exception.</source>
          <target state="translated">可能引发异常的表达式。</target>
        </trans-unit>
        <trans-unit id="646fe39033d4569a34021185a6750173a3852965" translate="yes" xml:space="preserve">
          <source>The expression:</source>
          <target state="translated">这句话:</target>
        </trans-unit>
        <trans-unit id="24968438ed1fc3f9aa123f08e882cf9dcb629a30" translate="yes" xml:space="preserve">
          <source>The extension part of a file name, including the dot.  If there is no extension, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">文件名的扩展名部分，包括点。如果没有扩展名，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="001c41a8faed92276e0710e5f77bacf1f43befe9" translate="yes" xml:space="preserve">
          <source>The extra *'s and +'s on the comment opening, closing and left margin are ignored and are not part of the embedded documentation. Comments not following one of those forms are not documentation comments.</source>
          <target state="translated">注释开头、结尾和左边空白处多余的*号和+号会被忽略,不属于嵌入式文档的一部分。不遵循这些形式之一的注释不属于文档注释。</target>
        </trans-unit>
        <trans-unit id="60cbf9a8b6c782eeaf3b240238aaad4006024e93" translate="yes" xml:space="preserve">
          <source>The factory should print an error and abort the program if it cannot successfully initialize the GC instance.</source>
          <target state="translated">如果工厂不能成功初始化GC实例,应打印错误并中止程序。</target>
        </trans-unit>
        <trans-unit id="f5a2d7b1faf4a00e391206a0b6d040b1dd55f507" translate="yes" xml:space="preserve">
          <source>The fallback allocator.</source>
          <target state="translated">后备分配器。</target>
        </trans-unit>
        <trans-unit id="6444c34b4999b63334e3fe1c10565688c176440d" translate="yes" xml:space="preserve">
          <source>The fiber function.</source>
          <target state="translated">的纤维功能。</target>
        </trans-unit>
        <trans-unit id="4ebf4ba0f41676101df65de78d14565377976d26" translate="yes" xml:space="preserve">
          <source>The fiber object representing the calling fiber or null if no fiber is currently active within this thread. The result of deleting this object is undefined.</source>
          <target state="translated">代表调用光纤的光纤对象,如果该线程内当前没有光纤活动,则为空。删除此对象的结果是未定义的。</target>
        </trans-unit>
        <trans-unit id="7163e2b220c5c73c7ee35da99996a1282317d054" translate="yes" xml:space="preserve">
          <source>The field is ended when there is no input, even if the quote was not closed.</source>
          <target state="translated">当没有输入时,即使报价没有关闭,该字段也会被结束。</target>
        </trans-unit>
        <trans-unit id="779d09c98e4cfcdaab8d2edfcd062b2bc1c5fe62" translate="yes" xml:space="preserve">
          <source>The fields below this were added in CURLVERSION_SECOND</source>
          <target state="translated">下面的字段是在CURLVERSION_SECOND中添加的。</target>
        </trans-unit>
        <trans-unit id="7fb4d8eebf35f6bbc1f833a412d5cc7420dea229" translate="yes" xml:space="preserve">
          <source>The file (or directory) to get a DirEntry for.</source>
          <target state="translated">要获取DirEntry的文件(或目录)。</target>
        </trans-unit>
        <trans-unit id="40dabb9eb8e81154153036d71178601514e1f7f3" translate="yes" xml:space="preserve">
          <source>The file and line of the call.</source>
          <target state="translated">召的文件和行。</target>
        </trans-unit>
        <trans-unit id="2587d80da404ef88f56c1d45c26f059538ee948c" translate="yes" xml:space="preserve">
          <source>The file attributes or 0 if the file attributes were encoded for an incompatible OS (Windows vs. Posix).</source>
          <target state="translated">文件属性,如果文件属性是为不兼容的操作系统(Windows与Posix)编码的,则为0。</target>
        </trans-unit>
        <trans-unit id="f357296885e979c9eb815032610719a979731bd8" translate="yes" xml:space="preserve">
          <source>The file attributes.</source>
          <target state="translated">文件属性。</target>
        </trans-unit>
        <trans-unit id="21cf4d39fea8701f9ccea1f6e9c33a8dca629be0" translate="yes" xml:space="preserve">
          <source>The file name of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">D源代码的文件名,对应的错误是从哪里抛出的。</target>
        </trans-unit>
        <trans-unit id="b64522363b929d137710605ff07b8daf334bc620" translate="yes" xml:space="preserve">
          <source>The file name to show. If not set, the actual file name will be used (if this is a file part)</source>
          <target state="translated">要显示的文件名。如果没有设置,将使用实际的文件名(如果这是一个文件部分)。</target>
        </trans-unit>
        <trans-unit id="bf8ad1ee8706b576c3d861ca4c35b04004625b5d" translate="yes" xml:space="preserve">
          <source>The file names for packages and modules should also be composed of the ASCII characters lower case letters, digits or &lt;code&gt;_&lt;/code&gt; and should not be a &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">软件包和模块的文件名还应该由ASCII字符，小写字母，数字或 &lt;code&gt;_&lt;/code&gt; 组成,并且不能作为&lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;关键字&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27e521d84e71e057af31f6b16036a8dda6098775" translate="yes" xml:space="preserve">
          <source>The file that is being linked. This is the target path that's stored in the symlink. A relative path is relative to the created symlink.</source>
          <target state="translated">被链接的文件。这是存储在符号链接中的目标路径。相对路径是相对于创建的符号链接而言的。</target>
        </trans-unit>
        <trans-unit id="a48d130bf6ed7fe001b9b68c13bd4356b06eb640" translate="yes" xml:space="preserve">
          <source>The file that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">如果抛出&lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; ,&lt;/a&gt;它将列出该文件。</target>
        </trans-unit>
        <trans-unit id="886ddc5df982fa3a52b4dae1cc5e097e3fae8531" translate="yes" xml:space="preserve">
          <source>The file to get the attributes of.</source>
          <target state="translated">要获取属性的文件。</target>
        </trans-unit>
        <trans-unit id="c5856ac3b9ed35958ce9f401bbff0c265bcd66da" translate="yes" xml:space="preserve">
          <source>The file to get the symbolic link attributes of.</source>
          <target state="translated">要获取符号链接属性的文件。</target>
        </trans-unit>
        <trans-unit id="d5a902223a6a641c14dbfbc008db96721d6af330" translate="yes" xml:space="preserve">
          <source>The file used for logging.</source>
          <target state="translated">用于记录的文件。</target>
        </trans-unit>
        <trans-unit id="f7969ce864cdb7d64da59da6dfc8b40cf28ba7bb" translate="yes" xml:space="preserve">
          <source>The file where the error occurred.</source>
          <target state="translated">发生错误的文件。</target>
        </trans-unit>
        <trans-unit id="3ff1fcb05fd162b545299ba30ad59377c1eb86a5" translate="yes" xml:space="preserve">
          <source>The file where the error occurred. Defaults to &lt;code&gt;__FILE__&lt;/code&gt;.</source>
          <target state="translated">发生错误的文件。默认为 &lt;code&gt;__FILE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a7b4c097e4526bdecb31861d25a87231f1a612b" translate="yes" xml:space="preserve">
          <source>The file where the exception occurred.</source>
          <target state="translated">发生异常的文件。</target>
        </trans-unit>
        <trans-unit id="2a8a857ec47a034acf4c2fcaed0de229c31869d5" translate="yes" xml:space="preserve">
          <source>The filename of the &lt;code&gt;File&lt;/code&gt; log messages are written to.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 日志消息的文件名被写入。</target>
        </trans-unit>
        <trans-unit id="37dc45c1af7cba50c135f406c906822e95a5938d" translate="yes" xml:space="preserve">
          <source>The filename of the output file of the &lt;code&gt;FileLogger&lt;/code&gt;. If that file can not be opened for writting an exception will be thrown.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; 的输出文件的文件名。如果无法打开该文件以进行写入，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="3910614447549528bc2d2fc1be565210c1526e11" translate="yes" xml:space="preserve">
          <source>The finish function returns the final hash sum and resets the Digest.</source>
          <target state="translated">完成函数返回最终的哈希和并重置Digest。</target>
        </trans-unit>
        <trans-unit id="133d5dd83ff02e493d05a0e47c1deb319a8252d7" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must be at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes big.</source>
          <target state="translated">finish函数返回哈希值。它需要一个可选的缓冲区将数据复制到其中。如果传递了缓冲区，则它必须至少为&lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;个字节大。</target>
        </trans-unit>
        <trans-unit id="22bbeb22c4ba0a11e694a3fb88ce4ce66c1aa8c4" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must have a length at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes.</source>
          <target state="translated">finish函数返回哈希值。它需要一个可选的缓冲区将数据复制到其中。如果传递了缓冲区，则其长度必须至少为&lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;个字节。</target>
        </trans-unit>
        <trans-unit id="957dc77c438abefa8c77eaf7563108a790ce4d94" translate="yes" xml:space="preserve">
          <source>The first</source>
          <target state="translated">第一个</target>
        </trans-unit>
        <trans-unit id="a33576b80d4f4e8bd604397c308091bd4d49eeac" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Exception&lt;/code&gt; which was bypassed when this Error was thrown, or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;Exception&lt;/code&gt;s were pending.</source>
          <target state="translated">引发此错误时将绕过的第一个 &lt;code&gt;Exception&lt;/code&gt; ;如果没有 &lt;code&gt;Exception&lt;/code&gt; 待处理，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83bd533ac7ce9ad8a841e8cf9ee5bfbb37b7a8f6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;v1&lt;/code&gt; for which &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; is true determines the result. This could lead to unexpected behaviour.</source>
          <target state="translated">第一 &lt;code&gt;v1&lt;/code&gt; 为其中 &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; 为真确定的结果。这可能会导致意外的行为。</target>
        </trans-unit>
        <trans-unit id="ba9501cbc71e13c8461adcfc7cfb46ad49a3228f" translate="yes" xml:space="preserve">
          <source>The first argument for the predicate.</source>
          <target state="translated">谓词的第一个论点。</target>
        </trans-unit>
        <trans-unit id="d76b59c9568cb4d5adeddeb8e61ac34ba34641de" translate="yes" xml:space="preserve">
          <source>The first argument is a class type or an expression of class type. The second argument is a string that matches the name of one of the functions of that class. The result is a tuple of the virtual overloads of that function. It does not include final functions that do not override anything.</source>
          <target state="translated">第一个参数是一个类类型或类类型的表达式。第二个参数是与该类的一个函数名称相匹配的字符串,结果是该函数的虚拟重载的元组。结果是该函数的虚拟重载的元组。它不包括不重载任何内容的最终函数。</target>
        </trans-unit>
        <trans-unit id="dd726d5af5bf0120b5bd49b63370601b230f8cd3" translate="yes" xml:space="preserve">
          <source>The first argument is a type that has members, or is an expression of a type that has members. The second argument is a string. If the string is a valid property of the type, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">第一个参数是具有成员的类型，或者是具有成员的类型的表达式。第二个参数是一个字符串。如果字符串是该类型的有效属性，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a43e4ec8b9b76809401c1e8287827f1c5ded36c" translate="yes" xml:space="preserve">
          <source>The first argument is an aggregate (e.g. struct/class/module). The second argument is a &lt;code&gt;string&lt;/code&gt; that matches the name of the member(s) to return. The third argument is a &lt;code&gt;bool&lt;/code&gt;, and is optional. If &lt;code&gt;true&lt;/code&gt;, the result will also include template overloads. The result is a tuple of all the overloads of the supplied name.</source>
          <target state="translated">第一个参数是一个聚合（例如struct / class / module）。第二个参数是与要返回的成员名称匹配的 &lt;code&gt;string&lt;/code&gt; 。第三个参数是 &lt;code&gt;bool&lt;/code&gt; ，并且是可选的。如果为 &lt;code&gt;true&lt;/code&gt; ，则结果还将包括模板重载。结果是提供的名称的所有重载的元组。</target>
        </trans-unit>
        <trans-unit id="2a174554ed3bb0d11c52209ee3ed7c598d6bcaa6" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;Checked&lt;/code&gt;, e.g. &lt;code&gt;int&lt;/code&gt; if the left-hand side of the operator is &lt;code&gt;Checked!int&lt;/code&gt;</source>
          <target state="translated">的第一个参数 &lt;code&gt;Checked&lt;/code&gt; ，如 &lt;code&gt;int&lt;/code&gt; 如果操作员的左侧是 &lt;code&gt;Checked!int&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8841f05f16f8289043fb3adb8a0d9f6c62e9f3bb" translate="yes" xml:space="preserve">
          <source>The first argument that passes the test &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">通过测试 &lt;code&gt;pred&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="6f69babce0033893a00ba9dd4fdded8c5d91d428" translate="yes" xml:space="preserve">
          <source>The first argument to apply to &lt;code&gt;fun&lt;/code&gt;</source>
          <target state="translated">适用于 &lt;code&gt;fun&lt;/code&gt; 的第一个论点</target>
        </trans-unit>
        <trans-unit id="5e0881d9245470375fca9c2a63d7fd75c1ab511d" translate="yes" xml:space="preserve">
          <source>The first array to compare</source>
          <target state="translated">第一个要比较的数组</target>
        </trans-unit>
        <trans-unit id="6402ea9c3911f868771a9ad2ee306a3ff47b76c7" translate="yes" xml:space="preserve">
          <source>The first choice that &lt;code&gt;switchObject&lt;/code&gt; can be casted to the type of argument it accepts will be called with &lt;code&gt;switchObject&lt;/code&gt; casted to that type, and the value it'll return will be returned by &lt;code&gt;castSwitch&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;switchObject&lt;/code&gt; 强制转换为它接受的参数类型的第一个选择将被调用， &lt;code&gt;switchObject&lt;/code&gt; 转换为该类型，并且将返回的值将由 &lt;code&gt;castSwitch&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="8c0a3698b1be7dcab735cd7cac7d279e510c1569" translate="yes" xml:space="preserve">
          <source>The first element of the array is the size of the type (for classes it is the &lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize&lt;/i&gt;&lt;/a&gt;).</source>
          <target state="translated">数组的第一个元素是类型的大小（对于类，它是&lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize&lt;/i&gt;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d156d92ea93ea0bd49c4929ebca8565a10591e92" translate="yes" xml:space="preserve">
          <source>The first element of the array.</source>
          <target state="translated">数组的第一个元素。</target>
        </trans-unit>
        <trans-unit id="d8e16b70885d5121ddc9494a6960e6bb4c96cb43" translate="yes" xml:space="preserve">
          <source>The first expression is converted to &lt;code&gt;bool&lt;/code&gt;, and is evaluated.</source>
          <target state="translated">第一个表达式将转换为 &lt;code&gt;bool&lt;/code&gt; 并被求值。</target>
        </trans-unit>
        <trans-unit id="cf9e5f533fce6e846463f393ddd35d42bb1f1cd6" translate="yes" xml:space="preserve">
          <source>The first field in the input</source>
          <target state="translated">输入的第一个字段</target>
        </trans-unit>
        <trans-unit id="d4d950398e4d3043c7b4cad357808ae2f4342dfd" translate="yes" xml:space="preserve">
          <source>The first form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;scope&lt;/code&gt;, and has &lt;a href=&quot;#return-scope-parameters&quot;&gt;return scope parameter&lt;/a&gt; semantics for the value of the &lt;code&gt;ref&lt;/code&gt; parameter.</source>
          <target state="translated">第一种形式将 &lt;code&gt;return&lt;/code&gt; 附加到 &lt;code&gt;scope&lt;/code&gt; ，并具有 &lt;code&gt;ref&lt;/code&gt; 参数值的&lt;a href=&quot;#return-scope-parameters&quot;&gt;return scope参数&lt;/a&gt;语义。</target>
        </trans-unit>
        <trans-unit id="8b1ce77e77b315411f0f72483fe564f04bb631f4" translate="yes" xml:space="preserve">
          <source>The first function</source>
          <target state="translated">第一个功能</target>
        </trans-unit>
        <trans-unit id="f3024cc5ecfa3c08bdbe44b263a51764ec97fd6f" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the &lt;code&gt;Interface&lt;/code&gt;, but the first virtual function pointer.</source>
          <target state="translated">&lt;code&gt;vtbl[]&lt;/code&gt; 的第一个成员不是指向 &lt;code&gt;Interface&lt;/code&gt; 的指针，而是第一个虚函数指针。</target>
        </trans-unit>
        <trans-unit id="847d6d02e0c1f522b786c8972c9a6146a642fa90" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the InterfaceInfo, but the first virtual function pointer.</source>
          <target state="translated">&lt;code&gt;vtbl[]&lt;/code&gt; 的第一个成员不是指向InterfaceInfo的指针，而是第一个虚函数指针。</target>
        </trans-unit>
        <trans-unit id="c2d2ce897245ef2180a0c50b1783471cf2be4244" translate="yes" xml:space="preserve">
          <source>The first overload exists only if &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt;. So if &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; or called for a constant or immutable object, then &lt;code&gt;refCountedPayload&lt;/code&gt; will also be qualified as safe and nothrow (but will still assert if not initialized).</source>
          <target state="translated">仅当 &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt; 时，才存在第一个重载。因此，如果 &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; 或为常量或不可变对象调用，则 &lt;code&gt;refCountedPayload&lt;/code&gt; 也将被视为安全且不抛出异常（但如果未初始化，则仍会断言）。</target>
        </trans-unit>
        <trans-unit id="dfd8266058456fb8b44a614fe1b78098bba5c6d8" translate="yes" xml:space="preserve">
          <source>The first overload of &lt;code&gt;makeIndex&lt;/code&gt; writes to a range containing pointers, and the second writes to a range containing offsets. The first overload requires &lt;code&gt;Range&lt;/code&gt; to be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, and the latter requires it to be a random-access range.</source>
          <target state="translated">&lt;code&gt;makeIndex&lt;/code&gt; 的第一个重载写入包含指针的范围，第二个重载包含偏移量的范围。第一个重载要求 &lt;code&gt;Range&lt;/code&gt; 为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围&lt;/a&gt;，而第二个过载则要求其为随机访问范围。</target>
        </trans-unit>
        <trans-unit id="2797f8bab40930285c67d69e0f78f4ff6b12f672" translate="yes" xml:space="preserve">
          <source>The first overload of this function will return &lt;code&gt;T.init&lt;/code&gt; if the range is empty. However, the second overload will return &lt;code&gt;seed&lt;/code&gt; on empty ranges.</source>
          <target state="translated">如果范围为空，则此函数的第一个重载将返回 &lt;code&gt;T.init&lt;/code&gt; 。但是，第二次过载将在空范围内返回 &lt;code&gt;seed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa15d56dc093902b6572dae74b23ea12e4df8659" translate="yes" xml:space="preserve">
          <source>The first part is done automatically by the language, the second part is done if a postblit function is defined for the struct. The postblit has access only to the destination struct object, not the source. Its job is to &amp;lsquo;fix up&amp;rsquo; the destination as necessary, such as making copies of referenced data, incrementing reference counts, etc. For example:</source>
          <target state="translated">第一部分由语言自动完成，第二部分（如果为结构定义了postblit函数）完成。postblit只能访问目标struct对象，而不能访问源。它的工作是根据需要&amp;ldquo;固定&amp;rdquo;目标，例如制作参考数据的副本，增加参考计数等。例如：</target>
        </trans-unit>
        <trans-unit id="b6a25e3471beef6bed20eb948a4b0de3cefb170f" translate="yes" xml:space="preserve">
          <source>The first part of the desired time zones.</source>
          <target state="translated">所需时区的第一部分。</target>
        </trans-unit>
        <trans-unit id="f479a5f1dc2ec5b3e8f93d2c246a61132b592fa7" translate="yes" xml:space="preserve">
          <source>The first range</source>
          <target state="translated">第一个范围</target>
        </trans-unit>
        <trans-unit id="978014a33cbc746b950a93b0f0736f4203ea8def" translate="yes" xml:space="preserve">
          <source>The first range to be compared.</source>
          <target state="translated">第一个要比较的范围。</target>
        </trans-unit>
        <trans-unit id="ca9cc691843153958d1dfce3f9f135428053bc03" translate="yes" xml:space="preserve">
          <source>The first range.</source>
          <target state="translated">第一个范围。</target>
        </trans-unit>
        <trans-unit id="376b0679101f4b59ef8dcfe360d9831914d2f062" translate="yes" xml:space="preserve">
          <source>The first section is the</source>
          <target state="translated">第一节是</target>
        </trans-unit>
        <trans-unit id="0a2ac8281c00878fb6aeb93d4c1aa8543d1c7cdd" translate="yes" xml:space="preserve">
          <source>The first template argument is the size of the region and the second is the needed alignment. Depending on the alignment requested and platform details, the actual available storage may be smaller than the compile-time parameter. To make sure that at least &lt;code&gt;n&lt;/code&gt; bytes are available in the region, use &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt;.</source>
          <target state="translated">第一个模板参数是区域的大小，第二个是所需的对齐方式。根据请求的对齐方式和平台详细信息，实际可用存储空间可能小于编译时参数。要确保该区域中至少有 &lt;code&gt;n&lt;/code&gt; 个字节可用，请使用 &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f09dcfe52dd359d217c384efcd5e2b579c11d4d5" translate="yes" xml:space="preserve">
          <source>The first thing a catch handler does is call this.</source>
          <target state="translated">捕捉处理程序首先要做的就是调用这个。</target>
        </trans-unit>
        <trans-unit id="06bc16353a0bd43b921f8f9a4d6fe2a9b273859a" translate="yes" xml:space="preserve">
          <source>The first time point in the range.</source>
          <target state="translated">范围内的第一个时间点。</target>
        </trans-unit>
        <trans-unit id="ee856ba33815edde83d3ab4573c1bb58ec0e2ba8" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if &lt;code&gt;alloc&lt;/code&gt;'s primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">前两个重载仅在 &lt;code&gt;alloc&lt;/code&gt; 的原语起作用时抛出。如果复制操作抛出异常，则涉及复制初始化的重载将释放内存并传播异常。</target>
        </trans-unit>
        <trans-unit id="333231d0183ec9a4310007ffcf10aa12ccaa5deb" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if the used allocator's primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">前两个重载只有在使用的分配器的基元抛出时才会抛出。涉及复制初始化的重载会在复制操作抛出时重新分配内存并传播异常。</target>
        </trans-unit>
        <trans-unit id="8adbee74bf4af885c51ba2cdd7ef319e8a5ccd70" translate="yes" xml:space="preserve">
          <source>The first type to receive the type name for</source>
          <target state="translated">第一个接收类型名称为</target>
        </trans-unit>
        <trans-unit id="24a327b5e33473298dc52e8aa179b1270880d206" translate="yes" xml:space="preserve">
          <source>The first version counts the number of elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;pred&lt;/code&gt; defaults to equality. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">第一版本计数的元素数 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;r&lt;/code&gt; 为其 &lt;code&gt;pred(x, value)&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;pred&lt;/code&gt; 默认为相等。执行 &lt;code&gt;pred&lt;/code&gt; 的 &amp;Omicron;（ &lt;code&gt;haystack.length&lt;/code&gt; ）个评估。</target>
        </trans-unit>
        <trans-unit id="c9816b3b28ee2e6c5406da992bb1cbb42be32059" translate="yes" xml:space="preserve">
          <source>The first way is to use a literal that is already immutable, such as string literals. String literals are always immutable.</source>
          <target state="translated">第一种方法是使用已经是不可变的文字,比如字符串字元。字符串字元总是不可变的。</target>
        </trans-unit>
        <trans-unit id="b05e9e189cc2bf7e6e8a6f344ff95d0591fc3a0f" translate="yes" xml:space="preserve">
          <source>The first will queue writers until no readers hold the mutex, then pass the writers through one at a time. If a reader acquires the mutex while there are still writers queued, the reader will take precedence.</source>
          <target state="translated">首先将作家排队,直到没有读者持有mutex,然后一次通过一个作家。如果有读者获得了mutex,而仍有写手在排队,则该读者将获得优先权。</target>
        </trans-unit>
        <trans-unit id="1b1951cc36673198c26cd910de69ac59cf5f6d05" translate="yes" xml:space="preserve">
          <source>The focus of this module is the core needs of developing Unicode-aware applications. To that effect it provides the following optimized primitives:</source>
          <target state="translated">该模块的重点是开发 Unicode-aware 应用程序的核心需求。为此,它提供了以下优化的基元。</target>
        </trans-unit>
        <trans-unit id="6fa1fe0d7308c90108a99d43bd343885cf39b2f7" translate="yes" xml:space="preserve">
          <source>The following IEEE 'real' formats are currently supported:</source>
          <target state="translated">目前支持以下IEEE &quot;真实 &quot;格式。</target>
        </trans-unit>
        <trans-unit id="fd79ad5ff3bdc8ea5cc9c7e973de1494e808a075" translate="yes" xml:space="preserve">
          <source>The following algorithm is used:</source>
          <target state="translated">采用以下算法。</target>
        </trans-unit>
        <trans-unit id="3781d7d912eacb6b194d6abe4908fafb2e1b7d5d" translate="yes" xml:space="preserve">
          <source>The following algorithms are currently implemented:</source>
          <target state="translated">目前实施的算法如下:</target>
        </trans-unit>
        <trans-unit id="d55ceaf72919876c8f40561d12b134a3ea66a2f7" translate="yes" xml:space="preserve">
          <source>The following alias declarations are valid:</source>
          <target state="translated">下列别名声明有效:</target>
        </trans-unit>
        <trans-unit id="3cfdc04ab915c01ce32c8d0e68bf6bc781aec0c7" translate="yes" xml:space="preserve">
          <source>The following are all embedded documentation comments:</source>
          <target state="translated">以下是所有嵌入的文档注释。</target>
        </trans-unit>
        <trans-unit id="98d73aa2fbdeacfd5d17519697402797329a5e39" translate="yes" xml:space="preserve">
          <source>The following are rules of input ranges are assumed to hold true in all Phobos code. These rules are not checkable at compile-time, so not conforming to these rules when writing ranges or range based code will result in undefined behavior.</source>
          <target state="translated">以下是输入范围的规则,假设在所有 Phobos 代码中都是正确的,这些规则在编译时不可检查,所以在编写范围或基于范围的代码时,不符合这些规则会导致未定义的行为。这些规则在编译时是不可检查的,所以在编写范围或基于范围的代码时,如果不符合这些规则,将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="eabfe29dc68817824868f2b1cc59ea44b7368f75" translate="yes" xml:space="preserve">
          <source>The following are what the Unicode standard considers as line terminators:</source>
          <target state="translated">以下是Unicode标准认为的行终止符。</target>
        </trans-unit>
        <trans-unit id="21052e7f487ea1e8da6a5dfd837062e0257bbb6f" translate="yes" xml:space="preserve">
          <source>The following binary operators are overloadable:</source>
          <target state="translated">以下二进制运算符是可以过载的。</target>
        </trans-unit>
        <trans-unit id="85cad5d1bff24fce98bfd578ab9c72fa9869b15d" translate="yes" xml:space="preserve">
          <source>The following code compares the use of &lt;code&gt;formatValue&lt;/code&gt; and &lt;code&gt;formattedWrite&lt;/code&gt;.</source>
          <target state="translated">以下代码比较了 &lt;code&gt;formatValue&lt;/code&gt; 和 &lt;code&gt;formattedWrite&lt;/code&gt; 的用法。</target>
        </trans-unit>
        <trans-unit id="36006625c3fb62c010db1770cfe9a955d1abc844" translate="yes" xml:space="preserve">
          <source>The following code does a full unzip</source>
          <target state="translated">下面的代码可以完全解压</target>
        </trans-unit>
        <trans-unit id="707a5e8dae71e24794f64d11490781d72f147427" translate="yes" xml:space="preserve">
          <source>The following code should compile for any forward range.</source>
          <target state="translated">下面的代码应该可以编译任何前向范围。</target>
        </trans-unit>
        <trans-unit id="b75b3b21bc4ed533a6d7d4185c0635676c150be0" translate="yes" xml:space="preserve">
          <source>The following describes the behavior of the qualified postblit definitions:</source>
          <target state="translated">下面描述了合格的blit后定义的行为。</target>
        </trans-unit>
        <trans-unit id="cc1ef4d0137291a52b36237f0a56da4b9479ab3e" translate="yes" xml:space="preserve">
          <source>The following describes the specific implementation of the vector types for the X86 and X86_64 architectures.</source>
          <target state="translated">下面介绍X86和X86_64架构的向量类型的具体实现。</target>
        </trans-unit>
        <trans-unit id="f4a4096a1a2c3a608e01b521d07c483d3463c6b6" translate="yes" xml:space="preserve">
          <source>The following elements describe the locations of GC managed pointers within the memory occupied by an instance of the type. For type T, there are &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; possible pointers represented by the bits of the array values.</source>
          <target state="translated">以下元素描述了该类型的实例占用的内存中GC管理的指针的位置。对于类型T，存在 &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; 可能的指针，这些指针由数组值的位表示。</target>
        </trans-unit>
        <trans-unit id="64e995a24781ca67ad26542b15d464819ff2f49a" translate="yes" xml:space="preserve">
          <source>The following example shows binding of a pure virtual function, its implementation in a derived class, a non-virtual member function, and a member field:</source>
          <target state="translated">下面的例子显示了一个纯虚拟函数、它在派生类中的实现、一个非虚拟成员函数和一个成员字段的绑定。</target>
        </trans-unit>
        <trans-unit id="7394f4cff4af73de38cdcc123f9d9cc433c49d32" translate="yes" xml:space="preserve">
          <source>The following expression must be true for &lt;code&gt;hasSlicing&lt;/code&gt; to be &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">为了使 &lt;code&gt;hasSlicing&lt;/code&gt; 为true，以下表达式必须为 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9182b2bc4da6786571366018715b092f896d0a9d" translate="yes" xml:space="preserve">
          <source>The following flag from DMD can be used to add a new path in which to search for frameworks:</source>
          <target state="translated">DMD的以下标志可以用来添加一个新的路径来搜索框架。</target>
        </trans-unit>
        <trans-unit id="f255eea7299aed827ce99b1b18680817e56fa6aa" translate="yes" xml:space="preserve">
          <source>The following forms of slice expression can be convertible to a static array type:</source>
          <target state="translated">以下形式的分片表达式可以转换为静态数组类型。</target>
        </trans-unit>
        <trans-unit id="b112356e7e4259c722c195a6e095476ecaa2fdb9" translate="yes" xml:space="preserve">
          <source>The following functions are publicly imported:</source>
          <target state="translated">以下功能是公开导入的。</target>
        </trans-unit>
        <trans-unit id="37498d7cc50ed898202c2748c98849d1a32c6302" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined, but are deprecated:</source>
          <target state="translated">定义了以下标识符,但已被废弃。</target>
        </trans-unit>
        <trans-unit id="4b758467388bb94c690cea1fb26de17875ff1787" translate="yes" xml:space="preserve">
          <source>The following information might be of help with choosing the appropriate block size. Actual allocation occurs in sizes multiple of the block size. Allocating one block is the fastest because only one 0 bit needs to be found in the metadata. Allocating 2 through 64 blocks is the next cheapest because it affects a maximum of two &lt;code&gt;ulong&lt;/code&gt; in the metadata. Allocations greater than 64 blocks require a multiword search through the metadata.</source>
          <target state="translated">以下信息可能有助于选择适当的块大小。实际分配的大小是块大小的倍数。分配一个块最快，因为在元数据中只需找到一个0位。分配2到64个块是下一个最便宜的，因为它影响元数据中最多两个 &lt;code&gt;ulong&lt;/code&gt; 。大于64个块的分配要求通过元数据进行多字搜索。</target>
        </trans-unit>
        <trans-unit id="3576cbb0f30565829c9a8b467650fa45b457f446" translate="yes" xml:space="preserve">
          <source>The following is a list of important Unicode notions and definitions. Any conventions used specifically in this module alone are marked as such. The descriptions are based on the formal definition as found in &lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt; chapter three of The Unicode Standard Core Specification.&lt;/a&gt;</source>
          <target state="translated">以下是重要的Unicode概念和定义的列表。仅在此模块中专门使用的任何约定均已标记为此类。这些描述基于&lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt;Unicode标准核心规范第三章中&lt;/a&gt;的正式定义。</target>
        </trans-unit>
        <trans-unit id="ee35f7e05bf101609042076d8164187dce2ce440" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;Allocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Allocator&lt;/code&gt; 定义了以下方法并将其转发，则定义以下方法： &lt;code&gt;deallocateAll&lt;/code&gt; ， &lt;code&gt;empty&lt;/code&gt; ， &lt;code&gt;owns&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91a10c7b038d71ce23d47d4e91b5d6d57a0c0ec0" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 定义了以下方法并将其转发，则定义以下方法： &lt;code&gt;allocateAll&lt;/code&gt; ， &lt;code&gt;expand&lt;/code&gt; ， &lt;code&gt;owns&lt;/code&gt; ， &lt;code&gt;reallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14685afb8641a641e101312bd747ad3ce716f779" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 定义了以下方法并将其转发，则会定义以下方法： &lt;code&gt;expand&lt;/code&gt; ， &lt;code&gt;owns&lt;/code&gt; ， &lt;code&gt;reallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5e999922ed0b2b38ea541add7eceec13e307896" translate="yes" xml:space="preserve">
          <source>The following methods are forwarded to the parent allocator if present: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;.</source>
          <target state="translated">以下方法（如果存在）将转发给父分配器： &lt;code&gt;allocateAll&lt;/code&gt; ， &lt;code&gt;owns&lt;/code&gt; ， &lt;code&gt;deallocateAll&lt;/code&gt; ， &lt;code&gt;empty&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90832fc606780913417ad9424b5b78d805e2f1c9" translate="yes" xml:space="preserve">
          <source>The following must not compile:</source>
          <target state="translated">下面的内容一定不能编译。</target>
        </trans-unit>
        <trans-unit id="151cf7cc11e7e2474415594512b78561ff78c2e4" translate="yes" xml:space="preserve">
          <source>The following op assignment operators are overloadable:</source>
          <target state="translated">下面的操作赋值运算符是可以重载的。</target>
        </trans-unit>
        <trans-unit id="1686f8bc7687029bb8df07eb18087ba36d800516" translate="yes" xml:space="preserve">
          <source>The following operations are not allowed in safe functions:</source>
          <target state="translated">安全函数中不允许进行以下操作。</target>
        </trans-unit>
        <trans-unit id="74510166d7dbf32dd076c82ed552fa55a6bbe522" translate="yes" xml:space="preserve">
          <source>The following part &lt;code&gt;=&amp;gt;&lt;/code&gt;</source>
          <target state="translated">以下部分 &lt;code&gt;=&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f46ca3cf008a6a798269fad6d3b26dd55f13657" translate="yes" xml:space="preserve">
          <source>The following registers are supported. Register names are always in upper case.</source>
          <target state="translated">支持以下寄存器。寄存器名称总是大写。</target>
        </trans-unit>
        <trans-unit id="747c928a756931b0ee0b7f4bfca0b996d4e0288f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to class construction:</source>
          <target state="translated">以下限制适用于班级建设。</target>
        </trans-unit>
        <trans-unit id="b257030ef10af45e49786ee89d857d61ed4e94b9" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to struct construction:</source>
          <target state="translated">以下限制适用于结构的建造。</target>
        </trans-unit>
        <trans-unit id="2f5e979077d2f3caabdbb4640da99e0c00a00749" translate="yes" xml:space="preserve">
          <source>The following steps happen:</source>
          <target state="translated">发生以下步骤:</target>
        </trans-unit>
        <trans-unit id="b441496fc086e7e8d354986714d6c04ebf32cc29" translate="yes" xml:space="preserve">
          <source>The following table compactly summarises the different process creation functions and how they relate to each other:</source>
          <target state="translated">下表简要总结了不同的流程创建功能及其相互之间的关系。</target>
        </trans-unit>
        <trans-unit id="05b248b2126c26cb91a89762582c19941d257e43" translate="yes" xml:space="preserve">
          <source>The following table is a quick reference guide for which Phobos modules to use for a given category of functionality. Note that some modules may appear in more than one category, as some Phobos modules are quite generic and can be applied in a variety of situations.</source>
          <target state="translated">下表是一个快速参考指南,说明哪些 Phobos 模块可用于特定类别的功能。请注意,有些模块可能出现在多个类别中,因为有些 Phobos 模块非常通用,可以应用于各种情况。</target>
        </trans-unit>
        <trans-unit id="a2cf73cb06dd66656b8e69a1d451407dbc663bbe" translate="yes" xml:space="preserve">
          <source>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to succesfully invoke the postblit:</source>
          <target state="translated">下表列出了与成功调用postblit所需使用的对象类型相关联的postblit的所有分组限定符的可能性。</target>
        </trans-unit>
        <trans-unit id="824da93e42b4013db578b67b46a78528e680f556" translate="yes" xml:space="preserve">
          <source>The following transformations of floating point expressions are not allowed because under IEEE rules they could produce different results.</source>
          <target state="translated">以下浮点表达式的变换是不允许的,因为根据IEEE规则,它们可能产生不同的结果。</target>
        </trans-unit>
        <trans-unit id="a206952bbb005ee76451476eb55d6acde4281a6d" translate="yes" xml:space="preserve">
          <source>The following typedef's are signatures of malloc, free, realloc, strdup and calloc respectively. Function pointers of these types can be passed to the curl_global_init_mem() function to set user defined memory management callback routines.</source>
          <target state="translated">下面的typedef分别是malloc、free、realloc、strdup和calloc的签名,这些类型的函数指针可以传递给curl_global_init_mem()函数,设置用户定义的内存管理回调例程。这些类型的函数指针可以传递给curl_global_init_mem()函数来设置用户定义的内存管理回调例程。</target>
        </trans-unit>
        <trans-unit id="6266d602387c0c2612f1f18ac8c95fc02fe3bb5d" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is applied the expanded &lt;code&gt;Tuple&lt;/code&gt;, so it may contain as many formats as the &lt;code&gt;Tuple&lt;/code&gt; has fields.</source>
          <target state="translated">格式 &lt;code&gt;inner&lt;/code&gt; 应用于扩展的 &lt;code&gt;Tuple&lt;/code&gt; ，因此它可能包含与 &lt;code&gt;Tuple&lt;/code&gt; 具有的字段一样多的格式。</target>
        </trans-unit>
        <trans-unit id="d91cc2eaba6a476564c6ddbd8124208fde7d92fe" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is one format, that is applied on all fields of the &lt;code&gt;Tuple&lt;/code&gt;. The inner format must be compatible to all of them.</source>
          <target state="translated">&lt;code&gt;inner&lt;/code&gt; 格式是一种格式，适用于 &lt;code&gt;Tuple&lt;/code&gt; 的所有字段。内部格式必须与所有这些格式兼容。</target>
        </trans-unit>
        <trans-unit id="b804a9979bb24328a2b2b5b25616b3fc268adff1" translate="yes" xml:space="preserve">
          <source>The format of the data to read.</source>
          <target state="translated">读取数据的格式。</target>
        </trans-unit>
        <trans-unit id="0a7a62414c21f47b50a1e92c766dda1b08a5910c" translate="yes" xml:space="preserve">
          <source>The format of the date should follow this template:</source>
          <target state="translated">日期的格式应遵循此模板。</target>
        </trans-unit>
        <trans-unit id="659e106c79a7ed685e316895f1b36b5ece514b7f" translate="yes" xml:space="preserve">
          <source>The format of the instructions is, of course, highly dependent on the native instruction set of the target CPU, and so is &lt;a href=&quot;iasm&quot;&gt;implementation defined&lt;/a&gt;. But, the format will follow the following conventions:</source>
          <target state="translated">指令的格式当然高度依赖于目标CPU的本机指令集，因此&lt;a href=&quot;iasm&quot;&gt;实现也是定义的&lt;/a&gt;。但是，格式将遵循以下约定：</target>
        </trans-unit>
        <trans-unit id="d00ef203b4bd1ca0d23b1201e668116dd138801d" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">故意不指定字符串的格式，关心字符串格式的代码应使用 &lt;code&gt;toISOString&lt;/code&gt; ， &lt;code&gt;toISOExtString&lt;/code&gt; ， &lt;code&gt;toSimpleString&lt;/code&gt; 或其他一些显式生成代码所需格式的自定义格式函数。原因是代码可以清楚地知道其使用的格式，从而使维护代码和与使用生成的字符串的其他软件进行交互的错误率降低。出于同样的原因，&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;没有 &lt;code&gt;fromString&lt;/code&gt; 函数，但确实具有 &lt;code&gt;fromISOString&lt;/code&gt; ， &lt;code&gt;fromISOExtString&lt;/code&gt; 和 &lt;code&gt;fromSimpleString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e82eb1994e0d2ee7e98c5b8f8c20cfd78e8b067" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">故意不指定字符串的格式，关心字符串格式的代码应使用 &lt;code&gt;toISOString&lt;/code&gt; ， &lt;code&gt;toISOExtString&lt;/code&gt; ， &lt;code&gt;toSimpleString&lt;/code&gt; 或其他一些显式生成代码所需格式的自定义格式函数。原因是代码可以清楚地知道其使用的格式，从而使维护代码和与使用生成的字符串的其他软件进行交互的错误率降低。出于同样的原因，&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;没有 &lt;code&gt;fromString&lt;/code&gt; 函数，但确实具有 &lt;code&gt;fromISOString&lt;/code&gt; ， &lt;code&gt;fromISOExtString&lt;/code&gt; 和 &lt;code&gt;fromSimpleString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96cf4abaa3ec73526e49a27860bcadf20906a190" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">故意不指定字符串的格式，关心字符串格式的代码应使用 &lt;code&gt;toISOString&lt;/code&gt; ， &lt;code&gt;toISOExtString&lt;/code&gt; ， &lt;code&gt;toSimpleString&lt;/code&gt; 或其他一些显式生成代码所需格式的自定义格式函数。原因是代码可以清楚地知道其使用的格式，从而使维护代码和与使用生成的字符串的其他软件进行交互的错误率降低。出于同样的原因，&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;没有 &lt;code&gt;fromString&lt;/code&gt; 函数，但确实具有 &lt;code&gt;fromISOString&lt;/code&gt; ， &lt;code&gt;fromISOExtString&lt;/code&gt; 和 &lt;code&gt;fromSimpleString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a7f64095e841cf54dadcac2f9cbc728022a8d4" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt; and &lt;code&gt;fromISOExtString&lt;/code&gt;.</source>
          <target state="translated">故意未指定字符串的格式，关心字符串格式的代码应使用 &lt;code&gt;toISOString&lt;/code&gt; ， &lt;code&gt;toISOExtString&lt;/code&gt; 或其他一些显式生成代码所需格式的自定义格式函数。原因是代码可以清楚地知道其使用的格式，从而使维护代码和与使用生成的字符串的其他软件进行交互的错误率降低。出于同样的原因，&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;没有 &lt;code&gt;fromString&lt;/code&gt; 函数，而确实具有 &lt;code&gt;fromISOString&lt;/code&gt; 和 &lt;code&gt;fromISOExtString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffca9618faa656329893915994f22e9af2d88357" translate="yes" xml:space="preserve">
          <source>The format returned by toString may or may not change in the future.</source>
          <target state="translated">toString返回的格式将来可能会或不会改变。</target>
        </trans-unit>
        <trans-unit id="03b68c7b67ac69b6f5b3f857c44f365ee971e450" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;' '&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含一个 &lt;code&gt;' '&lt;/code&gt; （与 &lt;code&gt;printf&lt;/code&gt; 兼容）。</target>
        </trans-unit>
        <trans-unit id="f06eba7969af19af6a609393b286c72694c125a1" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'#'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含 &lt;code&gt;'#'&lt;/code&gt; （ &lt;code&gt;printf&lt;/code&gt; 兼容性）。</target>
        </trans-unit>
        <trans-unit id="2b3efef6165630dae7b0c5941cb57f0ff6fb2723" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含 &lt;code&gt;'+'&lt;/code&gt; （ &lt;code&gt;printf&lt;/code&gt; 兼容性）。</target>
        </trans-unit>
        <trans-unit id="6460ee5bc9ce27cd4f9cfd713bf8f2494817b14f" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;','&lt;/code&gt;</source>
          <target state="translated">格式说明符包含 &lt;code&gt;','&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="962882364923635b105d5f54d8d7565b59680ac3" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含 &lt;code&gt;'-'&lt;/code&gt; （ &lt;code&gt;printf&lt;/code&gt; 兼容性）。</target>
        </trans-unit>
        <trans-unit id="d34bdd42fd319223df703e24b238ea323c66c17e" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">格式说明符包含 &lt;code&gt;'0'&lt;/code&gt; （与 &lt;code&gt;printf&lt;/code&gt; 兼容）。</target>
        </trans-unit>
        <trans-unit id="4e47d83ed9645d662de3546c090652b44c5fa2bb" translate="yes" xml:space="preserve">
          <source>The format string can be checked at compile-time (see &lt;a href=&quot;#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; for details):</source>
          <target state="translated">可以在编译时检查格式字符串（有关详细信息，请参见&lt;a href=&quot;#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="bd749ebde47823b6d49d60691dec84566b639bf8" translate="yes" xml:space="preserve">
          <source>The format string can reference parts of match using the following notation.</source>
          <target state="translated">格式字符串可以使用以下符号引用匹配的部分。</target>
        </trans-unit>
        <trans-unit id="2d3aec5d983c44f1af503ee811b2266d3dca8cd3" translate="yes" xml:space="preserve">
          <source>The format string has the following grammar:</source>
          <target state="translated">格式字符串的语法如下:</target>
        </trans-unit>
        <trans-unit id="0625c7ec1018d088678495be9b57d04b31498a03" translate="yes" xml:space="preserve">
          <source>The format string supports the formatting of array and nested array elements via the grouping format specifiers &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt;. Each matching pair of &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt; corresponds with a single array argument. The enclosed sub-format string is applied to individual array elements. The trailing portion of the sub-format string following the conversion specifier for the array element is interpreted as the array delimiter, and is therefore omitted following the last array element. The &lt;b&gt;%|&lt;/b&gt; specifier may be used to explicitly indicate the start of the delimiter, so that the preceding portion of the string will be included following the last array element. (See below for explicit examples.)</source>
          <target state="translated">格式字符串通过分组格式说明符&lt;b&gt;％（&lt;/b&gt;和&lt;b&gt;％）&lt;/b&gt;支持数组和嵌套数组元素的格式。&lt;b&gt;％（&lt;/b&gt;和&lt;b&gt;％）的&lt;/b&gt;每个匹配对都对应一个数组参数。附带的子格式字符串应用于单个数组元素。数组元素的转换说明符之后的子格式字符串的结尾部分被解释为数组定界符，因此在最后一个数组元素之后被省略。在&lt;b&gt;％|&lt;/b&gt;说明符可用于显式指示定界符的开始，以便字符串的前面部分将包含在最后一个数组元素之后。 （请参阅下面的显式示例。）</target>
        </trans-unit>
        <trans-unit id="693a71e5dd0ab926d97018418f98a27b3e174029" translate="yes" xml:space="preserve">
          <source>The format string used for this log call.</source>
          <target state="translated">本次日志调用使用的格式字符串。</target>
        </trans-unit>
        <trans-unit id="9fa2fc4abd1b83aca1055ee06f982cdb131c59e5" translate="yes" xml:space="preserve">
          <source>The formatting flag is applied individually to each value, for example:</source>
          <target state="translated">格式化标志被单独应用于每个值,例如。</target>
        </trans-unit>
        <trans-unit id="d26ac44ffe5a86909c11c81e0ef71d3888da5c4c" translate="yes" xml:space="preserve">
          <source>The forms of the</source>
          <target state="translated">的形式</target>
        </trans-unit>
        <trans-unit id="38e88fa7315be494a88a395eb056b9ace726e37c" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. Returns null if there is no Soundex representation for the string.</source>
          <target state="translated">包含Soundex结果的四个字符数组。如果字符串没有Soundex表示,则返回空值。</target>
        </trans-unit>
        <trans-unit id="0480c3df77ed33fc07e614d2d8de8fc045910624" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. The array has zero's in it if there is no Soundex representation for the string.</source>
          <target state="translated">包含Soundex结果的四个字符数组。如果字符串没有Soundex表示,则数组中为零。</target>
        </trans-unit>
        <trans-unit id="5766013bffb3825b0abbe1d083667aa11616b979" translate="yes" xml:space="preserve">
          <source>The fourth form, &lt;code&gt;goto case&lt;/code&gt;&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;, transfers to the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; with a matching &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">第四种形式， &lt;code&gt;goto case&lt;/code&gt; &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; &lt;code&gt;;&lt;/code&gt; ，转移到&lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;最内包围的&lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;具有匹配&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;的表达&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13efbc5e672643becc355867b63d8f22b9e474d7" translate="yes" xml:space="preserve">
          <source>The fourth version counts the number of elements in a range. It is an optimization for the third version: if the given range has the &lt;code&gt;length&lt;/code&gt; property the count is returned right away, otherwise performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) to walk the range.</source>
          <target state="translated">第四个版本计算范围内的元素数。这是对第三个版本的优化：如果给定范围具有 &lt;code&gt;length&lt;/code&gt; 属性，则立即返回计数，否则执行&amp;Omicron;（ &lt;code&gt;haystack.length&lt;/code&gt; ）遍历该范围。</target>
        </trans-unit>
        <trans-unit id="48edc0798b06f223cb1ddbda6fdb31f83f4e14ab" translate="yes" xml:space="preserve">
          <source>The fractional part of x.</source>
          <target state="translated">x的小数部分。</target>
        </trans-unit>
        <trans-unit id="afaeb9378608c5260a3259e8f02e82dbd938d6f1" translate="yes" xml:space="preserve">
          <source>The fractional seconds portion of the time.</source>
          <target state="translated">小数秒部分的时间。</target>
        </trans-unit>
        <trans-unit id="a033f1a65da2c07804aca3b53ca406684bb91d81" translate="yes" xml:space="preserve">
          <source>The free list is circular, with the last node pointing back to the first.</source>
          <target state="translated">自由列表是循环的,最后一个节点指向第一个节点。</target>
        </trans-unit>
        <trans-unit id="c4517bc5d244bf2185e9745bb334e09ef6af1ee0" translate="yes" xml:space="preserve">
          <source>The free tree has special handling of duplicates (a singly-linked list per node) in anticipation of large number of duplicates. Allocation time from the free tree is expected to be &amp;Omicron;(&lt;code&gt;log n&lt;/code&gt;) where &lt;code&gt;n&lt;/code&gt; is the number of distinct sizes (not total nodes) kept in the free tree.</source>
          <target state="translated">自由树对重复项有特殊处理（每个节点一个单链接的列表），因为预期会有大量重复项。从自由树分配的时间预计为〇（ &lt;code&gt;log n&lt;/code&gt; ），其中 &lt;code&gt;n&lt;/code&gt; 是在自由树中保留的不同大小（不是总节点）的数量。</target>
        </trans-unit>
        <trans-unit id="ee4d09c6e55b89fcf5b3563176298a96aa717ff4" translate="yes" xml:space="preserve">
          <source>The freelist is maintained in increasing address order, which makes coalescing easy.</source>
          <target state="translated">自由列表是按照地址顺序递增的方式来维护的,这使得聚合变得很容易。</target>
        </trans-unit>
        <trans-unit id="8fea8f11f99f1f8b366c244a4de1a614fd67b29c" translate="yes" xml:space="preserve">
          <source>The front element in the container</source>
          <target state="translated">容器中的前置元件</target>
        </trans-unit>
        <trans-unit id="13da137fb2ab48bf4928214ec4fc5ac7d9dd7e0b" translate="yes" xml:space="preserve">
          <source>The full URL to get/put</source>
          <target state="translated">获取/输入的完整URL</target>
        </trans-unit>
        <trans-unit id="bdda625bfb1430028e4b6006d0968612c21121d6" translate="yes" xml:space="preserve">
          <source>The full list of named character entities from the &lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5 Spec&lt;/a&gt; is supported except for the named entities which contain multiple code points. Below is a</source>
          <target state="translated">支持&lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5规范&lt;/a&gt;中命名字符实体的完整列表，但包含多个代码点的命名实体除外。下面是一个</target>
        </trans-unit>
        <trans-unit id="53abcf6f821b2e7ec7e516af58f09e5bd8d1aff5" translate="yes" xml:space="preserve">
          <source>The full module system</source>
          <target state="translated">完整的模块系统</target>
        </trans-unit>
        <trans-unit id="ee63124c4c066661e689e48b06ebee05399673e5" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the symbol.</source>
          <target state="translated">符号的全称。</target>
        </trans-unit>
        <trans-unit id="4d00150ca0468a4f7743a4f3a38c13aec942337c" translate="yes" xml:space="preserve">
          <source>The fully-qualified names of both types if the two type names are not the same, or the unqualified names of both types if the two type names are the same.</source>
          <target state="translated">如果两种类型名称不相同,则为两种类型的全限定名称;如果两种类型名称相同,则为两种类型的非限定名称。</target>
        </trans-unit>
        <trans-unit id="38a1580a58c3012db59e4a8a700c45c0c6b1674d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fd&lt;/code&gt; is added to the nested references of the newly created variable such that a closure is made for the variable when the address of &lt;code&gt;fd&lt;/code&gt; is taken.</source>
          <target state="translated">将函数 &lt;code&gt;fd&lt;/code&gt; 添加到新创建的变量的嵌套引用中，以便在获取 &lt;code&gt;fd&lt;/code&gt; 的地址时对该变量进行封闭。</target>
        </trans-unit>
        <trans-unit id="1bc8d00dffc62265a3b988178c4153a69f61f3ec" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;remove&lt;/code&gt; works on bidirectional ranges that have assignable lvalue elements. The moving strategy is (listed from fastest to slowest):</source>
          <target state="translated">该功能 &lt;code&gt;remove&lt;/code&gt; 对具有可分配左值元素的双向范围有效。移动策略（从最快到最慢列出）：</target>
        </trans-unit>
        <trans-unit id="dfdecb6a33548c2c3a57ed9788619ffcbcd64fcd" translate="yes" xml:space="preserve">
          <source>The function allocates memory if and only if it gets to the third stage of this algorithm.</source>
          <target state="translated">如果且仅当该函数到了该算法的第三阶段时,该函数才会分配内存。</target>
        </trans-unit>
        <trans-unit id="59d7ef7bccfe8628462077a719a53074c919f8fa" translate="yes" xml:space="preserve">
          <source>The function call operator, &lt;code&gt;()&lt;/code&gt;, can be overloaded by declaring a function named &lt;code&gt;opCall&lt;/code&gt;:</source>
          <target state="translated">可以通过声明一个名为 &lt;code&gt;opCall&lt;/code&gt; 的函数来重载函数调用运算符 &lt;code&gt;()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="75414fa30a8eeadba0f9df43d9a81faffe1eb302" translate="yes" xml:space="preserve">
          <source>The function declaration makes it clear what the inputs and outputs to the function are.</source>
          <target state="translated">函数声明要明确函数的输入和输出是什么。</target>
        </trans-unit>
        <trans-unit id="36bd72a87a6fb51210593d16c9d3850d26ad2813" translate="yes" xml:space="preserve">
          <source>The function generated tests if the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; passed belongs to this set or not. The result is to be used with string mixin. The intended usage area is aggressive optimization via meta programming in parser generators and the like.</source>
          <target state="translated">该函数生成的&lt;a href=&quot;#Code%20point&quot;&gt;代码&lt;/a&gt;将测试传递的代码点是否属于此集合。结果将与字符串mixin一起使用。预期的使用区域是通过解析器生成器等中的元编程进行的积极优化。</target>
        </trans-unit>
        <trans-unit id="98e31cd639a66b786829a51b07b196c9eb02f441" translate="yes" xml:space="preserve">
          <source>The function is doing something impure, so mark it as impure. If there's a purity error, return true.</source>
          <target state="translated">该函数正在做一些不纯洁的事情,所以将其标记为不纯洁。如果有纯度错误,返回true。</target>
        </trans-unit>
        <trans-unit id="78716a8e02a777fde55cd9f5bd9506b86f2cd433" translate="yes" xml:space="preserve">
          <source>The function is doing something that may allocate with the GC, so mark it as not nogc (not no-how).</source>
          <target state="translated">该函数正在做一些可能与GC分配的事情,所以标记为not nogc(不是no-how)。</target>
        </trans-unit>
        <trans-unit id="1582435911618910fd1cebd4a56e5bade73d2f42" translate="yes" xml:space="preserve">
          <source>The function is doing something unsafe, so mark it as unsafe. If there's a safe error, return true.</source>
          <target state="translated">该函数正在做一些不安全的事情,所以将其标记为不安全。如果出现安全错误,返回true。</target>
        </trans-unit>
        <trans-unit id="185793595bc4f7b5898c63f905d91abe291e2c5e" translate="yes" xml:space="preserve">
          <source>The function is explicitly annotated &lt;code&gt;@nogc&lt;/code&gt; because inference could fail, see &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;issue 17084&lt;/a&gt;.</source>
          <target state="translated">该函数已显式注释 &lt;code&gt;@nogc&lt;/code&gt; ,因为推断可能会失败，请参见&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;问题17084&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94377b90d447230e8a5ccf1a52d33d616f20136c" translate="yes" xml:space="preserve">
          <source>The function is intended to replace the hexadecimal literal strings starting with &lt;code&gt;'x'&lt;/code&gt;, which could be removed to simplify the core language.</source>
          <target state="translated">该函数旨在替换以 &lt;code&gt;'x'&lt;/code&gt; 开头的十六进制文字字符串，可以将其删除以简化核心语言。</target>
        </trans-unit>
        <trans-unit id="408608d2bfc199a6a551d83606a62872252fdf6d" translate="yes" xml:space="preserve">
          <source>The function overloads returning a string allocate their return values using the GC. The versions returning static arrays use pass-by-value for the return value, effectively avoiding dynamic allocation.</source>
          <target state="translated">返回字符串的函数重载使用GC分配其返回值。返回静态数组的版本对返回值使用逐值传递,有效地避免了动态分配。</target>
        </trans-unit>
        <trans-unit id="7b0e25cbd51eccc8cf3fde77bb9a906902973f49" translate="yes" xml:space="preserve">
          <source>The function parameter attributes &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;scope&lt;/code&gt; are used to track what happens to low-level pointers passed to functions. Such pointers include: raw pointers, arrays, &lt;code&gt;this&lt;/code&gt;, classes, &lt;code&gt;ref&lt;/code&gt; parameters, delegate/lazy parameters, and aggregates containing a pointer.</source>
          <target state="translated">函数参数属性 &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;scope&lt;/code&gt; 用于跟踪传递给函数的低级指针发生了什么。此类指针包括：原始指针，数组， &lt;code&gt;this&lt;/code&gt; ，类， &lt;code&gt;ref&lt;/code&gt; 参数，委托/惰性参数以及包含指针的聚合。</target>
        </trans-unit>
        <trans-unit id="6e994bfc1a839ed290d4129f0f5733e981d5373e" translate="yes" xml:space="preserve">
          <source>The function returns a range containing the consecutive reduced values. If there is more than one &lt;code&gt;fun&lt;/code&gt;, the element type will be &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt; std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; containing one element for each &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">该函数返回一个包含连续减少值的范围。如果有多个 &lt;code&gt;fun&lt;/code&gt; ，则元素类型将为&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt; std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;，每个 &lt;code&gt;fun&lt;/code&gt; 包含一个元素。</target>
        </trans-unit>
        <trans-unit id="f1de9581bb40aa0605e1d4f2b900b32c62cf6dcb" translate="yes" xml:space="preserve">
          <source>The function returns immediately, leaving the child process to execute in parallel with its parent. It is recommended to always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; unless the process was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag, as detailed in the documentation for &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">该函数立即返回，使子进程与其父进程并行执行。建议始终对返回的&lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;，除非已使用 &lt;code&gt;Config.detached&lt;/code&gt; 标志生成了该进程，如 &lt;code&gt;wait&lt;/code&gt; 文档中所述。</target>
        </trans-unit>
        <trans-unit id="d1462ec35dc456ac6ff3045ecdc8148b89412c36" translate="yes" xml:space="preserve">
          <source>The function source code must be available to the compiler. Functions which exist in the source code only as extern declarations cannot be executed in CTFE.</source>
          <target state="translated">函数的源代码必须提供给编译器。在源代码中仅作为外部声明存在的函数不能在CTFE中执行。</target>
        </trans-unit>
        <trans-unit id="c99c9ccaa6aadf1ddb21d118ac9a2b39a2936c1d" translate="yes" xml:space="preserve">
          <source>The function that wants to measure speed.</source>
          <target state="translated">想要测量速度的功能。</target>
        </trans-unit>
        <trans-unit id="411ac38391245e7bd9f2d61489a0679e909d3705" translate="yes" xml:space="preserve">
          <source>The function to become the base of the speed.</source>
          <target state="translated">的功能,成为速的基。</target>
        </trans-unit>
        <trans-unit id="ca30c519a6a156f76c6573e841573612bc2aad51" translate="yes" xml:space="preserve">
          <source>The function to execute.</source>
          <target state="translated">要执行的功能。</target>
        </trans-unit>
        <trans-unit id="38560d673ec14174a5201f65e942b10ff886f6eb" translate="yes" xml:space="preserve">
          <source>The function to execute. This may be the actual function passed by the user to spawn itself, or may be a wrapper function.</source>
          <target state="translated">要执行的功能。这可能是用户传递给自己的实际函数,也可能是一个包装函数。</target>
        </trans-unit>
        <trans-unit id="67a64604c4717ec6e34e3f3a6e53ee63c3039ae1" translate="yes" xml:space="preserve">
          <source>The function used to check if &lt;code&gt;addr&lt;/code&gt; is marked.</source>
          <target state="translated">该功能用于检查是否标记了 &lt;code&gt;addr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4a8105c562ae246a8ce7c12b0a3320ba9511dc7" translate="yes" xml:space="preserve">
          <source>The function used to generate the next time point in the range.</source>
          <target state="translated">用于生成范围内下一个时间点的函数。</target>
        </trans-unit>
        <trans-unit id="dc715bdc2551fef5137debdc9a1fe82c19568021" translate="yes" xml:space="preserve">
          <source>The function used to generate the time points of the range over the interval.</source>
          <target state="translated">用于在区间内生成范围的时间点的函数。</target>
        </trans-unit>
        <trans-unit id="f3d2158936e817ae5d4b5a34d016e49a32ca1146" translate="yes" xml:space="preserve">
          <source>The function will not return if any enclosing finally clause does a return, goto or throw that exits the finally clause.</source>
          <target state="translated">如果任何包围的final子句做了返回、goto或throw等退出final子句的操作,该函数将不会返回。</target>
        </trans-unit>
        <trans-unit id="46f3e02eaaa99bc9ca72c46c606ddf965d307189" translate="yes" xml:space="preserve">
          <source>The functionality closely follows the IEEE754-2008 standard for floating-point arithmetic, including the use of camelCase names rather than C99-style lower case names. All of these functions behave correctly when presented with an infinity or NaN.</source>
          <target state="translated">该功能严格遵循IEEE754-2008浮点运算标准,包括使用camelCase名称而不是C99式的小写名称。当出现无穷大或NaN时,所有这些函数都能正常工作。</target>
        </trans-unit>
        <trans-unit id="a8b49dde8278905e1da61afa2345291851916bc1" translate="yes" xml:space="preserve">
          <source>The functionally is based on &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;. LibCurl is licensed under an MIT/X derivative license.</source>
          <target state="translated">功能上基于&lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;。LibCurl是根据MIT / X衍生许可证许可的。</target>
        </trans-unit>
        <trans-unit id="4e9193abd91f293a360c49af75182f625a029338" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#formatValue&quot;&gt;&lt;code&gt;formatValue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unformatValue&quot;&gt;&lt;code&gt;unformatValue&lt;/code&gt;&lt;/a&gt; are used for the plumbing.</source>
          <target state="translated">函数&lt;a href=&quot;#formatValue&quot;&gt; &lt;code&gt;formatValue&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#unformatValue&quot;&gt; &lt;code&gt;unformatValue&lt;/code&gt; &lt;/a&gt;用于管道。</target>
        </trans-unit>
        <trans-unit id="09d84b61f63134826318f5b038f0d9e7c6a89164" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#multiwayMerge&quot;&gt;&lt;code&gt;multiwayMerge&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiwayUnion&quot;&gt;&lt;code&gt;multiwayUnion&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setDifference&quot;&gt;&lt;code&gt;setDifference&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setIntersection&quot;&gt;&lt;code&gt;setIntersection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setSymmetricDifference&quot;&gt;&lt;code&gt;setSymmetricDifference&lt;/code&gt;&lt;/a&gt; expect a range of sorted ranges as input.</source>
          <target state="translated">函数&lt;a href=&quot;#multiwayMerge&quot;&gt; &lt;code&gt;multiwayMerge&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#multiwayUnion&quot;&gt; &lt;code&gt;multiwayUnion&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setDifference&quot;&gt; &lt;code&gt;setDifference&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setIntersection&quot;&gt; &lt;code&gt;setIntersection&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#setSymmetricDifference&quot;&gt; &lt;code&gt;setSymmetricDifference&lt;/code&gt; &lt;/a&gt;期望输入一定范围的排序范围。</target>
        </trans-unit>
        <trans-unit id="4fde7de03cdc04e15dde2a51577db6987e675d9f" translate="yes" xml:space="preserve">
          <source>The functions can use &lt;code&gt;@trusted&lt;/code&gt; instead of &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">这些函数可以使用 &lt;code&gt;@trusted&lt;/code&gt; 而不是 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30a160975f83d4201f4fd65daf1113007bc807be" translate="yes" xml:space="preserve">
          <source>The gamma and related functions, and the error function are crucial for mathematical statistics. The Bessel and related functions arise in problems involving wave propagation (especially in optics). Other major categories of special functions include the elliptic integrals (related to the arc length of an ellipse), and the hypergeometric functions.</source>
          <target state="translated">伽马函数和相关函数以及误差函数对数理统计至关重要。Bessel函数和相关函数出现在涉及波传播的问题中(特别是在光学领域)。其他主要类别的特殊函数包括椭圆积分(与椭圆的弧长有关)和超几何函数。</target>
        </trans-unit>
        <trans-unit id="447281d1324337b15482dcfc848c6a78d28256cf" translate="yes" xml:space="preserve">
          <source>The gapped similarity at the current match length (initially 1, grows with each call to &lt;code&gt;popFront&lt;/code&gt;).</source>
          <target state="translated">当前匹配长度（最初为1，随着对 &lt;code&gt;popFront&lt;/code&gt; 的每次调用都增加）的相似度。</target>
        </trans-unit>
        <trans-unit id="05176e7bf5bf611688f908ea258370d40d6b3039" translate="yes" xml:space="preserve">
          <source>The garbage collector calls the destructor function when the object is deleted. The syntax is:</source>
          <target state="translated">当对象被删除时,垃圾回收器会调用destructor函数。语法为:</target>
        </trans-unit>
        <trans-unit id="8162594fc1e13b54530b98ac255177e2a9d2ab78" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan non-pointer fields for GC pointers.</source>
          <target state="translated">垃圾回收器不会扫描非指针字段的GC指针。</target>
        </trans-unit>
        <trans-unit id="bace0715c82c9b149257399e18cc90537b20fbf1" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not created by the D Thread interface. Nor does it scan the data segments of other DLLs, etc.</source>
          <target state="translated">垃圾回收器不会扫描非D线程接口创建的线程堆栈。也不扫描其他DLL的数据段等。</target>
        </trans-unit>
        <trans-unit id="679912e5f590d3f8f03034fbcabdaff8e29c8cba" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not registered with the D runtime, nor does it scan the data segments of shared libraries that aren't registered with the D runtime.</source>
          <target state="translated">垃圾回收器不会扫描未在D运行时注册的线程堆栈,也不会扫描未在D运行时注册的共享库的数据段。</target>
        </trans-unit>
        <trans-unit id="248f5f617e65210251e2aceaf897cfac6784a5ad" translate="yes" xml:space="preserve">
          <source>The garbage collector is not guaranteed to run the destructor for all unreferenced objects. Furthermore, the order in which the garbage collector calls destructors for unreferenced objects is not specified. This means that when the garbage collector calls a destructor for an object of a class that has members which are references to garbage collected objects, those references may no longer be valid. This means that destructors cannot reference sub objects. This rule does not apply to auto objects or objects destructed with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, as the destructor is not being run by the garbage collector, meaning all references are valid.</source>
          <target state="translated">不能保证垃圾收集器为所有未引用的对象运行析构函数。此外，未指定垃圾收集器为未引用的对象调用析构函数的顺序。这意味着，当垃圾回收器为某个类的对象调用析构函数时，该类的对象具有对垃圾回收对象的引用，这些引用可能不再有效。这意味着析构函数无法引用子对象。该规则不适用于自动对象或使用&lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; 破坏的&lt;/a&gt;对象，因为析构函数不是由垃圾收集器运行的，这意味着所有引用都是有效的。</target>
        </trans-unit>
        <trans-unit id="7ed0a2988d2028482af5b70f4886f714e874cd68" translate="yes" xml:space="preserve">
          <source>The garbage collector looks for roots in:</source>
          <target state="translated">垃圾收集器寻找根在。</target>
        </trans-unit>
        <trans-unit id="a61608c994e8531817d927f16b69cb4ec2652687" translate="yes" xml:space="preserve">
          <source>The general usage guideline is to keep regex complexity on the side of simplicity, as its capabilities reside in purely character-level manipulation. As such it's ill-suited for tasks involving higher level invariants like matching an integer number &lt;em&gt;bounded&lt;/em&gt; in an [a,b] interval. Checks of this sort of are better addressed by additional post-processing.</source>
          <target state="translated">通用用法指南是将正则表达式的复杂性放在简单性的一边，因为它的功能仅存在于字符级操作中。因此，它不适合涉及更高级别不变性的任务，例如匹配以[a，b]区间为&lt;em&gt;界&lt;/em&gt;的整数。通过额外的后处理可以更好地解决此类检查。</target>
        </trans-unit>
        <trans-unit id="587ae2153e1cd24d01fed6ce88e2ec32ff8c2014" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;opAssign&lt;/code&gt; function has the following signature:</source>
          <target state="translated">生成的 &lt;code&gt;opAssign&lt;/code&gt; 函数具有以下签名：</target>
        </trans-unit>
        <trans-unit id="b65a1da736509a9381ee000758f5d850e508e3e2" translate="yes" xml:space="preserve">
          <source>The generated links to D symbols are relative if they have the same root package as the module being documented. If not, their URLs are preceeded by a &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; macro, where &lt;code&gt;pkg&lt;/code&gt; is the root package of the symbol being linked to. Links to D symbols are generated with a &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; macro after the module name. So the generated URL for &lt;code&gt;[Object]&lt;/code&gt; in the above example is as if you had written:</source>
          <target state="translated">如果所生成的D符号链接与所记录的模块具有相同的根包，则它们是相对的。如果不是，则它们的URL以 &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; 宏开头，其中 &lt;code&gt;pkg&lt;/code&gt; 是链接到的符号的根包。在模块名称后使用 &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; 宏生成D符号的链接。因此，上面示例中为 &lt;code&gt;[Object]&lt;/code&gt; 生成的URL 就像您已经编写了：</target>
        </trans-unit>
        <trans-unit id="adc505580a3e3a25fed9b9c63e6f0745b68f08fa" translate="yes" xml:space="preserve">
          <source>The getopt module implements a &lt;code&gt;getopt&lt;/code&gt; function, which adheres to the POSIX syntax for command line options. GNU extensions are supported in the form of long options introduced by a double dash (&quot;--&quot;). Support for bundling of command line options, as was the case with the more traditional single-letter approach, is provided but not enabled by default.</source>
          <target state="translated">getopt模块实现了 &lt;code&gt;getopt&lt;/code&gt; 函数，该函数遵循POSIX语法的命令行选项。以双破折号（&amp;ldquo;-&amp;rdquo;）引入的长选项形式支持GNU扩展。与更传统的单字母方法一样，提供了对命令行选项捆绑的支持，但默认情况下未启用。</target>
        </trans-unit>
        <trans-unit id="38436bf13581d96cda14b3d712a9839eef76ade6" translate="yes" xml:space="preserve">
          <source>The given HMAC token is compared with the expected token using the &lt;code&gt;==&lt;/code&gt; string comparison, which returns &lt;code&gt;false&lt;/code&gt; as soon as the first wrong element is found. If a wrong element is found, then a rejection is sent back to the sender.</source>
          <target state="translated">使用 &lt;code&gt;==&lt;/code&gt; 字符串比较将给定的HMAC令牌与期望的令牌进行比较，一旦发现第一个错误的元素，它将返回 &lt;code&gt;false&lt;/code&gt; 。如果发现错误的元素，则拒绝被发送回发件人。</target>
        </trans-unit>
        <trans-unit id="262b74b064f7ed4973ae2acf3633f01634ced6b1" translate="yes" xml:space="preserve">
          <source>The given array exposed to a standard D array.</source>
          <target state="translated">给定的数组暴露在一个标准的D数组中。</target>
        </trans-unit>
        <trans-unit id="8bc950de5698dccabc99a10c52424998aec0c7a6" translate="yes" xml:space="preserve">
          <source>The given array of &lt;code&gt;char&lt;/code&gt; or random-access range of &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;ubyte&lt;/code&gt; is expected to be in the format specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; section 3.3 with the grammar rule</source>
          <target state="translated">给定的 &lt;code&gt;char&lt;/code&gt; 数组或 &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;ubyte&lt;/code&gt; 的随机访问范围应采用&lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;第3.3节中指定的格式，并带有语法规则</target>
        </trans-unit>
        <trans-unit id="12501a73a540c686a37f4823a66a820dabde2f39" translate="yes" xml:space="preserve">
          <source>The glob pattern</source>
          <target state="translated">球状图案</target>
        </trans-unit>
        <trans-unit id="496ff2fc921b0a5cf99d9a4227ed4bf96d90c632" translate="yes" xml:space="preserve">
          <source>The grapheme cluster represents a horizontally segmentable unit of text, consisting of some grapheme base (which may consist of a Korean syllable) together with any number of nonspacing marks applied to it.</source>
          <target state="translated">字词群代表一个可水平分割的文本单位,由一些字词基数(可能由一个韩语音节组成)和任何数量的非间隔标记组成。</target>
        </trans-unit>
        <trans-unit id="37af0a5e629675000a6dfa7103d088d3ddd62dac" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the given arguments.</source>
          <target state="translated">给定参数的最大公除数。</target>
        </trans-unit>
        <trans-unit id="8b3e1c284ef7e8df3ea6a61551c667aeed265141" translate="yes" xml:space="preserve">
          <source>The hack for bugzilla 4820 case is still questionable. Perhaps would have to handle a delegate expression with 'null' context properly in front-end.</source>
          <target state="translated">针对bugzilla 4820案例的破解还是值得商榷的。也许要在前端正确处理一个带有'null'上下文的delegate表达式。</target>
        </trans-unit>
        <trans-unit id="38f5b63c8a583d4d295cf756159c50490e54c13e" translate="yes" xml:space="preserve">
          <source>The handle to an array is specified by naming the array, as in p, s or a:</source>
          <target state="translated">数组的句柄是通过命名数组来指定的,比如p、s或a。</target>
        </trans-unit>
        <trans-unit id="06b9457ea3f4fa7b2cb019db8602c7584d3ac0a3" translate="yes" xml:space="preserve">
          <source>The handler to run if the expression throwed.</source>
          <target state="translated">如果表达式被抛出,要运行的处理程序。</target>
        </trans-unit>
        <trans-unit id="bb782c4330787617d4fce577aae35ea8ac20fb68" translate="yes" xml:space="preserve">
          <source>The hash function RIPEMD-160</source>
          <target state="translated">哈希函数RIPEMD-160。</target>
        </trans-unit>
        <trans-unit id="1a548321e03af2d162f5b6fb8172e4e75095c3be" translate="yes" xml:space="preserve">
          <source>The hashBlockSize and digestSize are in bits. However, it's likely easier to simply use the convenience aliases: SHA1, SHA224, SHA256, SHA384, SHA512, SHA512_224 and SHA512_256.</source>
          <target state="translated">hashBlockSize和digestSize的单位是比特。然而,简单地使用方便的别名可能更容易。SHA1,SHA224,SHA256,SHA384,SHA512,SHA512_224 和 SHA512_256.</target>
        </trans-unit>
        <trans-unit id="71c022924374f373de8247c9ee1154db2efdf429" translate="yes" xml:space="preserve">
          <source>The header can also be left empty if the input contains a header row and all columns should be iterated. The header from the input can always be accessed from the &lt;code&gt;header&lt;/code&gt; field.</source>
          <target state="translated">如果输入包含标题行并且所有列都应进行迭代，则标题也可以保留为空。输入的标题始终可以在 &lt;code&gt;header&lt;/code&gt; 字段中访问。</target>
        </trans-unit>
        <trans-unit id="23806478590a3d73211d3f9cfeab9ec2c30f42f5" translate="yes" xml:space="preserve">
          <source>The header of &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; for tutorials on ranges.</source>
          <target state="translated">有关范围教程的&lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;的标头。</target>
        </trans-unit>
        <trans-unit id="a73e614d706951342951d40aeeb01697424cadb7" translate="yes" xml:space="preserve">
          <source>The headers read from a successful response.</source>
          <target state="translated">从成功的响应中读取的标题。</target>
        </trans-unit>
        <trans-unit id="1ba658c4da138d5aa67105b1d7cc27b3cfde13e6" translate="yes" xml:space="preserve">
          <source>The highlighting macros start with &lt;code&gt;DDOC_&lt;/code&gt;. They control the formatting of individual parts of the presentation.</source>
          <target state="translated">突出显示宏以 &lt;code&gt;DDOC_&lt;/code&gt; 开头。它们控制演示文稿各个部分的格式。</target>
        </trans-unit>
        <trans-unit id="7850bd95e95bab4d64e3c6d1c398982e32639f37" translate="yes" xml:space="preserve">
          <source>The hook to wrap</source>
          <target state="translated">缠绕的钩子</target>
        </trans-unit>
        <trans-unit id="8f90c58c05f3db77fe848d30cab0798e3f6b00e3" translate="yes" xml:space="preserve">
          <source>The hook's members are looked up statically in a Design by Introspection manner and are all optional. The table below illustrates the members that a hook type may define and their influence over the behavior of the &lt;code&gt;Checked&lt;/code&gt; type using it. In the table, &lt;code&gt;hook&lt;/code&gt; is an alias for &lt;code&gt;Hook&lt;/code&gt; if the type &lt;code&gt;Hook&lt;/code&gt; does not introduce any state, or an object of type &lt;code&gt;Hook&lt;/code&gt; otherwise.</source>
          <target state="translated">挂钩的成员以&amp;ldquo;通过自省设计&amp;rdquo;的方式静态查找，并且都是可选的。下表说明了挂钩类型可以定义的成员，以及它们对使用它的 &lt;code&gt;Checked&lt;/code&gt; 类型的行为的影响。在表中， &lt;code&gt;hook&lt;/code&gt; 是一个别名 &lt;code&gt;Hook&lt;/code&gt; 如果类型 &lt;code&gt;Hook&lt;/code&gt; 不引入任何状态，或类型的对象 &lt;code&gt;Hook&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="c351eba3d013581a191d3a885a49968be29fd469" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的小时设置为一天中的小时。</target>
        </trans-unit>
        <trans-unit id="66136c779346b036c2def79ac7f0dfb73004b7bb" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">将此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;的小时设置为一天中的小时。</target>
        </trans-unit>
        <trans-unit id="a6a4e60304c50d5e98aa115b78722f98c55537a4" translate="yes" xml:space="preserve">
          <source>The hour portion of the time;</source>
          <target state="translated">小时部分的时间。</target>
        </trans-unit>
        <trans-unit id="ae576aa7ec4954f0a9eb6186b74173801d58e446" translate="yes" xml:space="preserve">
          <source>The hours to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的小时设置为的小时。</target>
        </trans-unit>
        <trans-unit id="dc9947af90e8e00095ff57d0a5f1abb3e951dbc5" translate="yes" xml:space="preserve">
          <source>The idea being these are compatible with C structs.</source>
          <target state="translated">我们的想法是这些都与C结构兼容。</target>
        </trans-unit>
        <trans-unit id="1355f078be2cb8440aa75f9a09689cdae9f0217b" translate="yes" xml:space="preserve">
          <source>The idea of a contract is simple - it's just an expression that must evaluate to true. If it does not, the contract is broken, and by definition, the program has a bug in it. Contracts form part of the specification for a program, moving it from the documentation to the code itself. And as every programmer knows, documentation tends to be incomplete, out of date, wrong, or non-existent. Moving the contracts into the code makes them verifiable against the program.</source>
          <target state="translated">契约的概念很简单--它只是一个必须求值为真的表达式。如果它不为真,那么合同就被破坏了,根据定义,程序中存在一个错误。契约构成了程序规范的一部分,把它从文档转移到代码本身。而每个程序员都知道,文档往往是不完整的、过时的、错误的或不存在的。将合同移到代码中,使得它们可以对照程序进行验证。</target>
        </trans-unit>
        <trans-unit id="f6757769fd791ee402dbfe3e43c1aa10845db21c" translate="yes" xml:space="preserve">
          <source>The identity operator &lt;code&gt;is&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">身份操作 &lt;code&gt;is&lt;/code&gt; 不能超载。</target>
        </trans-unit>
        <trans-unit id="1a6dd428d8629e97cfcace7f86b78f24c85c36c4" translate="yes" xml:space="preserve">
          <source>The imaginary part of the number.</source>
          <target state="translated">数的虚部。</target>
        </trans-unit>
        <trans-unit id="1ac7f7e21c56da918de0900c242a59f862e477cf" translate="yes" xml:space="preserve">
          <source>The immutable applies to the type within the following parentheses. So, while &lt;code&gt;s&lt;/code&gt; can be assigned new values, the contents of &lt;code&gt;s[]&lt;/code&gt; cannot be:</source>
          <target state="translated">不可变适用于以下括号内的类型。因此，虽然可以为 &lt;code&gt;s&lt;/code&gt; 分配新值，但 &lt;code&gt;s[]&lt;/code&gt; 的内容不能为：</target>
        </trans-unit>
        <trans-unit id="b076480db50c8a69f17ceccfb8074a2146342dec" translate="yes" xml:space="preserve">
          <source>The immutable array.</source>
          <target state="translated">不变的数组。</target>
        </trans-unit>
        <trans-unit id="d4da7504d70ac035ecf312cd124c3e9b875475b7" translate="yes" xml:space="preserve">
          <source>The implementation exploits properties of types and operations to minimize additional work.</source>
          <target state="translated">该实现利用类型和操作的属性来减少额外的工作。</target>
        </trans-unit>
        <trans-unit id="94333a362aef71aa736007c1291437cf4a5d5675" translate="yes" xml:space="preserve">
          <source>The implementation guarantees that all threads simultaneously calling initOnce with the same var argument block until var is fully initialized. All side-effects of init are globally visible afterwards.</source>
          <target state="translated">该实现保证了所有线程同时用同一个var参数块调用initOnce,直到var被完全初始化。之后init的所有副作用都是全局可见的。</target>
        </trans-unit>
        <trans-unit id="2e2b0dbd8c35c5a1541392596f49b59f590b7d4b" translate="yes" xml:space="preserve">
          <source>The implementation is available as a public member.</source>
          <target state="translated">实施是作为公共成员提供的。</target>
        </trans-unit>
        <trans-unit id="61a0fdac2dd135b95e81234f7a42c96423c9eb12" translate="yes" xml:space="preserve">
          <source>The implementation is based on the pseudocode in Fig. 4 of the paper &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&quot;Efﬁcient Computation of Gapped Substring Kernels on Large Alphabets&quot;&lt;/a&gt; by Rousu et al., with additional algorithmic and systems-level optimizations.</source>
          <target state="translated">该实现基于Rousu等人在论文&lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&amp;ldquo;大字母上的空子字符串核的有效计算&amp;rdquo;&lt;/a&gt;中图4中的伪代码，并进行了其他算法和系统级优化。</target>
        </trans-unit>
        <trans-unit id="c3c79f00444b1a8f6b8dd0d247228e66376bb4b5" translate="yes" xml:space="preserve">
          <source>The implementation may handle the case of the first</source>
          <target state="translated">本实施例可以对第一种情况进行处理。</target>
        </trans-unit>
        <trans-unit id="3f62d25116bc0232c42a3fb96db6f12be7eef293" translate="yes" xml:space="preserve">
          <source>The implementations of all predefined macros are implementation-defined. The reference implementation's macro definitions can be found &lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">所有预定义宏的实现都是实现定义的。参考实现的宏定义可以在&lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;此处&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="ce44ea558c01cd44607fe7bfdaba1c3db8da7616" translate="yes" xml:space="preserve">
          <source>The implicit conversions of built-in scalar types can be explicitly represented by using function call syntax. For example:</source>
          <target state="translated">内置标量类型的隐式转换可以通过使用函数调用语法来显式表示。例如:</target>
        </trans-unit>
        <trans-unit id="8663ba6f06eeb782a371db21df4acbb1af0c444b" translate="yes" xml:space="preserve">
          <source>The importance of component programming (properties, signals and slots, etc)</source>
          <target state="translated">组件编程的重要性(属性、信号和插槽等)。</target>
        </trans-unit>
        <trans-unit id="c5712d89ed6b6b5326913e6635b003b614c7a5c4" translate="yes" xml:space="preserve">
          <source>The imports are looked up to satisfy any unresolved symbols at that scope. Imported symbols may hide symbols from outer scopes.</source>
          <target state="translated">导入的符号会被查找以满足该作用域的任何未解决的符号。导入的符号可以隐藏外部作用域的符号。</target>
        </trans-unit>
        <trans-unit id="28c93ed79edf143da68c0f3519f73741ba79046d" translate="yes" xml:space="preserve">
          <source>The index of the element that should be in sorted position after the function is done.</source>
          <target state="translated">函数完成后,应该在排序位置的元素的索引。</target>
        </trans-unit>
        <trans-unit id="7b8cbc4deacf04830f34d38905f8ffd00330c728" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the maximum in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 最大值的第一次遇到的索引。如果 &lt;code&gt;range&lt;/code&gt; 为空，则返回-1。</target>
        </trans-unit>
        <trans-unit id="1a84eb9548c30b563a95a1fcfb270886bdd52d9e" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the minimum element in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 最小元素的首次遇到的索引。如果 &lt;code&gt;range&lt;/code&gt; 为空，则返回-1。</target>
        </trans-unit>
        <trans-unit id="33a0038a0fcaf095d5057aead72f83713739fc8b" translate="yes" xml:space="preserve">
          <source>The index of the last occurrence of &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is not found, then &lt;code&gt;-1&lt;/code&gt; is returned. The &lt;code&gt;startIdx&lt;/code&gt; slices &lt;code&gt;s&lt;/code&gt; in the following way &lt;code&gt;s[0 .. startIdx]&lt;/code&gt;. &lt;code&gt;startIdx&lt;/code&gt; represents a codeunit index in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 中最后一次出现的索引。如果找不到 &lt;code&gt;c&lt;/code&gt; ，则返回 &lt;code&gt;-1&lt;/code&gt; 。所述 &lt;code&gt;startIdx&lt;/code&gt; 切片 &lt;code&gt;s&lt;/code&gt; 通过以下方式 &lt;code&gt;s[0 .. startIdx]&lt;/code&gt; 。 &lt;code&gt;startIdx&lt;/code&gt; 表示 &lt;code&gt;s&lt;/code&gt; 中的代码单位索引。</target>
        </trans-unit>
        <trans-unit id="c2e5baf3f6abe9b83760e32cef1632ac5f67ea47" translate="yes" xml:space="preserve">
          <source>The index of the pivot for partitioning, must be less than &lt;code&gt;r.length&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;r.length&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">枢轴进行分区的索引，必须小于 &lt;code&gt;r.length&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 如果 &lt;code&gt;r.length&lt;/code&gt; 是 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4e8d4da6e42c851e373823697d10ed8eae4adf3" translate="yes" xml:space="preserve">
          <source>The index of the type among &lt;code&gt;AllowedTypesParam&lt;/code&gt;, zero-based.</source>
          <target state="translated">在 &lt;code&gt;AllowedTypesParam&lt;/code&gt; 中的类型的索引，从零开始。</target>
        </trans-unit>
        <trans-unit id="6f4d7d5591308d1987c179c707865f7263b2522b" translate="yes" xml:space="preserve">
          <source>The index of this archive member within the archive.</source>
          <target state="translated">该档案成员在档案馆内的索引。</target>
        </trans-unit>
        <trans-unit id="9b3efb64d9c8c3a8462cc2762d6a92ac26c24dcc" translate="yes" xml:space="preserve">
          <source>The index starts at &lt;code&gt;start&lt;/code&gt; and is incremented by one on every iteration.</source>
          <target state="translated">该索引从开始处 &lt;code&gt;start&lt;/code&gt; 并在每次迭代时增加1。</target>
        </trans-unit>
        <trans-unit id="86fe7372a9779ec608c645bda74b3617bd2f68d1" translate="yes" xml:space="preserve">
          <source>The index to start reading from (instead of starting at the front). If index is a pointer, then it is updated to the index after the bytes read. The overloads with index are only available if &lt;code&gt;hasSlicing!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">从其开始读取的索引（而不是从最前面开始）。如果index是指针，则在读取字节后将其更新为索引。仅当 &lt;code&gt;hasSlicing!R&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时,带索引的重载才可用。</target>
        </trans-unit>
        <trans-unit id="3b0d5226f25947ab0cd2172717539dced2cf1ca0" translate="yes" xml:space="preserve">
          <source>The index to start writing to. If index is a pointer, then it is updated to the index after the bytes read.</source>
          <target state="translated">要开始写入的索引。如果index是指针,则在读取字节后更新为索引。</target>
        </trans-unit>
        <trans-unit id="f9ffb074b766c5938ff8b7357963618eaf462bcb" translate="yes" xml:space="preserve">
          <source>The indexed range. If rs consists of only one range, the return type is an alias of that range's type.</source>
          <target state="translated">索引的范围。如果rs只包含一个范围,返回类型是该范围类型的别名。</target>
        </trans-unit>
        <trans-unit id="619765ffdaa0071187a8f77abd362e7dda091d2c" translate="yes" xml:space="preserve">
          <source>The inference is done by determining if the function body follows the rules of the particular attribute.</source>
          <target state="translated">推理的方法是判断函数体是否遵循特定属性的规则。</target>
        </trans-unit>
        <trans-unit id="44470f7ce0660d4121c31a312118ccb100fd5b58" translate="yes" xml:space="preserve">
          <source>The initial count for the semaphore.</source>
          <target state="translated">旗语的初始计数。</target>
        </trans-unit>
        <trans-unit id="8c9e853ca955ba71f49e1626fd9e59d97a172b5c" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with its predicates converted to an equivalent single predicate.</source>
          <target state="translated">初始范围包装为 &lt;code&gt;SortedRange&lt;/code&gt; ，其谓词转换为等效的单个谓词。</target>
        </trans-unit>
        <trans-unit id="47bf51e4f2c2e73e2360a982a3dcd26ed977c3bb" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt;.</source>
          <target state="translated">初始范围包装成 &lt;code&gt;SortedRange&lt;/code&gt; 与谓词 &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae187df68ec47146dca1715d3e3c373579beb355" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;binaryFun!less&lt;/code&gt;.</source>
          <target state="translated">最初的范围包装成 &lt;code&gt;SortedRange&lt;/code&gt; 与谓词 &lt;code&gt;binaryFun!less&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80d1aad4ad1e534532ce1e885f47d8eb7c78b11f" translate="yes" xml:space="preserve">
          <source>The initial size of each buffer. If &lt;code&gt;next&lt;/code&gt; takes its array by reference, it may resize the buffers.</source>
          <target state="translated">每个缓冲区的初始大小。如果 &lt;code&gt;next&lt;/code&gt; 通过引用获取其数组，则可以调整缓冲区的大小。</target>
        </trans-unit>
        <trans-unit id="06bcd9aed8f8362952958dfe41f57dcc25fe7b79" translate="yes" xml:space="preserve">
          <source>The initialization expression for the type.</source>
          <target state="translated">类型的初始化表达式。</target>
        </trans-unit>
        <trans-unit id="ef4a846934e7e3a7c6fada2c58784a67e938dc53" translate="yes" xml:space="preserve">
          <source>The initializer for a manifest constant is evaluated using compile time function evaluation.</source>
          <target state="translated">清单常量的初始化器使用编译时函数评估。</target>
        </trans-unit>
        <trans-unit id="4866f78cdd0450f210abe845a0008dc25126137c" translate="yes" xml:space="preserve">
          <source>The initializer for a non-local immutable declaration must be evaluatable at compile time:</source>
          <target state="translated">非本地不可变声明的初始化器在编译时必须是可评估的。</target>
        </trans-unit>
        <trans-unit id="c3ff76d4230d39e88bec6a17e3fa23c6428b640f" translate="yes" xml:space="preserve">
          <source>The initializer for a non-static local immutable declaration is evaluated at run time:</source>
          <target state="translated">非静态局部不可变声明的初始化器在运行时被评估。</target>
        </trans-unit>
        <trans-unit id="8f27ed7b518832024e3d6a15cbe377f8e47f39ab" translate="yes" xml:space="preserve">
          <source>The initializer for a static variable must be evaluatable at compile time, and they are initialized upon the start of the thread (or the start of the program for &lt;code&gt;__gshared&lt;/code&gt;). There are no static constructors or static destructors for static local variables.</source>
          <target state="translated">静态变量的初始化程序必须在编译时可求值，并且它们在线程启动时（或 &lt;code&gt;__gshared&lt;/code&gt; 的程序启动时）进行初始化。静态局部变量没有静态构造函数或静态析构函数。</target>
        </trans-unit>
        <trans-unit id="56398784568892251b9dcc7b9a121fdad0fc1209" translate="yes" xml:space="preserve">
          <source>The inout forms a wildcard that stands in for any of mutable, const, immutable, inout, or inout const. When the function is called, the inout of the return type is changed to whatever the mutable, const, immutable, inout, or inout const status of the argument type to the parameter inout was.</source>
          <target state="translated">inout形成一个通配符,代表mutable、const、immutable、inout或inout const中的任何一种。当函数被调用时,返回类型的inout会被改变为参数inout的参数类型的mutable、const、immutable、inout或inout const状态。</target>
        </trans-unit>
        <trans-unit id="47e39fe3c6321bc48452728017762afb10e65931" translate="yes" xml:space="preserve">
          <source>The inout in the return type is then rewritten to be the inout matched qualifiers:</source>
          <target state="translated">然后将返回类型中的inout改写为inout匹配的限定符。</target>
        </trans-unit>
        <trans-unit id="894e5ecc4ff73411cc66384f9e949e3263a04d5e" translate="yes" xml:space="preserve">
          <source>The input data is too long (There's no guarantee the first part of the data is valid)</source>
          <target state="translated">输入的数据太长(不能保证数据的第一部分是有效的</target>
        </trans-unit>
        <trans-unit id="37721cea9b7ff856cc5a0d72da55bfcef8342f2c" translate="yes" xml:space="preserve">
          <source>The input elements. If there are less elements than the specified length of the static array, the rest of it is default-initialized. If there are more than specified, the first elements up to the specified length are used.</source>
          <target state="translated">输入的元素。如果元素数量少于静态数组的指定长度,则其余元素默认为初始化。如果元素数量超过指定长度,则使用指定长度以内的第一个元素。</target>
        </trans-unit>
        <trans-unit id="4b42c37fa56b476654b6a22d064c38aab28dcdfc" translate="yes" xml:space="preserve">
          <source>The input is returned.</source>
          <target state="translated">输入的内容会被返回。</target>
        </trans-unit>
        <trans-unit id="fb78206bd59b576b51359aab6e37d1fe64780809" translate="yes" xml:space="preserve">
          <source>The input may have originated from &lt;code&gt;U[]&lt;/code&gt; or &lt;code&gt;immutable(U)[]&lt;/code&gt;, so it may be actually shared or not. Returning an unqualified affix may result in race conditions, whereas returning a &lt;code&gt;shared&lt;/code&gt; affix may result in inadvertent sharing of mutable thread-local data across multiple threads. So the returned type is conservatively &lt;code&gt;ref const&lt;/code&gt;.</source>
          <target state="translated">输入可能源自 &lt;code&gt;U[]&lt;/code&gt; 或 &lt;code&gt;immutable(U)[]&lt;/code&gt; ，因此它可能实际上是共享的或不是共享的。返回不合格的词缀可能会导致竞争状况，而返回 &lt;code&gt;shared&lt;/code&gt; 词缀可能会导致在多个线程之间无意间共享可变线程局部数据。因此，返回的类型保守地为 &lt;code&gt;ref const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab7802e78bae021ec9f77bb19cdbefc46c138fde" translate="yes" xml:space="preserve">
          <source>The input range being passed through.</source>
          <target state="translated">被传递的输入范围。</target>
        </trans-unit>
        <trans-unit id="c0225247a221452c012002a0bc4a76423e77fd6b" translate="yes" xml:space="preserve">
          <source>The input range must not be empty.</source>
          <target state="translated">输入范围不能为空。</target>
        </trans-unit>
        <trans-unit id="786f6ba29b51fa6818ec422c83e424f885e18b3d" translate="yes" xml:space="preserve">
          <source>The input range set up to parse one line at a time into a record tuple.</source>
          <target state="translated">设置的输入范围,每次将一行解析为一个记录元组。</target>
        </trans-unit>
        <trans-unit id="4c83aa414329fad18718e6fa488a3b442df22d1b" translate="yes" xml:space="preserve">
          <source>The input range to check.</source>
          <target state="translated">要检查的输入范围。</target>
        </trans-unit>
        <trans-unit id="4dd476cc824391e088069cbddbb750e2eef61f40" translate="yes" xml:space="preserve">
          <source>The input text string s is formed into a paragraph by breaking it up into a sequence of lines, delineated by \n, such that the number of columns is not exceeded on each line. The last line is terminated with a \n.</source>
          <target state="translated">输入的文本字符串s被分成一系列的行,用&quot;\n &quot;来划分,形成一个段落,这样每行的列数就不会超过。最后一行用一个\n结束。</target>
        </trans-unit>
        <trans-unit id="93424042a1977cf3da75467c8916a2a7eddec8a8" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point.</source>
          <target state="translated">该函数的输入必须是一个有效的代码点。</target>
        </trans-unit>
        <trans-unit id="44b890bb7f50ef5e291775cda4bfde289081100b" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point. This is enforced by the function's in-contract.</source>
          <target state="translated">该函数的输入必须是一个有效的代码点。这是由函数的契约中强制执行的。</target>
        </trans-unit>
        <trans-unit id="c67615e6ffc16592b049d69cbff653f9fe85f2f3" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by DocumentParser's in contract.</source>
          <target state="translated">该函数的输入必须是有效的XML。这是由DocumentParser在合同中强制执行的。</target>
        </trans-unit>
        <trans-unit id="4bb4a25af5340195ef134855f808d1711e956a9a" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by the function's in contract.</source>
          <target state="translated">该函数的输入必须是有效的XML。这是由函数的in contract强制执行的。</target>
        </trans-unit>
        <trans-unit id="323b8c9102f07dbc17e6156b32bdb18e8608c8b5" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded.</source>
          <target state="translated">该函数的输入必须是有效的编码。</target>
        </trans-unit>
        <trans-unit id="d4a76f46d20716b9c53fd13981afb49f20693850" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded. This is enforced by the function's in-contract.</source>
          <target state="translated">该函数的输入必须是有效的编码。这是由函数的契约中强制执行的。</target>
        </trans-unit>
        <trans-unit id="52bc0973d7be9145a7f9c10120f8ee1522aa2643" translate="yes" xml:space="preserve">
          <source>The instantiated template.</source>
          <target state="translated">实例化的模板。</target>
        </trans-unit>
        <trans-unit id="caa69ad6f2cd188077c7e982e4e11f26b6cdf5a4" translate="yes" xml:space="preserve">
          <source>The integral and floating type sizes should be considered as minimums. Algorithms should be designed to continue to work properly if the type size increases.</source>
          <target state="translated">积分型和浮动型的大小应被视为最小值。如果字体大小增加,算法的设计应能继续正常工作。</target>
        </trans-unit>
        <trans-unit id="bfaa650f603081ed06b593e3b4e5c458c3260e28" translate="yes" xml:space="preserve">
          <source>The integral is</source>
          <target state="translated">积分是</target>
        </trans-unit>
        <trans-unit id="d07416a83435e11558037f6cda4d47f4d33fe73e" translate="yes" xml:space="preserve">
          <source>The integral is evaluated by a continued fraction expansion or, when b * x is small, by a power series.</source>
          <target state="translated">积分通过持续的分数展开来评估,或者当b*x较小时,通过幂级数来评估。</target>
        </trans-unit>
        <trans-unit id="4502af3e801c133bfaf7193afbee4f48610ef881" translate="yes" xml:space="preserve">
          <source>The integral type to convert the first &lt;code&gt;T.sizeof&lt;/code&gt; bytes to.</source>
          <target state="translated">将第一个 &lt;code&gt;T.sizeof&lt;/code&gt; 字节转换为的整数类型。</target>
        </trans-unit>
        <trans-unit id="51127e20341aada7d08b3905487eaefce7dd284a" translate="yes" xml:space="preserve">
          <source>The integral value to return the absolute value of.</source>
          <target state="translated">返回绝对值的积分值。</target>
        </trans-unit>
        <trans-unit id="54f14afee26358f556f656a70b82a5a8901a5411" translate="yes" xml:space="preserve">
          <source>The intent of this function is to provide an allocation-less way to call a C function using a D slice. The function internally allocates a buffer if needed, but frees it on exit.</source>
          <target state="translated">这个函数的目的是提供一种无需分配的方式来使用D片调用C函数。如果需要的话,这个函数会在内部分配一个缓冲区,但在退出时释放它。</target>
        </trans-unit>
        <trans-unit id="aa32bace5214cedb20ff140ded35da64a7980bf0" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opDollar!i&lt;/code&gt; should return the length of the array along its &lt;code&gt;i&lt;/code&gt;'th dimension, or a user-defined object representing the end of the array along that dimension, that is understood by &lt;code&gt;opSlice&lt;/code&gt; and &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">目的是 &lt;code&gt;opDollar!i&lt;/code&gt; 应该返回数组在其第 &lt;code&gt;i&lt;/code&gt; 个维度上的长度，或者是一个用户定义的对象，该对象代表该数组在该维度上的末尾，这是 &lt;code&gt;opSlice&lt;/code&gt; 和 &lt;code&gt;opIndex&lt;/code&gt; 可以理解的。</target>
        </trans-unit>
        <trans-unit id="7ed569bfceb9bac4ccf7954c87c2cc7395c8f770" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opSlice!i&lt;/code&gt; should return a user-defined object that represents an interval of indices along the &lt;code&gt;i&lt;/code&gt;'th dimension of the array. This object is then passed to &lt;code&gt;opIndex&lt;/code&gt; to perform the actual slicing operation. If only one-dimensional slicing is desired, &lt;code&gt;opSlice&lt;/code&gt; may be declared without the compile-time parameter &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">目的是 &lt;code&gt;opSlice!i&lt;/code&gt; 应该返回一个用户定义的对象，该对象表示沿着数组第 &lt;code&gt;i&lt;/code&gt; 个维度的索引间隔。然后将此对象传递给 &lt;code&gt;opIndex&lt;/code&gt; 以执行实际的切片操作。如果只需要一 &lt;code&gt;opSlice&lt;/code&gt; 片，则可以声明opSlice而不使用编译时参数 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf6066b8690ba4fa47007edd6d83a6b71547ae35" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism defined above (back up to a comment remarkably similar to this one) is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">上文所定义的虚拟表机制的接口(回溯到与此非常相似的评论)目前被认为是试验性的。该接口可能会以不兼容的方式改变。如果这对你来说是个问题,请不要在这个时候使用这个接口。</target>
        </trans-unit>
        <trans-unit id="6250bca0465ce111dcc80945b2149f4168412958" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">虚拟表格机制的接口目前被认为是试验性的。该接口可能会以不兼容的方式改变。如果这对你来说是个问题,请不要在这个时候使用这个接口。</target>
        </trans-unit>
        <trans-unit id="8d2e293904f5395fe014c79325ed5dca620f1643" translate="yes" xml:space="preserve">
          <source>The interface to this is found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc/gcinterface.d&lt;/a&gt;.</source>
          <target state="translated">可以在Druntime的&lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc / gcinterface.d中&lt;/a&gt;找到此接口。</target>
        </trans-unit>
        <trans-unit id="70ba1bd45dceaea5f1daa9192d952a7efda4639e" translate="yes" xml:space="preserve">
          <source>The interval that this &lt;code&gt;IntervalRange&lt;/code&gt; currently covers.</source>
          <target state="translated">此 &lt;code&gt;IntervalRange&lt;/code&gt; 当前覆盖的间隔。</target>
        </trans-unit>
        <trans-unit id="b1b8b6efa0b6085f29ca02a503001474bd874de3" translate="yes" xml:space="preserve">
          <source>The interval that this range currently covers.</source>
          <target state="translated">该范围当前所覆盖的区间。</target>
        </trans-unit>
        <trans-unit id="99ed0102a151474509c2f50c80c6a8fd9abde664" translate="yes" xml:space="preserve">
          <source>The interval to check against this interval.</source>
          <target state="translated">对照此区间进行检查的区间。</target>
        </trans-unit>
        <trans-unit id="e9709ec7167a6294d35ca54cb0db7b761b6bd4bb" translate="yes" xml:space="preserve">
          <source>The interval to check for against this interval.</source>
          <target state="translated">根据这个区间来检查的区间。</target>
        </trans-unit>
        <trans-unit id="c93a05b54bf8db01ca44894e1b6574520f0f25cd" translate="yes" xml:space="preserve">
          <source>The interval to check for inclusion in this interval.</source>
          <target state="translated">要检查是否包含在这个区间内的区间。</target>
        </trans-unit>
        <trans-unit id="7af5c560175f78550b8fa16520f8bceb2478bd1e" translate="yes" xml:space="preserve">
          <source>The interval to check for intersection with this interval.</source>
          <target state="translated">要检查的区间与这个区间是否有交集。</target>
        </trans-unit>
        <trans-unit id="758e2e8521e78873ca075d9d09978b3e79b23a85" translate="yes" xml:space="preserve">
          <source>The interval to check whether its adjecent to this interval.</source>
          <target state="translated">检查其是否与该区间相邻的区间。</target>
        </trans-unit>
        <trans-unit id="ec8c525abec811d6fafbe3af351dcf7c933228a1" translate="yes" xml:space="preserve">
          <source>The interval to create a span together with this interval.</source>
          <target state="translated">要和这个区间一起创建一个跨度。</target>
        </trans-unit>
        <trans-unit id="ffa8edd7fe1af9b169dddd595e3c77f03e44244d" translate="yes" xml:space="preserve">
          <source>The interval to intersect with this interval.</source>
          <target state="translated">与这个区间相交的区间。</target>
        </trans-unit>
        <trans-unit id="450cf7fb1673450b11d1c6b4254176a2488c262a" translate="yes" xml:space="preserve">
          <source>The interval to merge with this interval.</source>
          <target state="translated">要与这个区间合并的区间。</target>
        </trans-unit>
        <trans-unit id="6dd87bff580699a73195a62f3312346bd1ffd61d" translate="yes" xml:space="preserve">
          <source>The invariant can be checked with an &lt;code&gt;assert()&lt;/code&gt; expression:</source>
          <target state="translated">可以使用 &lt;code&gt;assert()&lt;/code&gt; 表达式检查不变量：</target>
        </trans-unit>
        <trans-unit id="3d1bc4f7a43b5f2dfbf63c4d45e4f9ad2787305a" translate="yes" xml:space="preserve">
          <source>The invariant is a contract saying that the &lt;code&gt;assert&lt;/code&gt;s must hold true. The invariant is checked when a class or struct constructor completes, and at the start of the class or struct destructor. For public or exported functions, the order of execution is:</source>
          <target state="translated">不变式是一个约定，要求 &lt;code&gt;assert&lt;/code&gt; 必须成立。当类或结构构造函数完成时以及在类或结构析构函数的开始处检查不变量。对于公共或导出功能，执行顺序为：</target>
        </trans-unit>
        <trans-unit id="db3237f4b413cd2d050f8846cd6a9cf6b11b5b9b" translate="yes" xml:space="preserve">
          <source>The invariant is in the form of a &lt;code&gt;const&lt;/code&gt; member function. The invariant is defined to</source>
          <target state="translated">不变式为 &lt;code&gt;const&lt;/code&gt; 成员函数的形式。不变量定义为</target>
        </trans-unit>
        <trans-unit id="4013ec9a85db3fcab85de75b73cedbcdfe5398d3" translate="yes" xml:space="preserve">
          <source>The invariant is not checked if the class or struct is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">如果使用默认的 &lt;code&gt;.init&lt;/code&gt; 值隐式构造了类或结构，则不检查不变量。</target>
        </trans-unit>
        <trans-unit id="b006ea59664dde8c9966b0ba37f0d9de49867d7b" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the class instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">如果使用默认的 &lt;code&gt;.init&lt;/code&gt; 值隐式构造了类实例，则不需要保留不变式。</target>
        </trans-unit>
        <trans-unit id="90d62a6c20b7727a896f3c7231e895bd333ec112" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the struct instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">如果使用默认的 &lt;code&gt;.init&lt;/code&gt; 值隐式构造struct实例，则不需要保留不变式。</target>
        </trans-unit>
        <trans-unit id="ae2f7e963cff5e59d45cd356ad6b537b6f9c2bbf" translate="yes" xml:space="preserve">
          <source>The isMarked callback function.</source>
          <target state="translated">isMarked回调函数。</target>
        </trans-unit>
        <trans-unit id="b53b0d99e692dbe7d750a9e3a8ec485970e1fe1a" translate="yes" xml:space="preserve">
          <source>The issue remains of calling &lt;code&gt;a.deallocate(b)&lt;/code&gt; from a different thread than the one that allocated &lt;code&gt;b&lt;/code&gt;. It follows that both threads must have access to the same instance &lt;code&gt;a&lt;/code&gt; of the respective allocator type. By definition of D, this is possible only if &lt;code&gt;a&lt;/code&gt; has the &lt;code&gt;shared&lt;/code&gt; qualifier. It follows that the allocator type must implement &lt;code&gt;allocate&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; as &lt;code&gt;shared&lt;/code&gt; methods. That way, the allocator commits to allowing usable &lt;code&gt;shared&lt;/code&gt; instances.</source>
          <target state="translated">问题仍然是从与分配 &lt;code&gt;b&lt;/code&gt; 的线程不同的线程中调用 &lt;code&gt;a.deallocate(b)&lt;/code&gt; 。因此，两个线程必须有权访问各自分配器类型的相同实例 &lt;code&gt;a&lt;/code&gt; 。根据D的定义，仅当 &lt;code&gt;a&lt;/code&gt; 具有 &lt;code&gt;shared&lt;/code&gt; 限定符时才有可能。因此，分配器类型必须实现 &lt;code&gt;allocate&lt;/code&gt; 和 &lt;code&gt;deallocate&lt;/code&gt; 作为 &lt;code&gt;shared&lt;/code&gt; 方法。这样，分配器将致力于允许可用的 &lt;code&gt;shared&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="f906deb3cb569875f4c530161fd80e93b9be746c" translate="yes" xml:space="preserve">
          <source>The key is the IANA time zone database name, and the value is a list of Windows time zone names which are close (usually only one, but it could be multiple).</source>
          <target state="translated">键是IANA时区数据库名称,值是与之接近的Windows时区名称列表(通常只有一个,但也可能是多个)。</target>
        </trans-unit>
        <trans-unit id="0cdd5bd88b6b5b8af271fba7af0cd3f24ac411a0" translate="yes" xml:space="preserve">
          <source>The key is the Windows time zone name, and the value is a list of IANA TZ database names which are close (currently only ever one, but it allows for multiple in case it's ever necessary).</source>
          <target state="translated">键是Windows时区名称,值是与之接近的IANA TZ数据库名称列表(目前只有一个,但它允许多个,以备不时之需)。</target>
        </trans-unit>
        <trans-unit id="07021616652b4190834cc6f5cd3d6a99828ab34d" translate="yes" xml:space="preserve">
          <source>The key.</source>
          <target state="translated">关键。</target>
        </trans-unit>
        <trans-unit id="a80046e2f9e469e161e9b64d7a84ab6bec7ee185" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;do&lt;/code&gt; can be used to announce the function body. Although any number of pre or post contracts of any form may follow each other, &lt;code&gt;do&lt;/code&gt; is required only when the last contract before the body is a block statement. (Before the acceptance of &lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003&lt;/a&gt;, the keyword &lt;code&gt;body&lt;/code&gt; was required instead of &lt;code&gt;do&lt;/code&gt;, and may still be encountered in old code bases. In the long term, &lt;code&gt;body&lt;/code&gt; may be deprecated, but for now it's allowed both as a keyword in this context and as an identifier elsewhere, although &lt;code&gt;do&lt;/code&gt; is preferred.)</source>
          <target state="translated">关键字 &lt;code&gt;do&lt;/code&gt; 可以用来声明功能主体。尽管可以以任意形式签订任意数量的合同， &lt;code&gt;do&lt;/code&gt; 只有在主体之前的最后一个合同为整体声明时，才需要这样做。（在接受&lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003&lt;/a&gt;之前，关键字 &lt;code&gt;body&lt;/code&gt; 是必需的，而不是 &lt;code&gt;do&lt;/code&gt; ，并且可能在旧代码库中仍然会遇到。从长远来看， &lt;code&gt;body&lt;/code&gt; 可能已被弃用，但就目前而言，它既可以用作关键字，也可以用作的标识符别处，尽管 &lt;code&gt;do&lt;/code&gt; 是优选的。）</target>
        </trans-unit>
        <trans-unit id="d0cf199fa5ede60a30e00df7068d936c5578eb01" translate="yes" xml:space="preserve">
          <source>The kind of pragma it is determined by the</source>
          <target state="translated">Pragma的种类是由以下因素决定的</target>
        </trans-unit>
        <trans-unit id="8c29b92f234fc529a35e51b203804649a01ac419" translate="yes" xml:space="preserve">
          <source>The lambda function arguments must not have a template instantiation as an explicit argument type. Any other argument types (basic, user-defined, template) are supported.</source>
          <target state="translated">lambda函数的参数必须没有模板实例作为显式参数类型。支持任何其他参数类型(基本的,用户定义的,模板的)。</target>
        </trans-unit>
        <trans-unit id="bdcf91e0f4f606e17a112c301f88ad8c5b2c10fe" translate="yes" xml:space="preserve">
          <source>The lambda function body must contain a single expression (no return statement) which contains only numeric values, manifest constants, enum values, function arguments and function calls. If the expression contains local variables or return statements, the function is considered incomparable.</source>
          <target state="translated">lambda函数体必须包含一个单一的表达式(没有返回语句),它只包含数值、显式常量、枚举值、函数参数和函数调用。如果表达式包含局部变量或返回语句,则该函数被认为是不可比较的。</target>
        </trans-unit>
        <trans-unit id="95be9f6bb557ebac60c617f8309a121bd86960bc" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;所在月份的最后一天。</target>
        </trans-unit>
        <trans-unit id="7a278dbcde6702c093900cb5053e8bf5709be9d8" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;所在月份的最后一天。</target>
        </trans-unit>
        <trans-unit id="49136c9e4ea103b38fd972475d00bbb19f727989" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;所在月份的最后一天。</target>
        </trans-unit>
        <trans-unit id="a7a9289af76d268aef34222393a4318b6b13e368" translate="yes" xml:space="preserve">
          <source>The last element in the container</source>
          <target state="translated">容器中的最后一个元素</target>
        </trans-unit>
        <trans-unit id="6a4a00d2337afbe6c2df52717b98e8e13215bd50" translate="yes" xml:space="preserve">
          <source>The last element of the array.</source>
          <target state="translated">数组的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="bdc0ac79d31e7752c2d29a6d8b9bf43609b17c83" translate="yes" xml:space="preserve">
          <source>The last parameter is passed in EAX rather than being pushed on the stack if the following conditions are met:</source>
          <target state="translated">如果满足以下条件,最后一个参数以EAX形式传递,而不是在堆栈上推送。</target>
        </trans-unit>
        <trans-unit id="746b4bdff136b3fa913bf1eeb63d7355bf56ba56" translate="yes" xml:space="preserve">
          <source>The last template parameter if it's a &lt;code&gt;TemplateTupleParameter&lt;/code&gt;</source>
          <target state="translated">最后一个模板参数（如果是 &lt;code&gt;TemplateTupleParameter&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="81aad1de98ee0f65f497fb989a25778e1871d9df" translate="yes" xml:space="preserve">
          <source>The lazy initializer value</source>
          <target state="translated">懒惰初始化值</target>
        </trans-unit>
        <trans-unit id="ea4b5c8a99ea43d9dec4f2b203a2486705eaedf1" translate="yes" xml:space="preserve">
          <source>The lazy variadic delegate solution is preferable to using a lazy variadic array, because each array index would evaluate every element:</source>
          <target state="translated">懒惰变量委托方案优于使用懒惰变量数组,因为每个数组索引会评估每个元素。</target>
        </trans-unit>
        <trans-unit id="421c4166a84b43c53a129a72090df266fc5436fb" translate="yes" xml:space="preserve">
          <source>The least significant bit in any &lt;code&gt;size_t&lt;/code&gt; unit is the starting bit of this unit, and the most significant bit is the last bit of this unit. Therefore, passing e.g. an array of &lt;code&gt;int&lt;/code&gt;s may result in a different &lt;code&gt;BitArray&lt;/code&gt; depending on the processor's endianness.</source>
          <target state="translated">任何 &lt;code&gt;size_t&lt;/code&gt; 单位中的最低有效位都是该单元的起始位，最高有效位是该单元的最后一位。因此，根据处理器的字节序，传递例如 &lt;code&gt;int&lt;/code&gt; 的数组可能会导致不同的 &lt;code&gt;BitArray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eeb9274b7abe5ec5313e249b7496b6be61a66b8b" translate="yes" xml:space="preserve">
          <source>The left operand of the &lt;code&gt;,&lt;/code&gt; is evaluated, then the right operand is evaluated. The type of the expression is the type of the right operand, and the result is the result of the right operand. Using the result of comma expressions isn't allowed.</source>
          <target state="translated">的左操作数 &lt;code&gt;,&lt;/code&gt; 进行评估，然后在右边的操作数进行评估。表达式的类型是右操作数的类型，结果是右操作数的结果。不允许使用逗号表达式的结果。</target>
        </trans-unit>
        <trans-unit id="f0716ee491b6b3f2e07375f7797e5c102ad33bdc" translate="yes" xml:space="preserve">
          <source>The left-hand side (or sole) argument</source>
          <target state="translated">左侧(或唯一)论点</target>
        </trans-unit>
        <trans-unit id="4d310cf569bfdf7161ed54cffc976e1b48e7851c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">比较的左侧（ &lt;code&gt;Lhs&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="204d5f370e11576f0fecb8929fdcdb88b117af5c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;T&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">比较的左侧（ &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="4fefd353c917f9a3bb60b52cf3d51cddee41a3f3" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for equality</source>
          <target state="translated">平等比较的左手边</target>
        </trans-unit>
        <trans-unit id="2b109cf29bece1affa9b23e640454252b8ecd16d" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for ordering</source>
          <target state="translated">左侧的比较,用于订购</target>
        </trans-unit>
        <trans-unit id="ae7fc7c90c99a250cd16f28bd7d7dbc3b81e86a8" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator</source>
          <target state="translated">操作员的左侧</target>
        </trans-unit>
        <trans-unit id="b4517c6bf6d758579387be92cded7d53dd545722" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">运算符的左侧（ &lt;code&gt;Lhs&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="1d155e4a7561179c70fb7012ae70744e878991c7" translate="yes" xml:space="preserve">
          <source>The left-hand side operand</source>
          <target state="translated">左手边的操作数</target>
        </trans-unit>
        <trans-unit id="56ecf39f32678f6ba12fdb543c053bc2a2538cfe" translate="yes" xml:space="preserve">
          <source>The left-hand side operand (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">左侧操作数（ &lt;code&gt;Lhs&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的第一个参数）</target>
        </trans-unit>
        <trans-unit id="fdc93a0d76b637886498906e463f3074234e7249" translate="yes" xml:space="preserve">
          <source>The leftmost side of the inheritance graph of the interfaces all share their vptrs, this is the single inheritance model. Every time the inheritance graph forks (for multiple inheritance) a new vptr is created and stored in the class' instance. Every time a virtual method is overridden, a new vtbl[] must be created with the updated method pointers in it.</source>
          <target state="translated">继承图最左边的接口都共享它们的vptr,这就是单继承模型。每当继承图分叉时(对于多重继承),就会创建一个新的vptr,并存储在类的实例中。每当一个虚拟方法被重写时,必须创建一个新的vtbl[],里面有更新的方法指针。</target>
        </trans-unit>
        <trans-unit id="f8ab85ff43a9b405f7f858dd6bd44661050bcbfb" translate="yes" xml:space="preserve">
          <source>The leftover portion of &lt;code&gt;tgt&lt;/code&gt; after all elements from &lt;code&gt;src&lt;/code&gt; have been moved.</source>
          <target state="translated">来自 &lt;code&gt;src&lt;/code&gt; 的所有元素移动后， &lt;code&gt;tgt&lt;/code&gt; 的剩余部分。</target>
        </trans-unit>
        <trans-unit id="ff1f6ec0205e886692fcbf4cdbd24c49883d76fd" translate="yes" xml:space="preserve">
          <source>The leftover portions of the two ranges after one or the other of the ranges have been exhausted.</source>
          <target state="translated">两个范围中的一个或另一个范围用完后剩余的部分。</target>
        </trans-unit>
        <trans-unit id="4aa5bf288555be6562c9b8eb71a2ee00b9edbaea" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">使用此运算符的&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="06d117fb1568b3c185b1dd70cf5e4111bec8c49d" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">使用此运算符的&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="31c5da3679aa5d6d97a971e899c7a8329e3f0d92" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">使用此运算符的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="1d00a55c762fc066020331efbb630b4cfc23721c" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">使用此运算符的&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="e029991ebf163a2ec03f499fc47cd21941b26f69" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator are</source>
          <target state="translated">使用此运算符的 &lt;code&gt;Duration&lt;/code&gt; 的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="2131ddc8b843bbfb7a2f56781e6183f4a90599d7" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">使用此运算符重载的 &lt;code&gt;Duration&lt;/code&gt; 的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="5584f88d5b275ee008fabf19cf9bf9477c6ef1e2" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator are</source>
          <target state="translated">使用此运算符的 &lt;code&gt;TickDuration&lt;/code&gt; 的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="c5479006c238183b17f8e4535d66092bdb92a1fe" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">使用此运算符重载的 &lt;code&gt;TickDuration&lt;/code&gt; 的合法算术类型为</target>
        </trans-unit>
        <trans-unit id="0bd23cc00d282f158f381c5c9ffe519dc3f30f3b" translate="yes" xml:space="preserve">
          <source>The length dimension(s) of the resulting array</source>
          <target state="translated">所得数组的长度维度</target>
        </trans-unit>
        <trans-unit id="44d89bfdd05d1a58a582eeedae0d9a14e3912d91" translate="yes" xml:space="preserve">
          <source>The length of a Base64 encoding of an array of the given length.</source>
          <target state="translated">给定长度的数组的Base64编码的长度。</target>
        </trans-unit>
        <trans-unit id="a5db64910ec8c3458fc1370fda6dd6afe4df6242" translate="yes" xml:space="preserve">
          <source>The length of the Base64 encoding.</source>
          <target state="translated">Base64编码的长度。</target>
        </trans-unit>
        <trans-unit id="a6c0235529e0d9db5d811993877bcc8428ae8800" translate="yes" xml:space="preserve">
          <source>The length of the decoded string corresponding to a Base64 encoding of length sourceLength.</source>
          <target state="translated">对应于长度为 sourceLength 的 Base64 编码的解码字符串的长度。</target>
        </trans-unit>
        <trans-unit id="11a141a49e0a68aaa17cb7bd6222ca0a80676913" translate="yes" xml:space="preserve">
          <source>The length of the initial segment of &lt;code&gt;r&lt;/code&gt; to sort.</source>
          <target state="translated">要排序的 &lt;code&gt;r&lt;/code&gt; 的初始段的长度。</target>
        </trans-unit>
        <trans-unit id="79633e883a28c37fc7cd1efc3c868307222fbc17" translate="yes" xml:space="preserve">
          <source>The length of the resulting range is the sum of all lengths of the ranges passed as input. This means that all elements (duplicates included) are transferred to the resulting range.</source>
          <target state="translated">生成的范围的长度是作为输入的所有范围的长度之和。这意味着所有的元素(包括重复的元素)都会被转移到结果范围中。</target>
        </trans-unit>
        <trans-unit id="e1ae840eb910889a7516866d4d199999a725e819" translate="yes" xml:space="preserve">
          <source>The length of the token is known to be 40 characters long due to its format, so the attacker first sends &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt;, then &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt;, and so on.</source>
          <target state="translated">由于令牌的格式，令牌的长度已知为40个字符，因此攻击者首先发送 &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt; ，然后发送 &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="1987089f20ee0b5d2ec2f8112d140a36df239f5b" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined.</source>
          <target state="translated">定义插座选项的级别。</target>
        </trans-unit>
        <trans-unit id="b86bd023c662d4e208c258be711aadc0b1b2efae" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined:</source>
          <target state="translated">定义插座选项的级别。</target>
        </trans-unit>
        <trans-unit id="f491d891c138db3f9bceff46473b495e216f49dc" translate="yes" xml:space="preserve">
          <source>The lexical analysis is independent of the syntax parsing and the semantic analysis. The lexical analyzer splits the source text up into tokens. The lexical grammar describes the syntax of those tokens. The grammar is designed to be suitable for high speed scanning and to make it easy to write a correct scanner for it. It has a minimum of special case rules and there is only one phase of translation.</source>
          <target state="translated">词法分析独立于语法解析和语义分析。词法分析器将源文本分割成标记。词法语法描述这些标记的语法。该语法的设计是为了适合高速扫描,并使其易于编写正确的扫描器。它有最少的特殊情况规则,而且只有一个翻译阶段。</target>
        </trans-unit>
        <trans-unit id="64fc62f1647f32635083b06c594d00bb08d6c211" translate="yes" xml:space="preserve">
          <source>The lexical order of the attributes &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;scope&lt;/code&gt; is not significant.</source>
          <target state="translated">属性 &lt;code&gt;ref&lt;/code&gt; ， &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;scope&lt;/code&gt; 的词汇顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="f68c7b698966b101a1a595982c2044cc2a404192" translate="yes" xml:space="preserve">
          <source>The line number information from where the call originates</source>
          <target state="translated">呼叫发起地的线路号码信息。</target>
        </trans-unit>
        <trans-unit id="630ea807f4230ab332463ca98ac961bf9f44e6d5" translate="yes" xml:space="preserve">
          <source>The line number of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">D源代码的行号,对应的错误是从哪里抛出的。</target>
        </trans-unit>
        <trans-unit id="229e0a2bdd93317a19e4a68e09629b3b6f154aca" translate="yes" xml:space="preserve">
          <source>The line number of the caller.</source>
          <target state="translated">呼叫者的线路号。</target>
        </trans-unit>
        <trans-unit id="0ad55de99f59d99a8ffdf4bac1fdfeed484559cb" translate="yes" xml:space="preserve">
          <source>The line number on which this error occurred.</source>
          <target state="translated">发生此错误的行号。</target>
        </trans-unit>
        <trans-unit id="b99341808eb5c2aeef537e3bc3ba23e7d2391ae4" translate="yes" xml:space="preserve">
          <source>The line number that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">如果抛出&lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; ,&lt;/a&gt;它将列出的行号。</target>
        </trans-unit>
        <trans-unit id="f269870f6d1360520fe00512e2c2e3c4c0c50b6e" translate="yes" xml:space="preserve">
          <source>The line number where the exception occurred.</source>
          <target state="translated">发生异常的行号。</target>
        </trans-unit>
        <trans-unit id="f737b0208cdb15cf160156fb11b96cdbc64efed4" translate="yes" xml:space="preserve">
          <source>The line terminator (&lt;code&gt;'\n'&lt;/code&gt; by default) is part of the string read (it could be missing in the last line of the file). Several types are supported for &lt;code&gt;line&lt;/code&gt;, and the behavior of &lt;code&gt;lines&lt;/code&gt; changes accordingly:</source>
          <target state="translated">行终止符（默认为 &lt;code&gt;'\n'&lt;/code&gt; ）是读取的字符串的一部分（文件的最后一行可能会丢失）。几种类型都支持 &lt;code&gt;line&lt;/code&gt; 和行为 &lt;code&gt;lines&lt;/code&gt; 相应变化：</target>
        </trans-unit>
        <trans-unit id="4223574eefbbf292923ac805daa2d742c2ceff1c" translate="yes" xml:space="preserve">
          <source>The line that was read, including the line terminator character.</source>
          <target state="translated">读取的行,包括行结束符。</target>
        </trans-unit>
        <trans-unit id="0c791857d998bbf0bb74dbde8821e8c09defc3d6" translate="yes" xml:space="preserve">
          <source>The line where the error occurred.</source>
          <target state="translated">发生错误的线路。</target>
        </trans-unit>
        <trans-unit id="5ba806293f71618709ac5ca5570d100d47098201" translate="yes" xml:space="preserve">
          <source>The line where the error occurred. Defaults to &lt;code&gt;__LINE__&lt;/code&gt;.</source>
          <target state="translated">发生错误的行。默认为 &lt;code&gt;__LINE__&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9ec5dcfd170a3e54aa2b0486e8b3a659ecba856" translate="yes" xml:space="preserve">
          <source>The linkage form &lt;code&gt;extern (C++, &lt;/code&gt;</source>
          <target state="translated">链接形式 &lt;code&gt;extern (C++, &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a68509fefd64796f7d1a07f49a259470873e621" translate="yes" xml:space="preserve">
          <source>The linkage is recognized on all platforms but will issue a compile error if it is used on a platform where Objective-C support is not available. This allows to easily hide Objective-C declarations from platforms where it is not available using the &lt;a href=&quot;version#version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; statement, without resorting to string mixins or other workarounds.</source>
          <target state="translated">在所有平台上都可以识别该链接，但是如果在没有Objective-C支持的平台上使用该链接，则会发出编译错误。这允许使用&lt;a href=&quot;version#version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt;语句轻松从无法使用的平台隐藏Objective-C声明，而无需使用字符串混合或其他变通方法。</target>
        </trans-unit>
        <trans-unit id="ee2dc34efb622f40653a49dbfe76ceb8d1ee0eff" translate="yes" xml:space="preserve">
          <source>The list of allowed types. If empty, any type is allowed.</source>
          <target state="translated">允许的类型列表。如果为空,则允许使用任何类型。</target>
        </trans-unit>
        <trans-unit id="7d752b3e0c165ac9972ad67362f39567c19601ad" translate="yes" xml:space="preserve">
          <source>The literal may not exceed the range of the type. The literal is rounded to fit into the significant digits of the type.</source>
          <target state="translated">字面意思不能超过类型的范围。字面意思是四舍五入,以适应类型的重要数字。</target>
        </trans-unit>
        <trans-unit id="cfda6f32ee8182b11470321e18429ff54847d85e" translate="yes" xml:space="preserve">
          <source>The local part is in a deprecated form</source>
          <target state="translated">本地部分采用的是废弃的形式。</target>
        </trans-unit>
        <trans-unit id="6f51eadb663d2759618c2c7f55ed73ce81e81662" translate="yes" xml:space="preserve">
          <source>The local part of the address is too long</source>
          <target state="translated">地址的本地部分太长</target>
        </trans-unit>
        <trans-unit id="d43703ab62f0fdfb0730decc44b9accfe993fc48" translate="yes" xml:space="preserve">
          <source>The local part of the email address, that is, the part before the @ sign.</source>
          <target state="translated">电子邮件地址的本地部分,也就是@号之前的部分。</target>
        </trans-unit>
        <trans-unit id="fb2b16bfeb403dd9d23822ef47a96282d2506733" translate="yes" xml:space="preserve">
          <source>The logger used by the logging function as reference.</source>
          <target state="translated">记录功能所使用的记录仪作为参考。</target>
        </trans-unit>
        <trans-unit id="9dc35ce16bcd5e0f3997b30f4a3a933ead8e2be7" translate="yes" xml:space="preserve">
          <source>The long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdce859b555eda9a366f161871fcdb633ee5b0eb" translate="yes" xml:space="preserve">
          <source>The long symbol for this option</source>
          <target state="translated">此选项的长符号</target>
        </trans-unit>
        <trans-unit id="eb826857f96e2fa8c72d4f984e7520701feb3d3d" translate="yes" xml:space="preserve">
          <source>The loop is correctly written:</source>
          <target state="translated">循环的写法是正确的。</target>
        </trans-unit>
        <trans-unit id="80cd3f025f71ab9fb6d037c50456d7fb59577d15" translate="yes" xml:space="preserve">
          <source>The lower bound of the clamp.</source>
          <target state="translated">钳的下限。</target>
        </trans-unit>
        <trans-unit id="c3ba355fcfd258cdc3b0962e2c92c7fd02aec3ad" translate="yes" xml:space="preserve">
          <source>The macro &quot;##&quot; is ISO C, we assume pre-ISO C doesn't support it.</source>
          <target state="translated">宏 &quot;##&quot;是ISO C,我们认为ISO C前不支持。</target>
        </trans-unit>
        <trans-unit id="4493cedee574dfabffbc81a40e14a5b6a3a6b77b" translate="yes" xml:space="preserve">
          <source>The macros section follows the same syntax as the &lt;b&gt;Params:&lt;/b&gt; section. It's a series of</source>
          <target state="translated">宏部分的语法与&lt;b&gt;Params：&lt;/b&gt;部分相同。这是一系列的</target>
        </trans-unit>
        <trans-unit id="7ae8a3b1299a2612db122fcc08bc88452fa0e22f" translate="yes" xml:space="preserve">
          <source>The magnitude of x is limited to about 106.56 for IEEE 80-bit arithmetic; 1 or -1 is returned outside this range.</source>
          <target state="translated">对于IEEE 80位算术来说,x的幅度被限制在106.56左右;在这个范围之外,会返回1或-1。</target>
        </trans-unit>
        <trans-unit id="327523b3c0bae538d6dd857c0b63c542d4c2e3ff" translate="yes" xml:space="preserve">
          <source>The main &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; module provides template-based tools for working with ranges, but sometimes an object-based interface for ranges is needed, such as when runtime polymorphism is required. For this purpose, this submodule provides a number of object and &lt;code&gt;interface&lt;/code&gt; definitions that can be used to wrap around range objects created by the &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; templates.</source>
          <target state="translated">主要的&lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;模块提供了用于范围的基于模板的工具，但是有时需要用于范围的基于对象的接口，例如当需要运行时多态时。为此，此子模块提供了许多对象和 &lt;code&gt;interface&lt;/code&gt; 定义，可用于包装由&lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;模板创建的范围对象。</target>
        </trans-unit>
        <trans-unit id="3c02f05cd38724c7e8cb17756e9c5152cd9c1060" translate="yes" xml:space="preserve">
          <source>The main entry point for garbage collection. The supplied delegate will be passed ranges representing both stack and register values.</source>
          <target state="translated">垃圾收集的主要入口。提供的委托人将被传递代表堆栈和寄存器值的范围。</target>
        </trans-unit>
        <trans-unit id="70a5f20578712db84e71fcdbe8fd245260ba0674" translate="yes" xml:space="preserve">
          <source>The main reasons that a program might need to use ticks directly is if the system clock has higher precision than hnsecs, and the program needs that higher precision, or if the program needs to avoid the rounding errors caused by converting to hnsecs.</source>
          <target state="translated">程序可能需要直接使用ticks的主要原因是,如果系统时钟的精度比hnsecs高,而程序需要更高的精度,或者程序需要避免转换为hnsecs造成的舍入误差。</target>
        </trans-unit>
        <trans-unit id="99346c9361ee044918b5692d75d84b05203809b4" translate="yes" xml:space="preserve">
          <source>The main uses cases for &lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; 的主要用例是：</target>
        </trans-unit>
        <trans-unit id="37721286eae1f656c81db469ea0c2aa0407bd201" translate="yes" xml:space="preserve">
          <source>The major 32-bit x86 microarchitecture 'dynasties' have been:</source>
          <target state="translated">主要的32位x86微架构 &quot;王朝 &quot;已经。</target>
        </trans-unit>
        <trans-unit id="982a1e7c4fc73fa370e90c954afb1f355930cd55" translate="yes" xml:space="preserve">
          <source>The managed array.</source>
          <target state="translated">管理阵列。</target>
        </trans-unit>
        <trans-unit id="24b3c10fb402cc3696f43a7e032402872866e5ae" translate="yes" xml:space="preserve">
          <source>The mangled name for a function with function pointer type T and the given fully qualified name.</source>
          <target state="translated">一个函数指针类型为T的函数和给定的完全限定名称的杂乱名称。</target>
        </trans-unit>
        <trans-unit id="2222f24e9ff7ad414fdd6df5db1a3a27354c9552" translate="yes" xml:space="preserve">
          <source>The mangled name for a symbols of type T and the given fully qualified name.</source>
          <target state="translated">T型符号的杂乱名称和给定的完全限定名称。</target>
        </trans-unit>
        <trans-unit id="582a49c9af38036e1960cd170f7932701e0fb6f3" translate="yes" xml:space="preserve">
          <source>The mangled name with deduplicated identifiers</source>
          <target state="translated">带有重复标识符的杂乱名称</target>
        </trans-unit>
        <trans-unit id="08774dd4c4d75e3bd42a748ee71506481a4f0a1b" translate="yes" xml:space="preserve">
          <source>The mangled string representing the type</source>
          <target state="translated">代表类型的杂乱字符串</target>
        </trans-unit>
        <trans-unit id="aa7ae029a5326a80d32c23d17dde2c45ccbc8321" translate="yes" xml:space="preserve">
          <source>The mapping of package and module identifiers to directory and file names.</source>
          <target state="translated">包和模块标识符与目录和文件名的映射。</target>
        </trans-unit>
        <trans-unit id="43effc8161287353136863e8d2f53a67a4ef703b" translate="yes" xml:space="preserve">
          <source>The max aliases are the largest integral types:</source>
          <target state="translated">最大别名是最大的积分类型。</target>
        </trans-unit>
        <trans-unit id="986ee926972449f806f769e32d7dd4ba24b84874" translate="yes" xml:space="preserve">
          <source>The maximal element of the passed-in range.</source>
          <target state="translated">传入范围的最大元素。</target>
        </trans-unit>
        <trans-unit id="ae723b7ad52bbfa1e17cf08fd49aa1b7abbdc458" translate="yes" xml:space="preserve">
          <source>The maximum allowed nesting level.</source>
          <target state="translated">允许的最大嵌套水平。</target>
        </trans-unit>
        <trans-unit id="c15b5870b72ff9ade8671f564f3ad47e5d8703b2" translate="yes" xml:space="preserve">
          <source>The maximum guarantee of &lt;code&gt;pure&lt;/code&gt; is called &quot;strong purity&quot;. It can enable optimizations based on the fact that a function is guaranteed to not mutate anything which isn't passed to it. For cases where the compiler can guarantee that a pure function cannot alter its arguments, it can enable full, functional purity (i.e. the guarantee that the function will always return the same result for the same arguments). To that end, a pure function:</source>
          <target state="translated">最高的 &lt;code&gt;pure&lt;/code&gt; 保证称为&amp;ldquo;强纯度&amp;rdquo;。它可以基于以下事实进行优化：保证一个函数不会对任何未传递给它的东西进行变异。对于编译器可以保证纯函数不能更改其参数的情况，它可以启用完整的函数纯净度（即，保证函数对于相同的参数始终返回相同的结果）。为此，一个纯函数：</target>
        </trans-unit>
        <trans-unit id="c855c6313f529356306d651f3e145813bb160323" translate="yes" xml:space="preserve">
          <source>The maximum length of &lt;code&gt;filename&lt;/code&gt; is given by the constant &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt;. (On Windows, this number is defined as the maximum number of UTF-16 code points, and the test will therefore only yield strictly correct results when &lt;code&gt;filename&lt;/code&gt; is a string of &lt;code&gt;wchar&lt;/code&gt;s.)</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 的最大长度由常量 &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt; 给出。（在Windows上，此数字定义为UTF-16代码点的最大数量，因此，仅在 &lt;code&gt;filename&lt;/code&gt; 是 &lt;code&gt;wchar&lt;/code&gt; 字符串时，测试才会产生严格正确的结果。）</target>
        </trans-unit>
        <trans-unit id="05e735a756b3fa2f43497424f8b3020883222ceb" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes of output that should be captured.</source>
          <target state="translated">应该捕获的最大输出字节数。</target>
        </trans-unit>
        <trans-unit id="f3e3e4f751fc559f30cd92f8522a3febd435ec99" translate="yes" xml:space="preserve">
          <source>The maximum number of elements the array can store without reallocating memory and invalidating iterators upon insertion.</source>
          <target state="translated">数组可以存储的最大元素数,而不需要重新分配内存和插入时使迭代器无效。</target>
        </trans-unit>
        <trans-unit id="ff490f34a5e2c376eac774681e1598898ac5391d" translate="yes" xml:space="preserve">
          <source>The maximum number of messages or zero if no limit.</source>
          <target state="translated">最大信息数量,如果没有限制,则为零。</target>
        </trans-unit>
        <trans-unit id="23ffb3d6838b02986026c5eeb543b889e4e64af2" translate="yes" xml:space="preserve">
          <source>The maximum of the passed-in args. The type of the returned value is the type among the passed arguments that is able to store the largest value.</source>
          <target state="translated">传入的参数中的最大值。返回值的类型是传递的参数中能够存储最大值的类型。</target>
        </trans-unit>
        <trans-unit id="7eb2470a27937a3494cee9a54b8062f651c54299" translate="yes" xml:space="preserve">
          <source>The maximum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the maximum valid priority for the scheduling policy of the process.</source>
          <target state="translated">可以为一个线程设置的最大调度优先级。在定义了多个调度策略的系统中,这个值代表进程的调度策略的最大有效优先级。</target>
        </trans-unit>
        <trans-unit id="f397747108afabbaad398b1bbfbbdd699e4c5ce8" translate="yes" xml:space="preserve">
          <source>The maximum size of the GC buffer to hold the return values</source>
          <target state="translated">GC缓冲区的最大尺寸,用于保存返回值。</target>
        </trans-unit>
        <trans-unit id="075c481912178c8ac79090ee5b3669c3def2fbb2" translate="yes" xml:space="preserve">
          <source>The maximum value representable is &lt;code&gt;T.max&lt;/code&gt; for signed integrals, &lt;code&gt; T.max - 1&lt;/code&gt; for unsigned integrals. The minimum value representable is &lt;code&gt; T.min + 1&lt;/code&gt; for signed integrals, &lt;code&gt;0&lt;/code&gt; for unsigned integrals.</source>
          <target state="translated">对于有符号积分，可表示的最大值为 &lt;code&gt;T.max&lt;/code&gt; ，对于无符号积分，可表示的最大值为 &lt;code&gt; T.max - 1&lt;/code&gt; 。对于有符号积分，可表示的最小值为 &lt;code&gt; T.min + 1&lt;/code&gt; ，对于无符号积分，可表示的最小值为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4957d9a3700ae6f7d93e51da85b7d5a4964d27b2" translate="yes" xml:space="preserve">
          <source>The mean of &lt;code&gt;r&lt;/code&gt; when &lt;code&gt;r&lt;/code&gt; is non-empty.</source>
          <target state="translated">当 &lt;code&gt;r&lt;/code&gt; 为非空 &lt;code&gt;r&lt;/code&gt; 时，r的平均值。</target>
        </trans-unit>
        <trans-unit id="c587177906e3358831db8b1c6944ffdb24226077" translate="yes" xml:space="preserve">
          <source>The members are completely hidden to the user, and so the only operations on those types are ones that do not require any knowledge of the contents of those types. For example:</source>
          <target state="translated">这些成员对用户来说是完全隐藏的,所以对这些类型的操作只有那些不需要知道这些类型内容的操作。例如:</target>
        </trans-unit>
        <trans-unit id="00dd946dd7ec09c0536b1658fc7e8ead520e7c8e" translate="yes" xml:space="preserve">
          <source>The memory is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">该存储器被从获得 &lt;code&gt;SmallAllocator&lt;/code&gt; 如果 &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt; ，或 &lt;code&gt;LargeAllocator&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="f8c96911fea13cb1c02d9f105c0c295fa2deb239" translate="yes" xml:space="preserve">
          <source>The memory location of different memory blocks is not defined. Ordered comparison (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;) between two pointers is permitted when both pointers point to the same array, or when at least one pointer is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">未定义不同存储块的存储位置。当两个指针都指向同一数组或至少一个指针为 &lt;code&gt;null&lt;/code&gt; 时，允许在两个指针之间进行有序比较（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe0b84897743c23c53a5e9577a10299a7a7b020c" translate="yes" xml:space="preserve">
          <source>The memory usage of this implementation is guaranteed to be constant in &lt;code&gt;range.length&lt;/code&gt;.</source>
          <target state="translated">确保此实现的内存使用情况在 &lt;code&gt;range.length&lt;/code&gt; 中是恒定的。</target>
        </trans-unit>
        <trans-unit id="7609ac8f3cf653b1ce0270fa8139880a547a9eea" translate="yes" xml:space="preserve">
          <source>The message for the exception.</source>
          <target state="translated">异常的信息。</target>
        </trans-unit>
        <trans-unit id="4c338cd37584d6e6e69bd4c24d1ae2acb50b8634" translate="yes" xml:space="preserve">
          <source>The message that was sent.</source>
          <target state="translated">发出的信息。</target>
        </trans-unit>
        <trans-unit id="68d612f02557a1940b9b2866c12015c2578745a2" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;AssertError&lt;/code&gt; if the assumption turns out to be false.</source>
          <target state="translated">如果假设为假，则包含在 &lt;code&gt;AssertError&lt;/code&gt; 中的消息。</target>
        </trans-unit>
        <trans-unit id="488aa84d557c1a01800a687e8f424ca1dc36fdd6" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;ErrnoException&lt;/code&gt; if it is thrown.</source>
          <target state="translated">如果抛出该消息，则包含在 &lt;code&gt;ErrnoException&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="79b8f8765c27119a953cd29d5a9f80179e617637" translate="yes" xml:space="preserve">
          <source>The metaclass of this class.</source>
          <target state="translated">这个类的元类。</target>
        </trans-unit>
        <trans-unit id="93cc36b0067843c6450f0911a4ca8b3ad0ea0493" translate="yes" xml:space="preserve">
          <source>The method used to enable or disable the unit tests. Use of a compiler switch such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt; to enable them is suggested.</source>
          <target state="translated">用于启用或禁用单元测试的方法。建议使用&lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt;之类的编译器开关来启用它们。</target>
        </trans-unit>
        <trans-unit id="c6a75cd2237917d2ed85214e205b4f1cf25efd9f" translate="yes" xml:space="preserve">
          <source>The minimal element of the passed-in range.</source>
          <target state="translated">传入范围的最小元素。</target>
        </trans-unit>
        <trans-unit id="ab6714e3fe053113da2960956c8eb82b3e5bbc67" translate="yes" xml:space="preserve">
          <source>The minimal number of edits to transform s into t.  Does not allocate GC memory.</source>
          <target state="translated">将s转化为t的最小编辑次数,不分配GC内存。</target>
        </trans-unit>
        <trans-unit id="10a4be4f3adcabd3abe79325f2076e9b9a100888" translate="yes" xml:space="preserve">
          <source>The minimum duration the calling thread should be suspended.</source>
          <target state="translated">调用线程应暂停的最短期限。</target>
        </trans-unit>
        <trans-unit id="28711c27ca983081eb31b72306fa4a118f39be3b" translate="yes" xml:space="preserve">
          <source>The minimum extension size in bytes.</source>
          <target state="translated">最小扩展大小,单位为字节。</target>
        </trans-unit>
        <trans-unit id="c06ab7e4e215252c3c928d52e3071658c4a68764" translate="yes" xml:space="preserve">
          <source>The minimum of the passed-in values.</source>
          <target state="translated">传入值的最小值。</target>
        </trans-unit>
        <trans-unit id="95346b92b5307b71b43fcd27332d111b5c7b81cb" translate="yes" xml:space="preserve">
          <source>The minimum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the minimum valid priority for the scheduling policy of the process.</source>
          <target state="translated">可以为一个线程设置的最小调度优先级。在定义了多个调度策略的系统中,这个值代表进程的调度策略的最小有效优先级。</target>
        </trans-unit>
        <trans-unit id="91d9db5c5ad3a0f6b05ff83250575799825e9e6d" translate="yes" xml:space="preserve">
          <source>The minimum, respectively maximum element of a range together with the number it occurs in the range.</source>
          <target state="translated">一个范围的最小,分别是最大的元素,以及它在该范围内出现的数量。</target>
        </trans-unit>
        <trans-unit id="4776ba2a4d44664c280371c94d75db0a68aa7f47" translate="yes" xml:space="preserve">
          <source>The minute portion of the time;</source>
          <target state="translated">分钟的部分时间。</target>
        </trans-unit>
        <trans-unit id="804dde72e3fca52bb6fee9e6c9a891f7a218393e" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的分钟设置为的分钟。</target>
        </trans-unit>
        <trans-unit id="fd8186f6e2f846fa308524ef0f64113f0d7289dd" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的分钟设置为的分钟。</target>
        </trans-unit>
        <trans-unit id="80d86d248f3ac806d407ff7069134427130713b0" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">将此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;的分钟设置为的分钟。</target>
        </trans-unit>
        <trans-unit id="204cac3357eeb22cb6ce425410ebf52a7b2c34ef" translate="yes" xml:space="preserve">
          <source>The mode the memory mapped file is opened with.</source>
          <target state="translated">内存映射文件的打开模式。</target>
        </trans-unit>
        <trans-unit id="973816115210d9c45eb2bc6fdd4a572e4108483e" translate="yes" xml:space="preserve">
          <source>The modified &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for any time on this date (since, the modified Julian day changes at midnight).</source>
          <target state="translated">修改后的&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;儒略日&lt;/a&gt;在该日期的任何时间（因为修改后的儒略日在午夜更改）。</target>
        </trans-unit>
        <trans-unit id="860d6be9b0cf54ee441891db4a2fd6202c776fe2" translate="yes" xml:space="preserve">
          <source>The modifier to apply.</source>
          <target state="translated">要应用的修改器。</target>
        </trans-unit>
        <trans-unit id="124f2941f2e52ecf62ccffc3b7646e3953931e7d" translate="yes" xml:space="preserve">
          <source>The modifiers of the &lt;code&gt;lhsMod&lt;/code&gt; mismatching the ones with the &lt;code&gt;rhsMod&lt;/code&gt; are printed, i.e. lhs(shared) vs. rhs() prints &quot;&lt;code&gt;shared&lt;/code&gt;&quot;, wheras lhs() vs rhs(shared) prints &quot;non-shared&quot;.</source>
          <target state="translated">&lt;code&gt;lhsMod&lt;/code&gt; 的修饰符与rhsMod不匹配，即 &lt;code&gt;rhsMod&lt;/code&gt; （shared）与rhs（）打印&amp;ldquo; &lt;code&gt;shared&lt;/code&gt; &amp;rdquo;，而wheras lhs（）vs rhs（shared）打印&amp;ldquo;非共享&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="95523edab7d804c0b6ab6eed37c8c3cadada1694" translate="yes" xml:space="preserve">
          <source>The module edges as found in the &lt;code&gt;importedModules&lt;/code&gt; member of each ModuleInfo. Generated in sortCtors.</source>
          <target state="translated">在每个ModuleInfo 的 &lt;code&gt;importedModules&lt;/code&gt; 成员中找到的模块边缘。在sortCtors中生成。</target>
        </trans-unit>
        <trans-unit id="47af20b56ee3955f4fd47d6c7951eb2d036d5a4c" translate="yes" xml:space="preserve">
          <source>The module for this virtual table</source>
          <target state="translated">该虚拟表的模块</target>
        </trans-unit>
        <trans-unit id="cab05c206d3bb715fd01c040c88f5fe361c942e4" translate="yes" xml:space="preserve">
          <source>The modulus</source>
          <target state="translated">模数</target>
        </trans-unit>
        <trans-unit id="82131155f810a5f75ba3764eb1563b749deb3cf3" translate="yes" xml:space="preserve">
          <source>The monotonic clock has no relation to wall clock time. Rather, it holds its time as the number of ticks of the clock which have occurred since the clock started (typically when the system booted up). So, to determine how much time has passed between two points in time, one monotonic time is subtracted from the other to determine the number of ticks which occurred between the two points of time, and those ticks are divided by the number of ticks that occur every second (as represented by MonoTime.ticksPerSecond) to get a meaningful duration of time. Normally, MonoTime does these calculations for the programmer, but the &lt;code&gt;ticks&lt;/code&gt; and &lt;code&gt;ticksPerSecond&lt;/code&gt; properties are provided for those who require direct access to the system ticks. The normal way that MonoTime would be used is</source>
          <target state="translated">单调时钟与挂钟时间无关。而是将其时间保留为自时钟启动以来（通常是系统启动时）发生的时钟滴答数。因此，要确定两个时间点之间经过了多少时间，请从另一个时间中减去一个单调时间，以确定在两个时间点之间发生的滴答声数量，然后将这些滴答声除以发生的滴答声数量。每秒（由MonoTime.ticksPerSecond表示）以获取有意义的持续时间。通常，MonoTime为程序员执行这些计算，但是 &lt;code&gt;ticks&lt;/code&gt; 和 &lt;code&gt;ticksPerSecond&lt;/code&gt; 属性是为需要直接访问系统ticks的用户提供的。通常使用MonoTime的方式是</target>
        </trans-unit>
        <trans-unit id="d74977e8496820ecedeff19e20ade1b05de3e4b6" translate="yes" xml:space="preserve">
          <source>The month of the day to validate (January is 1).</source>
          <target state="translated">日的月份进行验证(1月为1)。</target>
        </trans-unit>
        <trans-unit id="6ebaf2163e939c5ad1bf15c5f8dae4f8a043e786" translate="yes" xml:space="preserve">
          <source>The month of the day to validate.</source>
          <target state="translated">日的月份来验证。</target>
        </trans-unit>
        <trans-unit id="d4d21752a92d87f995da2fa4e777f8856076f4d2" translate="yes" xml:space="preserve">
          <source>The month of the year to get the number of months to.</source>
          <target state="translated">年的月份,以获得月数到。</target>
        </trans-unit>
        <trans-unit id="3b03ba6279034200ca13bdea73b6dd032c6515f6" translate="yes" xml:space="preserve">
          <source>The month portion of the date (January is 1).</source>
          <target state="translated">日期的月份部分(一月为1)。</target>
        </trans-unit>
        <trans-unit id="e6fd335018a8476e0b61c3352fc0e3562dbfcc53" translate="yes" xml:space="preserve">
          <source>The month that each time point in the range will be in (January is 1).</source>
          <target state="translated">每个时间点的范围内的月份(一月为1)。</target>
        </trans-unit>
        <trans-unit id="3a058535cdaf9aa70980ff68790ecdb70d352df1" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">将此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的月份设置为的月份。</target>
        </trans-unit>
        <trans-unit id="b85e045063e5ffa8ef021269a9798226e87028d9" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的月份设置为的月份。</target>
        </trans-unit>
        <trans-unit id="a9daf4d7ebc51fc3e649125b409fa21bb86aa474" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的月份设置为的月份。</target>
        </trans-unit>
        <trans-unit id="cf6b4f0b397f7fd7fb57c763984e8789cb54772a" translate="yes" xml:space="preserve">
          <source>The most basic contract is the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;. An &lt;b&gt;assert&lt;/b&gt; declares an expression that must evaluate to true, with an optional failure string as a second argument:</source>
          <target state="translated">最基本的合同是&lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;。一个&lt;b&gt;assert&lt;/b&gt;声明一个必须计算为true的表达式，并使用一个可选的失败字符串作为第二个参数：</target>
        </trans-unit>
        <trans-unit id="8a6bd68f79c5b13e9b7d8eaf7293f850cd2e0e6d" translate="yes" xml:space="preserve">
          <source>The most conservative/general allocation: memory may be shared, deallocated in a different thread, may or may not be resized, and may embed references.</source>
          <target state="translated">最保守/一般的分配方式:内存可以共享,在不同的线程中重新分配,可以调整大小,也可以不调整大小,还可以嵌入引用。</target>
        </trans-unit>
        <trans-unit id="1f6880935884c96d8b2634bfd6b4fbc9dbe4652c" translate="yes" xml:space="preserve">
          <source>The most interesting case is when gapped matches still participate in the result, but not as strongly as ungapped matches. The result will be a smooth, fine-grained similarity measure between the input strings. This is where values of &lt;code&gt;lambda&lt;/code&gt; between 0 and 1 enter into play: gapped matches are</source>
          <target state="translated">最有趣的情况是当空缺的比赛仍参与结果，但不如空缺的比赛强。结果将是输入字符串之间的平滑，细粒度的相似性度量。这是0到1之间的 &lt;code&gt;lambda&lt;/code&gt; 值起作用的地方：差距匹配是</target>
        </trans-unit>
        <trans-unit id="9317ec6cdc50605b3f7ad3a0a9efb80f09d16bb9" translate="yes" xml:space="preserve">
          <source>The mutex associated with this condition.</source>
          <target state="translated">与此条件相关的mutex。</target>
        </trans-unit>
        <trans-unit id="8402314bcd0aba6dacdd48ffde4057ad88f89bec" translate="yes" xml:space="preserve">
          <source>The mutex module provides a primitive for maintaining mutually exclusive access.</source>
          <target state="translated">互斥模块提供了一个维护互斥访问的基元。</target>
        </trans-unit>
        <trans-unit id="437cb228e7e76ab9ff7feb1b0fb4ca0971be7ae2" translate="yes" xml:space="preserve">
          <source>The mutex with which this condition will be associated.</source>
          <target state="translated">与该条件相关联的mutex。</target>
        </trans-unit>
        <trans-unit id="4d5ce17987e89e660e90474cca14f7f4718221ad" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;string&lt;/code&gt; is aliased to &lt;code&gt;immutable(char)[]&lt;/code&gt;, so the above declarations could be equivalently written as:</source>
          <target state="translated">名称 &lt;code&gt;string&lt;/code&gt; 别名为 &lt;code&gt;immutable(char)[]&lt;/code&gt; ，因此上述声明可以等效地写为：</target>
        </trans-unit>
        <trans-unit id="abdfc7dd54ebeb228e02bc4ac46894950c3ebbee" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class::WhiteHole&lt;/a&gt; Perl module by Michael G Schwern.</source>
          <target state="translated">该名称来自Michael G Schwern的&lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class :: WhiteHole&lt;/a&gt; Perl模块。</target>
        </trans-unit>
        <trans-unit id="173aa229bfebb13b14fcecd5dd6654d108541499" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class::BlackHole&lt;/a&gt; Perl module by Sean M. Burke.</source>
          <target state="translated">该名称来自Sean M. Burke的&lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class :: BlackHole&lt;/a&gt; Perl模块。</target>
        </trans-unit>
        <trans-unit id="ba677412cf6055cfe046fa4f2b82702d23be25af" translate="yes" xml:space="preserve">
          <source>The name if the &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 的名称</target>
        </trans-unit>
        <trans-unit id="ef45a06b2c7cb94d26e3df83157cd1f979d10e1a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to insert.</source>
          <target state="translated">要插入的 &lt;code&gt;Logger&lt;/code&gt; 的名称。</target>
        </trans-unit>
        <trans-unit id="dd55ce2538ac752361cbfd21c951f733e9d094b0" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to remove. If the &lt;code&gt;Logger&lt;/code&gt; is not found &lt;code&gt;null&lt;/code&gt; will be returned. Only the first occurrence of a &lt;code&gt;Logger&lt;/code&gt; with the given name will be removed.</source>
          <target state="translated">要删除的 &lt;code&gt;Logger&lt;/code&gt; 的名称。如果找不到 &lt;code&gt;Logger&lt;/code&gt; ,则将返回 &lt;code&gt;null&lt;/code&gt; 。仅会删除首次出现的具有给定名称的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ee544165e4b0ac751c5682d99380143dea28b21" translate="yes" xml:space="preserve">
          <source>The name of the coverage file.</source>
          <target state="translated">覆盖文件的名称。</target>
        </trans-unit>
        <trans-unit id="8ede299dc9f0c5729961ad67f198075314269cda" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library to load.</source>
          <target state="translated">要加载的动态库的名称。</target>
        </trans-unit>
        <trans-unit id="eb57c5ab9b22c7728fcb5026ae94a8f672f4064a" translate="yes" xml:space="preserve">
          <source>The name of the file in the path name, without any leading directory and with an optional suffix chopped off.  If &lt;code&gt;suffix&lt;/code&gt; is specified, it will be compared to &lt;code&gt;path&lt;/code&gt; using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">路径名中的文件名，不带任何前导目录，并且带有可选的后缀。如果指定了 &lt;code&gt;suffix&lt;/code&gt; ，则将使用 &lt;code&gt;filenameCmp!cs&lt;/code&gt; 将其与 &lt;code&gt;path&lt;/code&gt; 进行比较，其中 &lt;code&gt;cs&lt;/code&gt; 是一个可选的模板参数，确定比较是否区分大小写。有关详细信息，请参见&lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="300f2fc600e9d7ddc4bfc394a66a2e870cf5e607" translate="yes" xml:space="preserve">
          <source>The name of the file that signaled this error.</source>
          <target state="translated">发出该错误信号的文件名称。</target>
        </trans-unit>
        <trans-unit id="c3104c1d832397234efa203c02c8d138f5d9f9fd" translate="yes" xml:space="preserve">
          <source>The name of the file to get the modification time for.</source>
          <target state="translated">要获取修改时间的文件名。</target>
        </trans-unit>
        <trans-unit id="e8109b9ee879cd4547f4e2ca59c0889a944b8289" translate="yes" xml:space="preserve">
          <source>The name of the time zone.</source>
          <target state="translated">时区的名称。</target>
        </trans-unit>
        <trans-unit id="f27bf1b63b731926e3cb9f283408921e662cdceb" translate="yes" xml:space="preserve">
          <source>The name of the time zone. Exactly how the time zone name is formatted depends on the derived class. In the case of &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt;, it's the TZ Database name, whereas with &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, it's the name that Windows chose to give the registry key for that time zone (typically the name that they give &lt;a href=&quot;#stdTime&quot;&gt;&lt;code&gt;stdTime&lt;/code&gt;&lt;/a&gt; if the OS is in English). For other time zone types, what it is depends on how they're implemented.</source>
          <target state="translated">时区的名称。时区名称的确切格式取决于派生类。在&lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt;的情况下，它是TZ数据库名称，而在&lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; 的情况下&lt;/a&gt;，这是Windows选择为该时区提供注册表项的名称（如果操作系统为英文，则通常为&lt;a href=&quot;#stdTime&quot;&gt; &lt;code&gt;stdTime&lt;/code&gt; &lt;/a&gt;）。对于其他时区类型，具体取决于它们的实现方式。</target>
        </trans-unit>
        <trans-unit id="7356c9b705dbe74fbd4051d488c2e6132abcd4c9" translate="yes" xml:space="preserve">
          <source>The name of this thread.</source>
          <target state="translated">这条线的名字。</target>
        </trans-unit>
        <trans-unit id="c1776179bbf96730aef0ae7bbd1e4946315a478b" translate="yes" xml:space="preserve">
          <source>The name to associate with tid.</source>
          <target state="translated">要联想到tid的名字。</target>
        </trans-unit>
        <trans-unit id="6450e623e92fd399a84552aa61d8d22ade4cc69a" translate="yes" xml:space="preserve">
          <source>The name to locate within the registry.</source>
          <target state="translated">要在登记处内查找的名称。</target>
        </trans-unit>
        <trans-unit id="2b6764cf8c6facb0fec9b546a291b7a2d4a5f2ee" translate="yes" xml:space="preserve">
          <source>The name to unregister.</source>
          <target state="translated">要取消注册的名称。</target>
        </trans-unit>
        <trans-unit id="237ed33d70031f44c43457be931f956373047992" translate="yes" xml:space="preserve">
          <source>The names of the &lt;code&gt;Tuple&lt;/code&gt;'s components. Unnamed fields have empty names.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 组件的名称。未命名字段的名称为空。</target>
        </trans-unit>
        <trans-unit id="3ad8dfc5a740c084b53b8cdd123ef24e70479c04" translate="yes" xml:space="preserve">
          <source>The names of the fields that are to be aligned.</source>
          <target state="translated">要对齐的字段名称;</target>
        </trans-unit>
        <trans-unit id="4d205145a6dee0cb48fa4896fcd5718737412eec" translate="yes" xml:space="preserve">
          <source>The necessity of &lt;code&gt;FPTemporary&lt;/code&gt; stems from the optimized floating-point operations and registers present in virtually all processors. When adding numbers in the example above, the addition may in fact be done in &lt;code&gt;real&lt;/code&gt; precision internally. In that case, storing the intermediate &lt;code&gt;result&lt;/code&gt; in &lt;code&gt;double format&lt;/code&gt; is not only less precise, it is also (surprisingly) slower, because a conversion from &lt;code&gt;real&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt; is performed every pass through the loop. This being a lose-lose situation, &lt;code&gt;FPTemporary!F&lt;/code&gt; has been defined as the</source>
          <target state="translated">&lt;code&gt;FPTemporary&lt;/code&gt; 的必要性源于几乎所有处理器中都存在的优化浮点运算和寄存器。在上面的示例中加数字时，实际上可以在内部以 &lt;code&gt;real&lt;/code&gt; 精度进行加。在这种情况下，存储中间 &lt;code&gt;result&lt;/code&gt; 在 &lt;code&gt;double format&lt;/code&gt; 不仅不太精确，这也是（令人惊讶的）慢，因为从一个转换 &lt;code&gt;real&lt;/code&gt; 到 &lt;code&gt;double&lt;/code&gt; 通过循环执行的每个通。这是一个双输的局面， &lt;code&gt;FPTemporary!F&lt;/code&gt; 已经被定义为</target>
        </trans-unit>
        <trans-unit id="ce69a83fa824acdbab753bf226be620b99f45d75" translate="yes" xml:space="preserve">
          <source>The needles against which the range is to be checked, which may be individual elements or input ranges of elements.</source>
          <target state="translated">要检查范围的针,可以是单个元素或元素的输入范围。</target>
        </trans-unit>
        <trans-unit id="bfdb89ae3952e0ebbdb470ec1b2208c20a477858" translate="yes" xml:space="preserve">
          <source>The needles to check against, which may be single elements, or bidirectional ranges of elements.</source>
          <target state="translated">要对照的针,可以是单个元素,也可以是元素的双向范围。</target>
        </trans-unit>
        <trans-unit id="aadc952b806bed5663dabd85a1e647a24a59b7a9" translate="yes" xml:space="preserve">
          <source>The network interface to use in form of the the IP of the interface.</source>
          <target state="translated">要使用的网络接口的IP形式的接口。</target>
        </trans-unit>
        <trans-unit id="d0400083bef2e7ef7cc46b24ddfeddfeb8ab8c14" translate="yes" xml:space="preserve">
          <source>The new GC is added to the list of available garbage collectors that can be selected via the usual configuration options, e.g. by embedding &lt;code&gt;rt_options&lt;/code&gt; into the binary:</source>
          <target state="translated">新的GC将添加到可用垃圾收集器的列表中，可以通过常规配置选项来选择垃圾收集器，例如，将 &lt;code&gt;rt_options&lt;/code&gt; 嵌入二进制文件中：</target>
        </trans-unit>
        <trans-unit id="9669eec52fe11c4d6bad1a51de754d4e92f468df" translate="yes" xml:space="preserve">
          <source>The new capacity of the array (which may be larger than the requested capacity).</source>
          <target state="translated">阵列的新容量(可能大于请求的容量)。</target>
        </trans-unit>
        <trans-unit id="1cf6198accddd14ad946cf8a5d9d64fbb23a0e02" translate="yes" xml:space="preserve">
          <source>The new collect handler. Set to null to use the default handler.</source>
          <target state="translated">新的收集处理程序。设为null则使用默认处理程序。</target>
        </trans-unit>
        <trans-unit id="0c74f8b0b947d138316f600a118f4af837db2c6f" translate="yes" xml:space="preserve">
          <source>The new daemon status for this thread.</source>
          <target state="translated">这条线的新守护状态。</target>
        </trans-unit>
        <trans-unit id="cc66954b4cb782475e75068053434548b84f648b" translate="yes" xml:space="preserve">
          <source>The new extension</source>
          <target state="translated">新的扩展部分</target>
        </trans-unit>
        <trans-unit id="6c6fed22d3bfa6cee371ded07b99f5fc419355ad" translate="yes" xml:space="preserve">
          <source>The new handle will have all options set as the one it was duplicated from. An exception to this is that all options that cannot be shared across threads are reset thereby making it safe to use the duplicate in a new thread.</source>
          <target state="translated">新的句柄将拥有所有选项的设置,就像它被复制的那个句柄一样。一个例外的情况是,所有不能跨线程共享的选项都会被重置,因此在新线程中使用复制的句柄是安全的。</target>
        </trans-unit>
        <trans-unit id="acc5bddfa65365c1a41f6c814bd0b6ebf529b8b6" translate="yes" xml:space="preserve">
          <source>The new length of the array</source>
          <target state="translated">阵列的新长度</target>
        </trans-unit>
        <trans-unit id="44a43ff11b1752259ff91b328a916debf3f4639d" translate="yes" xml:space="preserve">
          <source>The new name of this thread.</source>
          <target state="translated">这条线的新名字。</target>
        </trans-unit>
        <trans-unit id="06d8bda027bfab1541ebec46a9bfa9f862174683" translate="yes" xml:space="preserve">
          <source>The new path name.</source>
          <target state="translated">新的路径名称。</target>
        </trans-unit>
        <trans-unit id="69ac0b91bb8b9e837548ad9dd2ea12af0f0c91cd" translate="yes" xml:space="preserve">
          <source>The new position of the pivot</source>
          <target state="translated">枢轴的新位置</target>
        </trans-unit>
        <trans-unit id="66818226d4d8e1db31b172237309a1e18f4a385a" translate="yes" xml:space="preserve">
          <source>The new scheduling priority of this thread.</source>
          <target state="translated">本线程新的调度优先级。</target>
        </trans-unit>
        <trans-unit id="bd1e49caf2a8a204c7259f45e5e91918594335cb" translate="yes" xml:space="preserve">
          <source>The new trace handler. Set to null to use the default handler.</source>
          <target state="translated">新的跟踪处理程序。设为null则使用默认处理程序。</target>
        </trans-unit>
        <trans-unit id="ef32f36ed520dab3a13bb8e95c2b955f22dc9b02" translate="yes" xml:space="preserve">
          <source>The new type supports all operations that the underlying type does, including all operators such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, etc.</source>
          <target state="translated">新类型支持基础类型执行的所有操作，包括所有运算符，例如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;--&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="4c2af0bb285d74b0268707c20367567927c3ffc7" translate="yes" xml:space="preserve">
          <source>The new unit tester. Set both to null to use the default unit tester.</source>
          <target state="translated">新的单元测试器。将两者都设置为空,以使用默认的单元测试器。</target>
        </trans-unit>
        <trans-unit id="6444785f7ab11942d704329e47346be10efdb756" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;px&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;px&lt;/code&gt; 的新值</target>
        </trans-unit>
        <trans-unit id="a51d15a8fa704020915ee450c5caa4010f6aa779" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 的新值</target>
        </trans-unit>
        <trans-unit id="e4e6a0eafbf606dbc06607e9b4455a1bb56b0445" translate="yes" xml:space="preserve">
          <source>The new-style generator objects hold their own state so they are immune of threading issues. The generators feature a number of well-known and well-documented methods of generating random numbers. An overall fast and reliable means to generate random numbers is the Mt19937 generator, which derives its name from &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; with a period of 2 to the power of 19937&quot;. In memory-constrained situations, &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;linear congruential generators&lt;/a&gt; such as &lt;code&gt;MinstdRand0&lt;/code&gt; and &lt;code&gt;MinstdRand&lt;/code&gt; might be useful. The standard library provides an alias Random for whichever generator it considers the most fit for the target environment.</source>
          <target state="translated">新型生成器对象保持其自己的状态，因此它们不受线程问题的影响。生成器具有生成随机数的许多众所周知且有据可查的方法。 Mt19937生成器是一种生成随机数的整体快速而可靠的方法，它的名称来源于&amp;ldquo; 周期为2到19937的幂的&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; &amp;rdquo;。在内存受限的情况下，&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;线性同余生成器（&lt;/a&gt;例如 &lt;code&gt;MinstdRand0&lt;/code&gt; 和 &lt;code&gt;MinstdRand&lt;/code&gt; )可能会有用。标准库为它认为最适合目标环境的任何生成器提供一个别名Random。</target>
        </trans-unit>
        <trans-unit id="6e04d5ec9d8b3f77749de3ac5300639b2dab8407" translate="yes" xml:space="preserve">
          <source>The newline following the opening identifier is not part of the string, but the last newline before the closing identifier is part of the string. The closing identifier must be placed on its own line at the leftmost column.</source>
          <target state="translated">开头标识符后的换行不属于字符串的一部分,但结尾标识符前的最后一个换行是字符串的一部分。结尾标识符必须放在最左栏的单独一行。</target>
        </trans-unit>
        <trans-unit id="51929efa4bba26701d3e4c3aa50f3e9c95ba7e57" translate="yes" xml:space="preserve">
          <source>The newly constructed object.</source>
          <target state="translated">新建的对象。</target>
        </trans-unit>
        <trans-unit id="c4d7c48e5f93c9ad9f6d35527dbfa50a57849838" translate="yes" xml:space="preserve">
          <source>The newly-created array, or &lt;code&gt;null&lt;/code&gt; if either &lt;code&gt;length&lt;/code&gt; was &lt;code&gt;0&lt;/code&gt; or allocation failed.</source>
          <target state="translated">新创建的数组；如果 &lt;code&gt;length&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; 或分配失败，则为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81ee0139f4bf3ca132aff416b4badbbfb8df40c" translate="yes" xml:space="preserve">
          <source>The next unnamed section is the</source>
          <target state="translated">下一个未命名的部分是</target>
        </trans-unit>
        <trans-unit id="4c1d1956fd234c462fed35c0d040ec6b5d07b95f" translate="yes" xml:space="preserve">
          <source>The non-static data members of a struct are called</source>
          <target state="translated">一个结构的非静态数据成员被称为</target>
        </trans-unit>
        <trans-unit id="604fdea6e74692fe9e13e9f5a58a3d2b1b6ac2cf" translate="yes" xml:space="preserve">
          <source>The normal (or Gaussian, or bell-shaped) distribution is defined as:</source>
          <target state="translated">正态分布(或高斯分布,或钟形分布)定义为:</target>
        </trans-unit>
        <trans-unit id="eff21418db566bf6deaa5b9e66141af90f3d37fd" translate="yes" xml:space="preserve">
          <source>The normal flow of program logic is performance critical.</source>
          <target state="translated">程序逻辑的正常流动对性能至关重要。</target>
        </trans-unit>
        <trans-unit id="7d10d0ff78a75299a167b0002f609034c9aaa171" translate="yes" xml:space="preserve">
          <source>The nth &lt;code&gt;ulong&lt;/code&gt; in the representation of this &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;BigInt&lt;/code&gt; 的表示形式中的第n个 &lt;code&gt;ulong&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb3057bb9b7c5b0a70e9ce3b421bd111159e0bc0" translate="yes" xml:space="preserve">
          <source>The nth number to retrieve. Must be less than &lt;a href=&quot;#ulongLength&quot;&gt;&lt;code&gt;ulongLength&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#uintLength&quot;&gt;&lt;code&gt;uintLength&lt;/code&gt;&lt;/a&gt; with respect to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">要检索的第n个数字。关于 &lt;code&gt;T&lt;/code&gt; ,必须小于&lt;a href=&quot;#ulongLength&quot;&gt; &lt;code&gt;ulongLength&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#uintLength&quot;&gt; &lt;code&gt;uintLength&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b76d5847a278447b3f3920d9aa794bc68c09f466" translate="yes" xml:space="preserve">
          <source>The null value which denotes the null state of this &lt;code&gt;Nullable&lt;/code&gt;. Must be of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">表示此 &lt;code&gt;Nullable&lt;/code&gt; 的null状态的null值。必须为 &lt;code&gt;T&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="199b0fb0977641f832ecd7a38d40b0a14f3dad41" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;Tgt&lt;/code&gt; elements written.</source>
          <target state="translated">写入的 &lt;code&gt;Tgt&lt;/code&gt; 元素的数量。</target>
        </trans-unit>
        <trans-unit id="95368522e59bb86a89704bd4d6738e476908f01e" translate="yes" xml:space="preserve">
          <source>The number of bits of state of this generator. This must be a positive multiple of the size in bits of UIntType. If nbits is large this struct may occupy slightly more memory than this so it can use a circular counter instead of shifting the entire array.</source>
          <target state="translated">该生成器的状态位数,必须是UIntType的正数倍。这必须是UIntType的位数大小的正数倍。如果nbits很大,这个结构可能会比这个结构占用稍多的内存,所以它可以使用一个循环计数器,而不是移动整个数组。</target>
        </trans-unit>
        <trans-unit id="ed0599417ff90656d7b8a7db044e9965e3ca5970" translate="yes" xml:space="preserve">
          <source>The number of buffers to cycle through when calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;next&lt;/code&gt; 时要循环通过的缓冲区数。</target>
        </trans-unit>
        <trans-unit id="30308060113660277e7be67f08fdce3f91011c41" translate="yes" xml:space="preserve">
          <source>The number of bytes actually received, &lt;code&gt;0&lt;/code&gt; if the remote side has closed the connection, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">实际接收的字节数，如果远程端已关闭连接， &lt;code&gt;Socket.ERROR&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; ，否则为Socket.ERROR。</target>
        </trans-unit>
        <trans-unit id="52771a2599e853e22c9997ae74caf507a27e6674" translate="yes" xml:space="preserve">
          <source>The number of bytes actually sent, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">实际发送的字节数， &lt;code&gt;Socket.ERROR&lt;/code&gt; 失败，则返回Socket.ERROR。</target>
        </trans-unit>
        <trans-unit id="cb4925770f917957f95841228cf7a081251584ac" translate="yes" xml:space="preserve">
          <source>The number of bytes written to &lt;code&gt;result&lt;/code&gt;. The length, in bytes, of the actual result - very different from getsockopt()</source>
          <target state="translated">写入 &lt;code&gt;result&lt;/code&gt; 的字节数。实际结果的长度（以字节为单位）-与getsockopt（）完全不同</target>
        </trans-unit>
        <trans-unit id="18e0b014069c5b9a5015fd8266605137eb19d431" translate="yes" xml:space="preserve">
          <source>The number of cache levels in the CPU.</source>
          <target state="translated">CPU的缓存级别数。</target>
        </trans-unit>
        <trans-unit id="4e1a5c7628d25ca94f5309da0ccfd2a5e3544707" translate="yes" xml:space="preserve">
          <source>The number of chunks buffered asynchronously</source>
          <target state="translated">异步缓冲的分块数。</target>
        </trans-unit>
        <trans-unit id="d794552fb711e9d13296816f458408c772152acf" translate="yes" xml:space="preserve">
          <source>The number of code units in &lt;code&gt;input&lt;/code&gt; when encoded to &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">编码为 &lt;code&gt;C&lt;/code&gt; 时 &lt;code&gt;input&lt;/code&gt; 的代码单位数</target>
        </trans-unit>
        <trans-unit id="4af8e22ffe4686545114fe30d8267cec1e21b38c" translate="yes" xml:space="preserve">
          <source>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per &lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, section 3&lt;/a&gt;). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1.</source>
          <target state="translated">UTF序列中的代码单元数。对于UTF-8，这是介于1和4之间的值（根据&lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629，第3节&lt;/a&gt;）。对于UTF-16，它是1或2。对于UTF-32，它总是1。</target>
        </trans-unit>
        <trans-unit id="5eb0aafa3d3443973bc7f248675786f305586655" translate="yes" xml:space="preserve">
          <source>The number of colons in the selector needs to match the number of parameters the method is declared with</source>
          <target state="translated">选择器中冒号的数量需要与方法声明的参数数量相匹配。</target>
        </trans-unit>
        <trans-unit id="cf1a54117f4160455c190793bfbc5f270d3ef431" translate="yes" xml:space="preserve">
          <source>The number of colons in the string need to match the number of arguments the method accept.</source>
          <target state="translated">字符串中的冒号数量需要与方法接受的参数数量一致。</target>
        </trans-unit>
        <trans-unit id="74867ebd8619c3c9f54bb7be26778ccc990cfd33" translate="yes" xml:space="preserve">
          <source>The number of days to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的天数。</target>
        </trans-unit>
        <trans-unit id="17519ebe025dfa827b2543290a321667b7bbfac2" translate="yes" xml:space="preserve">
          <source>The number of elements brought to the front, i.e., the length of &lt;code&gt;back&lt;/code&gt;.</source>
          <target state="translated">带到前面的元素数，即 &lt;code&gt;back&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="30c9197d75a0a694e962a609bbc59e4ba11be6f0" translate="yes" xml:space="preserve">
          <source>The number of elements in an</source>
          <target state="translated">元素的数量</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">数组中元素的数量。</target>
        </trans-unit>
        <trans-unit id="325aeffb680232bb5eba0a4534994930400a1165" translate="yes" xml:space="preserve">
          <source>The number of elements inserted</source>
          <target state="translated">插入的要素数量</target>
        </trans-unit>
        <trans-unit id="4f13d3392d3b50fea45a81fe242fa67f3021e8e8" translate="yes" xml:space="preserve">
          <source>The number of elements inserted.</source>
          <target state="translated">插入的元素数量;</target>
        </trans-unit>
        <trans-unit id="c6d6d4be5d1980bfa9a3ce44b333a124372b6ae3" translate="yes" xml:space="preserve">
          <source>The number of elements removed</source>
          <target state="translated">删除的要素数量</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">删除的元素数量;</target>
        </trans-unit>
        <trans-unit id="a147df2d8f03d61a2cbd49ca985ab3c09c4946c0" translate="yes" xml:space="preserve">
          <source>The number of elements to evaluate in a single &lt;code&gt;Task&lt;/code&gt;. Must be less than or equal to &lt;code&gt;bufSize&lt;/code&gt;, and should be a fraction of &lt;code&gt;bufSize&lt;/code&gt; such that all worker threads can be used. If the default of size_t.max is used, workUnitSize will be set to the pool-wide default.</source>
          <target state="translated">单个 &lt;code&gt;Task&lt;/code&gt; 中要评估的元素数。必须小于或等于 &lt;code&gt;bufSize&lt;/code&gt; ，并且应为 &lt;code&gt;bufSize&lt;/code&gt; 的一部分，以便可以使用所有辅助线程。如果使用默认值size_t.max，则workUnitSize将设置为池范围的默认值。</target>
        </trans-unit>
        <trans-unit id="9de93b8e68b06f4138b723f65ba57f9135fbd680" translate="yes" xml:space="preserve">
          <source>The number of elements which must be popped from the front of &lt;code&gt;haystack&lt;/code&gt; before reaching an element for which &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; for any element in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;-1&lt;/code&gt; is returned. If only &lt;code&gt;pred&lt;/code&gt; is provided, &lt;code&gt;pred(haystack)&lt;/code&gt; is tested for each element.</source>
          <target state="translated">在到达 &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的元素之前必须从 &lt;code&gt;haystack&lt;/code&gt; 的前端弹出的元素数。如果 &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; 对于 &lt;code&gt;haystack&lt;/code&gt; 中的任何元素都不 &lt;code&gt;true&lt;/code&gt; ，则返回 &lt;code&gt;-1&lt;/code&gt; 。如果只有 &lt;code&gt;pred&lt;/code&gt; 设置， &lt;code&gt;pred(haystack)&lt;/code&gt; 对每个元件进行测试。</target>
        </trans-unit>
        <trans-unit id="495bce27f099960a19a7f2777229fe07b08dc353" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since January 1st, 1 A.D. UTC.</source>
          <target state="translated">世界协调时公元1月1日以来的hnsecs数量。</target>
        </trans-unit>
        <trans-unit id="0128cf9b280876e985f5bc63b3c33b05eec8b671" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since midnight, January 1st, 1 A.D. UTC.</source>
          <target state="translated">自世界协调时公元1月1日午夜以来的hnsecs数量。</target>
        </trans-unit>
        <trans-unit id="dfa696143d106fe9221db705fdd3a015ad40f3ab" translate="yes" xml:space="preserve">
          <source>The number of lines buffered asynchronously</source>
          <target state="translated">异步缓冲的行数。</target>
        </trans-unit>
        <trans-unit id="9bd6f12f8ce1f299c0d0263b77bcc143be77d073" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的月数或年数。</target>
        </trans-unit>
        <trans-unit id="b9c39f066ee7dbe68f94fd81f8c5f3cf00396747" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的月数或年数。</target>
        </trans-unit>
        <trans-unit id="57340a14727c652a36c1e1fc1ba3e2830bbfa123" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的月数或年数。</target>
        </trans-unit>
        <trans-unit id="02485194b1dc362bace73e65c9372da46a13c61b" translate="yes" xml:space="preserve">
          <source>The number of months to add to the time point passed to the delegate.</source>
          <target state="translated">在传递给委托人的时间点上增加月数。</target>
        </trans-unit>
        <trans-unit id="aca30d94828d21a4c6a8ef3a42e227aa33b46f16" translate="yes" xml:space="preserve">
          <source>The number of months to expand the interval by.</source>
          <target state="translated">月数,以扩大间隔。</target>
        </trans-unit>
        <trans-unit id="4f7751ef3f5968bb794d3b81c43237882d9d52ee" translate="yes" xml:space="preserve">
          <source>The number of months to shift the interval by.</source>
          <target state="translated">挪动间隔的月数。</target>
        </trans-unit>
        <trans-unit id="63a68d030d7307514d07c50786c06b3b1b3f26d9" translate="yes" xml:space="preserve">
          <source>The number of pages is variable (but not less then 1) unlike the number of entries in the index. The slots of the index all have to contain a number of a page that is present. The lookup is then just a couple of operations - slice the upper bits, lookup an index for these, take a page at this index and use the lower bits as an offset within this page.</source>
          <target state="translated">与索引中的条目数不同,页数是可变的(但不能小于1)。索引的槽位都要包含一个存在的页数。那么查找就只需要几个操作--切开上位,查找这些的索引,在这个索引处取一个页,然后用下位作为这个页内的偏移。</target>
        </trans-unit>
        <trans-unit id="a4a9d929861b7f4540e0616b20649c026af1b75f" translate="yes" xml:space="preserve">
          <source>The number of positions in the &lt;code&gt;haystack&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returned true.</source>
          <target state="translated">在 &lt;code&gt;haystack&lt;/code&gt; 中 &lt;code&gt;pred&lt;/code&gt; 返回true 的职位数。</target>
        </trans-unit>
        <trans-unit id="e5d60a9e70df9e4591b2299d06f99ccc91195edd" translate="yes" xml:space="preserve">
          <source>The number of sockets with status changes, &lt;code&gt;0&lt;/code&gt; on timeout, or &lt;code&gt;-1&lt;/code&gt; on interruption. If the return value is greater than &lt;code&gt;0&lt;/code&gt;, the &lt;code&gt;SocketSets&lt;/code&gt; are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.  &lt;code&gt;SocketSet&lt;/code&gt;'s updated to include only those sockets which an event occured. For a &lt;code&gt;connect()&lt;/code&gt;ing socket, writeability means connected. For a &lt;code&gt;listen()&lt;/code&gt;ing socket, readability means listening &lt;code&gt;Winsock&lt;/code&gt;; possibly internally limited to 64 sockets per set.</source>
          <target state="translated">状态更改的套接字数，超时时为 &lt;code&gt;0&lt;/code&gt; 或中断时为 &lt;code&gt;-1&lt;/code&gt; 。如果返回值大于 &lt;code&gt;0&lt;/code&gt; ，则将 &lt;code&gt;SocketSets&lt;/code&gt; 更新为仅包含状态更改的套接字。对于连接套接字，写状态更改意味着已建立连接并且可以发送连接。对于侦听套接字，读取状态更改意味着存在传入的连接请求，并且可以接受。 &lt;code&gt;SocketSet&lt;/code&gt; 的更新为仅包括发生事件的那些套接字。对于 &lt;code&gt;connect()&lt;/code&gt; 套接字，可写性表示已连接。对于 &lt;code&gt;listen()&lt;/code&gt; 套接字，可读性意味着监听 &lt;code&gt;Winsock&lt;/code&gt; ; 可能内部限制为每组64个套接字。</target>
        </trans-unit>
        <trans-unit id="92623bd7d09398f80bbab3bb0f5f2ef38d3da421" translate="yes" xml:space="preserve">
          <source>The number of system ticks in this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;TickDuration&lt;/code&gt; 中的系统刻度数。</target>
        </trans-unit>
        <trans-unit id="8f11ee7d7d27eb3d41061b45eac584df0b5f1cfe" translate="yes" xml:space="preserve">
          <source>The number of ticks in the TickDuration.</source>
          <target state="translated">TickDuration中的tick数。</target>
        </trans-unit>
        <trans-unit id="c3535c21516c22bad36e4ae79f60e710279eebd0" translate="yes" xml:space="preserve">
          <source>The number of ticks in the monotonic time.</source>
          <target state="translated">在单调的时间里,蜱虫的数量。</target>
        </trans-unit>
        <trans-unit id="133c2247d181f5eb459c19f2950580ed684e418a" translate="yes" xml:space="preserve">
          <source>The number of ticks that MonoTime has per second - i.e. the resolution or frequency of the system's monotonic clock.</source>
          <target state="translated">MonoTime每秒拥有的滴数--即系统单调时钟的分辨率或频率。</target>
        </trans-unit>
        <trans-unit id="8271982f8f2afc20c964508f18ca6b32767857e7" translate="yes" xml:space="preserve">
          <source>The number of ticks that the system clock has in one second.</source>
          <target state="translated">系统时钟在一秒钟内的跳动次数。</target>
        </trans-unit>
        <trans-unit id="8b51266ea49a500bd86819d90d5f5babd9fda252" translate="yes" xml:space="preserve">
          <source>The number of times each function is to be executed.</source>
          <target state="translated">每个函数的执行次数。</target>
        </trans-unit>
        <trans-unit id="f1050ae226927365357fc51efba9b81760d7056b" translate="yes" xml:space="preserve">
          <source>The number of times the output range's &lt;code&gt;put&lt;/code&gt; method was invoked.</source>
          <target state="translated">调用输出范围的 &lt;code&gt;put&lt;/code&gt; 方法的次数。</target>
        </trans-unit>
        <trans-unit id="4d82522805f2ebbbf559fec74a61f5c7cb9cc3a6" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 的单位数。</target>
        </trans-unit>
        <trans-unit id="794f084381c766ea0ff9fffa3e14bba305b1eb34" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 中的单位数。</target>
        </trans-unit>
        <trans-unit id="22c3d0c8685c468fadcdccd79c29727ddf2e7e9a" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的单位数。</target>
        </trans-unit>
        <trans-unit id="9b148446ca97774856b435f40497b3469e8ca6ab" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的单位数。</target>
        </trans-unit>
        <trans-unit id="b3b24aff6aba1d0b2f312ff80d7560f7feabc059" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要添加到此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;的单位数。</target>
        </trans-unit>
        <trans-unit id="37c2540cc1f38510b5307fd0d898532d4c17f0e5" translate="yes" xml:space="preserve">
          <source>The number of units to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">该 &lt;code&gt;Duration&lt;/code&gt; 乘以的单位数。</target>
        </trans-unit>
        <trans-unit id="5f6b34534215487ddb13229d1e9eb704abfb659b" translate="yes" xml:space="preserve">
          <source>The number of values inserted.</source>
          <target state="translated">插入的值的数量。</target>
        </trans-unit>
        <trans-unit id="d14be6e779a48d8faa82f80e4dc078722606651d" translate="yes" xml:space="preserve">
          <source>The number of waiting threads to release in unison.</source>
          <target state="translated">等候线程的数量来统一释放。</target>
        </trans-unit>
        <trans-unit id="365cb2c08dafe42960332e827da68e53b00a9bd8" translate="yes" xml:space="preserve">
          <source>The number of years to add to the time point passed to the delegate.</source>
          <target state="translated">在传递给代表的时间点上增加年数。</target>
        </trans-unit>
        <trans-unit id="fcc2e5d2212e8d8be70b8d4677e493fc3848a020" translate="yes" xml:space="preserve">
          <source>The number of years to expand the interval by.</source>
          <target state="translated">年数,以扩大间隔。</target>
        </trans-unit>
        <trans-unit id="2241ab252f8a5484883abb33a8af4a6dad25eb69" translate="yes" xml:space="preserve">
          <source>The number of years to shift the interval by.</source>
          <target state="translated">挪动间隔的年数。</target>
        </trans-unit>
        <trans-unit id="ab33e33805a08eda08dd986381c2b8f8b862f93b" translate="yes" xml:space="preserve">
          <source>The number to validate.</source>
          <target state="translated">要验证的数字。</target>
        </trans-unit>
        <trans-unit id="b28803e23c2f1bebd73a4d48e79b273e730f7db3" translate="yes" xml:space="preserve">
          <source>The numeric literals &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; can be implicitly converted to the &lt;code&gt;bool&lt;/code&gt; values &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;, respectively. Casting an expression to &lt;code&gt;bool&lt;/code&gt; means testing for &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;!=0&lt;/code&gt; for arithmetic types, and &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;!=null&lt;/code&gt; for pointers or references.</source>
          <target state="translated">可以将数字文字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 隐式转换为 &lt;code&gt;bool&lt;/code&gt; 值 &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; 。将表达式转换为 &lt;code&gt;bool&lt;/code&gt; 意味着对于算术类型测试为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;!=0&lt;/code&gt; ，对于指针或引用测试为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;!=null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe0da3c8ef7d3c766ce89becdf0b23671a0397f9" translate="yes" xml:space="preserve">
          <source>The numeric version number is also available &quot;in parts&quot; by using these constants</source>
          <target state="translated">数字化的版本号也可以通过使用这些常数 &quot;分批 &quot;提供。</target>
        </trans-unit>
        <trans-unit id="126529265bda77a1ffa31840d1614e6dc6547606" translate="yes" xml:space="preserve">
          <source>The object to throw.</source>
          <target state="translated">要扔的对象。</target>
        </trans-unit>
        <trans-unit id="917127d4e18a9f0f96c8fddb70a363dd7f1bb7b1" translate="yes" xml:space="preserve">
          <source>The object-oriented features of D all come from classes. The class hierarchy has as its root the class Object. Object defines a minimum level of functionality that each derived class has, and a default implementation for that functionality.</source>
          <target state="translated">D的面向对象特性都来自于类。类的层次结构以类Object为根。Object定义了每个派生类所具有的最低功能级别,以及该功能的默认实现。</target>
        </trans-unit>
        <trans-unit id="83450785309cc6865682ad266cad8f967bd48d27" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that comparingBenchmark has not been ported over, because it's a trivial wrapper around benchmark. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。注意，comparingBenchmark尚未移植，因为它是围绕基准的琐碎包装。请参阅&lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="efeb1eab4dde5b659a31f85b9f2c2ca05099ac2d" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that measureTime has not been ported over, because it's a trivial wrapper around StopWatch. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。请注意，measureTime尚未移植，因为它是StopWatch的一个小包装。请参阅&lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="8251e06b859fc1bf7834e47982a51786233d653a" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt;&lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。请参阅&lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt; &lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="3836851ebe09983822b4948475513fd0ffdb5b68" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。请参阅&lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="852cd69a4d8476a6740350b9e4fa04e022f147f2" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime中的旧基准测试功能（使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;）已被弃用。请改用std.datetime.stopwatch中的内容。它使用&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。请参阅&lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; &lt;/a&gt;。该符号将于2018年10月从文档中删除，并于2019年10月从Phobos中完全删除。</target>
        </trans-unit>
        <trans-unit id="e2b766119f4b2cc6bf40fa4a91668ec3bf749415" translate="yes" xml:space="preserve">
          <source>The one area in which this function violates RFC 5322 is that it accepts &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in folding whitespace in the place of &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, because the HTTP spec requires it.</source>
          <target state="translated">此功能违反RFC 5322 的地方是因为HTTP规范要求它在折叠空格中代替 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 接受 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e2e3dd788c39da352fad71950c0b91387508356" translate="yes" xml:space="preserve">
          <source>The one shared instance.</source>
          <target state="translated">的一个共享实例。</target>
        </trans-unit>
        <trans-unit id="c72b10055e71a8b6b107b05c7231e9b97b023ff1" translate="yes" xml:space="preserve">
          <source>The only accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">唯一接受的单位是 &lt;code&gt;&quot;days&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8437a6599312b98a4f8ede285a1950b78c0b6f0d" translate="yes" xml:space="preserve">
          <source>The only operators that can accept operands of type bool are: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt; ! &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;?:&lt;/code&gt;.</source>
          <target state="translated">唯一可以接受bool类型的操作数的运算符是： &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; ！ &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;?:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="984e1c71edfda04f82606405d232f57e26747587" translate="yes" xml:space="preserve">
          <source>The only reason to have a max limit for this is to avoid the risk of a bad server feeding libcurl with a never-ending header that will cause reallocs infinitely</source>
          <target state="translated">设置最大限制的唯一原因是为了避免服务器给libcurl提供一个无休止的头,从而导致reallocs无穷无尽的风险。</target>
        </trans-unit>
        <trans-unit id="6b3469bf6885e1dc5e98c3245a18dbbf237d2baa" translate="yes" xml:space="preserve">
          <source>The opAssign function will be built for a struct &lt;code&gt;S&lt;/code&gt; if the following constraints are met:</source>
          <target state="translated">如果满足以下约束，则将为结构 &lt;code&gt;S&lt;/code&gt; 构建opAssign函数：</target>
        </trans-unit>
        <trans-unit id="7e056906d7315529b66ec021904f0bc134465c13" translate="yes" xml:space="preserve">
          <source>The operand syntax more or less follows the Intel CPU documentation conventions. In particular, the convention is that for two operand instructions the source is the right operand and the destination is the left operand. The syntax differs from that of Intel's in order to be compatible with the D language tokenizer and to simplify parsing.</source>
          <target state="translated">操作数语法或多或少地遵循了英特尔CPU文档的惯例。特别是,约定对于两个操作数指令,源操作数为右操作数,目的操作数为左操作数。为了与D语言tokenizer兼容和简化解析,其语法与Intel的不同。</target>
        </trans-unit>
        <trans-unit id="73d4a21766587b932de571c9748f396e770947d7" translate="yes" xml:space="preserve">
          <source>The operands are AND'd together.</source>
          <target state="translated">操作数是一起AND的。</target>
        </trans-unit>
        <trans-unit id="8d68364ecd5a5efc98bbefe2167cf9e02f879955" translate="yes" xml:space="preserve">
          <source>The operands are OR'd together.</source>
          <target state="translated">操作数是一起OR的。</target>
        </trans-unit>
        <trans-unit id="164b0a5deb7171b65940816115319c8c761747b7" translate="yes" xml:space="preserve">
          <source>The operands are XOR'd together.</source>
          <target state="translated">操作数是一起XOR的。</target>
        </trans-unit>
        <trans-unit id="efb02cff4c27dc22b01308f5fbd88aaf28eb4b20" translate="yes" xml:space="preserve">
          <source>The operands must be arithmetic types. They undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">操作数必须是算术类型。他们经历了&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常的算术转换&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d66ba90561dbdef784a715ae4ab9b7cee0e0776" translate="yes" xml:space="preserve">
          <source>The operands must be integral types, and undergo the &lt;a href=&quot;type#integer-promotions&quot;&gt;Integer Promotions&lt;/a&gt;. The result type is the type of the left operand after the promotions. The result value is the result of shifting the bits by the right operand's value.</source>
          <target state="translated">操作数必须是整数类型，并且必须经过&lt;a href=&quot;type#integer-promotions&quot;&gt;整数提升&lt;/a&gt;。结果类型是提升后左操作数的类型。结果值是将位移位右操作数的值的结果。</target>
        </trans-unit>
        <trans-unit id="194f20d5a432fe368709d99fb1ac7743c7e38bcc" translate="yes" xml:space="preserve">
          <source>The operation takes time proportional to the number of adjacent free blocks at the front of the free list. These blocks get coalesced, whether &lt;code&gt;allocateAll&lt;/code&gt; succeeds or fails due to fragmentation.</source>
          <target state="translated">该操作花费的时间与空闲列表前面的相邻空闲块的数量成正比。这些块将合并，无论是由于碎片， &lt;code&gt;allocateAll&lt;/code&gt; 是成功还是失败。</target>
        </trans-unit>
        <trans-unit id="f1c4e404ec78b75726373485d13f7546b584f7c2" translate="yes" xml:space="preserve">
          <source>The operator involved</source>
          <target state="translated">所涉经营者</target>
        </trans-unit>
        <trans-unit id="56d4f8f0aeb6a713fa59381e88345eb1ab065529" translate="yes" xml:space="preserve">
          <source>The operator involved (without the &lt;code&gt;&quot;=&quot;&lt;/code&gt;, e.g. &lt;code&gt;&quot;+&quot;&lt;/code&gt; for &lt;code&gt;&quot;+=&quot;&lt;/code&gt; etc)</source>
          <target state="translated">所涉及的运算符（不带 &lt;code&gt;&quot;=&quot;&lt;/code&gt; ，例如， &lt;code&gt;&quot;+&quot;&lt;/code&gt; 代表 &lt;code&gt;&quot;+=&quot;&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="141e2b7ce22914ac93e27f77aab194720297a6c0" translate="yes" xml:space="preserve">
          <source>The operator involved in the &lt;code&gt;opAssign&lt;/code&gt; operation</source>
          <target state="translated">参与 &lt;code&gt;opAssign&lt;/code&gt; 操作的操作员</target>
        </trans-unit>
        <trans-unit id="c70edf6dccf2f2bcea3add3cefb68aaf253c7966" translate="yes" xml:space="preserve">
          <source>The operator symbol</source>
          <target state="translated">操作符号</target>
        </trans-unit>
        <trans-unit id="a647036ebf74c7864e90900632a3906ffefe590e" translate="yes" xml:space="preserve">
          <source>The operator symbol (without the &lt;code&gt;=&lt;/code&gt;)</source>
          <target state="translated">运算符（不带 &lt;code&gt;=&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e53e52b5f08d1bbd687148f6992aae7c464c1b9d" translate="yes" xml:space="preserve">
          <source>The operator, e.g. &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">操作员，例如 &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="638907907a566c0abcca8d70105d1f419f1a935d" translate="yes" xml:space="preserve">
          <source>The option &quot;--Foo&quot; is rejected due to &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt;, but not &quot;--Bar&quot;, &quot;--bAr&quot; etc. because the directive &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; turned sensitivity off before option &quot;bar&quot; was parsed.</source>
          <target state="translated">选项&amp;ldquo; --Foo&amp;rdquo;由于 &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt; 而被拒绝，但由于&amp;ldquo; --Bar&amp;rdquo;，&amp;ldquo;-bAr&amp;rdquo;等原因而被拒绝，因为伪指令 &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; 在选项&amp;ldquo;之前关闭了灵敏度&amp;rdquo;栏&amp;rdquo;被解析。</target>
        </trans-unit>
        <trans-unit id="ca52d0f89f2c76dbc26910f2e62e7d1ae6cb85b2" translate="yes" xml:space="preserve">
          <source>The option character (default '-').</source>
          <target state="translated">选项字符(默认为'-')。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">可选的</target>
        </trans-unit>
        <trans-unit id="2c9d42a79cf23316432c06818064db7b0873ce86" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; may be used to assign arbitrary &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; objects as the standard input, output and error streams, respectively, of the child process. The former must be opened for reading, while the latter two must be opened for writing. The default is for the child process to inherit the standard streams of its parent.</source>
          <target state="translated">可选参数 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 可用于将任意&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;对象分配为子进程的标准输入，输出和错误流。前者必须开放供阅读，而后两者必须开放供写作。子进程的默认设置是继承其父进程的标准流。</target>
        </trans-unit>
        <trans-unit id="fa35856038ac4a3b33d6b7f25cf0f4d58ca154fb" translate="yes" xml:space="preserve">
          <source>The optional identifier in either type of &lt;code&gt;out&lt;/code&gt; contract is set to the return value of the function.</source>
          <target state="translated">两种类型的 &lt;code&gt;out&lt;/code&gt; 合同中的可选标识符都设置为函数的返回值。</target>
        </trans-unit>
        <trans-unit id="2a198d0d9bb81399553ce901d094fc3b34485c1e" translate="yes" xml:space="preserve">
          <source>The optional parameters &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt; are meant for avoiding duplicate computation. Many applications may have already computed &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; and/or &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt;. In that case, they can be passed as &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt;, respectively.</source>
          <target state="translated">可选参数 &lt;code&gt;sSelfSim&lt;/code&gt; 和 &lt;code&gt;tSelfSim&lt;/code&gt; 用于避免重复计算。许多应用程序可能已经计算了 &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; 和/或 &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt; 。在这种情况下，它们可以分别作为 &lt;code&gt;sSelfSim&lt;/code&gt; 和 &lt;code&gt;tSelfSim&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="5c87a0f28ba13b43a3c29d6c4b297e44986adfc3" translate="yes" xml:space="preserve">
          <source>The optional second &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; can be used to supply additional information, such as a text string, that will be printed out along with the error diagnostic.</source>
          <target state="translated">可选的第二个&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;可用于提供其他信息，例如文本字符串，这些信息将与错误诊断一起打印出来。</target>
        </trans-unit>
        <trans-unit id="c53af2790b7d2658a475ec200743c6decbbbabb1" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;minSize == unbounded&lt;/code&gt; and &lt;code&gt;maxSize == unbounded&lt;/code&gt; are not available for &lt;code&gt;ContiguousFreeList&lt;/code&gt;.</source>
          <target state="translated">选项 &lt;code&gt;minSize == unbounded&lt;/code&gt; 和 &lt;code&gt;maxSize == unbounded&lt;/code&gt; 不适用于 &lt;code&gt;ContiguousFreeList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="908f73a8a6b26eae214ea14d01c95ac8e585a696" translate="yes" xml:space="preserve">
          <source>The options corresponding to the statistics collected.</source>
          <target state="translated">与所收集的统计数据相对应的选项。</target>
        </trans-unit>
        <trans-unit id="9f44bfb42bea099b410e3ae043b64bf941a3d3a9" translate="yes" xml:space="preserve">
          <source>The order in which</source>
          <target state="translated">顺序</target>
        </trans-unit>
        <trans-unit id="b05eb5dee9e8e5735c1321572abe7fba26d328c8" translate="yes" xml:space="preserve">
          <source>The order in which modules are called to run their unit tests.</source>
          <target state="translated">调用模块运行单元测试的顺序。</target>
        </trans-unit>
        <trans-unit id="ded62be1138c956a50d03fffedad7ec44e6f9533" translate="yes" xml:space="preserve">
          <source>The order in which modules are imported does not affect the semantics.</source>
          <target state="translated">模块导入的顺序不影响语义。</target>
        </trans-unit>
        <trans-unit id="506073a2cdf721a37f43310020509dea0ea03bee" translate="yes" xml:space="preserve">
          <source>The order in which the array elements are computed is implementation defined, and may even occur in parallel. An application must not depend on this order.</source>
          <target state="translated">数组元素的计算顺序是由实现定义的,甚至可以并行进行。应用程序不能依赖于这个顺序。</target>
        </trans-unit>
        <trans-unit id="fae272dd73f8d57ce9c199e28861d6ffb1d9af6c" translate="yes" xml:space="preserve">
          <source>The order in which the strings appear in the result is not defined.</source>
          <target state="translated">结果中字符串出现的顺序没有定义。</target>
        </trans-unit>
        <trans-unit id="ce7e17de4cb24469d3444a40e36096efcb9cbfd4" translate="yes" xml:space="preserve">
          <source>The order is defined as follows:</source>
          <target state="translated">顺序定义如下:</target>
        </trans-unit>
        <trans-unit id="29a373653e2bfc1cca0d961f259da0c1298ecbea" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments for functions with linkage other than &lt;code&gt;extern (D)&lt;/code&gt;.</source>
          <target state="translated">具有除 &lt;code&gt;extern (D)&lt;/code&gt; 以外的链接的函数的函数自变量的求值顺序。</target>
        </trans-unit>
        <trans-unit id="a021fc1e222d6a27aea27e4b5f97128841b9a128" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;操作数的&lt;i&gt;求值顺序&lt;/i&gt;。</target>
        </trans-unit>
        <trans-unit id="2d093662468f96c13ae9c5b9d6116c7cabff1635" translate="yes" xml:space="preserve">
          <source>The order of execution within a function is controlled by &lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statement&lt;/i&gt;&lt;/a&gt;s. A function's body consists of a sequence of zero or more</source>
          <target state="translated">函数中的执行顺序由&lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statements&lt;/i&gt;&lt;/a&gt;控制。函数的主体由零个或多个序列组成</target>
        </trans-unit>
        <trans-unit id="86b67a2b0c6a048e601645470c096d4bbf2604b6" translate="yes" xml:space="preserve">
          <source>The order of static initialization is implicitly determined by the</source>
          <target state="translated">静态初始化的顺序隐含在由</target>
        </trans-unit>
        <trans-unit id="24e23dd7191b5b1c5bce0de2b67d0f3911ebed53" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum) element.</source>
          <target state="translated">用于确定极限(最小或最大)元素的排序谓词。</target>
        </trans-unit>
        <trans-unit id="15fe5b10e5755a86213c0dc1ab135ad913a77ba2" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum).</source>
          <target state="translated">用于确定极限值(最小或最大)的排序谓词。</target>
        </trans-unit>
        <trans-unit id="15cad23161bf9aec9c429568dd291ae988b53252" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the maximum element.</source>
          <target state="translated">用于确定最大元素的排序谓词。</target>
        </trans-unit>
        <trans-unit id="c31f591c19316494ae227e4269b1bc55d8071c12" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the minimum element.</source>
          <target state="translated">用来确定最小元素的排序谓词。</target>
        </trans-unit>
        <trans-unit id="c29760283ce7793aa4d7bc71616456fe1b03fbb5" translate="yes" xml:space="preserve">
          <source>The ordering to be used to determine lexicographical ordering of the permutations.</source>
          <target state="translated">用来确定排列组合的词性顺序。</target>
        </trans-unit>
        <trans-unit id="e1d7ba6a0bf70661c8825f1616095c8946712ba1" translate="yes" xml:space="preserve">
          <source>The original input string which should have been parsed.</source>
          <target state="translated">应该被解析的原始输入字符串。</target>
        </trans-unit>
        <trans-unit id="d69e475dd9b96313d02abbca4307d1659af41d28" translate="yes" xml:space="preserve">
          <source>The original range.</source>
          <target state="translated">原来的范围。</target>
        </trans-unit>
        <trans-unit id="8724db772d60fec4013f34182f1e847ecec76068" translate="yes" xml:space="preserve">
          <source>The original string.</source>
          <target state="translated">原来的字符串。</target>
        </trans-unit>
        <trans-unit id="2c0e83de5dd344b677213345fa51e9db2eed3ab8" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ClockType&lt;/code&gt;s are provided so that other clocks provided by the underlying C, system calls can be used with &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; without having to use the C API directly.</source>
          <target state="translated">提供了其他 &lt;code&gt;ClockType&lt;/code&gt; ，以便底层C，系统调用提供的其他时钟可以与&lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; 一起使用，而不必直接使用C API。</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">产出是:</target>
        </trans-unit>
        <trans-unit id="a69373623c7518d00fa36ea24366f398f8ce8bad" translate="yes" xml:space="preserve">
          <source>The output of the code above is:</source>
          <target state="translated">上述代码的输出是:</target>
        </trans-unit>
        <trans-unit id="515b77d0f9f95e74d1d9b053ac5339be1c82aca5" translate="yes" xml:space="preserve">
          <source>The output range used to write the help information.</source>
          <target state="translated">用于编写帮助信息的输出范围。</target>
        </trans-unit>
        <trans-unit id="708e6e32f4bb4d910b35568c24af1ecbdd8ae5b7" translate="yes" xml:space="preserve">
          <source>The overflow indicator (assigned &lt;code&gt;true&lt;/code&gt; in case there's an error)</source>
          <target state="translated">溢出指示器（如果有错误，则分配为 &lt;code&gt;true&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="49d360d20fd79e75a1f6f41c1f5efdbc589a5b18" translate="yes" xml:space="preserve">
          <source>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end.</source>
          <target state="translated">溢出是粘性的,也就是说可以进行一系列的操作,只需要在最后检查溢出即可。</target>
        </trans-unit>
        <trans-unit id="ef93ac8e948c5ada2f00084b4ec036473c66f367" translate="yes" xml:space="preserve">
          <source>The overlapping portion of the two arrays.</source>
          <target state="translated">两个阵列的重叠部分。</target>
        </trans-unit>
        <trans-unit id="fae150090ecb0366b43d58bfc4a6f3010da8d11c" translate="yes" xml:space="preserve">
          <source>The overload which accepts function arguments takes integral types in the order that the time unit strings were given, and those integers are passed by &lt;code&gt;ref&lt;/code&gt;. split assigns the values for the units to each corresponding integer. Any integral type may be used, but no attempt is made to prevent integer overflow, so don't use small integral types in circumstances where the values for those units aren't likely to fit in an integral type that small.</source>
          <target state="translated">接受函数参数的重载按时间单位字符串给出的顺序采用整数类型，这些整数由 &lt;code&gt;ref&lt;/code&gt; 传递。split将单位的值分配给每个对应的整数。可以使用任何整数类型，但是不会尝试防止整数溢出，因此，在那些单位的值不太可能适合这么小的整数类型的情况下，请不要使用较小的整数类型。</target>
        </trans-unit>
        <trans-unit id="8a27d36415963d11bb0a2a74d725380e58b5b81a" translate="yes" xml:space="preserve">
          <source>The overload with no arguments returns the values for the units in a struct with members whose names are the same as the given time unit strings. The members are all &lt;code&gt;long&lt;/code&gt;s. This overload will also work with no time strings being given, in which case</source>
          <target state="translated">没有参数的重载将返回结构中具有其名称与给定时间单位字符串相同的成员的单位的值。成员都是 &lt;code&gt;long&lt;/code&gt; 的。在没有给出时间字符串的情况下，这种重载也可以工作，在这种情况下</target>
        </trans-unit>
        <trans-unit id="260af145e3cbda28a26f16fe1989f4e1c8d1a0d0" translate="yes" xml:space="preserve">
          <source>The package module can then be imported with the standard module import declaration:</source>
          <target state="translated">然后可以用标准的模块导入声明导入包模块。</target>
        </trans-unit>
        <trans-unit id="5512330e5fcd74efc6dbc5aca616099f51685035" translate="yes" xml:space="preserve">
          <source>The package module must have the file name &lt;code&gt;package.d&lt;/code&gt;. The module name is declared to be the fully qualified name of the package. Package modules can be imported just like any other modules:</source>
          <target state="translated">软件包模块必须具有文件名 &lt;code&gt;package.d&lt;/code&gt; 。模块名称被声明为软件包的标准名称。包模块可以像其他模块一样导入：</target>
        </trans-unit>
        <trans-unit id="136770d3c4f96881a7cd83ac52b3b200de071989" translate="yes" xml:space="preserve">
          <source>The padding data can be accessed, but its contents are undefined.</source>
          <target state="translated">可以访问padding数据,但其内容未定义。</target>
        </trans-unit>
        <trans-unit id="c23637ad29e92d690ee7e91ffa4bbac52dae1105" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;level&lt;/code&gt; indicates the number of trie levels to use, allowed values are: 1, 2, 3 or 4. Levels represent different trade-offs speed-size wise.</source>
          <target state="translated">参数 &lt;code&gt;level&lt;/code&gt; 指示要使用的特里级别的数量，允许的值为：1、2、3或4。级别表示不同的权衡速度大小明智的选择。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
