<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="7f3ea7f5b668b927908903c59ab3b69fcb5af861" translate="yes" xml:space="preserve">
          <source>The stack size for this fiber.</source>
          <target state="translated">该光纤的堆栈尺寸。</target>
        </trans-unit>
        <trans-unit id="d77b689dcb1ab13845e33f5ac0d239d2be984a77" translate="yes" xml:space="preserve">
          <source>The stack size for this thread.</source>
          <target state="translated">本线程的堆栈大小。</target>
        </trans-unit>
        <trans-unit id="1902c662d9b13b82fe81369d128dde4e10ffcdaa" translate="yes" xml:space="preserve">
          <source>The stack trace of where the error happened. This is an opaque object that can either be converted to &lt;code&gt;string&lt;/code&gt;, or iterated over with &lt;code&gt; foreach&lt;/code&gt; to extract the items in the stack trace (as strings).</source>
          <target state="translated">错误发生位置的堆栈跟踪。这是一个不透明的对象，可以将其转换为 &lt;code&gt;string&lt;/code&gt; ，或者使用 &lt;code&gt; foreach&lt;/code&gt; 进行迭代以提取堆栈跟踪中的项（作为字符串）。</target>
        </trans-unit>
        <trans-unit id="9f20dc3ac3213d71596e365d3a32376deda65355" translate="yes" xml:space="preserve">
          <source>The stack variables referenced by a nested function are still valid even after the function exits (this is different from D 1.0). This is called a</source>
          <target state="translated">嵌套函数引用的堆栈变量即使在函数退出后仍然有效(这与D 1.0不同)。这就是所谓的</target>
        </trans-unit>
        <trans-unit id="813353f101357b03d0b61c073a4c5ccf1975eaf3" translate="yes" xml:space="preserve">
          <source>The standard HTTP methods : &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616 Section 5.1.1&lt;/a&gt;</source>
          <target state="translated">标准的HTTP方法：&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot;&gt;RFC2616第5.1.1节&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5be2cd87a2b0f4860fcc1853c1fefdfb3d5a3f6e" translate="yes" xml:space="preserve">
          <source>The standard error stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's error stream.</source>
          <target state="translated">子进程的标准错误流。这可以是打开以进行写入的任何&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;。默认情况下，子进程继承父进程的错误流。</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">标准误差流。</target>
        </trans-unit>
        <trans-unit id="28e8c3771deea57b1287ddecdda74142b64d7ee8" translate="yes" xml:space="preserve">
          <source>The standard input stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for reading. By default the child process inherits the parent's input stream.</source>
          <target state="translated">子进程的标准输入流。这可以是打开以读取的任何&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;。默认情况下，子进程继承父进程的输入流。</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">标准输入流。</target>
        </trans-unit>
        <trans-unit id="7f5d48c8b0f2de69f4c747237a77a2d1bfba7b08" translate="yes" xml:space="preserve">
          <source>The standard library lends a hand for comparing strings with mixed encodings (by transparently decoding, see &lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt;&lt;code&gt;std.algorithm.cmp&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;case-insensitive comparison&lt;/a&gt; and &lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;normalization&lt;/a&gt;.</source>
          <target state="translated">标准库有助于比较混合编码的字符串（通过透明解码，请参见&lt;a href=&quot;https://dlang.org/phobos/std_algorithm.html#cmp&quot;&gt; &lt;code&gt;std.algorithm.cmp&lt;/code&gt; &lt;/a&gt;），&lt;a href=&quot;https://dlang.org/phobos/std_uni.html#icmp&quot;&gt;不区分大小写的比较&lt;/a&gt;和&lt;a href=&quot;https://dlang.org/phobos/std_uni.html#normalize&quot;&gt;规范化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d461322cb73ba656cc10ee6e78ac236193d95ae6" translate="yes" xml:space="preserve">
          <source>The standard output stream of the child process. This can be any &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; that is opened for writing. By default the child process inherits the parent's output stream.</source>
          <target state="translated">子进程的标准输出流。这可以是打开以进行写入的任何&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt;。默认情况下，子进程继承父进程的输出流。</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">标准输出流。</target>
        </trans-unit>
        <trans-unit id="21e7fda428c2c6b1ed80304e44601e7fae93a662" translate="yes" xml:space="preserve">
          <source>The start tag of the element</source>
          <target state="translated">元素的起始标签</target>
        </trans-unit>
        <trans-unit id="e872d9d6a6689ad057f6c088df86c8dbaa1e7c70" translate="yes" xml:space="preserve">
          <source>The starting point of the interval. It is included in the interval.</source>
          <target state="translated">区间的起点。它包括在区间内。</target>
        </trans-unit>
        <trans-unit id="3554fc05aa3ab3a9ddf7ec9973a0bf7f4072e5a0" translate="yes" xml:space="preserve">
          <source>The starting value.</source>
          <target state="translated">起始值;</target>
        </trans-unit>
        <trans-unit id="a84bd1411e0ff3c732833affc83038a36b88c2e4" translate="yes" xml:space="preserve">
          <source>The state of the sequence is stored as a &lt;code&gt;Tuple&lt;/code&gt; so it can be heterogeneous.</source>
          <target state="translated">序列的状态存储为 &lt;code&gt;Tuple&lt;/code&gt; 因此它可以是异构的。</target>
        </trans-unit>
        <trans-unit id="a8013cbe10851e46bc860bd1d31ef9871f35e223" translate="yes" xml:space="preserve">
          <source>The state of this fiber as an enumerated value.</source>
          <target state="translated">该光纤的状态为一个枚举值。</target>
        </trans-unit>
        <trans-unit id="debdb4248e291669b86fe314e231ec5f465f64cb" translate="yes" xml:space="preserve">
          <source>The std time to convert.</source>
          <target state="translated">转换的标准时间。</target>
        </trans-unit>
        <trans-unit id="e0b383e1171d8d015f97f2490da3a859a852e7d9" translate="yes" xml:space="preserve">
          <source>The stored &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">存储的 &lt;code&gt;Logger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d23198b78726b12c064950153015ab0cde6faecb" translate="yes" xml:space="preserve">
          <source>The strategy for finding the next available block is first fit.</source>
          <target state="translated">寻找下一个可用区块的策略是先配合。</target>
        </trans-unit>
        <trans-unit id="c2420fb1448496dbbd08ceea8e09dc60562adfb8" translate="yes" xml:space="preserve">
          <source>The stream to pass to INTERLEAVEFUNCTION.</source>
          <target state="translated">要传递给INTERLEAVEFUNCTION的流。</target>
        </trans-unit>
        <trans-unit id="18822dcb8b0bc3c64136bcaebcbf45df0cd6a713" translate="yes" xml:space="preserve">
          <source>The string</source>
          <target state="translated">字符串</target>
        </trans-unit>
        <trans-unit id="e64ff94f3ecfd8fab9d37892f66980e617d6433b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;command&lt;/code&gt; is passed verbatim to the shell, and is therefore subject to its rules about command structure, argument/filename quoting and escaping of special characters. The path to the shell executable defaults to &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;command&lt;/code&gt; 是逐字传递到外壳程序的，因此要遵守其有关命令结构，参数/文件名引号和特殊字符转义的规则。Shell可执行文件的路径默认为&lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="601595000f8c78875086bc48ab40c9c94bc17a1c" translate="yes" xml:space="preserve">
          <source>The string arguments must only contain valid characters for C++ name mangling which currently include alphanumerics and the underscore character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf86f45ac17363df2917e94c577fdefa4162b88" translate="yes" xml:space="preserve">
          <source>The string indicating which characters to replace and what to replace them with. It is generated by &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串，指示要替换的字符以及替换的字符。它由&lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; &lt;/a&gt;生成。</target>
        </trans-unit>
        <trans-unit id="f0533873999a54cfe4dbbd386fac2585e64d8e51" translate="yes" xml:space="preserve">
          <source>The string is meant to be human readable, not machine parseable (e.g. whether there is an &lt;code&gt;'s'&lt;/code&gt; on the end of the unit name usually depends on whether it's plural or not, and empty units are not included unless the Duration is &lt;code&gt;zero&lt;/code&gt;). Any code needing a specific string format should use &lt;code&gt;total&lt;/code&gt; or &lt;code&gt;split&lt;/code&gt; to get the units needed to create the desired string format and create the string itself.</source>
          <target state="translated">该字符串应是人类可读的，而不是机器可解析的（例如，单元名称末尾是否带有 &lt;code&gt;'s'&lt;/code&gt; 通常取决于其是否为复数形式，并且除非Duration &lt;code&gt;zero&lt;/code&gt; 否则不包括空单元）。任何需要特定字符串格式的代码都应使用 &lt;code&gt;total&lt;/code&gt; 或 &lt;code&gt;split&lt;/code&gt; 来获得创建所需字符串格式和创建字符串本身所需的单位。</target>
        </trans-unit>
        <trans-unit id="2bd07e9629d13f3f409b884d3ffac3a7eb0da845" translate="yes" xml:space="preserve">
          <source>The string literal specifies a linker directive to be embedded in the generated object file.</source>
          <target state="translated">字符串指定要嵌入到生成的对象文件中的链接器指令。</target>
        </trans-unit>
        <trans-unit id="32d9e6c3c8e59228cc1e78ece5ad6aef58df9887" translate="yes" xml:space="preserve">
          <source>The string literals are assembled as UTF-8 char arrays, and the postfix is applied to convert to wchar or dchar as necessary as a final step.</source>
          <target state="translated">字符串被组装成UTF-8字符数组,并在最后一步应用后缀来转换为wchar或dchar。</target>
        </trans-unit>
        <trans-unit id="e1f9801101f016db2a559c014cb349546f881701" translate="yes" xml:space="preserve">
          <source>The string representation of this &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;Tuple&lt;/code&gt; 的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="95ecc1c83a5bc8c9a30b488436872240eb5cf883" translate="yes" xml:space="preserve">
          <source>The string that conventionally marks the end of all options (default '--').</source>
          <target state="translated">习惯上标记所有选项结束的字符串(默认为'--')。</target>
        </trans-unit>
        <trans-unit id="a364f528b991ce1bd157c8e5da1cb5665c7d72c5" translate="yes" xml:space="preserve">
          <source>The string to be decoded</source>
          <target state="translated">要解码的字符串</target>
        </trans-unit>
        <trans-unit id="a6de95ac63fa71760fd1a5b11770046f783a2524" translate="yes" xml:space="preserve">
          <source>The string to be encoded</source>
          <target state="translated">要编码的字符串</target>
        </trans-unit>
        <trans-unit id="e2b9d608f0fe83dbf1e7d9c07afcec863203911e" translate="yes" xml:space="preserve">
          <source>The string to capitalize.</source>
          <target state="translated">要大写的字符串。</target>
        </trans-unit>
        <trans-unit id="cf1478823e2820a59dba10485e438b40c5348725" translate="yes" xml:space="preserve">
          <source>The string to center</source>
          <target state="translated">绳子对中</target>
        </trans-unit>
        <trans-unit id="2e9ccd0a631efea8fdc72a8c62875a331c029bd3" translate="yes" xml:space="preserve">
          <source>The string to demangle.</source>
          <target state="translated">要解开的绳子。</target>
        </trans-unit>
        <trans-unit id="b67968a1752f9ee5eb2c12fda8191f64a6136ec4" translate="yes" xml:space="preserve">
          <source>The string to parse</source>
          <target state="translated">要解析的字符串</target>
        </trans-unit>
        <trans-unit id="5681bac273a271a57db9a94a9ee8c1380568e850" translate="yes" xml:space="preserve">
          <source>The string to return the representation of.</source>
          <target state="translated">返回表示的字符串。</target>
        </trans-unit>
        <trans-unit id="6f72b4c4ff92e79f46043b6ac90fd712bc168dfd" translate="yes" xml:space="preserve">
          <source>The string used to separate the elements of an array or associative array (default is &quot;&quot; which means the elements are separated by whitespace).</source>
          <target state="translated">用于分隔数组或关联数组元素的字符串(默认为&quot;&quot;,表示元素用空格分隔)。</target>
        </trans-unit>
        <trans-unit id="555d16dee4415f5ab0acc21725fda20143e994af" translate="yes" xml:space="preserve">
          <source>The strip group of functions allow stripping of either leading, trailing, or both leading and trailing elements.</source>
          <target state="translated">strip函数组允许对前导元素、尾部元素或前导元素和尾部元素进行剥离。</target>
        </trans-unit>
        <trans-unit id="58b660c2a16b28679d8eef710bda4717a0e26225" translate="yes" xml:space="preserve">
          <source>The structs &lt;code&gt;Yes&lt;/code&gt; and &lt;code&gt;No&lt;/code&gt; are provided as shorthand for &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; and &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; and are preferred for brevity and readability. These convenience structs mean it is usually unnecessary and counterproductive to create an alias of a &lt;code&gt;Flag&lt;/code&gt; as a way of avoiding typing out the full type while specifying the affirmative or negative options.  Passing categorical data by means of unstructured &lt;code&gt;bool&lt;/code&gt; parameters is classified under &quot;simple-data coupling&quot; by Steve McConnell in the &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;Code Complete&lt;/a&gt; book, along with three other kinds of coupling. The author argues citing several studies that coupling has a negative effect on code quality. &lt;code&gt;Flag&lt;/code&gt; offers a simple structuring method for passing yes/no flags to APIs.</source>
          <target state="translated">提供的 &lt;code&gt;Yes&lt;/code&gt; 和 &lt;code&gt;No&lt;/code&gt; 结构是 &lt;code&gt;Flag!&quot;Name&quot;.yes&lt;/code&gt; 和 &lt;code&gt;Flag!&quot;Name&quot;.no&lt;/code&gt; 简写，为简洁起见和可读性，它们是首选。这些便利结构意味着创建 &lt;code&gt;Flag&lt;/code&gt; 的别名通常是不必要的且适得其反，从而避免在指定肯定或否定选项时避免键入完整类型。借助非结构化 &lt;code&gt;bool&lt;/code&gt; 参数传递分类数据，在&amp;ldquo; &lt;a href=&quot;https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8&amp;amp;q=Code%20Complete&quot;&gt;代码完成&amp;rdquo;&lt;/a&gt;书中的史蒂夫&amp;middot;麦康奈尔（Steve McConnell）的&amp;ldquo;简单数据耦合&amp;rdquo;下，与其他三种耦合一起进行了分类。作者引用了几项研究，认为耦合对代码质量有负面影响。 &lt;code&gt;Flag&lt;/code&gt; 提供了一种简单的结构化方法，用于将yes / no标志传递给API。</target>
        </trans-unit>
        <trans-unit id="076392e866b208f90ee610d973e43efceb10e97e" translate="yes" xml:space="preserve">
          <source>The subclass of EncodingScheme to register.</source>
          <target state="translated">要注册的 EncodingScheme 的子类。</target>
        </trans-unit>
        <trans-unit id="c1ed1f004de54db1586dcfe56503caa35fb79f44" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;sizes&lt;/code&gt; must be equal 21.</source>
          <target state="translated">&lt;code&gt;sizes&lt;/code&gt; 总和必须等于21。</target>
        </trans-unit>
        <trans-unit id="789facc231279c33347577b57e2a474fbfbd6abb" translate="yes" xml:space="preserve">
          <source>The sum of all bit lengths in one bitfield instantiation must be exactly 8, 16, 32, or 64. If padding is needed, just allocate one bitfield with an empty name.</source>
          <target state="translated">一个位域实例中所有位长的总和必须正好是8、16、32或64。如果需要填充,只需分配一个空名的位场。</target>
        </trans-unit>
        <trans-unit id="2cfe229a83e79df357cdfd328b79e038bc593b6f" translate="yes" xml:space="preserve">
          <source>The sum of all the elements in the range r.</source>
          <target state="translated">r范围内所有元素的总和。</target>
        </trans-unit>
        <trans-unit id="9be88f8537261298343db1ff319dde4340861d75" translate="yes" xml:space="preserve">
          <source>The supplied code as a delegate.</source>
          <target state="translated">所提供的代码作为一个委托。</target>
        </trans-unit>
        <trans-unit id="63d3a3cda8996c92ecd751aecdc230c95f7170d2" translate="yes" xml:space="preserve">
          <source>The swapping strategy parameter is not implemented yet; currently it is ignored.</source>
          <target state="translated">交换策略参数还没有实现,目前是忽略的。</target>
        </trans-unit>
        <trans-unit id="80b980e073fe362e9683180ed237939256d93352" translate="yes" xml:space="preserve">
          <source>The swapping strategy to employ.</source>
          <target state="translated">要采用的交换策略。</target>
        </trans-unit>
        <trans-unit id="170969e1d0fabb640f8089b36d7401a205bca51c" translate="yes" xml:space="preserve">
          <source>The swapping strategy to use.</source>
          <target state="translated">要使用的交换策略。</target>
        </trans-unit>
        <trans-unit id="98e99ba24a8243b8fd6b17bc749b4554c5b7f75e" translate="yes" xml:space="preserve">
          <source>The swapping strategy.</source>
          <target state="translated">的交换策略。</target>
        </trans-unit>
        <trans-unit id="48042820d83937bec0797943750b58634bf67f60" translate="yes" xml:space="preserve">
          <source>The symbol containing the &lt;code&gt;static foreach&lt;/code&gt; variables.</source>
          <target state="translated">包含 &lt;code&gt;static foreach&lt;/code&gt; 变量的符号。</target>
        </trans-unit>
        <trans-unit id="56e1148f66671625bb0c6990da38dc2d64edea1a" translate="yes" xml:space="preserve">
          <source>The symbol this &lt;code&gt;alias this&lt;/code&gt; resolves to</source>
          <target state="translated">此 &lt;code&gt;alias this&lt;/code&gt; 解析为的符号</target>
        </trans-unit>
        <trans-unit id="dac6f5e28e8cd7e2f90032028de6bb0f0117f4f9" translate="yes" xml:space="preserve">
          <source>The symlink to create. A relative path is relative to the current working directory.</source>
          <target state="translated">要创建的符号链接。相对路径是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="83a33998cfc84a9e39e9f0423cfd7357619092df" translate="yes" xml:space="preserve">
          <source>The synchronization gets released even if</source>
          <target state="translated">同步化被释放,即使</target>
        </trans-unit>
        <trans-unit id="f52720ebc8b4fb3263a1e381206af9d0efeeb0c2" translate="yes" xml:space="preserve">
          <source>The synchronized statement wraps a statement with a mutex to synchronize access among multiple threads.</source>
          <target state="translated">synchronized语句用mutex包装一个语句,以实现多个线程之间的同步访问。</target>
        </trans-unit>
        <trans-unit id="54b1dbc833575883512c8f1664c887a121ae9fd3" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;b&gt;/c/string/&lt;/b&gt;, where &lt;b&gt;c&lt;/b&gt; is either a single character, or multiple characters separated by whitespace or commas, and &lt;b&gt;string&lt;/b&gt; is the replacement text.</source>
          <target state="translated">语法为&lt;b&gt;/ c / string /&lt;/b&gt;，其中&lt;b&gt;c&lt;/b&gt;是单个字符，或由空格或逗号分隔的多个字符，而&lt;b&gt;string&lt;/b&gt;是替换文本。</target>
        </trans-unit>
        <trans-unit id="29a57978120d30d4470e32a4ab4fb731cec2bd76" translate="yes" xml:space="preserve">
          <source>The syntax trees are traversed to declare variables, load symbol tables, assign types, and determine the meaning of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9da9fc28de038f5884f945667be4b8054f95702" translate="yes" xml:space="preserve">
          <source>The syntax trees are traversed to declare variables, load symbol tables, assign types, and in general determine the meaning of the program.</source>
          <target state="translated">语法树的遍历是为了声明变量,加载符号表,分配类型,并在一般情况下确定程序的意义。</target>
        </trans-unit>
        <trans-unit id="fa94a6e6326b720f3ede8ff8d6c4dce16a4fa303" translate="yes" xml:space="preserve">
          <source>The system clock ticks are the ticks of the system clock at the highest precision that the system provides.</source>
          <target state="translated">系统时钟滴数是指系统提供的最高精度的系统时钟的滴数。</target>
        </trans-unit>
        <trans-unit id="5387aa28c9051257b0dae7b093c61c8a7eb3427d" translate="yes" xml:space="preserve">
          <source>The system-provided garbage-collector allocator. This should be the default fallback allocator tapping into system memory. It offers manual &lt;code&gt;free&lt;/code&gt; and dutifully collects litter.</source>
          <target state="translated">系统提供的垃圾收集器分配器。这应该是进入系统内存的默认后备分配器。它提供 &lt;code&gt;free&lt;/code&gt; 手册，忠实地收集垃圾。</target>
        </trans-unit>
        <trans-unit id="ec81049f6e21b9ea49ff325809160b315623cf2d" translate="yes" xml:space="preserve">
          <source>The table below gives a synopsis of predefined allocator building blocks, with their respective modules. Either &lt;code&gt;import&lt;/code&gt; the needed modules individually, or &lt;code&gt;import&lt;/code&gt;&lt;code&gt;std.experimental.building_blocks&lt;/code&gt;, which imports them all &lt;code&gt;public&lt;/code&gt;ly. The building blocks can be assembled in unbounded ways and also combined with your own. For a collection of typical and useful preassembled allocators and for inspiration in defining more such assemblies, refer to &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt;&lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下表概述了预定义的分配器构建块及其各自的模块。可以单独 &lt;code&gt;import&lt;/code&gt; 所需的模块，也可以 &lt;code&gt;import&lt;/code&gt; &lt;code&gt;std.experimental.building_blocks&lt;/code&gt; ，然后将其全部 &lt;code&gt;public&lt;/code&gt; 导入。这些构建块可以以无限制的方式组装，也可以与您自己的组装在一起。有关典型和有用的预组装分配器的集合，以及对定义更多此类组装的启发，请参阅&lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt; &lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d173662a2aa058963145fe71e5e20907062a55be" translate="yes" xml:space="preserve">
          <source>The target hardware does not have a floating point unit</source>
          <target state="translated">目标硬件没有浮点单位。</target>
        </trans-unit>
        <trans-unit id="c5cdb1793dc5882606089de2cbe88b09e1226416" translate="yes" xml:space="preserve">
          <source>The target hardware has a floating point unit</source>
          <target state="translated">目标硬件有一个浮点单元</target>
        </trans-unit>
        <trans-unit id="b0979a69d6f3a7dae7324755cd1aa56f216e319b" translate="yes" xml:space="preserve">
          <source>The target object</source>
          <target state="translated">目标对象</target>
        </trans-unit>
        <trans-unit id="0b824dcd9bca9b5db9480c831c6a63d26770ea48" translate="yes" xml:space="preserve">
          <source>The target of the search. Must be an input range. If any of &lt;code&gt;needles&lt;/code&gt; is a range with elements comparable to elements in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; such that the search can backtrack.</source>
          <target state="translated">搜索的目标。必须是输入范围。如果任何一个 &lt;code&gt;needles&lt;/code&gt; 具有与 &lt;code&gt;haystack&lt;/code&gt; 中的元素可比的元素的范围，则 &lt;code&gt;haystack&lt;/code&gt; 必须为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;向前范围&lt;/a&gt;，以便搜索可以回溯。</target>
        </trans-unit>
        <trans-unit id="1bfc030365108c10d6974605e9bd398b8361c092" translate="yes" xml:space="preserve">
          <source>The target range to copy common elements to.</source>
          <target state="translated">要复制常用元素的目标范围。</target>
        </trans-unit>
        <trans-unit id="829e896e39b70090cbc3b2de79f25fe9335f1b77" translate="yes" xml:space="preserve">
          <source>The target range.</source>
          <target state="translated">靶场。</target>
        </trans-unit>
        <trans-unit id="23350db16fa1f3e6288ccb87e5a181ba79379e10" translate="yes" xml:space="preserve">
          <source>The target supports interfacing with Objective-C</source>
          <target state="translated">目标支持与Objective-C的接口</target>
        </trans-unit>
        <trans-unit id="eac1bff04784409ef03a30482f19ef41091d6414" translate="yes" xml:space="preserve">
          <source>The target type in the conversion or comparison</source>
          <target state="translated">转换或比较中的目标类型</target>
        </trans-unit>
        <trans-unit id="390654f1dbf50ff204a2f1fd9ed2609258c428a9" translate="yes" xml:space="preserve">
          <source>The target type of the cast</source>
          <target state="translated">投放的目标类型</target>
        </trans-unit>
        <trans-unit id="5431c3bccb7e8fdc6dc54d831207394bad385ccd" translate="yes" xml:space="preserve">
          <source>The target variable.</source>
          <target state="translated">目标变量。</target>
        </trans-unit>
        <trans-unit id="b71a4a76d74bf9f8e3d2c97011ae3038c9fc6fff" translate="yes" xml:space="preserve">
          <source>The technical term 'Special Functions' includes several families of transcendental functions, which have important applications in particular branches of mathematics and physics.</source>
          <target state="translated">技术术语 &quot;特殊函数 &quot;包括几个超函数族,它们在数学和物理学的特殊分支中有着重要的应用。</target>
        </trans-unit>
        <trans-unit id="2b45d76d889fde617363950e6293b054095035b5" translate="yes" xml:space="preserve">
          <source>The template API is slightly more efficient. It does not have to allocate memory dynamically, all memory is allocated on the stack. The OOP API has to allocate in the finish method if no buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate, but the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; classes still have to be created using &lt;code&gt;new&lt;/code&gt; which allocates them using the GC.  The OOP API is useful to change the digest function and/or digest backend at 'runtime'. The benefit here is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.  If just one specific digest type and backend is needed, the template API is usually a good fit. In this simplest case, the template API can even be used without templates: Just use the &quot;&lt;b&gt;x&lt;/b&gt;&quot; structs directly.</source>
          <target state="translated">模板API效率更高。它不必动态分配内存，所有内存都分配在堆栈上。如果未提供缓冲区，则OOP API必须在finish方法中进行分配。如果为OOP API finish函数提供缓冲区，则不会分配缓冲区，但是&lt;a href=&quot;#Digest&quot;&gt; &lt;code&gt;Digest&lt;/code&gt; &lt;/a&gt;类仍必须使用 &lt;code&gt;new&lt;/code&gt; 创建，后者使用GC对其进行分配。 OOP API可用于在&amp;ldquo;运行时&amp;rdquo;更改摘要功能和/或摘要后端。这样做的好处是，例如Phobos MD5Digest和OpenSSLMD5Digest实现的切换与ABI兼容。如果仅需要一种特定的摘要类型和后端，则通常适合使用模板API。在这种最简单的情况下，甚至可以在不使用模板的情况下使用模板API：只需使用&amp;ldquo; &lt;b&gt;x&lt;/b&gt;&amp;rdquo;直接构建。</target>
        </trans-unit>
        <trans-unit id="408001ca506523fa6af663497d5def923a607239" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;. If asking for &lt;code&gt;char&lt;/code&gt;, content will be converted from the connection character set (specified in HTTP response headers or FTP connection properties, both ISO-8859-1 by default) to UTF-8.</source>
          <target state="translated">模板参数 &lt;code&gt;T&lt;/code&gt; 指定要返回的类型。可能的值为 &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;ubyte&lt;/code&gt; ,以返回 &lt;code&gt;char[]&lt;/code&gt; 或 &lt;code&gt;ubyte[]&lt;/code&gt; 。如果要求 &lt;code&gt;char&lt;/code&gt; ，内容将从连接字符集（在HTTP响应标头或FTP连接属性中指定，默认情况下均为ISO-8859-1）转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="3d301625295a49a8e01e8072c1823836d6260302" translate="yes" xml:space="preserve">
          <source>The template picked to instantiate is the one that is most specialized that fits the types of the</source>
          <target state="translated">挑选实例化的模板是最专业的,符合类型的模板。</target>
        </trans-unit>
        <trans-unit id="02b51510e4339a80ea7cc2a65d41d079d75e78b8" translate="yes" xml:space="preserve">
          <source>The template to instantiate.</source>
          <target state="translated">要实例化的模板。</target>
        </trans-unit>
        <trans-unit id="e41f924354ea35f5712eb828813900cd1d5f4161" translate="yes" xml:space="preserve">
          <source>The term and concept of a 'critical region' comes from &lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;Mono's SGen garbage collector&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;关键区域&amp;rdquo;的术语和概念来自&lt;a href=&quot;https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925&quot;&gt;Mono的SGen垃圾收集器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efe68f5f28809042f03e04ab3e7e40904902798b" translate="yes" xml:space="preserve">
          <source>The tested value</source>
          <target state="translated">测试值</target>
        </trans-unit>
        <trans-unit id="836717195b2e4f6e650af52f82b03152a0dc0a7a" translate="yes" xml:space="preserve">
          <source>The text from &lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;</source>
          <target state="translated">来自&lt;a href=&quot;http://unicode.org/cldr/data/common/supplemental/windowsZones.xml&quot;&gt;windowsZones.xml&lt;/a&gt;的文本</target>
        </trans-unit>
        <trans-unit id="459f3d558c2480422a70a7a05484244d80510d43" translate="yes" xml:space="preserve">
          <source>The text to print at the beginning of the help output.</source>
          <target state="translated">在帮助输出的开头要打印的文字。</target>
        </trans-unit>
        <trans-unit id="b43a60a00dd34982ab5b9431db8979ee331c8fcd" translate="yes" xml:space="preserve">
          <source>The text to printed at the beginning of the help output.</source>
          <target state="translated">在帮助输出的开头打印的文字。</target>
        </trans-unit>
        <trans-unit id="f99eb9686d85d18418cbec2f3108af60157b8372" translate="yes" xml:space="preserve">
          <source>The third form, &lt;code&gt;goto case;&lt;/code&gt;, transfers to the next &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">第三种形式， &lt;code&gt;goto case;&lt;/code&gt; ，转移到下一&lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;最内包围的&lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d93a13c865f0a3f12bf9f0bb2248b62195335a7" translate="yes" xml:space="preserve">
          <source>The third version counts the elements for which &lt;code&gt;pred(x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">第三个版本计算 &lt;code&gt;pred(x)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的元素。执行 &lt;code&gt;pred&lt;/code&gt; 的 &amp;Omicron;（ &lt;code&gt;haystack.length&lt;/code&gt; ）个评估。</target>
        </trans-unit>
        <trans-unit id="a7f1a71c5e73a907487dd15adada9e34f7e659b3" translate="yes" xml:space="preserve">
          <source>The thread function.</source>
          <target state="translated">线程功能。</target>
        </trans-unit>
        <trans-unit id="3959bc13b481b7efab32161f7b4d802658e73e9a" translate="yes" xml:space="preserve">
          <source>The thread identifier to search for.</source>
          <target state="translated">要搜索的线程标识符。</target>
        </trans-unit>
        <trans-unit id="5a0f4bf2e74aee3208cf1615166945a5d795e350" translate="yes" xml:space="preserve">
          <source>The thread module provides support for thread creation and management.</source>
          <target state="translated">线程模块提供对线程创建和管理的支持。</target>
        </trans-unit>
        <trans-unit id="d7abe70146b93589cb3df68907f1263f3d11f70c" translate="yes" xml:space="preserve">
          <source>The thread object associated with the thread identifier, null if not found.</source>
          <target state="translated">与线程标识符相关联的线程对象,如果没有找到则为空。</target>
        </trans-unit>
        <trans-unit id="ab55fec985d480d7e55fafd41bc48fa26e59c5c7" translate="yes" xml:space="preserve">
          <source>The thread object representing the calling thread. The result of deleting this object is undefined. If the current thread is not attached to the runtime, a null reference is returned.</source>
          <target state="translated">代表调用线程的线程对象。删除该对象的结果是未定义的。如果当前线程没有连接到运行时,则返回一个空引用。</target>
        </trans-unit>
        <trans-unit id="e5711fdf4eb878a460acdc3e1a74ec3adfd4c562" translate="yes" xml:space="preserve">
          <source>The thread to add.</source>
          <target state="translated">要添加的线。</target>
        </trans-unit>
        <trans-unit id="7d29c86c6e1877f0c1dbf42c7ab48cb432ebae10" translate="yes" xml:space="preserve">
          <source>The thread to remove.</source>
          <target state="translated">要删除的线。</target>
        </trans-unit>
        <trans-unit id="d0b4719e19dcec3e27e7ac05162455919bfcbe02" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;. The semantics of the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; are identical to the regular &lt;a href=&quot;#BitmappedBlock&quot;&gt;&lt;code&gt;BitmappedBlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#BitmappedBlock&quot;&gt; &lt;code&gt;BitmappedBlock&lt;/code&gt; &lt;/a&gt;的线程安全版本。 &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 的语义与常规&lt;a href=&quot;#BitmappedBlock&quot;&gt; &lt;code&gt;BitmappedBlock&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="59a01b618381df97fff6e53a1c501e32c03fcf01" translate="yes" xml:space="preserve">
          <source>The threadsafe version of the &lt;code&gt;Region&lt;/code&gt; allocator. Allocations and deallocations are lock-free based using &lt;a href=&quot;core_atomic#cas&quot;&gt;&lt;code&gt;core.atomic.cas&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Region&lt;/code&gt; 分配器的线程安全版本。分配和取消分配使用&lt;a href=&quot;core_atomic#cas&quot;&gt; &lt;code&gt;core.atomic.cas&lt;/code&gt; &lt;/a&gt;是无锁的。</target>
        </trans-unit>
        <trans-unit id="1aa46d46c716c543c618abaaa5d085bc00056cfe" translate="yes" xml:space="preserve">
          <source>The tick of the system clock (as a &lt;code&gt;TickDuration&lt;/code&gt;) when the application started.</source>
          <target state="translated">应用程序启动时系统时钟的滴答声（作为 &lt;code&gt;TickDuration&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c9d9d06b3436a3b01b898cdc70083c5a552bbada" translate="yes" xml:space="preserve">
          <source>The tid register by name.</source>
          <target state="translated">滴滴按名称登记。</target>
        </trans-unit>
        <trans-unit id="c95778519910f76a9057566bdc33da531d73931d" translate="yes" xml:space="preserve">
          <source>The time complexity of &lt;code&gt;resolveInternalPointer&lt;/code&gt; is &amp;Omicron;(&lt;code&gt;k&lt;/code&gt;), where &lt;code&gt;k&lt;/code&gt; is the size of the object within which the internal pointer is looked up.</source>
          <target state="translated">&lt;code&gt;resolveInternalPointer&lt;/code&gt; 的时间复杂度为〇（ &lt;code&gt;k&lt;/code&gt; ），其中 &lt;code&gt;k&lt;/code&gt; 是在其中查找内部指针的对象的大小。</target>
        </trans-unit>
        <trans-unit id="c6f885eba6e13ebbe7785527359e11e5b18d7b86" translate="yes" xml:space="preserve">
          <source>The time in this time zone that needs to be adjusted to UTC time.</source>
          <target state="translated">这个时区的时间,需要调整为UTC时间。</target>
        </trans-unit>
        <trans-unit id="36444ba6ba0b4c42e3d384843ef7cb9d529fafd9" translate="yes" xml:space="preserve">
          <source>The time it takes for a collection to complete is not bounded. While in practice it is very quick, this cannot normally be guaranteed.</source>
          <target state="translated">完成一次收集所需的时间是没有限制的。虽然在实践中,完成时间非常快,但通常无法保证。</target>
        </trans-unit>
        <trans-unit id="de1882702ad690d9d775a9f36384bf0f0cf2e003" translate="yes" xml:space="preserve">
          <source>The time point to check for inclusion in this interval.</source>
          <target state="translated">检查是否包含在这个区间的时间点。</target>
        </trans-unit>
        <trans-unit id="6e148efcac14a5504ed5ebc4915f1425f4ffaad7" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is after it.</source>
          <target state="translated">的时间点,检查这个区间是否在它之后。</target>
        </trans-unit>
        <trans-unit id="0af6ef24e2680b0852356a3c276c84d96252cda5" translate="yes" xml:space="preserve">
          <source>The time point to check whether this interval is before it.</source>
          <target state="translated">的时间点,检查这个区间是否在它之前。</target>
        </trans-unit>
        <trans-unit id="8a3820a8c6e406527bb35a80565a009d598d8a36" translate="yes" xml:space="preserve">
          <source>The time point to set &lt;code&gt;begin&lt;/code&gt; to.</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; 设置的时间点。</target>
        </trans-unit>
        <trans-unit id="cbec4c576826e4c65a07a27c4030261f911b3fc7" translate="yes" xml:space="preserve">
          <source>The time point to set end to.</source>
          <target state="translated">设定结束的时间点。</target>
        </trans-unit>
        <trans-unit id="4e8c71e16602a3ead734892883c0297513fcb288" translate="yes" xml:space="preserve">
          <source>The time point which begins the interval.</source>
          <target state="translated">开始间隔的时间点。</target>
        </trans-unit>
        <trans-unit id="b2fbbe21f1348e2b8375bc085e626db9a6aa48c4" translate="yes" xml:space="preserve">
          <source>The time point which ends (but is not included in) the interval.</source>
          <target state="translated">间隔结束(但不包括在)的时间点。</target>
        </trans-unit>
        <trans-unit id="78c4a788ebf74ce66cd510d9291804e7429c59df" translate="yes" xml:space="preserve">
          <source>The time point which ends the interval.</source>
          <target state="translated">结束间隔的时间点。</target>
        </trans-unit>
        <trans-unit id="a07ced07ea48cf9efd3c59008997a5861e92661c" translate="yes" xml:space="preserve">
          <source>The time portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的时间部分。</target>
        </trans-unit>
        <trans-unit id="eaefa3fbda7de51442bf3c3c08acb463add5f535" translate="yes" xml:space="preserve">
          <source>The time required of the base function</source>
          <target state="translated">基本功能所需时间</target>
        </trans-unit>
        <trans-unit id="5dfcadc4d17bd6640e6259395ec434dc6bc95330" translate="yes" xml:space="preserve">
          <source>The time required of the target function</source>
          <target state="translated">目标函数所需时间</target>
        </trans-unit>
        <trans-unit id="48cf786f30ef005c486cb7a01e2f10f8f8403d94" translate="yes" xml:space="preserve">
          <source>The time to return if the given file does not exist.</source>
          <target state="translated">如果给定的文件不存在,返回的时间。</target>
        </trans-unit>
        <trans-unit id="4267537c103e163837339d1b65e1d8cf5f9910a8" translate="yes" xml:space="preserve">
          <source>The time to wait.</source>
          <target state="translated">等待的时间。</target>
        </trans-unit>
        <trans-unit id="fa99618f433466483613abfd766711a1f7a82462" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;Duration&lt;/code&gt; (e.g. &lt;code&gt;&quot;days&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 的时间单位（例如 &lt;code&gt;&quot;days&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e6cd7e80f003f95225b75b6571da8250b5085bd4" translate="yes" xml:space="preserve">
          <source>The time units of the &lt;code&gt;TickDuration&lt;/code&gt; (e.g. &lt;code&gt;&quot;msecs&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 的时间单位（例如 &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="da60824664e52c129d1706b86eb17c66b6fccefc" translate="yes" xml:space="preserve">
          <source>The time zone for the SysTime that's returned.</source>
          <target state="translated">返回的SysTime的时区。</target>
        </trans-unit>
        <trans-unit id="c438d5ef1eeaa45747297e85768ff04bc9674297" translate="yes" xml:space="preserve">
          <source>The time zone that the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; will be in (&lt;code&gt;FILETIME&lt;/code&gt;s are in UTC).</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 所在&lt;/a&gt;的时区（ &lt;code&gt;FILETIME&lt;/code&gt; 的单位为UTC）。</target>
        </trans-unit>
        <trans-unit id="8ed6f652fe44fd70fdb71a9b99c39e57d001f270" translate="yes" xml:space="preserve">
          <source>The time zone that the time in the &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct is assumed to be (if the &lt;code&gt;SYSTEMTIME&lt;/code&gt; was supplied by a Windows system call, the &lt;code&gt;SYSTEMTIME&lt;/code&gt; will either be in local time or UTC, depending on the call).</source>
          <target state="translated">假定 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 结构中的时间为时区（如果 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 是由Windows系统调用提供的，则根据调用， &lt;code&gt;SYSTEMTIME&lt;/code&gt; 可以是本地时间，也可以是UTC）。</target>
        </trans-unit>
        <trans-unit id="e2b1325df63f2bced3800f46b247c623c3e4272e" translate="yes" xml:space="preserve">
          <source>The time zone to convert the given time to (no conversion occurs if null).</source>
          <target state="translated">要将给定时间转换为的时区(如果为空,则不发生转换)。</target>
        </trans-unit>
        <trans-unit id="07061a5295594952467858d09a80f0ac4c6b93c5" translate="yes" xml:space="preserve">
          <source>The time zone which the DOS file time is assumed to be in.</source>
          <target state="translated">假定DOS文件时间所在的时区。</target>
        </trans-unit>
        <trans-unit id="ea5d10f63e5499e351af6e045b5284865995d1c6" translate="yes" xml:space="preserve">
          <source>The time-domain signal.</source>
          <target state="translated">时域信号。</target>
        </trans-unit>
        <trans-unit id="77a3aa828967d445cff64c8dd096774ce4063dcd" translate="yes" xml:space="preserve">
          <source>The timeout duration to set. Must not be negative.</source>
          <target state="translated">要设置的超时时间。不得为负值。</target>
        </trans-unit>
        <trans-unit id="d16c09d69ed3827cc0d9a393d7d97a0e7218d947" translate="yes" xml:space="preserve">
          <source>The times when endianness matters are:</source>
          <target state="translated">恩典重要的时候是。</target>
        </trans-unit>
        <trans-unit id="e3fa37b42db66accd6b9bcd0e0be5ca501e23ea7" translate="yes" xml:space="preserve">
          <source>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the internal representation of &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从1 UTC 1月1日午夜开始的总hnsec。这是&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的内部表示。</target>
        </trans-unit>
        <trans-unit id="1c5851853cba4938d9ece2d746e33f63f5ccc8b6" translate="yes" xml:space="preserve">
          <source>The total number of CPU cores available on the current machine, as reported by the operating system.</source>
          <target state="translated">当前机器上可用的CPU核心总数,由操作系统报告。</target>
        </trans-unit>
        <trans-unit id="79b5fcc0a58019c01762b4288a59bbc0fed9cdab" translate="yes" xml:space="preserve">
          <source>The total number of fields minus the number of hidden fields.</source>
          <target state="translated">总字段数减去隐藏字段数。</target>
        </trans-unit>
        <trans-unit id="dc0f294e7939a4a8cc8e219285559a0f838c9d26" translate="yes" xml:space="preserve">
          <source>The total number of valid bits in the given bit array</source>
          <target state="translated">在给定的位数组中,有效位的总数。</target>
        </trans-unit>
        <trans-unit id="df0ace455640aad44a2f2df358df6cfc839cb3dc" translate="yes" xml:space="preserve">
          <source>The total size of a static array cannot exceed 16Mb.</source>
          <target state="translated">静态阵列的总大小不能超过16Mb。</target>
        </trans-unit>
        <trans-unit id="976a549fe53e07ee95927e3a3f5dc68542025ca7" translate="yes" xml:space="preserve">
          <source>The traditional C way of detecting and reporting errors is not traditional, it is ad-hoc and varies from function to function, including:</source>
          <target state="translated">传统的C语言检测和报告错误的方式并不传统,它是临时性的,不同的功能之间也有差异,包括:。</target>
        </trans-unit>
        <trans-unit id="67c33a524b8d09894199c567d354a8e0cb98ab34" translate="yes" xml:space="preserve">
          <source>The trailing end of the sub-format string following the specifier for each item is interpreted as the array delimiter, and is therefore omitted following the last array item. The &lt;b&gt;%|&lt;/b&gt; delimiter specifier may be used to indicate where the delimiter begins, so that the portion of the format string prior to it will be retained in the last array element:</source>
          <target state="translated">每个项目的说明符之后的子格式字符串的结尾被解释为数组定界符，因此在最后一个数组项目之后被省略。在&lt;b&gt;％| &lt;/b&gt;分隔符说明符可用于指示分隔符的起始位置，以便格式字符串之前的部分将保留在最后一个数组元素中：</target>
        </trans-unit>
        <trans-unit id="ba1799b6274ed3732b914694e0713f19f1425685" translate="yes" xml:space="preserve">
          <source>The transformation target</source>
          <target state="translated">改造目标</target>
        </trans-unit>
        <trans-unit id="dc8b213c861da206308d6e24e6eb30fbdfae1604" translate="yes" xml:space="preserve">
          <source>The transformation to apply.</source>
          <target state="translated">要应用的转变。</target>
        </trans-unit>
        <trans-unit id="6b4ca3ee54513a021c5a032735367ac7e4c3f685" translate="yes" xml:space="preserve">
          <source>The transformation to apply. Either a unary function (&lt;code&gt;unaryFun!transform(element)&lt;/code&gt;), or a binary function (&lt;code&gt;binaryFun!transform(element, index)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e46c489c0f174beeea6508fe063266ccec2c4d" translate="yes" xml:space="preserve">
          <source>The transversal assumes, without verifying, that the elements of a range of ranges have all the same length. This option is useful if checking was already done from the outside of the range.</source>
          <target state="translated">横向假设,不需要验证,一个范围的元素都有相同的长度。如果已经从范围外进行了检查,这个选项就很有用。</target>
        </trans-unit>
        <trans-unit id="c892e981eb5136632b424a66b388d449fc7ea3de" translate="yes" xml:space="preserve">
          <source>The transversal enforces that the elements of a range of ranges have all the same length (e.g. an array of arrays, all having the same length). Checking is done once upon construction of the transversal range.</source>
          <target state="translated">横向强制要求范围的元素具有相同的长度(例如,一个数组,所有的数组具有相同的长度)。横向范围的构造时,检查只进行一次。</target>
        </trans-unit>
        <trans-unit id="39be873b141578a1b5b94098b6cdd594b486bf6c" translate="yes" xml:space="preserve">
          <source>The try/catch/finally statements look a lot nicer than endless if (error) goto errorhandler; statements.</source>
          <target state="translated">try/catch/finally 语句比起无休止的 if (error)goto errorhandler;语句要好看得多。</target>
        </trans-unit>
        <trans-unit id="2180bb589eb009453566d9091bc41a602b56f38e" translate="yes" xml:space="preserve">
          <source>The tuple passes in a range closed to the left and open to the right (consistent with built-in slices), e.g. &lt;code&gt;tuple(1, 3)&lt;/code&gt; means indices &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; but not &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">元组在从左向右打开（与内置切片一致）的范围内通过，例如 &lt;code&gt;tuple(1, 3)&lt;/code&gt; 表示索引 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; ,但不等于 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07a7ad5d5f1c875f8f019e5586ed049f63bb8fa1" translate="yes" xml:space="preserve">
          <source>The two functions are almost identical semantically. The expressions in the first are lowered to contract blocks that look almost exactly like the second, except that a separate block is created for each expression in the first, thus avoiding shadowing variable names.</source>
          <target state="translated">这两个函数在语义上几乎完全相同。第一个函数中的表达式被下放到合同块中,看起来几乎和第二个函数一模一样,只是第一个函数中的每个表达式都会创建一个单独的块,从而避免了变量名的阴影。</target>
        </trans-unit>
        <trans-unit id="28b3f8f71ef0f4ce43325479aa6cdea23771283e" translate="yes" xml:space="preserve">
          <source>The two sockets are indistinguishable.</source>
          <target state="translated">两个插座是分不清的。</target>
        </trans-unit>
        <trans-unit id="61509f7d94291812c28aff0f194b21e094315464" translate="yes" xml:space="preserve">
          <source>The type being allocated embeds no pointers. Examples: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt; Tuple!(int, float)&lt;/code&gt;. The implicit conservative assumption is that the type has members with indirections so it needs to be scanned if garbage collected. Example of types with pointers: &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)&lt;/code&gt;.</source>
          <target state="translated">分配的类型不嵌入任何指针。示例： &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;int[]&lt;/code&gt; ， &lt;code&gt; Tuple!(int, float)&lt;/code&gt; 。隐式的保守假设是该类型的成员具有间接性，因此如果收集了垃圾，则需要对其进行扫描。带有指针的类型的示例： &lt;code&gt;int*[]&lt;/code&gt; ， &lt;code&gt;Tuple!(int, string)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c92e87e9681d72db37be621f13a19e6f9ccab9d8" translate="yes" xml:space="preserve">
          <source>The type being allocated is &lt;code&gt;immutable&lt;/code&gt; and has no pointers. The thread that allocated it must also deallocate it. Example: &lt;code&gt;immutable(int)&lt;/code&gt;.</source>
          <target state="translated">分配的类型是 &lt;code&gt;immutable&lt;/code&gt; ，没有指针。分配它的线程也必须取消分配它。示例： &lt;code&gt;immutable(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e05464f951110a64f08a5f46efef5075a235c4f" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, embeds no indirections, and has fixed size.</source>
          <target state="translated">被分配的类型可以在各线程间共享,不嵌入任何内向项,并具有固定的大小。</target>
        </trans-unit>
        <trans-unit id="31e0418a4ffc820d767ece7d24f4809101c1c145" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has fixed size.</source>
          <target state="translated">被分配的类型可以在各线程之间共享,可以嵌入内联,并且有固定的大小。</target>
        </trans-unit>
        <trans-unit id="6fe4cebdd8e8add445c91158cc91cb4158edec6a" translate="yes" xml:space="preserve">
          <source>The type being allocated may be shared across threads, may embed indirections, and has variable size.</source>
          <target state="translated">被分配的类型可以在各线程之间共享,可以嵌入内向,并且大小可变。</target>
        </trans-unit>
        <trans-unit id="ddfa6b8808ffdca7214f401f8531dd3f2c5d3a94" translate="yes" xml:space="preserve">
          <source>The type can be inferred from the initializer:</source>
          <target state="translated">类型可以从初始化器中推断出来。</target>
        </trans-unit>
        <trans-unit id="a2bca00fd97360bf19d51b245e76c8ddf38d445e" translate="yes" xml:space="preserve">
          <source>The type for a callback function. This is legacy and deprecated. It is included for historical compatibility and is not documented.</source>
          <target state="translated">回调函数的类型。这是遗留的,已经废弃。它是为了历史的兼容性而包含的,没有记录在案。</target>
        </trans-unit>
        <trans-unit id="121e0a2d6317bfb42929d38aae907c92fbe1c037" translate="yes" xml:space="preserve">
          <source>The type for a unary expression is incompatible. Print error message.</source>
          <target state="translated">单元表达式的类型不兼容。打印错误信息。</target>
        </trans-unit>
        <trans-unit id="6c3d19b0730f008ab63e19c7a8d36ffbf8fb1da1" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt; to handle.</source>
          <target state="translated">可处理的 &lt;code&gt;Throwable&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="3c9c6ef66ad21283731c4e03058407f8e8389f4f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;Throwable&lt;/code&gt;s to catch. Defaults to &lt;code&gt;Exception&lt;/code&gt;</source>
          <target state="translated">要捕获的 &lt;code&gt;Throwable&lt;/code&gt; 的类型。默认为 &lt;code&gt;Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="334019df59cb8690811d0f69b9dd1719fafb9c56" translate="yes" xml:space="preserve">
          <source>The type of a bit field can be any integral type or enumerated type. The most efficient type to store in bitfields is bool, followed by unsigned types, followed by signed types.</source>
          <target state="translated">位字段的类型可以是任何积分类型或枚举类型。位字段中最有效的存储类型是bool,其次是无符号类型,然后是有符号类型。</target>
        </trans-unit>
        <trans-unit id="94b6a8f2e23e23e45fa071980296e38bdaa78842" translate="yes" xml:space="preserve">
          <source>The type of a const declaration is itself const.</source>
          <target state="translated">const声明的类型本身就是const。</target>
        </trans-unit>
        <trans-unit id="f092f06205403400bf68aeecbf79e12113097113" translate="yes" xml:space="preserve">
          <source>The type of a string is determined by the semantic phase of compilation. The type is one of: char[], wchar[], dchar[], and is determined by implicit conversion rules. If there are two equally applicable implicit conversions, the result is an error. To disambiguate these cases, a cast or a postfix of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; can be used:</source>
          <target state="translated">字符串的类型由编译的语义阶段确定。类型是char []，wchar []，dchar []之一，由隐式转换规则确定。如果存在两个同样适用的隐式转换，则结果为错误。为了消除这些情况的歧义，可以使用 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; 或 &lt;code&gt;d&lt;/code&gt; 的强制转换或后缀：</target>
        </trans-unit>
        <trans-unit id="ca53c8f136489f724620c0090bfc2e63be277e6a" translate="yes" xml:space="preserve">
          <source>The type of an</source>
          <target state="translated">的类型</target>
        </trans-unit>
        <trans-unit id="31de113d851dba3763860dc7a09ef0a95ac4302d" translate="yes" xml:space="preserve">
          <source>The type of concurrency used when logical threads are created is determined by the Scheduler selected at initialization time. The default behavior is currently to create a new kernel thread per call to spawn, but other schedulers are available that multiplex fibers across the main thread or use some combination of the two approaches.</source>
          <target state="translated">创建逻辑线程时使用的并发类型由初始化时选择的调度器决定。目前默认的行为是每次调用 spawn 时创建一个新的内核线程,但也有其他调度器可以在主线程上复用光纤或使用两种方法的某种组合。</target>
        </trans-unit>
        <trans-unit id="98b545b7a4a8236494e660dadf828715e09984c5" translate="yes" xml:space="preserve">
          <source>The type of encoding cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type.</source>
          <target state="translated">编码类型无法推断。因此,必须明确规定编码类型。</target>
        </trans-unit>
        <trans-unit id="28559fdc7fafacf56a4b4aa4caf411513cf1a53a" translate="yes" xml:space="preserve">
          <source>The type of exception to catch.</source>
          <target state="translated">要捕捉的异常类型。</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">的类型</target>
        </trans-unit>
        <trans-unit id="e2db65940bfb878a54cfaaae819d3064fa148502" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;t&lt;/code&gt; 关联的 &lt;code&gt;TypeInfo&lt;/code&gt; 对象的类型</target>
        </trans-unit>
        <trans-unit id="3fe50288d353a1cb4576b8e3e05c3c630fa3b33c" translate="yes" xml:space="preserve">
          <source>The type of the array elements</source>
          <target state="translated">数组元素的类型</target>
        </trans-unit>
        <trans-unit id="d37e2aaad386c1ac5e9f0016c42e7b609226d289" translate="yes" xml:space="preserve">
          <source>The type of the expression.</source>
          <target state="translated">表达式的类型。</target>
        </trans-unit>
        <trans-unit id="028c1d38d3da5ded0145ae38e0f7c2dbd53920e7" translate="yes" xml:space="preserve">
          <source>The type of the integer is resolved as follows:</source>
          <target state="translated">整数的类型解析如下。</target>
        </trans-unit>
        <trans-unit id="212a76fc03c17bbe0ddb79883b2541fa9887cff9" translate="yes" xml:space="preserve">
          <source>The type of the integral subject to checking.</source>
          <target state="translated">被检查的积分类型。</target>
        </trans-unit>
        <trans-unit id="c013517e503aa577ef8db2efdfe587a3e89caa97" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter.</source>
          <target state="translated">输出的类型无法推断。因此,有必要将编码明确地指定为模板参数。</target>
        </trans-unit>
        <trans-unit id="03cbac5dfebfa2a554890fbfd9c43c204a18bfcf" translate="yes" xml:space="preserve">
          <source>The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type in the template parameter.</source>
          <target state="translated">输出的类型无法推断。因此,必须在模板参数中明确指定编码类型。</target>
        </trans-unit>
        <trans-unit id="d39ec39bd451294d5515fb3a127cb955f855d7d6" translate="yes" xml:space="preserve">
          <source>The type of the previous</source>
          <target state="translated">以前的类型</target>
        </trans-unit>
        <trans-unit id="033a19799f0fa5ac9cef064ceb5d1268d8f17524" translate="yes" xml:space="preserve">
          <source>The type of the resulting array elements</source>
          <target state="translated">产生的数组元素的类型</target>
        </trans-unit>
        <trans-unit id="81040b338b2e6abd79e9a3fdf3377720163baee6" translate="yes" xml:space="preserve">
          <source>The type of the return value.</source>
          <target state="translated">返回值的类型。</target>
        </trans-unit>
        <trans-unit id="dd58ac5452c68f3b56c536830be3fca377a108cc" translate="yes" xml:space="preserve">
          <source>The type of the slice is a dynamic array of the element type of the</source>
          <target state="translated">的元素类型的动态数组。</target>
        </trans-unit>
        <trans-unit id="cd785b1199a8635d3d151523c5ad55526bbbd6f9" translate="yes" xml:space="preserve">
          <source>The type of the symbol.</source>
          <target state="translated">符号的类型。</target>
        </trans-unit>
        <trans-unit id="452196a4318917b63a4cfe89691bc99e9fba3c75" translate="yes" xml:space="preserve">
          <source>The type of units to add (&quot;years&quot; or &quot;months&quot;).</source>
          <target state="translated">要添加的单位类型(&quot;年 &quot;或 &quot;月&quot;);</target>
        </trans-unit>
        <trans-unit id="f9dccb4c7e9a59ec9ebfcaaaf2ab57b17a652de7" translate="yes" xml:space="preserve">
          <source>The type returned by &lt;code&gt;takeOne&lt;/code&gt; is a random-access range with length regardless of &lt;code&gt;R&lt;/code&gt;'s capabilities, as long as it is a forward range. (another feature that distinguishes &lt;code&gt;takeOne&lt;/code&gt; from &lt;code&gt;take&lt;/code&gt;). If (D R) is an input range but not a forward range, return type is an input range with all random-access capabilities except save.</source>
          <target state="translated">&lt;code&gt;takeOne&lt;/code&gt; 返回的类型是一个随机访问范围，其长度与 &lt;code&gt;R&lt;/code&gt; 的功能无关，只要它是前向范围即可。（另一个将 &lt;code&gt;takeOne&lt;/code&gt; 与 &lt;code&gt;take&lt;/code&gt; 区别开的功能）。如果（DR）是输入范围而不是正向范围，则返回类型是具有所有随机访问功能（保存除外）的输入范围。</target>
        </trans-unit>
        <trans-unit id="df7e4abf69509dd860941f1b197de09e0d181452" translate="yes" xml:space="preserve">
          <source>The type stored inside &lt;code&gt;bomTable&lt;/code&gt;.</source>
          <target state="translated">存储在 &lt;code&gt;bomTable&lt;/code&gt; 中的类型。</target>
        </trans-unit>
        <trans-unit id="6da0e0e3a59ae4f419059fd79e6a5b2efe510dd1" translate="yes" xml:space="preserve">
          <source>The type to cast from. The programmer must ensure it is legal to make this cast.</source>
          <target state="translated">要投射的类型。程序员必须确保其合法地进行投射。</target>
        </trans-unit>
        <trans-unit id="6fc6b3afd9d09c214bbb47deabcb3d5029a321f8" translate="yes" xml:space="preserve">
          <source>The type to cast to.</source>
          <target state="translated">要投向的类型。</target>
        </trans-unit>
        <trans-unit id="7a12dddb89baf93f3c8ff660933719a4552a94a9" translate="yes" xml:space="preserve">
          <source>The type to check</source>
          <target state="translated">要检查的类型</target>
        </trans-unit>
        <trans-unit id="20caa9de7c60aa932980e2103bddf1b7c37802ff" translate="yes" xml:space="preserve">
          <source>The type to check Returns A &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">要检查的类型返回A &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="129cd5fe4646df1f906533b11f848d4c99ca621d" translate="yes" xml:space="preserve">
          <source>The type to check.</source>
          <target state="translated">要检查的类型。</target>
        </trans-unit>
        <trans-unit id="e0884902d15a178811c08946d7f41f322c3b3c6e" translate="yes" xml:space="preserve">
          <source>The type to convert to (either an integral type or a floating point type).</source>
          <target state="translated">要转换的类型(积分类型或浮点类型)。</target>
        </trans-unit>
        <trans-unit id="731464fe86427c8aef65d3aa38988badaf10df11" translate="yes" xml:space="preserve">
          <source>The type to qualify</source>
          <target state="translated">符合条件的类型</target>
        </trans-unit>
        <trans-unit id="d4255aeb11f7f1166da5fe91079652809cb8c332" translate="yes" xml:space="preserve">
          <source>The type to transform</source>
          <target state="translated">要转换的类型</target>
        </trans-unit>
        <trans-unit id="a182178d558aaac6dc8d492d1e7dc9ff9e25bdd0" translate="yes" xml:space="preserve">
          <source>The types bool, byte, ubyte, short, ushort, int, uint, pointer, Object, and interfaces are returned in EAX.</source>
          <target state="translated">EAX中返回的类型有bool、byte、ubyte、short、ushort、int、uint、指针、Object和接口。</target>
        </trans-unit>
        <trans-unit id="0110212887a1a5d92fbf43e56315c07c9570e0ab" translate="yes" xml:space="preserve">
          <source>The types defined will all follow the naming convention:</source>
          <target state="translated">定义的类型都将遵循命名惯例。</target>
        </trans-unit>
        <trans-unit id="04692c0de4f65115c6356357897fe3c8458aeb37" translate="yes" xml:space="preserve">
          <source>The types for a binary expression are incompatible. Print error message.</source>
          <target state="translated">二进制表达式的类型不兼容。打印错误信息。</target>
        </trans-unit>
        <trans-unit id="5522b90b8401affc194c75d94ed28b129ed2edae" translate="yes" xml:space="preserve">
          <source>The types of template parameters are deduced for a particular template instantiation by comparing the template argument with the corresponding template parameter.</source>
          <target state="translated">通过比较模板参数与对应的模板参数,推导出特定模板实例的模板参数类型。</target>
        </trans-unit>
        <trans-unit id="066569f5b571624866c51a31fa6ddcb337821083" translate="yes" xml:space="preserve">
          <source>The types of the &lt;code&gt;Tuple&lt;/code&gt;'s components.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 组件的类型。</target>
        </trans-unit>
        <trans-unit id="3c8b9bedfec2099e1aa223db3144a32e496f4931" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;FILE*&lt;/code&gt; handle is maintained in a reference-counted manner, such that as soon as the last &lt;code&gt;File&lt;/code&gt; variable bound to a given &lt;code&gt;FILE*&lt;/code&gt; goes out of scope, the underlying &lt;code&gt;FILE*&lt;/code&gt; is automatically closed.</source>
          <target state="translated">基础 &lt;code&gt;FILE*&lt;/code&gt; 句柄以引用计数的方式维护，这样，一旦绑定到给定 &lt;code&gt;FILE*&lt;/code&gt; 的最后一个 &lt;code&gt;File&lt;/code&gt; 变量超出范围，基础 &lt;code&gt;FILE*&lt;/code&gt; 就会自动关闭。</target>
        </trans-unit>
        <trans-unit id="2e4c90c054f0493a2822eb59e3b3bf2666457fe9" translate="yes" xml:space="preserve">
          <source>The underlying delegate of the &lt;code&gt;lazy&lt;/code&gt; parameter may be extracted by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc75b662708321c7f89938e96034aeb600136f1" translate="yes" xml:space="preserve">
          <source>The unfilled part of target</source>
          <target state="translated">目标的未填写部分</target>
        </trans-unit>
        <trans-unit id="634a8a351a2208e39d6a5ada2c8d683b264478f7" translate="yes" xml:space="preserve">
          <source>The units of time to convert from.</source>
          <target state="translated">时间单位换算为:</target>
        </trans-unit>
        <trans-unit id="ca496597d1b0052334d45f82b4d1ebb346322b8a" translate="yes" xml:space="preserve">
          <source>The units of time to convert to.</source>
          <target state="translated">换算成的时间单位。</target>
        </trans-unit>
        <trans-unit id="0be285da06571b223018436a72e418b7f4b54a74" translate="yes" xml:space="preserve">
          <source>The units of time to validate.</source>
          <target state="translated">审定的时间单位。</target>
        </trans-unit>
        <trans-unit id="421844a18abe81313eecb91da7e35563552d941b" translate="yes" xml:space="preserve">
          <source>The units to add.</source>
          <target state="translated">要增加的单位。</target>
        </trans-unit>
        <trans-unit id="b4529f66e815e24cb45e91c0feb5284c7f7ff115" translate="yes" xml:space="preserve">
          <source>The units to add. Must be &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">要添加的单位。必须是 &lt;code&gt;&quot;days&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a30f00fc7d9dabd0ab88732559ada44060afc844" translate="yes" xml:space="preserve">
          <source>The units to convert to. Accepts &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; and smaller only.</source>
          <target state="translated">转换成的单位。仅接受 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; 或更小。</target>
        </trans-unit>
        <trans-unit id="77097e55fb24c41c45ac8fd555bdb9f92cb58569" translate="yes" xml:space="preserve">
          <source>The unix time to convert.</source>
          <target state="translated">unix时间的转换。</target>
        </trans-unit>
        <trans-unit id="20dd814c3aa8014ba5957f08ad17be1db064e4d2" translate="yes" xml:space="preserve">
          <source>The unsorted, right-hand side of the random access range to be sorted.</source>
          <target state="translated">未排序的,要排序的随机访问范围的右侧。</target>
        </trans-unit>
        <trans-unit id="d1d3c14f93e1c2e8f53e8dab18a0c8184c6c7a98" translate="yes" xml:space="preserve">
          <source>The upper bound of the clamp.</source>
          <target state="translated">钳的上界。</target>
        </trans-unit>
        <trans-unit id="0983ef86eb34d76a2780b35b3edfbd68c63c7dea" translate="yes" xml:space="preserve">
          <source>The url to receive content from</source>
          <target state="translated">接收内容的网址</target>
        </trans-unit>
        <trans-unit id="446e2b0a1f994283348417fe7415a244c477d8c8" translate="yes" xml:space="preserve">
          <source>The use in the example above is correct because &lt;code&gt;result&lt;/code&gt; was private to &lt;code&gt;letters&lt;/code&gt; and is inaccessible in writing after the function returns. The following example shows an incorrect use of &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">上面的示例中的用法是正确的，因为 &lt;code&gt;result&lt;/code&gt; 是 &lt;code&gt;letters&lt;/code&gt; 专有的，并且在函数返回后无法用书面形式访问。下面的示例显示了对 &lt;code&gt;assumeUnique&lt;/code&gt; 的错误使用。</target>
        </trans-unit>
        <trans-unit id="f765f067fdbcdb23f122179aadad4e3aab7633fe" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged - use either of &lt;a href=&quot;#matchAll&quot;&gt;&lt;code&gt;matchAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#matchFirst&quot;&gt;&lt;code&gt;matchFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不鼓励使用此功能-使用&lt;a href=&quot;#matchAll&quot;&gt; &lt;code&gt;matchAll&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#matchFirst&quot;&gt; &lt;code&gt;matchFirst&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12cefe2def110643149592a34e2703038ffe95e9" translate="yes" xml:space="preserve">
          <source>The use of this function is discouraged, please use &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="translated">不建议使用此功能，请显式使用&lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="258077ec71c841ca26961567df7573b36d2e9600" translate="yes" xml:space="preserve">
          <source>The user-defined attribute to search for</source>
          <target state="translated">要搜索的用户自定义属性</target>
        </trans-unit>
        <trans-unit id="aef8bf31a8de472e5ee4f185e2b79cc50024f24a" translate="yes" xml:space="preserve">
          <source>The usual arithmetic conversions convert operands of binary operators to a common type. The operands must already be of arithmetic types. The following rules are applied in order, looking at the base type:</source>
          <target state="translated">通常的算术转换将二进制运算符的操作数转换为一种通用类型。操作数必须已经是算术类型的。从基本类型来看,依次应用以下规则。</target>
        </trans-unit>
        <trans-unit id="ed8ed81507c265fdc6ddf599aacfb34e442e2017" translate="yes" xml:space="preserve">
          <source>The value held internally by this &lt;code&gt;Nullable&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;Nullable&lt;/code&gt; 在内部保留的值。</target>
        </trans-unit>
        <trans-unit id="18c2cd4ec56e16370bc6d10103dd74ac049c5530" translate="yes" xml:space="preserve">
          <source>The value held previously by &lt;code&gt;here&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; 以前保留的值。</target>
        </trans-unit>
        <trans-unit id="d539c77bb27b77f2df22dab504e881d99f6b5dd9" translate="yes" xml:space="preserve">
          <source>The value held previously by &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758230c61eadaee99aa3c3ef284aa623718c1933" translate="yes" xml:space="preserve">
          <source>The value of 'val'.</source>
          <target state="translated">val'的值。</target>
        </trans-unit>
        <trans-unit id="b06c415192563751b142dd5d437c6004b2e9459e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;expr&lt;/code&gt;, if any.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 的值（如果有）。</target>
        </trans-unit>
        <trans-unit id="efa4633a9b927147870c40861701a3a66f460ac4" translate="yes" xml:space="preserve">
          <source>The value of an</source>
          <target state="translated">价值</target>
        </trans-unit>
        <trans-unit id="e705d7da4d67602f093ecd07ec55976add979079" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember&lt;/i&gt;&lt;/a&gt; is given by its &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;. If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is the first</source>
          <target state="translated">一个值&lt;a href=&quot;#EnumMember&quot;&gt;&lt;i&gt;EnumMember&lt;/i&gt;&lt;/a&gt;由其给出&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;赋值&lt;/i&gt;&lt;/a&gt;。如果没有&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;，它是第一个</target>
        </trans-unit>
        <trans-unit id="cfdd678ef3efc50d4d19e113e22570e812ee97e8" translate="yes" xml:space="preserve">
          <source>The value of cos(y) + i sin(y).</source>
          <target state="translated">cos(y)+i sin(y)的值。</target>
        </trans-unit>
        <trans-unit id="ce228048bba4c787805c0ea9367075ff06ba1fcc" translate="yes" xml:space="preserve">
          <source>The value of cosh(y) + i sinh(y)</source>
          <target state="translated">cosh(y)+i sinh(y)的值。</target>
        </trans-unit>
        <trans-unit id="dffcef37a6c60e8c1178ac476b670c4fbdc86276" translate="yes" xml:space="preserve">
          <source>The value of the bound being violated</source>
          <target state="translated">被违反的约束值</target>
        </trans-unit>
        <trans-unit id="911671dbc78d40ead01af236d912c34ae5fc15c4" translate="yes" xml:space="preserve">
          <source>The value of the selected choice.</source>
          <target state="translated">选择的价值。</target>
        </trans-unit>
        <trans-unit id="2079c7788ad766ba6207e480774a32436765df0d" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as a &lt;code&gt;long&lt;/code&gt;, or &lt;code&gt;long.max&lt;/code&gt;/&lt;code&gt;long.min&lt;/code&gt; if outside the representable range.</source>
          <target state="translated">这个值 &lt;code&gt;BigInt&lt;/code&gt; 有作为 &lt;code&gt;long&lt;/code&gt; ，或 &lt;code&gt;long.max&lt;/code&gt; / &lt;code&gt;long.min&lt;/code&gt; 如果可表示的范围之外。</target>
        </trans-unit>
        <trans-unit id="bfb5bbd989c9054cc2b242d5eea3691758f09eed" translate="yes" xml:space="preserve">
          <source>The value of this &lt;code&gt;BigInt&lt;/code&gt; as an &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;int.max&lt;/code&gt;/&lt;code&gt;int.min&lt;/code&gt; if outside the representable range.</source>
          <target state="translated">这个值 &lt;code&gt;BigInt&lt;/code&gt; 有作为 &lt;code&gt;int&lt;/code&gt; ，或 &lt;code&gt;int.max&lt;/code&gt; / &lt;code&gt;int.min&lt;/code&gt; 如果可表示的范围之外。</target>
        </trans-unit>
        <trans-unit id="44a86e613513bb5b90f75505c846e4f1a8d5e443" translate="yes" xml:space="preserve">
          <source>The value of x - i * y, where i is the number of times that y can be completely subtracted from x. The result has the same sign as x.</source>
          <target state="translated">x-i*y 的值,其中 i 是 y 可以完全从 x 中减去的次数,结果与 x 的符号相同。</target>
        </trans-unit>
        <trans-unit id="fbda37a05f283a201fa47e61f1a28829aac6ca57" translate="yes" xml:space="preserve">
          <source>The value that serves as the stopping criterion. This value is not included in the range.</source>
          <target state="translated">作为停止标准的值。此值不包括在范围内。</target>
        </trans-unit>
        <trans-unit id="06ef9451ca2a6ddc30c31abb46ec77c558d2c434" translate="yes" xml:space="preserve">
          <source>The value to act as a proxy for all operations. It must be an lvalue.</source>
          <target state="translated">作为所有操作的代理值。它必须是一个l值。</target>
        </trans-unit>
        <trans-unit id="c4437657364f8d6c0ea26bb67bc977fd2c3d6762" translate="yes" xml:space="preserve">
          <source>The value to add to the current value at each iteration.</source>
          <target state="translated">每次迭代时要加到当前值上的值。</target>
        </trans-unit>
        <trans-unit id="71df2093c5012459c48815bda74ee8c58897d1c9" translate="yes" xml:space="preserve">
          <source>The value to add.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea1a4ae4b9c004c5d2afcb14b6504f978c0f7ea" translate="yes" xml:space="preserve">
          <source>The value to append.</source>
          <target state="translated">要附加的值。</target>
        </trans-unit>
        <trans-unit id="3e27e971fbf5a179f864e36ffcc71eeed5543b79" translate="yes" xml:space="preserve">
          <source>The value to be reference counted</source>
          <target state="translated">参考值的计算</target>
        </trans-unit>
        <trans-unit id="48cc3d885cf27d16c55ff2638b8883795263bff6" translate="yes" xml:space="preserve">
          <source>The value to bind to.</source>
          <target state="translated">要绑定的值。</target>
        </trans-unit>
        <trans-unit id="a802e0b8a3a2b83e804f3a0f0ce8a9cba9671bc8" translate="yes" xml:space="preserve">
          <source>The value to cast. It must be of type &lt;code&gt;From&lt;/code&gt;, otherwise a compile-time error is emitted.</source>
          <target state="translated">要转换的值。它必须是 &lt;code&gt;From&lt;/code&gt; 类型，否则会发出编译时错误。</target>
        </trans-unit>
        <trans-unit id="62da9509e3333e477d714ba7dbd138814897fd19" translate="yes" xml:space="preserve">
          <source>The value to clamp.</source>
          <target state="translated">要夹紧的数值。</target>
        </trans-unit>
        <trans-unit id="4ad7684bb8903fcc2f377acbdab0d055ec3933a5" translate="yes" xml:space="preserve">
          <source>The value to convert.</source>
          <target state="translated">要转换的值。</target>
        </trans-unit>
        <trans-unit id="50f2da1a55629d14637add94e8f4d0df9b3b3315" translate="yes" xml:space="preserve">
          <source>The value to divide from this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">要从此 &lt;code&gt;TickDuration&lt;/code&gt; 中除的值。</target>
        </trans-unit>
        <trans-unit id="0a1bf08b423c514be4510f8c180b0baca8c3ce06" translate="yes" xml:space="preserve">
          <source>The value to divide from this duration.</source>
          <target state="translated">从该持续时间中除以数值。</target>
        </trans-unit>
        <trans-unit id="1354007d97f6ba4733c332273819ddc621808569" translate="yes" xml:space="preserve">
          <source>The value to exchange.</source>
          <target state="translated">兑换的价值。</target>
        </trans-unit>
        <trans-unit id="1212730d5cf61a8236b91aa2562728d9cffb815c" translate="yes" xml:space="preserve">
          <source>The value to initialize this &lt;code&gt;Nullable&lt;/code&gt; with.</source>
          <target state="translated">用于初始化此 &lt;code&gt;Nullable&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="d9870b988dc93826e41d9e14caae258236099356" translate="yes" xml:space="preserve">
          <source>The value to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">该 &lt;code&gt;Duration&lt;/code&gt; 乘以的值。</target>
        </trans-unit>
        <trans-unit id="b63d59c749f4e3c4e27b5c62bc54fa60f14460d7" translate="yes" xml:space="preserve">
          <source>The value to multiply/divide this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">该 &lt;code&gt;Duration&lt;/code&gt; 乘以/除以的值。</target>
        </trans-unit>
        <trans-unit id="5f9706fe37a21ebb4f5356314e9dbb0f193612de" translate="yes" xml:space="preserve">
          <source>The value to search for.</source>
          <target state="translated">要搜索的价值。</target>
        </trans-unit>
        <trans-unit id="26611747ab051faf83da9bb9d7c2556f3251cdff" translate="yes" xml:space="preserve">
          <source>The value to store.</source>
          <target state="translated">要存储的值。</target>
        </trans-unit>
        <trans-unit id="623dc949267aac51bc4afc97ec71884d344d0223" translate="yes" xml:space="preserve">
          <source>The value to subtract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572affcd555e45a118ca8c255703b01188667dc6" translate="yes" xml:space="preserve">
          <source>The value to test.</source>
          <target state="translated">要测试的数值。</target>
        </trans-unit>
        <trans-unit id="19051782b6b3c278237f01645d39c916e236a933" translate="yes" xml:space="preserve">
          <source>The value to write.</source>
          <target state="translated">要写的值。</target>
        </trans-unit>
        <trans-unit id="ed8375fc18b2f2889a5d8178e1f4e71c024e1115" translate="yes" xml:space="preserve">
          <source>The value to yield.</source>
          <target state="translated">的价值,以产。</target>
        </trans-unit>
        <trans-unit id="36090b23e6b19abea403f7cf11708f739d6ebe0a" translate="yes" xml:space="preserve">
          <source>The value.</source>
          <target state="translated">价值。</target>
        </trans-unit>
        <trans-unit id="d9c7ac0f2459cf0fcaba3e1a3c53a1114b6dd604" translate="yes" xml:space="preserve">
          <source>The values of the statistics. Has the same length as &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="translated">统计信息的值。与 &lt;code&gt;opts&lt;/code&gt; 具有相同的长度。</target>
        </trans-unit>
        <trans-unit id="73dba46e865b8a15dc63f7dc2a467e9bb9da631f" translate="yes" xml:space="preserve">
          <source>The values to compare the value to.</source>
          <target state="translated">要比较的值。</target>
        </trans-unit>
        <trans-unit id="75999ceef9f4bfecc84eef7c1abce7ef1a1e25fa" translate="yes" xml:space="preserve">
          <source>The values to select the maximum from. At least two arguments must be passed, and they must be comparable with &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c472612eda8a57b671db853841e452b39218b0df" translate="yes" xml:space="preserve">
          <source>The values to select the maximum from. At least two arguments must be passed.</source>
          <target state="translated">要选择的最大值。必须至少传递两个参数。</target>
        </trans-unit>
        <trans-unit id="7a965cfb58b4af69ed40e336a152e8e938e3ae5e" translate="yes" xml:space="preserve">
          <source>The values to select the minimum from. At least two arguments must be passed, and they must be comparable with &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">从中选择最小值的值。至少必须传递两个参数，并且它们必须与 &lt;code&gt;&amp;lt;&lt;/code&gt; 相匹配。</target>
        </trans-unit>
        <trans-unit id="6c4b476e00d554e5b462693564ced434266700cc" translate="yes" xml:space="preserve">
          <source>The vararg module is intended to facilitate vararg manipulation in D. It should be interface compatible with the C module &quot;stdarg,&quot; and the two modules may share a common implementation if possible (as is done here).</source>
          <target state="translated">vararg模块的目的是为了方便在D中进行vararg操作,它应该与C模块 &quot;stdarg &quot;的接口兼容,如果可能的话,这两个模块可以共享一个共同的实现(这里就是这样做的)。</target>
        </trans-unit>
        <trans-unit id="e58c51068f71cad0c83773e1d40394fdd897c493" translate="yes" xml:space="preserve">
          <source>The variable to initialize</source>
          <target state="translated">要初始化的变量</target>
        </trans-unit>
        <trans-unit id="da94a792f23c83ccf884c163bc10a13c232be367" translate="yes" xml:space="preserve">
          <source>The variadic arguments are normally consumed in order. POSIX-style &lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt; positional parameter syntax&lt;/a&gt; is also supported. Each argument is formatted into a sequence of chars according to the format specification, and the characters are passed to &lt;code&gt;w&lt;/code&gt;. As many arguments as specified in the format string are consumed and formatted. If there are fewer arguments than format specifiers, a &lt;code&gt;FormatException&lt;/code&gt; is thrown. If there are more remaining arguments than needed by the format specification, they are ignored but only if at least one argument was formatted.</source>
          <target state="translated">可变参数通常按顺序使用。还支持POSIX样式的&lt;a href=&quot;http://opengroup.org/onlinepubs/009695399/functions/printf.html&quot;&gt;位置参数语法&lt;/a&gt;。根据格式说明，每个自变量都被格式化为char序列，并将字符传递给 &lt;code&gt;w&lt;/code&gt; 。使用并格式化了格式字符串中指定的尽可能多的参数。如果参数少于格式说明符，则将引发 &lt;code&gt;FormatException&lt;/code&gt; 。如果剩余的参数超出了格式规范的要求，则仅当格式化至少一个参数时，它们才会被忽略。</target>
        </trans-unit>
        <trans-unit id="fa8f9f636d8a6045425f97a32a164b87a688ed99" translate="yes" xml:space="preserve">
          <source>The variadic part is converted to a dynamic array and the rest is the same as for non-variadic functions.</source>
          <target state="translated">变量部分转化为动态数组,其余与非变量函数相同。</target>
        </trans-unit>
        <trans-unit id="4280e8c5fae666595a22ad15b85940850cfe38e7" translate="yes" xml:space="preserve">
          <source>The vector extensions are currently implemented for the OS X 32 bit target, and all 64 bit targets.</source>
          <target state="translated">目前,OS X 32位目标和所有64位目标都实现了向量扩展。</target>
        </trans-unit>
        <trans-unit id="9a3f2a8776586397a6e7f50b19626acf584f35ca" translate="yes" xml:space="preserve">
          <source>The vendor specific version number, as in version_major.version_minor</source>
          <target state="translated">厂商特定的版本号,如 version_major.version_minor。</target>
        </trans-unit>
        <trans-unit id="00e7fe40797e665c537b4d388116b4be59e896ff" translate="yes" xml:space="preserve">
          <source>The version of the D Programming Language Specification supported by the compiler.</source>
          <target state="translated">编译器支持的D编程语言规范的版本。</target>
        </trans-unit>
        <trans-unit id="349a4c5870066cd09694037d969de8543ecfc287" translate="yes" xml:space="preserve">
          <source>The version specification makes it straightforward to group a set of features under one major version, for example:</source>
          <target state="translated">例如,版本规范可以直接将一组功能归入一个主要版本。</target>
        </trans-unit>
        <trans-unit id="8bd1d61a79fbe94ca1f6332082364d1be24742ef" translate="yes" xml:space="preserve">
          <source>The vtable consists of:</source>
          <target state="translated">该表包括:</target>
        </trans-unit>
        <trans-unit id="f3b5820f28d3bae10a6ec27f163ae2a69ac3fe29" translate="yes" xml:space="preserve">
          <source>The way the type of</source>
          <target state="translated">类型的方式</target>
        </trans-unit>
        <trans-unit id="0fcc6679e5070c2e4f446305491364698920c76a" translate="yes" xml:space="preserve">
          <source>The way to read this is: start with negative meaning that all numbers smaller then the next one are not present in this set (and positive - the contrary). Then switch positive/negative after each number passed from left to right.</source>
          <target state="translated">解读的方法是:从负数开始,意味着所有小于下一个数字的数字都不在这个集合中(正数则相反)。然后在从左到右的每一个数字之后切换正/负数。</target>
        </trans-unit>
        <trans-unit id="ee95d5338e2cc507c044af212b980a2ccdb0be06" translate="yes" xml:space="preserve">
          <source>The week that each time point in the range will be.</source>
          <target state="translated">周,范围内的每个时间点将。</target>
        </trans-unit>
        <trans-unit id="cd65d21aaa17290a8030b106efe73434ab04b752" translate="yes" xml:space="preserve">
          <source>The worker threads in this pool will not stop until &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; is called, even if the main thread has finished already. This may lead to programs that never end. If you do not want this behaviour, you can set &lt;code&gt;isDaemon&lt;/code&gt; to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccaf69d731f86b374a2484d6db7113668b98a057" translate="yes" xml:space="preserve">
          <source>The worker treads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by the &lt;code&gt;taskPool&lt;/code&gt; property are daemon by default. The worker threads of manually instantiated task pools are non-daemon by default.</source>
          <target state="translated">默认情况下，由 &lt;code&gt;taskPool&lt;/code&gt; 属性返回的 &lt;code&gt;TaskPool&lt;/code&gt; 实例中的worker进程是守护程序。默认情况下，手动实例化的任务池的工作线程是非守护程序。</target>
        </trans-unit>
        <trans-unit id="032848bfda222930e013953265615c3e0ccbd961" translate="yes" xml:space="preserve">
          <source>The working directory for the new process. By default the child process inherits the parent's working directory.</source>
          <target state="translated">新进程的工作目录。默认情况下,子进程继承父进程的工作目录。</target>
        </trans-unit>
        <trans-unit id="5b0246698510343503660da61604a3af0a5e9947" translate="yes" xml:space="preserve">
          <source>The wrapped statement.</source>
          <target state="translated">包的声明。</target>
        </trans-unit>
        <trans-unit id="83d3fe39ddb643ccc2434ee8c1b4b3abc6a78d80" translate="yes" xml:space="preserve">
          <source>The wrapped type for which Nullable provides a null value.</source>
          <target state="translated">Nullable提供空值的封装类型。</target>
        </trans-unit>
        <trans-unit id="52054c2c6d64acc406d7bd018817d7a8a1e5c5bf" translate="yes" xml:space="preserve">
          <source>The write end of the pipe.</source>
          <target state="translated">管道的写端。</target>
        </trans-unit>
        <trans-unit id="d72f5499f6b8ab39b36f3e5d6ad25d6e2121747c" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的年份设置为BC 年。</target>
        </trans-unit>
        <trans-unit id="70438f0b3fdbdd369345e88c2fd45090d92cb7e3" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的年份设置为的BC 年。</target>
        </trans-unit>
        <trans-unit id="744d36d482072547f2d6e876741e0a75ffde2547" translate="yes" xml:space="preserve">
          <source>The year B.C. to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的年份设置为BC 年。</target>
        </trans-unit>
        <trans-unit id="645eb13622787fa8a0e2f12539a4222d12dcebc3" translate="yes" xml:space="preserve">
          <source>The year inside the ISO 8601 week calendar that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f253f2171ebe80090cc18ce562187b7793a28ea" translate="yes" xml:space="preserve">
          <source>The year of the ISO 8601 week calendar that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ffac4afd7dedd0db0cf62512494ecd5d03ce9b" translate="yes" xml:space="preserve">
          <source>The year of the day to validate.</source>
          <target state="translated">日的年份来验证。</target>
        </trans-unit>
        <trans-unit id="6a632533914c1a4222f015d798cec051375cb6c9" translate="yes" xml:space="preserve">
          <source>The year portion of the date.</source>
          <target state="translated">日期的年份部分。</target>
        </trans-unit>
        <trans-unit id="674f0ed2625d2fbf8d46e126ee7509b07e39337e" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的年份设置为的年份。</target>
        </trans-unit>
        <trans-unit id="78b3d4944643d10e9690ce8b16f07cee0b861543" translate="yes" xml:space="preserve">
          <source>The year to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s year to.</source>
          <target state="translated">将此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的年份设置为的年份。</target>
        </trans-unit>
        <trans-unit id="938c9fb56ce9737aba86f7a255d511c39f3f1219" translate="yes" xml:space="preserve">
          <source>The year to set this Date's year to.</source>
          <target state="translated">将这个Date的年份设定为。</target>
        </trans-unit>
        <trans-unit id="25dac3542e9629d3c6f770b554d3c9420550d89e" translate="yes" xml:space="preserve">
          <source>The year to to be tested.</source>
          <target state="translated">年待测。</target>
        </trans-unit>
        <trans-unit id="6dbbdf11fc9d313a566bcf1e2531faa610eda60f" translate="yes" xml:space="preserve">
          <source>The zip file format version needed to extract this member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05a3a1416ac42134535e13e8cceef19ad3efbf2" translate="yes" xml:space="preserve">
          <source>The ~= operator. It can have one of the following operators:</source>
          <target state="translated">~=运算符。它可以有以下运算符之一。</target>
        </trans-unit>
        <trans-unit id="483dc9258037e4ea0f71ce99febdf439cc645ac7" translate="yes" xml:space="preserve">
          <source>Then each of the arguments whose type does not match that of the delegate is converted to a delegate.</source>
          <target state="translated">然后将每个类型不符合委托人的参数转换为委托人。</target>
        </trans-unit>
        <trans-unit id="51ac7bc32bb46bc23b3538364d227ae9bc701e39" translate="yes" xml:space="preserve">
          <source>Then you can import the package containing the extern C++ declarations as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef903eb9cd7218e2998c6f06dec42c64cb3057d" translate="yes" xml:space="preserve">
          <source>ThenStatement</source>
          <target state="translated">ThenStatement</target>
        </trans-unit>
        <trans-unit id="cffa55acb530a469e1c0e72f460da047941e3e1e" translate="yes" xml:space="preserve">
          <source>There are advantages to storing bookkeeping data separated from the payload (as opposed to e.g. using &lt;code&gt;AffixAllocator&lt;/code&gt; to store metadata together with each allocation). The layout is more compact (overhead is one bit per block), searching for a free block during allocation enjoys better cache locality, and deallocation does not touch memory around the payload being deallocated (which is often cold).</source>
          <target state="translated">存储与有效负载分离的簿记数据具有优势（例如，与使用 &lt;code&gt;AffixAllocator&lt;/code&gt; 一起将元数据与每个分配存储在一起）。布局更紧凑（开销为每个块一位），在分配期间搜索空闲块享有更好的缓存局部性，并且释放不会触及正在释放的有效负载周围的内存（这通常很冷）。</target>
        </trans-unit>
        <trans-unit id="71da829c4cc0769086794220605ec04ef8da0ce9" translate="yes" xml:space="preserve">
          <source>There are eight usable logging level. These level are</source>
          <target state="translated">有8个可用的记录级别。这些级别是</target>
        </trans-unit>
        <trans-unit id="88bbdd16439c34d51b5285ff9a938ae545ede756" translate="yes" xml:space="preserve">
          <source>There are four kinds of arrays:</source>
          <target state="translated">阵列有四种。</target>
        </trans-unit>
        <trans-unit id="e137971ce6d07a865f890bb2bb72e21617522984" translate="yes" xml:space="preserve">
          <source>There are four overloads of this function. The first two take an array of strings, &lt;code&gt;args&lt;/code&gt;, which should contain the program name as the zeroth element and any command-line arguments in subsequent elements. The third and fourth versions are included for convenience, and may be used when there are no command-line arguments. They take a single string, &lt;code&gt;program&lt;/code&gt;, which specifies the program name.</source>
          <target state="translated">此函数有四个重载。前两个采用字符串数组 &lt;code&gt;args&lt;/code&gt; ，其中应包含程序名称作为第零个元素，并在后续元素中包含任何命令行参数。为了方便起见，包括了第三和第四版本，并且在没有命令行参数时可以使用它们。它们采用单个字符串 &lt;code&gt;program&lt;/code&gt; ，它指定程序名称。</target>
        </trans-unit>
        <trans-unit id="72dc9dd21f6b2060d2cd40a0fb38433822ac81cb" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="translated">此模块中有一些辅助函数，这些函数生成公共委托以传递给 &lt;code&gt;bwdRange&lt;/code&gt; 。他们的文档以&amp;ldquo;范围生成功能&amp;rdquo;开始，使其易于搜索。</target>
        </trans-unit>
        <trans-unit id="b5dd0af54e988a94be1d9ad088b9582f13489afd" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;bwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="translated">此模块中有一些辅助函数，这些函数生成公共委托以传递给 &lt;code&gt;bwdRange&lt;/code&gt; 。他们的文档以&amp;ldquo;范围生成功能&amp;rdquo;开始，以使其易于搜索。</target>
        </trans-unit>
        <trans-unit id="7d94c1629b0bd4094ede841815962ed80d0586ef" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; making them easily searchable.</source>
          <target state="translated">此模块中有一些辅助函数，这些函数生成公共委托以传递给 &lt;code&gt;fwdRange&lt;/code&gt; 。他们的文档以&amp;ldquo;范围生成功能&amp;rdquo;开始，使其易于搜索。</target>
        </trans-unit>
        <trans-unit id="4b9f6a69e089c92a07a88022f54475869259bbc2" translate="yes" xml:space="preserve">
          <source>There are helper functions in this module which generate common delegates to pass to &lt;code&gt;fwdRange&lt;/code&gt;. Their documentation starts with &quot;Range-generating function,&quot; to make them easily searchable.</source>
          <target state="translated">此模块中有一些辅助函数，这些函数生成公共委托以传递给 &lt;code&gt;fwdRange&lt;/code&gt; 。他们的文档以&amp;ldquo;范围生成功能&amp;rdquo;开始，以使其易于搜索。</target>
        </trans-unit>
        <trans-unit id="fd1414ed61178080af45a1f5ca51914c6e9d26e1" translate="yes" xml:space="preserve">
          <source>There are many articles available that can bolster understanding ranges:</source>
          <target state="translated">有很多文章可以支撑理解范围。</target>
        </trans-unit>
        <trans-unit id="c2d037a1149b17d68159307022f28fe56d8f92d3" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt;&lt;/a&gt;, or other such C &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;extended type modifiers&lt;/a&gt; in D. These are handled by &lt;a href=&quot;attribute#linkage&quot;&gt;linkage attributes&lt;/a&gt;, such as &lt;code&gt;extern (C)&lt;/code&gt;.</source>
          <target state="translated">有没有 &lt;code&gt;__cdecl&lt;/code&gt; ， &lt;code&gt;__far&lt;/code&gt; ， &lt;code&gt;__stdcall&lt;/code&gt; ，&lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#declspec&quot;&gt; &lt;code&gt;__declspec&lt;/code&gt; &lt;/a&gt;，或其它这样的&amp;Ccedil; &lt;a href=&quot;http://www.digitalmars.com/ctg/ctgLanguageImplementation.html#extended&quot;&gt;扩展型改性剂&lt;/a&gt;中D.这些通过处理&lt;a href=&quot;attribute#linkage&quot;&gt;联动的属性&lt;/a&gt;，诸如 &lt;code&gt;extern (C)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b9f66c209295069e84d0b1adcf2cd5cdb6933de" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__far&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt;, &lt;code&gt;__declspec&lt;/code&gt;, or other such nonstandard C++ extensions in D.</source>
          <target state="translated">有没有 &lt;code&gt;__cdecl&lt;/code&gt; ， &lt;code&gt;__far&lt;/code&gt; ， &lt;code&gt;__stdcall&lt;/code&gt; ， &lt;code&gt;__declspec&lt;/code&gt; ，或在D.其它这样的非标准C ++扩展</target>
        </trans-unit>
        <trans-unit id="b1bbd1ded800fb7f0f4f094477d38ab432c667c3" translate="yes" xml:space="preserve">
          <source>There are no volatile type modifiers in D.</source>
          <target state="translated">D中没有挥发型修饰词。</target>
        </trans-unit>
        <trans-unit id="bf7de3e93eae097ffa9c0cf65d8e97655fc5a893" translate="yes" xml:space="preserve">
          <source>There are other web resources on regular expressions to help newcomers, and a good &lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;reference with tutorial&lt;/a&gt; can easily be found.</source>
          <target state="translated">正则表达式上还有其他Web资源可以帮助新手，并且可以轻松找到&lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;教程&lt;/a&gt;的良好参考。</target>
        </trans-unit>
        <trans-unit id="6c5539350a7f6635346ecf0167abeb30fa2fea73" translate="yes" xml:space="preserve">
          <source>There are several forms of the</source>
          <target state="translated">有几种形式</target>
        </trans-unit>
        <trans-unit id="6bdc06ec8e2f529ede508fc3fd01087470669fa0" translate="yes" xml:space="preserve">
          <source>There are several things going on here:</source>
          <target state="translated">这里有几件事。</target>
        </trans-unit>
        <trans-unit id="06fc1953f9bbd669c6940d581b7a118ebf65b6cd" translate="yes" xml:space="preserve">
          <source>There are several workarounds for this limitation:</source>
          <target state="translated">对于这个限制,有几种变通方法。</target>
        </trans-unit>
        <trans-unit id="83683e99bdd11374a698bc33993ac450a4156b31" translate="yes" xml:space="preserve">
          <source>There are three categories of functions from the perspective of memory safety:</source>
          <target state="translated">从内存安全的角度看,有三类功能。</target>
        </trans-unit>
        <trans-unit id="eebb936bce7d3ae26cde36cf7bb35604dacc5791" translate="yes" xml:space="preserve">
          <source>There are three kinds of comments:</source>
          <target state="translated">有三种意见。</target>
        </trans-unit>
        <trans-unit id="0ec3b7350c3966a7a5f315773f8a0d6461bc2b7c" translate="yes" xml:space="preserve">
          <source>There are two APIs for digests: The template API and the OOP API. The template API uses structs and template helpers like &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;. The OOP API implements digests as classes inheriting the &lt;a href=&quot;#Digest&quot;&gt;&lt;code&gt;Digest&lt;/code&gt;&lt;/a&gt; interface. All digests are named so that the template API struct is called &quot;&lt;b&gt;x&lt;/b&gt;&quot; and the OOP API class is called &quot;&lt;b&gt;x&lt;/b&gt;Digest&quot;. For example we have &lt;code&gt;MD5&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt;, &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;--&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt;, etc.</source>
          <target state="translated">有两种用于摘要的API：模板API和OOP API。模板API使用结构和模板助手，例如&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;。 OOP API将摘要实现为继承&lt;a href=&quot;#Digest&quot;&gt; &lt;code&gt;Digest&lt;/code&gt; &lt;/a&gt;接口的类。所有摘要均已命名，因此模板API结构被称为&amp;ldquo; &lt;b&gt;x&lt;/b&gt; &amp;rdquo;，而OOP API类被称为&amp;ldquo; &lt;b&gt;x&lt;/b&gt; Digest&amp;rdquo;。例如，我们有 &lt;code&gt;MD5&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;MD5Digest&lt;/code&gt; ， &lt;code&gt;CRC32&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;CRC32Digest&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="f36743287cbe9730e4d00f520be725403f6d9245" translate="yes" xml:space="preserve">
          <source>There are two broad kinds of operations to do on an array - affecting the handle to the array, and affecting the contents of the array.</source>
          <target state="translated">在数组上有两大类操作--影响数组的句柄和影响数组的内容。</target>
        </trans-unit>
        <trans-unit id="355137d832c3c393499aa7072985b4778468466a" translate="yes" xml:space="preserve">
          <source>There are two categories of overloads in this template: the first one does a simple compare-and-set, and returns a boolean if the operation happened. The value this is written (&lt;code&gt;writeThis&lt;/code&gt;) can be an rvalue. the second category does a compare-and-swap, or compare-and-exchange, and expects &lt;code&gt;writeThis&lt;/code&gt; to be a pointer type, where the previous value of &lt;code&gt;here&lt;/code&gt; will be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1096c19f131f18fc7530f2ce040303f511bfe2" translate="yes" xml:space="preserve">
          <source>There are two main ways of usage: Extracting files from a zip archive and storing files into a zip archive. These can be mixed though (e.g. read an archive, remove some files, add others and write the new archive).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f32e0774371c9709a85def64d98a62e794b8e4d" translate="yes" xml:space="preserve">
          <source>There are two options for handlers. The &lt;code&gt;bool&lt;/code&gt; version is deprecated but will be kept for legacy support. Returning &lt;code&gt;true&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.pass&lt;/code&gt; from the extended version. Returning &lt;code&gt;false&lt;/code&gt; from the handler is equivalent to returning &lt;code&gt;UnitTestResult.fail&lt;/code&gt; from the extended version.</source>
          <target state="translated">处理程序有两个选项。该 &lt;code&gt;bool&lt;/code&gt; 版本已弃用，但会保留传统支持。从处理程序返回 &lt;code&gt;true&lt;/code&gt; 等同于从扩展版本返回 &lt;code&gt;UnitTestResult.pass&lt;/code&gt; 。从处理程序中返回 &lt;code&gt;false&lt;/code&gt; 等同于从扩展版本中返回 &lt;code&gt;UnitTestResult.fail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ba98a9e569b41d605493fc4327d51d93311f773" translate="yes" xml:space="preserve">
          <source>There are two ways of using tilde expansion in a path. One involves using the tilde alone or followed by a path separator. In this case, the tilde will be expanded with the value of the environment variable &lt;code&gt;HOME&lt;/code&gt;. The second way is putting a username after the tilde (i.e. &lt;code&gt;~john/Mail&lt;/code&gt;). Here, the username will be searched for in the user database (i.e. &lt;code&gt;/etc/passwd&lt;/code&gt; on Unix systems) and will expand to whatever path is stored there. The username is considered the string after the tilde ending at the first instance of a path separator.</source>
          <target state="translated">有两种在路径中使用波浪号扩展的方法。其中之一是单独使用波浪号，或者使用路径分隔符。在这种情况下，代字号将使用环境变量 &lt;code&gt;HOME&lt;/code&gt; 的值扩展。第二种方法是将用户名放在波浪号后面（即 &lt;code&gt;~john/Mail&lt;/code&gt; ）。在这里，将在用户数据库（即Unix系统上的 &lt;code&gt;/etc/passwd&lt;/code&gt; ）中搜索用户名，并将其扩展到存储在其中的任何路径。用户名被视为波浪符号后的字符串，该字符串在路径分隔符的第一个实例处结束。</target>
        </trans-unit>
        <trans-unit id="4751b63f33932c16045492e8c9d0524f058f4c0a" translate="yes" xml:space="preserve">
          <source>There are two ways to declarate a symbol as member of a namespace: &lt;code&gt;Nspace&lt;/code&gt; and &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt;. The former creates a scope for the symbol, and inject them in the parent scope at the same time. The later, this class, has no semantic implications and is only used for mangling. Additionally, this class allows one to use reserved identifiers (D keywords) in the namespace.</source>
          <target state="translated">有两种方法可以将符号声明为名称空间的成员： &lt;code&gt;Nspace&lt;/code&gt; 和 &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt; 。前者为符号创建作用域，然后将其同时注入父作用域。后面的类没有语义含义，仅用于修饰。另外，此类允许一个人在名称空间中使用保留的标识符（D关键字）。</target>
        </trans-unit>
        <trans-unit id="87bb5bc4a10799fcef3cdb638af33c37c5ac5274" translate="yes" xml:space="preserve">
          <source>There can be any number of unit test functions in a module, including within struct, union and class declarations. They are executed in lexical order.</source>
          <target state="translated">在一个模块中可以有任何数量的单元测试函数,包括在结构、联合和类的声明中。它们是按照词法顺序执行的。</target>
        </trans-unit>
        <trans-unit id="ed108d2e4ffaebbc3cca03de1cfa2dee10188c4a" translate="yes" xml:space="preserve">
          <source>There can be more than one invariant declared per class or struct.</source>
          <target state="translated">每个类或结构可以声明一个以上的不变量。</target>
        </trans-unit>
        <trans-unit id="07b99c3830a2a4bb0228e8b9b17dd7669ccd56c2" translate="yes" xml:space="preserve">
          <source>There can be multiple documented unittests and they can appear in any order. They will be attached to the last non-unittest declaration:</source>
          <target state="translated">可以有多个记录的单元测试,它们可以以任何顺序出现。它们将被附加到最后一个非unittest声明中。</target>
        </trans-unit>
        <trans-unit id="a95e25d0165fbf5408fd68a513879e3e08629026" translate="yes" xml:space="preserve">
          <source>There can be multiple static constructors and static destructors within one module. The static constructors are run in lexical order, the static destructors are run in reverse lexical order.</source>
          <target state="translated">在一个模块中可以有多个静态构造函数和静态破坏函数,静态构造函数按词法顺序运行,静态破坏函数按反向词法顺序运行。静态构造函数按词法顺序运行,静态破坏函数按相反的词法顺序运行。</target>
        </trans-unit>
        <trans-unit id="079786d2cc065de51998cade65524ac448945bab" translate="yes" xml:space="preserve">
          <source>There can be only one destructor per class, the destructor does not have any parameters, and has no attributes. It is always virtual.</source>
          <target state="translated">每个类只能有一个destructor,destructor没有任何参数,也没有属性。它永远是虚拟的。</target>
        </trans-unit>
        <trans-unit id="a32fb137b8708f3a1060842effbe53862ee224b5" translate="yes" xml:space="preserve">
          <source>There can be only zero or one</source>
          <target state="translated">只能有零或一</target>
        </trans-unit>
        <trans-unit id="997178780ab769837ddb59d8efa52d7b04a80956" translate="yes" xml:space="preserve">
          <source>There can only be one such attribute per symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54e87553bcbc89bb92a0dbc881f7633b6a68acf" translate="yes" xml:space="preserve">
          <source>There has been a great deal of discussion in the D newsgroups over this, and several implementations:  &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;signal slots library&lt;/a&gt;</source>
          <target state="translated">D新闻组对此进行了大量讨论，并讨论了几种实现方式： &lt;a href=&quot;http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html&quot;&gt;信号槽库&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb4241af492e556aa6aed9941d820f825c722aec" translate="yes" xml:space="preserve">
          <source>There have been several D implementations of Signals and Slots. This version makes use of several new features in D, which make using it simpler and less error prone. In particular, it is no longer necessary to instrument the slots.</source>
          <target state="translated">信号和槽的D版实现已经有好几个了。这个版本利用了D中的一些新特性,使其使用更加简单,不易出错。特别是,不再需要对槽进行仪表化。</target>
        </trans-unit>
        <trans-unit id="137e54850bfef26233dbe4876142a62cdeee9d88" translate="yes" xml:space="preserve">
          <source>There is a hierarchy of allocation kinds. When an allocator is implemented for a given combination of flags, it is used. Otherwise, the next down the list is chosen.</source>
          <target state="translated">分配器的种类是有层次的。当给定的标志组合有一个分配器时,就会使用它。否则,就会选择下一个分配器。</target>
        </trans-unit>
        <trans-unit id="fb4bb1493d0166938db3cf214276bbc597f0dc3b" translate="yes" xml:space="preserve">
          <source>There is a rich set of functions for string handling defined in other modules. Functions related to Unicode and ASCII are found in &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_ascii&quot;&gt;&lt;code&gt;std.ascii&lt;/code&gt;&lt;/a&gt;, respectively. Other functions that have a wider generality than just strings can be found in &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">There is a rich set of functions for string handling defined in other modules. Functions related to Unicode and ASCII are found in &lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;std_ascii&quot;&gt; &lt;code&gt;std.ascii&lt;/code&gt; &lt;/a&gt;, respectively. Other functions that have a wider generality than just strings can be found in &lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="567058ffed748f85071d989bbf1a314374e793b2" translate="yes" xml:space="preserve">
          <source>There is a special type of array which acts as a wildcard that can hold arrays of any kind, declared as &lt;code&gt;void[]&lt;/code&gt;. Void arrays are used for low-level operations where some kind of array data is being handled, but the exact type of the array elements are unimportant. The &lt;code&gt;.length&lt;/code&gt; of a void array is the length of the data in bytes, rather than the number of elements in its original type. Array indices in indexing and slicing operations are interpreted as byte indices.</source>
          <target state="translated">有一种特殊类型的数组，它充当通配符，可以保存任何声明为 &lt;code&gt;void[]&lt;/code&gt; 数组。空数组用于处理某些数组数据的低级操作，但是数组元素的确切类型并不重要。空数组的 &lt;code&gt;.length&lt;/code&gt; 是数据的长度（以字节为单位），而不是其原始类型中的元素数。索引和切片操作中的数组索引被解释为字节索引。</target>
        </trans-unit>
        <trans-unit id="33cea21ca6b34b343eb25bbde6ebec03ec759bdc" translate="yes" xml:space="preserve">
          <source>There is currently only one special token sequence, &lt;code&gt;#line&lt;/code&gt;.</source>
          <target state="translated">当前只有一个特殊的令牌序列 &lt;code&gt;#line&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef49fac97d8d2e188e2b78d1a813470cc50ed39b" translate="yes" xml:space="preserve">
          <source>There is currently work in progress to make the runtime library free of GC heap allocations, to allow its use in scenarios where the use of GC infrastructure is not possible.</source>
          <target state="translated">目前正在努力使运行时库摆脱GC堆分配,以便在不可能使用GC基础设施的场景中使用它。</target>
        </trans-unit>
        <trans-unit id="4d933b4164fe170e150ab2367873a597423583d2" translate="yes" xml:space="preserve">
          <source>There is no more need to translate error codes into human readable strings, the correct string is generated by the error detection code, not the error recovery code. This also leads to consistent error messages for the same error between applications.</source>
          <target state="translated">不再需要将错误代码翻译成人类可读的字符串,正确的字符串由错误检测代码生成,而不是错误恢复代码。这也导致了不同应用程序之间相同错误的错误信息的一致性。</target>
        </trans-unit>
        <trans-unit id="f17b623fe683ff68f6ed189b8d0d74d5452c95d7" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 不会占用 &lt;code&gt;NegInfInterval&lt;/code&gt; 的重载，因为不可能有从负无穷大到正无穷大的间隔。</target>
        </trans-unit>
        <trans-unit id="e26153f4d19858ed80c05ff7d79d4191b5074d49" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;merge&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 不会占用 &lt;code&gt;PosInfInterval&lt;/code&gt; 的重载，因为不可能有从负无穷大到正无穷大的间隔。</target>
        </trans-unit>
        <trans-unit id="5f100a7a77aee94633ec1e2fffc1096ce477240e" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;NegInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">没有占用 &lt;code&gt;NegInfInterval&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt; 过载，因为不可能有从负无穷大到正无穷大的间隔。</target>
        </trans-unit>
        <trans-unit id="5ac7b0e8d9f0ebf981b0a2590d75065c28e84b23" translate="yes" xml:space="preserve">
          <source>There is no overload for &lt;code&gt;span&lt;/code&gt; which takes a &lt;code&gt;PosInfInterval&lt;/code&gt;, because an interval going from negative infinity to positive infinity is not possible.</source>
          <target state="translated">没有一个需要 &lt;code&gt;PosInfInterval&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt; 过载，因为从负无穷大到正无穷大的间隔是不可能的。</target>
        </trans-unit>
        <trans-unit id="f2973bc2fd6add6e6231856c6dedc987f0924540" translate="yes" xml:space="preserve">
          <source>There is no remove command functionality. Do a &lt;a href=&quot;#clearCommands&quot;&gt;&lt;code&gt;clearCommands&lt;/code&gt;&lt;/a&gt; and set the needed commands instead.</source>
          <target state="translated">没有删除命令功能。执行&lt;a href=&quot;#clearCommands&quot;&gt; &lt;code&gt;clearCommands&lt;/code&gt; &lt;/a&gt;并设置所需的命令。</target>
        </trans-unit>
        <trans-unit id="5030f2329ed730fd9eebd4cf5437fa2be5db1b38" translate="yes" xml:space="preserve">
          <source>There is no remove header functionality. Do a &lt;a href=&quot;#clearRequestHeaders&quot;&gt;&lt;code&gt;clearRequestHeaders&lt;/code&gt;&lt;/a&gt; and set the needed headers instead.</source>
          <target state="translated">没有删除标头功能。执行&lt;a href=&quot;#clearRequestHeaders&quot;&gt; &lt;code&gt;clearRequestHeaders&lt;/code&gt; &lt;/a&gt;并设置所需的标头。</target>
        </trans-unit>
        <trans-unit id="97b11eff895aae8a00d7fa461823417d322a76c8" translate="yes" xml:space="preserve">
          <source>There is no virtual table.</source>
          <target state="translated">没有虚拟表。</target>
        </trans-unit>
        <trans-unit id="5dac0a061658caed895ea08b3637f43c40d7da9d" translate="yes" xml:space="preserve">
          <source>There is no volatile type modifier in D. To declare a C function that uses volatile, just drop the keyword from the declaration.</source>
          <target state="translated">D中没有volatile类型修饰符,如果要声明一个使用volatile的C函数,只需在声明中去掉关键字即可。</target>
        </trans-unit>
        <trans-unit id="2434d329704768f135cc60da2cb84c7ba22ac13f" translate="yes" xml:space="preserve">
          <source>There is one exception to the fact that the new type is not related to the old type. &lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;Pseudo-member&lt;/a&gt; functions are usable with the new type; they will be forwarded on to the proxied value.</source>
          <target state="translated">新类型与旧类型无关的事实是一个例外。&lt;a href=&quot;https://dlang.org/spec/function.html#pseudo-member&quot;&gt;伪成员&lt;/a&gt;函数可与新类型一起使用。他们将被转发到代理价值。</target>
        </trans-unit>
        <trans-unit id="ba21f8033d033a747c90b386e1729af20f18ceb8" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a class. They are applied in lexical order.</source>
          <target state="translated">一个类中可能有多个不变量。它们是按词法顺序应用的。</target>
        </trans-unit>
        <trans-unit id="9a039cc903df4604c54902450e403871fe046481" translate="yes" xml:space="preserve">
          <source>There may be multiple invariants in a struct. They are applied in lexical order.</source>
          <target state="translated">一个结构中可能有多个不变量。它们是按词法顺序应用的。</target>
        </trans-unit>
        <trans-unit id="d77d0c2b7a22ee08dcc65faf1983734627d5bea1" translate="yes" xml:space="preserve">
          <source>There may be one or more callable entities (&lt;code&gt;functions&lt;/code&gt; argument) to apply.</source>
          <target state="translated">可能有一个或多个可调用的实体（ &lt;code&gt;functions&lt;/code&gt; 参数）要应用。</target>
        </trans-unit>
        <trans-unit id="32ca8690590fc77f40e2a27fd064159d0d52468b" translate="yes" xml:space="preserve">
          <source>There must be at least one non-variadic parameter declared.</source>
          <target state="translated">必须至少声明一个非变量参数。</target>
        </trans-unit>
        <trans-unit id="60b895f637fb0461c08aa3c29c276b9513bb30e3" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a function symbol.</source>
          <target state="translated">必须有一个&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression，&lt;/i&gt;&lt;/a&gt;并且它必须在编译时对函数符号求值。</target>
        </trans-unit>
        <trans-unit id="ed59ba7f34618cfcf4f2f62b488d49f3556f524b" translate="yes" xml:space="preserve">
          <source>There must be one &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it must evaluate at compile time to a string literal.</source>
          <target state="translated">必须有一个&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression，&lt;/i&gt;&lt;/a&gt;并且它必须在编译时计算为字符串文字。</target>
        </trans-unit>
        <trans-unit id="9800621b870999653a584633cd52d141e5fbaea7" translate="yes" xml:space="preserve">
          <source>There's only one instance of each module, and it is statically allocated.</source>
          <target state="translated">每个模块只有一个实例,而且是静态分配的。</target>
        </trans-unit>
        <trans-unit id="2acf8c215fcf96c4f44ab4510da81603fd6cc2b3" translate="yes" xml:space="preserve">
          <source>Therefore, it is the programmer's responsibility to ensure that &lt;code&gt;opCmp&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; are consistent with each other. If &lt;code&gt;opEquals&lt;/code&gt; is not specified, the compiler provides a default version that does member-wise comparison. If this suffices, one may define only &lt;code&gt;opCmp&lt;/code&gt; to customize the behaviour of the inequality operators. But if not, then a custom version of &lt;code&gt;opEquals&lt;/code&gt; should be defined as well, in order to preserve consistent semantics between the two kinds of comparison operators.</source>
          <target state="translated">因此，程序员有责任确保 &lt;code&gt;opCmp&lt;/code&gt; 和 &lt;code&gt;opEquals&lt;/code&gt; 彼此一致。如果未指定 &lt;code&gt;opEquals&lt;/code&gt; ，则编译器将提供一个默认版本，该版本会进行成员比较。如果足够，可以只定义 &lt;code&gt;opCmp&lt;/code&gt; 来自定义不等式运算符的行为。但是，如果没有，则还应该定义 &lt;code&gt;opEquals&lt;/code&gt; 的自定义版本，以保留两种比较运算符之间的一致语义。</target>
        </trans-unit>
        <trans-unit id="f6272f7f8273a14bd5544dddbcb1b98032093e68" translate="yes" xml:space="preserve">
          <source>These allow you to construct a &lt;code&gt;Duration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="translated">这些允许您从具有给定长度的给定时间单位构造 &lt;code&gt;Duration&lt;/code&gt; 时间。</target>
        </trans-unit>
        <trans-unit id="da7cf3cb33f506c60b3bae2d7621731fe8a25b5a" translate="yes" xml:space="preserve">
          <source>These are a temporary means of providing a GC hook for DLL use. They may be replaced with some other similar functionality later.</source>
          <target state="translated">这些是为DLL的使用提供GC钩子的一种临时手段。以后可能会被其他类似的功能所取代。</target>
        </trans-unit>
        <trans-unit id="6b408f5f827798e4336b44c606a3a8049fa5f385" translate="yes" xml:space="preserve">
          <source>These are convenience aliases for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the SHA implementation.</source>
          <target state="translated">这些是使用SHA实现的&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; 的&lt;/a&gt;方便别名。</target>
        </trans-unit>
        <trans-unit id="cc11c250252b92e0b68a712fc50db2f954bbf31e" translate="yes" xml:space="preserve">
          <source>These are found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;rt/&lt;/a&gt;.</source>
          <target state="translated">这些可以在Druntime的&lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/&quot;&gt;rt /&lt;/a&gt;中找到。</target>
        </trans-unit>
        <trans-unit id="d82964c86f7448130324ef200af867ae90f45f65" translate="yes" xml:space="preserve">
          <source>These are mostly undocumented, as documentation for the functions these declarations provide bindings to can be found on external resources.</source>
          <target state="translated">这些声明大多是无文档的,因为这些声明提供绑定的函数的文档可以在外部资源中找到。</target>
        </trans-unit>
        <trans-unit id="a0b799b4059387b1ffa81eb5e832597a15aaf9ea" translate="yes" xml:space="preserve">
          <source>These are not directly overloadable, but instead are rewritten in terms of the ++</source>
          <target state="translated">这些都是不能直接过载的,而是用++的方式重写的。</target>
        </trans-unit>
        <trans-unit id="684251477ee92646066796884e053236894cc9d8" translate="yes" xml:space="preserve">
          <source>These are not to be conflated with atomic operations. They do not guarantee any atomicity. This may be provided by coincidence as a result of the instructions used on the target, but this should not be relied on for portable programs. Further, no memory fences are implied by these functions. They should not be used for communication between threads. They may be used to guarantee a write or read cycle occurs at a specified address.</source>
          <target state="translated">这些不能与原子操作混为一谈。它们不保证任何原子性。这可能是由于在目标上使用的指令的巧合而提供的,但对于可移植程序来说,不应该依赖这一点。此外,这些函数没有暗示任何内存栅栏。它们不应该用于线程之间的通信。它们可用于保证写或读周期发生在指定地址。</target>
        </trans-unit>
        <trans-unit id="ebd50df5a290d3b9f19a683a307dc1ce5e6fed02" translate="yes" xml:space="preserve">
          <source>These are of type &lt;code&gt;bool&lt;/code&gt; and when cast to another integral type become the values 1 and 0, respectively.</source>
          <target state="translated">它们是 &lt;code&gt;bool&lt;/code&gt; 类型，当转换为另一个整数类型时，其值分别为1和0。</target>
        </trans-unit>
        <trans-unit id="812c2acf872ebe10657aaa2bbdf1807e2d587d11" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-debug=&lt;/code&gt;</source>
          <target state="translated">这些大概是在命令行中设置为 &lt;code&gt;-debug=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c1d2e1e32630d5e744bf290c6e49eb16fa04f9" translate="yes" xml:space="preserve">
          <source>These are presumably set by the command line as &lt;code&gt;-version=n&lt;/code&gt; and &lt;code&gt;-version=identifier&lt;/code&gt;.</source>
          <target state="translated">大概在命令行中将它们设置为 &lt;code&gt;-version=n&lt;/code&gt; 和 &lt;code&gt;-version=identifier&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2ddfd41f42add825e0e95354286885963260165" translate="yes" xml:space="preserve">
          <source>These are the return codes for the seek callbacks</source>
          <target state="translated">这些是seek回调的返回代码。</target>
        </trans-unit>
        <trans-unit id="402db899657981891e40b75b734371cded453058" translate="yes" xml:space="preserve">
          <source>These are the same kinds of scenarios where different optimization settings affect the results.</source>
          <target state="translated">这些都是同种情况下,不同的优化设置会影响结果。</target>
        </trans-unit>
        <trans-unit id="1b6a4816df5dd7b7abf0b558eca9229ade75c78d" translate="yes" xml:space="preserve">
          <source>These arrays are statically allocated when they appear in global scope. Otherwise, they need to be marked with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; storage classes to make them statically allocated arrays.</source>
          <target state="translated">这些数组出现在全局范围中时将被静态分配。否则，需要将它们标记为 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 存储类，以使其成为静态分配的数组。</target>
        </trans-unit>
        <trans-unit id="89a145122969b840110b2fc3e84b6ee09c611afa" translate="yes" xml:space="preserve">
          <source>These attributes may appear after the formal parameter list, in which case they apply either to a method's &lt;code&gt;this&lt;/code&gt; parameter, or to a free function's first parameter</source>
          <target state="translated">这些属性可能出现在形式参数列表之后，在这种情况下，它们要么应用于方法的 &lt;code&gt;this&lt;/code&gt; 参数，要么应用于自由函数的第一个参数。</target>
        </trans-unit>
        <trans-unit id="a7f7fc51e48ac814a4df7b5cf79166bee33de381" translate="yes" xml:space="preserve">
          <source>These attributes may be inferred when the compiler has the function body available, such as with templates.</source>
          <target state="translated">这些属性可以在编译器有函数体可用时推断出来,比如用模板。</target>
        </trans-unit>
        <trans-unit id="2c92e5f8eec2fac65821b6ee901edef5b0d32346" translate="yes" xml:space="preserve">
          <source>These behaviors may be specified when a mailbox is full.</source>
          <target state="translated">当邮箱已满时,可指定这些行为。</target>
        </trans-unit>
        <trans-unit id="36131b1e9db1f47f4a6ae00babc38af51f8234a5" translate="yes" xml:space="preserve">
          <source>These characters are not normally used in isolation unless they are being described. They include such characters as accents, diacritics, Hebrew points, Arabic vowel signs, and Indic matras.</source>
          <target state="translated">这些字符通常不单独使用,除非正在描述它们。它们包括重音、双音符、希伯来语点、阿拉伯语元音符号和印地语母音等字符。</target>
        </trans-unit>
        <trans-unit id="5af07f8dc23a2ff314c5b53d75ac93fc8390edf4" translate="yes" xml:space="preserve">
          <source>These compound format specifiers may be nested in the case of a nested array argument:</source>
          <target state="translated">在嵌套数组参数的情况下,这些复合格式指定符可以被嵌套。</target>
        </trans-unit>
        <trans-unit id="636ef2d434aea6975bee7e2e69eaea244d21ce1f" translate="yes" xml:space="preserve">
          <source>These constraints are addressed by techniques outlined in &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;Memory Management&lt;/a&gt;, including the mechanisms provided by D to control allocations outside the GC heap.</source>
          <target state="translated">这些限制通过&amp;ldquo; &lt;a href=&quot;https://wiki.dlang.org/Memory_Management&quot;&gt;内存管理&amp;rdquo;中&lt;/a&gt;概述的技术来解决，其中包括D提供的用于控制GC堆外部分配的机制。</target>
        </trans-unit>
        <trans-unit id="ce5525a7da98014873ce5f20228128913e88d54f" translate="yes" xml:space="preserve">
          <source>These declarations are transformed into templates:</source>
          <target state="translated">这些声明被转化为模板。</target>
        </trans-unit>
        <trans-unit id="cd87aa675633720f30baafcf6365c73aa7dc6850" translate="yes" xml:space="preserve">
          <source>These directories are recognized by some tools, like the Objective-C compiler and linker, to be frameworks. To link with a framework from DMD, use the following flags:</source>
          <target state="translated">这些目录被一些工具,比如Objective-C编译器和链接器,识别为框架。要与DMD中的框架链接,请使用以下标志。</target>
        </trans-unit>
        <trans-unit id="2db5010283f3eff8277b4bb683d65dd36da0605f" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_HTTP_VERSION option.</source>
          <target state="translated">这些枚举与CURLOPT_HTTP_VERSION选项一起使用。</target>
        </trans-unit>
        <trans-unit id="66b51419f8ca45e5302436f93fca4afec04366fd" translate="yes" xml:space="preserve">
          <source>These enums are for use with the CURLOPT_NETRC option.</source>
          <target state="translated">这些枚举与CURLOPT_NETRC选项一起使用。</target>
        </trans-unit>
        <trans-unit id="792d4e3a997f4a55954321b6a67c17e920eebf88" translate="yes" xml:space="preserve">
          <source>These equivalents hold for most C compilers. The C standard does not pin down the sizes of the types, so some care is needed.</source>
          <target state="translated">这些等价物适用于大多数C编译器。C标准并没有明确规定类型的大小,所以需要注意。</target>
        </trans-unit>
        <trans-unit id="dd5b42710c6e5261013fdb1ae53fc4cbc41fd9bf" translate="yes" xml:space="preserve">
          <source>These equivalents hold when the D and C++ compilers used are companions on the host platform.</source>
          <target state="translated">当使用的D和C++编译器是主机平台上的同伴时,这些等价物成立。</target>
        </trans-unit>
        <trans-unit id="90ade43ed5cb1a3092e67126f0f81a88dfd49b38" translate="yes" xml:space="preserve">
          <source>These extensions can be pretty-printed by &lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm&lt;/a&gt;. The &lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg&lt;/a&gt; debugger supports them.</source>
          <target state="translated">这些扩展名可以由&lt;a href=&quot;http://www.digitalmars.com/ctg/obj2asm.html&quot;&gt;obj2asm&lt;/a&gt;打印。该&lt;a href=&quot;http://ddbg.mainia.de/releases.html&quot;&gt;Ddbg&lt;/a&gt;调试器支持他们。</target>
        </trans-unit>
        <trans-unit id="ad13d21d22689769fb2cd4c608e9e8fc232324fc" translate="yes" xml:space="preserve">
          <source>These field were added in CURLVERSION_FOURTH. Same as 'libiconv_version' if built with HAVE_ICONV</source>
          <target state="translated">这些字段是在CURLVERSION_FOURTH中添加的。如果使用HAVE_ICONV构建,则与'libiconv_version'相同。</target>
        </trans-unit>
        <trans-unit id="507497a0514f5bd17890a554cbbbf16c831493b7" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent a complex attribute.</source>
          <target state="translated">这些标志可以用位数OR-一起表示一个复杂的属性。</target>
        </trans-unit>
        <trans-unit id="0046ed397526fe785a54f9113f894289f9d20106" translate="yes" xml:space="preserve">
          <source>These flags can be bitwise OR-ed together to represent complex storage class.</source>
          <target state="translated">这些标志可以用位数OR-一起表示复杂的存储类。</target>
        </trans-unit>
        <trans-unit id="91bde2af8a3dc4b91f2f8c73ebb091513ee7a69a" translate="yes" xml:space="preserve">
          <source>These flags can be set/reset via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;core.stdc.fenv&lt;/code&gt; 中的函数设置/重置这些标志。</target>
        </trans-unit>
        <trans-unit id="10b77f7a0eebb3e7a656fbdfd23d4cee9e1bc0e6" translate="yes" xml:space="preserve">
          <source>These flags indicate that an exceptional floating-point condition has occurred. They indicate that a NaN or an infinity has been generated, that a result is inexact, or that a signalling NaN has been encountered. If floating-point exceptions are enabled (unmasked), a hardware exception will be generated instead of setting these flags.</source>
          <target state="translated">这些标志表示发生了一个特殊的浮点条件,它们表示产生了一个NaN或无穷大,结果不精确,或者遇到了一个信号NaN。它们表示产生了一个NaN或无穷大,结果不精确,或者遇到了一个信号NaN。如果启用了浮点异常(未屏蔽),则会产生一个硬件异常,而不是设置这些标志。</target>
        </trans-unit>
        <trans-unit id="e250dcdba1c724b4c5950d43225e8f190c1411c5" translate="yes" xml:space="preserve">
          <source>These functions allow getting and setting the OS scheduling priority of the worker threads in this &lt;code&gt;TaskPool&lt;/code&gt;. They forward to &lt;code&gt;core.thread.Thread.priority&lt;/code&gt;, so a given priority value here means the same thing as an identical priority value in &lt;code&gt;core.thread&lt;/code&gt;.</source>
          <target state="translated">这些功能允许在此 &lt;code&gt;TaskPool&lt;/code&gt; 中获取和设置工作线程的操作系统调度优先级。它们转发到 &lt;code&gt;core.thread.Thread.priority&lt;/code&gt; ，因此给定的优先级值与 &lt;code&gt;core.thread&lt;/code&gt; 中相同的优先级值具有相同的含义。</target>
        </trans-unit>
        <trans-unit id="563010f17028868ed8865c10ee72ad70b45bdc1f" translate="yes" xml:space="preserve">
          <source>These functions allow the creation of &lt;code&gt;Task&lt;/code&gt; objects on the stack rather than the GC heap. The lifetime of a &lt;code&gt;Task&lt;/code&gt; created by &lt;code&gt;scopedTask&lt;/code&gt; cannot exceed the lifetime of the scope it was created in.</source>
          <target state="translated">这些功能允许在堆栈而不是GC堆上创建 &lt;code&gt;Task&lt;/code&gt; 对象。 &lt;code&gt;scopedTask&lt;/code&gt; 创建的 &lt;code&gt;Task&lt;/code&gt; 的生存期不能超过其创建范围的生存期。</target>
        </trans-unit>
        <trans-unit id="4c3aa616b64e71a662b37e0ffc58b47e53c7d7a0" translate="yes" xml:space="preserve">
          <source>These functions are defined by</source>
          <target state="translated">这些功能的定义是</target>
        </trans-unit>
        <trans-unit id="64a3eca56341ef165f9199f2a7eb38f22c9f31d6" translate="yes" xml:space="preserve">
          <source>These functions are only available if &lt;code&gt;hasPeek!T&lt;/code&gt; is true.</source>
          <target state="translated">仅当 &lt;code&gt;hasPeek!T&lt;/code&gt; 为true时，这些功能才可用。</target>
        </trans-unit>
        <trans-unit id="ca1095cd637088fb9ac4b341f976f96ce873e4a7" translate="yes" xml:space="preserve">
          <source>These functions are only supported on POSIX platforms, as the Windows operating systems do not provide the ability to overwrite the current process image with another. In single-threaded programs it is possible to approximate the effect of &lt;code&gt;execv*&lt;/code&gt; by using &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and terminating the current process once the child process has returned. For example:</source>
          <target state="translated">这些功能仅在POSIX平台上受支持，因为Windows操作系统不提供使用另一个功能覆盖当前过程映像的功能。在单线程程序中，可以通过使用&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;并在子进程返回后终止当前进程来近似 &lt;code&gt;execv*&lt;/code&gt; 的效果。例如：</target>
        </trans-unit>
        <trans-unit id="536f51437dc16a03b75f3b412228393928fdac5c" translate="yes" xml:space="preserve">
          <source>These functions are recognized by the compiler, and calls to them are guaranteed to not be removed (as dead assignment elimination or presumed to have no effect) or reordered in the same thread.</source>
          <target state="translated">这些函数被编译器识别,对它们的调用保证不会被删除(作为死任务消除或假定没有效果),也不会在同一线程中重新排序。</target>
        </trans-unit>
        <trans-unit id="1689bc1bc5afab34bd94fef9d049d296d24218eb" translate="yes" xml:space="preserve">
          <source>These functions find the first occurrence of &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; and then split &lt;code&gt;haystack&lt;/code&gt; as follows.</source>
          <target state="translated">这些功能首先在 &lt;code&gt;haystack&lt;/code&gt; 找到 &lt;code&gt;needle&lt;/code&gt; ，然后按以下方式拆分 &lt;code&gt;haystack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b1cfbf3893f882218472af28278eb2e9814bf0e" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">通过适当选择 &lt;code&gt;pred&lt;/code&gt; ,这些函数可用于计算任意极值。对于正确的功能， &lt;code&gt;pred&lt;/code&gt; 必须是严格的偏序，即传递（如果 &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; 然后 &lt;code&gt;pred(a, c)&lt;/code&gt; ）和不反身的（ &lt;code&gt;pred(a, a)&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="add0a2e2f51a24f38416d0099f1fae2ea0488394" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;). The trichotomy property of inequality is not required: these algorithms consider elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal (for the purpose of counting) if &lt;code&gt;pred&lt;/code&gt; puts them in the same equivalence class, i.e. &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60755fe688a68024196bc269a7db2354557a4c9" translate="yes" xml:space="preserve">
          <source>These functions may be used for computing arbitrary extrema by choosing &lt;code&gt;pred&lt;/code&gt; appropriately. For corrrect functioning, &lt;code&gt;pred&lt;/code&gt; must be a strict partial order, i.e. transitive (if &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; then &lt;code&gt;pred(a, c)&lt;/code&gt;) and irreflexive (&lt;code&gt;pred(a, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;). The trichotomy property of inequality is not required: these algoritms consider elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equal (for the purpose of counting) if &lt;code&gt;pred&lt;/code&gt; puts them in the same equivalence class, i.e. &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">通过适当选择 &lt;code&gt;pred&lt;/code&gt; ,这些函数可用于计算任意极值。对于正确的功能， &lt;code&gt;pred&lt;/code&gt; 必须是严格的偏序，即传递（如果 &lt;code&gt;pred(a, b) &amp;amp;&amp;amp; pred(b, c)&lt;/code&gt; 然后 &lt;code&gt;pred(a, c)&lt;/code&gt; ）和不反身的（ &lt;code&gt;pred(a, a)&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ）。不要求不等式的三分法性质：如果 &lt;code&gt;pred&lt;/code&gt; 将元素 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 放在相同的等价类中，则这些算法将它们视为相等（出于计数目的），即 &lt;code&gt;!pred(a, b) &amp;amp;&amp;amp; !pred(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4885c55c8f009fc55e3ded5c636baed4e8b1027a" translate="yes" xml:space="preserve">
          <source>These functions must be defined for any D program linked against this library.</source>
          <target state="translated">这些函数必须为任何与该库链接的D程序定义。</target>
        </trans-unit>
        <trans-unit id="863522dc2f55e2bd3557bec461908ee54bfe9148" translate="yes" xml:space="preserve">
          <source>These functions substitute for dynamic_cast. dynamic_cast does not work on earlier versions of gcc.</source>
          <target state="translated">这些函数替代了dynamic_cast,dynamic_cast在早期的gcc版本中无法使用。</target>
        </trans-unit>
        <trans-unit id="a6f52bdfe03bd9c3b6aa669ea2216cab6aa5652c" translate="yes" xml:space="preserve">
          <source>These functions will, when possible, do the load/store as a single operation. In general, this is possible when the size of the operation is less than or equal to &lt;code&gt;(void*).sizeof&lt;/code&gt;, although some targets may support larger operations. If the load/store cannot be done as a single operation, multiple smaller operations will be used.</source>
          <target state="translated">如果可能，这些功能将作为单个操作进行加载/存储。通常，当操作的大小小于或等于 &lt;code&gt;(void*).sizeof&lt;/code&gt; 时，这是可能的，尽管某些目标可能支持更大的操作。如果无法通过单个操作完成加载/存储，则将使用多个较小的操作。</target>
        </trans-unit>
        <trans-unit id="aa2712a3447962365aa53a08ef19b228a050bafc" translate="yes" xml:space="preserve">
          <source>These interfaces are intended to provide virtual function-based wrappers around input ranges with element type E. This is useful where a well-defined binary interface is required, such as when a DLL function or virtual function needs to accept a generic range as a parameter. Note that &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt; and friends check for conformance to structural interfaces not for implementation of these &lt;code&gt;interface&lt;/code&gt; types.</source>
          <target state="translated">这些接口旨在为元素类型E的输入范围提供基于虚拟函数的包装器。这在需要定义明确的二进制接口时很有用，例如DLL函数或虚拟函数需要接受通用范围作为参数时。请注意，&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;isInputRange&lt;/a&gt;和好友检查是否与结构化接口相符，而不是针对这些 &lt;code&gt;interface&lt;/code&gt; 类型的实现。</target>
        </trans-unit>
        <trans-unit id="e7b0ea076cc1a10005c1bfd351e1967a3ff3876c" translate="yes" xml:space="preserve">
          <source>These interfaces are not capable of forwarding &lt;code&gt;ref&lt;/code&gt; access to elements.</source>
          <target state="translated">这些接口无法转发对元素的 &lt;code&gt;ref&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="8fa26313291d5018e0a3e59f0f8f336286abcb0a" translate="yes" xml:space="preserve">
          <source>These issues also apply to appending arrays with the ~= operator. Concatenation using the ~ operator is not affected since it always reallocates.</source>
          <target state="translated">这些问题也适用于使用 ~=操作符进行数组追加。使用 ~ 运算符进行的连接不受影响,因为它总是重新分配。</target>
        </trans-unit>
        <trans-unit id="b9ff0eb99086639c464f06ffda166431e591559b" translate="yes" xml:space="preserve">
          <source>These members are populated when one of the following functions are called successfully:</source>
          <target state="translated">当下列函数之一被成功调用时,这些成员将被填充。</target>
        </trans-unit>
        <trans-unit id="e69f6a6ea64238818e57857e50d3b4e6fac28582" translate="yes" xml:space="preserve">
          <source>These methods return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这些方法返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2f532d1b48edcd9143f50919e4b67ad8068e5c5" translate="yes" xml:space="preserve">
          <source>These policies may be used alone, e.g. &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; defines a &lt;code&gt;uint&lt;/code&gt;-like type that reaches a stable NaN state for all erroneous operations. They may also be &quot;stacked&quot; on top of each other, owing to the property that a checked integral emulates an actual integral, which means another checked integral can be built on top of it. Some combinations of interest include:</source>
          <target state="translated">这些策略可以单独使用，例如 &lt;code&gt;Checked!(uint, WithNaN)&lt;/code&gt; 定义了类似于 &lt;code&gt;uint&lt;/code&gt; 的类型，该类型对于所有错误操作均达到稳定的NaN状态。由于检查的积分模拟实际的积分的性质，它们也可能彼此&amp;ldquo;堆叠&amp;rdquo;，这意味着可以在其顶部构建另一个检查的积分。一些感兴趣的组合包括：</target>
        </trans-unit>
        <trans-unit id="7368ecff3f3d439be72be4fcfde0947c1e9f8e58" translate="yes" xml:space="preserve">
          <source>These prefix instructions do not appear in the same statement as the instructions they prefix; they appear in their own statement. For example:</source>
          <target state="translated">这些前缀指令与它们前缀的指令不出现在同一语句中,它们出现在自己的语句中。例如:</target>
        </trans-unit>
        <trans-unit id="9636b646d702390220bc4fa38bc7bba209069d1d" translate="yes" xml:space="preserve">
          <source>These properties can be used to set and get this &lt;code&gt;Logger&lt;/code&gt;. Every modification to this &lt;code&gt;Logger&lt;/code&gt; will only be visible in the thread the modification has been done from.</source>
          <target state="translated">这些属性可用于设置和获取此 &lt;code&gt;Logger&lt;/code&gt; 。对该 &lt;code&gt;Logger&lt;/code&gt; 的每次修改仅在修改所基于的线程中可见。</target>
        </trans-unit>
        <trans-unit id="d0c185c1fb708b1056aa4da779b1949039005b7f" translate="yes" xml:space="preserve">
          <source>These properties control whether the worker threads are daemon threads. A daemon thread is automatically terminated when all non-daemon threads have terminated. A non-daemon thread will prevent a program from terminating as long as it has not terminated.</source>
          <target state="translated">这些属性控制着工作线程是否是守护者线程。当所有非守护线程都终止时,守护线程会自动终止。只要一个非守护进程线程没有终止,它就会阻止程序终止。</target>
        </trans-unit>
        <trans-unit id="15376758dabe755dcb87d082399d9c18e9269e9e" translate="yes" xml:space="preserve">
          <source>These properties get and set the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; instance returned by &lt;code&gt;taskPool&lt;/code&gt;. The default value is &lt;code&gt;totalCPUs&lt;/code&gt; - 1. Calling the setter after the first call to &lt;code&gt;taskPool&lt;/code&gt; does not changes number of worker threads in the instance returned by &lt;code&gt;taskPool&lt;/code&gt;.</source>
          <target state="translated">这些属性获取和设置工作线程的数量 &lt;code&gt;TaskPool&lt;/code&gt; 通过返回的实例 &lt;code&gt;taskPool&lt;/code&gt; 。默认值为 &lt;code&gt;totalCPUs&lt;/code&gt; -1。在第一次调用 &lt;code&gt;taskPool&lt;/code&gt; 之后调用setter 不会更改 &lt;code&gt;taskPool&lt;/code&gt; 返回的实例中的辅助线程数。</target>
        </trans-unit>
        <trans-unit id="980ecd42d3382da4165c5745d3e514950a686c39" translate="yes" xml:space="preserve">
          <source>These pseudo ops are for inserting raw data directly into the code. &lt;code&gt;db&lt;/code&gt; is for bytes, &lt;code&gt;ds&lt;/code&gt; is for 16 bit words, &lt;code&gt;di&lt;/code&gt; is for 32 bit words, &lt;code&gt;dl&lt;/code&gt; is for 64 bit words, &lt;code&gt;df&lt;/code&gt; is for 32 bit floats, &lt;code&gt;dd&lt;/code&gt; is for 64 bit doubles, and &lt;code&gt;de&lt;/code&gt; is for 80 bit extended reals. Each can have multiple operands. If an operand is a string literal, it is as if there were</source>
          <target state="translated">这些伪操作用于将原始数据直接插入代码中。 &lt;code&gt;db&lt;/code&gt; 用于字节， &lt;code&gt;ds&lt;/code&gt; 用于16位字， &lt;code&gt;di&lt;/code&gt; 用于32位字， &lt;code&gt;dl&lt;/code&gt; 用于64位字， &lt;code&gt;df&lt;/code&gt; 用于32位浮点数， &lt;code&gt;dd&lt;/code&gt; 用于64位双精度数，而 &lt;code&gt;de&lt;/code&gt; 用于80位扩展实数。每个都可以有多个操作数。如果操作数是字符串文字，就好像有</target>
        </trans-unit>
        <trans-unit id="dc738e7762e036039780916cbdd5404d3269d8a0" translate="yes" xml:space="preserve">
          <source>These reordering guarantees are only made with regards to other operations done through these functions; the compiler is free to reorder regular loads/stores with regards to loads/stores done through these functions.</source>
          <target state="translated">这些重新排序的保证只针对通过这些函数完成的其他操作,编译器可以自由地对通过这些函数完成的负载/存储进行重新排序。</target>
        </trans-unit>
        <trans-unit id="59c337390b522d2f745f8ff19e4af335466b8d80" translate="yes" xml:space="preserve">
          <source>These rules exist to ensure that D source code can be tokenized independently of syntactic or semantic analysis.</source>
          <target state="translated">这些规则的存在是为了确保D源代码可以独立于语法或语义分析而被标记化。</target>
        </trans-unit>
        <trans-unit id="0c76e41e867d53b374fa782852a104df9aca82b4" translate="yes" xml:space="preserve">
          <source>These tokens are replaced with other tokens according to the following table:</source>
          <target state="translated">根据下表,这些代币被其他代币取代。</target>
        </trans-unit>
        <trans-unit id="d0bdde0a231ee1346d31198eca44ed30c45d180a" translate="yes" xml:space="preserve">
          <source>These two functions are publicly imported by &lt;a href=&quot;std_string&quot;&gt;&lt;code&gt;std.string&lt;/code&gt;&lt;/a&gt; to be easily available.</source>
          <target state="translated">这两个函数由&lt;a href=&quot;std_string&quot;&gt; &lt;code&gt;std.string&lt;/code&gt; &lt;/a&gt;公开导入，以便于使用。</target>
        </trans-unit>
        <trans-unit id="d116b35a1d1eb38f8d6deaebff517f7281edce29" translate="yes" xml:space="preserve">
          <source>These two methods set and get the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">这两种方法设置并获取使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c31bee48bf9882a765ab31f12d60d8852693f17b" translate="yes" xml:space="preserve">
          <source>These two were added to Bionic in Lollipop.</source>
          <target state="translated">这两个是在棒棒糖中添加到Bionic中的。</target>
        </trans-unit>
        <trans-unit id="51b1a7127ec2cda2b11c1f4d950a66756e0a424a" translate="yes" xml:space="preserve">
          <source>These types and operations will be the ones defined for the architecture the compiler is targeting. If a particular CPU family has varying support for vector types, an additional runtime check may be necessary. The compiler does not emit runtime checks; those must be done by the programmer.</source>
          <target state="translated">这些类型和操作将是为编译器所针对的架构所定义的。如果一个特定的CPU系列对向量类型有不同的支持,可能需要额外的运行时检查。编译器不会发出运行时检查,这些检查必须由程序员来完成。</target>
        </trans-unit>
        <trans-unit id="23aa9ed08051d1b26b975da56b7c482018edf989" translate="yes" xml:space="preserve">
          <source>These use the &lt;code&gt;zd&lt;/code&gt; and &lt;code&gt;dt&lt;/code&gt; format specifiers respectively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f060e83954cb7bb657a24fc206a36f49a7d93ba" translate="yes" xml:space="preserve">
          <source>These variadic functions have a special local variable declared for them, &lt;code&gt;_argptr&lt;/code&gt;, which is a &lt;code&gt;core.vararg&lt;/code&gt; reference to the first of the variadic arguments. To access the arguments, &lt;code&gt;_argptr&lt;/code&gt; must be used in conjuction with &lt;code&gt;va_arg&lt;/code&gt;:</source>
          <target state="translated">这些可变参数函数为它们声明了一个特殊的局部变量 &lt;code&gt;_argptr&lt;/code&gt; ，这是对第一个可变参数的 &lt;code&gt;core.vararg&lt;/code&gt; 引用。要访问参数，必须将 &lt;code&gt;_argptr&lt;/code&gt; 与 &lt;code&gt;va_arg&lt;/code&gt; 结合使用：</target>
        </trans-unit>
        <trans-unit id="d8252040edcfa70507497891f3e37c3388deec3b" translate="yes" xml:space="preserve">
          <source>These variadic functions have a special local variable declared for them, &lt;code&gt;_argptr&lt;/code&gt;, which is a &lt;code&gt;core.vararg&lt;/code&gt; reference to the first of the variadic arguments. To access the arguments, &lt;code&gt;_argptr&lt;/code&gt; must be used in conjunction with &lt;code&gt;va_arg&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234027e68858253217a4940ca8276de49e1921e6" translate="yes" xml:space="preserve">
          <source>They cannot be accessed directly, but can be when converted to an array type:</source>
          <target state="translated">它们不能直接被访问,但当转换为数组类型时可以被访问。</target>
        </trans-unit>
        <trans-unit id="221e10b06207df21853c30ac081dc011d76ee4a6" translate="yes" xml:space="preserve">
          <source>Things that are reliable and can be done:</source>
          <target state="translated">可靠的事情,可以做。</target>
        </trans-unit>
        <trans-unit id="3c0e4517dcdbca852a34fee2578fdfec0c6193f9" translate="yes" xml:space="preserve">
          <source>This 6-digit (24 bits) hexadecimal number does not show pre-release number, and it is always a greater number in a more recent release. It makes comparisons with greater than and less than work.</source>
          <target state="translated">这个6位数(24位)的十六进制数字不显示发布前的数字,在最近的版本中,它总是一个大于的数字。它使大于和小于的比较工作。</target>
        </trans-unit>
        <trans-unit id="229cd848f340b1059ab841306649066eb2235f02" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt;&lt;code&gt;NSLog&lt;/code&gt;&lt;/a&gt; function prints a message to the System Log facility, i.e. to stderr and Console.</source>
          <target state="translated">此&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/index.html#//apple_ref/c/func/NSLog&quot;&gt; &lt;code&gt;NSLog&lt;/code&gt; &lt;/a&gt;函数将消息打印到系统日志工具，即stderr和控制台。</target>
        </trans-unit>
        <trans-unit id="d3784623518bf5135672133e5b2128ce4da1e03a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; implementation writes log messages to the associated file. The name of the file has to be passed on construction time. If the file is already present new log messages will be append at its end.</source>
          <target state="translated">该 &lt;code&gt;Logger&lt;/code&gt; 实现将日志消息写入关联的文件。文件名必须在构造时传递。如果文件已经存在，则将在其末尾附加新的日志消息。</target>
        </trans-unit>
        <trans-unit id="713e6c7267281da115b32a479fb632b10a4676bf" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;Logger&lt;/code&gt; is called by the free standing log functions. This allows to create thread local redirections and still use the free standing log functions.</source>
          <target state="translated">独立记录功能调用此 &lt;code&gt;Logger&lt;/code&gt; 。这允许创建线程本地重定向，并且仍然使用独立日志功能。</target>
        </trans-unit>
        <trans-unit id="e1905487aa2f3222c1f92ca85d42ee6ef82cec0b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;delegate&lt;/code&gt; is called in case a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; gets logged.</source>
          <target state="translated">如果记录了带有 &lt;code&gt;LogLevel.fatal&lt;/code&gt; 的日志消息，则将调用此 &lt;code&gt;delegate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="742a25561151a973ba133d1f0c2d43dea4909a81" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used as a template argument to functions which compare file names, and determines whether the comparison is case sensitive or not.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 用作比较文件名的函数的模板参数，并确定比较是否区分大小写。</target>
        </trans-unit>
        <trans-unit id="5b6a1b7ec8e15b4671a0723320a6b157081a9b40" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;enum&lt;/code&gt; is used to select the primitives of the range to handle by the &lt;a href=&quot;#handle&quot;&gt;&lt;code&gt;handle&lt;/code&gt;&lt;/a&gt; range wrapper. The values of the &lt;code&gt;enum&lt;/code&gt; can be &lt;code&gt;OR&lt;/code&gt;'d to select multiple primitives to be handled.</source>
          <target state="translated">该 &lt;code&gt;enum&lt;/code&gt; 用于通过&lt;a href=&quot;#handle&quot;&gt; &lt;code&gt;handle&lt;/code&gt; &lt;/a&gt;范围包装器选择要处理的范围的基元。 &lt;code&gt;enum&lt;/code&gt; 的值可以进行 &lt;code&gt;OR&lt;/code&gt; 以选择要处理的多个基元。</target>
        </trans-unit>
        <trans-unit id="60302f8f7437eabfe1118a9f0d4373fe741b982e" translate="yes" xml:space="preserve">
          <source>This &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, U)(U rhs)</source>
          <target state="translated">这个&lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;（字符串op，U）（U rhs）</target>
        </trans-unit>
        <trans-unit id="0844f4e216523548601b41cd5d7151c085ad2d4f" translate="yes" xml:space="preserve">
          <source>This Element is stored inside the &lt;code&gt;MultiLogger&lt;/code&gt; and associates a &lt;code&gt;Logger&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">该元素存储在 &lt;code&gt;MultiLogger&lt;/code&gt; 内部，并将 &lt;code&gt;Logger&lt;/code&gt; 与 &lt;code&gt;string&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="3f3ba7f1176ff2dafbb0e0f64e80accd29320699" translate="yes" xml:space="preserve">
          <source>This Exception is thrown if something goes wrong when encoding or decoding a URI.</source>
          <target state="translated">如果在编码或解码URI时出错,就会抛出这个异常。</target>
        </trans-unit>
        <trans-unit id="808758fad2f8e432c6429e19e97ca8ce38bd7755" translate="yes" xml:space="preserve">
          <source>This UDA is not transitive, and inner scope do not inherit outer scopes' ABI tag. See examples below for how to translate a C++ declaration to D. Also note that entries in this UDA will be automatically sorted alphabetically, hence &lt;code&gt;gnuAbiTag(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;)&lt;/code&gt; will appear as &lt;code&gt;@gnuAbiTag(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f52bee84df158d351adbe607d7ed92c29a830ca" translate="yes" xml:space="preserve">
          <source>This access can span multiple nesting levels:</source>
          <target state="translated">这种访问可以跨越多个嵌套级别。</target>
        </trans-unit>
        <trans-unit id="6b73948545ca0a17466100c56872304c05fd8262" translate="yes" xml:space="preserve">
          <source>This advice applies only to static references or references embedded inside other objects. There is not much point for such stored on the stack to be nulled because new stack frames are initialized anyway.</source>
          <target state="translated">这个建议只适用于静态引用或嵌入其他对象内部的引用。对于这种存储在堆栈上的引用来说,被清空是没有多大意义的,因为新的堆栈框架无论如何都会被初始化。</target>
        </trans-unit>
        <trans-unit id="b180cae02977110add927a1c4e0c64f40292d64f" translate="yes" xml:space="preserve">
          <source>This algorithm is lazy, doing work progressively as elements are pulled off the result.  Time complexity is proportional to the sum of element counts over all inputs.  If all inputs have the same element type and offer it by &lt;code&gt;ref&lt;/code&gt;, output becomes a range with mutable &lt;code&gt;front&lt;/code&gt; (and &lt;code&gt;back&lt;/code&gt; where appropriate) that reflects in the original inputs.  If any of the inputs &lt;code&gt;rs&lt;/code&gt; is infinite so is the result (&lt;code&gt;empty&lt;/code&gt; being always &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">该算法是惰性的，随着元素从结果中拉出而逐渐进行工作。时间复杂度与所有输入的元素计数之和成正比。如果所有输入都具有相同的元素类型，并由 &lt;code&gt;ref&lt;/code&gt; 提供，则输出将变成一个范围可变，其范围在 &lt;code&gt;front&lt;/code&gt; （适当时可以在 &lt;code&gt;back&lt;/code&gt; ）反映原始输入。如果任何输入 &lt;code&gt;rs&lt;/code&gt; 是无限的，则结果也是如此（ &lt;code&gt;empty&lt;/code&gt; 始终为 &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="17ac7dad87e44aee326cfad5b437dc8fb209353e" translate="yes" xml:space="preserve">
          <source>This allocator sits on top of &lt;code&gt;ParentAllocator&lt;/code&gt; and quantizes allocation sizes, usually from arbitrary positive numbers to a small set of round numbers (e.g. powers of two, page sizes etc). This technique is commonly used to:</source>
          <target state="translated">此分配器位于 &lt;code&gt;ParentAllocator&lt;/code&gt; 之上，并量化分配大小，通常是从任意正数到一小组舍入数（例如，2的幂，页大小等）。此技术通常用于：</target>
        </trans-unit>
        <trans-unit id="c92308ef13d80d3dc1f8f963c2ddd3981e8c6bde" translate="yes" xml:space="preserve">
          <source>This allows you to construct a &lt;code&gt;TickDuration&lt;/code&gt; from the given time units with the given length.</source>
          <target state="translated">这使您可以从具有给定长度的给定时间单位构造一个 &lt;code&gt;TickDuration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75add17a5265c1c86eea3c10773eb85a2a082611" translate="yes" xml:space="preserve">
          <source>This also checks if T passes &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">这还将检查T是否通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21d1b39871e7f1893df45ac1736d0defe8bdb68b" translate="yes" xml:space="preserve">
          <source>This approach to sorting is akin to the &lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian transform&lt;/a&gt;, also known as the decorate-sort-undecorate pattern in Python and Lisp. The complexity is the same as that of the corresponding &lt;code&gt;sort&lt;/code&gt;, but &lt;code&gt;schwartzSort&lt;/code&gt; evaluates &lt;code&gt;transform&lt;/code&gt; only &lt;code&gt;r.length&lt;/code&gt; times (less than half when compared to regular sorting). The usage can be best illustrated with an example.</source>
          <target state="translated">这种排序方法类似于&lt;a href=&quot;http://wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian变换&lt;/a&gt;，在Python和Lisp中也称为decorate-sort-unecorate模式。复杂度与相应 &lt;code&gt;sort&lt;/code&gt; 的复杂度相同，但是 &lt;code&gt;schwartzSort&lt;/code&gt; 仅计算 &lt;code&gt;transform&lt;/code&gt; &lt;code&gt;r.length&lt;/code&gt; 次（与常规排序相比，减少一半）。用法可以通过一个例子最好地说明。</target>
        </trans-unit>
        <trans-unit id="5d88f963aa92f920cdc8aeb7a00bc154db20bbb5" translate="yes" xml:space="preserve">
          <source>This array can be used by a precise GC to avoid false pointers.</source>
          <target state="translated">这个数组可以被一个精确的GC使用,以避免错误的指针。</target>
        </trans-unit>
        <trans-unit id="c35154b2193fa21859ceac41f1d4b9a67330be66" translate="yes" xml:space="preserve">
          <source>This attack can also be mitigated via rate limiting and banning IPs which have too many rejected requests. However, this does not completely solve the problem, as the attacker could be in control of a bot net. To fully defend against the timing attack, rate limiting, banning IPs, and using this function should be used together.</source>
          <target state="translated">这种攻击也可以通过限制速率和禁止有太多拒绝请求的IP来缓解。但是,这并不能完全解决这个问题,因为攻击者可能会控制一个僵尸网络。为了完全防御定时攻击,限制速率、禁止IP和使用这个功能应该一起使用。</target>
        </trans-unit>
        <trans-unit id="0a9127e0dd3d0b5214532b99c1123e71d947a773" translate="yes" xml:space="preserve">
          <source>This binary operator returns a narrower, built-in integer type where applicable, according to the following table.</source>
          <target state="translated">这个二进制运算符根据下表,在适用的情况下返回一个较窄的内置整数类型。</target>
        </trans-unit>
        <trans-unit id="37d90ec49bcad1514fffff07ef5725f0a4ce3b52" translate="yes" xml:space="preserve">
          <source>This block contains the info to allow appending.</source>
          <target state="translated">该块包含允许追加的信息。</target>
        </trans-unit>
        <trans-unit id="bf616d2c8bb18a1f79e9b94bb01fac01a9f85e97" translate="yes" xml:space="preserve">
          <source>This block is guaranteed to have a pointer to its base while it is alive. Interior pointers can be safely ignored. This attribute is useful for eliminating false pointers in very large data structures and is only implemented for data structures at least a page in size.</source>
          <target state="translated">这个块在活着的时候,保证有一个指向它的基座的指针。内部指针可以被安全地忽略。这个属性对于消除非常大的数据结构中的错误指针非常有用,并且只对至少有一页大小的数据结构实施。</target>
        </trans-unit>
        <trans-unit id="bf3bcec7830ceded3b9368b09e74254cb38823f2" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. It's highly platform dependent.</source>
          <target state="translated">它将一个类型分解成 &quot;更简单 &quot;的类型,这些类型可以在寄存器中传递给一个函数,并在寄存器中返回。它高度依赖于平台。</target>
        </trans-unit>
        <trans-unit id="c8f37b58b4d0486e147bae447382fe4c40e89ace" translate="yes" xml:space="preserve">
          <source>This breaks a type down into 'simpler' types that can be passed to a function in registers, and returned in registers. This is the implementation for the x86_64 System V ABI (not used for Win64), based on &lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf.&lt;/a&gt;</source>
          <target state="translated">这将类型分解为&amp;ldquo;简单&amp;rdquo;类型，可以将其传递给寄存器中的函数，然后返回给寄存器。这是基于&lt;a href=&quot;https://www.uclibc.org/docs/psABI-x86_64.pdf.&quot;&gt;https://www.uclibc.org/docs/psABI-x86_64.pdf&lt;/a&gt;的x86_64 System V ABI（不适用于Win64）的实现。</target>
        </trans-unit>
        <trans-unit id="0bd70fd848ca13dea85fa0c9ed45a1bd7458ccab" translate="yes" xml:space="preserve">
          <source>This can be a useful function to place in a chain, after functions that have expensive evaluation, as a lazy alternative to &lt;a href=&quot;std_array#array&quot;&gt;&lt;code&gt;std.array.array&lt;/code&gt;&lt;/a&gt;. In particular, it can be placed after a call to &lt;a href=&quot;#map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, or before a call &lt;a href=&quot;std_range#filter&quot;&gt;&lt;code&gt;std.range.filter&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range#tee&quot;&gt;&lt;code&gt;std.range.tee&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">这可能是有用的功能，可以放在链上，而这些功能需要昂贵的评估，可以替代&lt;a href=&quot;std_array#array&quot;&gt; &lt;code&gt;std.array.array&lt;/code&gt; &lt;/a&gt;。特别是，可以将其放置在调用&lt;a href=&quot;#map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;之后或调用&lt;a href=&quot;std_range#filter&quot;&gt; &lt;code&gt;std.range.filter&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;std_range#tee&quot;&gt; &lt;code&gt;std.range.tee&lt;/code&gt; 之前&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b2e989aa67544fd1198815cd532b63a0f766b8f" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = File.readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="translated">这可以比 &lt;code&gt;line = File.readln()&lt;/code&gt; 更快，因为您可以为每个调用重用缓冲区。请注意，重用缓冲区意味着如果要保留以前的内容，则必须复制它们。</target>
        </trans-unit>
        <trans-unit id="9135461de3ded4b1c69a8c8663d6dc1b7b1298f3" translate="yes" xml:space="preserve">
          <source>This can be faster than &lt;code&gt;line = readln()&lt;/code&gt; because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them.</source>
          <target state="translated">这可以比 &lt;code&gt;line = readln()&lt;/code&gt; 更快，因为您可以为每个调用重用缓冲区。请注意，重用缓冲区意味着如果要保留以前的内容，则必须复制它们。</target>
        </trans-unit>
        <trans-unit id="0948e8d31ea2c28fe26752cedea06ec0ba1ce2b0" translate="yes" xml:space="preserve">
          <source>This can be generalized to a graph of memory objects interconnected by pointers, where only a single pointer connects to that graph from elsewhere. That single pointer becomes the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffa42c18f8e5280df0dc347c1adc3088bd2e98b" translate="yes" xml:space="preserve">
          <source>This can be mitigated by using type-specific pools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a112b2327f090d0fc1bf3af12645c6807ea32f38" translate="yes" xml:space="preserve">
          <source>This can be used to manually allocate arrays. Initial slice size is 0.</source>
          <target state="translated">这可以用来手动分配数组。初始分片大小为0。</target>
        </trans-unit>
        <trans-unit id="77b164cf465602d02b3ffc40b53faf3928b97c45" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;_init&lt;/code&gt; to its original state.</source>
          <target state="translated">这可用于将 &lt;code&gt;_init&lt;/code&gt; 设置的状态恢复到其原始状态。</target>
        </trans-unit>
        <trans-unit id="fd9b6c28efb844ef78e5e1874ec7103f9aedb900" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;builtin_init&lt;/code&gt; to its original state.</source>
          <target state="translated">这可用于将 &lt;code&gt;builtin_init&lt;/code&gt; 设置的状态恢复到其原始状态。</target>
        </trans-unit>
        <trans-unit id="bf855a97cfb23a3029962fde96c07063d751f784" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initDMD&lt;/code&gt; to its original state. Useful if there's a need for multiple sessions of the DMD compiler in the same application.</source>
          <target state="translated">这可用于将 &lt;code&gt;initDMD&lt;/code&gt; 设置的状态恢复到其原始状态。如果在同一应用程序中需要多个DMD编译器会话，则很有用。</target>
        </trans-unit>
        <trans-unit id="8b9d5f27029fa9824ee5b1d78b90c2ec7ef5fd1e" translate="yes" xml:space="preserve">
          <source>This can be used to restore the state set by &lt;code&gt;initialize&lt;/code&gt; to its original state.</source>
          <target state="translated">这可以用于通过 &lt;code&gt;initialize&lt;/code&gt; 将状态集恢复为其原始状态。</target>
        </trans-unit>
        <trans-unit id="ab6e2c03932762345b65936a6392947f9f7fc40e" translate="yes" xml:space="preserve">
          <source>This causes the array to be reallocated in place, and the existing contents copied over to the new array. If the new array length is shorter, the array is not reallocated, and no data is copied. It is equivalent to slicing the array:</source>
          <target state="translated">这将导致数组在原地被重新分配,并将现有的内容复制到新的数组中。如果新的数组长度较短,则不重新分配数组,也不复制数据。这相当于对数组进行切片。</target>
        </trans-unit>
        <trans-unit id="2dc8c51a26f6ef694173726a55aa90d7d6530cc8" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a read lock for the enclosing mutex.</source>
          <target state="translated">这个类本身就可以被认为是一个mutex,用来协商包围mutex的读锁。</target>
        </trans-unit>
        <trans-unit id="c087ce5411ffc17188818ec319892aeaf2de87df" translate="yes" xml:space="preserve">
          <source>This class can be considered a mutex in its own right, and is used to negotiate a write lock for the enclosing mutex.</source>
          <target state="translated">这个类本身就可以被认为是一个mutex,用于为包围的mutex协商一个写锁。</target>
        </trans-unit>
        <trans-unit id="e6fa3f3a70f061e4c741e7043e9f128e38434b5c" translate="yes" xml:space="preserve">
          <source>This class contains only static methods, and cannot be instantiated. See below for examples of use.</source>
          <target state="translated">该类只包含静态方法,不能实例化。请看下面的使用实例。</target>
        </trans-unit>
        <trans-unit id="e74dd67572321fcf836dd082da1156043102db48" translate="yes" xml:space="preserve">
          <source>This class encapsulates a task queue and a set of worker threads. Its purpose is to efficiently map a large number of &lt;code&gt;Task&lt;/code&gt;s onto a smaller number of threads. A task queue is a FIFO queue of &lt;code&gt;Task&lt;/code&gt; objects that have been submitted to the &lt;code&gt;TaskPool&lt;/code&gt; and are awaiting execution. A worker thread is a thread that executes the &lt;code&gt;Task&lt;/code&gt; at the front of the queue when one is available and sleeps when the queue is empty.</source>
          <target state="translated">此类封装了一个任务队列和一组工作线程。其目的是有效地将大量 &lt;code&gt;Task&lt;/code&gt; 映射到较少数量的线程上。任务队列是已提交到 &lt;code&gt;TaskPool&lt;/code&gt; 并等待执行的 &lt;code&gt;Task&lt;/code&gt; 对象的FIFO队列。工作线程是一个线程，当一个线程可用时，该线程在队列的最前面执行 &lt;code&gt;Task&lt;/code&gt; ，而在队列为空时进入睡眠状态。</target>
        </trans-unit>
        <trans-unit id="cb7ed7def5fa337d461b92cc10d68f83905440de" translate="yes" xml:space="preserve">
          <source>This class encapsulates all threading functionality for the D programming language. As thread manipulation is a required facility for garbage collection, all user threads should derive from this class, and instances of this class should never be explicitly deleted. A new thread may be created using either derivation or composition, as in the following example.</source>
          <target state="translated">这个类封装了D编程语言的所有线程功能。由于线程操作是垃圾收集所需的设施,所以所有的用户线程都应该从这个类派生出来,而且这个类的实例永远不应该被显式删除。一个新的线程可以使用派生或组成来创建,如下例所示。</target>
        </trans-unit>
        <trans-unit id="060824159317cc2ae0b94150653daf83c3c520fb" translate="yes" xml:space="preserve">
          <source>This class is Windows-Only.</source>
          <target state="translated">这个类是Windows-Only的。</target>
        </trans-unit>
        <trans-unit id="74950bb501f7c21fc01a4eeb41b151e182fd4b25" translate="yes" xml:space="preserve">
          <source>This class is intended to simplify certain common programming techniques.</source>
          <target state="translated">该类旨在简化某些常见的编程技术。</target>
        </trans-unit>
        <trans-unit id="23197b76b4ee940fb447d39ecd365edbbb4617e7" translate="yes" xml:space="preserve">
          <source>This class is the base of every logger. In order to create a new kind of logger a deriving class needs to implement the &lt;code&gt;writeLogMsg&lt;/code&gt; method. By default this is not thread-safe.</source>
          <target state="translated">此类是每个记录器的基础。为了创建一种新的记录器，派生类需要实现 &lt;code&gt;writeLogMsg&lt;/code&gt; 方法。默认情况下，这不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="5087e482a877ae3c12085be27794a8883c7a901f" translate="yes" xml:space="preserve">
          <source>This class provides a cooperative concurrency mechanism integrated with the threading and garbage collection functionality. Calling a fiber may be considered a blocking operation that returns when the fiber yields (via Fiber.yield()). Execution occurs within the context of the calling thread so synchronization is not necessary to guarantee memory visibility so long as the same thread calls the fiber each time. Please note that there is no requirement that a fiber be bound to one specific thread. Rather, fibers may be freely passed between threads so long as they are not currently executing. Like threads, a new fiber thread may be created using either derivation or composition, as in the following example.</source>
          <target state="translated">这个类提供了一个与线程和垃圾收集功能集成的合作并发机制。调用光纤可以被认为是一个阻塞操作,当光纤产生时返回(通过Fiber.yield())。执行发生在调用线程的上下文中,所以只要每次调用光纤的是同一个线程,就不需要同步来保证内存的可见性。请注意,没有要求光纤必须绑定到一个特定的线程。相反,只要线程当前没有执行,光纤可以在线程之间自由传递。和线程一样,新的光纤线程也可以使用派生或组成的方式创建,如下例。</target>
        </trans-unit>
        <trans-unit id="82a75ec7718c8b6f47e4366c93dbe98cf77e29de" translate="yes" xml:space="preserve">
          <source>This class represents a barrier across which threads may only travel in groups of a specific size.</source>
          <target state="translated">该类代表了一个障碍,线程只能以特定大小的组为单位穿行。</target>
        </trans-unit>
        <trans-unit id="766ad20f64361ee3b240dfaf608ee851aeb433ae" translate="yes" xml:space="preserve">
          <source>This class represents a condition variable as conceived by C.A.R. Hoare. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="translated">这个类代表了C.A.R.Hoare所设想的一个条件变量。然而,按照Mesa类型监控器,&quot;signal &quot;被替换为 &quot;notify&quot;,以表明当发送通知时,控制权不会转移到服务员身上。</target>
        </trans-unit>
        <trans-unit id="4ebd970226df03dbe75e13571a9e96c6ff81d3f8" translate="yes" xml:space="preserve">
          <source>This class represents a general counting semaphore as concieved by Edsger Dijkstra. As per Mesa type monitors however, &quot;signal&quot; has been replaced with &quot;notify&quot; to indicate that control is not transferred to the waiter when a notification is sent.</source>
          <target state="translated">这个类代表了Edsger Dijkstra构思的一个通用计数信号体。然而,按照Mesa类型监控器,&quot;signal &quot;被替换为 &quot;notify&quot;,以表明当发送通知时,控制权不会转移到服务员身上。</target>
        </trans-unit>
        <trans-unit id="c8cd845734952865e5a8f06563815740028af34a" translate="yes" xml:space="preserve">
          <source>This class represents a general purpose, recursive mutex.</source>
          <target state="translated">这个类表示一个通用的、递归的mutex。</target>
        </trans-unit>
        <trans-unit id="59a28f2816234c02947ecfa7c34d28fcd7aff787" translate="yes" xml:space="preserve">
          <source>This class represents a mutex that allows any number of readers to enter, but when a writer enters, all other readers and writers are blocked.</source>
          <target state="translated">该类表示一个mutex,允许任何数量的读者进入,但当一个作家进入时,所有其他读者和作家都会被阻止。</target>
        </trans-unit>
        <trans-unit id="869079d3acf8bad41ab545f5cd5b6ff38c3d966c" translate="yes" xml:space="preserve">
          <source>This class should usually be used via the global instantiation available via the &lt;a href=&quot;std_parallelism#taskPool&quot;&gt;&lt;code&gt;std.parallelism.taskPool&lt;/code&gt;&lt;/a&gt; property. Occasionally it is useful to explicitly instantiate a &lt;code&gt;TaskPool&lt;/code&gt;:</source>
          <target state="translated">通常应通过&lt;a href=&quot;std_parallelism#taskPool&quot;&gt; &lt;code&gt;std.parallelism.taskPool&lt;/code&gt; &lt;/a&gt;属性提供的全局实例化来使用此类。有时，显式实例化 &lt;code&gt;TaskPool&lt;/code&gt; 很有用：</target>
        </trans-unit>
        <trans-unit id="67a778401b8293f4ab050d1d10ec2027dc2c3143" translate="yes" xml:space="preserve">
          <source>This class uses a high-performance counter. On Windows systems, it uses &lt;code&gt;QueryPerformanceCounter&lt;/code&gt;, and on Posix systems, it uses &lt;code&gt;clock_gettime&lt;/code&gt; if available, and &lt;code&gt;gettimeofday&lt;/code&gt; otherwise.</source>
          <target state="translated">此类使用高性能计数器。在Windows系统上，它使用 &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; ，在Posix系统上，它使用 &lt;code&gt;clock_gettime&lt;/code&gt; (如果可用），否则使用 &lt;code&gt;gettimeofday&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaa98a68eef2ad7cd1dc56f0e12cad2e4ff0ed1d" translate="yes" xml:space="preserve">
          <source>This code handles backtrace generation using DWARF debug_line section in ELF and Mach-O files for Posix.</source>
          <target state="translated">这段代码在ELF和Mach-O文件中使用DWARF debug_line部分处理Posix的回溯生成。</target>
        </trans-unit>
        <trans-unit id="6140309682aaa69b6ff498f8a25796d0edfd215e" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="translated">这段代码处理forach循环的UTF字符串解码。char、wchar和dchar之间有6种转换组合,每种组合有2种。</target>
        </trans-unit>
        <trans-unit id="982470496432064145436b3b7c81c481f591fd15" translate="yes" xml:space="preserve">
          <source>This code handles decoding UTF strings for foreach_reverse loops. There are 6 combinations of conversions between char, wchar, and dchar, and 2 of each of those.</source>
          <target state="translated">这段代码处理foreach_reverse循环的UTF字符串解码。char、wchar和dchar之间有6种转换组合,每种组合有2种。</target>
        </trans-unit>
        <trans-unit id="e76eacdedc4fa73ee336ac22c18ef834f35805af" translate="yes" xml:space="preserve">
          <source>This code reads ELF files and sections using memory mapped IO.</source>
          <target state="translated">这段代码使用内存映射IO读取ELF文件和部分。</target>
        </trans-unit>
        <trans-unit id="db89b4b4bb5b2f93ea6d6ff02b4131b5059932ab" translate="yes" xml:space="preserve">
          <source>This combining of the environment and the function is called a</source>
          <target state="translated">这种环境和函数的结合称为一个</target>
        </trans-unit>
        <trans-unit id="f04a03c616b5e70e398965fd9e6bb2d3b0919b13" translate="yes" xml:space="preserve">
          <source>This command-line parameter does not affect custom unit test handlers.</source>
          <target state="translated">这个命令行参数不影响自定义单元测试处理程序。</target>
        </trans-unit>
        <trans-unit id="230aa360bfc55c5cf21e968f489f8b1241790aa2" translate="yes" xml:space="preserve">
          <source>This compile-time flag is &lt;code&gt;true&lt;/code&gt; if logging is not statically disabled.</source>
          <target state="translated">如果未静态禁用日志记录，则此编译时标志为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d82eb07cfddf77181a4fa8aca621ce6591fd7ca9" translate="yes" xml:space="preserve">
          <source>This constructor is only called when we figured out which function template to instantiate.</source>
          <target state="translated">这个构造函数只有在我们弄清楚要实例化哪个函数模板时才会被调用。</target>
        </trans-unit>
        <trans-unit id="aa95214feed626f5e6eebb5c6959ff1d8bcafc67" translate="yes" xml:space="preserve">
          <source>This constructor is the inverse of &lt;a href=&quot;#opCast&quot;&gt;&lt;code&gt;opCast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此构造函数与&lt;a href=&quot;#opCast&quot;&gt; &lt;code&gt;opCast&lt;/code&gt; 相反&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8fcfb06ab6c25d2bbe46e5cfe782e5b576ac2d4" translate="yes" xml:space="preserve">
          <source>This contains the copyright notice. The macro COPYRIGHT is set to the contents of the section when it documents the module declaration. The copyright section only gets this special treatment when it is for the module declaration.</source>
          <target state="translated">这里面包含了版权声明。当它记录模块声明时,宏观的 COPYRIGHT 被设置为该部分的内容。只有当模块声明时,版权部分才会得到这种特殊处理。</target>
        </trans-unit>
        <trans-unit id="822ca8d08b221bc29495c95da9984e8cee76c282" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage decoding buffers.</source>
          <target state="translated">这种方便的方法减轻了手动管理解码缓冲区的需要。</target>
        </trans-unit>
        <trans-unit id="cf045283f89baa3e44e42e507f01aa06b96bde31" translate="yes" xml:space="preserve">
          <source>This convenience method alleviates the need to manually manage output buffers.</source>
          <target state="translated">这种方便的方法减轻了手动管理输出缓冲区的需要。</target>
        </trans-unit>
        <trans-unit id="16b88e43157a2f6f2c5142b90b7d5fe45695bbef" translate="yes" xml:space="preserve">
          <source>This created a new Fiber for the supplied op and adds it to the dispatch list.</source>
          <target state="translated">这就为所提供的操作创建了一个新的光纤,并将其添加到调度列表中。</target>
        </trans-unit>
        <trans-unit id="fdc94e4392e59112302f3c3212c7174cb2489e38" translate="yes" xml:space="preserve">
          <source>This creates a new Fiber for the supplied op and then starts the dispatcher.</source>
          <target state="translated">这将为提供的操作创建一个新的光纤,然后启动调度器。</target>
        </trans-unit>
        <trans-unit id="af45f3f128eb584feb53ad796c2bd75a57d5180c" translate="yes" xml:space="preserve">
          <source>This defines a new type &lt;code&gt;X&lt;/code&gt; which has values &lt;code&gt;X.A=0&lt;/code&gt;, &lt;code&gt;X.B=1&lt;/code&gt;, &lt;code&gt;X.C=2&lt;/code&gt;:</source>
          <target state="translated">这定义了一个新的 &lt;code&gt;X&lt;/code&gt; 类型，其值 &lt;code&gt;X.A=0&lt;/code&gt; ， &lt;code&gt;X.B=1&lt;/code&gt; ， &lt;code&gt;X.C=2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0d27799b2bf9fed9292a027676e909387c978ddb" translate="yes" xml:space="preserve">
          <source>This definition of mutable functions is more general than the one traditionally employed by pure functional languages because it allows a D pure function to use state mutation, as long as all state is created internally or reachable through its arguments. In particular, a pure function may allocate memory by means of e.g. &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;malloc&lt;/code&gt; without these being special cases. A pure function is allowed to loop indefinitely or terminate the program.</source>
          <target state="translated">这种可变函数的定义比纯函数语言传统上使用的定义更笼统，因为只要所有状态都是在内部创建或通过其参数可访问的，它就允许D纯函数使用状态突变。尤其是，纯函数可以通过例如 &lt;code&gt;new&lt;/code&gt; 或 &lt;code&gt;malloc&lt;/code&gt; 分配内存，而这些都不是特殊情况。允许纯函数无限循环或终止程序。</target>
        </trans-unit>
        <trans-unit id="524100fdceb69609090212fc4caf6a68ca169c00" translate="yes" xml:space="preserve">
          <source>This deletes the key e1 from the associative array e2</source>
          <target state="translated">这将从关联数组e2中删除键e1。</target>
        </trans-unit>
        <trans-unit id="e594f9c668086e01075383fb67708b16f0e2344d" translate="yes" xml:space="preserve">
          <source>This describes the OOP API. To understand when to use the template API and when to use the OOP API, see the module documentation at the top of this page.</source>
          <target state="translated">这里描述了OOP API。要了解什么时候使用模板API,什么时候使用OOP API,请看本页顶部的模块文档。</target>
        </trans-unit>
        <trans-unit id="3007dc64e992f88997b93bf75939ee91b3bf45cf" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;code&gt;x86&lt;/code&gt; and &lt;code&gt;x86_64&lt;/code&gt; implementations of the inline assembler. The inline assembler platform support that a compiler provides is indicated by the &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; and &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; version identifiers, respectively.</source>
          <target state="translated">本文档介绍了嵌入式汇编程序的 &lt;code&gt;x86&lt;/code&gt; 和 &lt;code&gt;x86_64&lt;/code&gt; 实现。编译器提供的内联汇编程序平台支持分别由 &lt;code&gt;D_InlineAsm_X86&lt;/code&gt; 和 &lt;code&gt;D_InlineAsm_X86_64&lt;/code&gt; 版本标识符指示。</target>
        </trans-unit>
        <trans-unit id="569cf1450215141639c3396e75fe3e0e30e8cd78" translate="yes" xml:space="preserve">
          <source>This document is the reference manual for the D Programming Language. For more information and other documents, see &lt;a href=&quot;https://dlang.org/&quot;&gt;The D Language Website&lt;/a&gt;.</source>
          <target state="translated">本文档是D编程语言的参考手册。有关更多信息和其他文档，请参见&lt;a href=&quot;https://dlang.org/&quot;&gt;The D Language Website&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b76c1da48d91edda64500d21af760a6ce3c2286" translate="yes" xml:space="preserve">
          <source>This document specifies how to interface with C++ directly.</source>
          <target state="translated">本文档规定了如何直接与C++接口。</target>
        </trans-unit>
        <trans-unit id="4eaa9b84c7822b2e3e77fa7e5df36263689f6cc9" translate="yes" xml:space="preserve">
          <source>This documents the general structure of a Digest in the template API. All digest implementations should implement the following members and therefore pass the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test.</source>
          <target state="translated">本文档在模板API中记录了摘要的一般结构。所有摘要实现均应实现以下成员，并因此通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;测试。</target>
        </trans-unit>
        <trans-unit id="ac0dd62d84db23b0de6fee189b1020c75493d355" translate="yes" xml:space="preserve">
          <source>This does not assign the pointer of &lt;code&gt;rhs&lt;/code&gt; to this &lt;code&gt;RefRange&lt;/code&gt;. Rather it assigns the range pointed to by &lt;code&gt;rhs&lt;/code&gt; to the range pointed to by this &lt;code&gt;RefRange&lt;/code&gt;. This is because</source>
          <target state="translated">这不会将 &lt;code&gt;rhs&lt;/code&gt; 的指针分配给此 &lt;code&gt;RefRange&lt;/code&gt; 。而是将 &lt;code&gt;rhs&lt;/code&gt; 指向的范围分配给此 &lt;code&gt;RefRange&lt;/code&gt; 指向的范围。这是因为</target>
        </trans-unit>
        <trans-unit id="e81812302527d63ee87960159e6a1b9dd25fb020" translate="yes" xml:space="preserve">
          <source>This does not include any time during which the StopWatch was stopped but does include</source>
          <target state="translated">这不包括停表期间的任何时间,但包括</target>
        </trans-unit>
        <trans-unit id="c432390e6bbf7d9fb981f314323bac09cd4ec391" translate="yes" xml:space="preserve">
          <source>This does not mean, however, that one can change the data:</source>
          <target state="translated">但这并不意味着可以改变数据。</target>
        </trans-unit>
        <trans-unit id="1d63844eee394540a61e05092a78018f8dcdacad" translate="yes" xml:space="preserve">
          <source>This doesn't include '\n', '\r', \t' and other non-space &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;. For commonly used less strict semantics see &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这不包括'\ n'，'\ r'，\ t'和其他非空格&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;。有关常用的不太严格的语义，请参见&lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b899c5918773ae82ab7898c96cd3e0a68f5b5e5e" translate="yes" xml:space="preserve">
          <source>This doesn't work for TLS memory, though.</source>
          <target state="translated">但这对TLS内存不起作用。</target>
        </trans-unit>
        <trans-unit id="add950f77c9072c48dcd0ff96facedd547735caa" translate="yes" xml:space="preserve">
          <source>This easy handle has completed. 'result' contains the CURLcode of the transfer</source>
          <target state="translated">这个简单的处理已经完成。'result'包含了传输的CURL代码。</target>
        </trans-unit>
        <trans-unit id="ef5d8951fd69c70c7d61e2bd1231248df49b6d3e" translate="yes" xml:space="preserve">
          <source>This example creates a DOM (Document Object Model) tree from an XML file.</source>
          <target state="translated">这个例子从XML文件中创建一个DOM(文档对象模型)树。</target>
        </trans-unit>
        <trans-unit id="74ec60c9c14341e9d9e5373aa773d98804f76f30" translate="yes" xml:space="preserve">
          <source>This example does much the same thing, except that the file is deconstructed and reconstructed by hand. This is more work, but the techniques involved offer vastly more power.</source>
          <target state="translated">这个例子做的事情大同小异,只是文件是由人工解构和重建的。这是更多的工作,但所涉及的技术提供了更大的力量。</target>
        </trans-unit>
        <trans-unit id="7a4cbb05cb72419e58f855fffb51071ca39f119b" translate="yes" xml:space="preserve">
          <source>This example encodes the input data one byte at a time.</source>
          <target state="translated">这个例子每次对输入数据进行一个字节的编码。</target>
        </trans-unit>
        <trans-unit id="efc529b5b8a635fe0248f0e1b5570f3e5c62ec50" translate="yes" xml:space="preserve">
          <source>This example encodes the input one line at a time.</source>
          <target state="translated">这个例子一次只对一行输入进行编码。</target>
        </trans-unit>
        <trans-unit id="709f6883e08535336d0975187381366956732f0d" translate="yes" xml:space="preserve">
          <source>This example of template foo has a value parameter that is specialized for 10:</source>
          <target state="translated">本例模板foo的值参数专门为10。</target>
        </trans-unit>
        <trans-unit id="0c7fc0bf8d7d58bae3c653e435da196f5834dccc" translate="yes" xml:space="preserve">
          <source>This example shows decoding one byte at a time.</source>
          <target state="translated">这个例子显示了一次一个字节的解码。</target>
        </trans-unit>
        <trans-unit id="ca9412e6a6a265cc25cdadaa2feca886b99350b4" translate="yes" xml:space="preserve">
          <source>This example shows decoding over a range of input data lines.</source>
          <target state="translated">这个例子显示了在一系列输入数据线上的解码。</target>
        </trans-unit>
        <trans-unit id="3ca157dc5296c9dbda3b67885000d1a3d169c64b" translate="yes" xml:space="preserve">
          <source>This example uses a mixin to implement a generic Duff's device for an arbitrary statement (in this case, the arbitrary statement is in bold). A nested function is generated as well as a delegate literal, these can be inlined by the compiler:</source>
          <target state="translated">这个例子使用一个 mixin 来实现一个通用的 Duff's 设备,用于任意语句(在本例中,任意语句用粗体表示)。一个嵌套的函数和一个委托文字被生成,这些可以被编译器内联。</target>
        </trans-unit>
        <trans-unit id="9fd04b9d165e95a5b5d46f431bdbd8794b151b29" translate="yes" xml:space="preserve">
          <source>This example will create an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;, and log the message using &lt;code&gt;NSLog&lt;/code&gt; to stderr.</source>
          <target state="translated">本示例将创建一个Objective-C字符串 &lt;code&gt;NSString&lt;/code&gt; ，并使用 &lt;code&gt;NSLog&lt;/code&gt; 将消息记录到stderr。</target>
        </trans-unit>
        <trans-unit id="5b44fd2927053fecf7f02a805bef21a73969e7c8" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an error occurs when parsing a UUID from a string.</source>
          <target state="translated">如果从字符串中解析UUID时发生错误,就会抛出这个异常。</target>
        </trans-unit>
        <trans-unit id="83cf2ca3dac976d4903c104f6cecb54eca32e9c0" translate="yes" xml:space="preserve">
          <source>This exists in order to find where &lt;code&gt;STC.maybescope&lt;/code&gt; is getting turned off.</source>
          <target state="translated">存在是为了找到 &lt;code&gt;STC.maybescope&lt;/code&gt; 正在关闭的位置。</target>
        </trans-unit>
        <trans-unit id="ec12e985e5f97029a4fdcc178a312496ababfe99" translate="yes" xml:space="preserve">
          <source>This fiber must be in state HOLD.</source>
          <target state="translated">该光纤必须处于HOLD状态。</target>
        </trans-unit>
        <trans-unit id="050dfac3109c2719a43b56525c7b1b2f0f5442dd" translate="yes" xml:space="preserve">
          <source>This fiber must be in state TERM or HOLD.</source>
          <target state="translated">该光纤必须处于TERM或HOLD状态。</target>
        </trans-unit>
        <trans-unit id="8069d75e504b5df60eaae8b05121a6dfce90e592" translate="yes" xml:space="preserve">
          <source>This field has been deprecated. Please use &lt;code&gt;cacheLevels&lt;/code&gt; instead.</source>
          <target state="translated">此字段已弃用。请改用 &lt;code&gt;cacheLevels&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a88f12f8698a93effebf4b21ac2fcaaf1ed6557e" translate="yes" xml:space="preserve">
          <source>This field is populated when using &lt;a href=&quot;#csvReader&quot;&gt;&lt;code&gt;csvReader&lt;/code&gt;&lt;/a&gt; but not by &lt;a href=&quot;#csvNextToken&quot;&gt;&lt;code&gt;csvNextToken&lt;/code&gt;&lt;/a&gt; as this data will have already been fed to the output range.</source>
          <target state="translated">使用&lt;a href=&quot;#csvReader&quot;&gt; &lt;code&gt;csvReader&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;#csvNextToken&quot;&gt; &lt;code&gt;csvNextToken&lt;/code&gt; 时&lt;/a&gt;，将填充此字段，因为此数据已被输入到输出范围。</target>
        </trans-unit>
        <trans-unit id="00b3ae505bfa7b5877d4290b9bf62b73f3526eab" translate="yes" xml:space="preserve">
          <source>This field was added in CURLVERSION_THIRD</source>
          <target state="translated">这个字段是在CURLVERSION_THIRD中添加的。</target>
        </trans-unit>
        <trans-unit id="ded4afb1457e0f04e1bc6ce625b9a154f7bfa729" translate="yes" xml:space="preserve">
          <source>This flag has no effect on &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该标志对&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt;没有影响。</target>
        </trans-unit>
        <trans-unit id="0c7a11a8d6d19389f0abbac4fa34ba46bd07ad35" translate="yes" xml:space="preserve">
          <source>This function</source>
          <target state="translated">该功能</target>
        </trans-unit>
        <trans-unit id="63a837cbc01e12716c2a63542540dfd3d20ec868" translate="yes" xml:space="preserve">
          <source>This function allocates memory.</source>
          <target state="translated">该函数分配内存。</target>
        </trans-unit>
        <trans-unit id="92814a3bf729ba0c96c36e96433e5f0d828849bd" translate="yes" xml:space="preserve">
          <source>This function allows user-defined subclasses of EncodingScheme to be declared in other modules.</source>
          <target state="translated">这个函数允许用户在其他模块中声明EncodingScheme的子类。</target>
        </trans-unit>
        <trans-unit id="471f7413c5ebea16f57422410a8bf930e30c75d3" translate="yes" xml:space="preserve">
          <source>This function also decomposes hangul syllables as prescribed by the standard.</source>
          <target state="translated">这个功能还可以按标准规定分解汉字音节。</target>
        </trans-unit>
        <trans-unit id="534457dcd59761dcb843df10d6fcec190ed3b4c4" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. The variadic overload is guaranteed to only perform a single allocation, as is the range version if &lt;code&gt;paths&lt;/code&gt; is a forward range.</source>
          <target state="translated">此函数始终分配内存以保存结果路径。如果 &lt;code&gt;paths&lt;/code&gt; 是正向范围，则保证可变参数重载仅执行单个分配，范围版本也是如此。</target>
        </trans-unit>
        <trans-unit id="bd9256b25c3dea2b100b91fc151d4d49aa057003" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#asNormalizedPath&quot;&gt;&lt;code&gt;asNormalizedPath&lt;/code&gt;&lt;/a&gt; to not allocate memory.</source>
          <target state="translated">此函数始终分配内存以保存结果路径。使用&lt;a href=&quot;#asNormalizedPath&quot;&gt; &lt;code&gt;asNormalizedPath&lt;/code&gt; &lt;/a&gt;不分配内存。</target>
        </trans-unit>
        <trans-unit id="187779b43f44c34c6b32550dd282a3cd2f13a1e6" translate="yes" xml:space="preserve">
          <source>This function always allocates memory to hold the resulting path. Use &lt;a href=&quot;#buildNormalizedPath&quot;&gt;&lt;code&gt;buildNormalizedPath&lt;/code&gt;&lt;/a&gt; to allocate memory and return a string.</source>
          <target state="translated">此函数始终分配内存以保存结果路径。使用&lt;a href=&quot;#buildNormalizedPath&quot;&gt; &lt;code&gt;buildNormalizedPath&lt;/code&gt; &lt;/a&gt;分配内存并返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="565ae089ae893ce04d0723fbc06da8efba3b5449" translate="yes" xml:space="preserve">
          <source>This function calls &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt;&lt;code&gt;FlushFileBuffers&lt;/code&gt;&lt;/a&gt; on Windows and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt;&lt;code&gt;fsync&lt;/code&gt;&lt;/a&gt; on POSIX for the file handle.</source>
          <target state="translated">此函数在Windows 上调用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx&quot;&gt; &lt;code&gt;FlushFileBuffers&lt;/code&gt; &lt;/a&gt;，在POSIX 上&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html&quot;&gt; &lt;code&gt;fsync&lt;/code&gt; &lt;/a&gt;作为文件句柄。</target>
        </trans-unit>
        <trans-unit id="f8c2e50367d22c68b1ef6bf70b530cf16359f88a" translate="yes" xml:space="preserve">
          <source>This function can allocate if the &lt;code&gt;Yes.allocateGC&lt;/code&gt; flag is passed. This has the benefit of have better complexity than the &lt;code&gt;Yes.allocateGC&lt;/code&gt; option. However, this option is only available for ranges whose equality can be determined via each element's &lt;code&gt;toHash&lt;/code&gt; method. If customized equality is needed, then the &lt;code&gt;pred&lt;/code&gt; template parameter can be passed, and the function will automatically switch to the non-allocating algorithm. See &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; for more details on how to define &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">如果传递了 &lt;code&gt;Yes.allocateGC&lt;/code&gt; 标志，则此函数可以分配。与 &lt;code&gt;Yes.allocateGC&lt;/code&gt; 选项相比，这样做的好处是具有更好的复杂性。但是，此选项仅适用于可以通过每个元素的 &lt;code&gt;toHash&lt;/code&gt; 方法确定其相等性的范围。如果需要自定义的相等性，则可以传递 &lt;code&gt;pred&lt;/code&gt; template参数，该函数将自动切换到非分配算法。有关如何定义 &lt;code&gt;pred&lt;/code&gt; 的更多详细信息，请参见&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b1f8d9be7c40727aeac47ccfd7444f517f04172" translate="yes" xml:space="preserve">
          <source>This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">这个功能可以 &lt;code&gt;@trusted&lt;/code&gt; 如果相应构造 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="287c25734ab50e3ae9a7c39776861bb5646f4c1c" translate="yes" xml:space="preserve">
          <source>This function can perform a case-sensitive or a case-insensitive comparison. This is controlled through the &lt;code&gt;cs&lt;/code&gt; template parameter which, if not specified, is given by &lt;a href=&quot;#CaseSensitive&quot;&gt;&lt;code&gt;CaseSensitive&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.osDefault&lt;/code&gt;.</source>
          <target state="translated">此函数可以执行区分大小写或不区分大小写的比较。这由 &lt;code&gt;cs&lt;/code&gt; 模板参数控制，如果未指定，则由&lt;a href=&quot;#CaseSensitive&quot;&gt; &lt;code&gt;CaseSensitive&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.osDefault&lt;/code&gt; 给出。</target>
        </trans-unit>
        <trans-unit id="5e873b6c5b5805640016d4214ee3463e370b995d" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt; the POSIX requirements for the 'basename' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="translated">此函数符合&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html&quot;&gt;&amp;ldquo; basename&amp;rdquo; shell实用程序的POSIX要求&lt;/a&gt;（对Windows路径进行了适当的修改）。</target>
        </trans-unit>
        <trans-unit id="271fe9a4358104e29e9baaf0f70ca7697a626f35" translate="yes" xml:space="preserve">
          <source>This function complies with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt; the POSIX requirements for the 'dirname' shell utility&lt;/a&gt; (with suitable adaptations for Windows paths).</source>
          <target state="translated">此函数符合&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html&quot;&gt;&amp;ldquo; dirname&amp;rdquo; shell实用程序的POSIX要求&lt;/a&gt;（对Windows路径进行了适当的修改）。</target>
        </trans-unit>
        <trans-unit id="f911814cd134bf58a8ba7e68aae37ec618511b50" translate="yes" xml:space="preserve">
          <source>This function consumes the input. After each call the input will start with either a delimiter or record break (\n, \r\n, \r) which must be removed for subsequent calls.</source>
          <target state="translated">该函数消耗输入。在每次调用后,输入将以一个定界符或记录中断开始(\n,\r\n,\r),这些记录必须在后续调用中被删除。</target>
        </trans-unit>
        <trans-unit id="82adca51d2d89c2e52168f23c5014dcf4b09b7e3" translate="yes" xml:space="preserve">
          <source>This function creates a complete DOM (Document Object Model) tree.</source>
          <target state="translated">该函数创建一个完整的DOM(文档对象模型)树。</target>
        </trans-unit>
        <trans-unit id="34f7e14685f9dc1d8824f48b2307f8cd989b3e43" translate="yes" xml:space="preserve">
          <source>This function decodes the entities &amp;amp;amp;, &amp;amp;quot;, &amp;amp;apos;, &amp;amp;lt; and &amp;amp;gt, as well as decimal and hexadecimal entities such as &amp;amp;#x20AC;</source>
          <target state="translated">该功能对实体＆amp;，&amp;ldquo;，&amp;rdquo;，＆lt; 和＆gt，以及十进制和十六进制实体，例如＆＃x20AC;</target>
        </trans-unit>
        <trans-unit id="37bc9985a8792341b2d7a8d50dc7ab55bd1e93ad" translate="yes" xml:space="preserve">
          <source>This function defends against this attack by always comparing every single item in the array if the two arrays are the same length. Therefore, this function is always &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;) for ranges of the same length.</source>
          <target state="translated">如果两个数组的长度相同，则此函数通过始终比较数组中的每个单个项来防御这种攻击。因此，对于相同长度的范围，此函数始终为&amp;omicron;（ &lt;code&gt;n&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="07fbd70f1f7940fca06c0a8a3c74b8aabe9ac979" translate="yes" xml:space="preserve">
          <source>This function does not provide overloads for wstring and dstring, as there's no clear answer on how that should be implemented. It could be argued, that string, wstring and dstring input should have the same output, but that wouldn't be compatible with Boost, which generates different output for strings and wstrings. It's always possible to pass wstrings and dstrings by using the ubyte[] function overload (but be aware of endianness issues!).</source>
          <target state="translated">这个函数不提供wstring和dstring的重载,因为没有明确的答案应该如何实现。可以说,字符串、wstring和dstring的输入应该有相同的输出,但这与Boost不兼容,因为Boost会为字符串和wstrings生成不同的输出。通过使用ubyte[]函数重载来传递wstrings和dstrings总是可能的(但是要注意endianness问题!)。</target>
        </trans-unit>
        <trans-unit id="a7eab1a520623d1ac5e68ed2c102542d0c568c2a" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units The code units are stored in a user-supplied fixed-size array, which must be passed by reference.</source>
          <target state="translated">该函数将单个代码点编码成一个或多个代码单元,代码单元存储在一个用户提供的固定大小的数组中,该数组必须通过引用传递。</target>
        </trans-unit>
        <trans-unit id="a4dfecb064dc08682e5d5f6ff6e2a923d6c06c55" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. It returns a string containing those code units.</source>
          <target state="translated">该函数将一个代码点编码成一个或多个代码单位。它返回一个包含这些代码单位的字符串。</target>
        </trans-unit>
        <trans-unit id="d23af3939d6f49cb27a211fdfb01f49551cd4f68" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more code units. The code units are passed one at a time to the supplied delegate.</source>
          <target state="translated">该函数将一个代码点编码成一个或多个代码单位。这些代码单元每次都会被传递给所提供的委托人。</target>
        </trans-unit>
        <trans-unit id="fd5007482279246870e612a2f7b9d7848a9ec8a9" translate="yes" xml:space="preserve">
          <source>This function encodes a single code point into one or more ubytes. The supplied buffer must be code unit aligned. (For example, UTF-16LE or UTF-16BE must be wchar-aligned, UTF-32LE or UTF-32BE must be dchar-aligned, etc.)</source>
          <target state="translated">该函数将单个码点编码为一个或多个uby字节。提供的缓冲区必须是代码单位对齐的。例如,UTF-16LE或UTF-16BE必须是wchar对齐,UTF-32LE或UTF-32BE必须是dchar对齐,等等。</target>
        </trans-unit>
        <trans-unit id="5a399e2ee90c7d22546000e946a9cf8427b4a082" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">使用此函数可以轻松地将&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;转换为字符串，而不必关心确切的格式，而只是以清晰的方式显示信息。使用 &lt;code&gt;to!string&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; 或 &lt;code&gt;writeln&lt;/code&gt; 之类的函数（使用toString转换用户定义的类型）时，还可以轻松地简单地将&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;转换为字符串。因此，不太可能有太多代码直接调用toString。</target>
        </trans-unit>
        <trans-unit id="1c7ed4f81f0a82e13d48bb2e31cd6ec82cd2b86c" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">使用此函数可以轻松地将&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;转换为字符串，而不必关心确切的格式，而只是以清晰的方式显示信息。使用 &lt;code&gt;to!string&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; 或 &lt;code&gt;writeln&lt;/code&gt; 之类的函数（使用toString转换用户定义的类型）时，还可以轻松地简单地将&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;转换为字符串。因此，不太可能有太多代码直接调用toString。</target>
        </trans-unit>
        <trans-unit id="6a64dc24e50c98de86395100f53371f383577cde" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">使用此功能可以轻松地将&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;转换为字符串，而不必关心确切的格式，而只是以清晰的方式显示信息。使用 &lt;code&gt;to!string&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; 或 &lt;code&gt;writeln&lt;/code&gt; 之类的函数（使用toString转换用户定义的类型）时，还可以轻松地将&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;转换为字符串。因此，不太可能有太多代码直接调用toString。</target>
        </trans-unit>
        <trans-unit id="14f41e253b823f745b15c2cc550803f474f520f9" translate="yes" xml:space="preserve">
          <source>This function exists to make it easy to convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string for code that does not care what the exact format is - just that it presents the information in a clear manner. It also makes it easy to simply convert a &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to a string when using functions such as &lt;code&gt;to!string&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;writeln&lt;/code&gt; which use toString to convert user-defined types. So, it is unlikely that much code will call toString directly.</source>
          <target state="translated">存在此函数的目的在于，可以轻松地将&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;转换为字符串，而不必关心确切的格式，而只是以清晰的方式显示信息。使用 &lt;code&gt;to!string&lt;/code&gt; ， &lt;code&gt;format&lt;/code&gt; 或 &lt;code&gt;writeln&lt;/code&gt; 之类的函数（使用toString转换用户定义的类型）时，还可以轻松地将&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;转换为字符串。因此，不太可能有太多代码直接调用toString。</target>
        </trans-unit>
        <trans-unit id="1148e69f156783aee95aaac3af378446a842c947" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 3) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="translated">此函数从名称空间UUID和名称生成基于名称（版本3）的UUID。如果未传递任何名称空间UUID，则使用空的UUID &lt;code&gt;UUID.init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66eef894e5457f79fe590d4b75d5bdb426faba8d" translate="yes" xml:space="preserve">
          <source>This function generates a name based (Version 5) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID &lt;code&gt;UUID.init&lt;/code&gt; is used.</source>
          <target state="translated">此函数从名称空间UUID和名称生成基于名称（版本5）的UUID。如果未传递任何名称空间UUID，则使用空的UUID &lt;code&gt;UUID.init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebad38cdc822b58300e9d455ffae98ef3b8355b1" translate="yes" xml:space="preserve">
          <source>This function generates a random number based UUID from a random number generator.</source>
          <target state="translated">该函数从随机数生成器中生成一个基于随机数的UUID。</target>
        </trans-unit>
        <trans-unit id="f6f7c9706e6dcaec3dbc1161d8b30b320ab44ea3" translate="yes" xml:space="preserve">
          <source>This function has high relative accuracy for values of x far from zero. (For values near zero, use erf(x)).</source>
          <target state="translated">这个函数对于远离零的x值有很高的相对精度。对于接近零的值,使用 erf(x))。</target>
        </trans-unit>
        <trans-unit id="e015cb774f65ac50bf4cc869720d1f86b5a714ec" translate="yes" xml:space="preserve">
          <source>This function is #1 on the list of functions that eat cpu time. Be very, very careful about slowing it down.</source>
          <target state="translated">这个函数是吃cpu时间的函数列表中的第一名。要非常非常小心地减慢它的速度。</target>
        </trans-unit>
        <trans-unit id="3d30b43ff787a8dfba63ef7540785dda2309b0ec" translate="yes" xml:space="preserve">
          <source>This function is &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">此函数为&amp;Omicron;（ &lt;code&gt;r.length&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="60a203a8ffe09817c002b043b4f7c89faa37bc5d" translate="yes" xml:space="preserve">
          <source>This function is &lt;code&gt;@safe&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 的对应构造函数为 &lt;code&gt;@safe&lt;/code&gt; ,则此函数为 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21b9e96c1bd954c7d66e5b95c40487111fc7a052" translate="yes" xml:space="preserve">
          <source>This function is POSIX-Only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f04b8551bbda2b81d8696beac9a1b771dca8c71" translate="yes" xml:space="preserve">
          <source>This function is Posix-Only.</source>
          <target state="translated">这个功能是Posix-Only的。</target>
        </trans-unit>
        <trans-unit id="fbf60467a7efe2e24827c64edfe554cec3d53403" translate="yes" xml:space="preserve">
          <source>This function is Windows-Only.</source>
          <target state="translated">此功能仅适用于Windows。</target>
        </trans-unit>
        <trans-unit id="ad2fac1ecb2ded333fe1cd86ddc09c5fee778c2d" translate="yes" xml:space="preserve">
          <source>This function is a public API, exposed in &lt;code&gt;core.runtime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103c72135b781967b4b7d6c0026bb26f7259605d" translate="yes" xml:space="preserve">
          <source>This function is also useful in checking for the existence of an environment variable.</source>
          <target state="translated">这个函数在检查环境变量是否存在时也很有用。</target>
        </trans-unit>
        <trans-unit id="ff6b0b14fd4304f9c34b27c03cced94d986e4033" translate="yes" xml:space="preserve">
          <source>This function is character-range specific and, contrary to &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt;, runs of whitespace will be merged together (no empty tokens will be produced).</source>
          <target state="translated">此功能是特定于字符范围的，并且与 &lt;code&gt;splitter!(std.uni.isWhite)&lt;/code&gt; 相反，空白空格将合并在一起（不会生成空令牌）。</target>
        </trans-unit>
        <trans-unit id="65b5ee7f9fec25cbb593bdce1cbdc98ea5f973e1" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and calls &lt;code&gt;deallocateAll&lt;/code&gt; for them in turn.</source>
          <target state="translated">仅当两个分配器都定义了该函数，然后依次为其调用 &lt;code&gt;deallocateAll&lt;/code&gt; 时，才定义此函数。</target>
        </trans-unit>
        <trans-unit id="8e12c13033743e308c93ef7b1af47f1c5b48d3a7" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and forwards appropriately depending on &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">仅当两个分配器都定义了此函数，然后才根据 &lt;code&gt;b.length&lt;/code&gt; 进行适当转发。</target>
        </trans-unit>
        <trans-unit id="ebd4634555bf7b1d8d38cdad8559fbd72f2f0cbb" translate="yes" xml:space="preserve">
          <source>This function is defined only if both allocators define it, and returns the conjunction of &lt;code&gt;empty&lt;/code&gt; calls for the two.</source>
          <target state="translated">该功能仅定义如果两个分配器定义它，并返回的联合 &lt;code&gt;empty&lt;/code&gt; 两个电话。</target>
        </trans-unit>
        <trans-unit id="0fd9509d9dd53b0824e520cb29e4d50f69f4b9cc" translate="yes" xml:space="preserve">
          <source>This function is never used when autodecoding is turned off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72987efb86a1c65d967d861a8683d92ed7f13b9d" translate="yes" xml:space="preserve">
          <source>This function is not generally very useful; it's almost always better to use the faster functions nextUp() or nextDown() instead.</source>
          <target state="translated">这个函数一般不是很有用,最好使用更快的函数nextUp()或nextDown()来代替。</target>
        </trans-unit>
        <trans-unit id="ee8874e9697da79fd0874b41752112f89149a3af" translate="yes" xml:space="preserve">
          <source>This function is not implemented for Digital Mars C runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e3e7b8bfa4b21481d77f68ea65de0d9b8237c1" translate="yes" xml:space="preserve">
          <source>This function is not supported at compile time.</source>
          <target state="translated">编译时不支持此功能。</target>
        </trans-unit>
        <trans-unit id="1569b54f86e9b2550627b7e8e8f05e326ad676e8" translate="yes" xml:space="preserve">
          <source>This function is not thread-safe!</source>
          <target state="translated">这个功能不是线程安全的</target>
        </trans-unit>
        <trans-unit id="41af9d14cc682c76550081ea13492c59097f2bca" translate="yes" xml:space="preserve">
          <source>This function is only aware of EncodingSchemes which have been registered with the register() function.</source>
          <target state="translated">这个函数只知道已经用register()函数注册的EncodingSchemes。</target>
        </trans-unit>
        <trans-unit id="290ee1b0991973abcaa58bca7c5f6871e5deb008" translate="yes" xml:space="preserve">
          <source>This function is only implemented to 80 bit precision.</source>
          <target state="translated">该功能仅实现80位精度。</target>
        </trans-unit>
        <trans-unit id="ee429d1ffe9a170a1a75d5b4a2ff165cd4f65550" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, all elements of tiargs won't be modified.</source>
          <target state="translated">这个函数是针对错误发生的重入式函数,如果返回false,所有tiargs的元素都不会被修改。如果返回false,tiargs的所有元素将不会被修改。</target>
        </trans-unit>
        <trans-unit id="a118a63c84fce3cf7c06f5f8756bac60c7cca3ac" translate="yes" xml:space="preserve">
          <source>This function is reentrant against error occurrence. If returns false, any members of this object won't be modified, and repetition call will reproduce same error.</source>
          <target state="translated">这个函数是针对错误发生的重入式函数,如果返回false,所有tiargs的元素都不会被修改。如果返回false,这个对象的任何成员都不会被修改,重复调用会重现同样的错误。</target>
        </trans-unit>
        <trans-unit id="45e502c95c63dd3997ac1ae57545286a53eaf26c" translate="yes" xml:space="preserve">
          <source>This function is supported in CTFE code. Note that error messages caused by a malformed UUID parsed at compile time can be cryptic, but errors are detected and reported at compile time.</source>
          <target state="translated">CTFE代码中支持此功能。请注意,在编译时解析的UUID错误引起的错误信息可能是神秘的,但在编译时就会检测并报告错误。</target>
        </trans-unit>
        <trans-unit id="5bb3aca496547a19019cbfbd46c1d03c7dd418c6" translate="yes" xml:space="preserve">
          <source>This function is tentatively defined as &lt;code&gt;nothrow&lt;/code&gt; to prevent &lt;code&gt;opPostMove&lt;/code&gt; from being defined without &lt;code&gt;nothrow&lt;/code&gt;, which would allow for possibly confusing changes in program flow.</source>
          <target state="translated">此功能暂时定义为 &lt;code&gt;nothrow&lt;/code&gt; 以防止 &lt;code&gt;opPostMove&lt;/code&gt; 从没有被定义的 &lt;code&gt;nothrow&lt;/code&gt; ，这将允许可能混淆的程序流的变化。</target>
        </trans-unit>
        <trans-unit id="185d734d5fc912e0041185bf79a2b6f944b2db35" translate="yes" xml:space="preserve">
          <source>This function is used to (re)initialize the digest. It must be called before using the digest and it also works as a 'reset' function if the digest has already processed data.</source>
          <target state="translated">这个函数用于(重新)初始化摘要。它必须在使用摘要之前被调用,如果摘要已经处理过数据,它也可以作为一个 &quot;复位 &quot;函数。</target>
        </trans-unit>
        <trans-unit id="99071cc1c1c24be1d51b7e6eda1e08791479ed2b" translate="yes" xml:space="preserve">
          <source>This function is used to read the content of DFLAGS. Flags are separated based on spaces and tabs.</source>
          <target state="translated">该函数用于读取DFLAGS的内容。标志以空格和制表符分开。</target>
        </trans-unit>
        <trans-unit id="2d39d375bb67b5bea56b7ea75d0a2e4ee34a5fe2" translate="yes" xml:space="preserve">
          <source>This function is useful for maintaining worker-local resources.</source>
          <target state="translated">这个功能对维护工人本地资源很有用。</target>
        </trans-unit>
        <trans-unit id="c37fe60667a42f9d7da86b803e8b5052d66d498d" translate="yes" xml:space="preserve">
          <source>This function is, in particular, meant to help maintain garbage collector invariants when a lock is not used.</source>
          <target state="translated">这个函数尤其是为了在不使用锁的时候帮助维护垃圾收集器的不变性。</target>
        </trans-unit>
        <trans-unit id="aa18c6da596117f8b9e11fbedcdfb9a943118fde" translate="yes" xml:space="preserve">
          <source>This function logs data in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以 &lt;code&gt;printf&lt;/code&gt; 样式记录数据。</target>
        </trans-unit>
        <trans-unit id="77ac69a4b95956005ebe3b90c8e1ca91567efe01" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以 &lt;code&gt;printf&lt;/code&gt; 样式的方式将数据记录到 &lt;code&gt;sharedLog&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98febaf749a97b9336fc523ba35aa7fdcff34cf1" translate="yes" xml:space="preserve">
          <source>This function logs data to the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;, optionally depending on a condition.</source>
          <target state="translated">此函数将数据记录到 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; ，视情况而定。</target>
        </trans-unit>
        <trans-unit id="eda414e04cca7c9801e1364601be4f243d02a0be" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">该功能的日志数据所使用的 &lt;code&gt;Logger&lt;/code&gt; 根据与一个条件 &lt;code&gt;LogLevel&lt;/code&gt; 所使用的 &lt;code&gt;Logger&lt;/code&gt; 中一个 &lt;code&gt;printf&lt;/code&gt; 风格的方式。</target>
        </trans-unit>
        <trans-unit id="66789021f1f75fa2b910c0e9aaed002765517585" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a condition.</source>
          <target state="translated">此功能根据条件将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea29ac02cb23a3225768859acfa66ad70cf0ae39" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; depending on a explicitly passed condition with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此函数根据使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 明确传递的条件将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7a8c9b909022c7e8d9e73cb0c216e864ba19a51" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以 &lt;code&gt;printf&lt;/code&gt; 样式将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="628f5766ea3ce125dda3efbe604aac9ecda078eb" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; and depending on a condition in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以特定的 &lt;code&gt;LogLevel&lt;/code&gt; 并根据条件以 &lt;code&gt;printf&lt;/code&gt; 样式方式将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f75a8e8d5f3578debc1682e9b8a4e7729b3c532e" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此函数以特定的 &lt;code&gt;LogLevel&lt;/code&gt; 以 &lt;code&gt;printf&lt;/code&gt; 样式的方式将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="ca804d9917691f26fc7fe486237e02550749abb2" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with a specific &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">此函数通过特定 &lt;code&gt;LogLevel&lt;/code&gt; 将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3ca01c9755ef83db66052e862db8bfa8416b4a46" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此函数使用二手 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 将数据记录到二手 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="32b20bbe0e9053ff439b8531776b44b5d48b2b21" translate="yes" xml:space="preserve">
          <source>This function logs data to the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此功能将数据记录到使用的 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="de4891742f4a098eab831566cf8b20847dcaef47" translate="yes" xml:space="preserve">
          <source>This function logs data.</source>
          <target state="translated">该功能可记录数据。</target>
        </trans-unit>
        <trans-unit id="f6a6f2512cc3b6d3cec5f7eabcb2475f26f787b9" translate="yes" xml:space="preserve">
          <source>This function modifies &lt;code&gt;inp&lt;/code&gt; and thus &lt;code&gt;inp&lt;/code&gt; must be an L-value.</source>
          <target state="translated">此函数修改 &lt;code&gt;inp&lt;/code&gt; ，因此 &lt;code&gt;inp&lt;/code&gt; 必须为L值。</target>
        </trans-unit>
        <trans-unit id="e7aa3a07169729c5a673fe4e99d00fd959fedfe3" translate="yes" xml:space="preserve">
          <source>This function normally allocates a new string (the possible exception being the case when path is immutable and doesn't already have an extension).</source>
          <target state="translated">这个函数通常会分配一个新的字符串(可能的例外情况是当路径是不可变的,并且还没有扩展时)。</target>
        </trans-unit>
        <trans-unit id="7c7d082480a49d72cdaa9587898253b55870d5fe" translate="yes" xml:space="preserve">
          <source>This function only handles 1:1 &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; mapping and thus is not sufficient for certain alphabets like German, Greek and few others.</source>
          <target state="translated">此功能仅处理1：1的&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;映射，因此对于某些字母（例如德语，希腊语和其他少数几个字母）是不够的。</target>
        </trans-unit>
        <trans-unit id="4d4c84cebd7adfe7f4082a2a17dcc09bc723efd3" translate="yes" xml:space="preserve">
          <source>This function performs several memory allocations.</source>
          <target state="translated">该函数执行多项内存分配。</target>
        </trans-unit>
        <trans-unit id="36f6f15315bfa28fc8956871508424ecedf0dc3c" translate="yes" xml:space="preserve">
          <source>This function picks the most suitable regular expression engine depending on the pattern properties.</source>
          <target state="translated">该函数根据模式属性选择最合适的正则表达式引擎。</target>
        </trans-unit>
        <trans-unit id="34bd902809c0b5255b567c50dd18197e0b398a33" translate="yes" xml:space="preserve">
          <source>This function prints the passed &lt;code&gt;Option&lt;/code&gt;s and text in an aligned manner on &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">此函数在 &lt;code&gt;stdout&lt;/code&gt; 上以对齐方式打印传递的 &lt;code&gt;Option&lt;/code&gt; 和文本。</target>
        </trans-unit>
        <trans-unit id="770ded5804f61f67694592c9314c6c39ad348096" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the end of a string, and returns the decoded code point which those code units represent.</source>
          <target state="translated">该函数从字符串的末尾删除一个或多个代码单元,并返回这些代码单元所代表的解码码点。</target>
        </trans-unit>
        <trans-unit id="63d27ce6c5e48781869a5f906f514c111b2ab498" translate="yes" xml:space="preserve">
          <source>This function removes one or more code units from the start of a string, and returns the decoded code point which those code units represent.</source>
          <target state="translated">这个函数从一个字符串的开头删除一个或多个代码单元,并返回这些代码单元所代表的解码码点。</target>
        </trans-unit>
        <trans-unit id="991bbd196cea9f8531404b722484d52c7268693c" translate="yes" xml:space="preserve">
          <source>This function removes one or more ubytes from the start of an array, and returns the decoded code point which those ubytes represent.</source>
          <target state="translated">这个函数从一个数组的开头删除一个或多个uby字节,并返回这些uby字节所代表的解码码点。</target>
        </trans-unit>
        <trans-unit id="bd8d3ae1218b20b89d6f5e7ab875d1f322ea2c00" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; on Windows, &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; on POSIX, and &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; on Android.</source>
          <target state="translated">这个函数返回 &lt;code&gt;&quot;cmd.exe&quot;&lt;/code&gt; 在Windows上， &lt;code&gt;&quot;/bin/sh&quot;&lt;/code&gt; 关于POSIX和 &lt;code&gt;&quot;/system/bin/sh&quot;&lt;/code&gt; 在Android上。</target>
        </trans-unit>
        <trans-unit id="cfc5056dabba79a946af25fc1dd8feac3fe04895" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to a static copy of the version info struct. See above.</source>
          <target state="translated">这个函数返回一个指向版本信息结构静态副本的指针。参见上文。</target>
        </trans-unit>
        <trans-unit id="bb8f6db61ab479424f86bd4d40e2eb70c3733a62" translate="yes" xml:space="preserve">
          <source>This function returns a thread unique &lt;code&gt;Logger&lt;/code&gt;, that by default propergates all data logged to it to the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">此函数返回一个线程唯一的 &lt;code&gt;Logger&lt;/code&gt; ，默认情况下，它将记录到该线程的所有数据分配到 &lt;code&gt;sharedLog&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85a54448d469e795c947752c78a6d4cb2de70c6f" translate="yes" xml:space="preserve">
          <source>This function searches with policy &lt;code&gt;sp&lt;/code&gt; to find the largest right subrange on which &lt;code&gt;pred(value, x)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly greater than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数使用策略 &lt;code&gt;sp&lt;/code&gt; 搜索，以找到所有 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;pred(value, x)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的最大右子范围（例如，如果 &lt;code&gt;pred&lt;/code&gt; &amp;ldquo;小于&amp;rdquo;，则返回元素严格大于 &lt;code&gt;value&lt;/code&gt; 的范围的那一部分）。搜索时间表及其复杂性记录在&lt;a href=&quot;#SearchPolicy&quot;&gt; &lt;code&gt;SearchPolicy&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86863ccd0cc5913a3769149726c682b13dc136f9" translate="yes" xml:space="preserve">
          <source>This function sets an association in the multi handle between the given socket and a private pointer of the application. This is (only) useful for curl_multi_socket uses.</source>
          <target state="translated">这个函数在多句柄中设置给定套接字和应用程序的私有指针之间的关联。这个函数(仅)对 curl_multi_socket 的使用有用。</target>
        </trans-unit>
        <trans-unit id="45ebc1498e7faf85df00e384f08e7ba59324aaf5" translate="yes" xml:space="preserve">
          <source>This function should be used for expensive functions, as waiting on a condition variable introduces latency, but avoids wasted CPU cycles.</source>
          <target state="translated">这个函数应该用于昂贵的函数,因为在条件变量上的等待会引入延迟,但可以避免浪费CPU周期。</target>
        </trans-unit>
        <trans-unit id="1e6634f9a998d963ab6d1c10d0d15ad19ccda248" translate="yes" xml:space="preserve">
          <source>This function should be used when you expect the result of the &lt;code&gt;Task&lt;/code&gt; to be available on a timescale shorter than that of an OS context switch.</source>
          <target state="translated">当您希望 &lt;code&gt;Task&lt;/code&gt; 的结果在比操作系统上下文切换更短的时间范围内可用时，应使用此功能。</target>
        </trans-unit>
        <trans-unit id="84d0dda7f69c92e937d2c85cb930b35b5906bc64" translate="yes" xml:space="preserve">
          <source>This function simply returns the &lt;code&gt;Rebindable&lt;/code&gt; object passed in. It's useful in generic programming cases when a given object may be either a regular &lt;code&gt;class&lt;/code&gt; or a &lt;code&gt;Rebindable&lt;/code&gt;.</source>
          <target state="translated">此函数仅返回传入的 &lt;code&gt;Rebindable&lt;/code&gt; 对象。在给定对象可能是常规 &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;Rebindable&lt;/code&gt; 的泛型编程情况下，此函数很有用。</target>
        </trans-unit>
        <trans-unit id="75bbfb153afd3973808d9088100797f6903e565d" translate="yes" xml:space="preserve">
          <source>This function supercedes &lt;a href=&quot;#toUCSindex&quot;&gt;&lt;code&gt;toUCSindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数取代&lt;a href=&quot;#toUCSindex&quot;&gt; &lt;code&gt;toUCSindex&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82566e279c83708bdcc5beef2341e2cb52b9d496" translate="yes" xml:space="preserve">
          <source>This function supersedes &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt;.</source>
          <target state="translated">此函数取代 &lt;code&gt;std.utf.startsValidDchar()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8a982375de1de2eaf1b0bfc6ef749e37da8e235" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode(), however, note that the function codePoints() supersedes it more conveniently.</source>
          <target state="translated">这个函数取代了std.utf.decode(),但是,请注意,函数codePoints()取代它更方便。</target>
        </trans-unit>
        <trans-unit id="3610464c0d3095b814b50eec2269b0b83ec7dc6a" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.decode().</source>
          <target state="translated">这个函数取代了std.utf.decode()。</target>
        </trans-unit>
        <trans-unit id="3ed87f3ac177989d1d591be6e146c6a7ad9b003c" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode(), however, note that the function codeUnits() supersedes it more conveniently.</source>
          <target state="translated">这个函数取代了std.utf.encode(),但是,请注意,函数codeUnits()取代它更方便。</target>
        </trans-unit>
        <trans-unit id="98db0a10ff6e0809060d25a9c9ccbac61cd894c8" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.encode().</source>
          <target state="translated">这个函数取代了std.utf.encode()。</target>
        </trans-unit>
        <trans-unit id="6581afa2c255deba8c9a51b34c12340690fe56e5" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTF8(), std.utf.toUTF16() and std.utf.toUTF32() (but note that to!() supersedes it more conveniently).</source>
          <target state="translated">这个函数取代了std.utf.toUTF8()、std.utf.toUTF16()和std.utf.toUTF32()(但注意to!()取代它更方便)。</target>
        </trans-unit>
        <trans-unit id="b48f04fdfd63524d418640a2544c0d752dc1f11b" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.toUTFindex().</source>
          <target state="translated">这个函数取代了std.utf.toUTFindex()。</target>
        </trans-unit>
        <trans-unit id="463c192ee5d4e01c6f9684913be662a0a7946d01" translate="yes" xml:space="preserve">
          <source>This function supersedes std.utf.validate(), however note that this function returns a bool indicating whether the input was valid or not, whereas the older function would throw an exception.</source>
          <target state="translated">这个函数取代了std.utf.validate(),但是要注意的是,这个函数返回一个表示输入是否有效的bool,而旧的函数会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="b42d760296ed5ca95af88ffb26c20168d2a48b77" translate="yes" xml:space="preserve">
          <source>This function takes a non-scope delegate, meaning it can be used with closures. If you can't allocate a closure due to objects on the stack that have scoped destruction, see &lt;code&gt;scopedTask&lt;/code&gt;, which takes a scope delegate.</source>
          <target state="translated">此函数采用非作用域委托，这意味着它可以与闭包一起使用。如果由于堆栈上具有范围破坏的对象而无法分配闭包，请参阅 &lt;code&gt;scopedTask&lt;/code&gt; ，它接受了一个范围委托。</target>
        </trans-unit>
        <trans-unit id="df71b7c251663548a0f5121464d05a78978a7d9e" translate="yes" xml:space="preserve">
          <source>This function takes a set of path segments, given as an input range of string elements or as a set of string arguments, and concatenates them with each other. Directory separators are inserted between segments if necessary. If any of the path segments are absolute (as defined by &lt;a href=&quot;#isAbsolute&quot;&gt;&lt;code&gt;isAbsolute&lt;/code&gt;&lt;/a&gt;), the preceding segments will be dropped.</source>
          <target state="translated">此函数采用一组路径段（作为字符串元素的输入范围或一组字符串参数给出），并将它们彼此串联在一起。如有必要，在段之间插入目录分隔符。如果任何路径段都是绝对的（由&lt;a href=&quot;#isAbsolute&quot;&gt; &lt;code&gt;isAbsolute&lt;/code&gt; &lt;/a&gt;定义），则前面的段将被删除。</target>
        </trans-unit>
        <trans-unit id="3df6f1df50a9028bb24157314b57114720f745cc" translate="yes" xml:space="preserve">
          <source>This function template needs be between the compiler and a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">此功能模板需要介于编译器和较旧的运行时挂钩之间，后者绕过安全性，纯度和可抛出性检查。为防止破坏现有代码，此函数模板被临时声明为 &lt;code&gt;@trusted pure&lt;/code&gt; ,直到实现可以达到现代D的期望为止。</target>
        </trans-unit>
        <trans-unit id="c911ca2b3e26ac7f7502675d63ee542618ab2fa0" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure nothrow&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">该功能模板是从一个较旧的运行时钩子移植而来的，该钩子绕过了安全性，纯度和可投掷性检查。为防止破坏现有代码，此函数模板临时声明为 &lt;code&gt;@trusted pure nothrow&lt;/code&gt; ,直到可以使实现达到现代D的期望为止。</target>
        </trans-unit>
        <trans-unit id="9fd88572c57bc63342adb7e4bba717ecc664649b" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted pure&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">该功能模板是从一个较旧的运行时钩子移植而来的，该钩子绕过了安全性，纯度和可投掷性检查。为防止破坏现有代码，此函数模板被临时声明为 &lt;code&gt;@trusted pure&lt;/code&gt; ,直到实现可以达到现代D的期望为止。</target>
        </trans-unit>
        <trans-unit id="54aa9e4c989c8754e09bfc948cb90d22fd4c28bf" translate="yes" xml:space="preserve">
          <source>This function template was ported from a much older runtime hook that bypassed safety, purity, and throwabilty checks. To prevent breaking existing code, this function template is temporarily declared &lt;code&gt;@trusted&lt;/code&gt; until the implementation can be brought up to modern D expectations.</source>
          <target state="translated">该功能模板是从一个较旧的运行时钩子移植而来的，该钩子绕过了安全性，纯度和可投掷性检查。为防止破坏现有代码，此函数模板被临时声明为 &lt;code&gt;@trusted&lt;/code&gt; ,直到可以使实现达到现代D的期望为止。</target>
        </trans-unit>
        <trans-unit id="c6faa363e2dc5b5097ffda67002301974586de4b" translate="yes" xml:space="preserve">
          <source>This function transforms &lt;code&gt;decimal&lt;/code&gt; value into a value in the factorial number system stored in &lt;code&gt;fac&lt;/code&gt;.</source>
          <target state="translated">此函数将 &lt;code&gt;decimal&lt;/code&gt; 值转换为存储在 &lt;code&gt;fac&lt;/code&gt; 中的阶乘系统中的值。</target>
        </trans-unit>
        <trans-unit id="8756d8490c0c80f8a3d6e17d81badb070e1ac3c5" translate="yes" xml:space="preserve">
          <source>This function uses a search with policy &lt;code&gt;sp&lt;/code&gt; to find the largest left subrange on which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; (e.g., if &lt;code&gt;pred&lt;/code&gt; is &quot;less than&quot;, returns the portion of the range with elements strictly smaller than &lt;code&gt;value&lt;/code&gt;). The search schedule and its complexity are documented in &lt;a href=&quot;#SearchPolicy&quot;&gt;&lt;code&gt;SearchPolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该函数使用带有策略 &lt;code&gt;sp&lt;/code&gt; 的搜索来查找所有 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;pred(x, value)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 的最大左子范围（例如，如果 &lt;code&gt;pred&lt;/code&gt; 为&amp;ldquo;小于&amp;rdquo;，则返回元素严格小于 &lt;code&gt;value&lt;/code&gt; 的范围的一部分））。搜索时间表及其复杂性记录在&lt;a href=&quot;#SearchPolicy&quot;&gt; &lt;code&gt;SearchPolicy&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4d6e17a7f140767c7776fa94ca98edbcfe8ab26" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded array as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="translated">这个函数将接受一个无效编码的数组作为输入,如果在字符串的开头发现一个无效的序列,这个函数将删除它,并返回值INVALID_SEQUENCE。如果在字符串的开头发现一个无效的序列,这个函数将删除它,并返回值INVALID_SEQUENCE。</target>
        </trans-unit>
        <trans-unit id="b3cc6b0a88ba3b96758bad3549ef80853faeb94e" translate="yes" xml:space="preserve">
          <source>This function will accept an invalidly encoded string as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE.</source>
          <target state="translated">这个函数将接受一个无效编码的字符串作为输入,如果在字符串的开头发现一个无效的序列,这个函数将删除它,并返回值INVALID_SEQUENCE。如果在字符串的开头发现一个无效的序列,这个函数将删除它,并返回值INVALID_SEQUENCE。</target>
        </trans-unit>
        <trans-unit id="b4c790e3c00edf06c3c523e9a96acaa7028222ba" translate="yes" xml:space="preserve">
          <source>This function will also strip &lt;code&gt;\n\r&lt;/code&gt;.</source>
          <target state="translated">此功能还将删除 &lt;code&gt;\n\r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2b84c3cd64925b3bc63cc6da8970f088bb9f6ed" translate="yes" xml:space="preserve">
          <source>This function will be called when an exception is constructed. The user-supplied trace handler will be called if one has been supplied, otherwise no trace will be generated.</source>
          <target state="translated">当一个异常被构造时,这个函数将被调用。如果有用户提供的跟踪处理程序,则会被调用,否则不会产生跟踪。</target>
        </trans-unit>
        <trans-unit id="5d78c169d84f9e0fc354575058eb3e604cfbfdad" translate="yes" xml:space="preserve">
          <source>This function will be called with elements of &lt;code&gt;inputRange&lt;/code&gt; progressively as iteration proceeds.</source>
          <target state="translated">随着迭代的进行，将使用 &lt;code&gt;inputRange&lt;/code&gt; 的元素逐渐调用此函数。</target>
        </trans-unit>
        <trans-unit id="68ba6b0b259ab19a35f9197082fe2ab6d70f5d70" translate="yes" xml:space="preserve">
          <source>This function will generate a module called &lt;code&gt;__entrypoint&lt;/code&gt;, and set the globals &lt;code&gt;entrypoint&lt;/code&gt; and &lt;code&gt;rootHasMain&lt;/code&gt;.</source>
          <target state="translated">此函数将生成一个名为 &lt;code&gt;__entrypoint&lt;/code&gt; 的模块，并设置全局 &lt;code&gt;entrypoint&lt;/code&gt; 和 &lt;code&gt;rootHasMain&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc2b9580fcf2b39177541158722d4ae408a87a59" translate="yes" xml:space="preserve">
          <source>This function works by splitting the range to be reduced into work units, which are slices to be reduced in parallel. Once the results from all work units are computed, a final serial reduction is performed on these results to compute the final answer. Therefore, care must be taken to choose the seed value appropriately.</source>
          <target state="translated">该函数的工作原理是将待还原的范围分割成工作单元,这些工作单元是要并行还原的切片。一旦计算出所有工作单元的结果,就会对这些结果进行最后的串行还原,计算出最终的答案。因此,必须注意适当地选择种子值。</target>
        </trans-unit>
        <trans-unit id="85b846fd97be25d80f095623caef21705cf01c55" translate="yes" xml:space="preserve">
          <source>This function writes the passed text and &lt;code&gt;Option&lt;/code&gt; into an output range in the manner described in the documentation of function &lt;code&gt;defaultGetoptPrinter&lt;/code&gt;, unless the style option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3aad905401dc04f581b2c6077d97923bbd2a8dd" translate="yes" xml:space="preserve">
          <source>This function writes the passed text and &lt;code&gt;Option&lt;/code&gt; into an output range in the manner described in the documentation of function &lt;code&gt;defaultGetoptPrinter&lt;/code&gt;.</source>
          <target state="translated">该函数以函数 &lt;code&gt;defaultGetoptPrinter&lt;/code&gt; 的文档中描述的方式将传递的文本和 &lt;code&gt;Option&lt;/code&gt; 写入输出范围。</target>
        </trans-unit>
        <trans-unit id="055b5453fa39d56b283008b9edaf05dd119fac56" translate="yes" xml:space="preserve">
          <source>This functions is equivalent to &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt;.</source>
          <target state="translated">此函数等效于 &lt;code&gt;max(lower, min(upper,val))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3de8acad7b682bb3660ea91b4edba8b390f1f531" translate="yes" xml:space="preserve">
          <source>This functions is used at runtime to determine if a &lt;code&gt;LogLevel&lt;/code&gt; is active. The same previously defined version statements are used to disable certain levels. Again the version statements are associated with a compile unit and can therefore not disable logging in other compile units. pure bool isLoggingEnabled()(LogLevel ll) @safe nothrow @nogc</source>
          <target state="translated">该函数在运行时用于确定 &lt;code&gt;LogLevel&lt;/code&gt; 是否处于活动状态。相同的先前定义的版本语句用于禁用某些级别。同样，版本语句与编译单元相关联，因此不能禁用其他编译单元中的日志记录。纯布尔isLoggingEnabled（）（LogLevel ll）@safe nothrow @nogc</target>
        </trans-unit>
        <trans-unit id="9f907426d2ef951648d87f5cd993e54c9a2f733d" translate="yes" xml:space="preserve">
          <source>This functions returns a trace handler, allowing to inspect the current stack trace.</source>
          <target state="translated">该函数返回一个跟踪处理程序,允许检查当前堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="84eb391f18a28223816cf561bff30465c4000886" translate="yes" xml:space="preserve">
          <source>This gets replaced by the number of local bytes in the local stack frame. It is most handy when the &lt;code&gt;naked&lt;/code&gt; is invoked and a custom stack frame is programmed.</source>
          <target state="translated">它被替换为本地堆栈帧中的本地字节数。当它是最得心应手的 &lt;code&gt;naked&lt;/code&gt; 调用和一个自定义堆栈帧编程。</target>
        </trans-unit>
        <trans-unit id="e8e4bebddf13552333bc85ebe7b11a4e7247c831" translate="yes" xml:space="preserve">
          <source>This handle is used to specify the process in OS-specific APIs. On POSIX, this function returns a &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; with the same value as &lt;a href=&quot;#Pid.processID&quot;&gt;&lt;code&gt;Pid.processID&lt;/code&gt;&lt;/a&gt;, while on Windows it returns a &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt;.</source>
          <target state="translated">该句柄用于指定特定于OS的API中的过程。在POSIX上，此函数返回 &lt;code&gt;core.sys.posix.sys.types.pid_t&lt;/code&gt; ，其值与&lt;a href=&quot;#Pid.processID&quot;&gt; &lt;code&gt;Pid.processID&lt;/code&gt; &lt;/a&gt;相同，而在Windows上，它返回 &lt;code&gt;core.sys.windows.windows.HANDLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33c852a0522cad2c2b4928299e850452d227ef5f" translate="yes" xml:space="preserve">
          <source>This handler overrides any legacy module unit tester set by the moduleUnitTester property.</source>
          <target state="translated">该处理程序会覆盖任何由模块UnitTester属性设置的传统模块单元测试器。</target>
        </trans-unit>
        <trans-unit id="c35e1bd5e0e6a04521fa5520ade57041fbf6240b" translate="yes" xml:space="preserve">
          <source>This hasher is compatible with the &lt;code&gt;Digest&lt;/code&gt; API:</source>
          <target state="translated">该哈希器与 &lt;code&gt;Digest&lt;/code&gt; API 兼容：</target>
        </trans-unit>
        <trans-unit id="3993e1a9197061dc1bf704959d048cb51b8578f3" translate="yes" xml:space="preserve">
          <source>This implements a standard critical section.</source>
          <target state="translated">这实现了一个标准的关键部分。</target>
        </trans-unit>
        <trans-unit id="e2f62226ce4de7b0f3cba225bd19bb063907d826" translate="yes" xml:space="preserve">
          <source>This initialization is done before any constructors are called.</source>
          <target state="translated">这个初始化是在调用任何构造函数之前完成的。</target>
        </trans-unit>
        <trans-unit id="2e9f56ef2bea3abd9b78b212cb634ac700d5b66a" translate="yes" xml:space="preserve">
          <source>This instance needs an identifier for name mangling purposes. Create one by taking the template declaration name and adding the type signature for it.</source>
          <target state="translated">这个实例需要一个标识符,以便于名称混杂。通过取模板声明名并为其添加类型签名来创建一个。</target>
        </trans-unit>
        <trans-unit id="912f09d79c05dc09ba32bc17497f7cccd43f92de" translate="yes" xml:space="preserve">
          <source>This is a D version 2 compiler</source>
          <target state="translated">这是一个D版2的编译器</target>
        </trans-unit>
        <trans-unit id="e5c32108063ea48a95f2ccade44899e02af1ccaa" translate="yes" xml:space="preserve">
          <source>This is a best-effort implementation of &lt;code&gt;length&lt;/code&gt; for any kind of range.</source>
          <target state="translated">对于任何类型的范围，这都是尽力而为的 &lt;code&gt;length&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="05c823d62e8c286f879871b1e12c6f9007211866" translate="yes" xml:space="preserve">
          <source>This is a compiler magic function - it doesn't behave like regular D functions.</source>
          <target state="translated">这是一个编译器魔法函数--它的行为不像普通的D函数。</target>
        </trans-unit>
        <trans-unit id="b09964b15b26c39a9ce61274e2f775777d6323e9" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC32 implementation.</source>
          <target state="translated">这是使用CRC32实现的&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt;的方便别名。</target>
        </trans-unit>
        <trans-unit id="512068cf15e63810e132140770d7648100089a8e" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ECMA implementation.</source>
          <target state="translated">这是一个方便的别名&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt;使用CRC64-ECMA实现。</target>
        </trans-unit>
        <trans-unit id="b3d4ec4ec88de63e322958e6b0d979a689b11d53" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the MD5 implementation.</source>
          <target state="translated">这是使用MD5实现的&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt;的方便别名。</target>
        </trans-unit>
        <trans-unit id="bd636dcefd273f520355be9a0afa2783ad66dbef" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest&lt;/code&gt;&lt;/a&gt; using the RIPEMD160 implementation.</source>
          <target state="translated">这是一个方便的别名&lt;a href=&quot;std_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest&lt;/code&gt; &lt;/a&gt;使用RIPEMD160实现。</target>
        </trans-unit>
        <trans-unit id="29b73ef07a42490f2884582abd8be259990a85c2" translate="yes" xml:space="preserve">
          <source>This is a convenience alias for &lt;a href=&quot;std_digest_digest#digest&quot;&gt;&lt;code&gt;std.digest.digest.digest&lt;/code&gt;&lt;/a&gt; using the CRC64-ISO implementation.</source>
          <target state="translated">这是一个方便的别名&lt;a href=&quot;std_digest_digest#digest&quot;&gt; &lt;code&gt;std.digest.digest.digest&lt;/code&gt; &lt;/a&gt;使用CRC64-ISO实现。</target>
        </trans-unit>
        <trans-unit id="69463742eb10b8885c85b63b60e71b70ccfdbb6a" translate="yes" xml:space="preserve">
          <source>This is a convenience function similar to &lt;a href=&quot;#digest&quot;&gt;&lt;code&gt;digest&lt;/code&gt;&lt;/a&gt;, but it returns the string representation of the hash. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="translated">这是一个类似于&lt;a href=&quot;#digest&quot;&gt; &lt;code&gt;digest&lt;/code&gt; &lt;/a&gt;的便利函数，但是它返回哈希的字符串表示形式。每个通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;测试的摘要都可以与此功能一起使用。</target>
        </trans-unit>
        <trans-unit id="d797c320e5f08f4ede0b091329f09c40bcd4c23b" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate a hash using the template API. Every digest passing the &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt; test can be used with this function.</source>
          <target state="translated">这是使用模板API计算哈希值的便捷功能。每个通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; &lt;/a&gt;测试的摘要都可以与此功能一起使用。</target>
        </trans-unit>
        <trans-unit id="c5b7feb30ef91eb966259d553831f946792e76d5" translate="yes" xml:space="preserve">
          <source>This is a convenience function to calculate the hash of a value using the OOP API.</source>
          <target state="translated">这是一个使用OOP API计算一个值的哈希值的方便函数。</target>
        </trans-unit>
        <trans-unit id="3fbe8b98c7fb42d7985a89e6cebbca4b22e50702" translate="yes" xml:space="preserve">
          <source>This is a convenience function which returns an initialized digest, so it's not necessary to call start manually.</source>
          <target state="translated">这是一个方便的函数,它返回一个初始化的摘要,所以没有必要手动调用start。</target>
        </trans-unit>
        <trans-unit id="b07fdbfd8e90c114315c0c22212b8f6590899cf6" translate="yes" xml:space="preserve">
          <source>This is a dmd specific setting.</source>
          <target state="translated">这是一个dmd特定的设置。</target>
        </trans-unit>
        <trans-unit id="87a04bae60dfddd5f321bbf38e370a4d6f98d8c6" translate="yes" xml:space="preserve">
          <source>This is a full list of Unicode properties accessible through &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; with specific helpers per category nested within. Consult the &lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;CLDR utility&lt;/a&gt; when in doubt about the contents of a particular set.</source>
          <target state="translated">这是Unicode属性的完整列表，可通过&lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt;访问，其中嵌套了每个类别的特定帮助器。如果对特定集合的内容有疑问，请咨询&lt;a href=&quot;http://www.unicode.org/cldr/utility/properties.jsp&quot;&gt;CLDR实用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c8f19a42bba7727a8ce8284636a08320c4e65f1" translate="yes" xml:space="preserve">
          <source>This is a general replacement tool that construct a new string by replacing matches of pattern &lt;code&gt;re&lt;/code&gt; in the &lt;code&gt;input&lt;/code&gt;. Unlike the other overload there is no format string instead captures are passed to to a user-defined functor &lt;code&gt;fun&lt;/code&gt; that returns a new string to use as replacement.</source>
          <target state="translated">这是一般的替换刀具通过取代模式的匹配构造一个新的字符串 &lt;code&gt;re&lt;/code&gt; 在 &lt;code&gt;input&lt;/code&gt; 。与其他重载不同，没有格式字符串，而是将捕获内容传递到用户定义的functor &lt;code&gt;fun&lt;/code&gt; ，该functor 返回一个新字符串以用作替换。</target>
        </trans-unit>
        <trans-unit id="48a52f467fdd89c347f6d4a8f50f81ff656d5562" translate="yes" xml:space="preserve">
          <source>This is a great way to implement simple circular buffers.</source>
          <target state="translated">这是实现简单循环缓冲的好方法。</target>
        </trans-unit>
        <trans-unit id="02adbf08da9a4c46841118c88fd0ba75eb2c489f" translate="yes" xml:space="preserve">
          <source>This is a less strict parser compared to the parser used in the UUID constructor. It enforces the following rules:</source>
          <target state="translated">与UUID构造函数中使用的解析器相比,这是一个不太严格的解析器。它执行以下规则。</target>
        </trans-unit>
        <trans-unit id="ecac55bd6998bb669ca8527fad92e747f31aecf4" translate="yes" xml:space="preserve">
          <source>This is a low-level messaging API upon which more structured or restrictive APIs may be built. The general idea is that every messageable entity is represented by a common handle type called a Tid, which allows messages to be sent to logical threads that are executing in both the current process and in external processes using the same interface. This is an important aspect of scalability because it allows the components of a program to be spread across available resources with few to no changes to the actual implementation.</source>
          <target state="translated">这是一个低级的消息传递API,可以在此基础上建立更多结构化或限制性的API。一般的想法是,每个可消息实体都由一个称为Tid的通用句柄类型来表示,它允许将消息发送到使用相同接口在当前进程和外部进程中执行的逻辑线程。这是可扩展性的一个重要方面,因为它允许程序的组件分布在可用的资源上,而对实际实现几乎不做任何改变。</target>
        </trans-unit>
        <trans-unit id="c99b5a617247c271e1cb66e28acf2ff8127a04e2" translate="yes" xml:space="preserve">
          <source>This is a magic return code for the write callback that, when returned, will signal libcurl to pause receiving on the current transfer.</source>
          <target state="translated">这是写回调的一个神奇的返回码,返回后,会给libcurl发出信号,让它暂停接收当前的传输。</target>
        </trans-unit>
        <trans-unit id="8a547f3bc057670af878d63b618663f30d9c888a" translate="yes" xml:space="preserve">
          <source>This is a number that uniquely identifies the process on the operating system, for at least as long as the process is running. Once &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; has been called on the &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt;, this method will return an invalid (negative) process ID.</source>
          <target state="translated">这是一个数字，至少在进程运行期间，它唯一地标识操作系统上的进程。一旦在&lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt;上调用了&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;，此方法将返回一个无效的（负）进程ID。</target>
        </trans-unit>
        <trans-unit id="2ba143cb17d230b35dd3e77b4d46b42bf59cd667" translate="yes" xml:space="preserve">
          <source>This is a port of &lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt; boost.uuid&lt;/a&gt; from the Boost project with some minor additions and API changes for a more D-like API.</source>
          <target state="translated">这是Boost项目中的&lt;a href=&quot;http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html&quot;&gt;boost.uuid&lt;/a&gt;端口，其中进行了一些小的添加，并对API进行了更改，以实现更像D的API。</target>
        </trans-unit>
        <trans-unit id="3639c2b895158186c93cfc3d4a942fd3a8a4bcfc" translate="yes" xml:space="preserve">
          <source>This is a public domain version of qsort.d. All it does is call C's qsort().</source>
          <target state="translated">这是qsort.d的公有领域版本,它所做的只是调用C的qsort()。</target>
        </trans-unit>
        <trans-unit id="2506c523fc3fb4d236735f105644ec414dfd3b6c" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will const signal libcurl to pause sending data on the current transfer.</source>
          <target state="translated">这是读取回调的返回代码,返回后,将 const 信号 libcurl 暂停发送当前传输的数据。</target>
        </trans-unit>
        <trans-unit id="a5f3cb2b8bae68d0d790adf6bf0c62982e12ad3f" translate="yes" xml:space="preserve">
          <source>This is a return code for the read callback that, when returned, will signal libcurl to immediately abort the current transfer.</source>
          <target state="translated">这是读取回调的返回代码,返回后,将向libcurl发出信号,立即中止当前的传输。</target>
        </trans-unit>
        <trans-unit id="0df6a7dff27cb6ce3775bea09f58211a06e0fa4d" translate="yes" xml:space="preserve">
          <source>This is a shell around a back end symbol</source>
          <target state="translated">这是一个围绕后端符号的外壳</target>
        </trans-unit>
        <trans-unit id="dc048af9db69350bf7d515c9bc813c09c6660d30" translate="yes" xml:space="preserve">
          <source>This is a shell containing a TraitsExp that can be either resolved to a type or to a symbol.</source>
          <target state="translated">这是一个包含TraitsExp的shell,它可以被解析为一个类型或一个符号。</target>
        </trans-unit>
        <trans-unit id="5ad2832faed57297a9408dcd8abe79e66f2c28ae" translate="yes" xml:space="preserve">
          <source>This is a simplified declaration of the &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt;&lt;code&gt;NSString&lt;/code&gt;&lt;/a&gt; class. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt; method allocates an instance of the class. The &lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt;&lt;code&gt;initWithUTF8String:&lt;/code&gt;&lt;/a&gt; method will be used to convert a C string in UTF-8 to an Objective-C string, &lt;code&gt;NSString&lt;/code&gt;. The &lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; method is used to release an deallocate the string. Since D doesn't support &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt; it's needed to manually release Objective-C instances.</source>
          <target state="translated">这是&lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring?language=objc&quot;&gt; &lt;code&gt;NSString&lt;/code&gt; &lt;/a&gt;类的简化声明。该&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc?language=objc&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt;方法分配的类的一个实例。该&lt;a href=&quot;https://developer.apple.com/documentation/foundation/nsstring/1412128-initwithutf8string?language=objc&quot;&gt; &lt;code&gt;initWithUTF8String:&lt;/code&gt; &lt;/a&gt;方法将用于C字符串以UTF-8转换为一个Objective-C串， &lt;code&gt;NSString&lt;/code&gt; 。该&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1418956-nsobject/1571957-release?language=objc&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt;方法用于释放DEALLOCATE的字符串。由于D不支持&lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC，&lt;/a&gt;因此需要手动释放Objective-C实例。</target>
        </trans-unit>
        <trans-unit id="fad6a93ca5b80ae2dfec457b0ce1d7b04f69cf3b" translate="yes" xml:space="preserve">
          <source>This is a special compiler recognized attribute, it has a few requirements, which all will be enforced by the compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b885a66018a314237093b8fb5cb095cdbb3b8c2" translate="yes" xml:space="preserve">
          <source>This is a special compiler recognized attribute, it has several requirements, which all will be enforced by the compiler:</source>
          <target state="translated">这是一个特殊的编译器认可的属性,它有几个要求,都会被编译器执行。</target>
        </trans-unit>
        <trans-unit id="ae39fd6f553ae7cbf7dc06cf4c01bdb3470af4ef" translate="yes" xml:space="preserve">
          <source>This is a speed optimization, a good guess at the maximum size of the resulting buffer will improve performance by eliminating reallocations and copying.</source>
          <target state="translated">这是一种速度优化,猜测好结果缓冲区的最大大小,可以通过消除重分配和复制来提高性能。</target>
        </trans-unit>
        <trans-unit id="35d1d3de86a677e769796c4bc667e5033e36cade" translate="yes" xml:space="preserve">
          <source>This is a strict parser. It only accepts the pattern above. It doesn't support any leading or trailing characters. It only accepts characters used for hex numbers and the string must have hyphens exactly like above.</source>
          <target state="translated">这是一个严格的解析器。它只接受上述模式。它不支持任何前导符或尾部字符。它只接受用于十六进制数字的字符,并且字符串必须有与上面完全相同的连字符。</target>
        </trans-unit>
        <trans-unit id="5ae5fdcefc9284313dd41ba3b8a3e36e9a73a45c" translate="yes" xml:space="preserve">
          <source>This is a subclass of ElementParser. Most of the useful functions are documented there.</source>
          <target state="translated">这是 ElementParser 的一个子类。大多数有用的功能都在这里被记录下来。</target>
        </trans-unit>
        <trans-unit id="f2e662785d1d5993dfe200ed0cd32d243953366c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic algorithms that implement set operations.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含实现集合操作的通用算法。</target>
        </trans-unit>
        <trans-unit id="e1b41f495bf4c79d2ddcbf0100179c8d893eed73" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic comparison algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用比较算法。</target>
        </trans-unit>
        <trans-unit id="7b5ed9bdf36ce4d3eb2f4fa31e710341bfe1a347" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic iteration algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用迭代算法。</target>
        </trans-unit>
        <trans-unit id="a1ca49a48babc2bf7a88dc2f9edada29da0b74aa" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic mutation algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用的变异算法。</target>
        </trans-unit>
        <trans-unit id="9256c3179b28cb98f2ccafcbf01fa1114c7ffabd" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic searching algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用搜索算法。</target>
        </trans-unit>
        <trans-unit id="d621cd2fb3907321fd3307426e0197b19ae1cd6c" translate="yes" xml:space="preserve">
          <source>This is a submodule of &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;. It contains generic sorting algorithms.</source>
          <target state="translated">这是&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;的子模块。它包含通用的排序算法。</target>
        </trans-unit>
        <trans-unit id="1a6a835a510bef24f9a4d09ad766e6b4789c5a10" translate="yes" xml:space="preserve">
          <source>This is accessible via the ClassData, but since it is frequently needed directly (like for rtti comparisons), make it directly accessible.</source>
          <target state="translated">这个是可以通过ClassData访问的,但由于经常直接需要(比如rtti比较),所以要让它直接访问。</target>
        </trans-unit>
        <trans-unit id="7c814acc56ca032045c3a40a509dc625dc91c4d4" translate="yes" xml:space="preserve">
          <source>This is actually what &lt;a href=&quot;#byLine&quot;&gt;&lt;code&gt;byLine&lt;/code&gt;&lt;/a&gt; does internally, so its usage is recommended if you want to process a complete file.</source>
          <target state="translated">这实际上是&lt;a href=&quot;#byLine&quot;&gt; &lt;code&gt;byLine&lt;/code&gt; &lt;/a&gt;在内部执行的操作，因此，如果要处理完整的文件，建议使用它。</target>
        </trans-unit>
        <trans-unit id="90cce6858fc6a3ac3c07d99643429177baeef347" translate="yes" xml:space="preserve">
          <source>This is also known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e213b7894a106692ed41475e921810e2f2ef96" translate="yes" xml:space="preserve">
          <source>This is an</source>
          <target state="translated">这是一个</target>
        </trans-unit>
        <trans-unit id="d562af56401d0e00dc584df85564d362806b263a" translate="yes" xml:space="preserve">
          <source>This is an advanced type manipulation necessary e.g. for replacing the placeholder type &lt;code&gt;This&lt;/code&gt; in &lt;a href=&quot;std_variant#Algebraic&quot;&gt;&lt;code&gt;std.variant.Algebraic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是一种先进的类型的操作需要例如用于替换占位符类型 &lt;code&gt;This&lt;/code&gt; 在&lt;a href=&quot;std_variant#Algebraic&quot;&gt; &lt;code&gt;std.variant.Algebraic&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3325f1bf2305c77a1849c9f8a9c2843663095726" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!CRC32&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="991e65c6e6968487ccb7bb69ca7320b94e4ca93f" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!MD5&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="b4ce5ff6ecd05c751170313d80d40096c853a878" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!RIPEMD160&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="d9558990a88eaad4533f53210d24e334b473686d" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest#WrapperDigest&quot;&gt;std.digest.WrapperDigest&lt;/a&gt;!SHA1&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="57c783fecd68424a831ee827a2afa820a6eb2e72" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ECMA&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="c0181596da443b5ba169ba47d5e2dd20f026611e" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt;, see there for more information.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;std_digest_digest#WrapperDigest&quot;&gt;std.digest.digest.WrapperDigest&lt;/a&gt;!CRC64ISO&lt;/code&gt; 的别名，有关更多信息，请参见此处。</target>
        </trans-unit>
        <trans-unit id="7d3c5e22d15f79f627e001b482acc6838518ff93" translate="yes" xml:space="preserve">
          <source>This is an example Scheduler that mirrors the default scheduling behavior of creating one kernel thread per call to spawn. It is fully functional and may be instantiated and used, but is not a necessary part of the default functioning of this module.</source>
          <target state="translated">这是一个Scheduler的例子,它反映了默认的调度行为,即每次调用 spawn时创建一个内核线程。它功能齐全,可以被实例化和使用,但不是这个模块默认功能的必要部分。</target>
        </trans-unit>
        <trans-unit id="6ff549d63c3ff212a46a7da946a73dffb4f080d9" translate="yes" xml:space="preserve">
          <source>This is an example scheduler that creates a new Fiber per call to spawn and multiplexes the execution of all fibers within the main thread.</source>
          <target state="translated">这是一个调度器的例子,每次调用 spawn 都会创建一个新的光纤,并在主线程内复用执行所有光纤。</target>
        </trans-unit>
        <trans-unit id="9b07c47f7921db818ae08b3487fd61d30861252d" translate="yes" xml:space="preserve">
          <source>This is an infinite range, so it is never empty.</source>
          <target state="translated">这是一个无限的范围,所以它永远不会空。</target>
        </trans-unit>
        <trans-unit id="12f3a1e35d9244804e6a51ca5a2db8f208c379f7" translate="yes" xml:space="preserve">
          <source>This is an interface to the libcurl library.</source>
          <target state="translated">这是对libcurl库的一个接口。</target>
        </trans-unit>
        <trans-unit id="0ecf41c17b4ddd40e8365245329f080912127dd4" translate="yes" xml:space="preserve">
          <source>This is an overload of &lt;code&gt;translate&lt;/code&gt; which takes an existing buffer to write the contents to.</source>
          <target state="translated">这是 &lt;code&gt;translate&lt;/code&gt; 的重载，它需要一个现有的缓冲区将内容写入其中。</target>
        </trans-unit>
        <trans-unit id="1ecb65db27289cae51fc17448747e90751d9751d" translate="yes" xml:space="preserve">
          <source>This is by design. During construction the &lt;code&gt;Variant&lt;/code&gt; needs static type information about the type being held, so as to store a pointer to function for fast retrieval.</source>
          <target state="translated">这是设计使然。在构造期间， &lt;code&gt;Variant&lt;/code&gt; 需要有关所保存类型的静态类型信息，以便存储指向函数的指针以进行快速检索。</target>
        </trans-unit>
        <trans-unit id="60ab54d413619310ad332327e4504502f2306f23" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.compare(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="translated">这被TypeInfo.compare(p1,p2)调用。如果该结构不支持const对象比较,它将在运行时抛出 &quot;not implemented &quot;错误。</target>
        </trans-unit>
        <trans-unit id="c89ac618e64974e5137c2fd8360adb505768057f" translate="yes" xml:space="preserve">
          <source>This is called by TypeInfo.equals(p1, p2). If the struct does not support const objects comparison, it will throw &quot;not implemented&quot; Error in runtime.</source>
          <target state="translated">这被TypeInfo.equals(p1,p2)调用。如果该结构不支持const对象比较,它将在运行时抛出 &quot;not implemented &quot;错误。</target>
        </trans-unit>
        <trans-unit id="165808d159b6f286bb50d6195dc7d22725a89812" translate="yes" xml:space="preserve">
          <source>This is called for a delete statement where the value being deleted is a pointer to a struct with a destructor but doesn't have an overloaded delete operator.</source>
          <target state="translated">当被删除的值是一个指向有析构器的结构的指针,但没有重载删除操作符时,就会调用这个语句。</target>
        </trans-unit>
        <trans-unit id="15901451d4d385b73b656d146d0381611e4eadbc" translate="yes" xml:space="preserve">
          <source>This is collectively called an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a5f292f669550cd589beb4131f8032cf765ed1" translate="yes" xml:space="preserve">
          <source>This is defined to be in exactly the reverse order of static construction. Static destructors for individual modules will only be run if the corresponding static constructor successfully completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252a57647acdf0a645523b6daf74e75444387572" translate="yes" xml:space="preserve">
          <source>This is designed for efficient memory reuse with some value-semantics structs, eg. &lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt;&lt;code&gt;std.bigint.BigInt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是为具有某些价值语义结构（例如）的有效内存重用而设计的。&lt;a href=&quot;https://dlang.org/phobos/std_bigint.html#BigInt&quot;&gt; &lt;code&gt;std.bigint.BigInt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06ae0b36fee3b8fd0ea0e39cba211a57066e0aad" translate="yes" xml:space="preserve">
          <source>This is done by matching the C compiler's data types, layouts, and function call/return sequences.</source>
          <target state="translated">这是通过匹配C编译器的数据类型、布局和函数调用/返回序列来实现的。</target>
        </trans-unit>
        <trans-unit id="11029a896ea23a30143fb56e21fe3c178f1a4a41" translate="yes" xml:space="preserve">
          <source>This is especially useful for adding/removing attributes to/from types in generic code, where the actual type name cannot be spelt out.</source>
          <target state="translated">这对于在通用代码中添加/删除属性到/从类型中添加/删除属性特别有用,因为实际的类型名称无法拼写出来。</target>
        </trans-unit>
        <trans-unit id="b13063fd35605a68f66f22b807caf15b21927ce2" translate="yes" xml:space="preserve">
          <source>This is especially useful when used with inheritance. For example, you might want to implement a final base method which returns a derived class type. Typically you would return a base type, but this won't allow you to call or access derived properties of the type:</source>
          <target state="translated">这在与继承一起使用时特别有用。例如,你可能想实现一个返回派生类类型的final base方法。通常情况下,你会返回一个基类型,但这将不允许你调用或访问该类型的派生属性。</target>
        </trans-unit>
        <trans-unit id="33a5219de6733b72248cb459ae3c108de0b27b6d" translate="yes" xml:space="preserve">
          <source>This is for cases where you need a value representing the OS at runtime. If you're doing something which should compile differently on different OSes, then please use &lt;code&gt;version (Windows)&lt;/code&gt;, &lt;code&gt;version (linux)&lt;/code&gt;, etc.</source>
          <target state="translated">这是在需要运行时表示操作系统的值的情况下使用的。如果您要执行的操作应在不同的操作系统上进行不同的编译，请使用 &lt;code&gt;version (Windows)&lt;/code&gt; ， &lt;code&gt;version (linux)&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="9085623d5748a41a60ced02ac9ea7374a5eb5654" translate="yes" xml:space="preserve">
          <source>This is generally fine, and by its very nature, converting from system ticks to any type of seconds (hnsecs, nsecs, etc.) will introduce rounding errors, but if code needs to avoid any of the small rounding errors introduced by conversion, then it needs to use MonoTime's &lt;code&gt;ticks&lt;/code&gt; property and keep all calculations in ticks rather than using &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常这很好，就其本质而言，从系统刻度转换为任何类型的秒数（hnsecs，nsecs等）都会引入舍入错误，但是如果代码需要避免转换引起的任何小舍入错误，则它需要使用MonoTime的 &lt;code&gt;ticks&lt;/code&gt; 属性并将所有计算保持在ticks中，而不是使用&lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88fe60e9205a837e1c893e74b0d472fd048224ed" translate="yes" xml:space="preserve">
          <source>This is generally the fastest method to convert a floating-point number to an integer. Note that the results from this function depend on the rounding mode, if the fractional part of x is exactly 0.5. If using the default rounding mode (ties round to even integers) lrint(4.5) == 4, lrint(5.5)==6.</source>
          <target state="translated">这通常是将浮点数转换为整数的最快方法。注意,这个函数的结果取决于四舍五入模式,如果x的小数部分正好是0.5。如果使用默认的四舍五入模式(四舍五入为偶数),则lrint(4.5)==4,lrint(5.5)==6。</target>
        </trans-unit>
        <trans-unit id="f53ca66b2923ca36935e7ce2bb35685de87690d9" translate="yes" xml:space="preserve">
          <source>This is intended for cases where you need to deal with endianness at runtime. If you're doing something which should compile differently depending on whether you're compiling on a big endian or little endian machine, then please use &lt;code&gt;version (BigEndian)&lt;/code&gt; and &lt;code&gt;version (LittleEndian)&lt;/code&gt;.</source>
          <target state="translated">这适用于需要在运行时处理字节序的情况。如果您要执行的操作根据在大端或小端机器上进行编译而不同，请使用 &lt;code&gt;version (BigEndian)&lt;/code&gt; 和 &lt;code&gt;version (LittleEndian)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b3b92fb9499542d848207397387795d022c0de6" translate="yes" xml:space="preserve">
          <source>This is intended to be called at the start of the program to yield all scheduling to the active Scheduler instance. This is necessary for schedulers that explicitly dispatch threads rather than simply relying on the operating system to do so, and so start should always be called within main() to begin normal program execution.</source>
          <target state="translated">这个函数的目的是在程序开始时被调用,以便将所有的调度工作交给活动的Scheduler实例。这对于显式调度线程的调度器来说是必要的,而不是简单地依靠操作系统来调度线程,因此start应该总是在main()中被调用,以开始正常的程序执行。</target>
        </trans-unit>
        <trans-unit id="168edfe34c09b55f1deed4c37990e3c71a1ca3c1" translate="yes" xml:space="preserve">
          <source>This is more efficient than testing each bit in a sparsely populated bit set. Note that the first bit in the bit set would be bit 0.</source>
          <target state="translated">这比测试一个人口稀少的位集中的每个位更有效率。注意,位集中的第一个位将是位0。</target>
        </trans-unit>
        <trans-unit id="8fcde002524d5c331c8548b6dca27a95656e7bce" translate="yes" xml:space="preserve">
          <source>This is most handy when the array indices are given by enums:</source>
          <target state="translated">当数组索引是由枚举给出时,这是最方便的。</target>
        </trans-unit>
        <trans-unit id="c31ac80c96aa26f46ec6ee9192e9e74924da45e0" translate="yes" xml:space="preserve">
          <source>This is needed because AssignExp rewrites CommaExp, hence it needs to trigger the deprecation.</source>
          <target state="translated">这是因为AssignExp重写了CommaExp,因此需要触发弃用。</target>
        </trans-unit>
        <trans-unit id="e7738cc186f07169467da57ea636fc910ff8ff41" translate="yes" xml:space="preserve">
          <source>This is not recursive; it will not search for symbols within symbols such as nested structs or unions.</source>
          <target state="translated">这不是递归的,它不会在符号中搜索符号,如嵌套结构或联合。</target>
        </trans-unit>
        <trans-unit id="79018f9004b6204ff482d1449a187f60021b161a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;takeWhile&lt;/code&gt; in other languages.</source>
          <target state="translated">这与其他语言中的 &lt;code&gt;takeWhile&lt;/code&gt; 类似。</target>
        </trans-unit>
        <trans-unit id="da1506be46b53535dcad92fb4d88063b66606cfa" translate="yes" xml:space="preserve">
          <source>This is so we can slice a TypeTuple</source>
          <target state="translated">这样,我们就可以将一个TypeTuple分片</target>
        </trans-unit>
        <trans-unit id="1ea183190e1a8d4a5c65894e3d7aa69b999c8015" translate="yes" xml:space="preserve">
          <source>This is the D way, and is used consistently in the D runtime library and examples.</source>
          <target state="translated">这是D的方式,在D的运行库和例子中是一致使用的。</target>
        </trans-unit>
        <trans-unit id="b87f9cb349c407cc69c74e007c81d9397e42baeb" translate="yes" xml:space="preserve">
          <source>This is the FILE * or void * the regular output should be written to.</source>
          <target state="translated">这是常规输出应该写入的FILE *或void *。</target>
        </trans-unit>
        <trans-unit id="e03f57cd49f977fe295ada31586860acb7b55e0d" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the socket callback</source>
          <target state="translated">这是传递给套接字回调的参数。</target>
        </trans-unit>
        <trans-unit id="be469fab3c85ca74b768977fadfadf33a82814bf" translate="yes" xml:space="preserve">
          <source>This is the argument passed to the timer callback</source>
          <target state="translated">这是传递给定时器回调的参数。</target>
        </trans-unit>
        <trans-unit id="47d1ba0ce023e632a01bb533e80836298674478a" translate="yes" xml:space="preserve">
          <source>This is the date and time when the full source package was created. The timestamp is not stored in git, as the timestamp is properly set in the tarballs by the maketgz script.</source>
          <target state="translated">这是创建完整源代码包的日期和时间。时间戳不会存储在 git 中,因为时间戳是由 maketgz 脚本在 tarballs 中正确设置的。</target>
        </trans-unit>
        <trans-unit id="bcb4b4d07cd24ad03f4d73cf2a834d60bf057434" translate="yes" xml:space="preserve">
          <source>This is the global package copyright</source>
          <target state="translated">这就是全球包装的版权</target>
        </trans-unit>
        <trans-unit id="00bd1884cd8f1f3700cdc8b2d576c08ba85d63de" translate="yes" xml:space="preserve">
          <source>This is the length in bytes of the hash value which is returned by &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;. It's also the required size of a buffer passed to &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是由&lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt;返回的哈希值的字节长度。这也是传递给&lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt;所需的缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="629c1787bf8dac085ebe6f000afbc79766608202" translate="yes" xml:space="preserve">
          <source>This is the most specific allocation policy: the memory being allocated is thread local, has no indirections at all, and will not be reallocated. Examples of types fitting this description: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">这是最具体的分配策略：分配的内存是线程本地的，根本没有间接寻址，也不会重新分配。适合此描述的类型的示例： &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;Tuple!(int, long)&lt;/code&gt; ，但不包含包含间接 &lt;code&gt;Tuple!(int, string)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d53bdfa25144b5efcd12699a648c0b943568037" translate="yes" xml:space="preserve">
          <source>This is the numeric version of the libcurl version number, meant for easier parsing and comparions by programs. The LIBCURL_VERSION_NUM define will always follow this syntax:</source>
          <target state="translated">这是libcurl版本号的数字版本,目的是为了方便程序的解析和比较。LIBCURL_VERSION_NUM定义将始终遵循这个语法。</target>
        </trans-unit>
        <trans-unit id="f516424ebe0c21d1c77be3938d4dc4c573211582" translate="yes" xml:space="preserve">
          <source>This is the old ctor sorting algorithm that does not find all cycles.</source>
          <target state="translated">这是老式的ctor排序算法,不能找到所有的循环。</target>
        </trans-unit>
        <trans-unit id="0b9ca6f8eacc1a78a90edd54d83160d4086f02d3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;getTimes&lt;/code&gt; except that it also gives you the file creation time - which isn't possible on POSIX systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e92c9060948634b2691b12a3f666bd6c1016991" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;getTimes&lt;/code&gt; except that it also gives you the file creation time - which isn't possible on Posix systems.</source>
          <target state="translated">这与 &lt;code&gt;getTimes&lt;/code&gt; 相同，除了它还为您提供文件创建时间-这在Posix系统上是不可能的。</target>
        </trans-unit>
        <trans-unit id="d8bc2540cd8cdfdea3a8a5b982374faccf0dd6c1" translate="yes" xml:space="preserve">
          <source>This is the socket callback function pointer</source>
          <target state="translated">这是套接字回调函数的指针。</target>
        </trans-unit>
        <trans-unit id="61598e1f6a7ec5d30e11d3aead7284998d0c4762" translate="yes" xml:space="preserve">
          <source>This is the timer callback function pointer</source>
          <target state="translated">这是定时器的回调函数指针。</target>
        </trans-unit>
        <trans-unit id="c718912a86bcbf8011f76f57098fa90f1498a69a" translate="yes" xml:space="preserve">
          <source>This is the version number of the libcurl package from which this header file origins:</source>
          <target state="translated">这是libcurl包的版本号,这个头文件来源于此。</target>
        </trans-unit>
        <trans-unit id="a98c5dbd73e5200bae0821dc0199531a02a94575" translate="yes" xml:space="preserve">
          <source>This is to support compiling expressions within the context of a function.</source>
          <target state="translated">这是为了支持在函数的上下文中编译表达式。</target>
        </trans-unit>
        <trans-unit id="1f258032a2e34908ad83c367bba4f67f9bf0d8fc" translate="yes" xml:space="preserve">
          <source>This is true even if the</source>
          <target state="translated">即使在</target>
        </trans-unit>
        <trans-unit id="915f3d07336b61352341e4f59f1cdec1c322cabb" translate="yes" xml:space="preserve">
          <source>This is useful for:</source>
          <target state="translated">这对于:</target>
        </trans-unit>
        <trans-unit id="fcc8360025ee8f837157968edcf3a60c6d678ceb" translate="yes" xml:space="preserve">
          <source>This is useful in cases where the user is expected to type in one of a known set of strings, and the program will helpfully auto-complete the string once sufficient characters have been entered that uniquely identify it.</source>
          <target state="translated">当用户需要输入一组已知的字符串时,这很有用,一旦输入了足够的字符,程序就会帮助用户自动完成该字符串,以唯一地识别它。</target>
        </trans-unit>
        <trans-unit id="e4e34d37acfaa90ff5c5cdca9c0444e2392c7b7c" translate="yes" xml:space="preserve">
          <source>This is useful when dealing with memory-mapped I/O (MMIO) where a store can have an effect other than just writing a value, or where sequential loads with no intervening stores can retrieve different values from the same location due to external stores to the location.</source>
          <target state="translated">这在处理内存映射I/O(MMIO)时很有用,在这种情况下,一个存储除了写一个值之外,还可以产生其他的效果,或者在没有中间存储的顺序加载时,由于外部存储到该位置,可以从同一位置检索不同的值。</target>
        </trans-unit>
        <trans-unit id="130a13f443489357f62d68edb3556823f7774c09" translate="yes" xml:space="preserve">
          <source>This is usually the default diagnostic reporter.</source>
          <target state="translated">这通常是默认的诊断报告器。</target>
        </trans-unit>
        <trans-unit id="6b8bd52c73d65472e04e60bf842e33bc426a473d" translate="yes" xml:space="preserve">
          <source>This is very useful as a template constraint (see examples)</source>
          <target state="translated">这作为模板约束是非常有用的(见示例)</target>
        </trans-unit>
        <trans-unit id="c9c38689ba29d74fc53f435aaf473866b312b836" translate="yes" xml:space="preserve">
          <source>This is, however, NOT equivalent to POSIX' &lt;code&gt;execv*&lt;/code&gt;. For one thing, the executed program is started as a separate process, with all this entails. Secondly, in a multithreaded program, other threads will continue to do work while the current thread is waiting for the child process to complete.  A better option may sometimes be to terminate the current program immediately after spawning the child process. This is the behaviour exhibited by the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt;&lt;code&gt;__exec&lt;/code&gt;&lt;/a&gt; functions in Microsoft's C runtime library, and it is how D's now-deprecated Windows &lt;code&gt;execv*&lt;/code&gt; functions work. Example:</source>
          <target state="translated">但是，这不等同于POSIX的 &lt;code&gt;execv*&lt;/code&gt; 。一方面，执行的程序是作为一个单独的过程启动的，因此需要这样做。其次，在多线程程序中，当当前线程正在等待子进程完成时，其他线程将继续工作。有时更好的选择可能是在生成子进程之后立即终止当前程序。这是Microsoft C运行时库中&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/431x4c1w.aspx&quot;&gt; &lt;code&gt;__exec&lt;/code&gt; &lt;/a&gt;函数所表现的行为，这也是D现在不推荐使用的Windows &lt;code&gt;execv*&lt;/code&gt; 函数的工作方式。例：</target>
        </trans-unit>
        <trans-unit id="86cd963d96c400e127b41fb5e1c683fd1645332a" translate="yes" xml:space="preserve">
          <source>This level is used to display information about the program.</source>
          <target state="translated">该级别用于显示有关程序的信息。</target>
        </trans-unit>
        <trans-unit id="7bd1213d23d1dea834726c3d604226e3f0bd7985" translate="yes" xml:space="preserve">
          <source>This library provides a mechanism whereby other modules may add &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for any other encoding.</source>
          <target state="translated">该库提供了一种机制，通过该机制，其他模块可以为任何其他编码添加&lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt;子类。</target>
        </trans-unit>
        <trans-unit id="a3c0ccf8cf8329e21b5b2e67a76439bedab69306" translate="yes" xml:space="preserve">
          <source>This library provides full Level 1 support* according to &lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18&lt;/a&gt;. Specifically:</source>
          <target state="translated">根据&lt;a href=&quot;http://unicode.org/reports/tr18/&quot;&gt;UTS 18，&lt;/a&gt;该库提供完整的1级支持* 。特别：</target>
        </trans-unit>
        <trans-unit id="4904626a5781bdaca7da93c6ed4103629917781b" translate="yes" xml:space="preserve">
          <source>This library supplies &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; subclasses for ASCII, ISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251, WINDOWS-1252, UTF-8, and (on little-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian architectures) UTF-16BE and UTF-32BE.</source>
          <target state="translated">该库为ASCII，ISO-8859-1（也称为LATIN-1），ISO-8859-2（LATIN-2），WINDOWS-1250，WINDOWS-1251，WINDOWS-1252，UTF-8和UTF-8 提供了&lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt;子类。 （在小端架构上）UTF-16LE和UTF-32LE；或（在大端架构上）UTF-16BE和UTF-32BE。</target>
        </trans-unit>
        <trans-unit id="2ab23006d99b3e64b2eb41b8a2440b3e86ff5b16" translate="yes" xml:space="preserve">
          <source>This library uses a remarkably common ECMAScript syntax flavor with the following extensions:</source>
          <target state="translated">这个库使用了一个非常常见的ECMAScript语法,并有以下扩展。</target>
        </trans-unit>
        <trans-unit id="1d7d527b40f488b0b076be50f2a630625a4b71d6" translate="yes" xml:space="preserve">
          <source>This library will supply your function with a new instance of ElementHandler, which may be used to parse inside the element whose start tag was just found, or to identify the tag attributes of the element, etc.  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; and &amp;lt;br/&amp;gt;.</source>
          <target state="translated">该库将为您的函数提供一个新的ElementHandler实例，该实例可用于解析刚刚找到其开始标签的元素内部，或者标识该元素的标签属性，等等。请注意，您的函数将同时被调用开始标签和空标签。也就是说，我们在&amp;lt;br&amp;gt; &amp;lt;/br&amp;gt;和&amp;lt;br/&amp;gt;之间没有区别。</target>
        </trans-unit>
        <trans-unit id="5bcb738af6294ebb159f7ef50c2f4ed098badaa1" translate="yes" xml:space="preserve">
          <source>This macro below was added in 7.16.3 to push users who recompile to use the new curl_multi_socket_action() instead of the old curl_multi_socket()</source>
          <target state="translated">下面这个宏是在7.16.3中添加的,目的是促使重新编译的用户使用新的curl_multi_socket_action()而不是旧的curl_multi_socket()</target>
        </trans-unit>
        <trans-unit id="05317d0fb9b73229e7a4b236f6860aa4bc992df1" translate="yes" xml:space="preserve">
          <source>This makes the intent clearer, because the first statement can easily be misread as the following code:</source>
          <target state="translated">这样一来,意图就更明确了,因为第一条语句很容易被误读成下面的代码。</target>
        </trans-unit>
        <trans-unit id="4d0a27a35faef1bf1f6ffad88638e7121e05700e" translate="yes" xml:space="preserve">
          <source>This means that pointers to elements of an &lt;code&gt;Array&lt;/code&gt; will become dangling as soon as the element is removed from the &lt;code&gt;Array&lt;/code&gt;. On the other hand the memory allocated by an &lt;code&gt;Array&lt;/code&gt; will be scanned by the GC and GC managed objects referenced from an &lt;code&gt;Array&lt;/code&gt; will be kept alive.</source>
          <target state="translated">这意味着一旦将元素从 &lt;code&gt;Array&lt;/code&gt; 中移除，指向 &lt;code&gt;Array&lt;/code&gt; 元素的指针就会悬空。另一方面，由 &lt;code&gt;Array&lt;/code&gt; 分配的内存将由GC扫描，并且从 &lt;code&gt;Array&lt;/code&gt; 引用的GC管理的对象将保持活动状态。</target>
        </trans-unit>
        <trans-unit id="604c9cc6344fc7f1b954e8b21d2a6ca0c3ac4133" translate="yes" xml:space="preserve">
          <source>This member holds all &lt;code&gt;Logger&lt;/code&gt;s stored in the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">该成员拥有存储在 &lt;code&gt;MultiLogger&lt;/code&gt; 中的所有 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2222d90d3dcd66aaa74b009940ed8d8638bced76" translate="yes" xml:space="preserve">
          <source>This memoizes all values of &lt;code&gt;fact&lt;/code&gt; up to the largest argument. To only cache the final result, move &lt;code&gt;memoize&lt;/code&gt; outside the function as shown below.</source>
          <target state="translated">这将记住 &lt;code&gt;fact&lt;/code&gt; 所有值，直到最大的论点为止。要仅缓存最终结果，请将 &lt;code&gt;memoize&lt;/code&gt; 移到函数外部，如下所示。</target>
        </trans-unit>
        <trans-unit id="3a167a300836fdd4ab2e0e008d931c833538789e" translate="yes" xml:space="preserve">
          <source>This method allows expansion within the respective bucket range. It succeeds if both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;b.length + delta&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;.</source>
          <target state="translated">这种方法允许在相应的铲斗范围内扩展。如果 &lt;code&gt;b.length&lt;/code&gt; 和 &lt;code&gt;b.length + delta&lt;/code&gt; 都落在 &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt; 形式的范围内，则成功。</target>
        </trans-unit>
        <trans-unit id="4461edb18d36faaf19bc846025f3b95c67801b6c" translate="yes" xml:space="preserve">
          <source>This method allows forwarding log entries from one logger to another.</source>
          <target state="translated">此方法允许将日志条目从一个记录仪转发到另一个记录仪。</target>
        </trans-unit>
        <trans-unit id="3816a6346828017f335a6081c798a8a0dd6de4dd" translate="yes" xml:space="preserve">
          <source>This method allows reallocation within the respective bucket range. If both &lt;code&gt;b.length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; fall in a range of the form &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt;, then reallocation is in place. Otherwise, reallocation with moving is attempted.</source>
          <target state="translated">此方法允许在各个存储段范围内重新分配。如果 &lt;code&gt;b.length&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 都在 &lt;code&gt;[min + k * step, min + (k + 1) * step - 1]&lt;/code&gt; 形式的范围内，则重新分配就位。否则，将尝试通过移动进行重新分配。</target>
        </trans-unit>
        <trans-unit id="b9a458cd0b30230c45418803529ca936bac85057" translate="yes" xml:space="preserve">
          <source>This method can be more efficient than the one in the previous example because &lt;code&gt;stdin.readln(buf)&lt;/code&gt; reuses (if possible) memory allocated for &lt;code&gt;buf&lt;/code&gt;, whereas &lt;code&gt;line = stdin.readln()&lt;/code&gt; makes a new memory allocation for every line.  For even better performance you can help &lt;code&gt;readln&lt;/code&gt; by passing in a large buffer to avoid memory reallocations. This can be done by reusing the largest buffer returned by &lt;code&gt;readln&lt;/code&gt;:</source>
          <target state="translated">此方法可能比上一个示例更有效，因为 &lt;code&gt;stdin.readln(buf)&lt;/code&gt; 会重用（如果可能）为 &lt;code&gt;buf&lt;/code&gt; 分配的内存，而 &lt;code&gt;line = stdin.readln()&lt;/code&gt; 会为每行进行新的内存分配。为了获得更好的性能，您可以通过传递一个大缓冲区来避免内存重新分配，从而帮助 &lt;code&gt;readln&lt;/code&gt; 。这可以通过重用 &lt;code&gt;readln&lt;/code&gt; 返回的最大缓冲区来完成：</target>
        </trans-unit>
        <trans-unit id="7f7c9ac03db99dc39088ab7814b92a020b0c3ad1" translate="yes" xml:space="preserve">
          <source>This method inserts a new Logger into the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">此方法将新的Logger插入 &lt;code&gt;MultiLogger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7e456631bd1026dc4c8384262111ee00c2ae6280" translate="yes" xml:space="preserve">
          <source>This method is defined if both allocators define it, and forwards to &lt;code&gt;SmallAllocator&lt;/code&gt; or &lt;code&gt;LargeAllocator&lt;/code&gt; appropriately.</source>
          <target state="translated">如果两个分配器都定义了此方法，则该方法将被适当地转发到 &lt;code&gt;SmallAllocator&lt;/code&gt; 或 &lt;code&gt;LargeAllocator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29c6c590b7cd5abdf60b16e55a89efa8f2694069" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it, and work similarly to &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">这种方法被定义仅当至少一个所述的分配器定义它的，并工作类似于 &lt;code&gt;reallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c403891dca13c06af654365809bbef8d64860536" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt;. If &lt;code&gt; LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt;LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">仅当至少一个分配器定义此方法时，才定义此方法。如果 &lt;code&gt;SmallAllocator&lt;/code&gt; 定义 &lt;code&gt;expand&lt;/code&gt; 并且 &lt;code&gt;b.length + delta &amp;lt;= threshold&lt;/code&gt; ，则将呼叫转发到 &lt;code&gt;SmallAllocator&lt;/code&gt; 。如果 &lt;code&gt; LargeAllocator&lt;/code&gt; 定义 &lt;code&gt;expand&lt;/code&gt; 并且 &lt;code&gt;b.length &amp;gt; threshold&lt;/code&gt; ，则将呼叫转发到 &lt;code&gt;LargeAllocator&lt;/code&gt; 。否则，调用返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc308051788a72be786da5419b09693d8595fa4d" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. If &lt;code&gt;SmallAllocator&lt;/code&gt; defines &lt;code&gt;reallocate&lt;/code&gt; and &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; SmallAllocator&lt;/code&gt;. If &lt;code&gt;LargeAllocator&lt;/code&gt; defines &lt;code&gt;expand&lt;/code&gt; and &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt;, the call is forwarded to &lt;code&gt; LargeAllocator&lt;/code&gt;. Otherwise, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">仅当至少一个分配器定义此方法时，才定义此方法。如果 &lt;code&gt;SmallAllocator&lt;/code&gt; 定义了 &lt;code&gt;reallocate&lt;/code&gt; 并且 &lt;code&gt;b.length &amp;lt;= threshold &amp;amp;&amp;amp; s &amp;lt;= threshold&lt;/code&gt; ，则将呼叫转发到 &lt;code&gt; SmallAllocator&lt;/code&gt; 。如果 &lt;code&gt;LargeAllocator&lt;/code&gt; 定义了 &lt;code&gt;expand&lt;/code&gt; 并且 &lt;code&gt; b.length &amp;gt; threshold &amp;amp;&amp;amp; s &amp;gt; threshold&lt;/code&gt; ，则将呼叫转发到 &lt;code&gt; LargeAllocator&lt;/code&gt; 。否则，调用返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="620e46438ddff127931a59ae1ef3a8f250fd07f0" translate="yes" xml:space="preserve">
          <source>This method is defined only if at least one of the allocators defines it. The good allocation size is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise. (If one of the allocators does not define &lt;code&gt;goodAllocSize&lt;/code&gt;, the default implementation in this module applies.)</source>
          <target state="translated">仅当至少一个分配器定义此方法时，才定义此方法。良好的分配大小获自 &lt;code&gt;SmallAllocator&lt;/code&gt; 如果 &lt;code&gt; s &amp;lt;= threshold&lt;/code&gt; ，或 &lt;code&gt;LargeAllocator&lt;/code&gt; 否则。（如果分配器之一未定义 &lt;code&gt;goodAllocSize&lt;/code&gt; ，则适用此模块中的默认实现。）</target>
        </trans-unit>
        <trans-unit id="d239e7b226a63994c92bb5f28f2af2cc148e0855" translate="yes" xml:space="preserve">
          <source>This method is defined only if both allocators define it. The call is forwarded to &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt; LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">仅当两个分配器都定义此方法时，才定义此方法。如果 &lt;code&gt;b.length &amp;lt;= threshold&lt;/code&gt; ， &lt;code&gt; LargeAllocator&lt;/code&gt; 呼叫转发给 &lt;code&gt;SmallAllocator&lt;/code&gt; ，否则，将呼叫转发给LargeAllocator。</target>
        </trans-unit>
        <trans-unit id="b5f2a8f9e894a52f7a4a03fd41c115c5a28e5d48" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;</source>
          <target state="translated">仅当基础范围为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围时，&lt;/a&gt;此方法才可用</target>
        </trans-unit>
        <trans-unit id="8fd044a02e3e694fc797ffa7b6155202b89056a3" translate="yes" xml:space="preserve">
          <source>This method is only available if the underlying range is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;.</source>
          <target state="translated">仅当基础范围为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围时，&lt;/a&gt;此方法才可用。</target>
        </trans-unit>
        <trans-unit id="832bf9b6aa94575865959f7e42866388acb50190" translate="yes" xml:space="preserve">
          <source>This method is only defined if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;Allocator&lt;/code&gt; 定义了 &lt;code&gt;deallocate&lt;/code&gt; 时,才定义此方法。</target>
        </trans-unit>
        <trans-unit id="d110cb43a292fbf904825bc3d4bb27446be41655" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; deallocateAll&lt;/code&gt;, and calls it for each bucket in turn. Returns &lt;code&gt;true&lt;/code&gt; if all allocators could deallocate all.</source>
          <target state="translated">仅当所有涉及的分配器都定义 &lt;code&gt; deallocateAll&lt;/code&gt; 并依次为每个存储桶调用时，才定义此方法。如果所有分配器都可以取消分配全部，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39358dd310cc162f2c05e4b4ad0f8504cf1a91af" translate="yes" xml:space="preserve">
          <source>This method is only defined if all allocators involved define &lt;code&gt; resolveInternalPointer&lt;/code&gt;, and tries it for each bucket in turn.</source>
          <target state="translated">仅当所有涉及的分配器都定义 &lt;code&gt; resolveInternalPointer&lt;/code&gt; 并依次对每个存储桶尝试时，才定义此方法。</target>
        </trans-unit>
        <trans-unit id="9dbdb0a556e3c7305bbb92177faa9a39d0b98a27" translate="yes" xml:space="preserve">
          <source>This method logs data to the used &lt;code&gt;Logger&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; of the this &lt;code&gt;Logger&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.</source>
          <target state="translated">此方法以 &lt;code&gt;printf&lt;/code&gt; 样式将数据记录到使用此 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 的已使用 &lt;code&gt;Logger&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b6f8a28a408a1ebec1b43e9856020fe703ce80ce" translate="yes" xml:space="preserve">
          <source>This method logs data with the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此方法使用使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 记录数据。</target>
        </trans-unit>
        <trans-unit id="3c1dde3d6319c6f9ff98c98c06a035679376bc16" translate="yes" xml:space="preserve">
          <source>This method removes a Logger from the &lt;code&gt;MultiLogger&lt;/code&gt;.</source>
          <target state="translated">此方法从 &lt;code&gt;MultiLogger&lt;/code&gt; 中删除一个Logger 。</target>
        </trans-unit>
        <trans-unit id="2129521b769d915727dcb1e653df38210cfe3143" translate="yes" xml:space="preserve">
          <source>This method takes a &lt;code&gt;bool&lt;/code&gt; as first argument. In order for the data to be processed the &lt;code&gt;bool&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;LogLevel&lt;/code&gt; of the Logger must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">此方法将 &lt;code&gt;bool&lt;/code&gt; 作为第一个参数。为了处理数据， &lt;code&gt;bool&lt;/code&gt; 必须为 &lt;code&gt;true&lt;/code&gt; ,并且Logger 的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0cb43593777a49c6e95ba5b0dcc72f45a57113c" translate="yes" xml:space="preserve">
          <source>This methods get and set the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">此方法获取并设置全局 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7803a9c22a232513790fa103468328fa0b2565b" translate="yes" xml:space="preserve">
          <source>This might affect your application if it has threads that are not suspended during the mark phase of the collection. You can configure the number of additional threads used for marking by GC option &lt;code&gt;parallel&lt;/code&gt;, e.g. by passing &lt;code&gt;--DRT-gcopt=parallel:2&lt;/code&gt; on the command line or embedding the option into the binary via &lt;code&gt;rt_options&lt;/code&gt;. The number of threads actually created is limited to &lt;a href=&quot;https://dlang.org/library/core/cpuid/threads_per_cpu.html&quot;&gt;&lt;code&gt;core.cpuid.threadsPerCPU-1&lt;/code&gt;&lt;/a&gt;. A value of &lt;code&gt;0&lt;/code&gt; disables parallel marking completely.</source>
          <target state="translated">如果在收集的标记阶段未挂起线程，则可能会影响您的应用程序。您可以配置用于通过GC选项 &lt;code&gt;parallel&lt;/code&gt; 标记的附加线程数，例如，通过在命令行上传递 &lt;code&gt;--DRT-gcopt=parallel:2&lt;/code&gt; 或通过 &lt;code&gt;rt_options&lt;/code&gt; 将选项嵌入二进制文件中。实际创建的线程数限制为&lt;a href=&quot;https://dlang.org/library/core/cpuid/threads_per_cpu.html&quot;&gt; &lt;code&gt;core.cpuid.threadsPerCPU-1&lt;/code&gt; &lt;/a&gt;。值为 &lt;code&gt;0&lt;/code&gt; 将完全禁用并行标记。</target>
        </trans-unit>
        <trans-unit id="abf107b5c6e2c3e95aef57b0f00ce4199d6e77e4" translate="yes" xml:space="preserve">
          <source>This module allows content to be iterated by record stored in a struct, class, associative array, or as a range of fields. Upon detection of an error an CSVException is thrown (can be disabled). csvNextToken has been made public to allow for attempted recovery.  Disabling exceptions will lift many restrictions specified above. A quote can appear in a field if the field was not quoted. If in a quoted field any quote by itself, not at the end of a field, will end processing for that field. The field is ended when there is no input, even if the quote was not closed.</source>
          <target state="translated">这个模块允许通过存储在结构、类、关联数组或字段范围的记录来迭代内容,一旦检测到错误就会抛出一个CSVException(可以禁用)。csvNextToken已经被公开,允许尝试恢复。禁用异常将解除上面指定的许多限制。如果一个字段没有被引用,引号可以出现在字段中。如果在引号字段中,任何引号本身,而不是在字段的末尾,将结束该字段的处理。当没有输入时,即使引号没有被关闭,该字段也会被结束。</target>
        </trans-unit>
        <trans-unit id="0c12be692d1a1b6196ff193f230f2b2b54e371d1" translate="yes" xml:space="preserve">
          <source>This module and its documentation are inspired by Perl's &lt;a href=&quot;http://%20%20%20%20%20%20%20%20%20%20%20perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt::Long&lt;/a&gt; module. The syntax of D's &lt;code&gt;getopt&lt;/code&gt; is simpler than its Perl counterpart because &lt;code&gt; getopt&lt;/code&gt; infers the expected parameter types from the static types of the passed-in pointers.</source>
          <target state="translated">该模块及其文档受Perl的&lt;a href=&quot;http://%20%20%20%20%20%20%20%20%20%20%20perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt :: Long&lt;/a&gt;模块启发。D的 &lt;code&gt;getopt&lt;/code&gt; 的语法比其Perl 语法简单，因为 &lt;code&gt; getopt&lt;/code&gt; 从传入的指针的静态类型中推断出预期的参数类型。</target>
        </trans-unit>
        <trans-unit id="e9ef4feea1926afdb50fb401e193258058409682" translate="yes" xml:space="preserve">
          <source>This module and its documentation are inspired by Perl's &lt;a href=&quot;https://perldoc.perl.org/Getopt/Long.html&quot;&gt;Getopt::Long&lt;/a&gt; module. The syntax of D's &lt;code&gt;getopt&lt;/code&gt; is simpler than its Perl counterpart because &lt;code&gt; getopt&lt;/code&gt; infers the expected parameter types from the static types of the passed-in pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f09ec381e380d7513f44d1a9c117509cf562d32" translate="yes" xml:space="preserve">
          <source>This module centers around two functions:</source>
          <target state="translated">该模块围绕两个功能展开。</target>
        </trans-unit>
        <trans-unit id="20c669a98c4868307d434ad05bfdc4a3a51a1300" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.  This module publicly imports &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt; and can be used as a stand-alone module.</source>
          <target state="translated">此模块符合&lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 中&lt;/a&gt;定义的API 。此模块公开导入&lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; ,&lt;/a&gt;并且可以用作独立模块。</target>
        </trans-unit>
        <trans-unit id="f7a16008011138e31550b797755a77e5d03cd02e" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;. To understand the differences between the template and the OOP API, see &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此模块符合&lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; 中&lt;/a&gt;定义的API 。要了解模板和OOP API之间的区别，请参阅&lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="17ae71bfaa531ddd2da20bee8e617777975ac653" translate="yes" xml:space="preserve">
          <source>This module conforms to the APIs defined in &lt;code&gt;std.digest&lt;/code&gt;. To understand the differences between the template and the OOP API, see &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此模块符合 &lt;code&gt;std.digest&lt;/code&gt; 中定义的API 。要了解模板和OOP API之间的区别，请参阅&lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d23cc75f3120c33113ac064a49eabf3de54b0fa" translate="yes" xml:space="preserve">
          <source>This module consists of the following submodules:</source>
          <target state="translated">本模块由以下子模块组成:</target>
        </trans-unit>
        <trans-unit id="acafb5c32c70d9aae6c63b01f760110057442f4d" translate="yes" xml:space="preserve">
          <source>This module contains UDA's (User Defined Attributes) either used in the runtime or special UDA's recognized by compiler.</source>
          <target state="translated">该模块包含了运行时使用的UDA(用户定义属性)或编译器识别的特殊UDA。</target>
        </trans-unit>
        <trans-unit id="85899b400fb24fe82d032611b825cbfb9b44e4d4" translate="yes" xml:space="preserve">
          <source>This module contains a collection of bit-level operations.</source>
          <target state="translated">这个模块包含一个位级操作的集合。</target>
        </trans-unit>
        <trans-unit id="c1389c215e1a5264fea083894c94780e9d38b766" translate="yes" xml:space="preserve">
          <source>This module contains all functions related to an object's lifetime: allocation, resizing, deallocation, and finalization.</source>
          <target state="translated">这个模块包含了所有与对象寿命相关的功能:分配、调整大小、去分配和最终确定。</target>
        </trans-unit>
        <trans-unit id="2e22ee3bb8cbf087613e536d6224ea16946bb6a9" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/assert.h.html&quot;&gt;&lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/assert.h.html&quot;&gt; &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="0790e73d68257f0feac07da73031d54a40efb1ec" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/complex.h.html&quot;&gt;&lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/complex.h.html&quot;&gt; &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="977e99994de35a20a0e314dc2374362a82960544" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/ctype.h.html&quot;&gt;&lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">此模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/ctype.h.html&quot;&gt; &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="12b921fc7078621d7eaa8b76c016bec3d37b2ea8" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/errno.h.html&quot;&gt;&lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">此模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/errno.h.html&quot;&gt; &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 中&lt;/a&gt;选择的类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="3184aa12179289bb1bc9cc36d8ce4348bfa946fe" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/fenv.h.html&quot;&gt;&lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/fenv.h.html&quot;&gt; &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="8eb2c62940c679e140d89cb9017957cd6a4ba64f" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/float.h.html&quot;&gt;&lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/float.h.html&quot;&gt; &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="82e3f25e60216c815c395312071e29f7c8ca0ddd" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/inttypes.h.html&quot;&gt;&lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">此模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/inttypes.h.html&quot;&gt; &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="f313b0f4d7c80470b377169af784edeeb810ec9d" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html&quot;&gt;&lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">此模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html&quot;&gt; &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="889ac9c43694fc79bd24e61dceed4e6fda688b35" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/locale.h.html&quot;&gt;&lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">此模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/locale.h.html&quot;&gt; &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; 中&lt;/a&gt;选择的类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="8bd014e9d5a4fdbad34dcb7fb8420e937c0abc85" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html&quot;&gt;&lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">此模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html&quot;&gt; &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 中&lt;/a&gt;选择的类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="fc16180c80d567a16457d88550f7aa27a1b419aa" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html&quot;&gt;&lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">此模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html&quot;&gt; &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; 中&lt;/a&gt;选择的类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="5971b6bf8e57282688ff4449029781d4b3a236d4" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdarg.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdarg.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="b580515d9fbf0a4ef7b9e421dec5768897b813d8" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stddef.h.html&quot;&gt;&lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stddef.h.html&quot;&gt; &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="95281628a03db4872107318eb8c99b1bea13ccc2" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="51ba870a61bb5fb732f12f00ebdf0f6bdf33ab08" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdio.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="b6d9cbc1fb19908d75c057b6e010d377eada4d77" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html&quot;&gt;&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html&quot;&gt; &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="050d1037c01667ef5f3b8f67c4951211e12ccacf" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/string.h.html&quot;&gt;&lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">此模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/string.h.html&quot;&gt; &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; 中&lt;/a&gt;选择的类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="f549cd509c6cf2035fd5afdb0920eaa5d4d5e84e" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/tgmath.h.html&quot;&gt;&lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/tgmath.h.html&quot;&gt; &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="62c64533f70dfc4fd8955bc0b3a2834ad07751af" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html&quot;&gt;&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html&quot;&gt; &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="92aabdabf0e70387e5a38f4c231411efd14217e3" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wchar.h.html&quot;&gt;&lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wchar.h.html&quot;&gt; &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="0ec277ffc9998ff3f0f63d9eedcde3635f0eb758" translate="yes" xml:space="preserve">
          <source>This module contains bindings to selected types and functions from the standard C header &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wctype.h.html&quot;&gt;&lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;&lt;/a&gt;. Note that this is not automatically generated, and may omit some types/functions from the original C header.</source>
          <target state="translated">该模块包含从标准C头文件&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/wctype.h.html&quot;&gt; &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; &lt;/a&gt;到所选类型和函数的绑定。请注意，这不是自动生成的，并且可能会从原始C标头中省略某些类型/功能。</target>
        </trans-unit>
        <trans-unit id="4332c56ae7f44bffd58f114ac37e892a2b103dd8" translate="yes" xml:space="preserve">
          <source>This module contains compiler support determining equality of dynamic arrays.</source>
          <target state="translated">该模块包含编译器支持确定动态数组的平等性。</target>
        </trans-unit>
        <trans-unit id="a9409989c24e53c52350805b177653fd011bfa05" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for casting dynamic arrays</source>
          <target state="translated">这个模块包含了对动态数组铸造的编译器支持。</target>
        </trans-unit>
        <trans-unit id="98da9476138dd631b9aa80ca4972d86126ed52a1" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for comparing dynamic arrays</source>
          <target state="translated">这个模块包含编译器对比较动态数组的支持。</target>
        </trans-unit>
        <trans-unit id="ea25ff08ceea8b6974ce0811b1a4d3c03f3a2b61" translate="yes" xml:space="preserve">
          <source>This module contains compiler support for constructing dynamic arrays</source>
          <target state="translated">该模块包含编译器对构建动态数组的支持。</target>
        </trans-unit>
        <trans-unit id="130d46533e13acaf0b0f736ae469ff9f68d6ff23" translate="yes" xml:space="preserve">
          <source>This module contains high-level interfaces for interacting with DMD as a library.</source>
          <target state="translated">该模块包含了与DMD作为一个库进行交互的高级接口。</target>
        </trans-unit>
        <trans-unit id="7df04f2ddca174e21d081429f9f3c53ebccb78b8" translate="yes" xml:space="preserve">
          <source>This module contains some common utilities used by containers.</source>
          <target state="translated">该模块包含一些容器常用的实用程序。</target>
        </trans-unit>
        <trans-unit id="dcac3a1b4da6941734058525116d97065268b549" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' appending</source>
          <target state="translated">这个模块包含对控制动态数组追加的支持。</target>
        </trans-unit>
        <trans-unit id="c49eb9ff2d1c37482fee0bb60748312c2292f298" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' capacity and length</source>
          <target state="translated">该模块包含了对控制动态数组容量和长度的支持。</target>
        </trans-unit>
        <trans-unit id="5a472e4841c397ed8a20c7da34116a395a9f78db" translate="yes" xml:space="preserve">
          <source>This module contains support for controlling dynamic arrays' concatenation</source>
          <target state="translated">该模块包含对控制动态数组连接的支持。</target>
        </trans-unit>
        <trans-unit id="d58f6f902fb5917dee8fa5b768555a18fd9ff404" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;#Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; type, which is used to represent complex numbers, along with related mathematical operations and functions.</source>
          <target state="translated">该模块包含用于表示复数的&amp;ldquo; &lt;a href=&quot;#Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt;类型，以及相关的数学运算和函数。</target>
        </trans-unit>
        <trans-unit id="1cafe10d55f1a2961b685e59594325a88af3e24c" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;code&gt;Id&lt;/code&gt; struct with a list of predefined symbols the compiler knows about.</source>
          <target state="translated">此模块包含 &lt;code&gt;Id&lt;/code&gt; 结构以及编译器已知的预定义符号列表。</target>
        </trans-unit>
        <trans-unit id="99093b5cfdcc5707f50f9cafa8f212b7442853a6" translate="yes" xml:space="preserve">
          <source>This module contains utilities for TypeInfo implementation.</source>
          <target state="translated">该模块包含TypeInfo实现的实用程序。</target>
        </trans-unit>
        <trans-unit id="a058b7e236eb5ab7c537629e84966c190eced743" translate="yes" xml:space="preserve">
          <source>This module contains utility functions to help the implementation of the runtime hook</source>
          <target state="translated">这个模块包含了一些实用的函数,以帮助实现运行时的钩子</target>
        </trans-unit>
        <trans-unit id="7d6317f5849751724969636691ef1f8625b672f7" translate="yes" xml:space="preserve">
          <source>This module contains various string related functions.</source>
          <target state="translated">该模块包含各种与字符串相关的功能。</target>
        </trans-unit>
        <trans-unit id="d02a1f1d4e42f0ca255a0d80699556c671a1024b" translate="yes" xml:space="preserve">
          <source>This module declares intrinsics for volatile operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a531226ad2342a85a7cda80bcc56003e90c7e5a" translate="yes" xml:space="preserve">
          <source>This module defines &lt;code&gt;TypedAllocator&lt;/code&gt;, a statically-typed allocator that aggregates multiple untyped allocators and uses them depending on the static properties of the types allocated. For example, distinct allocators may be used for thread-local vs. thread-shared data, or for fixed-size data (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt; objects) vs. resizable data (arrays).</source>
          <target state="translated">该模块定义 &lt;code&gt;TypedAllocator&lt;/code&gt; ，这是一个静态类型的分配器，它聚合多个未类型的分配器并根据分配的类型的静态属性使用它们。例如，可以将不同的分配器用于线程本地数据与线程共享数据，或者用于固定大小的数据（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 对象）与可调整大小的数据（数组）。</target>
        </trans-unit>
        <trans-unit id="259e74bca77eb48b491beebe7a35554776cb2efb" translate="yes" xml:space="preserve">
          <source>This module defines a number of primitives that work with graphemes: &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decodeGrapheme&quot;&gt;&lt;code&gt;decodeGrapheme&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#graphemeStride&quot;&gt;&lt;code&gt;graphemeStride&lt;/code&gt;&lt;/a&gt;. All of them are using</source>
          <target state="translated">这个模块定义了许多原语的工作与字形：&lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#decodeGrapheme&quot;&gt; &lt;code&gt;decodeGrapheme&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#graphemeStride&quot;&gt; &lt;code&gt;graphemeStride&lt;/code&gt; &lt;/a&gt;。他们都在用</target>
        </trans-unit>
        <trans-unit id="99bc02ede476ad853ab518e42294b5202a998289" translate="yes" xml:space="preserve">
          <source>This module defines facilities for efficient checking of integral operations against overflow, casting with loss of precision, unexpected change of sign, etc. The checking (and possibly correction) can be done at operation level, for example &lt;a href=&quot;#opChecked&quot;&gt;&lt;code&gt;opChecked&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!&quot;+&quot;(x, y, overflow)&lt;/code&gt; adds two integrals &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and sets &lt;code&gt;overflow&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; if an overflow occurred. The flag &lt;code&gt;overflow&lt;/code&gt; (a &lt;code&gt;bool&lt;/code&gt; passed by reference) is not touched if the operation succeeded, so the same flag can be reused for a sequence of operations and tested at the end.</source>
          <target state="translated">该模块定义了用于有效检查整体操作以防溢出，精度损失，符号意外更改等的功能。检查（以及可能的更正）可以在操作级别进行，例如&lt;a href=&quot;#opChecked&quot;&gt; &lt;code&gt;opChecked&lt;/code&gt; &lt;/a&gt; &lt;code&gt;!&quot;+&quot;(x, y, overflow)&lt;/code&gt; 将两个积分 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 相加，如果发生 &lt;code&gt;overflow&lt;/code&gt; ，则将overflow 设置为 &lt;code&gt;true&lt;/code&gt; 。如果操作成功，则不会触摸标志 &lt;code&gt;overflow&lt;/code&gt; （通过引用传递的 &lt;code&gt;bool&lt;/code&gt; ），因此可以将同一标志重新用于一系列操作并在最后进行测试。</target>
        </trans-unit>
        <trans-unit id="8e33eb3468c635b3f1b1bf8d7ab1a84f24b11f39" translate="yes" xml:space="preserve">
          <source>This module defines functions related to exceptions and general error handling. It also defines functions intended to aid in unit testing.</source>
          <target state="translated">这个模块定义了与异常和一般错误处理有关的函数。它还定义了用于辅助单元测试的函数。</target>
        </trans-unit>
        <trans-unit id="2f439ece9b3ae412ebb6e407781c8a8d19e803e8" translate="yes" xml:space="preserve">
          <source>This module defines generic containers.</source>
          <target state="translated">该模块定义了通用容器。</target>
        </trans-unit>
        <trans-unit id="7716ef353856b8c8fdc336f0f551c1520abef4d6" translate="yes" xml:space="preserve">
          <source>This module defines the notion of a range. Ranges generalize the concept of arrays, lists, or anything that involves sequential access. This abstraction enables the same set of algorithms (see &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt;) to be used with a vast variety of different concrete types. For example, a linear search algorithm such as &lt;a href=&quot;std_algorithm_searching#find&quot;&gt;&lt;code&gt;std.algorithm.searching.find&lt;/code&gt;&lt;/a&gt; works not just for arrays, but for linked-lists, input files, incoming network data, etc.</source>
          <target state="translated">此模块定义范围的概念。范围概括了数组，列表或涉及顺序访问的任何内容的概念。这种抽象使同一套算法（请参阅&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;）可以用于多种不同的具体类型。例如，线性搜索算法（例如&lt;a href=&quot;std_algorithm_searching#find&quot;&gt; &lt;code&gt;std.algorithm.searching.find&lt;/code&gt; )&lt;/a&gt;不仅适用于数组，而且适用于链表，输入文件，传入的网络数据等。</target>
        </trans-unit>
        <trans-unit id="0c2b133a65c34666134047443b875c3c6bf1823e" translate="yes" xml:space="preserve">
          <source>This module describes the digest APIs used in Phobos. All digests follow these APIs. Additionally, this module contains useful helper methods which can be used with every digest type.</source>
          <target state="translated">本模块描述了 Phobos 中使用的摘要 API。所有摘要都遵循这些 API。此外,本模块还包含了一些有用的辅助方法,这些方法可用于每种摘要类型。</target>
        </trans-unit>
        <trans-unit id="9eac267b2bca3c4e62e74376d6d1858e8b30f305" translate="yes" xml:space="preserve">
          <source>This module extracts debug info from the currently running Mach-O executable.</source>
          <target state="translated">该模块从当前运行的Mach-O可执行文件中提取调试信息。</target>
        </trans-unit>
        <trans-unit id="2b3bde835b97011d3a24374bdd792ad0a067b596" translate="yes" xml:space="preserve">
          <source>This module has two submodules:</source>
          <target state="translated">该模块有两个子模块。</target>
        </trans-unit>
        <trans-unit id="c364d07bb94ddbade750564cb1b9de747e163c33" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;a href=&quot;http://erdani.org/publications/cuj-04-2002.html&quot;&gt;discriminated union&lt;/a&gt; type (a.k.a. &lt;a href=&quot;http://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged union&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;algebraic type&lt;/a&gt;). Such types are useful for type-uniform binary interfaces, interfacing with scripting languages, and comfortable exploratory programming.</source>
          <target state="translated">该模块实现了&lt;a href=&quot;http://erdani.org/publications/cuj-04-2002.html&quot;&gt;区分的联合&lt;/a&gt;类型（又名带&lt;a href=&quot;http://en.wikipedia.org/wiki/Tagged_union&quot;&gt;标签的联合&lt;/a&gt;，&lt;a href=&quot;http://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;代数类型&lt;/a&gt;）。此类类型对于类型统一的二进制接口，与脚本语言的接口以及舒适的探索性编程很有用。</target>
        </trans-unit>
        <trans-unit id="dcf874427a131dcde8af3f16bcfbe7028972cb86" translate="yes" xml:space="preserve">
          <source>This module implements a generic doubly-linked list container. It can be used as a queue, dequeue or stack.</source>
          <target state="translated">这个模块实现了一个通用的双链路列表容器。它可以作为一个队列、去队列或堆栈使用。</target>
        </trans-unit>
        <trans-unit id="276f012505f8a462f31b45a6f4a35457a2d35dbc" translate="yes" xml:space="preserve">
          <source>This module implements a red-black tree container.</source>
          <target state="translated">该模块实现了一个红黑树容器。</target>
        </trans-unit>
        <trans-unit id="7870ea3fc10596df955abb619b60da2851a384ad" translate="yes" xml:space="preserve">
          <source>This module implements a singly-linked list container. It can be used as a stack.</source>
          <target state="translated">这个模块实现了一个单一链接的列表容器。它可以作为一个堆栈使用。</target>
        </trans-unit>
        <trans-unit id="b8ec77e995992fa015630679195d60252ee43e89" translate="yes" xml:space="preserve">
          <source>This module implements a variety of type constructors, i.e., templates that allow construction of new, useful general-purpose types.</source>
          <target state="translated">这个模块实现了各种类型构造器,即允许构造新的、有用的通用类型的模板。</target>
        </trans-unit>
        <trans-unit id="64f274b864d84b8337845eb1c9cfcbc24ac5038e" translate="yes" xml:space="preserve">
          <source>This module implements experimental additions/modifications to &lt;a href=&quot;std_typecons&quot;&gt;&lt;code&gt;std.typecons&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块实现了对&lt;a href=&quot;std_typecons&quot;&gt; &lt;code&gt;std.typecons&lt;/code&gt; 的&lt;/a&gt;实验性添加/修改。</target>
        </trans-unit>
        <trans-unit id="eaa4498639b5fb5cabef3038967389ce127f79a8" translate="yes" xml:space="preserve">
          <source>This module implements integral arithmetic primitives that check for out-of-range results.</source>
          <target state="translated">该模块实现了检查范围外结果的积分算术基元。</target>
        </trans-unit>
        <trans-unit id="19bff9c3e2a27e1a7382004762c10f34a531050a" translate="yes" xml:space="preserve">
          <source>This module implements the formatting functionality for strings and I/O. It's comparable to C99's &lt;code&gt;vsprintf()&lt;/code&gt; and uses a similar format encoding scheme.</source>
          <target state="translated">该模块实现了字符串和I / O的格式化功能。它可与C99的 &lt;code&gt;vsprintf()&lt;/code&gt; 相提并论，并使用类似的格式编码方案。</target>
        </trans-unit>
        <trans-unit id="c014fbea053ad61d3a5ae1fc743fb6c3131c1dfb" translate="yes" xml:space="preserve">
          <source>This module is a port of a growing fragment of the numeric header in Alexander Stepanov's &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;Standard Template Library&lt;/a&gt;, with a few additions.</source>
          <target state="translated">该模块是Alexander Stepanov的&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_Template_Library&quot;&gt;标准模板库中&lt;/a&gt;数字标头的不断增长的片段的端口，其中包括一些附加内容。</target>
        </trans-unit>
        <trans-unit id="186b66046159293951af2f7bf5b6d370eaa1c7f1" translate="yes" xml:space="preserve">
          <source>This module is a submodule of &lt;a href=&quot;std_container&quot;&gt;&lt;code&gt;std.container&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块是&lt;a href=&quot;std_container&quot;&gt; &lt;code&gt;std.container&lt;/code&gt; &lt;/a&gt;的子模块。</target>
        </trans-unit>
        <trans-unit id="b888919ea96721208483544ffecc9a20b885369e" translate="yes" xml:space="preserve">
          <source>This module is a submodule of &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块是&lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;的子模块。</target>
        </trans-unit>
        <trans-unit id="66276a22645692b59d3aafb558b5c8800653b392" translate="yes" xml:space="preserve">
          <source>This module is used to manipulate path strings.</source>
          <target state="translated">该模块用于操作路径字符串。</target>
        </trans-unit>
        <trans-unit id="1fb13153b51d693dc351aaf671b676f52a55b77c" translate="yes" xml:space="preserve">
          <source>This module only supports DWARF 3 and 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676c0f1d3f6966f52d6837dedf54ff7909b0c357" translate="yes" xml:space="preserve">
          <source>This module provides a &lt;code&gt;BinaryHeap&lt;/code&gt; (aka priority queue) adaptor that makes a binary heap out of any user-provided random-access range.</source>
          <target state="translated">此模块提供 &lt;code&gt;BinaryHeap&lt;/code&gt; （又称为优先级队列）适配器，该适配器使二进制堆超出用户提供的任何随机访问范围。</target>
        </trans-unit>
        <trans-unit id="71c4856d53f3e5b6efc2d0b1e712b1b6dc800220" translate="yes" xml:space="preserve">
          <source>This module provides a few predefined hooks (below) that add useful behavior to &lt;code&gt;Checked&lt;/code&gt;:</source>
          <target state="translated">该模块提供了一些预定义的挂钩（如下），这些挂钩为 &lt;code&gt;Checked&lt;/code&gt; 添加了有用的行为：</target>
        </trans-unit>
        <trans-unit id="b737fcac62cfd177fb2788c39a8e794c75cf3e63" translate="yes" xml:space="preserve">
          <source>This module provides all kinds of functions to create, manipulate or convert arrays:</source>
          <target state="translated">本模块提供了各种创建、操作或转换数组的功能。</target>
        </trans-unit>
        <trans-unit id="744c3d7cd21f0164caf9f95d6fbb778bc3ca3903" translate="yes" xml:space="preserve">
          <source>This module provides an &lt;code&gt;Array&lt;/code&gt; type with deterministic memory usage not reliant on the GC, as an alternative to the built-in arrays.</source>
          <target state="translated">此模块提供了一种 &lt;code&gt;Array&lt;/code&gt; 类型，它具有不依赖于GC的确定性内存使用情况，以替代内置数组。</target>
        </trans-unit>
        <trans-unit id="223a76451a573bc8bae5a7f8a3df3aee7f1c9bdf" translate="yes" xml:space="preserve">
          <source>This module provides an interface to the garbage collector used by applications written in the D programming language. It allows the garbage collector in the runtime to be swapped without affecting binary compatibility of applications.</source>
          <target state="translated">这个模块提供了一个接口,可以连接到用D编程语言编写的应用程序所使用的垃圾收集器。它允许在不影响应用程序二进制兼容性的情况下,对运行时的垃圾收集器进行调换。</target>
        </trans-unit>
        <trans-unit id="45492b4e65c39718d334c504b40cf5ab9383e9f9" translate="yes" xml:space="preserve">
          <source>This module provides functions for compile time function composition. These functions are helpful when constructing predicates for the algorithms in &lt;a href=&quot;std_algorithm&quot;&gt;&lt;code&gt;std.algorithm&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该模块提供用于编译时间函数合成的函数。这些函数在为&lt;a href=&quot;std_algorithm&quot;&gt; &lt;code&gt;std.algorithm&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt;构建算法的谓词时很有帮助。</target>
        </trans-unit>
        <trans-unit id="5d2a6ed25bc583d8e01cfa972338639c00d25698" translate="yes" xml:space="preserve">
          <source>This module provides two default implementations of Base64 encoding, &lt;a href=&quot;#Base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt; with a standard encoding alphabet, and a variant &lt;a href=&quot;#Base64URL&quot;&gt;&lt;code&gt;Base64URL&lt;/code&gt;&lt;/a&gt; that has a modified encoding alphabet designed to be safe for embedding in URLs and filenames.</source>
          <target state="translated">该模块提供了两种默认的Base64编码实现，一种是带有标准编码字母的&lt;a href=&quot;#Base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Base64URL&quot;&gt; &lt;code&gt;Base64URL&lt;/code&gt; &lt;/a&gt;一种是带有修改后的编码字母的Base64URL，该编码字母旨在安全地嵌入URL和文件名中。</target>
        </trans-unit>
        <trans-unit id="14ea77a508973ad119aa38dedb9cc8889215b5e7" translate="yes" xml:space="preserve">
          <source>This module publicly imports &lt;a href=&quot;std_digest&quot;&gt;&lt;code&gt;std.digest&lt;/code&gt;&lt;/a&gt; and can be used as a stand-alone module.</source>
          <target state="translated">此模块公开导入&lt;a href=&quot;std_digest&quot;&gt; &lt;code&gt;std.digest&lt;/code&gt; ,&lt;/a&gt;并且可以用作独立模块。</target>
        </trans-unit>
        <trans-unit id="821aad4a4d60f837d17e068e658c2b293af2fa2e" translate="yes" xml:space="preserve">
          <source>This module publicly imports &lt;code&gt;std.digest&lt;/code&gt; and can be used as a stand-alone module.</source>
          <target state="translated">此模块公开导入 &lt;code&gt;std.digest&lt;/code&gt; ,并且可以用作独立模块。</target>
        </trans-unit>
        <trans-unit id="b024b98a208b935e325d89f7c0523c717e6fc717" translate="yes" xml:space="preserve">
          <source>This module tells the garbage collector about the static data and bss segments, so the GC can scan them for roots. It does not deal with thread local static data.</source>
          <target state="translated">这个模块告诉垃圾收集器关于静态数据和bss段的信息,这样GC就可以扫描它们的根。它不处理线程本地静态数据。</target>
        </trans-unit>
        <trans-unit id="0394ab52f6a74bfd6653d7622a7e2f41048f71f6" translate="yes" xml:space="preserve">
          <source>This module uses two main sources for generating human-readable data. First, it uses &lt;code&gt;backtrace_symbols&lt;/code&gt; to obtain the name of the symbols (functions or methods) associated with the addresses. Since the names are mangled, it will also call into &lt;code&gt;core.demangle&lt;/code&gt;, and doesn't need to use any DWARF information for this, however a future extension could make use of the call frame information (See DWARF4 &quot;6.4 Call Frame Information&quot;, PDF page 126).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463dc59b1d8043356600fc31e94afe8ce61592b7" translate="yes" xml:space="preserve">
          <source>This modules defines some utility functions for DMD.</source>
          <target state="translated">该模块定义了DMD的一些实用功能。</target>
        </trans-unit>
        <trans-unit id="43097636fc7721cda69a3011b02706b476fb53a5" translate="yes" xml:space="preserve">
          <source>This modules defines the entry point (main) for DMD, as well as related utilities needed for arguments parsing, path manipulation, etc... This file is not shared with other compilers which use the DMD front-end.</source>
          <target state="translated">这个模块定义了DMD的入口点(main),以及参数解析、路径操作等所需的相关实用程序。这个文件不与其他使用DMD前端的编译器共享。</target>
        </trans-unit>
        <trans-unit id="8c5c0a58905cfb5b439b5201a82885c00dee51e2" translate="yes" xml:space="preserve">
          <source>This modules defines the help texts for the CLI options offered by DMD. This file is not shared with other compilers which use the DMD front-end. However, this file will be used to generate the &lt;a href=&quot;https://dlang.org/dmd-linux.html&quot;&gt;online documentation&lt;/a&gt; and MAN pages.</source>
          <target state="translated">该模块定义了DMD提供的CLI选项的帮助文本。该文件不与使用DMD前端的其他编译器共享。但是，此文件将用于生成&lt;a href=&quot;https://dlang.org/dmd-linux.html&quot;&gt;在线文档&lt;/a&gt;和MAN页面。</target>
        </trans-unit>
        <trans-unit id="d366277495521395d02d0e8919a008889699c8b6" translate="yes" xml:space="preserve">
          <source>This modules implements the serialization of a lambda function. The serialization is computed by visiting the abstract syntax subtree of the given lambda function. The serialization is a string which contains the type of the parameters and the string represantation of the lambda expression.</source>
          <target state="translated">这个模块实现了lambda函数的序列化。序列化是通过访问给定lambda函数的抽象语法子树来计算的。序列化是一个字符串,其中包含参数的类型和lambda表达式的字符串重述。</target>
        </trans-unit>
        <trans-unit id="4686239dc1c916453ca8175a0c8f0fd5b10fd0f8" translate="yes" xml:space="preserve">
          <source>This mostly means checking that the &lt;a href=&quot;http://www.digitalmars.com/rtl/stdio.html#printf&quot;&gt;printf format specifier&lt;/a&gt; matches the corresponding D data type. Although printf is designed to handle 0 terminated strings, not D dynamic arrays of chars, it turns out that since D dynamic arrays are a length followed by a pointer to the data, the &lt;code&gt;%.*s&lt;/code&gt; format works:</source>
          <target state="translated">这主要意味着检查&lt;a href=&quot;http://www.digitalmars.com/rtl/stdio.html#printf&quot;&gt;printf格式说明符是否&lt;/a&gt;与相应的D数据类型匹配。尽管将printf设计为处理0个终止的字符串，而不是D个字符的动态数组，但事实证明，由于D个动态数组是一个长度，后跟指向数据的指针，因此 &lt;code&gt;%.*s&lt;/code&gt; 格式有效：</target>
        </trans-unit>
        <trans-unit id="d2a9ab8f340972eb23caaae774d32f80fccc2570" translate="yes" xml:space="preserve">
          <source>This must be called when a scheduled thread terminates. It tears down the messaging system for the thread and notifies interested parties of the thread's termination.</source>
          <target state="translated">当一个预定的线程终止时,必须调用这个函数。它拆除线程的消息系统,并通知相关方线程的终止。</target>
        </trans-unit>
        <trans-unit id="a87fd9a7f939391e41bf76be573f03fa79c258b5" translate="yes" xml:space="preserve">
          <source>This opcode is not supported by the assembler, instead use</source>
          <target state="translated">汇编器不支持这个操作码,可以使用</target>
        </trans-unit>
        <trans-unit id="475523109cd4bf257a07dadc9f0c389730bafbbb" translate="yes" xml:space="preserve">
          <source>This operation is both lock-free and atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5080314419c68e07e9fbf46cb969bb8f7aec2b87" translate="yes" xml:space="preserve">
          <source>This overload converts a character input range to a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">此重载将字符输入范围转换为 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2f77cb81e183ee70aaac158a6010f060479e211" translate="yes" xml:space="preserve">
          <source>This overload of the digest function handles arrays.</source>
          <target state="translated">这个digest函数的重载处理数组。</target>
        </trans-unit>
        <trans-unit id="5b5704e7eb61d0c1141594f127f54400ac726629" translate="yes" xml:space="preserve">
          <source>This overload of the hexDigest function handles arrays.</source>
          <target state="translated">这个hexDigest函数的重载处理数组。</target>
        </trans-unit>
        <trans-unit id="9b517602563a0a0437638b7de42771ba24220c9c" translate="yes" xml:space="preserve">
          <source>This override handles the following two cases: static foreach (i, i; [0]) { ... } and static foreach (i; [0]) { enum i = 2; }</source>
          <target state="translated">这个覆盖处理了以下两种情况:static foreach (i,i;[0]){...}和 static foreach (i;[0]){enum i=2;}。</target>
        </trans-unit>
        <trans-unit id="4b5c72b79cb5cdac8aa14be60be09b9790cb2ce2" translate="yes" xml:space="preserve">
          <source>This package also implements untyped composable memory allocators. They are</source>
          <target state="translated">这个包还实现了非类型的可组合内存分配器。它们是</target>
        </trans-unit>
        <trans-unit id="5b7998033b82c18a421be4c93bdff9f111ea8e70" translate="yes" xml:space="preserve">
          <source>This package implements generic algorithms oriented towards the processing of sequences. Sequences processed by these functions define range-based interfaces. See also &lt;a href=&quot;std_range&quot;&gt;Reference on ranges&lt;/a&gt; and &lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;tutorial on ranges&lt;/a&gt;.</source>
          <target state="translated">该软件包实现了面向序列处理的通用算法。这些函数处理的序列定义了基于范围的接口。另请参见&lt;a href=&quot;std_range&quot;&gt;有关范围的参考&lt;/a&gt;和&lt;a href=&quot;http://ddili.org/ders/d.en/ranges.html&quot;&gt;有关范围的教程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58c7d9c8a3cee8b3cf80c6b3b4132f86a95f5343" translate="yes" xml:space="preserve">
          <source>This package implements the hash-based message authentication code (HMAC) algorithm as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc2104&quot;&gt;RFC2104&lt;/a&gt;. See also the corresponding &lt;a href=&quot;http://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Wikipedia article&lt;/a&gt;.</source>
          <target state="translated">该软件包实现了&lt;a href=&quot;http://tools.ietf.org/html/rfc2104&quot;&gt;RFC2104中&lt;/a&gt;定义的基于哈希的消息认证代码（HMAC）算法。另请参见相应的&lt;a href=&quot;http://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;Wikipedia文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b54b15a9491f8b22812d70e97f6e30656fbe4637" translate="yes" xml:space="preserve">
          <source>This points to a linked list of headers, struct curl_slist kind</source>
          <target state="translated">这指向一个链接的头文件列表,struct curl_slist kind</target>
        </trans-unit>
        <trans-unit id="4fa3e3f63776b5b0936a2fb2bebc42c79d485368" translate="yes" xml:space="preserve">
          <source>This points to a linked list of post entries, struct curl_httppost</source>
          <target state="translated">这指向一个链接的帖子条目列表,结构curl_httppost</target>
        </trans-unit>
        <trans-unit id="4709ade7923d0d8282a3479562e2dbd3f6142a8c" translate="yes" xml:space="preserve">
          <source>This points to a linked list of telnet options</source>
          <target state="translated">这指向一个telnet选项的链接列表。</target>
        </trans-unit>
        <trans-unit id="2d122d6794084d92dff4c8603b8a998294750f13" translate="yes" xml:space="preserve">
          <source>This pragma must directly precede an &lt;code&gt;extern(C)&lt;/code&gt; function declaration that must take no argument, even default ones. The function this pragma applies to will be inserted in &lt;code&gt;.init_array&lt;/code&gt; or &lt;code&gt;.ctors&lt;/code&gt;, depending on the target and compiler implementation. It is equivalent to GCC's &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Function-Attributes.html&quot;&gt;&lt;code&gt;__attribute__((constructor))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f59d77929e72a8f25d40e635e0a3a32957778c" translate="yes" xml:space="preserve">
          <source>This predicate must be an equivalence relation, that is, it must be reflexive (&lt;code&gt;pred(x,x)&lt;/code&gt; is always true), symmetric (&lt;code&gt;pred(x,y) == pred(y,x)&lt;/code&gt;), and transitive (&lt;code&gt;pred(x,y) &amp;amp;&amp;amp; pred(y,z)&lt;/code&gt; implies &lt;code&gt;pred(x,z)&lt;/code&gt;). If this is not the case, the range returned by chunkBy may assert at runtime or behave erratically.</source>
          <target state="translated">该谓词必须是等价关系，也就是说，它必须是自反的（ &lt;code&gt;pred(x,x)&lt;/code&gt; 始终为true），对称的（ &lt;code&gt;pred(x,y) == pred(y,x)&lt;/code&gt; ）和可传递的（ &lt;code&gt;pred(x,y) &amp;amp;&amp;amp; pred(y,z)&lt;/code&gt; 意味着 &lt;code&gt;pred(x,z)&lt;/code&gt; ）。如果不是这种情况，chunkBy返回的范围可能在运行时断言或行为异常。</target>
        </trans-unit>
        <trans-unit id="0a267b44ef886d9c8baf429e8671183b625c8796" translate="yes" xml:space="preserve">
          <source>This program reads standard in and writes it to standard out, pretty-printing any found D mangled names.</source>
          <target state="translated">这个程序把标准的读进去,然后写成标准的出,把发现的D杂名漂亮的打印出来。</target>
        </trans-unit>
        <trans-unit id="afdb5e2e48fdacd7a6c8694592ad8b718667d89f" translate="yes" xml:space="preserve">
          <source>This property is overridden because the local time of the system could change while the program is running and we need to determine it dynamically rather than it being fixed like it would be with most time zones.</source>
          <target state="translated">这个属性被重写,因为在程序运行时,系统的本地时间可能会发生变化,我们需要动态地确定它,而不是像大多数时区那样固定不变。</target>
        </trans-unit>
        <trans-unit id="6d74dd10b5c800dca0bea3aabcacb84d776dbed7" translate="yes" xml:space="preserve">
          <source>This property sets and gets the default &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">此属性设置并获取默认的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="233904e9ff09001991edcef153035ddd2dc72e31" translate="yes" xml:space="preserve">
          <source>This property should not be used, but is supported for legacy purposes.</source>
          <target state="translated">此属性不应使用,但支持用于遗留目的。</target>
        </trans-unit>
        <trans-unit id="0c0985b965d550bee9a97d40f84d906e5dd41300" translate="yes" xml:space="preserve">
          <source>This prototype applies to all conversion callbacks</source>
          <target state="translated">这个原型适用于所有的转换回调。</target>
        </trans-unit>
        <trans-unit id="362936247c39185758bfe185928298d458cd1898" translate="yes" xml:space="preserve">
          <source>This provides a transition from the non-promoting behavior of unary + - ~ to the C-like integral promotion behavior.</source>
          <target state="translated">这就提供了一个从单项+-~的非促进行为到C类积分促进行为的过渡。</target>
        </trans-unit>
        <trans-unit id="42fdb37f7871dd64abfac735f6f1948def69313b" translate="yes" xml:space="preserve">
          <source>This provides a way to add functions to a class externally as if they were public final member functions, which enables &lt;a href=&quot;http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321&quot;&gt; function chaining and component programming&lt;/a&gt;.</source>
          <target state="translated">这提供了一种从外部向类添加函数的方法，就像它们是公共最终成员函数一样，从而实现了&lt;a href=&quot;http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321&quot;&gt;函数链接和组件编程&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5e3135a675f967dd5c5470ea386f16d7ad31f41" translate="yes" xml:space="preserve">
          <source>This range iterates over fixed-sized chunks of size &lt;code&gt;chunkSize&lt;/code&gt; of a &lt;code&gt;source&lt;/code&gt; range. &lt;code&gt;Source&lt;/code&gt; must be an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;. &lt;code&gt;chunkSize&lt;/code&gt; must be greater than zero.</source>
          <target state="translated">此范围在 &lt;code&gt;source&lt;/code&gt; 范围的大小 &lt;code&gt;chunkSize&lt;/code&gt; 的固定大小的块上进行迭代。 &lt;code&gt;Source&lt;/code&gt; 必须是&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;。 &lt;code&gt;chunkSize&lt;/code&gt; 必须大于零。</target>
        </trans-unit>
        <trans-unit id="ffdad1d5b9cd516ba877128f5377fd43732ba01e" translate="yes" xml:space="preserve">
          <source>This range splits a &lt;code&gt;source&lt;/code&gt; range into &lt;code&gt;chunkCount&lt;/code&gt; chunks of approximately equal length. &lt;code&gt;Source&lt;/code&gt; must be a forward range with known length.</source>
          <target state="translated">此范围将 &lt;code&gt;source&lt;/code&gt; 范围划分为大约相等长度的 &lt;code&gt;chunkCount&lt;/code&gt; 块。 &lt;code&gt;Source&lt;/code&gt; 必须是已知长度的前向范围。</target>
        </trans-unit>
        <trans-unit id="99784cdd841b29b6c6c458a6a98700cdba67e67d" translate="yes" xml:space="preserve">
          <source>This range will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the underlying data source is at least a forward range.</source>
          <target state="translated">这个范围将是一个&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前进档&lt;/a&gt;，如果基础数据源是至少一个前进档。</target>
        </trans-unit>
        <trans-unit id="87508ea3111ce555c431f5b202f7db1e58a43a32" translate="yes" xml:space="preserve">
          <source>This range will receive elements of &lt;code&gt;inputRange&lt;/code&gt; progressively as iteration proceeds.</source>
          <target state="translated">随着迭代的进行，此范围将逐渐接收 &lt;code&gt;inputRange&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="76aba1f55c69e82481c98e4e2c1338584cc1691e" translate="yes" xml:space="preserve">
          <source>This represents the category of &lt;code&gt;Throwable&lt;/code&gt; objects that are &lt;b&gt;not&lt;/b&gt; safe to catch and handle. In principle, one should not catch Error objects, as they represent unrecoverable runtime errors. Certain runtime guarantees may fail to hold when these errors are thrown, making it unsafe to continue execution after catching them.</source>
          <target state="translated">这代表的类 &lt;code&gt;Throwable&lt;/code&gt; 是对象&lt;b&gt;不是&lt;/b&gt;安全捕获并处理。原则上，不应捕获Error对象，因为它们表示不可恢复的运行时错误。当抛出这些错误时，某些运行时保证可能无法保留，从而在捕获到它们之后继续执行是不安全的。</target>
        </trans-unit>
        <trans-unit id="f5f588659c6a58c1ddf047b3a2039449d9c56d1c" translate="yes" xml:space="preserve">
          <source>This returns the evaluation value of performance as the ratio of baseFunc's time over targetFunc's time. If performance is high, this returns a high value.</source>
          <target state="translated">返回性能的评价值,为baseFunc的时间与targetFunc的时间之比。如果性能高,则返回高值。</target>
        </trans-unit>
        <trans-unit id="f6949b897dc88b2038c4de24c6845ff78a726d87" translate="yes" xml:space="preserve">
          <source>This routine allows the runtime to process any special per-thread handling for the GC. This is needed for taking into account any memory that is referenced by non-scanned pointers but is about to be freed. That currently means the array append cache.</source>
          <target state="translated">这个例程允许运行时处理GC的任何特殊的每线程处理。这是需要考虑到任何被非扫描指针引用但即将被释放的内存。目前这意味着数组追加缓存。</target>
        </trans-unit>
        <trans-unit id="08f408a77465437e08636b8afacc3919eb737cd7" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static constructors when called. If full functionality as a D thread is desired, the following function must be called after thread_attachThis:</source>
          <target state="translated">该例程在调用时不会运行线程本地静态构造函数。如果需要作为D线程的全部功能,则必须在thread_attachThis之后调用以下函数。</target>
        </trans-unit>
        <trans-unit id="29f29aed6bb63f2bb71ea82e3247723ea06a2ff1" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static destructors when called. If full functionality as a D thread is desired, the following function must be called after thread_detachThis, particularly if the thread is being detached at some indeterminate time before program termination:</source>
          <target state="translated">该例程被调用时,不会运行线程本地的静态析构器。如果需要作为D线程的全部功能,必须在thread_detachThis之后调用以下函数,特别是当线程在程序终止前的某个不确定的时间被分离时。</target>
        </trans-unit>
        <trans-unit id="e2210ae223e7d7387e02e70f648478605beed923" translate="yes" xml:space="preserve">
          <source>This routine does not run thread-local static destructors when called. If full functionality as a D thread is desired, the following function must be called by the detached thread, particularly if the thread is being detached at some indeterminate time before program termination:</source>
          <target state="translated">该例程被调用时,不会运行线程本地的静态析构器。如果需要作为D线程的全部功能,那么下面的函数必须被分离的线程调用,特别是当线程在程序终止前的某个不确定的时间被分离时。</target>
        </trans-unit>
        <trans-unit id="47826c4895a3860e96fcff125901760f36d390ea" translate="yes" xml:space="preserve">
          <source>This routine is called at various points within concurrency-aware APIs to provide a scheduler a chance to yield execution when using some sort of cooperative multithreading model. If this is not appropriate, such as when each logical thread is backed by a dedicated kernel thread, this routine may be a no-op.</source>
          <target state="translated">这个例程在并发感知API中的不同点被调用,以便在使用某种合作多线程模型时,为调度器提供一个让步执行的机会。如果这样做不合适,比如当每个逻辑线程都有专门的内核线程支持时,这个例程可能是个不可能的选择。</target>
        </trans-unit>
        <trans-unit id="09474f394a8e3b0e692c20bd617ea5e90dedaeea" translate="yes" xml:space="preserve">
          <source>This routine is called by spawn. It is expected to instantiate a new logical thread and run the supplied operation. This thread must call thisInfo.cleanup() when the thread terminates if the scheduled thread is not a kernel thread--all kernel threads will have their ThreadInfo cleaned up automatically by a thread-local destructor.</source>
          <target state="translated">该例程由 spawn 调用。它被期望实例化一个新的逻辑线程并运行提供的操作。如果预定的线程不是内核线程,这个线程必须在线程终止时调用thisInfo.cleanup()--所有的内核线程都会被线程本地的destructor自动清理掉它们的ThreadInfo。</target>
        </trans-unit>
        <trans-unit id="df7600e8a5ce5c3ece105f6eb175adf2b4921aaa" translate="yes" xml:space="preserve">
          <source>This routine is called by the runtime to run module unit tests on startup. The user-supplied unit tester will be called if one has been set, otherwise all unit tests will be run in sequence.</source>
          <target state="translated">这个例程被运行时调用,在启动时运行模块单元测试。如果用户提供的单元测试器已经被设置,则会被调用,否则所有的单元测试都会依次运行。</target>
        </trans-unit>
        <trans-unit id="f8232f4d22c940d991cfdba88d087083634996f9" translate="yes" xml:space="preserve">
          <source>This routine may only be called once per thread instance.</source>
          <target state="translated">每个线程实例只能调用一次该例程。</target>
        </trans-unit>
        <trans-unit id="5878411090cc704550555efc36dc55fc7cf0dd39" translate="yes" xml:space="preserve">
          <source>This routine must be called just prior to resuming all threads.</source>
          <target state="translated">这个例程必须在恢复所有线程之前被调用。</target>
        </trans-unit>
        <trans-unit id="53cb6dbac5dae389abe55edf28bc4109aaf707d5" translate="yes" xml:space="preserve">
          <source>This routine must be preceded by a call to thread_suspendAll.</source>
          <target state="translated">这个例程之前必须调用线程_suspendAll。</target>
        </trans-unit>
        <trans-unit id="cb9fbb3e9cb5f0e9bf7804e870b0289aa3f2cc00" translate="yes" xml:space="preserve">
          <source>This rule precludes any associative or commutative reordering of floating point expressions.</source>
          <target state="translated">这条规则排除了浮点表达式的任何关联或换位重排。</target>
        </trans-unit>
        <trans-unit id="a889c8b355f9d26b9d8f09416cc5c638f19cc1bc" translate="yes" xml:space="preserve">
          <source>This scheduler does no explicit multiplexing, so this is a no-op.</source>
          <target state="translated">这个调度器不做显式复用,所以这是一个无奈之举。</target>
        </trans-unit>
        <trans-unit id="101357cb2b96f04e1249bc15480608aae10e36fd" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;ANSI_X3.4-1968&quot;, &quot;ANSI_X3.4-1986&quot;, &quot;ASCII&quot;, &quot;IBM367&quot;, &quot;ISO646-US&quot;, &quot;ISO_646.irv:1991&quot;, &quot;US-ASCII&quot;, &quot;cp367&quot;, &quot;csASCII&quot; &quot;iso-ir-6&quot;, &quot;us&quot;</source>
          <target state="translated">该方案可识别以下名称。&quot;ANSI_X3.4-1968&quot;、&quot;ANSI_X3.4-1986&quot;、&quot;ASCII&quot;、&quot;IBM367&quot;、&quot;ISO646-US&quot;、&quot;ISO_646.irv:1991&quot;、&quot;US-ASCII&quot;、&quot;cp367&quot;、&quot;csASCII&quot;、&quot;iso-ir-6&quot;、&quot;us&quot;</target>
        </trans-unit>
        <trans-unit id="f19febfbd6afd5a3316429731972510fc66c030b" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;CP819&quot;, &quot;IBM819&quot;, &quot;ISO-8859-1&quot;, &quot;ISO_8859-1&quot;, &quot;ISO_8859-1:1987&quot;, &quot;csISOLatin1&quot;, &quot;iso-ir-100&quot;, &quot;l1&quot;, &quot;latin1&quot;</source>
          <target state="translated">该方案可识别以下名称。&quot;CP819&quot;、&quot;IBM819&quot;、&quot;ISO-8859-1&quot;、&quot;ISO_8859-1&quot;、&quot;ISO_8859-1:1987&quot;、&quot;csISOLatin1&quot;、&quot;iso-ir-100&quot;、&quot;l1&quot;、&quot;latin1&quot;</target>
        </trans-unit>
        <trans-unit id="664030e2fd624069f198afd088ac055c78bd6022" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;Latin 2&quot;, &quot;ISO-8859-2&quot;, &quot;ISO_8859-2&quot;, &quot;ISO_8859-2:1999&quot;, &quot;Windows-28592&quot;</source>
          <target state="translated">该方案可识别以下名称。&quot;拉丁语2&quot;、&quot;ISO-8859-2&quot;、&quot;ISO_8859-2&quot;、&quot;ISO_8859-2:1999&quot;、&quot;Windows-28592&quot;</target>
        </trans-unit>
        <trans-unit id="ade669f4e0479a561d644cf792664ebe8c58b7f3" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;UTF-16LE&quot; (little-endian architecture only) &quot;UTF-16BE&quot; (big-endian architecture only)</source>
          <target state="translated">该方案可识别以下名称。&quot;UTF-16LE&quot;(仅小字段结构)&quot;UTF-16BE&quot;(仅大字段结构)</target>
        </trans-unit>
        <trans-unit id="270ab7b02be7a6bde21e8c3a620aecc09d063e99" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;UTF-32LE&quot; (little-endian architecture only) &quot;UTF-32BE&quot; (big-endian architecture only)</source>
          <target state="translated">该方案可识别以下名称。&quot;UTF-32LE&quot;(仅小字段结构)&quot;UTF-32BE&quot;(仅大字段结构)</target>
        </trans-unit>
        <trans-unit id="bced95f493391cc0c075fc9dc4db4804161c397b" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;UTF-8&quot;</source>
          <target state="translated">该方案可识别以下名称。&quot;UTF-8&quot;</target>
        </trans-unit>
        <trans-unit id="c947e47deb508176a3928ec96e6e69a35c074c39" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;windows-1250&quot;</source>
          <target state="translated">该方案可识别以下名称。&quot;windows-1250&quot;</target>
        </trans-unit>
        <trans-unit id="a3402a215c1529c61ece58d5fce0d4798222c23b" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;windows-1251&quot;</source>
          <target state="translated">该方案可识别以下名称。&quot;windows-1251&quot;</target>
        </trans-unit>
        <trans-unit id="ded1d5e22b73a1f4af6cf6f2d1b37c6532f710c1" translate="yes" xml:space="preserve">
          <source>This scheme recognises the following names: &quot;windows-1252&quot;</source>
          <target state="translated">该方案可识别以下名称。&quot;windows-1252&quot;</target>
        </trans-unit>
        <trans-unit id="d2dfa0f433df9d45239ecc782eb245fb19fd21d2" translate="yes" xml:space="preserve">
          <source>This seed function gives 2^w starting points (the lowest w bits of the value provided will be used). To allow the RNG to be started in any one of its internal states use the seed overload taking an InputRange.</source>
          <target state="translated">这个种子函数给出了2^w个起始点(将使用所提供值的最低w位)。要允许RNG在其任何一个内部状态下启动,使用种子重载取一个InputRange。</target>
        </trans-unit>
        <trans-unit id="94a54cee12f5bd9b51532e5452c5a4a484e54378" translate="yes" xml:space="preserve">
          <source>This sets the current source line number to &lt;a href=&quot;#IntegerLiteral&quot;&gt;&lt;i&gt;IntegerLiteral&lt;/i&gt;&lt;/a&gt;, and optionally the current source file name to &lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt;, beginning with the next line of source text.</source>
          <target state="translated">这&lt;a href=&quot;#IntegerLiteral&quot;&gt;&lt;i&gt;会将&lt;/i&gt;&lt;/a&gt;当前源行号设置为&lt;i&gt;IntegerLiteral&lt;/i&gt;，还可以将当前源文件名设置为&lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt;，从源文本的下一行开始。</target>
        </trans-unit>
        <trans-unit id="4be50da9e108662a57689b8ace75d7581f5375c8" translate="yes" xml:space="preserve">
          <source>This should be used to avoid dead-locks when the init expression waits for the result of another thread that might also call initOnce. Use with care.</source>
          <target state="translated">当init表达式等待另一个可能也会调用initOnce的线程的结果时,应该使用这个来避免死锁。请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="fe2d190a50345872c262cf5d3029bd911309ce44" translate="yes" xml:space="preserve">
          <source>This simply runs op directly, since no real scheduling is needed by this approach.</source>
          <target state="translated">这只是直接运行op,因为这种方法不需要真正的调度。</target>
        </trans-unit>
        <trans-unit id="c1f36fea04df939005e7ae3b3481769a9d3881d4" translate="yes" xml:space="preserve">
          <source>This software is distributed on an &quot;AS IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.</source>
          <target state="translated">本软件是在 &quot;原样 &quot;的基础上发布的,没有任何形式的明示或暗示的保证。</target>
        </trans-unit>
        <trans-unit id="cce69bf7cc8f89b41a07f3aa1ac572a9417bd871" translate="yes" xml:space="preserve">
          <source>This software is licensed as described in the file COPYING, which you should have received as part of this distribution. The terms are also available at &lt;a href=&quot;http://curl.haxx.se/docs/copyright.html&quot;&gt;http://curl.haxx.se/docs/copyright.html&lt;/a&gt;.</source>
          <target state="translated">该软件已按照文件COPYING中的说明获得许可，您应在分发中获得该软件。这些条款也可以从&lt;a href=&quot;http://curl.haxx.se/docs/copyright.html&quot;&gt;http://curl.haxx.se/docs/copyright.html获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a35b5b2fcea0cd5e1372a50fcdb64c90186c1d8" translate="yes" xml:space="preserve">
          <source>This string mixin generator allows one to create tagged class reference inside structs and classes.</source>
          <target state="translated">这个字符串混搭生成器允许你在结构和类中创建标签类引用。</target>
        </trans-unit>
        <trans-unit id="89b88529e193e34ffae54fa1436ac384d8a51298" translate="yes" xml:space="preserve">
          <source>This string mixin generator allows one to create tagged pointers inside structs and classes.</source>
          <target state="translated">这个字符串混搭生成器允许我们在结构和类中创建标签指针。</target>
        </trans-unit>
        <trans-unit id="fa44f8a37539dd0c481f757fd2c6c916db973189" translate="yes" xml:space="preserve">
          <source>This struct encapsulates all functionality related to the underlying runtime module for the calling context.</source>
          <target state="translated">这个结构封装了与调用上下文的底层运行时模块相关的所有功能。</target>
        </trans-unit>
        <trans-unit id="93192c346919e8c29838bf372e377e45a2bf11e8" translate="yes" xml:space="preserve">
          <source>This struct encapsulates all garbage collection functionality for the D programming language.</source>
          <target state="translated">这个结构封装了D编程语言的所有垃圾收集功能。</target>
        </trans-unit>
        <trans-unit id="c0b4243b7a8d23b55f18ae71ce114f500fc9e037" translate="yes" xml:space="preserve">
          <source>This struct is needed for TemplateInstance to be the key in an associative array. Fixing &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=15812&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=15812&lt;/a&gt; and &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=15813&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=15813&lt;/a&gt; would make it unnecessary.</source>
          <target state="translated">TemplateInstance要成为关联数组中的键，需要此结构。修复&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=15812&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=15812&lt;/a&gt;和&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=15813&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=15813&lt;/a&gt;将使其不必要。</target>
        </trans-unit>
        <trans-unit id="ba71ab789db33d9d41fe31ac671b08fc2ff9a27c" translate="yes" xml:space="preserve">
          <source>This struct is not intended to be created in user code directly; use the &lt;a href=&quot;#decoder&quot;&gt;&lt;code&gt;decoder&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">不应直接在用户代码中创建此结构。请改用&lt;a href=&quot;#decoder&quot;&gt; &lt;code&gt;decoder&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="c808480f164a9ce60af47373128f270ece2f4c37" translate="yes" xml:space="preserve">
          <source>This struct is not intended to be created in user code directly; use the &lt;a href=&quot;#encoder&quot;&gt;&lt;code&gt;encoder&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">不应直接在用户代码中创建此结构。请改用&lt;a href=&quot;#encoder&quot;&gt; &lt;code&gt;encoder&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="bf5472fdbac439d01e7f55c549978ae9fe484216" translate="yes" xml:space="preserve">
          <source>This struct takes two ranges, &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt;, and creates a view of &lt;code&gt;source&lt;/code&gt; as if its elements were reordered according to &lt;code&gt;indices&lt;/code&gt;. &lt;code&gt;indices&lt;/code&gt; may include only a subset of the elements of &lt;code&gt;source&lt;/code&gt; and may also repeat elements.</source>
          <target state="translated">此结构采用两个范围， &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;indices&lt;/code&gt; ，并创建 &lt;code&gt;source&lt;/code&gt; 视图，就好像其元素根据 &lt;code&gt;indices&lt;/code&gt; 重新排序一样。 &lt;code&gt;indices&lt;/code&gt; 可能只包含 &lt;code&gt;source&lt;/code&gt; 元素的子集，也可能重复元素。</target>
        </trans-unit>
        <trans-unit id="321a83cb6c2189fda5f0740151e0077549cc346c" translate="yes" xml:space="preserve">
          <source>This struct uses interior pointers for callbacks. Only allocate it on the stack if you never move or copy it. This also means passing by reference when passing Curl to other functions. Otherwise always allocate on the heap.</source>
          <target state="translated">这个结构使用内部指针进行回调。只有当你从不移动或复制它时,才会在栈上分配它。这也意味着在将Curl传递给其他函数时通过引用来传递。否则总是在堆上分配。</target>
        </trans-unit>
        <trans-unit id="9b4fde43b38a0e50f9025a0370a796c10515fd4f" translate="yes" xml:space="preserve">
          <source>This template defines a simple struct to represent bitwise OR combinations of enum values. It can be used if all the enum values are integral constants with a bit count of at most 1, or if the &lt;code&gt;unsafe&lt;/code&gt; parameter is explicitly set to Yes. This is much safer than using the enum itself to store the OR combination, which can produce surprising effects like this:</source>
          <target state="translated">该模板定义了一个简单的结构来表示枚举值的按位或组合。如果所有枚举值都是位计数最多为1的整数常量，或者如果 &lt;code&gt;unsafe&lt;/code&gt; 参数显式设置为Yes，则可以使用它。这比使用枚举本身存储OR组合要安全得多，OR组合可以产生如下所示的令人惊讶的效果：</target>
        </trans-unit>
        <trans-unit id="ed7a16b135cb8df8ef4a3a540a84c393a96223c7" translate="yes" xml:space="preserve">
          <source>This template evaluates if the passed &lt;code&gt;LogLevel&lt;/code&gt; is active. The previously described version statements are used to decide if the &lt;code&gt;LogLevel&lt;/code&gt; is active. The version statements only influence the compile unit they are used with, therefore this function can only disable logging this specific compile unit.</source>
          <target state="translated">此模板评估传递的 &lt;code&gt;LogLevel&lt;/code&gt; 是否处于活动状态。先前描述的版本语句用于确定 &lt;code&gt;LogLevel&lt;/code&gt; 是否处于活动状态。版本语句仅影响与它们一起使用的编译单元，因此该功能只能禁用记录该特定编译单元。</target>
        </trans-unit>
        <trans-unit id="bf1947986c71233faa898611680a1e6ac855b2d0" translate="yes" xml:space="preserve">
          <source>This template is used instead of &lt;code&gt;cmpTimeUnits&lt;/code&gt; because exceptions can't be thrown at compile time and &lt;code&gt;cmpTimeUnits&lt;/code&gt; must enforce that the strings it's given are valid time unit strings. This template uses a template constraint instead.</source>
          <target state="translated">使用此模板代替 &lt;code&gt;cmpTimeUnits&lt;/code&gt; ,因为在编译时不能引发异常，并且 &lt;code&gt;cmpTimeUnits&lt;/code&gt; 必须强制其给出的字符串是有效的时间单位字符串。该模板改为使用模板约束。</target>
        </trans-unit>
        <trans-unit id="721049b2d1b7c17de4953e979423c5d9509ce4dc" translate="yes" xml:space="preserve">
          <source>This template provides the global &lt;code&gt;printf&lt;/code&gt;-style log functions with the &lt;code&gt;LogLevel&lt;/code&gt; is encoded in the function name.</source>
          <target state="translated">该模板提供了全局 &lt;code&gt;printf&lt;/code&gt; 样式的日志函数，并且 &lt;code&gt;LogLevel&lt;/code&gt; 编码在函数名称中。</target>
        </trans-unit>
        <trans-unit id="95faefdf67a9c230f11cf5997976bb55047f6e84" translate="yes" xml:space="preserve">
          <source>This template provides the global log functions with the &lt;code&gt;LogLevel&lt;/code&gt; is encoded in the function name.</source>
          <target state="translated">该模板提供了全局日志功能，其中 &lt;code&gt;LogLevel&lt;/code&gt; 编码在函数名称中。</target>
        </trans-unit>
        <trans-unit id="a660b19c7d186bc39b4f6c265fe64cdd5e100bb7" translate="yes" xml:space="preserve">
          <source>This template provides the log functions for the &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;class&lt;/code&gt; with the &lt;code&gt;LogLevel&lt;/code&gt; encoded in the function name.</source>
          <target state="translated">该模板为 &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;class&lt;/code&gt; 提供了日志功能，并在函数名称中编码了 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="649dff2094ef00bc31b9858d34965ac9fc9b644e" translate="yes" xml:space="preserve">
          <source>This template returns the &lt;code&gt;LogLevel&lt;/code&gt; named &quot;logLevel&quot; of type &lt;code&gt;LogLevel&lt;/code&gt; defined in a user defined module where the filename has the suffix &quot;loggerconfig.d&quot;. This &lt;code&gt;LogLevel&lt;/code&gt; sets the minimal &lt;code&gt;LogLevel&lt;/code&gt; of the module.</source>
          <target state="translated">这个模板返回 &lt;code&gt;LogLevel&lt;/code&gt; 类型的名为&amp;ldquo;日志级别&amp;rdquo; &lt;code&gt;LogLevel&lt;/code&gt; 在文件名的后缀为&amp;ldquo;loggerconfig.d&amp;rdquo;用户自定义模块中定义。此 &lt;code&gt;LogLevel&lt;/code&gt; 设置模块的最小 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="965d72a63b18d413b5715e4a973525a9b52a396c" translate="yes" xml:space="preserve">
          <source>This time zone's offset from UTC with west of UTC being negative (it is added to UTC to get the adjusted time).</source>
          <target state="translated">这个时区与UTC的偏移,UTC以西为负值(与UTC相加得到调整后的时间)。</target>
        </trans-unit>
        <trans-unit id="b7456f76fa17160c9c0587cc7d1c50d1dbf69825" translate="yes" xml:space="preserve">
          <source>This type is only used by the interpreter.</source>
          <target state="translated">此类型仅由解释器使用。</target>
        </trans-unit>
        <trans-unit id="bfaad68c51bc3ac5b55f9911a6ad3e337bcd2001" translate="yes" xml:space="preserve">
          <source>This type is returned by the module unit test handler to indicate testing results.</source>
          <target state="translated">该类型由模块单元测试处理程序返回,用于指示测试结果。</target>
        </trans-unit>
        <trans-unit id="fe05b2c35b150ac51e9c5a58b58b8bdf4deb8005" translate="yes" xml:space="preserve">
          <source>This uniformly outdents the text as much as possible. Whitespace-only lines are always converted to blank lines.</source>
          <target state="translated">这就尽可能地统一了文字的轮廓。只用空格的行总是被转换为空行。</target>
        </trans-unit>
        <trans-unit id="1b0c762aaeeda93028fb7042712ade026276dad3" translate="yes" xml:space="preserve">
          <source>This unittest verifies that &lt;code&gt;myFunc&lt;/code&gt; contains only &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt; code. Although this can also be accomplished by attaching these attributes to &lt;code&gt;myFunc&lt;/code&gt; itself, that would prevent &lt;code&gt;myFunc&lt;/code&gt; from being instantiated with types &lt;code&gt;T&lt;/code&gt; that have &lt;code&gt;@system&lt;/code&gt; or throwing code in their &lt;code&gt;opAssign&lt;/code&gt; method, or other methods that &lt;code&gt;myFunc&lt;/code&gt; may call. The above idiom allows &lt;code&gt;myFunc&lt;/code&gt; to be instantiated with such types, yet at the same time verify that the &lt;code&gt;@system&lt;/code&gt; and throwing behavior is not introduced by the code within &lt;code&gt;myFunc&lt;/code&gt; itself.</source>
          <target state="translated">这个单元测试验证的是 &lt;code&gt;myFunc&lt;/code&gt; 的只包含 &lt;code&gt;@safe&lt;/code&gt; ， &lt;code&gt;nothrow&lt;/code&gt; 的代码。尽管这也可以通过将这些属性附加到 &lt;code&gt;myFunc&lt;/code&gt; 本身来实现，但是这将阻止使用类型为 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;myFunc&lt;/code&gt; 实例化T，这些类型T具有 &lt;code&gt;@system&lt;/code&gt; 或在其 &lt;code&gt;opAssign&lt;/code&gt; 方法或 &lt;code&gt;myFunc&lt;/code&gt; 可能调用的其他方法中抛出代码。上面的惯用法允许使用此类类型实例化 &lt;code&gt;myFunc&lt;/code&gt; ，但同时验证 &lt;code&gt;myFunc&lt;/code&gt; 自身内的代码未引入 &lt;code&gt;@system&lt;/code&gt; 和throwing行为。</target>
        </trans-unit>
        <trans-unit id="6d997c4734cfeb63e2eb24775621ef1b07f282bd" translate="yes" xml:space="preserve">
          <source>This used to be in druntime, but contained a reference to Dmain which didn't work when druntime was made into a dll and was linked to a program, such as a C++ program, that didn't have a Dmain.</source>
          <target state="translated">这以前是在druntime中,但包含了对Dmain的引用,当druntime被制作成dll并链接到一个没有Dmain的程序,比如C++程序时,这个引用就不起作用了。</target>
        </trans-unit>
        <trans-unit id="630760402237caac7d04f49e204e2dbcf15d6147" translate="yes" xml:space="preserve">
          <source>This uses the underlying C calls to adjust the time rather than using specific D code based off of system settings to calculate the time such as &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt; do. That also means that it will use whatever the current time zone is on the system, even if the system's time zone changes while the program is running.</source>
          <target state="translated">这将使用基础C调用来调整时间，而不是根据系统设置使用特定的D代码来计算时间，例如&lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt;。这也意味着它将使用系统上当前的时区，即使在程序运行时系统的时区发生了变化。</target>
        </trans-unit>
        <trans-unit id="6c0591e1a6e9bca143fbe15c58217719c4322b5a" translate="yes" xml:space="preserve">
          <source>This value is set at startup time of the application. It's safe to use early in the start process, like in shared module constructors and initialization of the D runtime itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222ffc2d96135317dcd7f4e64432ee48d6b47aca" translate="yes" xml:space="preserve">
          <source>This variable sets the Scheduler behavior within this program. Typically, when setting a Scheduler, scheduler.start() should be called in main. This routine will not return until program execution is complete.</source>
          <target state="translated">这个变量设置了这个程序中的Scheduler行为。通常情况下,当设置一个Scheduler时,scheduler.start()应该在main中被调用。这个例程在程序执行完成之前不会返回。</target>
        </trans-unit>
        <trans-unit id="350617ff126e41fac846ab28e60173b84f0e36ad" translate="yes" xml:space="preserve">
          <source>This version does a merge even if the deco is already computed. Necessary for types that have a deco, but are not merged.</source>
          <target state="translated">这个版本即使已经计算了deco,也会进行合并。对于那些有deco但没有合并的类型来说是必要的。</target>
        </trans-unit>
        <trans-unit id="ca9704bfd218246a881b4d0fdbb145b4f7ed6074" translate="yes" xml:space="preserve">
          <source>This version manages its own read buffer, which means one memory allocation per call. If you are not retaining a reference to the read data, consider the &lt;code&gt;File.readln(buf)&lt;/code&gt; version, which may offer better performance as it can reuse its read buffer.</source>
          <target state="translated">此版本管理自己的读取缓冲区，这意味着每个调用分配一个内存。如果您不保留对读取数据的引用，请考虑 &lt;code&gt;File.readln(buf)&lt;/code&gt; 版本，该版本可能会提供更好的性能，因为它可以重用其读取缓冲区。</target>
        </trans-unit>
        <trans-unit id="4730e8481a2bf9923ca7e3e571c62d109e3d3d83" translate="yes" xml:space="preserve">
          <source>This version manages its own read buffer, which means one memory allocation per call. If you are not retaining a reference to the read data, consider the &lt;code&gt;readln(buf)&lt;/code&gt; version, which may offer better performance as it can reuse its read buffer.</source>
          <target state="translated">此版本管理自己的读取缓冲区，这意味着每个调用分配一个内存。如果您不保留对读取数据的引用，请考虑使用 &lt;code&gt;readln(buf)&lt;/code&gt; 版本，该版本可能会提供更好的性能，因为它可以重用其读取缓冲区。</target>
        </trans-unit>
        <trans-unit id="5d0ffd1140b6bdea2f557dabf439528af74c3f10" translate="yes" xml:space="preserve">
          <source>This version replaces all of the matches found in &lt;code&gt;input&lt;/code&gt;, see &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; to replace the first match only.</source>
          <target state="translated">此版本将替换 &lt;code&gt;input&lt;/code&gt; 中找到的所有匹配项，请参见&lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt;以仅替换第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="58e4144e8bfe93d9e0c64e9b4fdfd2a6a17871d2" translate="yes" xml:space="preserve">
          <source>This version replaces the first match in &lt;code&gt;input&lt;/code&gt;, see &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; to replace the all of the matches.</source>
          <target state="translated">此版本替换 &lt;code&gt;input&lt;/code&gt; 中的第一个匹配项，请参见&lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt;替换所有匹配项。</target>
        </trans-unit>
        <trans-unit id="ff770a07d7fe1b2d8549b2bfe1914ce344e62c1a" translate="yes" xml:space="preserve">
          <source>This way negative spans until 10, then positive until 50, then negative until 60, then positive until 61, and so on. As seen this provides a space-efficient storage of highly redundant data that comes in long runs. A description which Unicode &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; properties fit nicely. The technique itself could be seen as a variation on &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;RLE encoding&lt;/a&gt;.</source>
          <target state="translated">这样，负数将一直扩展到10，然后正数直到50，然后负数直到60，再正数直到61，依此类推。如图所示，这为长期使用的高冗余数据提供了节省空间的存储方式。Unicode &lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;属性非常适合的描述。该技术本身可以看作是&lt;a href=&quot;https://en.wikipedia.org/wiki/Run-length_encoding&quot;&gt;RLE编码的&lt;/a&gt;一种变体。</target>
        </trans-unit>
        <trans-unit id="9d7e80d5423ced31332c30ecab9af5e8333da350" translate="yes" xml:space="preserve">
          <source>This will print a message to the &lt;code&gt;stderr&lt;/code&gt; device. The message will contain the filename, the line number, the name of the surrounding function, the time and the message.  More complex log call can go along the lines like:</source>
          <target state="translated">这会将消息打印到 &lt;code&gt;stderr&lt;/code&gt; 设备。该消息将包含文件名，行号，周围函数的名称，时间和消息。更复杂的日志调用可以遵循以下方式：</target>
        </trans-unit>
        <trans-unit id="7bbc11a96caae26edcdd1170876c310429d5242c" translate="yes" xml:space="preserve">
          <source>This wrapper function documents commitment on the part of the caller that the appropriate steps have been taken to avoid whatever conditions may trigger an exception during the evaluation of &lt;code&gt;expr&lt;/code&gt;. If it turns out that the expression</source>
          <target state="translated">该包装函数记录了调用者方面的承诺，即已采取适当的步骤来避免在评估 &lt;code&gt;expr&lt;/code&gt; 期间可能触发异常的任何条件。如果事实证明</target>
        </trans-unit>
        <trans-unit id="e1c33135ff86972a6ed3b9c446ccc19496208487" translate="yes" xml:space="preserve">
          <source>Though any arbitrary D code is allowed in the &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; contract blocks, their only function should be to verify incoming and outgoing data. It is important to ensure that the code has no side effects, and that the release version of the code will not depend on any effects of the code. For a release build of the code, &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; contracts are not inserted.</source>
          <target state="translated">尽管 &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 合同块中允许使用任意D代码，但它们的唯一功能应该是验证传入和传出数据。重要的是要确保代码没有副作用，并且代码的发行版本将不依赖于代码的任何影响。对于代码的发布版本， &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 合同不被插入。</target>
        </trans-unit>
        <trans-unit id="820043383b2d6abecf10763532e4c82a66d9247e" translate="yes" xml:space="preserve">
          <source>Thread &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">螺纹 &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04c6d1513db9ed02d67521add8386801a5b34539" translate="yes" xml:space="preserve">
          <source>Thread &lt;strong id=&quot;thread_attachThis&quot;&gt;thread_attachThis&lt;/strong&gt;();</source>
          <target state="translated">线程&lt;strong id=&quot;thread_attachThis&quot;&gt;thread_attachThis&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="1f330e4c64cef67c5a0e2c92e690f07993e4d060" translate="yes" xml:space="preserve">
          <source>Thread Local Redirection</source>
          <target state="translated">线程本地重定向</target>
        </trans-unit>
        <trans-unit id="84f19dfef7c6980d5ce82fb1aaa5685b925bb278" translate="yes" xml:space="preserve">
          <source>Thread creation and management.</source>
          <target state="translated">线程创建和管理。</target>
        </trans-unit>
        <trans-unit id="77ad25b2a19fb9a3d515d2ce54db487fb84795e8" translate="yes" xml:space="preserve">
          <source>Thread-local memory locations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ec6af76df19383c52b8f66c7369b7f13dd32d0" translate="yes" xml:space="preserve">
          <source>ThreadError if the resume operation fails for a running thread.</source>
          <target state="translated">如果正在运行的线程恢复操作失败,则出现ThreadError。</target>
        </trans-unit>
        <trans-unit id="9e4b42c8be29f1c6cbd83e3ca1f8a1f5acbf80c3" translate="yes" xml:space="preserve">
          <source>ThreadError if the suspend operation fails for a running thread.</source>
          <target state="translated">如果一个正在运行的线程的暂停操作失败,则出现ThreadError。</target>
        </trans-unit>
        <trans-unit id="2464c0788d3d18de94ad9135c7e0e048ee525f11" translate="yes" xml:space="preserve">
          <source>ThreadException if the operation fails. Any exception not handled by the joined thread.</source>
          <target state="translated">如果操作失败,则出现ThreadException。任何未被加入的线程处理的异常。</target>
        </trans-unit>
        <trans-unit id="988c5cc71109eafcf99c8ab21fce21fe97ec770d" translate="yes" xml:space="preserve">
          <source>ThreadException if the thread fails to start.</source>
          <target state="translated">如果线程未能启动,则出现ThreadException。</target>
        </trans-unit>
        <trans-unit id="1cf40193fb824b4f6ad8cb26327d035d6a028786" translate="yes" xml:space="preserve">
          <source>ThreadID &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">ThreadID &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7ed723eeac4df5e125f2b0678ab67abc0922b8b" translate="yes" xml:space="preserve">
          <source>ThreadID &lt;code&gt;tid&lt;/code&gt;</source>
          <target state="translated">线程ID &lt;code&gt;tid&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f726da94b243f6df0f10d0a1927ff4f089c0ce2" translate="yes" xml:space="preserve">
          <source>Three Valued Logic on Wikipedia</source>
          <target state="translated">维基百科上的三值逻辑</target>
        </trans-unit>
        <trans-unit id="041271075c6e4b6b2987479db37b359cf95b9df5" translate="yes" xml:space="preserve">
          <source>Throw Statement</source>
          <target state="translated">抛出声明</target>
        </trans-unit>
        <trans-unit id="a99ee7b003bda4ab0516b744e02d6d8979581b73" translate="yes" xml:space="preserve">
          <source>Throw a D object.</source>
          <target state="translated">抛出一个D对象。</target>
        </trans-unit>
        <trans-unit id="811a07f7fa5dfaadc18e11fed4ce882015f391d7" translate="yes" xml:space="preserve">
          <source>Throw a MailboxFull exception.</source>
          <target state="translated">抛出一个MailboxFull异常。</target>
        </trans-unit>
        <trans-unit id="57315ab12c3532377a724ba12831fde623b6e79a" translate="yes" xml:space="preserve">
          <source>ThrowOnError &lt;code&gt;throwOnError&lt;/code&gt;</source>
          <target state="translated">ThrowOnError &lt;code&gt;throwOnError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abf11297f412ee4fff55514bb434f634e293565" translate="yes" xml:space="preserve">
          <source>Throwable</source>
          <target state="translated">Throwable</target>
        </trans-unit>
        <trans-unit id="d49a4962de645ce124e96bde4ce448c93911dad9" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;e1&lt;/code&gt;</source>
          <target state="translated">可抛 &lt;code&gt;e1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bea49f69b95bd4c7986b53182b30e586c968d01" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;e2&lt;/code&gt;</source>
          <target state="translated">可抛 &lt;code&gt;e2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c3508159ea74e593b1f8f83bb63c996e12b6d4b0" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">可抛 &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="181dadb1ebd21977fc70a4734b2c296e2903f089" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;ex&lt;/code&gt;</source>
          <target state="translated">投掷 &lt;code&gt;ex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bd2954e71e7cefaff13ce8e463c354cbaac4f4d" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;next&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 抛出</target>
        </trans-unit>
        <trans-unit id="7daca6bf6d530d9a8e0dd28e96710df7d9ed3bc1" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;o&lt;/code&gt;</source>
          <target state="translated">可投掷 &lt;code&gt;o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5722462feb7ab62b6beb25519312de887c65befc" translate="yes" xml:space="preserve">
          <source>Throwable &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">可投掷 &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3bf36d01f399602316eb8550fa8ea67915755f2" translate="yes" xml:space="preserve">
          <source>Throwable &lt;strong id=&quot;__dmd_begin_catch&quot;&gt;__dmd_begin_catch&lt;/strong&gt;(_Unwind_Exception* exceptionObject);</source>
          <target state="translated">可&lt;strong id=&quot;__dmd_begin_catch&quot;&gt;抛出__dmd_begin_catch&lt;/strong&gt;（_Unwind_Exception * exceptionObject）;</target>
        </trans-unit>
        <trans-unit id="ad43afcb02ba70a606fef1b16e48cd558c53facc" translate="yes" xml:space="preserve">
          <source>Throwable &lt;strong id=&quot;_d_newThrowable&quot;&gt;_d_newThrowable&lt;/strong&gt;(const TypeInfo_Class ci);</source>
          <target state="translated">Throwable &lt;strong id=&quot;_d_newThrowable&quot;&gt;_d_newThrowable&lt;/strong&gt;（const TypeInfo_Class ci）;</target>
        </trans-unit>
        <trans-unit id="8b0b716c6a4da9650ea963345d9f03fa5190cefb" translate="yes" xml:space="preserve">
          <source>Throwable &lt;strong id=&quot;bypassedException&quot;&gt;bypassedException&lt;/strong&gt;;</source>
          <target state="translated">抛出Throwable &lt;strong id=&quot;bypassedException&quot;&gt;异常&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="aeb265277be0ed46b320d4bee447dd1287a5e503" translate="yes" xml:space="preserve">
          <source>Throwable that is at the start of the chain; null if both &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; are null</source>
          <target state="translated">链开始时的可抛；如果 &lt;code&gt;e1&lt;/code&gt; 和 &lt;code&gt;e2&lt;/code&gt; 均为null ，则返回null</target>
        </trans-unit>
        <trans-unit id="329a88fde5ec9ba12b2a662751a9fce532d8dd80" translate="yes" xml:space="preserve">
          <source>Throwable.TraceInfo &lt;strong id=&quot;_d_traceContext&quot;&gt;_d_traceContext&lt;/strong&gt;(void* ptr = null);</source>
          <target state="translated">Throwable.TraceInfo &lt;strong id=&quot;_d_traceContext&quot;&gt;_d_traceContext&lt;/strong&gt;（void * ptr = null）;</target>
        </trans-unit>
        <trans-unit id="d96037e204c51c808042650da8a6d05d2f5c0fd2" translate="yes" xml:space="preserve">
          <source>Throwable.TraceInfo &lt;strong id=&quot;defaultTraceHandler&quot;&gt;defaultTraceHandler&lt;/strong&gt;(void* ptr = null);</source>
          <target state="translated">Throwable.TraceInfo &lt;strong id=&quot;defaultTraceHandler&quot;&gt;defaultTraceHandler&lt;/strong&gt;（void * ptr = null）;</target>
        </trans-unit>
        <trans-unit id="b63ae3eec5f24e1fd1c64ed1289ae0f818654562" translate="yes" xml:space="preserve">
          <source>Thrown during CData constructor</source>
          <target state="translated">在CData构造函数中抛出</target>
        </trans-unit>
        <trans-unit id="84c89a52cbdc1ec28b439af4dc893b9b91ec7840" translate="yes" xml:space="preserve">
          <source>Thrown during Comment constructor</source>
          <target state="translated">在Comment构造函数中抛出</target>
        </trans-unit>
        <trans-unit id="35729b43847e49168c803e1563bb3cc31ad4a437" translate="yes" xml:space="preserve">
          <source>Thrown during ProcessingInstruction constructor</source>
          <target state="translated">在ProcessingInstruction构造函数中抛出</target>
        </trans-unit>
        <trans-unit id="3f251cad502f4c0805742ab01450a6da94826b64" translate="yes" xml:space="preserve">
          <source>Thrown during Text constructor</source>
          <target state="translated">在Text构造函数中抛出</target>
        </trans-unit>
        <trans-unit id="c92a5bfc11a555b169a0a27ab74990b80319893a" translate="yes" xml:space="preserve">
          <source>Thrown during XMLInstruction constructor</source>
          <target state="translated">在XMLInstruction构造函数中抛出</target>
        </trans-unit>
        <trans-unit id="6bb5956cc1d8626088d792baf8b347e8b18e899c" translate="yes" xml:space="preserve">
          <source>Thrown during check()</source>
          <target state="translated">在check()过程中抛出</target>
        </trans-unit>
        <trans-unit id="86110bc7ee50ca60178c35406ca162fd7743b4e8" translate="yes" xml:space="preserve">
          <source>Thrown during decode()</source>
          <target state="translated">在decode()期间抛出</target>
        </trans-unit>
        <trans-unit id="c5aba430c55d417364422428a9f362472f91604b" translate="yes" xml:space="preserve">
          <source>Thrown if I/O errors happen.</source>
          <target state="translated">当发生I/O错误时抛出。</target>
        </trans-unit>
        <trans-unit id="6372ea6ded1ced271f30bfc67bb4f1080dda6330" translate="yes" xml:space="preserve">
          <source>Thrown if a linked thread has terminated.</source>
          <target state="translated">如果一个链接线程已经终止,则抛出。</target>
        </trans-unit>
        <trans-unit id="91f2c1021f927e931dd4a9bfa5d4cb0938ead33e" translate="yes" xml:space="preserve">
          <source>Thrown if a message was sent to a thread via &lt;a href=&quot;std_concurrency#prioritySend&quot;&gt;&lt;code&gt;std.concurrency.prioritySend&lt;/code&gt;&lt;/a&gt; and the receiver does not have a handler for a message of this type.</source>
          <target state="translated">如果通过&lt;a href=&quot;std_concurrency#prioritySend&quot;&gt; &lt;code&gt;std.concurrency.prioritySend&lt;/code&gt; &lt;/a&gt;将消息发送到线程，并且接收方没有此类消息的处理程序，则抛出该异常。</target>
        </trans-unit>
        <trans-unit id="6ae8d47d33d71e65b4335fb509b682ebfeb58c62" translate="yes" xml:space="preserve">
          <source>Thrown if comparing with wrong type</source>
          <target state="translated">如果与错误的类型进行比较,则抛出</target>
        </trans-unit>
        <trans-unit id="7cf0300c5ba15c42524d147daa6bffbdb893c34b" translate="yes" xml:space="preserve">
          <source>Thrown if errors that set &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms679360.aspx&quot;&gt; &lt;code&gt;GetLastError&lt;/code&gt;&lt;/a&gt; occur.</source>
          <target state="translated">如果发生设置&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms679360.aspx&quot;&gt; &lt;code&gt;GetLastError&lt;/code&gt; 的&lt;/a&gt;错误，则抛出该异常。</target>
        </trans-unit>
        <trans-unit id="be91161c0d8489393a798c2ad672cda178b1f826" translate="yes" xml:space="preserve">
          <source>Thrown if errors that set &lt;code&gt;errno&lt;/code&gt; occur.</source>
          <target state="translated">如果设置 &lt;code&gt;errno&lt;/code&gt; 的错误发生，则抛出该异常。</target>
        </trans-unit>
        <trans-unit id="d5a85f8afbd62c38c087ce3656815cdc461fe61e" translate="yes" xml:space="preserve">
          <source>Thrown in three cases:</source>
          <target state="translated">扔了三箱。</target>
        </trans-unit>
        <trans-unit id="a1a94163addf8ed9aeb98b45ad38a50ceb43b8d6" translate="yes" xml:space="preserve">
          <source>Thrown objects derived from</source>
          <target state="translated">抛出的物体来自于</target>
        </trans-unit>
        <trans-unit id="1b617604610b1e1a6d54699cece22c41ffbacef5" translate="yes" xml:space="preserve">
          <source>Thrown on a range error.</source>
          <target state="translated">扔在一个范围错误。</target>
        </trans-unit>
        <trans-unit id="b565d21ffa55aff8807f89b443feb9fd6f91d085" translate="yes" xml:space="preserve">
          <source>Thrown on a switch error.</source>
          <target state="translated">抛出的开关错误。</target>
        </trans-unit>
        <trans-unit id="e2a9b6920e3c3f67cbd3cb688ecd5615035c5221" translate="yes" xml:space="preserve">
          <source>Thrown on a unicode conversion error.</source>
          <target state="translated">在unicode转换错误时抛出。</target>
        </trans-unit>
        <trans-unit id="7dea37b71e3f163a1d2f5bf641ee7dc124d30397" translate="yes" xml:space="preserve">
          <source>Thrown on an assert error.</source>
          <target state="translated">在断言错误时抛出。</target>
        </trans-unit>
        <trans-unit id="86c6bfd21c61151f3be7775d602fc143c1a57943" translate="yes" xml:space="preserve">
          <source>Thrown on an invalid memory operation.</source>
          <target state="translated">抛出无效的内存操作。</target>
        </trans-unit>
        <trans-unit id="16e3cf208858e40592c9d2d38ed8e64cdeeb978f" translate="yes" xml:space="preserve">
          <source>Thrown on an out of memory error.</source>
          <target state="translated">抛出的内存错误。</target>
        </trans-unit>
        <trans-unit id="3d00baaee4bcf2f35b15a207e7685eb27dac105f" translate="yes" xml:space="preserve">
          <source>Thrown on calls to &lt;code&gt;receive&lt;/code&gt; if the thread that spawned the receiving thread has terminated and no more messages exist.</source>
          <target state="translated">扔在呼叫 &lt;code&gt;receive&lt;/code&gt; 如果催生接收线程的线程终止而存在没有更多的消息。</target>
        </trans-unit>
        <trans-unit id="2324a54efe11d589ff8d54fcc1b56a073a6a5882" translate="yes" xml:space="preserve">
          <source>Thrown on calls to &lt;code&gt;receiveOnly&lt;/code&gt; if a message other than the type the receiving thread expected is sent.</source>
          <target state="translated">如果发送了不同于接收线程预期类型的​​消息，则 &lt;code&gt;receiveOnly&lt;/code&gt; 对receiveOnly的调用。</target>
        </trans-unit>
        <trans-unit id="3129f3e1668dc67a58429ffa0cef7d5a14bcbb14" translate="yes" xml:space="preserve">
          <source>Thrown on conversion errors.</source>
          <target state="translated">转换错误时抛出。</target>
        </trans-unit>
        <trans-unit id="29878d6640bc6d1eaad971922e0aa1d911c88d3a" translate="yes" xml:space="preserve">
          <source>Thrown on conversion overflow errors.</source>
          <target state="translated">在转换溢出错误时抛出。</target>
        </trans-unit>
        <trans-unit id="5b47b72e06e1d04f8e2399d1acfde860c151b623" translate="yes" xml:space="preserve">
          <source>Thrown on error.</source>
          <target state="translated">抛出的错误。</target>
        </trans-unit>
        <trans-unit id="a4752cf51c73b5b3850abf244753cdd8e6632e42" translate="yes" xml:space="preserve">
          <source>Thrown on finalize error.</source>
          <target state="translated">在finalize错误时抛出。</target>
        </trans-unit>
        <trans-unit id="36d88aa95deaa8eb68ccf7623cd01071911543b5" translate="yes" xml:space="preserve">
          <source>Thrown on mailbox crowding if the mailbox is configured with &lt;code&gt;OnCrowding.throwException&lt;/code&gt;.</source>
          <target state="translated">如果邮箱配置了 &lt;code&gt;OnCrowding.throwException&lt;/code&gt; ,则在邮箱拥挤时引发。</target>
        </trans-unit>
        <trans-unit id="79b810076b73721a41a2673482bdf7baf7ec2c8a" translate="yes" xml:space="preserve">
          <source>Thrown on one of the following conditions:</source>
          <target state="translated">在下列条件之一时抛出。</target>
        </trans-unit>
        <trans-unit id="5ab114d73446a9ce4d36fd9f522df3a1eebc6c65" translate="yes" xml:space="preserve">
          <source>Thrown when a Tid is missing, e.g. when &lt;code&gt;ownerTid&lt;/code&gt; doesn't find an owner thread.</source>
          <target state="translated">缺少Tid时抛出，例如 &lt;code&gt;ownerTid&lt;/code&gt; 找不到所有者线程时抛出。</target>
        </trans-unit>
        <trans-unit id="1e6ce338b7ac50ade34d3b28700ff70b8d4a7605" translate="yes" xml:space="preserve">
          <source>Thrown when parsing for Tags</source>
          <target state="translated">当解析标签时抛出</target>
        </trans-unit>
        <trans-unit id="f3f52f3792a4bcc4f042510f3988510a62c2449d" translate="yes" xml:space="preserve">
          <source>Throws an exception.</source>
          <target state="translated">抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="9c1b3e348c5e658c9f04296e21ad3e2315006119" translate="yes" xml:space="preserve">
          <source>Throws:</source>
          <target state="translated">Throws:</target>
        </trans-unit>
        <trans-unit id="ff6fea9d058e3c0f1cc7f0adf3f77f4b9520cb7a" translate="yes" xml:space="preserve">
          <source>Thunks adjust the incoming 'this' pointer by 'offset'.</source>
          <target state="translated">Thunks通过'offset'调整传入的'this'指针。</target>
        </trans-unit>
        <trans-unit id="681bc8d0be931a268296c48f3f9e40f73e12b3a8" translate="yes" xml:space="preserve">
          <source>Thus, a static array always has the dimension statically available as part of the type, and so it is implemented like in C. Static arrays and Dynamic arrays can be easily converted back and forth to each other.</source>
          <target state="translated">因此,一个静态数组总是将维度作为类型的一部分静态可用,所以它的实现就像在C语言中一样,静态数组和动态数组可以很容易地相互来回转换。</target>
        </trans-unit>
        <trans-unit id="8b6a4f79c67e1c0cfc398c2295408f2eb4b88ca9" translate="yes" xml:space="preserve">
          <source>Tibetan</source>
          <target state="translated">Tibetan</target>
        </trans-unit>
        <trans-unit id="62fac526b50cebc251a6af759bfe5d5bd018bff6" translate="yes" xml:space="preserve">
          <source>TickDuration</source>
          <target state="translated">TickDuration</target>
        </trans-unit>
        <trans-unit id="c0d2d45e63dc40fd88c7a14b1c2358a160a7833d" translate="yes" xml:space="preserve">
          <source>TickDuration &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">TickDuration &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ce36a6b212a9b591eeb95689defcb8d1ae88308" translate="yes" xml:space="preserve">
          <source>TickDuration[fun.length] &lt;strong id=&quot;benchmark&quot;&gt;benchmark&lt;/strong&gt;(fun...)(uint n);</source>
          <target state="translated">TickDuration [fun.length] &lt;strong id=&quot;benchmark&quot;&gt;基准&lt;/strong&gt;（fun ...）（uint n）;</target>
        </trans-unit>
        <trans-unit id="dc7acc903cfca8ef291e395f7b085edc57885861" translate="yes" xml:space="preserve">
          <source>Tid &lt;code&gt;tid&lt;/code&gt;</source>
          <target state="translated">TID &lt;code&gt;tid&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1f074e4e94dc8553442f6182f62fea84786f05c" translate="yes" xml:space="preserve">
          <source>Tid &lt;strong id=&quot;locate&quot;&gt;locate&lt;/strong&gt;(string name);</source>
          <target state="translated">提示&lt;strong id=&quot;locate&quot;&gt;查找&lt;/strong&gt;（字符串名称）；</target>
        </trans-unit>
        <trans-unit id="3e99e02f714335d73cd91fb8d55900b4d5bd1b70" translate="yes" xml:space="preserve">
          <source>Tid &lt;strong id=&quot;spawn&quot;&gt;spawn&lt;/strong&gt;(F, T...)(F fn, T args)</source>
          <target state="translated">Tid &lt;strong id=&quot;spawn&quot;&gt;产生&lt;/strong&gt;（F，T ...）（F fn，T args）</target>
        </trans-unit>
        <trans-unit id="25d02d5a84c7931ece10b93795e423a694986b38" translate="yes" xml:space="preserve">
          <source>Tid &lt;strong id=&quot;spawnLinked&quot;&gt;spawnLinked&lt;/strong&gt;(F, T...)(F fn, T args)</source>
          <target state="translated">Tid &lt;strong id=&quot;spawnLinked&quot;&gt;spawnLinked&lt;/strong&gt;（F，T ...）（F fn，T args）</target>
        </trans-unit>
        <trans-unit id="5b2248c38faf525d4aa66c5d69e86959be2e64dd" translate="yes" xml:space="preserve">
          <source>Tid &lt;strong id=&quot;threadId&quot;&gt;threadId&lt;/strong&gt;;</source>
          <target state="translated">Tid &lt;strong id=&quot;threadId&quot;&gt;threadId&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cf46deb14abc3ae4a0180bd680085f5421becb62" translate="yes" xml:space="preserve">
          <source>Tifinagh</source>
          <target state="translated">Tifinagh</target>
        </trans-unit>
        <trans-unit id="bf7505fef58bfd49abbc3421a5a8a317c819906e" translate="yes" xml:space="preserve">
          <source>Time Measurement and Benchmarking</source>
          <target state="translated">时间测量和基准</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
