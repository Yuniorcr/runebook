<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="c2cc357fb7c03c09f92dcb1aaffc28e51837dbc6" translate="yes" xml:space="preserve">
          <source>Flag used by &lt;a href=&quot;#resolveFuncCall&quot;&gt;&lt;code&gt;resolveFuncCall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#resolveFuncCall&quot;&gt; &lt;code&gt;resolveFuncCall&lt;/code&gt; &lt;/a&gt;使用的标志。</target>
        </trans-unit>
        <trans-unit id="dfa1ebe73458327f2f1b2331e7d2bc64bda02225" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Iterable)(auto ref Iterable r)</source>
          <target state="translated">标记！&amp;ldquo; &lt;strong id=&quot;each&quot;&gt;每个&lt;/strong&gt; &amp;rdquo; &lt;strong id=&quot;each&quot;&gt;每个&lt;/strong&gt;（Iterable）（auto ref Iterable r）</target>
        </trans-unit>
        <trans-unit id="2e29bfd584368e0b6c450b93dff8e2b4b7d7e79b" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">标记！&amp;ldquo; &lt;strong id=&quot;each&quot;&gt;每个&lt;/strong&gt; &amp;rdquo; &lt;strong id=&quot;each&quot;&gt;每个&lt;/strong&gt;（Range）（Range r）</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="a98a30dbf66202f4a1ca6fcfeff706e1cb961f9b" translate="yes" xml:space="preserve">
          <source>Flags affect formatting depending on the specifier as follows.</source>
          <target state="translated">影响格式的标志取决于指定者,具体如下。</target>
        </trans-unit>
        <trans-unit id="517da122a2fd8a775a91cf3934a2421fdfecad5e" translate="yes" xml:space="preserve">
          <source>Flags may be OR'ed together:</source>
          <target state="translated">旗帜可以一起被OR。</target>
        </trans-unit>
        <trans-unit id="9a817b12d43958a297fe78c774ef0aab232c3032" translate="yes" xml:space="preserve">
          <source>Flags that can be passed to &lt;a href=&quot;#pipeProcess&quot;&gt;&lt;code&gt;pipeProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; to specify which of the child process' standard streams are redirected. Use bitwise OR to combine flags.</source>
          <target state="translated">可以传递给&lt;a href=&quot;#pipeProcess&quot;&gt; &lt;code&gt;pipeProcess&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; 的&lt;/a&gt;标志，以指定重定向子进程的标准流。使用按位或来组合标志。</target>
        </trans-unit>
        <trans-unit id="d7bf08131e02f1b45b6731cfdb8ac81266998286" translate="yes" xml:space="preserve">
          <source>Flags that control how json is encoded and parsed.</source>
          <target state="translated">控制json如何编码和解析的标志。</target>
        </trans-unit>
        <trans-unit id="9101e63c4b97693993f5de7e6caad68a3e230e45" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags, and note that the &lt;code&gt;retainStd...&lt;/code&gt; flags have no effect in this function.</source>
          <target state="translated">控制进程创建的标志。有关可用标志的概述，请参见&lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;。请注意， &lt;code&gt;retainStd...&lt;/code&gt; 标志对该功能无效。</target>
        </trans-unit>
        <trans-unit id="8fa52f42ca8ff70a9db0dc2e586798abb191d35d" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">控制进程创建的标志。有关可用标志的概述，请参见&lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0978ac0b3ccfd7282e3c33d010ed6583a1755a4" translate="yes" xml:space="preserve">
          <source>Flags that control the behaviour of process creation functions in this module. Most flags only apply to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">控制此模块中流程创建功能行为的标志。大多数标志仅适用于&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a98c5de453c2c7c3caf6bb14f159914e55de8b90" translate="yes" xml:space="preserve">
          <source>Flags that determine which streams are redirected, and how. See &lt;a href=&quot;#Redirect&quot;&gt;&lt;code&gt;Redirect&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">确定哪些流以及如何重定向的标志。有关可用标志的概述，请参见&lt;a href=&quot;#Redirect&quot;&gt; &lt;code&gt;Redirect&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b620409ddfc3fc2bb8b14e73ba7780a044ad90c9" translate="yes" xml:space="preserve">
          <source>Flatten out the scope by presenting the statement as an array of statements.</source>
          <target state="translated">通过将语句作为一个语句数组来呈现,从而将范围扁平化。</target>
        </trans-unit>
        <trans-unit id="69f2ec628a1c75aed5c37949245c44cc81da511d" translate="yes" xml:space="preserve">
          <source>Flips a single bit, specified by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">翻转一位，由 &lt;code&gt;pos&lt;/code&gt; 指定</target>
        </trans-unit>
        <trans-unit id="a4e1ce065ff47fa12c8210de50047287b30b8075" translate="yes" xml:space="preserve">
          <source>Flips all the bits in the &lt;code&gt;BitArray&lt;/code&gt;</source>
          <target state="translated">翻转 &lt;code&gt;BitArray&lt;/code&gt; 中的所有位</target>
        </trans-unit>
        <trans-unit id="f980f6669a99ae97aa471b598c62ac0c3e1f823b" translate="yes" xml:space="preserve">
          <source>Floating Point</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="a7a463a748e16b2f5b0e11e3ae1b317ccea7b0fc" translate="yes" xml:space="preserve">
          <source>Floating Point Constant Folding</source>
          <target state="translated">浮点恒定折线</target>
        </trans-unit>
        <trans-unit id="d66cb8936a51df45efbb55e9f325e90025cbbefc" translate="yes" xml:space="preserve">
          <source>Floating Point Intermediate Values</source>
          <target state="translated">浮点中间值</target>
        </trans-unit>
        <trans-unit id="a6c4e80d19a5698157c68955c5feabc616b55ad5" translate="yes" xml:space="preserve">
          <source>Floating Point Literals</source>
          <target state="translated">浮点文字</target>
        </trans-unit>
        <trans-unit id="549c1462b87072d7712396a53e8de6f7b9f76688" translate="yes" xml:space="preserve">
          <source>Floating Point Transformations</source>
          <target state="translated">浮点变换</target>
        </trans-unit>
        <trans-unit id="00848e3da3c10e7ab7937982dcd4c2d2c3dffaaa" translate="yes" xml:space="preserve">
          <source>Floating literals can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">浮动文字可以包含嵌入的&amp;ldquo; _&amp;rdquo;字符，这些字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="01668267e3349ef380ebd600403f931fc5d66ef9" translate="yes" xml:space="preserve">
          <source>Floating literals with no suffix are of type &lt;code&gt;double&lt;/code&gt;. They can be followed by one &lt;b&gt;f&lt;/b&gt;, &lt;b&gt;F&lt;/b&gt;, or &lt;b&gt;L&lt;/b&gt; suffix. The &lt;b&gt;f&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; suffix types it is a &lt;code&gt;float&lt;/code&gt;, and &lt;b&gt;L&lt;/b&gt; types it is a &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">不带后缀的浮点文字为 &lt;code&gt;double&lt;/code&gt; 类型。它们后面可以是一个&lt;b&gt;f&lt;/b&gt;，&lt;b&gt;F&lt;/b&gt;或&lt;b&gt;L&lt;/b&gt;后缀。所述&lt;b&gt;˚F&lt;/b&gt;或&lt;b&gt;˚F&lt;/b&gt;后缀类型它是一个 &lt;code&gt;float&lt;/code&gt; ，和&lt;b&gt;大号&lt;/b&gt;类型它是一个 &lt;code&gt;real&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a4195feb88e405b4996ac5dcca713ad5c6175c1" translate="yes" xml:space="preserve">
          <source>Floating point NaN's are formatted as &lt;b&gt;nan&lt;/b&gt; if the</source>
          <target state="translated">浮点NaN的格式为&lt;b&gt;楠&lt;/b&gt;如果</target>
        </trans-unit>
        <trans-unit id="afa8bdea6b3525811aead9f74976b708a0d15aba" translate="yes" xml:space="preserve">
          <source>Floating point comparison operators</source>
          <target state="translated">浮点比较运算符</target>
        </trans-unit>
        <trans-unit id="ed4b0ae6cd9ee0a107d7642401f3d58f692c98b4" translate="yes" xml:space="preserve">
          <source>Floating point comparisons</source>
          <target state="translated">浮点比较</target>
        </trans-unit>
        <trans-unit id="51fe49d981df10fc2a3ca0c38f66d9ec597eda64" translate="yes" xml:space="preserve">
          <source>Floating point computations can be carried out at a higher precision than the size of the floating point variable can hold. Floating point algorithms should continue to work properly if precision is arbitrarily increased.</source>
          <target state="translated">浮点计算可以在比浮点变量所能容纳的大小更高的精度下进行。如果任意提高精度,浮点算法应继续正常工作。</target>
        </trans-unit>
        <trans-unit id="cbc0ff66a82e332f74b6f7f08625c15927132156" translate="yes" xml:space="preserve">
          <source>Floating point constants are internally represented in the implementation in at least &lt;code&gt;real&lt;/code&gt; precision, regardless of the constant's type. The extra precision is available for constant folding. Committing to the precision of the result is done as late as possible in the compilation process. For example:</source>
          <target state="translated">浮点常数在实现中至少以 &lt;code&gt;real&lt;/code&gt; 精度在内部表示，而与常数的类型无关。额外的精度可用于恒定折叠。在编译过程中尽可能晚地保证结果的准确性。例如：</target>
        </trans-unit>
        <trans-unit id="35c2559ddef9cb0435b556f187c76ca13d0d375f" translate="yes" xml:space="preserve">
          <source>Floating point numbers</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="95bc83092a43ba79dea2ddad11b46e7cfef6083c" translate="yes" xml:space="preserve">
          <source>Floating point numerics functions.</source>
          <target state="translated">浮点数字函数。</target>
        </trans-unit>
        <trans-unit id="160661b47177ecb78c896bad472b47b4dfd37f9e" translate="yes" xml:space="preserve">
          <source>Floating point return values are returned on the FPU stack. These must be cleaned off by the caller, even if they are not used.</source>
          <target state="translated">浮点返回值会在FPU堆栈上返回。这些值必须由调用者清理掉,即使它们没有被使用。</target>
        </trans-unit>
        <trans-unit id="33856b075b952fb87e57ad69006f9b871108ab99" translate="yes" xml:space="preserve">
          <source>Floating point types cannot be implicitly converted to integral types. Complex or imaginary floating point types cannot be implicitly converted to non-complex floating point types. Non-complex floating point types cannot be implicitly converted to imaginary floating point types.</source>
          <target state="translated">浮点类型不能隐式转换为积分类型。复式或虚式浮点类型不能隐式转换为非复式浮点类型。非复杂浮点类型不能隐式转换为虚浮点类型。</target>
        </trans-unit>
        <trans-unit id="d3a01c245469b7e18ff38a92dc5c6ea9b1ec4c23" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (cfloat, cdouble, and creal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+] [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|nan+nani|inf|-inf]</source>
          <target state="translated">浮点数。(cfloat,cdouble,and creal)['+'|'-'][数字(s)][数字(s)][[e-|e+]数字(s)][+][数字(s)[.][数字(s)][[e-|e+]数字(s)][i|f|L|Li|fi]]或[nan|nani|nan+nani|inf|inf]。</target>
        </trans-unit>
        <trans-unit id="6d2316f26e5bf23de4ad985a49ccce2c80f4f913" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (float, double, real, ifloat, idouble, and ireal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|inf|-inf]</source>
          <target state="translated">浮点数。(float,double,real,ifloat,idouble,and ireal)['+'|'-'][数字(s)][[数字(s)][[e-|e+]数字(s)][i|f|L|Li|fi]]或[nan|nani|inf|-inf]。</target>
        </trans-unit>
        <trans-unit id="4e439c8e69a24e7d54c5622205640014d4f59099" translate="yes" xml:space="preserve">
          <source>Floating-Point manipulation</source>
          <target state="translated">浮点运算</target>
        </trans-unit>
        <trans-unit id="417d3791f22357e1adf665e28ee4d505d124a89d" translate="yes" xml:space="preserve">
          <source>Floating-point operations</source>
          <target state="translated">浮点运算</target>
        </trans-unit>
        <trans-unit id="e0d24bd6f36291462113f127088f35f4090a373d" translate="yes" xml:space="preserve">
          <source>Floating-point random variate of type &lt;code&gt;T&lt;/code&gt; drawn from the uniform distribution across the half-open interval [0, 1).</source>
          <target state="translated">从半开区间[0，1]的均匀分布得出的 &lt;code&gt;T&lt;/code&gt; 型浮点随机变量。</target>
        </trans-unit>
        <trans-unit id="f2714b106a05319f2ace1ce68d8ac69bcf4f5ff7" translate="yes" xml:space="preserve">
          <source>Floating-point values are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">浮点值的格式类似于&lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6b8da4fa90bdf05e2c05a6593125f02a7d82431" translate="yes" xml:space="preserve">
          <source>Floats can be in decimal or hexadecimal format.</source>
          <target state="translated">浮点数可以是十进制或十六进制格式。</target>
        </trans-unit>
        <trans-unit id="aee4c734dc6fd3c7a89584d7e5348d40237e1949" translate="yes" xml:space="preserve">
          <source>Flush cookie jar to disk.</source>
          <target state="translated">将饼干罐冲到磁盘上。</target>
        </trans-unit>
        <trans-unit id="7f0c95d2e99f8f6f791a3dcf13701e05342006cc" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;FILE&lt;/code&gt; buffers.</source>
          <target state="translated">刷新C &lt;code&gt;FILE&lt;/code&gt; 缓冲区。</target>
        </trans-unit>
        <trans-unit id="bebb80c78ce429db39d79d68feeba680b58038de" translate="yes" xml:space="preserve">
          <source>Folding White Space contains consecutive CRLF sequences</source>
          <target state="translated">折叠白色空间包含连续的CRLF序列。</target>
        </trans-unit>
        <trans-unit id="67f0ed9d72f8298bdd413ec634b75103f7a22dc1" translate="yes" xml:space="preserve">
          <source>Folding White Space ends with a CRLF sequence</source>
          <target state="translated">折叠白色空间以CRLF序列结束。</target>
        </trans-unit>
        <trans-unit id="08097cc4ab9f5b9568ed73c27e3a597381bce1b4" translate="yes" xml:space="preserve">
          <source>Following arguments works the same way as &lt;code&gt;bitfield&lt;/code&gt;'s. The bitfield must fit into the bits known to be zero because of the pointer alignment.</source>
          <target state="translated">跟随参数的方式与 &lt;code&gt;bitfield&lt;/code&gt; 的方式相同。由于指针对齐，位字段必须适合已知为零的位。</target>
        </trans-unit>
        <trans-unit id="6cfe2219958a5948a49371cf65d64e832c75a6f7" translate="yes" xml:space="preserve">
          <source>Following initialization, the &lt;code&gt;HashTable&lt;/code&gt; object would consistently use its &lt;code&gt;allocator&lt;/code&gt; object for acquiring memory. Furthermore, setting &lt;code&gt;HashTable.allocator&lt;/code&gt; to point to a different allocator should be legal but only if the object is empty; otherwise, the object wouldn't be able to deallocate its existing state.</source>
          <target state="translated">初始化之后， &lt;code&gt;HashTable&lt;/code&gt; 对象将始终使用其 &lt;code&gt;allocator&lt;/code&gt; 对象来获取内存。此外，将 &lt;code&gt;HashTable.allocator&lt;/code&gt; 设置为指向其他分配器应该是合法的，但前提是该对象为空。否则，该对象将无法取消分配其现有状态。</target>
        </trans-unit>
        <trans-unit id="c77938fcdf67aea78282407b90406b49eb71c3e5" translate="yes" xml:space="preserve">
          <source>Follows Itanium C++ ABI 1.86 section 5.1 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt; which is where the grammar comments come from.</source>
          <target state="translated">遵循Itanium C ++ ABI 1.86第5.1节&lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt;，这是语法注释的来源。</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="2496332383d78a1d33c27c0e38fa6de47dc78a49" translate="yes" xml:space="preserve">
          <source>For &quot;store&quot; operations of the form: op1 op= op2</source>
          <target state="translated">对于 &quot;存储 &quot;操作的形式:op1 op=op2。</target>
        </trans-unit>
        <trans-unit id="97c9b61a869134f6120476fe4a99b3b11a45291d" translate="yes" xml:space="preserve">
          <source>For 16 bit generator, this is always a (targ_short) sign-extended value.</source>
          <target state="translated">对于16位的生成器,这总是一个(targ_short)符号扩展值。</target>
        </trans-unit>
        <trans-unit id="78b280836f07395eef32226ce729d39d05fd0d6b" translate="yes" xml:space="preserve">
          <source>For 64 bit code, follows Itanium C++ ABI 1.86 Chapter 3 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&lt;/a&gt;</source>
          <target state="translated">对于64位代码，请遵循Itanium C ++ ABI 1.86第3章&lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b23dde54b23d16d77035a1e0e2b0833121f3ea89" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; or the operation would result in an overflow, sets &lt;code&gt;v&lt;/code&gt; to &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">对于 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; ，如果 &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; 或该操作将导致溢出， &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; 设置为WithNaN.defaultValue！T。否则，语义与内置运算符的语义相同。</target>
        </trans-unit>
        <trans-unit id="c0328592d323a259faf0da7a348a86fd52092b62" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">对于 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; ，如果 &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; ，则返回 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; 。否则，语义与内置运算符的语义相同。</target>
        </trans-unit>
        <trans-unit id="4e56b23a72d6de96ffb1933a70486eb64d0dea7d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;foreach&lt;/code&gt;, the elements for the array are iterated over starting at index 0 and continuing to the maximum of the array. For &lt;code&gt;foreach_reverse&lt;/code&gt;, the array elements are visited in the reverse order.</source>
          <target state="translated">对于 &lt;code&gt;foreach&lt;/code&gt; ，从索引0开始迭代数组的元素，直到数组的最大值。对于 &lt;code&gt;foreach_reverse&lt;/code&gt; ，以相反的顺序访问数组元素。</target>
        </trans-unit>
        <trans-unit id="d0ceede7c3735e19c4f9e84dfec5a98cdaa80c75" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;windowSize = 1&lt;/code&gt; it splits the range into single element groups (aka &lt;code&gt;unflatten&lt;/code&gt;) For &lt;code&gt;windowSize = 2&lt;/code&gt; it is similar to &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;windowSize = 1&lt;/code&gt; 它将范围划分为单个元素组（又名 &lt;code&gt;unflatten&lt;/code&gt; ）；对于 &lt;code&gt;windowSize = 2&lt;/code&gt; 它类似于 &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fde640aa4409bbb47d5287c2ea78c26d39f59e9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt;: The function returns &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt; ：函数返回 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5ba5d0612e564fafee84b671c5c4d115f7c0b6e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt;: If &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, the function returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise it returns the normal result of the operator.</source>
          <target state="translated">对于 &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt; ：如果 &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; ，则函数返回 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; 。否则，它将返回操作员的正常结果。</target>
        </trans-unit>
        <trans-unit id="d465e34c13d15e0333f8cd7f1c7c1944ae2b7911" translate="yes" xml:space="preserve">
          <source>For C++ class cd, generate an instance of _cpp_type_info_ptr and populate it with a pointer to the C++ type info.</source>
          <target state="translated">对于C++类cd,生成一个_cpp_type_info_ptr的实例,并用指向C++类型信息的指针填充它。</target>
        </trans-unit>
        <trans-unit id="84fc2ed3d82dfac4fe4b1db7e54128df57816954" translate="yes" xml:space="preserve">
          <source>For Posix/x86_64 this returns the type which will really be used for passing an argument of type va_list.</source>
          <target state="translated">对于Posix/x86_64来说,这将返回真正用于传递va_list类型参数的类型。</target>
        </trans-unit>
        <trans-unit id="826bad097a9af03241478f133b816c28a093c4ff" translate="yes" xml:space="preserve">
          <source>For Statement</source>
          <target state="translated">声明</target>
        </trans-unit>
        <trans-unit id="1658d59f02098b291dd70d6afbe72baf35b0b46e" translate="yes" xml:space="preserve">
          <source>For TypeFunction, nextOf() can return NULL if the function return type is meant to be inferred, and semantic() hasn't yet ben run on the function. After semantic(), it must no longer be NULL.</source>
          <target state="translated">对于TypeFunction来说,如果函数的返回类型是要推断的,并且semantic()还没有在函数上运行,那么nextOf()可以返回NULL。在semantic()之后,它必须不再是NULL。</target>
        </trans-unit>
        <trans-unit id="ed4c1eb6664e08f8534b1fe769460ebc44281875" translate="yes" xml:space="preserve">
          <source>For a lazy version, refer to &lt;a href=&quot;std_range#repeat&quot;&gt;&lt;code&gt;std.range.repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于惰性版本，请参考&lt;a href=&quot;std_range#repeat&quot;&gt; &lt;code&gt;std.range.repeat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8cd7374ae5703f87c90badd0385e4fb829226681" translate="yes" xml:space="preserve">
          <source>For a lazy version, see &lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt;&lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">对于懒惰的版本，请参见&lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt; &lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20ca13cf71a91c26b14ec6bf15dd84151e56cf9e" translate="yes" xml:space="preserve">
          <source>For a lazy, non-allocating version of these functions, see &lt;a href=&quot;#byUTF&quot;&gt;&lt;code&gt;byUTF&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关这些函数的惰性，非分配版本，请参见&lt;a href=&quot;#byUTF&quot;&gt; &lt;code&gt;byUTF&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="567c03cab3251ca5dd2f65be01f597e8de5b789b" translate="yes" xml:space="preserve">
          <source>For a less strict parser, see &lt;a href=&quot;#parseUUID&quot;&gt;&lt;code&gt;parseUUID&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">对于不太严格的解析器，请参阅&lt;a href=&quot;#parseUUID&quot;&gt; &lt;code&gt;parseUUID&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32cf17cd505298c5983970817a14f4d4aa02e1a3" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; and the setter has no effect.</source>
          <target state="translated">对于零大小的池，getter会任意返回 &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; ，而setter无效。</target>
        </trans-unit>
        <trans-unit id="703bdcc05cee4b856a950e3e2494d43650695c33" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns true and the setter has no effect.</source>
          <target state="translated">对于大小为零的池子,getter任意返回true,setter没有效果。</target>
        </trans-unit>
        <trans-unit id="7062424b6df58f7b0070477aac1caffce7eac347" translate="yes" xml:space="preserve">
          <source>For all assign expressions, the left operand must be a modifiable lvalue. The type of the assign expression is the type of the left operand, and the value is the value of the left operand after assignment occurs. The resulting expression is a modifiable lvalue.</source>
          <target state="translated">对于所有的赋值表达式,左操作数必须是一个可修改的l值。赋值表达式的类型是左操作数的类型,值是赋值发生后左操作数的值。结果表达式是一个可修改的l值。</target>
        </trans-unit>
        <trans-unit id="4c1c5870b4b89a912a0f2d752c3a6fab5551a649" translate="yes" xml:space="preserve">
          <source>For all other cases, the temporaries generated for the purpose of invoking functions are deferred to the end of the full expression. The order of destruction is inverse to the order of construction.</source>
          <target state="translated">对于所有其他情况,为调用函数而生成的时态被推迟到完整表达式的最后。销毁的顺序与构造的顺序相反。</target>
        </trans-unit>
        <trans-unit id="95e2e0ca2da36fd3882b011dd82190d8d5ee7297" translate="yes" xml:space="preserve">
          <source>For an introductory look at &lt;b&gt;std.format&lt;/b&gt;'s capabilities and how to use this module see the dedicated &lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki article&lt;/a&gt;.</source>
          <target state="translated">有关&lt;b&gt;std.format&lt;/b&gt;的功能以及如何使用此模块的介绍，请参见专用的&lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="076ae6cb1419d1feff35ba4b7e6bb266176337c6" translate="yes" xml:space="preserve">
          <source>For another example:</source>
          <target state="translated">再举个例子:</target>
        </trans-unit>
        <trans-unit id="4f7c5dea21579ef43f50bda4d8b8e7dd5ee9236e" translate="yes" xml:space="preserve">
          <source>For any given platform/compiler curl_off_t must be typedef'ed to a 64-bit wide signed integral data type. The width of this data type must remain constant and independent of any possible large file support settings.</source>
          <target state="translated">对于任何给定的平台/编译器,curl_off_t必须被类型化为一个64位宽的有符号的积分数据类型,这个数据类型的宽度必须保持不变,并且独立于任何可能的大文件支持设置。这个数据类型的宽度必须保持不变,并且独立于任何可能的大文件支持设置。</target>
        </trans-unit>
        <trans-unit id="078912245b32cd2a66bf3a96da7307acc2485fbe" translate="yes" xml:space="preserve">
          <source>For any other declaration even if &lt;code&gt;@disable&lt;/code&gt; is a syntactically valid attribute &lt;code&gt;false&lt;/code&gt; is returned because the annotation has no effect.</source>
          <target state="translated">对于任何其他声明，即使 &lt;code&gt;@disable&lt;/code&gt; 是语法上有效的属性，也将返回 &lt;code&gt;false&lt;/code&gt; ，因为注释无效。</target>
        </trans-unit>
        <trans-unit id="701d1a14380c65e4a855899951d9d7a65d27e60f" translate="yes" xml:space="preserve">
          <source>For any values &lt;code&gt;v1&lt;/code&gt; on the right-hand side and &lt;code&gt;v2&lt;/code&gt; on the left-hand side:</source>
          <target state="translated">对于右侧的 &lt;code&gt;v1&lt;/code&gt; 和左侧的 &lt;code&gt;v2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f1e77f1044f99821b0b2c5cfb9d3d37a079ad5ec" translate="yes" xml:space="preserve">
          <source>For applications like command line switch processing, this can lead to much more straightforward code, being clearer and less error prone. char, wchar and dchar strings are allowed.</source>
          <target state="translated">对于像命令行开关处理这样的应用,这可以使代码更简单,更清晰,更不容易出错,允许使用char、wchar和dchar字符串。</target>
        </trans-unit>
        <trans-unit id="d1b8d2445b680cd8ee27f3fc95623cb30af7a286" translate="yes" xml:space="preserve">
          <source>For arguments of built-in types, assignment operator expressions such as</source>
          <target state="translated">对于内置类型的参数,赋值运算符表达式如</target>
        </trans-unit>
        <trans-unit id="0f5d29eff2633e7fd841d0a6738a98ac739e92a9" translate="yes" xml:space="preserve">
          <source>For arrays:</source>
          <target state="translated">对于数组。</target>
        </trans-unit>
        <trans-unit id="dc14ba04c2c4629e1d2d0d30f5dc9d2a1dddd9e2" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;a[]&lt;/code&gt; and &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">为了向后兼容，请使用 &lt;code&gt;a[]&lt;/code&gt; 和 &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="542878137297059fb68730fd24d9158d8fdb95d5" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;multiwayMerge&lt;/code&gt; is available under the name &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; under the name of &lt;code&gt;NWayUnion&lt;/code&gt; . Future code should use &lt;code&gt;multiwayMerge&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; as &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;NWayUnion&lt;/code&gt; will be deprecated.</source>
          <target state="translated">为了向后兼容， &lt;code&gt;multiwayMerge&lt;/code&gt; 是名下可用 &lt;code&gt;nWayUnion&lt;/code&gt; 和 &lt;code&gt;MultiwayMerge&lt;/code&gt; 名下 &lt;code&gt;NWayUnion&lt;/code&gt; 。将来的代码应使用 &lt;code&gt;multiwayMerge&lt;/code&gt; 和 &lt;code&gt;MultiwayMerge&lt;/code&gt; ,因为 &lt;code&gt;nWayUnion&lt;/code&gt; 和 &lt;code&gt;NWayUnion&lt;/code&gt; 将被弃用。</target>
        </trans-unit>
        <trans-unit id="e3a3c169dbbfe63cc4460a15c98153cda1f6881e" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if rewriting &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">为了向后兼容，如果重写 &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92276f55c3cccb89a03bd28b0c6443429cb6df1c" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail and &lt;code&gt;opSliceOpAssign&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; are tried, respectively.</source>
          <target state="translated">为了向后兼容，如果上述重写失败和 &lt;code&gt;opSliceOpAssign&lt;/code&gt; 被定义，则重写 &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; 和 &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; 中分别尝试。</target>
        </trans-unit>
        <trans-unit id="e5a6a2446de90976e232d13603325c19c48a5a94" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail to compile and &lt;code&gt;opSliceUnary&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; are tried instead, respectively.</source>
          <target state="translated">为了向后兼容，如果上述重写失败编译和 &lt;code&gt;opSliceUnary&lt;/code&gt; 被定义，则重写 &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; 和 &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; 分别代替尝试。</target>
        </trans-unit>
        <trans-unit id="757d4d7a3dccc207f58716a0eadde379a304a5d2" translate="yes" xml:space="preserve">
          <source>For binary operators, the result is as follows:</source>
          <target state="translated">对于二元运算符,结果如下。</target>
        </trans-unit>
        <trans-unit id="aeea5f41f2c7d1bd01e14aae86afc3b17192c6d2" translate="yes" xml:space="preserve">
          <source>For blocks &amp;gt;= pagesize, the length is a size_t and is at the beginning of the block. The reason we have to do this is because the block can extend into more pages, so we cannot trust the block length if it sits at the end of the block, because it might have just been extended. If we can prove in the future that the block is unshared, we may be able to change this, but I'm not sure it's important.</source>
          <target state="translated">对于&amp;gt; = pagesize的块，长度为size_t，位于块的开头。我们之所以这样做，是因为该块可以扩展到更多页面，所以如果它位于块的末尾，我们就不能相信它的长度，因为它可能刚刚被扩展了。如果我们将来能证明该区块是未共享的，我们也许可以更改它，但是我不确定它是否重要。</target>
        </trans-unit>
        <trans-unit id="6435d22c869fa126d1d0aea9e7983183ab7f918e" translate="yes" xml:space="preserve">
          <source>For both ++i and --i</source>
          <target state="translated">对于++i和-i</target>
        </trans-unit>
        <trans-unit id="93107872cedc76cc5719158670858cf146f5ce57" translate="yes" xml:space="preserve">
          <source>For both i++ and i--</source>
          <target state="translated">对于i++和i--</target>
        </trans-unit>
        <trans-unit id="c2f1745a5232cce644154e5a3850452a31978021" translate="yes" xml:space="preserve">
          <source>For both overloads, the entire value of the Duration is split among the units (rather than splitting the Duration across all units and then only providing the values for the requested units), so if only one unit is given, the result is equivalent to &lt;a href=&quot;#total&quot;&gt;&lt;code&gt;total&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于这两个重载，Duration的整个值都在单位之间进行分配（而不是在所有单位之间划分Duration，然后仅提供所请求单位的值），因此，如果仅给出一个单位，则结果等于&lt;a href=&quot;#total&quot;&gt; &lt;code&gt;total&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad0f0aabfe7ebb013586fcfb45b89ab392324a84" translate="yes" xml:space="preserve">
          <source>For built-in numerical types, accurate Knuth &amp;amp; Welford mean calculation is used. For user-defined types, element by element summation is used. Additionally an extra parameter &lt;code&gt;seed&lt;/code&gt; is needed in order to correctly seed the summation with the equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">对于内置数字类型，使用精确的Knuth＆Welford均值计算。对于用户定义的类型，使用逐个元素求和。另外，还需要一个额外的参数 &lt;code&gt;seed&lt;/code&gt; ，以正确地将等于 &lt;code&gt;0&lt;/code&gt; 的总和种子。</target>
        </trans-unit>
        <trans-unit id="a4cc9dd81eb95c3553b97b6dbcaf73ca851ceabc" translate="yes" xml:space="preserve">
          <source>For calendar-based operations that don't care about time zones, then &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt; would be the type to use. For system time, use &lt;code&gt;SysTime&lt;/code&gt;.</source>
          <target state="translated">对于不关心时区的基于日历的操作，则将使用&lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt;。对于系统时间，请使用 &lt;code&gt;SysTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7199c84f095b28abf14901a280827544df19151" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is known at compile-time, functions are provided for arbitrary encoding and decoding of characters, arbitrary transcoding between strings of different type, as well as validation and sanitization.</source>
          <target state="translated">对于在编译时已知编码的情况,提供了字符的任意编码和解码、不同类型字符串之间的任意转码以及验证和净化的函数。</target>
        </trans-unit>
        <trans-unit id="a53a545de095bd4f4e296c839d801de6e744e030" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is not known at compile-time, but is known at run-time, the abstract class &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; and its subclasses is provided. To construct a run-time encoder/decoder, one does e.g.</source>
          <target state="translated">对于编码在编译时未知但在运行时已知的情况，提供了抽象类&lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt;及其子类。为了构造运行时编码器/解码器，例如</target>
        </trans-unit>
        <trans-unit id="d53cba26ee6cdc76a4ea74c67f57bac33bebf848" translate="yes" xml:space="preserve">
          <source>For class and struct objects, the expression &lt;code&gt;(a == b)&lt;/code&gt; is rewritten as &lt;code&gt;a.opEquals(b)&lt;/code&gt;, and &lt;code&gt;(a != b)&lt;/code&gt; is rewritten as &lt;code&gt;!a.opEquals(b)&lt;/code&gt;.</source>
          <target state="translated">对于类和结构对象，将表达式 &lt;code&gt;(a == b)&lt;/code&gt; 重写为 &lt;code&gt;a.opEquals(b)&lt;/code&gt; ，将 &lt;code&gt;(a != b)&lt;/code&gt; 重写为 &lt;code&gt;!a.opEquals(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6164499db4fd6a0a2e064668be7de8146561558" translate="yes" xml:space="preserve">
          <source>For class objects, identity is defined as the object references are for the same object. Null class objects can be compared with &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">对于类对象，将身份定义为对象引用是针对同一对象的。空类对象可以与 &lt;code&gt;is&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="95c093eaf464e50c213285367cf108a1f21af7e6" translate="yes" xml:space="preserve">
          <source>For class objects, the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators are intended to compare the contents of the objects, however an appropriate &lt;code&gt;opEquals&lt;/code&gt; override must be defined for this to work. The default &lt;code&gt;opEquals&lt;/code&gt; provided by the root &lt;code&gt;Object&lt;/code&gt; class is equivalent to the &lt;code&gt;is&lt;/code&gt; operator. Comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents. Use the &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt; operators instead.</source>
          <target state="translated">对于类对象， &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符旨在比较对象的内容，但是必须定义适当的 &lt;code&gt;opEquals&lt;/code&gt; 重写才能起作用。根 &lt;code&gt;Object&lt;/code&gt; 类提供的默认 &lt;code&gt;opEquals&lt;/code&gt; 等效于 &lt;code&gt;is&lt;/code&gt; 运算符。与 &lt;code&gt;null&lt;/code&gt; 比较无效，因为 &lt;code&gt;null&lt;/code&gt; 没有内容。请使用 &lt;code&gt;is&lt;/code&gt; 和 &lt;code&gt;!is&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="d5b1405cc3330cccfdcfd53a468de428485e9157" translate="yes" xml:space="preserve">
          <source>For class objects, the relational operators compare the contents of the objects. Therefore, comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents.</source>
          <target state="translated">对于类对象，关系运算符比较对象的内容。因此，与 &lt;code&gt;null&lt;/code&gt; 比较是无效的，因为 &lt;code&gt;null&lt;/code&gt; 没有内容。</target>
        </trans-unit>
        <trans-unit id="ab366bbd1fd34ad6f5b2cd340e858e3c25d5bb75" translate="yes" xml:space="preserve">
          <source>For class objects, the result of Object.opCmp() forms the left operand, and 0 forms the right operand. The result of the relational expression (o1 op o2) is:</source>
          <target state="translated">对于类对象,Object.opCmp()的结果构成左操作数,0构成右操作数。关系表达式(o1 op o2)的结果是:。</target>
        </trans-unit>
        <trans-unit id="e894f77d4bc27bedbf87e79de7b7a21550ebd3e1" translate="yes" xml:space="preserve">
          <source>For class objects:</source>
          <target state="translated">对于类对象。</target>
        </trans-unit>
        <trans-unit id="6ae638739525d1c55b35c525b46eec46d1197fc5" translate="yes" xml:space="preserve">
          <source>For completeness a level 1 trie is simply an array. The current implementation takes advantage of bit-packing values when the range is known to be limited in advance (such as &lt;code&gt;bool&lt;/code&gt;). See also &lt;a href=&quot;#BitPacked&quot;&gt;&lt;code&gt;BitPacked&lt;/code&gt;&lt;/a&gt; for enforcing it manually. The major size advantage however comes from the fact that multiple &lt;b&gt;identical pages on every level are merged&lt;/b&gt; by construction.</source>
          <target state="translated">为了完整性，第1级特里只是一个数组。当已知范围预先受到限制时（例如 &lt;code&gt;bool&lt;/code&gt; ），当前实现利用位打包值。另请参阅&lt;a href=&quot;#BitPacked&quot;&gt; &lt;code&gt;BitPacked&lt;/code&gt; ,&lt;/a&gt;以手动执行它。但是，主要的大小优势来自于以下事实：&lt;b&gt;每个级别上的&lt;/b&gt;多个&lt;b&gt;相同页面都是&lt;/b&gt;通过构造&lt;b&gt;合并&lt;/b&gt;的。</target>
        </trans-unit>
        <trans-unit id="8ebdc89d7f40766ce711349010ffd3cd409b6e68" translate="yes" xml:space="preserve">
          <source>For complex numbers, equality is defined as equivalent to:</source>
          <target state="translated">对于复数,平等的定义是等于。</target>
        </trans-unit>
        <trans-unit id="c92d80178cde078393b89e6d6a1bab596929a28f" translate="yes" xml:space="preserve">
          <source>For consistency and predictability, there are several standard sections. None of these are required to be present.</source>
          <target state="translated">为了保持一致性和可预测性,有几个标准章节。其中没有一个是必须存在的。</target>
        </trans-unit>
        <trans-unit id="b5df2d0a44db277a01e403815ff3d6ffbf0a4688" translate="yes" xml:space="preserve">
          <source>For console programs, &lt;code&gt;main()&lt;/code&gt; serves as the entry point. It gets called after all the module initializers are run, and after any unittests are run. After it returns, all the module destructors are run. &lt;code&gt;main()&lt;/code&gt; must be declared using one of the following forms:</source>
          <target state="translated">对于控制台程序， &lt;code&gt;main()&lt;/code&gt; 充当入口点。在所有模块初始化程序运行之后以及任何单元测试运行之后，它将被调用。返回后，所有模块析构函数都将运行。 &lt;code&gt;main()&lt;/code&gt; 必须使用以下形式之一声明：</target>
        </trans-unit>
        <trans-unit id="a87a16b2108087eba4cfd4c27e06f2199e9c9ea6" translate="yes" xml:space="preserve">
          <source>For convenience</source>
          <target state="translated">为方便起见</target>
        </trans-unit>
        <trans-unit id="c28923eb8e6fce56c97d1e69a2459b17db795a95" translate="yes" xml:space="preserve">
          <source>For convenience, if the seed is const, or has qualified fields, then &lt;code&gt;reduce&lt;/code&gt; will operate on an unqualified copy. If this happens then the returned type will not perfectly match &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">为方便起见，如果种子为const或具有限定字段，则 &lt;code&gt;reduce&lt;/code&gt; 将对非限定副本进行操作。如果发生这种情况，则返回类型不完全匹配 &lt;code&gt;S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db55a017e4d8880bceaa15cbff12d8e02dda2446" translate="yes" xml:space="preserve">
          <source>For convenience, this module publicly imports &lt;a href=&quot;core_time&quot;&gt;&lt;code&gt;core.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了方便起见，此模块公开导入&lt;a href=&quot;core_time&quot;&gt; &lt;code&gt;core.time&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0750ffdd6d85bc11bd3ef50c265df606e3d06eba" translate="yes" xml:space="preserve">
          <source>For conversion of strings to signed types, the grammar recognized is:</source>
          <target state="translated">对于字符串到有符号类型的转换,认可的语法是。</target>
        </trans-unit>
        <trans-unit id="6d295d9ab6e17239455a68d95e6a9009da2b2b99" translate="yes" xml:space="preserve">
          <source>For conversion to unsigned types, the grammar recognized is:</source>
          <target state="translated">对于转换为无符号类型,认可的语法是:。</target>
        </trans-unit>
        <trans-unit id="7cbf49f210f0c77ac5cb0d36bff7e0a64b475c82" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal.</source>
          <target state="translated">为了进行正确的比较，如果 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 返回正整数，如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 返回负整数，如果两者相等则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eb5e30aca486d38067e5e0193c4b1bb0345617f" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal. Upon a mistaken comparison such as &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt;, the function never returns because it aborts the program.</source>
          <target state="translated">为了进行正确的比较，如果 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 返回正整数，如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 返回负整数，如果两者相等则返回 &lt;code&gt;0&lt;/code&gt; 。如果比较错误，例如 &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt; ，该函数将永远不会返回，因为它会中止程序。</target>
        </trans-unit>
        <trans-unit id="fa11ef91f282359e697ab411a2105694aa1fc413" translate="yes" xml:space="preserve">
          <source>For debuggers that can be modified to accept new types, the following extensions help them fully support the types.</source>
          <target state="translated">对于可以修改以接受新类型的调试器,以下扩展有助于它们完全支持这些类型。</target>
        </trans-unit>
        <trans-unit id="63e9558b3c028e1d9a23d1722de151ab9342540d" translate="yes" xml:space="preserve">
          <source>For dynamic array and object parameters, which are passed by reference, in/out/ref apply only to the reference and not the contents.</source>
          <target state="translated">对于通过引用传递的动态数组和对象参数,in/out/ref只适用于引用而不是内容。</target>
        </trans-unit>
        <trans-unit id="26ffddfdbc1c41c2be1034e80310b3f852b74078" translate="yes" xml:space="preserve">
          <source>For each active attribute (ref/const/nogc/etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">对于每个活动属性（ref / const / nogc / etc），请调用 &lt;code&gt;fp&lt;/code&gt; 并为工作参数添加一个void *和该属性的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="8eea3bce7669308b1434c353731e136dc4b97c1c" translate="yes" xml:space="preserve">
          <source>For each active modifier (MODFlags.const_, MODFlags.immutable_, etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">对于每个活动的修饰符（MODFlags.const_，MODFlags.immutable_等），调用 &lt;code&gt;fp&lt;/code&gt; 并使用void *作为工作参数，并使用属性的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="3203682624a9b4a1635c6de69e488d06fa56e15c" translate="yes" xml:space="preserve">
          <source>For each evaluation that yields a temporary value, the lifetime of that temporary begins at the evaluation point, similarly to creation of a usual named value initialized with an expression.</source>
          <target state="translated">对于每次产生临时值的评价,该临时值的生命期从评价点开始,类似于创建一个用表达式初始化的普通命名值。</target>
        </trans-unit>
        <trans-unit id="5f7caa6316d56bf976ab623e5dd0b440be2fe098" translate="yes" xml:space="preserve">
          <source>For each function &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;fun&lt;/code&gt;, the corresponding seed type &lt;code&gt;S&lt;/code&gt; is &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an element of &lt;code&gt;r&lt;/code&gt;: &lt;code&gt;ElementType!R&lt;/code&gt; for ranges, and &lt;code&gt;ForeachType!R&lt;/code&gt; otherwise.</source>
          <target state="translated">对于每个功能 &lt;code&gt;f&lt;/code&gt; 在 &lt;code&gt;fun&lt;/code&gt; ，相应的种子类型 &lt;code&gt;S&lt;/code&gt; 是 &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt; ，其中 &lt;code&gt;e&lt;/code&gt; 是的元件 &lt;code&gt;r&lt;/code&gt; ！ &lt;code&gt;ElementType!R&lt;/code&gt; 为范围，以及 &lt;code&gt;ForeachType!R&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="89f96ba2b9022471ac4b3f99072ac57893d52c5d" translate="yes" xml:space="preserve">
          <source>For each function that has exception handlers, an EH table entry is generated.</source>
          <target state="translated">对于每个有异常处理程序的函数,都会生成一个EH表项。</target>
        </trans-unit>
        <trans-unit id="c170bc5a2dcbb7f263f34807c28c73343f6168e3" translate="yes" xml:space="preserve">
          <source>For each template parameter, the following rules are applied in order until a type is deduced for each parameter:</source>
          <target state="translated">对于每个模板参数,依次应用以下规则,直到为每个参数推导出一个类型。</target>
        </trans-unit>
        <trans-unit id="de2d36eb496ad6425d4fddf01b0f74d4997c1c21" translate="yes" xml:space="preserve">
          <source>For each type &lt;code&gt;T&lt;/code&gt; on the left-hand side and each type &lt;code&gt;U&lt;/code&gt; on the right-hand side, values of type &lt;code&gt;T&lt;/code&gt; can be compared with values of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">对于左侧的每种类型 &lt;code&gt;T&lt;/code&gt; 和右侧的每种类型 &lt;code&gt;U&lt;/code&gt; ，可以将类型 &lt;code&gt;T&lt;/code&gt; 的值与类型 &lt;code&gt;U&lt;/code&gt; 的值进行比较。</target>
        </trans-unit>
        <trans-unit id="e27d5d7f20198430510bed8d554d11950a10ed02" translate="yes" xml:space="preserve">
          <source>For each value &lt;code&gt;v1&lt;/code&gt; on the left-hand side and each value &lt;code&gt;v2&lt;/code&gt; on the right-hand side, the expression &lt;code&gt;v1 == v2&lt;/code&gt; is true.</source>
          <target state="translated">对于左侧的每个值 &lt;code&gt;v1&lt;/code&gt; 和右侧的每个值 &lt;code&gt;v2&lt;/code&gt; ，表达式 &lt;code&gt;v1 == v2&lt;/code&gt; 为true。</target>
        </trans-unit>
        <trans-unit id="9025d5cca105be0e8976e2851061cc835c9a962a" translate="yes" xml:space="preserve">
          <source>For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly initialized. An UUID is empty if &lt;a href=&quot;#empty&quot;&gt;`UUID.empty`&lt;/a&gt; is true. Empty UUIDs are equal to &lt;code&gt;UUID.init&lt;/code&gt;, which is a UUID with all 16 bytes set to 0. Use UUID's constructors or the UUID generator functions to get an initialized UUID.</source>
          <target state="translated">为了提高效率，UUID被实现为结构。因此，如果未明确初始化，则UUID为空。如果&lt;a href=&quot;#empty&quot;&gt;UUID.empty&lt;/a&gt;为true，则UUID为空。空的UUID等于 &lt;code&gt;UUID.init&lt;/code&gt; ，这是一个UUID，所有16个字节均设置为0。使用UUID的构造函数或UUID生成器函数来获取已初始化的UUID。</target>
        </trans-unit>
        <trans-unit id="62d0aac1e2c0659f1732b0c95533d24eac16f4a7" translate="yes" xml:space="preserve">
          <source>For example the primitives &lt;code&gt;c.remove(r)&lt;/code&gt; and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; both remove the sequence of elements in range &lt;code&gt;r&lt;/code&gt; from the container &lt;code&gt;c&lt;/code&gt;. The primitive &lt;code&gt;c.remove(r)&lt;/code&gt; guarantees &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;) complexity in the worst case and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; relaxes this guarantee to &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;).  Since a sequence of elements can be removed from a &lt;a href=&quot;std_container_dlist&quot;&gt;doubly linked list&lt;/a&gt; in constant time, &lt;code&gt;DList&lt;/code&gt; provides the primitive &lt;code&gt;c.remove(r)&lt;/code&gt; as well as &lt;code&gt;c.linearRemove(r)&lt;/code&gt;. On the other hand &lt;a href=&quot;std_container_array&quot;&gt;Array&lt;/a&gt; only offers &lt;code&gt;c.linearRemove(r)&lt;/code&gt;.  The following table describes the common set of primitives that containers implement. A container need not implement all primitives, but if a primitive is implemented, it must support the syntax described in the &lt;b&gt;syntax&lt;/b&gt; column with the semantics described in the &lt;b&gt;description&lt;/b&gt; column, and it must not have a worst-case complexity worse than denoted in big-O notation in the &amp;Omicron;(&lt;code&gt;&amp;middot;&lt;/code&gt;) column. Below, &lt;code&gt;C&lt;/code&gt; means a container type, &lt;code&gt;c&lt;/code&gt; is a value of container type, &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; represents the effective length of value &lt;code&gt;x&lt;/code&gt;, which could be a single element (in which case &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;), a container, or a range.</source>
          <target state="translated">例如，图元 &lt;code&gt;c.remove(r)&lt;/code&gt; 和 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 都从容器 &lt;code&gt;c&lt;/code&gt; 中删除了范围 &lt;code&gt;r&lt;/code&gt; 中的元素序列。原始 &lt;code&gt;c.remove(r)&lt;/code&gt; 保证&amp;Omicron;（ &lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;[R&lt;/sub&gt;为log N &lt;sub&gt;&amp;Ccedil;&lt;/sub&gt;）在最坏情况下的复杂性和 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 放宽了这一条件保证&amp;Omicron;（ &lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;&amp;Ccedil;&lt;/sub&gt;）。由于元素的序列可以从被删除&lt;a href=&quot;std_container_dlist&quot;&gt;双向链表&lt;/a&gt;在恒定的时间， &lt;code&gt;DList&lt;/code&gt; 提供原始 &lt;code&gt;c.remove(r)&lt;/code&gt; 以及 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 。另一方面&lt;a href=&quot;std_container_array&quot;&gt;数组&lt;/a&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;只提供 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 。下表描述了容器实现的通用原语集。容器不需要实现所有原语，但是如果实现了原语，则它必须支持&lt;b&gt;语法&lt;/b&gt;列中所描述的&lt;b&gt;语法&lt;/b&gt;以及&lt;b&gt;描述&lt;/b&gt;列中所&lt;b&gt;描述&lt;/b&gt;的语义，并且容器的最坏情况下的复杂性也不应比大容器中所&lt;b&gt;描述的&lt;/b&gt;复杂。 &amp;Omicron;（ &lt;code&gt;&amp;middot;&lt;/code&gt; ）列中的O标记。下面， &lt;code&gt;C&lt;/code&gt; 表示容器类型， &lt;code&gt;c&lt;/code&gt; 是容器类型的值， &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; 表示值 &lt;code&gt;x&lt;/code&gt; 的有效长度，它可以是单个元素（在这种情况下， &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ），容器或范围。</target>
        </trans-unit>
        <trans-unit id="d00edd8f12a04d1befc302c87668dfdb2d903e2a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\U0001F603&lt;/code&gt; represents the Unicode character U+1F603 (SMILING FACE WITH OPEN MOUTH).</source>
          <target state="translated">例如， &lt;code&gt;\U0001F603&lt;/code&gt; 表示Unicode字符U + 1F603（带有张开嘴的笑脸）。</target>
        </trans-unit>
        <trans-unit id="bddb2b6572ea79b1700e73180c6a9ef4a9e2c7be" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\u03B3&lt;/code&gt; represents the Unicode character &amp;gamma; (U+03B3 - GREEK SMALL LETTER GAMMA).</source>
          <target state="translated">例如， &lt;code&gt;\u03B3&lt;/code&gt; 表示Unicode字符&amp;gamma;（U + 03B3-希腊小写字母GAMMA）。</target>
        </trans-unit>
        <trans-unit id="e8c9021af829ec2346f217a33bffab12b0880918" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;a[index]&lt;/code&gt; is really &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;s.f&lt;/code&gt; is really &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;a[index]&lt;/code&gt; 实际上 &lt;code&gt;a&lt;/code&gt; ，而 &lt;code&gt;s.f&lt;/code&gt; 实际上 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aee49e2b5de63bc28985d9e3f5b2391109f50868" translate="yes" xml:space="preserve">
          <source>For example, consider a class that is a container for two elements:</source>
          <target state="translated">例如,考虑一个类,它是两个元素的容器。</target>
        </trans-unit>
        <trans-unit id="f4060213712449048c8c23e8aed13169261c66f1" translate="yes" xml:space="preserve">
          <source>For example, for the Intel Pentium:</source>
          <target state="translated">例如,对于英特尔奔腾。</target>
        </trans-unit>
        <trans-unit id="56a66959fa3d6d051e3f2985a858c24aef88cfec" translate="yes" xml:space="preserve">
          <source>For example, given a class &lt;code&gt;Sum&lt;/code&gt; that is used to add two values, a unit test can be given:</source>
          <target state="translated">例如，给定用于将两个值相加的 &lt;code&gt;Sum&lt;/code&gt; 类，可以给出单元测试：</target>
        </trans-unit>
        <trans-unit id="afa20f7fd4e06e98278c1c050fed1f04af8aa95d" translate="yes" xml:space="preserve">
          <source>For example, here is how to remove a single element from an array:</source>
          <target state="translated">例如,下面是如何从一个数组中删除一个元素。</target>
        </trans-unit>
        <trans-unit id="664b22b4de56d86a94d4d1f08efe5f39ea8b5955" translate="yes" xml:space="preserve">
          <source>For example, if this qualifies to 'a1.a2' and pkg - to 'a1.a2.a3', this function returns 'true'. If it is other way around or qualified package paths conflict function returns 'false'.</source>
          <target state="translated">例如,如果这个限定为'a1.a2',而 pkg -限定为'a1.a2.a3',这个函数返回'true'。如果是其他方式或者限定的包路径冲突,函数返回 'false'。</target>
        </trans-unit>
        <trans-unit id="2f4a0bc25491ad453cd52460e2badab7db117513" translate="yes" xml:space="preserve">
          <source>For example, in order to overload the &lt;code&gt;-&lt;/code&gt; (negation) operator for struct S, and no other operator:</source>
          <target state="translated">例如，为了重载结构S 的 &lt;code&gt;-&lt;/code&gt; （否定）运算符，而没有其他运算符：</target>
        </trans-unit>
        <trans-unit id="1db4a09c9c6a230d99b45c4869c4f6e84c23d582" translate="yes" xml:space="preserve">
          <source>For example, one could redefine &lt;code&gt;DDOC_SUMMARY&lt;/code&gt;:</source>
          <target state="translated">例如，可以重新定义 &lt;code&gt;DDOC_SUMMARY&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0e5d29b3a3287b6048a7baf84989543162cfde72" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;immutable&lt;/code&gt; type qualifier can be used to create variables of immutable type, such as:</source>
          <target state="translated">例如， &lt;code&gt;immutable&lt;/code&gt; 类型限定符可用于创建不可变类型的变量，例如：</target>
        </trans-unit>
        <trans-unit id="b3a7c81f27baa62d867db8143dafce975505e522" translate="yes" xml:space="preserve">
          <source>For example, the expression &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt; is permitted when &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt; are expressions yielding pointers to memory block</source>
          <target state="translated">例如，当 &lt;code&gt;p1&lt;/code&gt; ， &lt;code&gt;p2&lt;/code&gt; 是产生指向存储块的指针的表达式时，允许使用表达式 &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afa193b836783a5ecabcde946cad5a9128e2b421" translate="yes" xml:space="preserve">
          <source>For example, the following function template only matches with odd values of &lt;code&gt;N&lt;/code&gt;:</source>
          <target state="translated">例如，以下功能模板仅与 &lt;code&gt;N&lt;/code&gt; 的奇数值匹配：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="38096dc369d1ebe6ec7ec60de5ac2d73db72feee" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\101&lt;/code&gt; represents the character with the value 65 (&lt;code&gt;'A'&lt;/code&gt;). Analogous to hexadecimal characters, the largest byte value is &lt;code&gt;\377&lt;/code&gt; (= &lt;code&gt;\xFF&lt;/code&gt; in hexadecimal or &lt;code&gt;255&lt;/code&gt; in decimal)</source>
          <target state="translated">例如： &lt;code&gt;\101&lt;/code&gt; 代表具有值65（ &lt;code&gt;'A'&lt;/code&gt; ）的字符。类似于十六进制字符，最大字节值为 &lt;code&gt;\377&lt;/code&gt; （十六进制为 &lt;code&gt;\xFF&lt;/code&gt; 或十进制为 &lt;code&gt;255&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8187ba92149a37ed481170300ec07180dd3c8361" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\xFF&lt;/code&gt; represents the character with the value 255.</source>
          <target state="translated">例如： &lt;code&gt;\xFF&lt;/code&gt; 表示值为255的字符。</target>
        </trans-unit>
        <trans-unit id="4d1688fe7c391489009113fe8f20b160cce3978f" translate="yes" xml:space="preserve">
          <source>For examples see the &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">例子可见的&lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt;下面。</target>
        </trans-unit>
        <trans-unit id="79381ea951fd6aadf813123f5b529dd772681030" translate="yes" xml:space="preserve">
          <source>For finite ranges, the result of &lt;code&gt;opSlice&lt;/code&gt; must be of the same type as the original range type. If the range defines &lt;code&gt;opDollar&lt;/code&gt;, then it must support subtraction.</source>
          <target state="translated">对于有限范围， &lt;code&gt;opSlice&lt;/code&gt; 的结果必须与原始范围类型相同。如果范围定义了 &lt;code&gt;opDollar&lt;/code&gt; ，那么它必须支持减法。</target>
        </trans-unit>
        <trans-unit id="c77ba69b2b7b1720fb5f6b789826c71a3c605b97" translate="yes" xml:space="preserve">
          <source>For float, double, and real values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. The values &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;+0&lt;/code&gt; are considered equal. If either or both operands are NAN, then &lt;code&gt;==&lt;/code&gt; returns false and &lt;code&gt;!=&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, the bit patterns of the common type are compared for equality.</source>
          <target state="translated">对于浮点，双精度和实数值，在进行比较之前，将应用&amp;ldquo; &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;常规算术转换&amp;rdquo;&lt;/a&gt;将它们转换为通用类型。值 &lt;code&gt;-0&lt;/code&gt; 和 &lt;code&gt;+0&lt;/code&gt; 被视为相等。如果一个或两个操作数均为NAN，则 &lt;code&gt;==&lt;/code&gt; 返回false， &lt;code&gt;!=&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。否则，将比较公共类型的位模式是否相等。</target>
        </trans-unit>
        <trans-unit id="ec28333c5408aa27a2824def03dd893394acfa05" translate="yes" xml:space="preserve">
          <source>For floating point inputs, calculations are made in &lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt; precision for &lt;code&gt;real&lt;/code&gt; inputs and in &lt;code&gt;double&lt;/code&gt; precision otherwise (Note this is a special case that deviates from &lt;code&gt;fold&lt;/code&gt;'s behavior, which would have kept &lt;code&gt;float&lt;/code&gt; precision for a &lt;code&gt;float&lt;/code&gt; range). For all other types, the calculations are done in the same type obtained from from adding two elements of the range, which may be a different type from the elements themselves (for example, in case of &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;integral promotion&lt;/a&gt;).</source>
          <target state="translated">对于浮点输入，将以&lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt;精度对 &lt;code&gt;real&lt;/code&gt; 输入进行计算，否则将以 &lt;code&gt;double&lt;/code&gt; 精度进行计算（请注意，这是一种特殊情况，它偏离 &lt;code&gt;fold&lt;/code&gt; 的行为，这会在 &lt;code&gt;float&lt;/code&gt; 范围内保持 &lt;code&gt;float&lt;/code&gt; 精度）。对于所有其他类型，计算是通过将范围内的两个元素相加而获得的相同类型进行的，这些元素可能与元素本身不同（例如，在&lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;积分提升的&lt;/a&gt;情况下）。</target>
        </trans-unit>
        <trans-unit id="765c4ec4b98b1848bab9c8fba86795001e6760ec" translate="yes" xml:space="preserve">
          <source>For floating point operands, the * and / operations correspond to the IEEE 754 floating point equivalents. % is not the same as the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas for IEEE 754, remainder(15.0,10.0) == -5.0.</source>
          <target state="translated">对于浮点操作数,*和/操作对应于IEEE 754浮点等价物。%与IEEE 754的余数不同。例如,15.0 % 10.0 ==5.0,而对于IEEE 754,remaxinder(15.0,10.0)==-5.0。</target>
        </trans-unit>
        <trans-unit id="311831dfcbe2aa85299a9b7419ec3f7edbd674b9" translate="yes" xml:space="preserve">
          <source>For floating point operations and expression intermediate values, a greater precision can be used than the type of the expression. Only the minimum precision is set by the types of the operands, not the maximum. &lt;b&gt;Implementation Note:&lt;/b&gt; On Intel x86 machines, for example, it is expected (but not required) that the intermediate calculations be done to the full 80 bits of precision implemented by the hardware.</source>
          <target state="translated">对于浮点运算和表达式中间值，可以使用比表达式类型更高的精度。操作数的类型仅设置最小精度，而不是最大精度。&lt;b&gt;实施注意：&lt;/b&gt;例如，在Intel x86机器上，可以（但不是必需）对硬件实现的全部80位精度进行中间计算。</target>
        </trans-unit>
        <trans-unit id="a8f36fac9b0314aa81c6e99d081aedbe4af658c5" translate="yes" xml:space="preserve">
          <source>For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</source>
          <target state="translated">对于浮点数,最大的有效载荷是0x3F_FFFF。对于双数,它是0x3_FFFF_FFFF_FFFF。对于80位或128位的雷亚尔,它是0x3FFF_FFFF_FFFF_FFFF。</target>
        </trans-unit>
        <trans-unit id="f68bb29877591d4b489a9f6fff54379ee749f0f3" translate="yes" xml:space="preserve">
          <source>For forward compatibility, the CPU is compared against different microarchitectures. For 32-bit x86, comparisons are made against the Intel PPro/PII/PIII/PM family.</source>
          <target state="translated">为了实现正向兼容性,将CPU与不同的微架构进行比较。对于32位x86,则与Intel PPro/PII/PIII/PM系列进行比较。</target>
        </trans-unit>
        <trans-unit id="cb68f2aaef1107ffda2b00fc87de858154352d8d" translate="yes" xml:space="preserve">
          <source>For functions which operate on Unicode characters, see &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关对Unicode字符进行操作的函数，请参见&lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c427f88fad780106904fb230a561fe45ae8afed" translate="yes" xml:space="preserve">
          <source>For functions, the &lt;code&gt;auto&lt;/code&gt; attribute means return type inference. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">对于函数， &lt;code&gt;auto&lt;/code&gt; 属性表示返回类型推断。请参阅&lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;自动功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb6e8700842932cee5fe004d021df4907ea6dd83" translate="yes" xml:space="preserve">
          <source>For further information see the the two functions defined inside of this template.</source>
          <target state="translated">更多信息请参见本模板中定义的两个函数。</target>
        </trans-unit>
        <trans-unit id="6d45ac630dd39944ad55493060e8c4dac92d7fc5" translate="yes" xml:space="preserve">
          <source>For garbage collected pointers and references, however, there are some restrictions. These restrictions are minor, but they are intended to enable the maximum flexibility in garbage collector design.</source>
          <target state="translated">然而,对于垃圾收集的指针和引用,有一些限制。这些限制虽然不大,但其目的是为了使垃圾收集器的设计具有最大的灵活性。</target>
        </trans-unit>
        <trans-unit id="b7afa355fcaa31af2cd3f80d70dbcf199acfca98" translate="yes" xml:space="preserve">
          <source>For historical compatibility when &lt;code&gt;nbits == 192&lt;/code&gt; and &lt;code&gt;UIntType&lt;/code&gt; is &lt;code&gt;uint&lt;/code&gt; a legacy hybrid PRNG is used consisting of a 160-bit xorshift combined with a 32-bit counter. This combined generator has period equal to the least common multiple of &lt;code&gt;2^^160 - 1&lt;/code&gt; and &lt;code&gt;2^^32&lt;/code&gt;.</source>
          <target state="translated">为了实现历史兼容性，当 &lt;code&gt;nbits == 192&lt;/code&gt; 且 &lt;code&gt;UIntType&lt;/code&gt; 为 &lt;code&gt;uint&lt;/code&gt; 时,将使用由160位xorshift和32位计数器组成的传统混合PRNG。该组合生成器的周期等于 &lt;code&gt;2^^160 - 1&lt;/code&gt; 和 &lt;code&gt;2^^32&lt;/code&gt; 最小公倍数。</target>
        </trans-unit>
        <trans-unit id="373d2d5153ba00f28887ffdca247e026ee396782" translate="yes" xml:space="preserve">
          <source>For hot code paths, it is worthwhile to check to see if the void initializer actually improves results before using it.</source>
          <target state="translated">对于热门的代码路径,在使用前不妨先检查一下void初始化器是否真的能提高效果。</target>
        </trans-unit>
        <trans-unit id="e4f4bd7aa4cad79620e1f6020bf4450eeadc7446" translate="yes" xml:space="preserve">
          <source>For illustration purposes only, every method call results in assertion failure. Use &lt;a href=&quot;#utfMatcher&quot;&gt;&lt;code&gt;utfMatcher&lt;/code&gt;&lt;/a&gt; to obtain a concrete matcher for UTF-8 or UTF-16 encodings.</source>
          <target state="translated">仅出于说明目的，每个方法调用都会导致断言失败。使用&lt;a href=&quot;#utfMatcher&quot;&gt; &lt;code&gt;utfMatcher&lt;/code&gt; &lt;/a&gt;可以获取UTF-8或UTF-16编码的具体匹配器。</target>
        </trans-unit>
        <trans-unit id="4cd5f2dc243960435d23cc958481129bcfb42bcc" translate="yes" xml:space="preserve">
          <source>For infinite ranges, when</source>
          <target state="translated">对于无限范围,当</target>
        </trans-unit>
        <trans-unit id="aae2fd6469d641f1e8d553dabcf2fe7c0be1babf" translate="yes" xml:space="preserve">
          <source>For instance, if the function used to generate a range of time points generated successive Easters (i.e. you're iterating over all of the Easters within the interval), the initial date probably isn't an Easter. Using &lt;code&gt;PopFirst.yes&lt;/code&gt; would tell the function which returned the range that &lt;code&gt;popFront&lt;/code&gt; was to be called so that front would then be an Easter - the next one generated by the function (which when iterating forward would be the Easter following the original &lt;code&gt;front&lt;/code&gt;, while when iterating backward, it would be the Easter prior to the original &lt;code&gt;front&lt;/code&gt;). If &lt;code&gt;PopFirst.no&lt;/code&gt; were used, then &lt;code&gt;front&lt;/code&gt; would remain the original time point and it would not necessarily be a time point which would be generated by the range-generating function (which in many cases is exactly what is desired - e.g. if iterating over every day starting at the beginning of the interval).</source>
          <target state="translated">例如，如果用于生成一系列时间点的函数生成了连续的复活节（即您要遍历该间隔内的所有复活节），则初始日期可能不是复活节。使用 &lt;code&gt;PopFirst.yes&lt;/code&gt; 会告诉该函数，该函数返回要调用的 &lt;code&gt;popFront&lt;/code&gt; 范围，因此front将成为Easter-该函数生成的下一个复活节（向前迭代时，它将是原始 &lt;code&gt;front&lt;/code&gt; 之前的Easter ，而当迭代落后，这将是复活节之前的原始 &lt;code&gt;front&lt;/code&gt; ）。如果使用 &lt;code&gt;PopFirst.no&lt;/code&gt; ，则 &lt;code&gt;front&lt;/code&gt; 仍将保留原始时间点，而不一定是范围生成功能所生成的时间点（在许多情况下正是所需的时间点-例如，如果从间隔开始时每天迭代一次） 。</target>
        </trans-unit>
        <trans-unit id="1a761bf1c3bac8790220dd0e044887eeb25a2cc8" translate="yes" xml:space="preserve">
          <source>For instructions with the imm8 version: PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW, PSRLDQ, PSLLDQ</source>
          <target state="translated">用于与imm8版本的说明。PSLLD,PSLLQ,PSLLW,PSRAD,PSRAW,PSRLD,PSRLQ,PSRLW,PSRLDQ,PSLLDQ。</target>
        </trans-unit>
        <trans-unit id="abfb408bf733bafad2f02f380cf2ab1c7688837d" translate="yes" xml:space="preserve">
          <source>For instructions: CMPPD, CMPSS, CMPSD, CMPPS, PSHUFD, PSHUFHW, PSHUFLW, BLENDPD, BLENDPS, DPPD, DPPS, MPSADBW, PBLENDW, ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS</source>
          <target state="translated">供说明。CMPPD、CMPSS、CMPSD、CMPPS、PSHUFD、PSHUFHW、PSHUFLW、BLENDPD、BLENDPS、DPPD、DPPS、MPSADBW、PBLENDW、ROUNDPD、ROUNDPS、ROUNDSD、ROUNDSS。</target>
        </trans-unit>
        <trans-unit id="2912089b8e4b5f7fb17c30aa7f29625c50f1f39a" translate="yes" xml:space="preserve">
          <source>For integral operands of the &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators, the quotient rounds towards zero and the remainder has the same sign as the dividend. If the divisor is zero, an Exception is thrown.</source>
          <target state="translated">对于 &lt;code&gt;/&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 运算符的整数操作数，商会四舍五入为零，余数与除数具有相同的符号。如果除数为零，则抛出异常。</target>
        </trans-unit>
        <trans-unit id="00fe6a3ea358be700add2733e7f987f7657eccea" translate="yes" xml:space="preserve">
          <source>For integral operands, the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; correspond to multiply, divide, and modulus operations. For multiply, overflows are ignored and simply chopped to fit into the integral type.</source>
          <target state="translated">对于整数操作数， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 对应于乘法，除法和模运算。对于乘法，将忽略溢出并将其简单地切整以适合整数类型。</target>
        </trans-unit>
        <trans-unit id="f8089e9fce56a8de104b1a2fd89f78f4e3794e38" translate="yes" xml:space="preserve">
          <source>For large file support, there is also a LARGE version of the key which takes an off_t type, allowing platforms with larger off_t sizes to handle larger files. See below for INFILESIZE_LARGE.</source>
          <target state="translated">对于大文件的支持,还有一个LARGE版本的key,它取一个off_t类型,允许有较大off_t大小的平台处理大文件。参见下面的INFILESIZE_LARGE。</target>
        </trans-unit>
        <trans-unit id="4573bc72a0b35e6968fbc43281884135acda5317" translate="yes" xml:space="preserve">
          <source>For many processes, a grapheme cluster behaves as if it was a single character with the same properties as its grapheme base. Effectively, nonspacing marks apply</source>
          <target state="translated">对于许多过程来说,一个词组的行为就像一个单一的字符,具有与其词组基础相同的属性。实际上,非间隔标记适用于</target>
        </trans-unit>
        <trans-unit id="d9d2c4569580379d483d010c37b2df4e739e00dd" translate="yes" xml:space="preserve">
          <source>For methods, it would be the class object or struct value the method is called on. For nested functions it would be the enclosing function's stack frame.</source>
          <target state="translated">对于方法来说,它是方法被调用的类对象或结构值。对于嵌套函数,它将是包围函数的堆栈框架。</target>
        </trans-unit>
        <trans-unit id="c658e43c1de6b0fdb8fb67e28199ecda730200d8" translate="yes" xml:space="preserve">
          <source>For more control than the high level functions provide, use the low level API:</source>
          <target state="translated">如果想获得比高级函数更多的控制权,请使用低级API。</target>
        </trans-unit>
        <trans-unit id="62fcc5c0c32d14129884b840a9ef5db5f9b4d71a" translate="yes" xml:space="preserve">
          <source>For more info about callbacks read the &lt;a href=&quot;function#closures&quot;&gt;closures&lt;/a&gt; section.</source>
          <target state="translated">有关回调的更多信息，请阅读&lt;a href=&quot;function#closures&quot;&gt;闭包&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="4e48b9f8da2dcff74dfa76b614f30e09e82d9357" translate="yes" xml:space="preserve">
          <source>For more information on normalization forms see the &lt;a href=&quot;#Normalization&quot;&gt;normalization section&lt;/a&gt;.</source>
          <target state="translated">有关规范化表格的更多信息，请参见&lt;a href=&quot;#Normalization&quot;&gt;规范化部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c70774a3bc49910eb2a297e31d36c248a26d7f7c" translate="yes" xml:space="preserve">
          <source>For more information please see the full section on &lt;a href=&quot;unittest#documented-unittests&quot;&gt;documented unit tests&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;unittest#documented-unittests&quot;&gt;记录的单元测试&lt;/a&gt;的完整部分。</target>
        </trans-unit>
        <trans-unit id="f4836c4e8b6fd2beb1b18962cae04c16a239752f" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;reference documentation&lt;/a&gt; and the &lt;code&gt;ld&lt;/code&gt; man page.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;参考文档&lt;/a&gt;和 &lt;code&gt;ld&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="d343011cf3b0f9c5af4eccef2d47be216bb18517" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D&lt;/a&gt;</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;D中的现代COM编程。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c75305c01a420c526f9930f5f2afef16712fe3db" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;Compile-time Sequences&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;编译时序列&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="232f8923a5b9a1c36aaeed4b764cc4a027de9c86" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;template#function-templates&quot;&gt;function templates&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;template#function-templates&quot;&gt;功能模板&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14fe53fd058540daece4c12310ac08fab7493096" translate="yes" xml:space="preserve">
          <source>For more information, see: &lt;a href=&quot;attribute#uda&quot;&gt;User-Defined Attributes&lt;/a&gt;</source>
          <target state="translated">有关更多信息，请参见：&lt;a href=&quot;attribute#uda&quot;&gt;用户定义的属性&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b01b147c4aa5229fbefd3dfcace458d961ffaae" translate="yes" xml:space="preserve">
          <source>For more on infering uniqueness see the &lt;b&gt;unique&lt;/b&gt; and &lt;b&gt;lent&lt;/b&gt; keywords in the &lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt; language.  The downside of using &lt;code&gt;assumeUnique&lt;/code&gt;'s convention-based usage is that at this time there is no formal checking of the correctness of the assumption; on the upside, the idiomatic use of &lt;code&gt;assumeUnique&lt;/code&gt; is simple and rare enough to be tolerable.</source>
          <target state="translated">有关推断唯一性的更多信息，请参见&lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt;语言中的&lt;b&gt;unique&lt;/b&gt;和&lt;b&gt;lent&lt;/b&gt;关键字。使用 &lt;code&gt;assumeUnique&lt;/code&gt; 的基于约定的用法的不利之处在于，目前尚无形式上正确的假设检查。从 &lt;code&gt;assumeUnique&lt;/code&gt; 来说，对前提条件的假设假设的惯用用法很简单，而且稀有到可以容忍的程度。</target>
        </trans-unit>
        <trans-unit id="9821fa00e5b3937536d63348fff48dbf21802af0" translate="yes" xml:space="preserve">
          <source>For most purposes, direct usage of this template is not necessary; instead, this module provides default implementations: &lt;a href=&quot;#Base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt;, implementing basic Base64 encoding, and &lt;a href=&quot;#Base64URL&quot;&gt;&lt;code&gt;Base64URL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base64URLNoPadding&quot;&gt;&lt;code&gt;Base64URLNoPadding&lt;/code&gt;&lt;/a&gt;, that implement the Base64 variant for use in URLs and filenames, with and without padding, respectively.</source>
          <target state="translated">在大多数情况下，无需直接使用此模板；代替，该模块提供默认实现：&lt;a href=&quot;#Base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; 的&lt;/a&gt;，实施基本Base64编码，和&lt;a href=&quot;#Base64URL&quot;&gt; &lt;code&gt;Base64URL&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Base64URLNoPadding&quot;&gt; &lt;code&gt;Base64URLNoPadding&lt;/code&gt; &lt;/a&gt;，实现将在URL和文件名，有和没有填充，分别使用中的Base64变体。</target>
        </trans-unit>
        <trans-unit id="1227b6928512c13bafca17372e6fc839cf749e01" translate="yes" xml:space="preserve">
          <source>For negative durations, all of the split values will be negative.</source>
          <target state="translated">对于负的持续时间,所有的拆分值都将为负。</target>
        </trans-unit>
        <trans-unit id="45d1ac4eefadfd952fb52f8057a9eb1805d7b858" translate="yes" xml:space="preserve">
          <source>For non-struct types, &lt;code&gt;move&lt;/code&gt; just performs &lt;code&gt;target = source&lt;/code&gt;:</source>
          <target state="translated">对于非结构类型， &lt;code&gt;move&lt;/code&gt; 仅执行 &lt;code&gt;target = source&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3570c921d353ad6046f6122f9d8cb40d604f2aae" translate="yes" xml:space="preserve">
          <source>For other operand types, identity is defined as being the same as equality.</source>
          <target state="translated">对于其他操作数类型,身份被定义为与平等相同。</target>
        </trans-unit>
        <trans-unit id="c79c85aac54555c7fe4b24d5b33131b97310e7b3" translate="yes" xml:space="preserve">
          <source>For other sized structs and static arrays, the return value is stored through a hidden pointer passed as an argument to the function.</source>
          <target state="translated">对于其他大小的结构和静态数组,返回值通过作为函数参数传递的隐藏指针来存储。</target>
        </trans-unit>
        <trans-unit id="c922333737093f82b45fffe13ff631745c29e34e" translate="yes" xml:space="preserve">
          <source>For other types, the argument is built with itself, as in:</source>
          <target state="translated">对于其他类型,参数是和自己一起建立的,如。</target>
        </trans-unit>
        <trans-unit id="936523f8bfb5590c510abb12f08771cbe0e0675b" translate="yes" xml:space="preserve">
          <source>For our new type 'this', which is type-constructed from t, fill in the cto, ito, sto, scto, wto shortcuts.</source>
          <target state="translated">对于我们的新类型'this',它是由t构造的类型,填写cto、ito、sto、scto、wto的快捷方式。</target>
        </trans-unit>
        <trans-unit id="4b41c44e66bd12d32d9b45595720696363ec412b" translate="yes" xml:space="preserve">
          <source>For popular C libraries, the first place to look for the corresponding D interface file is the &lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt;. If it isn't there already, and you write one, please contribute it to the Deimos Project.</source>
          <target state="translated">对于流行的C库，查找对应的D接口文件的第一个地方是&lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt;。如果还不存在，请编写一个，然后将其贡献给Deimos项目。</target>
        </trans-unit>
        <trans-unit id="dd500fbbdcecf0b15b4a7bec7168a77dbb809b02" translate="yes" xml:space="preserve">
          <source>For precise typing of that area, you can also let the compiler generate the class instance into the DATA segment for you:</source>
          <target state="translated">为了精确地输入该区域,你也可以让编译器为你生成类实例到data段。</target>
        </trans-unit>
        <trans-unit id="d95500d6486dd9976894874f4bc1686c74984f1a" translate="yes" xml:space="preserve">
          <source>For pretty-printing a type.</source>
          <target state="translated">用于漂亮地打印字体。</target>
        </trans-unit>
        <trans-unit id="6beaf38011ce8934c0bf0fe14801463a84176de7" translate="yes" xml:space="preserve">
          <source>For printing two types with qualification when necessary.</source>
          <target state="translated">必要时,用于打印两种类型的限定。</target>
        </trans-unit>
        <trans-unit id="b457b27aba75e0c9b673db93afc4a6454c8737c9" translate="yes" xml:space="preserve">
          <source>For ranges that do not offer random access, &lt;code&gt;SearchPolicy.linear&lt;/code&gt; is the only policy allowed (and it must be specified explicitly lest it exposes user code to unexpected inefficiencies). For random-access searches, all policies are allowed, and &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; is the default.</source>
          <target state="translated">对于不提供随机访问的范围， &lt;code&gt;SearchPolicy.linear&lt;/code&gt; 是唯一允许的策略（并且必须明确指定，以免将用户代码暴露在意料之外的低效率中）。对于随机访问搜索，允许所有策略，默认值为 &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed3956141d9c50632728180436f8b91fa73ece41" translate="yes" xml:space="preserve">
          <source>For reals, logGamma is equivalent to log(fabs(gamma(x))).</source>
          <target state="translated">对于实际情况,logGamma相当于log(fabs(gamma(x)))。</target>
        </trans-unit>
        <trans-unit id="96cc49076f4a58f629be6c15f8c505a83f5ad981" translate="yes" xml:space="preserve">
          <source>For runtime testing to see if certain vector instructions are available, see the functions in &lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid&lt;/a&gt;.</source>
          <target state="translated">要进行运行时测试以查看某些矢量指令是否可用，请参阅&lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid中&lt;/a&gt;的函数。</target>
        </trans-unit>
        <trans-unit id="b0f737f02cc74529ec3e1d25c3b2fb5c37d91021" translate="yes" xml:space="preserve">
          <source>For some D implementations, such as a translator from D to C, an inline assembler makes no sense, and need not be implemented. The version statement can be used to account for this:</source>
          <target state="translated">对于一些D的实现,例如从D到C的翻译器,内联汇编器是没有意义的,也不需要实现。版本声明可以用来说明这一点。</target>
        </trans-unit>
        <trans-unit id="432250ecd3da26b3dac3ea1fed77d588163ee5c7" translate="yes" xml:space="preserve">
          <source>For stateless allocators, this does nothing.</source>
          <target state="translated">对于无状态的分配器来说,这没有任何作用。</target>
        </trans-unit>
        <trans-unit id="098a57b35500f4f0a012b83d59f1556df0c13332" translate="yes" xml:space="preserve">
          <source>For statements implement loops with initialization, test, and increment clauses.</source>
          <target state="translated">For语句实现具有初始化、测试和增量子句的循环。</target>
        </trans-unit>
        <trans-unit id="53f702e5ced5b4f4e7dbc696e5107fe16283acd0" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, equality is defined as the lengths of the arrays matching, and all the elements are equal.</source>
          <target state="translated">对于静态数组和动态数组,平等的定义是数组的长度相匹配,所有元素都相等。</target>
        </trans-unit>
        <trans-unit id="fa40b68079370408167ad68be5b40bbec28bf002" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, identity is defined as referring to the same array elements and the same number of elements.</source>
          <target state="translated">对于静态数组和动态数组,身份被定义为指同一数组元素和相同数量的元素。</target>
        </trans-unit>
        <trans-unit id="0ec6b65a9ed5b90b70c026136f3fd68edfea3f4e" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, the result of the relational op is the result of the operator applied to the first non-equal element of the array. If two arrays compare equal, but are of different lengths, the shorter array compares as &quot;less&quot; than the longer array.</source>
          <target state="translated">对于静态和动态数组,关系运算的结果是应用于数组中第一个非等值元素的运算符的结果。如果两个数组比较相等,但长度不同,那么较短的数组比较长的数组比较 &quot;少&quot;。</target>
        </trans-unit>
        <trans-unit id="f2b8a81160066cc4e2c9823b604d02970c2dda27" translate="yes" xml:space="preserve">
          <source>For static arrays:</source>
          <target state="translated">对于静态数组。</target>
        </trans-unit>
        <trans-unit id="e3e34261f3141bf464d51f74f924244b763433b8" translate="yes" xml:space="preserve">
          <source>For struct objects and floating point values, identity is defined as the bits in the operands being identical.</source>
          <target state="translated">对于结构体对象和浮点值,标识性定义为操作数中的位是相同的。</target>
        </trans-unit>
        <trans-unit id="dacb4ed6715c30c5a9147d7fcd6915634bae0082" translate="yes" xml:space="preserve">
          <source>For struct objects, equality means the result of the &lt;a href=&quot;operatoroverloading#equals&quot;&gt;&lt;code&gt;opEquals()&lt;/code&gt; member function&lt;/a&gt;. If an &lt;code&gt;opEquals()&lt;/code&gt; is not provided, equality is defined as the logical product of all equality results of the corresponding object fields.</source>
          <target state="translated">对于结构对象，相等意味着&lt;a href=&quot;operatoroverloading#equals&quot;&gt; &lt;code&gt;opEquals()&lt;/code&gt; 成员函数的结果&lt;/a&gt;。如果未提供 &lt;code&gt;opEquals()&lt;/code&gt; ，则将相等定义为相应对象字段的所有相等结果的逻辑积。</target>
        </trans-unit>
        <trans-unit id="77b81660c87ba600c859281896d0e680dc7a0639" translate="yes" xml:space="preserve">
          <source>For struct types, operator overloading for the identity assignment is allowed.</source>
          <target state="translated">对于结构类型,允许对身份分配进行运算符重载。</target>
        </trans-unit>
        <trans-unit id="7d6ebd4bd1de4cb13975d6ad6d6494f493e36039" translate="yes" xml:space="preserve">
          <source>For structs that do not define &lt;code&gt;toString&lt;/code&gt;, the conversion to string produces the list of fields.</source>
          <target state="translated">对于未定义 &lt;code&gt;toString&lt;/code&gt; 的结构，到string的转换将产生字段列表。</target>
        </trans-unit>
        <trans-unit id="24c5ae67500605fc6fe25591d513c37d81e53fba" translate="yes" xml:space="preserve">
          <source>For the &quot;this&quot; parameter to member functions</source>
          <target state="translated">对于成员函数的 &quot;this &quot;参数</target>
        </trans-unit>
        <trans-unit id="1c01d80e91a2499949025f2280ab6ed6d2555900" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; objects which does not have &lt;code&gt;toString&lt;/code&gt;,</source>
          <target state="translated">对于没有 &lt;code&gt;toString&lt;/code&gt; 的 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 对象，</target>
        </trans-unit>
        <trans-unit id="4f49cbadbf80fd5534728dbb0a52da7243f0e4cf" translate="yes" xml:space="preserve">
          <source>For the class objects which have input range interface,</source>
          <target state="translated">对于有输入范围接口的类对象。</target>
        </trans-unit>
        <trans-unit id="3fe70e23dba2fe2f6a6436972a79f198b1023846" translate="yes" xml:space="preserve">
          <source>For the default implementation, &lt;code&gt;notifyAll&lt;/code&gt;will behave like &lt;code&gt;notify&lt;/code&gt;.</source>
          <target state="translated">对于默认实现， &lt;code&gt;notifyAll&lt;/code&gt; 的行为类似于 &lt;code&gt;notify&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a32f3e2bbec4c5b80346149779ed01edefc9b85" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, a further check is made to see if the function can be called.</source>
          <target state="translated">对于表达 &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; 其中 &lt;code&gt;exp&lt;/code&gt; 是 &lt;code&gt;@property&lt;/code&gt; 功能，进行进一步检查以查看是否该函数可以被调用。</target>
        </trans-unit>
        <trans-unit id="b458b5efdd66ae7f2f84dbe61163a34a752450a1" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;typeof(exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, the type is the return type of the function, rather than the type of the function.</source>
          <target state="translated">对于表达式 &lt;code&gt;typeof(exp)&lt;/code&gt; ，其中 &lt;code&gt;exp&lt;/code&gt; 是 &lt;code&gt;@property&lt;/code&gt; 函数，类型是函数的返回类型，而不是函数的类型。</target>
        </trans-unit>
        <trans-unit id="4da3489e77815a3f59254a16848fd39b736c2ccf" translate="yes" xml:space="preserve">
          <source>For the given module, perform any post parsing analysis. Certain compiler backends (ie: GDC) have special placeholder modules whose source are empty, but code gets injected immediately after loading.</source>
          <target state="translated">对于给定的模块,执行任何后解析分析。某些编译器后端(即:GDC)有特殊的占位模块,其源码是空的,但代码会在加载后立即被注入。</target>
        </trans-unit>
        <trans-unit id="eee09d9bd02ca0e040c01e0c78e4b5fbf6e37934" translate="yes" xml:space="preserve">
          <source>For this CRC32 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">对于这个CRC32 Digest的实现,在默认构造后调用start是不必要的。只有在重置Digest时才需要调用start。</target>
        </trans-unit>
        <trans-unit id="cffc81d750572e8587c7a4c64f2343abc051fae9" translate="yes" xml:space="preserve">
          <source>For this MD5 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">对于这个MD5 Digest的实现,在默认构造后调用start是不必要的。只有在重置Digest时才需要调用start。</target>
        </trans-unit>
        <trans-unit id="ed2c37418037d9b0c7a9812c6d18534a64e6ecf7" translate="yes" xml:space="preserve">
          <source>For this RIPEMD160 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">对于这个RIPEMD160 Digest的实现,在默认构造后调用start是不必要的。只有在重置Digest时才需要调用start。</target>
        </trans-unit>
        <trans-unit id="249161f18b734896a386ad2283f2254a90cd8dc8" translate="yes" xml:space="preserve">
          <source>For this SHA Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">对于这个SHA Digest的实现,在默认构造后调用start是没有必要的。只有在重置Digest时才需要调用start。</target>
        </trans-unit>
        <trans-unit id="29b834a88118650bc23043a0e1a119bc9548636a" translate="yes" xml:space="preserve">
          <source>For unary &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;onOverflow&lt;/code&gt; is called if &lt;code&gt;lhs == Lhs.min&lt;/code&gt; and &lt;code&gt;Lhs&lt;/code&gt; is a signed type. The function returns &lt;code&gt;Lhs.max&lt;/code&gt;.</source>
          <target state="translated">对于一元 &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;onOverflow&lt;/code&gt; 被称为如果 &lt;code&gt;lhs == Lhs.min&lt;/code&gt; 和 &lt;code&gt;Lhs&lt;/code&gt; 是有符号的类型。该函数返回 &lt;code&gt;Lhs.max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3735f46e74c34d876c612b5f0d45ae5d470195b4" translate="yes" xml:space="preserve">
          <source>For unsatisfied conditions, the conditionally compiled code need only be syntactically correct. It does not have to be semantically correct.</source>
          <target state="translated">对于不满足的条件,条件编译的代码只需要在语法上是正确的。它不一定要在语义上正确。</target>
        </trans-unit>
        <trans-unit id="cbc5de8d1ef5491a35e3c236ec7889a9c2c4a94d" translate="yes" xml:space="preserve">
          <source>For use by application</source>
          <target state="translated">用于应用</target>
        </trans-unit>
        <trans-unit id="e74c782f1ffbeab9de3e921ce4304765a91d12e2" translate="yes" xml:space="preserve">
          <source>For use by application VFS</source>
          <target state="translated">供应用VFS使用</target>
        </trans-unit>
        <trans-unit id="3505b0edb5eee92682026f8144fd82b24c70a4f7" translate="yes" xml:space="preserve">
          <source>For use by built-in VFS</source>
          <target state="translated">供内置VFS使用</target>
        </trans-unit>
        <trans-unit id="88dbc145581c8c0573b319436a71bb181cd0808c" translate="yes" xml:space="preserve">
          <source>For use by extension VFS</source>
          <target state="translated">供扩展VFS使用</target>
        </trans-unit>
        <trans-unit id="230bac78e67f31568eb4729e25ce498036be0132" translate="yes" xml:space="preserve">
          <source>For user defined types. Should be equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">对于用户定义的类型。应该等于 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5f2524697bf575ce5005555e479cdd81f208227" translate="yes" xml:space="preserve">
          <source>For user-defined types, assignment operator expressions are overloaded separately from the binary operator. Still the left operand must be an lvalue.</source>
          <target state="translated">对于用户定义类型,赋值运算符表达式与二进制运算符分开重载。左边的操作数仍然必须是一个l值。</target>
        </trans-unit>
        <trans-unit id="0fb758f20654c3c8f3d278d2ed2c4c22389d5933" translate="yes" xml:space="preserve">
          <source>For using time zones other than local time or UTC, use &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Posix systems (or on Windows, if providing the TZ Database files), and use &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt; on Windows systems. The time in &lt;code&gt;SysTime&lt;/code&gt; is kept internally in hnsecs from midnight, January 1st, 1 A.D. UTC. Conversion error cannot happen when changing the time zone of a &lt;code&gt;SysTime&lt;/code&gt;. &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents the local time, and &lt;code&gt;UTC&lt;/code&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents UTC. &lt;code&gt;SysTime&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; if no &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; is provided. For more details on time zones, see the documentation for &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要使用本地时间或UTC以外的时区，&lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt;在Posix系统上（或在Windows（如果提供TZ数据库文件）上）使用&lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; &lt;/a&gt;在Windows系统上使用std.datetime.timezone.WindowsTimeZone。 &lt;code&gt;SysTime&lt;/code&gt; 中的时间从1 UTC 1月1日午夜开始在内部以hnsecs为单位。更改 &lt;code&gt;SysTime&lt;/code&gt; 的时区时，不会发生转换错误。&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;类表示本地时间， &lt;code&gt;UTC&lt;/code&gt; 是&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;类代表UTC。 &lt;code&gt;SysTime&lt;/code&gt; 使用&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;如果未提供 std.datetime.timezone.TimeZone，则为&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;。有关时区的更多详细信息，请参阅&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; 的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab8570d227afb15f540b536d5d1262c12c2ed538" translate="yes" xml:space="preserve">
          <source>For very large numbers, consider using the &lt;a href=&quot;http://gmplib.org&quot;&gt;GMP library&lt;/a&gt; instead.</source>
          <target state="translated">对于很大的数字，请考虑改用&lt;a href=&quot;http://gmplib.org&quot;&gt;GMP库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb0aaa1972b9827ddaeaa8c903dd012d64dc52a6" translate="yes" xml:space="preserve">
          <source>For very small x, expm1(x) is more accurate than exp(x)-1.</source>
          <target state="translated">对于很小的x,expm1(x)比exp(x)-1更准确。</target>
        </trans-unit>
        <trans-unit id="f6a75d7a9f98a84894db843b9fa129f7e85e4ad5" translate="yes" xml:space="preserve">
          <source>For very small x, log1p(x) will be more accurate than log(1 + x).</source>
          <target state="translated">对于很小的x,log1p(x)会比log(1+x)更准确。</target>
        </trans-unit>
        <trans-unit id="d5e2ba36b5f0fe67d03dfd60aced704179f8dc15" translate="yes" xml:space="preserve">
          <source>For virtual tables.</source>
          <target state="translated">对于虚拟表:</target>
        </trans-unit>
        <trans-unit id="9b2f5f01d7f036017bc44e0f5e7dd87067f218dd" translate="yes" xml:space="preserve">
          <source>For when the array has a non-zero initializer.</source>
          <target state="translated">用于当数组有一个非零的初始化器时。</target>
        </trans-unit>
        <trans-unit id="62235af30d4d3e83911b7f668444bdadcbf6e31f" translate="yes" xml:space="preserve">
          <source>For which &lt;code&gt;TargetOS&lt;/code&gt; the flags are applicable</source>
          <target state="translated">这些标志适用于哪些 &lt;code&gt;TargetOS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0512a8baa5c7d81d4b0fde3207bf25c16a72e5f5" translate="yes" xml:space="preserve">
          <source>ForStatement</source>
          <target state="translated">ForStatement</target>
        </trans-unit>
        <trans-unit id="2d317e6f14c862c7eb4252c51b1bf37d642b8a8c" translate="yes" xml:space="preserve">
          <source>ForStatements</source>
          <target state="translated">ForStatements</target>
        </trans-unit>
        <trans-unit id="809149a8ad9a0028e99b6a9d68c6c4147cc5a5e7" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by printing an error message to &lt;code&gt;stderr&lt;/code&gt; and then abort the program. &lt;code&gt;Abort&lt;/code&gt; is the default second argument for &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">通过将错误消息打印到 &lt;code&gt;stderr&lt;/code&gt; ，然后中止程序，强制所有积分错误失败。 &lt;code&gt;Abort&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的默认第二个参数。</target>
        </trans-unit>
        <trans-unit id="cb769685cb2418f96e7eb5cd6f3bc4bc9cdba76c" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by throwing an exception of type &lt;code&gt;Throw.CheckFailure&lt;/code&gt;. The message coming with the error is similar to the one printed by &lt;code&gt;Warn&lt;/code&gt;.</source>
          <target state="translated">通过抛出 &lt;code&gt;Throw.CheckFailure&lt;/code&gt; 类型的异常来强制所有积分错误失败。带有错误的消息类似于 &lt;code&gt;Warn&lt;/code&gt; 打印的消息。</target>
        </trans-unit>
        <trans-unit id="568ec7a75ae095d53209f55c9ce73fe37d60ef50" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;capacity&lt;/code&gt; to at least &lt;code&gt;x&lt;/code&gt; without reducing it.</source>
          <target state="translated">强制 &lt;code&gt;capacity&lt;/code&gt; 至少达到 &lt;code&gt;x&lt;/code&gt; 而不减小。</target>
        </trans-unit>
        <trans-unit id="19149ba839181262b9bdb188174930e36e6f0df9" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;this&lt;/code&gt; to the null state.</source>
          <target state="translated">强制 &lt;code&gt;this&lt;/code&gt; 为空状态。</target>
        </trans-unit>
        <trans-unit id="a8db5e83b8a35fac9d3b32ebcc923950ddcc52de" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber and then throws obj in the calling fiber.</source>
          <target state="translated">强制上下文切换发生在远离调用光纤的地方,然后在调用光纤中抛出obj。</target>
        </trans-unit>
        <trans-unit id="2f48cbfa34abf44639ec829c0d55463cc9494c97" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber.</source>
          <target state="translated">迫使上下文切换发生在远离呼叫光纤的地方。</target>
        </trans-unit>
        <trans-unit id="80579a9d1e587d7b0ea440174e72821dab14c81a" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling thread.</source>
          <target state="translated">强制在调用线程之外进行上下文切换。</target>
        </trans-unit>
        <trans-unit id="13258c0abcfb4cca178a3b35d4e0664b60f42a89" translate="yes" xml:space="preserve">
          <source>Forces any data buffered by the OS to be written to disk. Call &lt;a href=&quot;#flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before calling this function to flush the C &lt;code&gt;FILE&lt;/code&gt; buffers first.</source>
          <target state="translated">强制将操作系统缓冲的所有数据写入磁盘。调用&lt;a href=&quot;#flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;调用此函数刷新前C &lt;code&gt;FILE&lt;/code&gt; 第一缓冲区。</target>
        </trans-unit>
        <trans-unit id="23e389c62cad5bc7af8046c1d45faa80b7add735" translate="yes" xml:space="preserve">
          <source>Forces free list mode. If already in free list mode, does nothing. Otherwise, sorts the free list accumulated so far and switches strategy for future allocations to KR style.</source>
          <target state="translated">强制进入自由列表模式。如果已经进入自由列表模式,则什么都不做。否则,对目前积累的自由列表进行排序,并将未来的分配策略切换为KR风格。</target>
        </trans-unit>
        <trans-unit id="7438f3f3f123487789d348d295cbd3a74e9f3636" translate="yes" xml:space="preserve">
          <source>Forces the number of elements in the container to &lt;code&gt;n&lt;/code&gt;. If the container ends up growing, the added elements are initialized in a container-dependent manner (usually with &lt;code&gt;T.init&lt;/code&gt;).</source>
          <target state="translated">强制容器中的元素数为 &lt;code&gt;n&lt;/code&gt; 。如果容器最终增长，则添加的元素将以与容器相关的方式初始化（​​通常使用 &lt;code&gt;T.init&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="41991c2a7e01e941592d10ca1b4c7b6d194af71f" translate="yes" xml:space="preserve">
          <source>Forcibly deallocates all memory allocated by this allocator, making it available for further allocations. Does not return memory to &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">强制取消分配此分配器分配的所有内存，使其可用于进一步的分配。不将内存返回给 &lt;code&gt;ParentAllocator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e05b71be24859a77e2790b0d8e71bc9f4dd8c1f8" translate="yes" xml:space="preserve">
          <source>Foreach</source>
          <target state="translated">Foreach</target>
        </trans-unit>
        <trans-unit id="24a9bd4ac18d7ddab41be52adbe896067b46f066" translate="yes" xml:space="preserve">
          <source>Foreach Range Methods</source>
          <target state="translated">Foreach Range方法</target>
        </trans-unit>
        <trans-unit id="2c53155a2e00768b8f625193cebda30089ce0843" translate="yes" xml:space="preserve">
          <source>Foreach Range Properties</source>
          <target state="translated">Foreach Range Properties</target>
        </trans-unit>
        <trans-unit id="45b6dd48295de07cd5e6e8af0d02a0aba0d48189" translate="yes" xml:space="preserve">
          <source>Foreach Range Statement</source>
          <target state="translated">Foreach Range Statement</target>
        </trans-unit>
        <trans-unit id="3e61286776c3201ae4e25284f6e9997d2d997281" translate="yes" xml:space="preserve">
          <source>Foreach Ref Parameters</source>
          <target state="translated">Foreach Ref Parameters</target>
        </trans-unit>
        <trans-unit id="a6c2c1398fe7e48f653dc8f0a8caddaee072679f" translate="yes" xml:space="preserve">
          <source>Foreach Restrictions</source>
          <target state="translated">Foreach Restrictions</target>
        </trans-unit>
        <trans-unit id="0553132dc6cdd5f87cabaeda4197e661d068c9f8" translate="yes" xml:space="preserve">
          <source>Foreach Statement</source>
          <target state="translated">Foreach声明</target>
        </trans-unit>
        <trans-unit id="da94ac95aa14d4788d7fd4a24d8272c7d97d35a8" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays</source>
          <target state="translated">Foreach over Arrays</target>
        </trans-unit>
        <trans-unit id="b1b911444dc098ad04d8c1492527b6551f0916f7" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays of Characters</source>
          <target state="translated">Foreach超过字符数组</target>
        </trans-unit>
        <trans-unit id="2a77599ec0f128dc2ac0586f465739ede0b37cd8" translate="yes" xml:space="preserve">
          <source>Foreach over Associative Arrays</source>
          <target state="translated">Foreach over Associative Arrays</target>
        </trans-unit>
        <trans-unit id="140fe06b456ed9f1ae3d0c4efbee66b6a7732580" translate="yes" xml:space="preserve">
          <source>Foreach over Delegates</source>
          <target state="translated">Foreach over Delegates</target>
        </trans-unit>
        <trans-unit id="2118d2308b39d4304cee2cfe11851139c70627b5" translate="yes" xml:space="preserve">
          <source>Foreach over Sequences</source>
          <target state="translated">Foreach over Sequences</target>
        </trans-unit>
        <trans-unit id="2f65a25f9fa525fd78d322a8ac805a6f39540fba" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with Ranges</source>
          <target state="translated">Foreach over Structs and Classes with Ranges.</target>
        </trans-unit>
        <trans-unit id="3d5dd8a83fe426ccb28e159ceb15528fef952829" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with opApply</source>
          <target state="translated">用 opApply Foreach over Structs 和 Classes。</target>
        </trans-unit>
        <trans-unit id="f667fe9347feaa7cb4e621c258d2edcbe22519e9" translate="yes" xml:space="preserve">
          <source>ForeachAggregate</source>
          <target state="translated">ForeachAggregate</target>
        </trans-unit>
        <trans-unit id="df2d328871cd71e3623bbdef344f4992bcecf2e1" translate="yes" xml:space="preserve">
          <source>ForeachRangeStatement &lt;strong id=&quot;rangefe&quot;&gt;rangefe&lt;/strong&gt;;</source>
          <target state="translated">ForeachRangeStatement &lt;strong id=&quot;rangefe&quot;&gt;rangefe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e19df85959b2b1a13377a372c2de5cdf84d1b37" translate="yes" xml:space="preserve">
          <source>ForeachStatement</source>
          <target state="translated">ForeachStatement</target>
        </trans-unit>
        <trans-unit id="9e64b4731b7dbeb3175b639030eb1b4587e3cf60" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;code&gt;fes&lt;/code&gt;</source>
          <target state="translated">Foreach语句 &lt;code&gt;fes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a17c7a682fe18e111c85eb3ffb6f2a4cbaae0f4" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt;;</source>
          <target state="translated">ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1330e14342be598ec267758faf0b9d03bb95ce41" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt;;</source>
          <target state="translated">ForeachStates &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="856f0cb9ba209b9b76b5f3f3110e190ba107f316" translate="yes" xml:space="preserve">
          <source>ForeachType</source>
          <target state="translated">ForeachType</target>
        </trans-unit>
        <trans-unit id="9c4e220b832fdde833e953123e22e947e7b36940" translate="yes" xml:space="preserve">
          <source>ForeachType!(PointerTarget!Range)[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType！（PointerTarget！Range）[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;（Range）（Range r）</target>
        </trans-unit>
        <trans-unit id="b97cbae09882028f8cf2caca90479d52c2db87df" translate="yes" xml:space="preserve">
          <source>ForeachType!Range[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType！Range [] &lt;strong id=&quot;array&quot;&gt;数组&lt;/strong&gt;（Range）（Range r）</target>
        </trans-unit>
        <trans-unit id="6c99353d4eb960ce958a85dea4dafad1de143866" translate="yes" xml:space="preserve">
          <source>ForeachTypeAttribute</source>
          <target state="translated">ForeachTypeAttribute</target>
        </trans-unit>
        <trans-unit id="7ce9ed7c2184e929a253429a20b37b4560fb165d" translate="yes" xml:space="preserve">
          <source>ForeachTypeList</source>
          <target state="translated">ForeachTypeList</target>
        </trans-unit>
        <trans-unit id="3432f720952ad1ef45f41182f803dfead87c5b2b" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Methods</source>
          <target state="translated">Foreach_reverse Range方法</target>
        </trans-unit>
        <trans-unit id="b050df33fa944ca9312b95dbcf3146816b9fa5f7" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Properties</source>
          <target state="translated">Foreach_reverse Range Properties</target>
        </trans-unit>
        <trans-unit id="4f7e5954df7c830e01a29a86da382389a582afe9" translate="yes" xml:space="preserve">
          <source>Form TypeTuple from the types of the expressions. Assume exps[] is already tuple expanded.</source>
          <target state="translated">从表达式的类型中形成TypeTuple。假设exps[]已经是元组展开。</target>
        </trans-unit>
        <trans-unit id="2d244117783206496417e62aa99112e2aad4b472" translate="yes" xml:space="preserve">
          <source>Form feed (FF) (U+000C).</source>
          <target state="translated">进纸(FF)(U+000C)。</target>
        </trans-unit>
        <trans-unit id="676f10eb2f485163d62fd19ea9c8545ba45ba1b3" translate="yes" xml:space="preserve">
          <source>Formally, the minimum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(a, x)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. Conversely, the maximum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(x, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; (note the swapped arguments to &lt;code&gt;pred&lt;/code&gt;).</source>
          <target state="translated">形式上，最小值是一个值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;range&lt;/code&gt; ，使得 &lt;code&gt;pred(a, x)&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 对于所有的值 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;range&lt;/code&gt; 。相反，最大是一个值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;range&lt;/code&gt; ，使得 &lt;code&gt;pred(x, a)&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 对于所有的值 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;range&lt;/code&gt; （注意交换参数 &lt;code&gt;pred&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="150d9f841097f64a42b925806fe3290abd9bc35d" translate="yes" xml:space="preserve">
          <source>Format String</source>
          <target state="translated">格式化字符串</target>
        </trans-unit>
        <trans-unit id="683303f489ff84a56879ace6d1310dfe54be7ff4" translate="yes" xml:space="preserve">
          <source>Format a static condition as a tree-like structure, marking failed and bypassed expressions.</source>
          <target state="translated">将静态条件格式化为树状结构,标记失败和绕过的表达式。</target>
        </trans-unit>
        <trans-unit id="51e82ebaf2db5ec167460d9fcf90c1ef8ea0f2d7" translate="yes" xml:space="preserve">
          <source>Format arguments into a string.</source>
          <target state="translated">将参数格式化为一个字符串。</target>
        </trans-unit>
        <trans-unit id="b0fb6e308cc109a50167ee0e6731cc7e72eb7494" translate="yes" xml:space="preserve">
          <source>Format arguments into buffer</source>
          <target state="translated">将参数格式化为缓冲区</target>
        </trans-unit>
        <trans-unit id="926bb79848aace359e9158738e215805c41e663b" translate="yes" xml:space="preserve">
          <source>Format data into strings.</source>
          <target state="translated">将数据格式化为字符串。</target>
        </trans-unit>
        <trans-unit id="23e10a3db64de41eba0cd45a912f85a4b56f3f1b" translate="yes" xml:space="preserve">
          <source>Format flags for CustomFloat.</source>
          <target state="translated">CustomFloat的格式标志。</target>
        </trans-unit>
        <trans-unit id="9bc6c7decb7638f7f45249d89d49acf2bfdc2a16" translate="yes" xml:space="preserve">
          <source>Format like &lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt;.</source>
          <target state="translated">格式类似于 &lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02e42cbae72865d54225666f797f795a1b96d6bb" translate="yes" xml:space="preserve">
          <source>Format specifier</source>
          <target state="translated">格式指定器</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">格式字符串。</target>
        </trans-unit>
        <trans-unit id="ee3b46d05547f4e1ed0fb6b16e92db78c1a30405" translate="yes" xml:space="preserve">
          <source>Format string. For detailed specification, see &lt;a href=&quot;#formattedWrite&quot;&gt;&lt;code&gt;formattedWrite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">格式字符串。有关详细说明，请参见&lt;a href=&quot;#formattedWrite&quot;&gt; &lt;code&gt;formattedWrite&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9e1764b317ef266e49f202653a88a32e68ea2fd" translate="yes" xml:space="preserve">
          <source>Format to a string such as: &lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt;.</source>
          <target state="translated">格式化为如下字符串： &lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7a8c4c502d36efd7cdb40b63094b0c90409c783" translate="yes" xml:space="preserve">
          <source>FormatChar</source>
          <target state="translated">FormatChar</target>
        </trans-unit>
        <trans-unit id="d7ab63d27b9f2759987e52fd620d64164025e796" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">FormatSpec！Char &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb9d269d7b56db9164861bd1ad68cf391c388350" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec！Char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fcb49409d4c929c4b7d5f9fa3a44391c37114d5" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;spec&lt;/code&gt;</source>
          <target state="translated">格式 &lt;code&gt;spec&lt;/code&gt; ！字符规范</target>
        </trans-unit>
        <trans-unit id="f215319169c289fbb719f3b0d628a3b737f8eded" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt;(Char)(Char[] fmt);</source>
          <target state="translated">FormatSpec！Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt;（Char）（Char [] fmt）;</target>
        </trans-unit>
        <trans-unit id="ff3a107be5350e9cbdf489fea1b9a3cb189415cc" translate="yes" xml:space="preserve">
          <source>FormatSpec!char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec！char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d214509fa791f89f2be58f52b1b3767a22ec982d" translate="yes" xml:space="preserve">
          <source>Formats &lt;code&gt;Tuple&lt;/code&gt; with either &lt;code&gt;%s&lt;/code&gt;, &lt;code&gt;%(inner%)&lt;/code&gt; or &lt;code&gt;%(inner%|sep%)&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;%s&lt;/code&gt; ， &lt;code&gt;%(inner%)&lt;/code&gt; 或 &lt;code&gt;%(inner%|sep%)&lt;/code&gt; 格式化 &lt;code&gt;Tuple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36fd923e1d2f6994803ec17defea621b9f080f14" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer, followed by a newline.</source>
          <target state="translated">格式化并将其参数以文本格式写入OutBuffer,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="7071823457762f9707da94f7448fddbd240e7baf" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer.</source>
          <target state="translated">将其参数以文本格式格式化并写入OutBuffer。</target>
        </trans-unit>
        <trans-unit id="a51cf9b2e5a5b055fe6bcc1d2693b2624065293b" translate="yes" xml:space="preserve">
          <source>Formats any value into &lt;code&gt;Char&lt;/code&gt; accepting &lt;code&gt;OutputRange&lt;/code&gt;, using the given &lt;code&gt;FormatSpec&lt;/code&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;FormatSpec&lt;/code&gt; 将任何值格式化为接受 &lt;code&gt;OutputRange&lt;/code&gt; 的 &lt;code&gt;Char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b1857e4f5a36639d321cc75f53c946b6701eca2" translate="yes" xml:space="preserve">
          <source>Formats its arguments according to the format string and puts them to an OutputRange.</source>
          <target state="translated">根据格式字符串对其参数进行格式化,并将它们放到一个OutputRange中。</target>
        </trans-unit>
        <trans-unit id="7b102bb156b0812a82b4b3cc910bf7cff6a74f11" translate="yes" xml:space="preserve">
          <source>Formats supported by Tuple</source>
          <target state="translated">Tuple支持的格式</target>
        </trans-unit>
        <trans-unit id="1eebc61a97141f60643e629482bce7edcfb75fe1" translate="yes" xml:space="preserve">
          <source>Formats the &lt;code&gt;Options&lt;/code&gt; for CLI printing.</source>
          <target state="translated">格式化用于CLI打印的 &lt;code&gt;Options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="026cf84e486080b485be195c8355623b05fc9001" translate="yes" xml:space="preserve">
          <source>Formats the RedBlackTree into a sink function. For more info see &lt;code&gt; std.format.formatValue&lt;/code&gt;. Note that this only is available when the element type can be formatted. Otherwise, the default toString from Object is used.</source>
          <target state="translated">将RedBlackTree格式化为接收器函数。有关更多信息，请参见 &lt;code&gt; std.format.formatValue&lt;/code&gt; 。请注意，仅当可以格式化元素类型时，此选项才可用。否则，将使用Object的默认toString。</target>
        </trans-unit>
        <trans-unit id="1a1c1d1c97be2b241e71fcbcd57b8c7212c71103" translate="yes" xml:space="preserve">
          <source>Formats the stored value as a string.</source>
          <target state="translated">将存储值格式化为字符串。</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">格式化字符串打印功能</target>
        </trans-unit>
        <trans-unit id="fc5187ca67d19625ec5705d6a55febca2c516352" translate="yes" xml:space="preserve">
          <source>Formatted number of arguments.</source>
          <target state="translated">格式化的参数数。</target>
        </trans-unit>
        <trans-unit id="dfdf9e737f02222e3b629df49845cd2f57eea582" translate="yes" xml:space="preserve">
          <source>Formatting a struct by defining a method &lt;code&gt;toString&lt;/code&gt;, which takes an output range.  It's recommended that any &lt;code&gt;toString&lt;/code&gt; using &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output ranges&lt;/a&gt; use &lt;a href=&quot;std_range_primitives#put&quot;&gt;&lt;code&gt;std.range.primitives.put&lt;/code&gt;&lt;/a&gt; rather than use the &lt;code&gt;put&lt;/code&gt; method of the range directly.</source>
          <target state="translated">通过定义方法 &lt;code&gt;toString&lt;/code&gt; 格式化结构，该方法采用输出范围。建议使用&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;输出范围的&lt;/a&gt;任何 &lt;code&gt;toString&lt;/code&gt; 使用&lt;a href=&quot;std_range_primitives#put&quot;&gt; &lt;code&gt;std.range.primitives.put&lt;/code&gt; &lt;/a&gt;而不是直接使用范围的 &lt;code&gt;put&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="8e465166e94e67eebeab101e4359626150ec10a5" translate="yes" xml:space="preserve">
          <source>Forms the symbols available to all D programs. Includes Object, which is the root of the class object hierarchy. This module is implicitly imported.</source>
          <target state="translated">形成所有D程序可用的符号。包括Object,它是类对象层次结构的根。该模块是隐式导入的。</target>
        </trans-unit>
        <trans-unit id="be4f9eeadbcbd0250352284fb3cd5289c89dd0aa" translate="yes" xml:space="preserve">
          <source>Forward range primitive.</source>
          <target state="translated">前期范围基元。</target>
        </trans-unit>
        <trans-unit id="f29ecd0a8c2e85a8dd0a05e6e1849d59d6e26721" translate="yes" xml:space="preserve">
          <source>Forward range primitives.</source>
          <target state="translated">远期范围基元。</target>
        </trans-unit>
        <trans-unit id="0aa520a29c82bb14e915d25c13dc5e309db9aa45" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Always present.</source>
          <target state="translated">远期范围基元。始终存在。</target>
        </trans-unit>
        <trans-unit id="d22e131c3ac191040ab33d51c37ffdb89ec4f5bd" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Only present if &lt;code&gt;Source&lt;/code&gt; is a forward range.</source>
          <target state="translated">正向范围原语。仅在 &lt;code&gt;Source&lt;/code&gt; 为正向范围时才存在。</target>
        </trans-unit>
        <trans-unit id="97bc99924d633226857a96f6afec14fc043cb16b" translate="yes" xml:space="preserve">
          <source>Forward range to check for sortedness.</source>
          <target state="translated">前进范围检查排序。</target>
        </trans-unit>
        <trans-unit id="7657ababded98f92f21842f17fb3c2a8cd28a85d" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().back&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;opSlice().back&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f670785452e24c08e6662a674722599db21dae68" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().front&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;opSlice().front&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="406d6f916ef4dc2cf86b7e71d06ceb89e750f775" translate="yes" xml:space="preserve">
          <source>Forward.</source>
          <target state="translated">Forward.</target>
        </trans-unit>
        <trans-unit id="619c49003b4924854c54d8f88890d01e742d1cdb" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;back&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;back&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef30f2488fc02c13b78587f98f5f66b1ed09c755" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;choices&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;choices&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="073a409c0a0f8fb805007ded8e0840b82337c88e" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;filler&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;filler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d735aafe3953821674bcc047eed0a464f448083f" translate="yes" xml:space="preserve">
          <source>Forwarding</source>
          <target state="translated">Forwarding</target>
        </trans-unit>
        <trans-unit id="59753dcda35fa8785a7cb0df7205b2d4bd41fb72" translate="yes" xml:space="preserve">
          <source>Forwarding ScopeDsymbol. Used by ForwardingAttribDeclaration and ForwardingScopeDeclaration to forward symbol insertions to another scope. See &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; for more details.</source>
          <target state="translated">转发ScopeDsymbol。由ForwardingAttribDeclaration和ForwardingScopeDeclaration用来将符号插入转发到另一个作用域。有关更多详细信息，请参见 &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8c3c38ee76d4f3b54240c75f491818942150299" translate="yes" xml:space="preserve">
          <source>ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt;;</source>
          <target state="translated">ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="350d94101794444e552e24c257a1f22a4fbe99df" translate="yes" xml:space="preserve">
          <source>ForwardingStatements are distributed over the flattened sequence of statements. This prevents flattening to be &quot;blocked&quot; by a ForwardingStatement and is necessary, for example, to support generating scope guards with `static foreach`:</source>
          <target state="translated">ForwardingStatements分布在扁平化的语句序列上。这可以防止扁平化被ForwardingStatement &quot;阻挡&quot;,并且是必要的,例如,支持用 &quot;static foreach &quot;生成作用域守护。</target>
        </trans-unit>
        <trans-unit id="692658a69283f7fb6a21aa51f11e5d6d2994d5d3" translate="yes" xml:space="preserve">
          <source>Forwards &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">转发 &lt;code&gt;length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5654a0e021e96bad526eccdeb7cb0d25a7be5435" translate="yes" xml:space="preserve">
          <source>Forwards each of the methods in &lt;code&gt;funs&lt;/code&gt; (if defined) to &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;funs&lt;/code&gt; 每个方法（如果已定义）转发给 &lt;code&gt;member&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e165afdb83bce78d5a7427c72318f24d46092f4d" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while keeping &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, and &lt;code&gt;lazy&lt;/code&gt; on the parameters.</source>
          <target state="translated">转发函数参数，同时对参数保持 &lt;code&gt;out&lt;/code&gt; ， &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;lazy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9385c6728b753fbb370a1c4f1034c150548b8bf1" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while saving ref-ness.</source>
          <target state="translated">转发函数参数,同时保存参考文献。</target>
        </trans-unit>
        <trans-unit id="9bf1ea57d6c29870d04450f92da2598f5a795126" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78d71ac4fe9046b06039c1f36978f900fc90d21" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt;. Should be used with blocks obtained with &lt;code&gt;allocate&lt;/code&gt; otherwise the custom alignment passed with &lt;code&gt;alignedAllocate&lt;/code&gt; can be lost.</source>
          <target state="translated">转发到 &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt; 。应与获得的块被用于 &lt;code&gt;allocate&lt;/code&gt; 以其他方式与通过了自定义对准 &lt;code&gt;alignedAllocate&lt;/code&gt; 可能会丢失。</target>
        </trans-unit>
        <trans-unit id="d788f6c07eb5fb2e6319214dbdc4af6789c0f502" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.alignedReallocate&lt;/code&gt; if defined, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果已定义，则转发到 &lt;code&gt;impl.alignedReallocate&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bd9cee5dc99654ad10a48eac7f3712c848d2492" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.empty()&lt;/code&gt; if defined, otherwise returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;impl.empty()&lt;/code&gt; (如果已定义），否则返回 &lt;code&gt;Ternary.unknown&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acf2453169c3a58c2868738f1fc21eb777d091c4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;insertBack&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;insertBack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60a899e29a86abcd90907c95435a5280010cfeb4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.alignedAllocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;parent.alignedAllocate&lt;/code&gt; 。每个实例的影响： &lt;code&gt;numAlignedAllocate&lt;/code&gt; ， &lt;code&gt;bytesUsed&lt;/code&gt; ， &lt;code&gt;bytesAllocated&lt;/code&gt; ， &lt;code&gt;bytesSlack&lt;/code&gt; ， &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; 和 &lt;code&gt;bytesHighTide&lt;/code&gt; 。每次调用的影响： &lt;code&gt;numAlignedAllocate&lt;/code&gt; ， &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; 和 &lt;code&gt;bytesAllocated&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de51b91db75956f253cd2e990aebff215db91a5" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.allocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt; numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;parent.allocate&lt;/code&gt; 。每个实例的影响： &lt;code&gt;numAllocate&lt;/code&gt; ， &lt;code&gt;bytesUsed&lt;/code&gt; ， &lt;code&gt;bytesAllocated&lt;/code&gt; ， &lt;code&gt;bytesSlack&lt;/code&gt; ， &lt;code&gt;numAllocateOK&lt;/code&gt; 和 &lt;code&gt;bytesHighTide&lt;/code&gt; 。每次调用的影响： &lt;code&gt;numAllocate&lt;/code&gt; ， &lt;code&gt; numAllocateOK&lt;/code&gt; 和 &lt;code&gt;bytesAllocated&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcaf3b31885140c27644f437101ba9113ddebba0" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.expand(b, delta)&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;parent.expand(b, delta)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b27aa4f3be329203334bb86f539151cb305c808b" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.goodAllocSize&lt;/code&gt; (which accounts for the management overhead).</source>
          <target state="translated">转发到 &lt;code&gt;parent.goodAllocSize&lt;/code&gt; （这占管理开销）。</target>
        </trans-unit>
        <trans-unit id="0a8e660798dc338a8a1471f38403abdf431c688a" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;parent.owns(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c49defce19fbb5c360ddd5f8418442bee4a9e756" translate="yes" xml:space="preserve">
          <source>Found function if it satisfies &lt;code&gt;isThis()&lt;/code&gt;, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">如果满足 &lt;code&gt;isThis()&lt;/code&gt; 的找到的函数，否则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5b2644294a615403e1d25df5a0697b50b1f11f" translate="yes" xml:space="preserve">
          <source>Fractional seconds past the second (i.e. the portion of a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; which is less than a second).</source>
          <target state="translated">秒后的小数秒（即，&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的一部分小于一秒）。</target>
        </trans-unit>
        <trans-unit id="379f2457e03cb11d9fb2efb285637d5db4d20d0e" translate="yes" xml:space="preserve">
          <source>Framework Paths</source>
          <target state="translated">框架路径</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="76f3bbf403c0a1d06091b2e954aa5148b52956ac" translate="yes" xml:space="preserve">
          <source>Free ExceptionHeader that was created by create().</source>
          <target state="translated">释放由create()创建的ExceptionHeader。</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">数据库连接使用的自由内存</target>
        </trans-unit>
        <trans-unit id="ebc0d55c1803ae64cbd97a59b9b2802ad68ac4a1" translate="yes" xml:space="preserve">
          <source>Free a data definition struct.</source>
          <target state="translated">释放一个数据定义结构。</target>
        </trans-unit>
        <trans-unit id="b863a7908826b1af85e7908ab51bda44bf1ecda4" translate="yes" xml:space="preserve">
          <source>Free a multipart formpost previously built with curl_formadd().</source>
          <target state="translated">释放一个之前用curl_formadd()构建的多部分formpost。</target>
        </trans-unit>
        <trans-unit id="3195ad8b795496334c672bd13584f65569ba68b7" translate="yes" xml:space="preserve">
          <source>Free a prior allocation</source>
          <target state="translated">解除先前的拨款</target>
        </trans-unit>
        <trans-unit id="b1f545998e095b9a06b4728df726ebf0dad217f2" translate="yes" xml:space="preserve">
          <source>Free blocks have variable size and are linked in a singly-linked list.</source>
          <target state="translated">自由区块的大小不一,并以单个链接的列表方式进行链接。</target>
        </trans-unit>
        <trans-unit id="2e8b5134a1b2ec3e5e93b6a487571bc8ad9bf630" translate="yes" xml:space="preserve">
          <source>Free free list.</source>
          <target state="translated">嶈单。</target>
        </trans-unit>
        <trans-unit id="0917613170fb85672a58086626671da808078654" translate="yes" xml:space="preserve">
          <source>Free idxStr using sqlite3_free() if true</source>
          <target state="translated">如果为真,则使用sqlite3_free()释放idxStr。</target>
        </trans-unit>
        <trans-unit id="98a1ae48a4466ad89a88d462e43c40189625122d" translate="yes" xml:space="preserve">
          <source>Free list built on top of exactly one contiguous block of memory. The block is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;, and is released in &lt;code&gt;ContiguousFreeList&lt;/code&gt;'s destructor (unless &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;code&gt;NullAllocator&lt;/code&gt;).</source>
          <target state="translated">空闲列表建立在一个连续的内存块之上。假设该块已与分配 &lt;code&gt;ParentAllocator&lt;/code&gt; ，并在被释放 &lt;code&gt;ContiguousFreeList&lt;/code&gt; 的析构函数（除非 &lt;code&gt;ParentAllocator&lt;/code&gt; 是 &lt;code&gt;NullAllocator&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="10d99eecb5370b60ca034187daa4ef1e45d53646" translate="yes" xml:space="preserve">
          <source>Free list.</source>
          <target state="translated">免费名单。</target>
        </trans-unit>
        <trans-unit id="56d7e4661565975bfba4769fa7e3d64507696d05" translate="yes" xml:space="preserve">
          <source>Free memory allocated by FileName routines</source>
          <target state="translated">由FileName例程分配的自由内存</target>
        </trans-unit>
        <trans-unit id="f7c1a4f30544ddc6377c5a280a73f14897416990" translate="yes" xml:space="preserve">
          <source>Free returned value with FileName::free()</source>
          <target state="translated">用FileName::free()释放返回值。</target>
        </trans-unit>
        <trans-unit id="3b18d56d2ee33e5deee0527f6a5620f9d07c8560" translate="yes" xml:space="preserve">
          <source>Free-form syntax, ignores whitespace in pattern, useful for formatting complex regular expressions.</source>
          <target state="translated">自由格式语法,忽略模式中的空白,对于格式化复杂的正则表达式很有用。</target>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="927e12a7e999b3e0f18d3a882968560f012cc81f" translate="yes" xml:space="preserve">
          <source>FreeBSD-Only</source>
          <target state="translated">FreeBSD-Only</target>
        </trans-unit>
        <trans-unit id="736e4cd346eb715c4446b514550578d814d7d0e0" translate="yes" xml:space="preserve">
          <source>FreeBSD/DragonFlyBSD are the only systems which specifically have a clock set up for this (it has &lt;code&gt;CLOCK_SECOND&lt;/code&gt; to use with &lt;code&gt;clock_gettime&lt;/code&gt; which takes advantage of an in-kernel cached value), but on other systems, the fastest function available will be used, and the resulting &lt;code&gt;SysTime&lt;/code&gt; will be rounded down to the second if the clock that was used gave the time at a more precise resolution. So, it's guaranteed that the time will be given at a precision of one second and it's likely the case that will be faster than &lt;code&gt;ClockType.normal&lt;/code&gt;, since there tend to be several options on a system to get the time at low resolutions, and they tend to be faster than getting the time at high resolutions.</source>
          <target state="translated">FreeBSD / DragonFlyBSD是仅有的为此专门设置了时钟的系统（它具有 &lt;code&gt;CLOCK_SECOND&lt;/code&gt; 和 &lt;code&gt;clock_gettime&lt;/code&gt; 一起使用，这利用了内核缓存的值），但是在其他系统上，将使用最快的可用功能，并且如果使用的时钟以更精确的分辨率提供时间，则生成的 &lt;code&gt;SysTime&lt;/code&gt; 将四舍五入到第二秒。因此，可以保证时间的精确度为一秒，并且这种情况可能会比 &lt;code&gt;ClockType.normal&lt;/code&gt; 的速度更快，因为系统上倾向于使用多个选项以低分辨率获取时间，并且往往比获得高分辨率时要快。</target>
        </trans-unit>
        <trans-unit id="a9cdca34912cf1be0977006662f6f41677329f87" translate="yes" xml:space="preserve">
          <source>FreeList shared across threads. Allocation and deallocation are lock-free. The parameters have the same semantics as for &lt;code&gt;FreeList&lt;/code&gt;.</source>
          <target state="translated">FreeList跨线程共享。分配和解除分配是无锁的。参数具有与 &lt;code&gt;FreeList&lt;/code&gt; 相同的语义。</target>
        </trans-unit>
        <trans-unit id="ebdbf1c9047d64cde03eaed8b92301afb24c8b3e" translate="yes" xml:space="preserve">
          <source>Freeing all GC allocated memory that has no active pointers to it and do not need destructors to run.</source>
          <target state="translated">释放所有GC分配的内存,这些内存没有活动指针,不需要destructor来运行。</target>
        </trans-unit>
        <trans-unit id="9c1d262fbf3a7e284bb2c20e67267943ef09c825" translate="yes" xml:space="preserve">
          <source>Freeing any remaining unreachable memory.</source>
          <target state="translated">释放任何剩余的无法到达的内存。</target>
        </trans-unit>
        <trans-unit id="b1843177cd4be06555f8650438e2f5cee23b6d7c" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated for &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is a reference to a class or interface, the memory allocated for the underlying instance is freed. If &lt;code&gt;x&lt;/code&gt; is a pointer, the memory allocated for the pointed-to object is freed. If &lt;code&gt;x&lt;/code&gt; is a built-in array, the memory allocated for the array is freed. If &lt;code&gt;x&lt;/code&gt; does not refer to memory previously allocated with &lt;code&gt;new&lt;/code&gt; (or the lower-level equivalents in the GC API), the behavior is undefined.</source>
          <target state="translated">释放分配给 &lt;code&gt;x&lt;/code&gt; 的内存。如果 &lt;code&gt;x&lt;/code&gt; 是对类或接口的引用，则释放为基础实例分配的内存。如果 &lt;code&gt;x&lt;/code&gt; 是指针，则释放分配给指向对象的内存。如果 &lt;code&gt;x&lt;/code&gt; 是内置数组，则释放为该数组分配的内存。如果 &lt;code&gt;x&lt;/code&gt; 不引用先前分配有 &lt;code&gt;new&lt;/code&gt; 内存的内存（或GC API中的较低等价内存），则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="306cb21df3375fca60d15a5cf9f358aab2a447e3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db2022114f51428d23663985d9512c4f397b106d" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#FracSec&quot;&gt;&lt;code&gt;FracSec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;#FracSec&quot;&gt; &lt;code&gt;FracSec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dcadc69133dc56548eb2198fe024d580cc53763" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#TickDuration&quot;&gt;&lt;code&gt;TickDuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;#TickDuration&quot;&gt; &lt;code&gt;TickDuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e8638502dca540c07f22be8e25e01957c58dc0f" translate="yes" xml:space="preserve">
          <source>From a postblit perspective, qualifiying the struct definition yields the same result as explicitly qualifying the postblit.</source>
          <target state="translated">从后缀的角度来看,限定结构定义与显式限定后缀的结果是一样的。</target>
        </trans-unit>
        <trans-unit id="a4300cea6afd6c5c0528f1834abaff027668e0ed" translate="yes" xml:space="preserve">
          <source>From units</source>
          <target state="translated">从单位</target>
        </trans-unit>
        <trans-unit id="87b5b5d7f217c54f10b305679e84d27b0ffddee6" translate="yes" xml:space="preserve">
          <source>Front-end expression rewriting should create temporary variables for non trivial sub-expressions in order to: 1. save evaluation order 2. prevent sharing of sub-expression in AST</source>
          <target state="translated">前端表达式重写应该为非琐碎的子表达式创建临时变量,以便。1.节省计算顺序 2.防止AST中子表达式的共享。</target>
        </trans-unit>
        <trans-unit id="d866f093f3136af5a6cee1f9313a0fdd24da6c23" translate="yes" xml:space="preserve">
          <source>FrontTransversal!(RangeOfRanges, opt) &lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr);</source>
          <target state="translated">FrontTransversal！（RangeOfRanges，opt）&lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt;（TransverseOptions opt = TransverseOptions.assumeJagged，RangeOfRanges）（RangeOfRanges rr）;</target>
        </trans-unit>
        <trans-unit id="b96493999dfb84df4fdc104ae8dc68c5ab28eeb6" translate="yes" xml:space="preserve">
          <source>Full Usage Example</source>
          <target state="translated">完整使用范例</target>
        </trans-unit>
        <trans-unit id="dd2159a885b04c76ad21acb9e9df96e1b3df4a78" translate="yes" xml:space="preserve">
          <source>Full content of the file to be written</source>
          <target state="translated">要写的文件的全部内容</target>
        </trans-unit>
        <trans-unit id="890fb87ee1e5cddd39317993afd9de0de79b7d45" translate="yes" xml:space="preserve">
          <source>Full metaprogramming facilities</source>
          <target state="translated">完整的元编程设施</target>
        </trans-unit>
        <trans-unit id="0c7ebd23a12a9077c88a3e9d528a97811a94a547" translate="yes" xml:space="preserve">
          <source>Fully sequenced (acquire + release). Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">完全排序（获取+释放）。对应于&lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt;和C ++ 11 / C11 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="244c67389fed3259f84c95197cc9eb3648ddcb0d" translate="yes" xml:space="preserve">
          <source>Fully working example is available at &lt;a href=&quot;#usage-example&quot;&gt;the bottom&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#usage-example&quot;&gt;底部&lt;/a&gt;提供了完整的工作示例。</target>
        </trans-unit>
        <trans-unit id="d32cb0b70d83396fe47823d8472eaa9476a37437" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">函数声明 &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46c96c463b9529c91720bbc72354f9466bd3c26f" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fd&lt;/code&gt;</source>
          <target state="translated">FuncDeclaration &lt;code&gt;fd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fd968926da674858b925b704767caf618b18035" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fdc&lt;/code&gt;</source>
          <target state="translated">功能声明 &lt;code&gt;fdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e24cae0141215bceece007770b580c50fd2f38" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;func&lt;/code&gt;</source>
          <target state="translated">FuncDeclaration &lt;code&gt;func&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f3b288cb44551e47fdefb27fe0ea167fb4d1483" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt;（AggregateDeclaration广告，范围* sc）；</target>
        </trans-unit>
        <trans-unit id="2e19843cd5ed176434a3efaeff7d8bda7426dc57" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="03359c276bccc50045b57bc8ace08bc6d8f2ae59" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="507d5c363210e3f23b2c42085b0c0ff39e10c2cc" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="859ef670635a842eaebad8ac23f82e95392d9e8c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="dc070bb95306fb1a92b40edce98353f4664181ad" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="a30ba00bb5d45e8e8a6da89f6ff22fb9cbecb606" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt;(TemplateInstance ti, Scope* sc2, FuncDeclaration fd, Type tthis, Expressions* fargs);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt;（TemplateInstance ti，Scope * sc2，FuncDeclaration fd，Type tthis，Expressions * fargs）;</target>
        </trans-unit>
        <trans-unit id="d05a566062ec8864bd0d4c9e283c124ce8c44dfa" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdensure&quot;&gt;fdensure&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;fdensure&quot;&gt;缺陷&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e42a220d72031c5ac346bcdb8b0d4dc5655921c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d75bdbbe19a26e762aba1b2f76a15fde383c64a0" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt;（AggregateDeclaration广告，范围* sc）；</target>
        </trans-unit>
        <trans-unit id="fb1ead50f11e27697b705598972fc6d1ffead188" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasThis&quot;&gt;hasThis&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;hasThis&quot;&gt;hasThis&lt;/strong&gt;（Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="9c8e5d63f59418c4c2add44a220d39f8eb8d7843" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e92604a27d4e8a86aead189ab657e429f7804d91" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt;(ref const Loc loc, Scope* sc, Dsymbol s, Objects* tiargs, Type tthis, Expressions* fargs, FuncResolveFlag flags);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt;（ref const Loc loc，Scope * sc，Dsymbol s，Objects * tiargs，tthis类型，Expressions * fargs，FuncResolveFlag标志）;</target>
        </trans-unit>
        <trans-unit id="6bc7f2dda0d8c4f33d8fa77e2a6866f9c3e063da" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt;(StructDeclaration sd);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt;（StructDeclaration sd）;</target>
        </trans-unit>
        <trans-unit id="d2f8d9014611a673032f33ed2918b0db3cbea6e7" translate="yes" xml:space="preserve">
          <source>FuncDeclaration of &lt;code&gt;toString()&lt;/code&gt; if found, &lt;code&gt;null&lt;/code&gt; if not</source>
          <target state="translated">的FuncDeclaration &lt;code&gt;toString()&lt;/code&gt; 如果找到， &lt;code&gt;null&lt;/code&gt; 如果不</target>
        </trans-unit>
        <trans-unit id="0de7865b78f78b6942752a1607fa8f3decdf8f8b" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;foverrides&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;泛滥&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cefac5fb4c4f6f7aad7982a9de7b94425bbd152a" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1147d19864a2f24679061fb745f4f2745312dc4d" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l1&lt;/code&gt;</source>
          <target state="translated">FuncLiteralDeclaration &lt;code&gt;l1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34754aacf81ddb7c1a4c8be9c611413058146f76" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l2&lt;/code&gt;</source>
          <target state="translated">FuncLiteralDeclaration &lt;code&gt;l2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0df7e78750c597d40962880c788feb5d42d0507c" translate="yes" xml:space="preserve">
          <source>FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</source>
          <target state="translated">FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d148d41b57da4467de12a195094eac776bca54d" translate="yes" xml:space="preserve">
          <source>Function Attribute Inference</source>
          <target state="translated">函数属性推断</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">功能辅助数据</target>
        </trans-unit>
        <trans-unit id="7cb4de12c910c8d000862c6b8806ba33b405085e" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading</source>
          <target state="translated">功能调用操作者重载</target>
        </trans-unit>
        <trans-unit id="b257168e280b545833c00a892f5a9654498e1038" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading &lt;code&gt;f()&lt;/code&gt;</source>
          <target state="translated">函数调用运算符重载 &lt;code&gt;f()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="287c317aff3ca62b6d115ccce3c3993c93d19bb1" translate="yes" xml:space="preserve">
          <source>Function Calling Conventions</source>
          <target state="translated">函数调用约定</target>
        </trans-unit>
        <trans-unit id="897aa7901cb2b135a5d5c44d09b74d23db3807ca" translate="yes" xml:space="preserve">
          <source>Function Default Arguments</source>
          <target state="translated">函数默认参数</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">功能标志</target>
        </trans-unit>
        <trans-unit id="d8861f5c13214753c72cc4ec28a42da4d33141ab" translate="yes" xml:space="preserve">
          <source>Function Inheritance and Overriding</source>
          <target state="translated">函数继承和覆盖</target>
        </trans-unit>
        <trans-unit id="5bcb901ef2c2acd0ad4fdd3aaa4dbd63df1c459e" translate="yes" xml:space="preserve">
          <source>Function Literals</source>
          <target state="translated">功能文字</target>
        </trans-unit>
        <trans-unit id="a9ab374cd6bd246bd36d7f40fb0af05f53c4d5a7" translate="yes" xml:space="preserve">
          <source>Function Name</source>
          <target state="translated">功能名称</target>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="translated">功能重载</target>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">功能参数</target>
        </trans-unit>
        <trans-unit id="27e4c7203c9643477f2a066182da530038d7af91" translate="yes" xml:space="preserve">
          <source>Function Return Values</source>
          <target state="translated">函数返回值</target>
        </trans-unit>
        <trans-unit id="564f4636a468d710ec718d52c0a86615388f886e" translate="yes" xml:space="preserve">
          <source>Function Safety</source>
          <target state="translated">功能安全</target>
        </trans-unit>
        <trans-unit id="89ef743a3244fbdb65d0570367a96fdb2440073a" translate="yes" xml:space="preserve">
          <source>Function Templates</source>
          <target state="translated">功能模板</target>
        </trans-unit>
        <trans-unit id="26851646d4034fb238c1b8a8d1cbdf65764b94ab" translate="yes" xml:space="preserve">
          <source>Function Templates with Auto Ref Parameters</source>
          <target state="translated">带有自动参考参数的功能模板</target>
        </trans-unit>
        <trans-unit id="2a828a2f47a94f98e25eacb43fb34ce3a0a927e6" translate="yes" xml:space="preserve">
          <source>Function argument initializes a &lt;code&gt;return&lt;/code&gt; parameter, and that parameter gets assigned to &lt;code&gt;firstArg&lt;/code&gt;. Essentially, treat as &lt;code&gt;firstArg = arg;&lt;/code&gt;</source>
          <target state="translated">Function参数初始化一个 &lt;code&gt;return&lt;/code&gt; 参数，然后将该参数分配给 &lt;code&gt;firstArg&lt;/code&gt; 。本质上，将其视为 &lt;code&gt;firstArg = arg;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87a4aa72b8e4acaa8f362e2eba871dd25b95962b" translate="yes" xml:space="preserve">
          <source>Function attributes</source>
          <target state="translated">功能属性</target>
        </trans-unit>
        <trans-unit id="a3518d2ba96341cb705a0844010da23ec63c4f60" translate="yes" xml:space="preserve">
          <source>Function attributes are emitted in the order as listed above.</source>
          <target state="translated">功能属性按上述顺序发出。</target>
        </trans-unit>
        <trans-unit id="090cdc3abee08672ecc88627488c127b4dd88e47" translate="yes" xml:space="preserve">
          <source>Function bodies cannot be empty:</source>
          <target state="translated">功能体不能为空。</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">职能机构</target>
        </trans-unit>
        <trans-unit id="daa6044eeb443eca769ad767c0b819da1d93de92" translate="yes" xml:space="preserve">
          <source>Function calls to these are generated by the compiler and inserted into the object code.</source>
          <target state="translated">对这些函数的调用由编译器生成并插入到对象代码中。</target>
        </trans-unit>
        <trans-unit id="dcd2bd5d9c9b442091f087f1d3ab7d165c7a6f01" translate="yes" xml:space="preserve">
          <source>Function contracts</source>
          <target state="translated">职能合同</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">功能声明</target>
        </trans-unit>
        <trans-unit id="dd0e134160bc0255e9ac645522671a4ceac9664b" translate="yes" xml:space="preserve">
          <source>Function for starting to a stop watch time when the function is called and stopping it when its return value goes out of scope and is destroyed.</source>
          <target state="translated">用于在调用函数时开始到停止手表时间,并在其返回值超出范围并被销毁时停止的函数。</target>
        </trans-unit>
        <trans-unit id="aae2ba6220f8db51d41c8edbd64b6b01f43243fd" translate="yes" xml:space="preserve">
          <source>Function is a C-style variadic function, which uses &lt;code&gt;core.stdc.stdarg&lt;/code&gt;</source>
          <target state="translated">函数是C风格的可变参数函数，它使用 &lt;code&gt;core.stdc.stdarg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87d2f358ca186efbcb568c16e606003520afa9cd" translate="yes" xml:space="preserve">
          <source>Function is a D-style variadic function, which uses &lt;code&gt;__argptr&lt;/code&gt; and &lt;code&gt;__arguments&lt;/code&gt;.</source>
          <target state="translated">函数是D风格的可变参数函数，它使用 &lt;code&gt;__argptr&lt;/code&gt; 和 &lt;code&gt;__arguments&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3435b54d43e95cebfb7003ed401ba2d6c58be33" translate="yes" xml:space="preserve">
          <source>Function is a typesafe variadic function.</source>
          <target state="translated">Function是一个类型安全的变量函数。</target>
        </trans-unit>
        <trans-unit id="02eaa479f3aca73ffbcbe24d76bdcbcb5f2a00b8" translate="yes" xml:space="preserve">
          <source>Function is not variadic.</source>
          <target state="translated">功能不是变化的。</target>
        </trans-unit>
        <trans-unit id="f04ac1afcdca4559aaa061f6f7593d6d3478e357" translate="yes" xml:space="preserve">
          <source>Function parameter &lt;code&gt;par&lt;/code&gt; is being initialized to &lt;code&gt;arg&lt;/code&gt;, and &lt;code&gt;par&lt;/code&gt; may escape. Detect if scoped values can escape this way. Print error messages when these are detected.</source>
          <target state="translated">函数参数 &lt;code&gt;par&lt;/code&gt; 被初始化为 &lt;code&gt;arg&lt;/code&gt; ，而 &lt;code&gt;par&lt;/code&gt; 可能会逸出。检测范围值是否可以通过这种方式逃脱。检测到错误消息时将其打印出来。</target>
        </trans-unit>
        <trans-unit id="3029155acb4ac5fc232abd3463c11350cc2d960a" translate="yes" xml:space="preserve">
          <source>Function parameter declarations can have default values:</source>
          <target state="translated">函数参数声明可以有默认值。</target>
        </trans-unit>
        <trans-unit id="f6a6b4c753629a0ad23be9a19a0def5754916cb7" translate="yes" xml:space="preserve">
          <source>Function parameters can be documented by listing them in a params section. Each line that starts with an identifier followed by an '=' starts a new parameter description. A description can span multiple lines.</source>
          <target state="translated">函数参数可以通过在params部分列出它们来记录。每一行以标识符开头,后面跟着一个'=',开始一个新的参数描述。一个描述可以跨越多行。</target>
        </trans-unit>
        <trans-unit id="6678c5d32e09052e0172ebd3cea351dcf7ca2766" translate="yes" xml:space="preserve">
          <source>Function parameters: Pident identifier of parameter Ptype type of argument Pelem default value for argument Psym symbol corresponding to Pident when using the parameter list as a symbol table For template-parameter-list: Pident identifier of parameter Ptype if NULL, this is a type-parameter else the type for a parameter-declaration value argument Pelem default value for value argument Pdeftype default value for type-parameter Pptpl template-parameter-list for template-template-parameter Psym default value for template-template-parameter For template-arg-list: (actual arguments) Pident NULL Ptype type-name Pelem expression (either Ptype or Pelem is NULL) Psym SCtemplate for template-template-argument</source>
          <target state="translated">函数参数。参数的Pident标识符 Ptype参数的类型 Pelem参数的缺省值 当把参数列表作为符号表使用时,Pident对应的Psym符号 对于模板-参数列表。参数的Pident标识符 Ptype 如果为NULL,则为类型参数,否则为参数声明值参数的类型 Pelem 值参数的缺省值 Pdeftype 类型参数的缺省值 Pptpl template-parameter-list 为 template-template-parameter Psym 为 template-template-parameter 的缺省值 为 template-arg-list:(实际参数)Pident NULL Ptype type-name Pelem表达式(Ptype或Pelem均为NULL)Psym SCtemplate for template-template-argument.</target>
        </trans-unit>
        <trans-unit id="4e74811387b8309f2eba7069545da73ad882b5db" translate="yes" xml:space="preserve">
          <source>Function pointers can be passed to functions taking a delegate argument by passing them through the &lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt;&lt;code&gt;std.functional.toDelegate&lt;/code&gt;&lt;/a&gt; template, which converts any callable to a delegate without context.</source>
          <target state="translated">函数指针可以通过&lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt; &lt;code&gt;std.functional.toDelegate&lt;/code&gt; &lt;/a&gt;模板传递给带有委托参数的函数，该模板将任何可调用对象转换为没有上下文的委托。</target>
        </trans-unit>
        <trans-unit id="2f4d971f1b9568ee68d3c3afd0afa4bb0664e45b" translate="yes" xml:space="preserve">
          <source>Function results are returned from &lt;code&gt;yieldForce&lt;/code&gt;, &lt;code&gt;spinForce&lt;/code&gt; and &lt;code&gt;workForce&lt;/code&gt; by ref. If &lt;code&gt;fun&lt;/code&gt; returns by ref, the reference will point to the returned reference of &lt;code&gt;fun&lt;/code&gt;. Otherwise it will point to a field in this struct.</source>
          <target state="translated">函数结果由ref 从 &lt;code&gt;yieldForce&lt;/code&gt; ， &lt;code&gt;spinForce&lt;/code&gt; 和 &lt;code&gt;workForce&lt;/code&gt; 返回。如果 &lt;code&gt;fun&lt;/code&gt; 由ref返回，则引用将指向返回的 &lt;code&gt;fun&lt;/code&gt; 引用。否则它将指向此结构中的一个字段。</target>
        </trans-unit>
        <trans-unit id="c3097f849806cf699273164feb8e2d0ccfb12c15" translate="yes" xml:space="preserve">
          <source>Function return values are considered to be rvalues. This means they cannot be passed by reference to other functions.</source>
          <target state="translated">函数的返回值被认为是r值,这意味着它们不能通过引用其他函数来传递。这意味着它们不能通过引用传递给其他函数。</target>
        </trans-unit>
        <trans-unit id="828053ed1d877ebcde1ff06a5dea505b651e20d3" translate="yes" xml:space="preserve">
          <source>Function template type parameters that are to be implicitly deduced may not have specializations:</source>
          <target state="translated">要隐式推导的函数模板类型参数不得有特殊化。</target>
        </trans-unit>
        <trans-unit id="a7d00ef56bc1d2f06bd67eb8bc21de19e80c263d" translate="yes" xml:space="preserve">
          <source>Function templates can be explicitly instantiated with a !(</source>
          <target state="translated">函数模板可以用 !()显式实例化。</target>
        </trans-unit>
        <trans-unit id="3b8df2ef7fc72848cf8d0bce3a9220b3a898f0b1" translate="yes" xml:space="preserve">
          <source>Function templates can have their return types deduced based on the &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function, just as with normal functions. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">就像普通函数一样，可以根据函数中的&lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;推断函数模板的返回类型。请参阅&lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;自动功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55b6f95d2a2736a8bfaa71fcc12b1d0a3c85769f" translate="yes" xml:space="preserve">
          <source>Function that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">调用 &lt;code&gt;_d_HookTraceImpl&lt;/code&gt; 的函数</target>
        </trans-unit>
        <trans-unit id="8c7a2db7de16ccd53dc1b73193b31c814b7489e6" translate="yes" xml:space="preserve">
          <source>Function that does not take any parameters</source>
          <target state="translated">不接受任何参数的函数</target>
        </trans-unit>
        <trans-unit id="85ff978df4b7d827c80c5b427bf2c4db1e2ed45d" translate="yes" xml:space="preserve">
          <source>Function that will be called instead of the internal progress display function. This function should be defined as the curl_progress_callback prototype defines.</source>
          <target state="translated">代替内部进度显示函数被调用的函数。这个函数应该被定义为curl_progress_callback原型所定义的函数。</target>
        </trans-unit>
        <trans-unit id="23533f8923b79f1dc08d42a47fdcce75663a40c0" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from UTF8 (instead of using the iconv calls in libcurl) Note that this is used only for SSL certificate processing</source>
          <target state="translated">调用UTF8转换的函数(而不是使用libcurl中的iconv调用),注意这只用于SSL证书处理。</target>
        </trans-unit>
        <trans-unit id="9149aa5e3f56e9141da81bbd147711474255a324" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">调用该函数来转换网络编码(而不是使用libcurl中的iconv调用)。</target>
        </trans-unit>
        <trans-unit id="cffc93dc9124a77261edd44618001f6b42f32854" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert to the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">将被调用的函数,用于转换为网络编码(而不是使用libcurl中的iconv调用)。</target>
        </trans-unit>
        <trans-unit id="53a515cf174973bb65a87a5952e5c03252c9695d" translate="yes" xml:space="preserve">
          <source>Function that will be called to read the input (instead of fread). The parameters will use fread() syntax, make sure to follow them.</source>
          <target state="translated">将被调用来读取输入的函数(代替fread)。参数将使用fread()语法,请务必遵循它们。</target>
        </trans-unit>
        <trans-unit id="babcbdb82bd11f7164bb99107054b2a484fb1682" translate="yes" xml:space="preserve">
          <source>Function that will be called to store headers (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">将被调用来存储头文件的函数(代替fwrite)。参数将使用fwrite()语法,请务必遵循它们。</target>
        </trans-unit>
        <trans-unit id="233d456dba50e927381d10867821a9bfe1f04637" translate="yes" xml:space="preserve">
          <source>Function that will be called to store the output (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">将被调用来存储输出的函数(代替fwrite)。参数将使用fwrite()语法,请务必遵循它们。</target>
        </trans-unit>
        <trans-unit id="e221c711ff99df59e968c914d1979c6a0ad3ee61" translate="yes" xml:space="preserve">
          <source>Function to apply to each element of range</source>
          <target state="translated">适用于范围内每个元素的函数</target>
        </trans-unit>
        <trans-unit id="b844384b07c0f5d9caaa10fd46cb397be8c61ded" translate="yes" xml:space="preserve">
          <source>Function to be analyzed</source>
          <target state="translated">需要分析的功能</target>
        </trans-unit>
        <trans-unit id="b78a95743121775c17568fcabf9200b6a902bef0" translate="yes" xml:space="preserve">
          <source>Function to check, followed by a variadic number of function attributes as strings</source>
          <target state="translated">要检查的函数,后面的函数属性为字符串,数量不等。</target>
        </trans-unit>
        <trans-unit id="aefc954f08bca71e2e39ec093b9e23048430f8af" translate="yes" xml:space="preserve">
          <source>Function traits</source>
          <target state="translated">功能特点</target>
        </trans-unit>
        <trans-unit id="2e40e24355bdf1170d50a1d6ead524ba20679656" translate="yes" xml:space="preserve">
          <source>Function/Delegate literal</source>
          <target state="translated">功能/委托字面意思</target>
        </trans-unit>
        <trans-unit id="8ebd95c8f1ce3b6070bf21aaa16655aa94a89c6b" translate="yes" xml:space="preserve">
          <source>FunctionLiteral</source>
          <target state="translated">FunctionLiteral</target>
        </trans-unit>
        <trans-unit id="a3d450d75bfa53b89f98aa6dae8be36130018cbb" translate="yes" xml:space="preserve">
          <source>FunctionLiteralBody</source>
          <target state="translated">FunctionLiteralBody</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="a03b0f45370db4b978978138169257e95bfff4b6" translate="yes" xml:space="preserve">
          <source>Functionality for processing subsequent matches of global regexes via range interface:</source>
          <target state="translated">通过范围接口处理全局regex的后续匹配的功能。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5687015bfcd81aa78a69312ebd359e3273b183cc" translate="yes" xml:space="preserve">
          <source>Functions Without Bodies</source>
          <target state="translated">无体功能</target>
        </trans-unit>
        <trans-unit id="bba90169e567d9c68b308641b7cc0ffd3300695b" translate="yes" xml:space="preserve">
          <source>Functions and delegates declared at module scope are zero-initialized by default. However both can be initialized to any function pointer (including a function literal). For delegates, the context pointer &lt;code&gt;.ptr&lt;/code&gt; is initialized to null.</source>
          <target state="translated">默认情况下，在模块作用域声明的函数和委托为零初始化。但是，两者都可以初始化为任何函数指针（包括函数文字）。对于委托，上下文指针 &lt;code&gt;.ptr&lt;/code&gt; 初始化为null。</target>
        </trans-unit>
        <trans-unit id="b9443a12c52c106d6f6936a59aa4d60507110962" translate="yes" xml:space="preserve">
          <source>Functions and types that manipulate built-in arrays and associative arrays.</source>
          <target state="translated">操作内置数组和关联数组的函数和类型。</target>
        </trans-unit>
        <trans-unit id="1fcc64ae1b70c55efc217545c066c056d0513c2e" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interface with extern(C++) ABI.</source>
          <target state="translated">extern(C++)ABI接口的函数和变量。</target>
        </trans-unit>
        <trans-unit id="fd8851f8cc2c81bc5719fd2159093b00e7797298" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interfacing with extern(C) ABI.</source>
          <target state="translated">与extern(C)ABI接口的特定函数和变量。</target>
        </trans-unit>
        <trans-unit id="7f5a53c5e8af7e00f9774b9397648dd6e21fd328" translate="yes" xml:space="preserve">
          <source>Functions are never inlined.</source>
          <target state="translated">函数从不内联。</target>
        </trans-unit>
        <trans-unit id="4713c57b4dfbd0d2f4ef062d96b18f64a40c55bc" translate="yes" xml:space="preserve">
          <source>Functions are overloaded based on how well the arguments to a function can match up with the parameters. The function with the</source>
          <target state="translated">函数的重载是基于函数的参数与参数的匹配程度。函数的</target>
        </trans-unit>
        <trans-unit id="a7f661a74f02a377df2091c16fea97336e40806f" translate="yes" xml:space="preserve">
          <source>Functions as Array Properties</source>
          <target state="translated">函数作为阵列属性</target>
        </trans-unit>
        <trans-unit id="e47c1a27abfc73a2fed656e28cc0a5aa9ab7a938" translate="yes" xml:space="preserve">
          <source>Functions can also be declared as &lt;code&gt;ref&lt;/code&gt;, meaning their return value is passed by reference:</source>
          <target state="translated">函数也可以声明为 &lt;code&gt;ref&lt;/code&gt; ，这意味着它们的返回值由引用传递：</target>
        </trans-unit>
        <trans-unit id="fc9e94fc77751f7a520ef1950989f7a0e1c7828b" translate="yes" xml:space="preserve">
          <source>Functions can be nested within member functions:</source>
          <target state="translated">函数可以嵌套在成员函数中。</target>
        </trans-unit>
        <trans-unit id="7e69a10d10797495520ab6d16edfbd50e9742682" translate="yes" xml:space="preserve">
          <source>Functions declared at the same scope overload against each other, and are called an</source>
          <target state="translated">在同一作用域声明的函数相互重载,并被称为一个</target>
        </trans-unit>
        <trans-unit id="c566e2fda222bdb6e383ab5ff3c3433df764aa7f" translate="yes" xml:space="preserve">
          <source>Functions defined with non-D linkage cannot be overloaded. This is because the name mangling might not take the parameter types into account.</source>
          <target state="translated">用非D链接定义的函数不能被重载。这是因为名称混杂可能没有考虑到参数类型。</target>
        </trans-unit>
        <trans-unit id="988f1aa7ff1ca669378942571abfebb6288e682f" translate="yes" xml:space="preserve">
          <source>Functions executed via CTFE can give different results from run time in the following scenarios:</source>
          <target state="translated">在以下情况下,通过CTFE执行的函数在运行时可以得到不同的结果。</target>
        </trans-unit>
        <trans-unit id="419aab857f4bb8c6136ba89e91fb3714fd5cb75f" translate="yes" xml:space="preserve">
          <source>Functions for starting and interacting with other processes, and for working with the current process' execution environment.</source>
          <target state="translated">用于启动其他进程并与之交互,以及与当前进程的执行环境一起工作的功能。</target>
        </trans-unit>
        <trans-unit id="50b5e5b232695481bdd4d283f8038b839689e2f6" translate="yes" xml:space="preserve">
          <source>Functions marked as &lt;code&gt;final&lt;/code&gt; may not be overridden in a derived class, unless they are also &lt;code&gt;private&lt;/code&gt;. For example:</source>
          <target state="translated">标记为 &lt;code&gt;final&lt;/code&gt; 的功能不得在派生类中重写，除非它们也是 &lt;code&gt;private&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="c40c48a24043c849a46e19c95c7d6f6bb43d3af4" translate="yes" xml:space="preserve">
          <source>Functions may be nested within other functions:</source>
          <target state="translated">函数可以嵌套在其他函数中。</target>
        </trans-unit>
        <trans-unit id="ab842017af8570439bf6ba4b27c54b5312a024b2" translate="yes" xml:space="preserve">
          <source>Functions nested inside safe functions default to being safe functions.</source>
          <target state="translated">嵌套在安全函数内的函数默认为安全函数。</target>
        </trans-unit>
        <trans-unit id="e7c3eeba379274331a0b9c881db32559bea140a9" translate="yes" xml:space="preserve">
          <source>Functions taking a variable number of arguments are called variadic functions. A variadic function can take one of three forms:</source>
          <target state="translated">取一个可变参数数的函数称为变元函数。变量函数可以采取三种形式之一。</target>
        </trans-unit>
        <trans-unit id="2f8dcbed7cf260c12b9f8f40b2d592ffce349a24" translate="yes" xml:space="preserve">
          <source>Functions that deal with mutable, const, or immutable types with equanimity often need to transmit their type to the return value:</source>
          <target state="translated">以等价的方式处理可变型、const型或不可变型的函数通常需要将其类型传输到返回值。</target>
        </trans-unit>
        <trans-unit id="8cc0d5a6974c142e0e42bd69101ee5cdc41acf88" translate="yes" xml:space="preserve">
          <source>Functions that manipulate other functions.</source>
          <target state="translated">操纵其他函数的函数。</target>
        </trans-unit>
        <trans-unit id="9283433eaa6818c4d57146ef0bb556e3d0ffc12f" translate="yes" xml:space="preserve">
          <source>Functions which are both portable and free of global side-effects can be executed at compile time. In certain contexts, such compile time execution is guaranteed. It is called Compile Time Function Execution (CTFE) then. The contexts that trigger CTFE are:</source>
          <target state="translated">既可移植又没有全局副作用的函数可以在编译时执行。在某些情况下,这种编译时执行是有保证的。那么,它被称为编译时函数执行(CTFE)。触发CTFE的上下文是:。</target>
        </trans-unit>
        <trans-unit id="670fb705837790471a38cafc20ec80fbf30c8bf6" translate="yes" xml:space="preserve">
          <source>Functions which operate on ASCII characters.</source>
          <target state="translated">对ASCII字符进行操作的函数。</target>
        </trans-unit>
        <trans-unit id="7c0d365cb94dab42778d857cad063abfc3d8f3b6" translate="yes" xml:space="preserve">
          <source>Functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage has an additional hidden, unnamed, parameter which is the selector it was called with.</source>
          <target state="translated">具有 &lt;code&gt;Objective-C&lt;/code&gt; 链接的函数还有一个额外的隐藏的，未命名的参数，它是调用它的选择器。</target>
        </trans-unit>
        <trans-unit id="ffbb7352ab0b0a6abe4eb4d50fb47e8061479506" translate="yes" xml:space="preserve">
          <source>Functions with non-D linkage cannot be virtual and hence cannot be overridden.</source>
          <target state="translated">非D连接的函数不能虚拟,因此不能被覆盖。</target>
        </trans-unit>
        <trans-unit id="2adb6747d6f26e87d983ed577d7da81919733d7b" translate="yes" xml:space="preserve">
          <source>Functions without bodies:</source>
          <target state="translated">没有机构的功能。</target>
        </trans-unit>
        <trans-unit id="d783b16a7b27b910940b783d5fcc870c6c683d47" translate="yes" xml:space="preserve">
          <source>Fundamental Unicode algorithms and data structures.</source>
          <target state="translated">基本的Unicode算法和数据结构。</target>
        </trans-unit>
        <trans-unit id="ba469f1bc17cb15fca5f5581188a0b34ac4471eb" translate="yes" xml:space="preserve">
          <source>Furthermore, even with orderable types, the order relation may not be linear. For example, one may define an ordering on sets via the subset relation, such that &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true if &lt;code&gt;x&lt;/code&gt; is a (strict) subset of &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are disjoint sets, then neither &lt;code&gt;x &amp;lt; y&lt;/code&gt; nor &lt;code&gt;y &amp;lt; x&lt;/code&gt; holds, but that does not imply that &lt;code&gt;x == y&lt;/code&gt;. Thus, it is insufficient to determine equality purely based on &lt;code&gt;opCmp&lt;/code&gt; alone. For this reason, &lt;code&gt;opCmp&lt;/code&gt; is only used for the inequality operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt;. The equality operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; always employ &lt;code&gt;opEquals&lt;/code&gt; instead.</source>
          <target state="translated">此外，即使具有可排序的类型，顺序关系也可能不是线性的。例如，一个可以经由所述子集关系限定在套的排序，使得 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 为真，如果 &lt;code&gt;x&lt;/code&gt; 是的（严格）的子集 &lt;code&gt;y&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是不交集，则 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 和 &lt;code&gt;y &amp;lt; x&lt;/code&gt; 都不成立，但这并不意味着 &lt;code&gt;x == y&lt;/code&gt; 。因此，仅基于 &lt;code&gt;opCmp&lt;/code&gt; 来确定相等性是不够的。因此， &lt;code&gt;opCmp&lt;/code&gt; 仅用于不等式运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 。等号运算符 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 始终使用 &lt;code&gt;opEquals&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="869bc7df187eb57c1861571c27bf80367e22db67" translate="yes" xml:space="preserve">
          <source>Furthermore, predefined version identifiers from this list cannot be set from the command line or from version statements. (This prevents things like both &lt;code&gt;Windows&lt;/code&gt; and &lt;code&gt;linux&lt;/code&gt; being simultaneously set.)</source>
          <target state="translated">此外，无法从命令行或版本语句设置此列表中的预定义版本标识符。（这可以防止同时设置 &lt;code&gt;Windows&lt;/code&gt; 和 &lt;code&gt;linux&lt;/code&gt; 之类的东西。）</target>
        </trans-unit>
        <trans-unit id="2b04009b8ca8039e0507f25a9f0361986b70a3e6" translate="yes" xml:space="preserve">
          <source>Future policies may offer a more even balance between reader and writer precedence.</source>
          <target state="translated">未来的政策可能会在读者和作者的优先权之间提供更均衡的平衡。</target>
        </trans-unit>
        <trans-unit id="99d254d35351117c9cff18872b82ba6d91c00e60" translate="yes" xml:space="preserve">
          <source>G &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">摹 &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="227e2edf0447cd04a773c3b823f1c89795158178" translate="yes" xml:space="preserve">
          <source>GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt;(string name);</source>
          <target state="translated">GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt;（字符串名称）；</target>
        </trans-unit>
        <trans-unit id="17686e6502ad0f3cdaf4206e0191cbc522cc8283" translate="yes" xml:space="preserve">
          <source>GC FAQ</source>
          <target state="translated">常见问题</target>
        </trans-unit>
        <trans-unit id="2715953d0812423734ebffeea6a105ce46d2c5b2" translate="yes" xml:space="preserve">
          <source>GC allocated string</source>
          <target state="translated">GC分配的字符串</target>
        </trans-unit>
        <trans-unit id="8b2c6daf9a150d506a85e85cb9bcb053667888f2" translate="yes" xml:space="preserve">
          <source>GC allocated string with spaces replaced with tabs; use &lt;a href=&quot;#entabber&quot;&gt;&lt;code&gt;entabber&lt;/code&gt;&lt;/a&gt; to not allocate.</source>
          <target state="translated">GC分配的字符串，其中空格用制表符替换；使用&lt;a href=&quot;#entabber&quot;&gt; &lt;code&gt;entabber&lt;/code&gt; &lt;/a&gt;不分配。</target>
        </trans-unit>
        <trans-unit id="86e1b687d8486a9dcb7b4165bc8e5226d854f2c7" translate="yes" xml:space="preserve">
          <source>GC allocated string with tabs replaced with spaces</source>
          <target state="translated">GC分配的字符串,用空格代替了制表符。</target>
        </trans-unit>
        <trans-unit id="6b9746104b4c3bc7be22e5b6d74741bddee5a6bf" translate="yes" xml:space="preserve">
          <source>GC implementations are added to a registry that allows to supply more implementations by just linking them into the binary. To do so add a function that is executed before the D runtime initialization using &lt;code&gt;pragma(crt_constructor)&lt;/code&gt;:</source>
          <target state="translated">GC实现已添加到注册表中，该注册表仅通过将其链接到二进制文件即可提供更多实现。为此，添加一个使用 &lt;code&gt;pragma(crt_constructor)&lt;/code&gt; 在D运行时初始化之前执行的函数：</target>
        </trans-unit>
        <trans-unit id="5951ff6858fe229e78c3aef61db342f3d5f757a1" translate="yes" xml:space="preserve">
          <source>GC scan hook, called FOR each thread. Can be used to scan additional thread local memory.</source>
          <target state="translated">GC扫描钩子,为每个线程调用。可用于扫描额外的线程本地内存。</target>
        </trans-unit>
        <trans-unit id="44da27f9ddec555cbd5fcd60022e2b6c8808bbdc" translate="yes" xml:space="preserve">
          <source>GC sweep hook, called FOR each thread. Can be used to free additional thread local memory or associated data structures. Note that only memory allocated from the GC can have marks.</source>
          <target state="translated">GC扫荡钩子,FOR每个线程调用。可以用来释放额外的线程本地内存或相关数据结构。注意,只有从GC分配的内存才能有标记。</target>
        </trans-unit>
        <trans-unit id="152e90dd32518be928b899f58b1e3835f65ca8cc" translate="yes" xml:space="preserve">
          <source>GCFactory &lt;code&gt;factory&lt;/code&gt;</source>
          <target state="translated">GCFactory &lt;code&gt;factory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04a69c000934b632336629d0d827590961013d5f" translate="yes" xml:space="preserve">
          <source>GDC (GNU D Compiler) is the compiler</source>
          <target state="translated">GDC(GNU D Compiler)是编译器</target>
        </trans-unit>
        <trans-unit id="c6b9fdbe9b835ce607d5f9465603dc2e9dd09b8c" translate="yes" xml:space="preserve">
          <source>GNU D Compiler (GDC)</source>
          <target state="translated">GNU D Compiler (GDC)</target>
        </trans-unit>
        <trans-unit id="1ced0cf23647bda25b46395cd7423d5899e8cec5" translate="yes" xml:space="preserve">
          <source>GNU Hurd</source>
          <target state="translated">GNU Hurd</target>
        </trans-unit>
        <trans-unit id="c9744a883d88a359c771c7c407727c811697e7d9" translate="yes" xml:space="preserve">
          <source>GSS-Negotiate</source>
          <target state="translated">GSS-Negotiate</target>
        </trans-unit>
        <trans-unit id="649101d4277d8226d1453ed4ac0ae23fef3f6651" translate="yes" xml:space="preserve">
          <source>GapWeightedSimilarityIncremental!(R, F) &lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;gapWeightedSimilarityIncremental&lt;/strong&gt;(R, F)(R r1, R r2, F penalty);</source>
          <target state="translated">GapWeightedSimilarityIncremental！（R，F）&lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;gapWeightedSimilarityIncremental&lt;/strong&gt;（R，F）（R r1，R r2，F罚分）;</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">垃圾收集</target>
        </trans-unit>
        <trans-unit id="b68927a1fc8d1a3e9f2d3afdf28381f11e58bc69" translate="yes" xml:space="preserve">
          <source>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</source>
          <target state="translated">垃圾收集。自动动态内存管理的算法</target>
        </trans-unit>
        <trans-unit id="26ed33deae58e27843afa7f067144cf4cc6aa56f" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are faster to develop and debug, because there's no need for developing, debugging, testing, or maintaining the explicit deallocation code.</source>
          <target state="translated">垃圾收集程序的开发和调试速度更快,因为不需要开发、调试、测试或维护显式deallocation代码。</target>
        </trans-unit>
        <trans-unit id="b5b34cabae6ba38a27f9919e85bfc06a08059602" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are often faster. This is counterintuitive, but the reasons are:</source>
          <target state="translated">垃圾收集程序通常更快。这有悖于直觉,但原因是。</target>
        </trans-unit>
        <trans-unit id="a8b92a6daa02321044a81fa8b11e153716774a33" translate="yes" xml:space="preserve">
          <source>Garbage collected programs do not suffer from gradual deterioration due to an accumulation of memory leaks.</source>
          <target state="translated">垃圾收集程序不会因为内存泄漏的积累而逐渐恶化。</target>
        </trans-unit>
        <trans-unit id="7b3b619bb8bd26c9ff456e8cbc3e5bc6b3b1d018" translate="yes" xml:space="preserve">
          <source>Garbage collected programs have fewer hard-to-find pointer bugs. This is because there are no dangling references to freed memory. There is no code to explicitly manage memory, hence no bugs in such code.</source>
          <target state="translated">垃圾收集程序有较少的难以发现的指针错误。这是因为没有悬而未决的对释放内存的引用。没有显式管理内存的代码,因此这种代码没有错误。</target>
        </trans-unit>
        <trans-unit id="6274199ad9ef2c79ed1df932fffcb7da577e7439" translate="yes" xml:space="preserve">
          <source>Garbage collection doesn't solve every memory deallocation problem. For example, if a pointer to a large data structure is kept, the garbage collector cannot reclaim it, even if it is never referred to again. To eliminate this problem, it is good practice to set a reference or pointer to an object to null when no longer needed.</source>
          <target state="translated">垃圾收集器并不能解决所有的内存去分配问题。例如,如果一个指向大型数据结构的指针被保留下来,垃圾收集器就无法回收它,即使它再也没有被引用。为了消除这个问题,好的做法是在不再需要的时候,将一个对象的引用或指针设置为空。</target>
        </trans-unit>
        <trans-unit id="2a483157166b15cc6add50950e71104545209b12" translate="yes" xml:space="preserve">
          <source>Garbage collection is not a panacea. There are some downsides:</source>
          <target state="translated">垃圾收集不是万能的。也有一些弊端。</target>
        </trans-unit>
        <trans-unit id="bdc8494b0a1f3be26c109010c1300b5540a63f86" translate="yes" xml:space="preserve">
          <source>Garbage collection kicks in only when memory gets tight. When memory is not tight, the program runs at full speed and does not spend any time tracing and freeing memory.</source>
          <target state="translated">只有当内存紧张时,垃圾收集才会启动。当内存不紧张时,程序全速运行,不花任何时间跟踪和释放内存。</target>
        </trans-unit>
        <trans-unit id="43e630068e8d3af90d5baf5c490d09a820b5fe43" translate="yes" xml:space="preserve">
          <source>Garbage collection should be implemented as a basic operating system kernel service. But since it is not, garbage collecting programs must carry around with them the garbage collection implementation. While this can be a shared library, it is still there.</source>
          <target state="translated">垃圾收集应该作为一个基本的操作系统内核服务来实现。但既然不是,垃圾收集程序就必须随身携带垃圾收集的实现。虽然这可以是一个共享库,但它还是存在的。</target>
        </trans-unit>
        <trans-unit id="8de09af360c7bfc02cd9b07759c0be1a92997bf1" translate="yes" xml:space="preserve">
          <source>Garbage collectors can keep around some memory that an explicit deallocator would not.</source>
          <target state="translated">垃圾收集器可以保留一些显式deallocator不会保留的内存。</target>
        </trans-unit>
        <trans-unit id="52f128a6c5d8578ad64f58e212419d6613dc978b" translate="yes" xml:space="preserve">
          <source>Garbage collectors reclaim unused memory, therefore they do not suffer from &quot;memory leaks&quot; which can cause long running applications to gradually consume more and more memory until they bring down the system. GC programs have longer term stability.</source>
          <target state="translated">垃圾回收器回收未使用的内存,因此不会出现 &quot;内存泄漏 &quot;的情况,因为长期运行的应用程序会逐渐消耗越来越多的内存,直至使系统瘫痪。GC程序具有较长的稳定性。</target>
        </trans-unit>
        <trans-unit id="5929f6c7d4d9ef8bac1c480f80dfd125a208b5f6" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol</source>
          <target state="translated">网关到网关协议</target>
        </trans-unit>
        <trans-unit id="6b850d9a8cc2ef5b85b6581a88258447107ac8f9" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol level</source>
          <target state="translated">网关对网关协议级别</target>
        </trans-unit>
        <trans-unit id="f0db25c1007f1ac431f102d1b6f3db7e823e1c1d" translate="yes" xml:space="preserve">
          <source>GccAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">GccAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="cc2b80e244c5b3f85b819f8e001f39a8b1778b1c" translate="yes" xml:space="preserve">
          <source>General Punctuation</source>
          <target state="translated">一般标点符号</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">一般类型</target>
        </trans-unit>
        <trans-unit id="fd7aec0ee16d41be57526539a4c6ef8ef63c34e9" translate="yes" xml:space="preserve">
          <source>General case =&amp;gt; symmetric calls to method opEquals</source>
          <target state="translated">一般情况=&amp;gt;对方法opEquals的对称调用</target>
        </trans-unit>
        <trans-unit id="2def4e3aff28a0804ab7417604344f41584fcca9" translate="yes" xml:space="preserve">
          <source>General category sets listed below are only accessible with the &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; shorthand accessor.</source>
          <target state="translated">下面列出的常规类别集只能使用&lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt;速记访问器访问。</target>
        </trans-unit>
        <trans-unit id="2083d118900999f8d32dc5f2e8254d3f52ea6bf1" translate="yes" xml:space="preserve">
          <source>General use synchronization semaphore.</source>
          <target state="translated">一般使用同步信号器。</target>
        </trans-unit>
        <trans-unit id="15c16d502337718b40d0beb9afa9790ccdf94859" translate="yes" xml:space="preserve">
          <source>Generally useful building blocks for customized normalization: &lt;a href=&quot;#combiningClass&quot;&gt;&lt;code&gt;combiningClass&lt;/code&gt;&lt;/a&gt; for querying combining class and &lt;a href=&quot;#allowedIn&quot;&gt;&lt;code&gt;allowedIn&lt;/code&gt;&lt;/a&gt; for testing the Quick_Check property of a given normalization form.</source>
          <target state="translated">用于自定义规范化的通常有用的构建块：&lt;a href=&quot;#combiningClass&quot;&gt; &lt;code&gt;combiningClass&lt;/code&gt; &lt;/a&gt;用于查询组合类，&lt;a href=&quot;#allowedIn&quot;&gt; &lt;code&gt;allowedIn&lt;/code&gt; &lt;/a&gt;用于测试给定规范化形式的Quick_Check属性。</target>
        </trans-unit>
        <trans-unit id="9641d9bcb23b576cc813cade93d2589aaa993fe5" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;stable&lt;/code&gt; ordering strategy may be more costly in time and/or space than the other two because it imposes additional constraints. Similarly, &lt;code&gt;semistable&lt;/code&gt; may be costlier than &lt;code&gt;unstable&lt;/code&gt;. As (semi-)stability is not needed very often, the ordering algorithms in this module parameterized by &lt;code&gt;SwapStrategy&lt;/code&gt; all choose &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; as the default.</source>
          <target state="translated">通常， &lt;code&gt;stable&lt;/code&gt; 排序策略在时间和/或空间上可能比其他两种策略更昂贵，因为它施加了额外的约束。同样， &lt;code&gt;semistable&lt;/code&gt; 可能比 &lt;code&gt;unstable&lt;/code&gt; 更昂贵。由于不经常需要（半）稳定性，因此由 &lt;code&gt;SwapStrategy&lt;/code&gt; 参数化的此模块中的排序算法均选择 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; 作为默认值。</target>
        </trans-unit>
        <trans-unit id="05d74eaaa124507aed1ad66047271caa648813e4" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;std&lt;/code&gt; namespace is used for the main modules in the Phobos standard library. The &lt;code&gt;etc&lt;/code&gt; namespace is used for external C/C++ library bindings. The &lt;code&gt;core&lt;/code&gt; namespace is used for low-level D runtime functions.</source>
          <target state="translated">通常， &lt;code&gt;std&lt;/code&gt; 名称空间用于Phobos标准库中的主要模块。所述 &lt;code&gt;etc&lt;/code&gt; 命名空间用于外部C / C ++库绑定。所述 &lt;code&gt;core&lt;/code&gt; 名称空间被用于低级别d运行时功能。</target>
        </trans-unit>
        <trans-unit id="270a807f0de4d20f0d7b86a3f7b8a65802e708dd" translate="yes" xml:space="preserve">
          <source>Generally, this function checks that &lt;code&gt;path&lt;/code&gt; is not empty, and that each component of the path either satisfies &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; or is equal to &lt;code&gt;&quot;.&quot;&lt;/code&gt; or &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">通常，此函数检查 &lt;code&gt;path&lt;/code&gt; 是否为空，以及路径的每个组成部分是否满足&lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt;或等于 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac3d74ace2e58f845d2e516e7b9c956be3febfc4" translate="yes" xml:space="preserve">
          <source>Generate .obj file for Module.</source>
          <target state="translated">为模块生成.obj文件。</target>
        </trans-unit>
        <trans-unit id="f9dad7b8a1ce93a4eb80b95d85ef1cf88d8f4597" translate="yes" xml:space="preserve">
          <source>Generate C main() in response to seeing D main().</source>
          <target state="translated">在看到D main()时,生成C main()。</target>
        </trans-unit>
        <trans-unit id="345123c70e49b34125173495f611953054f48574" translate="yes" xml:space="preserve">
          <source>Generate Expression to call the invariant.</source>
          <target state="translated">生成Expression来调用不变式。</target>
        </trans-unit>
        <trans-unit id="d90320355fd64aadd68db9a959d0db877a879578" translate="yes" xml:space="preserve">
          <source>Generate HALT instruction.</source>
          <target state="translated">生成HALT指令。</target>
        </trans-unit>
        <trans-unit id="f40cd732815b9b227c307d8a881eabcde883c532" translate="yes" xml:space="preserve">
          <source>Generate Symbol of C++ type info for C++ class cd.</source>
          <target state="translated">为C++类cd生成C++类型信息符号。</target>
        </trans-unit>
        <trans-unit id="71428fcf71b36719232a357b20981c579d5f795c" translate="yes" xml:space="preserve">
          <source>Generate a FuncDeclaration for a runtime library function.</source>
          <target state="translated">生成一个运行时库函数的FuncDeclaration。</target>
        </trans-unit>
        <trans-unit id="c1f38d03f2f34b3b4a976dcf593b7574be546eff" translate="yes" xml:space="preserve">
          <source>Generate a convenient string for identifying this Tid. This is only useful to see if Tid's that are currently executing are the same or different, e.g. for logging and debugging. It is potentially possible that a Tid executed in the future will have the same toString() output as another Tid that has already terminated.</source>
          <target state="translated">生成一个方便的字符串来识别这个Tid。这只对查看当前正在执行的Tid是否相同或不同很有用,例如用于记录和调试。未来执行的一个Tid有可能与另一个已经终止的Tid有相同的toString()输出。</target>
        </trans-unit>
        <trans-unit id="42a4983512e25bdf4577cfbc7ade2d3d9ef11551" translate="yes" xml:space="preserve">
          <source>Generate a copy from e2 to e1.</source>
          <target state="translated">从e2生成一个副本到e1。</target>
        </trans-unit>
        <trans-unit id="7e990bafe6b9623ad15b6163c4381e1e24f60827" translate="yes" xml:space="preserve">
          <source>Generate and output scope table.</source>
          <target state="translated">生成并输出范围表。</target>
        </trans-unit>
        <trans-unit id="d887428fee6838e30b863f3266f3121541d951d0" translate="yes" xml:space="preserve">
          <source>Generate call to C's assert failure function. One of exp, emsg, or str must not be null.</source>
          <target state="translated">生成对C的断言失败函数的调用。exp,emsg,或 str 中的一个不能为空。</target>
        </trans-unit>
        <trans-unit id="b0e2deeef3299cd274df6c669c731ce070bbe521" translate="yes" xml:space="preserve">
          <source>Generate data for instance of _cpp_type_info_ptr that refers to the C++ RTTI symbol for cd.</source>
          <target state="translated">生成指向cd的C++RTTI符号的_cpp_type_info_ptr实例的数据。</target>
        </trans-unit>
        <trans-unit id="92ed283aad401b73892410374fb18c0200210984" translate="yes" xml:space="preserve">
          <source>Generate deterministic named identifier based on a source location, such that the name is consistent across multiple compilations. A new unique name is generated. If the prefix+location is already in the stringtable, an extra suffix is added (starting the count at &quot;1&quot;).</source>
          <target state="translated">基于源位置生成确定性的命名标识符,使名称在多个编译中保持一致。生成一个新的唯一名称。如果前缀+位置已经在字符串表中,则增加一个额外的后缀(从 &quot;1 &quot;开始计数)。</target>
        </trans-unit>
        <trans-unit id="e688f516a8d461fb5372c55840691f744fd51391" translate="yes" xml:space="preserve">
          <source>Generate import symbol from symbol.</source>
          <target state="translated">从符号生成导入符号。</target>
        </trans-unit>
        <trans-unit id="9978fdec524f341bfac18807618c73a3b51b46c1" translate="yes" xml:space="preserve">
          <source>Generate symbol of type ty at DATA:offset</source>
          <target state="translated">在DATA:offset处生成ty类型的符号。</target>
        </trans-unit>
        <trans-unit id="821fb78c5c9319cc69fa8057c9c2cd2d48fedaf8" translate="yes" xml:space="preserve">
          <source>Generate two operand instruction with XMM 128 bit operands.</source>
          <target state="translated">生成两个操作数指令,操作数为XMM 128位。</target>
        </trans-unit>
        <trans-unit id="5c437f1471923979723873169275d327e196c1fa" translate="yes" xml:space="preserve">
          <source>Generated Macro Definitions</source>
          <target state="translated">生成的宏定义</target>
        </trans-unit>
        <trans-unit id="b53fd19a2486af4f399d146936aa03eb7d82a727" translate="yes" xml:space="preserve">
          <source>Generated code is inserted in the scope of &lt;code&gt;std.typecons&lt;/code&gt; module. Thus, any useful functions outside &lt;code&gt;std.typecons&lt;/code&gt; cannot be used in the generated code. To workaround this problem, you may &lt;code&gt;import&lt;/code&gt; necessary things in a local struct, as done in the &lt;code&gt;generateLogger()&lt;/code&gt; template in the above example.</source>
          <target state="translated">生成的代码将插入到 &lt;code&gt;std.typecons&lt;/code&gt; 模块的范围内。因此， &lt;code&gt;std.typecons&lt;/code&gt; 之外的任何有用函数都不能在生成的代码中使用。要解决此问题，您可以在本地结构中 &lt;code&gt;import&lt;/code&gt; 必要的内容，如上例中的 &lt;code&gt;generateLogger()&lt;/code&gt; 模板中所述。</target>
        </trans-unit>
        <trans-unit id="e6857b9e8cb1c55a9a2f9226a5b4dc0cf595f501" translate="yes" xml:space="preserve">
          <source>Generates a hash for &lt;code&gt;this&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookToHash&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; does not implement &lt;code&gt;hookToHash&lt;/code&gt;, but it has state, a hash will be generated for the &lt;code&gt;Hook&lt;/code&gt; using the built-in function and it will be xored with the hash of the &lt;code&gt;payload&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 生成一个哈希值。如果 &lt;code&gt;Hook&lt;/code&gt; 定义了 &lt;code&gt;hookToHash&lt;/code&gt; ，则调用将立即返回 &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; 。如果 &lt;code&gt;Hook&lt;/code&gt; 没有实现 &lt;code&gt;hookToHash&lt;/code&gt; ，但是它具有状态，则将使用内置函数为 &lt;code&gt;Hook&lt;/code&gt; 生成一个哈希，并将其与 &lt;code&gt;payload&lt;/code&gt; 的哈希进行异或。</target>
        </trans-unit>
        <trans-unit id="feba4b72ab473cbf0cd5ea105195b64ec1ac1f2d" translate="yes" xml:space="preserve">
          <source>Generates a hash for the tree. Note that with a custom comparison function it may not hold that if two rbtrees are equal, the hashes of the trees will be equal.</source>
          <target state="translated">生成树的哈希值。需要注意的是,如果两个 rbtrees 相等,树的哈希值就不一定相等。</target>
        </trans-unit>
        <trans-unit id="398b1403000b9404acc8a7edce2480693602dfc5" translate="yes" xml:space="preserve">
          <source>Generates a number between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The &lt;code&gt;boundaries&lt;/code&gt; parameter controls the shape of the interval (open vs. closed on either side). Valid values for &lt;code&gt;boundaries&lt;/code&gt; are &lt;code&gt;&quot;[]&quot;&lt;/code&gt;, &lt;code&gt;&quot;(]&quot;&lt;/code&gt;, &lt;code&gt;&quot;[)&quot;&lt;/code&gt;, and &lt;code&gt;&quot;()&quot;&lt;/code&gt;. The default interval is closed to the left and open to the right. The version that does not take &lt;code&gt;urng&lt;/code&gt; uses the default generator &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">生成之间的数字 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。的 &lt;code&gt;boundaries&lt;/code&gt; 参数控制的间隔的形状（打开与闭合在任一侧上）。为有效值 &lt;code&gt;boundaries&lt;/code&gt; 是 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; &amp;ldquo;（]&amp;rdquo; &lt;code&gt;&quot;(]&quot;&lt;/code&gt; ， &lt;code&gt;&quot;[)&quot;&lt;/code&gt; ，和 &lt;code&gt;&quot;()&quot;&lt;/code&gt; 。默认间隔在左侧关闭，在右侧打开。不使用 &lt;code&gt;urng&lt;/code&gt; 的版本使用默认生成器 &lt;code&gt;rndGen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31d5a7a72aa7d6403397ac8f8b98d7136fb359b8" translate="yes" xml:space="preserve">
          <source>Generates a uniform probability distribution of size &lt;code&gt;n&lt;/code&gt;, i.e., an array of size &lt;code&gt;n&lt;/code&gt; of positive numbers of type &lt;code&gt;F&lt;/code&gt; that sum to &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;useThis&lt;/code&gt; is provided, it is used as storage.</source>
          <target state="translated">生成大小为 &lt;code&gt;n&lt;/code&gt; 的均匀概率分布，即，大小为 &lt;code&gt;n&lt;/code&gt; 且类型为 &lt;code&gt;F&lt;/code&gt; 的正数的总和为 &lt;code&gt;1&lt;/code&gt; 的数组。如果提供了 &lt;code&gt;useThis&lt;/code&gt; ，它将用作存储。</target>
        </trans-unit>
        <trans-unit id="e2682a8625295cc7a75ade62ec910662e42eb1ad" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed floating point number of type &lt;code&gt;T&lt;/code&gt; in the range [0, 1). If no random number generator is specified, the default RNG &lt;code&gt;rndGen&lt;/code&gt; will be used as the source of randomness.</source>
          <target state="translated">生成类型为 &lt;code&gt;T&lt;/code&gt; 的均匀分布浮点数，范围为[0，1）。如果未指定随机数生成器，则默认RNG &lt;code&gt;rndGen&lt;/code&gt; 将用作随机性的来源。</target>
        </trans-unit>
        <trans-unit id="590a92dca2ec49812f71151418c5576ff9ad8ac5" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed number in the range &lt;code&gt;[T.min, T.max]&lt;/code&gt; for any integral or character type &lt;code&gt;T&lt;/code&gt;. If no random number generator is passed, uses the default &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">为任何整数或字符类型 &lt;code&gt;T&lt;/code&gt; 生成一个在 &lt;code&gt;[T.min, T.max]&lt;/code&gt; 范围内的均匀分布的数字。如果未传递随机数生成器，则使用默认的 &lt;code&gt;rndGen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a3dd4ef1d89d221f34cd8efe42c23a94aa835c2" translate="yes" xml:space="preserve">
          <source>Generates string with D source code of unary function with name of &lt;code&gt;funcName&lt;/code&gt; taking a single &lt;code&gt;dchar&lt;/code&gt; argument. If &lt;code&gt;funcName&lt;/code&gt; is empty the code is adjusted to be a lambda function.</source>
          <target state="translated">生成字符串与名称一元函数的d源代码 &lt;code&gt;funcName&lt;/code&gt; 服用单一 &lt;code&gt;dchar&lt;/code&gt; 参数。如果 &lt;code&gt;funcName&lt;/code&gt; 为空，则将代码调整为lambda函数。</target>
        </trans-unit>
        <trans-unit id="4b3935a65e18852e853df767745851e9e88c4154" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;torig&lt;/code&gt; if it hasn't already been generated</source>
          <target state="translated">生成与 &lt;code&gt;torig&lt;/code&gt; 关联的 &lt;code&gt;TypeInfo&lt;/code&gt; 对象（如果尚未生成）</target>
        </trans-unit>
        <trans-unit id="c898dd30458bc82445a94b03bf4338f7812ed73c" translate="yes" xml:space="preserve">
          <source>Generates the following:</source>
          <target state="translated">产生以下内容:</target>
        </trans-unit>
        <trans-unit id="ef2e0bcfe378859fb93a76e38ab31870b5aaab4c" translate="yes" xml:space="preserve">
          <source>Generating UUIDs</source>
          <target state="translated">生成UUIDs</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="7282cafe7ab4dcfbd06151ce87eab6a8cb7b662e" translate="yes" xml:space="preserve">
          <source>Generic Template API used for CRC32 and CRC64 implementations.</source>
          <target state="translated">通用模板API用于CRC32和CRC64的实现。</target>
        </trans-unit>
        <trans-unit id="48d04e2739718c3b5809e3d93e9ab17e0175ee79" translate="yes" xml:space="preserve">
          <source>Generic algorithms for processing sequences.</source>
          <target state="translated">处理序列的通用算法。</target>
        </trans-unit>
        <trans-unit id="7bca8ef182b8f3deaa44e5a838347a3d8559084e" translate="yes" xml:space="preserve">
          <source>Generic algorithms that work with &lt;a href=&quot;std_range&quot;&gt;ranges&lt;/a&gt; of any type, including strings, arrays, and other kinds of sequentially-accessed data. Algorithms include searching, comparison, iteration, sorting, set operations, and mutation.</source>
          <target state="translated">适用于任何类型&lt;a href=&quot;std_range&quot;&gt;范围&lt;/a&gt;的通用算法，包括字符串，数组和其他顺序访问的数据。算法包括搜索，比较，迭代，排序，设置操作和变异。</target>
        </trans-unit>
        <trans-unit id="e37a68ed0e7f2e44e67335effd984a4809f41f52" translate="yes" xml:space="preserve">
          <source>Generic code which deals with different Digest types should always call start though.</source>
          <target state="translated">处理不同Digest类型的通用代码应该总是调用start。</target>
        </trans-unit>
        <trans-unit id="a4fe6a7b8d8e501df226058c573d01d9418d71dd" translate="yes" xml:space="preserve">
          <source>Generic error</source>
          <target state="translated">通用错误</target>
        </trans-unit>
        <trans-unit id="070a5062376a825143c54fc921ea5b5a3350219e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt;&lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">范围上的通用剥离：&lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt; &lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5f39e04859e495f02a94a4f09ad4d9de0e5160e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">范围上的通用剥离：&lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14b5394baf94216f2e7707c45724f2e122958d4a" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">范围上的通用剥离：&lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d110955c054077a9782bc3e9dc049c8ed9e192f" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units.</source>
          <target state="translated">两种时间单位之间的通用换算方式。</target>
        </trans-unit>
        <trans-unit id="fdfe3a8efedde26bb169021d4c0add270ebc9913" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units. Conversions to smaller units use truncating division. Years and months can be converted to each other, small units can be converted to each other, but years and months cannot be converted to or from smaller units (due to the varying number of days in a month or year).</source>
          <target state="translated">两种时间单位之间的通用换算方式。换算成更小的单位时,采用截断式除法。年和月可以互相换算,小单位可以互相换算,但年和月不能与小单位换算或从小单位换算(由于月或年的天数不同)。</target>
        </trans-unit>
        <trans-unit id="8351f1bd421bb3c2f34de06d3708adb7a974a3d4" translate="yes" xml:space="preserve">
          <source>Geometric Shapes</source>
          <target state="translated">几何形状</target>
        </trans-unit>
        <trans-unit id="aca441ddd2e8d07643b87c1b24a828fa5b4b3e42" translate="yes" xml:space="preserve">
          <source>Georgian</source>
          <target state="translated">Georgian</target>
        </trans-unit>
        <trans-unit id="c559cff938d372579d74b90c80d2874125e4b5d4" translate="yes" xml:space="preserve">
          <source>Georgian Supplement</source>
          <target state="translated">格鲁吉亚语补编</target>
        </trans-unit>
        <trans-unit id="2e85da619ae334aca9d3221727062ef17b60edd9" translate="yes" xml:space="preserve">
          <source>Get Pointer to Thrown Object if type of thrown object is implicitly convertible to the catch type.</source>
          <target state="translated">如果抛出对象的类型可以隐式转换为捕捉类型,则获取抛出对象的指针。</target>
        </trans-unit>
        <trans-unit id="49759c09a6285b1e1c3c2442b86bed6b17c79b57" translate="yes" xml:space="preserve">
          <source>Get RTTI mangling of the given class declaration for C++ ABI.</source>
          <target state="translated">获取C++ABI的给定类声明的RTTI杂乱。</target>
        </trans-unit>
        <trans-unit id="30af4ba10b05a5544d5e9caa6adff1c6bc3df069" translate="yes" xml:space="preserve">
          <source>Get TypeInfo for 'next' type, as defined by what kind of type this is, null if none.</source>
          <target state="translated">获取'next'类型的类型信息,由类型定义,如果没有则为空。</target>
        </trans-unit>
        <trans-unit id="c92e7f5f377e9154bb8151fe8cde1e5454a8ad6b" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of</source>
          <target state="translated">获取AliasSeq的</target>
        </trans-unit>
        <trans-unit id="2697c6709922de4b4eb3a504173797b3b2d2f222" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of the base class and base interfaces of this class or interface. BaseTypeTuple!Object returns the empty type tuple.</source>
          <target state="translated">获取这个类或接口的基类和基接口的AliasSeq。BaseTypeTuple!Object返回空的类型元组。</target>
        </trans-unit>
        <trans-unit id="debff9d835c323dd33cb0eb8c68915f9979c7a6c" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;gt; e according to the less comparator</source>
          <target state="translated">根据less比较器从容器中获得一个范围，其中所有元素都&amp;gt; e</target>
        </trans-unit>
        <trans-unit id="2f427a0e190ea30b9ef773b930557ceb28c95c24" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;lt; e according to the less comparator</source>
          <target state="translated">根据较小的比较器，从容器中获取所有元素&amp;lt;e的范围</target>
        </trans-unit>
        <trans-unit id="1a49fd135d74779940e67901f3680596c3cb7489" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are == e according to the less comparator</source>
          <target state="translated">根据较小的比较器,从容器中获取所有元素==e的范围。</target>
        </trans-unit>
        <trans-unit id="57416603cdc2a4317e5cef5fc1df8438a0dc691d" translate="yes" xml:space="preserve">
          <source>Get a socket option.</source>
          <target state="translated">获得一个插座选项。</target>
        </trans-unit>
        <trans-unit id="ab0526a6b77b2a6ea32e278479a2c15bfc6233f8" translate="yes" xml:space="preserve">
          <source>Get a text description of this socket's error status, and clear the socket's error status.</source>
          <target state="translated">获取该套接字的错误状态的文字描述,并清除该套接字的错误状态。</target>
        </trans-unit>
        <trans-unit id="cb65e9616425e0463e1160c764ce114f293c53ad" translate="yes" xml:space="preserve">
          <source>Get a timeout (duration) option.</source>
          <target state="translated">获取超时(持续时间)选项。</target>
        </trans-unit>
        <trans-unit id="cb1503c554d562fcb4fdd362460ca0e88facc2f1" translate="yes" xml:space="preserve">
          <source>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union returns a tuple with one element &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">以元组的形式获取结构，类或联合的字段的类型。它由占用内存空间的字段组成，不包括诸如虚拟功能表指针或嵌套类型的上下文指针之类的隐藏字段。如果 &lt;code&gt;T&lt;/code&gt; 不是结构，类或联合，则返回带有一个元素 &lt;code&gt;T&lt;/code&gt; 的元组。</target>
        </trans-unit>
        <trans-unit id="8352810d8951fe7d425bf1322ba1521329088590" translate="yes" xml:space="preserve">
          <source>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. Inherited fields (for classes) are not included. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union, an expression tuple with an empty string is returned.</source>
          <target state="translated">获取表达式，结构，类或联合的字段名称作为表达式元组。它由占用内存空间的字段组成，不包括诸如虚拟功能表指针或嵌套类型的上下文指针之类的隐藏字段。不包括继承的字段（用于类）。如果 &lt;code&gt;T&lt;/code&gt; 不是结构，类或联合，则返回带有空字符串的表达式元组。</target>
        </trans-unit>
        <trans-unit id="a198ff5da76a4a9aab19b26589c9b2c10f34f479" translate="yes" xml:space="preserve">
          <source>Get creation/access/modified times of file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">获取文件 &lt;code&gt;name&lt;/code&gt; 创建/访问/修改时间。</target>
        </trans-unit>
        <trans-unit id="d0005ffe3affeeb682da9580156ed97b001d178e" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in XMM register</source>
          <target state="translated">获取类型的标志。1表示GC应该扫描指针,2表示在XMM寄存器中传递该类型的arg。</target>
        </trans-unit>
        <trans-unit id="d67dceb8ecd32907f4c80efef5b62cf3e873c8e4" translate="yes" xml:space="preserve">
          <source>Get index of field. Returns -1 if not found.</source>
          <target state="translated">获取字段的索引。如果没有找到,返回-1。</target>
        </trans-unit>
        <trans-unit id="7cbd98494450e74ae712eba7afdee4e2a97eaec8" translate="yes" xml:space="preserve">
          <source>Get nth Parameter, folding in tuples.</source>
          <target state="translated">获取第n个Parameter,用tuple折叠。</target>
        </trans-unit>
        <trans-unit id="b0d99cd151ddfeaf2b13f0d9a95c891f89fbb223" translate="yes" xml:space="preserve">
          <source>Get offset of base class's vtbl[] initializer from start of csym. Returns ~0 if not this csym.</source>
          <target state="translated">获取基类的vtbl[]初始化器从csym开始的偏移量。如果不是这个csym,返回~0。</target>
        </trans-unit>
        <trans-unit id="a4feb1bf141a1d88be78b9a3366a4467fa93a965" translate="yes" xml:space="preserve">
          <source>Get range that spans all of the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; intervals in this &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取覆盖此&lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; 中&lt;/a&gt;所有&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;间隔的范围。</target>
        </trans-unit>
        <trans-unit id="f03d5bd32538b64243f7cd6441ecfa2b2622dbab" translate="yes" xml:space="preserve">
          <source>Get size of file &lt;code&gt;name&lt;/code&gt; in bytes.</source>
          <target state="translated">获取文件 &lt;code&gt;name&lt;/code&gt; 大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="461490b8f32608cfbfd66725579129263619bc8c" translate="yes" xml:space="preserve">
          <source>Get size of ty</source>
          <target state="translated">获取轮胎的尺寸</target>
        </trans-unit>
        <trans-unit id="be155f80e71c94e749bac3dc7da0073ca4565577" translate="yes" xml:space="preserve">
          <source>Get targetInfo by key</source>
          <target state="translated">按键获取目标信息</target>
        </trans-unit>
        <trans-unit id="73796f5728cf9c28582274f26067b749361695c9" translate="yes" xml:space="preserve">
          <source>Get the Key type of an Associative Array.</source>
          <target state="translated">获取关联数组的Key类型。</target>
        </trans-unit>
        <trans-unit id="d22a099130780c3f0f5de0e5b8d691ed79199316" translate="yes" xml:space="preserve">
          <source>Get the OS specific file attributes for the archive member.</source>
          <target state="translated">获取存档成员的操作系统特定文件属性。</target>
        </trans-unit>
        <trans-unit id="79ecfb6529a74964e1e68cd5ab4d563b90f3da7a" translate="yes" xml:space="preserve">
          <source>Get the Value type of an Associative Array.</source>
          <target state="translated">获取关联数组的值类型。</target>
        </trans-unit>
        <trans-unit id="98635513b7474e13e846f5ff833241b41e74887e" translate="yes" xml:space="preserve">
          <source>Get the access and modified times of file or folder &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">获取文件或文件夹 &lt;code&gt;name&lt;/code&gt; 的访问和修改时间。</target>
        </trans-unit>
        <trans-unit id="5e205b38d81166876ff783947529f334bd179d77" translate="yes" xml:space="preserve">
          <source>Get the cached block info of an interior pointer. Returns null if the interior pointer's block is not cached.</source>
          <target state="translated">获取内部指针的缓存块信息。如果内部指针的块没有被缓存,则返回null。</target>
        </trans-unit>
        <trans-unit id="4282bb82ffa1bb1dd9a0f9f0f2bf4c8c171f011b" translate="yes" xml:space="preserve">
          <source>Get the code unit at index i</source>
          <target state="translated">在索引i处获取代码单位</target>
        </trans-unit>
        <trans-unit id="7c3dd3625eabe5a78ecd2dfc079c83bf66c607d8" translate="yes" xml:space="preserve">
          <source>Get the current thread's instance. Returns by ref. Note that calling &lt;code&gt;get&lt;/code&gt; from any thread outside the &lt;code&gt;TaskPool&lt;/code&gt; that created this instance will return the same reference, so an instance of worker-local storage should only be accessed from one thread outside the pool that created it. If this rule is violated, undefined behavior will result.</source>
          <target state="translated">获取当前线程的实例。按参考返回。请注意，从创建该实例的 &lt;code&gt;TaskPool&lt;/code&gt; 外部的任何线程调用 &lt;code&gt;get&lt;/code&gt; 将返回相同的引用，因此，只能从创建它的池外的一个线程访问工作人员本地存储的实例。如果违反此规则，将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="2fa40eed5d4831ba4894fa0d2f99824123d18451" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">获取当前时间作为&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8dce800f00dab2a31ba905f4b229d5e41f026c6" translate="yes" xml:space="preserve">
          <source>Get the current time from the system clock</source>
          <target state="translated">从系统时钟获取当前时间</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">获取当前工作目录。</target>
        </trans-unit>
        <trans-unit id="b3b0d480375a5d6d1deedae54218ae4809699a35" translate="yes" xml:space="preserve">
          <source>Get the default &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; implementation for the platform</source>
          <target state="translated">获取平台的默认 &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; 实现</target>
        </trans-unit>
        <trans-unit id="1a4ef6fd99cfc2a1e29f50c6d9ba5ed116754be8" translate="yes" xml:space="preserve">
          <source>Get the drive portion of a path.</source>
          <target state="translated">获取路径的驱动部分。</target>
        </trans-unit>
        <trans-unit id="c1d426ae9f2d48f1089e0e4fbe50dd7b4c9abc89" translate="yes" xml:space="preserve">
          <source>Get the first argument &lt;code&gt;a&lt;/code&gt; that passes an &lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; test. If no argument passes the test, return the last argument.</source>
          <target state="translated">获取通过 &lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; 测试的第一个参数 &lt;code&gt;a&lt;/code&gt; 。如果没有参数通过测试，则返回最后一个参数。</target>
        </trans-unit>
        <trans-unit id="71fd3b068f374669047aed8f9838bd5650f74328" translate="yes" xml:space="preserve">
          <source>Get the full package name for the given symbol.</source>
          <target state="translated">获取给定符号的完整包名。</target>
        </trans-unit>
        <trans-unit id="e88db6759fbbcb530d5bab26ba3ec77a124f346e" translate="yes" xml:space="preserve">
          <source>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string converter.</source>
          <target state="translated">获取类型或符号的完全限定名称。可以作为一个智能类型/符号到字符串的转换器。</target>
        </trans-unit>
        <trans-unit id="e02735fcab968c6e59f5f8bdf04603517f7d65eb" translate="yes" xml:space="preserve">
          <source>Get the function type from a callable object &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">从可调用对象 &lt;code&gt;func&lt;/code&gt; 获取函数类型。</target>
        </trans-unit>
        <trans-unit id="0126813350919cfa23ae233f4d4ec97faf37d1f5" translate="yes" xml:space="preserve">
          <source>Get the last modification time for this member.</source>
          <target state="translated">获取该会员的最后修改时间。</target>
        </trans-unit>
        <trans-unit id="2b55b05c55c5a5fab2ff26e964d410c035b4ab1b" translate="yes" xml:space="preserve">
          <source>Get the linger option.</source>
          <target state="translated">获得玲珑选项。</target>
        </trans-unit>
        <trans-unit id="2731449c54e0db2efeec9062c6ec93a54eb72587" translate="yes" xml:space="preserve">
          <source>Get the message describing the error. Base behavior is to return the &lt;code&gt;Throwable.msg&lt;/code&gt; field. Override to return some other error message.</source>
          <target state="translated">获取描述错误的消息。基本行为是返回 &lt;code&gt;Throwable.msg&lt;/code&gt; 字段。重写以返回其他错误消息。</target>
        </trans-unit>
        <trans-unit id="4b21108b2b9de9b6cbf7e566c0a2ddc0c0ca72f0" translate="yes" xml:space="preserve">
          <source>Get the module name (including package) for the given symbol.</source>
          <target state="translated">获取给定符号的模块名称(包括包)。</target>
        </trans-unit>
        <trans-unit id="3288e20d4e0a2e8cea872e1f5d70b8c2b93389f8" translate="yes" xml:space="preserve">
          <source>Get the primitive types of the fields of a struct or class, in topological order.</source>
          <target state="translated">按拓扑顺序获取结构或类的字段的基元类型。</target>
        </trans-unit>
        <trans-unit id="3543b05579b2dbf35e3b0cd1e4b2b942a6076e5c" translate="yes" xml:space="preserve">
          <source>Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.</source>
          <target state="translated">获取文件的大小,如果文件不可搜索,则为ulong.max,但如果实际发生错误,仍会抛出。</target>
        </trans-unit>
        <trans-unit id="79a49f491dcc81c94695a311e67110f25317cf05" translate="yes" xml:space="preserve">
          <source>Get the socket's address family.</source>
          <target state="translated">获取插座的地址族。</target>
        </trans-unit>
        <trans-unit id="4e5a697008886f18598415a18e551017ef50a8a2" translate="yes" xml:space="preserve">
          <source>Get the the default initialization expression for a type.</source>
          <target state="translated">获取类型的默认初始化表达式。</target>
        </trans-unit>
        <trans-unit id="ebb8fbb5373a6b9ecc71521fb5c82104b76b2dda" translate="yes" xml:space="preserve">
          <source>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an &lt;code&gt;opCall&lt;/code&gt;. Please note that ref is not part of a type, but the attribute of the function (see template &lt;a href=&quot;#functionAttributes&quot;&gt;&lt;code&gt;functionAttributes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">得到的返回值，从函数类型，函数指针，委托，与的opCall，指向与一个的opCall，或与一类的结构体的结构体 &lt;code&gt;opCall&lt;/code&gt; 。请注意，ref不是类型的一部分，而是函数的属性（请参见template &lt;a href=&quot;#functionAttributes&quot;&gt; &lt;code&gt;functionAttributes&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2f15e792b4182f5761446203a960686f6a1fd8cb" translate="yes" xml:space="preserve">
          <source>Get the type that a scalar type &lt;code&gt;T&lt;/code&gt; will &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;promote&lt;/a&gt; to in multi-term arithmetic expressions.</source>
          <target state="translated">获取标量类型 &lt;code&gt;T&lt;/code&gt; 在多项算术表达式中将&lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;提升&lt;/a&gt;为的类型。</target>
        </trans-unit>
        <trans-unit id="d86851901246015e180e22d937a94cdd4a67d0cf" translate="yes" xml:space="preserve">
          <source>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns void if passed an empty list, or if the types have no common type.</source>
          <target state="translated">获取所有类型可以隐式转换的类型。例如,在从一堆初始化值中找出一个数组类型时很有用。如果传递了一个空列表,或者如果类型没有共同的类型,返回void。</target>
        </trans-unit>
        <trans-unit id="d8834c0e5c45f02dee115c0af5916029dd3645eb" translate="yes" xml:space="preserve">
          <source>Get the type that will really be used for passing the given argument to an &lt;code&gt;extern(C++)&lt;/code&gt; function.</source>
          <target state="translated">获取将用于将给定参数传递给 &lt;code&gt;extern(C++)&lt;/code&gt; 函数的类型。</target>
        </trans-unit>
        <trans-unit id="1a8db062181587e0a37ac18deba2e6a2d99a21b8" translate="yes" xml:space="preserve">
          <source>Get the underlying path.</source>
          <target state="translated">获取底层路径。</target>
        </trans-unit>
        <trans-unit id="8aa89601daef2aac5d5712f9ccfde65d17aeb883" translate="yes" xml:space="preserve">
          <source>Get the underlying type which a &lt;code&gt;Typedef&lt;/code&gt; wraps. If &lt;code&gt;T&lt;/code&gt; is not a &lt;code&gt;Typedef&lt;/code&gt; it will alias itself to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;Typedef&lt;/code&gt; 包装的基础类型。如果 &lt;code&gt;T&lt;/code&gt; 不是 &lt;code&gt;Typedef&lt;/code&gt; ，会自我别名，从而 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc66c2f8e24da37f6181d5e17247039b03831383" translate="yes" xml:space="preserve">
          <source>Get the value of the .max/.min property as an Expression. Lazily computes the value and caches it in maxval/minval. Reports any errors.</source>
          <target state="translated">以Expression的形式获取.max/.min属性的值。懒惰地计算该值并将其缓存在maxval/minval中。报告任何错误。</target>
        </trans-unit>
        <trans-unit id="bb25c1e8984031c906b57204ab00dc5ad735d012" translate="yes" xml:space="preserve">
          <source>Get the various timings like name lookup time, total time, connect time etc. The timed category is passed through the timing parameter while the timing value is stored at val. The value is usable only if res is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">获取各种计时，例如名称查找时间，总时间，连接时间等。计时类别通过计时参数传递，而计时值存储在val中。仅当res等于 &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; 时,该值才可用。</target>
        </trans-unit>
        <trans-unit id="912a474bb0a0204ed6b0e20848237a640087bf6c" translate="yes" xml:space="preserve">
          <source>Get tuple, one per function parameter, of the storage classes of the parameters.</source>
          <target state="translated">获取参数的存储类元组,每个函数参数一个。</target>
        </trans-unit>
        <trans-unit id="36c705a4549f55994270c31cf59dc15c22af56b1" translate="yes" xml:space="preserve">
          <source>Get type information on the contents of the type; null if not available</source>
          <target state="translated">获取类型内容的类型信息;如果没有,则为空。</target>
        </trans-unit>
        <trans-unit id="96f72b00f8ed83794b8d1d1ca2272471a19aedec" translate="yes" xml:space="preserve">
          <source>Get underlying socket handle.</source>
          <target state="translated">获取底层套接字句柄。</target>
        </trans-unit>
        <trans-unit id="48ec336cb3c23da76d213eaa7aef8a04ca5f0b14" translate="yes" xml:space="preserve">
          <source>Get various timings defined in &lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt;&lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt;&lt;/a&gt;. The value is usable only if the return value is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">获取&lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt; &lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt; 中&lt;/a&gt;定义的各种计时。仅当返回值等于 &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; 时,该值才可用。</target>
        </trans-unit>
        <trans-unit id="bb969faa69556a50edb8b7474adfcb5288a0eabc" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the default value of the parameters to a function symbol. If a parameter doesn't have the default value, &lt;code&gt;void&lt;/code&gt; is returned instead.</source>
          <target state="translated">以元组的形式将参数的默认值获取为功能符号。如果参数没有默认值，则返回 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e5eb1b88f56e22db495838fb23d06aff7902858" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the identifiers of the parameters to a function symbol.</source>
          <target state="translated">以元组的形式获取一个函数符号的参数标识符。</target>
        </trans-unit>
        <trans-unit id="0d9be8cea698e918f8f5553c38491cc55f980684" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an &lt;code&gt;opCall&lt;/code&gt;, a pointer to a struct with an &lt;code&gt;opCall&lt;/code&gt;, or a class with an &lt;code&gt;opCall&lt;/code&gt;.</source>
          <target state="translated">得到的，作为一个元组，该类型的参数的一个函数，函数指针，委托，与一个结构 &lt;code&gt;opCall&lt;/code&gt; ，一个指向与一个结构 &lt;code&gt;opCall&lt;/code&gt; ，或与一类 &lt;code&gt;opCall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a2a322d7843413da4411904750627b588381236" translate="yes" xml:space="preserve">
          <source>Get/set number of elements in the array. It is of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">获取/设置数组中元素的数量。类型为 &lt;code&gt;size_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e903dced1589591dccd55f4a2a573704d37b25f7" translate="yes" xml:space="preserve">
          <source>Get/set socket's blocking flag.</source>
          <target state="translated">获取/设置socket的阻塞标志。</target>
        </trans-unit>
        <trans-unit id="8143cfad11bbcb508b2faa890c629adbe90a1326" translate="yes" xml:space="preserve">
          <source>GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt;(T...)(ref string[] args, T opts);</source>
          <target state="translated">GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt;（T ...）（ref string [] args，T opts）;</target>
        </trans-unit>
        <trans-unit id="3639898092fae686744daf985b5a5af78426e672" translate="yes" xml:space="preserve">
          <source>Gets a &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; at the given index in this cluster.</source>
          <target state="translated">获取此群集中给定索引的&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b7dd24ad864c772981b0d66dc0022feced1b999" translate="yes" xml:space="preserve">
          <source>Gets a larger buffer &lt;code&gt;buf&lt;/code&gt; by calling &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt;. If &lt;code&gt;buf&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, returns &lt;code&gt;null&lt;/code&gt;. Otherwise, returns &lt;code&gt;buf[0 .. n]&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt; 获得更大的缓冲区 &lt;code&gt;buf&lt;/code&gt; 。如果 &lt;code&gt;buf&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则返回 &lt;code&gt;null&lt;/code&gt; 。否则，返回 &lt;code&gt;buf[0 .. n]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2c0f14712193b76cf9f29f4a2238a646ef9482c" translate="yes" xml:space="preserve">
          <source>Gets a range of key/values for &lt;code&gt;aa&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;aa&lt;/code&gt; 的键/值范围。</target>
        </trans-unit>
        <trans-unit id="0f00eae4c2ff9337f7291213da97c9dc6aebf8d8" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo, which should be used as the default instance when info is requested for a thread not created by the Scheduler.</source>
          <target state="translated">获取线程本地的ThreadInfo实例,当信息被请求给一个没有被Scheduler创建的线程时,它应该作为默认实例使用。</target>
        </trans-unit>
        <trans-unit id="f6f18bccfb576e34d7b5fa60615448449996ea12" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo.</source>
          <target state="translated">获取线程本地的ThreadInfo实例。</target>
        </trans-unit>
        <trans-unit id="b472fcab365d2a6ba9fdba822432b62db948d127" translate="yes" xml:space="preserve">
          <source>Gets an object representing the reader lock for the associated mutex.</source>
          <target state="translated">获取代表相关mutex的读取器锁的对象。</target>
        </trans-unit>
        <trans-unit id="2bad6a1697863b959c51608194a08c6aaf894ca4" translate="yes" xml:space="preserve">
          <source>Gets an object representing the writer lock for the associated mutex.</source>
          <target state="translated">获取代表相关mutex的写入锁的对象。</target>
        </trans-unit>
        <trans-unit id="c2134c8e8821e26937fe2aedd4aa0e2891a164f8" translate="yes" xml:space="preserve">
          <source>Gets called on program shutdown just after GC is terminated.</source>
          <target state="translated">在GC终止后程序关闭时被调用。</target>
        </trans-unit>
        <trans-unit id="3863a33d5ec162d09008cccc833b8dbca9f1864e" translate="yes" xml:space="preserve">
          <source>Gets called on program startup just before GC is initialized.</source>
          <target state="translated">在GC被初始化之前,在程序启动时被调用。</target>
        </trans-unit>
        <trans-unit id="fdc75e27ba04f67b552a395ef0dbfb72c8501519" translate="yes" xml:space="preserve">
          <source>Gets expression at offset of type. Returns NULL if not found.</source>
          <target state="translated">在类型的偏移处获取表达式。如果没有找到,返回NULL。</target>
        </trans-unit>
        <trans-unit id="cc94d4edefc014f546538ff3e9cb05bec4999447" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;i&lt;/code&gt;'th bit in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;BitArray&lt;/code&gt; 中的第 &lt;code&gt;i&lt;/code&gt; 位。</target>
        </trans-unit>
        <trans-unit id="8011563ddbd748ff521930918dc8bcb499b269a2" translate="yes" xml:space="preserve">
          <source>Gets the OS identifier for this thread.</source>
          <target state="translated">获取本线程的操作系统标识符。</target>
        </trans-unit>
        <trans-unit id="685489f583759f962fe7c1daab0034a07cb9d516" translate="yes" xml:space="preserve">
          <source>Gets the Tid associated with name.</source>
          <target state="translated">获取与名称相关联的Tid。</target>
        </trans-unit>
        <trans-unit id="5c6e15b07949cc6ff89428732b9e3b99b89bcdc8" translate="yes" xml:space="preserve">
          <source>Gets the current collect handler.</source>
          <target state="translated">获取当前的收集处理程序。</target>
        </trans-unit>
        <trans-unit id="4ee9c2ec9df011130e3394bc652f9b3e7978ed43" translate="yes" xml:space="preserve">
          <source>Gets the current legacy module unit tester.</source>
          <target state="translated">获取当前的传统模块单元测试器。</target>
        </trans-unit>
        <trans-unit id="b9fd850a635cce1ec806814a7cb5c442887ef8c8" translate="yes" xml:space="preserve">
          <source>Gets the current module unit tester.</source>
          <target state="translated">获取当前模块单元测试器。</target>
        </trans-unit>
        <trans-unit id="e72b94a5c6c1c6b67ed9a2ba11a48dec6fb51fea" translate="yes" xml:space="preserve">
          <source>Gets the current state of this fiber.</source>
          <target state="translated">获取该光纤的当前状态。</target>
        </trans-unit>
        <trans-unit id="86b54a37d38df76c69490341ad477a651e752312" translate="yes" xml:space="preserve">
          <source>Gets the current trace handler.</source>
          <target state="translated">获取当前的跟踪处理程序。</target>
        </trans-unit>
        <trans-unit id="48b50302326e46ace0f0f71974024ade98c4d812" translate="yes" xml:space="preserve">
          <source>Gets the daemon status for this thread. While the runtime will wait for all normal threads to complete before tearing down the process, daemon threads are effectively ignored and thus will not prevent the process from terminating. In effect, daemon threads will be terminated automatically by the OS when the process exits.</source>
          <target state="translated">获取该线程的守护进程状态。虽然运行时将等待所有正常线程完成后再关闭进程,但守护进程线程实际上是被忽略的,因此不会阻止进程的终止。实际上,当进程退出时,守护进程线程将被操作系统自动终止。</target>
        </trans-unit>
        <trans-unit id="6388b81675e677f57fc44bb674c4998dc61bbf09" translate="yes" xml:space="preserve">
          <source>Gets the index of the current thread relative to this &lt;code&gt;TaskPool&lt;/code&gt;. Any thread not in this pool will receive an index of 0. The worker threads in this pool receive unique indices of 1 through &lt;code&gt;this.size&lt;/code&gt;.</source>
          <target state="translated">获取相对于此 &lt;code&gt;TaskPool&lt;/code&gt; 的当前线程的索引。此池中没有的任何线程都将收到索引0。此池中的工作线程通过 &lt;code&gt;this.size&lt;/code&gt; 接收到唯一索引1 。</target>
        </trans-unit>
        <trans-unit id="397d4288bd9f56373ed42093b36baf0cf34c80d4" translate="yes" xml:space="preserve">
          <source>Gets the matching &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;user-defined attributes&lt;/a&gt; from the given symbol.</source>
          <target state="translated">从给定的符号获取匹配的&lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;用户定义属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff4bb9618e0f172c3deb93f3fe4c73732cb67c80" translate="yes" xml:space="preserve">
          <source>Gets the mutex associated with this condition.</source>
          <target state="translated">获取与此条件相关的mutex。</target>
        </trans-unit>
        <trans-unit id="b1cafc8d1ad4c93a1519578fd6ef07cfbae8c0d4" translate="yes" xml:space="preserve">
          <source>Gets the nth number in the underlying representation that makes up the whole &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">获取组成整个 &lt;code&gt;BigInt&lt;/code&gt; 的基础表示形式中的第n个数字。</target>
        </trans-unit>
        <trans-unit id="801e40683c25723cacc6326aca38101be95c4627" translate="yes" xml:space="preserve">
          <source>Gets the policy used by this mutex.</source>
          <target state="translated">获取该mutex使用的策略。</target>
        </trans-unit>
        <trans-unit id="8aba27c226485427875db239e8c2e09071484ea6" translate="yes" xml:space="preserve">
          <source>Gets the scheduling priority for the associated thread.</source>
          <target state="translated">获取关联线程的调度优先级。</target>
        </trans-unit>
        <trans-unit id="cf58bd5c03eda3fe4cc7594124c4b61e9c109dc9" translate="yes" xml:space="preserve">
          <source>Gets the type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">获取与 &lt;code&gt;t&lt;/code&gt; 关联的 &lt;code&gt;TypeInfo&lt;/code&gt; 对象的类型</target>
        </trans-unit>
        <trans-unit id="9211b2fb8e24a472f1780790cfdc50455081852e" translate="yes" xml:space="preserve">
          <source>Gets the user-readable label for this thread.</source>
          <target state="translated">获取本主题的用户可读标签。</target>
        </trans-unit>
        <trans-unit id="611d2080794dfc9ee82363d9d9da4aa9a138b19f" translate="yes" xml:space="preserve">
          <source>Gets the value if not null. If &lt;code&gt;this&lt;/code&gt; is in the null state, and the optional parameter &lt;code&gt;fallback&lt;/code&gt; was provided, it will be returned. Without &lt;code&gt;fallback&lt;/code&gt;, calling &lt;code&gt;get&lt;/code&gt; with a null state is invalid.</source>
          <target state="translated">获取值（如果不为null）。如果 &lt;code&gt;this&lt;/code&gt; 处于null状态，并且提供了可选参数 &lt;code&gt;fallback&lt;/code&gt; ，则将返回它。没有 &lt;code&gt;fallback&lt;/code&gt; ，以空状态调用 &lt;code&gt;get&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="7ce43e8e9e8874c455bc1d408b4db63789ae5ade" translate="yes" xml:space="preserve">
          <source>Gets the value. &lt;code&gt;this&lt;/code&gt; must not be in the null state. This function is also called for the implicit conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">获取值。 &lt;code&gt;this&lt;/code&gt; 一定不能为空状态。此功能也呼吁隐式转换 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27ec2c5053941a53ff7bc20b3630c9aa87b310af" translate="yes" xml:space="preserve">
          <source>Gets vendor-specific type mangling for C++ ABI.</source>
          <target state="translated">获取C++ABI的特定供应商类型杂乱。</target>
        </trans-unit>
        <trans-unit id="7e2612461374b070bc3713b89e3df4f4c33fbf6f" translate="yes" xml:space="preserve">
          <source>Gets/sets assert hander. null means the default handler is used.</source>
          <target state="translated">获取/设置断言处理程序,null表示使用默认处理程序。</target>
        </trans-unit>
        <trans-unit id="8a46199cc00d346a1fe72a372a1bcb52b3b1947f" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current process. This allocator must be used for allocating memory shared across threads. Objects created using this allocator can be cast to &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="translated">获取/设置当前进程的分配器。该分配器必须用于分配线程间共享的内存。使用此分配器创建的对象可以强制转换为 &lt;code&gt;shared&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f3fc74fb3ec91a1abfd15e2f2178014ba02b91" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current thread. This is the default allocator that should be used for allocating thread-local memory. For allocating memory to be shared across threads, use &lt;code&gt;processAllocator&lt;/code&gt; (below). By default, &lt;code&gt;theAllocator&lt;/code&gt; ultimately fetches memory from &lt;code&gt;processAllocator&lt;/code&gt;, which in turn uses the garbage collected heap.</source>
          <target state="translated">获取/设置当前线程的分配器。这是应用于分配线程本地内存的默认分配器。要分配要在线程之间共享的内存，请使用 &lt;code&gt;processAllocator&lt;/code&gt; （如下）。默认情况下， &lt;code&gt;theAllocator&lt;/code&gt; 最终从 &lt;code&gt;processAllocator&lt;/code&gt; 获取内存，该内存又使用了垃圾回收堆。</target>
        </trans-unit>
        <trans-unit id="ce0e5e384b0423d01fbe02461b7f604937af05a9" translate="yes" xml:space="preserve">
          <source>Getting a range of all the named captures in the regex.</source>
          <target state="translated">在regex中获取所有命名的捕获范围。</target>
        </trans-unit>
        <trans-unit id="3239f451b140324af46d3a3db896ec8a5a618fbd" translate="yes" xml:space="preserve">
          <source>Getting the benefits of multiple adaptable freelists that do not need to be tuned for one specific size but insted automatically adapts itself to frequently used sizes.</source>
          <target state="translated">获得多个适应性自由列表的好处,不需要为一个特定的尺寸进行调整,而是insted自动适应经常使用的尺寸。</target>
        </trans-unit>
        <trans-unit id="c7ae27f036579182bace286ba1e0cf636e5ff36f" translate="yes" xml:space="preserve">
          <source>Getting the priority of a thread that already terminated might return the default priority.</source>
          <target state="translated">获取一个已经终止的线程的优先级,可能会返回默认的优先级。</target>
        </trans-unit>
        <trans-unit id="d5546b9dfb555ac771be9469163d9af49686adbe" translate="yes" xml:space="preserve">
          <source>Give error if we're not an lvalue. If we can, convert expression to be an lvalue.</source>
          <target state="translated">如果我们不是一个l值,就给出错误。如果可以,将表达式转换为l值。</target>
        </trans-unit>
        <trans-unit id="74474e23aa26985e7a98ca671962a908920e33b2" translate="yes" xml:space="preserve">
          <source>Give up.</source>
          <target state="translated">放弃吧</target>
        </trans-unit>
        <trans-unit id="6839d82e03f5268d9a7cc97802db76c48c8cce6e" translate="yes" xml:space="preserve">
          <source>Given</source>
          <target state="translated">Given</target>
        </trans-unit>
        <trans-unit id="545c45c89bb40c5d7b7b442770eb2c94a5c06899" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a == b&lt;/code&gt; :</source>
          <target state="translated">给定 &lt;code&gt;a == b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="53726705da0088ae9fbab83c8c50c091febc70d1" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;flags&lt;/code&gt; as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values, or a type &lt;code&gt;T&lt;/code&gt;, returns the allocator that's a closest fit in capabilities.</source>
          <target state="translated">给定 &lt;code&gt;flags&lt;/code&gt; 作为 &lt;code&gt;AllocFlag&lt;/code&gt; 值的组合或类型 &lt;code&gt;T&lt;/code&gt; ，返回与功能最接近的分配器。</target>
        </trans-unit>
        <trans-unit id="62b1bd97df8e740424d65deb5d1e60e2802ffce0" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;index&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt; and assuming that &lt;code&gt;index&lt;/code&gt; is at the start of a UTF sequence, &lt;code&gt;toUCSindex&lt;/code&gt; determines the number of UCS characters up to &lt;code&gt;index&lt;/code&gt;. So, &lt;code&gt;index&lt;/code&gt; is the index of a code unit at the beginning of a code point, and the return value is how many code points into the string that that code point is.</source>
          <target state="translated">给定 &lt;code&gt;index&lt;/code&gt; 到 &lt;code&gt;str&lt;/code&gt; 并假设 &lt;code&gt;index&lt;/code&gt; 处于UTF序列的开始， &lt;code&gt;toUCSindex&lt;/code&gt; 确定UCS字符的数目最多 &lt;code&gt;index&lt;/code&gt; 。因此， &lt;code&gt;index&lt;/code&gt; 是代码单元在代码点开始处的索引，返回值是该代码点所在的字符串中有多少代码点。</target>
        </trans-unit>
        <trans-unit id="bb7cf3072f3bd953aeae94de343ed5c6b8a94867" translate="yes" xml:space="preserve">
          <source>Given D code like:</source>
          <target state="translated">给定D代码如:</target>
        </trans-unit>
        <trans-unit id="d736ecdf41cd9fce2597d330cc34519b6b941a39" translate="yes" xml:space="preserve">
          <source>Given EBP, find return address to caller, and caller's EBP.</source>
          <target state="translated">给定EBP,找到呼叫者的返回地址,以及呼叫者的EBP。</target>
        </trans-unit>
        <trans-unit id="eb6400b34d9067d59b3f43922d46e893c8d36002" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;source&lt;/code&gt; range that is expensive to iterate over, returns an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that asynchronously buffers the contents of &lt;code&gt;source&lt;/code&gt; into a buffer of &lt;code&gt;bufSize&lt;/code&gt; elements in a worker thread, while making previously buffered elements from a second buffer, also of size &lt;code&gt;bufSize&lt;/code&gt;, available via the range interface of the returned object. The returned range has a length iff &lt;code&gt;hasLength!S&lt;/code&gt;. &lt;code&gt;asyncBuf&lt;/code&gt; is useful, for example, when performing expensive operations on the elements of ranges that represent data on a disk or network.</source>
          <target state="translated">给定要迭代的 &lt;code&gt;source&lt;/code&gt; 范围，返回一个&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;，该范围将 &lt;code&gt;source&lt;/code&gt; 的内容异步缓冲到工作线程中的 &lt;code&gt;bufSize&lt;/code&gt; 元素的缓冲区中，同时通过第二个缓冲区（大小也为 &lt;code&gt;bufSize&lt;/code&gt; )使先前缓冲的元素可通过返回对象的范围接口。返回范围的长度为iff &lt;code&gt;hasLength!S&lt;/code&gt; 。例如，当对表示磁盘或网络上数据的范围的元素执行昂贵的操作时， &lt;code&gt;asyncBuf&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="699c74248abd14b4250ad690ede845e5aad24631" translate="yes" xml:space="preserve">
          <source>Given a Base64 encoded string, calculates the length of the decoded string.</source>
          <target state="translated">给定一个Base64编码的字符串,计算解码后的字符串长度。</target>
        </trans-unit>
        <trans-unit id="bc7d61e132762100a6e8861609dacf0581eebca4" translate="yes" xml:space="preserve">
          <source>Given a C++ function in a C++ source file:</source>
          <target state="translated">在C++源文件中给定一个C++函数。</target>
        </trans-unit>
        <trans-unit id="7de884353daa1d02f969775316b89c9805864eba" translate="yes" xml:space="preserve">
          <source>Given a UCS index &lt;code&gt;n&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt;, returns the UTF index. So, &lt;code&gt;n&lt;/code&gt; is how many code points into the string the code point is, and the array index of the code unit is returned.</source>
          <target state="translated">给定一个UCS指数 &lt;code&gt;n&lt;/code&gt; 进入 &lt;code&gt;str&lt;/code&gt; ，返回UTF指数。因此， &lt;code&gt;n&lt;/code&gt; 是代码点在字符串中有多少代码点，并返回代码单元的数组索引。</target>
        </trans-unit>
        <trans-unit id="3aa76f9d8ead49fe4c4634dcc93f9d715d5abf9c" translate="yes" xml:space="preserve">
          <source>Given a and p, the function finds x such that</source>
          <target state="translated">给定a和p,函数找到x,使得</target>
        </trans-unit>
        <trans-unit id="97696594fbe0457c99be87ef93b37c947e4a5703" translate="yes" xml:space="preserve">
          <source>Given a callable object &lt;code&gt;next&lt;/code&gt; that writes to a user-provided buffer and a second callable object &lt;code&gt;empty&lt;/code&gt; that determines whether more data is available to write via &lt;code&gt;next&lt;/code&gt;, returns an input range that asynchronously calls &lt;code&gt;next&lt;/code&gt; with a set of size &lt;code&gt;nBuffers&lt;/code&gt; of buffers and makes the results available in the order they were obtained via the input range interface of the returned object. Similarly to the input range overload of &lt;code&gt;asyncBuf&lt;/code&gt;, the first half of the buffers are made available via the range interface while the second half are filled and vice-versa.</source>
          <target state="translated">给定一个可调用对象 &lt;code&gt;next&lt;/code&gt; 一个写入用户提供的缓冲液和第二可调用对象 &lt;code&gt;empty&lt;/code&gt; ，其确定是否有更多的数据是通过提供给写入 &lt;code&gt;next&lt;/code&gt; ，返回一个输入范围异步调用 &lt;code&gt;next&lt;/code&gt; 与一组尺寸的 &lt;code&gt;nBuffers&lt;/code&gt; 缓冲器，并且使结果可以通过返回对象的输入范围接口获得的顺序获得。类似于 &lt;code&gt;asyncBuf&lt;/code&gt; 的输入范围过载，缓冲区的前半部分通过range接口提供，而后半部分则被填充，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f4bc9912c00cf7ade5e6f59f3c7bafa79a0098bb" translate="yes" xml:space="preserve">
          <source>Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;[a .. b]&lt;/code&gt; such that &lt;code&gt;f(a)&lt;/code&gt; and &lt;code&gt;f(b)&lt;/code&gt; have opposite signs or at least one of them equals &amp;plusmn;0, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a root of &lt;code&gt;f(x)&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one root in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN, NaN will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">给定一个函数 &lt;code&gt;f&lt;/code&gt; 和一个范围 &lt;code&gt;[a .. b]&lt;/code&gt; ，使得 &lt;code&gt;f(a)&lt;/code&gt; 和 &lt;code&gt;f(b)&lt;/code&gt; 具有相反的符号或至少其中一个等于&amp;plusmn;0，则返回最接近a的范围内的 &lt;code&gt;x&lt;/code&gt; 值 &lt;code&gt;f(x)&lt;/code&gt; 的根。如果 &lt;code&gt;f(x)&lt;/code&gt; 在该范围内具有多个根，则将任意选择一个。如果 &lt;code&gt;f(x)&lt;/code&gt; 返回NaN，则将返回NaN；否则，将返回NaN。否则，保证该算法成功。</target>
        </trans-unit>
        <trans-unit id="b3d905355b0b0e68c40d2c94bafa678611e3caae" translate="yes" xml:space="preserve">
          <source>Given a new instance tithis of this TemplateDeclaration, see if there already exists an instance. If so, return that existing instance.</source>
          <target state="translated">给定这个TemplateDeclaration的一个新实例tithis,查看是否已经存在一个实例。如果存在,则返回该现有实例。</target>
        </trans-unit>
        <trans-unit id="7902cf88ea3243b9d5f9eb153e89c6c4585563c1" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as &lt;code&gt;T&lt;/code&gt;), constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to null.</source>
          <target state="translated">给定一个指向未初始化内存的指针 &lt;code&gt;chunk&lt;/code&gt; （但已将其键入为 &lt;code&gt;T&lt;/code&gt; ），则在该地址处构造一个非 &lt;code&gt;class&lt;/code&gt; 类型 &lt;code&gt;T&lt;/code&gt; 的对象。如果 &lt;code&gt;T&lt;/code&gt; 是一个类，则将该类引用初始化为null。</target>
        </trans-unit>
        <trans-unit id="abaa134bbbf8060e8ac6344879f8e8d611739ebe" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;.</source>
          <target state="translated">给定一个指向未初始化内存的指针 &lt;code&gt;chunk&lt;/code&gt; （但已将其键入为非类类型 &lt;code&gt;T&lt;/code&gt; ），则从实 &lt;code&gt;args&lt;/code&gt; 在该地址处构造一个 &lt;code&gt;T&lt;/code&gt; 类型的对象。如果 &lt;code&gt;T&lt;/code&gt; 是一个类，则将该类引用初始化为 &lt;code&gt;args[0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58557c048614c0f1ce20fdb67b5db3ba6bf2d1b4" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;. This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">给定一个指向未初始化内存的指针 &lt;code&gt;chunk&lt;/code&gt; （但已将其键入为非类类型 &lt;code&gt;T&lt;/code&gt; ），则从实 &lt;code&gt;args&lt;/code&gt; 在该地址处构造一个 &lt;code&gt;T&lt;/code&gt; 类型的对象。如果 &lt;code&gt;T&lt;/code&gt; 是一个类，则将该类引用初始化为 &lt;code&gt;args[0]&lt;/code&gt; 。这个功能可以 &lt;code&gt;@trusted&lt;/code&gt; 如果相应构造 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;@safe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18ffdf892cf328d6d063a845b68a6520844d64c2" translate="yes" xml:space="preserve">
          <source>Given a pointer: If it is an Object, return that Object. If it is an interface, return the Object implementing the interface. If it is null, return null. Else, undefined crash</source>
          <target state="translated">给定一个指针。如果是一个对象,返回该对象。如果是一个接口,返回实现该接口的对象。如果是null,返回null。否则,未定义崩溃</target>
        </trans-unit>
        <trans-unit id="a2a17bffc5b9d113dc0183d4777b121f1563c333" translate="yes" xml:space="preserve">
          <source>Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point.</source>
          <target state="translated">给定一个随机访问范围和一个起点,创建一个交替返回下一个左元素和下一个右元素到起点的范围。</target>
        </trans-unit>
        <trans-unit id="cf77f4783176c69f24bf5139063bed48dbcdbc05" translate="yes" xml:space="preserve">
          <source>Given a range of elements, constructs an index of its top</source>
          <target state="translated">给定一个元素范围,构造其顶部的索引。</target>
        </trans-unit>
        <trans-unit id="f82f27390a9cc6295ef9d3e2c499d003645adbcb" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the &lt;code&gt;n&lt;/code&gt;th element of each of the enclosed ranges. This function is similar to &lt;code&gt;unzip&lt;/code&gt; in other languages.</source>
          <target state="translated">给定一个范围范围，横向遍历每个封闭范围的第 &lt;code&gt;n&lt;/code&gt; 个元素。此功能类似于其他语言的 &lt;code&gt;unzip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99d831c39b761ba6173d077a392b684dab424593" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</source>
          <target state="translated">给定一个范围,横向迭代每个封闭范围的第一个元素。</target>
        </trans-unit>
        <trans-unit id="76deeb26e0b9b94a659a1c8d77489812eb190823" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, returns a range of ranges where the</source>
          <target state="translated">给定一个范围,返回一个范围,其中的</target>
        </trans-unit>
        <trans-unit id="23b1b22050fe1a6a85e37baec0da8ef5a908711a" translate="yes" xml:space="preserve">
          <source>Given a range of sorted &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward ranges&lt;/a&gt;&lt;code&gt;ror&lt;/code&gt;, copies to &lt;code&gt;tgt&lt;/code&gt; the elements that are common to most ranges, along with their number of occurrences. All ranges in &lt;code&gt;ror&lt;/code&gt; are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Only the most frequent &lt;code&gt;tgt.length&lt;/code&gt; elements are returned.</source>
          <target state="translated">给定一定范围的&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围&lt;/a&gt; &lt;code&gt;ror&lt;/code&gt; ，将大多数范围共有的元素及其出现次数复制到 &lt;code&gt;tgt&lt;/code&gt; 。假定 &lt;code&gt;ror&lt;/code&gt; 中的所有范围都按 &lt;code&gt;less&lt;/code&gt; 排序。仅返回最常用的 &lt;code&gt;tgt.length&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="6cadfddfad656a52536264d1af9f3900d194ed5c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">给定一个原始内存区域 &lt;code&gt;chunk&lt;/code&gt; （但已经输入为类类型 &lt;code&gt;T&lt;/code&gt; ），则在该地址处构造一个 &lt;code&gt;class&lt;/code&gt; 类型 &lt;code&gt;T&lt;/code&gt; 的对象。构造函数将传递参数 &lt;code&gt;Args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adbee075f1252282f1c423c0af02edd4265ab66b" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">给定一个原始内存区域 &lt;code&gt;chunk&lt;/code&gt; （但已经输入为类类型 &lt;code&gt;T&lt;/code&gt; ），则在该地址处构造一个 &lt;code&gt;class&lt;/code&gt; 类型 &lt;code&gt;T&lt;/code&gt; 的对象。构造函数将传递参数 &lt;code&gt;Args&lt;/code&gt; 。如果 &lt;code&gt;T&lt;/code&gt; 是一个内部类，其 &lt;code&gt;outer&lt;/code&gt; 字段可用于访问该封闭类的实例，则 &lt;code&gt;Args&lt;/code&gt; 不能为空，并且它的第一个成员必须是该 &lt;code&gt;outer&lt;/code&gt; 字段的有效初始化器。正确初始化此字段对于访问 &lt;code&gt;T&lt;/code&gt; 方法中外部类的成员至关重要。</target>
        </trans-unit>
        <trans-unit id="0653a1ab81721bb4c49575b0fcabecb4d629612a" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">给定一个原始内存区域 &lt;code&gt;chunk&lt;/code&gt; ，构建的目的 &lt;code&gt;class&lt;/code&gt; 型 &lt;code&gt;T&lt;/code&gt; 在该地址。构造函数将传递参数 &lt;code&gt;Args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74cf19c0277fb6a57dd8ab3cb630a33bfe4fee0c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">给定一个原始内存区域 &lt;code&gt;chunk&lt;/code&gt; ，构建的目的 &lt;code&gt;class&lt;/code&gt; 型 &lt;code&gt;T&lt;/code&gt; 在该地址。构造函数将传递参数 &lt;code&gt;Args&lt;/code&gt; 。如果 &lt;code&gt;T&lt;/code&gt; 是一个内部类，其 &lt;code&gt;outer&lt;/code&gt; 字段可用于访问该封闭类的实例，则 &lt;code&gt;Args&lt;/code&gt; 不能为空，并且它的第一个成员必须是该 &lt;code&gt;outer&lt;/code&gt; 字段的有效初始化器。正确初始化此字段对于访问 &lt;code&gt;T&lt;/code&gt; 方法中外部类的成员至关重要。</target>
        </trans-unit>
        <trans-unit id="e137ad6b52d9b560e6ecf089479316e86462ce01" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;args&lt;/code&gt;, if any.</source>
          <target state="translated">给定一个原始存储 &lt;code&gt;chunk&lt;/code&gt; ，在该地址处构造一个非 &lt;code&gt;class&lt;/code&gt; 类型 &lt;code&gt;T&lt;/code&gt; 的对象。向构造函数传递参数 &lt;code&gt;args&lt;/code&gt; （如果有）。</target>
        </trans-unit>
        <trans-unit id="f8745e4f392d96921746aba6d016d8b75a3eaf5b" translate="yes" xml:space="preserve">
          <source>Given a symbol that could be either a FuncDeclaration or a function template, resolve it to a function symbol.</source>
          <target state="translated">给定一个可以是FuncDeclaration或函数模板的符号,将其解析为函数符号。</target>
        </trans-unit>
        <trans-unit id="3ec7e3b2070dd15d8c86e7da24a716e09d94b001" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;S&lt;/code&gt; that is one of:</source>
          <target state="translated">给定类型 &lt;code&gt;S&lt;/code&gt; 为以下之一：</target>
        </trans-unit>
        <trans-unit id="5bf486ff307c1ac9da00abda18e996a0151d6f51" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, returns its allocation-related flags as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values.</source>
          <target state="translated">给定类型 &lt;code&gt;T&lt;/code&gt; ，将其与分配相关的标志作为 &lt;code&gt;AllocFlag&lt;/code&gt; 值的组合返回。</target>
        </trans-unit>
        <trans-unit id="1ec656f1b47e3a570669cfd79e664b45a8112e7a" translate="yes" xml:space="preserve">
          <source>Given address that is inside a function, figure out which function it is in. Return DHandlerTable if there is one, NULL if not.</source>
          <target state="translated">给定一个函数中的地址,找出它在哪个函数中。如果有,返回DHandlerTable,如果没有,返回NULL。</target>
        </trans-unit>
        <trans-unit id="84fb4bae252188c74a52ee250ba7895934a71e72" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;object factory&lt;/a&gt; of type &lt;code&gt;Factory&lt;/code&gt; or a factory function &lt;code&gt;factoryFunction&lt;/code&gt;, and optionally also &lt;code&gt;BookkeepingAllocator&lt;/code&gt; as a supplemental allocator for bookkeeping, &lt;code&gt;AllocatorList&lt;/code&gt; creates an allocator that lazily creates as many allocators are needed for satisfying client allocation requests.</source>
          <target state="translated">给定类型为 &lt;code&gt;Factory&lt;/code&gt; 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;对象工厂&lt;/a&gt;或工厂函数 &lt;code&gt;factoryFunction&lt;/code&gt; ，还可以选择 &lt;code&gt;BookkeepingAllocator&lt;/code&gt; 作为簿记的补充分配器， &lt;code&gt;AllocatorList&lt;/code&gt; 创建一个分配器，该分配器懒惰地创建满足客户分配请求所需的尽可能多的分配器。</target>
        </trans-unit>
        <trans-unit id="2c2ffbad9b196900545a99b58a4a8084fb8e968f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;AssignExp&lt;/code&gt;, determine if the lvalue will cause the contents of the rvalue to escape. Print error messages when these are detected. Infer &lt;code&gt;scope&lt;/code&gt; attribute for the lvalue where possible, in order to eliminate the error.</source>
          <target state="translated">给定一个 &lt;code&gt;AssignExp&lt;/code&gt; ，确定左值是否会使右值的内容转义。检测到错误消息时将其打印出来。尽可能推断左值的 &lt;code&gt;scope&lt;/code&gt; 属性，以消除错误。</target>
        </trans-unit>
        <trans-unit id="f4edc9674fd3041f4bd8fcdf8c36704d26537a1f" translate="yes" xml:space="preserve">
          <source>Given an Expression, find the variable it really is.</source>
          <target state="translated">给定一个Expression,找到它真正的变量。</target>
        </trans-unit>
        <trans-unit id="10135b6f779b47ff66661cf2060528825cdb0465" translate="yes" xml:space="preserve">
          <source>Given an allocator factory, lazily creates as many allocators as needed to satisfy allocation requests. The allocators are stored in a linked list. Requests for allocation are satisfied by searching the list in a linear manner.</source>
          <target state="translated">给定一个分配器工厂,懒惰地创建所需的分配器以满足分配请求。分配器存储在一个链接列表中。通过以线性方式搜索列表来满足分配请求。</target>
        </trans-unit>
        <trans-unit id="c68fd4e0d6a4caa1cbbef6c7b7cc84e1b16b2800" translate="yes" xml:space="preserve">
          <source>Given an error instantiating the TemplateInstance, give the nested TemplateInstance instantiations that got us here. Those are a list threaded into the nested scopes.</source>
          <target state="translated">给定一个实例化TemplateInstance的错误,给出导致我们到这里的嵌套TemplateInstance实例。这些是一个线程到嵌套作用域的列表。</target>
        </trans-unit>
        <trans-unit id="0d192178ddf2961ae655bd11083f31d24b553ec6" translate="yes" xml:space="preserve">
          <source>Given an expression e that is an array, determine and set the 'length' variable.</source>
          <target state="translated">给定一个数组的表达式e,确定并设置 &quot;长度 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="13b4b240c1888ba281f7a8d067f704fc09eba179" translate="yes" xml:space="preserve">
          <source>Given array literal oldval of type ArrayLiteralExp or StringExp, of length oldlen, change its length to newlen. If the newlen is longer than oldlen, all new elements will be set to the default initializer for the element type.</source>
          <target state="translated">给定长度为oldlen的ArrayLiteralExp或StringExp类型的数组文字oldval,将其长度改为newlen。如果newlen比oldlen长,所有新元素将被设置为元素类型的默认初始化器。</target>
        </trans-unit>
        <trans-unit id="4fe6c27981ac387048ac652b298a3c233afd1136" translate="yes" xml:space="preserve">
          <source>Given array of foreach parameters and an aggregate type, find best opApply overload, if any of the parameter types are missing, attempt to infer them from the aggregate type.</source>
          <target state="translated">给定foreach参数数组和集合类型,找到最佳的opApply重载,如果缺少任何一个参数类型,尝试从集合类型中推断它们。</target>
        </trans-unit>
        <trans-unit id="548081a2237345a0383114c21603c8b8dab1f303" translate="yes" xml:space="preserve">
          <source>Given callable (&lt;a href=&quot;std_traits#isCallable&quot;&gt;&lt;code&gt;std.traits.isCallable&lt;/code&gt;&lt;/a&gt;) &lt;code&gt;fun&lt;/code&gt;, create as a range whose front is defined by successive calls to &lt;code&gt;fun()&lt;/code&gt;. This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire &lt;code&gt;front&lt;/code&gt;/&lt;code&gt;popFront&lt;/code&gt;/&lt;code&gt;empty&lt;/code&gt; structure. &lt;code&gt;fun&lt;/code&gt; maybe be passed either a template alias parameter (existing function, delegate, struct type defining &lt;code&gt;static opCall&lt;/code&gt;) or a run-time value argument (delegate, function object). The result range models an InputRange (&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;). The resulting range will call &lt;code&gt;fun()&lt;/code&gt; on construction, and every call to &lt;code&gt;popFront&lt;/code&gt;, and the cached value will be returned when &lt;code&gt;front&lt;/code&gt; is called.</source>
          <target state="translated">给定callable（&lt;a href=&quot;std_traits#isCallable&quot;&gt; &lt;code&gt;std.traits.isCallable&lt;/code&gt; &lt;/a&gt;）的 &lt;code&gt;fun&lt;/code&gt; ，将其创建为范围，其范围由对 &lt;code&gt;fun()&lt;/code&gt; 的连续调用定义。这对于调用具有全局副作用的函数（随机函数）或创建表示为单个委托而不是整个 &lt;code&gt;front&lt;/code&gt; / &lt;code&gt;popFront&lt;/code&gt; / &lt;code&gt;empty&lt;/code&gt; 结构的范围特别有用。可以通过模板别名参数（现有函数，委托，定义 &lt;code&gt;static opCall&lt;/code&gt; 结构类型）或运行时值参数（委托，函数对象）传递 &lt;code&gt;fun&lt;/code&gt; 。结果范围对InputRange（&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt; &lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt; &lt;/a&gt;）进行建模。结果范围将调用 &lt;code&gt;fun()&lt;/code&gt; 对建设，每次调用 &lt;code&gt;popFront&lt;/code&gt; ，和缓存的值时，将返回 &lt;code&gt;front&lt;/code&gt; 被调用。</target>
        </trans-unit>
        <trans-unit id="a6cdf45c5874188e502ef446c2f299954ad8e06e" translate="yes" xml:space="preserve">
          <source>Given function arguments, figure out which template function to expand, and return matching result.</source>
          <target state="translated">给定函数参数,找出要展开的模板函数,并返回匹配结果。</target>
        </trans-unit>
        <trans-unit id="f1c0666f9da353f9c6f10f1cf5edecb5189140bb" translate="yes" xml:space="preserve">
          <source>Given that the most frequent use of &lt;code&gt;InSituRegion&lt;/code&gt; is as a stack allocator, it allocates starting at the end on systems where stack grows downwards, such that hot memory is used first.</source>
          <target state="translated">鉴于 &lt;code&gt;InSituRegion&lt;/code&gt; 最常使用的是堆栈分配器，因此它在堆栈向下增长的系统上从末尾开始分配，这样就首先使用热内存。</target>
        </trans-unit>
        <trans-unit id="433dfce23255598b88ff3eee832e615faf6acb1f" translate="yes" xml:space="preserve">
          <source>Given that ti is an instance of this TemplateDeclaration, deduce the types of the parameters to this, and store those deduced types in dedtypes[].</source>
          <target state="translated">给定ti是这个TemplateDeclaration的一个实例,推导出这个参数的类型,并将这些推导出的类型存储在dedtypes[]中。</target>
        </trans-unit>
        <trans-unit id="de6b7e538358277d4d77d0a6dfdd22d328ebcdc2" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such log(x) - digamma(x) = y.</source>
          <target state="translated">给定y,函数找到这样的x:log(x)-digamma(x)=y。</target>
        </trans-unit>
        <trans-unit id="992b94a2b2bacb1095a0b111a75eb520df8ea274" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such that</source>
          <target state="translated">给定y,函数找到x,则</target>
        </trans-unit>
        <trans-unit id="a6d6838e980e7d735fe427a6cf2d72e4e8647a21" translate="yes" xml:space="preserve">
          <source>Gives a string containing all of the member variables on their own line.</source>
          <target state="translated">给出一个包含所有成员变量的字符串。</target>
        </trans-unit>
        <trans-unit id="7913f0379d403503a25672003418cf5f3eca8630" translate="yes" xml:space="preserve">
          <source>Gives a string in the form of &lt;code&gt;Appender!(A)(data)&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;Appender!(A)(data)&lt;/code&gt; 的形式给出一个字符串。</target>
        </trans-unit>
        <trans-unit id="e8ea4a4989f9ed3007485f30bc4c477cf8cf78af" translate="yes" xml:space="preserve">
          <source>Gives a template that can be used to apply the same attributes that are on the given type &lt;code&gt;T&lt;/code&gt;. E.g. passing &lt;code&gt;inout shared int&lt;/code&gt; will return &lt;code&gt;SharedInoutOf&lt;/code&gt;.</source>
          <target state="translated">提供一个模板，该模板可用于应用给定类型 &lt;code&gt;T&lt;/code&gt; 上的相同属性。例如，传递 &lt;code&gt;inout shared int&lt;/code&gt; 将返回 &lt;code&gt;SharedInoutOf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2633d057ea2e2d5df044edc1a3e53e74d5c07e4" translate="yes" xml:space="preserve">
          <source>Gives size in bytes of the memory mapped file.</source>
          <target state="translated">给出内存映射文件的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="16bbae332a1e2ca617ea29aad4cae716be022cf2" translate="yes" xml:space="preserve">
          <source>Gives the &lt;code&gt;sizeof&lt;/code&gt; the largest type given.</source>
          <target state="translated">给出给定最大类型的 &lt;code&gt;sizeof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83055a3a0dd1a147d856955312d10beee008598a" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">给出两个&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;之间的差值。</target>
        </trans-unit>
        <trans-unit id="7aeb61024a32a4be6fbe1fa0169b6dc0e34e0c60" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">给出两个&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;之间的差。</target>
        </trans-unit>
        <trans-unit id="a3e5e3dc87d1abe001240e5d15a0f4c35cd6e9f2" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">给出两个&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;之间的差异。</target>
        </trans-unit>
        <trans-unit id="e0ddf7ec5492699d7655f4aa024331ee0d174c96" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">给出两个&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;之间的差。</target>
        </trans-unit>
        <trans-unit id="23a706ac15ae0a2795d3b9540c47b5bd8f3ce3a4" translate="yes" xml:space="preserve">
          <source>Gives the last power of two before &lt;code&gt;val&lt;/code&gt;. &amp;lt;&amp;gt;&amp;gt; can be any built-in numerical type.</source>
          <target state="translated">给出 &lt;code&gt;val&lt;/code&gt; 之前的2的最后幂。&amp;lt;&amp;gt;&amp;gt;可以是任何内置数字类型。</target>
        </trans-unit>
        <trans-unit id="5eba15a4a12033f10f76ecaeb54e9264300c3d84" translate="yes" xml:space="preserve">
          <source>Gives the next power of two after &lt;code&gt;val&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; can be any built-in numerical type.</source>
          <target state="translated">给出 &lt;code&gt;val&lt;/code&gt; 之后的下一个2的幂。 &lt;code&gt;T&lt;/code&gt; 可以是任何内置数字类型。</target>
        </trans-unit>
        <trans-unit id="5dcd127d912205c801dfa9fd55aab21bc7540488" translate="yes" xml:space="preserve">
          <source>Gives the precision for numeric conversions. If the precision is a &lt;b&gt;*&lt;/b&gt;, an additional argument of type &lt;b&gt;int&lt;/b&gt;, preceding the actual argument, is taken as the precision. If it is negative, it is as if there was no</source>
          <target state="translated">给出数字转换的精度。如果precision为&lt;b&gt;*&lt;/b&gt;，则在实际参数之前添加&lt;b&gt;int&lt;/b&gt;类型的附加参数作为精度。如果是负数，就好像没有</target>
        </trans-unit>
        <trans-unit id="066636e1bed1369dff6efcd3fab1c1e8776d7710" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from</source>
          <target state="translated">给出加上或减去的结果&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;从</target>
        </trans-unit>
        <trans-unit id="13fd9f69f64522f3bd20d1184529d631b3677431" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给出从此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;添加或减去&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;的结果，并将结果分配给此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3c64b6298caea8c356268035bf6bb2213d1e63d" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给出从此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;中添加或减去&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="a1405f5ebc75767bb0c5bcf744b2d2f96a676122" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给出从此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;中添加或减去&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;的结果，并将结果分配给此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aea621df7ee3b5185f92bf03dc43838e74f11ab8" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给出从此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;中添加或减去&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="3d5dfde7603919eee6582396d3e52686e64f60c3" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给出从此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;中添加或减去&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;的结果，并将结果分配给此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1b9fd1a6e616c022dd85e5f596721b33e55dad9" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给出从此&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;中添加或减去&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;的结果。</target>
        </trans-unit>
        <trans-unit id="d7bb55c3ac43c11992ce982a465028a297070c37" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a duration from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给出从此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;中添加或减去持续时间的结果，以及将结果分配给此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b010645431226eb0d475a6508504f6360118e2aa" translate="yes" xml:space="preserve">
          <source>Gives the string &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; if &lt;code&gt;isNull&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is equivalent to calling &lt;a href=&quot;std_format#formattedWrite&quot;&gt;&lt;code&gt;std.format.formattedWrite&lt;/code&gt;&lt;/a&gt; on the underlying value.</source>
          <target state="translated">如果 &lt;code&gt;isNull&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,则提供字符串 &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; 。否则，结果等同于对基础值调用&lt;a href=&quot;std_format#formattedWrite&quot;&gt; &lt;code&gt;std.format.formattedWrite&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee3ba1f4d58b51dacaf77da9e736c2398dd52211" translate="yes" xml:space="preserve">
          <source>Giving better error messages inside generic code than the sometimes hard to follow compiler ones.</source>
          <target state="translated">在通用代码中提供比有时难以遵循的编译器错误信息更好的错误信息。</target>
        </trans-unit>
        <trans-unit id="fe40132df9803a579f2616316fd9f36e8b76b6f5" translate="yes" xml:space="preserve">
          <source>Glagolitic</source>
          <target state="translated">Glagolitic</target>
        </trans-unit>
        <trans-unit id="52d16b8e3607d3a956a90dad397b270e88b2a626" translate="yes" xml:space="preserve">
          <source>Glibc C runtime</source>
          <target state="translated">Glibc C运行时</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">全局功能</target>
        </trans-unit>
        <trans-unit id="60d510ca3fec034b096ecb101e79c44baa3bcfa4" translate="yes" xml:space="preserve">
          <source>Global and Static Initializers</source>
          <target state="translated">全局和静态初始化器</target>
        </trans-unit>
        <trans-unit id="ad8992e0e77b510d8dd8c9f31b8493285307157f" translate="yes" xml:space="preserve">
          <source>Global names</source>
          <target state="translated">全球名称</target>
        </trans-unit>
        <trans-unit id="fb160cab6ebf08ae16224b7387fbe010ff67af79" translate="yes" xml:space="preserve">
          <source>Global random number generator used by various functions in this module whenever no generator is specified. It is allocated per-thread and initialized to an unpredictable value for each thread.</source>
          <target state="translated">全局随机数生成器,当没有指定生成器时,本模块中的各种函数都会使用它。它是按线程分配的,并为每个线程初始化为一个不可预测的值。</target>
        </trans-unit>
        <trans-unit id="359a7909d420e528181333df942be655d355c0d2" translate="yes" xml:space="preserve">
          <source>Global regex, repeat over the whole input.</source>
          <target state="translated">全局的regex,在整个输入上重复。</target>
        </trans-unit>
        <trans-unit id="9d8204544b72aac8944f7aa50f34d5f2b83ebda7" translate="yes" xml:space="preserve">
          <source>Global status of the CTFE engine. Mostly used for performance diagnostics</source>
          <target state="translated">CTFE发动机的全局状态。主要用于性能诊断</target>
        </trans-unit>
        <trans-unit id="3bb8f4a4ce9e8fc53902a34f5711af6100354847" translate="yes" xml:space="preserve">
          <source>Global variables.</source>
          <target state="translated">全球变量:</target>
        </trans-unit>
        <trans-unit id="322346956002b43d1272ba3ca4fad36e87acf31f" translate="yes" xml:space="preserve">
          <source>Go through the variables in function fd that are to be allocated in a closure, and set the .offset fields for those variables to their positions relative to the start of the closure instance. Also turns off nrvo for closure variables.</source>
          <target state="translated">查看函数fd中要在闭包中分配的变量,并将这些变量的.offset字段设置为相对于闭包实例开始的位置。同时关闭闭包变量的 nrvo。</target>
        </trans-unit>
        <trans-unit id="83644e2182412c095ed367b8519c41f7f1a72b2f" translate="yes" xml:space="preserve">
          <source>Good error handling code tends to clutter up what otherwise would be a neat and clean looking implementation.</source>
          <target state="translated">好的错误处理代码往往会让原本整洁干净的实现变得混乱不堪。</target>
        </trans-unit>
        <trans-unit id="a4cc20ddddd5df91dbeeeac20e28069cdc6d35d5" translate="yes" xml:space="preserve">
          <source>Gothic</source>
          <target state="translated">Gothic</target>
        </trans-unit>
        <trans-unit id="523bd87e510be4584eb678bda56047b4e81b4e41" translate="yes" xml:space="preserve">
          <source>Goto Statement</source>
          <target state="translated">Goto声明</target>
        </trans-unit>
        <trans-unit id="d153d2afa0d10e789b42decd9c86f4c6ba7c4b32" translate="yes" xml:space="preserve">
          <source>GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt;;</source>
          <target state="translated">GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2d75a452fb197b862328ddf89077f60c5411007e" translate="yes" xml:space="preserve">
          <source>GotoStatement</source>
          <target state="translated">GotoStatement</target>
        </trans-unit>
        <trans-unit id="469b09861974ba8cba6608f5b50f5a4378e847aa" translate="yes" xml:space="preserve">
          <source>GotoStatements* &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt;;</source>
          <target state="translated">GotoStatements * &lt;strong id=&quot;gotos&quot;&gt;goto的&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b1b76e26ed39195055923abbd6da5da5869145b4" translate="yes" xml:space="preserve">
          <source>Gotos with forward references</source>
          <target state="translated">后藤,带正向参照物</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="40e6976321b98f0050106aca23fe0094f3e12aec" translate="yes" xml:space="preserve">
          <source>Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt;(Input)(ref Input inp)</source>
          <target state="translated">字形&lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt;（输入）（REF输入INP）</target>
        </trans-unit>
        <trans-unit id="09e21aefbc5d72becfb6e61403ad83558925c509" translate="yes" xml:space="preserve">
          <source>Grapheme cluster length in &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">音素簇长度的&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85a58af54a6759d4a9d1a773cb4f960185f26fe4" translate="yes" xml:space="preserve">
          <source>Grapheme_Base</source>
          <target state="translated">Grapheme_Base</target>
        </trans-unit>
        <trans-unit id="9aa96ceeca035f99f4979af4785877395b3fcca9" translate="yes" xml:space="preserve">
          <source>Grapheme_Extend</source>
          <target state="translated">Grapheme_Extend</target>
        </trans-unit>
        <trans-unit id="2299a70876b7b20196c0e232824b6e303cf0f817" translate="yes" xml:space="preserve">
          <source>Grapheme_Link</source>
          <target state="translated">Grapheme_Link</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="305ccd272b16a96e13db1c4faa38b1913caf51d8" translate="yes" xml:space="preserve">
          <source>Greek Extended</source>
          <target state="translated">希腊语扩展版</target>
        </trans-unit>
        <trans-unit id="63e0451063c60d5f6eae102313ee1b6d993a1f76" translate="yes" xml:space="preserve">
          <source>Greek and Coptic</source>
          <target state="translated">希腊语和科普特语</target>
        </trans-unit>
        <trans-unit id="73fb2dd5cc2643e9f02bc351410b98713e0c50c9" translate="yes" xml:space="preserve">
          <source>Group separator</source>
          <target state="translated">群体分离器</target>
        </trans-unit>
        <trans-unit id="10986e5fcbdd40c81d3e51dfc3ad691df9a6347c" translate="yes" xml:space="preserve">
          <source>Group!(pred, Range) &lt;strong id=&quot;group&quot;&gt;group&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range r);</source>
          <target state="translated">组！（pred，Range）&lt;strong id=&quot;group&quot;&gt;组&lt;/strong&gt;（alias pred =&amp;ldquo; a == b&amp;rdquo;，Range）（范围r）;</target>
        </trans-unit>
        <trans-unit id="83af1301254c2810b776d48cab533ffdca19f557" translate="yes" xml:space="preserve">
          <source>Groups consecutively equivalent elements into a single tuple of the element and the number of its repetitions.</source>
          <target state="translated">将连续等价的元素组合成一个元素及其重复数的元组。</target>
        </trans-unit>
        <trans-unit id="afb8bcba7055a53eb0c5db950f6c2af39388fdf2" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using &lt;code&gt;alloc&lt;/code&gt;. The extra elements added are either default- initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">生长 &lt;code&gt;array&lt;/code&gt; 通过附加 &lt;code&gt;delta&lt;/code&gt; 多个元件。所需的内存使用 &lt;code&gt;alloc&lt;/code&gt; 分配。添加的额外元素可以是默认初始化的，可以填充 &lt;code&gt;init&lt;/code&gt; 的副本，也可以使用从 &lt;code&gt;range&lt;/code&gt; 获取的值进行初始化。</target>
        </trans-unit>
        <trans-unit id="e03f30a2f53aecda689ec68c63bc0d88b73542a6" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using the same allocator that was used for the array type. The extra elements added are either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">生长 &lt;code&gt;array&lt;/code&gt; 通过附加 &lt;code&gt;delta&lt;/code&gt; 多个元件。使用与数组类型相同的分配器分配所需的内存。添加的额外元素可以是默认初始化的，可以填充 &lt;code&gt;init&lt;/code&gt; 的副本，也可以使用从 &lt;code&gt;range&lt;/code&gt; 获取的值进行初始化。</target>
        </trans-unit>
        <trans-unit id="77afda6ffc95cc0f06adb904e94cef0fc69add7d" translate="yes" xml:space="preserve">
          <source>Guaranteed &amp;Omicron;(&lt;code&gt;abs(length - newLength)&lt;/code&gt;) if &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt;. If &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; the worst case is &amp;Omicron;(&lt;code&gt;newLength&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt; 则保证&amp;Omicron;（ &lt;code&gt;abs(length - newLength)&lt;/code&gt; ）。如果 &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; ，最坏的情况是&amp;Omicron;（ &lt;code&gt;newLength&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="35776951606a73d6ff2bfb1c43d6ba2de2721cad" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet</source>
          <target state="translated">Guillaume Chatelet</target>
        </trans-unit>
        <trans-unit id="971317803587830757efb436fa41eeb1d9292828" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet Manu Evans</source>
          <target state="translated">Guillaume Chatelet Manu Evans</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="265e1c23debf982bad1eb28dbf1fb86580b82eab" translate="yes" xml:space="preserve">
          <source>Gurmukhi</source>
          <target state="translated">Gurmukhi</target>
        </trans-unit>
        <trans-unit id="72c5d728b8c5e13d38cf050220cb41c1803704d1" translate="yes" xml:space="preserve">
          <source>H &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">^ h &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44602ce53397cc7e3837311abb7db1d03042b84" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="translated">HS Teoh &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;关于带范围的组件编程&lt;/a&gt;的教程，真实展示了基于范围的编程对复杂算法的影响。</target>
        </trans-unit>
        <trans-unit id="7fa36c2d12dc8308dd96737ca9539591241ccb57" translate="yes" xml:space="preserve">
          <source>HTML can be embedded into the documentation comments, and it will be passed through to the HTML output unchanged. However, since it is not necessarily true that HTML will be the desired output format of the embedded documentation comment extractor, it is best to avoid using it where practical.</source>
          <target state="translated">HTML可以被嵌入到文档注释中,并且它将被传递到HTML输出中而不被改变。但是,由于HTML不一定是嵌入式文档注释提取器所需要的输出格式,所以在实际操作中最好不要使用它。</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="0481530df63832f72dfdebbe0c7a51d57e32da26" translate="yes" xml:space="preserve">
          <source>HTTP &lt;code&gt;conn&lt;/code&gt;</source>
          <target state="translated">HTTP &lt;code&gt;conn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca83e4b247db9f9a4bf080067c192c5cb65a0d61" translate="yes" xml:space="preserve">
          <source>HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="e4e09a7d12cb155ba460134c8bdd1f1479d801ce" translate="yes" xml:space="preserve">
          <source>HTTP POST method</source>
          <target state="translated">HTTP POST方式</target>
        </trans-unit>
        <trans-unit id="923988ff39d0e3042c9df0f259d1de84a01fde11" translate="yes" xml:space="preserve">
          <source>HTTP PUT</source>
          <target state="translated">HTTP PUT</target>
        </trans-unit>
        <trans-unit id="cc2478137d7b71e72935b2fddc027880593e756f" translate="yes" xml:space="preserve">
          <source>HTTP client functionality.</source>
          <target state="translated">HTTP客户端功能。</target>
        </trans-unit>
        <trans-unit id="827e4a67a71c875b43e732a905d1fd8e7200d6d6" translate="yes" xml:space="preserve">
          <source>HTTP connect request.</source>
          <target state="translated">HTTP连接请求。</target>
        </trans-unit>
        <trans-unit id="51449b9a0615713cbd19f5f01e23d5f58e4358b0" translate="yes" xml:space="preserve">
          <source>HTTP connection to use</source>
          <target state="translated">使用的HTTP连接</target>
        </trans-unit>
        <trans-unit id="797634e3b267b6d81699bf16ac8a0f81dc1a1ba6" translate="yes" xml:space="preserve">
          <source>HTTP connection to use  The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="translated">要使用的HTTP连接模板参数 &lt;code&gt;T&lt;/code&gt; 指定要返回的类型。可能的值为 &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;ubyte&lt;/code&gt; ,以返回 &lt;code&gt;char[]&lt;/code&gt; 或 &lt;code&gt;ubyte[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5b69d980b7b8a0f8d5057989430d112ecf22206" translate="yes" xml:space="preserve">
          <source>HTTP method used.</source>
          <target state="translated">使用的HTTP方法。</target>
        </trans-unit>
        <trans-unit id="bedfc3b8a98f74436dfffc470905a4cb727d6eb4" translate="yes" xml:space="preserve">
          <source>HTTP options request.</source>
          <target state="translated">HTTP选项请求。</target>
        </trans-unit>
        <trans-unit id="eca27a5fb0f79404f93ba2b2ff7621d850fa94c3" translate="yes" xml:space="preserve">
          <source>HTTP patch content.</source>
          <target state="translated">HTTP补丁内容。</target>
        </trans-unit>
        <trans-unit id="0f24bcb381b514379fb794061233a0fac483e67d" translate="yes" xml:space="preserve">
          <source>HTTP post content.</source>
          <target state="translated">HTTP帖子内容。</target>
        </trans-unit>
        <trans-unit id="fd473bd4cc525d8634b2d06223e94be806e9169e" translate="yes" xml:space="preserve">
          <source>HTTP request, for odd commands like DELETE, TRACE and others</source>
          <target state="translated">HTTP请求,用于DELETE、TRACE等奇葩命令。</target>
        </trans-unit>
        <trans-unit id="7c360b79abb627a8a4c93e546c995b917aedbbb1" translate="yes" xml:space="preserve">
          <source>HTTP status line code e.g. 200.</source>
          <target state="translated">HTTP状态行代码,如200。</target>
        </trans-unit>
        <trans-unit id="7fb8b94d5f23dd0fd12704704bd5724a9a81dd11" translate="yes" xml:space="preserve">
          <source>HTTP status line ie. the first line returned in an HTTP response.</source>
          <target state="translated">HTTP状态行即HTTP响应中返回的第一行。</target>
        </trans-unit>
        <trans-unit id="5c1ee2091ce3bea9e5a23e0562f6b6fd7953de16" translate="yes" xml:space="preserve">
          <source>HTTP status line of last response. One call to perform may result in several requests because of redirection.</source>
          <target state="translated">最后响应的HTTP状态行。由于重定向的原因,一次调用执行可能会导致多个请求。</target>
        </trans-unit>
        <trans-unit id="45f917922bd09e11086c274630d2415137d36f0f" translate="yes" xml:space="preserve">
          <source>HTTP status line reason string.</source>
          <target state="translated">HTTP状态行原因字符串。</target>
        </trans-unit>
        <trans-unit id="1909e6b2261783a8d317d6f55a66a50ec6cfafb1" translate="yes" xml:space="preserve">
          <source>HTTP trace request.</source>
          <target state="translated">HTTP跟踪请求。</target>
        </trans-unit>
        <trans-unit id="52f8dbc2c259a9731d9751db65ced2bb8937f72a" translate="yes" xml:space="preserve">
          <source>HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</source>
          <target state="translated">HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59dd0563a7efe56dbe888a8e6b63f08d0ec7b1a" translate="yes" xml:space="preserve">
          <source>HTTP/FTP delete content.</source>
          <target state="translated">HTTP/FTP删除内容。</target>
        </trans-unit>
        <trans-unit id="c911addb5a09d460fe739f0ee6699cd1115b2ceb" translate="yes" xml:space="preserve">
          <source>HTTP/FTP download to local file system.</source>
          <target state="translated">HTTP/FTP下载到本地文件系统。</target>
        </trans-unit>
        <trans-unit id="444e75970e6f6b8a13c7660b530b8789eb9d1688" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks asynchronously.</source>
          <target state="translated">HTTP/FTP以异步的方式获取一系列的块状内容。</target>
        </trans-unit>
        <trans-unit id="067f2a38c032292745289e6d568747297c1eb36d" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks.</source>
          <target state="translated">HTTP/FTP获取内容为一系列的小块。</target>
        </trans-unit>
        <trans-unit id="ba7a6201d2a706377c412c319526144deec7201e" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines asynchronously.</source>
          <target state="translated">HTTP/FTP以一系列行的形式异步获取内容。</target>
        </trans-unit>
        <trans-unit id="a30ab80f3f96882837554330daf0f4a6aaa048ff" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines.</source>
          <target state="translated">HTTP/FTP获取的内容为一系列的行。</target>
        </trans-unit>
        <trans-unit id="0a0a651b4d9a70a2c11401ce60fa08020ea7c52c" translate="yes" xml:space="preserve">
          <source>HTTP/FTP get content.</source>
          <target state="translated">HTTP/FTP获取内容。</target>
        </trans-unit>
        <trans-unit id="a18566ddab985dc1d64ecd1c3e55c7fe0283f6cd" translate="yes" xml:space="preserve">
          <source>HTTP/FTP put content.</source>
          <target state="translated">HTTP/FTP把内容。</target>
        </trans-unit>
        <trans-unit id="fd41ab93c5537d58968dc08902626f4aedcfc790" translate="yes" xml:space="preserve">
          <source>Halfwidth and Fullwidth Forms</source>
          <target state="translated">半宽和全宽表格</target>
        </trans-unit>
        <trans-unit id="15710324ddc14a3ddc719e414d041bb782d93764" translate="yes" xml:space="preserve">
          <source>Han</source>
          <target state="translated">Han</target>
        </trans-unit>
        <trans-unit id="495fba644d4dd3d28a3df2c5e262bc0aa344bdc1" translate="yes" xml:space="preserve">
          <source>Handle and transcode between various text encodings.</source>
          <target state="translated">在各种文本编码之间进行处理和转码。</target>
        </trans-unit>
        <trans-unit id="4cae35b945ed013183aeec759fb173f2b5e74ee5" translate="yes" xml:space="preserve">
          <source>Handle enums.</source>
          <target state="translated">处理枚举。</target>
        </trans-unit>
        <trans-unit id="70c0fd2c64cbbc7d9a73e18bc0fd02b46b142b9f" translate="yes" xml:space="preserve">
          <source>Handle exceptions thrown from range primitives.</source>
          <target state="translated">处理从范围基元抛出的异常。</target>
        </trans-unit>
        <trans-unit id="ed3da861f4c68bd404277c3815bb4277903ee0c7" translate="yes" xml:space="preserve">
          <source>Handle the postblit call on lvalue, or the move of rvalue.</source>
          <target state="translated">处理lvalue的blit后调用,或rvalue的移动。</target>
        </trans-unit>
        <trans-unit id="e61477ad33d711243071181209298dcaac99b754" translate="yes" xml:space="preserve">
          <source>Handle to the system-specific semaphore.</source>
          <target state="translated">系统专用信号体的处理方式。</target>
        </trans-unit>
        <trans-unit id="362f233bfd36bbe9ffba21ece507104cececa24e" translate="yes" xml:space="preserve">
          <source>Handlers</source>
          <target state="translated">Handlers</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="46a74e921ed0b81734815d203a76d63ac9b445e2" translate="yes" xml:space="preserve">
          <source>Hangul Compatibility Jamo</source>
          <target state="translated">韩语兼容性Jamo</target>
        </trans-unit>
        <trans-unit id="6e435e03b7ff7b49d783dd12f4139eb337e88129" translate="yes" xml:space="preserve">
          <source>Hangul Jamo</source>
          <target state="translated">Hangul Jamo</target>
        </trans-unit>
        <trans-unit id="1af30ae437546a0c8f4e8c904b38e9e32c465cd5" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-A</source>
          <target state="translated">Hangul Jamo Extended-A</target>
        </trans-unit>
        <trans-unit id="7f76ea3a5ca65b3f7be6271028b86fb4c24ad5b4" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-B</source>
          <target state="translated">Hangul Jamo Extended-B</target>
        </trans-unit>
        <trans-unit id="a3c09f1beeeb5e6518d7a5aa130f9229a5bab1c8" translate="yes" xml:space="preserve">
          <source>Hangul Syllables</source>
          <target state="translated">韩语音节</target>
        </trans-unit>
        <trans-unit id="9649db5db6338c7bb1ab5215b20988c58817b67a" translate="yes" xml:space="preserve">
          <source>Hangul syllables are not covered by this function. See &lt;code&gt;composeJamo&lt;/code&gt; below.</source>
          <target state="translated">该功能不涵盖韩文音节。请参阅下面的 &lt;code&gt;composeJamo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="e938944cea2d9cc40e1f9955e4a0cfe8a2544308" translate="yes" xml:space="preserve">
          <source>Hardware Control</source>
          <target state="translated">硬件控制</target>
        </trans-unit>
        <trans-unit id="624a7b201d0ea02f7b27a09976e5469ea739a9e3" translate="yes" xml:space="preserve">
          <source>Has the same meaning as outside of a character class.</source>
          <target state="translated">与人物类外的意义相同。</target>
        </trans-unit>
        <trans-unit id="ff69afc8afb157be53fcca5d806ead0afca8f54a" translate="yes" xml:space="preserve">
          <source>Hash &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt;(Hash)();</source>
          <target state="translated">散列&lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt;（Hash）（）;</target>
        </trans-unit>
        <trans-unit id="512530e2001855653aa805d74cb64a05638ad3fd" translate="yes" xml:space="preserve">
          <source>Hash options.</source>
          <target state="translated">散列选项。</target>
        </trans-unit>
        <trans-unit id="82c3b55a6e6190b4ea897a708e89b49564008ef7" translate="yes" xml:space="preserve">
          <source>Hash syntax for json objects.</source>
          <target state="translated">json对象的哈希语法。</target>
        </trans-unit>
        <trans-unit id="8d05adeedcb7aa54cc03e4f260b3e38d1479ae1c" translate="yes" xml:space="preserve">
          <source>HashTab container for internal usage.</source>
          <target state="translated">HashTab容器供内部使用。</target>
        </trans-unit>
        <trans-unit id="201cd54dff7c562fa04665ce3ec7f389323b7356" translate="yes" xml:space="preserve">
          <source>Have some variables that are maybescopes that were assigned values from other maybescope variables. Now that semantic analysis of the function is complete, we can finalize this by turning off maybescope for array elements that cannot be scope.</source>
          <target state="translated">有一些变量是maybescopes,是从其他maybescope变量中赋值的。现在,函数的语义分析已经完成,我们可以通过关闭不能成为scope的数组元素的maybescope来最终完成。</target>
        </trans-unit>
        <trans-unit id="dea56ebbd4737b0cd9262ab0c819e3683d0b5416" translate="yes" xml:space="preserve">
          <source>Having unmatched parentheses can hose the output of Ddoc, as the macros depend on properly nested parentheses. This function replaces all ( with ( and ) with ) to preserve text literally. This also means macros in the text won't be expanded.</source>
          <target state="translated">不匹配的小括号会影响 Ddoc 的输出,因为宏依赖于正确的嵌套小括号。这个函数用(和 )代替所有(用 ),以保留文本的字面意思。这也意味着文本中的宏不会被展开。</target>
        </trans-unit>
        <trans-unit id="71653e5271aa72abad98ba52f8927b0be428b96b" translate="yes" xml:space="preserve">
          <source>Haystack &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">干 &lt;code&gt;haystack&lt;/code&gt; 干草堆</target>
        </trans-unit>
        <trans-unit id="e0403de1effb4e88849c3d2d079f299e89f093ed" translate="yes" xml:space="preserve">
          <source>HeaderFormat &lt;code&gt;header&lt;/code&gt;</source>
          <target state="translated">HeaderFormat &lt;code&gt;header&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c97d4c3dede14ee24bc42018c52f19917fd481c9" translate="yes" xml:space="preserve">
          <source>Headings</source>
          <target state="translated">Headings</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="fbea2ec13adcf999e380e13a429a4e17dc3d8090" translate="yes" xml:space="preserve">
          <source>Help Information Generation</source>
          <target state="translated">帮助信息生成</target>
        </trans-unit>
        <trans-unit id="1e7eebdb08c9dbf27c7668e2badd51e667707d3c" translate="yes" xml:space="preserve">
          <source>Helper</source>
          <target state="translated">Helper</target>
        </trans-unit>
        <trans-unit id="5e31a530e83afec402c4c09898e79e56b473dc7d" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create a string literal consisting of 'value' duplicated 'dim' times.</source>
          <target state="translated">NewExp的助手 创建一个由'value'重复'dim'次数组成的字符串文字。</target>
        </trans-unit>
        <trans-unit id="766c386647e8e48a9fcd435724f1d350167f7ed5" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create an array literal consisting of 'elem' duplicated 'dim' times.</source>
          <target state="translated">NewExp的助手 创建一个由'elem'重复'dim'次数组成的数组文字。</target>
        </trans-unit>
        <trans-unit id="c02c79263e4ed8c5595da2dd0c63a6d49edcd0eb" translate="yes" xml:space="preserve">
          <source>Helper function for &lt;code&gt;getRightThis()&lt;/code&gt;. Gets &lt;code&gt;this&lt;/code&gt; of the next outer aggregate.</source>
          <target state="translated">&lt;code&gt;getRightThis()&lt;/code&gt; 的辅助函数。获取 &lt;code&gt;this&lt;/code&gt; 下一外骨料。</target>
        </trans-unit>
        <trans-unit id="467531459771317152c9703e3f120447d81f80b5" translate="yes" xml:space="preserve">
          <source>Helper function for easy error propagation. If error occurs, returns ErrorExp. Otherwise returns NULL.</source>
          <target state="translated">方便错误传播的辅助函数。如果发生错误,返回ErrorExp。否则返回NULL。</target>
        </trans-unit>
        <trans-unit id="3576c823fa70ffbb40f146b4e65274f6dc08a676" translate="yes" xml:space="preserve">
          <source>Helper function for the expansion of manifest constant.</source>
          <target state="translated">扩显常数的辅助函数。</target>
        </trans-unit>
        <trans-unit id="f45a0f048cca01c298f3e28147b97707c3bec7c9" translate="yes" xml:space="preserve">
          <source>Helper function that returns a &lt;code&gt;FormatSpec&lt;/code&gt; for a single specifier given in &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;fmt&lt;/code&gt; 中给定的单个说明符返回 &lt;code&gt;FormatSpec&lt;/code&gt; 的帮助程序函数。</target>
        </trans-unit>
        <trans-unit id="10a93d4497e85393cb5499fb73d96c729ebc3ddb" translate="yes" xml:space="preserve">
          <source>Helper function that returns a complex number with the specified real and imaginary parts.</source>
          <target state="translated">辅助函数,用于返回一个具有指定实部和虚部的复数。</target>
        </trans-unit>
        <trans-unit id="b43936919328317134bad177cd4f68d6f84246ac" translate="yes" xml:space="preserve">
          <source>Helper function to turn operator into template argument list</source>
          <target state="translated">将运算符转化为模板参数列表的辅助函数。</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">辅助功能</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="e9e62a53ff4cde1bc51ffbf3814a1010c7743286" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the</source>
          <target state="translated">&lt;code&gt;o&lt;/code&gt; 在这里提供</target>
        </trans-unit>
        <trans-unit id="8cf320d31b7dd0774140c8f2ed90c8c274ff772d" translate="yes" xml:space="preserve">
          <source>Here block names are unambiguous as no scripts are searched and thus to search use simply &lt;code&gt;unicode.block.BlockName&lt;/code&gt; notation.</source>
          <target state="translated">此处，块名称是明确的，因为不搜索任何脚本，因此仅使用 &lt;code&gt;unicode.block.BlockName&lt;/code&gt; 表示法即可进行搜索。</target>
        </trans-unit>
        <trans-unit id="6dcb204b7bfbc922a65c81d29d2d9fe0db1b0d9c" translate="yes" xml:space="preserve">
          <source>Here is an example function in both forms:</source>
          <target state="translated">下面是一个两种形式的函数示例。</target>
        </trans-unit>
        <trans-unit id="d0b4b9e647805e60f485e34136037cafd1a89034" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;add&lt;/code&gt; returns the base type, which doesn't implement the &lt;code&gt;remove&lt;/code&gt; method. The &lt;code&gt;template this&lt;/code&gt; parameter can be used for this purpose:</source>
          <target state="translated">在这里，方法 &lt;code&gt;add&lt;/code&gt; 返回基本类型，该基本类型未实现 &lt;code&gt;remove&lt;/code&gt; 方法。 &lt;code&gt;template this&lt;/code&gt; 参数的模板可用于此目的：</target>
        </trans-unit>
        <trans-unit id="c4a0b731de4fd47e1ec934359b73224f54545eef" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;initWith&lt;/code&gt; is overloaded with two versions, one accepting &lt;code&gt;in char*&lt;/code&gt;, the other one &lt;code&gt;NSString&lt;/code&gt;. These two methods are mapped to two different Objective-C selectors, &lt;code&gt;initWithUTF8String:&lt;/code&gt; and &lt;code&gt;initWithString:&lt;/code&gt;.</source>
          <target state="translated">这里所述方法 &lt;code&gt;initWith&lt;/code&gt; 重载用两个版本，一个接受 &lt;code&gt;in char*&lt;/code&gt; ，另外一个 &lt;code&gt;NSString&lt;/code&gt; 。这两种方法被映射到两个不同的目标C选择器， &lt;code&gt;initWithUTF8String:&lt;/code&gt; 和 &lt;code&gt;initWithString:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7394eed5672426c0a80d302b8f8393ed7eec5e66" translate="yes" xml:space="preserve">
          <source>Here's an example of C code providing a callback to D code:</source>
          <target state="translated">下面是一个C代码为D代码提供回调的例子。</target>
        </trans-unit>
        <trans-unit id="ca207d127693f0056dad58049c5cee1c802022ff" translate="yes" xml:space="preserve">
          <source>Here's an example of a</source>
          <target state="translated">下面是一个例子</target>
        </trans-unit>
        <trans-unit id="62b798df4ae2b665a95d9fcc9f504deddb178a54" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S&lt;/code&gt; has a temporary workspace &lt;code&gt;buf[]&lt;/code&gt;. The normal postblit will pointlessly free and reallocate it. The custom &lt;code&gt;opAssign&lt;/code&gt; will reuse the existing storage.</source>
          <target state="translated">在这里， &lt;code&gt;S&lt;/code&gt; 具有一个临时工作区 &lt;code&gt;buf[]&lt;/code&gt; 。普通的postblit将毫无意义地释放并重新分配它。自定义 &lt;code&gt;opAssign&lt;/code&gt; 将重用现有存储。</target>
        </trans-unit>
        <trans-unit id="8062e6745c830b66848176f824bd120bb6ff6bff" translate="yes" xml:space="preserve">
          <source>Here, an implementation may assume (without having knowledge of the body of &lt;code&gt;make&lt;/code&gt;) that all references in &lt;code&gt;make&lt;/code&gt;'s result refer to other &lt;code&gt;List&lt;/code&gt; objects created by &lt;code&gt;make&lt;/code&gt;, and that no other part of the program refers to any of these objects.</source>
          <target state="translated">在这里，一个实现可以假定（无需身体的知识 &lt;code&gt;make&lt;/code&gt; ），在所有引用 &lt;code&gt;make&lt;/code&gt; 的结果，参考其他 &lt;code&gt;List&lt;/code&gt; 对象通过创建 &lt;code&gt;make&lt;/code&gt; ，并且该程序的任何其他部分是指任何这些对象。</target>
        </trans-unit>
        <trans-unit id="aa7249d3729c33470954c40f7854c88ac6ea3626" translate="yes" xml:space="preserve">
          <source>Hex Strings</source>
          <target state="translated">六角串</target>
        </trans-unit>
        <trans-unit id="55d1c93cb26fa4369bf6dcef06802017d907bd51" translate="yes" xml:space="preserve">
          <source>Hex strings allow string literals to be created using hex data. The hex data need not form valid UTF characters.</source>
          <target state="translated">十六进制字符串允许使用十六进制数据创建字符串字元。十六进制数据不需要形成有效的UTF字符。</target>
        </trans-unit>
        <trans-unit id="d39bdde77ca95b7a4b0450ffc2d016efdeac30d3" translate="yes" xml:space="preserve">
          <source>Hex_Digit</source>
          <target state="translated">Hex_Digit</target>
        </trans-unit>
        <trans-unit id="c45ee0a2d08a303c51fd2da33a102a3979857332" translate="yes" xml:space="preserve">
          <source>Hexadecimal floats are preceded by a &lt;b&gt;0x&lt;/b&gt; or &lt;b&gt;0X&lt;/b&gt; and the exponent is a &lt;b&gt;p&lt;/b&gt; or &lt;b&gt;P&lt;/b&gt; followed by a decimal number serving as the exponent of 2.</source>
          <target state="translated">十六进制浮点数以&lt;b&gt;0x&lt;/b&gt;或&lt;b&gt;0X &lt;/b&gt;&lt;b&gt;开头&lt;/b&gt;，指数为&lt;b&gt;p&lt;/b&gt;或&lt;b&gt;P，&lt;/b&gt;后跟一个十进制数字（即2）。</target>
        </trans-unit>
        <trans-unit id="f16858a5f250d36219d82e048f143333094b2747" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers are a sequence of hexadecimal digits preceded by a &amp;lsquo;0x&amp;rsquo; or &amp;lsquo;0X&amp;rsquo;.</source>
          <target state="translated">十六进制整数是十六进制数字的序列，后跟一个&amp;ldquo; 0x&amp;rdquo;或&amp;ldquo; 0X&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="11ddb91ab70b44df8f22cc56bf0f33cd3a59aeec" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation</source>
          <target state="translated">十六进制记数法</target>
        </trans-unit>
        <trans-unit id="66364879eee2501137250fec2b98de691bb34dff" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation with explicit suffixes</source>
          <target state="translated">带明确后缀的十六进制记数法</target>
        </trans-unit>
        <trans-unit id="4606d5486909f59f9ecd950c1b17f287693253b2" translate="yes" xml:space="preserve">
          <source>Hexadecimal, lower case</source>
          <target state="translated">十六进制,小写</target>
        </trans-unit>
        <trans-unit id="bf0117ce1416e40b23cca8ffd7b3aa016afb333f" translate="yes" xml:space="preserve">
          <source>Hexadecimal, upper case</source>
          <target state="translated">十六进制,大写</target>
        </trans-unit>
        <trans-unit id="30b3eea9819f7439bb0562c0c53437f8d9a50617" translate="yes" xml:space="preserve">
          <source>Hidden parameters include the &lt;code&gt;this&lt;/code&gt; parameter of a class, struct or nested function and the selector parameter for Objective-C methods.</source>
          <target state="translated">隐藏的参数包括类，结构或嵌套函数的 &lt;code&gt;this&lt;/code&gt; 参数以及Objective-C方法的选择器参数。</target>
        </trans-unit>
        <trans-unit id="53541869fd4c351759ad332d3244e2355b446808" translate="yes" xml:space="preserve">
          <source>High Private Use Surrogates</source>
          <target state="translated">高私用代用</target>
        </trans-unit>
        <trans-unit id="a2c5b830397db70f03f56d26786a97a92aad7755" translate="yes" xml:space="preserve">
          <source>High Surrogates</source>
          <target state="translated">高级代用药</target>
        </trans-unit>
        <trans-unit id="f8ac1be04c27612db7a3ef64fd5edd48a9cbefb5" translate="yes" xml:space="preserve">
          <source>High level</source>
          <target state="translated">高级别</target>
        </trans-unit>
        <trans-unit id="0720fad238d3af6e0d988b6041fc7aff02b725de" translate="yes" xml:space="preserve">
          <source>High level bit level manipulation, bit arrays, bit fields.</source>
          <target state="translated">高层位级操作,位数组,位域。</target>
        </trans-unit>
        <trans-unit id="a05a4fbe2b607cf88b24dc00ca5c949b2b6f1756" translate="yes" xml:space="preserve">
          <source>High level primitives for SMP parallelism.</source>
          <target state="translated">用于SMP并行的高级基元。</target>
        </trans-unit>
        <trans-unit id="2ced0d4c7e1faee3d9f900306c2e846112d18012" translate="yes" xml:space="preserve">
          <source>High-level interface for allocators. Implements bundled allocation/creation and destruction/deallocation of data including &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es, and also array primitives related to allocation. This module is the entry point for both making use of allocators and for their documentation.</source>
          <target state="translated">分配器的高级接口。实现数据的捆绑分配/创建和销毁/取消分配，包括 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; es，以及与分配有关的数组原语。该模块是使用分配器及其文档的切入点。</target>
        </trans-unit>
        <trans-unit id="e4a71da2c94aa8ebb4eabe525bf9bfaf87c49456" translate="yes" xml:space="preserve">
          <source>Highest generated value (&lt;code&gt;modulus - 1&lt;/code&gt;).</source>
          <target state="translated">最高生成值（ &lt;code&gt;modulus - 1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9a7ebfdbeeab34f9a74c5ea30182aae05ebb58ca" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">最高可能的 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="464c7e7834d9d7bd5320fc6bf866ca1e41042986" translate="yes" xml:space="preserve">
          <source>Highlighting</source>
          <target state="translated">Highlighting</target>
        </trans-unit>
        <trans-unit id="b95101e7e46150f6462631854125e5fff96c059a" translate="yes" xml:space="preserve">
          <source>Highlighting of D code is performed by the following macros:</source>
          <target state="translated">D代码的高亮显示是通过以下宏来实现的。</target>
        </trans-unit>
        <trans-unit id="683f475e2ebb85d31bca86c12acb027ecf0e8eb2" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords</source>
          <target state="translated">突出D关键词</target>
        </trans-unit>
        <trans-unit id="c4ca1644d89763135e446cfbeade41acbff8ee52" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords.</source>
          <target state="translated">突出D关键词。</target>
        </trans-unit>
        <trans-unit id="935e04346b38d14f49040acb6c379fad11a7bf81" translate="yes" xml:space="preserve">
          <source>Highlighting of a function parameter section.</source>
          <target state="translated">高亮显示功能参数部分。</target>
        </trans-unit>
        <trans-unit id="826389bac96eaeab4717271d63b43c94f3297c72" translate="yes" xml:space="preserve">
          <source>Highlighting of a name=value function parameter.</source>
          <target state="translated">高亮显示一个name=value的函数参数。</target>
        </trans-unit>
        <trans-unit id="51eda7a8eeff739d414894834699b4db25dca6d2" translate="yes" xml:space="preserve">
          <source>Highlighting of a template constraint.</source>
          <target state="translated">高亮显示模板约束。</target>
        </trans-unit>
        <trans-unit id="cc13dc42b045774509fcd534fa3f901ea5ee4636" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's individual parameters.</source>
          <target state="translated">高亮显示模板的各个参数。</target>
        </trans-unit>
        <trans-unit id="61100e35b4349aa073e0605d9e5a97e7d22147a5" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's parameter list.</source>
          <target state="translated">高亮显示模板的参数列表。</target>
        </trans-unit>
        <trans-unit id="c13fcc9292d599790bf9edbd77af674db96191fd" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a class.</source>
          <target state="translated">突出一个班级的所有成员。</target>
        </trans-unit>
        <trans-unit id="e4ae17c8f2cb1ec34256f6f0903677d6b391295e" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a module.</source>
          <target state="translated">突出显示一个模块的所有成员。</target>
        </trans-unit>
        <trans-unit id="c09feb09e99ce22a8559d127647547ccdb5c7c15" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a struct.</source>
          <target state="translated">突出显示一个结构的所有成员。</target>
        </trans-unit>
        <trans-unit id="cbef76e4daad8898695a45761c2de54a52f8635b" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a template.</source>
          <target state="translated">突出显示一个模板的所有成员。</target>
        </trans-unit>
        <trans-unit id="0faf83c3ae32ade36ccd67312a59a723e525d473" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of an enum.</source>
          <target state="translated">突出显示一个枚举的所有成员。</target>
        </trans-unit>
        <trans-unit id="e8d93f96992576e6ba1194d00e53b1efd8bd3019" translate="yes" xml:space="preserve">
          <source>Highlighting of all the sections.</source>
          <target state="translated">突出所有部分。</target>
        </trans-unit>
        <trans-unit id="4778b67265bf5d04ac6df97ab091affb27b022ea" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected keywords</source>
          <target state="translated">高亮显示自动检测的关键词。</target>
        </trans-unit>
        <trans-unit id="dd81b3fecd0f20ab2c7c2cd23019f77363841968" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected parameters</source>
          <target state="translated">突出显示自动检测的参数</target>
        </trans-unit>
        <trans-unit id="2d5dbc630aa84bc9b06ad40e57222a60ed6a293a" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol</source>
          <target state="translated">突出显示自动检测的符号</target>
        </trans-unit>
        <trans-unit id="5a59602c4760ed030bee0db0f8f2fc1e157c8fe6" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol that starts with underscore</source>
          <target state="translated">突出显示以下划线开头的自动检测符号。</target>
        </trans-unit>
        <trans-unit id="03eeb845c1ab1c169a400e57021a9975be5fcd70" translate="yes" xml:space="preserve">
          <source>Highlighting of comments</source>
          <target state="translated">突出评论</target>
        </trans-unit>
        <trans-unit id="b342620229626113c8bd37f08c3e00019479575f" translate="yes" xml:space="preserve">
          <source>Highlighting of current declaration name</source>
          <target state="translated">高亮显示当前的声明名称</target>
        </trans-unit>
        <trans-unit id="176f12498ba670eeda224994c2d82350441886fe" translate="yes" xml:space="preserve">
          <source>Highlighting of current function declaration parameters</source>
          <target state="translated">突出显示当前函数声明参数</target>
        </trans-unit>
        <trans-unit id="6b99cfaf4826b1d374574b650af15bdd57440bdb" translate="yes" xml:space="preserve">
          <source>Highlighting of declaration name to which a particular section is referring.</source>
          <target state="translated">突出显示某一节所涉及的声明名称。</target>
        </trans-unit>
        <trans-unit id="0ccd215d873103285e575951e68bee16377784a3" translate="yes" xml:space="preserve">
          <source>Highlighting of ditto declarations.</source>
          <target state="translated">突出强调同上声明。</target>
        </trans-unit>
        <trans-unit id="e60176b3b0d8bba6525dbfb5d2184816b026c16d" translate="yes" xml:space="preserve">
          <source>Highlighting of function parameters.</source>
          <target state="translated">突出显示函数参数。</target>
        </trans-unit>
        <trans-unit id="738f3d1a73adb20a6fc751e428562fd5770c4fbf" translate="yes" xml:space="preserve">
          <source>Highlighting of non-special sections is done.</source>
          <target state="translated">对非特殊部分进行高亮处理。</target>
        </trans-unit>
        <trans-unit id="4e9319188986e049a769be81e81ed23eb17972c2" translate="yes" xml:space="preserve">
          <source>Highlighting of string literals</source>
          <target state="translated">字符串高亮显示</target>
        </trans-unit>
        <trans-unit id="9dc393c818c0c8fcccd04642b35f2031235608ef" translate="yes" xml:space="preserve">
          <source>Highlighting of the authors section.</source>
          <target state="translated">突出作者部分。</target>
        </trans-unit>
        <trans-unit id="c04db9dc0d813c1ccd8c3f2345ab8b620b85f230" translate="yes" xml:space="preserve">
          <source>Highlighting of the base type of a class.</source>
          <target state="translated">突出显示一个类的基本类型。</target>
        </trans-unit>
        <trans-unit id="a07587fe4175acb9782fe36fd142c60cdfdd6da4" translate="yes" xml:space="preserve">
          <source>Highlighting of the bugs section.</source>
          <target state="translated">高亮显示错误部分。</target>
        </trans-unit>
        <trans-unit id="7882769ed43990ada8c8b23f2c29f9e27cd0f71b" translate="yes" xml:space="preserve">
          <source>Highlighting of the contents of a non-standard section.</source>
          <target state="translated">突出显示非标准部分的内容。</target>
        </trans-unit>
        <trans-unit id="4f9d3c220f1308abbd19a33e68d9159fe1a7bcac" translate="yes" xml:space="preserve">
          <source>Highlighting of the copyright section.</source>
          <target state="translated">突出版权部分。</target>
        </trans-unit>
        <trans-unit id="7d6e48fe7e09c72518d7c42b2053ac6afd252e38" translate="yes" xml:space="preserve">
          <source>Highlighting of the date section.</source>
          <target state="translated">突出日期部分。</target>
        </trans-unit>
        <trans-unit id="895c3d9b137fe00aae27a823464b74cfac8c6e8b" translate="yes" xml:space="preserve">
          <source>Highlighting of the declaration.</source>
          <target state="translated">突出声明。</target>
        </trans-unit>
        <trans-unit id="63dc31f05686ee2516c9b1d4403bc34707de916c" translate="yes" xml:space="preserve">
          <source>Highlighting of the deprecated section.</source>
          <target state="translated">高亮显示被废弃的部分。</target>
        </trans-unit>
        <trans-unit id="c8decd9303e1480e7050896c2d68e41aba55a19d" translate="yes" xml:space="preserve">
          <source>Highlighting of the description of a declaration.</source>
          <target state="translated">突出声明的说明;</target>
        </trans-unit>
        <trans-unit id="c34c68b3feaf8a8af047b5dc0b27284ee8a4a976" translate="yes" xml:space="preserve">
          <source>Highlighting of the description section.</source>
          <target state="translated">突出说明部分。</target>
        </trans-unit>
        <trans-unit id="66395af507be6d2f2c64374c4dcc34d87ba08e37" translate="yes" xml:space="preserve">
          <source>Highlighting of the examples section.</source>
          <target state="translated">突出例子部分。</target>
        </trans-unit>
        <trans-unit id="6c9891d5d62ba75e6f4bc3861099aa91d8757c3e" translate="yes" xml:space="preserve">
          <source>Highlighting of the history section.</source>
          <target state="translated">突出历史部分。</target>
        </trans-unit>
        <trans-unit id="b7f85e62f0cd3405e5bd64486a1604e80fdbaccf" translate="yes" xml:space="preserve">
          <source>Highlighting of the license section.</source>
          <target state="translated">突出显示许可证部分。</target>
        </trans-unit>
        <trans-unit id="a1bf0eef04a7e415262c4a93c4981e89e888edcc" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter name.</source>
          <target state="translated">高亮显示参数名称。</target>
        </trans-unit>
        <trans-unit id="f88d01cfff7b61b2efa32b18d2de859fdd295ab7" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter value.</source>
          <target state="translated">突出显示参数值。</target>
        </trans-unit>
        <trans-unit id="e1964e06337cb784d3309fe34806373d2ea7eb8f" translate="yes" xml:space="preserve">
          <source>Highlighting of the returns section.</source>
          <target state="translated">突出强调回报部分。</target>
        </trans-unit>
        <trans-unit id="833453d17a268f3c235ee74c7f3da2609550d437" translate="yes" xml:space="preserve">
          <source>Highlighting of the section name of a non-standard section.</source>
          <target state="translated">突出显示非标准节的节名。</target>
        </trans-unit>
        <trans-unit id="c7903d232b908137bafe89e336276f896f569fc5" translate="yes" xml:space="preserve">
          <source>Highlighting of the see-also section.</source>
          <target state="translated">高亮显示 &quot;又见 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="df390d31d75e9b616a073ce0adb1eeb2634d7fd5" translate="yes" xml:space="preserve">
          <source>Highlighting of the standards section.</source>
          <target state="translated">突出标准部分。</target>
        </trans-unit>
        <trans-unit id="f0d2af38c35f5e37acd97274204555972b2988bd" translate="yes" xml:space="preserve">
          <source>Highlighting of the summary section.</source>
          <target state="translated">突出总结部分。</target>
        </trans-unit>
        <trans-unit id="21e5f168213fe615e9ee4675e90cca4182bf4f11" translate="yes" xml:space="preserve">
          <source>Highlighting of the throws section.</source>
          <target state="translated">突出投掷部分。</target>
        </trans-unit>
        <trans-unit id="0dff0c156a9e500788193fc7d13465ffae833297" translate="yes" xml:space="preserve">
          <source>Highlighting of the type an enum is based upon</source>
          <target state="translated">突出显示一个枚举所基于的类型。</target>
        </trans-unit>
        <trans-unit id="6b50d26c177d3621167352e70fcbe2f923cd28c3" translate="yes" xml:space="preserve">
          <source>Highlighting of the version section.</source>
          <target state="translated">突出版本部分。</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="835fe32e11d06c07988640ea18d5a882081aeaae" translate="yes" xml:space="preserve">
          <source>History:</source>
          <target state="translated">History:</target>
        </trans-unit>
        <trans-unit id="b44fed8b2ad60db45d1dfeb77fbed8d582ca1505" translate="yes" xml:space="preserve">
          <source>Hoist-load + hoist-store barrier. Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_acquire&lt;/code&gt;.</source>
          <target state="translated">提升负载+提升存储屏障。对应于&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt;和C ++ 11 / C11 &lt;code&gt;memory_order_acquire&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e61310c65ecb57873a154d2408b9cc4403ad4a2" translate="yes" xml:space="preserve">
          <source>Holds information about a socket address retrieved by &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="translated">包含有关由 &lt;code&gt;getAddressInfo&lt;/code&gt; 检索的套接字地址的信息。</target>
        </trans-unit>
        <trans-unit id="c10ba96a990de4f937f02e9f283e74796b47e3f8" translate="yes" xml:space="preserve">
          <source>Home of the TZ Database files</source>
          <target state="translated">TZ数据库文件的主页</target>
        </trans-unit>
        <trans-unit id="b3e0a103daa9ae3f375b2654f0a482c7c0d36297" translate="yes" xml:space="preserve">
          <source>Hook</source>
          <target state="translated">Hook</target>
        </trans-unit>
        <trans-unit id="df83ba56b9bf84a7f6828386bfb0ec0b4ea31298" translate="yes" xml:space="preserve">
          <source>Hook &lt;strong id=&quot;hook&quot;&gt;hook&lt;/strong&gt;;</source>
          <target state="translated">勾&lt;strong id=&quot;hook&quot;&gt;勾&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c491dcee1ba5406ded29938b72d3efa58c8898bc" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values, for example &lt;code&gt;0u &amp;lt; -1&lt;/code&gt;. The call &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; is smaller than &lt;code&gt;y&lt;/code&gt; in abstract arithmetic sense.</source>
          <target state="translated">钩上 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; ，以确保与整数值进行比较具有常规算术规则所期望的行为。当将带符号的值与无符号的值进行比较时，例如 &lt;code&gt;0u &amp;lt; -1&lt;/code&gt; ，内置语义产生令人惊讶的行为。当且仅当 &lt;code&gt;x&lt;/code&gt; 在抽象算术意义上小于 &lt;code&gt;y&lt;/code&gt; 时，调用 &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cf42c2609ccf8480c4c29b09d1eeb015d535402" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values for equality, for example &lt;code&gt;uint.max == -1&lt;/code&gt; or &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt;. The call &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent the same arithmetic number.</source>
          <target state="translated">确保 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 的钩子确保与整数值进行比较具有常规算术规则期望的行为。当将带符号的值与无符号的值进行相等性比较时，内置语义会产生令人惊讶的行为，例如 &lt;code&gt;uint.max == -1&lt;/code&gt; 或 &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt; 。当且仅当 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 表示相同的算术数时 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 调用hookOpEquals（x，y）才返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="041c61fdd24218cf59730fd0cdbaa1de754b6893" translate="yes" xml:space="preserve">
          <source>Hook that implements</source>
          <target state="translated">实现的钩子</target>
        </trans-unit>
        <trans-unit id="b449d04fd061c7af394902d015ecf01abcf02e96" translate="yes" xml:space="preserve">
          <source>Hook that prints to &lt;code&gt;stderr&lt;/code&gt; a trace of all integral errors, without affecting default behavior.</source>
          <target state="translated">该钩子将向 &lt;code&gt;stderr&lt;/code&gt; 显示所有积分错误的痕迹，而不会影响默认行为。</target>
        </trans-unit>
        <trans-unit id="efbf28167139074d8823a898190b189c85ea78aa" translate="yes" xml:space="preserve">
          <source>Hook that provides arithmetically correct comparisons for equality and ordering. Comparing an object of type &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; against another integral (for equality or ordering) ensures that no surprising conversions from signed to unsigned integral occur before the comparison. Using &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; on either side of a comparison for equality against a floating-point number makes sure the integral can be properly converted to the floating point type, thus making sure equality is transitive.</source>
          <target state="translated">挂钩为相等性和顺序提供了算术上正确的比较。将类型为 &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; 与另一个整数（用于相等性或有序性）进行比较，可确保在比较之前不会发生从有符号到无符号整数的任何令人惊讶的转换。在比较的任一侧使用 &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; 与浮点数进行相等性可确保将整数正确转换为浮点类型，从而确保相等性是可传递的。</target>
        </trans-unit>
        <trans-unit id="d806e6661a85f88dc9eaa221319b2117db0f755d" translate="yes" xml:space="preserve">
          <source>Hook that reserves a special value as a &quot;Not a Number&quot; representative. For signed integrals, the reserved value is &lt;code&gt;T.min&lt;/code&gt;. For signed integrals, the reserved value is &lt;code&gt;T.max&lt;/code&gt;.</source>
          <target state="translated">保留特殊值的挂钩作为&amp;ldquo;非数字&amp;rdquo;代表。对于有符号积分，保留值为 &lt;code&gt;T.min&lt;/code&gt; 。对于有符号积分，保留值为 &lt;code&gt;T.max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33488d4b3cbb5ba16b0673469e60db7094fb670e" translate="yes" xml:space="preserve">
          <source>Horizontal Rules</source>
          <target state="translated">横向规则</target>
        </trans-unit>
        <trans-unit id="7212f381e90838fabdee36fb0501fbba0ed9cd58" translate="yes" xml:space="preserve">
          <source>Horizontal tab</source>
          <target state="translated">水平标签</target>
        </trans-unit>
        <trans-unit id="3ac6fafe4ab0f338471b45cb71f20d044e5f5cc2" translate="yes" xml:space="preserve">
          <source>Horizontal tab (U+0009).</source>
          <target state="translated">水平标签(U+0009)。</target>
        </trans-unit>
        <trans-unit id="bbb1b4f452c31b5eb2b5c0983d50e71cb342831f" translate="yes" xml:space="preserve">
          <source>Host compiler vendor string and language version.</source>
          <target state="translated">主机编译器供应商字符串和语言版本。</target>
        </trans-unit>
        <trans-unit id="e118cd39d323f526da5b0f63e4f3c3b86e96af36" translate="yes" xml:space="preserve">
          <source>Hour of the day [0 - 24).</source>
          <target state="translated">一天中的一个小时[0-24]。</target>
        </trans-unit>
        <trans-unit id="47f45a8e9beb5422f5775e424c56239ab38cf0a6" translate="yes" xml:space="preserve">
          <source>Hours past midnight.</source>
          <target state="translated">午夜过后的时间。</target>
        </trans-unit>
        <trans-unit id="aea1f84448c4cd135127feb893d3e5b86649ead7" translate="yes" xml:space="preserve">
          <source>How Garbage Collection Works</source>
          <target state="translated">垃圾回收的方法</target>
        </trans-unit>
        <trans-unit id="5e1ecfe3dd4c1b701a8f4295c2bd308de6db519e" translate="yes" xml:space="preserve">
          <source>How a socket is shutdown:</source>
          <target state="translated">插座是如何关闭的。</target>
        </trans-unit>
        <trans-unit id="14072cd783ee679dcd4faa9d6011722e64957f7d" translate="yes" xml:space="preserve">
          <source>How does this meet our assumptions about errors?</source>
          <target state="translated">这如何满足我们对错误的假设?</target>
        </trans-unit>
        <trans-unit id="2cef028c4c427db32ab248fb0fa09f711b8938d4" translate="yes" xml:space="preserve">
          <source>How does this meet our criteria?</source>
          <target state="translated">这怎么符合我们的标准呢?</target>
        </trans-unit>
        <trans-unit id="46c019e7726b602bf175d16d3e47d3c9855717af" translate="yes" xml:space="preserve">
          <source>How much &lt;code&gt;r&lt;/code&gt; was actually advanced, which may be less than &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; did not have at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">很多如何 &lt;code&gt;r&lt;/code&gt; 竟是先进，这可能小于 &lt;code&gt;n&lt;/code&gt; 如果 &lt;code&gt;r&lt;/code&gt; 没有至少有 &lt;code&gt;n&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="39a1caec9f5c9eff0c38eb6253af004f14eeaf48" translate="yes" xml:space="preserve">
          <source>How the deprecation messages are presented to the user.</source>
          <target state="translated">如何向用户展示废弃信息。</target>
        </trans-unit>
        <trans-unit id="45ad0b30a0ba21c8300555e31b930fb7fa5c8e56" translate="yes" xml:space="preserve">
          <source>How to check an entire string</source>
          <target state="translated">如何检查整个字符串</target>
        </trans-unit>
        <trans-unit id="3944bdd486c5b281b0d76b6fea24f7aa42d88928" translate="yes" xml:space="preserve">
          <source>However for class types, identity assignment is not allowed. All class types have reference semantics, so identity assignment by default rebinds the left-hand-side to the argument at the right, and this is not overridable.</source>
          <target state="translated">然而对于类类型,身份赋值是不允许的。所有的类类型都有引用语义,所以身份赋值默认会将左边的参数重新绑定到右边的参数上,这一点是不可覆盖的。</target>
        </trans-unit>
        <trans-unit id="d81485ead3a03b09d4ef041206a388f9ba3d1726" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; does allow reassignment, while otherwise behaving exactly like a &lt;code&gt;const Widget&lt;/code&gt;.</source>
          <target state="translated">但是， &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; 确实允许重新分配，而其他方面的行为与 &lt;code&gt;const Widget&lt;/code&gt; 完全一样。</target>
        </trans-unit>
        <trans-unit id="39fcf81b03ae2153072256cf5c2ed783812c0162" translate="yes" xml:space="preserve">
          <source>However, if the AA element type is a struct which supports an implicit constructor call from the assigned value, implicit construction is used for setting the AA entry:</source>
          <target state="translated">但是,如果AA元素类型是支持从赋值中调用隐式构造函数的结构体,则在设置AA条目时使用隐式构造。</target>
        </trans-unit>
        <trans-unit id="be6cc5f771eb95dadab03bad5c4c89972ffb70a4" translate="yes" xml:space="preserve">
          <source>However, in &lt;code&gt;-betterC&lt;/code&gt;&lt;code&gt;assert&lt;/code&gt; expressions don't use Druntime's assert and are directed to &lt;code&gt;assert&lt;/code&gt; of the C runtime library instead.</source>
          <target state="translated">但是，在 &lt;code&gt;-betterC&lt;/code&gt; 中, &lt;code&gt;assert&lt;/code&gt; 表达式不使用Druntime的断言，而是直接转为C运行时库的 &lt;code&gt;assert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a66b8122994e01e172373073ab6d4fa34b94942" translate="yes" xml:space="preserve">
          <source>However, it should be noted that the time zone information on Windows is frequently less accurate than that in the IANA time zone database, and if someone really wants accurate time zone information, they should use the IANA time zone database files with &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Windows rather than &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, whereas &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt; makes more sense when trying to match what Windows will think the time is in a specific time zone.</source>
          <target state="translated">但是，应该注意的是，Windows上的时区信息通常不如IANA时区数据库中的准确，并且如果有人真的想要准确的时区信息，他们应该将IANA时区数据库文件与Windows 上的&lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt;一起使用。比&lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt;更好，而&lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt;在尝试匹配Windows认为时间在特定时区时更有意义。</target>
        </trans-unit>
        <trans-unit id="6fe9389c4ddd121d6493079f489aee81befd5618" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Daylight Time). Regardless, it is not the same as name.</source>
          <target state="translated">然而,在Windows上,它可能是不加缩写的名称(如太平洋夏令时)。无论如何,它与名称是不一样的。</target>
        </trans-unit>
        <trans-unit id="47c13d8e213a10f9001fd45644c1b3afeb68823d" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Standard Time). Regardless, it is not the same as name.</source>
          <target state="translated">然而,在Windows上,它可能是不加缩写的名称(如太平洋标准时间)。无论如何,它与名称是不一样的。</target>
        </trans-unit>
        <trans-unit id="eff8dd0f2d633371467a00fc8759aea595ab2872" translate="yes" xml:space="preserve">
          <source>However, when doing overload resolution, the functions in the base class are not considered:</source>
          <target state="translated">但在做重载解析时,不考虑基类中的函数。</target>
        </trans-unit>
        <trans-unit id="599b7a863c6a59d1092f07e1710589a8785bdb8d" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 address in dotted-decimal form.</source>
          <target state="translated">人可读的字符串,以点-十进制形式表示IPv4地址。</target>
        </trans-unit>
        <trans-unit id="aff39bc2ec043587101457aaa3ae19023826875e" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 port.</source>
          <target state="translated">代表IPv4端口的可读字符串。</target>
        </trans-unit>
        <trans-unit id="a79746cad8ecf9d33b60d8dd5347136a9d85ef98" translate="yes" xml:space="preserve">
          <source>Human readable string representing this address.</source>
          <target state="translated">代表该地址的人类可读字符串。</target>
        </trans-unit>
        <trans-unit id="4c4d996a690c3ac43662d610a18221ccc97faec3" translate="yes" xml:space="preserve">
          <source>Hyphen</source>
          <target state="translated">Hyphen</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="47af55839c3e9c9ba933349c6295cd1ce082a6a3" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;im&lt;/code&gt;</source>
          <target state="translated">我 &lt;code&gt;im&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84ff080e0a1bf2c778d5efdc523acd4678a5928f" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;sizes&lt;/code&gt;</source>
          <target state="translated">我 &lt;code&gt;sizes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4ce4e386de11613809ef416e70170284dffb219" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;startingIndex&lt;/code&gt;</source>
          <target state="translated">我 &lt;code&gt;startingIndex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3df1df26aa4ea931d9e988f62da215ed0c3e81a7" translate="yes" xml:space="preserve">
          <source>I came, I coded, I crashed.</source>
          <target state="translated">我来了,我编码了,我崩溃了。</target>
        </trans-unit>
        <trans-unit id="81cb37800b131d16bca390e388601790ff6f313b" translate="yes" xml:space="preserve">
          <source>I.e. is it a single return statement or some compound statement that unconditionally hits a return statement.</source>
          <target state="translated">即是单一的返回语句还是一些复合语句,无条件的打一个返回语句。</target>
        </trans-unit>
        <trans-unit id="d8212950b3ac05f1c5deaff0d3a32ce51c051e7f" translate="yes" xml:space="preserve">
          <source>I/O operation successful</source>
          <target state="translated">I/O操作成功</target>
        </trans-unit>
        <trans-unit id="a07107356f25616c07b6fd35ca4ce30f409251c5" translate="yes" xml:space="preserve">
          <source>IBM Advanced Interactive eXecutive OS</source>
          <target state="translated">IBM Advanced Interactive eXecutive OS</target>
        </trans-unit>
        <trans-unit id="7e73f4b459341f6552e0a60723ed4f4fb582c963" translate="yes" xml:space="preserve">
          <source>IDS_Binary_Operator</source>
          <target state="translated">IDS_Binary_Operator</target>
        </trans-unit>
        <trans-unit id="dfddbbc74d0d43db63cde2a6e1024f6ba8221fff" translate="yes" xml:space="preserve">
          <source>IDS_Trinary_Operator</source>
          <target state="translated">IDS_Trinary_Operator</target>
        </trans-unit>
        <trans-unit id="0a50f9983af5839dd0d0dc6f249331d57b64db6f" translate="yes" xml:space="preserve">
          <source>ID_Continue</source>
          <target state="translated">ID_Continue</target>
        </trans-unit>
        <trans-unit id="92936d6f1e8f3e471e6f43d46a9887af5d007bd8" translate="yes" xml:space="preserve">
          <source>ID_Start</source>
          <target state="translated">ID_Start</target>
        </trans-unit>
        <trans-unit id="3f4e414c32b3902ba3f69c8b82e07f90e3313525" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic can set several flags based on what happened with a computation:</source>
          <target state="translated">IEEE 754浮点运算可以根据计算的情况设置几个标志。</target>
        </trans-unit>
        <trans-unit id="ca31149be1b5f9a497eaee503fda4915c7e1c829" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic includes the ability to set 4 different rounding modes. These are accessible via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">IEEE 754浮点算法包括设置4种不同舍入模式的能力。这些可以通过 &lt;code&gt;core.stdc.fenv&lt;/code&gt; 中的函数进行访问。</target>
        </trans-unit>
        <trans-unit id="c9fbff470ecc71dad6d33f5eeaccc83f4e863050" translate="yes" xml:space="preserve">
          <source>IEEE exception status flags ('sticky bits')</source>
          <target state="translated">IEEE异常状态标志('粘性位')</target>
        </trans-unit>
        <trans-unit id="a2584841fe85abc74e15db0f23c9cdba2dd8ab2a" translate="yes" xml:space="preserve">
          <source>IEEE hardware exceptions. By default, all exceptions are masked (disabled).</source>
          <target state="translated">IEEE硬件异常。默认情况下,所有的异常都被屏蔽(禁用)。</target>
        </trans-unit>
        <trans-unit id="b9e2d958b9ca41f87ae15ec8c35999c50ae4ff8c" translate="yes" xml:space="preserve">
          <source>IEEE rounding modes. The default mode is roundToNearest.</source>
          <target state="translated">IEEE取整模式。默认模式是roundToNearest。</target>
        </trans-unit>
        <trans-unit id="7d81343ef8eab15b8d8f8c68c7c8bdb404ed88bb" translate="yes" xml:space="preserve">
          <source>ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt;;</source>
          <target state="translated">ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="362fa36f30a060b9e1fcf247cb78ff4ce49924f2" translate="yes" xml:space="preserve">
          <source>IMP</source>
          <target state="translated">IMP</target>
        </trans-unit>
        <trans-unit id="bdc4004339f8557d5a75257afe0bb8aef0ebaaba" translate="yes" xml:space="preserve">
          <source>IP multicast hops</source>
          <target state="translated">IP多播跳数</target>
        </trans-unit>
        <trans-unit id="20fe7e463770b20399ece7b586c1bbb5d3def572" translate="yes" xml:space="preserve">
          <source>IP multicast interface</source>
          <target state="translated">IP组播接口</target>
        </trans-unit>
        <trans-unit id="7279e4b3160656f1f51a778df4e83b92cb83cf30" translate="yes" xml:space="preserve">
          <source>IP multicast loopback</source>
          <target state="translated">IP多播环回</target>
        </trans-unit>
        <trans-unit id="9ebd1fbe7ba3cf5bdc775290d0d686e15bf4c0b2" translate="yes" xml:space="preserve">
          <source>IP unicast hop limit</source>
          <target state="translated">IP单播跳数限制</target>
        </trans-unit>
        <trans-unit id="cc01b492cee0acdf48f0b298c26fa47256bd3faf" translate="yes" xml:space="preserve">
          <source>IPA Extensions</source>
          <target state="translated">IPA扩展</target>
        </trans-unit>
        <trans-unit id="80570baac1433d8da38eb560349f85ffa3c24938" translate="yes" xml:space="preserve">
          <source>IPv6 address ends with a single colon</source>
          <target state="translated">IPv6地址以一个冒号结束</target>
        </trans-unit>
        <trans-unit id="f971f61e6734e2eb397d8944032e3b5547c71b4c" translate="yes" xml:space="preserve">
          <source>IPv6 address starts with a single colon</source>
          <target state="translated">IPv6地址以一个冒号开头</target>
        </trans-unit>
        <trans-unit id="ffeae36229b4084ab3f5431d5a5e2894acff57f8" translate="yes" xml:space="preserve">
          <source>IPv6-enabled</source>
          <target state="translated">IPv6-enabled</target>
        </trans-unit>
        <trans-unit id="ae9887477b5a4dc86ce15b0c56db938ec92c9140" translate="yes" xml:space="preserve">
          <source>IRState* &lt;code&gt;irs&lt;/code&gt;</source>
          <target state="translated">IRState * &lt;code&gt;irs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="0f3e173e17d8fbdbf144076143d8cd16c3b60805" translate="yes" xml:space="preserve">
          <source>ISO Week Date</source>
          <target state="translated">ISO周日期</target>
        </trans-unit>
        <trans-unit id="6edb4ac9bcba71ad7ccb4ee02897a84fda819a4e" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)</source>
          <target state="translated">ISO/IEC 9899:1999 (E)</target>
        </trans-unit>
        <trans-unit id="8e40d146e834aa0554ad9d258a39d303ac74b95c" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)  These are the various functions called by the assert() macro. They are all noreturn functions, although D doesn't have a specific attribute for that.</source>
          <target state="translated">ISO/IEC 9899:1999 (E)这些是assert()宏调用的各种函数。它们都是noreturn函数,尽管D没有一个特定的属性。</target>
        </trans-unit>
        <trans-unit id="79c91cb6efbe5dfcc03f77ea0bf59ceecfb03a1b" translate="yes" xml:space="preserve">
          <source>Iain Buclaw</source>
          <target state="translated">Iain Buclaw</target>
        </trans-unit>
        <trans-unit id="a61268b8e652624d626d166308f20560b1d3aa63" translate="yes" xml:space="preserve">
          <source>Id::max or Id::min</source>
          <target state="translated">Id::max或Id::min</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="d884429135c14548b3e978b368447365cb96cfc8" translate="yes" xml:space="preserve">
          <source>Identifier (inside Identifier.idPool) with deterministic name based on the source location.</source>
          <target state="translated">Identifier(在Identifier.idPool内),具有基于源位置的确定性名称。</target>
        </trans-unit>
        <trans-unit id="d39412a656d9c3c7bf8a3a174965f8e76b9c6aae" translate="yes" xml:space="preserve">
          <source>Identifier : NonVoidInitializer</source>
          <target state="translated">Identify:NonVoidInitializer。</target>
        </trans-unit>
        <trans-unit id="2ea823871928966eb34d2d6331730d76f54cfc52" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;id&lt;/code&gt;</source>
          <target state="translated">标识 &lt;code&gt;id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd812024edf80fc26687c86baab342484d1cca2a" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;ident&lt;/code&gt;</source>
          <target state="translated">标识符 &lt;code&gt;ident&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f032313123f1ffabc6636b37a2cdfb763957f48d" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;module_&lt;/code&gt;</source>
          <target state="translated">标识符 &lt;code&gt;module_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff20fb48822c4ece471eaa71420a8e3f17752e0" translate="yes" xml:space="preserve">
          <source>Identifier &lt;strong id=&quot;identifier&quot;&gt;identifier&lt;/strong&gt;;</source>
          <target state="translated">标识符&lt;strong id=&quot;identifier&quot;&gt;标识符&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="964e8904f66adfee7e7841e9b8d4ec24e389fed4" translate="yes" xml:space="preserve">
          <source>Identifier Emphasis</source>
          <target state="translated">识别码 强调</target>
        </trans-unit>
        <trans-unit id="57fd2f9988cc1bead6d88fdd99fa28550daa5071" translate="yes" xml:space="preserve">
          <source>Identifier required for this condition to pass. If &lt;code&gt;null&lt;/code&gt;, this conditiion will use an integer level.</source>
          <target state="translated">此条件通过所需的标识符。如果为 &lt;code&gt;null&lt;/code&gt; ，则此条件将使用整数级别。</target>
        </trans-unit>
        <trans-unit id="72a03d37bdb5a52d9cfa01295909001833684faa" translate="yes" xml:space="preserve">
          <source>Identifier value (e.g. &lt;code&gt;Id.unitTest&lt;/code&gt;) or &lt;code&gt;TOK.identifier&lt;/code&gt;</source>
          <target state="translated">标识符值（例如 &lt;code&gt;Id.unitTest&lt;/code&gt; ）或 &lt;code&gt;TOK.identifier&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22dcd4202be0468eb915e08817484731c04ef629" translate="yes" xml:space="preserve">
          <source>IdentifierList</source>
          <target state="translated">IdentifierList</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="29849b8a9887214097873771c1ada1e4a2b26c67" translate="yes" xml:space="preserve">
          <source>Identifiers in documentation comments that are function parameters or are names that are in scope at the associated declaration are emphasized in the output. This emphasis can take the form of italics, boldface, a hyperlink, etc. How it is emphasized depends on what it is</source>
          <target state="translated">文档注释中作为函数参数的标识符或在相关声明中属于范围的名称在输出中会被强调。这种强调可以采取斜体、粗体、超链接等形式。如何强调取决于它是什么</target>
        </trans-unit>
        <trans-unit id="ee26ed57025d5c31d0bf47a619bdb084494918ff" translate="yes" xml:space="preserve">
          <source>Identifiers start with a letter, &lt;code&gt;_&lt;/code&gt;, or universal alpha, and are followed by any number of letters, &lt;code&gt;_&lt;/code&gt;, digits, or universal alphas. Universal alphas are as defined in ISO/IEC 9899:1999(E) Appendix D of the C99 Standard. Identifiers can be arbitrarily long, and are case sensitive.</source>
          <target state="translated">标识符以字母 &lt;code&gt;_&lt;/code&gt; 或通用字母开头，后跟任意数量的字母 &lt;code&gt;_&lt;/code&gt; ，数字或通用字母。通用alpha定义在C99标准的ISO / IEC 9899：1999（E）附录D中。标识符可以任意长，并且区分大小写。</target>
        </trans-unit>
        <trans-unit id="745651339d520944f46b951509355e65410d85d8" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;ids&lt;/code&gt;</source>
          <target state="translated">标识符* &lt;code&gt;ids&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bce0759953389b7f6673a7b1dcdcbe2f5adafd6" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;pkg_identifiers&lt;/code&gt;</source>
          <target state="translated">标识符* &lt;code&gt;pkg_identifiers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd196121fbac89b149b3c74f08384f1bdda01148" translate="yes" xml:space="preserve">
          <source>Identify Statement types with this enum rather than virtual functions.</source>
          <target state="translated">用这个枚举来识别Statement类型,而不是虚拟函数。</target>
        </trans-unit>
        <trans-unit id="897cc900af9b1d4567cf3ac949c0ce028e5b29c4" translate="yes" xml:space="preserve">
          <source>Identify the characteristics of the host CPU, providing information about cache sizes and assembly optimisation hints. This module is provided primarily for assembly language programmers.</source>
          <target state="translated">识别主机CPU的特性,提供有关缓存大小和汇编优化提示的信息。本模块主要为汇编语言程序员提供。</target>
        </trans-unit>
        <trans-unit id="294c861b2aa613142591a5192af15c07f9d87cde" translate="yes" xml:space="preserve">
          <source>Identify the compiler used and its various features.</source>
          <target state="translated">确定使用的编译器及其各种功能。</target>
        </trans-unit>
        <trans-unit id="2adbbf9ddb856b5eee69eb90a8ddc235f490d75b" translate="yes" xml:space="preserve">
          <source>Identify whether a variable is defined in the environment.</source>
          <target state="translated">识别环境中是否定义了一个变量。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
