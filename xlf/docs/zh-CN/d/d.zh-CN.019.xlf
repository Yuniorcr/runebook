<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="91b5a4505ff4388b543e615403e943b213e146be" translate="yes" xml:space="preserve">
          <source>Enums must have at least one member.</source>
          <target state="translated">Enums必须至少有一个成员。</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="af2c16f78a14f7f4e0c19bb8444d3b5d1ddbd6bc" translate="yes" xml:space="preserve">
          <source>Eponymous Templates</source>
          <target state="translated">同名模板</target>
        </trans-unit>
        <trans-unit id="98960d79731e92f6a1481f64f5023d43b91903f0" translate="yes" xml:space="preserve">
          <source>Equal to &lt;a href=&quot;etc_c_curl#CURLcode&quot;&gt;&lt;code&gt;etc.c.curl.CURLcode&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">等于&lt;a href=&quot;etc_c_curl#CURLcode&quot;&gt; &lt;code&gt;etc.c.curl.CURLcode&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb253eb5985c5dedcf6ea0e168a624316301f2da" translate="yes" xml:space="preserve">
          <source>Equality Expressions</source>
          <target state="translated">平等的表达方式</target>
        </trans-unit>
        <trans-unit id="d0f7f003b5eae761303767b178c5b32ad771e92d" translate="yes" xml:space="preserve">
          <source>Equality comparisons (==, !=, is, !is) are permitted between all pointers, without restriction.</source>
          <target state="translated">所有指针之间允许进行等价比较(==,!=,is,! is),不受限制。</target>
        </trans-unit>
        <trans-unit id="d0efd94caf98a8617b53c3b12681dbbfdad08e3c" translate="yes" xml:space="preserve">
          <source>Equality expressions compare the two operands for equality (&lt;code&gt;==&lt;/code&gt;) or inequality (&lt;code&gt;!=&lt;/code&gt;). The type of the result is &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">相等表达式比较两个操作数是否相等（ &lt;code&gt;==&lt;/code&gt; ）或不相等（ &lt;code&gt;!=&lt;/code&gt; ）。结果的类型为 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a821b59480ce2414bd6165847b5c1fb14cb79065" translate="yes" xml:space="preserve">
          <source>Equivalence is defined by the predicate &lt;code&gt;pred&lt;/code&gt;, which can be either binary, which is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, or unary, which is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;. In the binary form, two range elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if &lt;code&gt;pred(a,b)&lt;/code&gt; is true. In unary form, two elements are considered equivalent if &lt;code&gt;pred(a) == pred(b)&lt;/code&gt; is true.</source>
          <target state="translated">等价由谓词所定义 &lt;code&gt;pred&lt;/code&gt; ，其可以是二进制的，被传递到&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;，或一元，其被传递到&lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt;。如果 &lt;code&gt;pred(a,b)&lt;/code&gt; 为true ，则以二进制形式将两个范围元素 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 视为等效。以一元形式，如果 &lt;code&gt;pred(a) == pred(b)&lt;/code&gt; 为true ，则认为两个元素相等。</target>
        </trans-unit>
        <trans-unit id="f3d4d9eeca49f09a17fcd8a54a0fa4787c33d0da" translate="yes" xml:space="preserve">
          <source>Equivalent elements separated by an intervening non-equivalent element will appear in separate subranges; this function only considers adjacent equivalence. Elements in the subranges will always appear in the same order they appear in the original range.</source>
          <target state="translated">被一个非等价元素隔开的等价元素将出现在不同的子域中;这个函数只考虑相邻的等价元素。子域中的元素将总是以它们在原始范围中出现的顺序出现。</target>
        </trans-unit>
        <trans-unit id="15ed9b5cca8803ef06cb9688dbc5af4fe192a4a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;file.writef(fmt, args, '\n')&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;file.writef(fmt, args, '\n')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce6d1bc952023308db732f8f94e2b34d7940aa93" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fmax(x-y, 0)&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;fmax(x-y, 0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e86802e906e78082747bcdbd4222e541b464705" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;write(args, '\n')&lt;/code&gt;. Calling &lt;code&gt;writeln&lt;/code&gt; without arguments is valid and just prints a newline to the standard output.</source>
          <target state="translated">等效于 &lt;code&gt;write(args, '\n')&lt;/code&gt; 。调用不带参数的 &lt;code&gt;writeln&lt;/code&gt; 是有效的，仅将换行符输出到标准输出。</target>
        </trans-unit>
        <trans-unit id="d1a5bc7d4ab0b05ff1942fc426e894258a7dcb1a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;writef(fmt, args, '\n')&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;writef(fmt, args, '\n')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f2f6a15cf8da2b27e5a4af47b58e7ad71c0b3d9" translate="yes" xml:space="preserve">
          <source>Error</source>
          <target state="translated">Error</target>
        </trans-unit>
        <trans-unit id="c73f93f4b9a02f4e5a949fd11052e3a166c6f2ac" translate="yes" xml:space="preserve">
          <source>Error Codes And Messages</source>
          <target state="translated">错误代码和信息</target>
        </trans-unit>
        <trans-unit id="7fc353a0378a6af6e63cb4e746bbbbd0e56d46cc" translate="yes" xml:space="preserve">
          <source>Error Logging Interface</source>
          <target state="translated">错误记录接口</target>
        </trans-unit>
        <trans-unit id="ebaf4b5ec788b16d6d54392acc5fde873dbc786a" translate="yes" xml:space="preserve">
          <source>Error exceptions get handled one way or another. There is nothing like a NULL pointer return indicating an error, followed by trying to use that NULL pointer.</source>
          <target state="translated">错误异常会得到这样或那样的处理。没有什么比一个NULL指针返回表示错误,然后试图使用这个NULL指针更合适的了。</target>
        </trans-unit>
        <trans-unit id="a623c8e1a198390969227d2d0b456f83bf23e21d" translate="yes" xml:space="preserve">
          <source>Error function</source>
          <target state="translated">错误功能</target>
        </trans-unit>
        <trans-unit id="34d6de902e8eedf56209e7c63d5376af7cf4d10e" translate="yes" xml:space="preserve">
          <source>Error message</source>
          <target state="translated">错误信息</target>
        </trans-unit>
        <trans-unit id="50c855f2252890155a086cc4373ee4123aab7e7a" translate="yes" xml:space="preserve">
          <source>Error message from sqlite3_mprintf()</source>
          <target state="translated">sqlite3_mprintf()发出的错误信息。</target>
        </trans-unit>
        <trans-unit id="2252ea1e4cbf7755de129147ae3fdbeb59b1c86e" translate="yes" xml:space="preserve">
          <source>ErrorExp</source>
          <target state="translated">ErrorExp</target>
        </trans-unit>
        <trans-unit id="813b5f9ec8deffdd987c925d7e6501434e44711b" translate="yes" xml:space="preserve">
          <source>ErrorExp &lt;strong id=&quot;arrayOpInvalidError&quot;&gt;arrayOpInvalidError&lt;/strong&gt;(Expression e);</source>
          <target state="translated">ErrorExp &lt;strong id=&quot;arrayOpInvalidError&quot;&gt;arrayOpInvalidError&lt;/strong&gt;（表达式e）;</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="36fd0b0b802c6a97f7436e7a54204bfe482a5123" translate="yes" xml:space="preserve">
          <source>Errors are not part of the normal flow of a program. Errors are exceptional, unusual, and unexpected.</source>
          <target state="translated">错误不是程序正常流程的一部分。错误是特殊的、不寻常的和意外的。</target>
        </trans-unit>
        <trans-unit id="e66bc34f0c40669df2318f69c4904fa255dc47c1" translate="yes" xml:space="preserve">
          <source>Errors throw a ZlibException.</source>
          <target state="translated">错误会抛出一个ZlibException。</target>
        </trans-unit>
        <trans-unit id="21208fcb40762782f0bd5de0b94d3c459b091b72" translate="yes" xml:space="preserve">
          <source>Es &lt;code&gt;es&lt;/code&gt;</source>
          <target state="translated">ES &lt;code&gt;es&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="3e13e2405c74a25265ee4e281ccf78feafc5234d" translate="yes" xml:space="preserve">
          <source>Escape Sequences</source>
          <target state="translated">逃逸序列</target>
        </trans-unit>
        <trans-unit id="7a8244906137fd404125079316acd1c376574734" translate="yes" xml:space="preserve">
          <source>Escapes URL strings (converts all letters consider illegal in URLs to their %XX versions). This function returns a new allocated string or NULL if an error occurred.</source>
          <target state="translated">Escapes URL字符串(将所有在URL中被认为是非法的字母转换为它们的%XX版本)。如果发生错误,该函数返回一个新分配的字符串或NULL。</target>
        </trans-unit>
        <trans-unit id="c62c2a45ea9630e69c7b0296a18169ca1da2c6cd" translate="yes" xml:space="preserve">
          <source>Escapes a filename to be used for shell redirection with &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt;转义要用于Shell重定向的文件名。</target>
        </trans-unit>
        <trans-unit id="334839f3a4af8ebe642ad214739fca50dd79b867" translate="yes" xml:space="preserve">
          <source>Escapes an argv-style argument array to be used with &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">转义要与&lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt;一起使用的argv样式的参数数组。</target>
        </trans-unit>
        <trans-unit id="c42e53a2ef68cf047319483e6444a0150025a7f7" translate="yes" xml:space="preserve">
          <source>Essentially just calls &lt;code&gt;checkNestedReference() for each variable reference in &lt;/code&gt;e`.</source>
          <target state="translated">本质上，只需为 &lt;code&gt;checkNestedReference() for each variable reference in &lt;/code&gt; 调用checkNestedReference（）。</target>
        </trans-unit>
        <trans-unit id="37eefc2536d5ec542e4520a234de4d178700f2f2" translate="yes" xml:space="preserve">
          <source>Establish a connection. If the socket is blocking, connect waits for the connection to be made. If the socket is nonblocking, connect returns immediately and the connection attempt is still in progress.</source>
          <target state="translated">建立一个连接。如果套接字是阻塞的,connect会等待连接的建立。如果套接字是非阻塞的,connect会立即返回,连接尝试仍在进行中。</target>
        </trans-unit>
        <trans-unit id="cb2a5e97585ee713b7b435ea0059ffc0b575e976" translate="yes" xml:space="preserve">
          <source>Estimated cost of using this index</source>
          <target state="translated">使用该指数的估计费用</target>
        </trans-unit>
        <trans-unit id="4dc2b41f9f62ae24f4ee1bdb98221a2c0df13e48" translate="yes" xml:space="preserve">
          <source>Ethiopic</source>
          <target state="translated">Ethiopic</target>
        </trans-unit>
        <trans-unit id="50a8bee7f3f7f91e053f811fb77da91693c7dedd" translate="yes" xml:space="preserve">
          <source>Ethiopic Extended</source>
          <target state="translated">埃塞俄比亚语扩展版</target>
        </trans-unit>
        <trans-unit id="0b1c5f04c3cf37f71157c85cf3538322e5bf9da1" translate="yes" xml:space="preserve">
          <source>Ethiopic Extended-A</source>
          <target state="translated">埃塞俄比亚语扩展A</target>
        </trans-unit>
        <trans-unit id="7c8438f345294d8ae21cfe001be4e6de5852f8b9" translate="yes" xml:space="preserve">
          <source>Ethiopic Supplement</source>
          <target state="translated">埃塞俄比亚语补编</target>
        </trans-unit>
        <trans-unit id="ec4e1ce13e95c935383dc5219130b98c64fd292a" translate="yes" xml:space="preserve">
          <source>Evaluate &amp;gt;,&amp;lt;=, etc. Resolves slices before comparing. Returns 0 or 1</source>
          <target state="translated">评估&amp;gt;，&amp;lt;=等。在比较之前解析切片。返回0或1</target>
        </trans-unit>
        <trans-unit id="63a877dc2e3925ab0262cba5e336e32067b1f868" translate="yes" xml:space="preserve">
          <source>Evaluate ==, !=. Resolves slices before comparing. Returns 0 or 1</source>
          <target state="translated">Evaluate ==,!=.在比较之前先解析切片。返回0或1</target>
        </trans-unit>
        <trans-unit id="b8465fee9c60fa18c66485376de57ad47eb492b1" translate="yes" xml:space="preserve">
          <source>Evaluate An SQL Statement</source>
          <target state="translated">评估一条SQL语句</target>
        </trans-unit>
        <trans-unit id="f0a33e70cc28b1c16a65e2ac8b3f23349a36f271" translate="yes" xml:space="preserve">
          <source>Evaluate builtin function. Return result; NULL if cannot evaluate it.</source>
          <target state="translated">评估内置函数。返回结果;如果不能评估,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="ba342f0fe13aca65712f2259febed282817e389a" translate="yes" xml:space="preserve">
          <source>Evaluate is, !is. Resolves slices before comparing. Returns 0 or 1</source>
          <target state="translated">评估是,!是。在比较之前解决切片问题。返回0或1</target>
        </trans-unit>
        <trans-unit id="0dfd6ef81633d9cb47cabec388bec88396961ba5" translate="yes" xml:space="preserve">
          <source>Evaluate polynomial A(x) = a&lt;sub&gt;0&lt;/sub&gt; + a&lt;sub&gt;1&lt;/sub&gt;x + a&lt;sub&gt;2&lt;/sub&gt;x&lt;sup&gt;2&lt;/sup&gt; + a&lt;sub&gt;3&lt;/sub&gt;x&lt;sup&gt;3&lt;/sup&gt;; ...</source>
          <target state="translated">评估多项式A（x）= a &lt;sub&gt;0&lt;/sub&gt; + a &lt;sub&gt;1&lt;/sub&gt; x + a &lt;sub&gt;2&lt;/sub&gt; x &lt;sup&gt;2&lt;/sup&gt; + a &lt;sub&gt;3&lt;/sub&gt; x &lt;sup&gt;3&lt;/sup&gt; ; ...</target>
        </trans-unit>
        <trans-unit id="a5be27aeb62439a889f10e6c829e770637dd9146" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;AliasSeq!(F!(T[0]), F!(T[1]), ..., F!(T[$ - 1]))&lt;/code&gt;.</source>
          <target state="translated">评估为 &lt;code&gt;AliasSeq!(F!(T[0]), F!(T[1]), ..., F!(T[$ - 1]))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9629b284d8cc44b6dfe8df63c6a3f0d4084cc53c" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;doesPointTo(x, x)&lt;/code&gt; checks whether &lt;code&gt;x&lt;/code&gt; has internal pointers. This should only be done as an assertive test, as the language is free to assume objects don't have internal pointers (TDPL 7.1.3.5).</source>
          <target state="translated">评估 &lt;code&gt;doesPointTo(x, x)&lt;/code&gt; 检查 &lt;code&gt;x&lt;/code&gt; 是否具有内部指针。这只能作为一种肯定的测试来完成，因为该语言可以自由地假定对象没有内部指针（TDPL 7.1.3.5）。</target>
        </trans-unit>
        <trans-unit id="0a4344337a70f4c33150fb408f68890c00d456e4" translate="yes" xml:space="preserve">
          <source>Evaluation is</source>
          <target state="translated">评价是</target>
        </trans-unit>
        <trans-unit id="66a21e1a42d0f889ed11cc2d4d6f241490fc741c" translate="yes" xml:space="preserve">
          <source>Evaluation is short-circuited if a true result is encountered; the template predicate must be instantiable with one of the given items.</source>
          <target state="translated">如果遇到真结果,评价就会被短路;模板谓词必须是可实例化的给定项之一。</target>
        </trans-unit>
        <trans-unit id="4d17d4bfeca546c47272dfcbb85f447b4b26bf12" translate="yes" xml:space="preserve">
          <source>Evaluation order of options is &lt;code&gt;rt_options&lt;/code&gt;, then environment variables, then command line arguments, i.e. if command line arguments are not disabled, they can override options specified through the environment or embedded in the executable.</source>
          <target state="translated">选项的评估顺序是 &lt;code&gt;rt_options&lt;/code&gt; ，然后是环境变量，然后是命令行参数，即，如果未禁用命令行参数，则它们可以覆盖通过环境指定或嵌入在可执行文件中的选项。</target>
        </trans-unit>
        <trans-unit id="180eef85054f4fcea96ca798ddcbe7751670c0c9" translate="yes" xml:space="preserve">
          <source>Evaluation value</source>
          <target state="translated">评价值</target>
        </trans-unit>
        <trans-unit id="6f02f12a41e5810b607c7f2ac63bab107ad16369" translate="yes" xml:space="preserve">
          <source>Even if template arguments are implicitly converted to the same template parameter type, they still refer to the same instance. This example uses a &lt;a href=&quot;#aggregate_templates&quot;&gt;&lt;code&gt;struct&lt;/code&gt; template&lt;/a&gt;:</source>
          <target state="translated">即使模板参数被隐式转换为相同的模板参数类型，它们仍然引用相同的实例。本示例使用&lt;a href=&quot;#aggregate_templates&quot;&gt; &lt;code&gt;struct&lt;/code&gt; 模板&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="becac2a7bbc3661ded85df34941db446bcb8fc99" translate="yes" xml:space="preserve">
          <source>Even permutations are useful for generating coordinates of certain geometric shapes. Here's a non-trivial example:</source>
          <target state="translated">即使是排列组合,对于生成某些几何图形的坐标也很有用。这里有一个非平凡的例子。</target>
        </trans-unit>
        <trans-unit id="ff9e5997c4690a9137a05954ed088426938f9897" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;B.foo(int)&lt;/code&gt; is a better match than &lt;code&gt; A.foo(long)&lt;/code&gt; for &lt;code&gt;foo(1)&lt;/code&gt;, it is an error because the two matches are in different overload sets.</source>
          <target state="translated">尽管 &lt;code&gt;B.foo(int)&lt;/code&gt; 是更好的匹配比 &lt;code&gt; A.foo(long)&lt;/code&gt; 为 &lt;code&gt;foo(1)&lt;/code&gt; ，这是一个错误，因为两场比赛都在不同的超载套。</target>
        </trans-unit>
        <trans-unit id="1b34452177e48c546c9017df7b18cba01909144f" translate="yes" xml:space="preserve">
          <source>Even though a new scope is introduced, local symbol declarations cannot shadow (hide) other local symbol declarations in the same function.</source>
          <target state="translated">即使引入了新的作用域,局部符号声明也不能在同一函数中影射(隐藏)其他局部符号声明。</target>
        </trans-unit>
        <trans-unit id="b53b461e5519dc40d2d9c94f0001bf7d1b8053d1" translate="yes" xml:space="preserve">
          <source>Even trivially sub-classing an exception involves writing boilerplate code for the constructor to: 1) correctly pass in the source file and line number the exception was thrown from; 2) be usable with &lt;a href=&quot;#enforce&quot;&gt;&lt;code&gt;enforce&lt;/code&gt;&lt;/a&gt; which expects exception constructors to take arguments in a fixed order. This mixin provides that boilerplate code.</source>
          <target state="translated">即使是对异常进行简单的子类化，都涉及为构造函数编写样板代码，以：1）正确传入异常所源自的源文件和行号；2）可以与&lt;a href=&quot;#enforce&quot;&gt; &lt;code&gt;enforce&lt;/code&gt; &lt;/a&gt;一起使用，该强制期望异常构造函数以固定顺序接受参数。这个mixin提供了样板代码。</target>
        </trans-unit>
        <trans-unit id="646505488568f65dc2d08be5e7c3988051fbafd1" translate="yes" xml:space="preserve">
          <source>Even worse, good error handling code is itself error prone, tends to be the least tested (and therefore buggy) part of the project, and is frequently simply omitted. The end result is likely a &quot;blue screen of death&quot; as the program failed to deal with some unanticipated error.</source>
          <target state="translated">更糟糕的是,好的错误处理代码本身就容易出错,往往是项目中测试最少的(因此也是最容易出错的)部分,而且经常被直接省略。最终的结果很可能是 &quot;蓝屏死机&quot;,因为程序没有处理好一些意料之外的错误。</target>
        </trans-unit>
        <trans-unit id="fd3204ba4b70213492f01a9c5c68e7ab2ed1ff96" translate="yes" xml:space="preserve">
          <source>EvenChunks!Source &lt;strong id=&quot;evenChunks&quot;&gt;evenChunks&lt;/strong&gt;(Source)(Source source, size_t chunkCount)</source>
          <target state="translated">EvenChunks！Source &lt;strong id=&quot;evenChunks&quot;&gt;evenChunks&lt;/strong&gt;（Source）（来源source，size_t chunkCount）</target>
        </trans-unit>
        <trans-unit id="a4a0cc71be8cf518b622bbb5bc79c5bc5de1b789" translate="yes" xml:space="preserve">
          <source>Eventually, the attacker is able to determine the first character in the correct token because the sever takes slightly longer to return a rejection. This is due to the comparison moving on to second item in the two arrays, seeing they are different, and then sending the rejection.</source>
          <target state="translated">最终,攻击者能够确定正确令牌中的第一个字符,因为sever需要稍长的时间来返回拒绝。这是由于比较转到两个数组中的第二项,看到它们不同,然后发送拒绝。</target>
        </trans-unit>
        <trans-unit id="f00b8f841e4cef948de65d22226c93fa103650fa" translate="yes" xml:space="preserve">
          <source>Every data logged to this &lt;code&gt;MultiLogger&lt;/code&gt; will be distributed to all the &lt;code&gt;Logger&lt;/code&gt;s inserted into it. This &lt;code&gt;MultiLogger&lt;/code&gt; implementation can hold multiple &lt;code&gt;Logger&lt;/code&gt;s with the same name. If the method &lt;code&gt;removeLogger&lt;/code&gt; is used to remove a &lt;code&gt;Logger&lt;/code&gt; only the first occurrence with that name will be removed.</source>
          <target state="translated">记录到此 &lt;code&gt;MultiLogger&lt;/code&gt; 的每个数据都将分发到插入其中的所有 &lt;code&gt;Logger&lt;/code&gt; 。此 &lt;code&gt;MultiLogger&lt;/code&gt; 实现可以保存多个具有相同名称的 &lt;code&gt;Logger&lt;/code&gt; 。如果使用 &lt;code&gt;removeLogger&lt;/code&gt; 方法删除 &lt;code&gt;Logger&lt;/code&gt; ,则只会删除该名称的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="4e61dc390abff2fed88336a14c32d2472d4eb8ec" translate="yes" xml:space="preserve">
          <source>Every log message with a &lt;code&gt;LogLevel&lt;/code&gt; lower as the global &lt;code&gt;LogLevel&lt;/code&gt; will be discarded before it reaches &lt;code&gt;writeLogMessage&lt;/code&gt; method of any &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; 较低的全局 &lt;code&gt;LogLevel&lt;/code&gt; 的每条日志消息在到达任何 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;writeLogMessage&lt;/code&gt; 方法之前将被丢弃。</target>
        </trans-unit>
        <trans-unit id="299691262b0966820ccb1f9ef81cef23f22ecbaf" translate="yes" xml:space="preserve">
          <source>Every subclass of &lt;code&gt;Logger&lt;/code&gt; has to call this constructor from their constructor. It sets the &lt;code&gt;LogLevel&lt;/code&gt;, and creates a fatal handler. The fatal handler will throw an &lt;code&gt;Error&lt;/code&gt; if a log call is made with level &lt;code&gt;LogLevel.fatal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 的每个子类都必须从其构造函数中调用此构造函数。它设置 &lt;code&gt;LogLevel&lt;/code&gt; ，并创建一个致命的处理程序。如果使用级别 &lt;code&gt;LogLevel.fatal&lt;/code&gt; 进行日志调用，致命处理程序将抛出 &lt;code&gt;Error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6bc748f9fbc0549e63a017cd5636a311c15fde2" translate="yes" xml:space="preserve">
          <source>Every symbol, type, and expression has properties that can be queried:</source>
          <target state="translated">每个符号、类型和表达式都有可以查询的属性。</target>
        </trans-unit>
        <trans-unit id="b71e20220eb46bc48ab7853c8f64b255dfcc7b90" translate="yes" xml:space="preserve">
          <source>Exact Alias</source>
          <target state="translated">准确的别名</target>
        </trans-unit>
        <trans-unit id="8659b6d121f9dcc98345ea85f4be6011035d4e4c" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;n - 1&lt;/code&gt; comparisons are needed.</source>
          <target state="translated">确实需要 &lt;code&gt;n - 1&lt;/code&gt; 比较。</target>
        </trans-unit>
        <trans-unit id="447595f030e16a9c11484fc6f4099975f890557c" translate="yes" xml:space="preserve">
          <source>Examine function signature for parameter p and see if the value of p can 'escape' the scope of the function. This is useful to minimize the needed annotations for the parameters.</source>
          <target state="translated">检查参数p的函数签名,看看p的值是否可以 &quot;逃脱 &quot;函数的范围。这对于减少参数的注释是很有用的。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3a8d7c39720f8b36996668ba6047e485a42fa9dc" translate="yes" xml:space="preserve">
          <source>Example for reading an existing zip archive:</source>
          <target state="translated">读取现有压缩包的例子。</target>
        </trans-unit>
        <trans-unit id="0c98a62db0de4db40cb83954f78ce2a6a8b61f57" translate="yes" xml:space="preserve">
          <source>Example for writing files into a zip archive:</source>
          <target state="translated">将文件写入zip档案的例子。</target>
        </trans-unit>
        <trans-unit id="c57552c19fd7d2da63a30f68727e3bb36eb45b21" translate="yes" xml:space="preserve">
          <source>Example from &quot;Introduction to Algorithms&quot; Cormen et al, p 146</source>
          <target state="translated">例子来自《算法导论》Cormen等人,第146页。</target>
        </trans-unit>
        <trans-unit id="71d13cfc872d9ac46d96e5966fcea949405ebbc4" translate="yes" xml:space="preserve">
          <source>Example of a simple program printing its stack trace</source>
          <target state="translated">一个简单的程序打印堆栈跟踪的例子</target>
        </trans-unit>
        <trans-unit id="529363f48295f0e991d2c61b1b24a9fe1aecfa01" translate="yes" xml:space="preserve">
          <source>Example predicate that compares individual elements in reverse lexical order</source>
          <target state="translated">按逆向词序比较各个元素的谓词示例。</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用实例。</target>
        </trans-unit>
        <trans-unit id="3ac96cc54ccaf408a3aa9265ec618b7d8d9688f3" translate="yes" xml:space="preserve">
          <source>Example using a custom predicate. Note that the needle appears as the second argument of the predicate.</source>
          <target state="translated">使用自定义谓词的例子。请注意,针作为谓词的第二个参数出现。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7c5d41ac96fe781891640f2cc6ae31d7dac093fe" translate="yes" xml:space="preserve">
          <source>Example: in the expression &lt;code&gt;((f() * 2 &amp;amp;&amp;amp; g()) + 1) || h()&lt;/code&gt;, the smallest short-circuit expression of the subexpression &lt;code&gt;f() * 2&lt;/code&gt; is &lt;code&gt;f() * 2 &amp;amp;&amp;amp; g()&lt;/code&gt;. In the expression &lt;code&gt;(f() &amp;amp;&amp;amp; g()) + h()&lt;/code&gt;, the subexpression &lt;code&gt;h()&lt;/code&gt; has no smallest short-circuit expression.</source>
          <target state="translated">示例：在表达式 &lt;code&gt;((f() * 2 &amp;amp;&amp;amp; g()) + 1) || h()&lt;/code&gt; ，子表达式 &lt;code&gt;f() * 2&lt;/code&gt; 的最小短路表达式是 &lt;code&gt;f() * 2 &amp;amp;&amp;amp; g()&lt;/code&gt; 。在表达式 &lt;code&gt;(f() &amp;amp;&amp;amp; g()) + h()&lt;/code&gt; ，子表达式 &lt;code&gt;h()&lt;/code&gt; 没有最小的短路表达式。</target>
        </trans-unit>
        <trans-unit id="3b6e410f2f289a8e54fbc074511ef251ffbf64e5" translate="yes" xml:space="preserve">
          <source>Example: in the statement &lt;code&gt;return f() + g() * 2;&lt;/code&gt;, the full expression of &lt;code&gt;g() * 2&lt;/code&gt; is &lt;code&gt;f() + g() * 2&lt;/code&gt;, but not the full expression of &lt;code&gt;f() + g()&lt;/code&gt; because the latter is not parsed as a subexpression.</source>
          <target state="translated">示例：在语句中 &lt;code&gt;return f() + g() * 2;&lt;/code&gt; ，则 &lt;code&gt;g() * 2&lt;/code&gt; 的完整表达式为 &lt;code&gt;f() + g() * 2&lt;/code&gt; ，但不是 &lt;code&gt;f() + g()&lt;/code&gt; 的完整表达式，因为后者没有被解析为子表达式。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2b57735b929f758540f6f204a80a85ed5455f140" translate="yes" xml:space="preserve">
          <source>Exception Flags</source>
          <target state="translated">异常标志</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="8e3da5af2290e454a8dda9f1e0d4340536bda871" translate="yes" xml:space="preserve">
          <source>Exception allocation, cloning, and release compiler support routines.</source>
          <target state="translated">异常分配、克隆和释放编译器支持例程。</target>
        </trans-unit>
        <trans-unit id="fffb66a488035e580bbe4d9dfb0563a4cf976029" translate="yes" xml:space="preserve">
          <source>Exception containing the row and column for when an exception was thrown.</source>
          <target state="translated">异常包含了异常发生时的行和列。</target>
        </trans-unit>
        <trans-unit id="04ccd57adc7199b9320005b31e59d240c692ae76" translate="yes" xml:space="preserve">
          <source>Exception handling is done with the try-catch-finally statement.</source>
          <target state="translated">异常处理是通过try-catch-finally语句完成的。</target>
        </trans-unit>
        <trans-unit id="5dd8fbbbac9a5ffa8a85c3407866002bfd2a943a" translate="yes" xml:space="preserve">
          <source>Exception handling is supported. Evaluates to &lt;code&gt;false&lt;/code&gt; when compiling with command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">支持异常处理。使用命令行开关&lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;编译时评估为 &lt;code&gt;false&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7977347a7a7188c09ab63d88a93b935cd78760c4" translate="yes" xml:space="preserve">
          <source>Exception handling method</source>
          <target state="translated">异常处理方法</target>
        </trans-unit>
        <trans-unit id="989c0eb85b5a41ecfef7a4557f1cdced37ec6bb0" translate="yes" xml:space="preserve">
          <source>Exception handling stack unwinding is a relatively slow process.</source>
          <target state="translated">异常处理堆栈解除是一个相对缓慢的过程。</target>
        </trans-unit>
        <trans-unit id="d5701a5b5f69ab1f2d7097d5d051b3d32981e410" translate="yes" xml:space="preserve">
          <source>Exception handling support for Dwarf-style portable exceptions.</source>
          <target state="translated">支持Dwarf风格的可移植异常处理。</target>
        </trans-unit>
        <trans-unit id="9829d9ff9d8698ea752a98d4a92c4ea756a83270" translate="yes" xml:space="preserve">
          <source>Exception if it fails.</source>
          <target state="translated">如果失败,则出现异常。</target>
        </trans-unit>
        <trans-unit id="a3fa8f21629b3a2bb2c1e659bd0f396554feda8e" translate="yes" xml:space="preserve">
          <source>Exception if there is an error while parsing the given XML.</source>
          <target state="translated">如果在解析给定的XML时出现错误,则出现异常。</target>
        </trans-unit>
        <trans-unit id="04d466ab829f02b64659284da536680cd0cead15" translate="yes" xml:space="preserve">
          <source>Exception interoperability is a work in progress.</source>
          <target state="translated">例外互操作性是一项正在进行的工作。</target>
        </trans-unit>
        <trans-unit id="ac3a987430d7002abc0aeb021e7b76ae195d4418" translate="yes" xml:space="preserve">
          <source>Exception object thrown in case of errors during regex compilation.</source>
          <target state="translated">在regex编译过程中发生错误时抛出的异常对象。</target>
        </trans-unit>
        <trans-unit id="d3b36ed4e90f7895ab9c1f841d81e354fcc19912" translate="yes" xml:space="preserve">
          <source>Exception thrown for file I/O errors.</source>
          <target state="translated">因文件I/O错误而引发的异常。</target>
        </trans-unit>
        <trans-unit id="cb3e9f844a01a0b96967f3dd6a290735d00840ed" translate="yes" xml:space="preserve">
          <source>Exception thrown on HTTP request failures, e.g. 404 Not Found.</source>
          <target state="translated">在HTTP请求失败时抛出的异常,如404 Not Found。</target>
        </trans-unit>
        <trans-unit id="bfe22b35920246b957f97d99d530bac8696b368e" translate="yes" xml:space="preserve">
          <source>Exception thrown on JSON errors</source>
          <target state="translated">JSON错误时产生的异常</target>
        </trans-unit>
        <trans-unit id="a84a6e62adad93da512146dbeb0d45a3dc267b49" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.net.curl functions.</source>
          <target state="translated">在std.net.curl函数出错时产生异常。</target>
        </trans-unit>
        <trans-unit id="253a6febbe3430c64130d06fa5981a03478c1db8" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.string functions.</source>
          <target state="translated">在std.string函数出错时产生异常。</target>
        </trans-unit>
        <trans-unit id="da2cac7a810249d2d11cee22b4057ecee00f3eee" translate="yes" xml:space="preserve">
          <source>Exception thrown on errors in std.utf functions.</source>
          <target state="translated">在std.utf函数出错时产生的异常。</target>
        </trans-unit>
        <trans-unit id="8b5a2ac6072f2d36ac52160e487df22a74f63da3" translate="yes" xml:space="preserve">
          <source>Exception thrown on timeout errors in std.net.curl functions.</source>
          <target state="translated">在std.net.curl函数中出现超时错误时引发的异常。</target>
        </trans-unit>
        <trans-unit id="5a4bbb2d3d63ddeb86708dd8ce427adf6b7d165d" translate="yes" xml:space="preserve">
          <source>Exception thrown under different conditions based on the type of &lt;code&gt; Contents&lt;/code&gt;.</source>
          <target state="translated">根据 &lt;code&gt; Contents&lt;/code&gt; 类型在不同条件下引发的异常。</target>
        </trans-unit>
        <trans-unit id="0b352a0dfd2cdf2adffdd6d799e3b32a8a9e3145" translate="yes" xml:space="preserve">
          <source>Exception thrown upon encountering Base64 encoding or decoding errors.</source>
          <target state="translated">遇到Base64编码或解码错误时产生的异常。</target>
        </trans-unit>
        <trans-unit id="66069ad3e21b6e2e8b6ef96e5b841bffb3ffeb38" translate="yes" xml:space="preserve">
          <source>Exception thrown when a Token is identified to not be completed: a quote is found in an unquoted field, data continues after a closing quote, or the quoted field was not closed before data was empty.</source>
          <target state="translated">当一个Token被识别为未完成时,抛出异常:在一个未引用的字段中发现引用,数据在关闭引用后继续,或引用字段在数据为空之前未关闭。</target>
        </trans-unit>
        <trans-unit id="905fb856166761ef9b7e30ba12340557f71b5efe" translate="yes" xml:space="preserve">
          <source>Exception type thrown upon any failure.</source>
          <target state="translated">失败时抛出的异常类型。</target>
        </trans-unit>
        <trans-unit id="f1d0d4844845d6b370b77234d0e77115c51b19af" translate="yes" xml:space="preserve">
          <source>Exception type to throw if the value evaluates to false.</source>
          <target state="translated">当值为false时,抛出的异常类型。</target>
        </trans-unit>
        <trans-unit id="f928a890db6dee56e7f09963fd1b5750c95236a4" translate="yes" xml:space="preserve">
          <source>Exception type used by core.time.</source>
          <target state="translated">core.time.使用的异常类型。</target>
        </trans-unit>
        <trans-unit id="653b9fe3f50eddc9f59c435dd81774a198a4bfb2" translate="yes" xml:space="preserve">
          <source>Exception type used by std.datetime. It's an alias to &lt;a href=&quot;core_time#TimeException&quot;&gt;&lt;code&gt;core.time.TimeException&lt;/code&gt;&lt;/a&gt;. Either can be caught without concern about which module it came from.</source>
          <target state="translated">std.datetime使用的异常类型。它是&lt;a href=&quot;core_time#TimeException&quot;&gt; &lt;code&gt;core.time.TimeException&lt;/code&gt; &lt;/a&gt;的别名。任何一种都可以捕获，而不必担心它来自哪个模块。</target>
        </trans-unit>
        <trans-unit id="15839feb51f6c7eb57eb20c2122df74004e3811b" translate="yes" xml:space="preserve">
          <source>ExceptionHeader to free</source>
          <target state="translated">ExceptionHeader释放</target>
        </trans-unit>
        <trans-unit id="668deca20711f80b1c2101115452f3a6ad56520b" translate="yes" xml:space="preserve">
          <source>ExceptionHeader* &lt;code&gt;eh&lt;/code&gt;</source>
          <target state="translated">ExceptionHeader * &lt;code&gt;eh&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="787a8beff59b551fcef4298de1a9187c800df51d" translate="yes" xml:space="preserve">
          <source>Exchange &lt;code&gt;exchangeWith&lt;/code&gt; with the memory referenced by &lt;code&gt;here&lt;/code&gt;. This operation is both lock-free and atomic.</source>
          <target state="translated">与 &lt;code&gt;here&lt;/code&gt; 引用的内存交换 &lt;code&gt;exchangeWith&lt;/code&gt; 。此操作既无锁又是原子的。</target>
        </trans-unit>
        <trans-unit id="947665622c6a0247540f1769e4059f113b774915" translate="yes" xml:space="preserve">
          <source>Execute and wait for completion, collect output</source>
          <target state="translated">执行并等待完成,收集输出</target>
        </trans-unit>
        <trans-unit id="9c247b36eae520ff5acf986006d217ce9ca4609a" translate="yes" xml:space="preserve">
          <source>Execute any unittests present. For each that fails, print the stack trace and continue.</source>
          <target state="translated">执行任何存在的单元测试。对于每一个失败的单元测试,打印堆栈跟踪并继续执行。</target>
        </trans-unit>
        <trans-unit id="9bf71057cfbf7879eaf07dde87aff1966a094423" translate="yes" xml:space="preserve">
          <source>Executed expressions may not reference any global or local static variables.</source>
          <target state="translated">执行的表达式不得引用任何全局或局部静态变量。</target>
        </trans-unit>
        <trans-unit id="6f05efa3a0f330761f283964056bd4c437269064" translate="yes" xml:space="preserve">
          <source>Executes and returns one of a collection of handlers based on the type of the switch object.</source>
          <target state="translated">执行并返回基于开关对象类型的处理程序集合中的一个。</target>
        </trans-unit>
        <trans-unit id="b2e599dd9da60b7076bf647f704ce6535a25f893" translate="yes" xml:space="preserve">
          <source>Executes the given program or shell command and returns its exit code and output.</source>
          <target state="translated">执行给定的程序或shell命令,并返回其退出代码和输出。</target>
        </trans-unit>
        <trans-unit id="67781825ef8399fa41b8bb55aee1e69bf3a817d6" translate="yes" xml:space="preserve">
          <source>Executes the supplied function in a new logical thread represented by &lt;code&gt;Tid&lt;/code&gt;. The calling thread is designated as the owner of the new thread. When the owner thread terminates an &lt;code&gt;OwnerTerminated&lt;/code&gt; message will be sent to the new thread, causing an &lt;code&gt;OwnerTerminated&lt;/code&gt; exception to be thrown on &lt;code&gt;receive()&lt;/code&gt;.</source>
          <target state="translated">在以 &lt;code&gt;Tid&lt;/code&gt; 表示的新逻辑线程中执行提供的功能。调用线程被指定为新线程的所有者。当所有者线程终止时， &lt;code&gt;OwnerTerminated&lt;/code&gt; 消息将发送到新线程，从而导致对 &lt;code&gt;receive()&lt;/code&gt; 抛出 &lt;code&gt;OwnerTerminated&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="89a3e381c5ed655eb3aa0b9b587d8ce12bdc9bba" translate="yes" xml:space="preserve">
          <source>Executes the supplied function in a new logical thread represented by Tid. This new thread is linked to the calling thread so that if either it or the calling thread terminates a LinkTerminated message will be sent to the other, causing a LinkTerminated exception to be thrown on receive(). The owner relationship from spawn() is preserved as well, so if the link between threads is broken, owner termination will still result in an OwnerTerminated exception to be thrown on receive().</source>
          <target state="translated">在一个由Tid表示的新逻辑线程中执行所提供的函数。这个新线程与调用线程相连,因此,如果它或调用线程中的任何一个线程终止,都会向另一个线程发送LinkTerminated消息,导致在receive()上抛出LinkTerminated异常。spawn()中的所有者关系也被保留下来,所以如果线程之间的链接被破坏,所有者终止仍然会导致在receive()上抛出一个OwnerTerminated异常。</target>
        </trans-unit>
        <trans-unit id="9a3ee996ad5df75a0a1bb42a960cc73553d41928" translate="yes" xml:space="preserve">
          <source>Executing functions via CTFE can take considerably longer than executing it at run time. If the function goes into an infinite loop, it will hang at compile time (rather than hanging at run time).</source>
          <target state="translated">通过CTFE执行函数的时间可能比在运行时执行它的时间长得多。如果函数进入无限循环,它将在编译时挂起(而不是在运行时挂起)。</target>
        </trans-unit>
        <trans-unit id="b3ad6d830cba01933bdd4eadf0962b5afcdb48bf" translate="yes" xml:space="preserve">
          <source>Execution of a single thread on thread-local and immutable memory locations is</source>
          <target state="translated">单线程在线程本地和不可变的内存位置上的执行情况是</target>
        </trans-unit>
        <trans-unit id="5b3292962bd3ae1aa2ceee38161b97042acb69b4" translate="yes" xml:space="preserve">
          <source>Expand alias this tuples.</source>
          <target state="translated">展开别名这个tuples。</target>
        </trans-unit>
        <trans-unit id="dfc518ef6c3dabb73461eac4a36f80d62e55ffe4" translate="yes" xml:space="preserve">
          <source>Expand any response files in command line. Response files are arguments that look like: @NAME The name is first searched for in the environment. If it is not there, it is searched for as a file name. Arguments are separated by spaces, tabs, or newlines. These can be imbedded within arguments by enclosing the argument in '' or &quot;&quot;. Recursively expands nested response files.</source>
          <target state="translated">在命令行中展开任何响应文件。响应文件是像这样的参数。@NAME 首先在环境中搜索名称。如果它不在那里,则作为文件名进行搜索。参数由空格、制表符或换行符分隔。这些可以通过用''或&quot;&quot;包围参数来嵌入到参数中。递归地展开嵌套的响应文件。</target>
        </trans-unit>
        <trans-unit id="39c5e7d251d329155aba4b991a2b7a09613fc576" translate="yes" xml:space="preserve">
          <source>Expand tuples.</source>
          <target state="translated">展开元组。</target>
        </trans-unit>
        <trans-unit id="308231a343f14ac3d5860b3570b1a37c81713ba1" translate="yes" xml:space="preserve">
          <source>Expanded Data.</source>
          <target state="translated">扩展数据。</target>
        </trans-unit>
        <trans-unit id="a3ed1860547be833e11502cb37798024cc995fdb" translate="yes" xml:space="preserve">
          <source>Expands &lt;code&gt;b&lt;/code&gt; by &lt;code&gt;delta&lt;/code&gt; bytes. If &lt;code&gt;delta == 0&lt;/code&gt;, succeeds without changing &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b is null&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt; (the null pointer cannot be expanded in place). Otherwise, &lt;code&gt;b&lt;/code&gt; must be a buffer previously allocated with the same allocator. If expansion was successful, &lt;code&gt;expand&lt;/code&gt; changes &lt;code&gt;b&lt;/code&gt;'s length to &lt;code&gt;b.length + delta&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Upon failure, the call effects no change upon the allocator object, leaves &lt;code&gt;b&lt;/code&gt; unchanged, and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">膨胀 &lt;code&gt;b&lt;/code&gt; 通过 &lt;code&gt;delta&lt;/code&gt; 字节。如果 &lt;code&gt;delta == 0&lt;/code&gt; ，则不更改 &lt;code&gt;b&lt;/code&gt; 即可成功。如果 &lt;code&gt;b is null&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt; （无法将null指针扩展到位）。否则， &lt;code&gt;b&lt;/code&gt; 必须是先前使用相同分配器分配的缓冲区。如果扩张成功， &lt;code&gt;expand&lt;/code&gt; 改变 &lt;code&gt;b&lt;/code&gt; 的长度 &lt;code&gt;b.length + delta&lt;/code&gt; ，并返回 &lt;code&gt;true&lt;/code&gt; 。失败时，该调用不会对分配器对象产生任何影响，使 &lt;code&gt;b&lt;/code&gt; 保持不变，并返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2b86b700bfa590be9e2b589c48ee8ac8959eaae" translate="yes" xml:space="preserve">
          <source>Expands a memory block in place and returns &lt;code&gt;true&lt;/code&gt; if successful. Implementations that don't support this primitive should always return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在适当的位置扩展存储块，如果成功，则返回 &lt;code&gt;true&lt;/code&gt; 。不支持该原语的实现应始终返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b262eee9273f1fc433f6691461d187672e0c5b45" translate="yes" xml:space="preserve">
          <source>Expands an allocated block in place. Expansion will succeed only if the block is the last allocated.</source>
          <target state="translated">原地展开已分配的块。只有当该块是最后一个被分配的块时,扩展才会成功。</target>
        </trans-unit>
        <trans-unit id="626d5a99aecb87499fb1f3a504d6e69914d2e4c6" translate="yes" xml:space="preserve">
          <source>Expands an allocated block in place. Expansion will succeed only if the block is the last allocated. Defined only if &lt;code&gt;growDownwards&lt;/code&gt; is &lt;code&gt;No.growDownwards&lt;/code&gt;.</source>
          <target state="translated">在适当位置扩展分配的块。仅当该块是最后分配的块时，扩展才会成功。仅在 &lt;code&gt;growDownwards&lt;/code&gt; 为 &lt;code&gt;No.growDownwards&lt;/code&gt; 时定义。</target>
        </trans-unit>
        <trans-unit id="cb2e7f8c65f285e69f36d6abb516fbfe712839e3" translate="yes" xml:space="preserve">
          <source>Expands attribute declarations in members in depth first order. Calls dg(size_t symidx, Dsymbol *sym) for each member. If dg returns !=0, stops and returns that value else returns 0. Use this function to avoid the O(N + N^2/2) complexity of calculating dim and calling N times getNth.</source>
          <target state="translated">在成员中按深度第一顺序展开属性声明。对每个成员调用 dg(size_t symidx,Dsymbol *sym)。如果 dg 返回 !=0,则停止并返回该值,否则返回 0.使用该函数可以避免计算 dim 和调用 N 次 getNth 的 O(N+N^2/2)复杂性。</target>
        </trans-unit>
        <trans-unit id="084a0336b3e0fa1cfbc75a4e2da9be624da8ae6d" translate="yes" xml:space="preserve">
          <source>Expands in place a buffer previously allocated by &lt;code&gt;BitmappedBlock&lt;/code&gt;. If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, the expansion fails if the new length exceeds &lt;code&gt;theBlockSize&lt;/code&gt;.</source>
          <target state="translated">在原位扩展由 &lt;code&gt;BitmappedBlock&lt;/code&gt; 分配的缓冲区。如果使用 &lt;code&gt;No.multiblock&lt;/code&gt; 实例化，则新长度超过 &lt;code&gt;theBlockSize&lt;/code&gt; 时，扩展将失败。</target>
        </trans-unit>
        <trans-unit id="797c11627b7043dd4bdb15c59a63cf420baa3b9d" translate="yes" xml:space="preserve">
          <source>Expands in place a buffer previously allocated by &lt;code&gt;SharedBitmappedBlock&lt;/code&gt;. Expansion fails if the new length exceeds the block size.</source>
          <target state="translated">在原处扩展由 &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 分配的缓冲区。如果新长度超过块大小，则扩展失败。</target>
        </trans-unit>
        <trans-unit id="34de05ada292b06170f1d6656265bf476c629815" translate="yes" xml:space="preserve">
          <source>Expands or shrinks allocated block to an allocated size of &lt;code&gt; goodAllocSize(s)&lt;/code&gt;. Expansion occurs in place under the conditions required by &lt;code&gt;expand&lt;/code&gt;. Shrinking occurs in place if &lt;code&gt;goodAllocSize(b.length) == goodAllocSize(s)&lt;/code&gt;.</source>
          <target state="translated">将分配的块扩展或缩小为 &lt;code&gt; goodAllocSize(s)&lt;/code&gt; 的分配大小。膨胀发生在所要求的条件下发生 &lt;code&gt;expand&lt;/code&gt; 。如果 &lt;code&gt;goodAllocSize(b.length) == goodAllocSize(s)&lt;/code&gt; 发生收缩。</target>
        </trans-unit>
        <trans-unit id="3ede9dbe92d17709e10217ef41b4cbf32ac479af" translate="yes" xml:space="preserve">
          <source>Expands the interval backwards in time. Effectively, it does &lt;code&gt;begin -= duration&lt;/code&gt;.</source>
          <target state="translated">向后扩展时间间隔。实际上，它确实 &lt;code&gt;begin -= duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b57a74d337ac5a259427e1f3ea04c84032512812" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it adds the given number of months/years to end.</source>
          <target state="translated">向前和/或向后扩展时间间隔。实际上,它将给定的月/年数加到最后。</target>
        </trans-unit>
        <trans-unit id="e16a1c93e572148be3e3c1e14d575c1803a317a6" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it does &lt;code&gt;begin -= duration&lt;/code&gt; and/or &lt;code&gt;end += duration&lt;/code&gt;. Whether it expands forwards and/or backwards in time is determined by dir.</source>
          <target state="translated">向前和/或向后扩展时间间隔。实际上，它确实 &lt;code&gt;begin -= duration&lt;/code&gt; 和/或 &lt;code&gt;end += duration&lt;/code&gt; 。它是否在时间上向前和/或向后扩展取决于dir。</target>
        </trans-unit>
        <trans-unit id="6115ade81a85a7f10953103eafa7ac7f27f7341b" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of months/years from &lt;code&gt;begin&lt;/code&gt; and adds them to &lt;code&gt;end&lt;/code&gt;. Whether it expands forwards and/or backwards in time is determined by dir.</source>
          <target state="translated">向前和/或向后扩展时间间隔。有效地，它从 &lt;code&gt;begin&lt;/code&gt; 减去给定的月/年数，并将它们添加到 &lt;code&gt;end&lt;/code&gt; 。它是否在时间上向前和/或向后扩展取决于dir。</target>
        </trans-unit>
        <trans-unit id="8f900e50b202dc7b5f34257efaca3c038012cd3e" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of months/years from &lt;code&gt;begin&lt;/code&gt;.</source>
          <target state="translated">向前和/或向后扩展时间间隔。有效地，它从 &lt;code&gt;begin&lt;/code&gt; 减去给定的月/年数。</target>
        </trans-unit>
        <trans-unit id="316269b9bcff090b5279a8dfef454d19bf6429c9" translate="yes" xml:space="preserve">
          <source>Expands the interval forwards in time. Effectively, it does &lt;code&gt;end += duration&lt;/code&gt;.</source>
          <target state="translated">扩展时间间隔。实际上，它确实以 &lt;code&gt;end += duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc5691de73841ad488b58382733ae62e16cc0fbb" translate="yes" xml:space="preserve">
          <source>Expands to a named anchor used for hyperlinking to a particular declaration section. Argument &amp;amp;dollar;1 expands to the qualified declaration name.</source>
          <target state="translated">扩展为用于超链接到特定声明部分的命名锚。参数＆1扩展为合格的声明名称。</target>
        </trans-unit>
        <trans-unit id="076b445912ca06b9147fd4ce226d6bbff02a82c5" translate="yes" xml:space="preserve">
          <source>Expands tuples in args in depth first order. Calls dg(void *ctx, size_t argidx, Parameter *arg) for each Parameter. If dg returns !=0, stops and returns that value else returns 0. Use this function to avoid the O(N + N^2/2) complexity of calculating dim and calling N times getNth.</source>
          <target state="translated">按深度一阶展开args中的元组。对每个参数调用 dg(void *ctx,size_t argidx,Parameter *arg)。如果 dg 返回 !=0,则停止并返回该值,否则返回 0.使用该函数可以避免计算 dim 和调用 N 次 getNth 的 O(N+N^2/2)复杂性。</target>
        </trans-unit>
        <trans-unit id="bcedc51cce47a902790753d67bea2312fe893839" translate="yes" xml:space="preserve">
          <source>Experienced FORTRAN numerics programmers know that multidimensional &quot;rectangular&quot; arrays for things like matrix operations are much faster than trying to access them via pointers to pointers resulting from &quot;array of pointers to array&quot; semantics. For example, the D syntax:</source>
          <target state="translated">有经验的FORTRAN数值程序员都知道,像矩阵运算这样的多维 &quot;矩形 &quot;数组,比试图通过 &quot;数组指针到数组 &quot;语义导致的指针来访问它们要快得多。例如,D语法。</target>
        </trans-unit>
        <trans-unit id="06490b0b5dc2e6f349a0c0ddde37643f5a5ac75c" translate="yes" xml:space="preserve">
          <source>Experimental network access via the File interface</source>
          <target state="translated">通过文件接口的实验性网络访问</target>
        </trans-unit>
        <trans-unit id="15a7ffb04c4605a09649beb118c20c17de19ede4" translate="yes" xml:space="preserve">
          <source>Explains the return value of the function. If the function returns &lt;b&gt;void&lt;/b&gt;, don't redundantly document it.</source>
          <target state="translated">说明函数的返回值。如果函数返回&lt;b&gt;void&lt;/b&gt;，请不要重复记录它。</target>
        </trans-unit>
        <trans-unit id="08c2201d6cdd5e0c73a89bc468a1c568ad04f452" translate="yes" xml:space="preserve">
          <source>Explicit Instantiation</source>
          <target state="translated">显式实例化</target>
        </trans-unit>
        <trans-unit id="20774c9957e71e2e463d16df16c4cfff77b34323" translate="yes" xml:space="preserve">
          <source>Explicit Template Instantiation</source>
          <target state="translated">显式模板实例化</target>
        </trans-unit>
        <trans-unit id="fbaa54eaab210a4cb9cfc7d9c1378fcdc2b85e52" translate="yes" xml:space="preserve">
          <source>Explicit cast to bool. Useful as a shorthand for !(x.empty) in if and assert statements.</source>
          <target state="translated">显式转换为 bool。在 if 和 assert 语句中作为 !(x.empty)的简写很有用。</target>
        </trans-unit>
        <trans-unit id="3d8f05eb6d48b04794152e7b23638cae9f48f278" translate="yes" xml:space="preserve">
          <source>Explicit suffixes</source>
          <target state="translated">明确的后缀</target>
        </trans-unit>
        <trans-unit id="a78d73b55b840cefe1a0a0daca2e42e60edecac9" translate="yes" xml:space="preserve">
          <source>Exponentiation &amp;amp; Logarithms</source>
          <target state="translated">求幂与对数</target>
        </trans-unit>
        <trans-unit id="1cd8e8a364673d3411b700d793c596d01bc2b145" translate="yes" xml:space="preserve">
          <source>Exposes the given root Array as a standard D array.</source>
          <target state="translated">将给定的根数组作为标准的D数组公开。</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="124e31831c2789749ceb9147facc91550d3ce84a" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">表达式 &lt;code&gt;arg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92b421f69102c781d75346243b5587cc88f90fb6" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e0&lt;/code&gt;</source>
          <target state="translated">表达式 &lt;code&gt;e0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7007fb43c92f8963b348d85ed11e388b0552e1c3" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e1&lt;/code&gt;</source>
          <target state="translated">表达式 &lt;code&gt;e1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f394df42c68efb7c3038933322adc5a961a6b555" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;e&lt;/code&gt;</source>
          <target state="translated">表达式 &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e60c9324dd44b217718e5d601d55424f1b4789b" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;earg1&lt;/code&gt;</source>
          <target state="translated">表达 &lt;code&gt;earg1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f910b8428605cbf862e3d1bb322d73f52f00aea1" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;elem&lt;/code&gt;</source>
          <target state="translated">表达 &lt;code&gt;elem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f2346f54fcfa8df07417dbd8829090b55118464" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;emsg&lt;/code&gt;</source>
          <target state="translated">表情 &lt;code&gt;emsg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cbf5e84e80504f53dddbdea7c64954b155cb357" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">表达式 &lt;code&gt;exp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37aac93cf0d495815e578c5699ff35828cf6f52d" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;feaggr&lt;/code&gt;</source>
          <target state="translated">表达 &lt;code&gt;feaggr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a953ed52efeca5916127c7919696beebfa3bd1fc" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;firstArg&lt;/code&gt;</source>
          <target state="translated">表达式 &lt;code&gt;firstArg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="793cca28c8f3f384b396f7adfd08149a1c0bf195" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;instantiated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;instantiated&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="4d6980b81fee04c7b5a70125a6146240a73039e9" translate="yes" xml:space="preserve">
          <source>Expression &lt;code&gt;original&lt;/code&gt;</source>
          <target state="translated">表达 &lt;code&gt;original&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0759ebb987367a96a51a5d1b5ffa1b699e18ec08" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;Expression_optimize&quot;&gt;Expression_optimize&lt;/strong&gt;(Expression e, int result, bool keepLvalue);</source>
          <target state="translated">表达式&lt;strong id=&quot;Expression_optimize&quot;&gt;Expression_optimize&lt;/strong&gt;（表达式e，int结果，布尔值keepLvalue）；</target>
        </trans-unit>
        <trans-unit id="e7eb0ac731fa465a7e553c45917e50e97836c4c4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;addDtorHook&quot;&gt;addDtorHook&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;addDtorHook&quot;&gt;addDtorHook&lt;/strong&gt;（Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="79e7a3e2a6b6bb028e3dee36c35a16bbcac64b57" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;addInvariant&quot;&gt;addInvariant&lt;/strong&gt;(ref const Loc loc, Scope* sc, AggregateDeclaration ad, VarDeclaration vthis);</source>
          <target state="translated">表达式&lt;strong id=&quot;addInvariant&quot;&gt;addInvariant&lt;/strong&gt;（ref const Loc loc，Scope * sc，AggregateDeclaration ad，VarDeclaration vthis）;</target>
        </trans-unit>
        <trans-unit id="c7de6a20914bd0188b326ef7d4369047d4127694" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt;(BinAssignExp e, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt;（BinAssignExp e，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="38cbef71fac259fb3e5addd6010c78720766a7e4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt;(BinExp e, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;arrayOp&quot;&gt;arrayOp&lt;/strong&gt;（BinExp e，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="d05e7a6332b506aff76d8910b31057f52e8e38f0" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;basis&quot;&gt;basis&lt;/strong&gt;;</source>
          <target state="translated">表达&lt;strong id=&quot;basis&quot;&gt;基础&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ce914de3f03e3182cbb394d12e8e44d61e13a1f4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;binSemantic&quot;&gt;binSemantic&lt;/strong&gt;(BinExp e, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;binSemantic&quot;&gt;binSemantic&lt;/strong&gt;（BinExp e，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="07cd4a6028fc596b40b13d6d0458444d8de8c8ab" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;build_overload&quot;&gt;build_overload&lt;/strong&gt;(ref const Loc loc, Scope* sc, Expression ethis, Expression earg, Dsymbol d);</source>
          <target state="translated">表达式&lt;strong id=&quot;build_overload&quot;&gt;build_overload&lt;/strong&gt;（ref const Loc loc，Scope * sc，表达式ethis，表达式earg，Dsymbol d）;</target>
        </trans-unit>
        <trans-unit id="6871fa1d9cef9535c1f853ab6b02a766a657fbfb" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;castTo&quot;&gt;castTo&lt;/strong&gt;(Expression e, Scope* sc, Type t);</source>
          <target state="translated">表达式&lt;strong id=&quot;castTo&quot;&gt;castTo&lt;/strong&gt;（表达式e，Scope * sc，类型t）;</target>
        </trans-unit>
        <trans-unit id="2b45466acfd0d3d2ded6118c9809d1350d706c46" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;charPromotions&quot;&gt;charPromotions&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;charPromotions&quot;&gt;charPromotions&lt;/strong&gt;（表达式e，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="3411c26ed41d2305da3a489d8bf4719326ae9f77" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;condition&quot;&gt;condition&lt;/strong&gt;;</source>
          <target state="translated">表达&lt;strong id=&quot;condition&quot;&gt;条件&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e6931cb91b1ae0e41a9ee765db1152dfb33ce0d4" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;ctfeInterpret&quot;&gt;ctfeInterpret&lt;/strong&gt;(Expression e);</source>
          <target state="translated">表达式&lt;strong id=&quot;ctfeInterpret&quot;&gt;ctfeInterpret&lt;/strong&gt;（表达式e）；</target>
        </trans-unit>
        <trans-unit id="f1f6d0f109e3e21ea56ab0c366d0d61e14ee4c7d" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;defaultInit&quot;&gt;defaultInit&lt;/strong&gt;(Type mt, ref const Loc loc);</source>
          <target state="translated">表达式&lt;strong id=&quot;defaultInit&quot;&gt;defaultInit&lt;/strong&gt;（类型mt，ref const Loc loc）;</target>
        </trans-unit>
        <trans-unit id="d97a47c0800d46fd3cd2e538e048bb178e515f0c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;defaultInitLiteral&quot;&gt;defaultInitLiteral&lt;/strong&gt;(ref const Loc loc);</source>
          <target state="translated">表达式&lt;strong id=&quot;defaultInitLiteral&quot;&gt;defaultInitLiteral&lt;/strong&gt;（ref const Loc loc）;</target>
        </trans-unit>
        <trans-unit id="0a092a26bbbc3c916453f449b7418f845d33b41c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;doCopyOrMove&quot;&gt;doCopyOrMove&lt;/strong&gt;(Scope* sc, Expression e, Type t = null);</source>
          <target state="translated">表达式&lt;strong id=&quot;doCopyOrMove&quot;&gt;doCopyOrMove&lt;/strong&gt;（Scope * sc，表达式e，类型t = null）;</target>
        </trans-unit>
        <trans-unit id="34a3fc99823ccdc5563fe45ca6f4cc54c969827f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;dotExp&quot;&gt;dotExp&lt;/strong&gt;(Type mt, Scope* sc, Expression e, Identifier ident, int flag);</source>
          <target state="translated">表达式&lt;strong id=&quot;dotExp&quot;&gt;dotExp&lt;/strong&gt;（类型mt，Scope * sc，表达式e，标识符ident，int标志）；</target>
        </trans-unit>
        <trans-unit id="192530034d665cef7795047e56ecf307c8762064" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;eval_builtin&quot;&gt;eval_builtin&lt;/strong&gt;(Loc loc, FuncDeclaration fd, Expressions* arguments);</source>
          <target state="translated">表达式&lt;strong id=&quot;eval_builtin&quot;&gt;eval_builtin&lt;/strong&gt;（Loc loc，FuncDeclaration fd，Expressions *参数）;</target>
        </trans-unit>
        <trans-unit id="80a303e71b3ae3f7d7217b7e5618f20dbd2535a9" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt;;</source>
          <target state="translated">表达&lt;strong id=&quot;exp&quot;&gt;EXP&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6eb2e3ce9ac3932da76f3de31bbf848ad262e34e" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;expandVar&quot;&gt;expandVar&lt;/strong&gt;(int result, VarDeclaration v);</source>
          <target state="translated">表达式&lt;strong id=&quot;expandVar&quot;&gt;expandVar&lt;/strong&gt;（int result，VarDeclaration v）;</target>
        </trans-unit>
        <trans-unit id="dfb3029a50e65b9de4b512fbdb1d29b5615172e3" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;extractSideEffect&quot;&gt;extractSideEffect&lt;/strong&gt;(Scope* sc, const char* name, ref Expression e0, Expression e, bool alwaysCopy = false);</source>
          <target state="translated">表达式&lt;strong id=&quot;extractSideEffect&quot;&gt;extractSideEffect&lt;/strong&gt;（Scope * sc，const char *名称，ref表达式e0，表达式e，bool alwaysCopy = false）;</target>
        </trans-unit>
        <trans-unit id="efcc60927be71d26c3c816535424c83c4bde8e5a" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getField&quot;&gt;getField&lt;/strong&gt;(Type type, uint offset);</source>
          <target state="translated">表达式&lt;strong id=&quot;getField&quot;&gt;getField&lt;/strong&gt;（Type type，uint offset）;</target>
        </trans-unit>
        <trans-unit id="5c869349f6aded66c0c7140fab666e82c3d45d29" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getMaxMinValue&quot;&gt;getMaxMinValue&lt;/strong&gt;(ref const Loc loc, Identifier id);</source>
          <target state="translated">表达式&lt;strong id=&quot;getMaxMinValue&quot;&gt;getMaxMinValue&lt;/strong&gt;（ref const Loc loc，Identifier id）;</target>
        </trans-unit>
        <trans-unit id="cf05303975b50b18a00371bfbf097a643287e833" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getProperty&quot;&gt;getProperty&lt;/strong&gt;(Type t, ref const Loc loc, Identifier ident, int flag);</source>
          <target state="translated">表达式&lt;strong id=&quot;getProperty&quot;&gt;getProperty&lt;/strong&gt;（类型t，ref const Loc loc，Identifier ident，int flag）;</target>
        </trans-unit>
        <trans-unit id="1ed9d54715957ffd3217c453236ae0352ea8d40c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getTargetInfo&quot;&gt;getTargetInfo&lt;/strong&gt;(const(char)* name, ref const Loc loc);</source>
          <target state="translated">表达式&lt;strong id=&quot;getTargetInfo&quot;&gt;getTargetInfo&lt;/strong&gt;（const（char）*名称，ref const Loc loc）;</target>
        </trans-unit>
        <trans-unit id="a06617afbe33da227ef8899ec1e3a2bf9eda75fc" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;getThisSkipNestedFuncs&quot;&gt;getThisSkipNestedFuncs&lt;/strong&gt;(ref const Loc loc, Scope* sc, Dsymbol s, AggregateDeclaration ad, Expression e1, Type t, Dsymbol var, bool flag = false);</source>
          <target state="translated">表达式&lt;strong id=&quot;getThisSkipNestedFuncs&quot;&gt;getThisSkipNestedFuncs&lt;/strong&gt;（ref const Loc loc，Scope * sc，Dsymbol s，AggregateDeclaration ad，表达式e1，Type t，Dsymbol var，bool flag = false）;</target>
        </trans-unit>
        <trans-unit id="5182dc71276170cd9c912e2c20da5b0104e0baed" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;identExp&quot;&gt;identExp&lt;/strong&gt;;</source>
          <target state="translated">表达&lt;strong id=&quot;identExp&quot;&gt;identExp&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6002f1b5688ee38493cb8bf57b584c7ad904867f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;implicitCastTo&quot;&gt;implicitCastTo&lt;/strong&gt;(Expression e, Scope* sc, Type t);</source>
          <target state="translated">表达式&lt;strong id=&quot;implicitCastTo&quot;&gt;implicitCastTo&lt;/strong&gt;（表达式e，Scope * sc，类型t）；</target>
        </trans-unit>
        <trans-unit id="d9fbd63977c9b0f6b381d61e7486228255c3141c" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Expression e, Type t, int flag = 0);</source>
          <target state="translated">表达式&lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;（表达式e，类型t，int标志= 0）；</target>
        </trans-unit>
        <trans-unit id="e4eed1230d55b4f7ffdb0f2946ec6b81e685c4d5" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;initializerToExpression&quot;&gt;initializerToExpression&lt;/strong&gt;(Initializer init, Type itype = null);</source>
          <target state="translated">表达式&lt;strong id=&quot;initializerToExpression&quot;&gt;initializerToExpression&lt;/strong&gt;（Initializer init，Type itype = null）;</target>
        </trans-unit>
        <trans-unit id="9fd9077340336bbdc42e5a0e55ae876cf74bf052" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;inlineCopy&quot;&gt;inlineCopy&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;inlineCopy&quot;&gt;inlineCopy&lt;/strong&gt;（表达式e，作用域* sc）；</target>
        </trans-unit>
        <trans-unit id="a93d5e116a77484a91fb6b2216ee9f2c3ab792bc" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;integralPromotions&quot;&gt;integralPromotions&lt;/strong&gt;(Expression e, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;integralPromotions&quot;&gt;积分促销&lt;/strong&gt;（表达式e，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="119f4b90e73b2490c0b337b5c2892ee45abe1b1b" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;op_overload&quot;&gt;op_overload&lt;/strong&gt;(Expression e, Scope* sc, TOK* pop = null);</source>
          <target state="translated">表达式&lt;strong id=&quot;op_overload&quot;&gt;op_overload&lt;/strong&gt;（表达式e，Scope * sc，TOK * pop = null）;</target>
        </trans-unit>
        <trans-unit id="ce92783572475e6e71bead0fd27548b7a7fa8d60" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveLoc&quot;&gt;resolveLoc&lt;/strong&gt;(ref const Loc loc, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;resolveLoc&quot;&gt;resolveLoc&lt;/strong&gt;（ref const Loc loc，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="20d217b5757071adb84549bfb94bd0bc8a5ef317" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt;(Scope* sc, ArrayExp ae, Expression* pe0);</source>
          <target state="translated">表达式&lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt;（Scope * sc，ArrayExp ae，Expression * pe0）;</target>
        </trans-unit>
        <trans-unit id="35eac18ed0785aafed68f419dd6c566022d1d5a9" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt;(Scope* sc, ArrayExp ae, IntervalExp ie, Expression* pe0);</source>
          <target state="translated">表达式&lt;strong id=&quot;resolveOpDollar&quot;&gt;resolveOpDollar&lt;/strong&gt;（Scope * sc，ArrayExp ae，IntervalExp即Expression * pe0）;</target>
        </trans-unit>
        <trans-unit id="24fb0ae31138927857d9517f368cb6748955cf0f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolvePropertiesOnly&quot;&gt;resolvePropertiesOnly&lt;/strong&gt;(Scope* sc, Expression e1);</source>
          <target state="translated">表达式&lt;strong id=&quot;resolvePropertiesOnly&quot;&gt;resolvePropertiesOnly&lt;/strong&gt;（Scope * sc，表达式e1）;</target>
        </trans-unit>
        <trans-unit id="9f1dd720666b1ebbdeaf1330037ca49680382277" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;resolveSlice&quot;&gt;resolveSlice&lt;/strong&gt;(Expression e, UnionExp* pue = null);</source>
          <target state="translated">表达式&lt;strong id=&quot;resolveSlice&quot;&gt;resolveSlice&lt;/strong&gt;（表达式e，UnionExp * pue = null）;</target>
        </trans-unit>
        <trans-unit id="399afa038530894af01c66997652832c22521978" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;scaleFactor&quot;&gt;scaleFactor&lt;/strong&gt;(BinExp be, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;scaleFactor&quot;&gt;scaleFactor&lt;/strong&gt;（BinExp be，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="79986118a4e6a934ff5fac083ee5a2d91f44d14e" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;symbolToExp&quot;&gt;symbolToExp&lt;/strong&gt;(Dsymbol s, ref const Loc loc, Scope* sc, bool hasOverloads);</source>
          <target state="translated">表达式&lt;strong id=&quot;symbolToExp&quot;&gt;symbolToExp&lt;/strong&gt;（Dsymbol s，ref const Loc loc，Scope * sc，bool hasOverloads）;</target>
        </trans-unit>
        <trans-unit id="ffc4deb0c336cdfa09b1452db6e63631f5d4122f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toAssocArrayLiteral&quot;&gt;toAssocArrayLiteral&lt;/strong&gt;(ArrayInitializer ai);</source>
          <target state="translated">表达式为&lt;strong id=&quot;toAssocArrayLiteral&quot;&gt;AssocArrayLiteral&lt;/strong&gt;（ArrayInitializer ai）;</target>
        </trans-unit>
        <trans-unit id="c6bce8f2be572a14af244cca194d546909ce6bb7" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toBoolean&quot;&gt;toBoolean&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;toBoolean&quot;&gt;toBoolean&lt;/strong&gt;（Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="bdb106e8f5a606a6dce675cd4ddbebbc5666068f" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toDelegate&quot;&gt;toDelegate&lt;/strong&gt;(Expression e, Type t, Scope* sc);</source>
          <target state="translated">Expression &lt;strong id=&quot;toDelegate&quot;&gt;toDelegate&lt;/strong&gt;（表达式e，类型t，范围* sc）；</target>
        </trans-unit>
        <trans-unit id="6cdc4080dafbc4371980fa1b4330711247ff8eee" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;toLvalue&quot;&gt;toLvalue&lt;/strong&gt;(Scope* sc, Expression e);</source>
          <target state="translated">表达式为&lt;strong id=&quot;toLvalue&quot;&gt;toLvalue&lt;/strong&gt;（范围* sc，表达式e）；</target>
        </trans-unit>
        <trans-unit id="6c7b6596f94002291db7dced4938937fd23206f2" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;trySemantic&quot;&gt;trySemantic&lt;/strong&gt;(Expression exp, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;trySemantic&quot;&gt;trySemantic&lt;/strong&gt;（Expression exp，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="2c47e576a24251679ce842e21fa63efaeebfa5ca" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;typeCombine&quot;&gt;typeCombine&lt;/strong&gt;(BinExp be, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;typeCombine&quot;&gt;typeCombine&lt;/strong&gt;（BinExp be，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="590987c28b7350e9354ffa20860fe52c9ed58235" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;typeToExpression&quot;&gt;typeToExpression&lt;/strong&gt;(Type t);</source>
          <target state="translated">表达式&lt;strong id=&quot;typeToExpression&quot;&gt;typeToExpression&lt;/strong&gt;（Type t）;</target>
        </trans-unit>
        <trans-unit id="6e7f226bf5b1c59c07426bc48bf791f755e82872" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;unaSemantic&quot;&gt;unaSemantic&lt;/strong&gt;(UnaExp e, Scope* sc);</source>
          <target state="translated">表达式&lt;strong id=&quot;unaSemantic&quot;&gt;unSemantic&lt;/strong&gt;（UnaExp e，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="25e7bb0649743e5711f99aca2d79a2a5b5648501" translate="yes" xml:space="preserve">
          <source>Expression &lt;strong id=&quot;valueNoDtor&quot;&gt;valueNoDtor&lt;/strong&gt;(Expression e);</source>
          <target state="translated">表达式&lt;strong id=&quot;valueNoDtor&quot;&gt;valueNoDtor&lt;/strong&gt;（表达式e）;</target>
        </trans-unit>
        <trans-unit id="bf3f22e25aac5a5716bd2ddc48521dc242830fb5" translate="yes" xml:space="preserve">
          <source>Expression Parser</source>
          <target state="translated">表达式分析器</target>
        </trans-unit>
        <trans-unit id="d9c4f2202566f51697b377f90555653846292193" translate="yes" xml:space="preserve">
          <source>Expression Statement</source>
          <target state="translated">表达式声明</target>
        </trans-unit>
        <trans-unit id="eabfa2441c13d974e2af574b0d99a70f4bb9a0d6" translate="yes" xml:space="preserve">
          <source>Expression for the requested targetInfo</source>
          <target state="translated">请求的 targetInfo 的表达式</target>
        </trans-unit>
        <trans-unit id="6063917999bbfe2ce9b3fa075874599a6ebc96e5" translate="yes" xml:space="preserve">
          <source>Expression representing the &lt;code&gt;this&lt;/code&gt; for the var</source>
          <target state="translated">表示var 的 &lt;code&gt;this&lt;/code&gt; 的表达式</target>
        </trans-unit>
        <trans-unit id="df6caa2f45ca5f6946eb55c0501e737ddb8bf27f" translate="yes" xml:space="preserve">
          <source>Expression to convert</source>
          <target state="translated">表达式转换</target>
        </trans-unit>
        <trans-unit id="cf9f917167bd00b70d460bca475535ddcbe6fc7e" translate="yes" xml:space="preserve">
          <source>Expression to determine cost of</source>
          <target state="translated">确定成本的表达式</target>
        </trans-unit>
        <trans-unit id="2f055d0b3e4b8725a9090bf4d8f45363b46775b9" translate="yes" xml:space="preserve">
          <source>Expression to look at</source>
          <target state="translated">表达方式看</target>
        </trans-unit>
        <trans-unit id="fbcc420f7af639d45c5081500755a47ce6367c0a" translate="yes" xml:space="preserve">
          <source>Expression which expected as a string</source>
          <target state="translated">以字符串形式出现的表达式</target>
        </trans-unit>
        <trans-unit id="d8e5fdfc95019b0e8b971e0729223c011b90611f" translate="yes" xml:space="preserve">
          <source>Expression* &lt;code&gt;pe&lt;/code&gt;</source>
          <target state="translated">表情* &lt;code&gt;pe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7bc014e6d10451a8147b649b688eca472ffab8da" translate="yes" xml:space="preserve">
          <source>Expression[] &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">表达式[] &lt;code&gt;args&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd7feaf7d6885e2aeae1d7088bcce98f228aa60c" translate="yes" xml:space="preserve">
          <source>Expression[] &lt;code&gt;negatives&lt;/code&gt;</source>
          <target state="translated">Expression [] &lt;code&gt;negatives&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="17b61fb742fe0544a0738e346e8b68266f8e6c2c" translate="yes" xml:space="preserve">
          <source>Expressions and statements may create and/or consume rvalues. Such values are called</source>
          <target state="translated">表达式和语句可以创建和/或消耗r值。这些值被称为</target>
        </trans-unit>
        <trans-unit id="827d05e6a3f1241aa29022321190716d0bac015a" translate="yes" xml:space="preserve">
          <source>Expressions are used to compute values with a resulting type. These values can then be assigned, tested, or ignored. Expressions can also have side effects.</source>
          <target state="translated">表达式用于计算具有结果类型的值。然后这些值可以被分配、测试或忽略。表达式也可以有副作用。</target>
        </trans-unit>
        <trans-unit id="213f37939286b76ce58e9d750cb8625a9de8b877" translate="yes" xml:space="preserve">
          <source>Expressions connected by commas</source>
          <target state="translated">用逗号连接的表达式</target>
        </trans-unit>
        <trans-unit id="eeda38d97c1591b472912826aeaaf79dee7875cf" translate="yes" xml:space="preserve">
          <source>Expressions of the form &lt;code&gt;a != b&lt;/code&gt; are rewritten as &lt;code&gt;!(a == b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a != b&lt;/code&gt; 形式的表达式被重写为 &lt;code&gt;!(a == b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9790c7ed767b515e2db3f5032fee145b7d8f3f2d" translate="yes" xml:space="preserve">
          <source>Expressions of the form &lt;code&gt;arr[&lt;/code&gt;</source>
          <target state="translated">形式为 &lt;code&gt;arr[&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="296ed9970d463ab72dec34118964f9a6a98b21b4" translate="yes" xml:space="preserve">
          <source>Expressions that have no effect, like &lt;code&gt;(x + x)&lt;/code&gt;, are illegal as expression statements unless the are cast to void.</source>
          <target state="translated">无效的表达式 &lt;code&gt;(x + x)&lt;/code&gt; 例如（x + x））作为表达式语句是非法的，除非将其强制转换为void。</target>
        </trans-unit>
        <trans-unit id="13135cffec267a2714ee700a44376c037a46555b" translate="yes" xml:space="preserve">
          <source>Expressions that have no effect, like &lt;code&gt;(x + x)&lt;/code&gt;, are illegal as expression statements unless they are cast to void.</source>
          <target state="translated">无效的表达式 &lt;code&gt;(x + x)&lt;/code&gt; 如（x + x））作为表达式语句是非法的，除非将它们强制转换为void。</target>
        </trans-unit>
        <trans-unit id="2d9ba85aff37987e9f1d9fafb80136e7c416676a" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;elements&lt;/code&gt;</source>
          <target state="translated">表达式* &lt;code&gt;elements&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="137b1c280f96de72078b78ad7d25efffd1250b2a" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;exps&lt;/code&gt;</source>
          <target state="translated">表达式* &lt;code&gt;exps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87db2601150b379b388e1556ff809504a78b747" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;fargs&lt;/code&gt;</source>
          <target state="translated">表达式* &lt;code&gt;fargs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e0b234b24cbc1fb165bd79fe8e05526407f3b36" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;code&gt;negatives&lt;/code&gt;</source>
          <target state="translated">表达式* &lt;code&gt;negatives&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd03daa888a0e583ceb40e2e00dacb30660a10cc" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;elements&quot;&gt;elements&lt;/strong&gt;;</source>
          <target state="translated">表达式* &lt;strong id=&quot;elements&quot;&gt;元素&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="37783cf5e7c87b4f591a55d79dbb7ea52f941431" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;fdensureParams&quot;&gt;fdensureParams&lt;/strong&gt;;</source>
          <target state="translated">表达式* &lt;strong id=&quot;fdensureParams&quot;&gt;fdensureParams&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="026b50f17d896e63ced46249a059380f8e6cbae1" translate="yes" xml:space="preserve">
          <source>Expressions* &lt;strong id=&quot;fdrequireParams&quot;&gt;fdrequireParams&lt;/strong&gt;;</source>
          <target state="translated">表达式* &lt;strong id=&quot;fdrequireParams&quot;&gt;fdrequireParams&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b7c9df0f13515170e90ad55a4b53a6f772217b57" translate="yes" xml:space="preserve">
          <source>Extend an array &lt;code&gt;px&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements. Caller must initialize those elements.</source>
          <target state="translated">延伸的阵列 &lt;code&gt;px&lt;/code&gt; 由 &lt;code&gt;n&lt;/code&gt; 元件。调用者必须初始化这些元素。</target>
        </trans-unit>
        <trans-unit id="f8d9ec6e863a0af2e6c6f8b6330f856c27efe720" translate="yes" xml:space="preserve">
          <source>Extend an array by n elements. Caller must initialize those elements.</source>
          <target state="translated">扩展一个数组,增加n个元素。调用者必须初始化这些元素。</target>
        </trans-unit>
        <trans-unit id="1b5d8573dd5bcf3e6c45847ffd98818bf7ecfc27" translate="yes" xml:space="preserve">
          <source>Extend may also be used to extend slices (or memory blocks with &lt;a href=&quot;#APPENDABLE&quot;&gt;&lt;code&gt;APPENDABLE&lt;/code&gt;&lt;/a&gt; info). However, use the return value only as an indicator of success. &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; should be used to retrieve actual usable slice capacity.</source>
          <target state="translated">扩展还可以用于扩展切片（或具有&lt;a href=&quot;#APPENDABLE&quot;&gt; &lt;code&gt;APPENDABLE&lt;/code&gt; &lt;/a&gt;信息的内存块）。但是，将返回值仅用作成功指示。应使用&lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;来检索实际可用的分片容量。</target>
        </trans-unit>
        <trans-unit id="43ee2587f2dee7414c6f7fffb20316fc7cc9240d" translate="yes" xml:space="preserve">
          <source>Extend the length of the input range &lt;code&gt;r&lt;/code&gt; by padding out the end of the range with the element &lt;code&gt;e&lt;/code&gt;. The element &lt;code&gt;e&lt;/code&gt; must be of a common type with the element type of the range &lt;code&gt;r&lt;/code&gt; as defined by &lt;a href=&quot;std_traits#CommonType&quot;&gt;&lt;code&gt;std.traits.CommonType&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;n&lt;/code&gt; is less than the length of of &lt;code&gt;r&lt;/code&gt;, then the contents of &lt;code&gt;r&lt;/code&gt; are returned.</source>
          <target state="translated">通过使用元素 &lt;code&gt;e&lt;/code&gt; 填充输入范围 &lt;code&gt;r&lt;/code&gt; 的长度来扩展输入范围r的长度。元素 &lt;code&gt;e&lt;/code&gt; 必须具有与&lt;a href=&quot;std_traits#CommonType&quot;&gt; &lt;code&gt;std.traits.CommonType&lt;/code&gt; &lt;/a&gt;定义的范围 &lt;code&gt;r&lt;/code&gt; 相同的公共类型。如果 &lt;code&gt;n&lt;/code&gt; 小于 &lt;code&gt;r&lt;/code&gt; 的长度，则返回 &lt;code&gt;r&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="aa833620006d2c6c6571801ae931036999a293ae" translate="yes" xml:space="preserve">
          <source>Extend, shrink or allocate a new block of memory keeping the contents of an existing block</source>
          <target state="translated">扩展、收缩或分配一个新的内存块,保留现有内存块的内容。</target>
        </trans-unit>
        <trans-unit id="1f14c54998b149072f5f4807010db7ef4def6435" translate="yes" xml:space="preserve">
          <source>ExtendedModuleUnitTester &lt;code&gt;h&lt;/code&gt;</source>
          <target state="translated">ExtendedModuleUnitTester &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9b77ddd59e96e949c32c9e07059de1e0868c54d" translate="yes" xml:space="preserve">
          <source>Extender</source>
          <target state="translated">Extender</target>
        </trans-unit>
        <trans-unit id="ca6a41cfa1be0460478758700e28ed97e69b6db4" translate="yes" xml:space="preserve">
          <source>Extends the length of the input range &lt;code&gt;r&lt;/code&gt; by padding out the start of the range with the element &lt;code&gt;e&lt;/code&gt;. The element &lt;code&gt;e&lt;/code&gt; must be of a common type with the element type of the range &lt;code&gt;r&lt;/code&gt; as defined by &lt;a href=&quot;std_traits#CommonType&quot;&gt;&lt;code&gt;std.traits.CommonType&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;n&lt;/code&gt; is less than the length of of &lt;code&gt;r&lt;/code&gt;, then &lt;code&gt;r&lt;/code&gt; is returned unmodified.</source>
          <target state="translated">通过使用元素 &lt;code&gt;e&lt;/code&gt; 填充输入范围 &lt;code&gt;r&lt;/code&gt; 的长度来扩展输入范围r的长度。元素 &lt;code&gt;e&lt;/code&gt; 必须具有与&lt;a href=&quot;std_traits#CommonType&quot;&gt; &lt;code&gt;std.traits.CommonType&lt;/code&gt; &lt;/a&gt;定义的范围 &lt;code&gt;r&lt;/code&gt; 相同的公共类型。如果 &lt;code&gt;n&lt;/code&gt; 小于 &lt;code&gt;r&lt;/code&gt; 的长度，则 &lt;code&gt;r&lt;/code&gt; 不变地返回。</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="006d500cd51d10312fee9a378180dd1c0dbff085" translate="yes" xml:space="preserve">
          <source>Extension to add (should not include '.')</source>
          <target state="translated">要添加的扩展名(不应包括'.')</target>
        </trans-unit>
        <trans-unit id="6482035493770d2e055c43b47e6d26c77dd6c0ef" translate="yes" xml:space="preserve">
          <source>Extern Declarations</source>
          <target state="translated">外部声明</target>
        </trans-unit>
        <trans-unit id="d4c9ef3b0f468eee8df0924f820ebf154b375ffb" translate="yes" xml:space="preserve">
          <source>External functions don't have a function body visible to the compiler:</source>
          <target state="translated">外部函数没有编译器可见的函数体。</target>
        </trans-unit>
        <trans-unit id="3748f7f3cb478d80788fa4224db3fc0a78eefd90" translate="yes" xml:space="preserve">
          <source>ExternallyMangledName</source>
          <target state="translated">ExternallyMangledName</target>
        </trans-unit>
        <trans-unit id="346cbbedcd46a1663dd5b1cc744bd9a949537eb2" translate="yes" xml:space="preserve">
          <source>Extra characters were found after the end of the domain literal</source>
          <target state="translated">在域名字面意思的结尾处发现了额外的字符。</target>
        </trans-unit>
        <trans-unit id="d5c6615073da0f312632e0d30300116c3bbca0ac" translate="yes" xml:space="preserve">
          <source>Extract Metadata About A Column Of A Table</source>
          <target state="translated">提取表中某列的元数据。</target>
        </trans-unit>
        <trans-unit id="9faa5d876b6179e6ba25ab15280e90240372d01c" translate="yes" xml:space="preserve">
          <source>Extract an integral payload from a NAN.</source>
          <target state="translated">从NAN中提取一个整体有效载荷。</target>
        </trans-unit>
        <trans-unit id="2c4b7673b033687b78b5842c4817a13b02fefd97" translate="yes" xml:space="preserve">
          <source>Extract information about types and symbols at compile time.</source>
          <target state="translated">在编译时提取有关类型和符号的信息。</target>
        </trans-unit>
        <trans-unit id="f06fb7685dce7967eb2226a2da1b90f2b56a47a7" translate="yes" xml:space="preserve">
          <source>Extract object previously wrapped by &lt;a href=&quot;#wrap&quot;&gt;&lt;code&gt;wrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">提取先前由&lt;a href=&quot;#wrap&quot;&gt; &lt;code&gt;wrap&lt;/code&gt; 包装的&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="bd69f2de6f5ccb7abb3ebb23adba928b9189680b" translate="yes" xml:space="preserve">
          <source>Extracting keys or values from an associative array</source>
          <target state="translated">从一个关联数组中提取键或值。</target>
        </trans-unit>
        <trans-unit id="33b53849a6a696afc1cd80915cbb26c701295344" translate="yes" xml:space="preserve">
          <source>Extracts the exponent of x as a signed integral value.</source>
          <target state="translated">提取x的指数作为有符号的积分值。</target>
        </trans-unit>
        <trans-unit id="f72287d204f2105b0fd97e600ee98c5cba938ca4" translate="yes" xml:space="preserve">
          <source>Extracts the norm of a complex number.</source>
          <target state="translated">提取复数的法线。</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="92e79f4fb4307210226b4892ad6cd4e88db84d8e" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;fn&lt;/code&gt;</source>
          <target state="translated">˚F &lt;code&gt;fn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="193f1d2a7d28460babdd5dae282bd85494298779" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;fp&lt;/code&gt;</source>
          <target state="translated">˚F &lt;code&gt;fp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24cceb382e88b5a613ffd52b108c408d0048ef0f" translate="yes" xml:space="preserve">
          <source>F &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">˚F &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a08f0857a21894d4669365254c28abd314ff69d5" translate="yes" xml:space="preserve">
          <source>F &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;(F, uint N)(ref scope const F[N] a, ref scope const F[N] b)</source>
          <target state="translated">F &lt;strong id=&quot;dotProduct&quot;&gt;dotProduct&lt;/strong&gt;（F，uint N）（参考范围const F [N] a，参考范围const F [N] b）</target>
        </trans-unit>
        <trans-unit id="2667ca0e687195a6570d57ab0089486c7bee46ff" translate="yes" xml:space="preserve">
          <source>F &lt;strong id=&quot;gapWeightedSimilarity&quot;&gt;gapWeightedSimilarity&lt;/strong&gt;(alias comp = &quot;a == b&quot;, R1, R2, F)(R1 s, R2 t, F lambda)</source>
          <target state="translated">F &lt;strong id=&quot;gapWeightedSimilarity&quot;&gt;gapWeightedSimilarity&lt;/strong&gt;（alias comp =&amp;ldquo; a == b&amp;rdquo;，R1，R2，F）（R1 s，R2 t，F lambda）</target>
        </trans-unit>
        <trans-unit id="fe6176f13577b4b75c6e15efab6754698b9c3bee" translate="yes" xml:space="preserve">
          <source>FE FF</source>
          <target state="translated">FE FF</target>
        </trans-unit>
        <trans-unit id="3e02b936dfd78b3c5ebed8632cb4cc204b3750a2" translate="yes" xml:space="preserve">
          <source>FF FE</source>
          <target state="translated">FF FE</target>
        </trans-unit>
        <trans-unit id="c498915b8f02917da6f0c028707f1c34277fe255" translate="yes" xml:space="preserve">
          <source>FF FE 00 00</source>
          <target state="translated">FF FE 00 00</target>
        </trans-unit>
        <trans-unit id="d2a0477ef856e83464b14c113e56b5dc50816ccb" translate="yes" xml:space="preserve">
          <source>FILE* &lt;code&gt;stream&lt;/code&gt;</source>
          <target state="translated">FILE * &lt;code&gt;stream&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2605a67597f1a10f5c96696e2424ee2db911144" translate="yes" xml:space="preserve">
          <source>FILETIME* &lt;code&gt;ft&lt;/code&gt;</source>
          <target state="translated">FILETIME * &lt;code&gt;ft&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="716c88fa55348f124b797e571db1aebe854236a3" translate="yes" xml:space="preserve">
          <source>FIPS PUB180-2</source>
          <target state="translated">FIPS PUB180-2</target>
        </trans-unit>
        <trans-unit id="1267dff51655e0a3bdc33fc1076bec75984a3f57" translate="yes" xml:space="preserve">
          <source>FLAGS /////////////////////////////////////</source>
          <target state="translated">旗帜 /////////////////////////////////////////////////////</target>
        </trans-unit>
        <trans-unit id="e96a8a604f9b6179e311fa3d5f24abcd71fc841e" translate="yes" xml:space="preserve">
          <source>FNMATCH_FUNCTION user pointer</source>
          <target state="translated">FNMATCH_FUNCTION用户指针。</target>
        </trans-unit>
        <trans-unit id="cd00fd89694c9543bbff899304d998d7ecf5294f" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!double &lt;strong id=&quot;DoubleProperties&quot;&gt;DoubleProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties！double &lt;strong id=&quot;DoubleProperties&quot;&gt;DoubleProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="0d8442da2a84281783f8838ad22bc5dbea8b7a72" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!float &lt;strong id=&quot;FloatProperties&quot;&gt;FloatProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties！float &lt;strong id=&quot;FloatProperties&quot;&gt;FloatProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="f033c2d3e8e972e4ef1768896ccae5d11b59035e" translate="yes" xml:space="preserve">
          <source>FPTypeProperties!real_t &lt;strong id=&quot;RealProperties&quot;&gt;RealProperties&lt;/strong&gt;;</source>
          <target state="translated">FPTypeProperties！real_t &lt;strong id=&quot;RealProperties&quot;&gt;RealProperties&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="33526cf6b3de29bbe86a32df97a3317f13177146" translate="yes" xml:space="preserve">
          <source>FP_ILOGB0</source>
          <target state="translated">FP_ILOGB0</target>
        </trans-unit>
        <trans-unit id="3ca2eaac7e96ce045c763f71e8ad21f82a4121ef" translate="yes" xml:space="preserve">
          <source>FP_ILOGBNAN</source>
          <target state="translated">FP_ILOGBNAN</target>
        </trans-unit>
        <trans-unit id="acb28212fba0272ee990cebd571ebe09b463312e" translate="yes" xml:space="preserve">
          <source>FTP</source>
          <target state="translated">FTP</target>
        </trans-unit>
        <trans-unit id="efd9df5bd03a5bb6ecc42cd9b76d43f3c4b84813" translate="yes" xml:space="preserve">
          <source>FTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">FTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="a156047c4af729c2fac38d529049b3b9938c1d8f" translate="yes" xml:space="preserve">
          <source>FTP Option that causes missing dirs to be created on the remote server. In 7.19.4 we introduced the convenience enums for this option using the CURLFTP_CREATE_DIR prefix.</source>
          <target state="translated">FTP选项,可以在远程服务器上创建丢失的目录。在7.19.4中,我们使用CURLFTP_CREATE_DIR前缀为这个选项引入了方便的枚举。</target>
        </trans-unit>
        <trans-unit id="fbfe183e82b68040592bf183fc081e933272629b" translate="yes" xml:space="preserve">
          <source>FTP access to the specified url.</source>
          <target state="translated">FTP访问指定的网址。</target>
        </trans-unit>
        <trans-unit id="79d1ddd73bbfe55930046d43cf864f9b3aca2fb2" translate="yes" xml:space="preserve">
          <source>FTP client functionality.</source>
          <target state="translated">FTP客户端功能。</target>
        </trans-unit>
        <trans-unit id="296657dabd1e7526b0c3bd8986b54a229ec9f74e" translate="yes" xml:space="preserve">
          <source>FTP option that changes the timeout, in seconds, associated with getting a response. This is different from transfer timeout time and essentially places a demand on the FTP server to acknowledge commands in a timely manner.</source>
          <target state="translated">FTP 选项,可更改与获得响应相关的超时时间(以秒为单位)。这与传输超时时间不同,主要是要求FTP服务器及时确认命令。</target>
        </trans-unit>
        <trans-unit id="1e9d5102532c80cabb71bedd22459f048605a2a0" translate="yes" xml:space="preserve">
          <source>FUNCFLAG.xxxxx</source>
          <target state="translated">FUNCFLAG.xxxxx</target>
        </trans-unit>
        <trans-unit id="04a22d510848e72d972438b2303f4bb0f8cefe40" translate="yes" xml:space="preserve">
          <source>F[] &lt;strong id=&quot;uniformDistribution&quot;&gt;uniformDistribution&lt;/strong&gt;(F = double)(size_t n, F[] useThis = null)</source>
          <target state="translated">F [] &lt;strong id=&quot;uniformDistribution&quot;&gt;均匀分布&lt;/strong&gt;（F =两倍）（size_t n，F [] useThis = null）</target>
        </trans-unit>
        <trans-unit id="885d20f30c6997f28727cb3b1c03c026a0423304" translate="yes" xml:space="preserve">
          <source>Facilities for random number generation.</source>
          <target state="translated">随机数生成设施;</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="9d80a11d6c9cd9d8129231038cc99dcf9cfe6c31" translate="yes" xml:space="preserve">
          <source>Fails: char[] has mutable aliasing.</source>
          <target state="translated">失败:char[]具有可变异的别名。</target>
        </trans-unit>
        <trans-unit id="7ca23f275cf26c43dc6cb80deec7cc73ebd0d6be" translate="yes" xml:space="preserve">
          <source>Fake a struct symbol.</source>
          <target state="translated">伪造一个结构符号。</target>
        </trans-unit>
        <trans-unit id="f92a31e5dc809226adfcdd7266d92ffe4d097f29" translate="yes" xml:space="preserve">
          <source>Fake class which holds the thrown exception. Used for implementing exception handling.</source>
          <target state="translated">持有thrown异常的假类。用于实现异常处理。</target>
        </trans-unit>
        <trans-unit id="187b6d7e012db85d9f53b228f8b221e037e5b215" translate="yes" xml:space="preserve">
          <source>Fallback &lt;strong id=&quot;fallback&quot;&gt;fallback&lt;/strong&gt;;</source>
          <target state="translated">后备&lt;strong id=&quot;fallback&quot;&gt;后备&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1d00915c3eb36b1f76efd0ec12a2e2bfdb9c88e2" translate="yes" xml:space="preserve">
          <source>FallbackAllocator!(Primary, Fallback) &lt;strong id=&quot;fallbackAllocator&quot;&gt;fallbackAllocator&lt;/strong&gt;(Primary, Fallback)(auto ref Primary p, auto ref Fallback f);</source>
          <target state="translated">FallbackAllocator！（Primary，Fallback）&lt;strong id=&quot;fallbackAllocator&quot;&gt;fallbackAllocator&lt;/strong&gt;（Primary，Fallback）（自动参考Primary p，自动参考Fallback f）;</target>
        </trans-unit>
        <trans-unit id="5d505b3f95c1c85d725f5b643bd03f8f11c638e3" translate="yes" xml:space="preserve">
          <source>Families of transcendental functions.</source>
          <target state="translated">超越功能的家族。</target>
        </trans-unit>
        <trans-unit id="c15afdf4366c1e5e116d4655301026b41771feaa" translate="yes" xml:space="preserve">
          <source>Family of this address.</source>
          <target state="translated">这个地址的家人。</target>
        </trans-unit>
        <trans-unit id="9784de560abfd12a3df7edbfce43582579bd83ea" translate="yes" xml:space="preserve">
          <source>Fast Alias</source>
          <target state="translated">快速别名</target>
        </trans-unit>
        <trans-unit id="b30639e5d7da09380f8d189ea58cefd7706fb2d8" translate="yes" xml:space="preserve">
          <source>Fast Integer Overflow Checks</source>
          <target state="translated">快速整数溢出检查</target>
        </trans-unit>
        <trans-unit id="0b12a136aeae505dcc0b7dbbf0dd96b9dfb9b43f" translate="yes" xml:space="preserve">
          <source>Fast implementation of SHA1</source>
          <target state="translated">快速实现SHA1</target>
        </trans-unit>
        <trans-unit id="f52bc5a79d93a586d9fd5f867d9e97fd2c1e94ed" translate="yes" xml:space="preserve">
          <source>Fast power modulus calculation for &lt;a href=&quot;#BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; operands.</source>
          <target state="translated">&lt;a href=&quot;#BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;操作数的快速功率模量计算。</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="5e04f2d50cdd060bbfcbfee4c55990dc2c53ebb6" translate="yes" xml:space="preserve">
          <source>Feeds a piece of data into the hash computation. This method allows the type to be used as an &lt;a href=&quot;std_range#OutputRange&quot;&gt;&lt;code&gt;std.range.OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将一段数据输入到哈希计算中。此方法允许将类型用作&lt;a href=&quot;std_range#OutputRange&quot;&gt; &lt;code&gt;std.range.OutputRange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef2e953b973aaaad728788af9fe005332250cfb9" translate="yes" xml:space="preserve">
          <source>Fetch a range that spans all the elements in the container.</source>
          <target state="translated">获取一个跨越容器中所有元素的范围。</target>
        </trans-unit>
        <trans-unit id="806c6077cb7a78f983cf9f3141f3488ff76bfb62" translate="yes" xml:space="preserve">
          <source>Fetch a set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; that have the given hangul syllable type.</source>
          <target state="translated">提取具有给定韩文音节类型的一组&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f82305ed0f65639966ae3ed3933a92d710f2e1b5" translate="yes" xml:space="preserve">
          <source>Fetches a portion of the container from key &lt;code&gt;a&lt;/code&gt; to key &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">从密钥 &lt;code&gt;a&lt;/code&gt; 到密钥 &lt;code&gt;b&lt;/code&gt; 获取容器的一部分。</target>
        </trans-unit>
        <trans-unit id="25fd3d77a2c1246116e41ea65fe998403f8ec08d" translate="yes" xml:space="preserve">
          <source>Fiber which embeds a ThreadInfo</source>
          <target state="translated">嵌入线程信息的光纤</target>
        </trans-unit>
        <trans-unit id="941f1ba20ae720e9df7d97f37ddc2a546949a068" translate="yes" xml:space="preserve">
          <source>Fibonacci numbers, using function in explicit form:</source>
          <target state="translated">斐波那契数,使用函数的明文形式。</target>
        </trans-unit>
        <trans-unit id="d046974a209aaf1dc186931ea0c33a691fda7aee" translate="yes" xml:space="preserve">
          <source>Field Properties</source>
          <target state="translated">字段属性</target>
        </trans-unit>
        <trans-unit id="107eaaea9a6cf7bffdc6f5831dadf9f4ae6e6dff" translate="yes" xml:space="preserve">
          <source>Field initialization inside a constructor</source>
          <target state="translated">在构造函数中进行字段初始化</target>
        </trans-unit>
        <trans-unit id="4bc4c6a8400a8c6f02130bcea08f292997d6b9f9" translate="yes" xml:space="preserve">
          <source>Field initialization inside constructor</source>
          <target state="translated">在构造函数中初始化字段</target>
        </trans-unit>
        <trans-unit id="c5a099fc15efbba12a358705f6143f4d6be98777" translate="yes" xml:space="preserve">
          <source>FieldInit[] &lt;strong id=&quot;fieldinit&quot;&gt;fieldinit&lt;/strong&gt;;</source>
          <target state="translated">FieldInit [] &lt;strong id=&quot;fieldinit&quot;&gt;fieldinit&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="0de912d25f2bf66472286b09fc92107582e1704b" translate="yes" xml:space="preserve">
          <source>Fields are by default initialized to the default initializer for their type (usually 0 for integer types and NAN for floating point types). If the field declaration has an optional &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; that will be used instead of the default.</source>
          <target state="translated">默认情况下，将字段初始化为其类型的默认初始化程序（对于整数类型，通常为0，对于浮点类型，则为NAN）。如果字段声明具有可选的&lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;初始化器&lt;/i&gt;&lt;/a&gt;，则将使用它而不是默认值。</target>
        </trans-unit>
        <trans-unit id="23cca95a6cdd188e6c7fc8755e8efb38d2d70c0e" translate="yes" xml:space="preserve">
          <source>Fields not specified in the</source>
          <target state="translated">未指定的字段</target>
        </trans-unit>
        <trans-unit id="208ad1de91661d0ad0a36ff8e397f7fa368d919b" translate="yes" xml:space="preserve">
          <source>Fields of &lt;code&gt;extern(Objective-C)&lt;/code&gt; classes have a dynamic offset. That means that the base class can change (add or remove instance variables) without the subclasses needing to recompile or relink.</source>
          <target state="translated">&lt;code&gt;extern(Objective-C)&lt;/code&gt; 类的字段具有动态偏移量。这意味着基类可以更改（添加或删除实例变量），而子类无需重新编译或重新链接。</target>
        </trans-unit>
        <trans-unit id="853d0fada94e86615dc6538f25f88964cc917132" translate="yes" xml:space="preserve">
          <source>Figure out what is being foreach'd over by looking at the ForeachAggregate.</source>
          <target state="translated">通过查看ForeachAggregate,找出被foreach的内容。</target>
        </trans-unit>
        <trans-unit id="30ce9f687ac35a29ae0ceb7c01a007d763160966" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">文件 &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e98c320744b7f0c7cb60ef318110b857423c138" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">文件 &lt;code&gt;file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f3f2227118512e7ca5c3ada9f680151527105c3" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/a.d&lt;/code&gt;:</source>
          <target state="translated">文件 &lt;code&gt;ns/a.d&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="748ef850240024ab9b9dfd885345924583894351" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/b.d&lt;/code&gt;:</source>
          <target state="translated">文件 &lt;code&gt;ns/b.d&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f3af95125686bb3393a41be2e1f0fecd04615870" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;ns/package.d&lt;/code&gt;:</source>
          <target state="translated">文件 &lt;code&gt;ns/package.d&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1aadfe8f43e9471a7ccd0a6d9513aa2d158d8fc8" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stderr&lt;/code&gt;</source>
          <target state="translated">文件 &lt;code&gt;stderr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2d5fc4ef533b94b6bad75f0391ad7ad10de8f26" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stdin&lt;/code&gt;</source>
          <target state="translated">文件 &lt;code&gt;stdin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e9228910eade205bba9f1037b88441eb129b20" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;stdout&lt;/code&gt;</source>
          <target state="translated">文件 &lt;code&gt;stdout&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9483d4c2825aba0712cc0561ced9af3cb73ecdf9" translate="yes" xml:space="preserve">
          <source>File &lt;strong id=&quot;openNetwork&quot;&gt;openNetwork&lt;/strong&gt;(string host, ushort port);</source>
          <target state="translated">文件&lt;strong id=&quot;openNetwork&quot;&gt;openNetwork&lt;/strong&gt;（字符串主机，ushort端口）；</target>
        </trans-unit>
        <trans-unit id="ce4206968eedd48fffee1e859866cc73f7755263" translate="yes" xml:space="preserve">
          <source>File descriptor to associate with this &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">与此 &lt;code&gt;File&lt;/code&gt; 关联的文件描述符。</target>
        </trans-unit>
        <trans-unit id="1e536d6d6e792234f9c45a8b85837120144d1507" translate="yes" xml:space="preserve">
          <source>File name to get times for.</source>
          <target state="translated">要获取次数的文件名。</target>
        </trans-unit>
        <trans-unit id="593c7807cce6682849c08e792d67a7b54a30c7c5" translate="yes" xml:space="preserve">
          <source>File names are case insensitive</source>
          <target state="translated">文件名不分大小写</target>
        </trans-unit>
        <trans-unit id="bba1cee852025b35d3e3478cf86257fa54326950" translate="yes" xml:space="preserve">
          <source>File names are case sensitive</source>
          <target state="translated">文件名区分大小写</target>
        </trans-unit>
        <trans-unit id="ddde036ce2875cbf396f907c8d72a294c865d6ee" translate="yes" xml:space="preserve">
          <source>File names on the DMD command line with the extension .ddoc are text files that are read and processed in order.</source>
          <target state="translated">DMD命令行中扩展名为.doc的文件名是按顺序读取和处理的文本文件。</target>
        </trans-unit>
        <trans-unit id="7b51622761aa9ab4147a65c01ed7a2f997bd6b63" translate="yes" xml:space="preserve">
          <source>File names to dispatch</source>
          <target state="translated">发送的文件名</target>
        </trans-unit>
        <trans-unit id="ab2a2923359cc254d1142cb254fa079493ce8064" translate="yes" xml:space="preserve">
          <source>File opened that is not a database file</source>
          <target state="translated">打开的文件不是数据库文件</target>
        </trans-unit>
        <trans-unit id="600941bc483d702b3e6700aa5c9df8eaacfc769f" translate="yes" xml:space="preserve">
          <source>File separator</source>
          <target state="translated">文件分隔符</target>
        </trans-unit>
        <trans-unit id="b8751b87838fad8e9c09877c3fcf2d38b742badf" translate="yes" xml:space="preserve">
          <source>File that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">名为 &lt;code&gt;_d_HookTraceImpl&lt;/code&gt; 的文件</target>
        </trans-unit>
        <trans-unit id="f6025d963ff7d5ab00dd321537b1088bcf0aa15c" translate="yes" xml:space="preserve">
          <source>File to read and split into its lines.</source>
          <target state="translated">读取文件并将其分割成行。</target>
        </trans-unit>
        <trans-unit id="4d239ce96517581903eea3ad6a5e5f8f129445d3" translate="yes" xml:space="preserve">
          <source>File to read lines from.</source>
          <target state="translated">要读行的文件。</target>
        </trans-unit>
        <trans-unit id="2a39297edcbf92570f7009a9439afaa0ade4a510" translate="yes" xml:space="preserve">
          <source>File.ReadResult &lt;code&gt;readResult&lt;/code&gt;</source>
          <target state="translated">File.ReadResult &lt;code&gt;readResult&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ba5924daeca1702606731ee6e33f3d6f5d8aeff" translate="yes" xml:space="preserve">
          <source>File/Folder name to get times for.</source>
          <target state="translated">要获取时间的文件/文件夹名称。</target>
        </trans-unit>
        <trans-unit id="b1281649a36423bcd13a1e5734562778e5a449fb" translate="yes" xml:space="preserve">
          <source>FileBuffer &lt;strong id=&quot;readFile&quot;&gt;readFile&lt;/strong&gt;(Loc loc, const(char)* filename);</source>
          <target state="translated">FileBuffer &lt;strong id=&quot;readFile&quot;&gt;readFile&lt;/strong&gt;（Loc loc，const（char）*文件名）;</target>
        </trans-unit>
        <trans-unit id="adb0ed28c9f6c61c2c5292ae0018a0dbd403f831" translate="yes" xml:space="preserve">
          <source>FileName &lt;strong id=&quot;setOutfilename&quot;&gt;setOutfilename&lt;/strong&gt;(const(char)[] name, const(char)[] dir, const(char)[] arg, const(char)[] ext);</source>
          <target state="translated">FileName &lt;strong id=&quot;setOutfilename&quot;&gt;setOutfilename&lt;/strong&gt;（const（char）[] name，const（char）[] dir，const（char）[] arg，const（char）[] ext）;复制代码</target>
        </trans-unit>
        <trans-unit id="2cdd52dc9b2dc3c92972beb5c0ac073541e5c497" translate="yes" xml:space="preserve">
          <source>Filename NULL</source>
          <target state="translated">文件名NULL</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="ac721011f794b0e8baf53f6a4a3ded5e6b587bdc" translate="yes" xml:space="preserve">
          <source>Files are dispatched in the various arrays (global.params.{ddocfiles,dllfiles,jsonfiles,etc...}) according to their extension. Binary files are added to libmodules.</source>
          <target state="translated">文件根据它们的扩展名被分配到各种数组(global.params.{ddocfiles,dllfiles,jsonfiles,等等...})中。二进制文件被添加到libmodules中。</target>
        </trans-unit>
        <trans-unit id="3c458791c8711a4da04ab0a8024c24f9c4200994" translate="yes" xml:space="preserve">
          <source>Fill in new entries below here!</source>
          <target state="translated">在这里填写下面的新作品!</target>
        </trans-unit>
        <trans-unit id="fec9699a2804108f414d1cbff9f937ab31b1059b" translate="yes" xml:space="preserve">
          <source>Fill in vtbl[] for base class based on member functions of class cd.</source>
          <target state="translated">根据类cd的成员函数,填写基类的vtbl[]。</target>
        </trans-unit>
        <trans-unit id="43d8814469e2dd06b7a4446e3a72fe3fb9b94b8b" translate="yes" xml:space="preserve">
          <source>Fill out remainder of elements[] with default initializers for fields[].</source>
          <target state="translated">用字段[]的默认初始化器填写元素[]的剩余部分。</target>
        </trans-unit>
        <trans-unit id="ce95d41d5dfbc8ae874f5267cf6c9192895a26f6" translate="yes" xml:space="preserve">
          <source>Fills a range (assumed uninitialized) with a value.</source>
          <target state="translated">用一个值填充一个范围(假设未初始化)。</target>
        </trans-unit>
        <trans-unit id="4af7384f97004098d0ba2d1490a26bd5ae8dc06c" translate="yes" xml:space="preserve">
          <source>Fills a range with a pattern, e.g., if &lt;code&gt;a = new int[3]&lt;/code&gt;, then &lt;code&gt;fill(a, 4)&lt;/code&gt; leaves &lt;code&gt;a = [4, 4, 4]&lt;/code&gt; and &lt;code&gt;fill(a, [3, 4])&lt;/code&gt; leaves &lt;code&gt;a = [3, 4, 3]&lt;/code&gt;.</source>
          <target state="translated">用模式填充范围，例如，如果 &lt;code&gt;a = new int[3]&lt;/code&gt; ，则 &lt;code&gt;fill(a, 4)&lt;/code&gt; 留下 &lt;code&gt;a = [4, 4, 4]&lt;/code&gt; 而 &lt;code&gt;fill(a, [3, 4])&lt;/code&gt; 留下 &lt;code&gt;a = [3, 4, 3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58c13531d89cbfd81b826ad0e0207a8e8f855efc" translate="yes" xml:space="preserve">
          <source>Fills in properties extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, expandedData[], name[], extra[].</source>
          <target state="translated">填充属性extractVersion、flags、compressionMethod、time、crc32、compressedSize、expandedSize、expandedData[]、name[]、extra[]。</target>
        </trans-unit>
        <trans-unit id="c839d156063c44cb328b154ceff7d45b6cd1f2d8" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], diskNumber, diskStartDir, numEntries, totalEntries, and directory[]. For each ArchiveMember, fills in properties crc32, compressedSize, compressedData[].</source>
          <target state="translated">填写属性data[]、diskNumber、diskStartDir、numEntries、totalEntries和directory[]。对于每个ArchiveMember,填写属性crc32、compressedSize、compressedData[]。</target>
        </trans-unit>
        <trans-unit id="ac430f749392cd86ab81a1eba5a5fa6084a02035" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], diskNumber, diskStartDir, numEntries, totalEntries, comment[], and directory[]. For each ArchiveMember, fills in properties madeVersion, extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, compressedData[], diskNumber, internalAttributes, externalAttributes, name[], extra[], comment[]. Use expand() to get the expanded data for each ArchiveMember.</source>
          <target state="translated">填写属性data[]、diskNumber、diskStartDir、numEntries、totalEntries、comment[]和directory[]。对于每个ArchiveMember,填写属性madeVersion、extractVersion、flags、compressionMethod、time、crc32、compressedSize、expandedSize、compressedData[]、diskNumber、internalAttributes、externalAttributes、name[]、extra[]、comment[]。使用expand()来获取每个ArchiveMember的扩展数据。</target>
        </trans-unit>
        <trans-unit id="46a5ea9f87c0b1df74d151c62691fe2ef4bb053c" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], totalEntries, and directory[]. For each ArchiveMember, fills in properties crc32, compressedSize, compressedData[].</source>
          <target state="translated">填写属性data[]、totalEntries、directory[]。对于每个ArchiveMember,填写属性crc32、compressedSize、compressedData[]。</target>
        </trans-unit>
        <trans-unit id="b346bd7916857edb9b3b4a990fd8d299ee339598" translate="yes" xml:space="preserve">
          <source>Fills in the properties data[], totalEntries, comment[], and directory[]. For each ArchiveMember, fills in properties madeVersion, extractVersion, flags, compressionMethod, time, crc32, compressedSize, expandedSize, compressedData[], internalAttributes, externalAttributes, name[], extra[], comment[]. Use expand() to get the expanded data for each ArchiveMember.</source>
          <target state="translated">填写属性data[]、totalEntries、comment[]和directory[]。对于每个 ArchiveMember,填写属性 madeVersion、extractVersion、flags、compressionMethod、time、crc32、compressedSize、expandedSize、compressedData[]、internalAttributes、externalAttributes、name[]、extra[]、comment[]。使用expand()来获取每个ArchiveMember的扩展数据。</target>
        </trans-unit>
        <trans-unit id="753c7b4dfb03e4b323218bfbcf8e9ce9e83fd215" translate="yes" xml:space="preserve">
          <source>Filter (higher-order function)</source>
          <target state="translated">滤波器(高阶函数</target>
        </trans-unit>
        <trans-unit id="e010e248c9fcbc07279b28e2d9cf39a816edeedc" translate="yes" xml:space="preserve">
          <source>Filtering Log Messages</source>
          <target state="translated">过滤日志信息</target>
        </trans-unit>
        <trans-unit id="b9cfd7e1924fe46ff476048bb232046b2445c30d" translate="yes" xml:space="preserve">
          <source>Filters an &lt;code&gt;AliasSeq&lt;/code&gt; using a template predicate. Returns an &lt;code&gt;AliasSeq&lt;/code&gt; of the elements which satisfy the predicate.</source>
          <target state="translated">使用模板谓词过滤 &lt;code&gt;AliasSeq&lt;/code&gt; 。返回满足谓词的元素的 &lt;code&gt;AliasSeq&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3a871296194a1fb868a45ed782c53f0637a842f" translate="yes" xml:space="preserve">
          <source>Final Classes</source>
          <target state="translated">毕业班</target>
        </trans-unit>
        <trans-unit id="c054c76415f8cf9cbfa3c705550abf7d2a659de6" translate="yes" xml:space="preserve">
          <source>Final Switch Statement</source>
          <target state="translated">最后的转换声明</target>
        </trans-unit>
        <trans-unit id="f28c69a57fd5a00b8c460d98af841dbdfc2cf776" translate="yes" xml:space="preserve">
          <source>Final classes cannot be subclassed:</source>
          <target state="translated">最后班级不能分班。</target>
        </trans-unit>
        <trans-unit id="ce6f1f9e3ddcc894278135e4f17b933043c105ab" translate="yes" xml:space="preserve">
          <source>Final variables cannot be directly mutated or rebound, but references reached through the variable are typed with their original mutability. It is equivalent to &lt;code&gt;final&lt;/code&gt; variables in D1 and Java, as well as &lt;code&gt;readonly&lt;/code&gt; variables in C#.</source>
          <target state="translated">最终变量不能直接突变或反弹，但通过变量到达的引用将使用其原始可变性进行键入。它等效于D1和Java中的 &lt;code&gt;final&lt;/code&gt; 变量，以及C＃中的 &lt;code&gt;readonly&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="0e2b4800b08f795f43f812ffedaf0e687b6d6874" translate="yes" xml:space="preserve">
          <source>Final!T &lt;strong id=&quot;makeFinal&quot;&gt;makeFinal&lt;/strong&gt;(T)(T t);</source>
          <target state="translated">Final！T &lt;strong id=&quot;makeFinal&quot;&gt;makeFinal&lt;/strong&gt;（T）（T t）;</target>
        </trans-unit>
        <trans-unit id="9e3e2e2f543272fd4cd5df84fdd43fdaeaef1da0" translate="yes" xml:space="preserve">
          <source>Final_Punctuation</source>
          <target state="translated">Final_Punctuation</target>
        </trans-unit>
        <trans-unit id="5651425846864705935b85d871957e1ebe78f459" translate="yes" xml:space="preserve">
          <source>Finalization hook, called FOR each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">Finalization钩子,for每个线程调用。不应假设模块初始化状态。</target>
        </trans-unit>
        <trans-unit id="3c0d51279d82c302cafb15142125c52a7d750035" translate="yes" xml:space="preserve">
          <source>Finalize A Dynamic String</source>
          <target state="translated">最终确定一个动态字符串</target>
        </trans-unit>
        <trans-unit id="c5174f6c9ec806f743432561800d7fb3cdce6c10" translate="yes" xml:space="preserve">
          <source>Finalize the data in this block on collect.</source>
          <target state="translated">在收集时最终确定这块的数据。</target>
        </trans-unit>
        <trans-unit id="1487ab4833797a8fe86e9e688a3c4af63df81678" translate="yes" xml:space="preserve">
          <source>Finalizes the computation of the hash and returns the computed value. Note that &lt;code&gt;finish&lt;/code&gt; can be called only once and that no subsequent calls to &lt;code&gt;put&lt;/code&gt; is allowed.</source>
          <target state="translated">完成哈希的计算并返回计算值。请注意， &lt;code&gt;finish&lt;/code&gt; 只能调用一次，并且不允许后续调用 &lt;code&gt;put&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edf7957cb21bb43e8c1e9e16262a7f52655c315a" translate="yes" xml:space="preserve">
          <source>Finally, any combination of integral offsets and tuples composed of two integral offsets can be passed in:</source>
          <target state="translated">最后,积分偏移量和由两个积分偏移量组成的元组的任意组合都可以传递进来。</target>
        </trans-unit>
        <trans-unit id="8318badcbf1d40a64d4bffbf97bd0efd4cae1f40" translate="yes" xml:space="preserve">
          <source>Finally, if the user-defined type is to be used as a key in the built-in associative arrays, then the programmer must ensure that the semantics of &lt;code&gt;opEquals&lt;/code&gt; and &lt;code&gt;toHash&lt;/code&gt; are consistent. If not, the associative array may not work in the expected manner.</source>
          <target state="translated">最后，如果要将用户定义的类型用作内置关联数组中的键，则程序员必须确保 &lt;code&gt;opEquals&lt;/code&gt; 和 &lt;code&gt;toHash&lt;/code&gt; 的语义一致。如果不是，则关联数组可能无法按预期方式工作。</target>
        </trans-unit>
        <trans-unit id="63ebc2a4bae0f29d985262d1e0a7882d311b33e0" translate="yes" xml:space="preserve">
          <source>Finally, it includes some convenience functions for manipulating ranges:</source>
          <target state="translated">最后,它包含了一些操作范围的方便函数。</target>
        </trans-unit>
        <trans-unit id="957ad37fd6f0cb718a9dbc02f2623b3113168bed" translate="yes" xml:space="preserve">
          <source>Finally, there is no guarantee that using &lt;code&gt;FPTemporary!F&lt;/code&gt; will always be fastest, as the speed of floating-point calculations depends on very many factors.</source>
          <target state="translated">最后，不能保证使用 &lt;code&gt;FPTemporary!F&lt;/code&gt; 总是最快的，因为浮点计算的速度取决于很多因素。</target>
        </trans-unit>
        <trans-unit id="1e7650a8c491fd4a8a63008ab0b8ff54cd68ebd3" translate="yes" xml:space="preserve">
          <source>FinallyStatement</source>
          <target state="translated">FinallyStatement</target>
        </trans-unit>
        <trans-unit id="af66114eea030ebc5f2464aa23997a938e455374" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;ident&lt;/code&gt; in an array of identifiers.</source>
          <target state="translated">在标识符数组中查找 &lt;code&gt;ident&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88937cdca6cc08c5d7dbfa18ae72ed67be952ed2" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;value&lt;/code&gt; among &lt;code&gt;values&lt;/code&gt;, returning the 1-based index of the first matching value in &lt;code&gt;values&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;value&lt;/code&gt; is not among &lt;code&gt;values&lt;/code&gt;. The predicate &lt;code&gt;pred&lt;/code&gt; is used to compare values, and uses equality by default.</source>
          <target state="translated">发现 &lt;code&gt;value&lt;/code&gt; 之间 &lt;code&gt;values&lt;/code&gt; ，返回在第一个匹配值的基于1的索引 &lt;code&gt;values&lt;/code&gt; ，或 &lt;code&gt;0&lt;/code&gt; ，如果 &lt;code&gt;value&lt;/code&gt; 不是中 &lt;code&gt;values&lt;/code&gt; 。谓词 &lt;code&gt;pred&lt;/code&gt; 用于比较值，默认情况下使用相等。</target>
        </trans-unit>
        <trans-unit id="545769c2d22b47615aaec611ab60b4390f1d36ac" translate="yes" xml:space="preserve">
          <source>Find The Database Handle Of A Prepared Statement</source>
          <target state="translated">查找已准备好的报表的数据库句柄。</target>
        </trans-unit>
        <trans-unit id="8ed4d78384609c747738b51bd99d57a7cbe3bca7" translate="yes" xml:space="preserve">
          <source>Find a common root between &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;. If there is no common root, return &lt;code&gt;path&lt;/code&gt; unaltered.</source>
          <target state="translated">在 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;base&lt;/code&gt; 之间找到一个共同的根。如果没有公共根，则返回 &lt;code&gt;path&lt;/code&gt; 不变。</target>
        </trans-unit>
        <trans-unit id="3cc4bdb526e48e9b0169cef3864d16c67f747c87" translate="yes" xml:space="preserve">
          <source>Find a real minimum of a real function &lt;code&gt;f(x)&lt;/code&gt; via bracketing. Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;(ax .. bx)&lt;/code&gt;, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a minimum of &lt;code&gt;f(x)&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; is never evaluted at the endpoints of &lt;code&gt;ax&lt;/code&gt; and &lt;code&gt;bx&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one minimum in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN or -Infinity, &lt;code&gt;(x, f(x), NaN)&lt;/code&gt; will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">通过括号找到实函数 &lt;code&gt;f(x)&lt;/code&gt; 的实最小值。给定一个函数 &lt;code&gt;f&lt;/code&gt; 和一个范围 &lt;code&gt;(ax .. bx)&lt;/code&gt; ，将返回最接近 &lt;code&gt;f(x)&lt;/code&gt; 最小值的范围内的 &lt;code&gt;x&lt;/code&gt; 值。 &lt;code&gt;f&lt;/code&gt; 从未在 &lt;code&gt;ax&lt;/code&gt; 和 &lt;code&gt;bx&lt;/code&gt; 的端点求值。如果 &lt;code&gt;f(x)&lt;/code&gt; 在该范围内具有多个最小值，则将任意选择一个。如果 &lt;code&gt;f(x)&lt;/code&gt; 返回NaN或-Infinity，则将返回 &lt;code&gt;(x, f(x), NaN)&lt;/code&gt; ；否则，保证该算法成功。</target>
        </trans-unit>
        <trans-unit id="dc439799cd4737f8236f05600fc64a52e0bdee1d" translate="yes" xml:space="preserve">
          <source>Find a real root of a real function f(x) via bracketing.</source>
          <target state="translated">通过括号求出实函数f(x)的实根。</target>
        </trans-unit>
        <trans-unit id="d9ea8a7553428e4555c42a356e28f37d1f30dc20" translate="yes" xml:space="preserve">
          <source>Find all instance fields, then push them into &lt;code&gt;fields&lt;/code&gt;.</source>
          <target state="translated">找到所有实例字段，然后将其放入 &lt;code&gt;fields&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f0f2515c2b37286fa318cf443dfdda11744bc3e" translate="yes" xml:space="preserve">
          <source>Find all variables accessed by this delegate that are in functions enclosing it.</source>
          <target state="translated">找到这个委托人访问的所有变量,这些变量都在包围它的函数中。</target>
        </trans-unit>
        <trans-unit id="41ae1d4488620fcf9a1fa1a9eea694e8dd8ef394" translate="yes" xml:space="preserve">
          <source>Find function in overload list that exactly matches t.</source>
          <target state="translated">在重载列表中找到与t完全匹配的函数。</target>
        </trans-unit>
        <trans-unit id="edff7cacecc816c7b2bf341caacbadeda732cdfa" translate="yes" xml:space="preserve">
          <source>Find function in overload list that matches to the 'this' modifier. There's four result types.</source>
          <target state="translated">在重载列表中找到与'this'修饰符匹配的函数。有四种结果类型。</target>
        </trans-unit>
        <trans-unit id="f0c98c985999ca34facaa820a09d254832cfa98f" translate="yes" xml:space="preserve">
          <source>Find index of function in vtbl[0..dim] that this function overrides. Prefer an exact match to a covariant one.</source>
          <target state="translated">在vtbl[0..dim]中找到这个函数覆盖的函数索引。倾向于精确匹配而不是共变匹配。</target>
        </trans-unit>
        <trans-unit id="8a869c31c58148141fe2bb0252ad8f9ecb8a528b" translate="yes" xml:space="preserve">
          <source>Find last statement in a sequence of statements.</source>
          <target state="translated">在一系列语句中找到最后一条语句。</target>
        </trans-unit>
        <trans-unit id="d69cdad0f7e718c4389bc96b6e8484b75621891a" translate="yes" xml:space="preserve">
          <source>Find root of a real function f(x) by bracketing, allowing the termination condition to be specified.</source>
          <target state="translated">通过括号查找实函数f(x)的根,允许指定终止条件。</target>
        </trans-unit>
        <trans-unit id="2fb393ab419b2e3f0988a888618d55945a606a1c" translate="yes" xml:space="preserve">
          <source>Find template declaration corresponding to template instance.</source>
          <target state="translated">找到模板实例对应的模板声明。</target>
        </trans-unit>
        <trans-unit id="e56b93cf2f4450a7eaf19462aacfb88f33166737" translate="yes" xml:space="preserve">
          <source>Find the config file</source>
          <target state="translated">找到配置文件</target>
        </trans-unit>
        <trans-unit id="d2dd908c00ec01e1d2253d53d434daf6a1857fe3" translate="yes" xml:space="preserve">
          <source>Find the first (leftmost) slice of the &lt;code&gt;input&lt;/code&gt; that matches the pattern &lt;code&gt;re&lt;/code&gt;. This function picks the most suitable regular expression engine depending on the pattern properties.</source>
          <target state="translated">找到与模式 &lt;code&gt;re&lt;/code&gt; 匹配的 &lt;code&gt;input&lt;/code&gt; 的第一个（最左侧）切片。此函数根据模式属性选择最合适的正则表达式引擎。</target>
        </trans-unit>
        <trans-unit id="b74109ae76fb090044e9df5875f1c38828f427c5" translate="yes" xml:space="preserve">
          <source>Find the first non-comma expression.</source>
          <target state="translated">找到第一个非逗号表达式。</target>
        </trans-unit>
        <trans-unit id="6cc3fb2f138f676cf6a94d5a2c6b5519efc51d83" translate="yes" xml:space="preserve">
          <source>Find the last non-comma expression.</source>
          <target state="translated">找到最后一个非逗号的表达式。</target>
        </trans-unit>
        <trans-unit id="19feb6b0e0b231038a55e2bf709f34b7a893df27" translate="yes" xml:space="preserve">
          <source>Find virtual function matching identifier and type. Used to build virtual function tables for interface implementations.</source>
          <target state="translated">查找匹配标识符和类型的虚拟函数。用于建立接口实现的虚拟函数表。</target>
        </trans-unit>
        <trans-unit id="1f779fad43ff937e8c60b5135580f17f7fea9279" translate="yes" xml:space="preserve">
          <source>Finds &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; and positions &lt;code&gt;haystack&lt;/code&gt; right after the first occurrence of &lt;code&gt;needle&lt;/code&gt;.</source>
          <target state="translated">发现 &lt;code&gt;needle&lt;/code&gt; 在 &lt;code&gt;haystack&lt;/code&gt; 和立场 &lt;code&gt;haystack&lt;/code&gt; 的第一次出现之后 &lt;code&gt;needle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dffa198dc7c767b46fa65ebc9d63a3a8195c5965" translate="yes" xml:space="preserve">
          <source>Finds &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; efficiently using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt; Boyer-Moore&lt;/a&gt; method.</source>
          <target state="translated">使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore&lt;/a&gt;方法可以有效地在 &lt;code&gt;haystack&lt;/code&gt; 找到 &lt;code&gt;needle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4aab22f9bf13ade683a53be805bd158b6756b54" translate="yes" xml:space="preserve">
          <source>Finds a &lt;code&gt;dmd.conf&lt;/code&gt; and parses it for import paths. This depends on the &lt;code&gt;$DMD&lt;/code&gt; environment variable. If &lt;code&gt;$DMD&lt;/code&gt; is set to &lt;code&gt;ldmd&lt;/code&gt;, it will try to detect and parse a &lt;code&gt;ldc2.conf&lt;/code&gt; instead.</source>
          <target state="translated">查找 &lt;code&gt;dmd.conf&lt;/code&gt; 并将其解析为导入路径。这取决于 &lt;code&gt;$DMD&lt;/code&gt; 环境变量。如果 &lt;code&gt;$DMD&lt;/code&gt; 设置为 &lt;code&gt;ldmd&lt;/code&gt; ，它将尝试检测并解析 &lt;code&gt;ldc2.conf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db4503384752d61843483992d0609b3513a269cd" translate="yes" xml:space="preserve">
          <source>Finds an individual element in an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;. Elements of &lt;code&gt;haystack&lt;/code&gt; are compared with &lt;code&gt;needle&lt;/code&gt; by using predicate &lt;code&gt;pred&lt;/code&gt; with &lt;code&gt;pred(haystack.front, needle)&lt;/code&gt;. &lt;code&gt;find&lt;/code&gt; performs &amp;Omicron;(&lt;code&gt;walkLength(haystack)&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">在&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围内&lt;/a&gt;查找单个元素。的元件 &lt;code&gt;haystack&lt;/code&gt; 与比较 &lt;code&gt;needle&lt;/code&gt; 通过使用谓词 &lt;code&gt;pred&lt;/code&gt; 与 &lt;code&gt;pred(haystack.front, needle)&lt;/code&gt; 。 &lt;code&gt;find&lt;/code&gt; 执行 &lt;code&gt;pred&lt;/code&gt; 的 &amp;Omicron;（ &lt;code&gt;walkLength(haystack)&lt;/code&gt; ）个评估。</target>
        </trans-unit>
        <trans-unit id="494b5c575695991289f1af6c553e989e7554d283" translate="yes" xml:space="preserve">
          <source>Finds multiple attributes</source>
          <target state="translated">查找多个属性</target>
        </trans-unit>
        <trans-unit id="dc6ca4363cb66199d14c81638ae0bacb275a040f" translate="yes" xml:space="preserve">
          <source>Finds nothing if there is no member with specific UDA</source>
          <target state="translated">如果没有特定的UDA成员,则什么也找不到。</target>
        </trans-unit>
        <trans-unit id="372b352a9faabc1d4848c96cff7df7512a64b542" translate="yes" xml:space="preserve">
          <source>Finds the mean (colloquially known as the average) of a range.</source>
          <target state="translated">找出一个范围的平均值(俗称平均数)。</target>
        </trans-unit>
        <trans-unit id="acc839859781d1a6fe4c1aa11b5d0cad6c9f277f" translate="yes" xml:space="preserve">
          <source>Finds the quotient and remainder for the given dividend and divisor in one operation.</source>
          <target state="translated">在一次操作中完成给定的红利和除数的商和余数。</target>
        </trans-unit>
        <trans-unit id="1f42db37e0be1957bbb7a73bd93bbacc6f6971b6" translate="yes" xml:space="preserve">
          <source>Finds two or more &lt;code&gt;needles&lt;/code&gt; into a &lt;code&gt;haystack&lt;/code&gt;. The predicate &lt;code&gt;pred&lt;/code&gt; is used throughout to compare elements. By default, elements are compared for equality.</source>
          <target state="translated">查找两个或两个以上 &lt;code&gt;needles&lt;/code&gt; 入 &lt;code&gt;haystack&lt;/code&gt; 。谓词 &lt;code&gt;pred&lt;/code&gt; 始终用于比较元素。默认情况下，比较元素是否相等。</target>
        </trans-unit>
        <trans-unit id="e49c750f94dfbe0f01c55cba7ce3a3fca1cb43ad" translate="yes" xml:space="preserve">
          <source>Finish and return completed data structure.</source>
          <target state="translated">完成并返回已完成的数据结构。</target>
        </trans-unit>
        <trans-unit id="910917ab298e1770af3ee0a6c87f4500d8fc3b35" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), and then attempts to associate the given Windows &lt;code&gt;HANDLE&lt;/code&gt; with the &lt;code&gt;File&lt;/code&gt;. The mode must be compatible with the access attributes of the handle. Windows only.</source>
          <target state="translated">首先调用 &lt;code&gt;detach&lt;/code&gt; （失败时抛出），然后尝试将给定的Windows &lt;code&gt;HANDLE&lt;/code&gt; 与 &lt;code&gt;File&lt;/code&gt; 关联。该模式必须与句柄的访问属性兼容。仅Windows。</target>
        </trans-unit>
        <trans-unit id="dcaf56d0ddc5fc561f47a3812f5bb4243cf6c321" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), and then attempts to associate the given file descriptor with the &lt;code&gt;File&lt;/code&gt;. The mode must be compatible with the mode of the file descriptor.</source>
          <target state="translated">首先调用 &lt;code&gt;detach&lt;/code&gt; （失败时抛出），然后尝试将给定的文件描述符与 &lt;code&gt;File&lt;/code&gt; 关联。该模式必须与文件描述符的模式兼容。</target>
        </trans-unit>
        <trans-unit id="7f59c090d80233a5077fc16f2881b79e76399aaf" translate="yes" xml:space="preserve">
          <source>First calls &lt;code&gt;detach&lt;/code&gt; (throwing on failure), then attempts to associate the given file descriptor with the &lt;code&gt;File&lt;/code&gt;, and sets the file's name to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">首先调用 &lt;code&gt;detach&lt;/code&gt; （失败时抛出），然后尝试将给定的文件描述符与 &lt;code&gt;File&lt;/code&gt; 关联，并将文件名设置为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9a4e48dd9c9e9c16b3c2bdc21882e910e46f414" translate="yes" xml:space="preserve">
          <source>First checks whether there's enough slack memory preallocated for &lt;code&gt;b&lt;/code&gt; by evaluating &lt;code&gt;b.length + delta &amp;lt;= goodAllocSize(b.length)&lt;/code&gt;. If that's the case, expands &lt;code&gt;b&lt;/code&gt; in place. Otherwise, attempts to use &lt;code&gt;parent.expand&lt;/code&gt; appropriately if present.</source>
          <target state="translated">首先，通过评估 &lt;code&gt;b.length + delta &amp;lt;= goodAllocSize(b.length)&lt;/code&gt; 检查是否为 &lt;code&gt;b&lt;/code&gt; 预分配了足够的空闲内存。在这种情况下，将 &lt;code&gt;b&lt;/code&gt; 展开到适当的位置。否则，尝试适当地使用 &lt;code&gt;parent.expand&lt;/code&gt; (如果存在）。</target>
        </trans-unit>
        <trans-unit id="232d9e5b94637d4aff68a5613d4eb2c442d5e710" translate="yes" xml:space="preserve">
          <source>First element of range is the whole match.</source>
          <target state="translated">范围的第一个元素是整个匹配。</target>
        </trans-unit>
        <trans-unit id="19eb5d2bea28d68e63b34cd9da02ecb96eb4de74" translate="yes" xml:space="preserve">
          <source>First element, null if *plist is null</source>
          <target state="translated">第一个元素,如果*plist为空,则为空。</target>
        </trans-unit>
        <trans-unit id="56336174ab5678a8f418a8043d57e8c559fdf20f" translate="yes" xml:space="preserve">
          <source>First enum member value</source>
          <target state="translated">第一个枚举成员值</target>
        </trans-unit>
        <trans-unit id="61c434e488f86b8e6b440a94d71c3f4ce5c76af6" translate="yes" xml:space="preserve">
          <source>First item to compare.</source>
          <target state="translated">第一个要比较的项目。</target>
        </trans-unit>
        <trans-unit id="eb036d61b03c52aec70ded61cf94c0bb2799a5dc" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;S(1)&lt;/code&gt; and &lt;code&gt;S(2)&lt;/code&gt; are evaluated in lexical order. Per the rules, they will be destroyed at the end of the full expression and in reverse order. The comparison &lt;code&gt;S(1) == S(2)&lt;/code&gt; yields &lt;code&gt;false&lt;/code&gt;, so the right-hand side of the &lt;code&gt;||&lt;/code&gt; is evaluated causing &lt;code&gt;S(3)&lt;/code&gt; and &lt;code&gt;S(4)&lt;/code&gt; to be evaluated, also in lexical order. However, their destruction is not deferred to the end of the full expression. Instead, &lt;code&gt;S(4)&lt;/code&gt; and then &lt;code&gt;S(3)&lt;/code&gt; are destroyed at the end of the &lt;code&gt;||&lt;/code&gt; expression. Following their destruction, &lt;code&gt;S(5)&lt;/code&gt; and &lt;code&gt;S(6)&lt;/code&gt; are constructed in lexical order. Again they are not destroyed at the end of the full expression, but right at the end of the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression. Consequently, the destruction of &lt;code&gt;S(6)&lt;/code&gt; and &lt;code&gt;S(5)&lt;/code&gt; is carried before that of &lt;code&gt;S(2)&lt;/code&gt; and &lt;code&gt;S(1)&lt;/code&gt;.</source>
          <target state="translated">首先，以词法顺序评估 &lt;code&gt;S(1)&lt;/code&gt; 和 &lt;code&gt;S(2)&lt;/code&gt; 。根据规则，它们将在完整表达式的末尾以相反的顺序销毁。比较 &lt;code&gt;S(1) == S(2)&lt;/code&gt; 得出 &lt;code&gt;false&lt;/code&gt; ，因此 &lt;code&gt;||&lt;/code&gt; 的右侧被评估导致 &lt;code&gt;S(3)&lt;/code&gt; 和 &lt;code&gt;S(4)&lt;/code&gt; 也被按词法顺序进行评估。但是，它们的销毁不会推迟到完整表达的结尾。相反，在 &lt;code&gt;||&lt;/code&gt; 的末尾销毁了 &lt;code&gt;S(4)&lt;/code&gt; 和 &lt;code&gt;S(3)&lt;/code&gt; 。表达。销毁后， &lt;code&gt;S(5)&lt;/code&gt; 和 &lt;code&gt;S(6)&lt;/code&gt; 按词汇顺序构造。同样，它们不会在完整表达式的末尾销毁，而是在 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 表达式的末尾销毁。因此，对 &lt;code&gt;S(6)&lt;/code&gt; 和 &lt;code&gt;S(5)&lt;/code&gt; 的破坏要早于 &lt;code&gt;S(2)&lt;/code&gt; 和 &lt;code&gt;S(1)&lt;/code&gt; 的破坏。</target>
        </trans-unit>
        <trans-unit id="35821ff9eaf82cccb4cd374c06db922677ab7c04" translate="yes" xml:space="preserve">
          <source>First, an instance of the reference-counted HTTP struct is created. Then the custom delegates are set. These will be called whenever the HTTP instance receives a header and a data buffer, respectively. In this simple example, the headers are written to stdout and the data is ignored. If the request should be stopped before it has finished then return something less than data.length from the onReceive callback. See &lt;a href=&quot;#onReceiveHeader&quot;&gt;&lt;code&gt;onReceiveHeader&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#onReceive&quot;&gt;&lt;code&gt;onReceive&lt;/code&gt;&lt;/a&gt; for more information. Finally the HTTP request is effected by calling perform(), which is synchronous.</source>
          <target state="translated">首先，创建引用计数的HTTP结构的实例。然后设置自定义委托。每当HTTP实例接收标头和数据缓冲区时，将分别调用它们。在这个简单的示例中，标头被写入到stdout，并且数据被忽略。如果请求应在完成之前停止，则从onReceive回调返回小于data.length的内容。有关更多信息，请参见&lt;a href=&quot;#onReceiveHeader&quot;&gt; &lt;code&gt;onReceiveHeader&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#onReceive&quot;&gt; &lt;code&gt;onReceive&lt;/code&gt; &lt;/a&gt;。最后，通过调用perform（）来实现HTTP请求，该同步是同步的。</target>
        </trans-unit>
        <trans-unit id="ddff6cdec0a5bb1099424737e7832e8c05999395" translate="yes" xml:space="preserve">
          <source>First, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are done on the operands. The result type of a relational expression is &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">首先，&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常的算术转换&lt;/a&gt;是在操作数上完成的。关系表达式的结果类型为 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4957bf53799feeb05b63a3d6e973fd8fa8760f6f" translate="yes" xml:space="preserve">
          <source>FirstExp</source>
          <target state="translated">FirstExp</target>
        </trans-unit>
        <trans-unit id="5613e8ed3a8c422a59b73ed2d59f778f438baaf8" translate="yes" xml:space="preserve">
          <source>Fit elements[] to the corresponding types of the struct's fields.</source>
          <target state="translated">将元素[]匹配到结构的字段的相应类型中。</target>
        </trans-unit>
        <trans-unit id="2fdb1b8027c76adc716597ecea40dafd0a1d1761" translate="yes" xml:space="preserve">
          <source>Fixed-size allocation (unlikely to get reallocated later). Examples: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, any &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; type. By default it is assumed that the allocation is variable-size, i.e. susceptible to later reallocation (for example all array types). This flag is advisory, i.e. in-place resizing may be attempted for &lt;code&gt;fixedSize&lt;/code&gt; allocations and may succeed. The flag is just a hint to the compiler it may use allocation strategies that work well with objects of fixed size.</source>
          <target state="translated">固定大小的分配（以后可能无法重新分配）。示例： &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; ，任何 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;class&lt;/code&gt; 类型。默认情况下，假定分配是可变大小的，即易于以后再分配（例如，所有数组类型）。此标志是建议性的，即，可以为 &lt;code&gt;fixedSize&lt;/code&gt; 分配尝试就地调整大小，并且可能成功。该标志只是对编译器的提示，它可能会使用与固定大小的对象配合使用的分配策略。</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="6349adf8f4924cf71432b2cc8b99298a02da104f" translate="yes" xml:space="preserve">
          <source>Flag for indicating if the isEmail function should perform a DNS check or not.</source>
          <target state="translated">用于指示isEmail函数是否应该执行DNS检查的标志。</target>
        </trans-unit>
        <trans-unit id="01fd2d670ffad32f041db95fdb5fd34e662c1fd5" translate="yes" xml:space="preserve">
          <source>Flag indicating if help was requested</source>
          <target state="translated">表示是否请求帮助的标志</target>
        </trans-unit>
        <trans-unit id="4839649a06c4517e676f395e7fb017b70b5e26a6" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a search is case-sensitive.</source>
          <target state="translated">表示搜索是否区分大小写的标志。</target>
        </trans-unit>
        <trans-unit id="728d7e2f5a2090a340dd62e4890170496eb26f90" translate="yes" xml:space="preserve">
          <source>Flag to control rethrow behavior of &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">标记以控制 &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 重新抛出行为</target>
        </trans-unit>
        <trans-unit id="e2bb64de167476df8d3672619e1590b0a282bc6b" translate="yes" xml:space="preserve">
          <source>Flag to specify whether or not an exception is thrown on error.</source>
          <target state="translated">用于指定是否在错误时抛出异常的标志。</target>
        </trans-unit>
        <trans-unit id="c2cc357fb7c03c09f92dcb1aaffc28e51837dbc6" translate="yes" xml:space="preserve">
          <source>Flag used by &lt;a href=&quot;#resolveFuncCall&quot;&gt;&lt;code&gt;resolveFuncCall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#resolveFuncCall&quot;&gt; &lt;code&gt;resolveFuncCall&lt;/code&gt; &lt;/a&gt;使用的标志。</target>
        </trans-unit>
        <trans-unit id="dfa1ebe73458327f2f1b2331e7d2bc64bda02225" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Iterable)(auto ref Iterable r)</source>
          <target state="translated">标记！&amp;ldquo; &lt;strong id=&quot;each&quot;&gt;每个&lt;/strong&gt; &amp;rdquo; &lt;strong id=&quot;each&quot;&gt;每个&lt;/strong&gt;（Iterable）（auto ref Iterable r）</target>
        </trans-unit>
        <trans-unit id="2e29bfd584368e0b6c450b93dff8e2b4b7d7e79b" translate="yes" xml:space="preserve">
          <source>Flag!&quot;&lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;&quot; &lt;strong id=&quot;each&quot;&gt;each&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">标记！&amp;ldquo; &lt;strong id=&quot;each&quot;&gt;每个&lt;/strong&gt; &amp;rdquo; &lt;strong id=&quot;each&quot;&gt;每个&lt;/strong&gt;（Range）（Range r）</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="a98a30dbf66202f4a1ca6fcfeff706e1cb961f9b" translate="yes" xml:space="preserve">
          <source>Flags affect formatting depending on the specifier as follows.</source>
          <target state="translated">影响格式的标志取决于指定者,具体如下。</target>
        </trans-unit>
        <trans-unit id="517da122a2fd8a775a91cf3934a2421fdfecad5e" translate="yes" xml:space="preserve">
          <source>Flags may be OR'ed together:</source>
          <target state="translated">旗帜可以一起被OR。</target>
        </trans-unit>
        <trans-unit id="9a817b12d43958a297fe78c774ef0aab232c3032" translate="yes" xml:space="preserve">
          <source>Flags that can be passed to &lt;a href=&quot;#pipeProcess&quot;&gt;&lt;code&gt;pipeProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pipeShell&quot;&gt;&lt;code&gt;pipeShell&lt;/code&gt;&lt;/a&gt; to specify which of the child process' standard streams are redirected. Use bitwise OR to combine flags.</source>
          <target state="translated">可以传递给&lt;a href=&quot;#pipeProcess&quot;&gt; &lt;code&gt;pipeProcess&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pipeShell&quot;&gt; &lt;code&gt;pipeShell&lt;/code&gt; 的&lt;/a&gt;标志，以指定重定向子进程的标准流。使用按位或来组合标志。</target>
        </trans-unit>
        <trans-unit id="d7bf08131e02f1b45b6731cfdb8ac81266998286" translate="yes" xml:space="preserve">
          <source>Flags that control how json is encoded and parsed.</source>
          <target state="translated">控制json如何编码和解析的标志。</target>
        </trans-unit>
        <trans-unit id="9101e63c4b97693993f5de7e6caad68a3e230e45" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags, and note that the &lt;code&gt;retainStd...&lt;/code&gt; flags have no effect in this function.</source>
          <target state="translated">控制进程创建的标志。有关可用标志的概述，请参见&lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;。请注意， &lt;code&gt;retainStd...&lt;/code&gt; 标志对该功能无效。</target>
        </trans-unit>
        <trans-unit id="8fa52f42ca8ff70a9db0dc2e586798abb191d35d" translate="yes" xml:space="preserve">
          <source>Flags that control process creation. See &lt;a href=&quot;#Config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">控制进程创建的标志。有关可用标志的概述，请参见&lt;a href=&quot;#Config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0978ac0b3ccfd7282e3c33d010ed6583a1755a4" translate="yes" xml:space="preserve">
          <source>Flags that control the behaviour of process creation functions in this module. Most flags only apply to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">控制此模块中流程创建功能行为的标志。大多数标志仅适用于&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a98c5de453c2c7c3caf6bb14f159914e55de8b90" translate="yes" xml:space="preserve">
          <source>Flags that determine which streams are redirected, and how. See &lt;a href=&quot;#Redirect&quot;&gt;&lt;code&gt;Redirect&lt;/code&gt;&lt;/a&gt; for an overview of available flags.</source>
          <target state="translated">确定哪些流以及如何重定向的标志。有关可用标志的概述，请参见&lt;a href=&quot;#Redirect&quot;&gt; &lt;code&gt;Redirect&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b620409ddfc3fc2bb8b14e73ba7780a044ad90c9" translate="yes" xml:space="preserve">
          <source>Flatten out the scope by presenting the statement as an array of statements.</source>
          <target state="translated">通过将语句作为一个语句数组来呈现,从而将范围扁平化。</target>
        </trans-unit>
        <trans-unit id="69f2ec628a1c75aed5c37949245c44cc81da511d" translate="yes" xml:space="preserve">
          <source>Flips a single bit, specified by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">翻转一位，由 &lt;code&gt;pos&lt;/code&gt; 指定</target>
        </trans-unit>
        <trans-unit id="a4e1ce065ff47fa12c8210de50047287b30b8075" translate="yes" xml:space="preserve">
          <source>Flips all the bits in the &lt;code&gt;BitArray&lt;/code&gt;</source>
          <target state="translated">翻转 &lt;code&gt;BitArray&lt;/code&gt; 中的所有位</target>
        </trans-unit>
        <trans-unit id="f980f6669a99ae97aa471b598c62ac0c3e1f823b" translate="yes" xml:space="preserve">
          <source>Floating Point</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="a7a463a748e16b2f5b0e11e3ae1b317ccea7b0fc" translate="yes" xml:space="preserve">
          <source>Floating Point Constant Folding</source>
          <target state="translated">浮点恒定折线</target>
        </trans-unit>
        <trans-unit id="d66cb8936a51df45efbb55e9f325e90025cbbefc" translate="yes" xml:space="preserve">
          <source>Floating Point Intermediate Values</source>
          <target state="translated">浮点中间值</target>
        </trans-unit>
        <trans-unit id="a6c4e80d19a5698157c68955c5feabc616b55ad5" translate="yes" xml:space="preserve">
          <source>Floating Point Literals</source>
          <target state="translated">浮点文字</target>
        </trans-unit>
        <trans-unit id="549c1462b87072d7712396a53e8de6f7b9f76688" translate="yes" xml:space="preserve">
          <source>Floating Point Transformations</source>
          <target state="translated">浮点变换</target>
        </trans-unit>
        <trans-unit id="2bed0fff60a5113135f273ef65f90946ade02e38" translate="yes" xml:space="preserve">
          <source>Floating literals can have embedded &amp;lsquo;_&amp;rsquo; characters to improve readability, and which are ignored.</source>
          <target state="translated">浮动文字可以嵌入'_'字符以提高可读性，这些字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="00848e3da3c10e7ab7937982dcd4c2d2c3dffaaa" translate="yes" xml:space="preserve">
          <source>Floating literals can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">浮动文字可以包含嵌入的&amp;ldquo; _&amp;rdquo;字符，这些字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="2f633a3ecaf3e65628ed43650f2d2e7563e4708a" translate="yes" xml:space="preserve">
          <source>Floating literals with no suffix are of type &lt;code&gt;double&lt;/code&gt;. Floating literals followed by &lt;b&gt;f&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; are of type &lt;code&gt;float&lt;/code&gt;, and those followed by &lt;b&gt;L&lt;/b&gt; are of type &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">不带后缀的浮点文字为 &lt;code&gt;double&lt;/code&gt; 类型。紧随其后的&lt;b&gt;f&lt;/b&gt;或&lt;b&gt;F的&lt;/b&gt;浮点文字为 &lt;code&gt;float&lt;/code&gt; 类型，而紧随其后的&lt;b&gt;L&lt;/b&gt;的 &lt;code&gt;real&lt;/code&gt; 为real类型。</target>
        </trans-unit>
        <trans-unit id="01668267e3349ef380ebd600403f931fc5d66ef9" translate="yes" xml:space="preserve">
          <source>Floating literals with no suffix are of type &lt;code&gt;double&lt;/code&gt;. They can be followed by one &lt;b&gt;f&lt;/b&gt;, &lt;b&gt;F&lt;/b&gt;, or &lt;b&gt;L&lt;/b&gt; suffix. The &lt;b&gt;f&lt;/b&gt; or &lt;b&gt;F&lt;/b&gt; suffix types it is a &lt;code&gt;float&lt;/code&gt;, and &lt;b&gt;L&lt;/b&gt; types it is a &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">不带后缀的浮点文字为 &lt;code&gt;double&lt;/code&gt; 类型。它们后面可以是一个&lt;b&gt;f&lt;/b&gt;，&lt;b&gt;F&lt;/b&gt;或&lt;b&gt;L&lt;/b&gt;后缀。所述&lt;b&gt;˚F&lt;/b&gt;或&lt;b&gt;˚F&lt;/b&gt;后缀类型它是一个 &lt;code&gt;float&lt;/code&gt; ，和&lt;b&gt;大号&lt;/b&gt;类型它是一个 &lt;code&gt;real&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a4195feb88e405b4996ac5dcca713ad5c6175c1" translate="yes" xml:space="preserve">
          <source>Floating point NaN's are formatted as &lt;b&gt;nan&lt;/b&gt; if the</source>
          <target state="translated">浮点NaN的格式为&lt;b&gt;楠&lt;/b&gt;如果</target>
        </trans-unit>
        <trans-unit id="afa8bdea6b3525811aead9f74976b708a0d15aba" translate="yes" xml:space="preserve">
          <source>Floating point comparison operators</source>
          <target state="translated">浮点比较运算符</target>
        </trans-unit>
        <trans-unit id="ed4b0ae6cd9ee0a107d7642401f3d58f692c98b4" translate="yes" xml:space="preserve">
          <source>Floating point comparisons</source>
          <target state="translated">浮点比较</target>
        </trans-unit>
        <trans-unit id="51fe49d981df10fc2a3ca0c38f66d9ec597eda64" translate="yes" xml:space="preserve">
          <source>Floating point computations can be carried out at a higher precision than the size of the floating point variable can hold. Floating point algorithms should continue to work properly if precision is arbitrarily increased.</source>
          <target state="translated">浮点计算可以在比浮点变量所能容纳的大小更高的精度下进行。如果任意提高精度,浮点算法应继续正常工作。</target>
        </trans-unit>
        <trans-unit id="cbc0ff66a82e332f74b6f7f08625c15927132156" translate="yes" xml:space="preserve">
          <source>Floating point constants are internally represented in the implementation in at least &lt;code&gt;real&lt;/code&gt; precision, regardless of the constant's type. The extra precision is available for constant folding. Committing to the precision of the result is done as late as possible in the compilation process. For example:</source>
          <target state="translated">浮点常数在实现中至少以 &lt;code&gt;real&lt;/code&gt; 精度在内部表示，而与常数的类型无关。额外的精度可用于恒定折叠。在编译过程中尽可能晚地保证结果的准确性。例如：</target>
        </trans-unit>
        <trans-unit id="35c2559ddef9cb0435b556f187c76ca13d0d375f" translate="yes" xml:space="preserve">
          <source>Floating point numbers</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="95bc83092a43ba79dea2ddad11b46e7cfef6083c" translate="yes" xml:space="preserve">
          <source>Floating point numerics functions.</source>
          <target state="translated">浮点数字函数。</target>
        </trans-unit>
        <trans-unit id="160661b47177ecb78c896bad472b47b4dfd37f9e" translate="yes" xml:space="preserve">
          <source>Floating point return values are returned on the FPU stack. These must be cleaned off by the caller, even if they are not used.</source>
          <target state="translated">浮点返回值会在FPU堆栈上返回。这些值必须由调用者清理掉,即使它们没有被使用。</target>
        </trans-unit>
        <trans-unit id="33856b075b952fb87e57ad69006f9b871108ab99" translate="yes" xml:space="preserve">
          <source>Floating point types cannot be implicitly converted to integral types. Complex or imaginary floating point types cannot be implicitly converted to non-complex floating point types. Non-complex floating point types cannot be implicitly converted to imaginary floating point types.</source>
          <target state="translated">浮点类型不能隐式转换为积分类型。复式或虚式浮点类型不能隐式转换为非复式浮点类型。非复杂浮点类型不能隐式转换为虚浮点类型。</target>
        </trans-unit>
        <trans-unit id="d3a01c245469b7e18ff38a92dc5c6ea9b1ec4c23" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (cfloat, cdouble, and creal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+] [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|nan+nani|inf|-inf]</source>
          <target state="translated">浮点数。(cfloat,cdouble,and creal)['+'|'-'][数字(s)][数字(s)][[e-|e+]数字(s)][+][数字(s)[.][数字(s)][[e-|e+]数字(s)][i|f|L|Li|fi]]或[nan|nani|nan+nani|inf|inf]。</target>
        </trans-unit>
        <trans-unit id="6d2316f26e5bf23de4ad985a49ccce2c80f4f913" translate="yes" xml:space="preserve">
          <source>Floating-Point Number: (float, double, real, ifloat, idouble, and ireal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|inf|-inf]</source>
          <target state="translated">浮点数。(float,double,real,ifloat,idouble,and ireal)['+'|'-'][数字(s)][[数字(s)][[e-|e+]数字(s)][i|f|L|Li|fi]]或[nan|nani|inf|-inf]。</target>
        </trans-unit>
        <trans-unit id="4e439c8e69a24e7d54c5622205640014d4f59099" translate="yes" xml:space="preserve">
          <source>Floating-Point manipulation</source>
          <target state="translated">浮点运算</target>
        </trans-unit>
        <trans-unit id="417d3791f22357e1adf665e28ee4d505d124a89d" translate="yes" xml:space="preserve">
          <source>Floating-point operations</source>
          <target state="translated">浮点运算</target>
        </trans-unit>
        <trans-unit id="e0d24bd6f36291462113f127088f35f4090a373d" translate="yes" xml:space="preserve">
          <source>Floating-point random variate of type &lt;code&gt;T&lt;/code&gt; drawn from the uniform distribution across the half-open interval [0, 1).</source>
          <target state="translated">从半开区间[0，1]的均匀分布得出的 &lt;code&gt;T&lt;/code&gt; 型浮点随机变量。</target>
        </trans-unit>
        <trans-unit id="f2714b106a05319f2ace1ce68d8ac69bcf4f5ff7" translate="yes" xml:space="preserve">
          <source>Floating-point values are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">浮点值的格式类似于&lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6b8da4fa90bdf05e2c05a6593125f02a7d82431" translate="yes" xml:space="preserve">
          <source>Floats can be in decimal or hexadecimal format.</source>
          <target state="translated">浮点数可以是十进制或十六进制格式。</target>
        </trans-unit>
        <trans-unit id="aee4c734dc6fd3c7a89584d7e5348d40237e1949" translate="yes" xml:space="preserve">
          <source>Flush cookie jar to disk.</source>
          <target state="translated">将饼干罐冲到磁盘上。</target>
        </trans-unit>
        <trans-unit id="7f0c95d2e99f8f6f791a3dcf13701e05342006cc" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;FILE&lt;/code&gt; buffers.</source>
          <target state="translated">刷新C &lt;code&gt;FILE&lt;/code&gt; 缓冲区。</target>
        </trans-unit>
        <trans-unit id="bebb80c78ce429db39d79d68feeba680b58038de" translate="yes" xml:space="preserve">
          <source>Folding White Space contains consecutive CRLF sequences</source>
          <target state="translated">折叠白色空间包含连续的CRLF序列。</target>
        </trans-unit>
        <trans-unit id="67f0ed9d72f8298bdd413ec634b75103f7a22dc1" translate="yes" xml:space="preserve">
          <source>Folding White Space ends with a CRLF sequence</source>
          <target state="translated">折叠白色空间以CRLF序列结束。</target>
        </trans-unit>
        <trans-unit id="08097cc4ab9f5b9568ed73c27e3a597381bce1b4" translate="yes" xml:space="preserve">
          <source>Following arguments works the same way as &lt;code&gt;bitfield&lt;/code&gt;'s. The bitfield must fit into the bits known to be zero because of the pointer alignment.</source>
          <target state="translated">跟随参数的方式与 &lt;code&gt;bitfield&lt;/code&gt; 的方式相同。由于指针对齐，位字段必须适合已知为零的位。</target>
        </trans-unit>
        <trans-unit id="6cfe2219958a5948a49371cf65d64e832c75a6f7" translate="yes" xml:space="preserve">
          <source>Following initialization, the &lt;code&gt;HashTable&lt;/code&gt; object would consistently use its &lt;code&gt;allocator&lt;/code&gt; object for acquiring memory. Furthermore, setting &lt;code&gt;HashTable.allocator&lt;/code&gt; to point to a different allocator should be legal but only if the object is empty; otherwise, the object wouldn't be able to deallocate its existing state.</source>
          <target state="translated">初始化之后， &lt;code&gt;HashTable&lt;/code&gt; 对象将始终使用其 &lt;code&gt;allocator&lt;/code&gt; 对象来获取内存。此外，将 &lt;code&gt;HashTable.allocator&lt;/code&gt; 设置为指向其他分配器应该是合法的，但前提是该对象为空。否则，该对象将无法取消分配其现有状态。</target>
        </trans-unit>
        <trans-unit id="c77938fcdf67aea78282407b90406b49eb71c3e5" translate="yes" xml:space="preserve">
          <source>Follows Itanium C++ ABI 1.86 section 5.1 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt; which is where the grammar comments come from.</source>
          <target state="translated">遵循Itanium C ++ ABI 1.86第5.1节&lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#mangling&lt;/a&gt;，这是语法注释的来源。</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="2496332383d78a1d33c27c0e38fa6de47dc78a49" translate="yes" xml:space="preserve">
          <source>For &quot;store&quot; operations of the form: op1 op= op2</source>
          <target state="translated">对于 &quot;存储 &quot;操作的形式:op1 op=op2。</target>
        </trans-unit>
        <trans-unit id="97c9b61a869134f6120476fe4a99b3b11a45291d" translate="yes" xml:space="preserve">
          <source>For 16 bit generator, this is always a (targ_short) sign-extended value.</source>
          <target state="translated">对于16位的生成器,这总是一个(targ_short)符号扩展值。</target>
        </trans-unit>
        <trans-unit id="78b280836f07395eef32226ce729d39d05fd0d6b" translate="yes" xml:space="preserve">
          <source>For 64 bit code, follows Itanium C++ ABI 1.86 Chapter 3 &lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&lt;/a&gt;</source>
          <target state="translated">对于64位代码，请遵循Itanium C ++ ABI 1.86第3章&lt;a href=&quot;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&quot;&gt;http://refspecs.linux-foundation.org/cxxabi-1.86.html#calls&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11a5de5d335b50e0f5cf5b3413b2f30e630b28c1" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;type#basic-data-types&quot;&gt;basic data types&lt;/a&gt;, all possible bit patterns are safe.</source>
          <target state="translated">对于&lt;a href=&quot;type#basic-data-types&quot;&gt;基本数据类型&lt;/a&gt;，所有可能的位模式都是安全的。</target>
        </trans-unit>
        <trans-unit id="b23dde54b23d16d77035a1e0e2b0833121f3ea89" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; or the operation would result in an overflow, sets &lt;code&gt;v&lt;/code&gt; to &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">对于 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; ，如果 &lt;code&gt;v == WithNaN.defaultValue!Lhs&lt;/code&gt; 或该操作将导致溢出， &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; 设置为WithNaN.defaultValue！T。否则，语义与内置运算符的语义相同。</target>
        </trans-unit>
        <trans-unit id="c0328592d323a259faf0da7a348a86fd52092b62" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, if &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise, the semantics is the same as for the built-in operator.</source>
          <target state="translated">对于 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; ，如果 &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; ，则返回 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; 。否则，语义与内置运算符的语义相同。</target>
        </trans-unit>
        <trans-unit id="4e56b23a72d6de96ffb1933a70486eb64d0dea7d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;foreach&lt;/code&gt;, the elements for the array are iterated over starting at index 0 and continuing to the maximum of the array. For &lt;code&gt;foreach_reverse&lt;/code&gt;, the array elements are visited in the reverse order.</source>
          <target state="translated">对于 &lt;code&gt;foreach&lt;/code&gt; ，从索引0开始迭代数组的元素，直到数组的最大值。对于 &lt;code&gt;foreach_reverse&lt;/code&gt; ，以相反的顺序访问数组元素。</target>
        </trans-unit>
        <trans-unit id="d0ceede7c3735e19c4f9e84dfec5a98cdaa80c75" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;windowSize = 1&lt;/code&gt; it splits the range into single element groups (aka &lt;code&gt;unflatten&lt;/code&gt;) For &lt;code&gt;windowSize = 2&lt;/code&gt; it is similar to &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;windowSize = 1&lt;/code&gt; 它将范围划分为单个元素组（又名 &lt;code&gt;unflatten&lt;/code&gt; ）；对于 &lt;code&gt;windowSize = 2&lt;/code&gt; 它类似于 &lt;code&gt;zip(source, source.save.dropOne)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fde640aa4409bbb47d5287c2ea78c26d39f59e9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt;: The function returns &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;x == &quot;++&quot; || x == &quot;--&quot;&lt;/code&gt; ：函数返回 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5ba5d0612e564fafee84b671c5c4d115f7c0b6e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt;: If &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt;, the function returns &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt;. Otherwise it returns the normal result of the operator.</source>
          <target state="translated">对于 &lt;code&gt;x == &quot;-&quot; || x == &quot;~&quot;&lt;/code&gt; ：如果 &lt;code&gt;v == WithNaN.defaultValue!T&lt;/code&gt; ，则函数返回 &lt;code&gt;WithNaN.defaultValue!T&lt;/code&gt; 。否则，它将返回操作员的正常结果。</target>
        </trans-unit>
        <trans-unit id="d465e34c13d15e0333f8cd7f1c7c1944ae2b7911" translate="yes" xml:space="preserve">
          <source>For C++ class cd, generate an instance of _cpp_type_info_ptr and populate it with a pointer to the C++ type info.</source>
          <target state="translated">对于C++类cd,生成一个_cpp_type_info_ptr的实例,并用指向C++类型信息的指针填充它。</target>
        </trans-unit>
        <trans-unit id="84fc2ed3d82dfac4fe4b1db7e54128df57816954" translate="yes" xml:space="preserve">
          <source>For Posix/x86_64 this returns the type which will really be used for passing an argument of type va_list.</source>
          <target state="translated">对于Posix/x86_64来说,这将返回真正用于传递va_list类型参数的类型。</target>
        </trans-unit>
        <trans-unit id="826bad097a9af03241478f133b816c28a093c4ff" translate="yes" xml:space="preserve">
          <source>For Statement</source>
          <target state="translated">声明</target>
        </trans-unit>
        <trans-unit id="1658d59f02098b291dd70d6afbe72baf35b0b46e" translate="yes" xml:space="preserve">
          <source>For TypeFunction, nextOf() can return NULL if the function return type is meant to be inferred, and semantic() hasn't yet ben run on the function. After semantic(), it must no longer be NULL.</source>
          <target state="translated">对于TypeFunction来说,如果函数的返回类型是要推断的,并且semantic()还没有在函数上运行,那么nextOf()可以返回NULL。在semantic()之后,它必须不再是NULL。</target>
        </trans-unit>
        <trans-unit id="ed4c1eb6664e08f8534b1fe769460ebc44281875" translate="yes" xml:space="preserve">
          <source>For a lazy version, refer to &lt;a href=&quot;std_range#repeat&quot;&gt;&lt;code&gt;std.range.repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于惰性版本，请参考&lt;a href=&quot;std_range#repeat&quot;&gt; &lt;code&gt;std.range.repeat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8cd7374ae5703f87c90badd0385e4fb829226681" translate="yes" xml:space="preserve">
          <source>For a lazy version, see &lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt;&lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">对于懒惰的版本，请参见&lt;a href=&quot;std_algorithm_iteration#joiner&quot;&gt; &lt;code&gt;std.algorithm.iteration.joiner&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20ca13cf71a91c26b14ec6bf15dd84151e56cf9e" translate="yes" xml:space="preserve">
          <source>For a lazy, non-allocating version of these functions, see &lt;a href=&quot;#byUTF&quot;&gt;&lt;code&gt;byUTF&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关这些函数的惰性，非分配版本，请参见&lt;a href=&quot;#byUTF&quot;&gt; &lt;code&gt;byUTF&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="567c03cab3251ca5dd2f65be01f597e8de5b789b" translate="yes" xml:space="preserve">
          <source>For a less strict parser, see &lt;a href=&quot;#parseUUID&quot;&gt;&lt;code&gt;parseUUID&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">对于不太严格的解析器，请参阅&lt;a href=&quot;#parseUUID&quot;&gt; &lt;code&gt;parseUUID&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3242f7887a56a8199a86141fd1d3d295d57af7c" translate="yes" xml:space="preserve">
          <source>For a nested class instance, the &lt;code&gt;.outer&lt;/code&gt; property is the &lt;code&gt;this&lt;/code&gt; reference for the enclosing class's instance. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would be a &lt;code&gt;void*&lt;/code&gt; to the enclosing function frame.</source>
          <target state="translated">对于嵌套的类实例， &lt;code&gt;.outer&lt;/code&gt; 属性是封闭类的实例的 &lt;code&gt;this&lt;/code&gt; 引用。如果没有封闭的类上下文， &lt;code&gt;.outer&lt;/code&gt; 将是封闭函数框架的 &lt;code&gt;void*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32cf17cd505298c5983970817a14f4d4aa02e1a3" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; and the setter has no effect.</source>
          <target state="translated">对于零大小的池，getter会任意返回 &lt;code&gt;core.thread.Thread.PRIORITY_MIN&lt;/code&gt; ，而setter无效。</target>
        </trans-unit>
        <trans-unit id="703bdcc05cee4b856a950e3e2494d43650695c33" translate="yes" xml:space="preserve">
          <source>For a size zero pool, the getter arbitrarily returns true and the setter has no effect.</source>
          <target state="translated">对于大小为零的池子,getter任意返回true,setter没有效果。</target>
        </trans-unit>
        <trans-unit id="7062424b6df58f7b0070477aac1caffce7eac347" translate="yes" xml:space="preserve">
          <source>For all assign expressions, the left operand must be a modifiable lvalue. The type of the assign expression is the type of the left operand, and the value is the value of the left operand after assignment occurs. The resulting expression is a modifiable lvalue.</source>
          <target state="translated">对于所有的赋值表达式,左操作数必须是一个可修改的l值。赋值表达式的类型是左操作数的类型,值是赋值发生后左操作数的值。结果表达式是一个可修改的l值。</target>
        </trans-unit>
        <trans-unit id="4c1c5870b4b89a912a0f2d752c3a6fab5551a649" translate="yes" xml:space="preserve">
          <source>For all other cases, the temporaries generated for the purpose of invoking functions are deferred to the end of the full expression. The order of destruction is inverse to the order of construction.</source>
          <target state="translated">对于所有其他情况,为调用函数而生成的时态被推迟到完整表达式的最后。销毁的顺序与构造的顺序相反。</target>
        </trans-unit>
        <trans-unit id="95e2e0ca2da36fd3882b011dd82190d8d5ee7297" translate="yes" xml:space="preserve">
          <source>For an introductory look at &lt;b&gt;std.format&lt;/b&gt;'s capabilities and how to use this module see the dedicated &lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki article&lt;/a&gt;.</source>
          <target state="translated">有关&lt;b&gt;std.format&lt;/b&gt;的功能以及如何使用此模块的介绍，请参见专用的&lt;a href=&quot;http://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fb635d85e291212fc5e73d7b40aa121e5ce7593" translate="yes" xml:space="preserve">
          <source>For an introductory look at &lt;b&gt;std.format&lt;/b&gt;'s capabilities and how to use this module see the dedicated &lt;a href=&quot;https://wiki.dlang.org/Defining_custom_print_format_specifiers&quot;&gt;DWiki article&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076ae6cb1419d1feff35ba4b7e6bb266176337c6" translate="yes" xml:space="preserve">
          <source>For another example:</source>
          <target state="translated">再举个例子:</target>
        </trans-unit>
        <trans-unit id="4f7c5dea21579ef43f50bda4d8b8e7dd5ee9236e" translate="yes" xml:space="preserve">
          <source>For any given platform/compiler curl_off_t must be typedef'ed to a 64-bit wide signed integral data type. The width of this data type must remain constant and independent of any possible large file support settings.</source>
          <target state="translated">对于任何给定的平台/编译器,curl_off_t必须被类型化为一个64位宽的有符号的积分数据类型,这个数据类型的宽度必须保持不变,并且独立于任何可能的大文件支持设置。这个数据类型的宽度必须保持不变,并且独立于任何可能的大文件支持设置。</target>
        </trans-unit>
        <trans-unit id="078912245b32cd2a66bf3a96da7307acc2485fbe" translate="yes" xml:space="preserve">
          <source>For any other declaration even if &lt;code&gt;@disable&lt;/code&gt; is a syntactically valid attribute &lt;code&gt;false&lt;/code&gt; is returned because the annotation has no effect.</source>
          <target state="translated">对于任何其他声明，即使 &lt;code&gt;@disable&lt;/code&gt; 是语法上有效的属性，也将返回 &lt;code&gt;false&lt;/code&gt; ，因为注释无效。</target>
        </trans-unit>
        <trans-unit id="701d1a14380c65e4a855899951d9d7a65d27e60f" translate="yes" xml:space="preserve">
          <source>For any values &lt;code&gt;v1&lt;/code&gt; on the right-hand side and &lt;code&gt;v2&lt;/code&gt; on the left-hand side:</source>
          <target state="translated">对于右侧的 &lt;code&gt;v1&lt;/code&gt; 和左侧的 &lt;code&gt;v2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f1e77f1044f99821b0b2c5cfb9d3d37a079ad5ec" translate="yes" xml:space="preserve">
          <source>For applications like command line switch processing, this can lead to much more straightforward code, being clearer and less error prone. char, wchar and dchar strings are allowed.</source>
          <target state="translated">对于像命令行开关处理这样的应用,这可以使代码更简单,更清晰,更不容易出错,允许使用char、wchar和dchar字符串。</target>
        </trans-unit>
        <trans-unit id="d1b8d2445b680cd8ee27f3fc95623cb30af7a286" translate="yes" xml:space="preserve">
          <source>For arguments of built-in types, assignment operator expressions such as</source>
          <target state="translated">对于内置类型的参数,赋值运算符表达式如</target>
        </trans-unit>
        <trans-unit id="0f5d29eff2633e7fd841d0a6738a98ac739e92a9" translate="yes" xml:space="preserve">
          <source>For arrays:</source>
          <target state="translated">对于数组。</target>
        </trans-unit>
        <trans-unit id="dc14ba04c2c4629e1d2d0d30f5dc9d2a1dddd9e2" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;a[]&lt;/code&gt; and &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">为了向后兼容，请使用 &lt;code&gt;a[]&lt;/code&gt; 和 &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="542878137297059fb68730fd24d9158d8fdb95d5" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;multiwayMerge&lt;/code&gt; is available under the name &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; under the name of &lt;code&gt;NWayUnion&lt;/code&gt; . Future code should use &lt;code&gt;multiwayMerge&lt;/code&gt; and &lt;code&gt;MultiwayMerge&lt;/code&gt; as &lt;code&gt;nWayUnion&lt;/code&gt; and &lt;code&gt;NWayUnion&lt;/code&gt; will be deprecated.</source>
          <target state="translated">为了向后兼容， &lt;code&gt;multiwayMerge&lt;/code&gt; 是名下可用 &lt;code&gt;nWayUnion&lt;/code&gt; 和 &lt;code&gt;MultiwayMerge&lt;/code&gt; 名下 &lt;code&gt;NWayUnion&lt;/code&gt; 。将来的代码应使用 &lt;code&gt;multiwayMerge&lt;/code&gt; 和 &lt;code&gt;MultiwayMerge&lt;/code&gt; ,因为 &lt;code&gt;nWayUnion&lt;/code&gt; 和 &lt;code&gt;NWayUnion&lt;/code&gt; 将被弃用。</target>
        </trans-unit>
        <trans-unit id="e3a3c169dbbfe63cc4460a15c98153cda1f6881e" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if rewriting &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">为了向后兼容，如果重写 &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92276f55c3cccb89a03bd28b0c6443429cb6df1c" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail and &lt;code&gt;opSliceOpAssign&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; are tried, respectively.</source>
          <target state="translated">为了向后兼容，如果上述重写失败和 &lt;code&gt;opSliceOpAssign&lt;/code&gt; 被定义，则重写 &lt;code&gt;a.opSliceOpAssign(c, i, j)&lt;/code&gt; 和 &lt;code&gt;a.opSliceOpAssign(c)&lt;/code&gt; 中分别尝试。</target>
        </trans-unit>
        <trans-unit id="e5a6a2446de90976e232d13603325c19c48a5a94" translate="yes" xml:space="preserve">
          <source>For backward compatibility, if the above rewrites fail to compile and &lt;code&gt;opSliceUnary&lt;/code&gt; is defined, then the rewrites &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; and &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; are tried instead, respectively.</source>
          <target state="translated">为了向后兼容，如果上述重写失败编译和 &lt;code&gt;opSliceUnary&lt;/code&gt; 被定义，则重写 &lt;code&gt;a.opSliceUnary!(op)(i, j)&lt;/code&gt; 和 &lt;code&gt;a.opSliceUnary!(op)&lt;/code&gt; 分别代替尝试。</target>
        </trans-unit>
        <trans-unit id="757d4d7a3dccc207f58716a0eadde379a304a5d2" translate="yes" xml:space="preserve">
          <source>For binary operators, the result is as follows:</source>
          <target state="translated">对于二元运算符,结果如下。</target>
        </trans-unit>
        <trans-unit id="aeea5f41f2c7d1bd01e14aae86afc3b17192c6d2" translate="yes" xml:space="preserve">
          <source>For blocks &amp;gt;= pagesize, the length is a size_t and is at the beginning of the block. The reason we have to do this is because the block can extend into more pages, so we cannot trust the block length if it sits at the end of the block, because it might have just been extended. If we can prove in the future that the block is unshared, we may be able to change this, but I'm not sure it's important.</source>
          <target state="translated">对于&amp;gt; = pagesize的块，长度为size_t，位于块的开头。我们之所以这样做，是因为该块可以扩展到更多页面，所以如果它位于块的末尾，我们就不能相信它的长度，因为它可能刚刚被扩展了。如果我们将来能证明该区块是未共享的，我们也许可以更改它，但是我不确定它是否重要。</target>
        </trans-unit>
        <trans-unit id="6435d22c869fa126d1d0aea9e7983183ab7f918e" translate="yes" xml:space="preserve">
          <source>For both ++i and --i</source>
          <target state="translated">对于++i和-i</target>
        </trans-unit>
        <trans-unit id="93107872cedc76cc5719158670858cf146f5ce57" translate="yes" xml:space="preserve">
          <source>For both i++ and i--</source>
          <target state="translated">对于i++和i--</target>
        </trans-unit>
        <trans-unit id="c2f1745a5232cce644154e5a3850452a31978021" translate="yes" xml:space="preserve">
          <source>For both overloads, the entire value of the Duration is split among the units (rather than splitting the Duration across all units and then only providing the values for the requested units), so if only one unit is given, the result is equivalent to &lt;a href=&quot;#total&quot;&gt;&lt;code&gt;total&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于这两个重载，Duration的整个值都在单位之间进行分配（而不是在所有单位之间划分Duration，然后仅提供所请求单位的值），因此，如果仅给出一个单位，则结果等于&lt;a href=&quot;#total&quot;&gt; &lt;code&gt;total&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad0f0aabfe7ebb013586fcfb45b89ab392324a84" translate="yes" xml:space="preserve">
          <source>For built-in numerical types, accurate Knuth &amp;amp; Welford mean calculation is used. For user-defined types, element by element summation is used. Additionally an extra parameter &lt;code&gt;seed&lt;/code&gt; is needed in order to correctly seed the summation with the equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">对于内置数字类型，使用精确的Knuth＆Welford均值计算。对于用户定义的类型，使用逐个元素求和。另外，还需要一个额外的参数 &lt;code&gt;seed&lt;/code&gt; ，以正确地将等于 &lt;code&gt;0&lt;/code&gt; 的总和种子。</target>
        </trans-unit>
        <trans-unit id="a4cc9dd81eb95c3553b97b6dbcaf73ca851ceabc" translate="yes" xml:space="preserve">
          <source>For calendar-based operations that don't care about time zones, then &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt; would be the type to use. For system time, use &lt;code&gt;SysTime&lt;/code&gt;.</source>
          <target state="translated">对于不关心时区的基于日历的操作，则将使用&lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt;。对于系统时间，请使用 &lt;code&gt;SysTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7199c84f095b28abf14901a280827544df19151" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is known at compile-time, functions are provided for arbitrary encoding and decoding of characters, arbitrary transcoding between strings of different type, as well as validation and sanitization.</source>
          <target state="translated">对于在编译时已知编码的情况,提供了字符的任意编码和解码、不同类型字符串之间的任意转码以及验证和净化的函数。</target>
        </trans-unit>
        <trans-unit id="a53a545de095bd4f4e296c839d801de6e744e030" translate="yes" xml:space="preserve">
          <source>For cases where the encoding is not known at compile-time, but is known at run-time, the abstract class &lt;a href=&quot;#EncodingScheme&quot;&gt;&lt;code&gt;EncodingScheme&lt;/code&gt;&lt;/a&gt; and its subclasses is provided. To construct a run-time encoder/decoder, one does e.g.</source>
          <target state="translated">对于编码在编译时未知但在运行时已知的情况，提供了抽象类&lt;a href=&quot;#EncodingScheme&quot;&gt; &lt;code&gt;EncodingScheme&lt;/code&gt; &lt;/a&gt;及其子类。为了构造运行时编码器/解码器，例如</target>
        </trans-unit>
        <trans-unit id="d53cba26ee6cdc76a4ea74c67f57bac33bebf848" translate="yes" xml:space="preserve">
          <source>For class and struct objects, the expression &lt;code&gt;(a == b)&lt;/code&gt; is rewritten as &lt;code&gt;a.opEquals(b)&lt;/code&gt;, and &lt;code&gt;(a != b)&lt;/code&gt; is rewritten as &lt;code&gt;!a.opEquals(b)&lt;/code&gt;.</source>
          <target state="translated">对于类和结构对象，将表达式 &lt;code&gt;(a == b)&lt;/code&gt; 重写为 &lt;code&gt;a.opEquals(b)&lt;/code&gt; ，将 &lt;code&gt;(a != b)&lt;/code&gt; 重写为 &lt;code&gt;!a.opEquals(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6164499db4fd6a0a2e064668be7de8146561558" translate="yes" xml:space="preserve">
          <source>For class objects, identity is defined as the object references are for the same object. Null class objects can be compared with &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">对于类对象，将身份定义为对象引用是针对同一对象的。空类对象可以与 &lt;code&gt;is&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="95c093eaf464e50c213285367cf108a1f21af7e6" translate="yes" xml:space="preserve">
          <source>For class objects, the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators are intended to compare the contents of the objects, however an appropriate &lt;code&gt;opEquals&lt;/code&gt; override must be defined for this to work. The default &lt;code&gt;opEquals&lt;/code&gt; provided by the root &lt;code&gt;Object&lt;/code&gt; class is equivalent to the &lt;code&gt;is&lt;/code&gt; operator. Comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents. Use the &lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt; operators instead.</source>
          <target state="translated">对于类对象， &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 运算符旨在比较对象的内容，但是必须定义适当的 &lt;code&gt;opEquals&lt;/code&gt; 重写才能起作用。根 &lt;code&gt;Object&lt;/code&gt; 类提供的默认 &lt;code&gt;opEquals&lt;/code&gt; 等效于 &lt;code&gt;is&lt;/code&gt; 运算符。与 &lt;code&gt;null&lt;/code&gt; 比较无效，因为 &lt;code&gt;null&lt;/code&gt; 没有内容。请使用 &lt;code&gt;is&lt;/code&gt; 和 &lt;code&gt;!is&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="d5b1405cc3330cccfdcfd53a468de428485e9157" translate="yes" xml:space="preserve">
          <source>For class objects, the relational operators compare the contents of the objects. Therefore, comparing against &lt;code&gt;null&lt;/code&gt; is invalid, as &lt;code&gt;null&lt;/code&gt; has no contents.</source>
          <target state="translated">对于类对象，关系运算符比较对象的内容。因此，与 &lt;code&gt;null&lt;/code&gt; 比较是无效的，因为 &lt;code&gt;null&lt;/code&gt; 没有内容。</target>
        </trans-unit>
        <trans-unit id="ab366bbd1fd34ad6f5b2cd340e858e3c25d5bb75" translate="yes" xml:space="preserve">
          <source>For class objects, the result of Object.opCmp() forms the left operand, and 0 forms the right operand. The result of the relational expression (o1 op o2) is:</source>
          <target state="translated">对于类对象,Object.opCmp()的结果构成左操作数,0构成右操作数。关系表达式(o1 op o2)的结果是:。</target>
        </trans-unit>
        <trans-unit id="e894f77d4bc27bedbf87e79de7b7a21550ebd3e1" translate="yes" xml:space="preserve">
          <source>For class objects:</source>
          <target state="translated">对于类对象。</target>
        </trans-unit>
        <trans-unit id="6ae638739525d1c55b35c525b46eec46d1197fc5" translate="yes" xml:space="preserve">
          <source>For completeness a level 1 trie is simply an array. The current implementation takes advantage of bit-packing values when the range is known to be limited in advance (such as &lt;code&gt;bool&lt;/code&gt;). See also &lt;a href=&quot;#BitPacked&quot;&gt;&lt;code&gt;BitPacked&lt;/code&gt;&lt;/a&gt; for enforcing it manually. The major size advantage however comes from the fact that multiple &lt;b&gt;identical pages on every level are merged&lt;/b&gt; by construction.</source>
          <target state="translated">为了完整性，第1级特里只是一个数组。当已知范围预先受到限制时（例如 &lt;code&gt;bool&lt;/code&gt; ），当前实现利用位打包值。另请参阅&lt;a href=&quot;#BitPacked&quot;&gt; &lt;code&gt;BitPacked&lt;/code&gt; ,&lt;/a&gt;以手动执行它。但是，主要的大小优势来自于以下事实：&lt;b&gt;每个级别上的&lt;/b&gt;多个&lt;b&gt;相同页面都是&lt;/b&gt;通过构造&lt;b&gt;合并&lt;/b&gt;的。</target>
        </trans-unit>
        <trans-unit id="8ebdc89d7f40766ce711349010ffd3cd409b6e68" translate="yes" xml:space="preserve">
          <source>For complex numbers, equality is defined as equivalent to:</source>
          <target state="translated">对于复数,平等的定义是等于。</target>
        </trans-unit>
        <trans-unit id="c92d80178cde078393b89e6d6a1bab596929a28f" translate="yes" xml:space="preserve">
          <source>For consistency and predictability, there are several standard sections. None of these are required to be present.</source>
          <target state="translated">为了保持一致性和可预测性,有几个标准章节。其中没有一个是必须存在的。</target>
        </trans-unit>
        <trans-unit id="b5df2d0a44db277a01e403815ff3d6ffbf0a4688" translate="yes" xml:space="preserve">
          <source>For console programs, &lt;code&gt;main()&lt;/code&gt; serves as the entry point. It gets called after all the module initializers are run, and after any unittests are run. After it returns, all the module destructors are run. &lt;code&gt;main()&lt;/code&gt; must be declared using one of the following forms:</source>
          <target state="translated">对于控制台程序， &lt;code&gt;main()&lt;/code&gt; 充当入口点。在所有模块初始化程序运行之后以及任何单元测试运行之后，它将被调用。返回后，所有模块析构函数都将运行。 &lt;code&gt;main()&lt;/code&gt; 必须使用以下形式之一声明：</target>
        </trans-unit>
        <trans-unit id="a87a16b2108087eba4cfd4c27e06f2199e9c9ea6" translate="yes" xml:space="preserve">
          <source>For convenience</source>
          <target state="translated">为方便起见</target>
        </trans-unit>
        <trans-unit id="c28923eb8e6fce56c97d1e69a2459b17db795a95" translate="yes" xml:space="preserve">
          <source>For convenience, if the seed is const, or has qualified fields, then &lt;code&gt;reduce&lt;/code&gt; will operate on an unqualified copy. If this happens then the returned type will not perfectly match &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">为方便起见，如果种子为const或具有限定字段，则 &lt;code&gt;reduce&lt;/code&gt; 将对非限定副本进行操作。如果发生这种情况，则返回类型不完全匹配 &lt;code&gt;S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db55a017e4d8880bceaa15cbff12d8e02dda2446" translate="yes" xml:space="preserve">
          <source>For convenience, this module publicly imports &lt;a href=&quot;core_time&quot;&gt;&lt;code&gt;core.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了方便起见，此模块公开导入&lt;a href=&quot;core_time&quot;&gt; &lt;code&gt;core.time&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0750ffdd6d85bc11bd3ef50c265df606e3d06eba" translate="yes" xml:space="preserve">
          <source>For conversion of strings to signed types, the grammar recognized is:</source>
          <target state="translated">对于字符串到有符号类型的转换,认可的语法是。</target>
        </trans-unit>
        <trans-unit id="6d295d9ab6e17239455a68d95e6a9009da2b2b99" translate="yes" xml:space="preserve">
          <source>For conversion to unsigned types, the grammar recognized is:</source>
          <target state="translated">对于转换为无符号类型,认可的语法是:。</target>
        </trans-unit>
        <trans-unit id="7cbf49f210f0c77ac5cb0d36bff7e0a64b475c82" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal.</source>
          <target state="translated">为了进行正确的比较，如果 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 返回正整数，如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 返回负整数，如果两者相等则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eb5e30aca486d38067e5e0193c4b1bb0345617f" translate="yes" xml:space="preserve">
          <source>For correct comparisons, returns a positive integer if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, a negative integer if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the two are equal. Upon a mistaken comparison such as &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt;, the function never returns because it aborts the program.</source>
          <target state="translated">为了进行正确的比较，如果 &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 返回正整数，如果 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 返回负整数，如果两者相等则返回 &lt;code&gt;0&lt;/code&gt; 。如果比较错误，例如 &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt; ，该函数将永远不会返回，因为它会中止程序。</target>
        </trans-unit>
        <trans-unit id="fa11ef91f282359e697ab411a2105694aa1fc413" translate="yes" xml:space="preserve">
          <source>For debuggers that can be modified to accept new types, the following extensions help them fully support the types.</source>
          <target state="translated">对于可以修改以接受新类型的调试器,以下扩展有助于它们完全支持这些类型。</target>
        </trans-unit>
        <trans-unit id="70f5609ca5e86e5be455bc08ca5f8a240497ea5a" translate="yes" xml:space="preserve">
          <source>For dynamic array and object parameters, which are always passed by reference, in/out/ref apply only to the reference and not the contents.</source>
          <target state="translated">对于总是通过引用传递的动态数组和对象参数,in/out/ref只适用于引用而不是内容。</target>
        </trans-unit>
        <trans-unit id="63e9558b3c028e1d9a23d1722de151ab9342540d" translate="yes" xml:space="preserve">
          <source>For dynamic array and object parameters, which are passed by reference, in/out/ref apply only to the reference and not the contents.</source>
          <target state="translated">对于通过引用传递的动态数组和对象参数,in/out/ref只适用于引用而不是内容。</target>
        </trans-unit>
        <trans-unit id="26ffddfdbc1c41c2be1034e80310b3f852b74078" translate="yes" xml:space="preserve">
          <source>For each active attribute (ref/const/nogc/etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">对于每个活动属性（ref / const / nogc / etc），请调用 &lt;code&gt;fp&lt;/code&gt; 并为工作参数添加一个void *和该属性的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="8eea3bce7669308b1434c353731e136dc4b97c1c" translate="yes" xml:space="preserve">
          <source>For each active modifier (MODFlags.const_, MODFlags.immutable_, etc) call &lt;code&gt;fp&lt;/code&gt; with a void* for the work param and a string representation of the attribute.</source>
          <target state="translated">对于每个活动的修饰符（MODFlags.const_，MODFlags.immutable_等），调用 &lt;code&gt;fp&lt;/code&gt; 并使用void *作为工作参数，并使用属性的字符串表示形式。</target>
        </trans-unit>
        <trans-unit id="3203682624a9b4a1635c6de69e488d06fa56e15c" translate="yes" xml:space="preserve">
          <source>For each evaluation that yields a temporary value, the lifetime of that temporary begins at the evaluation point, similarly to creation of a usual named value initialized with an expression.</source>
          <target state="translated">对于每次产生临时值的评价,该临时值的生命期从评价点开始,类似于创建一个用表达式初始化的普通命名值。</target>
        </trans-unit>
        <trans-unit id="5f7caa6316d56bf976ab623e5dd0b440be2fe098" translate="yes" xml:space="preserve">
          <source>For each function &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;fun&lt;/code&gt;, the corresponding seed type &lt;code&gt;S&lt;/code&gt; is &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an element of &lt;code&gt;r&lt;/code&gt;: &lt;code&gt;ElementType!R&lt;/code&gt; for ranges, and &lt;code&gt;ForeachType!R&lt;/code&gt; otherwise.</source>
          <target state="translated">对于每个功能 &lt;code&gt;f&lt;/code&gt; 在 &lt;code&gt;fun&lt;/code&gt; ，相应的种子类型 &lt;code&gt;S&lt;/code&gt; 是 &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt; ，其中 &lt;code&gt;e&lt;/code&gt; 是的元件 &lt;code&gt;r&lt;/code&gt; ！ &lt;code&gt;ElementType!R&lt;/code&gt; 为范围，以及 &lt;code&gt;ForeachType!R&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="89f96ba2b9022471ac4b3f99072ac57893d52c5d" translate="yes" xml:space="preserve">
          <source>For each function that has exception handlers, an EH table entry is generated.</source>
          <target state="translated">对于每个有异常处理程序的函数,都会生成一个EH表项。</target>
        </trans-unit>
        <trans-unit id="c170bc5a2dcbb7f263f34807c28c73343f6168e3" translate="yes" xml:space="preserve">
          <source>For each template parameter, the following rules are applied in order until a type is deduced for each parameter:</source>
          <target state="translated">对于每个模板参数,依次应用以下规则,直到为每个参数推导出一个类型。</target>
        </trans-unit>
        <trans-unit id="de2d36eb496ad6425d4fddf01b0f74d4997c1c21" translate="yes" xml:space="preserve">
          <source>For each type &lt;code&gt;T&lt;/code&gt; on the left-hand side and each type &lt;code&gt;U&lt;/code&gt; on the right-hand side, values of type &lt;code&gt;T&lt;/code&gt; can be compared with values of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">对于左侧的每种类型 &lt;code&gt;T&lt;/code&gt; 和右侧的每种类型 &lt;code&gt;U&lt;/code&gt; ，可以将类型 &lt;code&gt;T&lt;/code&gt; 的值与类型 &lt;code&gt;U&lt;/code&gt; 的值进行比较。</target>
        </trans-unit>
        <trans-unit id="e27d5d7f20198430510bed8d554d11950a10ed02" translate="yes" xml:space="preserve">
          <source>For each value &lt;code&gt;v1&lt;/code&gt; on the left-hand side and each value &lt;code&gt;v2&lt;/code&gt; on the right-hand side, the expression &lt;code&gt;v1 == v2&lt;/code&gt; is true.</source>
          <target state="translated">对于左侧的每个值 &lt;code&gt;v1&lt;/code&gt; 和右侧的每个值 &lt;code&gt;v2&lt;/code&gt; ，表达式 &lt;code&gt;v1 == v2&lt;/code&gt; 为true。</target>
        </trans-unit>
        <trans-unit id="9025d5cca105be0e8976e2851061cc835c9a962a" translate="yes" xml:space="preserve">
          <source>For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly initialized. An UUID is empty if &lt;a href=&quot;#empty&quot;&gt;`UUID.empty`&lt;/a&gt; is true. Empty UUIDs are equal to &lt;code&gt;UUID.init&lt;/code&gt;, which is a UUID with all 16 bytes set to 0. Use UUID's constructors or the UUID generator functions to get an initialized UUID.</source>
          <target state="translated">为了提高效率，UUID被实现为结构。因此，如果未明确初始化，则UUID为空。如果&lt;a href=&quot;#empty&quot;&gt;UUID.empty&lt;/a&gt;为true，则UUID为空。空的UUID等于 &lt;code&gt;UUID.init&lt;/code&gt; ，这是一个UUID，所有16个字节均设置为0。使用UUID的构造函数或UUID生成器函数来获取已初始化的UUID。</target>
        </trans-unit>
        <trans-unit id="62d0aac1e2c0659f1732b0c95533d24eac16f4a7" translate="yes" xml:space="preserve">
          <source>For example the primitives &lt;code&gt;c.remove(r)&lt;/code&gt; and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; both remove the sequence of elements in range &lt;code&gt;r&lt;/code&gt; from the container &lt;code&gt;c&lt;/code&gt;. The primitive &lt;code&gt;c.remove(r)&lt;/code&gt; guarantees &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;) complexity in the worst case and &lt;code&gt;c.linearRemove(r)&lt;/code&gt; relaxes this guarantee to &amp;Omicron;(&lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt;).  Since a sequence of elements can be removed from a &lt;a href=&quot;std_container_dlist&quot;&gt;doubly linked list&lt;/a&gt; in constant time, &lt;code&gt;DList&lt;/code&gt; provides the primitive &lt;code&gt;c.remove(r)&lt;/code&gt; as well as &lt;code&gt;c.linearRemove(r)&lt;/code&gt;. On the other hand &lt;a href=&quot;std_container_array&quot;&gt;Array&lt;/a&gt; only offers &lt;code&gt;c.linearRemove(r)&lt;/code&gt;.  The following table describes the common set of primitives that containers implement. A container need not implement all primitives, but if a primitive is implemented, it must support the syntax described in the &lt;b&gt;syntax&lt;/b&gt; column with the semantics described in the &lt;b&gt;description&lt;/b&gt; column, and it must not have a worst-case complexity worse than denoted in big-O notation in the &amp;Omicron;(&lt;code&gt;&amp;middot;&lt;/code&gt;) column. Below, &lt;code&gt;C&lt;/code&gt; means a container type, &lt;code&gt;c&lt;/code&gt; is a value of container type, &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; represents the effective length of value &lt;code&gt;x&lt;/code&gt;, which could be a single element (in which case &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;), a container, or a range.</source>
          <target state="translated">例如，图元 &lt;code&gt;c.remove(r)&lt;/code&gt; 和 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 都从容器 &lt;code&gt;c&lt;/code&gt; 中删除了范围 &lt;code&gt;r&lt;/code&gt; 中的元素序列。原始 &lt;code&gt;c.remove(r)&lt;/code&gt; 保证&amp;Omicron;（ &lt;code&gt;n&lt;sub&gt;r&lt;/sub&gt; log n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;[R&lt;/sub&gt;为log N &lt;sub&gt;&amp;Ccedil;&lt;/sub&gt;）在最坏情况下的复杂性和 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 放宽了这一条件保证&amp;Omicron;（ &lt;code&gt;n&lt;sub&gt;c&lt;/sub&gt;&lt;/code&gt; &lt;sub&gt;&amp;Ccedil;&lt;/sub&gt;）。由于元素的序列可以从被删除&lt;a href=&quot;std_container_dlist&quot;&gt;双向链表&lt;/a&gt;在恒定的时间， &lt;code&gt;DList&lt;/code&gt; 提供原始 &lt;code&gt;c.remove(r)&lt;/code&gt; 以及 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 。另一方面&lt;a href=&quot;std_container_array&quot;&gt;数组&lt;/a&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;只提供 &lt;code&gt;c.linearRemove(r)&lt;/code&gt; 。下表描述了容器实现的通用原语集。容器不需要实现所有原语，但是如果实现了原语，则它必须支持&lt;b&gt;语法&lt;/b&gt;列中所描述的&lt;b&gt;语法&lt;/b&gt;以及&lt;b&gt;描述&lt;/b&gt;列中所&lt;b&gt;描述&lt;/b&gt;的语义，并且容器的最坏情况下的复杂性也不应比大容器中所&lt;b&gt;描述的&lt;/b&gt;复杂。 &amp;Omicron;（ &lt;code&gt;&amp;middot;&lt;/code&gt; ）列中的O标记。下面， &lt;code&gt;C&lt;/code&gt; 表示容器类型， &lt;code&gt;c&lt;/code&gt; 是容器类型的值， &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; 表示值 &lt;code&gt;x&lt;/code&gt; 的有效长度，它可以是单个元素（在这种情况下， &lt;code&gt;n&lt;sub&gt;x&lt;/sub&gt;&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ），容器或范围。</target>
        </trans-unit>
        <trans-unit id="d00edd8f12a04d1befc302c87668dfdb2d903e2a" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\U0001F603&lt;/code&gt; represents the Unicode character U+1F603 (SMILING FACE WITH OPEN MOUTH).</source>
          <target state="translated">例如， &lt;code&gt;\U0001F603&lt;/code&gt; 表示Unicode字符U + 1F603（带有张开嘴的笑脸）。</target>
        </trans-unit>
        <trans-unit id="bddb2b6572ea79b1700e73180c6a9ef4a9e2c7be" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;\u03B3&lt;/code&gt; represents the Unicode character &amp;gamma; (U+03B3 - GREEK SMALL LETTER GAMMA).</source>
          <target state="translated">例如， &lt;code&gt;\u03B3&lt;/code&gt; 表示Unicode字符&amp;gamma;（U + 03B3-希腊小写字母GAMMA）。</target>
        </trans-unit>
        <trans-unit id="e8c9021af829ec2346f217a33bffab12b0880918" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;a[index]&lt;/code&gt; is really &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;s.f&lt;/code&gt; is really &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;a[index]&lt;/code&gt; 实际上 &lt;code&gt;a&lt;/code&gt; ，而 &lt;code&gt;s.f&lt;/code&gt; 实际上 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="429a44b7b476fadc40e55c9fb2ea9f99eab49de1" translate="yes" xml:space="preserve">
          <source>For example, a programmatic equivalent of Unix's &lt;code&gt;chmod +x name&lt;/code&gt; to make a file executable is &lt;code&gt;name.setAttributes(name.getAttributes | octal!700)&lt;/code&gt;.</source>
          <target state="translated">例如，使文件可执行的Unix的 &lt;code&gt;chmod +x name&lt;/code&gt; 的编程等效项是 &lt;code&gt;name.setAttributes(name.getAttributes | octal!700)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aee49e2b5de63bc28985d9e3f5b2391109f50868" translate="yes" xml:space="preserve">
          <source>For example, consider a class that is a container for two elements:</source>
          <target state="translated">例如,考虑一个类,它是两个元素的容器。</target>
        </trans-unit>
        <trans-unit id="f4060213712449048c8c23e8aed13169261c66f1" translate="yes" xml:space="preserve">
          <source>For example, for the Intel Pentium:</source>
          <target state="translated">例如,对于英特尔奔腾。</target>
        </trans-unit>
        <trans-unit id="56a66959fa3d6d051e3f2985a858c24aef88cfec" translate="yes" xml:space="preserve">
          <source>For example, given a class &lt;code&gt;Sum&lt;/code&gt; that is used to add two values, a unit test can be given:</source>
          <target state="translated">例如，给定用于将两个值相加的 &lt;code&gt;Sum&lt;/code&gt; 类，可以给出单元测试：</target>
        </trans-unit>
        <trans-unit id="afa20f7fd4e06e98278c1c050fed1f04af8aa95d" translate="yes" xml:space="preserve">
          <source>For example, here is how to remove a single element from an array:</source>
          <target state="translated">例如,下面是如何从一个数组中删除一个元素。</target>
        </trans-unit>
        <trans-unit id="664b22b4de56d86a94d4d1f08efe5f39ea8b5955" translate="yes" xml:space="preserve">
          <source>For example, if this qualifies to 'a1.a2' and pkg - to 'a1.a2.a3', this function returns 'true'. If it is other way around or qualified package paths conflict function returns 'false'.</source>
          <target state="translated">例如,如果这个限定为'a1.a2',而 pkg -限定为'a1.a2.a3',这个函数返回'true'。如果是其他方式或者限定的包路径冲突,函数返回 'false'。</target>
        </trans-unit>
        <trans-unit id="2f4a0bc25491ad453cd52460e2badab7db117513" translate="yes" xml:space="preserve">
          <source>For example, in order to overload the &lt;code&gt;-&lt;/code&gt; (negation) operator for struct S, and no other operator:</source>
          <target state="translated">例如，为了重载结构S 的 &lt;code&gt;-&lt;/code&gt; （否定）运算符，而没有其他运算符：</target>
        </trans-unit>
        <trans-unit id="1db4a09c9c6a230d99b45c4869c4f6e84c23d582" translate="yes" xml:space="preserve">
          <source>For example, one could redefine &lt;code&gt;DDOC_SUMMARY&lt;/code&gt;:</source>
          <target state="translated">例如，可以重新定义 &lt;code&gt;DDOC_SUMMARY&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0e5d29b3a3287b6048a7baf84989543162cfde72" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;immutable&lt;/code&gt; type qualifier can be used to create variables of immutable type, such as:</source>
          <target state="translated">例如， &lt;code&gt;immutable&lt;/code&gt; 类型限定符可用于创建不可变类型的变量，例如：</target>
        </trans-unit>
        <trans-unit id="b3a7c81f27baa62d867db8143dafce975505e522" translate="yes" xml:space="preserve">
          <source>For example, the expression &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt; is permitted when &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt; are expressions yielding pointers to memory block</source>
          <target state="translated">例如，当 &lt;code&gt;p1&lt;/code&gt; ， &lt;code&gt;p2&lt;/code&gt; 是产生指向存储块的指针的表达式时，允许使用表达式 &lt;code&gt;(p1 &amp;gt; q1 &amp;amp;&amp;amp; p2 &amp;lt;= q2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afa193b836783a5ecabcde946cad5a9128e2b421" translate="yes" xml:space="preserve">
          <source>For example, the following function template only matches with odd values of &lt;code&gt;N&lt;/code&gt;:</source>
          <target state="translated">例如，以下功能模板仅与 &lt;code&gt;N&lt;/code&gt; 的奇数值匹配：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="38096dc369d1ebe6ec7ec60de5ac2d73db72feee" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\101&lt;/code&gt; represents the character with the value 65 (&lt;code&gt;'A'&lt;/code&gt;). Analogous to hexadecimal characters, the largest byte value is &lt;code&gt;\377&lt;/code&gt; (= &lt;code&gt;\xFF&lt;/code&gt; in hexadecimal or &lt;code&gt;255&lt;/code&gt; in decimal)</source>
          <target state="translated">例如： &lt;code&gt;\101&lt;/code&gt; 代表具有值65（ &lt;code&gt;'A'&lt;/code&gt; ）的字符。类似于十六进制字符，最大字节值为 &lt;code&gt;\377&lt;/code&gt; （十六进制为 &lt;code&gt;\xFF&lt;/code&gt; 或十进制为 &lt;code&gt;255&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8187ba92149a37ed481170300ec07180dd3c8361" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;\xFF&lt;/code&gt; represents the character with the value 255.</source>
          <target state="translated">例如： &lt;code&gt;\xFF&lt;/code&gt; 表示值为255的字符。</target>
        </trans-unit>
        <trans-unit id="4d1688fe7c391489009113fe8f20b160cce3978f" translate="yes" xml:space="preserve">
          <source>For examples see the &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">例子可见的&lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt;下面。</target>
        </trans-unit>
        <trans-unit id="79381ea951fd6aadf813123f5b529dd772681030" translate="yes" xml:space="preserve">
          <source>For finite ranges, the result of &lt;code&gt;opSlice&lt;/code&gt; must be of the same type as the original range type. If the range defines &lt;code&gt;opDollar&lt;/code&gt;, then it must support subtraction.</source>
          <target state="translated">对于有限范围， &lt;code&gt;opSlice&lt;/code&gt; 的结果必须与原始范围类型相同。如果范围定义了 &lt;code&gt;opDollar&lt;/code&gt; ，那么它必须支持减法。</target>
        </trans-unit>
        <trans-unit id="c77ba69b2b7b1720fb5f6b789826c71a3c605b97" translate="yes" xml:space="preserve">
          <source>For float, double, and real values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. The values &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;+0&lt;/code&gt; are considered equal. If either or both operands are NAN, then &lt;code&gt;==&lt;/code&gt; returns false and &lt;code&gt;!=&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, the bit patterns of the common type are compared for equality.</source>
          <target state="translated">对于浮点，双精度和实数值，在进行比较之前，将应用&amp;ldquo; &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;常规算术转换&amp;rdquo;&lt;/a&gt;将它们转换为通用类型。值 &lt;code&gt;-0&lt;/code&gt; 和 &lt;code&gt;+0&lt;/code&gt; 被视为相等。如果一个或两个操作数均为NAN，则 &lt;code&gt;==&lt;/code&gt; 返回false， &lt;code&gt;!=&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。否则，将比较公共类型的位模式是否相等。</target>
        </trans-unit>
        <trans-unit id="ec28333c5408aa27a2824def03dd893394acfa05" translate="yes" xml:space="preserve">
          <source>For floating point inputs, calculations are made in &lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt; precision for &lt;code&gt;real&lt;/code&gt; inputs and in &lt;code&gt;double&lt;/code&gt; precision otherwise (Note this is a special case that deviates from &lt;code&gt;fold&lt;/code&gt;'s behavior, which would have kept &lt;code&gt;float&lt;/code&gt; precision for a &lt;code&gt;float&lt;/code&gt; range). For all other types, the calculations are done in the same type obtained from from adding two elements of the range, which may be a different type from the elements themselves (for example, in case of &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;integral promotion&lt;/a&gt;).</source>
          <target state="translated">对于浮点输入，将以&lt;a href=&quot;https://dlang.org/spec/type.html&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt;精度对 &lt;code&gt;real&lt;/code&gt; 输入进行计算，否则将以 &lt;code&gt;double&lt;/code&gt; 精度进行计算（请注意，这是一种特殊情况，它偏离 &lt;code&gt;fold&lt;/code&gt; 的行为，这会在 &lt;code&gt;float&lt;/code&gt; 范围内保持 &lt;code&gt;float&lt;/code&gt; 精度）。对于所有其他类型，计算是通过将范围内的两个元素相加而获得的相同类型进行的，这些元素可能与元素本身不同（例如，在&lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;积分提升的&lt;/a&gt;情况下）。</target>
        </trans-unit>
        <trans-unit id="765c4ec4b98b1848bab9c8fba86795001e6760ec" translate="yes" xml:space="preserve">
          <source>For floating point operands, the * and / operations correspond to the IEEE 754 floating point equivalents. % is not the same as the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas for IEEE 754, remainder(15.0,10.0) == -5.0.</source>
          <target state="translated">对于浮点操作数,*和/操作对应于IEEE 754浮点等价物。%与IEEE 754的余数不同。例如,15.0 % 10.0 ==5.0,而对于IEEE 754,remaxinder(15.0,10.0)==-5.0。</target>
        </trans-unit>
        <trans-unit id="311831dfcbe2aa85299a9b7419ec3f7edbd674b9" translate="yes" xml:space="preserve">
          <source>For floating point operations and expression intermediate values, a greater precision can be used than the type of the expression. Only the minimum precision is set by the types of the operands, not the maximum. &lt;b&gt;Implementation Note:&lt;/b&gt; On Intel x86 machines, for example, it is expected (but not required) that the intermediate calculations be done to the full 80 bits of precision implemented by the hardware.</source>
          <target state="translated">对于浮点运算和表达式中间值，可以使用比表达式类型更高的精度。操作数的类型仅设置最小精度，而不是最大精度。&lt;b&gt;实施注意：&lt;/b&gt;例如，在Intel x86机器上，可以（但不是必需）对硬件实现的全部80位精度进行中间计算。</target>
        </trans-unit>
        <trans-unit id="a8f36fac9b0314aa81c6e99d081aedbe4af658c5" translate="yes" xml:space="preserve">
          <source>For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</source>
          <target state="translated">对于浮点数,最大的有效载荷是0x3F_FFFF。对于双数,它是0x3_FFFF_FFFF_FFFF。对于80位或128位的雷亚尔,它是0x3FFF_FFFF_FFFF_FFFF。</target>
        </trans-unit>
        <trans-unit id="f68bb29877591d4b489a9f6fff54379ee749f0f3" translate="yes" xml:space="preserve">
          <source>For forward compatibility, the CPU is compared against different microarchitectures. For 32-bit x86, comparisons are made against the Intel PPro/PII/PIII/PM family.</source>
          <target state="translated">为了实现正向兼容性,将CPU与不同的微架构进行比较。对于32位x86,则与Intel PPro/PII/PIII/PM系列进行比较。</target>
        </trans-unit>
        <trans-unit id="cb68f2aaef1107ffda2b00fc87de858154352d8d" translate="yes" xml:space="preserve">
          <source>For functions which operate on Unicode characters, see &lt;a href=&quot;std_uni&quot;&gt;&lt;code&gt;std.uni&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关对Unicode字符进行操作的函数，请参见&lt;a href=&quot;std_uni&quot;&gt; &lt;code&gt;std.uni&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c427f88fad780106904fb230a561fe45ae8afed" translate="yes" xml:space="preserve">
          <source>For functions, the &lt;code&gt;auto&lt;/code&gt; attribute means return type inference. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">对于函数， &lt;code&gt;auto&lt;/code&gt; 属性表示返回类型推断。请参阅&lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;自动功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb6e8700842932cee5fe004d021df4907ea6dd83" translate="yes" xml:space="preserve">
          <source>For further information see the the two functions defined inside of this template.</source>
          <target state="translated">更多信息请参见本模板中定义的两个函数。</target>
        </trans-unit>
        <trans-unit id="6d45ac630dd39944ad55493060e8c4dac92d7fc5" translate="yes" xml:space="preserve">
          <source>For garbage collected pointers and references, however, there are some restrictions. These restrictions are minor, but they are intended to enable the maximum flexibility in garbage collector design.</source>
          <target state="translated">然而,对于垃圾收集的指针和引用,有一些限制。这些限制虽然不大,但其目的是为了使垃圾收集器的设计具有最大的灵活性。</target>
        </trans-unit>
        <trans-unit id="b7afa355fcaa31af2cd3f80d70dbcf199acfca98" translate="yes" xml:space="preserve">
          <source>For historical compatibility when &lt;code&gt;nbits == 192&lt;/code&gt; and &lt;code&gt;UIntType&lt;/code&gt; is &lt;code&gt;uint&lt;/code&gt; a legacy hybrid PRNG is used consisting of a 160-bit xorshift combined with a 32-bit counter. This combined generator has period equal to the least common multiple of &lt;code&gt;2^^160 - 1&lt;/code&gt; and &lt;code&gt;2^^32&lt;/code&gt;.</source>
          <target state="translated">为了实现历史兼容性，当 &lt;code&gt;nbits == 192&lt;/code&gt; 且 &lt;code&gt;UIntType&lt;/code&gt; 为 &lt;code&gt;uint&lt;/code&gt; 时,将使用由160位xorshift和32位计数器组成的传统混合PRNG。该组合生成器的周期等于 &lt;code&gt;2^^160 - 1&lt;/code&gt; 和 &lt;code&gt;2^^32&lt;/code&gt; 最小公倍数。</target>
        </trans-unit>
        <trans-unit id="184c65349a2ddaab04f57fbc0fe983f92c59a278" translate="yes" xml:space="preserve">
          <source>For hot code paths, it is worth profiling to see if the void initializer actually improves results.</source>
          <target state="translated">对于热点代码路径,值得剖析的是,看看void初始化器是否真的能改善效果。</target>
        </trans-unit>
        <trans-unit id="373d2d5153ba00f28887ffdca247e026ee396782" translate="yes" xml:space="preserve">
          <source>For hot code paths, it is worthwhile to check to see if the void initializer actually improves results before using it.</source>
          <target state="translated">对于热门的代码路径,在使用前不妨先检查一下void初始化器是否真的能提高效果。</target>
        </trans-unit>
        <trans-unit id="e4f4bd7aa4cad79620e1f6020bf4450eeadc7446" translate="yes" xml:space="preserve">
          <source>For illustration purposes only, every method call results in assertion failure. Use &lt;a href=&quot;#utfMatcher&quot;&gt;&lt;code&gt;utfMatcher&lt;/code&gt;&lt;/a&gt; to obtain a concrete matcher for UTF-8 or UTF-16 encodings.</source>
          <target state="translated">仅出于说明目的，每个方法调用都会导致断言失败。使用&lt;a href=&quot;#utfMatcher&quot;&gt; &lt;code&gt;utfMatcher&lt;/code&gt; &lt;/a&gt;可以获取UTF-8或UTF-16编码的具体匹配器。</target>
        </trans-unit>
        <trans-unit id="4cd5f2dc243960435d23cc958481129bcfb42bcc" translate="yes" xml:space="preserve">
          <source>For infinite ranges, when</source>
          <target state="translated">对于无限范围,当</target>
        </trans-unit>
        <trans-unit id="aae2fd6469d641f1e8d553dabcf2fe7c0be1babf" translate="yes" xml:space="preserve">
          <source>For instance, if the function used to generate a range of time points generated successive Easters (i.e. you're iterating over all of the Easters within the interval), the initial date probably isn't an Easter. Using &lt;code&gt;PopFirst.yes&lt;/code&gt; would tell the function which returned the range that &lt;code&gt;popFront&lt;/code&gt; was to be called so that front would then be an Easter - the next one generated by the function (which when iterating forward would be the Easter following the original &lt;code&gt;front&lt;/code&gt;, while when iterating backward, it would be the Easter prior to the original &lt;code&gt;front&lt;/code&gt;). If &lt;code&gt;PopFirst.no&lt;/code&gt; were used, then &lt;code&gt;front&lt;/code&gt; would remain the original time point and it would not necessarily be a time point which would be generated by the range-generating function (which in many cases is exactly what is desired - e.g. if iterating over every day starting at the beginning of the interval).</source>
          <target state="translated">例如，如果用于生成一系列时间点的函数生成了连续的复活节（即您要遍历该间隔内的所有复活节），则初始日期可能不是复活节。使用 &lt;code&gt;PopFirst.yes&lt;/code&gt; 会告诉该函数，该函数返回要调用的 &lt;code&gt;popFront&lt;/code&gt; 范围，因此front将成为Easter-该函数生成的下一个复活节（向前迭代时，它将是原始 &lt;code&gt;front&lt;/code&gt; 之前的Easter ，而当迭代落后，这将是复活节之前的原始 &lt;code&gt;front&lt;/code&gt; ）。如果使用 &lt;code&gt;PopFirst.no&lt;/code&gt; ，则 &lt;code&gt;front&lt;/code&gt; 仍将保留原始时间点，而不一定是范围生成功能所生成的时间点（在许多情况下正是所需的时间点-例如，如果从间隔开始时每天迭代一次） 。</target>
        </trans-unit>
        <trans-unit id="1a761bf1c3bac8790220dd0e044887eeb25a2cc8" translate="yes" xml:space="preserve">
          <source>For instructions with the imm8 version: PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW, PSRLDQ, PSLLDQ</source>
          <target state="translated">用于与imm8版本的说明。PSLLD,PSLLQ,PSLLW,PSRAD,PSRAW,PSRLD,PSRLQ,PSRLW,PSRLDQ,PSLLDQ。</target>
        </trans-unit>
        <trans-unit id="abfb408bf733bafad2f02f380cf2ab1c7688837d" translate="yes" xml:space="preserve">
          <source>For instructions: CMPPD, CMPSS, CMPSD, CMPPS, PSHUFD, PSHUFHW, PSHUFLW, BLENDPD, BLENDPS, DPPD, DPPS, MPSADBW, PBLENDW, ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS</source>
          <target state="translated">供说明。CMPPD、CMPSS、CMPSD、CMPPS、PSHUFD、PSHUFHW、PSHUFLW、BLENDPD、BLENDPS、DPPD、DPPS、MPSADBW、PBLENDW、ROUNDPD、ROUNDPS、ROUNDSD、ROUNDSS。</target>
        </trans-unit>
        <trans-unit id="c9f96708c73215da1e5407fa5ce762f21c941725" translate="yes" xml:space="preserve">
          <source>For integral operands of the &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators, the quotient rounds towards zero and the remainder has the same sign as the dividend.</source>
          <target state="translated">对于 &lt;code&gt;/&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 运算符的整数操作数，商会四舍五入为零，余数与除数具有相同的符号。</target>
        </trans-unit>
        <trans-unit id="2912089b8e4b5f7fb17c30aa7f29625c50f1f39a" translate="yes" xml:space="preserve">
          <source>For integral operands of the &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; operators, the quotient rounds towards zero and the remainder has the same sign as the dividend. If the divisor is zero, an Exception is thrown.</source>
          <target state="translated">对于 &lt;code&gt;/&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 运算符的整数操作数，商会四舍五入为零，余数与除数具有相同的符号。如果除数为零，则抛出异常。</target>
        </trans-unit>
        <trans-unit id="00fe6a3ea358be700add2733e7f987f7657eccea" translate="yes" xml:space="preserve">
          <source>For integral operands, the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; correspond to multiply, divide, and modulus operations. For multiply, overflows are ignored and simply chopped to fit into the integral type.</source>
          <target state="translated">对于整数操作数， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 对应于乘法，除法和模运算。对于乘法，将忽略溢出并将其简单地切整以适合整数类型。</target>
        </trans-unit>
        <trans-unit id="f8089e9fce56a8de104b1a2fd89f78f4e3794e38" translate="yes" xml:space="preserve">
          <source>For large file support, there is also a LARGE version of the key which takes an off_t type, allowing platforms with larger off_t sizes to handle larger files. See below for INFILESIZE_LARGE.</source>
          <target state="translated">对于大文件的支持,还有一个LARGE版本的key,它取一个off_t类型,允许有较大off_t大小的平台处理大文件。参见下面的INFILESIZE_LARGE。</target>
        </trans-unit>
        <trans-unit id="4573bc72a0b35e6968fbc43281884135acda5317" translate="yes" xml:space="preserve">
          <source>For many processes, a grapheme cluster behaves as if it was a single character with the same properties as its grapheme base. Effectively, nonspacing marks apply</source>
          <target state="translated">对于许多过程来说,一个词组的行为就像一个单一的字符,具有与其词组基础相同的属性。实际上,非间隔标记适用于</target>
        </trans-unit>
        <trans-unit id="d9d2c4569580379d483d010c37b2df4e739e00dd" translate="yes" xml:space="preserve">
          <source>For methods, it would be the class object or struct value the method is called on. For nested functions it would be the enclosing function's stack frame.</source>
          <target state="translated">对于方法来说,它是方法被调用的类对象或结构值。对于嵌套函数,它将是包围函数的堆栈框架。</target>
        </trans-unit>
        <trans-unit id="c658e43c1de6b0fdb8fb67e28199ecda730200d8" translate="yes" xml:space="preserve">
          <source>For more control than the high level functions provide, use the low level API:</source>
          <target state="translated">如果想获得比高级函数更多的控制权,请使用低级API。</target>
        </trans-unit>
        <trans-unit id="62fcc5c0c32d14129884b840a9ef5db5f9b4d71a" translate="yes" xml:space="preserve">
          <source>For more info about callbacks read the &lt;a href=&quot;function#closures&quot;&gt;closures&lt;/a&gt; section.</source>
          <target state="translated">有关回调的更多信息，请阅读&lt;a href=&quot;function#closures&quot;&gt;闭包&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="71b3018631aa22db33f776c9f67587180199aba3" translate="yes" xml:space="preserve">
          <source>For more information and a</source>
          <target state="translated">欲了解更多信息和</target>
        </trans-unit>
        <trans-unit id="4e48b9f8da2dcff74dfa76b614f30e09e82d9357" translate="yes" xml:space="preserve">
          <source>For more information on normalization forms see the &lt;a href=&quot;#Normalization&quot;&gt;normalization section&lt;/a&gt;.</source>
          <target state="translated">有关规范化表格的更多信息，请参见&lt;a href=&quot;#Normalization&quot;&gt;规范化部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c70774a3bc49910eb2a297e31d36c248a26d7f7c" translate="yes" xml:space="preserve">
          <source>For more information please see the full section on &lt;a href=&quot;unittest#documented-unittests&quot;&gt;documented unit tests&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;unittest#documented-unittests&quot;&gt;记录的单元测试&lt;/a&gt;的完整部分。</target>
        </trans-unit>
        <trans-unit id="f4836c4e8b6fd2beb1b18962cae04c16a239752f" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;reference documentation&lt;/a&gt; and the &lt;code&gt;ld&lt;/code&gt; man page.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/IncludingFrameworks.html&quot;&gt;参考文档&lt;/a&gt;和 &lt;code&gt;ld&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="d343011cf3b0f9c5af4eccef2d47be216bb18517" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D&lt;/a&gt;</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;D中的现代COM编程。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3833d3948eb765db1f448508cd33cee5954a145d" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;Modern COM Programming in D&lt;/a&gt;</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;http://www.lunesu.com/uploads/ModernCOMProgramminginD.pdf&quot;&gt;D中的现代COM编程。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c75305c01a420c526f9930f5f2afef16712fe3db" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;Compile-time Sequences&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://dlang.org/ctarguments.html&quot;&gt;编译时序列&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="232f8923a5b9a1c36aaeed4b764cc4a027de9c86" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;template#function-templates&quot;&gt;function templates&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;template#function-templates&quot;&gt;功能模板&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14fe53fd058540daece4c12310ac08fab7493096" translate="yes" xml:space="preserve">
          <source>For more information, see: &lt;a href=&quot;attribute#uda&quot;&gt;User-Defined Attributes&lt;/a&gt;</source>
          <target state="translated">有关更多信息，请参见：&lt;a href=&quot;attribute#uda&quot;&gt;用户定义的属性&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b01b147c4aa5229fbefd3dfcace458d961ffaae" translate="yes" xml:space="preserve">
          <source>For more on infering uniqueness see the &lt;b&gt;unique&lt;/b&gt; and &lt;b&gt;lent&lt;/b&gt; keywords in the &lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt; language.  The downside of using &lt;code&gt;assumeUnique&lt;/code&gt;'s convention-based usage is that at this time there is no formal checking of the correctness of the assumption; on the upside, the idiomatic use of &lt;code&gt;assumeUnique&lt;/code&gt; is simple and rare enough to be tolerable.</source>
          <target state="translated">有关推断唯一性的更多信息，请参见&lt;a href=&quot;http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt;语言中的&lt;b&gt;unique&lt;/b&gt;和&lt;b&gt;lent&lt;/b&gt;关键字。使用 &lt;code&gt;assumeUnique&lt;/code&gt; 的基于约定的用法的不利之处在于，目前尚无形式上正确的假设检查。从 &lt;code&gt;assumeUnique&lt;/code&gt; 来说，对前提条件的假设假设的惯用用法很简单，而且稀有到可以容忍的程度。</target>
        </trans-unit>
        <trans-unit id="467ee170e1f7b089ee09d2538996894e7758fd89" translate="yes" xml:space="preserve">
          <source>For more on infering uniqueness see the &lt;b&gt;unique&lt;/b&gt; and &lt;b&gt;lent&lt;/b&gt; keywords in the &lt;a href=&quot;https://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf&quot;&gt;ArchJava&lt;/a&gt; language.  The downside of using &lt;code&gt;assumeUnique&lt;/code&gt;'s convention-based usage is that at this time there is no formal checking of the correctness of the assumption; on the upside, the idiomatic use of &lt;code&gt;assumeUnique&lt;/code&gt; is simple and rare enough to be tolerable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9821fa00e5b3937536d63348fff48dbf21802af0" translate="yes" xml:space="preserve">
          <source>For most purposes, direct usage of this template is not necessary; instead, this module provides default implementations: &lt;a href=&quot;#Base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt;, implementing basic Base64 encoding, and &lt;a href=&quot;#Base64URL&quot;&gt;&lt;code&gt;Base64URL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base64URLNoPadding&quot;&gt;&lt;code&gt;Base64URLNoPadding&lt;/code&gt;&lt;/a&gt;, that implement the Base64 variant for use in URLs and filenames, with and without padding, respectively.</source>
          <target state="translated">在大多数情况下，无需直接使用此模板；代替，该模块提供默认实现：&lt;a href=&quot;#Base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; 的&lt;/a&gt;，实施基本Base64编码，和&lt;a href=&quot;#Base64URL&quot;&gt; &lt;code&gt;Base64URL&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Base64URLNoPadding&quot;&gt; &lt;code&gt;Base64URLNoPadding&lt;/code&gt; &lt;/a&gt;，实现将在URL和文件名，有和没有填充，分别使用中的Base64变体。</target>
        </trans-unit>
        <trans-unit id="1227b6928512c13bafca17372e6fc839cf749e01" translate="yes" xml:space="preserve">
          <source>For negative durations, all of the split values will be negative.</source>
          <target state="translated">对于负的持续时间,所有的拆分值都将为负。</target>
        </trans-unit>
        <trans-unit id="45d1ac4eefadfd952fb52f8057a9eb1805d7b858" translate="yes" xml:space="preserve">
          <source>For non-struct types, &lt;code&gt;move&lt;/code&gt; just performs &lt;code&gt;target = source&lt;/code&gt;:</source>
          <target state="translated">对于非结构类型， &lt;code&gt;move&lt;/code&gt; 仅执行 &lt;code&gt;target = source&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3570c921d353ad6046f6122f9d8cb40d604f2aae" translate="yes" xml:space="preserve">
          <source>For other operand types, identity is defined as being the same as equality.</source>
          <target state="translated">对于其他操作数类型,身份被定义为与平等相同。</target>
        </trans-unit>
        <trans-unit id="c79c85aac54555c7fe4b24d5b33131b97310e7b3" translate="yes" xml:space="preserve">
          <source>For other sized structs and static arrays, the return value is stored through a hidden pointer passed as an argument to the function.</source>
          <target state="translated">对于其他大小的结构和静态数组,返回值通过作为函数参数传递的隐藏指针来存储。</target>
        </trans-unit>
        <trans-unit id="c922333737093f82b45fffe13ff631745c29e34e" translate="yes" xml:space="preserve">
          <source>For other types, the argument is built with itself, as in:</source>
          <target state="translated">对于其他类型,参数是和自己一起建立的,如。</target>
        </trans-unit>
        <trans-unit id="936523f8bfb5590c510abb12f08771cbe0e0675b" translate="yes" xml:space="preserve">
          <source>For our new type 'this', which is type-constructed from t, fill in the cto, ito, sto, scto, wto shortcuts.</source>
          <target state="translated">对于我们的新类型'this',它是由t构造的类型,填写cto、ito、sto、scto、wto的快捷方式。</target>
        </trans-unit>
        <trans-unit id="4b41c44e66bd12d32d9b45595720696363ec412b" translate="yes" xml:space="preserve">
          <source>For popular C libraries, the first place to look for the corresponding D interface file is the &lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt;. If it isn't there already, and you write one, please contribute it to the Deimos Project.</source>
          <target state="translated">对于流行的C库，查找对应的D接口文件的第一个地方是&lt;a href=&quot;https://github.com/D-Programming-Deimos/&quot;&gt;Deimos Project&lt;/a&gt;。如果还不存在，请编写一个，然后将其贡献给Deimos项目。</target>
        </trans-unit>
        <trans-unit id="dd500fbbdcecf0b15b4a7bec7168a77dbb809b02" translate="yes" xml:space="preserve">
          <source>For precise typing of that area, you can also let the compiler generate the class instance into the DATA segment for you:</source>
          <target state="translated">为了精确地输入该区域,你也可以让编译器为你生成类实例到data段。</target>
        </trans-unit>
        <trans-unit id="d95500d6486dd9976894874f4bc1686c74984f1a" translate="yes" xml:space="preserve">
          <source>For pretty-printing a type.</source>
          <target state="translated">用于漂亮地打印字体。</target>
        </trans-unit>
        <trans-unit id="6beaf38011ce8934c0bf0fe14801463a84176de7" translate="yes" xml:space="preserve">
          <source>For printing two types with qualification when necessary.</source>
          <target state="translated">必要时,用于打印两种类型的限定。</target>
        </trans-unit>
        <trans-unit id="b457b27aba75e0c9b673db93afc4a6454c8737c9" translate="yes" xml:space="preserve">
          <source>For ranges that do not offer random access, &lt;code&gt;SearchPolicy.linear&lt;/code&gt; is the only policy allowed (and it must be specified explicitly lest it exposes user code to unexpected inefficiencies). For random-access searches, all policies are allowed, and &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; is the default.</source>
          <target state="translated">对于不提供随机访问的范围， &lt;code&gt;SearchPolicy.linear&lt;/code&gt; 是唯一允许的策略（并且必须明确指定，以免将用户代码暴露在意料之外的低效率中）。对于随机访问搜索，允许所有策略，默认值为 &lt;code&gt;SearchPolicy.binarySearch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed3956141d9c50632728180436f8b91fa73ece41" translate="yes" xml:space="preserve">
          <source>For reals, logGamma is equivalent to log(fabs(gamma(x))).</source>
          <target state="translated">对于实际情况,logGamma相当于log(fabs(gamma(x)))。</target>
        </trans-unit>
        <trans-unit id="96cc49076f4a58f629be6c15f8c505a83f5ad981" translate="yes" xml:space="preserve">
          <source>For runtime testing to see if certain vector instructions are available, see the functions in &lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid&lt;/a&gt;.</source>
          <target state="translated">要进行运行时测试以查看某些矢量指令是否可用，请参阅&lt;a href=&quot;https://dlang.org/phobos/core_cpuid.html&quot;&gt;core.cpuid中&lt;/a&gt;的函数。</target>
        </trans-unit>
        <trans-unit id="b0f737f02cc74529ec3e1d25c3b2fb5c37d91021" translate="yes" xml:space="preserve">
          <source>For some D implementations, such as a translator from D to C, an inline assembler makes no sense, and need not be implemented. The version statement can be used to account for this:</source>
          <target state="translated">对于一些D的实现,例如从D到C的翻译器,内联汇编器是没有意义的,也不需要实现。版本声明可以用来说明这一点。</target>
        </trans-unit>
        <trans-unit id="432250ecd3da26b3dac3ea1fed77d588163ee5c7" translate="yes" xml:space="preserve">
          <source>For stateless allocators, this does nothing.</source>
          <target state="translated">对于无状态的分配器来说,这没有任何作用。</target>
        </trans-unit>
        <trans-unit id="098a57b35500f4f0a012b83d59f1556df0c13332" translate="yes" xml:space="preserve">
          <source>For statements implement loops with initialization, test, and increment clauses.</source>
          <target state="translated">For语句实现具有初始化、测试和增量子句的循环。</target>
        </trans-unit>
        <trans-unit id="53f702e5ced5b4f4e7dbc696e5107fe16283acd0" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, equality is defined as the lengths of the arrays matching, and all the elements are equal.</source>
          <target state="translated">对于静态数组和动态数组,平等的定义是数组的长度相匹配,所有元素都相等。</target>
        </trans-unit>
        <trans-unit id="fa40b68079370408167ad68be5b40bbec28bf002" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, identity is defined as referring to the same array elements and the same number of elements.</source>
          <target state="translated">对于静态数组和动态数组,身份被定义为指同一数组元素和相同数量的元素。</target>
        </trans-unit>
        <trans-unit id="0ec6b65a9ed5b90b70c026136f3fd68edfea3f4e" translate="yes" xml:space="preserve">
          <source>For static and dynamic arrays, the result of the relational op is the result of the operator applied to the first non-equal element of the array. If two arrays compare equal, but are of different lengths, the shorter array compares as &quot;less&quot; than the longer array.</source>
          <target state="translated">对于静态和动态数组,关系运算的结果是应用于数组中第一个非等值元素的运算符的结果。如果两个数组比较相等,但长度不同,那么较短的数组比较长的数组比较 &quot;少&quot;。</target>
        </trans-unit>
        <trans-unit id="f2b8a81160066cc4e2c9823b604d02970c2dda27" translate="yes" xml:space="preserve">
          <source>For static arrays:</source>
          <target state="translated">对于静态数组。</target>
        </trans-unit>
        <trans-unit id="e3e34261f3141bf464d51f74f924244b763433b8" translate="yes" xml:space="preserve">
          <source>For struct objects and floating point values, identity is defined as the bits in the operands being identical.</source>
          <target state="translated">对于结构体对象和浮点值,标识性定义为操作数中的位是相同的。</target>
        </trans-unit>
        <trans-unit id="dacb4ed6715c30c5a9147d7fcd6915634bae0082" translate="yes" xml:space="preserve">
          <source>For struct objects, equality means the result of the &lt;a href=&quot;operatoroverloading#equals&quot;&gt;&lt;code&gt;opEquals()&lt;/code&gt; member function&lt;/a&gt;. If an &lt;code&gt;opEquals()&lt;/code&gt; is not provided, equality is defined as the logical product of all equality results of the corresponding object fields.</source>
          <target state="translated">对于结构对象，相等意味着&lt;a href=&quot;operatoroverloading#equals&quot;&gt; &lt;code&gt;opEquals()&lt;/code&gt; 成员函数的结果&lt;/a&gt;。如果未提供 &lt;code&gt;opEquals()&lt;/code&gt; ，则将相等定义为相应对象字段的所有相等结果的逻辑积。</target>
        </trans-unit>
        <trans-unit id="77b81660c87ba600c859281896d0e680dc7a0639" translate="yes" xml:space="preserve">
          <source>For struct types, operator overloading for the identity assignment is allowed.</source>
          <target state="translated">对于结构类型,允许对身份分配进行运算符重载。</target>
        </trans-unit>
        <trans-unit id="7d6ebd4bd1de4cb13975d6ad6d6494f493e36039" translate="yes" xml:space="preserve">
          <source>For structs that do not define &lt;code&gt;toString&lt;/code&gt;, the conversion to string produces the list of fields.</source>
          <target state="translated">对于未定义 &lt;code&gt;toString&lt;/code&gt; 的结构，到string的转换将产生字段列表。</target>
        </trans-unit>
        <trans-unit id="24c5ae67500605fc6fe25591d513c37d81e53fba" translate="yes" xml:space="preserve">
          <source>For the &quot;this&quot; parameter to member functions</source>
          <target state="translated">对于成员函数的 &quot;this &quot;参数</target>
        </trans-unit>
        <trans-unit id="1c01d80e91a2499949025f2280ab6ed6d2555900" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; objects which does not have &lt;code&gt;toString&lt;/code&gt;,</source>
          <target state="translated">对于没有 &lt;code&gt;toString&lt;/code&gt; 的 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;union&lt;/code&gt; 对象，</target>
        </trans-unit>
        <trans-unit id="4f49cbadbf80fd5534728dbb0a52da7243f0e4cf" translate="yes" xml:space="preserve">
          <source>For the class objects which have input range interface,</source>
          <target state="translated">对于有输入范围接口的类对象。</target>
        </trans-unit>
        <trans-unit id="3fe70e23dba2fe2f6a6436972a79f198b1023846" translate="yes" xml:space="preserve">
          <source>For the default implementation, &lt;code&gt;notifyAll&lt;/code&gt;will behave like &lt;code&gt;notify&lt;/code&gt;.</source>
          <target state="translated">对于默认实现， &lt;code&gt;notifyAll&lt;/code&gt; 的行为类似于 &lt;code&gt;notify&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a32f3e2bbec4c5b80346149779ed01edefc9b85" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, a further check is made to see if the function can be called.</source>
          <target state="translated">对于表达 &lt;code&gt;__traits(compiles, exp)&lt;/code&gt; 其中 &lt;code&gt;exp&lt;/code&gt; 是 &lt;code&gt;@property&lt;/code&gt; 功能，进行进一步检查以查看是否该函数可以被调用。</target>
        </trans-unit>
        <trans-unit id="b458b5efdd66ae7f2f84dbe61163a34a752450a1" translate="yes" xml:space="preserve">
          <source>For the expression &lt;code&gt;typeof(exp)&lt;/code&gt; where &lt;code&gt;exp&lt;/code&gt; is an &lt;code&gt;@property&lt;/code&gt; function, the type is the return type of the function, rather than the type of the function.</source>
          <target state="translated">对于表达式 &lt;code&gt;typeof(exp)&lt;/code&gt; ，其中 &lt;code&gt;exp&lt;/code&gt; 是 &lt;code&gt;@property&lt;/code&gt; 函数，类型是函数的返回类型，而不是函数的类型。</target>
        </trans-unit>
        <trans-unit id="4da3489e77815a3f59254a16848fd39b736c2ccf" translate="yes" xml:space="preserve">
          <source>For the given module, perform any post parsing analysis. Certain compiler backends (ie: GDC) have special placeholder modules whose source are empty, but code gets injected immediately after loading.</source>
          <target state="translated">对于给定的模块,执行任何后解析分析。某些编译器后端(即:GDC)有特殊的占位模块,其源码是空的,但代码会在加载后立即被注入。</target>
        </trans-unit>
        <trans-unit id="eee09d9bd02ca0e040c01e0c78e4b5fbf6e37934" translate="yes" xml:space="preserve">
          <source>For this CRC32 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">对于这个CRC32 Digest的实现,在默认构造后调用start是不必要的。只有在重置Digest时才需要调用start。</target>
        </trans-unit>
        <trans-unit id="cffc81d750572e8587c7a4c64f2343abc051fae9" translate="yes" xml:space="preserve">
          <source>For this MD5 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">对于这个MD5 Digest的实现,在默认构造后调用start是不必要的。只有在重置Digest时才需要调用start。</target>
        </trans-unit>
        <trans-unit id="ed2c37418037d9b0c7a9812c6d18534a64e6ecf7" translate="yes" xml:space="preserve">
          <source>For this RIPEMD160 Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">对于这个RIPEMD160 Digest的实现,在默认构造后调用start是不必要的。只有在重置Digest时才需要调用start。</target>
        </trans-unit>
        <trans-unit id="249161f18b734896a386ad2283f2254a90cd8dc8" translate="yes" xml:space="preserve">
          <source>For this SHA Digest implementation calling start after default construction is not necessary. Calling start is only necessary to reset the Digest.</source>
          <target state="translated">对于这个SHA Digest的实现,在默认构造后调用start是没有必要的。只有在重置Digest时才需要调用start。</target>
        </trans-unit>
        <trans-unit id="29b834a88118650bc23043a0e1a119bc9548636a" translate="yes" xml:space="preserve">
          <source>For unary &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;onOverflow&lt;/code&gt; is called if &lt;code&gt;lhs == Lhs.min&lt;/code&gt; and &lt;code&gt;Lhs&lt;/code&gt; is a signed type. The function returns &lt;code&gt;Lhs.max&lt;/code&gt;.</source>
          <target state="translated">对于一元 &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;onOverflow&lt;/code&gt; 被称为如果 &lt;code&gt;lhs == Lhs.min&lt;/code&gt; 和 &lt;code&gt;Lhs&lt;/code&gt; 是有符号的类型。该函数返回 &lt;code&gt;Lhs.max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3735f46e74c34d876c612b5f0d45ae5d470195b4" translate="yes" xml:space="preserve">
          <source>For unsatisfied conditions, the conditionally compiled code need only be syntactically correct. It does not have to be semantically correct.</source>
          <target state="translated">对于不满足的条件,条件编译的代码只需要在语法上是正确的。它不一定要在语义上正确。</target>
        </trans-unit>
        <trans-unit id="cbc5de8d1ef5491a35e3c236ec7889a9c2c4a94d" translate="yes" xml:space="preserve">
          <source>For use by application</source>
          <target state="translated">用于应用</target>
        </trans-unit>
        <trans-unit id="e74c782f1ffbeab9de3e921ce4304765a91d12e2" translate="yes" xml:space="preserve">
          <source>For use by application VFS</source>
          <target state="translated">供应用VFS使用</target>
        </trans-unit>
        <trans-unit id="3505b0edb5eee92682026f8144fd82b24c70a4f7" translate="yes" xml:space="preserve">
          <source>For use by built-in VFS</source>
          <target state="translated">供内置VFS使用</target>
        </trans-unit>
        <trans-unit id="88dbc145581c8c0573b319436a71bb181cd0808c" translate="yes" xml:space="preserve">
          <source>For use by extension VFS</source>
          <target state="translated">供扩展VFS使用</target>
        </trans-unit>
        <trans-unit id="230bac78e67f31568eb4729e25ce498036be0132" translate="yes" xml:space="preserve">
          <source>For user defined types. Should be equivalent to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">对于用户定义的类型。应该等于 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5f2524697bf575ce5005555e479cdd81f208227" translate="yes" xml:space="preserve">
          <source>For user-defined types, assignment operator expressions are overloaded separately from the binary operator. Still the left operand must be an lvalue.</source>
          <target state="translated">对于用户定义类型,赋值运算符表达式与二进制运算符分开重载。左边的操作数仍然必须是一个l值。</target>
        </trans-unit>
        <trans-unit id="0fb758f20654c3c8f3d278d2ed2c4c22389d5933" translate="yes" xml:space="preserve">
          <source>For using time zones other than local time or UTC, use &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Posix systems (or on Windows, if providing the TZ Database files), and use &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt; on Windows systems. The time in &lt;code&gt;SysTime&lt;/code&gt; is kept internally in hnsecs from midnight, January 1st, 1 A.D. UTC. Conversion error cannot happen when changing the time zone of a &lt;code&gt;SysTime&lt;/code&gt;. &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents the local time, and &lt;code&gt;UTC&lt;/code&gt; is the &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; class which represents UTC. &lt;code&gt;SysTime&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; if no &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; is provided. For more details on time zones, see the documentation for &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要使用本地时间或UTC以外的时区，&lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt;在Posix系统上（或在Windows（如果提供TZ数据库文件）上）使用&lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; &lt;/a&gt;在Windows系统上使用std.datetime.timezone.WindowsTimeZone。 &lt;code&gt;SysTime&lt;/code&gt; 中的时间从1 UTC 1月1日午夜开始在内部以hnsecs为单位。更改 &lt;code&gt;SysTime&lt;/code&gt; 的时区时，不会发生转换错误。&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;是&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;类表示本地时间， &lt;code&gt;UTC&lt;/code&gt; 是&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;类代表UTC。 &lt;code&gt;SysTime&lt;/code&gt; 使用&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;如果未提供 std.datetime.timezone.TimeZone，则为&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;。有关时区的更多详细信息，请参阅&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;std_datetime_timezone#PosixTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.PosixTimeZone&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;std_datetime_timezone#WindowsTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.WindowsTimeZone&lt;/code&gt; 的文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab8570d227afb15f540b536d5d1262c12c2ed538" translate="yes" xml:space="preserve">
          <source>For very large numbers, consider using the &lt;a href=&quot;http://gmplib.org&quot;&gt;GMP library&lt;/a&gt; instead.</source>
          <target state="translated">对于很大的数字，请考虑改用&lt;a href=&quot;http://gmplib.org&quot;&gt;GMP库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e95ca0b1ba53ec60e9f02c5651b3f5d4954e798d" translate="yes" xml:space="preserve">
          <source>For very large numbers, consider using the &lt;a href=&quot;https://gmplib.org&quot;&gt;GMP library&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0aaa1972b9827ddaeaa8c903dd012d64dc52a6" translate="yes" xml:space="preserve">
          <source>For very small x, expm1(x) is more accurate than exp(x)-1.</source>
          <target state="translated">对于很小的x,expm1(x)比exp(x)-1更准确。</target>
        </trans-unit>
        <trans-unit id="f6a75d7a9f98a84894db843b9fa129f7e85e4ad5" translate="yes" xml:space="preserve">
          <source>For very small x, log1p(x) will be more accurate than log(1 + x).</source>
          <target state="translated">对于很小的x,log1p(x)会比log(1+x)更准确。</target>
        </trans-unit>
        <trans-unit id="d5e2ba36b5f0fe67d03dfd60aced704179f8dc15" translate="yes" xml:space="preserve">
          <source>For virtual tables.</source>
          <target state="translated">对于虚拟表:</target>
        </trans-unit>
        <trans-unit id="9b2f5f01d7f036017bc44e0f5e7dd87067f218dd" translate="yes" xml:space="preserve">
          <source>For when the array has a non-zero initializer.</source>
          <target state="translated">用于当数组有一个非零的初始化器时。</target>
        </trans-unit>
        <trans-unit id="62235af30d4d3e83911b7f668444bdadcbf6e31f" translate="yes" xml:space="preserve">
          <source>For which &lt;code&gt;TargetOS&lt;/code&gt; the flags are applicable</source>
          <target state="translated">这些标志适用于哪些 &lt;code&gt;TargetOS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0512a8baa5c7d81d4b0fde3207bf25c16a72e5f5" translate="yes" xml:space="preserve">
          <source>ForStatement</source>
          <target state="translated">ForStatement</target>
        </trans-unit>
        <trans-unit id="2d317e6f14c862c7eb4252c51b1bf37d642b8a8c" translate="yes" xml:space="preserve">
          <source>ForStatements</source>
          <target state="translated">ForStatements</target>
        </trans-unit>
        <trans-unit id="809149a8ad9a0028e99b6a9d68c6c4147cc5a5e7" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by printing an error message to &lt;code&gt;stderr&lt;/code&gt; and then abort the program. &lt;code&gt;Abort&lt;/code&gt; is the default second argument for &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">通过将错误消息打印到 &lt;code&gt;stderr&lt;/code&gt; ，然后中止程序，强制所有积分错误失败。 &lt;code&gt;Abort&lt;/code&gt; 是 &lt;code&gt;Checked&lt;/code&gt; 的默认第二个参数。</target>
        </trans-unit>
        <trans-unit id="cb769685cb2418f96e7eb5cd6f3bc4bc9cdba76c" translate="yes" xml:space="preserve">
          <source>Force all integral errors to fail by throwing an exception of type &lt;code&gt;Throw.CheckFailure&lt;/code&gt;. The message coming with the error is similar to the one printed by &lt;code&gt;Warn&lt;/code&gt;.</source>
          <target state="translated">通过抛出 &lt;code&gt;Throw.CheckFailure&lt;/code&gt; 类型的异常来强制所有积分错误失败。带有错误的消息类似于 &lt;code&gt;Warn&lt;/code&gt; 打印的消息。</target>
        </trans-unit>
        <trans-unit id="568ec7a75ae095d53209f55c9ce73fe37d60ef50" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;capacity&lt;/code&gt; to at least &lt;code&gt;x&lt;/code&gt; without reducing it.</source>
          <target state="translated">强制 &lt;code&gt;capacity&lt;/code&gt; 至少达到 &lt;code&gt;x&lt;/code&gt; 而不减小。</target>
        </trans-unit>
        <trans-unit id="19149ba839181262b9bdb188174930e36e6f0df9" translate="yes" xml:space="preserve">
          <source>Forces &lt;code&gt;this&lt;/code&gt; to the null state.</source>
          <target state="translated">强制 &lt;code&gt;this&lt;/code&gt; 为空状态。</target>
        </trans-unit>
        <trans-unit id="a8db5e83b8a35fac9d3b32ebcc923950ddcc52de" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber and then throws obj in the calling fiber.</source>
          <target state="translated">强制上下文切换发生在远离调用光纤的地方,然后在调用光纤中抛出obj。</target>
        </trans-unit>
        <trans-unit id="2f48cbfa34abf44639ec829c0d55463cc9494c97" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling fiber.</source>
          <target state="translated">迫使上下文切换发生在远离呼叫光纤的地方。</target>
        </trans-unit>
        <trans-unit id="80579a9d1e587d7b0ea440174e72821dab14c81a" translate="yes" xml:space="preserve">
          <source>Forces a context switch to occur away from the calling thread.</source>
          <target state="translated">强制在调用线程之外进行上下文切换。</target>
        </trans-unit>
        <trans-unit id="13258c0abcfb4cca178a3b35d4e0664b60f42a89" translate="yes" xml:space="preserve">
          <source>Forces any data buffered by the OS to be written to disk. Call &lt;a href=&quot;#flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before calling this function to flush the C &lt;code&gt;FILE&lt;/code&gt; buffers first.</source>
          <target state="translated">强制将操作系统缓冲的所有数据写入磁盘。调用&lt;a href=&quot;#flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;调用此函数刷新前C &lt;code&gt;FILE&lt;/code&gt; 第一缓冲区。</target>
        </trans-unit>
        <trans-unit id="23e389c62cad5bc7af8046c1d45faa80b7add735" translate="yes" xml:space="preserve">
          <source>Forces free list mode. If already in free list mode, does nothing. Otherwise, sorts the free list accumulated so far and switches strategy for future allocations to KR style.</source>
          <target state="translated">强制进入自由列表模式。如果已经进入自由列表模式,则什么都不做。否则,对目前积累的自由列表进行排序,并将未来的分配策略切换为KR风格。</target>
        </trans-unit>
        <trans-unit id="7438f3f3f123487789d348d295cbd3a74e9f3636" translate="yes" xml:space="preserve">
          <source>Forces the number of elements in the container to &lt;code&gt;n&lt;/code&gt;. If the container ends up growing, the added elements are initialized in a container-dependent manner (usually with &lt;code&gt;T.init&lt;/code&gt;).</source>
          <target state="translated">强制容器中的元素数为 &lt;code&gt;n&lt;/code&gt; 。如果容器最终增长，则添加的元素将以与容器相关的方式初始化（​​通常使用 &lt;code&gt;T.init&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="41991c2a7e01e941592d10ca1b4c7b6d194af71f" translate="yes" xml:space="preserve">
          <source>Forcibly deallocates all memory allocated by this allocator, making it available for further allocations. Does not return memory to &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">强制取消分配此分配器分配的所有内存，使其可用于进一步的分配。不将内存返回给 &lt;code&gt;ParentAllocator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e05b71be24859a77e2790b0d8e71bc9f4dd8c1f8" translate="yes" xml:space="preserve">
          <source>Foreach</source>
          <target state="translated">Foreach</target>
        </trans-unit>
        <trans-unit id="24a9bd4ac18d7ddab41be52adbe896067b46f066" translate="yes" xml:space="preserve">
          <source>Foreach Range Methods</source>
          <target state="translated">Foreach Range方法</target>
        </trans-unit>
        <trans-unit id="2c53155a2e00768b8f625193cebda30089ce0843" translate="yes" xml:space="preserve">
          <source>Foreach Range Properties</source>
          <target state="translated">Foreach Range Properties</target>
        </trans-unit>
        <trans-unit id="45b6dd48295de07cd5e6e8af0d02a0aba0d48189" translate="yes" xml:space="preserve">
          <source>Foreach Range Statement</source>
          <target state="translated">Foreach Range Statement</target>
        </trans-unit>
        <trans-unit id="3e61286776c3201ae4e25284f6e9997d2d997281" translate="yes" xml:space="preserve">
          <source>Foreach Ref Parameters</source>
          <target state="translated">Foreach Ref Parameters</target>
        </trans-unit>
        <trans-unit id="a6c2c1398fe7e48f653dc8f0a8caddaee072679f" translate="yes" xml:space="preserve">
          <source>Foreach Restrictions</source>
          <target state="translated">Foreach Restrictions</target>
        </trans-unit>
        <trans-unit id="0553132dc6cdd5f87cabaeda4197e661d068c9f8" translate="yes" xml:space="preserve">
          <source>Foreach Statement</source>
          <target state="translated">Foreach声明</target>
        </trans-unit>
        <trans-unit id="da94ac95aa14d4788d7fd4a24d8272c7d97d35a8" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays</source>
          <target state="translated">Foreach over Arrays</target>
        </trans-unit>
        <trans-unit id="b1b911444dc098ad04d8c1492527b6551f0916f7" translate="yes" xml:space="preserve">
          <source>Foreach over Arrays of Characters</source>
          <target state="translated">Foreach超过字符数组</target>
        </trans-unit>
        <trans-unit id="2a77599ec0f128dc2ac0586f465739ede0b37cd8" translate="yes" xml:space="preserve">
          <source>Foreach over Associative Arrays</source>
          <target state="translated">Foreach over Associative Arrays</target>
        </trans-unit>
        <trans-unit id="140fe06b456ed9f1ae3d0c4efbee66b6a7732580" translate="yes" xml:space="preserve">
          <source>Foreach over Delegates</source>
          <target state="translated">Foreach over Delegates</target>
        </trans-unit>
        <trans-unit id="2118d2308b39d4304cee2cfe11851139c70627b5" translate="yes" xml:space="preserve">
          <source>Foreach over Sequences</source>
          <target state="translated">Foreach over Sequences</target>
        </trans-unit>
        <trans-unit id="2f65a25f9fa525fd78d322a8ac805a6f39540fba" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with Ranges</source>
          <target state="translated">Foreach over Structs and Classes with Ranges.</target>
        </trans-unit>
        <trans-unit id="3d5dd8a83fe426ccb28e159ceb15528fef952829" translate="yes" xml:space="preserve">
          <source>Foreach over Structs and Classes with opApply</source>
          <target state="translated">用 opApply Foreach over Structs 和 Classes。</target>
        </trans-unit>
        <trans-unit id="f667fe9347feaa7cb4e621c258d2edcbe22519e9" translate="yes" xml:space="preserve">
          <source>ForeachAggregate</source>
          <target state="translated">ForeachAggregate</target>
        </trans-unit>
        <trans-unit id="df2d328871cd71e3623bbdef344f4992bcecf2e1" translate="yes" xml:space="preserve">
          <source>ForeachRangeStatement &lt;strong id=&quot;rangefe&quot;&gt;rangefe&lt;/strong&gt;;</source>
          <target state="translated">ForeachRangeStatement &lt;strong id=&quot;rangefe&quot;&gt;rangefe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e19df85959b2b1a13377a372c2de5cdf84d1b37" translate="yes" xml:space="preserve">
          <source>ForeachStatement</source>
          <target state="translated">ForeachStatement</target>
        </trans-unit>
        <trans-unit id="9e64b4731b7dbeb3175b639030eb1b4587e3cf60" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;code&gt;fes&lt;/code&gt;</source>
          <target state="translated">Foreach语句 &lt;code&gt;fes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a17c7a682fe18e111c85eb3ffb6f2a4cbaae0f4" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt;;</source>
          <target state="translated">ForeachStatement &lt;strong id=&quot;aggrfe&quot;&gt;aggrfe&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1330e14342be598ec267758faf0b9d03bb95ce41" translate="yes" xml:space="preserve">
          <source>ForeachStatement &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt;;</source>
          <target state="translated">ForeachStates &lt;strong id=&quot;fes&quot;&gt;fes&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="856f0cb9ba209b9b76b5f3f3110e190ba107f316" translate="yes" xml:space="preserve">
          <source>ForeachType</source>
          <target state="translated">ForeachType</target>
        </trans-unit>
        <trans-unit id="9c4e220b832fdde833e953123e22e947e7b36940" translate="yes" xml:space="preserve">
          <source>ForeachType!(PointerTarget!Range)[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType！（PointerTarget！Range）[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;（Range）（Range r）</target>
        </trans-unit>
        <trans-unit id="b97cbae09882028f8cf2caca90479d52c2db87df" translate="yes" xml:space="preserve">
          <source>ForeachType!Range[] &lt;strong id=&quot;array&quot;&gt;array&lt;/strong&gt;(Range)(Range r)</source>
          <target state="translated">ForeachType！Range [] &lt;strong id=&quot;array&quot;&gt;数组&lt;/strong&gt;（Range）（Range r）</target>
        </trans-unit>
        <trans-unit id="6c99353d4eb960ce958a85dea4dafad1de143866" translate="yes" xml:space="preserve">
          <source>ForeachTypeAttribute</source>
          <target state="translated">ForeachTypeAttribute</target>
        </trans-unit>
        <trans-unit id="7ce9ed7c2184e929a253429a20b37b4560fb165d" translate="yes" xml:space="preserve">
          <source>ForeachTypeList</source>
          <target state="translated">ForeachTypeList</target>
        </trans-unit>
        <trans-unit id="3432f720952ad1ef45f41182f803dfead87c5b2b" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Methods</source>
          <target state="translated">Foreach_reverse Range方法</target>
        </trans-unit>
        <trans-unit id="b050df33fa944ca9312b95dbcf3146816b9fa5f7" translate="yes" xml:space="preserve">
          <source>Foreach_reverse Range Properties</source>
          <target state="translated">Foreach_reverse Range Properties</target>
        </trans-unit>
        <trans-unit id="4f7e5954df7c830e01a29a86da382389a582afe9" translate="yes" xml:space="preserve">
          <source>Form TypeTuple from the types of the expressions. Assume exps[] is already tuple expanded.</source>
          <target state="translated">从表达式的类型中形成TypeTuple。假设exps[]已经是元组展开。</target>
        </trans-unit>
        <trans-unit id="2d244117783206496417e62aa99112e2aad4b472" translate="yes" xml:space="preserve">
          <source>Form feed (FF) (U+000C).</source>
          <target state="translated">进纸(FF)(U+000C)。</target>
        </trans-unit>
        <trans-unit id="676f10eb2f485163d62fd19ea9c8545ba45ba1b3" translate="yes" xml:space="preserve">
          <source>Formally, the minimum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(a, x)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. Conversely, the maximum is a value &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; such that &lt;code&gt;pred(x, a)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; (note the swapped arguments to &lt;code&gt;pred&lt;/code&gt;).</source>
          <target state="translated">形式上，最小值是一个值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;range&lt;/code&gt; ，使得 &lt;code&gt;pred(a, x)&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 对于所有的值 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;range&lt;/code&gt; 。相反，最大是一个值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;range&lt;/code&gt; ，使得 &lt;code&gt;pred(x, a)&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 对于所有的值 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;range&lt;/code&gt; （注意交换参数 &lt;code&gt;pred&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="150d9f841097f64a42b925806fe3290abd9bc35d" translate="yes" xml:space="preserve">
          <source>Format String</source>
          <target state="translated">格式化字符串</target>
        </trans-unit>
        <trans-unit id="683303f489ff84a56879ace6d1310dfe54be7ff4" translate="yes" xml:space="preserve">
          <source>Format a static condition as a tree-like structure, marking failed and bypassed expressions.</source>
          <target state="translated">将静态条件格式化为树状结构,标记失败和绕过的表达式。</target>
        </trans-unit>
        <trans-unit id="51e82ebaf2db5ec167460d9fcf90c1ef8ea0f2d7" translate="yes" xml:space="preserve">
          <source>Format arguments into a string.</source>
          <target state="translated">将参数格式化为一个字符串。</target>
        </trans-unit>
        <trans-unit id="b0fb6e308cc109a50167ee0e6731cc7e72eb7494" translate="yes" xml:space="preserve">
          <source>Format arguments into buffer</source>
          <target state="translated">将参数格式化为缓冲区</target>
        </trans-unit>
        <trans-unit id="926bb79848aace359e9158738e215805c41e663b" translate="yes" xml:space="preserve">
          <source>Format data into strings.</source>
          <target state="translated">将数据格式化为字符串。</target>
        </trans-unit>
        <trans-unit id="23e10a3db64de41eba0cd45a912f85a4b56f3f1b" translate="yes" xml:space="preserve">
          <source>Format flags for CustomFloat.</source>
          <target state="translated">CustomFloat的格式标志。</target>
        </trans-unit>
        <trans-unit id="9bc6c7decb7638f7f45249d89d49acf2bfdc2a16" translate="yes" xml:space="preserve">
          <source>Format like &lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt;.</source>
          <target state="translated">格式类似于 &lt;code&gt;Tuple!(types)(elements formatted with %s each)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02e42cbae72865d54225666f797f795a1b96d6bb" translate="yes" xml:space="preserve">
          <source>Format specifier</source>
          <target state="translated">格式指定器</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">格式字符串。</target>
        </trans-unit>
        <trans-unit id="ee3b46d05547f4e1ed0fb6b16e92db78c1a30405" translate="yes" xml:space="preserve">
          <source>Format string. For detailed specification, see &lt;a href=&quot;#formattedWrite&quot;&gt;&lt;code&gt;formattedWrite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">格式字符串。有关详细说明，请参见&lt;a href=&quot;#formattedWrite&quot;&gt; &lt;code&gt;formattedWrite&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9e1764b317ef266e49f202653a88a32e68ea2fd" translate="yes" xml:space="preserve">
          <source>Format to a string such as: &lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt;.</source>
          <target state="translated">格式化为如下字符串： &lt;code&gt;mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69dbb2a04350f8cee981103c2cb9db39585e38b6" translate="yes" xml:space="preserve">
          <source>Format version needed to extract this member.</source>
          <target state="translated">提取该成员所需的格式版本。</target>
        </trans-unit>
        <trans-unit id="e7a8c4c502d36efd7cdb40b63094b0c90409c783" translate="yes" xml:space="preserve">
          <source>FormatChar</source>
          <target state="translated">FormatChar</target>
        </trans-unit>
        <trans-unit id="d7ab63d27b9f2759987e52fd620d64164025e796" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">FormatSpec！Char &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb9d269d7b56db9164861bd1ad68cf391c388350" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec！Char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fcb49409d4c929c4b7d5f9fa3a44391c37114d5" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;code&gt;spec&lt;/code&gt;</source>
          <target state="translated">格式 &lt;code&gt;spec&lt;/code&gt; ！字符规范</target>
        </trans-unit>
        <trans-unit id="f215319169c289fbb719f3b0d628a3b737f8eded" translate="yes" xml:space="preserve">
          <source>FormatSpec!Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt;(Char)(Char[] fmt);</source>
          <target state="translated">FormatSpec！Char &lt;strong id=&quot;singleSpec&quot;&gt;singleSpec&lt;/strong&gt;（Char）（Char [] fmt）;</target>
        </trans-unit>
        <trans-unit id="ff3a107be5350e9cbdf489fea1b9a3cb189415cc" translate="yes" xml:space="preserve">
          <source>FormatSpec!char &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">FormatSpec！char &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d214509fa791f89f2be58f52b1b3767a22ec982d" translate="yes" xml:space="preserve">
          <source>Formats &lt;code&gt;Tuple&lt;/code&gt; with either &lt;code&gt;%s&lt;/code&gt;, &lt;code&gt;%(inner%)&lt;/code&gt; or &lt;code&gt;%(inner%|sep%)&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;%s&lt;/code&gt; ， &lt;code&gt;%(inner%)&lt;/code&gt; 或 &lt;code&gt;%(inner%|sep%)&lt;/code&gt; 格式化 &lt;code&gt;Tuple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36fd923e1d2f6994803ec17defea621b9f080f14" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer, followed by a newline.</source>
          <target state="translated">格式化并将其参数以文本格式写入OutBuffer,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="7071823457762f9707da94f7448fddbd240e7baf" translate="yes" xml:space="preserve">
          <source>Formats and writes its arguments in text format to the OutBuffer.</source>
          <target state="translated">将其参数以文本格式格式化并写入OutBuffer。</target>
        </trans-unit>
        <trans-unit id="a51cf9b2e5a5b055fe6bcc1d2693b2624065293b" translate="yes" xml:space="preserve">
          <source>Formats any value into &lt;code&gt;Char&lt;/code&gt; accepting &lt;code&gt;OutputRange&lt;/code&gt;, using the given &lt;code&gt;FormatSpec&lt;/code&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;FormatSpec&lt;/code&gt; 将任何值格式化为接受 &lt;code&gt;OutputRange&lt;/code&gt; 的 &lt;code&gt;Char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b1857e4f5a36639d321cc75f53c946b6701eca2" translate="yes" xml:space="preserve">
          <source>Formats its arguments according to the format string and puts them to an OutputRange.</source>
          <target state="translated">根据格式字符串对其参数进行格式化,并将它们放到一个OutputRange中。</target>
        </trans-unit>
        <trans-unit id="7b102bb156b0812a82b4b3cc910bf7cff6a74f11" translate="yes" xml:space="preserve">
          <source>Formats supported by Tuple</source>
          <target state="translated">Tuple支持的格式</target>
        </trans-unit>
        <trans-unit id="1eebc61a97141f60643e629482bce7edcfb75fe1" translate="yes" xml:space="preserve">
          <source>Formats the &lt;code&gt;Options&lt;/code&gt; for CLI printing.</source>
          <target state="translated">格式化用于CLI打印的 &lt;code&gt;Options&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="026cf84e486080b485be195c8355623b05fc9001" translate="yes" xml:space="preserve">
          <source>Formats the RedBlackTree into a sink function. For more info see &lt;code&gt; std.format.formatValue&lt;/code&gt;. Note that this only is available when the element type can be formatted. Otherwise, the default toString from Object is used.</source>
          <target state="translated">将RedBlackTree格式化为接收器函数。有关更多信息，请参见 &lt;code&gt; std.format.formatValue&lt;/code&gt; 。请注意，仅当可以格式化元素类型时，此选项才可用。否则，将使用Object的默认toString。</target>
        </trans-unit>
        <trans-unit id="1a1c1d1c97be2b241e71fcbcd57b8c7212c71103" translate="yes" xml:space="preserve">
          <source>Formats the stored value as a string.</source>
          <target state="translated">将存储值格式化为字符串。</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">格式化字符串打印功能</target>
        </trans-unit>
        <trans-unit id="fc5187ca67d19625ec5705d6a55febca2c516352" translate="yes" xml:space="preserve">
          <source>Formatted number of arguments.</source>
          <target state="translated">格式化的参数数。</target>
        </trans-unit>
        <trans-unit id="dfdf9e737f02222e3b629df49845cd2f57eea582" translate="yes" xml:space="preserve">
          <source>Formatting a struct by defining a method &lt;code&gt;toString&lt;/code&gt;, which takes an output range.  It's recommended that any &lt;code&gt;toString&lt;/code&gt; using &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output ranges&lt;/a&gt; use &lt;a href=&quot;std_range_primitives#put&quot;&gt;&lt;code&gt;std.range.primitives.put&lt;/code&gt;&lt;/a&gt; rather than use the &lt;code&gt;put&lt;/code&gt; method of the range directly.</source>
          <target state="translated">通过定义方法 &lt;code&gt;toString&lt;/code&gt; 格式化结构，该方法采用输出范围。建议使用&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;输出范围的&lt;/a&gt;任何 &lt;code&gt;toString&lt;/code&gt; 使用&lt;a href=&quot;std_range_primitives#put&quot;&gt; &lt;code&gt;std.range.primitives.put&lt;/code&gt; &lt;/a&gt;而不是直接使用范围的 &lt;code&gt;put&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="8e465166e94e67eebeab101e4359626150ec10a5" translate="yes" xml:space="preserve">
          <source>Forms the symbols available to all D programs. Includes Object, which is the root of the class object hierarchy. This module is implicitly imported.</source>
          <target state="translated">形成所有D程序可用的符号。包括Object,它是类对象层次结构的根。该模块是隐式导入的。</target>
        </trans-unit>
        <trans-unit id="be4f9eeadbcbd0250352284fb3cd5289c89dd0aa" translate="yes" xml:space="preserve">
          <source>Forward range primitive.</source>
          <target state="translated">前期范围基元。</target>
        </trans-unit>
        <trans-unit id="f29ecd0a8c2e85a8dd0a05e6e1849d59d6e26721" translate="yes" xml:space="preserve">
          <source>Forward range primitives.</source>
          <target state="translated">远期范围基元。</target>
        </trans-unit>
        <trans-unit id="0aa520a29c82bb14e915d25c13dc5e309db9aa45" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Always present.</source>
          <target state="translated">远期范围基元。始终存在。</target>
        </trans-unit>
        <trans-unit id="d22e131c3ac191040ab33d51c37ffdb89ec4f5bd" translate="yes" xml:space="preserve">
          <source>Forward range primitives. Only present if &lt;code&gt;Source&lt;/code&gt; is a forward range.</source>
          <target state="translated">正向范围原语。仅在 &lt;code&gt;Source&lt;/code&gt; 为正向范围时才存在。</target>
        </trans-unit>
        <trans-unit id="97bc99924d633226857a96f6afec14fc043cb16b" translate="yes" xml:space="preserve">
          <source>Forward range to check for sortedness.</source>
          <target state="translated">前进范围检查排序。</target>
        </trans-unit>
        <trans-unit id="7657ababded98f92f21842f17fb3c2a8cd28a85d" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().back&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;opSlice().back&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f670785452e24c08e6662a674722599db21dae68" translate="yes" xml:space="preserve">
          <source>Forward to &lt;code&gt;opSlice().front&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;opSlice().front&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="406d6f916ef4dc2cf86b7e71d06ceb89e750f775" translate="yes" xml:space="preserve">
          <source>Forward.</source>
          <target state="translated">Forward.</target>
        </trans-unit>
        <trans-unit id="619c49003b4924854c54d8f88890d01e742d1cdb" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;back&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;back&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef30f2488fc02c13b78587f98f5f66b1ed09c755" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;choices&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;choices&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="073a409c0a0f8fb805007ded8e0840b82337c88e" translate="yes" xml:space="preserve">
          <source>ForwardRange &lt;code&gt;filler&lt;/code&gt;</source>
          <target state="translated">ForwardRange &lt;code&gt;filler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d735aafe3953821674bcc047eed0a464f448083f" translate="yes" xml:space="preserve">
          <source>Forwarding</source>
          <target state="translated">Forwarding</target>
        </trans-unit>
        <trans-unit id="59753dcda35fa8785a7cb0df7205b2d4bd41fb72" translate="yes" xml:space="preserve">
          <source>Forwarding ScopeDsymbol. Used by ForwardingAttribDeclaration and ForwardingScopeDeclaration to forward symbol insertions to another scope. See &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; for more details.</source>
          <target state="translated">转发ScopeDsymbol。由ForwardingAttribDeclaration和ForwardingScopeDeclaration用来将符号插入转发到另一个作用域。有关更多详细信息，请参见 &lt;code&gt;dmd.attrib.ForwardingAttribDeclaration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8c3c38ee76d4f3b54240c75f491818942150299" translate="yes" xml:space="preserve">
          <source>ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt;;</source>
          <target state="translated">ForwardingScopeDsymbol &lt;strong id=&quot;sym&quot;&gt;sym&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="350d94101794444e552e24c257a1f22a4fbe99df" translate="yes" xml:space="preserve">
          <source>ForwardingStatements are distributed over the flattened sequence of statements. This prevents flattening to be &quot;blocked&quot; by a ForwardingStatement and is necessary, for example, to support generating scope guards with `static foreach`:</source>
          <target state="translated">ForwardingStatements分布在扁平化的语句序列上。这可以防止扁平化被ForwardingStatement &quot;阻挡&quot;,并且是必要的,例如,支持用 &quot;static foreach &quot;生成作用域守护。</target>
        </trans-unit>
        <trans-unit id="692658a69283f7fb6a21aa51f11e5d6d2994d5d3" translate="yes" xml:space="preserve">
          <source>Forwards &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">转发 &lt;code&gt;length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5654a0e021e96bad526eccdeb7cb0d25a7be5435" translate="yes" xml:space="preserve">
          <source>Forwards each of the methods in &lt;code&gt;funs&lt;/code&gt; (if defined) to &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;funs&lt;/code&gt; 每个方法（如果已定义）转发给 &lt;code&gt;member&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e165afdb83bce78d5a7427c72318f24d46092f4d" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while keeping &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, and &lt;code&gt;lazy&lt;/code&gt; on the parameters.</source>
          <target state="translated">转发函数参数，同时对参数保持 &lt;code&gt;out&lt;/code&gt; ， &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;lazy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9385c6728b753fbb370a1c4f1034c150548b8bf1" translate="yes" xml:space="preserve">
          <source>Forwards function arguments while saving ref-ness.</source>
          <target state="translated">转发函数参数,同时保存参考文献。</target>
        </trans-unit>
        <trans-unit id="9bf1ea57d6c29870d04450f92da2598f5a795126" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;alignedAllocate(bytes, platformAlignment)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78d71ac4fe9046b06039c1f36978f900fc90d21" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt;. Should be used with blocks obtained with &lt;code&gt;allocate&lt;/code&gt; otherwise the custom alignment passed with &lt;code&gt;alignedAllocate&lt;/code&gt; can be lost.</source>
          <target state="translated">转发到 &lt;code&gt;alignedReallocate(b, newSize, platformAlignment)&lt;/code&gt; 。应与获得的块被用于 &lt;code&gt;allocate&lt;/code&gt; 以其他方式与通过了自定义对准 &lt;code&gt;alignedAllocate&lt;/code&gt; 可能会丢失。</target>
        </trans-unit>
        <trans-unit id="d788f6c07eb5fb2e6319214dbdc4af6789c0f502" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.alignedReallocate&lt;/code&gt; if defined, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果已定义，则转发到 &lt;code&gt;impl.alignedReallocate&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bd9cee5dc99654ad10a48eac7f3712c848d2492" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;impl.empty()&lt;/code&gt; if defined, otherwise returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;impl.empty()&lt;/code&gt; (如果已定义），否则返回 &lt;code&gt;Ternary.unknown&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acf2453169c3a58c2868738f1fc21eb777d091c4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;insertBack&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;insertBack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60a899e29a86abcd90907c95435a5280010cfeb4" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.alignedAllocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAlignedAllocate&lt;/code&gt;, &lt;code&gt;numAlignedAllocateOk&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;parent.alignedAllocate&lt;/code&gt; 。每个实例的影响： &lt;code&gt;numAlignedAllocate&lt;/code&gt; ， &lt;code&gt;bytesUsed&lt;/code&gt; ， &lt;code&gt;bytesAllocated&lt;/code&gt; ， &lt;code&gt;bytesSlack&lt;/code&gt; ， &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; 和 &lt;code&gt;bytesHighTide&lt;/code&gt; 。每次调用的影响： &lt;code&gt;numAlignedAllocate&lt;/code&gt; ， &lt;code&gt;numAlignedAllocateOk&lt;/code&gt; 和 &lt;code&gt;bytesAllocated&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de51b91db75956f253cd2e990aebff215db91a5" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.allocate&lt;/code&gt;. Affects per instance: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt;bytesUsed&lt;/code&gt;, &lt;code&gt;bytesAllocated&lt;/code&gt;, &lt;code&gt;bytesSlack&lt;/code&gt;, &lt;code&gt;numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesHighTide&lt;/code&gt;. Affects per call: &lt;code&gt;numAllocate&lt;/code&gt;, &lt;code&gt; numAllocateOK&lt;/code&gt;, and &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;parent.allocate&lt;/code&gt; 。每个实例的影响： &lt;code&gt;numAllocate&lt;/code&gt; ， &lt;code&gt;bytesUsed&lt;/code&gt; ， &lt;code&gt;bytesAllocated&lt;/code&gt; ， &lt;code&gt;bytesSlack&lt;/code&gt; ， &lt;code&gt;numAllocateOK&lt;/code&gt; 和 &lt;code&gt;bytesHighTide&lt;/code&gt; 。每次调用的影响： &lt;code&gt;numAllocate&lt;/code&gt; ， &lt;code&gt; numAllocateOK&lt;/code&gt; 和 &lt;code&gt;bytesAllocated&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcaf3b31885140c27644f437101ba9113ddebba0" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.expand(b, delta)&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;parent.expand(b, delta)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b27aa4f3be329203334bb86f539151cb305c808b" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.goodAllocSize&lt;/code&gt; (which accounts for the management overhead).</source>
          <target state="translated">转发到 &lt;code&gt;parent.goodAllocSize&lt;/code&gt; （这占管理开销）。</target>
        </trans-unit>
        <trans-unit id="0a8e660798dc338a8a1471f38403abdf431c688a" translate="yes" xml:space="preserve">
          <source>Forwards to &lt;code&gt;parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">转发到 &lt;code&gt;parent.owns(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c49defce19fbb5c360ddd5f8418442bee4a9e756" translate="yes" xml:space="preserve">
          <source>Found function if it satisfies &lt;code&gt;isThis()&lt;/code&gt;, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">如果满足 &lt;code&gt;isThis()&lt;/code&gt; 的找到的函数，否则为 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5b2644294a615403e1d25df5a0697b50b1f11f" translate="yes" xml:space="preserve">
          <source>Fractional seconds past the second (i.e. the portion of a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; which is less than a second).</source>
          <target state="translated">秒后的小数秒（即，&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的一部分小于一秒）。</target>
        </trans-unit>
        <trans-unit id="379f2457e03cb11d9fb2efb285637d5db4d20d0e" translate="yes" xml:space="preserve">
          <source>Framework Paths</source>
          <target state="translated">框架路径</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="76f3bbf403c0a1d06091b2e954aa5148b52956ac" translate="yes" xml:space="preserve">
          <source>Free ExceptionHeader that was created by create().</source>
          <target state="translated">释放由create()创建的ExceptionHeader。</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">数据库连接使用的自由内存</target>
        </trans-unit>
        <trans-unit id="ebc0d55c1803ae64cbd97a59b9b2802ad68ac4a1" translate="yes" xml:space="preserve">
          <source>Free a data definition struct.</source>
          <target state="translated">释放一个数据定义结构。</target>
        </trans-unit>
        <trans-unit id="b863a7908826b1af85e7908ab51bda44bf1ecda4" translate="yes" xml:space="preserve">
          <source>Free a multipart formpost previously built with curl_formadd().</source>
          <target state="translated">释放一个之前用curl_formadd()构建的多部分formpost。</target>
        </trans-unit>
        <trans-unit id="3195ad8b795496334c672bd13584f65569ba68b7" translate="yes" xml:space="preserve">
          <source>Free a prior allocation</source>
          <target state="translated">解除先前的拨款</target>
        </trans-unit>
        <trans-unit id="b1f545998e095b9a06b4728df726ebf0dad217f2" translate="yes" xml:space="preserve">
          <source>Free blocks have variable size and are linked in a singly-linked list.</source>
          <target state="translated">自由区块的大小不一,并以单个链接的列表方式进行链接。</target>
        </trans-unit>
        <trans-unit id="2e8b5134a1b2ec3e5e93b6a487571bc8ad9bf630" translate="yes" xml:space="preserve">
          <source>Free free list.</source>
          <target state="translated">嶈单。</target>
        </trans-unit>
        <trans-unit id="0917613170fb85672a58086626671da808078654" translate="yes" xml:space="preserve">
          <source>Free idxStr using sqlite3_free() if true</source>
          <target state="translated">如果为真,则使用sqlite3_free()释放idxStr。</target>
        </trans-unit>
        <trans-unit id="98a1ae48a4466ad89a88d462e43c40189625122d" translate="yes" xml:space="preserve">
          <source>Free list built on top of exactly one contiguous block of memory. The block is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;, and is released in &lt;code&gt;ContiguousFreeList&lt;/code&gt;'s destructor (unless &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;code&gt;NullAllocator&lt;/code&gt;).</source>
          <target state="translated">空闲列表建立在一个连续的内存块之上。假设该块已与分配 &lt;code&gt;ParentAllocator&lt;/code&gt; ，并在被释放 &lt;code&gt;ContiguousFreeList&lt;/code&gt; 的析构函数（除非 &lt;code&gt;ParentAllocator&lt;/code&gt; 是 &lt;code&gt;NullAllocator&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="10d99eecb5370b60ca034187daa4ef1e45d53646" translate="yes" xml:space="preserve">
          <source>Free list.</source>
          <target state="translated">免费名单。</target>
        </trans-unit>
        <trans-unit id="56d7e4661565975bfba4769fa7e3d64507696d05" translate="yes" xml:space="preserve">
          <source>Free memory allocated by FileName routines</source>
          <target state="translated">由FileName例程分配的自由内存</target>
        </trans-unit>
        <trans-unit id="f7c1a4f30544ddc6377c5a280a73f14897416990" translate="yes" xml:space="preserve">
          <source>Free returned value with FileName::free()</source>
          <target state="translated">用FileName::free()释放返回值。</target>
        </trans-unit>
        <trans-unit id="3b18d56d2ee33e5deee0527f6a5620f9d07c8560" translate="yes" xml:space="preserve">
          <source>Free-form syntax, ignores whitespace in pattern, useful for formatting complex regular expressions.</source>
          <target state="translated">自由格式语法,忽略模式中的空白,对于格式化复杂的正则表达式很有用。</target>
        </trans-unit>
        <trans-unit id="b845fdaff1bf49c014dff506cfa6bdc63dadd835" translate="yes" xml:space="preserve">
          <source>FreeBSD</source>
          <target state="translated">FreeBSD</target>
        </trans-unit>
        <trans-unit id="927e12a7e999b3e0f18d3a882968560f012cc81f" translate="yes" xml:space="preserve">
          <source>FreeBSD-Only</source>
          <target state="translated">FreeBSD-Only</target>
        </trans-unit>
        <trans-unit id="736e4cd346eb715c4446b514550578d814d7d0e0" translate="yes" xml:space="preserve">
          <source>FreeBSD/DragonFlyBSD are the only systems which specifically have a clock set up for this (it has &lt;code&gt;CLOCK_SECOND&lt;/code&gt; to use with &lt;code&gt;clock_gettime&lt;/code&gt; which takes advantage of an in-kernel cached value), but on other systems, the fastest function available will be used, and the resulting &lt;code&gt;SysTime&lt;/code&gt; will be rounded down to the second if the clock that was used gave the time at a more precise resolution. So, it's guaranteed that the time will be given at a precision of one second and it's likely the case that will be faster than &lt;code&gt;ClockType.normal&lt;/code&gt;, since there tend to be several options on a system to get the time at low resolutions, and they tend to be faster than getting the time at high resolutions.</source>
          <target state="translated">FreeBSD / DragonFlyBSD是仅有的为此专门设置了时钟的系统（它具有 &lt;code&gt;CLOCK_SECOND&lt;/code&gt; 和 &lt;code&gt;clock_gettime&lt;/code&gt; 一起使用，这利用了内核缓存的值），但是在其他系统上，将使用最快的可用功能，并且如果使用的时钟以更精确的分辨率提供时间，则生成的 &lt;code&gt;SysTime&lt;/code&gt; 将四舍五入到第二秒。因此，可以保证时间的精确度为一秒，并且这种情况可能会比 &lt;code&gt;ClockType.normal&lt;/code&gt; 的速度更快，因为系统上倾向于使用多个选项以低分辨率获取时间，并且往往比获得高分辨率时要快。</target>
        </trans-unit>
        <trans-unit id="a9cdca34912cf1be0977006662f6f41677329f87" translate="yes" xml:space="preserve">
          <source>FreeList shared across threads. Allocation and deallocation are lock-free. The parameters have the same semantics as for &lt;code&gt;FreeList&lt;/code&gt;.</source>
          <target state="translated">FreeList跨线程共享。分配和解除分配是无锁的。参数具有与 &lt;code&gt;FreeList&lt;/code&gt; 相同的语义。</target>
        </trans-unit>
        <trans-unit id="ebdbf1c9047d64cde03eaed8b92301afb24c8b3e" translate="yes" xml:space="preserve">
          <source>Freeing all GC allocated memory that has no active pointers to it and do not need destructors to run.</source>
          <target state="translated">释放所有GC分配的内存,这些内存没有活动指针,不需要destructor来运行。</target>
        </trans-unit>
        <trans-unit id="9c1d262fbf3a7e284bb2c20e67267943ef09c825" translate="yes" xml:space="preserve">
          <source>Freeing any remaining unreachable memory.</source>
          <target state="translated">释放任何剩余的无法到达的内存。</target>
        </trans-unit>
        <trans-unit id="b1843177cd4be06555f8650438e2f5cee23b6d7c" translate="yes" xml:space="preserve">
          <source>Frees the memory allocated for &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is a reference to a class or interface, the memory allocated for the underlying instance is freed. If &lt;code&gt;x&lt;/code&gt; is a pointer, the memory allocated for the pointed-to object is freed. If &lt;code&gt;x&lt;/code&gt; is a built-in array, the memory allocated for the array is freed. If &lt;code&gt;x&lt;/code&gt; does not refer to memory previously allocated with &lt;code&gt;new&lt;/code&gt; (or the lower-level equivalents in the GC API), the behavior is undefined.</source>
          <target state="translated">释放分配给 &lt;code&gt;x&lt;/code&gt; 的内存。如果 &lt;code&gt;x&lt;/code&gt; 是对类或接口的引用，则释放为基础实例分配的内存。如果 &lt;code&gt;x&lt;/code&gt; 是指针，则释放分配给指向对象的内存。如果 &lt;code&gt;x&lt;/code&gt; 是内置数组，则释放为该数组分配的内存。如果 &lt;code&gt;x&lt;/code&gt; 不引用先前分配有 &lt;code&gt;new&lt;/code&gt; 内存的内存（或GC API中的较低等价内存），则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="306cb21df3375fca60d15a5cf9f358aab2a447e3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db2022114f51428d23663985d9512c4f397b106d" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#FracSec&quot;&gt;&lt;code&gt;FracSec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;#FracSec&quot;&gt; &lt;code&gt;FracSec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dcadc69133dc56548eb2198fe024d580cc53763" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;#TickDuration&quot;&gt;&lt;code&gt;TickDuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;#TickDuration&quot;&gt; &lt;code&gt;TickDuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e8638502dca540c07f22be8e25e01957c58dc0f" translate="yes" xml:space="preserve">
          <source>From a postblit perspective, qualifiying the struct definition yields the same result as explicitly qualifying the postblit.</source>
          <target state="translated">从后缀的角度来看,限定结构定义与显式限定后缀的结果是一样的。</target>
        </trans-unit>
        <trans-unit id="a4300cea6afd6c5c0528f1834abaff027668e0ed" translate="yes" xml:space="preserve">
          <source>From units</source>
          <target state="translated">从单位</target>
        </trans-unit>
        <trans-unit id="87b5b5d7f217c54f10b305679e84d27b0ffddee6" translate="yes" xml:space="preserve">
          <source>Front-end expression rewriting should create temporary variables for non trivial sub-expressions in order to: 1. save evaluation order 2. prevent sharing of sub-expression in AST</source>
          <target state="translated">前端表达式重写应该为非琐碎的子表达式创建临时变量,以便。1.节省计算顺序 2.防止AST中子表达式的共享。</target>
        </trans-unit>
        <trans-unit id="d866f093f3136af5a6cee1f9313a0fdd24da6c23" translate="yes" xml:space="preserve">
          <source>FrontTransversal!(RangeOfRanges, opt) &lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr);</source>
          <target state="translated">FrontTransversal！（RangeOfRanges，opt）&lt;strong id=&quot;frontTransversal&quot;&gt;frontTransversal&lt;/strong&gt;（TransverseOptions opt = TransverseOptions.assumeJagged，RangeOfRanges）（RangeOfRanges rr）;</target>
        </trans-unit>
        <trans-unit id="b96493999dfb84df4fdc104ae8dc68c5ab28eeb6" translate="yes" xml:space="preserve">
          <source>Full Usage Example</source>
          <target state="translated">完整使用范例</target>
        </trans-unit>
        <trans-unit id="dd2159a885b04c76ad21acb9e9df96e1b3df4a78" translate="yes" xml:space="preserve">
          <source>Full content of the file to be written</source>
          <target state="translated">要写的文件的全部内容</target>
        </trans-unit>
        <trans-unit id="890fb87ee1e5cddd39317993afd9de0de79b7d45" translate="yes" xml:space="preserve">
          <source>Full metaprogramming facilities</source>
          <target state="translated">完整的元编程设施</target>
        </trans-unit>
        <trans-unit id="0c7ebd23a12a9077c88a3e9d528a97811a94a547" translate="yes" xml:space="preserve">
          <source>Fully sequenced (acquire + release). Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">完全排序（获取+释放）。对应于&lt;a href=&quot;https://llvm.org/docs/Atomics.html#sequentiallyconsistent&quot;&gt;LLVM AtomicOrdering.SequentiallyConsistent&lt;/a&gt;和C ++ 11 / C11 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="244c67389fed3259f84c95197cc9eb3648ddcb0d" translate="yes" xml:space="preserve">
          <source>Fully working example is available at &lt;a href=&quot;#usage-example&quot;&gt;the bottom&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#usage-example&quot;&gt;底部&lt;/a&gt;提供了完整的工作示例。</target>
        </trans-unit>
        <trans-unit id="d32cb0b70d83396fe47823d8472eaa9476a37437" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;f&lt;/code&gt;</source>
          <target state="translated">函数声明 &lt;code&gt;f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46c96c463b9529c91720bbc72354f9466bd3c26f" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fd&lt;/code&gt;</source>
          <target state="translated">FuncDeclaration &lt;code&gt;fd&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fd968926da674858b925b704767caf618b18035" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;fdc&lt;/code&gt;</source>
          <target state="translated">功能声明 &lt;code&gt;fdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e24cae0141215bceece007770b580c50fd2f38" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;code&gt;func&lt;/code&gt;</source>
          <target state="translated">FuncDeclaration &lt;code&gt;func&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f3b288cb44551e47fdefb27fe0ea167fb4d1483" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildInv&quot;&gt;buildInv&lt;/strong&gt;（AggregateDeclaration广告，范围* sc）；</target>
        </trans-unit>
        <trans-unit id="2e19843cd5ed176434a3efaeff7d8bda7426dc57" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpAssign&quot;&gt;buildOpAssign&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="03359c276bccc50045b57bc8ace08bc6d8f2ae59" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildOpEquals&quot;&gt;buildOpEquals&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="507d5c363210e3f23b2c42085b0c0ff39e10c2cc" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopCmp&quot;&gt;buildXopCmp&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="859ef670635a842eaebad8ac23f82e95392d9e8c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXopEquals&quot;&gt;buildXopEquals&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="dc070bb95306fb1a92b40edce98353f4664181ad" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt;(StructDeclaration sd, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;buildXtoHash&quot;&gt;buildXtoHash&lt;/strong&gt;（StructDeclaration sd，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="a30ba00bb5d45e8e8a6da89f6ff22fb9cbecb606" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt;(TemplateInstance ti, Scope* sc2, FuncDeclaration fd, Type tthis, Expressions* fargs);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;doHeaderInstantiation&quot;&gt;doHeaderInstantiation&lt;/strong&gt;（TemplateInstance ti，Scope * sc2，FuncDeclaration fd，Type tthis，Expressions * fargs）;</target>
        </trans-unit>
        <trans-unit id="d05a566062ec8864bd0d4c9e283c124ce8c44dfa" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdensure&quot;&gt;fdensure&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;fdensure&quot;&gt;缺陷&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e42a220d72031c5ac346bcdb8b0d4dc5655921c" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;fdrequire&quot;&gt;fdrequire&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d75bdbbe19a26e762aba1b2f76a15fde383c64a0" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt;(AggregateDeclaration ad, Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;hasIdentityOpAssign&quot;&gt;hasIdentityOpAssign&lt;/strong&gt;（AggregateDeclaration广告，范围* sc）；</target>
        </trans-unit>
        <trans-unit id="fb1ead50f11e27697b705598972fc6d1ffead188" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;hasThis&quot;&gt;hasThis&lt;/strong&gt;(Scope* sc);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;hasThis&quot;&gt;hasThis&lt;/strong&gt;（Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="9c8e5d63f59418c4c2add44a220d39f8eb8d7843" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;overnext0&quot;&gt;overnext0&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e92604a27d4e8a86aead189ab657e429f7804d91" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt;(ref const Loc loc, Scope* sc, Dsymbol s, Objects* tiargs, Type tthis, Expressions* fargs, FuncResolveFlag flags);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;resolveFuncCall&quot;&gt;resolveFuncCall&lt;/strong&gt;（ref const Loc loc，Scope * sc，Dsymbol s，Objects * tiargs，tthis类型，Expressions * fargs，FuncResolveFlag标志）;</target>
        </trans-unit>
        <trans-unit id="6bc7f2dda0d8c4f33d8fa77e2a6866f9c3e063da" translate="yes" xml:space="preserve">
          <source>FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt;(StructDeclaration sd);</source>
          <target state="translated">FuncDeclaration &lt;strong id=&quot;search_toString&quot;&gt;search_toString&lt;/strong&gt;（StructDeclaration sd）;</target>
        </trans-unit>
        <trans-unit id="d2f8d9014611a673032f33ed2918b0db3cbea6e7" translate="yes" xml:space="preserve">
          <source>FuncDeclaration of &lt;code&gt;toString()&lt;/code&gt; if found, &lt;code&gt;null&lt;/code&gt; if not</source>
          <target state="translated">的FuncDeclaration &lt;code&gt;toString()&lt;/code&gt; 如果找到， &lt;code&gt;null&lt;/code&gt; 如果不</target>
        </trans-unit>
        <trans-unit id="0de7865b78f78b6942752a1607fa8f3decdf8f8b" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;foverrides&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;foverrides&quot;&gt;泛滥&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cefac5fb4c4f6f7aad7982a9de7b94425bbd152a" translate="yes" xml:space="preserve">
          <source>FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt;;</source>
          <target state="translated">FuncDeclarations &lt;strong id=&quot;siblingCallers&quot;&gt;siblingCallers&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1147d19864a2f24679061fb745f4f2745312dc4d" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l1&lt;/code&gt;</source>
          <target state="translated">FuncLiteralDeclaration &lt;code&gt;l1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34754aacf81ddb7c1a4c8be9c611413058146f76" translate="yes" xml:space="preserve">
          <source>FuncLiteralDeclaration &lt;code&gt;l2&lt;/code&gt;</source>
          <target state="translated">FuncLiteralDeclaration &lt;code&gt;l2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0df7e78750c597d40962880c788feb5d42d0507c" translate="yes" xml:space="preserve">
          <source>FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</source>
          <target state="translated">FuncResolveFlag &lt;code&gt;flags&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d148d41b57da4467de12a195094eac776bca54d" translate="yes" xml:space="preserve">
          <source>Function Attribute Inference</source>
          <target state="translated">函数属性推断</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">功能辅助数据</target>
        </trans-unit>
        <trans-unit id="7cb4de12c910c8d000862c6b8806ba33b405085e" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading</source>
          <target state="translated">功能调用操作者重载</target>
        </trans-unit>
        <trans-unit id="b257168e280b545833c00a892f5a9654498e1038" translate="yes" xml:space="preserve">
          <source>Function Call Operator Overloading &lt;code&gt;f()&lt;/code&gt;</source>
          <target state="translated">函数调用运算符重载 &lt;code&gt;f()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="287c317aff3ca62b6d115ccce3c3993c93d19bb1" translate="yes" xml:space="preserve">
          <source>Function Calling Conventions</source>
          <target state="translated">函数调用约定</target>
        </trans-unit>
        <trans-unit id="897aa7901cb2b135a5d5c44d09b74d23db3807ca" translate="yes" xml:space="preserve">
          <source>Function Default Arguments</source>
          <target state="translated">函数默认参数</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">功能标志</target>
        </trans-unit>
        <trans-unit id="d8861f5c13214753c72cc4ec28a42da4d33141ab" translate="yes" xml:space="preserve">
          <source>Function Inheritance and Overriding</source>
          <target state="translated">函数继承和覆盖</target>
        </trans-unit>
        <trans-unit id="5bcb901ef2c2acd0ad4fdd3aaa4dbd63df1c459e" translate="yes" xml:space="preserve">
          <source>Function Literals</source>
          <target state="translated">功能文字</target>
        </trans-unit>
        <trans-unit id="a9ab374cd6bd246bd36d7f40fb0af05f53c4d5a7" translate="yes" xml:space="preserve">
          <source>Function Name</source>
          <target state="translated">功能名称</target>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="translated">功能重载</target>
        </trans-unit>
        <trans-unit id="cec90ffa8d067cfb33c2b7e5ea59f57a4ab51f07" translate="yes" xml:space="preserve">
          <source>Function Parameters</source>
          <target state="translated">功能参数</target>
        </trans-unit>
        <trans-unit id="27e4c7203c9643477f2a066182da530038d7af91" translate="yes" xml:space="preserve">
          <source>Function Return Values</source>
          <target state="translated">函数返回值</target>
        </trans-unit>
        <trans-unit id="564f4636a468d710ec718d52c0a86615388f886e" translate="yes" xml:space="preserve">
          <source>Function Safety</source>
          <target state="translated">功能安全</target>
        </trans-unit>
        <trans-unit id="89ef743a3244fbdb65d0570367a96fdb2440073a" translate="yes" xml:space="preserve">
          <source>Function Templates</source>
          <target state="translated">功能模板</target>
        </trans-unit>
        <trans-unit id="26851646d4034fb238c1b8a8d1cbdf65764b94ab" translate="yes" xml:space="preserve">
          <source>Function Templates with Auto Ref Parameters</source>
          <target state="translated">带有自动参考参数的功能模板</target>
        </trans-unit>
        <trans-unit id="2a828a2f47a94f98e25eacb43fb34ce3a0a927e6" translate="yes" xml:space="preserve">
          <source>Function argument initializes a &lt;code&gt;return&lt;/code&gt; parameter, and that parameter gets assigned to &lt;code&gt;firstArg&lt;/code&gt;. Essentially, treat as &lt;code&gt;firstArg = arg;&lt;/code&gt;</source>
          <target state="translated">Function参数初始化一个 &lt;code&gt;return&lt;/code&gt; 参数，然后将该参数分配给 &lt;code&gt;firstArg&lt;/code&gt; 。本质上，将其视为 &lt;code&gt;firstArg = arg;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87a4aa72b8e4acaa8f362e2eba871dd25b95962b" translate="yes" xml:space="preserve">
          <source>Function attributes</source>
          <target state="translated">功能属性</target>
        </trans-unit>
        <trans-unit id="a3518d2ba96341cb705a0844010da23ec63c4f60" translate="yes" xml:space="preserve">
          <source>Function attributes are emitted in the order as listed above.</source>
          <target state="translated">功能属性按上述顺序发出。</target>
        </trans-unit>
        <trans-unit id="090cdc3abee08672ecc88627488c127b4dd88e47" translate="yes" xml:space="preserve">
          <source>Function bodies cannot be empty:</source>
          <target state="translated">功能体不能为空。</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">职能机构</target>
        </trans-unit>
        <trans-unit id="daa6044eeb443eca769ad767c0b819da1d93de92" translate="yes" xml:space="preserve">
          <source>Function calls to these are generated by the compiler and inserted into the object code.</source>
          <target state="translated">对这些函数的调用由编译器生成并插入到对象代码中。</target>
        </trans-unit>
        <trans-unit id="dcd2bd5d9c9b442091f087f1d3ab7d165c7a6f01" translate="yes" xml:space="preserve">
          <source>Function contracts</source>
          <target state="translated">职能合同</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">功能声明</target>
        </trans-unit>
        <trans-unit id="60f82695f39f080d8446d9390fdbf10f4625d827" translate="yes" xml:space="preserve">
          <source>Function declarations annotated with the &lt;code&gt;@live&lt;/code&gt; attribute are checked for compliance with the Ownership/Borrowing rules. The checks are run after other semantic processing is complete. The checking does not influence code generation.</source>
          <target state="translated">检查使用 &lt;code&gt;@live&lt;/code&gt; 属性注释的函数声明是否符合所有权/借用规则。在其他语义处理完成后运行检查。该检查不影响代码生成。</target>
        </trans-unit>
        <trans-unit id="dd0e134160bc0255e9ac645522671a4ceac9664b" translate="yes" xml:space="preserve">
          <source>Function for starting to a stop watch time when the function is called and stopping it when its return value goes out of scope and is destroyed.</source>
          <target state="translated">用于在调用函数时开始到停止手表时间,并在其返回值超出范围并被销毁时停止的函数。</target>
        </trans-unit>
        <trans-unit id="aae2ba6220f8db51d41c8edbd64b6b01f43243fd" translate="yes" xml:space="preserve">
          <source>Function is a C-style variadic function, which uses &lt;code&gt;core.stdc.stdarg&lt;/code&gt;</source>
          <target state="translated">函数是C风格的可变参数函数，它使用 &lt;code&gt;core.stdc.stdarg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87d2f358ca186efbcb568c16e606003520afa9cd" translate="yes" xml:space="preserve">
          <source>Function is a D-style variadic function, which uses &lt;code&gt;__argptr&lt;/code&gt; and &lt;code&gt;__arguments&lt;/code&gt;.</source>
          <target state="translated">函数是D风格的可变参数函数，它使用 &lt;code&gt;__argptr&lt;/code&gt; 和 &lt;code&gt;__arguments&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3435b54d43e95cebfb7003ed401ba2d6c58be33" translate="yes" xml:space="preserve">
          <source>Function is a typesafe variadic function.</source>
          <target state="translated">Function是一个类型安全的变量函数。</target>
        </trans-unit>
        <trans-unit id="02eaa479f3aca73ffbcbe24d76bdcbcb5f2a00b8" translate="yes" xml:space="preserve">
          <source>Function is not variadic.</source>
          <target state="translated">功能不是变化的。</target>
        </trans-unit>
        <trans-unit id="f04ac1afcdca4559aaa061f6f7593d6d3478e357" translate="yes" xml:space="preserve">
          <source>Function parameter &lt;code&gt;par&lt;/code&gt; is being initialized to &lt;code&gt;arg&lt;/code&gt;, and &lt;code&gt;par&lt;/code&gt; may escape. Detect if scoped values can escape this way. Print error messages when these are detected.</source>
          <target state="translated">函数参数 &lt;code&gt;par&lt;/code&gt; 被初始化为 &lt;code&gt;arg&lt;/code&gt; ，而 &lt;code&gt;par&lt;/code&gt; 可能会逸出。检测范围值是否可以通过这种方式逃脱。检测到错误消息时将其打印出来。</target>
        </trans-unit>
        <trans-unit id="3029155acb4ac5fc232abd3463c11350cc2d960a" translate="yes" xml:space="preserve">
          <source>Function parameter declarations can have default values:</source>
          <target state="translated">函数参数声明可以有默认值。</target>
        </trans-unit>
        <trans-unit id="f6a6b4c753629a0ad23be9a19a0def5754916cb7" translate="yes" xml:space="preserve">
          <source>Function parameters can be documented by listing them in a params section. Each line that starts with an identifier followed by an '=' starts a new parameter description. A description can span multiple lines.</source>
          <target state="translated">函数参数可以通过在params部分列出它们来记录。每一行以标识符开头,后面跟着一个'=',开始一个新的参数描述。一个描述可以跨越多行。</target>
        </trans-unit>
        <trans-unit id="6678c5d32e09052e0172ebd3cea351dcf7ca2766" translate="yes" xml:space="preserve">
          <source>Function parameters: Pident identifier of parameter Ptype type of argument Pelem default value for argument Psym symbol corresponding to Pident when using the parameter list as a symbol table For template-parameter-list: Pident identifier of parameter Ptype if NULL, this is a type-parameter else the type for a parameter-declaration value argument Pelem default value for value argument Pdeftype default value for type-parameter Pptpl template-parameter-list for template-template-parameter Psym default value for template-template-parameter For template-arg-list: (actual arguments) Pident NULL Ptype type-name Pelem expression (either Ptype or Pelem is NULL) Psym SCtemplate for template-template-argument</source>
          <target state="translated">函数参数。参数的Pident标识符 Ptype参数的类型 Pelem参数的缺省值 当把参数列表作为符号表使用时,Pident对应的Psym符号 对于模板-参数列表。参数的Pident标识符 Ptype 如果为NULL,则为类型参数,否则为参数声明值参数的类型 Pelem 值参数的缺省值 Pdeftype 类型参数的缺省值 Pptpl template-parameter-list 为 template-template-parameter Psym 为 template-template-parameter 的缺省值 为 template-arg-list:(实际参数)Pident NULL Ptype type-name Pelem表达式(Ptype或Pelem均为NULL)Psym SCtemplate for template-template-argument.</target>
        </trans-unit>
        <trans-unit id="4e74811387b8309f2eba7069545da73ad882b5db" translate="yes" xml:space="preserve">
          <source>Function pointers can be passed to functions taking a delegate argument by passing them through the &lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt;&lt;code&gt;std.functional.toDelegate&lt;/code&gt;&lt;/a&gt; template, which converts any callable to a delegate without context.</source>
          <target state="translated">函数指针可以通过&lt;a href=&quot;https://dlang.org/phobos/std_functional.html#toDelegate&quot;&gt; &lt;code&gt;std.functional.toDelegate&lt;/code&gt; &lt;/a&gt;模板传递给带有委托参数的函数，该模板将任何可调用对象转换为没有上下文的委托。</target>
        </trans-unit>
        <trans-unit id="2f4d971f1b9568ee68d3c3afd0afa4bb0664e45b" translate="yes" xml:space="preserve">
          <source>Function results are returned from &lt;code&gt;yieldForce&lt;/code&gt;, &lt;code&gt;spinForce&lt;/code&gt; and &lt;code&gt;workForce&lt;/code&gt; by ref. If &lt;code&gt;fun&lt;/code&gt; returns by ref, the reference will point to the returned reference of &lt;code&gt;fun&lt;/code&gt;. Otherwise it will point to a field in this struct.</source>
          <target state="translated">函数结果由ref 从 &lt;code&gt;yieldForce&lt;/code&gt; ， &lt;code&gt;spinForce&lt;/code&gt; 和 &lt;code&gt;workForce&lt;/code&gt; 返回。如果 &lt;code&gt;fun&lt;/code&gt; 由ref返回，则引用将指向返回的 &lt;code&gt;fun&lt;/code&gt; 引用。否则它将指向此结构中的一个字段。</target>
        </trans-unit>
        <trans-unit id="c3097f849806cf699273164feb8e2d0ccfb12c15" translate="yes" xml:space="preserve">
          <source>Function return values are considered to be rvalues. This means they cannot be passed by reference to other functions.</source>
          <target state="translated">函数的返回值被认为是r值,这意味着它们不能通过引用其他函数来传递。这意味着它们不能通过引用传递给其他函数。</target>
        </trans-unit>
        <trans-unit id="c7004e7f868eeb59bcb8e6e80ff83ca5a6d46adf" translate="yes" xml:space="preserve">
          <source>Function return values not marked as &lt;code&gt;ref&lt;/code&gt; are considered to be rvalues. This means they cannot be passed by reference to other functions.</source>
          <target state="translated">未标记为 &lt;code&gt;ref&lt;/code&gt; 的函数返回值被视为右值。这意味着它们不能通过引用传递给其他功能。</target>
        </trans-unit>
        <trans-unit id="828053ed1d877ebcde1ff06a5dea505b651e20d3" translate="yes" xml:space="preserve">
          <source>Function template type parameters that are to be implicitly deduced may not have specializations:</source>
          <target state="translated">要隐式推导的函数模板类型参数不得有特殊化。</target>
        </trans-unit>
        <trans-unit id="a7d00ef56bc1d2f06bd67eb8bc21de19e80c263d" translate="yes" xml:space="preserve">
          <source>Function templates can be explicitly instantiated with a !(</source>
          <target state="translated">函数模板可以用 !()显式实例化。</target>
        </trans-unit>
        <trans-unit id="3b8df2ef7fc72848cf8d0bce3a9220b3a898f0b1" translate="yes" xml:space="preserve">
          <source>Function templates can have their return types deduced based on the &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function, just as with normal functions. See &lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;Auto Functions&lt;/a&gt;.</source>
          <target state="translated">就像普通函数一样，可以根据函数中的&lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;推断函数模板的返回类型。请参阅&lt;a href=&quot;https://dlang.org/function.html#auto-functions&quot;&gt;自动功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55b6f95d2a2736a8bfaa71fcc12b1d0a3c85769f" translate="yes" xml:space="preserve">
          <source>Function that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">调用 &lt;code&gt;_d_HookTraceImpl&lt;/code&gt; 的函数</target>
        </trans-unit>
        <trans-unit id="8c7a2db7de16ccd53dc1b73193b31c814b7489e6" translate="yes" xml:space="preserve">
          <source>Function that does not take any parameters</source>
          <target state="translated">不接受任何参数的函数</target>
        </trans-unit>
        <trans-unit id="85ff978df4b7d827c80c5b427bf2c4db1e2ed45d" translate="yes" xml:space="preserve">
          <source>Function that will be called instead of the internal progress display function. This function should be defined as the curl_progress_callback prototype defines.</source>
          <target state="translated">代替内部进度显示函数被调用的函数。这个函数应该被定义为curl_progress_callback原型所定义的函数。</target>
        </trans-unit>
        <trans-unit id="23533f8923b79f1dc08d42a47fdcce75663a40c0" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from UTF8 (instead of using the iconv calls in libcurl) Note that this is used only for SSL certificate processing</source>
          <target state="translated">调用UTF8转换的函数(而不是使用libcurl中的iconv调用),注意这只用于SSL证书处理。</target>
        </trans-unit>
        <trans-unit id="9149aa5e3f56e9141da81bbd147711474255a324" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert from the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">调用该函数来转换网络编码(而不是使用libcurl中的iconv调用)。</target>
        </trans-unit>
        <trans-unit id="cffc93dc9124a77261edd44618001f6b42f32854" translate="yes" xml:space="preserve">
          <source>Function that will be called to convert to the network encoding (instead of using the iconv calls in libcurl)</source>
          <target state="translated">将被调用的函数,用于转换为网络编码(而不是使用libcurl中的iconv调用)。</target>
        </trans-unit>
        <trans-unit id="53a515cf174973bb65a87a5952e5c03252c9695d" translate="yes" xml:space="preserve">
          <source>Function that will be called to read the input (instead of fread). The parameters will use fread() syntax, make sure to follow them.</source>
          <target state="translated">将被调用来读取输入的函数(代替fread)。参数将使用fread()语法,请务必遵循它们。</target>
        </trans-unit>
        <trans-unit id="babcbdb82bd11f7164bb99107054b2a484fb1682" translate="yes" xml:space="preserve">
          <source>Function that will be called to store headers (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">将被调用来存储头文件的函数(代替fwrite)。参数将使用fwrite()语法,请务必遵循它们。</target>
        </trans-unit>
        <trans-unit id="233d456dba50e927381d10867821a9bfe1f04637" translate="yes" xml:space="preserve">
          <source>Function that will be called to store the output (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.</source>
          <target state="translated">将被调用来存储输出的函数(代替fwrite)。参数将使用fwrite()语法,请务必遵循它们。</target>
        </trans-unit>
        <trans-unit id="e221c711ff99df59e968c914d1979c6a0ad3ee61" translate="yes" xml:space="preserve">
          <source>Function to apply to each element of range</source>
          <target state="translated">适用于范围内每个元素的函数</target>
        </trans-unit>
        <trans-unit id="b844384b07c0f5d9caaa10fd46cb397be8c61ded" translate="yes" xml:space="preserve">
          <source>Function to be analyzed</source>
          <target state="translated">需要分析的功能</target>
        </trans-unit>
        <trans-unit id="b78a95743121775c17568fcabf9200b6a902bef0" translate="yes" xml:space="preserve">
          <source>Function to check, followed by a variadic number of function attributes as strings</source>
          <target state="translated">要检查的函数,后面的函数属性为字符串,数量不等。</target>
        </trans-unit>
        <trans-unit id="aefc954f08bca71e2e39ec093b9e23048430f8af" translate="yes" xml:space="preserve">
          <source>Function traits</source>
          <target state="translated">功能特点</target>
        </trans-unit>
        <trans-unit id="2e40e24355bdf1170d50a1d6ead524ba20679656" translate="yes" xml:space="preserve">
          <source>Function/Delegate literal</source>
          <target state="translated">功能/委托字面意思</target>
        </trans-unit>
        <trans-unit id="8ebd95c8f1ce3b6070bf21aaa16655aa94a89c6b" translate="yes" xml:space="preserve">
          <source>FunctionLiteral</source>
          <target state="translated">FunctionLiteral</target>
        </trans-unit>
        <trans-unit id="a3d450d75bfa53b89f98aa6dae8be36130018cbb" translate="yes" xml:space="preserve">
          <source>FunctionLiteralBody</source>
          <target state="translated">FunctionLiteralBody</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="a03b0f45370db4b978978138169257e95bfff4b6" translate="yes" xml:space="preserve">
          <source>Functionality for processing subsequent matches of global regexes via range interface:</source>
          <target state="translated">通过范围接口处理全局regex的后续匹配的功能。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5687015bfcd81aa78a69312ebd359e3273b183cc" translate="yes" xml:space="preserve">
          <source>Functions Without Bodies</source>
          <target state="translated">无体功能</target>
        </trans-unit>
        <trans-unit id="bba90169e567d9c68b308641b7cc0ffd3300695b" translate="yes" xml:space="preserve">
          <source>Functions and delegates declared at module scope are zero-initialized by default. However both can be initialized to any function pointer (including a function literal). For delegates, the context pointer &lt;code&gt;.ptr&lt;/code&gt; is initialized to null.</source>
          <target state="translated">默认情况下，在模块作用域声明的函数和委托为零初始化。但是，两者都可以初始化为任何函数指针（包括函数文字）。对于委托，上下文指针 &lt;code&gt;.ptr&lt;/code&gt; 初始化为null。</target>
        </trans-unit>
        <trans-unit id="b9443a12c52c106d6f6936a59aa4d60507110962" translate="yes" xml:space="preserve">
          <source>Functions and types that manipulate built-in arrays and associative arrays.</source>
          <target state="translated">操作内置数组和关联数组的函数和类型。</target>
        </trans-unit>
        <trans-unit id="1fcc64ae1b70c55efc217545c066c056d0513c2e" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interface with extern(C++) ABI.</source>
          <target state="translated">extern(C++)ABI接口的函数和变量。</target>
        </trans-unit>
        <trans-unit id="fd8851f8cc2c81bc5719fd2159093b00e7797298" translate="yes" xml:space="preserve">
          <source>Functions and variables specific to interfacing with extern(C) ABI.</source>
          <target state="translated">与extern(C)ABI接口的特定函数和变量。</target>
        </trans-unit>
        <trans-unit id="7f5a53c5e8af7e00f9774b9397648dd6e21fd328" translate="yes" xml:space="preserve">
          <source>Functions are never inlined.</source>
          <target state="translated">函数从不内联。</target>
        </trans-unit>
        <trans-unit id="4713c57b4dfbd0d2f4ef062d96b18f64a40c55bc" translate="yes" xml:space="preserve">
          <source>Functions are overloaded based on how well the arguments to a function can match up with the parameters. The function with the</source>
          <target state="translated">函数的重载是基于函数的参数与参数的匹配程度。函数的</target>
        </trans-unit>
        <trans-unit id="a7f661a74f02a377df2091c16fea97336e40806f" translate="yes" xml:space="preserve">
          <source>Functions as Array Properties</source>
          <target state="translated">函数作为阵列属性</target>
        </trans-unit>
        <trans-unit id="e47c1a27abfc73a2fed656e28cc0a5aa9ab7a938" translate="yes" xml:space="preserve">
          <source>Functions can also be declared as &lt;code&gt;ref&lt;/code&gt;, meaning their return value is passed by reference:</source>
          <target state="translated">函数也可以声明为 &lt;code&gt;ref&lt;/code&gt; ，这意味着它们的返回值由引用传递：</target>
        </trans-unit>
        <trans-unit id="fc9e94fc77751f7a520ef1950989f7a0e1c7828b" translate="yes" xml:space="preserve">
          <source>Functions can be nested within member functions:</source>
          <target state="translated">函数可以嵌套在成员函数中。</target>
        </trans-unit>
        <trans-unit id="7e69a10d10797495520ab6d16edfbd50e9742682" translate="yes" xml:space="preserve">
          <source>Functions declared at the same scope overload against each other, and are called an</source>
          <target state="translated">在同一作用域声明的函数相互重载,并被称为一个</target>
        </trans-unit>
        <trans-unit id="c566e2fda222bdb6e383ab5ff3c3433df764aa7f" translate="yes" xml:space="preserve">
          <source>Functions defined with non-D linkage cannot be overloaded. This is because the name mangling might not take the parameter types into account.</source>
          <target state="translated">用非D链接定义的函数不能被重载。这是因为名称混杂可能没有考虑到参数类型。</target>
        </trans-unit>
        <trans-unit id="988f1aa7ff1ca669378942571abfebb6288e682f" translate="yes" xml:space="preserve">
          <source>Functions executed via CTFE can give different results from run time in the following scenarios:</source>
          <target state="translated">在以下情况下,通过CTFE执行的函数在运行时可以得到不同的结果。</target>
        </trans-unit>
        <trans-unit id="419aab857f4bb8c6136ba89e91fb3714fd5cb75f" translate="yes" xml:space="preserve">
          <source>Functions for starting and interacting with other processes, and for working with the current process' execution environment.</source>
          <target state="translated">用于启动其他进程并与之交互,以及与当前进程的执行环境一起工作的功能。</target>
        </trans-unit>
        <trans-unit id="50b5e5b232695481bdd4d283f8038b839689e2f6" translate="yes" xml:space="preserve">
          <source>Functions marked as &lt;code&gt;final&lt;/code&gt; may not be overridden in a derived class, unless they are also &lt;code&gt;private&lt;/code&gt;. For example:</source>
          <target state="translated">标记为 &lt;code&gt;final&lt;/code&gt; 的功能不得在派生类中重写，除非它们也是 &lt;code&gt;private&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="c40c48a24043c849a46e19c95c7d6f6bb43d3af4" translate="yes" xml:space="preserve">
          <source>Functions may be nested within other functions:</source>
          <target state="translated">函数可以嵌套在其他函数中。</target>
        </trans-unit>
        <trans-unit id="ab842017af8570439bf6ba4b27c54b5312a024b2" translate="yes" xml:space="preserve">
          <source>Functions nested inside safe functions default to being safe functions.</source>
          <target state="translated">嵌套在安全函数内的函数默认为安全函数。</target>
        </trans-unit>
        <trans-unit id="e7c3eeba379274331a0b9c881db32559bea140a9" translate="yes" xml:space="preserve">
          <source>Functions taking a variable number of arguments are called variadic functions. A variadic function can take one of three forms:</source>
          <target state="translated">取一个可变参数数的函数称为变元函数。变量函数可以采取三种形式之一。</target>
        </trans-unit>
        <trans-unit id="2f8dcbed7cf260c12b9f8f40b2d592ffce349a24" translate="yes" xml:space="preserve">
          <source>Functions that deal with mutable, const, or immutable types with equanimity often need to transmit their type to the return value:</source>
          <target state="translated">以等价的方式处理可变型、const型或不可变型的函数通常需要将其类型传输到返回值。</target>
        </trans-unit>
        <trans-unit id="8cc0d5a6974c142e0e42bd69101ee5cdc41acf88" translate="yes" xml:space="preserve">
          <source>Functions that manipulate other functions.</source>
          <target state="translated">操纵其他函数的函数。</target>
        </trans-unit>
        <trans-unit id="d4e8675aa25a2bddb84bf8fd8b778e29fe3cf68c" translate="yes" xml:space="preserve">
          <source>Functions that meet these requirements may be &lt;a href=&quot;#safe-functions&quot;&gt;&lt;code&gt;@safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trusted-functions&quot;&gt;&lt;code&gt;@trusted&lt;/code&gt;&lt;/a&gt;. Function that do not meet these requirements can only be &lt;a href=&quot;#system-functions&quot;&gt;&lt;code&gt;@system&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">满足这些要求的功能可以是&lt;a href=&quot;#safe-functions&quot;&gt; &lt;code&gt;@safe&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#trusted-functions&quot;&gt; &lt;code&gt;@trusted&lt;/code&gt; &lt;/a&gt;。不满足这些要求的功能只能是&lt;a href=&quot;#system-functions&quot;&gt; &lt;code&gt;@system&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9283433eaa6818c4d57146ef0bb556e3d0ffc12f" translate="yes" xml:space="preserve">
          <source>Functions which are both portable and free of global side-effects can be executed at compile time. In certain contexts, such compile time execution is guaranteed. It is called Compile Time Function Execution (CTFE) then. The contexts that trigger CTFE are:</source>
          <target state="translated">既可移植又没有全局副作用的函数可以在编译时执行。在某些情况下,这种编译时执行是有保证的。那么,它被称为编译时函数执行(CTFE)。触发CTFE的上下文是:。</target>
        </trans-unit>
        <trans-unit id="670fb705837790471a38cafc20ec80fbf30c8bf6" translate="yes" xml:space="preserve">
          <source>Functions which operate on ASCII characters.</source>
          <target state="translated">对ASCII字符进行操作的函数。</target>
        </trans-unit>
        <trans-unit id="7c0d365cb94dab42778d857cad063abfc3d8f3b6" translate="yes" xml:space="preserve">
          <source>Functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage has an additional hidden, unnamed, parameter which is the selector it was called with.</source>
          <target state="translated">具有 &lt;code&gt;Objective-C&lt;/code&gt; 链接的函数还有一个额外的隐藏的，未命名的参数，它是调用它的选择器。</target>
        </trans-unit>
        <trans-unit id="2f12c7ced7f8f22b29fa0338695211d8c0538660" translate="yes" xml:space="preserve">
          <source>Functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage have an additional hidden, unnamed, parameter which is the selector it was called with.</source>
          <target state="translated">具有 &lt;code&gt;Objective-C&lt;/code&gt; 链接的函数还有一个额外的隐藏的，未命名的参数，它是调用它的选择器。</target>
        </trans-unit>
        <trans-unit id="ffbb7352ab0b0a6abe4eb4d50fb47e8061479506" translate="yes" xml:space="preserve">
          <source>Functions with non-D linkage cannot be virtual and hence cannot be overridden.</source>
          <target state="translated">非D连接的函数不能虚拟,因此不能被覆盖。</target>
        </trans-unit>
        <trans-unit id="eaad94952abd8178c9c878e428d9910f2e427164" translate="yes" xml:space="preserve">
          <source>Functions with the &lt;code&gt;@live&lt;/code&gt; attribute enable diagnosing these sorts of errors by tracking the status of owner pointers.</source>
          <target state="translated">具有 &lt;code&gt;@live&lt;/code&gt; 属性的函数可通过跟踪所有者指针的状态来诊断这些类型的错误。</target>
        </trans-unit>
        <trans-unit id="2adb6747d6f26e87d983ed577d7da81919733d7b" translate="yes" xml:space="preserve">
          <source>Functions without bodies:</source>
          <target state="translated">没有机构的功能。</target>
        </trans-unit>
        <trans-unit id="d783b16a7b27b910940b783d5fcc870c6c683d47" translate="yes" xml:space="preserve">
          <source>Fundamental Unicode algorithms and data structures.</source>
          <target state="translated">基本的Unicode算法和数据结构。</target>
        </trans-unit>
        <trans-unit id="ba469f1bc17cb15fca5f5581188a0b34ac4471eb" translate="yes" xml:space="preserve">
          <source>Furthermore, even with orderable types, the order relation may not be linear. For example, one may define an ordering on sets via the subset relation, such that &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true if &lt;code&gt;x&lt;/code&gt; is a (strict) subset of &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are disjoint sets, then neither &lt;code&gt;x &amp;lt; y&lt;/code&gt; nor &lt;code&gt;y &amp;lt; x&lt;/code&gt; holds, but that does not imply that &lt;code&gt;x == y&lt;/code&gt;. Thus, it is insufficient to determine equality purely based on &lt;code&gt;opCmp&lt;/code&gt; alone. For this reason, &lt;code&gt;opCmp&lt;/code&gt; is only used for the inequality operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&lt;/code&gt;. The equality operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; always employ &lt;code&gt;opEquals&lt;/code&gt; instead.</source>
          <target state="translated">此外，即使具有可排序的类型，顺序关系也可能不是线性的。例如，一个可以经由所述子集关系限定在套的排序，使得 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 为真，如果 &lt;code&gt;x&lt;/code&gt; 是的（严格）的子集 &lt;code&gt;y&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是不交集，则 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 和 &lt;code&gt;y &amp;lt; x&lt;/code&gt; 都不成立，但这并不意味着 &lt;code&gt;x == y&lt;/code&gt; 。因此，仅基于 &lt;code&gt;opCmp&lt;/code&gt; 来确定相等性是不够的。因此， &lt;code&gt;opCmp&lt;/code&gt; 仅用于不等式运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 。等号运算符 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 始终使用 &lt;code&gt;opEquals&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="869bc7df187eb57c1861571c27bf80367e22db67" translate="yes" xml:space="preserve">
          <source>Furthermore, predefined version identifiers from this list cannot be set from the command line or from version statements. (This prevents things like both &lt;code&gt;Windows&lt;/code&gt; and &lt;code&gt;linux&lt;/code&gt; being simultaneously set.)</source>
          <target state="translated">此外，无法从命令行或版本语句设置此列表中的预定义版本标识符。（这可以防止同时设置 &lt;code&gt;Windows&lt;/code&gt; 和 &lt;code&gt;linux&lt;/code&gt; 之类的东西。）</target>
        </trans-unit>
        <trans-unit id="2b04009b8ca8039e0507f25a9f0361986b70a3e6" translate="yes" xml:space="preserve">
          <source>Future policies may offer a more even balance between reader and writer precedence.</source>
          <target state="translated">未来的政策可能会在读者和作者的优先权之间提供更均衡的平衡。</target>
        </trans-unit>
        <trans-unit id="99d254d35351117c9cff18872b82ba6d91c00e60" translate="yes" xml:space="preserve">
          <source>G &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">摹 &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="227e2edf0447cd04a773c3b823f1c89795158178" translate="yes" xml:space="preserve">
          <source>GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt;(string name);</source>
          <target state="translated">GC &lt;strong id=&quot;createGCInstance&quot;&gt;createGCInstance&lt;/strong&gt;（字符串名称）；</target>
        </trans-unit>
        <trans-unit id="17686e6502ad0f3cdaf4206e0191cbc522cc8283" translate="yes" xml:space="preserve">
          <source>GC FAQ</source>
          <target state="translated">常见问题</target>
        </trans-unit>
        <trans-unit id="2715953d0812423734ebffeea6a105ce46d2c5b2" translate="yes" xml:space="preserve">
          <source>GC allocated string</source>
          <target state="translated">GC分配的字符串</target>
        </trans-unit>
        <trans-unit id="8b2c6daf9a150d506a85e85cb9bcb053667888f2" translate="yes" xml:space="preserve">
          <source>GC allocated string with spaces replaced with tabs; use &lt;a href=&quot;#entabber&quot;&gt;&lt;code&gt;entabber&lt;/code&gt;&lt;/a&gt; to not allocate.</source>
          <target state="translated">GC分配的字符串，其中空格用制表符替换；使用&lt;a href=&quot;#entabber&quot;&gt; &lt;code&gt;entabber&lt;/code&gt; &lt;/a&gt;不分配。</target>
        </trans-unit>
        <trans-unit id="86e1b687d8486a9dcb7b4165bc8e5226d854f2c7" translate="yes" xml:space="preserve">
          <source>GC allocated string with tabs replaced with spaces</source>
          <target state="translated">GC分配的字符串,用空格代替了制表符。</target>
        </trans-unit>
        <trans-unit id="6b9746104b4c3bc7be22e5b6d74741bddee5a6bf" translate="yes" xml:space="preserve">
          <source>GC implementations are added to a registry that allows to supply more implementations by just linking them into the binary. To do so add a function that is executed before the D runtime initialization using &lt;code&gt;pragma(crt_constructor)&lt;/code&gt;:</source>
          <target state="translated">GC实现已添加到注册表中，该注册表仅通过将其链接到二进制文件即可提供更多实现。为此，添加一个使用 &lt;code&gt;pragma(crt_constructor)&lt;/code&gt; 在D运行时初始化之前执行的函数：</target>
        </trans-unit>
        <trans-unit id="5951ff6858fe229e78c3aef61db342f3d5f757a1" translate="yes" xml:space="preserve">
          <source>GC scan hook, called FOR each thread. Can be used to scan additional thread local memory.</source>
          <target state="translated">GC扫描钩子,为每个线程调用。可用于扫描额外的线程本地内存。</target>
        </trans-unit>
        <trans-unit id="44da27f9ddec555cbd5fcd60022e2b6c8808bbdc" translate="yes" xml:space="preserve">
          <source>GC sweep hook, called FOR each thread. Can be used to free additional thread local memory or associated data structures. Note that only memory allocated from the GC can have marks.</source>
          <target state="translated">GC扫荡钩子,FOR每个线程调用。可以用来释放额外的线程本地内存或相关数据结构。注意,只有从GC分配的内存才能有标记。</target>
        </trans-unit>
        <trans-unit id="152e90dd32518be928b899f58b1e3835f65ca8cc" translate="yes" xml:space="preserve">
          <source>GCFactory &lt;code&gt;factory&lt;/code&gt;</source>
          <target state="translated">GCFactory &lt;code&gt;factory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04a69c000934b632336629d0d827590961013d5f" translate="yes" xml:space="preserve">
          <source>GDC (GNU D Compiler) is the compiler</source>
          <target state="translated">GDC(GNU D Compiler)是编译器</target>
        </trans-unit>
        <trans-unit id="c6b9fdbe9b835ce607d5f9465603dc2e9dd09b8c" translate="yes" xml:space="preserve">
          <source>GNU D Compiler (GDC)</source>
          <target state="translated">GNU D Compiler (GDC)</target>
        </trans-unit>
        <trans-unit id="1ced0cf23647bda25b46395cd7423d5899e8cec5" translate="yes" xml:space="preserve">
          <source>GNU Hurd</source>
          <target state="translated">GNU Hurd</target>
        </trans-unit>
        <trans-unit id="c9744a883d88a359c771c7c407727c811697e7d9" translate="yes" xml:space="preserve">
          <source>GSS-Negotiate</source>
          <target state="translated">GSS-Negotiate</target>
        </trans-unit>
        <trans-unit id="649101d4277d8226d1453ed4ac0ae23fef3f6651" translate="yes" xml:space="preserve">
          <source>GapWeightedSimilarityIncremental!(R, F) &lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;gapWeightedSimilarityIncremental&lt;/strong&gt;(R, F)(R r1, R r2, F penalty);</source>
          <target state="translated">GapWeightedSimilarityIncremental！（R，F）&lt;strong id=&quot;gapWeightedSimilarityIncremental&quot;&gt;gapWeightedSimilarityIncremental&lt;/strong&gt;（R，F）（R r1，R r2，F罚分）;</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">垃圾收集</target>
        </trans-unit>
        <trans-unit id="b68927a1fc8d1a3e9f2d3afdf28381f11e58bc69" translate="yes" xml:space="preserve">
          <source>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</source>
          <target state="translated">垃圾收集。自动动态内存管理的算法</target>
        </trans-unit>
        <trans-unit id="26ed33deae58e27843afa7f067144cf4cc6aa56f" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are faster to develop and debug, because there's no need for developing, debugging, testing, or maintaining the explicit deallocation code.</source>
          <target state="translated">垃圾收集程序的开发和调试速度更快,因为不需要开发、调试、测试或维护显式deallocation代码。</target>
        </trans-unit>
        <trans-unit id="b5b34cabae6ba38a27f9919e85bfc06a08059602" translate="yes" xml:space="preserve">
          <source>Garbage collected programs are often faster. This is counterintuitive, but the reasons are:</source>
          <target state="translated">垃圾收集程序通常更快。这有悖于直觉,但原因是。</target>
        </trans-unit>
        <trans-unit id="a8b92a6daa02321044a81fa8b11e153716774a33" translate="yes" xml:space="preserve">
          <source>Garbage collected programs do not suffer from gradual deterioration due to an accumulation of memory leaks.</source>
          <target state="translated">垃圾收集程序不会因为内存泄漏的积累而逐渐恶化。</target>
        </trans-unit>
        <trans-unit id="7b3b619bb8bd26c9ff456e8cbc3e5bc6b3b1d018" translate="yes" xml:space="preserve">
          <source>Garbage collected programs have fewer hard-to-find pointer bugs. This is because there are no dangling references to freed memory. There is no code to explicitly manage memory, hence no bugs in such code.</source>
          <target state="translated">垃圾收集程序有较少的难以发现的指针错误。这是因为没有悬而未决的对释放内存的引用。没有显式管理内存的代码,因此这种代码没有错误。</target>
        </trans-unit>
        <trans-unit id="6274199ad9ef2c79ed1df932fffcb7da577e7439" translate="yes" xml:space="preserve">
          <source>Garbage collection doesn't solve every memory deallocation problem. For example, if a pointer to a large data structure is kept, the garbage collector cannot reclaim it, even if it is never referred to again. To eliminate this problem, it is good practice to set a reference or pointer to an object to null when no longer needed.</source>
          <target state="translated">垃圾收集器并不能解决所有的内存去分配问题。例如,如果一个指向大型数据结构的指针被保留下来,垃圾收集器就无法回收它,即使它再也没有被引用。为了消除这个问题,好的做法是在不再需要的时候,将一个对象的引用或指针设置为空。</target>
        </trans-unit>
        <trans-unit id="2a483157166b15cc6add50950e71104545209b12" translate="yes" xml:space="preserve">
          <source>Garbage collection is not a panacea. There are some downsides:</source>
          <target state="translated">垃圾收集不是万能的。也有一些弊端。</target>
        </trans-unit>
        <trans-unit id="bdc8494b0a1f3be26c109010c1300b5540a63f86" translate="yes" xml:space="preserve">
          <source>Garbage collection kicks in only when memory gets tight. When memory is not tight, the program runs at full speed and does not spend any time tracing and freeing memory.</source>
          <target state="translated">只有当内存紧张时,垃圾收集才会启动。当内存不紧张时,程序全速运行,不花任何时间跟踪和释放内存。</target>
        </trans-unit>
        <trans-unit id="43e630068e8d3af90d5baf5c490d09a820b5fe43" translate="yes" xml:space="preserve">
          <source>Garbage collection should be implemented as a basic operating system kernel service. But since it is not, garbage collecting programs must carry around with them the garbage collection implementation. While this can be a shared library, it is still there.</source>
          <target state="translated">垃圾收集应该作为一个基本的操作系统内核服务来实现。但既然不是,垃圾收集程序就必须随身携带垃圾收集的实现。虽然这可以是一个共享库,但它还是存在的。</target>
        </trans-unit>
        <trans-unit id="8de09af360c7bfc02cd9b07759c0be1a92997bf1" translate="yes" xml:space="preserve">
          <source>Garbage collectors can keep around some memory that an explicit deallocator would not.</source>
          <target state="translated">垃圾收集器可以保留一些显式deallocator不会保留的内存。</target>
        </trans-unit>
        <trans-unit id="52f128a6c5d8578ad64f58e212419d6613dc978b" translate="yes" xml:space="preserve">
          <source>Garbage collectors reclaim unused memory, therefore they do not suffer from &quot;memory leaks&quot; which can cause long running applications to gradually consume more and more memory until they bring down the system. GC programs have longer term stability.</source>
          <target state="translated">垃圾回收器回收未使用的内存,因此不会出现 &quot;内存泄漏 &quot;的情况,因为长期运行的应用程序会逐渐消耗越来越多的内存,直至使系统瘫痪。GC程序具有较长的稳定性。</target>
        </trans-unit>
        <trans-unit id="5929f6c7d4d9ef8bac1c480f80dfd125a208b5f6" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol</source>
          <target state="translated">网关到网关协议</target>
        </trans-unit>
        <trans-unit id="6b850d9a8cc2ef5b85b6581a88258447107ac8f9" translate="yes" xml:space="preserve">
          <source>Gateway to Gateway Protocol level</source>
          <target state="translated">网关对网关协议级别</target>
        </trans-unit>
        <trans-unit id="8e56a55c1f12981e7b0c87a44da833cae0277f14" translate="yes" xml:space="preserve">
          <source>Gcc Cpp runtime</source>
          <target state="translated">Gcc Cpp运行时</target>
        </trans-unit>
        <trans-unit id="f0db25c1007f1ac431f102d1b6f3db7e823e1c1d" translate="yes" xml:space="preserve">
          <source>GccAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">GccAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="cc2b80e244c5b3f85b819f8e001f39a8b1778b1c" translate="yes" xml:space="preserve">
          <source>General Punctuation</source>
          <target state="translated">一般标点符号</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">一般类型</target>
        </trans-unit>
        <trans-unit id="fd7aec0ee16d41be57526539a4c6ef8ef63c34e9" translate="yes" xml:space="preserve">
          <source>General case =&amp;gt; symmetric calls to method opEquals</source>
          <target state="translated">一般情况=&amp;gt;对方法opEquals的对称调用</target>
        </trans-unit>
        <trans-unit id="2def4e3aff28a0804ab7417604344f41584fcca9" translate="yes" xml:space="preserve">
          <source>General category sets listed below are only accessible with the &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; shorthand accessor.</source>
          <target state="translated">下面列出的常规类别集只能使用&lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt;速记访问器访问。</target>
        </trans-unit>
        <trans-unit id="2083d118900999f8d32dc5f2e8254d3f52ea6bf1" translate="yes" xml:space="preserve">
          <source>General use synchronization semaphore.</source>
          <target state="translated">一般使用同步信号器。</target>
        </trans-unit>
        <trans-unit id="15c16d502337718b40d0beb9afa9790ccdf94859" translate="yes" xml:space="preserve">
          <source>Generally useful building blocks for customized normalization: &lt;a href=&quot;#combiningClass&quot;&gt;&lt;code&gt;combiningClass&lt;/code&gt;&lt;/a&gt; for querying combining class and &lt;a href=&quot;#allowedIn&quot;&gt;&lt;code&gt;allowedIn&lt;/code&gt;&lt;/a&gt; for testing the Quick_Check property of a given normalization form.</source>
          <target state="translated">用于自定义规范化的通常有用的构建块：&lt;a href=&quot;#combiningClass&quot;&gt; &lt;code&gt;combiningClass&lt;/code&gt; &lt;/a&gt;用于查询组合类，&lt;a href=&quot;#allowedIn&quot;&gt; &lt;code&gt;allowedIn&lt;/code&gt; &lt;/a&gt;用于测试给定规范化形式的Quick_Check属性。</target>
        </trans-unit>
        <trans-unit id="9641d9bcb23b576cc813cade93d2589aaa993fe5" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;stable&lt;/code&gt; ordering strategy may be more costly in time and/or space than the other two because it imposes additional constraints. Similarly, &lt;code&gt;semistable&lt;/code&gt; may be costlier than &lt;code&gt;unstable&lt;/code&gt;. As (semi-)stability is not needed very often, the ordering algorithms in this module parameterized by &lt;code&gt;SwapStrategy&lt;/code&gt; all choose &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; as the default.</source>
          <target state="translated">通常， &lt;code&gt;stable&lt;/code&gt; 排序策略在时间和/或空间上可能比其他两种策略更昂贵，因为它施加了额外的约束。同样， &lt;code&gt;semistable&lt;/code&gt; 可能比 &lt;code&gt;unstable&lt;/code&gt; 更昂贵。由于不经常需要（半）稳定性，因此由 &lt;code&gt;SwapStrategy&lt;/code&gt; 参数化的此模块中的排序算法均选择 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; 作为默认值。</target>
        </trans-unit>
        <trans-unit id="05d74eaaa124507aed1ad66047271caa648813e4" translate="yes" xml:space="preserve">
          <source>Generally, the &lt;code&gt;std&lt;/code&gt; namespace is used for the main modules in the Phobos standard library. The &lt;code&gt;etc&lt;/code&gt; namespace is used for external C/C++ library bindings. The &lt;code&gt;core&lt;/code&gt; namespace is used for low-level D runtime functions.</source>
          <target state="translated">通常， &lt;code&gt;std&lt;/code&gt; 名称空间用于Phobos标准库中的主要模块。所述 &lt;code&gt;etc&lt;/code&gt; 命名空间用于外部C / C ++库绑定。所述 &lt;code&gt;core&lt;/code&gt; 名称空间被用于低级别d运行时功能。</target>
        </trans-unit>
        <trans-unit id="270a807f0de4d20f0d7b86a3f7b8a65802e708dd" translate="yes" xml:space="preserve">
          <source>Generally, this function checks that &lt;code&gt;path&lt;/code&gt; is not empty, and that each component of the path either satisfies &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; or is equal to &lt;code&gt;&quot;.&quot;&lt;/code&gt; or &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">通常，此函数检查 &lt;code&gt;path&lt;/code&gt; 是否为空，以及路径的每个组成部分是否满足&lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt;或等于 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac3d74ace2e58f845d2e516e7b9c956be3febfc4" translate="yes" xml:space="preserve">
          <source>Generate .obj file for Module.</source>
          <target state="translated">为模块生成.obj文件。</target>
        </trans-unit>
        <trans-unit id="f9dad7b8a1ce93a4eb80b95d85ef1cf88d8f4597" translate="yes" xml:space="preserve">
          <source>Generate C main() in response to seeing D main().</source>
          <target state="translated">在看到D main()时,生成C main()。</target>
        </trans-unit>
        <trans-unit id="345123c70e49b34125173495f611953054f48574" translate="yes" xml:space="preserve">
          <source>Generate Expression to call the invariant.</source>
          <target state="translated">生成Expression来调用不变式。</target>
        </trans-unit>
        <trans-unit id="d90320355fd64aadd68db9a959d0db877a879578" translate="yes" xml:space="preserve">
          <source>Generate HALT instruction.</source>
          <target state="translated">生成HALT指令。</target>
        </trans-unit>
        <trans-unit id="f40cd732815b9b227c307d8a881eabcde883c532" translate="yes" xml:space="preserve">
          <source>Generate Symbol of C++ type info for C++ class cd.</source>
          <target state="translated">为C++类cd生成C++类型信息符号。</target>
        </trans-unit>
        <trans-unit id="71428fcf71b36719232a357b20981c579d5f795c" translate="yes" xml:space="preserve">
          <source>Generate a FuncDeclaration for a runtime library function.</source>
          <target state="translated">生成一个运行时库函数的FuncDeclaration。</target>
        </trans-unit>
        <trans-unit id="c1f38d03f2f34b3b4a976dcf593b7574be546eff" translate="yes" xml:space="preserve">
          <source>Generate a convenient string for identifying this Tid. This is only useful to see if Tid's that are currently executing are the same or different, e.g. for logging and debugging. It is potentially possible that a Tid executed in the future will have the same toString() output as another Tid that has already terminated.</source>
          <target state="translated">生成一个方便的字符串来识别这个Tid。这只对查看当前正在执行的Tid是否相同或不同很有用,例如用于记录和调试。未来执行的一个Tid有可能与另一个已经终止的Tid有相同的toString()输出。</target>
        </trans-unit>
        <trans-unit id="42a4983512e25bdf4577cfbc7ade2d3d9ef11551" translate="yes" xml:space="preserve">
          <source>Generate a copy from e2 to e1.</source>
          <target state="translated">从e2生成一个副本到e1。</target>
        </trans-unit>
        <trans-unit id="7e990bafe6b9623ad15b6163c4381e1e24f60827" translate="yes" xml:space="preserve">
          <source>Generate and output scope table.</source>
          <target state="translated">生成并输出范围表。</target>
        </trans-unit>
        <trans-unit id="d887428fee6838e30b863f3266f3121541d951d0" translate="yes" xml:space="preserve">
          <source>Generate call to C's assert failure function. One of exp, emsg, or str must not be null.</source>
          <target state="translated">生成对C的断言失败函数的调用。exp,emsg,或 str 中的一个不能为空。</target>
        </trans-unit>
        <trans-unit id="b0e2deeef3299cd274df6c669c731ce070bbe521" translate="yes" xml:space="preserve">
          <source>Generate data for instance of _cpp_type_info_ptr that refers to the C++ RTTI symbol for cd.</source>
          <target state="translated">生成指向cd的C++RTTI符号的_cpp_type_info_ptr实例的数据。</target>
        </trans-unit>
        <trans-unit id="92ed283aad401b73892410374fb18c0200210984" translate="yes" xml:space="preserve">
          <source>Generate deterministic named identifier based on a source location, such that the name is consistent across multiple compilations. A new unique name is generated. If the prefix+location is already in the stringtable, an extra suffix is added (starting the count at &quot;1&quot;).</source>
          <target state="translated">基于源位置生成确定性的命名标识符,使名称在多个编译中保持一致。生成一个新的唯一名称。如果前缀+位置已经在字符串表中,则增加一个额外的后缀(从 &quot;1 &quot;开始计数)。</target>
        </trans-unit>
        <trans-unit id="e688f516a8d461fb5372c55840691f744fd51391" translate="yes" xml:space="preserve">
          <source>Generate import symbol from symbol.</source>
          <target state="translated">从符号生成导入符号。</target>
        </trans-unit>
        <trans-unit id="9978fdec524f341bfac18807618c73a3b51b46c1" translate="yes" xml:space="preserve">
          <source>Generate symbol of type ty at DATA:offset</source>
          <target state="translated">在DATA:offset处生成ty类型的符号。</target>
        </trans-unit>
        <trans-unit id="821fb78c5c9319cc69fa8057c9c2cd2d48fedaf8" translate="yes" xml:space="preserve">
          <source>Generate two operand instruction with XMM 128 bit operands.</source>
          <target state="translated">生成两个操作数指令,操作数为XMM 128位。</target>
        </trans-unit>
        <trans-unit id="5c437f1471923979723873169275d327e196c1fa" translate="yes" xml:space="preserve">
          <source>Generated Macro Definitions</source>
          <target state="translated">生成的宏定义</target>
        </trans-unit>
        <trans-unit id="b53fd19a2486af4f399d146936aa03eb7d82a727" translate="yes" xml:space="preserve">
          <source>Generated code is inserted in the scope of &lt;code&gt;std.typecons&lt;/code&gt; module. Thus, any useful functions outside &lt;code&gt;std.typecons&lt;/code&gt; cannot be used in the generated code. To workaround this problem, you may &lt;code&gt;import&lt;/code&gt; necessary things in a local struct, as done in the &lt;code&gt;generateLogger()&lt;/code&gt; template in the above example.</source>
          <target state="translated">生成的代码将插入到 &lt;code&gt;std.typecons&lt;/code&gt; 模块的范围内。因此， &lt;code&gt;std.typecons&lt;/code&gt; 之外的任何有用函数都不能在生成的代码中使用。要解决此问题，您可以在本地结构中 &lt;code&gt;import&lt;/code&gt; 必要的内容，如上例中的 &lt;code&gt;generateLogger()&lt;/code&gt; 模板中所述。</target>
        </trans-unit>
        <trans-unit id="e6857b9e8cb1c55a9a2f9226a5b4dc0cf595f501" translate="yes" xml:space="preserve">
          <source>Generates a hash for &lt;code&gt;this&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookToHash&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt;. If &lt;code&gt;Hook&lt;/code&gt; does not implement &lt;code&gt;hookToHash&lt;/code&gt;, but it has state, a hash will be generated for the &lt;code&gt;Hook&lt;/code&gt; using the built-in function and it will be xored with the hash of the &lt;code&gt;payload&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 生成一个哈希值。如果 &lt;code&gt;Hook&lt;/code&gt; 定义了 &lt;code&gt;hookToHash&lt;/code&gt; ，则调用将立即返回 &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; 。如果 &lt;code&gt;Hook&lt;/code&gt; 没有实现 &lt;code&gt;hookToHash&lt;/code&gt; ，但是它具有状态，则将使用内置函数为 &lt;code&gt;Hook&lt;/code&gt; 生成一个哈希，并将其与 &lt;code&gt;payload&lt;/code&gt; 的哈希进行异或。</target>
        </trans-unit>
        <trans-unit id="feba4b72ab473cbf0cd5ea105195b64ec1ac1f2d" translate="yes" xml:space="preserve">
          <source>Generates a hash for the tree. Note that with a custom comparison function it may not hold that if two rbtrees are equal, the hashes of the trees will be equal.</source>
          <target state="translated">生成树的哈希值。需要注意的是,如果两个 rbtrees 相等,树的哈希值就不一定相等。</target>
        </trans-unit>
        <trans-unit id="57845456ec25b869fe6d9c20ab2d9cba380674de" translate="yes" xml:space="preserve">
          <source>Generates a human-readable stack-trace on POSIX targets using DWARF</source>
          <target state="translated">使用DWARF在POSIX目标上生成一个人类可读的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="398b1403000b9404acc8a7edce2480693602dfc5" translate="yes" xml:space="preserve">
          <source>Generates a number between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The &lt;code&gt;boundaries&lt;/code&gt; parameter controls the shape of the interval (open vs. closed on either side). Valid values for &lt;code&gt;boundaries&lt;/code&gt; are &lt;code&gt;&quot;[]&quot;&lt;/code&gt;, &lt;code&gt;&quot;(]&quot;&lt;/code&gt;, &lt;code&gt;&quot;[)&quot;&lt;/code&gt;, and &lt;code&gt;&quot;()&quot;&lt;/code&gt;. The default interval is closed to the left and open to the right. The version that does not take &lt;code&gt;urng&lt;/code&gt; uses the default generator &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">生成之间的数字 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。的 &lt;code&gt;boundaries&lt;/code&gt; 参数控制的间隔的形状（打开与闭合在任一侧上）。为有效值 &lt;code&gt;boundaries&lt;/code&gt; 是 &lt;code&gt;&quot;[]&quot;&lt;/code&gt; &amp;ldquo;（]&amp;rdquo; &lt;code&gt;&quot;(]&quot;&lt;/code&gt; ， &lt;code&gt;&quot;[)&quot;&lt;/code&gt; ，和 &lt;code&gt;&quot;()&quot;&lt;/code&gt; 。默认间隔在左侧关闭，在右侧打开。不使用 &lt;code&gt;urng&lt;/code&gt; 的版本使用默认生成器 &lt;code&gt;rndGen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31d5a7a72aa7d6403397ac8f8b98d7136fb359b8" translate="yes" xml:space="preserve">
          <source>Generates a uniform probability distribution of size &lt;code&gt;n&lt;/code&gt;, i.e., an array of size &lt;code&gt;n&lt;/code&gt; of positive numbers of type &lt;code&gt;F&lt;/code&gt; that sum to &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;useThis&lt;/code&gt; is provided, it is used as storage.</source>
          <target state="translated">生成大小为 &lt;code&gt;n&lt;/code&gt; 的均匀概率分布，即，大小为 &lt;code&gt;n&lt;/code&gt; 且类型为 &lt;code&gt;F&lt;/code&gt; 的正数的总和为 &lt;code&gt;1&lt;/code&gt; 的数组。如果提供了 &lt;code&gt;useThis&lt;/code&gt; ，它将用作存储。</target>
        </trans-unit>
        <trans-unit id="e2682a8625295cc7a75ade62ec910662e42eb1ad" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed floating point number of type &lt;code&gt;T&lt;/code&gt; in the range [0, 1). If no random number generator is specified, the default RNG &lt;code&gt;rndGen&lt;/code&gt; will be used as the source of randomness.</source>
          <target state="translated">生成类型为 &lt;code&gt;T&lt;/code&gt; 的均匀分布浮点数，范围为[0，1）。如果未指定随机数生成器，则默认RNG &lt;code&gt;rndGen&lt;/code&gt; 将用作随机性的来源。</target>
        </trans-unit>
        <trans-unit id="590a92dca2ec49812f71151418c5576ff9ad8ac5" translate="yes" xml:space="preserve">
          <source>Generates a uniformly-distributed number in the range &lt;code&gt;[T.min, T.max]&lt;/code&gt; for any integral or character type &lt;code&gt;T&lt;/code&gt;. If no random number generator is passed, uses the default &lt;code&gt;rndGen&lt;/code&gt;.</source>
          <target state="translated">为任何整数或字符类型 &lt;code&gt;T&lt;/code&gt; 生成一个在 &lt;code&gt;[T.min, T.max]&lt;/code&gt; 范围内的均匀分布的数字。如果未传递随机数生成器，则使用默认的 &lt;code&gt;rndGen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a3dd4ef1d89d221f34cd8efe42c23a94aa835c2" translate="yes" xml:space="preserve">
          <source>Generates string with D source code of unary function with name of &lt;code&gt;funcName&lt;/code&gt; taking a single &lt;code&gt;dchar&lt;/code&gt; argument. If &lt;code&gt;funcName&lt;/code&gt; is empty the code is adjusted to be a lambda function.</source>
          <target state="translated">生成字符串与名称一元函数的d源代码 &lt;code&gt;funcName&lt;/code&gt; 服用单一 &lt;code&gt;dchar&lt;/code&gt; 参数。如果 &lt;code&gt;funcName&lt;/code&gt; 为空，则将代码调整为lambda函数。</target>
        </trans-unit>
        <trans-unit id="4b3935a65e18852e853df767745851e9e88c4154" translate="yes" xml:space="preserve">
          <source>Generates the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;torig&lt;/code&gt; if it hasn't already been generated</source>
          <target state="translated">生成与 &lt;code&gt;torig&lt;/code&gt; 关联的 &lt;code&gt;TypeInfo&lt;/code&gt; 对象（如果尚未生成）</target>
        </trans-unit>
        <trans-unit id="c898dd30458bc82445a94b03bf4338f7812ed73c" translate="yes" xml:space="preserve">
          <source>Generates the following:</source>
          <target state="translated">产生以下内容:</target>
        </trans-unit>
        <trans-unit id="ef2e0bcfe378859fb93a76e38ab31870b5aaab4c" translate="yes" xml:space="preserve">
          <source>Generating UUIDs</source>
          <target state="translated">生成UUIDs</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="7282cafe7ab4dcfbd06151ce87eab6a8cb7b662e" translate="yes" xml:space="preserve">
          <source>Generic Template API used for CRC32 and CRC64 implementations.</source>
          <target state="translated">通用模板API用于CRC32和CRC64的实现。</target>
        </trans-unit>
        <trans-unit id="48d04e2739718c3b5809e3d93e9ab17e0175ee79" translate="yes" xml:space="preserve">
          <source>Generic algorithms for processing sequences.</source>
          <target state="translated">处理序列的通用算法。</target>
        </trans-unit>
        <trans-unit id="7bca8ef182b8f3deaa44e5a838347a3d8559084e" translate="yes" xml:space="preserve">
          <source>Generic algorithms that work with &lt;a href=&quot;std_range&quot;&gt;ranges&lt;/a&gt; of any type, including strings, arrays, and other kinds of sequentially-accessed data. Algorithms include searching, comparison, iteration, sorting, set operations, and mutation.</source>
          <target state="translated">适用于任何类型&lt;a href=&quot;std_range&quot;&gt;范围&lt;/a&gt;的通用算法，包括字符串，数组和其他顺序访问的数据。算法包括搜索，比较，迭代，排序，设置操作和变异。</target>
        </trans-unit>
        <trans-unit id="e37a68ed0e7f2e44e67335effd984a4809f41f52" translate="yes" xml:space="preserve">
          <source>Generic code which deals with different Digest types should always call start though.</source>
          <target state="translated">处理不同Digest类型的通用代码应该总是调用start。</target>
        </trans-unit>
        <trans-unit id="a4fe6a7b8d8e501df226058c573d01d9418d71dd" translate="yes" xml:space="preserve">
          <source>Generic error</source>
          <target state="translated">通用错误</target>
        </trans-unit>
        <trans-unit id="070a5062376a825143c54fc921ea5b5a3350219e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt;&lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">范围上的通用剥离：&lt;a href=&quot;std_algorithm_mutation#strip&quot;&gt; &lt;code&gt;std.algorithm.mutation.strip&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5f39e04859e495f02a94a4f09ad4d9de0e5160e" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">范围上的通用剥离：&lt;a href=&quot;std_algorithm_mutation#stripLeft&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripLeft&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14b5394baf94216f2e7707c45724f2e122958d4a" translate="yes" xml:space="preserve">
          <source>Generic stripping on ranges: &lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt;&lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">范围上的通用剥离：&lt;a href=&quot;std_algorithm_mutation#stripRight&quot;&gt; &lt;code&gt;std.algorithm.mutation.stripRight&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9464f7b462f8074504ba78be947c4f876e0fc5c" translate="yes" xml:space="preserve">
          <source>Generic type value getter A convenience getter that returns this &lt;code&gt;JSONValue&lt;/code&gt; as the specified D type.</source>
          <target state="translated">通用类型值getter便利的getter，它以指定的D类型返回此 &lt;code&gt;JSONValue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d110955c054077a9782bc3e9dc049c8ed9e192f" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units.</source>
          <target state="translated">两种时间单位之间的通用换算方式。</target>
        </trans-unit>
        <trans-unit id="fdfe3a8efedde26bb169021d4c0add270ebc9913" translate="yes" xml:space="preserve">
          <source>Generic way of converting between two time units. Conversions to smaller units use truncating division. Years and months can be converted to each other, small units can be converted to each other, but years and months cannot be converted to or from smaller units (due to the varying number of days in a month or year).</source>
          <target state="translated">两种时间单位之间的通用换算方式。换算成更小的单位时,采用截断式除法。年和月可以互相换算,小单位可以互相换算,但年和月不能与小单位换算或从小单位换算(由于月或年的天数不同)。</target>
        </trans-unit>
        <trans-unit id="8351f1bd421bb3c2f34de06d3708adb7a974a3d4" translate="yes" xml:space="preserve">
          <source>Geometric Shapes</source>
          <target state="translated">几何形状</target>
        </trans-unit>
        <trans-unit id="aca441ddd2e8d07643b87c1b24a828fa5b4b3e42" translate="yes" xml:space="preserve">
          <source>Georgian</source>
          <target state="translated">Georgian</target>
        </trans-unit>
        <trans-unit id="c559cff938d372579d74b90c80d2874125e4b5d4" translate="yes" xml:space="preserve">
          <source>Georgian Supplement</source>
          <target state="translated">格鲁吉亚语补编</target>
        </trans-unit>
        <trans-unit id="2e85da619ae334aca9d3221727062ef17b60edd9" translate="yes" xml:space="preserve">
          <source>Get Pointer to Thrown Object if type of thrown object is implicitly convertible to the catch type.</source>
          <target state="translated">如果抛出对象的类型可以隐式转换为捕捉类型,则获取抛出对象的指针。</target>
        </trans-unit>
        <trans-unit id="49759c09a6285b1e1c3c2442b86bed6b17c79b57" translate="yes" xml:space="preserve">
          <source>Get RTTI mangling of the given class declaration for C++ ABI.</source>
          <target state="translated">获取C++ABI的给定类声明的RTTI杂乱。</target>
        </trans-unit>
        <trans-unit id="30af4ba10b05a5544d5e9caa6adff1c6bc3df069" translate="yes" xml:space="preserve">
          <source>Get TypeInfo for 'next' type, as defined by what kind of type this is, null if none.</source>
          <target state="translated">获取'next'类型的类型信息,由类型定义,如果没有则为空。</target>
        </trans-unit>
        <trans-unit id="c92e7f5f377e9154bb8151fe8cde1e5454a8ad6b" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of</source>
          <target state="translated">获取AliasSeq的</target>
        </trans-unit>
        <trans-unit id="2697c6709922de4b4eb3a504173797b3b2d2f222" translate="yes" xml:space="preserve">
          <source>Get a AliasSeq of the base class and base interfaces of this class or interface. BaseTypeTuple!Object returns the empty type tuple.</source>
          <target state="translated">获取这个类或接口的基类和基接口的AliasSeq。BaseTypeTuple!Object返回空的类型元组。</target>
        </trans-unit>
        <trans-unit id="debff9d835c323dd33cb0eb8c68915f9979c7a6c" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;gt; e according to the less comparator</source>
          <target state="translated">根据less比较器从容器中获得一个范围，其中所有元素都&amp;gt; e</target>
        </trans-unit>
        <trans-unit id="2f427a0e190ea30b9ef773b930557ceb28c95c24" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are &amp;lt; e according to the less comparator</source>
          <target state="translated">根据较小的比较器，从容器中获取所有元素&amp;lt;e的范围</target>
        </trans-unit>
        <trans-unit id="1a49fd135d74779940e67901f3680596c3cb7489" translate="yes" xml:space="preserve">
          <source>Get a range from the container with all elements that are == e according to the less comparator</source>
          <target state="translated">根据较小的比较器,从容器中获取所有元素==e的范围。</target>
        </trans-unit>
        <trans-unit id="57416603cdc2a4317e5cef5fc1df8438a0dc691d" translate="yes" xml:space="preserve">
          <source>Get a socket option.</source>
          <target state="translated">获得一个插座选项。</target>
        </trans-unit>
        <trans-unit id="ab0526a6b77b2a6ea32e278479a2c15bfc6233f8" translate="yes" xml:space="preserve">
          <source>Get a text description of this socket's error status, and clear the socket's error status.</source>
          <target state="translated">获取该套接字的错误状态的文字描述,并清除该套接字的错误状态。</target>
        </trans-unit>
        <trans-unit id="cb65e9616425e0463e1160c764ce114f293c53ad" translate="yes" xml:space="preserve">
          <source>Get a timeout (duration) option.</source>
          <target state="translated">获取超时(持续时间)选项。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
