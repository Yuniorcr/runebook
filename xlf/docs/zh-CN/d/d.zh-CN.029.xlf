<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="d8b561572b4c6d9af712780047246b7bc740a0d4" translate="yes" xml:space="preserve">
          <source>Time condition enumeration as an alias of &lt;a href=&quot;etc_c_curl#CurlTimeCond&quot;&gt;&lt;code&gt;etc.c.curl.CurlTimeCond&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">时间条件枚举作为&lt;a href=&quot;etc_c_curl#CurlTimeCond&quot;&gt; &lt;code&gt;etc.c.curl.CurlTimeCond&lt;/code&gt; &lt;/a&gt;的别名</target>
        </trans-unit>
        <trans-unit id="c4aa3d14f701bba1ce181f3ec53ab695e0ade4da" translate="yes" xml:space="preserve">
          <source>Time the file was created.</source>
          <target state="translated">文件创建的时间。</target>
        </trans-unit>
        <trans-unit id="e359a0b0bd880a8c9076e3b462259fa4ca22d2f6" translate="yes" xml:space="preserve">
          <source>Time the file was last accessed.</source>
          <target state="translated">文件最后一次被访问的时间。</target>
        </trans-unit>
        <trans-unit id="36c7dbef3cde666059933c227164a5d18726f66b" translate="yes" xml:space="preserve">
          <source>Time the file was last modified.</source>
          <target state="translated">文件最后修改的时间。</target>
        </trans-unit>
        <trans-unit id="27cd174e9f8cc698cbd69056f98a77a3a55cb471" translate="yes" xml:space="preserve">
          <source>Time the file/folder was last accessed.</source>
          <target state="translated">文件/文件夹最后被访问的时间。</target>
        </trans-unit>
        <trans-unit id="4f227039843bc9b22d4f838b81ed18e54bb7b1a9" translate="yes" xml:space="preserve">
          <source>Time the file/folder was last modified.</source>
          <target state="translated">文件/文件夹最后一次修改的时间。</target>
        </trans-unit>
        <trans-unit id="1ea7cebe3f6da97aa7f2b8e66e161d60c16635c8" translate="yes" xml:space="preserve">
          <source>Time to set (will be saved as DosFileTime, which is less accurate).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5f4600d3071981a08116aeac1a782767d2276f" translate="yes" xml:space="preserve">
          <source>Time to use with the above condition. Specified in number of seconds since 1 Jan 1970</source>
          <target state="translated">在上述条件下使用的时间。以1970年1月1日以来的秒数表示。</target>
        </trans-unit>
        <trans-unit id="d4cc22c8986572ffe1c232ea2044aac4c6d79f91" translate="yes" xml:space="preserve">
          <source>Time units</source>
          <target state="translated">时间单位</target>
        </trans-unit>
        <trans-unit id="27745ce39165b24aa9162930c4465ce642154b42" translate="yes" xml:space="preserve">
          <source>Time zone is irrelevant when comparing &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">比较&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;时，时区无关紧要。</target>
        </trans-unit>
        <trans-unit id="9699f4eda399b03a7b8d7d0af76df9f2a6323ecf" translate="yes" xml:space="preserve">
          <source>Time zone offsets will be in the form +HH:MM or -HH:MM.</source>
          <target state="translated">时区偏移的形式为+HH:MM或-HH:MM。</target>
        </trans-unit>
        <trans-unit id="cbdea8478f6e24b16a22dfabfcf393abc2b6f5b4" translate="yes" xml:space="preserve">
          <source>Time zone offsets will be in the form +HHMM or -HHMM.</source>
          <target state="translated">时区偏移将以+HHMM或-HHMM的形式出现。</target>
        </trans-unit>
        <trans-unit id="fa9aac4028931969e4e43d5926f21c1c02b03737" translate="yes" xml:space="preserve">
          <source>Time zones</source>
          <target state="translated">时区</target>
        </trans-unit>
        <trans-unit id="25ea0fb6ef66b02b90f259085a72c5aa3a1cb38b" translate="yes" xml:space="preserve">
          <source>Time-out connect operations after this amount of seconds, if connects are OK within this time, then fine... This only aborts the connect phase. [Only works on unix-style/SIGALRM operating systems]</source>
          <target state="translated">超时连接操作过了这一秒,如果在这段时间内连接正常,那么就可以...这只是中止连接阶段。只适用于unix-style/SIGALRM操作系统】。</target>
        </trans-unit>
        <trans-unit id="7898ff5a29bdccadbf6ffe3af05c0479d1dfccc9" translate="yes" xml:space="preserve">
          <source>Time-out the read operation after this amount of seconds</source>
          <target state="translated">读取操作在此秒数后超时。</target>
        </trans-unit>
        <trans-unit id="3a383c209c07d7ddd4a20a832e5e3183c6735122" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
          <target state="translated">TimeOfDay</target>
        </trans-unit>
        <trans-unit id="931ede6287bc0e0bd7fe601fddba6e76758a6ca6" translate="yes" xml:space="preserve">
          <source>TimeOfDay &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">TimeOfDay &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1555a6cfeedd9ca84067267bcd651953c04210d9" translate="yes" xml:space="preserve">
          <source>TimeOfDay &lt;code&gt;tod&lt;/code&gt;</source>
          <target state="translated">TimeOfDay &lt;code&gt;tod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab9bed73cb84a17cfdff14b6f7c15cb12325d572" translate="yes" xml:space="preserve">
          <source>TimeZone &lt;code&gt;timezone&lt;/code&gt;</source>
          <target state="translated">时 &lt;code&gt;timezone&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fda33f37c23c6bf9d7fa6e3c06b399f2722e4e9" translate="yes" xml:space="preserve">
          <source>TimeZone &lt;code&gt;tz&lt;/code&gt;</source>
          <target state="translated">时区 &lt;code&gt;tz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="a05f35aebea6d90bfd4a149a3c110d0ba93cf063" translate="yes" xml:space="preserve">
          <source>Timestamp for the condition  &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25&quot;&gt;RFC2616 Section 14.25&lt;/a&gt;</source>
          <target state="translated">条件&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25&quot;&gt;RFC2616第14.25节的&lt;/a&gt;时间戳</target>
        </trans-unit>
        <trans-unit id="791214dda21a45673e6a00a407416e403372c00e" translate="yes" xml:space="preserve">
          <source>Timezones</source>
          <target state="translated">Timezones</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="c554ef7e0f768a7921e2d8ca33350a8183049302" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;cache&lt;/code&gt; is eager when evaluating elements. If calling front on the underlying range has a side effect, it will be observable before calling front on the actual cached range.  Furthermore, care should be taken composing &lt;code&gt;cache&lt;/code&gt; with &lt;a href=&quot;std_range#take&quot;&gt;&lt;code&gt;std.range.take&lt;/code&gt;&lt;/a&gt;. By placing &lt;code&gt;take&lt;/code&gt; before &lt;code&gt;cache&lt;/code&gt;, then &lt;code&gt;cache&lt;/code&gt; will be &quot;aware&quot; of when the range ends, and correctly stop caching elements when needed. If calling front has no side effect though, placing &lt;code&gt;take&lt;/code&gt; after &lt;code&gt;cache&lt;/code&gt; may yield a faster range.  Either way, the resulting ranges will be equivalent, but maybe not at the same cost or side effects.</source>
          <target state="translated">提示：评估元素时急于 &lt;code&gt;cache&lt;/code&gt; 。如果在基础范围上调用front有副作用，则在实际缓存的范围上调用front之前将是可以观察到的。此外，应注意使用&lt;a href=&quot;std_range#take&quot;&gt; &lt;code&gt;std.range.take&lt;/code&gt; &lt;/a&gt;组成 &lt;code&gt;cache&lt;/code&gt; 。通过将 &lt;code&gt;take&lt;/code&gt; 放在 &lt;code&gt;cache&lt;/code&gt; 之前，然后 &lt;code&gt;cache&lt;/code&gt; 将&amp;ldquo;知道&amp;rdquo;范围何时结束，并在需要时正确停止缓存元素。如果调用front没有副作用，则将 &lt;code&gt;take&lt;/code&gt; 放在 &lt;code&gt;cache&lt;/code&gt; 之后可能会产生更快的范围。无论哪种方式，结果范围都是相等的，但可能不会产生相同的成本或副作用。</target>
        </trans-unit>
        <trans-unit id="a22acb5aeb0a04605632e4e842da9793f03544b7" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;equal&lt;/code&gt; can itself be used as a predicate to other functions. This can be very useful when the element type of a range is itself a range. In particular, &lt;code&gt;equal&lt;/code&gt; can be its own predicate, allowing range of range (of range...) comparisons.</source>
          <target state="translated">提示： &lt;code&gt;equal&lt;/code&gt; 本身可以用作其他函数的谓词。当范围的元素类型本身是范围时，这将非常有用。特别地， &lt;code&gt;equal&lt;/code&gt; 可以是它自己的谓词，允许比较range的范围。</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="c5a0e0828626901459115ce06aafb77df7b91db7" translate="yes" xml:space="preserve">
          <source>Titlecase_Letter</source>
          <target state="translated">Titlecase_Letter</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="6494691e25f78cf9ccf69f1c60778c2c794c2372" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">到&lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="108e81f625c0fab42d496ad348b5d4bf286b22ec" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#FracSec&quot;&gt;&lt;code&gt;FracSec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">前往&lt;a href=&quot;#FracSec&quot;&gt; &lt;code&gt;FracSec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551da37cf37171dc3ce54406334d09a8cfda8b37" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#TickDuration&quot;&gt;&lt;code&gt;TickDuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">到&lt;a href=&quot;#TickDuration&quot;&gt; &lt;code&gt;TickDuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64a71b7026dcf6ae8a460197932fea36a34976f6" translate="yes" xml:space="preserve">
          <source>To access members of an aggregate, given a pointer to the aggregate is in a register, use the &lt;code&gt;.offsetof&lt;/code&gt; property of the qualified name of the member:</source>
          <target state="translated">要访问聚集的成员，给定聚集的指针位于寄存器中，请使用成员的合格名称的 &lt;code&gt;.offsetof&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="acccbbe3599b947ae29100cb34a4d4f21d373721" translate="yes" xml:space="preserve">
          <source>To access them, the following import is required:</source>
          <target state="translated">要访问它们,需要导入以下内容。</target>
        </trans-unit>
        <trans-unit id="e706ae3f9491e98dd5256ff2e4c4957c44c28316" translate="yes" xml:space="preserve">
          <source>To alias more than one thing at once, use &lt;a href=&quot;#AliasSeq&quot;&gt;&lt;code&gt;AliasSeq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要一次别名多个事物，请使用&lt;a href=&quot;#AliasSeq&quot;&gt; &lt;code&gt;AliasSeq&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39e9b604b80a0ec5108d41826ff96040f90f8ef1" translate="yes" xml:space="preserve">
          <source>To allocate multidimensional arrays, the declaration reads in the same order as the prefix array declaration order.</source>
          <target state="translated">要分配多维数组,声明的读取顺序与前缀数组声明顺序相同。</target>
        </trans-unit>
        <trans-unit id="6af61f245522dedf48b1b3d8a204655196724e93" translate="yes" xml:space="preserve">
          <source>To allocate the nested arrays, multiple arguments can be used:</source>
          <target state="translated">要分配嵌套的数组,可以使用多个参数。</target>
        </trans-unit>
        <trans-unit id="bf5996d93a7b5a9d8df4050814c45a9661fdd6d1" translate="yes" xml:space="preserve">
          <source>To avoid dynamic binding on member function call, insert base class name before the member function name. For example:</source>
          <target state="translated">为了避免成员函数调用时的动态绑定,在成员函数名称前插入基类名称。例如,在成员函数名称前插入基类名称。</target>
        </trans-unit>
        <trans-unit id="df138afd646bec9cd5ef16ca5a7a9ffa6dca6b3a" translate="yes" xml:space="preserve">
          <source>To avoid performance overhead, &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bi-directionality&lt;/a&gt; is only available when &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; are true.</source>
          <target state="translated">为避免性能开销，&lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;双向性&lt;/a&gt;仅在&lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt;为true 时可用。</target>
        </trans-unit>
        <trans-unit id="e1b64ed586a51e4f5bb9e2b8e69de6ea4cbf1eb9" translate="yes" xml:space="preserve">
          <source>To avoid this from happening, either</source>
          <target state="translated">为了避免这种情况的发生,要么</target>
        </trans-unit>
        <trans-unit id="fb6c2b246e5caf09e7ad4ac345e30c3e0c4946f9" translate="yes" xml:space="preserve">
          <source>To consider the base class's functions in the overload resolution process, use an</source>
          <target state="translated">为了在重载解析过程中考虑基类的功能,使用一个</target>
        </trans-unit>
        <trans-unit id="3cb5d4aaed3b2fe5d4443f21b6ff9f49e40d7fc2" translate="yes" xml:space="preserve">
          <source>To copy at most &lt;code&gt;n&lt;/code&gt; elements from a range, you may want to use &lt;a href=&quot;std_range#take&quot;&gt;&lt;code&gt;std.range.take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要从一个范围复制最多 &lt;code&gt;n&lt;/code&gt; 个元素，您可能需要使用&lt;a href=&quot;std_range#take&quot;&gt; &lt;code&gt;std.range.take&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d66375110d390ecdb959eb48abc4793e5606ed6b" translate="yes" xml:space="preserve">
          <source>To copy just those elements from a range that satisfy a predicate, use &lt;a href=&quot;#filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要仅复制满足谓词范围的那些元素，请使用&lt;a href=&quot;#filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a57c46e45190814579474a4cac7131c8e3ca8e36" translate="yes" xml:space="preserve">
          <source>To create a documented unit test just add three forward slashes before the unittest block, like this:</source>
          <target state="translated">要创建一个文档化的单元测试,只需在 unittest 块前加三个斜线,像这样。</target>
        </trans-unit>
        <trans-unit id="eeb898e0497caa20850f724cd4cb92b13730b597" translate="yes" xml:space="preserve">
          <source>To create a horizontal rule with hyphens, add spaces between the hyphens. Without the spaces they would be treated as the start or end of an &lt;a href=&quot;#embedded_code&quot;&gt;embedded code block&lt;/a&gt;. Note that any horizontal rule may contain spaces:</source>
          <target state="translated">要使用连字符创建水平线，请在连字符之间添加空格。如果没有空格，它们将被视为&lt;a href=&quot;#embedded_code&quot;&gt;嵌入式代码块&lt;/a&gt;的开始或结尾。请注意，任何水平尺都可以包含空格：</target>
        </trans-unit>
        <trans-unit id="bc19837608d956da40f53510498a517f1210860d" translate="yes" xml:space="preserve">
          <source>To customize the &lt;code&gt;Logger&lt;/code&gt; behavior, create a new &lt;code&gt;class&lt;/code&gt; that inherits from the abstract &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;class&lt;/code&gt;, and implements the &lt;code&gt;writeLogMsg&lt;/code&gt; method.</source>
          <target state="translated">要定制 &lt;code&gt;Logger&lt;/code&gt; 的行为，创建一个新的 &lt;code&gt;class&lt;/code&gt; 从抽象继承 &lt;code&gt;Logger&lt;/code&gt; &lt;code&gt;class&lt;/code&gt; ，并实现了 &lt;code&gt;writeLogMsg&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2abc1d47025179e8b25ad0d252e787e5f2f4b0e4" translate="yes" xml:space="preserve">
          <source>To deal with these possible errors, tedious error handling code must be added to each function call. If an error happened, code must be written to recover from the error, and the error must be reported to the user in some user friendly fashion. If an error cannot be handled locally, it must be explicitly propagated back to its caller. The long list of errno values needs to be converted into appropriate text to be displayed. Adding all the code to do this can consume a large part of the time spent coding a project - and still, if a new errno value is added to the runtime system, the old code can not properly display a meaningful error message.</source>
          <target state="translated">为了处理这些可能发生的错误,必须在每个函数调用中加入繁琐的错误处理代码。如果发生了错误,必须编写代码来从错误中恢复,并且必须以某种用户友好的方式将错误报告给用户。如果一个错误不能在本地处理,它必须显式地传播回其调用者。长长的errno值列表需要转换为适当的文本来显示。添加所有的代码来实现这一点,可能会消耗项目编码的大部分时间--而且,如果运行时系统中添加了新的errno值,旧的代码仍然无法正确显示有意义的错误信息。</target>
        </trans-unit>
        <trans-unit id="0840e11f513cf9d6a67586541ed4c39bc7f43411" translate="yes" xml:space="preserve">
          <source>To define how one type can be cast to another, define the &lt;code&gt;opCast&lt;/code&gt; template method, which is used as follows:</source>
          <target state="translated">要定义如何将一种类型转换为另一种类型，请定义 &lt;code&gt;opCast&lt;/code&gt; 模板方法，该方法如下使用：</target>
        </trans-unit>
        <trans-unit id="69db67f87737bda086a681af3ab5a4a2b512d66e" translate="yes" xml:space="preserve">
          <source>To distinguish between the type of the back reference a look-up of the back referenced character is necessary: An identifier back reference always points to a digit &lt;b&gt;0&lt;/b&gt; to &lt;b&gt;9&lt;/b&gt;, while a type back reference always points to a letter.</source>
          <target state="translated">为了区分反向引用的类型，必须对反向引用的字符进行查找：标识符反向引用始终指向数字&lt;b&gt;0&lt;/b&gt;到&lt;b&gt;9&lt;/b&gt;，而类型反向引用始终指向字母。</target>
        </trans-unit>
        <trans-unit id="04d9771dcd4d104db6559e0305a6f19443a680de" translate="yes" xml:space="preserve">
          <source>To do them all en masse:</source>
          <target state="translated">要把他们都集体做了。</target>
        </trans-unit>
        <trans-unit id="dcfefb9ac665ea68efebc3194f27ebac0436a51d" translate="yes" xml:space="preserve">
          <source>To ease debugging, in a &lt;a href=&quot;version#ConditionalStatement&quot;&gt;&lt;i&gt;ConditionalStatement&lt;/i&gt;&lt;/a&gt; controlled by a &lt;a href=&quot;version#DebugCondition&quot;&gt;&lt;i&gt;DebugCondition&lt;/i&gt;&lt;/a&gt;&lt;code&gt;@nogc&lt;/code&gt; functions can call functions that are not &lt;code&gt;@nogc&lt;/code&gt;.</source>
          <target state="translated">为减轻调试工作，在&lt;a href=&quot;version#ConditionalStatement&quot;&gt;&lt;i&gt;ConditionalStatement&lt;/i&gt;&lt;/a&gt;由控制&lt;a href=&quot;version#DebugCondition&quot;&gt;&lt;i&gt;DebugCondition&lt;/i&gt;&lt;/a&gt; &lt;code&gt;@nogc&lt;/code&gt; 函数可以调用不是函数 &lt;code&gt;@nogc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d4c7d82f37671d49bf06ba7162803fca2ebe085" translate="yes" xml:space="preserve">
          <source>To experiment with alternative allocators, set &lt;a href=&quot;#theAllocator&quot;&gt;&lt;code&gt;theAllocator&lt;/code&gt;&lt;/a&gt; for the current thread. For example, consider an application that allocates many 8-byte objects. These are not well supported by the default allocator, so a &lt;a href=&quot;std_experimental_allocator_building_blocks_free_list&quot;&gt;free list allocator&lt;/a&gt; would be recommended. To install one in &lt;code&gt;main&lt;/code&gt;, the application would use:</source>
          <target state="translated">要尝试使用其他分配器，&lt;a href=&quot;#theAllocator&quot;&gt; &lt;code&gt;theAllocator&lt;/code&gt; &lt;/a&gt;为当前线程设置Allocator。例如，考虑一个分配许多8字节对象的应用程序。默认分配器不很好地支持这些分配，因此建议使用&lt;a href=&quot;std_experimental_allocator_building_blocks_free_list&quot;&gt;自由列表分配器&lt;/a&gt;。要在 &lt;code&gt;main&lt;/code&gt; 中安装一个，应用程序将使用：</target>
        </trans-unit>
        <trans-unit id="8d9e12dc536b1565bc9fda436c93ff675e8dc213" translate="yes" xml:space="preserve">
          <source>To find the last occurrence of &lt;code&gt;needle&lt;/code&gt; in a &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional&lt;/a&gt;&lt;code&gt;haystack&lt;/code&gt;, call &lt;code&gt;find(retro(haystack), needle)&lt;/code&gt;. See &lt;a href=&quot;std_range#retro&quot;&gt;&lt;code&gt;std.range.retro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了找到最后一次出现 &lt;code&gt;needle&lt;/code&gt; 的&lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;双向&lt;/a&gt; &lt;code&gt;haystack&lt;/code&gt; ，呼叫 &lt;code&gt;find(retro(haystack), needle)&lt;/code&gt; 。请参阅&lt;a href=&quot;std_range#retro&quot;&gt; &lt;code&gt;std.range.retro&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="940d35064ca2c064467578facb6ad445a27bab6b" translate="yes" xml:space="preserve">
          <source>To gain more precise control over the logging process, additionally to overriding the &lt;code&gt;writeLogMsg&lt;/code&gt; method the methods &lt;code&gt;beginLogMsg&lt;/code&gt;, &lt;code&gt;logMsgPart&lt;/code&gt; and &lt;code&gt;finishLogMsg&lt;/code&gt; can be overridden.</source>
          <target state="translated">为了获得对日志记录过程的更精确控制，除了覆盖 &lt;code&gt;writeLogMsg&lt;/code&gt; 方法 &lt;code&gt;beginLogMsg&lt;/code&gt; ，还可以覆盖beginLogMsg， &lt;code&gt;logMsgPart&lt;/code&gt; 和 &lt;code&gt;finishLogMsg&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="266f2a903ad8aca0a8023659715c707ee628d78a" translate="yes" xml:space="preserve">
          <source>To get a &lt;code&gt;PosixTimeZone&lt;/code&gt;, call &lt;code&gt;PosixTimeZone.getTimeZone&lt;/code&gt; (which allows specifying the location the time zone files).</source>
          <target state="translated">要获取 &lt;code&gt;PosixTimeZone&lt;/code&gt; ，请调用 &lt;code&gt;PosixTimeZone.getTimeZone&lt;/code&gt; （它可以指定时区文件的位置）。</target>
        </trans-unit>
        <trans-unit id="2ed14e678985f0d95b56a32019f42872453c2e19" translate="yes" xml:space="preserve">
          <source>To get a &lt;code&gt;WindowsTimeZone&lt;/code&gt;, call &lt;code&gt;WindowsTimeZone.getTimeZone&lt;/code&gt;.</source>
          <target state="translated">要获取 &lt;code&gt;WindowsTimeZone&lt;/code&gt; ，请调用 &lt;code&gt;WindowsTimeZone.getTimeZone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a52fa8889b7712f63349220576c00248419ac6ec" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">要获得年份差异，请减去两个&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;的year属性。要获得以天或周为单位的差异，请减去&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;本身，并使用结果的&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。由于在月份和较小单位之间进行转换需要一个特定的日期（&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;没有），因此使用year和month属性获取月份之间的差异需要一些数学运算，因此这对于获取月份差异。</target>
        </trans-unit>
        <trans-unit id="611f6f04377a68cee3f9ad63b2b1775dac313cf8" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">要获得年份差异，请减去两个&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;的year属性。要获得以天或周为单位的差异，请减去&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;本身，并使用结果得到的&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。由于在月份和较小单位之间进行转换需要一个特定的日期（&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;没有），因此使用year和month属性获取月份之间的差异需要一些数学运算，因此这对于获取月份差异。</target>
        </trans-unit>
        <trans-unit id="ca114625afe6909751302b60256cce50a6455f6b" translate="yes" xml:space="preserve">
          <source>To get the difference in years, subtract the year property of two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s. To get the difference in days or weeks, subtract the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s themselves and use the &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; that results. Because converting between months and smaller units requires a specific date (which &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s don't have), getting the difference in months requires some math using both the year and month properties, so this is a convenience function for getting the difference in months.</source>
          <target state="translated">要获得年份差异，请减去两个&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的year属性。要获得以天或周为单位的差异，请减去&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;本身，并使用得到的&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;。由于在月份和较小的单位之间进行转换需要一个特定的日期（&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;没有），因此，使用year和month属性获取月份之间的差异需要一些数学运算，因此这对于获取月份差异。</target>
        </trans-unit>
        <trans-unit id="9044e06c13b847070ef5dcf4834092817fbca12b" translate="yes" xml:space="preserve">
          <source>To guarantee copying behavior, use the .dup property to ensure a unique array that can be resized. Also, one may use the &lt;code&gt;.capacity&lt;/code&gt; property to determine how many elements can be appended to the array without reallocating.</source>
          <target state="translated">为了保证复制行为，请使用.dup属性以确保可以调整大小的唯一数组。同样，可以使用 &lt;code&gt;.capacity&lt;/code&gt; 属性来确定在不重新分配的情况下可以将多少个元素附加到数组。</target>
        </trans-unit>
        <trans-unit id="233d724da932399f4e00f061e832a34896042f59" translate="yes" xml:space="preserve">
          <source>To implement the different containers both struct and class based approaches have been used. &lt;a href=&quot;std_container_util#make&quot;&gt;&lt;code&gt;std.container.util.make&lt;/code&gt;&lt;/a&gt; allows for uniform construction with either approach.</source>
          <target state="translated">为了实现不同的容器，已经使用了基于结构和基于类的方法。&lt;a href=&quot;std_container_util#make&quot;&gt; &lt;code&gt;std.container.util.make&lt;/code&gt; &lt;/a&gt;允许使用任一方法进行统一构造。</target>
        </trans-unit>
        <trans-unit id="ee9b559376db4a1e8468c6848a3ba5a71bc8dfb5" translate="yes" xml:space="preserve">
          <source>To improve the speed of the factorial function,</source>
          <target state="translated">为了提高因子函数的速度。</target>
        </trans-unit>
        <trans-unit id="4e375b9e257d51069f4250fe3867302e9a258fcf" translate="yes" xml:space="preserve">
          <source>To link D functions and libraries into C programs, it's necessary to only require the C runtime library to be linked in. This is accomplished by defining a subset of D that fits this requirement, called &lt;b&gt;BetterC&lt;/b&gt;.</source>
          <target state="translated">要将D函数和库链接到C程序，只需要链接C运行时库即可。这是通过定义一个满足此要求的D子集（称为&lt;b&gt;BetterC）来实现的&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="418e30d51bb596772e9d5629c8d43dd500ddc9a6" translate="yes" xml:space="preserve">
          <source>To maintain accuracy at values of x near 1.0, use normalDistribution(x) = 1.0 - normalDistribution(-x).</source>
          <target state="translated">为了保持x值接近1.0时的精度,使用normalDistribution(x)=1.0-normalDistribution(-x)。</target>
        </trans-unit>
        <trans-unit id="5b3b3d7bbc8b8e87f34fef0c04e823aed7dd8943" translate="yes" xml:space="preserve">
          <source>To make a D function accessible from C++, give it C++ linkage:</source>
          <target state="translated">要使一个D函数能从C++中访问,就给它C++链接。</target>
        </trans-unit>
        <trans-unit id="85053099cfb1e1260b205f5910c452e424126760" translate="yes" xml:space="preserve">
          <source>To make a copy of a container, use the &lt;code&gt;c.dup&lt;/code&gt; container primitive.</source>
          <target state="translated">要复制容器，请使用 &lt;code&gt;c.dup&lt;/code&gt; 容器原语。</target>
        </trans-unit>
        <trans-unit id="4330151dd0a4b250164d66c145c77b530d3ed205" translate="yes" xml:space="preserve">
          <source>To make both the return type and the method immutable, you can write:</source>
          <target state="translated">要使返回类型和方法都不可变,你可以写。</target>
        </trans-unit>
        <trans-unit id="57e902cb18fc9ae8488bd57a41a216b45b84b7c6" translate="yes" xml:space="preserve">
          <source>To make the return type immutable, you need to surround the return type with parentheses:</source>
          <target state="translated">要使返回类型不可变,需要用括号将返回类型包围起来。</target>
        </trans-unit>
        <trans-unit id="eb050bb6aba36c3b829cdba22de5651eceed94cb" translate="yes" xml:space="preserve">
          <source>To match the Objective-C semantics, &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;final&lt;/code&gt; methods are virtual. &lt;code&gt;static&lt;/code&gt; methods are overridable as well.</source>
          <target state="translated">为了匹配Objective-C语义， &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 方法是虚拟的。 &lt;code&gt;static&lt;/code&gt; 方法也是可重写的。</target>
        </trans-unit>
        <trans-unit id="399f378b17e04ab3e088842cfc946bfa37190fec" translate="yes" xml:space="preserve">
          <source>To maximize efficiency, the runtime always tries to resize the array in place to avoid extra copying. It will always do a copy if the new size is larger and the array was not allocated via the new operator or resizing in place would overwrite valid data in the array. For example:</source>
          <target state="translated">为了最大限度地提高效率,运行时总是试图在原地调整数组的大小,以避免额外的复制。如果新的大小比较大,而且数组没有通过新的操作符分配,或者原地调整大小会覆盖数组中的有效数据,它总是会进行复制。例如</target>
        </trans-unit>
        <trans-unit id="6e630a6f0fbc69f96409d719fe2bf8debbee2ea5" translate="yes" xml:space="preserve">
          <source>To memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call. For example, to transform the exponential-time Fibonacci implementation into a linear-time computation:</source>
          <target state="translated">要对递归函数进行备忘,只需插入备忘调用来代替普通的递归调用。例如,将指数时间的Fibonacci实现转化为线性时间的计算。</target>
        </trans-unit>
        <trans-unit id="3516e14bd92ad99d31558a33d40a58c99908579a" translate="yes" xml:space="preserve">
          <source>To output a backslash, simply use two backslashes in a row: &lt;code&gt;\\&lt;/code&gt;. Note that backslashes inside embedded or inline code do &lt;em&gt;not&lt;/em&gt; escape punctuation and are included in the output as-is. Backslashes before non-punctation are also included in the output as-is. For example, &lt;code&gt;C:\dmd2\bin\dmd.exe&lt;/code&gt; does not require escaping its embedded backslashes.</source>
          <target state="translated">要输出反斜杠，只需在一行中使用两个反斜杠： &lt;code&gt;\\&lt;/code&gt; 。请注意，嵌入式或内联代码中的反斜杠&lt;em&gt;不会&lt;/em&gt;转义标点符号，而是按原样包含在输出中。非标点之前的反斜杠也按原样包含在输出中。例如， &lt;code&gt;C:\dmd2\bin\dmd.exe&lt;/code&gt; 不需要转义其嵌入式反斜杠。</target>
        </trans-unit>
        <trans-unit id="8f1374001cf71d8c7f16d7eec671343030bcedf0" translate="yes" xml:space="preserve">
          <source>To overload &lt;code&gt;a[]&lt;/code&gt;, simply define &lt;code&gt;opIndex&lt;/code&gt; with no parameters:</source>
          <target state="translated">要重载 &lt;code&gt;a[]&lt;/code&gt; ，只需定义 &lt;code&gt;opIndex&lt;/code&gt; 带参数的opIndex：</target>
        </trans-unit>
        <trans-unit id="15d95aac44624f17ec16bbbfbc71490c6fbf287e" translate="yes" xml:space="preserve">
          <source>To overload array indexing of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">要重载形式为 &lt;code&gt;a[&lt;/code&gt; 数组索引</target>
        </trans-unit>
        <trans-unit id="000e88e7e58bbba47a3e6a8c3ea25f6d7d08d6b5" translate="yes" xml:space="preserve">
          <source>To parallelize the copying of a range with expensive to evaluate elements to an array, pass an identity function (a function that just returns whatever argument is provided to it) to &lt;code&gt;amap&lt;/code&gt;.  &lt;b&gt;Exception Handling&lt;/b&gt;:  When at least one exception is thrown from inside the map functions, the submission of additional &lt;code&gt;Task&lt;/code&gt; objects is terminated as soon as possible, in a non-deterministic manner. All currently executing or enqueued work units are allowed to complete. Then, all exceptions that were thrown from any work unit are chained using &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The order of the exception chaining is non-deterministic.</source>
          <target state="translated">要并行化具有昂贵的评估元素范围的复制到数组， &lt;code&gt;amap&lt;/code&gt; 标识函数（该函数仅返回提供给它的任何参数的函数）传递给amap。 &lt;b&gt;异常处理&lt;/b&gt;：当从map函数内部引发至少一个异常时，其他 &lt;code&gt;Task&lt;/code&gt; 对象的提交将以不确定性方式尽快终止。允许所有当前正在执行或排队的工作单元完成。然后，使用 &lt;code&gt;Throwable.next&lt;/code&gt; 链接从任何工作单元抛出的所有异常并重新抛出。异常链接的顺序是不确定的。</target>
        </trans-unit>
        <trans-unit id="87b4b285bca7df049293dca955a7cff806c39c54" translate="yes" xml:space="preserve">
          <source>To perform the mapping operation in place, provide the same range for the input and output range.</source>
          <target state="translated">要在原地进行映射操作,请为输入和输出范围提供相同的范围。</target>
        </trans-unit>
        <trans-unit id="b6f84739ea0309b309811ceae01cf81f2836b095" translate="yes" xml:space="preserve">
          <source>To prevent mutation, D offers the &lt;code&gt;immutable&lt;/code&gt; type qualifier. If all of a &lt;code&gt;pure&lt;/code&gt; function's parameters are &lt;code&gt;immutable&lt;/code&gt; or copied values without any indirections (e.g. &lt;code&gt;int&lt;/code&gt;), the type system guarantees no side effects.</source>
          <target state="translated">为了防止突变，D提供了 &lt;code&gt;immutable&lt;/code&gt; 类型限定符。如果所有 &lt;code&gt;pure&lt;/code&gt; 函数的参数都是 &lt;code&gt;immutable&lt;/code&gt; 或复制的值，而没有任何间接指示（例如 &lt;code&gt;int&lt;/code&gt; ），则类型系统保证没有副作用。</target>
        </trans-unit>
        <trans-unit id="510e8a37c94f1fddd48f494b45f9c445ac13386e" translate="yes" xml:space="preserve">
          <source>To replace all matches use &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要替换所有匹配项，请使用&lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32637bfed038dc3b07de78cef61a544d88ceed68" translate="yes" xml:space="preserve">
          <source>To replace only the first match use &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要仅替换第一个匹配项，请使用&lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d699e84d4ef2358f78c4907449972ca3c8ecaf0" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;color&lt;/code&gt; to &lt;code&gt;Color.yes&lt;/code&gt;, invoke the program with either &lt;code&gt;--color=yes&lt;/code&gt; or &lt;code&gt;--color yes&lt;/code&gt;.</source>
          <target state="translated">要将 &lt;code&gt;color&lt;/code&gt; 设置为 &lt;code&gt;Color.yes&lt;/code&gt; ，请使用 &lt;code&gt;--color=yes&lt;/code&gt; 或 &lt;code&gt;--color yes&lt;/code&gt; 调用程序。</target>
        </trans-unit>
        <trans-unit id="6bda9df29c966af1a72e8a5182df74509b8e721a" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;timeout&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, invoke the program with either &lt;code&gt;--timeout=5&lt;/code&gt; or &lt;code&gt;--timeout 5&lt;/code&gt;.</source>
          <target state="translated">要将 &lt;code&gt;timeout&lt;/code&gt; 设置为 &lt;code&gt;5&lt;/code&gt; ，请使用 &lt;code&gt;--timeout=5&lt;/code&gt; 或 &lt;code&gt;--timeout 5&lt;/code&gt; 调用程序。</target>
        </trans-unit>
        <trans-unit id="cd8216ab7d939932ec00d9d6f5006763dd329753" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;timeout&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, use either of the following: &lt;code&gt;--timeout=5&lt;/code&gt;, &lt;code&gt;--timeout 5&lt;/code&gt;, &lt;code&gt;--t=5&lt;/code&gt;, &lt;code&gt;--t 5&lt;/code&gt;, &lt;code&gt;-t5&lt;/code&gt;, or &lt;code&gt;-t 5&lt;/code&gt;. Forms such as &lt;code&gt;-timeout=5&lt;/code&gt; will be not accepted.  For more details about short options, refer also to the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7233a698292e0a276de835ff862d037b155c9056" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;timeout&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, use either of the following: &lt;code&gt;--timeout=5&lt;/code&gt;, &lt;code&gt;--timeout 5&lt;/code&gt;, &lt;code&gt;--t=5&lt;/code&gt;, &lt;code&gt;--t 5&lt;/code&gt;, or &lt;code&gt;-t5&lt;/code&gt;. Forms such as &lt;code&gt;-t 5&lt;/code&gt; and &lt;code&gt;-timeout=5&lt;/code&gt; will be not accepted.  For more details about short options, refer also to the next section.</source>
          <target state="translated">要设置 &lt;code&gt;timeout&lt;/code&gt; 到 &lt;code&gt;5&lt;/code&gt; ，使用下列的： &lt;code&gt;--timeout=5&lt;/code&gt; ， &lt;code&gt;--timeout 5&lt;/code&gt; ， &lt;code&gt;--t=5&lt;/code&gt; ， &lt;code&gt;--t 5&lt;/code&gt; ，或 &lt;code&gt;-t5&lt;/code&gt; 。 &lt;code&gt;-t 5&lt;/code&gt; 和 &lt;code&gt;-timeout=5&lt;/code&gt; 之类的格式将不被接受。有关简短选项的更多详细信息，另请参阅下一节。</target>
        </trans-unit>
        <trans-unit id="ddaae0a344d10b36be801991a765088949e60549" translate="yes" xml:space="preserve">
          <source>To set &lt;code&gt;verbose&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, invoke the program with either &lt;code&gt;--verbose&lt;/code&gt; or &lt;code&gt;--verbose=true&lt;/code&gt;.  To set &lt;code&gt;debugging&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, invoke the program with &lt;code&gt;--debugging=false&lt;/code&gt;.</source>
          <target state="translated">要将 &lt;code&gt;verbose&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，请使用 &lt;code&gt;--verbose&lt;/code&gt; 或 &lt;code&gt;--verbose=true&lt;/code&gt; 调用程序。要将 &lt;code&gt;debugging&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，请使用 &lt;code&gt;--debugging=false&lt;/code&gt; 调用程序。</target>
        </trans-unit>
        <trans-unit id="90aeb9b368ec13053b28da39579d017a147e76dd" translate="yes" xml:space="preserve">
          <source>To solve the fragile base class problem, instance variables in Objective-C has a dynamic offset. That means that the base class can change (add or remove instance variables) without the subclasses needing to recompile or relink. Thanks to this feature it's not necessary to declare instance variables when creating bindings to Objective-C classes.</source>
          <target state="translated">为了解决基类脆弱的问题,Objective-C中的实例变量有一个动态偏移。这意味着基类可以改变(添加或删除实例变量),而不需要子类重新编译或重新链接。由于这个特性,在创建Objective-C类的绑定时,不需要声明实例变量。</target>
        </trans-unit>
        <trans-unit id="120e7e0cecbea01188056698938dba51c73d2ca2" translate="yes" xml:space="preserve">
          <source>To understand what &lt;code&gt;gapWeightedSimilarity(s, t, lambda)&lt;/code&gt; computes, consider first the case &lt;code&gt;lambda = 1&lt;/code&gt; and the strings &lt;code&gt;s = [&quot;Hello&quot;, &quot;brave&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; and &lt;code&gt;t = [&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt;. In that case, &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; counts the following matches:</source>
          <target state="translated">要了解 &lt;code&gt;gapWeightedSimilarity(s, t, lambda)&lt;/code&gt; 计算的内容，请首先考虑 &lt;code&gt;lambda = 1&lt;/code&gt; 且字符串 &lt;code&gt;s = [&quot;Hello&quot;, &quot;brave&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; 和 &lt;code&gt;t = [&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;]&lt;/code&gt; 。在这种情况下， &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; 计算以下匹配项：</target>
        </trans-unit>
        <trans-unit id="94904fa76d4f11340da03fec0a15c494a85ffea1" translate="yes" xml:space="preserve">
          <source>To units</source>
          <target state="translated">至单位</target>
        </trans-unit>
        <trans-unit id="b3ba6419dc9ea2b78f83db771b45536f87338e59" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;isInstanceOf&lt;/code&gt; to check the identity of a template while inside of said template, use &lt;a href=&quot;#TemplateOf&quot;&gt;&lt;code&gt;TemplateOf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要在模板中使用 &lt;code&gt;isInstanceOf&lt;/code&gt; 检查模板的身份，请使用&lt;a href=&quot;#TemplateOf&quot;&gt; &lt;code&gt;TemplateOf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ccc24a097574057226e86500cf33d397fb42f61" translate="yes" xml:space="preserve">
          <source>To use a different comparison than &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;, pass a different operator string that can be used by &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, or pass in a function, delegate, functor, or any type where &lt;code&gt;less(a, b)&lt;/code&gt; results in a &lt;code&gt;bool&lt;/code&gt; value.</source>
          <target state="translated">使用比一个不同的比较 &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; ，传递可以通过使用不同的算子串&lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; &lt;/a&gt;，或通过在一个函数，委托，函子，或任何类型的，其中 &lt;code&gt;less(a, b)&lt;/code&gt; 中的结果一个 &lt;code&gt;bool&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="ec17d2b0393d701bb378fb92b5f34cc43ec1456a" translate="yes" xml:space="preserve">
          <source>To use it:</source>
          <target state="translated">要使用它。</target>
        </trans-unit>
        <trans-unit id="ccbeeee07e1df8ffe8c8184d16795dcbbad96d59" translate="yes" xml:space="preserve">
          <source>To use the registered GC, it's name must be specified gcopt runtime option, e.g. by passing &lt;em&gt;, --DRT-gcopt=gc:my_gc_name&lt;/em&gt; as application argument.</source>
          <target state="translated">要使用注册的GC，必须使用gcopt运行时选项指定其名称，例如，通过传递&lt;em&gt;--DRT-gcopt = gc：my_gc_name&lt;/em&gt;作为应用程序参数。</target>
        </trans-unit>
        <trans-unit id="66efb9234157955b960a3139060c665ce5882658" translate="yes" xml:space="preserve">
          <source>To use this template, it must first be instantiated with a specific type:</source>
          <target state="translated">要使用该模板,必须先用特定类型实例化。</target>
        </trans-unit>
        <trans-unit id="0773afb54ea37c47bd380cce3db76b12cb278887" translate="yes" xml:space="preserve">
          <source>To use, put the line: response_expand(&amp;amp;argc,&amp;amp;argv); as the first executable statement in main(int argc, char **argv). argc and argv are adjusted to be the new command line arguments after response file expansion.</source>
          <target state="translated">要使用，将以下行放入：response_expand（＆argc，＆argv）; 作为main（int argc，char ** argv）中的第一个可执行语句。响应文件扩展后，将argc和argv调整为新的命令行参数。</target>
        </trans-unit>
        <trans-unit id="6054d88f6fd53a5005771519db583793dcab79e9" translate="yes" xml:space="preserve">
          <source>To what precision is x equal to y?</source>
          <target state="translated">x等于y的精度是多少?</target>
        </trans-unit>
        <trans-unit id="fdebf667212089ea7017a4b5425a561bdb3a30b0" translate="yes" xml:space="preserve">
          <source>Todo</source>
          <target state="translated">Todo</target>
        </trans-unit>
        <trans-unit id="fca57aee253e291d0ee9aa5ecbb555afdc35567c" translate="yes" xml:space="preserve">
          <source>Token Strings</source>
          <target state="translated">代币字符串</target>
        </trans-unit>
        <trans-unit id="fed427b1f3d3ef7e65fc5054b2e5e854301b06b4" translate="yes" xml:space="preserve">
          <source>Token strings open with the characters &lt;code&gt;q&lt;/code&gt;&lt;code&gt;{&lt;/code&gt; and close with the token &lt;code&gt;}&lt;/code&gt;. In between must be valid D tokens. The &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens nest. The string is formed of all the characters between the opening and closing of the token string, including comments.</source>
          <target state="translated">令牌字符串以字符 &lt;code&gt;q&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; 打开，并以令牌 &lt;code&gt;}&lt;/code&gt; 关闭。在两者之间必须是有效的D令牌。的 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 令牌巢。该字符串由令牌字符串的开头和结尾之间的所有字符组成，包括注释。</target>
        </trans-unit>
        <trans-unit id="c38c6c1f3a2743f8626703abb302e403d20ff81c" translate="yes" xml:space="preserve">
          <source>Tokens</source>
          <target state="translated">Tokens</target>
        </trans-unit>
        <trans-unit id="052c92ab74e0edce8a8ddb051550d404ed7fea5b" translate="yes" xml:space="preserve">
          <source>Total Number Of Rows Modified</source>
          <target state="translated">修改的总行数</target>
        </trans-unit>
        <trans-unit id="acfc1c14180f3c75b37d492cbf0679b8f5397d5e" translate="yes" xml:space="preserve">
          <source>Trace handler</source>
          <target state="translated">跟踪处理程序</target>
        </trans-unit>
        <trans-unit id="339bd194ea0514f6931ef3cb54a8ab0164d4cdd4" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;core_internal_array_concat#d_arraycatnTX&quot;&gt;&lt;code&gt;core.internal.array.concat.d_arraycatnTX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">TraceGC封装在&lt;a href=&quot;core_internal_array_concat#d_arraycatnTX&quot;&gt; &lt;code&gt;core.internal.array.concat.d_arraycatnTX&lt;/code&gt; &lt;/a&gt;周围。</target>
        </trans-unit>
        <trans-unit id="d0e0642895405b7e1549bc202853dc5cb0187b5b" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;core_internal_array_core.internal.array.capacity#d_arraysetlengthT&quot;&gt;&lt;code&gt;core.internal.array.core.internal.array.capacity.d_arraysetlengthT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">TraceGC封装在&lt;a href=&quot;core_internal_array_core.internal.array.capacity#d_arraysetlengthT&quot;&gt; &lt;code&gt;core.internal.array.core.internal.array.capacity.d_arraysetlengthT&lt;/code&gt; &lt;/a&gt;周围。</target>
        </trans-unit>
        <trans-unit id="b368b80c6345f7eb3fde3e057ff304366850fb39" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;rt_array_appending_d_arrayappendctximpl#d_arrayappendcTX&quot;&gt;&lt;code&gt;rt.array.appending.d_arrayappendcTXImpl.d_arrayappendcTX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">TraceGC包装围绕&lt;a href=&quot;rt_array_appending_d_arrayappendctximpl#d_arrayappendcTX&quot;&gt; &lt;code&gt;rt.array.appending.d_arrayappendcTXImpl.d_arrayappendcTX&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80dd4794746522d5a6319b62ffeb07ebb7212a09" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around &lt;a href=&quot;rt_array_appending_d_arrayappendtimpl#d_arrayappendT&quot;&gt;&lt;code&gt;rt.array.appending.d_arrayappendTImpl.d_arrayappendT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">TraceGC包装围绕&lt;a href=&quot;rt_array_appending_d_arrayappendtimpl#d_arrayappendT&quot;&gt; &lt;code&gt;rt.array.appending.d_arrayappendTImpl.d_arrayappendT&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75a5d485e29e7339691a82c35666d01ee9e99be8" translate="yes" xml:space="preserve">
          <source>TraceGC wrapper around runtime hook &lt;code&gt;Hook&lt;/code&gt;.</source>
          <target state="translated">围绕运行时挂钩 &lt;code&gt;Hook&lt;/code&gt; 的 TraceGC包装器。</target>
        </trans-unit>
        <trans-unit id="968e231f347833476137cde0bb130f49fd1066a0" translate="yes" xml:space="preserve">
          <source>TraceHandler &lt;code&gt;h&lt;/code&gt;</source>
          <target state="translated">跟踪处理程序 &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40795f513f85788543dae6b9a0f0c645b802b300" translate="yes" xml:space="preserve">
          <source>TraceHandler &lt;strong id=&quot;rt_getTraceHandler&quot;&gt;rt_getTraceHandler&lt;/strong&gt;();</source>
          <target state="translated">TraceHandler &lt;strong id=&quot;rt_getTraceHandler&quot;&gt;rt_getTraceHandler&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="3ff2cf2928371330c202528a4ec623af7dd4183d" translate="yes" xml:space="preserve">
          <source>TraceInfo &lt;strong id=&quot;info&quot;&gt;info&lt;/strong&gt;;</source>
          <target state="translated">TraceInfo &lt;strong id=&quot;info&quot;&gt;信息&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="97acc1b59f9ec17c88715b436c8c28883bd4892f" translate="yes" xml:space="preserve">
          <source>Tracing And Profiling Functions</source>
          <target state="translated">追踪和剖析功能</target>
        </trans-unit>
        <trans-unit id="21b475fc378b9dfe253f756130d92a38d32baa27" translate="yes" xml:space="preserve">
          <source>Tracked Pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e37088abead19a42acc6c17545cb5db3148d64" translate="yes" xml:space="preserve">
          <source>Tracking progress:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f99f0c420682f802c163b96d0a0feb063b02f8" translate="yes" xml:space="preserve">
          <source>Tracking the ownership status of a pointer can be safely extended by adding the capability of temporarilly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94fe6610b8c5aab12f91b0905d8d39edb892d87" translate="yes" xml:space="preserve">
          <source>Tracks bytes currently allocated by this allocator. This number goes up and down as memory is allocated and deallocated, and is zero if the allocator currently has no active allocation.</source>
          <target state="translated">追踪该分配器当前分配的字节数。这个数字会随着内存的分配和重新分配而上下浮动,如果分配器当前没有主动分配,则为零。</target>
        </trans-unit>
        <trans-unit id="3ec8a086c7378a608bd7ab5887414689898832b0" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all &lt;code&gt;b.length - s&lt;/code&gt; with &lt;code&gt;b.length &amp;gt; s&lt;/code&gt; in calls of the form &lt;code&gt;realloc(b, s)&lt;/code&gt; that succeed (return &lt;code&gt;true&lt;/code&gt;). In per-call statistics, also unambiguously counts the bytes deallocated with &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">跟踪所有的总和 &lt;code&gt;b.length - s&lt;/code&gt; 与 &lt;code&gt;b.length &amp;gt; s&lt;/code&gt; 形式的调用 &lt;code&gt;realloc(b, s)&lt;/code&gt; 是成功（返回 &lt;code&gt;true&lt;/code&gt; ）。在每次呼叫统计中，也明确地计算了用 &lt;code&gt;deallocate&lt;/code&gt; 释放的字节数。</target>
        </trans-unit>
        <trans-unit id="b241e803ff9fd9ce02dd41f6d962d259eca7d1cc" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all &lt;code&gt;delta&lt;/code&gt; values in calls of the form &lt;code&gt;expand(b, delta)&lt;/code&gt; that succeed (return &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">在成功（返回 &lt;code&gt;true&lt;/code&gt; ）形式 &lt;code&gt;expand(b, delta)&lt;/code&gt; 调用中跟踪所有 &lt;code&gt;delta&lt;/code&gt; 值的总和。</target>
        </trans-unit>
        <trans-unit id="5008e18d38dabcd09c748f97cdb5eb01dccc1e39" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all bytes NOT moved as result of calls to &lt;code&gt;realloc&lt;/code&gt; that managed to reallocate in place. A large number (relative to &lt;code&gt; bytesAllocated&lt;/code&gt;) indicates that the application is expansion-intensive and is saving a good amount of moves. However, if this number is relatively small and &lt;code&gt;bytesSlack&lt;/code&gt; is high, it means the application is overallocating for little benefit.</source>
          <target state="translated">跟踪所有的总和字节则不会移动，调用的结果 &lt;code&gt;realloc&lt;/code&gt; 的是管理到位，以重新分配。较大的数字（相对于 &lt;code&gt; bytesAllocated&lt;/code&gt; ）表明应用程序是扩展密集型的，并且节省了大量的移动。但是，如果此数字相对较小并且 &lt;code&gt;bytesSlack&lt;/code&gt; 较高，则意味着应用程序在总体上获益不大。</target>
        </trans-unit>
        <trans-unit id="7955ac7f466b43052c0744fbaca4b335f62263c8" translate="yes" xml:space="preserve">
          <source>Tracks the sum of all bytes moved as a result of calls to &lt;code&gt;realloc&lt;/code&gt; that were unable to reallocate in place. A large number (relative to &lt;code&gt; bytesAllocated&lt;/code&gt;) indicates that the application should use larger preallocations.</source>
          <target state="translated">跟踪所有的总和字节移动，调用的结果 &lt;code&gt;realloc&lt;/code&gt; 的是无法在地方重新分配。较大的数字（相对于 &lt;code&gt; bytesAllocated&lt;/code&gt; ）指示应用程序应使用较大的预分配。</target>
        </trans-unit>
        <trans-unit id="faf9f30dc9aae03a78ac2b0d759eee7f02feabde" translate="yes" xml:space="preserve">
          <source>Tracks total cumulative bytes allocated by means of &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, and &lt;code&gt;reallocate&lt;/code&gt; (when resulting in an expansion). This number always grows and indicates allocation traffic. To compute bytes deallocated cumulatively, subtract &lt;code&gt;bytesUsed&lt;/code&gt; from &lt;code&gt;bytesAllocated&lt;/code&gt;.</source>
          <target state="translated">跟踪通过 &lt;code&gt;allocate&lt;/code&gt; ， &lt;code&gt;expand&lt;/code&gt; 和 &lt;code&gt;reallocate&lt;/code&gt; 分配的总累积字节数（导致扩展时）。此数字始终在增长，并指示分配流量。要计算累积释放的字节， &lt;code&gt;bytesUsed&lt;/code&gt; 从 &lt;code&gt;bytesAllocated&lt;/code&gt; 中减去bytesUsed。</target>
        </trans-unit>
        <trans-unit id="05e8d1a3538b3e90690cad906240b5fa54e138df" translate="yes" xml:space="preserve">
          <source>Trademarks</source>
          <target state="translated">Trademarks</target>
        </trans-unit>
        <trans-unit id="09fffdd1f186dcf09acdfe5f33b486db93c4b362" translate="yes" xml:space="preserve">
          <source>Traditionally, programs accepted single-letter options preceded by only one dash (e.g. &lt;code&gt;-t&lt;/code&gt;). &lt;code&gt;getopt&lt;/code&gt; accepts such parameters seamlessly. When used with a double-dash (e.g. &lt;code&gt;--t&lt;/code&gt;), a single-letter option behaves the same as a multi-letter option. When used with a single dash, a single-letter option is accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65c761b81d8b95898721c08b732f21414baa36d" translate="yes" xml:space="preserve">
          <source>Traditionally, programs accepted single-letter options preceded by only one dash (e.g. &lt;code&gt;-t&lt;/code&gt;). &lt;code&gt;getopt&lt;/code&gt; accepts such parameters seamlessly. When used with a double-dash (e.g. &lt;code&gt;--t&lt;/code&gt;), a single-letter option behaves the same as a multi-letter option. When used with a single dash, a single-letter option is accepted. If the option has a parameter, that must be &quot;stuck&quot; to the option without any intervening space or &quot;=&quot;:</source>
          <target state="translated">传统上，程序接受单字母选项，后接一个破折号（例如 &lt;code&gt;-t&lt;/code&gt; ）。 &lt;code&gt;getopt&lt;/code&gt; 无缝接受此类参数。与双破折号（例如 &lt;code&gt;--t&lt;/code&gt; ）一起使用时，单字母选项的行为与多字母选项相同。与单破折号一起使用时，将接受单字母选项。如果选项具有参数，则该参数必须&amp;ldquo;粘在&amp;rdquo;选项上，且中间没有空格或&amp;ldquo; =&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="32a79a3c4d4b7259d08b26cc56e7bb87a9fe9843" translate="yes" xml:space="preserve">
          <source>Trailing template parameters can be given default values:</source>
          <target state="translated">后面的模板参数可以给出默认值。</target>
        </trans-unit>
        <trans-unit id="c05d0571a965a586c4e7efe02429db2afdc8c356" translate="yes" xml:space="preserve">
          <source>Trailing_Jamo</source>
          <target state="translated">Trailing_Jamo</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="3eb508881f4d401ebe62236f9dc8c80c61228925" translate="yes" xml:space="preserve">
          <source>Traits are extensions to the language to enable programs, at compile time, to get at information internal to the compiler. This is also known as compile time reflection. It is done as a special, easily extended syntax (similar to Pragmas) so that new capabilities can be added as required.</source>
          <target state="translated">特征是对语言的扩展,使程序在编译时能够获得编译器内部的信息。这也被称为编译时反射。它是作为一种特殊的、易于扩展的语法(类似于Pragmas)来完成的,因此可以根据需要添加新的功能。</target>
        </trans-unit>
        <trans-unit id="45ce7caaed05d2b5c0efd3ebab2b970cdb17b248" translate="yes" xml:space="preserve">
          <source>TraitsExp &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt;;</source>
          <target state="translated">TraitsExp &lt;strong id=&quot;exp&quot;&gt;exp&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="776df5d3d02b2f2502c0ba9fde683a6ac4564118" translate="yes" xml:space="preserve">
          <source>Transfer ownership from a &lt;code&gt;Unique&lt;/code&gt; of a type that is convertible to our type.</source>
          <target state="translated">从可转换为我们类型的 &lt;code&gt;Unique&lt;/code&gt; 类型转移所有权。</target>
        </trans-unit>
        <trans-unit id="b3f957b52d56c1cbf2d25e123eda610314928a9b" translate="yes" xml:space="preserve">
          <source>Transfer ownership to a &lt;code&gt;Unique&lt;/code&gt; rvalue. Nullifies the current contents. Same as calling std.algorithm.move on it.</source>
          <target state="translated">将所有权转让给 &lt;code&gt;Unique&lt;/code&gt; 右值。清空当前内容。与在其上调用std.algorithm.move相同。</target>
        </trans-unit>
        <trans-unit id="1f1886aabb4342f3629dbcd769504a41bfa676c8" translate="yes" xml:space="preserve">
          <source>Transfers execution to this fiber object. The calling context will be suspended until the fiber calls Fiber.yield() or until it terminates via an unhandled exception.</source>
          <target state="translated">将执行转移到这个fiber对象。调用上下文将被暂停,直到光纤调用Fiber.yield()或通过一个未处理的异常终止。</target>
        </trans-unit>
        <trans-unit id="31251528682bcb8b77a91ffbd3b05ea524c5340e" translate="yes" xml:space="preserve">
          <source>Transfers ownership of the buffer to the caller.</source>
          <target state="translated">将缓冲区的所有权转移给调用者。</target>
        </trans-unit>
        <trans-unit id="188eeca51b370b3f079cb0e0ef0721398bd7bd93" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;path&lt;/code&gt; into a path relative to &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;path&lt;/code&gt; 转换为相对于 &lt;code&gt;base&lt;/code&gt; 的路径。</target>
        </trans-unit>
        <trans-unit id="00ded035b85d9ff7c01b323b06df130cfc1720ab" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;path&lt;/code&gt; into an absolute path.</source>
          <target state="translated">将 &lt;code&gt;path&lt;/code&gt; 转换为绝对路径。</target>
        </trans-unit>
        <trans-unit id="34fc8e092bab0ba38ba7f911f332353c9a7c0772" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;string&lt;/code&gt; representing an expression into a binary function. The &lt;code&gt;string&lt;/code&gt; must either use symbol names &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as the parameters or provide the symbols via the &lt;code&gt;parm1Name&lt;/code&gt; and &lt;code&gt;parm2Name&lt;/code&gt; arguments.</source>
          <target state="translated">将表示表达式的 &lt;code&gt;string&lt;/code&gt; 转换为二进制函数。该 &lt;code&gt;string&lt;/code&gt; 必须使用符号名称 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 作为参数，或者通过 &lt;code&gt;parm1Name&lt;/code&gt; 和 &lt;code&gt;parm2Name&lt;/code&gt; 参数提供符号。</target>
        </trans-unit>
        <trans-unit id="5e4574331dd9213dff75e0c56ce82cdfa938b199" translate="yes" xml:space="preserve">
          <source>Transforms a &lt;code&gt;string&lt;/code&gt; representing an expression into a unary function. The &lt;code&gt;string&lt;/code&gt; must either use symbol name &lt;code&gt;a&lt;/code&gt; as the parameter or provide the symbol via the &lt;code&gt;parmName&lt;/code&gt; argument.</source>
          <target state="translated">将表示表达式的 &lt;code&gt;string&lt;/code&gt; 转换为一元函数。该 &lt;code&gt;string&lt;/code&gt; 必须使用符号名称 &lt;code&gt;a&lt;/code&gt; 作为参数，或者通过 &lt;code&gt;parmName&lt;/code&gt; 参数提供符号。</target>
        </trans-unit>
        <trans-unit id="7b88afb73f270a00af5effe51e0f8272f4aa3e3a" translate="yes" xml:space="preserve">
          <source>Translate init to an &lt;code&gt;Expression&lt;/code&gt; in order to infer the type.</source>
          <target state="translated">将init转换为 &lt;code&gt;Expression&lt;/code&gt; 以便推断类型。</target>
        </trans-unit>
        <trans-unit id="959a6d1def925aa5efa951960e2388ce3ff0f34b" translate="yes" xml:space="preserve">
          <source>Translate init to an &lt;code&gt;Expression&lt;/code&gt;.</source>
          <target state="translated">将init转换为 &lt;code&gt;Expression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b87d9bdcb57690f52a1f26d8df3d98e87cf8b7e" translate="yes" xml:space="preserve">
          <source>Translates &lt;code&gt;path&lt;/code&gt; into a relative path.</source>
          <target state="translated">将 &lt;code&gt;path&lt;/code&gt; 转换为相对路径。</target>
        </trans-unit>
        <trans-unit id="98dc0425ab3f9caa6b04fd152b154f235170a331" translate="yes" xml:space="preserve">
          <source>Translation to D of Linux's melf.h</source>
          <target state="translated">将Linux的melf.h翻译成D。</target>
        </trans-unit>
        <trans-unit id="a4f515edfc4806822304c5e5ba93f1584400280b" translate="yes" xml:space="preserve">
          <source>Transmission Control Protocol</source>
          <target state="translated">传输控制协议</target>
        </trans-unit>
        <trans-unit id="65ee3b2fd39b9602bb0e6c467c899854326f9080" translate="yes" xml:space="preserve">
          <source>Transmission Control Protocol level</source>
          <target state="translated">传输控制协议级别</target>
        </trans-unit>
        <trans-unit id="392746932775e052b533e7404ac34fc0d43420a8" translate="yes" xml:space="preserve">
          <source>Transport And Map Symbols</source>
          <target state="translated">运输和地图符号</target>
        </trans-unit>
        <trans-unit id="bb1493e21daf9bc01d2c8bbab57c14f37d6e777e" translate="yes" xml:space="preserve">
          <source>Transposed!(RangeOfRanges, opt) &lt;strong id=&quot;transposed&quot;&gt;transposed&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr)</source>
          <target state="translated">（RangeOfRanges，opt）&lt;strong id=&quot;transposed&quot;&gt;转置&lt;/strong&gt;（TransverseOptions opt = TransverseOptions.assumeJagged，RangeOfRanges）（RangeOfRanges rr）</target>
        </trans-unit>
        <trans-unit id="2cb4af12ae00a70b772cd041efc803dad1d5d955" translate="yes" xml:space="preserve">
          <source>Transposes a range of ranges.</source>
          <target state="translated">转移范围的范围。</target>
        </trans-unit>
        <trans-unit id="4bca179998de8185466d7b4948059e2b6d46a32a" translate="yes" xml:space="preserve">
          <source>Transversal!(RangeOfRanges, opt) &lt;strong id=&quot;transversal&quot;&gt;transversal&lt;/strong&gt;(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr, size_t n);</source>
          <target state="translated">横向（RangeOfRanges，opt）&lt;strong id=&quot;transversal&quot;&gt;横向&lt;/strong&gt;（TransverseOptions opt = TransverseOptions.assumeJagged，RangeOfRanges）（RangeOfRanges rr，size_t n）;</target>
        </trans-unit>
        <trans-unit id="89cf6770d26bcadaba07c91c703d1d100d7ecf19" translate="yes" xml:space="preserve">
          <source>Treap container for internal usage.</source>
          <target state="translated">内部使用的Treap容器。</target>
        </trans-unit>
        <trans-unit id="0a9f92517de5b94ca2202e73bfb4ff1ae0e96219" translate="yes" xml:space="preserve">
          <source>Treat wildcard bind as AF_INET6-only</source>
          <target state="translated">将通配符绑定处理为只绑定AF_INET6</target>
        </trans-unit>
        <trans-unit id="2b931f6f03ddf3f11b6a931c301cd688e5837818" translate="yes" xml:space="preserve">
          <source>Treatment of invalid UTF encodings is implementation defined.</source>
          <target state="translated">无效UTF编码的处理方法是在实施中定义的。</target>
        </trans-unit>
        <trans-unit id="7ca6b4d5d472cc8ae3e80819b582f65c3b7ce26a" translate="yes" xml:space="preserve">
          <source>Triangular numbers, using function in lambda form:</source>
          <target state="translated">三角形数,使用函数的lambda形式。</target>
        </trans-unit>
        <trans-unit id="9b543ca20b4da0104d2324c842cb2ec287022816" translate="yes" xml:space="preserve">
          <source>Trie</source>
          <target state="translated">Trie</target>
        </trans-unit>
        <trans-unit id="80d0235fc8480eef2ad4552832fe178049a6c3b3" translate="yes" xml:space="preserve">
          <source>Tries to receive but will give up if no matches arrive within duration. Won't wait at all if provided &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; is negative.</source>
          <target state="translated">尝试接收，但如果在持续时间内未找到匹配项则放弃。如果提供的&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;为负，则根本不会等待。</target>
        </trans-unit>
        <trans-unit id="c45198e3a1cef5be9e9ea6378e5c328265a866c6" translate="yes" xml:space="preserve">
          <source>Trigger Name Table Name</source>
          <target state="translated">触发器名称 表名称</target>
        </trans-unit>
        <trans-unit id="bcd455ee5ad5e27e2fed7e5f2b4d193ba5b2dc98" translate="yes" xml:space="preserve">
          <source>Trigonometric functions on complex numbers.</source>
          <target state="translated">复数上的三角函数。</target>
        </trans-unit>
        <trans-unit id="89225146f512abd9863323c7f96ee652306f95de" translate="yes" xml:space="preserve">
          <source>Trigonometry</source>
          <target state="translated">Trigonometry</target>
        </trans-unit>
        <trans-unit id="9324b1be3eab89aaa4331826e321fe950cd6f28d" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type directly embedded in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate assignment. Elaborate assignments are introduced by defining &lt;code&gt;opAssign(typeof(this))&lt;/code&gt; or &lt;code&gt;opAssign(ref typeof(this))&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt; or when there is a compiler-generated &lt;code&gt;opAssign&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;S&lt;/code&gt; 或直接嵌入在 &lt;code&gt;S&lt;/code&gt; 表示形式中的任何类型定义了详细的赋值，则为true 。通过为 &lt;code&gt;struct&lt;/code&gt; 或在有编译器生成的 &lt;code&gt;opAssign&lt;/code&gt; 时定义 &lt;code&gt;opAssign(typeof(this))&lt;/code&gt; 或 &lt;code&gt;opAssign(ref typeof(this))&lt;/code&gt; 来引入精心分配。</target>
        </trans-unit>
        <trans-unit id="435f68d9ae71393e298d71580ab5403b39c6eeb4" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type directly embedded in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate destructor. Elaborate destructors are introduced by defining &lt;code&gt;~this()&lt;/code&gt; for a &lt;code&gt; struct&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;S&lt;/code&gt; 或直接嵌入在 &lt;code&gt;S&lt;/code&gt; 表示形式中的任何类型定义复杂的析构函数，则为true 。通过为 &lt;code&gt; struct&lt;/code&gt; 定义 &lt;code&gt;~this()&lt;/code&gt; 来引入精心构造的析构函数。</target>
        </trans-unit>
        <trans-unit id="a05d6bcd95b9d55e986b0af7bf4aba60806b34ed" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type embedded directly in the representation of &lt;code&gt;S&lt;/code&gt; defines an elaborate copy constructor. Elaborate copy constructors are introduced by defining &lt;code&gt;this(this)&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;S&lt;/code&gt; 或直接嵌入到 &lt;code&gt;S&lt;/code&gt; 表示形式中的任何类型定义了复杂的复制构造函数，则为true 。通过为 &lt;code&gt;struct&lt;/code&gt; 定义 &lt;code&gt;this(this)&lt;/code&gt; 来引入复杂的复制构造函数。</target>
        </trans-unit>
        <trans-unit id="db144774838df48d1aab2237df1c1431f648dde1" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;S&lt;/code&gt; or any type embedded directly in the representation of &lt;code&gt;S&lt;/code&gt; defines elaborate move semantics. Elaborate move semantics are introduced by defining &lt;code&gt;opPostMove(ref typeof(this))&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;S&lt;/code&gt; 或直接嵌入在 &lt;code&gt;S&lt;/code&gt; 表示形式中的任何类型定义了详尽的移动语义，则为true 。通过为 &lt;code&gt;struct&lt;/code&gt; 定义 &lt;code&gt;opPostMove(ref typeof(this))&lt;/code&gt; 来引入详尽的移动语义。</target>
        </trans-unit>
        <trans-unit id="83286feea43cbdff092efa76ecf7b71ba2f88e52" translate="yes" xml:space="preserve">
          <source>True if output is already ordered</source>
          <target state="translated">如果输出已经排序,则为真</target>
        </trans-unit>
        <trans-unit id="a07b7fa9f3e40c77f1c67f20db579672485bc6b7" translate="yes" xml:space="preserve">
          <source>True if the element existed and was successfully removed, false otherwise.</source>
          <target state="translated">如果该元素存在并被成功删除,则为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="9ce4971f7bab09ad8525733035042183aaa85004" translate="yes" xml:space="preserve">
          <source>True if the instance is stopped. A stopped instance is not usable.</source>
          <target state="translated">如果实例被停止,则为真。停止的实例是不可用的。</target>
        </trans-unit>
        <trans-unit id="a4d0aeb9232f48bb1fab12af59602ee0a168f2c0" translate="yes" xml:space="preserve">
          <source>True if this object contains valid extended grapheme cluster. Decoding primitives of this module always return a valid &lt;code&gt;Grapheme&lt;/code&gt;.</source>
          <target state="translated">如果此对象包含有效的扩展字素簇，则为true。此模块的解码原语始终返回有效的 &lt;code&gt;Grapheme&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="741d78e7c1f0bffb06939bcb7022d56f2f3604a6" translate="yes" xml:space="preserve">
          <source>True if this set doesn't contain any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">如果此集合不包含任何&lt;a href=&quot;#Code%20point&quot;&gt;代码点，&lt;/a&gt;则为true 。</target>
        </trans-unit>
        <trans-unit id="a7044bfa031ab131bad87130e1755ca8c06a8fda" translate="yes" xml:space="preserve">
          <source>True when the archive is in Zip64 format.</source>
          <target state="translated">当存档为Zip64格式时为真。</target>
        </trans-unit>
        <trans-unit id="874ffa7aabdfbf0f6814728e49d1e00d8b409174" translate="yes" xml:space="preserve">
          <source>True when the archive is in Zip64 format. Set this to true to force building a Zip64 archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1974cd2786d3cb97b6da102856265950ee454dc" translate="yes" xml:space="preserve">
          <source>True, when a format specifier is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcab3708f7050161a4f235596fffc4adce59593e" translate="yes" xml:space="preserve">
          <source>True, when the archive is forced to be build in Zip64 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97e9325300bbea12fb2d470b8ed9009e1a25de0" translate="yes" xml:space="preserve">
          <source>True, when the archive is in Zip64 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9be005b0435403e870851df7d4131f3a0109ac9" translate="yes" xml:space="preserve">
          <source>Trusted Functions</source>
          <target state="translated">受信功能</target>
        </trans-unit>
        <trans-unit id="40f12844940629afacea122912b44fee54a96dc6" translate="yes" xml:space="preserve">
          <source>Trusted functions are covariant with safe or system functions.</source>
          <target state="translated">可信函数与安全函数或系统函数是相通的。</target>
        </trans-unit>
        <trans-unit id="b81cf6c642ef243859e62c2673b1273c1506df41" translate="yes" xml:space="preserve">
          <source>Trusted functions are guaranteed to not exhibit any undefined behavior if called by a safe function. Furthermore, calls to trusted functions cannot lead to undefined behavior in &lt;code&gt;@safe&lt;/code&gt; code that is executed afterwards. It is the responsibility of the programmer to ensure that these guarantees are upheld.</source>
          <target state="translated">如果安全函数调用了可信函数，则保证它们不会表现出任何未定义的行为。此外，对受信任函数的调用不会导致随后执行的 &lt;code&gt;@safe&lt;/code&gt; 代码中未定义的行为。程序员有责任确保遵守这些保证。</target>
        </trans-unit>
        <trans-unit id="e99ece345b7d4461848926cc1472e577d410e5e4" translate="yes" xml:space="preserve">
          <source>Trusted functions are marked with the &lt;code&gt;@trusted&lt;/code&gt; attribute.</source>
          <target state="translated">可信函数用 &lt;code&gt;@trusted&lt;/code&gt; 属性标记。</target>
        </trans-unit>
        <trans-unit id="44bf3c1616a6357f7a131b6c0a39fc313c94e84c" translate="yes" xml:space="preserve">
          <source>Trusted functions may call safe, trusted, or system functions.</source>
          <target state="translated">可信函数可以调用安全、可信或系统函数。</target>
        </trans-unit>
        <trans-unit id="459c8d9a1e6d3847007459ddd42920c4db61b906" translate="yes" xml:space="preserve">
          <source>Truth table for logical operations</source>
          <target state="translated">逻辑运算的真值表</target>
        </trans-unit>
        <trans-unit id="13da7fbcb3f25e75b715c9fd87fc1fcc65959500" translate="yes" xml:space="preserve">
          <source>Try Statement</source>
          <target state="translated">尝试声明</target>
        </trans-unit>
        <trans-unit id="1ed4257452c884a8b0797028299d6b533a605ed8" translate="yes" xml:space="preserve">
          <source>Try to canonically compose 2 &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt;. Returns the composed &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; if they do compose and dchar.init otherwise.</source>
          <target state="translated">尝试规范地组成2个&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;。如果组成，则返回组成的&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;，否则返回dchar.init。</target>
        </trans-unit>
        <trans-unit id="af1dc631a797cf3323aa1ab6b455b4f41ff959a7" translate="yes" xml:space="preserve">
          <source>Try to compose hangul syllable out of a leading consonant (&lt;code&gt;lead&lt;/code&gt;), a &lt;code&gt;vowel&lt;/code&gt; and optional &lt;code&gt;trailing&lt;/code&gt; consonant jamos.</source>
          <target state="translated">尝试用前置辅音（ &lt;code&gt;lead&lt;/code&gt; ）， &lt;code&gt;vowel&lt;/code&gt; 和可选的 &lt;code&gt;trailing&lt;/code&gt; 辅音来组成汉字音节。</target>
        </trans-unit>
        <trans-unit id="2f882d1c819b2be8fca22d9247747ab281b24bcf" translate="yes" xml:space="preserve">
          <source>Try to get arg as a type.</source>
          <target state="translated">试着把arg作为一个类型。</target>
        </trans-unit>
        <trans-unit id="4cb5c2463fdeee729189be2318f4a45f82417dad" translate="yes" xml:space="preserve">
          <source>Try to run semantic routines. If they fail, return NULL.</source>
          <target state="translated">尝试运行语义例程。如果失败,返回NULL。</target>
        </trans-unit>
        <trans-unit id="2e3437da5d7c211579a17d9d89d77ab06ca5cfe0" translate="yes" xml:space="preserve">
          <source>Try to stop forgetting to remove the breakpoints from release builds.</source>
          <target state="translated">尽量不要再忘记从版本构建中删除断点。</target>
        </trans-unit>
        <trans-unit id="bd89ac0e2f8d21f48d2dd844d0cfaadc52595afa" translate="yes" xml:space="preserve">
          <source>TryFinallyStatement &lt;strong id=&quot;tf&quot;&gt;tf&lt;/strong&gt;;</source>
          <target state="translated">TryFinallyStatement &lt;strong id=&quot;tf&quot;&gt;tf&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="7b1fdcae82a3bda8500a782276a90907df015b0b" translate="yes" xml:space="preserve">
          <source>TryStatement</source>
          <target state="translated">TryStatement</target>
        </trans-unit>
        <trans-unit id="db36ec316b7f2d3519063434cfdeb6b15e62e78d" translate="yes" xml:space="preserve">
          <source>Trying to use returned value will result in a &quot;Symbol Undefined&quot; error at link time.</source>
          <target state="translated">试图使用返回的值将在链接时导致 &quot;Symbol Undefined &quot;错误。</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="81493a4efae126007a86642029f330ea19b00d39" translate="yes" xml:space="preserve">
          <source>Tuple containing the remainder portions of r1 and r2 that were not swapped</source>
          <target state="translated">包含r1和r2未被交换的剩余部分的元组。</target>
        </trans-unit>
        <trans-unit id="0334a3ee71c30886045ce944919d843672b82a98" translate="yes" xml:space="preserve">
          <source>Tuple of result identifier (possibly null) and statement. This is used to store out contracts: out(id){ ensure }</source>
          <target state="translated">结果标识符(可能为空)和语句的元组。这是用来存储输出合同的:out(id){ensure }。</target>
        </trans-unit>
        <trans-unit id="fe605913e40c1b2d66822716dc9acacaef59b4a5" translate="yes" xml:space="preserve">
          <source>Tuple of values, for example &lt;code&gt;Tuple!(int, string)&lt;/code&gt; is a record that stores an &lt;code&gt;int&lt;/code&gt; and a &lt;code&gt;string&lt;/code&gt;. &lt;code&gt;Tuple&lt;/code&gt; can be used to bundle values together, notably when returning multiple values from a function. If &lt;code&gt;obj&lt;/code&gt; is a &lt;code&gt;Tuple&lt;/code&gt;, the individual members are accessible with the syntax &lt;code&gt;obj[0]&lt;/code&gt; for the first field, &lt;code&gt;obj[1]&lt;/code&gt; for the second, and so on.</source>
          <target state="translated">值的元组，例如 &lt;code&gt;Tuple!(int, string)&lt;/code&gt; 是存储 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 的记录。 &lt;code&gt;Tuple&lt;/code&gt; 可用于将值捆绑在一起，特别是在从函数返回多个值时。如果 &lt;code&gt;obj&lt;/code&gt; 是 &lt;code&gt;Tuple&lt;/code&gt; ，则可以使用第一个字段的语法 &lt;code&gt;obj[0]&lt;/code&gt; ，第二个字段的 &lt;code&gt;obj[1]&lt;/code&gt; 来访问单个成员，依此类推。</target>
        </trans-unit>
        <trans-unit id="0a9986e9aa2ae5162b29264e46abc7e827c1fef4" translate="yes" xml:space="preserve">
          <source>Tuple with the first element being the minimal amount of edits to transform s into t and the second element being the sequence of edits to effect this transformation.  Allocates GC memory for the returned EditOp[] array.</source>
          <target state="translated">元组,第一个元素是将s转换为t的最小编辑量,第二个元素是实现这一转换的编辑序列。为返回的EditOp[]数组分配GC内存。</target>
        </trans-unit>
        <trans-unit id="ca82eca51bdda72eb0ed74065cca566ee0b72807" translate="yes" xml:space="preserve">
          <source>Tuple!(ElementType!Range, size_t) &lt;strong id=&quot;maxCount&quot;&gt;maxCount&lt;/strong&gt;(alias pred = &quot;a &amp;lt; b&quot;, Range)(Range range)</source>
          <target state="translated">元组（ElementType！Range，size_t）&lt;strong id=&quot;maxCount&quot;&gt;maxCount&lt;/strong&gt;（alias pred =&amp;ldquo; a &amp;lt;b&amp;rdquo;，Range）（范围）</target>
        </trans-unit>
        <trans-unit id="c94a9ad6dc26bde095208b9742dea8d55cd74e36" translate="yes" xml:space="preserve">
          <source>Tuple!(ElementType!Range, size_t) &lt;strong id=&quot;minCount&quot;&gt;minCount&lt;/strong&gt;(alias pred = &quot;a &amp;lt; b&quot;, Range)(Range range)</source>
          <target state="translated">元组（ElementType！Range，size_t）&lt;strong id=&quot;minCount&quot;&gt;minCount&lt;/strong&gt;（alias pred =&amp;ldquo; a &amp;lt;b&amp;rdquo;，Range）（范围）</target>
        </trans-unit>
        <trans-unit id="5b8d3e9bf7e07ed5d350fa5b6dce75fa73629a67" translate="yes" xml:space="preserve">
          <source>Tuple!(InputRange1, InputRange2) &lt;strong id=&quot;moveSome&quot;&gt;moveSome&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">元组！（InputRange1，InputRange2）&lt;strong id=&quot;moveSome&quot;&gt;moveSome&lt;/strong&gt;（InputRange1，InputRange2）（InputRange1 src，InputRange2 tgt）</target>
        </trans-unit>
        <trans-unit id="06252b12aadc6855e3f6a48094435d5ba0fef2ac" translate="yes" xml:space="preserve">
          <source>Tuple!(InputRange1, InputRange2) &lt;strong id=&quot;swapRanges&quot;&gt;swapRanges&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 r1, InputRange2 r2)</source>
          <target state="translated">元组！（InputRange1，InputRange2）&lt;strong id=&quot;swapRanges&quot;&gt;swapRanges&lt;/strong&gt;（InputRange1，InputRange2）（InputRange1 r1，InputRange2 r2）</target>
        </trans-unit>
        <trans-unit id="bce2cc2678db91fbec2284d40957048f616f80c5" translate="yes" xml:space="preserve">
          <source>Tuple!(Module, &quot;module_&quot;, Diagnostics, &quot;diagnostics&quot;) &lt;strong id=&quot;parseModule&quot;&gt;parseModule&lt;/strong&gt;(AST = ASTCodegen)(const(char)[] fileName, const(char)[] code = null, DiagnosticReporter diagnosticReporter = defaultDiagnosticReporter);</source>
          <target state="translated">元组！（模块，&amp;ldquo;模块_&amp;rdquo;，诊断，&amp;ldquo;诊断&amp;rdquo;）&lt;strong id=&quot;parseModule&quot;&gt;parseModule&lt;/strong&gt;（AST = ASTCodegen）（const（char）[] fileName，const（char）[] code = null，DiagnosticReporter diagnosticReporter = defaultDiagnosticReporter）;</target>
        </trans-unit>
        <trans-unit id="ecf8ee3baa7b9c5aeb7e04fdf957e2203fbab0aa" translate="yes" xml:space="preserve">
          <source>Tuple!(Range, size_t) &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range, Ranges...)(Range haystack, Ranges needles)</source>
          <target state="translated">元组！（范围，size_t）&lt;strong id=&quot;find&quot;&gt;查找&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，范围，范围...）（范围干草堆，范围针）</target>
        </trans-unit>
        <trans-unit id="95cc77bd73a8dcdc8783b1903366dc167f6f0405" translate="yes" xml:space="preserve">
          <source>Tuple!(Range1, Range2) &lt;strong id=&quot;mismatch&quot;&gt;mismatch&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range1, Range2)(Range1 r1, Range2 r2)</source>
          <target state="translated">元组！（Range1，Range2）&lt;strong id=&quot;mismatch&quot;&gt;不匹配&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，Range1，Range2）（Range1 r1，Range2 r2）</target>
        </trans-unit>
        <trans-unit id="000cf2a61823c3534d53f39458b33b8bdccf2670" translate="yes" xml:space="preserve">
          <source>Tuple!(T, &quot;x&quot;, Unqual!(ReturnType!DF), &quot;y&quot;, T, &quot;error&quot;) &lt;strong id=&quot;findLocalMin&quot;&gt;findLocalMin&lt;/strong&gt;(T, DF)(scope DF f, in T ax, in T bx, in T relTolerance = sqrt(T.epsilon), in T absTolerance = sqrt(T.epsilon))</source>
          <target state="translated">Tuple！（T，&amp;ldquo; x&amp;rdquo;，不等于！（ReturnType！DF），&amp;ldquo; y&amp;rdquo;，T，&amp;ldquo;错误&amp;rdquo;）&lt;strong id=&quot;findLocalMin&quot;&gt;findLocalMin&lt;/strong&gt;（T，DF）（范围DF f，在T ax中，在T bx中，在T relTolerance = sqrt（T.epsilon），以T abs容差= sqrt（T.epsilon））</target>
        </trans-unit>
        <trans-unit id="840acdf57ba98e4920f2fbec545eb130df4593a8" translate="yes" xml:space="preserve">
          <source>Tuple!(T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, R, DF)(scope DF f, in T ax, in T bx, in R fax, in R fbx);</source>
          <target state="translated">（T，T，R，R）&lt;strong id=&quot;findRoot&quot;&gt;tuple！&lt;/strong&gt;（T，R，DF）（范围DF f，在T ax中，在T bx中，在R传真中，在R fbx中）;</target>
        </trans-unit>
        <trans-unit id="51994771db6a3d28fa759af046d2c850390305a5" translate="yes" xml:space="preserve">
          <source>Tuple!(T, T, R, R) &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, R, DF, DT)(scope DF f, in T ax, in T bx, in R fax, in R fbx, scope DT tolerance)</source>
          <target state="translated">元组！（T，T，R，R）&lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;（T，R，DF，DT）（DF范围楼T中斧头，T中BX，R中的传真，R中FBX，范围DT公差）</target>
        </trans-unit>
        <trans-unit id="639ddd2f21c13c7af4c3fc3a46fe3e1d7b82673a" translate="yes" xml:space="preserve">
          <source>Tuple!(size_t, EditOp[]) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt;(alias equals = (a, b) =&amp;gt; a == b, Range1, Range2)(Range1 s, Range2 t)</source>
          <target state="translated">元组！（size_t，EditOp []）&lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt;（别名等于=（a，b）=&amp;gt; a == b，Range1，Range2）（Range1 s，Range2 t）</target>
        </trans-unit>
        <trans-unit id="c0c86644914e59cf3e95dc2d9e3358d7adb8b024" translate="yes" xml:space="preserve">
          <source>Tuple!(size_t, EditOp[]) &lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt;(alias equals = (a, b) =&amp;gt; a == b, Range1, Range2)(auto ref Range1 s, auto ref Range2 t)</source>
          <target state="translated">元组！（size_t，EditOp []）&lt;strong id=&quot;levenshteinDistanceAndPath&quot;&gt;levenshteinDistanceAndPath&lt;/strong&gt;（alias equals =（a，b）=&amp;gt; a == b，Range1，Range2）（自动引用Range1 s，自动引用Range2 t）</target>
        </trans-unit>
        <trans-unit id="b4ce998808efbe7007c7ba094a0ff589456afbc6" translate="yes" xml:space="preserve">
          <source>TupleDeclaration &lt;strong id=&quot;isAliasThisTuple&quot;&gt;isAliasThisTuple&lt;/strong&gt;(Expression e);</source>
          <target state="translated">元组声明为&lt;strong id=&quot;isAliasThisTuple&quot;&gt;AliasThisTuple&lt;/strong&gt;（表达式e）；</target>
        </trans-unit>
        <trans-unit id="80678cb1445455517d232f6976a2ee0f4da0533a" translate="yes" xml:space="preserve">
          <source>TupleForeachRet!(isStatic, isDecl) &lt;strong id=&quot;makeTupleForeach&quot;&gt;makeTupleForeach&lt;/strong&gt;(bool isStatic, bool isDecl)(Scope* sc, ForeachStatement fs, TupleForeachArgs!(isStatic, isDecl) args);</source>
          <target state="translated">TupleForeachRet！（isStatic，isDecl）&lt;strong id=&quot;makeTupleForeach&quot;&gt;makeTupleForeach&lt;/strong&gt;（bool isStatic，bool isDecl）（范围* sc，ForeachStatement fs，TupleForeachArgs！（isStatic，isDecl）args）;</target>
        </trans-unit>
        <trans-unit id="6584111cad42d4105dd8e9be93a1310902d91e92" translate="yes" xml:space="preserve">
          <source>Tuples of two integral offsets can be used to remove an indices range:</source>
          <target state="translated">两个积分偏移量的图组可以用来删除一个指数范围。</target>
        </trans-unit>
        <trans-unit id="d9a474dda4f883ffd7fcbe2488c48bb66a58fbd7" translate="yes" xml:space="preserve">
          <source>Turn DT_azeros into DTcommon</source>
          <target state="translated">把DT_azeros变成DTcommon</target>
        </trans-unit>
        <trans-unit id="b124a21a659b94416124a0c6d11837b408eec822" translate="yes" xml:space="preserve">
          <source>Turn StringExp into Symbol.</source>
          <target state="translated">把StringExp变成Symbol。</target>
        </trans-unit>
        <trans-unit id="e5fc19e75828d2a9872def0cc347c568479bfe06" translate="yes" xml:space="preserve">
          <source>Turn bundling off (default)</source>
          <target state="translated">关闭捆绑(默认)。</target>
        </trans-unit>
        <trans-unit id="bba5b8eb4f9f33288234c4eea8f1ef87433a4f05" translate="yes" xml:space="preserve">
          <source>Turn bundling on</source>
          <target state="translated">打开捆绑功能</target>
        </trans-unit>
        <trans-unit id="902547bf87091225cc20e88f552ffa5d6f0ad9d8" translate="yes" xml:space="preserve">
          <source>Turn case sensitivity off (default)</source>
          <target state="translated">关闭大小写敏感度(默认)。</target>
        </trans-unit>
        <trans-unit id="62ba7010a40283d77918d8073bba5d1ed5b505cc" translate="yes" xml:space="preserve">
          <source>Turn case sensitivity on</source>
          <target state="translated">打开表壳灵敏度</target>
        </trans-unit>
        <trans-unit id="74f2dbf84af28045a37d376cd4e1edd3fa01e659" translate="yes" xml:space="preserve">
          <source>Turn next token in buffer into a token.</source>
          <target state="translated">将缓冲区内的下一个token变成token。</target>
        </trans-unit>
        <trans-unit id="5e3e0a4844ec64b01594e006a743ab91237a31f0" translate="yes" xml:space="preserve">
          <source>Turn off &lt;code&gt;STC.maybescope&lt;/code&gt; for variable &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">关闭 &lt;code&gt;STC.maybescope&lt;/code&gt; 以获取变量 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84cccbe55a872601d865bab8ec58d82539ff0a07" translate="yes" xml:space="preserve">
          <source>Turn on wildcard matching</source>
          <target state="translated">开启通配符</target>
        </trans-unit>
        <trans-unit id="a87d900130ba3c16a326f82759f1060e5ae35223" translate="yes" xml:space="preserve">
          <source>Turn symbol &lt;code&gt;s&lt;/code&gt; into the expression it represents.</source>
          <target state="translated">将符号 &lt;code&gt;s&lt;/code&gt; 转换为其表示的表达式。</target>
        </trans-unit>
        <trans-unit id="e5a454f3b1345dd58c63efa8e881a860cfb32111" translate="yes" xml:space="preserve">
          <source>Two adjacent separators are considered to surround an empty element in the split range. Use &lt;code&gt;filter!(a =&amp;gt; !a.empty)&lt;/code&gt; on the result to compress empty elements.</source>
          <target state="translated">在分割范围内，两个相邻的分隔符被认为围绕着一个空元素。在结果上使用 &lt;code&gt;filter!(a =&amp;gt; !a.empty)&lt;/code&gt; 压缩空元素。</target>
        </trans-unit>
        <trans-unit id="e3ed11541d2964198473ed0a82426d9b49c8d63f" translate="yes" xml:space="preserve">
          <source>Two format specifiers are supported:</source>
          <target state="translated">支持两个格式指定器。</target>
        </trans-unit>
        <trans-unit id="f728c436a5d60ae7a74a1fb01d9c670443ddbdc1" translate="yes" xml:space="preserve">
          <source>Two functions have been added for convenience:</source>
          <target state="translated">为了方便,增加了两个功能。</target>
        </trans-unit>
        <trans-unit id="241f31fb40e72ec287fecd2a2aa243010af09b63" translate="yes" xml:space="preserve">
          <source>Two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are in different contexts, but outer context is indirectly accessible from innter context, so nested template instance &lt;code&gt;sum!(a, b)&lt;/code&gt; will capture only inner context.</source>
          <target state="translated">两个局部变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 处于不同的上下文中，但是可以从内部上下文间接访问外部上下文，因此嵌套的模板实例 &lt;code&gt;sum!(a, b)&lt;/code&gt; 将仅捕获内部上下文。</target>
        </trans-unit>
        <trans-unit id="7344649ec3349339576b149dc016e926290914de" translate="yes" xml:space="preserve">
          <source>Two or more non-infinite forward ranges</source>
          <target state="translated">两个或两个以上的非无限前行范围</target>
        </trans-unit>
        <trans-unit id="541bef60f707acc034ee30fb6ceb5b604a068f40" translate="yes" xml:space="preserve">
          <source>Two versions of programs are commonly built, a release build and a debug build. The debug build includes extra error checking code, test harnesses, pretty-printing code, etc. The debug statement conditionally compiles in its statement body. It is D's way of what in C is done with &lt;code&gt;#ifdef DEBUG&lt;/code&gt; / &lt;code&gt;#endif&lt;/code&gt; pairs.</source>
          <target state="translated">通常会构建两种版本的程序，即发行版和调试版。调试版本包括额外的错误检查代码，测试工具，漂亮的打印代码等。debug语句在其语句主体中有条件地编译。这是D使用 &lt;code&gt;#ifdef DEBUG&lt;/code&gt; / &lt;code&gt;#endif&lt;/code&gt; 对完成D的方式。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="96e4f0ac6a824b3c4a6ad224979d9909d711bd86" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;T&lt;/code&gt; can be one of:</source>
          <target state="translated">键入 &lt;code&gt;T&lt;/code&gt; 可以是一个：</target>
        </trans-unit>
        <trans-unit id="074961b98338169a77631354ecc98de531ee94fd" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;itype&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;itype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abcae8ebd4b965d368a249e36f4d23c1e65f3bc6" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;mt&lt;/code&gt;</source>
          <target state="translated">键入 &lt;code&gt;mt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96b17264511c000a8d2d312a068c77228139ea5b" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;stype&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;stype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b088eef787c263bc72b35d7bf8bffb02250f35af" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t1&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;t1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7dce03ad43b5e48ad6926eff66da1dc0fbd992e8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t2&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;t2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f8a5d9f738e3ec7573a4c3d2bfa71c9dab55055" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c297c055e8021da1038d32c6451a431dc0cd79a4" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tfrom&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;tfrom&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be5260cde80d2a83f5fa8c9f051bba7fb9b67140" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;torig&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;torig&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="265bebeeaa74df34bb2463a7ccd6495a2fd2b3e7" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tthis&lt;/code&gt;</source>
          <target state="translated">输入 &lt;code&gt;tthis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d90e13e3fed6c33599ffe3adfef07d6fecfb113f" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;tto&lt;/code&gt;</source>
          <target state="translated">输入 &lt;code&gt;tto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac37939248da7ca7fc509e594e3e1162b28e7f03" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa75b76e3b4d199eb5bf1cbe330006d90e593043" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;addStorageClass&quot;&gt;addStorageClass&lt;/strong&gt;(StorageClass stc);</source>
          <target state="translated">键入&lt;strong id=&quot;addStorageClass&quot;&gt;addStorageClass&lt;/strong&gt;（StorageClass stc）;</target>
        </trans-unit>
        <trans-unit id="d84d22937a28d260576af02a61a011cb7b2b2cc5" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;compileTypeMixin&quot;&gt;compileTypeMixin&lt;/strong&gt;(TypeMixin tm, Loc loc, Scope* sc);</source>
          <target state="translated">类型&lt;strong id=&quot;compileTypeMixin&quot;&gt;compileTypeMixin&lt;/strong&gt;（TypeMixin tm，Loc loc，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="c24f3c59131a7c5a8bc5e783fc5e665af1b32a5e" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;getIndirection&quot;&gt;getIndirection&lt;/strong&gt;(Type t);</source>
          <target state="translated">键入&lt;strong id=&quot;getIndirection&quot;&gt;getIndirection&lt;/strong&gt;（T型）;</target>
        </trans-unit>
        <trans-unit id="c2b92e082fd5a3ac4a7a6baf60cbd699edacc254" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;getTypeInfoType&quot;&gt;getTypeInfoType&lt;/strong&gt;(Loc loc, Type t, Scope* sc);</source>
          <target state="translated">输入&lt;strong id=&quot;getTypeInfoType&quot;&gt;getTypeInfoType&lt;/strong&gt;（Loc loc，Type t，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="7988a8b265a00347de81079da3fe4590a68ee7ca" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;isLazyArray&quot;&gt;isLazyArray&lt;/strong&gt;();</source>
          <target state="translated">类型为&lt;strong id=&quot;isLazyArray&quot;&gt;isLazyArray&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="f4d3b40b91dc28c4e5940a35bf69a0bbb241540d" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;merge&quot;&gt;merge&lt;/strong&gt;(Type type);</source>
          <target state="translated">类型&lt;strong id=&quot;merge&quot;&gt;合并&lt;/strong&gt;（Type type）；</target>
        </trans-unit>
        <trans-unit id="35806f9ee47f3dd812d869bb49adecc56fab810b" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;nextOf&quot;&gt;nextOf&lt;/strong&gt;();</source>
          <target state="translated">键入&lt;strong id=&quot;nextOf&quot;&gt;nextOf&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="87e0a9680f0eea47764ac3ffa10dd8d73e88aeee" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;parameterType&quot;&gt;parameterType&lt;/strong&gt;(Parameter p);</source>
          <target state="translated">类型&lt;strong id=&quot;parameterType&quot;&gt;parameterType&lt;/strong&gt;（参数p）;</target>
        </trans-unit>
        <trans-unit id="7016ea73ad39a852ab2478cb095dfe5d455408a3" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;stype&quot;&gt;stype&lt;/strong&gt;;</source>
          <target state="translated">类型&lt;strong id=&quot;stype&quot;&gt;stype&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="deae4e726d62ba433ff0fa85c1e57f1770faea08" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;tintro&quot;&gt;tintro&lt;/strong&gt;;</source>
          <target state="translated">类型&lt;strong id=&quot;tintro&quot;&gt;tintro&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1eadd5370543a51dcc388d2fe2066cef28052c13" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;toBasetype&quot;&gt;toBasetype&lt;/strong&gt;();</source>
          <target state="translated">键入&lt;strong id=&quot;toBasetype&quot;&gt;toBasetype&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="a8533c3e5233456fb672ac9c547f329a114136e2" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;toHeadMutable&quot;&gt;toHeadMutable&lt;/strong&gt;();</source>
          <target state="translated">键入&lt;strong id=&quot;toHeadMutable&quot;&gt;toHeadMutable&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="96b0f23e070ede5bec63f5e83cdeac74f8089165" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;typeSemantic&quot;&gt;typeSemantic&lt;/strong&gt;(Type t, Loc loc, Scope* sc);</source>
          <target state="translated">类型type &lt;strong id=&quot;typeSemantic&quot;&gt;语义&lt;/strong&gt;（Type t，Loc loc，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="5d4688f5531e8a08ef8e0ff730f862cace988d3d" translate="yes" xml:space="preserve">
          <source>Type &lt;strong id=&quot;va_listType&quot;&gt;va_listType&lt;/strong&gt;();</source>
          <target state="translated">键入&lt;strong id=&quot;va_listType&quot;&gt;va_listType&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="4f59c6d42771bbb84c27a2121ad3681f0bb72d20" translate="yes" xml:space="preserve">
          <source>Type AST node</source>
          <target state="translated">类型AST节点</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">类型转换</target>
        </trans-unit>
        <trans-unit id="c6b7ec08c1e42e9023620d7d964ae0eef2d20644" translate="yes" xml:space="preserve">
          <source>Type Mangling</source>
          <target state="translated">Type Mangling</target>
        </trans-unit>
        <trans-unit id="264ee4dfa69c98ad557b3342fe8cc1e2b97db3e7" translate="yes" xml:space="preserve">
          <source>Type Qualifiers</source>
          <target state="translated">类型限定词</target>
        </trans-unit>
        <trans-unit id="edc9c0e21717c816a5ec56b1e42647baf2336f1d" translate="yes" xml:space="preserve">
          <source>Type Qualifiers vs. Storage Classes</source>
          <target state="translated">类型限定符与存储类</target>
        </trans-unit>
        <trans-unit id="931cf893dd7787c77998acad492a0ecb55e589ff" translate="yes" xml:space="preserve">
          <source>Type behaviours</source>
          <target state="translated">类型行为</target>
        </trans-unit>
        <trans-unit id="25bae51139cada12199444a9e1b243f934dd5a35" translate="yes" xml:space="preserve">
          <source>Type checking can be done when fmt is known at compile-time:</source>
          <target state="translated">当在编译时知道fmt时,可以进行类型检查。</target>
        </trans-unit>
        <trans-unit id="e3ba04dc56b4f38a8765f8f4d22b580ca485aa27" translate="yes" xml:space="preserve">
          <source>Type constructor for final (aka head-const) variables.</source>
          <target state="translated">final (又称head-const)变量的类型构造函数。</target>
        </trans-unit>
        <trans-unit id="5bf7d2b202fca4883a92f0548ad74fcbd4972ddc" translate="yes" xml:space="preserve">
          <source>Type constructors for scoped variables, ref counted types, etc.</source>
          <target state="translated">用于作用域变量、ref counted类型等的类型构造器。</target>
        </trans-unit>
        <trans-unit id="8b9b79043e64613a9793b392102a5c4ae4b65fe0" translate="yes" xml:space="preserve">
          <source>Type containing symbol &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">类型包含符号 &lt;code&gt;member&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb30eafbd228209766b8a8bef60c18b615f0e87b" translate="yes" xml:space="preserve">
          <source>Type for the &lt;code&gt;va_list&lt;/code&gt; type for the target.</source>
          <target state="translated">类型为目标的 &lt;code&gt;va_list&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="ef47c7ac43e7255929d6c306077f07f47b722eec" translate="yes" xml:space="preserve">
          <source>Type of Trie generated by codepointSetTrie function.</source>
          <target state="translated">codepointSetTrie函数生成的Trie类型。</target>
        </trans-unit>
        <trans-unit id="4dccd7a2bbd9b94a92f0a8c92cf9c4faa4852cf6" translate="yes" xml:space="preserve">
          <source>Type of a factory object that returns new allocators on a need basis. For an object &lt;code&gt;sweatshop&lt;/code&gt; of type &lt;code&gt;Factory&lt;/code&gt;, &lt;code&gt;sweatshop(n)&lt;/code&gt; should return an allocator able to allocate at least &lt;code&gt;n&lt;/code&gt; bytes (i.e. &lt;code&gt;Factory&lt;/code&gt; must define &lt;code&gt;opCall(size_t)&lt;/code&gt; to return an allocator object). Usually the capacity of allocators created should be much larger than &lt;code&gt;n&lt;/code&gt; such that an allocator can be used for many subsequent allocations. &lt;code&gt;n&lt;/code&gt; is passed only to ensure the minimum necessary for the next allocation. The factory object is allowed to hold state, which will be stored inside &lt;code&gt;AllocatorList&lt;/code&gt; as a direct &lt;code&gt;public&lt;/code&gt; member called &lt;code&gt;factory&lt;/code&gt;.</source>
          <target state="translated">根据需要返回新分配器的工厂对象的类型。对于类型为 &lt;code&gt;Factory&lt;/code&gt; 的对象 &lt;code&gt;sweatshop&lt;/code&gt; ， &lt;code&gt;sweatshop(n)&lt;/code&gt; 应该返回能够分配至少 &lt;code&gt;n&lt;/code&gt; 个字节的分配器（即， &lt;code&gt;Factory&lt;/code&gt; 必须定义 &lt;code&gt;opCall(size_t)&lt;/code&gt; 才能返回分配器对象）。通常，创建的分配器的容量应远大于 &lt;code&gt;n&lt;/code&gt; ，以便分配器可用于许多后续分配。仅传递 &lt;code&gt;n&lt;/code&gt; 以确保下一次分配所需的最小值。允许工厂对象保持状态，该状态将作为直接 &lt;code&gt;public&lt;/code&gt; 状态存储在 &lt;code&gt;AllocatorList&lt;/code&gt; 中成员叫 &lt;code&gt;factory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53b3c45deaab965f30fbaf51880e1afc49233e18" translate="yes" xml:space="preserve">
          <source>Type of hook to report to accumulate</source>
          <target state="translated">报告积累的钩子类型</target>
        </trans-unit>
        <trans-unit id="15e383896d707844d0eca91f8b6889d73b97fbb0" translate="yes" xml:space="preserve">
          <source>Type of proxy</source>
          <target state="translated">代理类型</target>
        </trans-unit>
        <trans-unit id="c83110b1d2db2259adf4200ec37888cbc9846639" translate="yes" xml:space="preserve">
          <source>Type of tag</source>
          <target state="translated">标签类型</target>
        </trans-unit>
        <trans-unit id="d3fa4f954ab06add7bd749b7bdea58934c993aaa" translate="yes" xml:space="preserve">
          <source>Type of the object being created.</source>
          <target state="translated">正在创建的对象的类型。</target>
        </trans-unit>
        <trans-unit id="a0daf2f1b22dd08dc29f641bae271010f9baf166" translate="yes" xml:space="preserve">
          <source>Type parameter deduction is not influenced by the order of function arguments.</source>
          <target state="translated">类型参数推导不受函数参数顺序的影响。</target>
        </trans-unit>
        <trans-unit id="6589b7ca4f64019c13d806f181e6e2f0d2a12efe" translate="yes" xml:space="preserve">
          <source>Type qualifer and storage classes are distinct.</source>
          <target state="translated">类型限定词和存储类是不同的。</target>
        </trans-unit>
        <trans-unit id="6be815ee4e71cdcd2fdc1b9f5a931c3396cc2ae9" translate="yes" xml:space="preserve">
          <source>Type qualifiers modify a type by applying a &lt;a href=&quot;declaration#TypeCtor&quot;&gt;&lt;i&gt;TypeCtor&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">类型限定符通过应用&lt;a href=&quot;declaration#TypeCtor&quot;&gt;&lt;i&gt;TypeCtor来&lt;/i&gt;&lt;/a&gt;修改类型。</target>
        </trans-unit>
        <trans-unit id="a70515f861481e8dc4615de28615ff7366fcc202" translate="yes" xml:space="preserve">
          <source>Type representing the DOS file date/time format.</source>
          <target state="translated">代表DOS文件日期/时间格式的类型。</target>
        </trans-unit>
        <trans-unit id="8707ce3b635eb9df5d025d3f0450b4a8fd3eb48d" translate="yes" xml:space="preserve">
          <source>Type sequences can also be deduced from the type of a delegate or function parameter list passed as a function argument:</source>
          <target state="translated">类型序列也可以从作为函数参数传递的委托或函数参数列表的类型推导出来。</target>
        </trans-unit>
        <trans-unit id="733ee898e1598d12bae36c91271af1529e4fcaa2" translate="yes" xml:space="preserve">
          <source>Type sequences can be deduced from the trailing parameters of an implicitly instantiated function template:</source>
          <target state="translated">类型序列可以从隐式实例化的函数模板的尾部参数推导出来。</target>
        </trans-unit>
        <trans-unit id="a8e4656cb8d277115469c8e6ecd03e51fd9b8df7" translate="yes" xml:space="preserve">
          <source>Type to check</source>
          <target state="translated">类型检查</target>
        </trans-unit>
        <trans-unit id="f741a0744a1572f9886a07067ea02acc1834b951" translate="yes" xml:space="preserve">
          <source>Type to check against existing types</source>
          <target state="translated">检查现有类型的类型</target>
        </trans-unit>
        <trans-unit id="de396937e60ad29356ea188a9c5d9ea651e367c0" translate="yes" xml:space="preserve">
          <source>Type tuple with 0, 1 or 2 types in it.</source>
          <target state="translated">类型元组,其中有0、1或2种类型。</target>
        </trans-unit>
        <trans-unit id="011c9eabb9ffe20e7e22482cfbe2286b6120bfa9" translate="yes" xml:space="preserve">
          <source>Type* &lt;code&gt;pt&lt;/code&gt;</source>
          <target state="translated">类型* &lt;code&gt;pt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58d77e6f74277f79b951803afbe1ddf1b35734df" translate="yes" xml:space="preserve">
          <source>TypeCtor</source>
          <target state="translated">TypeCtor</target>
        </trans-unit>
        <trans-unit id="ac9e1cc0b26d4033ad5c959b5f820850ea93475b" translate="yes" xml:space="preserve">
          <source>TypeCtors</source>
          <target state="translated">TypeCtors</target>
        </trans-unit>
        <trans-unit id="3928ee67b003a61e2825045ee7c6856586fe197b" translate="yes" xml:space="preserve">
          <source>TypeDotIdExp</source>
          <target state="translated">TypeDotIdExp</target>
        </trans-unit>
        <trans-unit id="0019be4cb34cff2695b5aff262952fd301c46685" translate="yes" xml:space="preserve">
          <source>TypeFunction &lt;code&gt;tf&lt;/code&gt;</source>
          <target state="translated">类型功能 &lt;code&gt;tf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db700355f8924fab7eada69ef0fe0e550c49d3a6" translate="yes" xml:space="preserve">
          <source>TypeFunction which holds parameter.</source>
          <target state="translated">持有参数的TypeFunction。</target>
        </trans-unit>
        <trans-unit id="5ca2910cf68fdd66a12e3e8220178f8b4cc5a0db" translate="yes" xml:space="preserve">
          <source>TypeIdentifier &lt;strong id=&quot;getException&quot;&gt;getException&lt;/strong&gt;();</source>
          <target state="translated">TypeIdentifier &lt;strong id=&quot;getException&quot;&gt;getException&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="42f5b285fc85964089e7dc297caf59c7103f1888" translate="yes" xml:space="preserve">
          <source>TypeIdentifier &lt;strong id=&quot;getThrowable&quot;&gt;getThrowable&lt;/strong&gt;();</source>
          <target state="translated">TypeIdentifier &lt;strong id=&quot;getThrowable&quot;&gt;getThrowable&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="f9d611bfddd3405f459de10a0cf6d218aa6287a1" translate="yes" xml:space="preserve">
          <source>TypeIdentifier corresponding to &lt;code&gt;object.Exception&lt;/code&gt;</source>
          <target state="translated">TypeIdentifier对应 &lt;code&gt;object.Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea8bcbfb0a4687ca07a5f9448fa2692699ee114" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;info&lt;/code&gt;</source>
          <target state="translated">TypeInfo &lt;code&gt;info&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1b8e2e2628fbdb6b877b9991519908026efcaf7" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;keyti&lt;/code&gt;</source>
          <target state="translated">TypeInfo &lt;code&gt;keyti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dec97b284949d704d7ee4541006a5521ba97794" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;code&gt;ti&lt;/code&gt;</source>
          <target state="translated">TypeInfo &lt;code&gt;ti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67c22ded6663e84767a53e56d998760516256038" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;source&quot;&gt;source&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;source&quot;&gt;源&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c1278db525adc97eab488999431f521bd14cee3e" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;target&quot;&gt;target&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;target&quot;&gt;目标&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="79ae15533fd627996ea193ee400334ad48f0ffa1" translate="yes" xml:space="preserve">
          <source>TypeInfo &lt;strong id=&quot;ti&quot;&gt;ti&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo &lt;strong id=&quot;ti&quot;&gt;ti&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="472c2c18b4ef0579bcce9fff2441baed8006d608" translate="yes" xml:space="preserve">
          <source>TypeInfo and ModuleInfo</source>
          <target state="translated">类型信息和模块信息</target>
        </trans-unit>
        <trans-unit id="60e117687bb5baf0fd5a823fd99cc2045df9bbdf" translate="yes" xml:space="preserve">
          <source>TypeInfo for some class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93be7833a3f5791fae09a639aee73a46e387e3c" translate="yes" xml:space="preserve">
          <source>TypeInfo for the associative array</source>
          <target state="translated">关联数组的类型信息</target>
        </trans-unit>
        <trans-unit id="7c7bfccff9046ef36445ee4c709ff7d995d70ab8" translate="yes" xml:space="preserve">
          <source>TypeInfo for the key</source>
          <target state="translated">键的类型信息</target>
        </trans-unit>
        <trans-unit id="23d395400e74ed54a9281933209acee2f90cbe4e" translate="yes" xml:space="preserve">
          <source>TypeInfo for this member</source>
          <target state="translated">该成员的类型信息</target>
        </trans-unit>
        <trans-unit id="6cae780f43ad1913cc11d46eaafdb1d914a0fecd" translate="yes" xml:space="preserve">
          <source>TypeInfo operations</source>
          <target state="translated">类型信息操作</target>
        </trans-unit>
        <trans-unit id="0c903e4430a6af28fc4a701dcf89fccf74b52c8e" translate="yes" xml:space="preserve">
          <source>TypeInfo support code.</source>
          <target state="translated">TypeInfo支持代码。</target>
        </trans-unit>
        <trans-unit id="7bac08fb0ecc35c0c1645fa9688ec0c7cbb7320b" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the full memory block. The GC might use this information to improve scanning for pointers or to call finalizers.</source>
          <target state="translated">TypeInfo来描述完整的内存块。GC可能会使用这些信息来改进对指针的扫描或调用定标器。</target>
        </trans-unit>
        <trans-unit id="e6a910dc0d5bf54bb8bb28b4e2782c2fac837ad2" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers</source>
          <target state="translated">TypeInfo来描述内存。GC可能会使用这些信息来改进对指针的扫描,或者调用定标器。</target>
        </trans-unit>
        <trans-unit id="8c13cb9891545ae558cb22a55266091cadf68bb8" translate="yes" xml:space="preserve">
          <source>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers.</source>
          <target state="translated">TypeInfo来描述内存。GC可能会使用这些信息来改进对指针的扫描或调用定标器。</target>
        </trans-unit>
        <trans-unit id="aff0fe6a2bf6b7e4ef9a8e4a029e01a4aeb8762f" translate="yes" xml:space="preserve">
          <source>TypeInfo_AssociativeArray &lt;code&gt;ti&lt;/code&gt;</source>
          <target state="translated">TypeInfo_AssociativeArray &lt;code&gt;ti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ddf3891d5ae85f580f981341a31916f1fc360a8" translate="yes" xml:space="preserve">
          <source>TypeInfo_Class &lt;code&gt;child&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25e4540ada3cc921bdd8d8fd0d8e1e7b7781066" translate="yes" xml:space="preserve">
          <source>TypeInfo_Class &lt;strong id=&quot;base&quot;&gt;base&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo_Class &lt;strong id=&quot;base&quot;&gt;基&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="9239ac5fb46ce2e24e9298817e7012c20bc78405" translate="yes" xml:space="preserve">
          <source>TypeInfo_Class &lt;strong id=&quot;classinfo&quot;&gt;classinfo&lt;/strong&gt;;</source>
          <target state="translated">TypeInfo_Class &lt;strong id=&quot;classinfo&quot;&gt;classinfo&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2bd0ed90864a622e90192ec41cb245073bc3a096" translate="yes" xml:space="preserve">
          <source>TypeMixin &lt;code&gt;tm&lt;/code&gt;</source>
          <target state="translated">TypeMixin &lt;code&gt;tm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="773e0bc0cc8840334c10f79e302767527cb23cf4" translate="yes" xml:space="preserve">
          <source>TypeSeq</source>
          <target state="translated">TypeSeq</target>
        </trans-unit>
        <trans-unit id="2485569c283c3e15dcdf66b2941cf2585cfbb0fb" translate="yes" xml:space="preserve">
          <source>TypeSpecialization</source>
          <target state="translated">TypeSpecialization</target>
        </trans-unit>
        <trans-unit id="d5bc30e762df0213573cbaddbf2be54ecff91c7a" translate="yes" xml:space="preserve">
          <source>TypeTuple &lt;strong id=&quot;toArgTypes&quot;&gt;toArgTypes&lt;/strong&gt;(Type t);</source>
          <target state="translated">TypeTuple &lt;strong id=&quot;toArgTypes&quot;&gt;toArgTypes&lt;/strong&gt;（Type t）;</target>
        </trans-unit>
        <trans-unit id="0a55489e3ecfb05595ff8f54b93c8573e3ce85a8" translate="yes" xml:space="preserve">
          <source>TypeTuple &lt;strong id=&quot;toArgTypes_sysv_x64&quot;&gt;toArgTypes_sysv_x64&lt;/strong&gt;(Type t);</source>
          <target state="translated">TypeTuple &lt;strong id=&quot;toArgTypes_sysv_x64&quot;&gt;toArgTypes_sysv_x64&lt;/strong&gt;（Type t）;</target>
        </trans-unit>
        <trans-unit id="e642a3765f89fbde01f0a2276d7abdf9b70ab3cf" translate="yes" xml:space="preserve">
          <source>Typed alias parameters</source>
          <target state="translated">输入的别名参数</target>
        </trans-unit>
        <trans-unit id="b30db53a60d0c35c43aeee9bc4f602733c935e33" translate="yes" xml:space="preserve">
          <source>Typedef creates a new type</source>
          <target state="translated">Typedef创建一个新类型</target>
        </trans-unit>
        <trans-unit id="6201a322fae660c45cd9849605bc8c759be0c5b0" translate="yes" xml:space="preserve">
          <source>Typeid Expressions</source>
          <target state="translated">Typeid表达式</target>
        </trans-unit>
        <trans-unit id="bf3662203dcf0ffc0db3cb9a25590ff39043990d" translate="yes" xml:space="preserve">
          <source>Typeof</source>
          <target state="translated">Typeof</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="98208c2d7d35bb6c2bec43c9c9c8b3b514bcabb3" translate="yes" xml:space="preserve">
          <source>Types &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad7fbb5ff653b4fb1310a106afd7d4d247c60fc4" translate="yes" xml:space="preserve">
          <source>Types &lt;strong id=&quot;expand&quot;&gt;expand&lt;/strong&gt;;</source>
          <target state="translated">类型&lt;strong id=&quot;expand&quot;&gt;扩展&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d33ff32e1c661c88ebc3ad3634169408689bdb2c" translate="yes" xml:space="preserve">
          <source>Types affected</source>
          <target state="translated">受影响的类型</target>
        </trans-unit>
        <trans-unit id="8b8ed26fa191ff295582e384bddd39585a3f8db2" translate="yes" xml:space="preserve">
          <source>Types are mangled using a simple linear scheme:</source>
          <target state="translated">类型采用简单的线性方案进行混搭。</target>
        </trans-unit>
        <trans-unit id="056fa98818fde905c87d68b5a8122d7a217fa627" translate="yes" xml:space="preserve">
          <source>Types for C Debuggers</source>
          <target state="translated">C语言调试器的类型</target>
        </trans-unit>
        <trans-unit id="a317ddf00723db3897d96406a7af0777748b751e" translate="yes" xml:space="preserve">
          <source>Typesafe PIMPL idiom so we can keep CompiledCtfeFunction private.</source>
          <target state="translated">Typesafe PIMPL成语,所以我们可以保持CompiledCtfeFunction的私有性。</target>
        </trans-unit>
        <trans-unit id="8c1a6486831bba104b5c93d116efda5decae0955" translate="yes" xml:space="preserve">
          <source>Typesafe Variadic Functions</source>
          <target state="translated">类型安全可变函数</target>
        </trans-unit>
        <trans-unit id="9c18f7085ca663e2eeeb1ab419e11c946cc281e9" translate="yes" xml:space="preserve">
          <source>Typesafe variadic functions</source>
          <target state="translated">类型安全的变量函数</target>
        </trans-unit>
        <trans-unit id="c158adeb6705f4b21c628caabe72dc1f58ae0f9b" translate="yes" xml:space="preserve">
          <source>Typesafe variadic functions are used when the variable argument portion of the arguments are used to construct an array or class object.</source>
          <target state="translated">当变量参数部分用于构造数组或类对象时,使用类型安全的变量函数。</target>
        </trans-unit>
        <trans-unit id="e6941e6087f5c747e81f3548ced3b053ce9e7b28" translate="yes" xml:space="preserve">
          <source>Typically updating a value in an associative array is simply done with an assign statement.</source>
          <target state="translated">通常情况下,更新一个关联数组中的值,只需通过赋值语句即可完成。</target>
        </trans-unit>
        <trans-unit id="db183258f807139f91ca3be4ce6506a44b76a64e" translate="yes" xml:space="preserve">
          <source>Typically used to transfer a &lt;code&gt;Unique&lt;/code&gt; rvalue of derived type to a &lt;code&gt;Unique&lt;/code&gt; of base type.</source>
          <target state="translated">通常用于传送一个 &lt;code&gt;Unique&lt;/code&gt; 派生类型的右值到一个 &lt;code&gt;Unique&lt;/code&gt; 基本类型的。</target>
        </trans-unit>
        <trans-unit id="733f934ae56c1f7d0fdf7d7b634f135f6d1638cd" translate="yes" xml:space="preserve">
          <source>Typically, &lt;code&gt;assumeUnique&lt;/code&gt; is used to return arrays from functions that have allocated and built them.</source>
          <target state="translated">通常， &lt;code&gt;assumeUnique&lt;/code&gt; 用于从已分配并构建它们的函数中返回数组。</target>
        </trans-unit>
        <trans-unit id="22c79bf41fa01646983d0e1c75126cd457c1bd02" translate="yes" xml:space="preserve">
          <source>Typically, the abbreviation (generally 3 or 4 letters) for the time zone when DST</source>
          <target state="translated">通常情况下,当夏令时时区的缩写(一般为3或4个字母)。</target>
        </trans-unit>
        <trans-unit id="b795aa6d3d9c14054ccb6a6aea11b3269a8595b3" translate="yes" xml:space="preserve">
          <source>Typically, the abbreviation (generally 3 or 4 letters) for the time zone when DST is</source>
          <target state="translated">通常情况下,当DST为时区的缩写(一般为3个或4个字母)。</target>
        </trans-unit>
        <trans-unit id="b7f34bb41388ea7e3fb767468d24019362880e11" translate="yes" xml:space="preserve">
          <source>Typically, the first element of &lt;code&gt;argv&lt;/code&gt; is the command being executed, i.e. &lt;code&gt;argv[0] == pathname&lt;/code&gt;. The 'p' versions of &lt;code&gt;exec&lt;/code&gt; search the PATH environment variable for &lt;code&gt; pathname&lt;/code&gt;. The 'e' versions additionally take the new process' environment variables as an array of strings of the form key=value.</source>
          <target state="translated">通常， &lt;code&gt;argv&lt;/code&gt; 的第一个元素是正在执行的命令，即 &lt;code&gt;argv[0] == pathname&lt;/code&gt; 。 &lt;code&gt;exec&lt;/code&gt; 的'p'版本在PATH环境变量中搜索 &lt;code&gt; pathname&lt;/code&gt; 。&amp;ldquo; e&amp;rdquo;版本还采用&amp;ldquo;新过程&amp;rdquo;环境变量作为键=值形式的字符串数组。</target>
        </trans-unit>
        <trans-unit id="de16dec91e0419147faeea7cdd994e0d6a8f8d25" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;another&lt;/code&gt;</source>
          <target state="translated">你 &lt;code&gt;another&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fb667fdcab211117158dd3ce9d3203d725af2f1" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;argument&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;argument&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="697f0c45a847f453216f051a5a6ee69d25e04ed2" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">&amp;uuml; &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63a11922fe248c81fbee9848ffa1f8b4dfbc12bd" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23c55c60a22ed27e0af35760d8416c17c4c523be" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;reference&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39dcf3fde6cc76619903303aa59a8ee79c73ff4f" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">&amp;uuml; &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd1523b1327c39f05597e30713c7dff5a3ff10c0" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;stuff&lt;/code&gt;</source>
          <target state="translated">你的 &lt;code&gt;stuff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14d2ebb04ddb126790e90698955610cc1aa2858f" translate="yes" xml:space="preserve">
          <source>U &lt;code&gt;update&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;update&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fa4864c90d6d362e77a889c4b5d08bf8651a60b" translate="yes" xml:space="preserve">
          <source>U &lt;strong id=&quot;opCast&quot;&gt;opCast&lt;/strong&gt;(U, this _)()</source>
          <target state="translated">U &lt;strong id=&quot;opCast&quot;&gt;opCast&lt;/strong&gt;（U，此_）（）</target>
        </trans-unit>
        <trans-unit id="dc24734c978d9bb3d649f59ea57f6fbfebb04938" translate="yes" xml:space="preserve">
          <source>UDAs can be extracted into an expression tuple using &lt;code&gt;__traits&lt;/code&gt;:</source>
          <target state="translated">可以使用 &lt;code&gt;__traits&lt;/code&gt; 将UDA提取到表达式元组中：</target>
        </trans-unit>
        <trans-unit id="8c9a445b357a8879b87fe2a26129a13cff925174" translate="yes" xml:space="preserve">
          <source>UDAs cannot be attached to template parameters.</source>
          <target state="translated">UDA不能附加到模板参数上。</target>
        </trans-unit>
        <trans-unit id="4196b39d1eebc6a19e223c4aac2d97a9aacf8120" translate="yes" xml:space="preserve">
          <source>UIntType</source>
          <target state="translated">UIntType</target>
        </trans-unit>
        <trans-unit id="c05d8b4022a5b33bdfe1da8ac44209fadee29acb" translate="yes" xml:space="preserve">
          <source>UIntType &lt;code&gt;x0&lt;/code&gt;</source>
          <target state="translated">UIntType &lt;code&gt;x0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1134895e9b29127e491e75b96f85825dd4e274" translate="yes" xml:space="preserve">
          <source>UNIX 98 requires that errno be set to ENOMEM upon failure. &lt;a href=&quot;https://linux.die.net/man/3/malloc&quot;&gt;https://linux.die.net/man/3/malloc&lt;/a&gt; However, this is irrelevant for DMD's purposes, and best practice protocol for using errno is to treat it as an &lt;code&gt;out&lt;/code&gt; parameter, and not something with state that can be relied on across function calls. So, we'll ignore it.</source>
          <target state="translated">UNIX 98要求在失败时将errno设置为ENOMEM。&lt;a href=&quot;https://linux.die.net/man/3/malloc&quot;&gt;https://linux.die.net/man/3/malloc&lt;/a&gt;但是，这与DMD的目的无关，使用errno的最佳实践协议是将其视为 &lt;code&gt;out&lt;/code&gt; 参数，而不是带有可依赖状态的东西跨函数调用。因此，我们将忽略它。</target>
        </trans-unit>
        <trans-unit id="beccb674b27af0ddeedf12b4de67513a39156f03" translate="yes" xml:space="preserve">
          <source>UNIX 98 requires that errno be set to ENOMEM upon failure. Purity is achieved by saving and restoring the value of &lt;code&gt;errno&lt;/code&gt;, thus behaving as if it were never changed.</source>
          <target state="translated">UNIX 98要求在失败时将errno设置为ENOMEM。通过保存和恢复 &lt;code&gt;errno&lt;/code&gt; 的值可实现纯度，因此行为似乎从未改变过。</target>
        </trans-unit>
        <trans-unit id="fd4c42e93b798f843e95525ca51904fccdadcf92" translate="yes" xml:space="preserve">
          <source>UNIX(7)</source>
          <target state="translated">UNIX(7)</target>
        </trans-unit>
        <trans-unit id="f9fc2ebde19b1bdca47e809441ff08ef908d85ea" translate="yes" xml:space="preserve">
          <source>UTF Byte Order Marks</source>
          <target state="translated">UTF 字节序号</target>
        </trans-unit>
        <trans-unit id="9f8129fc3aa0089cfcf72b031ad3d481df53b04d" translate="yes" xml:space="preserve">
          <source>UTF character support is restricted to &lt;code&gt;'\u0000' &amp;lt;= character &amp;lt;= '\U0010FFFF'&lt;/code&gt;.</source>
          <target state="translated">UTF字符支持仅限于 &lt;code&gt;'\u0000' &amp;lt;= character &amp;lt;= '\U0010FFFF'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f9afa06e54090c43e842aa15b3fe3611896ff8c" translate="yes" xml:space="preserve">
          <source>UTF sequences that cannot be converted to the specified encoding are either replaced by U+FFFD per &quot;5.22 Best Practice for U+FFFD Substitution&quot; of the Unicode Standard 6.2 or result in a thrown UTFException. Hence byUTF is not symmetric. This algorithm is lazy, and does not allocate memory. &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;-ity, &lt;code&gt;nothrow&lt;/code&gt;, and &lt;code&gt;@safe&lt;/code&gt;-ty are inferred from the &lt;code&gt;r&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5411953a4d42cf12809bd4464e6d4db7776d601" translate="yes" xml:space="preserve">
          <source>UTF sequences that cannot be converted to the specified encoding are replaced by U+FFFD per &quot;5.22 Best Practice for U+FFFD Substitution&quot; of the Unicode Standard 6.2. Hence byUTF is not symmetric. This algorithm is lazy, and does not allocate memory. &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;-ity, &lt;code&gt;nothrow&lt;/code&gt;, and &lt;code&gt;@safe&lt;/code&gt;-ty are inferred from the &lt;code&gt;r&lt;/code&gt; parameter.</source>
          <target state="translated">根据Unicode标准6.2的&amp;ldquo; 5.22 U + FFFD替代最佳实践&amp;rdquo;，不能转换为指定编码的UTF序列由U + FFFD替换。因此，byUTF不是对称的。该算法是惰性的，并且不分配内存。 &lt;code&gt;@nogc&lt;/code&gt; ， &lt;code&gt;pure&lt;/code&gt; -ity， &lt;code&gt;nothrow&lt;/code&gt; ，并且 &lt;code&gt;@safe&lt;/code&gt; -TY从推断 &lt;code&gt;r&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="815b5d137b049f840a84ea779942f380fee2d1b2" translate="yes" xml:space="preserve">
          <source>UTF-16 sequence</source>
          <target state="translated">UTF-16序列</target>
        </trans-unit>
        <trans-unit id="de4a45e716017695cfee4bc84f1a4e0c8e1e9b9a" translate="yes" xml:space="preserve">
          <source>UTF-16BE</source>
          <target state="translated">UTF-16BE</target>
        </trans-unit>
        <trans-unit id="6af12beb19d40aa853839c482e864ce703f4d2a9" translate="yes" xml:space="preserve">
          <source>UTF-16LE</source>
          <target state="translated">UTF-16LE</target>
        </trans-unit>
        <trans-unit id="9e4d8d4f017185a065b570c771eb332a1c842bec" translate="yes" xml:space="preserve">
          <source>UTF-32BE</source>
          <target state="translated">UTF-32BE</target>
        </trans-unit>
        <trans-unit id="35cabe85c31dfe3f6b86974de33fef51a0f7276a" translate="yes" xml:space="preserve">
          <source>UTF-32LE</source>
          <target state="translated">UTF-32LE</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="f9496a431551e339492736948b4e238922bacdef" translate="yes" xml:space="preserve">
          <source>UTF-8 sequence</source>
          <target state="translated">UTF-8序列</target>
        </trans-unit>
        <trans-unit id="877994f4b4067d2a1f1f0f6bd6384f2638fcb6f8" translate="yes" xml:space="preserve">
          <source>UTF-8 string to convert.</source>
          <target state="translated">要转换的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="4ec698a623934218d006f758f60cc65200b7e5d5" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt;(Range)(ref Range uuidRange)</source>
          <target state="translated">UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt;（Range）（参考范围uuidRange）</target>
        </trans-unit>
        <trans-unit id="67faabd33b533aa2705b030a23deec418ddc4531" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt;(T)(T uuidString)</source>
          <target state="translated">UUID &lt;strong id=&quot;parseUUID&quot;&gt;parseUUID&lt;/strong&gt;（T）（T uuidString）</target>
        </trans-unit>
        <trans-unit id="cc9e30340d1753d3d85fd300f0e9b269c9de763e" translate="yes" xml:space="preserve">
          <source>UUID &lt;strong id=&quot;randomUUID&quot;&gt;randomUUID&lt;/strong&gt;(RNG)(ref RNG randomGen)</source>
          <target state="translated">UUID &lt;strong id=&quot;randomUUID&quot;&gt;randomUUID&lt;/strong&gt;（RNG）（参考RNG randomGen）</target>
        </trans-unit>
        <trans-unit id="a772ba2e5a42ae80f2c9272ebcf1178fcfb9d897" translate="yes" xml:space="preserve">
          <source>UUID namespaces</source>
          <target state="translated">UUID命名空间</target>
        </trans-unit>
        <trans-unit id="5138cdf5aa51c8e0f95889706fc9ee1e7f17902c" translate="yes" xml:space="preserve">
          <source>UUID uses a 16-ubyte representation for the UUID data. RFC 4122 defines a UUID as a special structure in big-endian format. These 16-ubytes always equal the big-endian structure defined in RFC 4122.</source>
          <target state="translated">UUID使用16个字节的UUID数据表示。RFC 4122将UUID定义为大恩迪安格式的特殊结构。这16个字节总是等于RFC 4122中定义的big-endian结构。</target>
        </trans-unit>
        <trans-unit id="97f3c3a3c12b841a2a4769e7f1a5d3a8268ab30f" translate="yes" xml:space="preserve">
          <source>UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify rows or records in order to ensure that they are unique across different databases, or for publication/subscription services. Network messages may be identified with a UUID to ensure that different parts of a message are put back together again. Distributed computing may use UUIDs to identify a remote procedure call. Transactions and classes involved in serialization may be identified by UUIDs. Microsoft's component object model (COM) uses UUIDs to distinguish different software component interfaces. UUIDs are inserted into documents from Microsoft Office programs. UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are also a basis for OIDs (object identifiers), and URNs (uniform resource name).</source>
          <target state="translated">UUID有许多应用。以下是一些例子。数据库可使用UUID识别行或记录,以确保它们在不同的数据库中是独一无二的,或用于出版/订阅服务。网络消息可以用UUID来识别,以确保消息的不同部分能重新放在一起。分布式计算可以使用UUID来识别远程过程调用。序列化中涉及的事务和类可以用UUID识别。微软的组件对象模型(COM)使用UUID来区分不同的软件组件接口。UUIDs被插入到Microsoft Office程序的文档中。UUIDs在高级系统格式(ASF)中识别音频或视频流。UUID也是OID(对象标识符)和URN(统一资源名称)的基础。</target>
        </trans-unit>
        <trans-unit id="7cfb32627383e93254e644d1ee41cde2752bcfaa" translate="yes" xml:space="preserve">
          <source>U[] &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">U [] &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5a8724faaa7b7c394cdf13e24050e05ae9df5e7" translate="yes" xml:space="preserve">
          <source>U[n] &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">U [n]个 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6328bc9f36f37764a79ddabe4b86ab6e97f09add" translate="yes" xml:space="preserve">
          <source>Ugaritic</source>
          <target state="translated">Ugaritic</target>
        </trans-unit>
        <trans-unit id="b338855e51e0be5b8018fcc6c3c8f1fb58ef1ed1" translate="yes" xml:space="preserve">
          <source>UnaExp &lt;code&gt;ue&lt;/code&gt;</source>
          <target state="translated">UnaExp &lt;code&gt;ue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7362d38845d769ab9292607291056855e2183b1" translate="yes" xml:space="preserve">
          <source>Unable to open the database file</source>
          <target state="translated">无法打开数据库文件</target>
        </trans-unit>
        <trans-unit id="33bd9ce85f04d2d2b0510e3bbb94561d4ef14386" translate="yes" xml:space="preserve">
          <source>Unary Expressions</source>
          <target state="translated">单式表达式</target>
        </trans-unit>
        <trans-unit id="591cb6d4ab93ebc2d2043b2cb411e0fb42e0f3f7" translate="yes" xml:space="preserve">
          <source>Unary Operator Overloading</source>
          <target state="translated">单元运算符超载</target>
        </trans-unit>
        <trans-unit id="f513f3dda804c19713470f3838e16096aa4d57eb" translate="yes" xml:space="preserve">
          <source>Unary SIMD instructions.</source>
          <target state="translated">一元SIMD指令。</target>
        </trans-unit>
        <trans-unit id="d4b656c31bdca61d3708bf6436103a5e4c87af7f" translate="yes" xml:space="preserve">
          <source>UnaryExpression</source>
          <target state="translated">UnaryExpression</target>
        </trans-unit>
        <trans-unit id="e57016edceec7e7b4449fe027bb35d1ba319eb9f" translate="yes" xml:space="preserve">
          <source>Unassigned</source>
          <target state="translated">Unassigned</target>
        </trans-unit>
        <trans-unit id="eb5d4c5516fc1c059de7a6392f9c37511d73768b" translate="yes" xml:space="preserve">
          <source>Unavailable Features</source>
          <target state="translated">不可用功能</target>
        </trans-unit>
        <trans-unit id="68af9ad2189921beb26a800d338b2a6b4e676cf3" translate="yes" xml:space="preserve">
          <source>Unclosed comment</source>
          <target state="translated">未结束的评论</target>
        </trans-unit>
        <trans-unit id="f6243a69cb62441fa6d87afa14c8d5e89b20730a" translate="yes" xml:space="preserve">
          <source>Unclosed quoted string</source>
          <target state="translated">未封闭的引号字符串</target>
        </trans-unit>
        <trans-unit id="0646f4afd90c8fdb87bbcb57b63ee1911f5a9a46" translate="yes" xml:space="preserve">
          <source>Undefined</source>
          <target state="translated">Undefined</target>
        </trans-unit>
        <trans-unit id="bf324c3d5f2f1b78051107d12302e948c629d468" translate="yes" xml:space="preserve">
          <source>Underlying ranges</source>
          <target state="translated">基本幅度</target>
        </trans-unit>
        <trans-unit id="83480b867507019f42179ab37987dcdb4c62cd97" translate="yes" xml:space="preserve">
          <source>Unescapes URL encoding in strings (converts all %XX codes to their 8bit versions). This function returns a new allocated string or NULL if an error occurred. Conversion Note: On non-ASCII platforms the ASCII %XX codes are converted into the host encoding.</source>
          <target state="translated">解除字符串中的URL编码(将所有%XX代码转换为8位版本)。如果发生错误,该函数将返回一个新分配的字符串或NULL。转换说明:在非ASCII平台上,ASCII %XX代码会被转换为主机编码。</target>
        </trans-unit>
        <trans-unit id="1043e7d94fb950dfc41b004ced60f3e79b56ed17" translate="yes" xml:space="preserve">
          <source>Unfortunately, there is no way to do it on Windows using the TZ Database name, so this function only exists on Posix systems.</source>
          <target state="translated">遗憾的是,在Windows上没有办法用TZ数据库的名字来做,所以这个功能只存在于Posix系统上。</target>
        </trans-unit>
        <trans-unit id="c7e823b88e4feebda781e31901fb8ed6b6646bbd" translate="yes" xml:space="preserve">
          <source>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252</source>
          <target state="translated">Unicode 5.0,ASCII,ISO-8859-1,ISO-8859-2,WINDOWS-1250,WINDOWS-1251,WINDOWS-1252。</target>
        </trans-unit>
        <trans-unit id="b81efb17a923e74f971664cf6551b29e3911eb7f" translate="yes" xml:space="preserve">
          <source>Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252</source>
          <target state="translated">Unicode 5.0,ASCII,ISO-8859-1,WINDOWS-1252。</target>
        </trans-unit>
        <trans-unit id="9efb04e249cf52e825a2ae577ec002967cfd9907" translate="yes" xml:space="preserve">
          <source>Unicode character U+</source>
          <target state="translated">统一码字符U+</target>
        </trans-unit>
        <trans-unit id="86d5346f841497e1a9a9e132b4794f45dbdd869c" translate="yes" xml:space="preserve">
          <source>Unicode character decomposition type.</source>
          <target state="translated">Unicode字符分解类型。</target>
        </trans-unit>
        <trans-unit id="85292ebf0b3cae013871cb556874cf9db932ca12" translate="yes" xml:space="preserve">
          <source>Unicode integrity is not preserved:</source>
          <target state="translated">不保留Unicode的完整性。</target>
        </trans-unit>
        <trans-unit id="3ec807b074593d04a3ef86db0a4d24fa457b2e5f" translate="yes" xml:space="preserve">
          <source>Unicode properties</source>
          <target state="translated">统一码属性</target>
        </trans-unit>
        <trans-unit id="5be5c9fefc535768d2b96dd8780acd22043ffcf7" translate="yes" xml:space="preserve">
          <source>Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.</source>
          <target state="translated">Unicode属性,如Scripts、Blocks和常见的二进制属性,如Alphabetic、White_Space、Hex_Digit等。</target>
        </trans-unit>
        <trans-unit id="4247bd31bdb74c5074c844a1f51c93a859ff8578" translate="yes" xml:space="preserve">
          <source>Unicode support</source>
          <target state="translated">支持Unicode</target>
        </trans-unit>
        <trans-unit id="b82773bc5411a43a67f701a9ac627a06c1cb6db2" translate="yes" xml:space="preserve">
          <source>Unicode v6.2</source>
          <target state="translated">Unicode v6.2</target>
        </trans-unit>
        <trans-unit id="7e2aea9a1091a65f50509009229ce4d23b5ee960" translate="yes" xml:space="preserve">
          <source>Unicode(tm) is a trademark of Unicode, Inc.</source>
          <target state="translated">Unicode(tm)是Unicode公司的商标。</target>
        </trans-unit>
        <trans-unit id="91c29c138dfa854b43a9c50a2f9ff956dcfd1401" translate="yes" xml:space="preserve">
          <source>Unified Canadian Aboriginal Syllabics</source>
          <target state="translated">加拿大土著人统一教学大纲</target>
        </trans-unit>
        <trans-unit id="0f85f583bbf512091ad1e17cda1699402ef799e1" translate="yes" xml:space="preserve">
          <source>Unified Canadian Aboriginal Syllabics Extended</source>
          <target state="translated">加拿大土著统一教学大纲扩展版</target>
        </trans-unit>
        <trans-unit id="4f290c277dbce6544950d95c7ffc983b5b870a4c" translate="yes" xml:space="preserve">
          <source>Unified_Ideograph</source>
          <target state="translated">Unified_Ideograph</target>
        </trans-unit>
        <trans-unit id="5ea2f727e179d06cc6c0064064aea5ee05d170fa" translate="yes" xml:space="preserve">
          <source>Uniform Function Call Syntax (UFCS)</source>
          <target state="translated">统一函数调用语法(UFCS)</target>
        </trans-unit>
        <trans-unit id="367b834ab9bc6ea15eef6f05af78776738e3081a" translate="yes" xml:space="preserve">
          <source>Uniform construction syntax for built-in scalar types</source>
          <target state="translated">统一内置标量类型的构造语法。</target>
        </trans-unit>
        <trans-unit id="bf061382e10d6798c2517c28e31d8d381de29d04" translate="yes" xml:space="preserve">
          <source>Uniform sampling</source>
          <target state="translated">统一抽样</target>
        </trans-unit>
        <trans-unit id="14c21961b2726c16163dc7492f677c46d510610a" translate="yes" xml:space="preserve">
          <source>UniformRNG &lt;code&gt;rng&lt;/code&gt;</source>
          <target state="translated">UniformRNG &lt;code&gt;rng&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dc2d8aa43cf4b7523681bf7a9d62b6503ab053" translate="yes" xml:space="preserve">
          <source>UniformRandomNumberGenerator &lt;code&gt;urng&lt;/code&gt;</source>
          <target state="translated">UniformRandomNumberGenerator &lt;code&gt;urng&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e68b9abd8444d542ee7ea49339a9fa1aecc4ff1" translate="yes" xml:space="preserve">
          <source>Union Constructors</source>
          <target state="translated">联合建筑公司</target>
        </trans-unit>
        <trans-unit id="b97025b5c9cabc7c40bfa14c6e38d256fa91fedc" translate="yes" xml:space="preserve">
          <source>Union of all data types. Storage allocated must be the right size of the data on the TARGET, not the host.</source>
          <target state="translated">所有数据类型的联合。分配的存储必须是TARGET上数据的正确大小,而不是主机。</target>
        </trans-unit>
        <trans-unit id="7fb0a0c24f714a3c6908f62d1750b60678074165" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;code&gt;ue&lt;/code&gt;</source>
          <target state="translated">UnionExp &lt;code&gt;ue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40c214e69699ab35dd26f2aea53893c65df5da1a" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;strong id=&quot;changeArrayLiteralLength&quot;&gt;changeArrayLiteralLength&lt;/strong&gt;(ref const Loc loc, TypeArray arrayType, Expression oldval, size_t oldlen, size_t newlen);</source>
          <target state="translated">UnionExp &lt;strong id=&quot;changeArrayLiteralLength&quot;&gt;changeArrayLiteralLength&lt;/strong&gt;（参考常量禄LOC，TypeArray arrayType中，表达OLDVAL，为size_t oldlen，为size_t newlen）;</target>
        </trans-unit>
        <trans-unit id="1331c179350671227b2059c060f0fb6cc96a01f6" translate="yes" xml:space="preserve">
          <source>UnionExp &lt;strong id=&quot;voidInitLiteral&quot;&gt;voidInitLiteral&lt;/strong&gt;(Type t, VarDeclaration var);</source>
          <target state="translated">UnionExp &lt;strong id=&quot;voidInitLiteral&quot;&gt;voidInitLiteral&lt;/strong&gt;（T型，VarDeclaration VAR）;</target>
        </trans-unit>
        <trans-unit id="573f8fc1579ee858b3690058c2822e4646fa3070" translate="yes" xml:space="preserve">
          <source>UnionExp* &lt;code&gt;pue&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pue&lt;/code&gt; * 设定值</target>
        </trans-unit>
        <trans-unit id="01e4d3a9b6c2a2f384ce5dac1eab2350dbb93588" translate="yes" xml:space="preserve">
          <source>Unions and Special Member Functions</source>
          <target state="translated">工会和会员特别职能</target>
        </trans-unit>
        <trans-unit id="a0102ec82c0bb90d78b643d15cf3fa6be00c6e25" translate="yes" xml:space="preserve">
          <source>Unions are a variation on structs.</source>
          <target state="translated">联合体是结构的一种变化。</target>
        </trans-unit>
        <trans-unit id="a62d59993aea7f6e6c355a91c3f289c9e8b350b1" translate="yes" xml:space="preserve">
          <source>Unions are by default initialized to whatever the &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; for the first field is, and if none is supplied, to the default initializer for the first field's type.</source>
          <target state="translated">联合默认情况下被&lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;初始化&lt;/i&gt;&lt;/a&gt;为第一个字段的&lt;i&gt;初始&lt;/i&gt;值设定项（如果未提供），则初始化为第一个字段类型的默认初始值设定项。</target>
        </trans-unit>
        <trans-unit id="4a6e457080b0b859845bccdbe95da2d70fb71565" translate="yes" xml:space="preserve">
          <source>Unions are constructed in the same way as structs.</source>
          <target state="translated">联合体的构造方式与结构体相同。</target>
        </trans-unit>
        <trans-unit id="f20d83de9444f44397049b15f04bc93ca6fb349d" translate="yes" xml:space="preserve">
          <source>Unions are initialized similarly to structs, except that only one initializer is allowed.</source>
          <target state="translated">联合体的初始化与结构类似,只是只允许一个初始化器。</target>
        </trans-unit>
        <trans-unit id="0b47874cdb794bfd2c5c4b866c3d58b4a7e2e1c5" translate="yes" xml:space="preserve">
          <source>Unions may have fields that have destructors. However, a union itself never has a destructor. When a union goes out of scope, destructors for it's fields are not called. If those calls are desired, they must be inserted explicitly by the programmer:</source>
          <target state="translated">联合体可以有具有反构件的字段。但是,一个联盟本身从来没有析构器。当一个联合体退出作用域时,它的字段的析构函数不会被调用。如果需要这些调用,必须由程序员明确地插入。</target>
        </trans-unit>
        <trans-unit id="2269a14097f76a4ebedc600cc449a6625817e305" translate="yes" xml:space="preserve">
          <source>Unions may have fields that have postblits. However, a union itself never has a postblit. Copying a union does not result in postblit calls for any fields. If those calls are desired, they must be inserted explicitly by the programmer:</source>
          <target state="translated">工会可能有带有尾号的字段。但是,一个联合体本身永远不会有后记。复制一个联合体不会导致对任何字段的后记调用。如果需要这些调用,必须由程序员明确地插入。</target>
        </trans-unit>
        <trans-unit id="b87fbd8e5787af83ccbd207ba527d5b29aa8f496" translate="yes" xml:space="preserve">
          <source>Unions may not have postblits, destructors, or invariants.</source>
          <target state="translated">联合体不可以有后记、破坏者或不变量。</target>
        </trans-unit>
        <trans-unit id="8298d2824bd021c0211d1ca231e5f2a363ecb036" translate="yes" xml:space="preserve">
          <source>Uniprocessor Garbage Collector Techniques</source>
          <target state="translated">Uniprocessor垃圾收集器技术</target>
        </trans-unit>
        <trans-unit id="27f5b1d97be4caf26df5cfa5ab8e2560a4fec6a2" translate="yes" xml:space="preserve">
          <source>Unique &lt;strong id=&quot;release&quot;&gt;release&lt;/strong&gt;();</source>
          <target state="translated">唯一&lt;strong id=&quot;release&quot;&gt;发布&lt;/strong&gt;（）；</target>
        </trans-unit>
        <trans-unit id="4be5d0f640b96963a935995d6fcf68492057bc00" translate="yes" xml:space="preserve">
          <source>Unique Expression</source>
          <target state="translated">独特的表达方式</target>
        </trans-unit>
        <trans-unit id="5ff1a5fc9718890c18a9173ea983ebaa427e76cf" translate="yes" xml:space="preserve">
          <source>Unique!T &lt;strong id=&quot;create&quot;&gt;create&lt;/strong&gt;(A...)(auto ref A args)</source>
          <target state="translated">独特！T &lt;strong id=&quot;create&quot;&gt;创建&lt;/strong&gt;（A ...）（自动引用A参数）</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">单元测试</target>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="translated">单元测试</target>
        </trans-unit>
        <trans-unit id="3db9bdfab0f022f13a4bb48d254cae9da8cb6639" translate="yes" xml:space="preserve">
          <source>Unit separator</source>
          <target state="translated">单元分离器</target>
        </trans-unit>
        <trans-unit id="b3da7cee02b824a66bc3ea485a41f342035764bb" translate="yes" xml:space="preserve">
          <source>Unit tests are a builtin framework of test cases applied to a module to determine if it is working properly. A D program can be run with unit tests enabled or disabled.</source>
          <target state="translated">单元测试是应用于模块的内置测试用例框架,以确定模块是否正常工作。D程序可以在启用或禁用单元测试的情况下运行。</target>
        </trans-unit>
        <trans-unit id="fefa6220ed6b9dc9a0e4d5cb4616b291bfab064b" translate="yes" xml:space="preserve">
          <source>Unit tests are a special function defined like:</source>
          <target state="translated">单元测试是一个特殊的函数,定义如。</target>
        </trans-unit>
        <trans-unit id="ad9b402c3f3372b26a20431c0ca8997a9ad0b7f1" translate="yes" xml:space="preserve">
          <source>Unit tests are run in the lexical order in which they appear within a module.</source>
          <target state="translated">单元测试按照模块中出现的词法顺序运行。</target>
        </trans-unit>
        <trans-unit id="a5c1e04fbed64b862e97e53f2641fe2ab46a7d9e" translate="yes" xml:space="preserve">
          <source>Unit tests, when enabled, are run after all static initialization is complete and before the &lt;code&gt;main()&lt;/code&gt; function is called.</source>
          <target state="translated">启用单元测试后，将在所有静态初始化完成之后且在调用 &lt;code&gt;main()&lt;/code&gt; 函数之前运行单元测试。</target>
        </trans-unit>
        <trans-unit id="055cf0570e66f2eea5181aa00a5c52d90e010552" translate="yes" xml:space="preserve">
          <source>UnitTestResult &lt;strong id=&quot;runModuleUnitTests&quot;&gt;runModuleUnitTests&lt;/strong&gt;();</source>
          <target state="translated">UnitTestResult &lt;strong id=&quot;runModuleUnitTests&quot;&gt;runModuleUnitTests&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="277414d40589e8e43fb1bb639e3eda546d3a39fa" translate="yes" xml:space="preserve">
          <source>Universally-unique identifiers for resources in distributed systems.</source>
          <target state="translated">分布式系统中资源的通用标识符。</target>
        </trans-unit>
        <trans-unit id="b65181ba4f28882f88c26feebc5a1054a0622a74" translate="yes" xml:space="preserve">
          <source>Unknown opcode in sqlite3_file_control()</source>
          <target state="translated">在 sqlite3_file_control()中的未知操作码。</target>
        </trans-unit>
        <trans-unit id="1931c3a0db3408e15d30035b5b64b4f6292dfc44" translate="yes" xml:space="preserve">
          <source>Unknown version</source>
          <target state="translated">未知版本</target>
        </trans-unit>
        <trans-unit id="33daa36ae00d362b5c2c8e9facf98bab576abcff" translate="yes" xml:space="preserve">
          <source>Unless a directory is specified in &lt;code&gt;args[0]&lt;/code&gt; or &lt;code&gt;program&lt;/code&gt;, &lt;code&gt;spawnProcess&lt;/code&gt; will search for the program in a platform-dependent manner. On POSIX systems, it will look for the executable in the directories listed in the PATH environment variable, in the order they are listed. On Windows, it will search for the executable in the following sequence:</source>
          <target state="translated">除非在 &lt;code&gt;args[0]&lt;/code&gt; 或 &lt;code&gt;program&lt;/code&gt; 中指定了目录， &lt;code&gt;spawnProcess&lt;/code&gt; 将以平台相关的方式搜索程序。在POSIX系统上，它将按列出的顺序在PATH环境变量中列出的目录中查找可执行文件。在Windows上，它将按以下顺序搜索可执行文件：</target>
        </trans-unit>
        <trans-unit id="b365da39577f92d7cfe9d00eec2c0518ddb0e1eb" translate="yes" xml:space="preserve">
          <source>Unless marked as &lt;code&gt;@trusted&lt;/code&gt; or &lt;code&gt;@safe&lt;/code&gt;, artifacts in this module allow implicit data sharing between threads and cannot guarantee that client code is free from low level data races.</source>
          <target state="translated">除非标记为 &lt;code&gt;@trusted&lt;/code&gt; 或 &lt;code&gt;@safe&lt;/code&gt; ，否则此模块中的构件允许线程之间进行隐式数据共享，并且不能保证客户端代码不受低级数据竞争的影响。</target>
        </trans-unit>
        <trans-unit id="2fa828ccd66084db8a03f15b05f0b611fac7ce01" translate="yes" xml:space="preserve">
          <source>Unless the child process inherits the standard input/output/error streams of its parent, one almost always wants the streams closed in the parent when &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; returns. Therefore, by default, this is done. If this is not desirable, pass any of these options to spawnProcess.</source>
          <target state="translated">除非子进程继承其父进程的标准输入/输出/错误流，否则几乎总是希望在&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;返回时在父进程中关闭流。因此，默认情况下，这是完成的。如果不希望这样做，请将任何这些选项传递给spawnProcess。</target>
        </trans-unit>
        <trans-unit id="0408692a5b5d8444ca9b8f0092ac439bf7234efa" translate="yes" xml:space="preserve">
          <source>Unless your system's local time zone deals with leap seconds (which is highly unlikely), then the only way to get a time zone which takes leap seconds into account is to use &lt;code&gt;PosixTimeZone&lt;/code&gt; with a time zone whose name starts with &quot;right/&quot;. Those time zone files do include leap seconds, and &lt;code&gt;PosixTimeZone&lt;/code&gt; will take them into account (though posix systems which use a &quot;right/&quot; time zone as their local time zone will</source>
          <target state="translated">除非系统的本地时区处理leap秒（极不可能），否则获取考虑takes秒的时区的唯一方法是将 &lt;code&gt;PosixTimeZone&lt;/code&gt; 与时区以&amp;ldquo; right /&amp;rdquo;开头。这些时区文件确实包含leap秒， &lt;code&gt;PosixTimeZone&lt;/code&gt; 会将它们考虑在内（尽管使用&amp;ldquo; right /&amp;rdquo;时区作为其本地时区的posix系统将</target>
        </trans-unit>
        <trans-unit id="64deb7f976a8cd98e26158b9c8e43cd6ab842a23" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;evenChunks&lt;/code&gt; takes a chunk count (not size). The returned range will contain zero or more &lt;code&gt;source.length / chunkCount + 1&lt;/code&gt; elements followed by &lt;code&gt;source.length / chunkCount&lt;/code&gt; elements. If &lt;code&gt;source.length &amp;lt; chunkCount&lt;/code&gt;, some chunks will be empty.</source>
          <target state="translated">与&lt;a href=&quot;#chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;evenChunks&lt;/code&gt; 需要块计数（而不是大小）。返回的范围将包含零个或多个 &lt;code&gt;source.length / chunkCount + 1&lt;/code&gt; 元素，后跟 &lt;code&gt;source.length / chunkCount&lt;/code&gt; 元素。如果 &lt;code&gt;source.length &amp;lt; chunkCount&lt;/code&gt; ，则一些块将为空。</target>
        </trans-unit>
        <trans-unit id="dcac2deafdbf1d1c8f905ae685dd247664bd1125" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#environment.opIndex&quot;&gt;&lt;code&gt;environment.opIndex&lt;/code&gt;&lt;/a&gt;, this function never throws on Posix.</source>
          <target state="translated">与&lt;a href=&quot;#environment.opIndex&quot;&gt; &lt;code&gt;environment.opIndex&lt;/code&gt; &lt;/a&gt;不同，此函数永远不会在Posix上抛出。</target>
        </trans-unit>
        <trans-unit id="78c9b1ecfc17a2d5366ab58d22803f6df68d29c3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#popFrontN&quot;&gt;&lt;code&gt;popFrontN&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;popFrontExactly&lt;/code&gt; will assume that the range holds at least &lt;code&gt;n&lt;/code&gt; elements. This makes &lt;code&gt;popFrontExactly&lt;/code&gt; faster than &lt;code&gt;popFrontN&lt;/code&gt;, but it also means that if &lt;code&gt;range&lt;/code&gt; does not contain at least &lt;code&gt;n&lt;/code&gt; elements, it will attempt to call &lt;code&gt;popFront&lt;/code&gt; on an empty range, which is undefined behavior. So, only use &lt;code&gt;popFrontExactly&lt;/code&gt; when it is guaranteed that &lt;code&gt;range&lt;/code&gt; holds at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">与&lt;a href=&quot;#popFrontN&quot;&gt; &lt;code&gt;popFrontN&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;popFrontExactly&lt;/code&gt; 将假定范围至少包含 &lt;code&gt;n&lt;/code&gt; 个元素。这使得 &lt;code&gt;popFrontExactly&lt;/code&gt; 速度比 &lt;code&gt;popFrontN&lt;/code&gt; ，但它也意味着，如果 &lt;code&gt;range&lt;/code&gt; 不包含至少 &lt;code&gt;n&lt;/code&gt; 元素，它会尝试打电话 &lt;code&gt;popFront&lt;/code&gt; 对空范围，这是不确定的行为。因此，仅在保证 &lt;code&gt;range&lt;/code&gt; 至少包含 &lt;code&gt;n&lt;/code&gt; 个元素时才使用 &lt;code&gt;popFrontExactly&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca26f78b889208702d57ff1d787f37620c2c7d92" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, however, it is illegal to pass a range with less than &lt;code&gt;n&lt;/code&gt; elements to &lt;code&gt;takeExactly&lt;/code&gt;; this will cause an assertion failure.</source>
          <target state="translated">但是，与&lt;a href=&quot;#take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;不同的是，传递少于 &lt;code&gt;n&lt;/code&gt; 个元素的范围以 &lt;code&gt;takeExactly&lt;/code&gt; 是非法的；这将导致断言失败。</target>
        </trans-unit>
        <trans-unit id="59fe163f287d88736da3589233f0c4e6d80fde94" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;take&lt;/code&gt; does not require that there are &lt;code&gt;n&lt;/code&gt; or more elements in &lt;code&gt;input&lt;/code&gt;. As a consequence, length information is not applied to the result unless &lt;code&gt;input&lt;/code&gt; also has length information.</source>
          <target state="translated">与&lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;take&lt;/code&gt; 不需要在 &lt;code&gt;input&lt;/code&gt; 包含 &lt;code&gt;n&lt;/code&gt; 个或更多元素。结果，除非 &lt;code&gt;input&lt;/code&gt; 也具有长度信息，否则不会将长度信息应用​​于结果。</target>
        </trans-unit>
        <trans-unit id="b8426ded2da3debb58d04add3a4a2ee0a01cedef" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;s,</source>
          <target state="translated">与&lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;不同，</target>
        </trans-unit>
        <trans-unit id="3c0a127638c1aa0ed774f4d832ca5f66eb374213" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt;, underscores (&lt;code&gt;_&lt;/code&gt;) are not supported for emphasizing text because it would break snake_case names and underscore prefix processing in &lt;a href=&quot;#emphasis&quot;&gt;identifier emphasis&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt;不同，下划线（ &lt;code&gt;_&lt;/code&gt; ）不支持强调文本，因为它会破坏snake_case名称并在&lt;a href=&quot;#emphasis&quot;&gt;标识符强调中&lt;/a&gt;加下划线前缀处理。</target>
        </trans-unit>
        <trans-unit id="62d6e6c303937f42cfdcfdeece835bc7d820f2ce" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;dropExactly&lt;/code&gt; will assume that the range holds at least &lt;code&gt;n&lt;/code&gt; elements. This makes &lt;code&gt;dropExactly&lt;/code&gt; faster than &lt;code&gt;drop&lt;/code&gt;, but it also means that if &lt;code&gt;range&lt;/code&gt; does not contain at least &lt;code&gt;n&lt;/code&gt; elements, it will attempt to call &lt;code&gt;popFront&lt;/code&gt; on an empty range, which is undefined behavior. So, only use &lt;code&gt;popFrontExactly&lt;/code&gt; when it is guaranteed that &lt;code&gt;range&lt;/code&gt; holds at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">与 &lt;code&gt;drop&lt;/code&gt; 不同， &lt;code&gt;dropExactly&lt;/code&gt; 将假定范围至少包含 &lt;code&gt;n&lt;/code&gt; 个元素。这使 &lt;code&gt;dropExactly&lt;/code&gt; 比 &lt;code&gt;drop&lt;/code&gt; 快得多，但是这也意味着，如果 &lt;code&gt;range&lt;/code&gt; 不包含至少 &lt;code&gt;n&lt;/code&gt; 个元素，它将尝试在空范围内调用 &lt;code&gt;popFront&lt;/code&gt; ，这是未定义的行为。因此，仅在保证 &lt;code&gt;range&lt;/code&gt; 至少包含 &lt;code&gt;n&lt;/code&gt; 个元素时才使用 &lt;code&gt;popFrontExactly&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dc495b4828660cfb1a6c926b761c16a9be27525" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;isSorted&lt;/code&gt;, &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; does not allow for equal values, i.e. values for which both &lt;code&gt;less(a, b)&lt;/code&gt; and &lt;code&gt;less(b, a)&lt;/code&gt; are false.</source>
          <target state="translated">与 &lt;code&gt;isSorted&lt;/code&gt; 不同， &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; 不允许使用相等的值，即 &lt;code&gt;less(a, b)&lt;/code&gt; 和 &lt;code&gt;less(b, a)&lt;/code&gt; 均为假的值。</target>
        </trans-unit>
        <trans-unit id="d9f03ddd3a521372a8aeb68d3750dc19aca654fd" translate="yes" xml:space="preserve">
          <source>Unlike C, there is no global 'errno' variable. Consequently, almost all of these functions are pure nothrow.</source>
          <target state="translated">与C语言不同,没有全局的 &quot;errno &quot;变量,因此,几乎所有的函数都是纯nothrow。因此,几乎所有这些函数都是纯nothrow。</target>
        </trans-unit>
        <trans-unit id="48065da6c19826224a06652b7752de447906d1e2" translate="yes" xml:space="preserve">
          <source>Unlike a template instantiation, a template mixin's body is evaluated within the scope where the mixin appears, not where the template declaration is defined. It is analogous to cutting and pasting the body of the template into the location of the mixin into a &lt;a href=&quot;#mixin_scope&quot;&gt;nested scope&lt;/a&gt;. It is useful for injecting parameterized &amp;lsquo;boilerplate&amp;rsquo; code, as well as for creating templated nested functions, which is not possible with template instantiations.</source>
          <target state="translated">与模板实例化不同，模板mixin的主体是在mixin出现的范围而不是定义模板声明的范围内进行评估的。这类似于将模板的主体剪切并粘贴到mixin的位置到&lt;a href=&quot;#mixin_scope&quot;&gt;嵌套范围中&lt;/a&gt;。这对于注入参数化的&amp;ldquo;样板&amp;rdquo;代码以及创建模板化嵌套函数非常有用，而模板实例化是不可能的。</target>
        </trans-unit>
        <trans-unit id="b78dd4d0c28721d6f33da60e8a9c5d426e8812c8" translate="yes" xml:space="preserve">
          <source>Unlike classes and interfaces with D linkage, &lt;code&gt;extern (C++)&lt;/code&gt; classes and interfaces are not rooted in &lt;code&gt;Object&lt;/code&gt; and cannot be used with &lt;code&gt;typeid&lt;/code&gt;.</source>
          <target state="translated">与具有D链接的类和接口不同， &lt;code&gt;extern (C++)&lt;/code&gt; 类和接口不是基于 &lt;code&gt;Object&lt;/code&gt; 的，因此不能与 &lt;code&gt;typeid&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="c4a06fb407933b874e0e43772b69d5b66b0d98d0" translate="yes" xml:space="preserve">
          <source>Unlike module level declarations, declarations within function scope are processed in order. This means that two nested functions cannot mutually call each other:</source>
          <target state="translated">与模块级声明不同,函数作用域内的声明是按顺序处理的。这意味着两个嵌套的函数不能相互调用。</target>
        </trans-unit>
        <trans-unit id="1e921c8f35a8b97ca5f6203bfbaa7a401ab85c77" translate="yes" xml:space="preserve">
          <source>Unlike other functional programming languages, D's &lt;code&gt;pure&lt;/code&gt; functions allow modification of the caller state through their mutable parameters.</source>
          <target state="translated">与其他函数式编程语言不同，D的 &lt;code&gt;pure&lt;/code&gt; 函数允许通过其可变参数来修改调用者的状态。</target>
        </trans-unit>
        <trans-unit id="0b036ee20c8407122782725738b7cc625cbeaae0" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;shared&lt;/code&gt; attribute, &lt;code&gt;__gshared&lt;/code&gt; provides no safe-guards against data races or other multi-threaded synchronization issues. It is the responsibility of the programmer to ensure that access to variables marked &lt;code&gt;__gshared&lt;/code&gt; is synchronized correctly.</source>
          <target state="translated">与 &lt;code&gt;shared&lt;/code&gt; 属性不同， &lt;code&gt;__gshared&lt;/code&gt; 不提供针对数据争用或其他多线程同步问题的安全防护。程序员有责任确保正确同步对标记为 &lt;code&gt;__gshared&lt;/code&gt; 的变量的访问。</target>
        </trans-unit>
        <trans-unit id="c04836bfb0781712a35902e55ee66bab09a7b952" translate="yes" xml:space="preserve">
          <source>Unlike the allocators for the C and C++ programming languages, which manage the allocated size internally, these allocators require that the client maintains (or knows</source>
          <target state="translated">与C和C++编程语言的分配器不同,这些分配器在内部管理分配的大小,需要客户端维护(或者知道</target>
        </trans-unit>
        <trans-unit id="4328a809b4119b5d1cdcaad1f63f238165209f39" translate="yes" xml:space="preserve">
          <source>Unlike the other modules in std.datetime, this module is not currently publicly imported in std.datetime.package, because the old versions of this functionality which use &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt; are in std.datetime.package and would conflict with the symbols in this module. After the old symbols have gone through the deprecation cycle and have been fully removed, then this module will be publicly imported in std.datetime.package. The old, deprecated symbols are currently scheduled to be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">与std.datetime中的其他模块不同，此模块当前未公开导入std.datetime.package中，因为使用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;的该功能的旧版本位于std.datetime.package中，并且会与符号冲突在此模块中。在旧符号经过弃用周期并被完全删除后，该模块将公开导入std.datetime.package中。目前已计划在2018年10月从文档中删除旧的，已过时的符号，并于2019年10月从Phobos中完全删除它们。</target>
        </trans-unit>
        <trans-unit id="2e44048ada6dc1ea0f3431423758e0f9238ad67a" translate="yes" xml:space="preserve">
          <source>Unlike the other modules in std.datetime, this module is not currently publicly imported in std.datetime.package, because the old versions of this functionality which use &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt; are in std.datetime.package and would conflict with the symbols in this module. After the old symbols have gone through the deprecation cycle and have been fully removed, then this module will be publicly imported in std.datetime.package. The old, deprecated symbols has been removed from the documentation in December 2019 and currently scheduled to be fully removed from Phobos after 2.094.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a96be23bb834e45b7c6ec859f0a33bbc2f1ea04" translate="yes" xml:space="preserve">
          <source>Unlike the other overloads of &lt;a href=&quot;#translate&quot;&gt;&lt;code&gt;translate&lt;/code&gt;&lt;/a&gt;, this one does not take an AA. Rather, it takes a &lt;code&gt;string&lt;/code&gt; generated by &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与其他&lt;a href=&quot;#translate&quot;&gt; &lt;code&gt;translate&lt;/code&gt; &lt;/a&gt;重载不同，此重载不需要AA。而是使用&lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; &lt;/a&gt;生成的 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2e414f9a9014ee44b7edd2f5c74b2ba99d64ccc" translate="yes" xml:space="preserve">
          <source>Unlike the rint functions, nearbyint does not raise the FE_INEXACT exception.</source>
          <target state="translated">与rint函数不同的是,nearbyint不会引发FE_INEXACT异常。</target>
        </trans-unit>
        <trans-unit id="57cc5a44978b2a56fd0b72e29be98d16b0472af0" translate="yes" xml:space="preserve">
          <source>Unloads the dynamic library referenced by p. If this library contains a D runtime then any necessary finalization or cleanup of that runtime will be performed.</source>
          <target state="translated">卸载p引用的动态库,如果这个库包含一个D运行时,那么将对该运行时进行任何必要的定型或清理。</target>
        </trans-unit>
        <trans-unit id="2e66bd886206de5f2b17ce23c8df1ed8d25d65b5" translate="yes" xml:space="preserve">
          <source>Unlock Notification</source>
          <target state="translated">解锁通知</target>
        </trans-unit>
        <trans-unit id="664d16b3bbd5ce740428335dc91179d8203f0409" translate="yes" xml:space="preserve">
          <source>Unpacks the content of a &lt;code&gt;Nullable&lt;/code&gt;, performs an operation and packs it again. Does nothing if isNull.</source>
          <target state="translated">解压缩 &lt;code&gt;Nullable&lt;/code&gt; 的内容，执行操作并再次打包。如果isNull则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="cc345a9119374c547d811f8c7da41c9ef92ad2fe" translate="yes" xml:space="preserve">
          <source>Unpadded variation of Base64 encoding that is safe for use in URLs and filenames, as used in RFCs 4648 and 7515 (JWS/JWT/JWE).</source>
          <target state="translated">未填充的Base64编码变体,可安全用于URL和文件名,如RFCs 4648和7515(JWS/JWT/JWE)。</target>
        </trans-unit>
        <trans-unit id="f88d720623b583f1cffc913373fdcc3a60ba2726" translate="yes" xml:space="preserve">
          <source>Unqual!(ElementEncodingType!R)[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(Allocator, R)(auto ref Allocator alloc, R range)</source>
          <target state="translated">不合格！（ElementEncodingType！R）[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;（分配器，R）（自动引用分配器分配，R范围）</target>
        </trans-unit>
        <trans-unit id="3c02fdbec5f33d0e592b953502081d961d449bb0" translate="yes" xml:space="preserve">
          <source>Unqual!(Largest!(F, H)) &lt;strong id=&quot;powmod&quot;&gt;powmod&lt;/strong&gt;(F, G, H)(F x, G n, H m)</source>
          <target state="translated">不等（最大（F，H））&lt;strong id=&quot;powmod&quot;&gt;powmod&lt;/strong&gt;（F，G，H）（F x，G n，H m）</target>
        </trans-unit>
        <trans-unit id="2bcb32fecdb532acd729e7486f0232969b7c3e9c" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(alias rfunc = rint, F)(const F val, const F unit)</source>
          <target state="translated">不等于F &lt;strong id=&quot;quantize&quot;&gt;量化&lt;/strong&gt;（别名rfunc = rint，F）（const F val，const F unit）</target>
        </trans-unit>
        <trans-unit id="9a98f2e85574e76d68401f4ce73c39509c4a2933" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(real base, alias rfunc = rint, F, E)(const F val, const E exp)</source>
          <target state="translated">F不等于F &lt;strong id=&quot;quantize&quot;&gt;量化&lt;/strong&gt;（实数基，别名rfunc = rint，F，E）（const F val，const E exp）</target>
        </trans-unit>
        <trans-unit id="1e2635e37463787b5dba88522830617f525b628d" translate="yes" xml:space="preserve">
          <source>Unqual!F &lt;strong id=&quot;quantize&quot;&gt;quantize&lt;/strong&gt;(real base, long exp = 1, alias rfunc = rint, F)(const F val)</source>
          <target state="translated">F不等式&lt;strong id=&quot;quantize&quot;&gt;量化&lt;/strong&gt;（实数基数，long exp = 1，别名rfunc = rint，F）（const F val）</target>
        </trans-unit>
        <trans-unit id="5a8d3ca0e300be0d25c318a263a03af4f2fff63d" translate="yes" xml:space="preserve">
          <source>Unqualified data has unqualified affixes.</source>
          <target state="translated">不合格的数据有不合格的附加值。</target>
        </trans-unit>
        <trans-unit id="c723d38c4fa3b7930c545d9e405d1f146212a63e" translate="yes" xml:space="preserve">
          <source>Unrestricted use of compile-time features</source>
          <target state="translated">不受限制地使用编译时的功能。</target>
        </trans-unit>
        <trans-unit id="80cfb4a037726fdae410bbf6df144554bff220d4" translate="yes" xml:space="preserve">
          <source>Unsafe function that wraps an existing &lt;code&gt;FILE*&lt;/code&gt;. The resulting &lt;code&gt;File&lt;/code&gt; never takes the initiative in closing the file. Note that the created file has no &lt;a href=&quot;#name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">包装现有 &lt;code&gt;FILE*&lt;/code&gt; 不安全函数。生成的 &lt;code&gt;File&lt;/code&gt; 永远不会主动关闭文件。请注意，创建的文件没有&lt;a href=&quot;#name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65422cb666169d3f3987078a0c14c3573d3c2445" translate="yes" xml:space="preserve">
          <source>Unsigned long divide.</source>
          <target state="translated">无符号长除法。</target>
        </trans-unit>
        <trans-unit id="0b87e9858f088c1c3ef7326a4daa7bc92af7a7dd" translate="yes" xml:space="preserve">
          <source>Unsigned or signed integers to strings.</source>
          <target state="translated">将无符号或有符号的整数转换成字符串。</target>
        </trans-unit>
        <trans-unit id="7dd2dae7076eed8003f9916d0a11ef6b86330446" translate="yes" xml:space="preserve">
          <source>Unsigned types are forwarded</source>
          <target state="translated">无符号类型被转发</target>
        </trans-unit>
        <trans-unit id="db264537a77391b4d1ffa4ba5078dbd65e89c632" translate="yes" xml:space="preserve">
          <source>Unsigned!T &lt;strong id=&quot;absUnsign&quot;&gt;absUnsign&lt;/strong&gt;(T)(T x)</source>
          <target state="translated">Unsigned！T &lt;strong id=&quot;absUnsign&quot;&gt;absUnsign&lt;/strong&gt;（T）（T x）</target>
        </trans-unit>
        <trans-unit id="ee28505eeae48ed21fb9c1a0cf9d2afe5eb71525" translate="yes" xml:space="preserve">
          <source>Unspecified address family</source>
          <target state="translated">未说明地址的家庭</target>
        </trans-unit>
        <trans-unit id="12a25d56dc3fd00254d1725dedadf02ca44b6632" translate="yes" xml:space="preserve">
          <source>Until!(pred, Range, Sentinel) &lt;strong id=&quot;until&quot;&gt;until&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range, Sentinel)(Range range, Sentinel sentinel, OpenRight openRight = Yes.openRight)</source>
          <target state="translated">直到！（pred，Range，Sentinel）&lt;strong id=&quot;until&quot;&gt;直到&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，Range，Sentinel）（范围，Sentinel前哨，OpenRight openRight = Yes.openRight）</target>
        </trans-unit>
        <trans-unit id="4b4508b4a6bcff851bf86982a2055c2003b1fa47" translate="yes" xml:space="preserve">
          <source>Until!(pred, Range, void) &lt;strong id=&quot;until&quot;&gt;until&lt;/strong&gt;(alias pred, Range)(Range range, OpenRight openRight = Yes.openRight);</source>
          <target state="translated">直到！（pred，Range，void）&lt;strong id=&quot;until&quot;&gt;直到&lt;/strong&gt;（alias pred，Range）（Range range，OpenRight openRight = Yes.openRight）;</target>
        </trans-unit>
        <trans-unit id="9c59dea84fd569db02119fea1a063859bf29b83a" translate="yes" xml:space="preserve">
          <source>Untyped array of bytes read.</source>
          <target state="translated">读取的非类型字节数组。</target>
        </trans-unit>
        <trans-unit id="4136979d06ff082f9f315b1eebb740ff6c03f3f6" translate="yes" xml:space="preserve">
          <source>Unused</source>
          <target state="translated">Unused</target>
        </trans-unit>
        <trans-unit id="b6935e98e40b6e21b32a31ee8441a03644c81e5c" translate="yes" xml:space="preserve">
          <source>Update real environment with our copy.</source>
          <target state="translated">用我们的副本更新真实环境。</target>
        </trans-unit>
        <trans-unit id="9bfdc7ffd31c3f1d9f8a46b9030a47cb21f4a6a6" translate="yes" xml:space="preserve">
          <source>Upload file from local files system using the HTTP or FTP protocol.</source>
          <target state="translated">使用HTTP或FTP协议从本地文件系统上传文件。</target>
        </trans-unit>
        <trans-unit id="d92a94252ae6e6e7308555bfab068876b651496a" translate="yes" xml:space="preserve">
          <source>Upon a correct comparison, returns the result of the comparison. Otherwise, the function terminates the application so it never returns.</source>
          <target state="translated">比较正确后,返回比较结果。否则,该函数将终止应用程序,所以永远不会返回。</target>
        </trans-unit>
        <trans-unit id="635a8d59b65d6fe6e79727c2b607e63e7021a7fc" translate="yes" xml:space="preserve">
          <source>Upon a mistaken comparison such as &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt;, the function never returns because it throws a &lt;code&gt;Throw.CheckedFailure&lt;/code&gt; exception.</source>
          <target state="translated">&lt;code&gt;Throw.CheckedFailure&lt;/code&gt; 错误的比较（例如 &lt;code&gt;int(-1) &amp;lt; uint(0)&lt;/code&gt; ，该函数将永远不会返回，因为它将引发Throw.CheckedFailure异常。</target>
        </trans-unit>
        <trans-unit id="fa0a038d12e10d6ea11977030e0079027d88a558" translate="yes" xml:space="preserve">
          <source>Upon deallocation, the deallocated block is inserted in the internally maintained free tree (not returned to the parent). The free tree is not kept balanced. Instead, it has a last-in-first-out flavor because newly inserted blocks are rotated to the root of the tree. That way allocations are cache friendly and also frequently used sizes are more likely to be found quickly, whereas seldom used sizes migrate to the leaves of the tree.</source>
          <target state="translated">在重定位时,重定位后的块被插入到内部维护的自由树中(不返回父树)。自由树不保持平衡。相反,它有一种最后进先出的味道,因为新插入的块会被轮换到树的根部。这样分配对缓存很友好,而且经常使用的大小也更容易被快速找到,而很少使用的大小则会迁移到树叶上。</target>
        </trans-unit>
        <trans-unit id="5f1bf936fc97a8f0474440921cf17c9bca92dd9a" translate="yes" xml:space="preserve">
          <source>Upper case letters</source>
          <target state="translated">大写字母</target>
        </trans-unit>
        <trans-unit id="83087183cf2fc461034d823bb990cf31750aea63" translate="yes" xml:space="preserve">
          <source>Uppercase</source>
          <target state="translated">Uppercase</target>
        </trans-unit>
        <trans-unit id="7a4164382331e68559c0554c6d69676b3cadeb03" translate="yes" xml:space="preserve">
          <source>Uppercase_Letter</source>
          <target state="translated">Uppercase_Letter</target>
        </trans-unit>
        <trans-unit id="c697647e510548f93776f9aafa822873da30eacb" translate="yes" xml:space="preserve">
          <source>UprExpression</source>
          <target state="translated">UprExpression</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="607204c2f99f603cd34be761bcbeaa8343288f47" translate="yes" xml:space="preserve">
          <source>Usage is otherwise identical to &lt;code&gt;task&lt;/code&gt;.</source>
          <target state="translated">用法与 &lt;code&gt;task&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="47d7700c39adc856cd703ac849cd6f7a58cd58a0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#DigestType&quot;&gt;&lt;code&gt;DigestType&lt;/code&gt;&lt;/a&gt; to obtain the actual return type.</source>
          <target state="translated">使用&lt;a href=&quot;#DigestType&quot;&gt; &lt;code&gt;DigestType&lt;/code&gt; &lt;/a&gt;获取实际的返回类型。</target>
        </trans-unit>
        <trans-unit id="adbbdb084a9fb0ec3254af6094f4eb6c04b801eb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#digestLength&quot;&gt;&lt;code&gt;digestLength&lt;/code&gt;&lt;/a&gt; to obtain the length of the ubyte array.</source>
          <target state="translated">使用&lt;a href=&quot;#digestLength&quot;&gt; &lt;code&gt;digestLength&lt;/code&gt; &lt;/a&gt;来获取ubyte数组的长度。</target>
        </trans-unit>
        <trans-unit id="b3231f8622cd090ef9e587f5edbb465aca7b09c8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#feqrel&quot;&gt;&lt;code&gt;feqrel&lt;/code&gt;&lt;/a&gt; to get the number of equal bits in the mantissa.</source>
          <target state="translated">使用&lt;a href=&quot;#feqrel&quot;&gt; &lt;code&gt;feqrel&lt;/code&gt; &lt;/a&gt;获取尾数中的相等位数。</target>
        </trans-unit>
        <trans-unit id="6d9307c326b8942333b6c398ebd4c07ddf71f566" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#isFunctionPointer&quot;&gt;&lt;code&gt;isFunctionPointer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#isDelegate&quot;&gt;&lt;code&gt;isDelegate&lt;/code&gt;&lt;/a&gt; for detecting those types respectively.</source>
          <target state="translated">使用&lt;a href=&quot;#isFunctionPointer&quot;&gt; &lt;code&gt;isFunctionPointer&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#isDelegate&quot;&gt; &lt;code&gt;isDelegate&lt;/code&gt; &lt;/a&gt;分别检测那些类型。</target>
        </trans-unit>
        <trans-unit id="05ceeae1c0ec5acb33be5d48da2dcb40fadf69b9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#makeTransTable&quot;&gt;&lt;code&gt;makeTransTable&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">请改用&lt;a href=&quot;#makeTransTable&quot;&gt; &lt;code&gt;makeTransTable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0a91d81a9ba5ac4e99ca49d89974cc7a9058e19" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;std_range#only&quot;&gt;&lt;code&gt;std.range.only&lt;/code&gt;&lt;/a&gt; to find single elements:</source>
          <target state="translated">使用&lt;a href=&quot;std_range#only&quot;&gt; &lt;code&gt;std.range.only&lt;/code&gt; &lt;/a&gt;查找单个元素：</target>
        </trans-unit>
        <trans-unit id="48dd858d3ce799ecfe17031cfb5c7e47121b6231" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Yes.keepTerminator&lt;/code&gt; to include the terminator at the end of each line.</source>
          <target state="translated">使用 &lt;code&gt;Yes.keepTerminator&lt;/code&gt; 在每行的末尾包含终止符。</target>
        </trans-unit>
        <trans-unit id="8b6c1674d2f204c22694f576b979cd1814df2141" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fold&lt;/code&gt; instead of &lt;code&gt;reduce&lt;/code&gt; to use the seed version in a UFCS chain.</source>
          <target state="translated">使用 &lt;code&gt;fold&lt;/code&gt; 而不是 &lt;code&gt;reduce&lt;/code&gt; 可以在UFCS链中使用种子版本。</target>
        </trans-unit>
        <trans-unit id="ffd1556b516ef1f66dbe93c932b16f01c4bc9667" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ptrdiff_t&lt;/code&gt; as an alias for a signed integral type that can span the address space. A type representing the difference between two pointers should be of type &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;ptrdiff_t&lt;/code&gt; 用作可跨越地址空间的带符号整数类型的别名。表示两个指针之间的差异的类型应该是 &lt;code&gt;ptrdiff_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="7fdf440fcaae93b5efe254ec61870d973ace818a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;size_t&lt;/code&gt; as an alias for an unsigned integral type that can span the address space. Array indices should be of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;size_t&lt;/code&gt; 作为可跨越地址空间的无符号整数类型的别名。数组索引应为 &lt;code&gt;size_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="0c8e53d39e2a0f98ecbcc400dea4845b6223508c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;t.expand&lt;/code&gt; for a &lt;code&gt;Tuple&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to expand it into its components. The result of &lt;code&gt;expand&lt;/code&gt; acts as if the &lt;code&gt;Tuple&lt;/code&gt;'s components were listed as a list of values. (Ordinarily, a &lt;code&gt;Tuple&lt;/code&gt; acts as a single value.)</source>
          <target state="translated">将 &lt;code&gt;t.expand&lt;/code&gt; 用于 &lt;code&gt;Tuple&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; ,以将其扩展为它的组件。 &lt;code&gt;expand&lt;/code&gt; 的结果就像将 &lt;code&gt;Tuple&lt;/code&gt; 的组件列为值列表一样。（通常， &lt;code&gt;Tuple&lt;/code&gt; 充当单个值。）</target>
        </trans-unit>
        <trans-unit id="48d884b7ca15aa475ec50789ca2ff3e23d86c484" translate="yes" xml:space="preserve">
          <source>Use EnumMembers to generate a switch statement using static foreach.</source>
          <target state="translated">使用EnumMembers使用静态foreach生成一个开关语句。</target>
        </trans-unit>
        <trans-unit id="ea3185b41d0b5eef9ea7299e9eaac7a36af0572e" translate="yes" xml:space="preserve">
          <source>Use a delegate:</source>
          <target state="translated">使用代表。</target>
        </trans-unit>
        <trans-unit id="0c1e0d0bf9ac652eb81fddab0fdf99124b593eff" translate="yes" xml:space="preserve">
          <source>Use a lambda to get the thrown object.</source>
          <target state="translated">使用一个lambda来获取抛出的对象。</target>
        </trans-unit>
        <trans-unit id="873a141220012e552838fdcfee0dd363789fe021" translate="yes" xml:space="preserve">
          <source>Use a range for splitting</source>
          <target state="translated">使用一个范围来分割</target>
        </trans-unit>
        <trans-unit id="743a812236b290eb42a4bbf575f256526d81c48f" translate="yes" xml:space="preserve">
          <source>Use a separate mutex when init blocks on another thread that might also call initOnce.</source>
          <target state="translated">当init块在另一个线程上使用时,使用一个单独的mutex,该线程也可能调用initOnce。</target>
        </trans-unit>
        <trans-unit id="b175392fd564ac3cefbc17dfb5b685defa989e44" translate="yes" xml:space="preserve">
          <source>Use a union to share storage with a pointer:</source>
          <target state="translated">使用联盟与指针共享存储。</target>
        </trans-unit>
        <trans-unit id="b01dba754a5979101f473d00f0a72b08eaa453e0" translate="yes" xml:space="preserve">
          <source>Use an automated tool such as SWIG to construct a C wrapper.</source>
          <target state="translated">使用SWIG等自动化工具来构建C语言包装器。</target>
        </trans-unit>
        <trans-unit id="391314ce9442e0f12875856e20c62869fdd57c69" translate="yes" xml:space="preserve">
          <source>Use an existing socket handle.</source>
          <target state="translated">使用现有的插座手柄。</target>
        </trans-unit>
        <trans-unit id="a7f84b37a52370f02dd55991fe07b971f3630397" translate="yes" xml:space="preserve">
          <source>Use bitwise OR to combine flags.</source>
          <target state="translated">使用位性OR来组合标志。</target>
        </trans-unit>
        <trans-unit id="d8684aed3619612b2b8756065eb3877a3a2f839f" translate="yes" xml:space="preserve">
          <source>Use dynamic arrays for larger arrays.</source>
          <target state="translated">对大型数组使用动态数组。</target>
        </trans-unit>
        <trans-unit id="666b47896c954d06222547665bcbfad2b613e2cd" translate="yes" xml:space="preserve">
          <source>Use dynamic arrays instead of pointers to arrays as much as practical. Indexing of dynamic arrays are bounds checked, avoiding buffer underflow and overflow problems.</source>
          <target state="translated">尽量使用动态数组代替数组的指针。动态数组的索引是经过边界检查的,避免了缓冲区下溢和溢出问题。</target>
        </trans-unit>
        <trans-unit id="7d2098c363acbeebbd0189589ce87c1539461b35" translate="yes" xml:space="preserve">
          <source>Use exceptions when input has incorrect CSV.</source>
          <target state="translated">当输入的CSV不正确时使用异常。</target>
        </trans-unit>
        <trans-unit id="4f7a702bd6e584b41d91d0f760813b556c810824" translate="yes" xml:space="preserve">
          <source>Use instead:</source>
          <target state="translated">用代替。</target>
        </trans-unit>
        <trans-unit id="a0bd8b9fd1352e9a7ee83b86e96f850112dd5cf1" translate="yes" xml:space="preserve">
          <source>Use leading zeros to pad rather than spaces (except for the floating point values &lt;code&gt;nan&lt;/code&gt; and &lt;code&gt;infinity&lt;/code&gt;). Ignore if there's a</source>
          <target state="translated">使用前导零填充而不是空格（浮点值 &lt;code&gt;nan&lt;/code&gt; 和 &lt;code&gt;infinity&lt;/code&gt; 除外）。忽略是否​​有</target>
        </trans-unit>
        <trans-unit id="e9eb0693d837d691dc401377d0b5f372d6ba7c76" translate="yes" xml:space="preserve">
          <source>Use native byte order</source>
          <target state="translated">使用本地字节顺序</target>
        </trans-unit>
        <trans-unit id="494d644b4cea82b0f2a11f12d31fe2c2c6340bb0" translate="yes" xml:space="preserve">
          <source>Use of this facility may invalidate grapheme cluster, see also &lt;a href=&quot;#Grapheme.valid&quot;&gt;&lt;code&gt;Grapheme.valid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用此功能可能会使字素簇失效，另请参阅&lt;a href=&quot;#Grapheme.valid&quot;&gt; &lt;code&gt;Grapheme.valid&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b875251d6eb81c5967bf6e62329a54f26bfa6687" translate="yes" xml:space="preserve">
          <source>Use of this facility may invalidate grapheme cluster, see also &lt;code&gt;valid&lt;/code&gt;.</source>
          <target state="translated">使用此功能可能会使字素簇失效，另请参见 &lt;code&gt;valid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="884a243fefd8e60fe323817fec2a996c8bebbfbc" translate="yes" xml:space="preserve">
          <source>Use of void initializers is rarely useful for individual local variables, as a modern optimizer will remove the dead store of its initialization if it is initialized later.</source>
          <target state="translated">使用void初始化器对单个局部变量很少有用,因为如果以后再初始化,现代优化器会删除其初始化的死存储。</target>
        </trans-unit>
        <trans-unit id="5f23be35fdcc7ad601fb3afd85d59caa262fe40f" translate="yes" xml:space="preserve">
          <source>Use of with object symbols that shadow local symbols with the same identifier are not allowed. This is to reduce the risk of inadvertent breakage of with statements when new members are added to the object declaration.</source>
          <target state="translated">不允许使用具有相同标识符的本地符号的with对象符号。这是为了减少在对象声明中添加新成员时无意中破坏with语句的风险。</target>
        </trans-unit>
        <trans-unit id="191654677e98da602653c371d9dfd799ee8ada8a" translate="yes" xml:space="preserve">
          <source>Use only if you have waited on every &lt;code&gt;Task&lt;/code&gt; and therefore know the queue is empty, or if you speculatively executed some tasks and no longer need the results.</source>
          <target state="translated">仅当您等待每个 &lt;code&gt;Task&lt;/code&gt; 并因此知道队列为空时，或者您以推测方式执行了一些任务并且不再需要结果时，才使用此属性。</target>
        </trans-unit>
        <trans-unit id="6a3134f25820d6e9b99efcc040afa78a19060e81" translate="yes" xml:space="preserve">
          <source>Use opSlice() from now on.</source>
          <target state="translated">从现在开始使用 opSlice()。</target>
        </trans-unit>
        <trans-unit id="0f7ce138690e71e3a3dfa4ced6f5458ab1f5899d" translate="yes" xml:space="preserve">
          <source>Use splitter without a separator</source>
          <target state="translated">使用不带分离器的分离器</target>
        </trans-unit>
        <trans-unit id="18386a6712ddd2e90ccdfcddd96ef23c786f1142" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#RangePrimitive&quot;&gt;&lt;code&gt;RangePrimitive&lt;/code&gt;&lt;/a&gt; enum to specify which primitives to handle. Multiple range primitives can be handled at once by using the &lt;code&gt;OR&lt;/code&gt; operator or the pseudo-primitives &lt;code&gt;RangePrimitive.access&lt;/code&gt; and &lt;code&gt;RangePrimitive.pop&lt;/code&gt;. All handled primitives must have return types or values compatible with the user-supplied handler.</source>
          <target state="translated">使用&lt;a href=&quot;#RangePrimitive&quot;&gt; &lt;code&gt;RangePrimitive&lt;/code&gt; &lt;/a&gt;枚举可指定要处理的原语。可以使用 &lt;code&gt;OR&lt;/code&gt; 运算符或伪基元 &lt;code&gt;RangePrimitive.access&lt;/code&gt; 和 &lt;code&gt;RangePrimitive.pop&lt;/code&gt; 一次处理多个范围基元。所有处理的原语必须具有与用户提供的处理程序兼容的返回类型或值。</target>
        </trans-unit>
        <trans-unit id="0b5f27af6328268d2605eb68f81d45548b5054bd" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#dur&quot;&gt;&lt;code&gt;dur&lt;/code&gt;&lt;/a&gt; function or one of its non-generic aliases to create &lt;code&gt;Duration&lt;/code&gt;s.</source>
          <target state="translated">使用&lt;a href=&quot;#dur&quot;&gt; &lt;code&gt;dur&lt;/code&gt; &lt;/a&gt;函数或其非通用别名之一创建 &lt;code&gt;Duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78a059e1d81c669061770e6ebc73b731a6af9efd" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;arrayPtr&lt;/code&gt; overload of &lt;a href=&quot;#appender&quot;&gt;&lt;code&gt;appender&lt;/code&gt;&lt;/a&gt; for construction with type-inference.</source>
          <target state="translated">使用&lt;a href=&quot;#appender&quot;&gt; &lt;code&gt;appender&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;arrayPtr&lt;/code&gt; 重载用于具有类型推断的构造。</target>
        </trans-unit>
        <trans-unit id="d09a4630f154886909155b3e1ae35f59cb094891" translate="yes" xml:space="preserve">
          <source>Use the ForwardingScopeDsymbol as the parent symbol for members.</source>
          <target state="translated">使用ForwardingScopeDsymbol作为成员的父符号。</target>
        </trans-unit>
        <trans-unit id="225bd24669abe9be158ae39e2ef06005821005b8" translate="yes" xml:space="preserve">
          <source>Use the SOCKS5 protocol but pass along the host name rather than the IP address. added in 7.18.0</source>
          <target state="translated">使用SOCKS5协议,但传递的是主机名而不是IP地址。</target>
        </trans-unit>
        <trans-unit id="5ad265a5408a557c8739bbf477749f03fe8edee2" translate="yes" xml:space="preserve">
          <source>Use the attributes &lt;code&gt;@nogc&lt;/code&gt; as much as possible on the &lt;code&gt;toHash&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; overrides.</source>
          <target state="translated">在 &lt;code&gt;toHash&lt;/code&gt; 和 &lt;code&gt;opEquals&lt;/code&gt; 上尽可能多地使用 &lt;code&gt;@nogc&lt;/code&gt; 属性覆盖。</target>
        </trans-unit>
        <trans-unit id="fa837e971bab06ebe9fa8cced0faa302241fa259" translate="yes" xml:space="preserve">
          <source>Use the attributes &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;scope&lt;/code&gt; as much as possible on the &lt;code&gt;toHash&lt;/code&gt; and &lt;code&gt;opEquals&lt;/code&gt; overrides.</source>
          <target state="translated">在 &lt;code&gt;toHash&lt;/code&gt; 和 &lt;code&gt;opEquals&lt;/code&gt; 上尽可能多地使用属性 &lt;code&gt;@safe&lt;/code&gt; ， &lt;code&gt;@nogc&lt;/code&gt; ， &lt;code&gt;pure&lt;/code&gt; ， &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;scope&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="73f4ee5c163a4b03bed0243fb0edd865f02a04da" translate="yes" xml:space="preserve">
          <source>Use the coarse clock, not the normal one (e.g. on Linux, that would be &lt;code&gt;CLOCK_REALTIME_COARSE&lt;/code&gt; instead of &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; for &lt;code&gt;clock_gettime&lt;/code&gt; if a function is using the realtime clock). It's generally faster to get the time with the coarse clock than the normal clock, but it's less precise (e.g. 1 msec instead of 1 usec or 1 nsec). Howeover, it</source>
          <target state="translated">使用粗粒时钟，而不是正常的（例如在Linux上，这将是 &lt;code&gt;CLOCK_REALTIME_COARSE&lt;/code&gt; 代替 &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; 为 &lt;code&gt;clock_gettime&lt;/code&gt; 如果一个函数使用实时时钟）。通常，使用粗略的时钟来获取时间比正常时钟要快，但是精度较低（例如1毫秒而不是1微秒或1纳秒）。但是，</target>
        </trans-unit>
        <trans-unit id="b5e0f9bdfa9016956fef4c6395c40953244dbc05" translate="yes" xml:space="preserve">
          <source>Use the faster compile-time overload</source>
          <target state="translated">使用更快的编译时重载</target>
        </trans-unit>
        <trans-unit id="003ec607e3d7cca9e027c3ee29178ae85ad8baeb" translate="yes" xml:space="preserve">
          <source>Use the most visible overload to check visibility. Later perform an access check on the resolved overload. This function is similar to overloadApply, but doesn't recurse nor resolve aliases because protection/visibility is an attribute of the alias not the aliasee.</source>
          <target state="translated">使用最可见的过载来检查可见性。之后对已解析的重载执行访问检查。这个函数类似于 overloadApply,但不递归也不解析别名,因为保护/可见性是别名的属性,而不是受别名者的属性。</target>
        </trans-unit>
        <trans-unit id="ecea27e7268c13a18f824b4741edffcbd21384fd" translate="yes" xml:space="preserve">
          <source>Use the normal clock.</source>
          <target state="translated">使用正常的时钟。</target>
        </trans-unit>
        <trans-unit id="2decee5fdcb2e6abe0efae775d6d245ceb48d907" translate="yes" xml:space="preserve">
          <source>Use the optional &lt;code&gt;cookie&lt;/code&gt; argument to create different types of the same base type</source>
          <target state="translated">使用可选的 &lt;code&gt;cookie&lt;/code&gt; 参数创建相同基本类型的不同类型</target>
        </trans-unit>
        <trans-unit id="199dc20b591ee68d927b26f24f29015b8587604c" translate="yes" xml:space="preserve">
          <source>Use the two operand form of the instruction format;</source>
          <target state="translated">使用两个操作数形式的指令格式。</target>
        </trans-unit>
        <trans-unit id="95a7b20ad88258a006cdce3eb4a48069b1dcaa41" translate="yes" xml:space="preserve">
          <source>Use this attribute to attach an Objective-C selector to a method.</source>
          <target state="translated">使用此属性将一个Objective-C选择器附加到一个方法上。</target>
        </trans-unit>
        <trans-unit id="4bb2c79967fecc4182a145b06d47c0f4b49f6ef8" translate="yes" xml:space="preserve">
          <source>Use this attribute to declare an ABI tag on a C++ symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7ee948a98daed0fa240ed47144ff4132b6001e" translate="yes" xml:space="preserve">
          <source>Use this constructor for string mixins.</source>
          <target state="translated">使用这个构造函数来实现字符串混搭。</target>
        </trans-unit>
        <trans-unit id="5b498b0856e978dcbbf4e0ffb7b97a34e638161a" translate="yes" xml:space="preserve">
          <source>Use this expression for error recovery. It should behave as a 'sink' to prevent further cascaded error messages.</source>
          <target state="translated">使用此表达式进行错误恢复。它应该起到 &quot;汇 &quot;的作用,以防止进一步的级联错误信息。</target>
        </trans-unit>
        <trans-unit id="bd06c192db7792c4cf00ede209798b786767b1ca" translate="yes" xml:space="preserve">
          <source>Use this for multipart formpost building</source>
          <target state="translated">用于多部分的柱子建设</target>
        </trans-unit>
        <trans-unit id="7c6ab14342528c5b12e30f0b33b6f65a5c654581" translate="yes" xml:space="preserve">
          <source>Use this instead of creating new instances for commonly used literals such as 0 or 1.</source>
          <target state="translated">使用它来代替为常用的字元(如0或1)创建新的实例。</target>
        </trans-unit>
        <trans-unit id="f3c0cff7dd757ca5c15bd47e9f720de6ca2a6e5e" translate="yes" xml:space="preserve">
          <source>Use this module to test out new functionality for &lt;a href=&quot;std_typecons#wrap&quot;&gt;&lt;code&gt;std.typecons.wrap&lt;/code&gt;&lt;/a&gt; which allows for a struct to be wrapped against an interface; the implementation in &lt;a href=&quot;std_typecons&quot;&gt;&lt;code&gt;std.typecons&lt;/code&gt;&lt;/a&gt; only allows for classes to use the wrap functionality.</source>
          <target state="translated">使用此模块来测试&lt;a href=&quot;std_typecons#wrap&quot;&gt; &lt;code&gt;std.typecons.wrap&lt;/code&gt; 的&lt;/a&gt;新功能，该功能允许将结构包装在接口上；&lt;a href=&quot;std_typecons&quot;&gt; &lt;code&gt;std.typecons&lt;/code&gt; 中&lt;/a&gt;的实现仅允许类使用包装功能。</target>
        </trans-unit>
        <trans-unit id="a95cb1b3a079b5ec85c4f5f432209f3bba70e39c" translate="yes" xml:space="preserve">
          <source>Use this only when it is certain there are no elements in use beyond the array in the memory block. If there are, those elements will be overwritten by appending to this array.</source>
          <target state="translated">只有当确定在内存块中的数组之外没有正在使用的元素时,才可以使用这个选项。如果有,这些元素将通过追加到这个数组来覆盖。</target>
        </trans-unit>
        <trans-unit id="a582381933463d5deb51e05bf545416141895fa5" translate="yes" xml:space="preserve">
          <source>Use this template to get the type which is returned by a digest's &lt;a href=&quot;#finish&quot;&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">使用此模板获取摘要的&lt;a href=&quot;#finish&quot;&gt; &lt;code&gt;finish&lt;/code&gt; &lt;/a&gt;方法返回的类型。</target>
        </trans-unit>
        <trans-unit id="f759a1693042701634c4658a13cab1e8618f57f7" translate="yes" xml:space="preserve">
          <source>Use this to check if a type is a digest. See &lt;a href=&quot;#ExampleDigest&quot;&gt;&lt;code&gt;ExampleDigest&lt;/code&gt;&lt;/a&gt; to see what a type must provide to pass this check.</source>
          <target state="translated">使用它来检查类型是否为摘要。请参见&lt;a href=&quot;#ExampleDigest&quot;&gt; &lt;code&gt;ExampleDigest&lt;/code&gt; ,&lt;/a&gt;以查看类型必须提供什么才能通过此检查。</target>
        </trans-unit>
        <trans-unit id="dc036b8b38f636a8da26f31247bb9aaf42862d52" translate="yes" xml:space="preserve">
          <source>Use this to feed the digest with data. Also implements the &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;&lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt;&lt;/a&gt; interface for &lt;code&gt;ubyte&lt;/code&gt; and &lt;code&gt;const(ubyte)[]&lt;/code&gt;.</source>
          <target state="translated">使用它为摘要提供数据。还为 &lt;code&gt;ubyte&lt;/code&gt; 和 &lt;code&gt;const(ubyte)[]&lt;/code&gt; 实现&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt; &lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt; &lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="4716d195c3662fddb3b8f04d5d336c547d5e1633" translate="yes" xml:space="preserve">
          <source>Use this to feed the digest with data. Also implements the &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;&lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt;&lt;/a&gt; interface for &lt;code&gt;ubyte&lt;/code&gt; and &lt;code&gt;const(ubyte)[]&lt;/code&gt;. The following usages of &lt;code&gt;put&lt;/code&gt; must work for any type which passes &lt;a href=&quot;#isDigest&quot;&gt;&lt;code&gt;isDigest&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用它为摘要提供数据。还为 &lt;code&gt;ubyte&lt;/code&gt; 和 &lt;code&gt;const(ubyte)[]&lt;/code&gt; 实现&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt; &lt;code&gt;std.range.primitives.isOutputRange&lt;/code&gt; &lt;/a&gt;接口。 &lt;code&gt;put&lt;/code&gt; 的以下用法必须适用于通过&lt;a href=&quot;#isDigest&quot;&gt; &lt;code&gt;isDigest&lt;/code&gt; 的&lt;/a&gt;任何类型：</target>
        </trans-unit>
        <trans-unit id="f0c5e9e55d90ec5f58114e5393a0956447e2f3df" translate="yes" xml:space="preserve">
          <source>Use tuples as ranges</source>
          <target state="translated">使用元组作为范围</target>
        </trans-unit>
        <trans-unit id="27f93c20b3a083f74d82c63db067812d27ea3722" translate="yes" xml:space="preserve">
          <source>Use when we prefer the default initializer to be a literal, rather than a global immutable variable.</source>
          <target state="translated">当我们希望默认的初始化器是一个文字,而不是一个全局不可变的变量时使用。</target>
        </trans-unit>
        <trans-unit id="8d5ca1642ce1a35cb57a7b97089dfc54c5486ae4" translate="yes" xml:space="preserve">
          <source>Use with care as the sub-matcher won't match any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; that have encoded length that doesn't belong to the selected set of lengths. Also the sub-matcher object references the parent matcher and must not be used past the liftetime of the latter.</source>
          <target state="translated">请谨慎使用，因为子匹配器不会匹配任何&lt;a href=&quot;#Code%20point&quot;&gt;代码点&lt;/a&gt;编码长度不属于所选长度集的。子匹配器对象还引用父匹配器，并且不得在父匹配器的提升时间之后使用。</target>
        </trans-unit>
        <trans-unit id="83af243aeee73279b4357b44c2865c0c312de9ce" translate="yes" xml:space="preserve">
          <source>Use with care for relatively small or regular sets. It could end up being slower then just using multi-staged tables.</source>
          <target state="translated">对于比较小的或有规律的套路要谨慎使用。最后可能会比较慢,那么只用多级表。</target>
        </trans-unit>
        <trans-unit id="868aa913da6e64ffd3178348ee39c40b6cb76409" translate="yes" xml:space="preserve">
          <source>UseReplacementDchar.yes means replace invalid UTF with &lt;code&gt;replacementDchar&lt;/code&gt;, UseReplacementDchar.no means throw &lt;code&gt;UTFException&lt;/code&gt; for invalid UTF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c271740e0ce7eb2e00647fa4da41721ca1e00a1" translate="yes" xml:space="preserve">
          <source>Used as a way to import a set of functions from another scope into this one.</source>
          <target state="translated">用来从另一个作用域将一组函数导入到这个作用域。</target>
        </trans-unit>
        <trans-unit id="9aff366f8817a8d85016a5af2ffa72cb41c12ea4" translate="yes" xml:space="preserve">
          <source>Used by PRAGMA temp_store_directory</source>
          <target state="translated">由PRAGMA temp_store_directory使用。</target>
        </trans-unit>
        <trans-unit id="c0d28c0a10bf62a3760e12afc8a7ed5df5261d7b" translate="yes" xml:space="preserve">
          <source>Used by StopWatch to indicate whether it should start immediately upon construction.</source>
          <target state="translated">由StopWatch使用来指示是否应该在施工后立即开始。</target>
        </trans-unit>
        <trans-unit id="d77cd63df95be5f8257fdd3b6685af113cfcac98" translate="yes" xml:space="preserve">
          <source>Used by scp/sftp to do public/private key authentication</source>
          <target state="translated">被scp/sftp用来进行公钥/私钥认证。</target>
        </trans-unit>
        <trans-unit id="62d064b18e4792e174e1c38c7f164d4b65412e06" translate="yes" xml:space="preserve">
          <source>Used for empty tags</source>
          <target state="translated">用于空标签</target>
        </trans-unit>
        <trans-unit id="948c35e8d2024f482ef61469edc1997c031e7684" translate="yes" xml:space="preserve">
          <source>Used for end tags</source>
          <target state="translated">用于结束标签</target>
        </trans-unit>
        <trans-unit id="6de76570eb43640d4d9e5b45038a00acc6b2bb9d" translate="yes" xml:space="preserve">
          <source>Used for reordering elem trees to minimize register usage.</source>
          <target state="translated">用于对elem树进行重新排序以减少寄存器的使用。</target>
        </trans-unit>
        <trans-unit id="f4030c3289de70676f4cc6c0e214e32db123298d" translate="yes" xml:space="preserve">
          <source>Used for start tags</source>
          <target state="translated">用于起始标签</target>
        </trans-unit>
        <trans-unit id="522e09bb5920f3c467bc6428b962e366709a3220" translate="yes" xml:space="preserve">
          <source>Used to (re)initialize the MD5 digest.</source>
          <target state="translated">用于(重新)初始化MD5摘要。</target>
        </trans-unit>
        <trans-unit id="d8ae013d8b394207c78281137c668f2dfc3c43cf" translate="yes" xml:space="preserve">
          <source>Used to (re)initialize the RIPEMD160 digest.</source>
          <target state="translated">用于(重新)初始化RIPEMD160摘要。</target>
        </trans-unit>
        <trans-unit id="f62bf8f2aca98cad054cf426c5476cfd425e9977" translate="yes" xml:space="preserve">
          <source>Used to check if a digest supports the &lt;code&gt;peek&lt;/code&gt; method. Peek has exactly the same function signatures as finish, but it doesn't reset the digest's internal state.</source>
          <target state="translated">用于检查摘要是否支持 &lt;code&gt;peek&lt;/code&gt; 方法。Peek具有与finish完全相同的功能签名，但不会重置摘要的内部状态。</target>
        </trans-unit>
        <trans-unit id="b2ca2eff17dd582e5ff65726409ecb0158897554" translate="yes" xml:space="preserve">
          <source>Used to convert a hash value (a static or dynamic array of ubytes) to a string. Can be used with the OOP and with the template API.</source>
          <target state="translated">用于将哈希值(静态或动态的ubytes数组)转换为字符串。可以与OOP和模板API一起使用。</target>
        </trans-unit>
        <trans-unit id="46222499a18dfe951ecc78e1c9590456d26ad7e4" translate="yes" xml:space="preserve">
          <source>Used to convert the argument to a lazy parameter.</source>
          <target state="translated">用于将参数转换为懒惰参数。</target>
        </trans-unit>
        <trans-unit id="65abc6a52a7ca50f9b90aca875b02f4b756c4a7a" translate="yes" xml:space="preserve">
          <source>Used to get the metaclass of an Objective-C class, &lt;code&gt;NSObject.Class&lt;/code&gt;.</source>
          <target state="translated">用于获取Objective-C类的元类 &lt;code&gt;NSObject.Class&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87b79b0e524609461d16e79324d5b506d0bd2f97" translate="yes" xml:space="preserve">
          <source>Used to indicate whether &lt;code&gt;popFront&lt;/code&gt; should be called immediately upon creating a range. The idea is that for some functions used to generate a range for an interval, &lt;code&gt;front&lt;/code&gt; is not necessarily a time point which would ever be generated by the range (e.g. if the range were every Sunday within an interval, but the interval started on a Monday), so there needs to be a way to deal with that. To get the first time point in the range to match what the function generates, then use &lt;code&gt;PopFirst.yes&lt;/code&gt; to indicate that the range should have &lt;code&gt;popFront&lt;/code&gt; called on it before the range is returned so that &lt;code&gt;front&lt;/code&gt; is a time point which the function would generate. To let the first time point not match the generator function, use &lt;code&gt;PopFront.no&lt;/code&gt;.</source>
          <target state="translated">用于指示在创建范围时是否应立即调用 &lt;code&gt;popFront&lt;/code&gt; 。这个想法是，对于某些用于生成间隔范围的函数， &lt;code&gt;front&lt;/code&gt; 不一定是该范围会生成的时间点（例如，如果范围是间隔内的每个星期日，但间隔从星期一开始），因此需要一种解决方法。要获取范围内的第一个时间点以匹配函数生成的内容，请使用 &lt;code&gt;PopFirst.yes&lt;/code&gt; 指示范围应在返回范围之前调用 &lt;code&gt;popFront&lt;/code&gt; ，以便 &lt;code&gt;front&lt;/code&gt; 是函数将生成的时间点。要使第一个时间点与生成器函数不匹配，请使用 &lt;code&gt;PopFront.no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="401f8606923b6b90d5e6990af08c1ea19653cfb5" translate="yes" xml:space="preserve">
          <source>Used to initialize the CRC32 digest.</source>
          <target state="translated">用于初始化CRC32摘要。</target>
        </trans-unit>
        <trans-unit id="9956d500692d633ff2d3c01404cd742cd7a59cd4" translate="yes" xml:space="preserve">
          <source>Used to specify the lock type for &lt;code&gt;File.lock&lt;/code&gt; and &lt;code&gt;File.tryLock&lt;/code&gt;.</source>
          <target state="translated">用于指定 &lt;code&gt;File.lock&lt;/code&gt; 和 &lt;code&gt;File.tryLock&lt;/code&gt; 的锁定类型。</target>
        </trans-unit>
        <trans-unit id="063f3cd8cbb18d78d982d0fe8406f2b8aad31844" translate="yes" xml:space="preserve">
          <source>Used to work around syntactic limitations of D with regard to instantiating a template from an alias sequence (e.g. &lt;code&gt;T[0]!(...)&lt;/code&gt; is not valid) or a template returning another template (e.g. &lt;code&gt;Foo!(Bar)!(Baz)&lt;/code&gt; is not allowed).</source>
          <target state="translated">用于从别名序列实例化模板（例如 &lt;code&gt;T[0]!(...)&lt;/code&gt; 无效）或返回另一个模板的模板（例如 &lt;code&gt;Foo!(Bar)!(Baz)&lt;/code&gt; 方面解决D的语法限制。）是不允许的）。</target>
        </trans-unit>
        <trans-unit id="9c84f45b498b0d39f128dcbb45ac2921760d01ee" translate="yes" xml:space="preserve">
          <source>Used when the data to be compressed is not all in one buffer.</source>
          <target state="translated">当需要压缩的数据不在一个缓冲区内时使用。</target>
        </trans-unit>
        <trans-unit id="5bb82bdca5155ef6b15ec62c178c8aa8ec5a96b1" translate="yes" xml:space="preserve">
          <source>Used when the data to be decompressed is not all in one buffer.</source>
          <target state="translated">当需要解压的数据不在一个缓冲区内时使用。</target>
        </trans-unit>
        <trans-unit id="c12660b5a95dd9583c836ce084d3eaa0c55a6813" translate="yes" xml:space="preserve">
          <source>Useful for converting the result to a string after doing operations on graphemes.</source>
          <target state="translated">在对graphemes进行操作后,用于将结果转换为字符串。</target>
        </trans-unit>
        <trans-unit id="7652b35b91d37f1b6a3e33d8a155a1f2c6064611" translate="yes" xml:space="preserve">
          <source>Useful for doing string manipulation that needs to be aware of graphemes.</source>
          <target state="translated">对于做需要意识到字词的字符串操作很有用。</target>
        </trans-unit>
        <trans-unit id="314d8fb768e706877d004a50cc06fd222bca9e32" translate="yes" xml:space="preserve">
          <source>Useful for error messages</source>
          <target state="translated">对错误信息有用</target>
        </trans-unit>
        <trans-unit id="6dc0953ee871790fa8f35a1a09d04c414cbf0ea7" translate="yes" xml:space="preserve">
          <source>Useful for using &lt;code&gt;foreach&lt;/code&gt; with an index loop variable:</source>
          <target state="translated">对于将 &lt;code&gt;foreach&lt;/code&gt; 与索引循环变量一起使用非常有用：</target>
        </trans-unit>
        <trans-unit id="4db4c19014a191f09a1cb0e5ee4b594d36a17fa5" translate="yes" xml:space="preserve">
          <source>Useful when a single value or multiple disconnected values must be passed to an algorithm expecting a range, without having to perform dynamic memory allocation.</source>
          <target state="translated">当一个单一的值或多个断开的值必须传递给一个期望范围的算法时,很有用,而不必执行动态内存分配。</target>
        </trans-unit>
        <trans-unit id="83a28142d94277b9f824e8d439d35c64935809cf" translate="yes" xml:space="preserve">
          <source>User Data For Functions</source>
          <target state="translated">功能的用户数据</target>
        </trans-unit>
        <trans-unit id="0ada253ac93105524488fa0636dd4f599ad803cd" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol</source>
          <target state="translated">用户数据报协议</target>
        </trans-unit>
        <trans-unit id="663967dca54d1f5a78a7cc7579aff26c92ec0848" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol level</source>
          <target state="translated">用户数据报协议级别</target>
        </trans-unit>
        <trans-unit id="7f12f4404ca8d6331a7dda600211516b88689808" translate="yes" xml:space="preserve">
          <source>User Defined Logger</source>
          <target state="translated">用户定义的记录器</target>
        </trans-unit>
        <trans-unit id="41b70159aa80a814a1c6708051f3c2cd54f55274" translate="yes" xml:space="preserve">
          <source>User defined attributes look like: @foo(args, ...) @(args, ...)</source>
          <target state="translated">用户定义的属性是这样的 @foo(args,...)@(args,...)</target>
        </trans-unit>
        <trans-unit id="6911ae8d9122e09ba3672b9fc7a2f5a03117c4b5" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes</source>
          <target state="translated">用户自定义属性</target>
        </trans-unit>
        <trans-unit id="53dcd43d2037ced97e920ab7c52c6c2b3f1d4b5b" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes (UDA) are compile-time expressions that can be attached to a declaration. These attributes can then be queried, extracted, and manipulated at compile time. There is no runtime component to them.</source>
          <target state="translated">用户自定义属性(UDA)是可以附加到声明中的编译时表达式,这些属性可以在编译时被查询、提取和操作。这些属性可以在编译时被查询、提取和操作。它们没有运行时组件。</target>
        </trans-unit>
        <trans-unit id="79c69632c5bdcde773a2213887dfa8de28b97fcd" translate="yes" xml:space="preserve">
          <source>User-Defined Attributes for Parameters</source>
          <target state="translated">用户定义的参数属性</target>
        </trans-unit>
        <trans-unit id="f97038e5aef05b8d6da775ac91f3df3186383a15" translate="yes" xml:space="preserve">
          <source>User-Defined Properties</source>
          <target state="translated">用户自定义属性</target>
        </trans-unit>
        <trans-unit id="a481ec805686b1111f45e923c0482b9b383bb80f" translate="yes" xml:space="preserve">
          <source>User-Defined Types</source>
          <target state="translated">用户自定义类型</target>
        </trans-unit>
        <trans-unit id="df398272c254dd9772b28c77026104de0cb4813e" translate="yes" xml:space="preserve">
          <source>User-defined properties can be created using &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;function#property-functions&quot;&gt;属性函数&lt;/a&gt;创建用户定义的属性。</target>
        </trans-unit>
        <trans-unit id="ad57ad15c0703a0e0107ec919b23c65c4cb01b03" translate="yes" xml:space="preserve">
          <source>User-defined type names</source>
          <target state="translated">用户定义的类型名称</target>
        </trans-unit>
        <trans-unit id="e276f7847775a88fc2abcad4667b89c9759a4155" translate="yes" xml:space="preserve">
          <source>User-defined types that support comparison with &amp;lt; are supported.</source>
          <target state="translated">支持支持与&amp;lt;比较的用户定义类型。</target>
        </trans-unit>
        <trans-unit id="e23e2a8ab594792759d1b60610fa3c8b02dd3e4d" translate="yes" xml:space="preserve">
          <source>User-provided store backing up the region. If &lt;code&gt; ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, memory is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">用户提供的商店将备份该区域。如果 &lt;code&gt; ParentAllocator&lt;/code&gt; 与&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt;不同，则假定已使用 &lt;code&gt;ParentAllocator&lt;/code&gt; 分配了内存。</target>
        </trans-unit>
        <trans-unit id="5092e979a5a593d67b4e82f9d2bbd095571e3d50" translate="yes" xml:space="preserve">
          <source>User-provided store backing up the region. If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, memory is assumed to have been allocated with &lt;code&gt;ParentAllocator&lt;/code&gt;.</source>
          <target state="translated">用户提供的商店将备份该区域。如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 与&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt;不同，则假定已使用 &lt;code&gt;ParentAllocator&lt;/code&gt; 分配了内存。</target>
        </trans-unit>
        <trans-unit id="e82338a943d21a1789251b44a5bd82afdadd9523" translate="yes" xml:space="preserve">
          <source>Users should prefer &lt;a href=&quot;object#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; to explicitly finalize objects, and only resort to &lt;a href=&quot;core_memory#_delete&quot;&gt;&lt;code&gt;core.memory._delete&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;object_#destroy&quot;&gt;&lt;code&gt;object.destroy&lt;/code&gt;&lt;/a&gt; wouldn't be a feasible option.</source>
          <target state="translated">用户应该更喜欢使用&lt;a href=&quot;object#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt;来显式地完成对象的确定，并且仅当&lt;a href=&quot;object_#destroy&quot;&gt; &lt;code&gt;object.destroy&lt;/code&gt; &lt;/a&gt;不太可行时才诉诸&lt;a href=&quot;core_memory#_delete&quot;&gt; &lt;code&gt;core.memory._delete&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4005d61c7d8ff0cb653333de46ae3789f1d31fe" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/8z34s9c6(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_malloc&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">用途&lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt;对POSIX和&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/8z34s9c6(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_malloc&lt;/code&gt; &lt;/a&gt;在Windows上。</target>
        </trans-unit>
        <trans-unit id="431691e401faf58fb8c19131908c69ff710b059d" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_BOOTTIME&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLOCK_BOOTTIME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a50d919e60bef0f60af91bbb8d114a0afe4665d" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_MONOTONIC_RAW&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLOCK_MONOTONIC_RAW&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="668062aef7777a80761a341372c3e3e366c83d67" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b6a765f3682873a0a6c777b9f9c93d6e30d47aa" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_THREAD_CPUTIME_ID&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLOCK_THREAD_CPUTIME_ID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a32c41537d0762601fcb3b8547ba1c5f0e90c61b" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLOCK_UPTIME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d155d55219e59719f96afbc402b6fce30fe7decd" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME_FAST&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLOCK_UPTIME_FAST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32cbdb3659578d385f11021d0324dc0968ef7d2b" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;CLOCK_UPTIME_PRECISE&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;CLOCK_UPTIME_PRECISE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21b474dd996ab465a4609dacd8af3f0c2c6b9e0a" translate="yes" xml:space="preserve">
          <source>Uses Horner's rule A(x) = a&lt;sub&gt;0&lt;/sub&gt; + x(a&lt;sub&gt;1&lt;/sub&gt; + x(a&lt;sub&gt;2&lt;/sub&gt; + x(a&lt;sub&gt;3&lt;/sub&gt; + ...)))</source>
          <target state="translated">使用霍纳规则A（x）= a &lt;sub&gt;0&lt;/sub&gt; + x（a &lt;sub&gt;1&lt;/sub&gt; + x（a &lt;sub&gt;2&lt;/sub&gt; + x（a &lt;sub&gt;3&lt;/sub&gt; + ...）））</target>
        </trans-unit>
        <trans-unit id="89865df2ae553e13ce078a7680590fe066489642" translate="yes" xml:space="preserve">
          <source>Uses OS features not supported on host</source>
          <target state="translated">使用主机不支持的操作系统功能</target>
        </trans-unit>
        <trans-unit id="d43174ab3f2c7ceb67637889035614b690710449" translate="yes" xml:space="preserve">
          <source>Uses a clock that has a precision of one second (contrast to the coarse clock, which has sub-second precision like the normal clock does).</source>
          <target state="translated">使用精度为一秒的时钟(与普通时钟一样具有亚秒级精度的粗时钟相反)。</target>
        </trans-unit>
        <trans-unit id="660abbaeae3754fa828725fdd746d4c8c7d904f7" translate="yes" xml:space="preserve">
          <source>Uses a more precise clock than the normal one (which is already very precise), but it takes longer to get the time. Similarly to &lt;code&gt;ClockType.coarse&lt;/code&gt;, if it's used on a system that does not support a more precise clock than the normal one, it's treated as equivalent to &lt;code&gt;ClockType.normal&lt;/code&gt;.</source>
          <target state="translated">使用比正常时钟（已经非常精确）更精确的时钟，但是花费时间更长。与 &lt;code&gt;ClockType.coarse&lt;/code&gt; 相似，如果在不支持比普通时钟更精确的时钟的系统上使用它，则将其视为 &lt;code&gt;ClockType.normal&lt;/code&gt; 等效。</target>
        </trans-unit>
        <trans-unit id="4810f4cffe0fe4e539877249a5f80a146a9437e8" translate="yes" xml:space="preserve">
          <source>Uses an algorithm based on TOMS748, which uses inverse cubic interpolation whenever possible, otherwise reverting to parabolic or secant interpolation. Compared to TOMS748, this implementation improves worst-case performance by a factor of more than 100, and typical performance by a factor of 2. For 80-bit reals, most problems require 8 to 15 calls to &lt;code&gt;f(x)&lt;/code&gt; to achieve full machine precision. The worst-case performance (pathological cases) is approximately twice the number of bits.</source>
          <target state="translated">使用基于TOMS748的算法，该算法在可能的情况下使用反三次插值，否则将恢复为抛物线或割线插值。与TOMS748相比，此实现将最坏情况的性能提高了100倍以上，典型性能提高了2倍。对于80位实数，大多数问题需要对 &lt;code&gt;f(x)&lt;/code&gt; 进行8到15次调用才能获得完整的计算机精确。最坏情况下的性能（病理情况）大约是位数的两倍。</target>
        </trans-unit>
        <trans-unit id="4498cdd81a3af92be5d71f0feb7499f91526eda6" translate="yes" xml:space="preserve">
          <source>Uses static address range/handler tables. It is not compatible with the ELF/Mach-O exception handling tables. The stack is walked assuming it uses the EBP/RBP stack frame convention. The EBP/RBP convention must be used for every function that has an associated EH (Exception Handler) table.</source>
          <target state="translated">使用静态地址范围/处理表。它与ELF/Mach-O异常处理表不兼容。假设堆栈使用EBP/RBP堆栈框架约定,就会被走过。EBP/RBP约定必须用于每个有关联EH(异常处理程序)表的函数。</target>
        </trans-unit>
        <trans-unit id="29fa78ad0c4fcffa6a248e751ed5f9b54e278c81" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;delete&lt;/code&gt; to free memory not allocated by the garbage collector.</source>
          <target state="translated">使用 &lt;code&gt;delete&lt;/code&gt; 释放垃圾回收器未分配的内存。</target>
        </trans-unit>
        <trans-unit id="dbc2fb498947c6d15c4f030eec28a604eed13c66" translate="yes" xml:space="preserve">
          <source>Using Allocators without &lt;code&gt;IAllocator&lt;/code&gt;</source>
          <target state="translated">在没有 &lt;code&gt;IAllocator&lt;/code&gt; 的情况下使用分配器</target>
        </trans-unit>
        <trans-unit id="f74c7aa68c43b38fd906d3d9eab694820f7c02be" translate="yes" xml:space="preserve">
          <source>Using C++ Classes From D</source>
          <target state="translated">从D语言中使用C++类</target>
        </trans-unit>
        <trans-unit id="5d2653c4926bb52d976ff78e98c04428994e66ea" translate="yes" xml:space="preserve">
          <source>Using Classes as the KeyType</source>
          <target state="translated">使用类作为KeyType</target>
        </trans-unit>
        <trans-unit id="42a76c4e6e5c83e56266b53307bd6eb59b5b616d" translate="yes" xml:space="preserve">
          <source>Using D Classes From C++</source>
          <target state="translated">从C++中使用D类</target>
        </trans-unit>
        <trans-unit id="5de7af94f529ff0a340538c931f4aeeba8137b89" translate="yes" xml:space="preserve">
          <source>Using Ddoc for other Documentation</source>
          <target state="translated">使用Ddoc制作其他文件</target>
        </trans-unit>
        <trans-unit id="a452f39b71d34befc0278e622c50c8e1b7016ce7" translate="yes" xml:space="preserve">
          <source>Using Ddoc to generate examples from unit tests</source>
          <target state="translated">使用Ddoc从单元测试中生成示例</target>
        </trans-unit>
        <trans-unit id="ffcf84b5292979d6d33051f4fd30a1a26f6708e4" translate="yes" xml:space="preserve">
          <source>Using Existing C Libraries</source>
          <target state="translated">使用现有的C库</target>
        </trans-unit>
        <trans-unit id="ca7da0d401d332ac17ab9ac27d6baa37cb6bed49" translate="yes" xml:space="preserve">
          <source>Using Structs or Unions as the KeyType</source>
          <target state="translated">使用结构或联合体作为键类型</target>
        </trans-unit>
        <trans-unit id="ac95e41bbb29ad991114a19ec2ec8a9eb2e7d8d1" translate="yes" xml:space="preserve">
          <source>Using UUIDs</source>
          <target state="translated">使用UUIDs</target>
        </trans-unit>
        <trans-unit id="5fa5d3e48800cfb7875c91e382ef8e4590ba92ea" translate="yes" xml:space="preserve">
          <source>Using a struct with modified delimiter:</source>
          <target state="translated">使用带修改定界符的结构。</target>
        </trans-unit>
        <trans-unit id="04602bc03bbc945a58891e81ee57c8cb19c96764" translate="yes" xml:space="preserve">
          <source>Using alias template parameter in &lt;code&gt;how&lt;/code&gt; and/or &lt;code&gt;what&lt;/code&gt; may cause strange compile error. Use template tuple parameter instead to workaround this problem. [&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=4217&quot;&gt;Bugzilla 4217&lt;/a&gt;]</source>
          <target state="translated">在使用别名模板参数 &lt;code&gt;how&lt;/code&gt; 和/或 &lt;code&gt;what&lt;/code&gt; 可能引起奇怪的编译错误。使用模板元组参数来解决此问题。[ &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=4217&quot;&gt;Bugzilla 4217&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="8be6b00f614d8a1cd2c1ef5b4a6f7e1192591421" translate="yes" xml:space="preserve">
          <source>Using allocatedInCurrentThread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2607c615db72ef7bb05726a2cf4b245712b98a0" translate="yes" xml:space="preserve">
          <source>Using an uninitialized struct-based container will work, because the struct intializes itself upon use; however, up to this point the container will not have an identity and assignment does not create two references to the same data.</source>
          <target state="translated">使用一个基于结构体的未初始化的容器将是可行的,因为结构体在使用时就会初始化自己;但是,在这之前,容器不会有一个身份,赋值也不会创建两个对同一数据的引用。</target>
        </trans-unit>
        <trans-unit id="35a44b902e18d805798c2c1e89fd00d153fbd20b" translate="yes" xml:space="preserve">
          <source>Using asNormalizedPath on empty paths will always return an empty path.</source>
          <target state="translated">在空路径上使用asNormalizedPath总是会返回一个空路径。</target>
        </trans-unit>
        <trans-unit id="0290f4a41ecd4a75dc3439f50553b7b4b3cab521" translate="yes" xml:space="preserve">
          <source>Using buildNormalizedPath on null paths will always return null.</source>
          <target state="translated">在null路径上使用buildNormalizedPath总是会返回null。</target>
        </trans-unit>
        <trans-unit id="6805f8dde5047fa0a76de0b0a48672e08cbc9fdb" translate="yes" xml:space="preserve">
          <source>Using builtin &lt;code&gt;typeof&lt;/code&gt; on a property function yields the types of the property value, not of the property function itself. Still, &lt;code&gt;FunctionTypeOf&lt;/code&gt; is able to obtain function types of properties.</source>
          <target state="translated">在属性函数上使用内置的 &lt;code&gt;typeof&lt;/code&gt; 会产生属性值的类型，而不是属性函数本身的类型。尽管如此， &lt;code&gt;FunctionTypeOf&lt;/code&gt; 仍能够获取属性的函数类型。</target>
        </trans-unit>
        <trans-unit id="7eb690c3ef3a1529c909411cf3d35c20b241fbf3" translate="yes" xml:space="preserve">
          <source>Using exceptions to handle errors leads to another issue - how to write exception safe programs. &lt;a href=&quot;https://dlang.org/exception-safe.html&quot;&gt;Here's how&lt;/a&gt;.</source>
          <target state="translated">使用异常处理错误会导致另一个问题-如何编写异常安全程序。&lt;a href=&quot;https://dlang.org/exception-safe.html&quot;&gt;就是这样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48badfbf8cc430bc5e24fa5412476d41eda3ceaf" translate="yes" xml:space="preserve">
          <source>Using functions and more types than the template:</source>
          <target state="translated">使用函数和比模板更多的类型。</target>
        </trans-unit>
        <trans-unit id="4eca2488380272881b9de30c76f64561c55803ca" translate="yes" xml:space="preserve">
          <source>Using group, an associative array can be easily generated with the count of each unique element in the range.</source>
          <target state="translated">使用group,可以很容易地生成一个关联数组,其中包含范围内每个唯一元素的计数。</target>
        </trans-unit>
        <trans-unit id="e894da306300d7264b04f9bbeb317a07ad4c4216" translate="yes" xml:space="preserve">
          <source>Using the above flag, the linker will search in the standard framework paths. The standard search paths for frameworks are:</source>
          <target state="translated">使用上述标志,链接器将在标准的框架路径中进行搜索。框架的标准搜索路径是:。</target>
        </trans-unit>
        <trans-unit id="e137a8793cb9aa11c5797755fd5b985067bcda9f" translate="yes" xml:space="preserve">
          <source>Using the range returned by this function in a parallel foreach loop will not work because buffers may be overwritten while the task that processes them is in queue. This is checked for at compile time and will result in a static assertion failure.</source>
          <target state="translated">在并行foreach循环中使用该函数返回的范围是行不通的,因为当处理缓冲区的任务在队列中时,缓冲区可能会被覆盖。这在编译时就会被检查,并会导致静态断言失败。</target>
        </trans-unit>
        <trans-unit id="b6ed578893f11c816c086498ada4c56ae14083de" translate="yes" xml:space="preserve">
          <source>Using this delegate allows iteration over successive time points which are all the same day of the week. e.g. passing &lt;code&gt;DayOfWeek.mon&lt;/code&gt; to &lt;code&gt;everyDayOfWeek&lt;/code&gt; would result in a delegate which could be used to iterate over all of the Mondays in a range.</source>
          <target state="translated">使用此委托可以在一周的同一天的连续时间点上进行迭代。例如，将 &lt;code&gt;DayOfWeek.mon&lt;/code&gt; 传递给 &lt;code&gt;everyDayOfWeek&lt;/code&gt; 将导致产生一个委托，该委托可用于遍历范围中的所有星期一。</target>
        </trans-unit>
        <trans-unit id="01e4a295ee1f89ba313532d06753451f037e5d2d" translate="yes" xml:space="preserve">
          <source>Using this delegate allows iteration over successive time points which are apart by the given duration e.g. passing &lt;code&gt;dur!&quot;days&quot;(3)&lt;/code&gt; to &lt;code&gt;everyDuration&lt;/code&gt; would result in a delegate which could be used to iterate over a range of days which are each 3 days apart.</source>
          <target state="translated">使用此委托可以在相隔给定持续时间的连续时间点上进行迭代，例如，将 &lt;code&gt;dur!&quot;days&quot;(3)&lt;/code&gt; 传递给 &lt;code&gt;everyDuration&lt;/code&gt; 将导致一个委托，该委托可用于迭代相隔3天的日期范围。</target>
        </trans-unit>
        <trans-unit id="c6ec51f5ced2a1c1be894f86e670f88f6e1b3f63" translate="yes" xml:space="preserve">
          <source>Using this module is not necessary in typical D code. It is mostly useful when doing low-level memory management.</source>
          <target state="translated">在典型的D代码中,使用这个模块是没有必要的。它主要是在做低级内存管理时有用。</target>
        </trans-unit>
        <trans-unit id="631bc23f5ec2b24f0267b7cee38a13c6b70e0b32" translate="yes" xml:space="preserve">
          <source>Using unit tests in conjuction with coverage testing (such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-cov&quot;&gt;&lt;b&gt;-cov&lt;/b&gt;&lt;/a&gt;) is effective.</source>
          <target state="translated">将单元测试与覆盖率测试（例如&lt;a href=&quot;https://dlang.org/dmd.html#switch-cov&quot;&gt;&lt;b&gt;-cov&lt;/b&gt;&lt;/a&gt;）结合使用是有效的。</target>
        </trans-unit>
        <trans-unit id="4a52cd6fd741b2e0850db631fed27601b7a4f5f6" translate="yes" xml:space="preserve">
          <source>Using unit tests in conjunction with coverage testing (such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-cov&quot;&gt;&lt;b&gt;-cov&lt;/b&gt;&lt;/a&gt;) is effective.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d387cfce482bd0157645391025dc0dab84b81bed" translate="yes" xml:space="preserve">
          <source>Using with void handlers:</source>
          <target state="translated">与void处理程序一起使用。</target>
        </trans-unit>
        <trans-unit id="9d57966a5fe4d9e61b9bd2b025a52cea4116ac88" translate="yes" xml:space="preserve">
          <source>Usual Arithmetic Conversions</source>
          <target state="translated">通常的算术转换</target>
        </trans-unit>
        <trans-unit id="375fab11fc70c98c677eac17e0744c53564be0ee" translate="yes" xml:space="preserve">
          <source>Usual decimal notation</source>
          <target state="translated">通常的小数点符号</target>
        </trans-unit>
        <trans-unit id="189e13a83ee98c7852ba58517289e900a3678612" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;CAllocatorImpl&lt;/code&gt; is used indirectly by calling &lt;a href=&quot;#theAllocator&quot;&gt;&lt;code&gt;theAllocator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常 &lt;code&gt;CAllocatorImpl&lt;/code&gt; 是通过调用间接使用&lt;a href=&quot;#theAllocator&quot;&gt; &lt;code&gt;theAllocator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a3ab50d8476aca67a9de9d6b2f04749ce4d85ba" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; is used indirectly by calling &lt;a href=&quot;#processAllocator&quot;&gt;&lt;code&gt;processAllocator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常，通过调用&lt;a href=&quot;#processAllocator&quot;&gt; &lt;code&gt;processAllocator&lt;/code&gt; &lt;/a&gt;间接使用 &lt;code&gt;CSharedAllocatorImpl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcec0c4180b39c4ca2dae249c28eee53727aacb0" translate="yes" xml:space="preserve">
          <source>Usually one would use &lt;code&gt;expression.checkDeprecated(scope, aliasthis)&lt;/code&gt; to check if &lt;code&gt;expression&lt;/code&gt; uses a deprecated &lt;code&gt;aliasthis&lt;/code&gt;, but this calls &lt;code&gt;toPrettyChars&lt;/code&gt; which lead to the following message: &quot;Deprecation: alias this &lt;code&gt;fullyqualified.aggregate.__anonymous&lt;/code&gt; is deprecated&quot;</source>
          <target state="translated">通常，人们会使用 &lt;code&gt;expression.checkDeprecated(scope, aliasthis)&lt;/code&gt; 来检查 &lt;code&gt;expression&lt;/code&gt; 是否使用了不赞成使用的 &lt;code&gt;aliasthis&lt;/code&gt; ，但这会调用 &lt;code&gt;toPrettyChars&lt;/code&gt; ，从而导致以下消息：&amp;ldquo; 不赞成使用：此 &lt;code&gt;fullyqualified.aggregate.__anonymous&lt;/code&gt; 别名。aggregate.__ anonymous已弃用&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="56e90d07707b3458a805a4bacd63daec2c432b02" translate="yes" xml:space="preserve">
          <source>Utf8Matcher</source>
          <target state="translated">Utf8Matcher</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="7ad38c788cc45a5074b9ffb9432c47c67a220b54" translate="yes" xml:space="preserve">
          <source>Utilities for manipulating files and scanning directories. Functions in this module handle files as a unit, e.g., read or write one file at a time. For opening files and manipulating them via handles refer to module &lt;a href=&quot;std_stdio&quot;&gt;&lt;code&gt;std.stdio&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用于处理文件和扫描目录的实用程序。该模块中的功能将文件作为一个单元来处理，例如，一次读取或写入一个文件。有关打开文件并通过句柄进行操作的信息，请参阅模块&lt;a href=&quot;std_stdio&quot;&gt; &lt;code&gt;std.stdio&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cb76eeaae4889cbc133d348ffc75221ffb8b4b7" translate="yes" xml:space="preserve">
          <source>Utility and ancillary artifacts of &lt;code&gt;std.experimental.allocator&lt;/code&gt;. This module shouldn't be used directly; its functionality will be migrated into more appropriate parts of &lt;code&gt;std&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.experimental.allocator&lt;/code&gt; 的实用程序和辅助工件。这个模块不应该直接使用；其功能将迁移到 &lt;code&gt;std&lt;/code&gt; 的更适当的部分。</target>
        </trans-unit>
        <trans-unit id="b9867d3a9c49162da041043a50cf7008b982e4ef" translate="yes" xml:space="preserve">
          <source>Utility to build a function call out of this reference and argument.</source>
          <target state="translated">用这个引用和参数建立一个函数调用的实用程序。</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="6cf0c0c7f5bb0a5a5c7282f8cd30993e76deb2f0" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;exchangeWith&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;exchangeWith&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="996b87ed0fe8487bff29a2dec4722ab527ea5a40" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;maxAbsDiff&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;maxAbsDiff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58e6f841de246b5933aae9d3dc5868627507c120" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;maxRelDiff&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;maxRelDiff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20db17f1551f67285ce8cf2eb53ceb553508099d" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;newval&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf6b2708f752f3849720cb5f4bb150990c142ea" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">V &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ceb0d7dbc0e1ba5c877e451af696f96367121e3f" translate="yes" xml:space="preserve">
          <source>V &lt;code&gt;writeThis&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7aa9428cf99ed21c9b2d50259bb210fc9c6653b" translate="yes" xml:space="preserve">
          <source>V &lt;strong id=&quot;loadUnaligned&quot;&gt;loadUnaligned&lt;/strong&gt;(V)(const V* p)</source>
          <target state="translated">V &lt;strong id=&quot;loadUnaligned&quot;&gt;负载未对齐&lt;/strong&gt;（V）（常数V * p）</target>
        </trans-unit>
        <trans-unit id="ea4bf31a65b803e6d5e8754862432a804bcf1f21" translate="yes" xml:space="preserve">
          <source>V &lt;strong id=&quot;storeUnaligned&quot;&gt;storeUnaligned&lt;/strong&gt;(V)(V* p, V value)</source>
          <target state="translated">V &lt;strong id=&quot;storeUnaligned&quot;&gt;store未对齐&lt;/strong&gt;（V）（V * p，V值）</target>
        </trans-unit>
        <trans-unit id="942a90c9bec88d5207a1a5060881571e2b1fe393" translate="yes" xml:space="preserve">
          <source>V* &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">V * &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3bd3be2bbc21bec248542658e53653f18b36f05" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;ifThis&lt;/code&gt;</source>
          <target state="translated">V1 &lt;code&gt;ifThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="049a85cf151f96bcc540c68c5cd2d1eea3c1509d" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;mod&lt;/code&gt;</source>
          <target state="translated">V1 &lt;code&gt;mod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4053c68a54663b4758120d92e86ef8bfc8c214a" translate="yes" xml:space="preserve">
          <source>V1 &lt;code&gt;newval&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;newval&lt;/code&gt; V1</target>
        </trans-unit>
        <trans-unit id="94d860f8b520a6cee844237c3ad2d206fa305d0f" translate="yes" xml:space="preserve">
          <source>V1 ifThis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d2c6ab8c00acf411a44e6002c81ee87fc3e301" translate="yes" xml:space="preserve">
          <source>V1* &lt;code&gt;ifThis&lt;/code&gt;</source>
          <target state="translated">V1 * &lt;code&gt;ifThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40135827f1648afd73698821e7495e8c2df48b20" translate="yes" xml:space="preserve">
          <source>V2 &lt;code&gt;writeThis&lt;/code&gt;</source>
          <target state="translated">V2 &lt;code&gt;writeThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27b474c7b076d7d30fee8040c56c7c2a561bd720" translate="yes" xml:space="preserve">
          <source>V2 writeThis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025198e42a319f7e1b7d4e566d6832369521d744" translate="yes" xml:space="preserve">
          <source>VFS only</source>
          <target state="translated">仅VFS</target>
        </trans-unit>
        <trans-unit id="76bc45e6071b6bf840834c3190d06cac0f7b7fac" translate="yes" xml:space="preserve">
          <source>V[K] &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="translated">V [K] &lt;code&gt;aa&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84f91d8df4169488a6e5b0c8d99b4bcf85ff79ce" translate="yes" xml:space="preserve">
          <source>V[K] &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;(T : V[K], K, V)(T aa);</source>
          <target state="translated">V [K] &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;（T：V [K]，K，V）（T aa）;</target>
        </trans-unit>
        <trans-unit id="4f374392fc8216fb266b35c7afa3c5383908a973" translate="yes" xml:space="preserve">
          <source>Vai</source>
          <target state="translated">Vai</target>
        </trans-unit>
        <trans-unit id="83f96f97d6bbb741686c832649fe36d1655e12f1" translate="yes" xml:space="preserve">
          <source>Validates an email address according to RFCs 5321, 5322 and others.</source>
          <target state="translated">根据RFC5321、5322等验证电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="cde694e20f6f1970e02f61b4fe4c250aab2573eb" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">价值 &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40e4777c3c9339aee0e1471542316f607e20c0b4" translate="yes" xml:space="preserve">
          <source>Value getter for &lt;code&gt;JSONType.array&lt;/code&gt;. Unlike &lt;code&gt;array&lt;/code&gt;, this retrieves the array by value and can be used in @safe code.</source>
          <target state="translated">&lt;code&gt;JSONType.array&lt;/code&gt; 的值获取器。与 &lt;code&gt;array&lt;/code&gt; 不同，它按值检索数组，可以在@safe代码中使用。</target>
        </trans-unit>
        <trans-unit id="debaeee666e351d6eab3b4f3c90b3aa9118a0ea0" translate="yes" xml:space="preserve">
          <source>Value getter for &lt;code&gt;JSONType.object&lt;/code&gt;. Unlike &lt;code&gt;object&lt;/code&gt;, this retrieves the object by value and can be used in @safe code.</source>
          <target state="translated">&lt;code&gt;JSONType.object&lt;/code&gt; 的值获取器。与 &lt;code&gt;object&lt;/code&gt; 不同，它按值检索对象，并且可以在@safe代码中使用。</target>
        </trans-unit>
        <trans-unit id="0d34b60081d5920e95d26de3b14e5976c483a6c8" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.array&lt;/code&gt; 的值获取/设置器。</target>
        </trans-unit>
        <trans-unit id="06d88a23659d2106a272fc3c2a0cbf425061e548" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.float_&lt;/code&gt;. Note that despite the name, this is a &lt;b&gt;64&lt;/b&gt;-bit &lt;code&gt;double&lt;/code&gt;, not a 32-bit &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.float_&lt;/code&gt; 的值获取/设置器。请注意，尽管有名称，但这是&lt;b&gt;64&lt;/b&gt;位 &lt;code&gt;double&lt;/code&gt; ，而不是32位 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="682193cf221d6f67ac3388d98af6c6643d6280c0" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.integer&lt;/code&gt; 的值获取/设置器。</target>
        </trans-unit>
        <trans-unit id="b856cf95a7918cf8c4713730d8144e2773a78ad5" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.object&lt;/code&gt; 的值获取/设置器。</target>
        </trans-unit>
        <trans-unit id="f77315c89ea8901db907f7202a186401d954a3ab" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.string&lt;/code&gt; 的值获取/设置器。</target>
        </trans-unit>
        <trans-unit id="04d25aeadd95822d75f9e6c63a59113dd6ae997a" translate="yes" xml:space="preserve">
          <source>Value getter/setter for &lt;code&gt;JSONType.uinteger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONType.uinteger&lt;/code&gt; 的值获取/设置器。</target>
        </trans-unit>
        <trans-unit id="c903c7f6e0c9717a3204ee2e6392ffb91a1e532e" translate="yes" xml:space="preserve">
          <source>Value getter/setter for boolean stored in JSON.</source>
          <target state="translated">存储在JSON中的布尔值获取器/设置器。</target>
        </trans-unit>
        <trans-unit id="f6a96ca6f671cd62067e2694b2efd9807e5523cb" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;f(ax)&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;f(ax)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f84944c7f8eab7774fddf4925d08c76461c466b" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;f(bx)&lt;/code&gt;. &lt;code&gt;fax&lt;/code&gt; and &lt;code&gt;fbx&lt;/code&gt; should have opposite signs. (&lt;code&gt;f(ax)&lt;/code&gt; and &lt;code&gt;f(bx)&lt;/code&gt; are commonly known in advance.)</source>
          <target state="translated">的值 &lt;code&gt;f(bx)&lt;/code&gt; 。 &lt;code&gt;fax&lt;/code&gt; 和 &lt;code&gt;fbx&lt;/code&gt; 的符号应相反。（ &lt;code&gt;f(ax)&lt;/code&gt; 和 &lt;code&gt;f(bx)&lt;/code&gt; 是事先众所周知的。）</target>
        </trans-unit>
        <trans-unit id="d1610fa402b56db1bc6c44e14091878669be03b2" translate="yes" xml:space="preserve">
          <source>Value that collectExceptionMsg returns when it catches an exception with an empty exception message.</source>
          <target state="translated">收集ExceptionMsg的值,当它捕捉到一个带有空的异常消息的异常时返回。</target>
        </trans-unit>
        <trans-unit id="35127929f685cd18a15efc62a6a5cd564850b329" translate="yes" xml:space="preserve">
          <source>Value to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640fc9d1038f173d9ff4e515bd951053c5419590" translate="yes" xml:space="preserve">
          <source>Value to return from &lt;code&gt;onSend&lt;/code&gt;/&lt;code&gt;onReceive&lt;/code&gt; delegates in order to pause a request</source>
          <target state="translated">从 &lt;code&gt;onSend&lt;/code&gt; / &lt;code&gt;onReceive&lt;/code&gt; 委托返回的值，以暂停请求</target>
        </trans-unit>
        <trans-unit id="436caeedb105a260006f5d9f53f71e6eb7af184e" translate="yes" xml:space="preserve">
          <source>Value to return from onSend delegate in order to abort a request</source>
          <target state="translated">从onSend委托人返回的值,以中止请求。</target>
        </trans-unit>
        <trans-unit id="ed85e45d389cbb4acbbfe9be4b8d5516228b0f43" translate="yes" xml:space="preserve">
          <source>Value type demonstration</source>
          <target state="translated">价值类型演示</target>
        </trans-unit>
        <trans-unit id="ad0bdabc6c843c169a4bd7ec05f40c7999e6699f" translate="yes" xml:space="preserve">
          <source>Value value</source>
          <target state="translated">价值价值</target>
        </trans-unit>
        <trans-unit id="5fb5308fe6160bec01a01fc2fea5f665d1701122" translate="yes" xml:space="preserve">
          <source>ValueSeq</source>
          <target state="translated">ValueSeq</target>
        </trans-unit>
        <trans-unit id="80e79fa2f03b848be57a9426e000a580cab24a28" translate="yes" xml:space="preserve">
          <source>Value[Key] &lt;code&gt;aa&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff7efaccf1f82a33020670f421492cb87dbc329" translate="yes" xml:space="preserve">
          <source>Values &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">值 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e66a2fd88968dd1905cd7e88ccfa7f4decf710b7" translate="yes" xml:space="preserve">
          <source>Values for Tflags:</source>
          <target state="translated">Tflags的数值。</target>
        </trans-unit>
        <trans-unit id="d65dbad78909b2a5a1065f983fcd9dc730699c3f" translate="yes" xml:space="preserve">
          <source>Values representing all properties for floating point types</source>
          <target state="translated">代表浮点类型所有属性的值</target>
        </trans-unit>
        <trans-unit id="f93686df732b3fd8135c18d6d396b9ab2d76ddbc" translate="yes" xml:space="preserve">
          <source>Values that have no mutable indirections (including structs that don't contain any field with mutable indirections) can be implicitly converted across</source>
          <target state="translated">没有可突变间接性的值(包括不包含任何可突变间接性字段的结构)可以隐式地转换为跨</target>
        </trans-unit>
        <trans-unit id="6dae52b6d63731f1974b82b7571f6c94a8ffe05e" translate="yes" xml:space="preserve">
          <source>Values to initialize the &lt;code&gt;Tuple&lt;/code&gt; with. The &lt;code&gt;Tuple&lt;/code&gt;'s type will be inferred from the types of the values given.</source>
          <target state="translated">用于初始化 &lt;code&gt;Tuple&lt;/code&gt; 值。该 &lt;code&gt;Tuple&lt;/code&gt; 的类型将从类型给出的值的推断。</target>
        </trans-unit>
        <trans-unit id="a08087f5493c6ce5a8e9b48863d20de7128f05b2" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">变量声明 &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09a1466d563df21a998ae094ed1211927a8bb608" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;copyToTemp&quot;&gt;copyToTemp&lt;/strong&gt;(StorageClass stc, const char* name, Expression e);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;copyToTemp&quot;&gt;copyToTemp&lt;/strong&gt;（StorageClass stc，const char *名称，表达式e）;</target>
        </trans-unit>
        <trans-unit id="8b0928059a3c63031609334a2150b3e8d06084c2" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;expToVariable&quot;&gt;expToVariable&lt;/strong&gt;(Expression e);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;expToVariable&quot;&gt;expToVariable&lt;/strong&gt;（表达式e）;</target>
        </trans-unit>
        <trans-unit id="90f8642275d9fc08bf7503b4c8af023eb923bdfb" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;lastVar&quot;&gt;lastVar&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;lastVar&quot;&gt;lastVar&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="93a7a74d06aa15956fd41f9b3c8c0f88bdfeb09e" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;makeThis2Argument&quot;&gt;makeThis2Argument&lt;/strong&gt;(ref const Loc loc, Scope* sc, FuncDeclaration fd);</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;makeThis2Argument&quot;&gt;makeThis2Argument&lt;/strong&gt;（ref const Loc loc，Scope * sc，FuncDeclaration fd）;</target>
        </trans-unit>
        <trans-unit id="f8436ac83c71ac8d42475febc7871f32c710c99c" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;nrvo_var&quot;&gt;nrvo_var&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;nrvo_var&quot;&gt;nrvo_var&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="18c616e0fbbc261b725f83621064accc3a1deeea" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;selectorParameter&quot;&gt;selectorParameter&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;selectorParameter&quot;&gt;selectorParameter&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="12d50a347dabe7e15bb22e20811c56593e1bcae1" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;v_argptr&quot;&gt;v_argptr&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;v_argptr&quot;&gt;v_argptr&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="f56d1a786ffb7ff06d7bb5bfa04d51b1b21ab644" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;v_arguments&quot;&gt;v_arguments&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;v_arguments&quot;&gt;v_arguments&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="876239d27c5e57e358e8556afab8f0538d5c97fc" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;var&quot;&gt;var&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;var&quot;&gt;var&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="42355f26f4ab9b91101680194f5be4e62a6fe977" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;vresult&quot;&gt;vresult&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;vresult&quot;&gt;结果&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2e565c7d36ce463afb9fc418f5d295a5bbc339dc" translate="yes" xml:space="preserve">
          <source>VarDeclaration &lt;strong id=&quot;vthis&quot;&gt;vthis&lt;/strong&gt;;</source>
          <target state="translated">VarDeclaration &lt;strong id=&quot;vthis&quot;&gt;vthis&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="cbb4632d198d84986be1df6e34c6a01f8e53f3c6" translate="yes" xml:space="preserve">
          <source>VarDeclaration[] &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">VarDeclaration [] &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3cd372ff99770eda36a8d3e2dcd3e16f4cd0b425" translate="yes" xml:space="preserve">
          <source>VarDeclarations &lt;strong id=&quot;closureVars&quot;&gt;closureVars&lt;/strong&gt;;</source>
          <target state="translated">VarDeclarations &lt;strong id=&quot;closureVars&quot;&gt;闭&lt;/strong&gt;包&lt;strong id=&quot;closureVars&quot;&gt;Vars&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="d1b9876e8a834a3e9b9e89838f595256e4706851" translate="yes" xml:space="preserve">
          <source>VarDeclarations* &lt;code&gt;vars&lt;/code&gt;</source>
          <target state="translated">VarDeclarations * &lt;code&gt;vars&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d65fd05a8f0de9525a8aab22e9d373bb1f9c2e" translate="yes" xml:space="preserve">
          <source>VarDeclarations* &lt;strong id=&quot;parameters&quot;&gt;parameters&lt;/strong&gt;;</source>
          <target state="translated">VarDeclarations * &lt;strong id=&quot;parameters&quot;&gt;参数&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="8de05a295df0a022b8c2f74c1c4b8846fa725f50" translate="yes" xml:space="preserve">
          <source>Variable Templates</source>
          <target state="translated">可变模板</target>
        </trans-unit>
        <trans-unit id="9ac503641226541343accfe90a0e5126b2011089" translate="yes" xml:space="preserve">
          <source>Variable declarations with the storage class &lt;code&gt;extern&lt;/code&gt; are not allocated storage within the module. They must be defined in some other object file with a matching name which is then linked in.</source>
          <target state="translated">存储类为 &lt;code&gt;extern&lt;/code&gt; 的变量声明未在模块内分配存储。必须在其他目标文件中使用匹配的名称定义它们，然后将其链接。</target>
        </trans-unit>
        <trans-unit id="f86354cce64b43ba4bcdfcfa863ee091b56ebec5" translate="yes" xml:space="preserve">
          <source>Variadic Function Arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d65e9595c5fe8cf9c55be3b01afd1c068462a4a" translate="yes" xml:space="preserve">
          <source>Variadic Function Templates can have parameters with default values. These parameters are always set to their default value in case of IFTI.</source>
          <target state="translated">变量函数模板可以有默认值的参数。在IFTI的情况下,这些参数总是被设置为默认值。</target>
        </trans-unit>
        <trans-unit id="816e535fd41b8ae59e68e3a0203deed34e57e3f0" translate="yes" xml:space="preserve">
          <source>Variadic Functions</source>
          <target state="translated">变分函数</target>
        </trans-unit>
        <trans-unit id="3ce44260db47b27a0765a58fa46f6799200c7452" translate="yes" xml:space="preserve">
          <source>Variadic argument list.</source>
          <target state="translated">变量参数列表。</target>
        </trans-unit>
        <trans-unit id="7587c77875817ada8a5026c856c2f1518162a905" translate="yes" xml:space="preserve">
          <source>Variadic argument lists &lt;a href=&quot;https://dlang.org/spec/function.html#variadic&quot;&gt;https://dlang.org/spec/function.html#variadic&lt;/a&gt;</source>
          <target state="translated">可变参数列表&lt;a href=&quot;https://dlang.org/spec/function.html#variadic&quot;&gt;https://dlang.org/spec/function.html#variadic&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2baf171f268c7ff8a5516278ea308ebe744eee6a" translate="yes" xml:space="preserve">
          <source>Variadic arguments to constructors are not forwarded to super.</source>
          <target state="translated">构造函数的变量参数不会被转发到super。</target>
        </trans-unit>
        <trans-unit id="032728a05fbda40894355d391ba66d41db7dfa0b" translate="yes" xml:space="preserve">
          <source>Variadic constructor</source>
          <target state="translated">变量构造函数</target>
        </trans-unit>
        <trans-unit id="399c0cba694f3cc4563013462fe2f380391903d2" translate="yes" xml:space="preserve">
          <source>Variadic functions with argument and type info are declared as taking a parameter of ... after the required function parameters. It has D linkage, and need not have any non-variadic parameters declared:</source>
          <target state="translated">变量函数有参数和类型信息,声明为在所需函数参数后取...的参数。它具有D的联系,不需要声明任何非变量参数。</target>
        </trans-unit>
        <trans-unit id="e4ee6519876a792c801d55be8e1784d8bf29d4ef" translate="yes" xml:space="preserve">
          <source>Variadic functions with type info</source>
          <target state="translated">带有类型信息的变量函数</target>
        </trans-unit>
        <trans-unit id="5d2a300261f6a90712ba60d1554b5378b1469844" translate="yes" xml:space="preserve">
          <source>Variadic list of arguments to format into returned string.</source>
          <target state="translated">用于格式化为返回字符串的变量列表。</target>
        </trans-unit>
        <trans-unit id="b8a1599a54086f4276bc080b191b81748f1fd35d" translate="yes" xml:space="preserve">
          <source>Variadic list of function pointers and delegates. Entries in this list must not occlude later entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea010a54d25304f176a7f8d1fba33099d2a6ac09" translate="yes" xml:space="preserve">
          <source>Variadic list of types to be received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cacd55c63e5681b498a2a8e79b74af695379b94" translate="yes" xml:space="preserve">
          <source>Variadic skipOver</source>
          <target state="translated">变量跳过</target>
        </trans-unit>
        <trans-unit id="3ec54f528a04bfb78ded9b978c3382ebd1084d0f" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;message&quot;&gt;message&lt;/strong&gt;;</source>
          <target state="translated">变体&lt;strong id=&quot;message&quot;&gt;信息&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="32ee207e01c00b2bfe4113ac9e48d0adc0d9a6ad" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;opIndexAssign&quot;&gt;opIndexAssign&lt;/strong&gt;(T, N)(T value, N i);</source>
          <target state="translated">变量&lt;strong id=&quot;opIndexAssign&quot;&gt;opIndexAssign&lt;/strong&gt;（T，N）（T值，N i）;</target>
        </trans-unit>
        <trans-unit id="39996f79d077e561bfc7c4efc30631527277acc7" translate="yes" xml:space="preserve">
          <source>Variant &lt;strong id=&quot;opIndexOpAssign&quot;&gt;opIndexOpAssign&lt;/strong&gt;(string op, T, N)(T value, N i);</source>
          <target state="translated">变量&lt;strong id=&quot;opIndexOpAssign&quot;&gt;opIndexOpAssign&lt;/strong&gt;（字符串op，T，N）（T值，N i）;</target>
        </trans-unit>
        <trans-unit id="54c59e2064d684bcdbd701d33a0bcca0d124521f" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opAssign&quot;&gt;opAssign&lt;/strong&gt;(T)(T rhs);</source>
          <target state="translated">VariantN &lt;strong id=&quot;opAssign&quot;&gt;opAssign&lt;/strong&gt;（T）（T rhs）;</target>
        </trans-unit>
        <trans-unit id="a89006b66590fbcedb1cf804abc7dcc4a7855324" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, T)(T rhs)</source>
          <target state="translated">VariantN &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;（字符串op，T）（T rhs）</target>
        </trans-unit>
        <trans-unit id="d50bd63e988142a8ed68771d6708dd3a3ef38a9f" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opBinaryRight&quot;&gt;opBinaryRight&lt;/strong&gt;(string op, T)(T lhs)</source>
          <target state="translated">VariantN &lt;strong id=&quot;opBinaryRight&quot;&gt;opBinaryRight&lt;/strong&gt;（字符串op，T）（T lhs）</target>
        </trans-unit>
        <trans-unit id="dcf8ce2200e09370d71e1c6c556f440c7178243e" translate="yes" xml:space="preserve">
          <source>VariantN &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, T)(T rhs);</source>
          <target state="translated">VariantN &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;（string op，T）（T rhs）;</target>
        </trans-unit>
        <trans-unit id="61d3a42cae9e2aa7a2127354c8d2a82e31e5f69f" translate="yes" xml:space="preserve">
          <source>Variant[] &lt;strong id=&quot;variantArray&quot;&gt;variantArray&lt;/strong&gt;(T...)(T args);</source>
          <target state="translated">Variant [] &lt;strong id=&quot;variantArray&quot;&gt;variantArray&lt;/strong&gt;（T ...）（T args）;</target>
        </trans-unit>
        <trans-unit id="901dc81724f513c6e370e0d8b34b4fa85efd9490" translate="yes" xml:space="preserve">
          <source>Variation Selectors</source>
          <target state="translated">变化选择器</target>
        </trans-unit>
        <trans-unit id="c842f577712c9ce569d8ca8213f4583b78433b04" translate="yes" xml:space="preserve">
          <source>Variation Selectors Supplement</source>
          <target state="translated">变化选择器补充版</target>
        </trans-unit>
        <trans-unit id="66283c9058f793e57afbf6f12f5f67c2782019ef" translate="yes" xml:space="preserve">
          <source>Variation of Base64 encoding that is safe for use in URLs and filenames.</source>
          <target state="translated">Base64编码的变化,可以安全地用于URL和文件名。</target>
        </trans-unit>
        <trans-unit id="85213404cd60884f4a897dfadd72c6565a384b83" translate="yes" xml:space="preserve">
          <source>Variation_Selector</source>
          <target state="translated">Variation_Selector</target>
        </trans-unit>
        <trans-unit id="37d044e9653fde1af3399c03c94f78dbe8624404" translate="yes" xml:space="preserve">
          <source>Various different debug builds can be built with a parameter to debug:</source>
          <target state="translated">各种不同的调试构建可以通过参数来调试。</target>
        </trans-unit>
        <trans-unit id="fdc4922db0ff01d0b7edd8e9b629bfcad196b8fd" translate="yes" xml:space="preserve">
          <source>Various different version builds can be built with a parameter to version:</source>
          <target state="translated">通过对版本的参数,可以建立各种不同的版本构建。</target>
        </trans-unit>
        <trans-unit id="e63f884e9cb15e3080b00623367fb3234dfb09e6" translate="yes" xml:space="preserve">
          <source>Various functions take a string (or strings) to represent a unit of time (e.g. &lt;code&gt;convert!(&quot;days&quot;, &quot;hours&quot;)(numDays)&lt;/code&gt;). The valid strings to use with such functions are &quot;years&quot;, &quot;months&quot;, &quot;weeks&quot;, &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;, &quot;seconds&quot;, &quot;msecs&quot; (milliseconds), &quot;usecs&quot; (microseconds), &quot;hnsecs&quot; (hecto-nanoseconds - i.e. 100 ns) or some subset thereof. There are a few functions that also allow &quot;nsecs&quot;, but very little actually has precision greater than hnsecs.</source>
          <target state="translated">各种函数使用一个（或多个）字符串来表示时间单位（例如， &lt;code&gt;convert!(&quot;days&quot;, &quot;hours&quot;)(numDays)&lt;/code&gt; ）。与此类函数一起使用的有效字符串是&amp;ldquo;年&amp;rdquo;，&amp;ldquo;月&amp;rdquo;，&amp;ldquo;周&amp;rdquo;，&amp;ldquo;天&amp;rdquo;，&amp;ldquo;小时&amp;rdquo;，&amp;ldquo;分钟&amp;rdquo;，&amp;ldquo;秒&amp;rdquo;，&amp;ldquo;毫秒&amp;rdquo;（毫秒），&amp;ldquo; usecs&amp;rdquo;（微秒） ，&amp;ldquo; hnsecs&amp;rdquo;（百纳秒-即100 ns）或其某些子集。有一些函数也允许&amp;ldquo; nsecs&amp;rdquo;，但实际上很少有比hnsecs大的精度。</target>
        </trans-unit>
        <trans-unit id="0e7432cf190c6da3860c9d822a4eb7ba1045ce6c" translate="yes" xml:space="preserve">
          <source>Vector Extensions</source>
          <target state="translated">矢量扩展</target>
        </trans-unit>
        <trans-unit id="10629e605ca0729fbf04887a08544de5fca2798c" translate="yes" xml:space="preserve">
          <source>Vector Operation Intrinsics</source>
          <target state="translated">矢量操作的本质</target>
        </trans-unit>
        <trans-unit id="c92e264e05e71f98aeb7e123b045932363360044" translate="yes" xml:space="preserve">
          <source>Vector Type Properties</source>
          <target state="translated">矢量类型属性</target>
        </trans-unit>
        <trans-unit id="2e86fbb68d6a32b094e97ddedce6b62c4721cb9e" translate="yes" xml:space="preserve">
          <source>Vector Types</source>
          <target state="translated">矢量类型</target>
        </trans-unit>
        <trans-unit id="07181b72545f73b7288ae34baa8a686beb32c758" translate="yes" xml:space="preserve">
          <source>Vector types and operations are introduced by importing &lt;a href=&quot;https://dlang.org/phobos/core_simd.html&quot;&gt;&lt;code&gt;core.simd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">向量类型和操作是通过导入&lt;a href=&quot;https://dlang.org/phobos/core_simd.html&quot;&gt; &lt;code&gt;core.simd&lt;/code&gt; &lt;/a&gt;引入的：</target>
        </trans-unit>
        <trans-unit id="c049990f0c907a0b35a257826bc00e0b75b1e2f2" translate="yes" xml:space="preserve">
          <source>Vector types have the property:</source>
          <target state="translated">矢量类型具有以下属性:</target>
        </trans-unit>
        <trans-unit id="b74915db3cd649e1a4f2705d1b61481a4f84d736" translate="yes" xml:space="preserve">
          <source>Vector types of the same size can be implicitly converted among each other. Vector types can be cast to their &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">大小相同的向量类型可以彼此隐式转换。向量类型可以转换为其&lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18c53b8bedaa759385d9a1d0719db45a3122d467" translate="yes" xml:space="preserve">
          <source>Vedic Extensions</source>
          <target state="translated">吠陀语扩展</target>
        </trans-unit>
        <trans-unit id="1414b2c627a4af94b45e0a6f7329a9caaa64d766" translate="yes" xml:space="preserve">
          <source>Vendor Specific Pragmas</source>
          <target state="translated">供应商的具体实践</target>
        </trans-unit>
        <trans-unit id="643648d81a8af7bf6b4f73a64885b12b7476a866" translate="yes" xml:space="preserve">
          <source>Vendor specific pragma</source>
          <target state="translated">厂商专用参数</target>
        </trans-unit>
        <trans-unit id="9200d77a5dd8fafeec19ec715fa8db6a41135a49" translate="yes" xml:space="preserve">
          <source>Vendor specific string naming the compiler, for example: &quot;Digital Mars D&quot;.</source>
          <target state="translated">厂商特定的字符串对编译器进行命名,例如。&quot;Digital Mars D&quot;。</target>
        </trans-unit>
        <trans-unit id="db3cbc01da600701b9fe4a497fe328e71fa7022f" translate="yes" xml:space="preserve">
          <source>Version 1</source>
          <target state="translated">第一版</target>
        </trans-unit>
        <trans-unit id="57ce28f628abe360a4bb4a57891d0472e82ed0fe" translate="yes" xml:space="preserve">
          <source>Version 2</source>
          <target state="translated">第二版</target>
        </trans-unit>
        <trans-unit id="075d8b625649c8aff29ec9c2a1b5610d7c109764" translate="yes" xml:space="preserve">
          <source>Version 3 (Name based + MD5)</source>
          <target state="translated">第3版(基于名称+MD5)</target>
        </trans-unit>
        <trans-unit id="ddcc753d5e82e42538acd5fc16f4473c5257f4b4" translate="yes" xml:space="preserve">
          <source>Version 4 (Random)</source>
          <target state="translated">第四版(随机)</target>
        </trans-unit>
        <trans-unit id="319868a4751c2b346e9dfe64ab6429818b302223" translate="yes" xml:space="preserve">
          <source>Version 5 (Name based + SHA-1)</source>
          <target state="translated">第5版(基于名称+SHA-1)</target>
        </trans-unit>
        <trans-unit id="e66316ca12a840f1988c4b94ab525a7f42bae2cc" translate="yes" xml:space="preserve">
          <source>Version Condition</source>
          <target state="translated">版本条件</target>
        </trans-unit>
        <trans-unit id="4d10083d98ea26e265f0014436dbfce2fa1927ba" translate="yes" xml:space="preserve">
          <source>Version Specification</source>
          <target state="translated">版本规格</target>
        </trans-unit>
        <trans-unit id="60cbe77612285f77722795eaf486e9077345ff6b" translate="yes" xml:space="preserve">
          <source>Version identifiers are in their own unique name space, they do not conflict with debug identifiers or other symbols in the module. Version identifiers defined in one module have no influence over other imported modules.</source>
          <target state="translated">版本标识符在自己唯一的名称空间中,它们与模块中的调试标识符或其他符号不冲突。一个模块中定义的版本标识符对其他导入的模块没有影响。</target>
        </trans-unit>
        <trans-unit id="8452f9b655098d440b8bbfefe1781b61039f888f" translate="yes" xml:space="preserve">
          <source>Version identifiers or levels may not be forward referenced:</source>
          <target state="translated">版本标识符或级别不得向前引用。</target>
        </trans-unit>
        <trans-unit id="8639bd1e7277675ae42f2185af060f18565b1cba" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;task&lt;/code&gt; usable from &lt;code&gt;@safe&lt;/code&gt; code. Usage mechanics are identical to the non-@safe case, but safety introduces some restrictions:</source>
          <target state="translated">可从 &lt;code&gt;@safe&lt;/code&gt; 代码使用的 &lt;code&gt;task&lt;/code&gt; 版本。使用机制与非@safe情况相同，但是安全性引入了一些限制：</target>
        </trans-unit>
        <trans-unit id="9f49127025fb5873ad1bd738867c76e3725ffeaa" translate="yes" xml:space="preserve">
          <source>Version:</source>
          <target state="translated">Version:</target>
        </trans-unit>
        <trans-unit id="8ba6c0ad00aab5da97cc5e9d2ce6ef4a16d6e35f" translate="yes" xml:space="preserve">
          <source>VersionCondition</source>
          <target state="translated">VersionCondition</target>
        </trans-unit>
        <trans-unit id="d5945a6259445f6d607383ec1208b7b2bf5b1920" translate="yes" xml:space="preserve">
          <source>VersionSpecification</source>
          <target state="translated">VersionSpecification</target>
        </trans-unit>
        <trans-unit id="7870ecf513f546adaa9964ca9e10d00cc0c279a8" translate="yes" xml:space="preserve">
          <source>VersionSymbol's happen for statements like: version = identifier; version = integer;</source>
          <target state="translated">VersionSymbol的发生于这样的语句:版本=标识符;版本=整数。</target>
        </trans-unit>
        <trans-unit id="3f4a4fcd926f6c485e563d96d221a73c6f637a3b" translate="yes" xml:space="preserve">
          <source>Versions enable multiple versions of a module to be implemented with a single source file.</source>
          <target state="translated">版本可以让一个模块的多个版本用一个源文件来实现。</target>
        </trans-unit>
        <trans-unit id="6fd4c427e710fed77db57126b79deded3402ad4f" translate="yes" xml:space="preserve">
          <source>Vertical Forms</source>
          <target state="translated">竖式</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">垂直标签</target>
        </trans-unit>
        <trans-unit id="783de7e5b7d2118dade416730da300df060f3cbb" translate="yes" xml:space="preserve">
          <source>Vertical tab (U+000B).</source>
          <target state="translated">垂直标签(U+000B)。</target>
        </trans-unit>
        <trans-unit id="b5a83b3d5b0ebbd94dda9282d36df61edd71daee" translate="yes" xml:space="preserve">
          <source>Very good at doing absolutely nothing. A good starting point for defining other allocators or for studying the API.</source>
          <target state="translated">非常擅长什么都不做。是定义其他分配器或研究API的良好起点。</target>
        </trans-unit>
        <trans-unit id="83b6b08c6edd1287fdcd6c32741f985b4501a4d1" translate="yes" xml:space="preserve">
          <source>View Name NULL</source>
          <target state="translated">视图名称 NULL</target>
        </trans-unit>
        <trans-unit id="7661d9e884510184f3115feaa61daa7fb90ab554" translate="yes" xml:space="preserve">
          <source>Virtual File System Objects</source>
          <target state="translated">虚拟文件系统对象</target>
        </trans-unit>
        <trans-unit id="b0befb20b7c19afcab0b8606b1eb82ff57c76c58" translate="yes" xml:space="preserve">
          <source>Virtual Function Pointer Table Layout</source>
          <target state="translated">虚拟功能指针表布局</target>
        </trans-unit>
        <trans-unit id="7dcd32ac0fb832374c32b25d413091959d3ff701" translate="yes" xml:space="preserve">
          <source>Virtual Functions</source>
          <target state="translated">虚拟功能</target>
        </trans-unit>
        <trans-unit id="0f4f4c40c9b657d040c9a5a3549b3c5d32fbc234" translate="yes" xml:space="preserve">
          <source>Virtual Table Configuration Options</source>
          <target state="translated">虚拟表配置选项</target>
        </trans-unit>
        <trans-unit id="d3cabefe217e8ae9513576669d0630c721003893" translate="yes" xml:space="preserve">
          <source>Virtual Table Cursor Object</source>
          <target state="translated">虚拟表光标对象</target>
        </trans-unit>
        <trans-unit id="02d05d9b66c15b554ca60cadbe6ddd8d5a77642f" translate="yes" xml:space="preserve">
          <source>Virtual Table Indexing Information</source>
          <target state="translated">虚拟表索引信息</target>
        </trans-unit>
        <trans-unit id="80548cb099ad243dfef606537d8cb425cbe7b21c" translate="yes" xml:space="preserve">
          <source>Virtual Table Instance Object</source>
          <target state="translated">虚拟表实例对象</target>
        </trans-unit>
        <trans-unit id="c7613e2461269638f02a689a01bdfb20ef96932a" translate="yes" xml:space="preserve">
          <source>Virtual Table Object</source>
          <target state="translated">虚拟表对象</target>
        </trans-unit>
        <trans-unit id="aff3c69afbe7a90d7ffde690777408380726fb5f" translate="yes" xml:space="preserve">
          <source>Virtual functions all have a hidden parameter called the</source>
          <target state="translated">虚拟函数都有一个隐藏的参数,叫做</target>
        </trans-unit>
        <trans-unit id="e1c58c4269e8592749612ae3da0cd7b360ba819a" translate="yes" xml:space="preserve">
          <source>Virtual functions are functions that are called indirectly through a function pointer table, called a vtbl[], rather than directly. All &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; member functions which are non-static and are not templatized are virtual unless the compiler can determine that they will never be overridden (e.g. they are marked with &lt;code&gt;final&lt;/code&gt; and do not override any functions in a base class), in which case, it will make them non-virtual. Static or &lt;code&gt;final&lt;/code&gt; functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage are virtual as well. This results in fewer bugs caused by not declaring a function virtual and then overriding it anyway.</source>
          <target state="translated">虚函数是通过称为vtbl []的函数指针表而不是直接调用的函数。在这种情况下，所有非静态且未模板化的 &lt;code&gt;public&lt;/code&gt; 和 &lt;code&gt;protected&lt;/code&gt; 成员函数都是虚拟的，除非编译器可以确定它们永远不会被覆盖（例如，将它们标记为 &lt;code&gt;final&lt;/code&gt; 且不覆盖基类中的任何函数） ，这将使它们成为非虚拟的。具有 &lt;code&gt;Objective-C&lt;/code&gt; 链接的静态或 &lt;code&gt;final&lt;/code&gt; 功能也是虚拟的。这导致较少的错误，这些错误是由于未声明虚拟函数然后无论如何都要覆盖它而导致的。</target>
        </trans-unit>
        <trans-unit id="14cc5cce0a54264b12497e056c1917afd19e7eb7" translate="yes" xml:space="preserve">
          <source>Virtual interface member functions do not have implementations. Interfaces are expected to implement static or final functions.</source>
          <target state="translated">虚拟接口成员函数没有实现。接口要实现静态或最终函数。</target>
        </trans-unit>
        <trans-unit id="23ecb6a10d1b99be3019a63076a2464bbfbb2301" translate="yes" xml:space="preserve">
          <source>Virtual table of this cursor</source>
          <target state="translated">该光标的虚拟表</target>
        </trans-unit>
        <trans-unit id="1c1672376b6b5ed02995bff06fe4feb7630511fb" translate="yes" xml:space="preserve">
          <source>Visibility Attribute</source>
          <target state="translated">可见度属性</target>
        </trans-unit>
        <trans-unit id="770309d5c2e0f2778ba518ab224adafe114b41f4" translate="yes" xml:space="preserve">
          <source>Visibility is an attribute that is one of &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt;, or &lt;code&gt;export&lt;/code&gt;. They may be referred to as protection attributes in documents predating &lt;a href=&quot;http://wiki.dlang.org/DIP22&quot;&gt;DIP22&lt;/a&gt;.</source>
          <target state="translated">可见性是 &lt;code&gt;private&lt;/code&gt; ， &lt;code&gt;package&lt;/code&gt; ， &lt;code&gt;protected&lt;/code&gt; ， &lt;code&gt;public&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 之一的属性。在&lt;a href=&quot;http://wiki.dlang.org/DIP22&quot;&gt;DIP22&lt;/a&gt;之前的文档中，它们可能被称为保护属性。</target>
        </trans-unit>
        <trans-unit id="6c05960b386f26ee3e915fac197d378f3ebcb6a8" translate="yes" xml:space="preserve">
          <source>Visibility participates in &lt;a href=&quot;module#name_lookup&quot;&gt;symbol name lookup&lt;/a&gt;.</source>
          <target state="translated">可见性参与&lt;a href=&quot;module#name_lookup&quot;&gt;符号名称查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c92fbe0bbb759a09c0faa29208bb88b78b9b6f8" translate="yes" xml:space="preserve">
          <source>Visit each overloaded function/template in turn, and call dg(s) on it. Exit when no more, or dg(s) returns nonzero.</source>
          <target state="translated">依次访问每个重载函数/模板,并调用 dg(s)。当不再调用或 dg(s)返回非零时退出。</target>
        </trans-unit>
        <trans-unit id="095d4e1da0ccccf0f23cb7d7417321dea1d13b5b" translate="yes" xml:space="preserve">
          <source>Visitor &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">访客 &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed75e8e2064c0cf00a947caba1ce28a6fe75f18b" translate="yes" xml:space="preserve">
          <source>Visitor that implements the AST traversal logic. The nodes just accept their children.</source>
          <target state="translated">实现AST遍历逻辑的访问者。节点只是接受它们的子节点。</target>
        </trans-unit>
        <trans-unit id="15fa187dd92efb368750787f933eb6c9f5cdd9fe" translate="yes" xml:space="preserve">
          <source>Visits this AST node using the given visitor.</source>
          <target state="translated">使用给定的访问者访问这个AST节点。</target>
        </trans-unit>
        <trans-unit id="7e76fe40efd36819ad4216cae6d472d259442ebf" translate="yes" xml:space="preserve">
          <source>Void Arrays</source>
          <target state="translated">虚数组</target>
        </trans-unit>
        <trans-unit id="a3b9953f805ebbaefa9422b2c296b873ff21f42c" translate="yes" xml:space="preserve">
          <source>Void Initialization</source>
          <target state="translated">虚空初始化</target>
        </trans-unit>
        <trans-unit id="bf3edd1e4d2a01f42d21c6548696eea61602c39b" translate="yes" xml:space="preserve">
          <source>Void Initializations</source>
          <target state="translated">虚空初始化</target>
        </trans-unit>
        <trans-unit id="ccfd4941fe26581cb178fed9382832c4cba184df" translate="yes" xml:space="preserve">
          <source>Void arrays can also be static if their length is known at compile-time. The length is specified in bytes:</source>
          <target state="translated">如果在编译时知道虚数组的长度,那么它也可以是静态的。长度是以字节为单位的。</target>
        </trans-unit>
        <trans-unit id="890c294807ca10112b82fc9f040a92f0216da8fb" translate="yes" xml:space="preserve">
          <source>Void initialization</source>
          <target state="translated">虚空初始化</target>
        </trans-unit>
        <trans-unit id="c4b24fa2258ec7811ee9e879e6eca4832264dcda" translate="yes" xml:space="preserve">
          <source>Void initialization happens when the</source>
          <target state="translated">虚空初始化发生在</target>
        </trans-unit>
        <trans-unit id="fb784fd125a647101103d95f3587d3eb4a57ab75" translate="yes" xml:space="preserve">
          <source>Void initializers are useful when a static array is on the stack, but may only be partially used, such as as a temporary buffer. Void initializers will potentially speed up the code, but they introduce risk, since one must ensure that array elements are always set before read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab1e006db65f1026fe412d6860f8f97f169e1e3" translate="yes" xml:space="preserve">
          <source>Void initializers are useful when a static array is on the stack, but may only be partially used, such as as a temporary buffer. Void initializers will speed up the code, but of course one must be careful that array elements are actually set before read.</source>
          <target state="translated">当静态数组在堆栈上,但可能只被部分使用时,比如作为临时缓冲区,虚空初始化器就很有用。Void初始化器会加快代码的速度,当然必须注意数组元素在读取前是否真的被设置。</target>
        </trans-unit>
        <trans-unit id="85711bbab02376ea3639e90420334b39d180e7f3" translate="yes" xml:space="preserve">
          <source>Vowel_Jamo</source>
          <target state="translated">Vowel_Jamo</target>
        </trans-unit>
        <trans-unit id="cc18367ee9ae48793537b626dc7c6035a5dae6ff" translate="yes" xml:space="preserve">
          <source>W &lt;code&gt;sink&lt;/code&gt;</source>
          <target state="translated">W &lt;code&gt;sink&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e10e55ca871f7800c8635fe6f5905c30390e16a5" translate="yes" xml:space="preserve">
          <source>W &lt;code&gt;writer&lt;/code&gt;</source>
          <target state="translated">W &lt;code&gt;writer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="976cfcd0da2fb30c19ae7f1f66adbb80b2336434" translate="yes" xml:space="preserve">
          <source>WANTvalue, WANTexpand, or both</source>
          <target state="translated">WANTvalue,WANTexpand,或两者都有。</target>
        </trans-unit>
        <trans-unit id="ec14f016fb7dffb13f20a17258a5682225f1c0e0" translate="yes" xml:space="preserve">
          <source>WARNING: The definition and usefulness of property functions is being reviewed, and the implementation is currently incomplete. Using property functions is not recommended until the definition is more certain and implementation more mature.</source>
          <target state="translated">警告:属性函数的定义和有用性正在被审查,目前的实现还不完整。在定义更加确定和实施更加成熟之前,不建议使用属性函数。</target>
        </trans-unit>
        <trans-unit id="b3bc723275b7f5ad79fcec381f0cb5efbff0d10d" translate="yes" xml:space="preserve">
          <source>WARNING: The postblit is considered legacy and is not recommended for new code. Code should use &lt;a href=&quot;#struct-copy-constructor&quot;&gt;copy constructors&lt;/a&gt; defined in the previous section. For backward compatibility reasons, a &lt;code&gt;struct&lt;/code&gt; that explicitly defines both a copy constructor and a postblit will only use the postblit for implicit copying. However, if the postblit is disabled, the copy constructor will be used. If a struct defines a copy constructor and has fields that define postblits, the user-defined copy constructor will have priority over the generated postblit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1993a9a26ed4c6cb9fdc78f41ef76eb1b8bc19b" translate="yes" xml:space="preserve">
          <source>WARNING: The postblit is considered legacy and is not recommended for new code. Code should use copy constructors defined in the previous section. For backward compatibility reasons, a &lt;code&gt;struct&lt;/code&gt; that defines both a copy constructor and a postblit will only use the postblit for implicit copying.</source>
          <target state="translated">警告：postblit被认为是旧的，不建议用于新代码。代码应使用上一节中定义的副本构造函数。为了向后兼容的原因， &lt;code&gt;struct&lt;/code&gt; 同时限定了拷贝构造函数和postblit将只使用隐式复印postblit。</target>
        </trans-unit>
        <trans-unit id="453d0dbab57f60df1e38422e14ddfb0ffca9751d" translate="yes" xml:space="preserve">
          <source>WASI C runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7856604c77c8c3b6db3dda073e819dddc48459eb" translate="yes" xml:space="preserve">
          <source>Wait for a socket to change status. A wait timeout of &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;TimeVal&lt;/code&gt;, may be specified; if a timeout is not specified or the &lt;code&gt;TimeVal&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the maximum timeout is used. The &lt;code&gt;TimeVal&lt;/code&gt; timeout has an unspecified value when &lt;code&gt;select&lt;/code&gt; returns.</source>
          <target state="translated">等待套接字更改状态。可以指定&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;TimeVal&lt;/code&gt; 的等待超时。如果未指定超时或 &lt;code&gt;TimeVal&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则使用最大超时。 &lt;code&gt;select&lt;/code&gt; 返回时， &lt;code&gt;TimeVal&lt;/code&gt; 超时具有未指定的值。</target>
        </trans-unit>
        <trans-unit id="77899536f331c4ec4bcbefe715f29e2da5bd4c54" translate="yes" xml:space="preserve">
          <source>Wait for a thread created with &lt;code&gt;createLowLevelThread&lt;/code&gt; to terminate.</source>
          <target state="translated">等待使用 &lt;code&gt;createLowLevelThread&lt;/code&gt; 创建的线程终止。</target>
        </trans-unit>
        <trans-unit id="ca457eefc1faa13be00867e50d6b627144102aaa" translate="yes" xml:space="preserve">
          <source>Wait for the event to be signaled with timeout.</source>
          <target state="translated">等待事件的超时信号。</target>
        </trans-unit>
        <trans-unit id="e54a6d62ec10ad64fad6d34ac9c7ea9e8f9d7cea" translate="yes" xml:space="preserve">
          <source>Wait for the event to be signaled without timeout.</source>
          <target state="translated">等待事件发出信号而不超时。</target>
        </trans-unit>
        <trans-unit id="2cb051846fa7c334adbe5b29a289c76659c70128" translate="yes" xml:space="preserve">
          <source>Wait for the pre-determined number of threads and then proceed.</source>
          <target state="translated">等待预设的线程数后再进行。</target>
        </trans-unit>
        <trans-unit id="d0970419de06465ae0edf094213021ffbd86ca8c" translate="yes" xml:space="preserve">
          <source>Wait until notified.</source>
          <target state="translated">等到通知。</target>
        </trans-unit>
        <trans-unit id="0dc5e5e58f190ca8a04c28a46a3ca3a88bd55e67" translate="yes" xml:space="preserve">
          <source>Wait until room is available.</source>
          <target state="translated">等到有房间的时候。</target>
        </trans-unit>
        <trans-unit id="1c463167f46a716a5b14ee22c6f2d6eefacb99a6" translate="yes" xml:space="preserve">
          <source>Wait until the current count is above zero, then atomically decrement the count by one and return.</source>
          <target state="translated">等到当前计数高于零,然后原子式地将计数减一并返回。</target>
        </trans-unit>
        <trans-unit id="80514bbd12242072fb7f4a1d006a0f9678d1c1b9" translate="yes" xml:space="preserve">
          <source>Waits for the process associated with &lt;code&gt;pid&lt;/code&gt; to terminate, and returns its exit status.</source>
          <target state="translated">等待与 &lt;code&gt;pid&lt;/code&gt; 关联的进程终止，并返回其退出状态。</target>
        </trans-unit>
        <trans-unit id="55b3defee5849fc459ec0c95440a420189307957" translate="yes" xml:space="preserve">
          <source>Waits for this thread to complete. If the thread terminated as the result of an unhandled exception, this exception will be rethrown.</source>
          <target state="translated">等待这个线程完成。如果线程因未处理的异常而终止,这个异常将被重抛。</target>
        </trans-unit>
        <trans-unit id="12fa1e2dd996c047a58f9ba7d2ce330199936585" translate="yes" xml:space="preserve">
          <source>Walter Bright</source>
          <target state="translated">沃尔特-布莱特</target>
        </trans-unit>
        <trans-unit id="f522c8536ffcd82af51edfc249659512df045ba6" translate="yes" xml:space="preserve">
          <source>Walter Bright, &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;http://www.digitalmars.com&lt;/a&gt;</source>
          <target state="translated">Walter Bright，&lt;a href=&quot;http://www.digitalmars.com&quot;&gt;http：//www.digitalmars.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c7dd627604afd04b6f718c66c366c4eb696346e2" translate="yes" xml:space="preserve">
          <source>Walter Bright, Ernesto Castellotti</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3beee02a56826201b4e6b2b6c654d2bfeca83868" translate="yes" xml:space="preserve">
          <source>Walter Bright, Hauke Duden</source>
          <target state="translated">Walter Bright,Hauke Duden</target>
        </trans-unit>
        <trans-unit id="5c0751740f1c6a65830f87cae86f0d0245266d3a" translate="yes" xml:space="preserve">
          <source>Walter Bright, Kenji Hara</source>
          <target state="translated">Walter Bright,Kenji Hara</target>
        </trans-unit>
        <trans-unit id="e6586c02000f1a5a2c5731c61da55cbfe00bb69e" translate="yes" xml:space="preserve">
          <source>Walter Bright, Martin Nowak</source>
          <target state="translated">Walter Bright,Martin Nowak</target>
        </trans-unit>
        <trans-unit id="f81568c929fce637f8dcc69599de31996dc7e100" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly</source>
          <target state="translated">Walter Bright,Sean Kelly</target>
        </trans-unit>
        <trans-unit id="40965a02688bf098c2a388fb88729085eee06cb1" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, Jeremy DeHaan</source>
          <target state="translated">Walter Bright,Sean Kelly,Jeremy DeHaan</target>
        </trans-unit>
        <trans-unit id="c27d8204a1d5d67ca7d8a6317276e0e520bffe4d" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, Martin Nowak</source>
          <target state="translated">Walter Bright,Sean Kelly,Martin Nowak</target>
        </trans-unit>
        <trans-unit id="3d7a0c203ec613c391f709227322acbb01b99aef" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, Martin Nowak, Jacob Carlborg</source>
          <target state="translated">Walter Bright,Sean Kelly,Martin Nowak,Jacob Carlborg</target>
        </trans-unit>
        <trans-unit id="ff7b964fdcca96888f3d5a37168a6f2f95584013" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, Steven Schveighoffer</source>
          <target state="translated">Walter Bright,Sean Kelly,Steven Schveighoffer</target>
        </trans-unit>
        <trans-unit id="79a2afbbb171f6a4420b36b662391abfa68bfb53" translate="yes" xml:space="preserve">
          <source>Walter Bright, Sean Kelly, the LDC team</source>
          <target state="translated">沃尔特-布赖特、肖恩-凯利、最不发达国家团队。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="585e372432dfe6f0fb6c193474b375e437143f90" translate="yes" xml:space="preserve">
          <source>Warning 1: If the result of &lt;code&gt;toUTFz&lt;/code&gt; equals &lt;code&gt;str.ptr&lt;/code&gt;, then if anything alters the character one past the end of &lt;code&gt;str&lt;/code&gt; (which is the &lt;code&gt;'\0'&lt;/code&gt; character terminating the string), then the string won't be zero-terminated anymore. The most likely scenarios for that are if you append to &lt;code&gt;str&lt;/code&gt; and no reallocation takes place or when &lt;code&gt;str&lt;/code&gt; is a slice of a larger array, and you alter the character in the larger array which is one character past the end of &lt;code&gt;str&lt;/code&gt;. Another case where it could occur would be if you had a mutable character array immediately after &lt;code&gt;str&lt;/code&gt; in memory (for example, if they're member variables in a user-defined type with one declared right after the other) and that character array happened to start with &lt;code&gt;'\0'&lt;/code&gt;. Such scenarios will never occur if you immediately use the zero-terminated string after calling &lt;code&gt;toUTFz&lt;/code&gt; and the C function using it doesn't keep a reference to it. Also, they are unlikely to occur even if you save the zero-terminated string (the cases above would be among the few examples of where it could happen). However, if you save the zero-terminate string and want to be absolutely certain that the string stays zero-terminated, then simply append a &lt;code&gt;'\0'&lt;/code&gt; to the string and use its &lt;code&gt;ptr&lt;/code&gt; property rather than calling &lt;code&gt;toUTFz&lt;/code&gt;.</source>
          <target state="translated">警告1：如果结果 &lt;code&gt;toUTFz&lt;/code&gt; 等于 &lt;code&gt;str.ptr&lt;/code&gt; ，然后如果有任何改变字符一个过去的端 &lt;code&gt;str&lt;/code&gt; （它是 &lt;code&gt;'\0'&lt;/code&gt; 字符终止字符串），则该字符串将不再被零封端的。最可能的情况是，如果您追加到 &lt;code&gt;str&lt;/code&gt; 并且没有重新分配发生，或者当 &lt;code&gt;str&lt;/code&gt; 是较大数组的一个切片，并且您更改了较大数组中的字符，该字符比 &lt;code&gt;str&lt;/code&gt; 末尾多了一个字符。可能发生这种情况的另一种情况是，如果在 &lt;code&gt;str&lt;/code&gt; 之后立即有一个可变字符数组在内存中（例如，如果它们是用户定义类型的成员变量，并且一个在另一个之后声明），则该字符数组恰巧以 &lt;code&gt;'\0'&lt;/code&gt; 开头。如果您在调用 &lt;code&gt;toUTFz&lt;/code&gt; 之后立即使用零结尾的字符串，并且使用它的C函数不保留对它的引用，则这种情况将永远不会发生。而且，即使您保存了零终止的字符串，它们也不大可能发生（上述情况只是少数可能发生此情况的例子）。但是，如果保存以零结尾的字符串，并且要绝对确定该字符串以零结尾，那么只需在字符串后附加一个 &lt;code&gt;'\0'&lt;/code&gt; 并使用其 &lt;code&gt;ptr&lt;/code&gt; 属性，而不要调用 &lt;code&gt;toUTFz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d5e6e458c5bbdf658e7836c9d3ff01a465d3f07" translate="yes" xml:space="preserve">
          <source>Warning 2: When passing a character pointer to a C function, and the C function keeps it around for any reason, make sure that you keep a reference to it in your D code. Otherwise, it may go away during a garbage collection cycle and cause a nasty bug when the C code tries to use it.</source>
          <target state="translated">警告2:当把一个字符指针传递给C函数,而C函数又因为任何原因把它留在身边时,请确保在D代码中保留对它的引用。否则,它可能会在垃圾收集周期中消失,并在C代码试图使用它时引起一个讨厌的错误。</target>
        </trans-unit>
        <trans-unit id="6223e4ea5d5725d8274391390c04b8667ffc6c34" translate="yes" xml:space="preserve">
          <source>Warning: All unmapped bits in the final word will be set to 0.</source>
          <target state="translated">警告:最后一个字中所有未映射的位将被设置为0。最后一个字中所有未映射的位将被设置为0。</target>
        </trans-unit>
        <trans-unit id="acf91dcbe1badc99fc7381d39957a80e6a341170" translate="yes" xml:space="preserve">
          <source>Warning: Because &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is in hnsecs, whereas MonoTime is in system ticks, it's usually the case that this assertion will fail</source>
          <target state="translated">警告：由于&lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;以hnsecs为单位，而MonoTime以系统滴答为单位，因此通常这种断言将失败</target>
        </trans-unit>
        <trans-unit id="27438780936e1340ac95e5da97a39dc3fbfd64bc" translate="yes" xml:space="preserve">
          <source>Warning: On some systems, the monotonic clock may stop counting when the computer goes to sleep or hibernates. So, the monotonic clock could be off if that occurs. This is known to happen on Mac OS X. It has not been tested whether it occurs on either Windows or on Linux.</source>
          <target state="translated">警告:最后一个字中所有未映射的位将被设置为0。在某些系统上,单调时钟可能会停止计数 当计算机进入睡眠或休眠状态。因此,如果发生这种情况,单调时钟可能会被关闭。这种情况在Mac OS X上是已知的,但尚未测试它是否会在Windows或Linux上发生。</target>
        </trans-unit>
        <trans-unit id="0e212f56c9e51d24ac52f320bb7b438cdfb95478" translate="yes" xml:space="preserve">
          <source>Warning: On some systems, the monotonic clock may stop counting when the computer goes to sleep or hibernates. So, the monotonic clock may indicate less time than has actually passed if that occurs. This is known to happen on Mac OS X. It has not been tested whether it occurs on either Windows or Linux.</source>
          <target state="translated">警告:最后一个字中所有未映射的位将被设置为0。在某些系统上,单调时钟可能会停止计数 当计算机进入睡眠或休眠状态。因此,如果发生这种情况,单调时钟可能会显示比实际经过的时间更少。这种情况在Mac OS X上是已知的,但尚未测试它是否会在Windows或Linux上发生。</target>
        </trans-unit>
        <trans-unit id="e46400427309b3b37f40efb471c7ac358834f3c4" translate="yes" xml:space="preserve">
          <source>Warning: Previously, &lt;a href=&quot;#toISOString&quot;&gt;&lt;code&gt;toISOString&lt;/code&gt;&lt;/a&gt; did the same as &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; and generated +HH:MM or -HH:MM for the time zone when it was not &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, which is not in conformance with ISO 8601 for the non-extended string format. This has now been fixed. However, for now, fromISOString will continue to accept the extended format for the time zone so that any code which has been writing out the result of toISOString to read in later will continue to work. The current behavior will be kept until July 2019 at which point, fromISOString will be fixed to be standards compliant.</source>
          <target state="translated">警告：此前，&lt;a href=&quot;#toISOString&quot;&gt; &lt;code&gt;toISOString&lt;/code&gt; &lt;/a&gt;也做了同样的&lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; &lt;/a&gt;和生成+ HH：MM或-HH：MM的时区时，它不是&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt;，这是不符合中对于非扩展字符串格式，使用ISO 8601。现在，此问题已得到解决。但是，目前，fromISOString将继续接受该时区的扩展格式，以便任何已写出toISOString结果供以后读取的代码将继续工作。当前行为将一直保留到2019年7月，届时fromISOString将被固定为符合标准。</target>
        </trans-unit>
        <trans-unit id="d2fc166d407d5b89388cb65f2fea3db607a53956" translate="yes" xml:space="preserve">
          <source>Warning: Previously, toISOString did the same as &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; and generated +HH:MM or -HH:MM for the time zone when it was not &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, which is not in conformance with ISO 8601 for the non-extended string format. This has now been fixed. However, for now, fromISOString will continue to accept the extended format for the time zone so that any code which has been writing out the result of toISOString to read in later will continue to work. The current behavior will be kept until July 2019 at which point, fromISOString will be fixed to be standards compliant.</source>
          <target state="translated">警告：此前，toISOString也做了同样的&lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; &lt;/a&gt;和生成+ HH：MM或-HH：MM的时区时，它不是&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt;，这是不符合中对于非扩展字符串格式，使用ISO 8601。现在，此问题已得到解决。但是，目前，fromISOString将继续接受该时区的扩展格式，以便任何已写出toISOString结果供以后读取的代码将继续工作。当前行为将一直保留到2019年7月，届时fromISOString将被固定为符合标准。</target>
        </trans-unit>
        <trans-unit id="fabcf756ccd01219ec37d730936c5b0173ea6da7" translate="yes" xml:space="preserve">
          <source>Warning: This field will be turned into a property in a future release.</source>
          <target state="translated">警告:最后一个字中所有未映射的位将被设置为0。这个字段在未来的版本中会变成一个属性。</target>
        </trans-unit>
        <trans-unit id="c8c3b8d8de62f29d31349b08905db4c48193bfc9" translate="yes" xml:space="preserve">
          <source>Warning: This module is considered out-dated and not up to Phobos' current standards. It will be removed from Phobos in 2.101.0. If you still need it, go to &lt;a href=&quot;https://github.com/DigitalMars/undeaD&quot;&gt;https://github.com/DigitalMars/undeaD&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c031ade7f7344cefefb6b6bd54f1bb3fa16257" translate="yes" xml:space="preserve">
          <source>Warning: This module is considered out-dated and not up to Phobos' current standards. It will remain until we have a suitable replacement, but be aware that it will not remain long term.</source>
          <target state="translated">警告:最后一个字中所有未映射的位将被设置为0。这个模块被认为是过时的,不符合Phobos的现行标准。在我们找到合适的替代品之前,该模块将一直保留,但请注意,它不会长期保留。</target>
        </trans-unit>
        <trans-unit id="92f5ff341e2b5afa18006c51adebb14319bc5d53" translate="yes" xml:space="preserve">
          <source>Warning: This trait will be deprecated as soon as it is no longer used in Phobos. For a function parameter to safely accept a type that implicitly converts to string as a string, the conversion needs to happen at the callsite; otherwise, the conversion is done inside the function, and in many cases, that means that local memory is sliced (e.g. if a static array is passed to the function, then it's copied, and the resulting dynamic array will be a slice of a local variable). So, if the resulting string escapes the function, the string refers to invalid memory, and accessing it would mean accessing invalid memory. As such, the only safe way for a function to accept types that implicitly convert to string is for the implicit conversion to be done at the callsite, and that can only occur if the parameter is explicitly typed as an array, whereas using isConvertibleToString in a template constraint would result in the conversion being done inside the function. As such, isConvertibleToString is inherently unsafe and is going to be deprecated.</source>
          <target state="translated">警告:最后一个字中所有未映射的位将被设置为0。一旦Phobos中不再使用这个特性,它就会被废弃。要想让一个函数参数安全地接受一个隐式转换为字符串的类型作为字符串,转换需要在调用点发生,否则,转换是在函数内部进行的,在很多情况下,这意味着本地内存被分片(例如,如果一个静态数组被传递给函数,那么它被复制,产生的动态数组将是一个本地变量的分片)。所以,如果产生的字符串逃出了函数,那么这个字符串指的是无效的内存,访问它就意味着访问无效的内存。因此,函数接受隐式转换为字符串的类型的唯一安全方式是在调用端进行隐式转换,而这只有在参数被显式类型为数组的情况下才能发生,而在模板约束中使用isConvertibleToString会导致转换在函数内部进行。因此,isConvertibleToString本质上是不安全的,将被废弃。</target>
        </trans-unit>
        <trans-unit id="83b7f7c160db15d481480fd952b8bc681419f483" translate="yes" xml:space="preserve">
          <source>Warning: TickDuration will be deprecated in the near future (once all uses of it in Phobos have been deprecated). Please use &lt;a href=&quot;#MonoTime&quot;&gt;&lt;code&gt;MonoTime&lt;/code&gt;&lt;/a&gt; for the cases where a monotonic timestamp is needed and &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; when a duration is needed, rather than using TickDuration. It has been decided that TickDuration is too confusing (e.g. it conflates a monotonic timestamp and a duration in monotonic clock ticks) and that having multiple duration types is too awkward and confusing.</source>
          <target state="translated">警告：TickDuration将在不久的将来被弃用（一旦在Phobos中所有使用都被弃用）。对于需要单调时间戳的情况，请使用&lt;a href=&quot;#MonoTime&quot;&gt; &lt;code&gt;MonoTime&lt;/code&gt; &lt;/a&gt;；在需要&lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;的情况下，请使用&amp;ldquo; 持续时间&amp;rdquo;，而不要使用TickDuration。已经确定TickDuration太混乱了（例如，它使单调时间戳和一个单调时钟滴答的持续时间混为一谈），并且具有多个持续时间类型太笨拙且令人困惑。</target>
        </trans-unit>
        <trans-unit id="62b3979c53ffb9c47b3a7d545b258a9878ad87de" translate="yes" xml:space="preserve">
          <source>Warning: Using critical regions is extremely error-prone. For instance, using locks inside a critical region can easily result in a deadlock when another thread holding the lock already got suspended.</source>
          <target state="translated">警告:最后一个字中所有未映射的位将被设置为0。使用临界区域是非常容易出错的。例如,在关键区域内使用锁很容易导致死锁,而另一个持有锁的线程已经被暂停。</target>
        </trans-unit>
        <trans-unit id="8f4c2b9f3e530a0a68edf252b1a344d7f8161a1d" translate="yes" xml:space="preserve">
          <source>Warning: unused bits in the final word up to the next word boundary may be overwritten by this operation. It does not attempt to preserve bits past the end of the array.</source>
          <target state="translated">警告:最后一个字到下一个字边界的未使用的位可能会被这个操作覆盖。它不试图保留过了数组末端的位。</target>
        </trans-unit>
        <trans-unit id="9bdfd3329c5bbf822175cb2b67912d964b37f972" translate="yes" xml:space="preserve">
          <source>We can overload templates.</source>
          <target state="translated">我们可以过载模板。</target>
        </trans-unit>
        <trans-unit id="c6fdca2f98040562a3c5fb4c490c84d24c94cc09" translate="yes" xml:space="preserve">
          <source>We can use it in D code like:</source>
          <target state="translated">我们可以在D代码中使用它,比如。</target>
        </trans-unit>
        <trans-unit id="507a3193c54b60247851a8ffa82864ffaffde25f" translate="yes" xml:space="preserve">
          <source>We need an opEquals for the struct if any fields has an opEquals. Generate one if a user-specified one does not exist.</source>
          <target state="translated">如果有任何字段有opEquals,我们需要为结构体提供一个opEquals。如果用户指定的opEquals不存在,则生成一个opEquals。</target>
        </trans-unit>
        <trans-unit id="68a72706eafc8d622298e3cdab30cee1fd24b9ba" translate="yes" xml:space="preserve">
          <source>We want the referrer field set automatically when following locations</source>
          <target state="translated">我们希望在以下地点时自动设置推荐人字段。</target>
        </trans-unit>
        <trans-unit id="5fbe925d225346411e9eccfc0b0f243297559267" translate="yes" xml:space="preserve">
          <source>We've mistakenly parsed &lt;code&gt;t&lt;/code&gt; as a type. Redo &lt;code&gt;t&lt;/code&gt; as an Expression.</source>
          <target state="translated">我们错误地将 &lt;code&gt;t&lt;/code&gt; 解析为类型。重做 &lt;code&gt;t&lt;/code&gt; 作为表达。</target>
        </trans-unit>
        <trans-unit id="845a99ed43b833e3f82d48703e30eb33f04bdd81" translate="yes" xml:space="preserve">
          <source>WeightsAA &lt;code&gt;weights&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; AA 重量</target>
        </trans-unit>
        <trans-unit id="cd3b500c5e4673ad9015a24bd46e94c7a25f4665" translate="yes" xml:space="preserve">
          <source>What happens for &lt;code&gt;pragma(inline, true)&lt;/code&gt; if the function cannot be inlined. An error message is typical.</source>
          <target state="translated">如果无法内联函数，则对 &lt;code&gt;pragma(inline, true)&lt;/code&gt; 会发生什么。错误消息是典型的。</target>
        </trans-unit>
        <trans-unit id="adfcea932d1629853978a1cd226d5f3e53520b78" translate="yes" xml:space="preserve">
          <source>What kind of HTTP time condition to use, see defines</source>
          <target state="translated">使用什么样的HTTP时间条件,见定义</target>
        </trans-unit>
        <trans-unit id="3eac45872ea1813c0c59c59b8e57b1a3dfaff419" translate="yes" xml:space="preserve">
          <source>What mutex is used is determined by the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;. If there is no &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, then a global mutex is created, one per such synchronized statement. Different synchronized statements will have different global mutexes.</source>
          <target state="translated">使用哪种互斥锁由&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;确定。如果没有&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;，则创建一个全局互斥锁，每个此类同步语句一个。不同的同步语句将具有不同的全局互斥量。</target>
        </trans-unit>
        <trans-unit id="3f00b0af3261ac469a497340912e30c3d784a1b3" translate="yes" xml:space="preserve">
          <source>What policy to use when closing connections when the cache is filled up</source>
          <target state="translated">当缓存被填满时,关闭连接时使用什么策略?</target>
        </trans-unit>
        <trans-unit id="a4ada23f9c4b1b5915da333f74d0432936b14fb5" translate="yes" xml:space="preserve">
          <source>What the string is expected for, will be used in error diagnostic.</source>
          <target state="translated">字符串的预期是什么,将用于错误诊断。</target>
        </trans-unit>
        <trans-unit id="207bb42cfbbad5b0c396c2caf20bfb81dbfce9b3" translate="yes" xml:space="preserve">
          <source>What to look for.</source>
          <target state="translated">要注意什么?</target>
        </trans-unit>
        <trans-unit id="6d65d283ddb2c53ef74d1eb3c0dd6bc21ff402bf" translate="yes" xml:space="preserve">
          <source>What type of clock to use with &lt;a href=&quot;#MonoTime&quot;&gt;&lt;code&gt;MonoTime&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;. They default to &lt;code&gt;ClockType.normal&lt;/code&gt;, and most programs do not need to ever deal with the others.</source>
          <target state="translated">&lt;a href=&quot;#MonoTime&quot;&gt; &lt;code&gt;MonoTime&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; 使用哪种类型的时钟。它们默认为 &lt;code&gt;ClockType.normal&lt;/code&gt; ，并且大多数程序不需要与其他程序打交道。</target>
        </trans-unit>
        <trans-unit id="146794bc552470dd1d6678ea93d3425d7b4f29e6" translate="yes" xml:space="preserve">
          <source>What values do a and b end up with, what order are the initializations executed in, what are the values of a and b before the initializations are run, is this a compile error, or is this a runtime error? Additional confusion comes from it not being obvious if an initializer is static or dynamic.</source>
          <target state="translated">a和b最后的值是什么,初始化的执行顺序是什么,初始化运行前a和b的值是什么,这是编译错误,还是运行时错误?额外的困惑来自于不清楚初始化器是静态的还是动态的。</target>
        </trans-unit>
        <trans-unit id="6b972ab83e5e7a76cfe2df1f21ebf933dc879011" translate="yes" xml:space="preserve">
          <source>What version to specifically try to use. See CURL_SSLVERSION defines below.</source>
          <target state="translated">具体尝试使用什么版本。请看下面CURL_SSLVERSION的定义。</target>
        </trans-unit>
        <trans-unit id="a1b7a5c6bdddfaa0a24b075c10b5835662fd0054" translate="yes" xml:space="preserve">
          <source>What's needed is an error handling philosophy and methodology such that:</source>
          <target state="translated">需要的是一种错误处理的理念和方法,这样:</target>
        </trans-unit>
        <trans-unit id="cfd1d82cce4f72aa99573e2ce4e60cfaf40ec308" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;BetterC&lt;/b&gt; is enabled, the predefined &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt;&lt;code&gt;D_BetterC&lt;/code&gt; can be used for conditional compilation.</source>
          <target state="translated">当&lt;b&gt;BetterC&lt;/b&gt;启用，预定义的&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt; &lt;code&gt;D_BetterC&lt;/code&gt; 可用于条件编译。</target>
        </trans-unit>
        <trans-unit id="2292b06867d16283b44aae130a4f39b2ac042759" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; type, &lt;code&gt;Final&lt;/code&gt; aliases to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;T&lt;/code&gt; 是一个 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;immutable&lt;/code&gt; 类型， &lt;code&gt;Final&lt;/code&gt; 别名 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a49d575ee1d6e7e4bcca9be6bbf7c0477c415fa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;startingIndex&lt;/code&gt; is 0 the range will be fully iterated in order and in reverse order when &lt;code&gt;r.length&lt;/code&gt; is given.</source>
          <target state="translated">当 &lt;code&gt;startingIndex&lt;/code&gt; 为0时，给定 &lt;code&gt;r.length&lt;/code&gt; 时，范围将完全按顺序进行迭代，并以相反的顺序进行迭代。</target>
        </trans-unit>
        <trans-unit id="5faf3ff2b29b975f2e5f9514d9470cfbe9751be7" translate="yes" xml:space="preserve">
          <source>When AA access requires that there must be a value corresponding to the key, a value must be constructed and inserted if not present. The &lt;code&gt;require&lt;/code&gt; function provides a means to construct a new value via a lazy argument. The lazy argument is evaluated when the key is not present. The &lt;code&gt;require&lt;/code&gt; operation avoids the need to perform multiple key lookups.</source>
          <target state="translated">当AA访问要求必须有一个对应于密钥的值时，必须构造一个值并将其插入（如果不存在）。的 &lt;code&gt;require&lt;/code&gt; 功能提供了一种手段通过一懒惰参数来构造一个新的值。当密钥不存在时，将评估惰性参数。该 &lt;code&gt;require&lt;/code&gt; 操作，避免执行多个键查找的需要。</target>
        </trans-unit>
        <trans-unit id="58756d267efe5c990a7cc915f22119bb4ae5363b" translate="yes" xml:space="preserve">
          <source>When FTP over SSL/TLS is selected (with CURLOPT_USE_SSL), this option can be used to change libcurl's default action which is to first try &quot;AUTH SSL&quot; and then &quot;AUTH TLS&quot; in this order, and proceed when a OK response has been received.</source>
          <target state="translated">当选择了FTP over SSL/TLS时(使用CURLOPT_USE_SSL),这个选项可以用来改变libcurl的默认操作,即先尝试 &quot;AUTH SSL&quot;,然后按照这个顺序尝试 &quot;AUTH TLS&quot;,当收到OK响应时再继续。</target>
        </trans-unit>
        <trans-unit id="d4a7db22a0550dc78b003dc93c9145ff60875535" translate="yes" xml:space="preserve">
          <source>When T is mutable,</source>
          <target state="translated">当T是可以突变的。</target>
        </trans-unit>
        <trans-unit id="5cf006f44400e65144d1b472f0ab8012be1c48f8" translate="yes" xml:space="preserve">
          <source>When UFCS rewrite is necessary, compiler searches the name on accessible module level scope, in order from the innermost scope.</source>
          <target state="translated">当需要对UFCS进行重写时,编译器会在可访问的模块级作用域中从最里面的作用域开始依次搜索名称。</target>
        </trans-unit>
        <trans-unit id="a7f07e7fd86974cfaed2565e4135da3e593e6283" translate="yes" xml:space="preserve">
          <source>When UUIDs are generated by one of the defined mechanisms, they are either guaranteed to be unique, different from all other generated UUIDs (that is, it has never been generated before and it will never be generated again), or it is extremely likely to be unique (depending on the mechanism).</source>
          <target state="translated">当UUID由定义的机制之一生成时,要么保证是唯一的,与所有其他生成的UUID不同(也就是说,它以前从未生成过,以后也不会再生成),要么极有可能是唯一的(取决于机制)。</target>
        </trans-unit>
        <trans-unit id="3eca062b8fe1e4231ecb785a261c5bf72ebd25a3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Task&lt;/code&gt; that calls a delegate is being created and a closure cannot be allocated due to objects on the stack that have scoped destruction. The delegate overload of &lt;code&gt;scopedTask&lt;/code&gt; takes a &lt;code&gt;scope&lt;/code&gt; delegate.</source>
          <target state="translated">当创建调用委托的 &lt;code&gt;Task&lt;/code&gt; 时，由于堆栈上具有范围破坏的对象而无法分配闭包。 &lt;code&gt;scopedTask&lt;/code&gt; 的委托重载采用 &lt;code&gt;scope&lt;/code&gt; 委托。</target>
        </trans-unit>
        <trans-unit id="b00afb911afc0a5ca26386b2a18ae6be85c2975e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Unique!T&lt;/code&gt; goes out of scope it will call &lt;code&gt;destroy&lt;/code&gt; on the resource &lt;code&gt;T&lt;/code&gt; that it manages, unless it is transferred. One important consequence of &lt;code&gt;destroy&lt;/code&gt; is that it will call the destructor of the resource &lt;code&gt;T&lt;/code&gt;. GC-managed references are not guaranteed to be valid during a destructor call, but other members of &lt;code&gt;T&lt;/code&gt;, such as file handles or pointers to &lt;code&gt;malloc&lt;/code&gt; memory, will still be valid during the destructor call. This allows the resource &lt;code&gt;T&lt;/code&gt; to deallocate or clean up any non-GC resources.</source>
          <target state="translated">当 &lt;code&gt;Unique!T&lt;/code&gt; 超出范围时，它将调用它管理的资源 &lt;code&gt;T&lt;/code&gt; 上的 &lt;code&gt;destroy&lt;/code&gt; ，除非将其转移。 &lt;code&gt;destroy&lt;/code&gt; 一个重要后果是它将调用资源 &lt;code&gt;T&lt;/code&gt; 的析构函数。 GC管理的引用不能保证在析构函数调用期间有效，但是 &lt;code&gt;T&lt;/code&gt; 的其他成员（例如文件句柄或指向 &lt;code&gt;malloc&lt;/code&gt; 内存的指针）在析构函数调用期间仍然有效。这允许资源 &lt;code&gt;T&lt;/code&gt; 取消分配或清除任何非GC资源。</target>
        </trans-unit>
        <trans-unit id="0b428ff9c922783f16405281044cf416efd51e62" translate="yes" xml:space="preserve">
          <source>When a chunk of memory is requested, the allocator finds a range of virtual pages that satisfy the requested size, changing their protection to read/write using OS primitives (&lt;code&gt;mprotect&lt;/code&gt; and &lt;code&gt;VirtualProtect&lt;/code&gt;, respectively). The physical memory is allocated on demand, when the pages are accessed.</source>
          <target state="translated">当请求一块内存时，分配器会找到一定范围的虚拟页，这些虚拟页可以满足所请求的大小，并将其保护更改为使用OS原语（分别为 &lt;code&gt;mprotect&lt;/code&gt; 和 &lt;code&gt;VirtualProtect&lt;/code&gt; ）进行读取/写入。访问页面时，将按需分配物理内存。</target>
        </trans-unit>
        <trans-unit id="84377709681ba4d9986310ee001bee93cd56cf23" translate="yes" xml:space="preserve">
          <source>When a copy constructor is defined for a &lt;code&gt;struct&lt;/code&gt; (or marked &lt;code&gt;@disable&lt;/code&gt;), the compiler no longer implicitly generates default copy/blitting constructors for that &lt;code&gt;struct&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58597b4b6cb332bd69f504c1f00c607c0eb16bbc" translate="yes" xml:space="preserve">
          <source>When a copy constructor is defined for a &lt;code&gt;struct&lt;/code&gt;, all implicit blitting is disabled for that &lt;code&gt;struct&lt;/code&gt;:</source>
          <target state="translated">当一个拷贝构造函数是一个定义 &lt;code&gt;struct&lt;/code&gt; ，所有隐式的blitting为残疾 &lt;code&gt;struct&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a331d1a65f7b110b5273b5d7868371d3b08b9ac" translate="yes" xml:space="preserve">
          <source>When a header is provided but a matching column is not found</source>
          <target state="translated">当提供了一个页眉,但没有找到匹配的列时。</target>
        </trans-unit>
        <trans-unit id="b0b45f354df73daafacbfa28c4412f42f9090d16" translate="yes" xml:space="preserve">
          <source>When a non-static nested class is instantiated, the context pointer is assigned before the class's constructor is called, therefore the constructor has full access to the enclosing variables. A non-static nested class can only be instantiated when the necessary context pointer information is available:</source>
          <target state="translated">当一个非静态嵌套类被实例化时,上下文指针是在类的构造函数被调用之前分配的,因此构造函数可以完全访问包围变量。只有在获得必要的上下文指针信息时,才能实例化一个非静态嵌套类。</target>
        </trans-unit>
        <trans-unit id="ef920e26f90cd5a47576ce324fd1771288bcca86" translate="yes" xml:space="preserve">
          <source>When a parameter is passed by value to a function:</source>
          <target state="translated">当一个参数通过值传递给一个函数时。</target>
        </trans-unit>
        <trans-unit id="c61c979210ecf2e4589b54627f634e1037a8ddad" translate="yes" xml:space="preserve">
          <source>When a parameter is returned by value from a function and Named Returned Value Optiomization (NRVO) cannot be performed:</source>
          <target state="translated">当参数由函数的值返回时,不能执行命名返回值 Optiomization(NRVO)。</target>
        </trans-unit>
        <trans-unit id="bad8777ba790b6e52988c8133c63b2e65339ddbd" translate="yes" xml:space="preserve">
          <source>When a pointer to</source>
          <target state="translated">当指向</target>
        </trans-unit>
        <trans-unit id="1e0b2ba65ca51f0167b76facd54366bc0400933e" translate="yes" xml:space="preserve">
          <source>When a scope class reference goes out of scope, the destructor (if any) for it is automatically called. This holds true even if the scope was exited via a thrown exception.</source>
          <target state="translated">当一个 scope 类引用退出 scope 时,它的析构器(如果有的话)会被自动调用。即使通过抛出的异常退出了作用域,这也是正确的。</target>
        </trans-unit>
        <trans-unit id="b6bb469f2736e5b29050178fdbb45f42be341bd3" translate="yes" xml:space="preserve">
          <source>When a socket is blocking, calls to receive(), accept(), and send() will block and wait for data/action. A non-blocking socket will immediately return instead of blocking.</source>
          <target state="translated">当套接字阻塞时,对receive()、accept()和send()的调用将阻塞并等待数据/动作。一个非阻塞的套接字将立即返回而不是阻塞。</target>
        </trans-unit>
        <trans-unit id="5af91437874803519acee62d5c577c0e8cbfe57c" translate="yes" xml:space="preserve">
          <source>When a symbol name is used unqualified, a two-phase lookup is used. First, the module scope is searched, starting from the innermost scope. For example, in the previous example, while looking for &lt;code&gt;writeln&lt;/code&gt;, the order will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53589a36e302415933b16ff556ec6d4fa213d853" translate="yes" xml:space="preserve">
          <source>When a symbol name is used unqualified, a two-phase lookup will happen. First, the module scope will be searched, starting from the innermost scope. For example, in the previous example, while looking for &lt;code&gt;writeln&lt;/code&gt;, the order will be:</source>
          <target state="translated">当符号名称使用不合格时，将进行两阶段查找。首先，将从最内部的范围开始搜索模块范围。例如，在前面的示例中，在查找 &lt;code&gt;writeln&lt;/code&gt; 时，顺序为：</target>
        </trans-unit>
        <trans-unit id="25a09fb47990dfe5a4bac049451c12fdc1522cc8" translate="yes" xml:space="preserve">
          <source>When a variable is explicitly initialized:</source>
          <target state="translated">当一个变量被显式初始化时。</target>
        </trans-unit>
        <trans-unit id="e356d7a1b95eac6faf7fe7ab10b40256f67e5d27" translate="yes" xml:space="preserve">
          <source>When an AA indexing access appears on the left side of an assignment operator, it is specially handled for setting an AA entry associated with the key.</source>
          <target state="translated">当赋值运算符左侧出现AA索引访问时,会专门处理设置与键相关的AA条目。</target>
        </trans-unit>
        <trans-unit id="847c3c4e979270acfa06a799f042c78559833b79" translate="yes" xml:space="preserve">
          <source>When an input contains a header the &lt;code&gt;Contents&lt;/code&gt; can be specified as an associative array. Passing null to signify that a header is present.</source>
          <target state="translated">当输入包含标题时，可以将 &lt;code&gt;Contents&lt;/code&gt; 指定为关联数组。传递null表示存在标头。</target>
        </trans-unit>
        <trans-unit id="0d733d6c910f9784e16ad4aef1338d80a037f29e" translate="yes" xml:space="preserve">
          <source>When an instance of a struct is created, the following steps happen:</source>
          <target state="translated">当一个结构的实例被创建时,会发生以下步骤。</target>
        </trans-unit>
        <trans-unit id="f9b07f7bbc9886fac959cdee6dc7290b9a45d6c3" translate="yes" xml:space="preserve">
          <source>When an output range's &lt;code&gt;put&lt;/code&gt; method only accepts elements of type &lt;code&gt;T&lt;/code&gt;, use the global &lt;code&gt;put&lt;/code&gt; to handle outputting a &lt;code&gt;T[]&lt;/code&gt; to the range or vice-versa.</source>
          <target state="translated">当输出范围的 &lt;code&gt;put&lt;/code&gt; 方法仅接受类型 &lt;code&gt;T&lt;/code&gt; 的元素时，请使用全局 &lt;code&gt;put&lt;/code&gt; 来处理将 &lt;code&gt;T[]&lt;/code&gt; 输出到范围，反之亦然。</target>
        </trans-unit>
        <trans-unit id="b0d460e664066b93100c6efcc10898f6bcea3cee" translate="yes" xml:space="preserve">
          <source>When any &lt;a href=&quot;std_range&quot;&gt;range&lt;/a&gt; can be passed as an argument to a member function, the documention usually refers to the parameter's templated type as &lt;code&gt;Stuff&lt;/code&gt;.</source>
          <target state="translated">当可以将任何&lt;a href=&quot;std_range&quot;&gt;范围&lt;/a&gt;作为参数传递给成员函数时，文档通常将参数的模板化类型称为 &lt;code&gt;Stuff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e035b70c43ed4b954c78ad9443d2b0b366cee1c" translate="yes" xml:space="preserve">
          <source>When array literals are cast to another array type, each element of the array is cast to the new element type. When arrays that are not literals are cast, the array is reinterpreted as the new type, and the length is recomputed:</source>
          <target state="translated">当数组的字元被投向另一个数组类型时,数组的每个元素都被投向新的元素类型。当数组非字面数组被转换时,数组会被重新解释为新的类型,并重新计算长度。</target>
        </trans-unit>
        <trans-unit id="8bc694b68085959ea8d163c5c30c93a25f539782" translate="yes" xml:space="preserve">
          <source>When called on a &lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt; will unpack the value contained in the &lt;code&gt;Nullable&lt;/code&gt;, pass it to the function you provide and wrap the result in another &lt;code&gt;Nullable&lt;/code&gt; (if necessary). If the &lt;code&gt;Nullable&lt;/code&gt; is null, &lt;code&gt;apply&lt;/code&gt; will return null itself.</source>
          <target state="translated">在对 &lt;code&gt;Nullable&lt;/code&gt; 进行调用时， &lt;code&gt;apply&lt;/code&gt; 将解压缩 &lt;code&gt;Nullable&lt;/code&gt; 中包含的值，将其传递给您提供的函数，并将结果包装在另一个 &lt;code&gt;Nullable&lt;/code&gt; 中（如有必要）。如果 &lt;code&gt;Nullable&lt;/code&gt; 为null，则 &lt;code&gt;apply&lt;/code&gt; 将自身返回null。</target>
        </trans-unit>
        <trans-unit id="dc1515373d01db08ef2117bb4defaff339297545" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;recurrence&lt;/code&gt;, the function that computes the next value is specified as a template argument, and the initial values in the recurrence are passed as regular arguments. For example, in a Fibonacci sequence, there are two initial values (and therefore a state size of 2) because computing the next Fibonacci value needs the past two values.</source>
          <target state="translated">调用 &lt;code&gt;recurrence&lt;/code&gt; ，将计算下一个值的函数指定为模板参数，并将递归中的初始值作为常规参数传递。例如，在斐波那契序列中，有两个初始值（因此状态大小为2），因为计算下一个斐波那契值需要过去的两个值。</target>
        </trans-unit>
        <trans-unit id="18b07986b7a6997aa1e86f263e6c86015fef29b1" translate="yes" xml:space="preserve">
          <source>When comparing with &lt;a href=&quot;function#nested&quot;&gt;nested functions&lt;/a&gt;, the &lt;code&gt;function&lt;/code&gt; form is analogous to static or non-nested functions, and the &lt;code&gt;delegate&lt;/code&gt; form is analogous to non-static nested functions. In other words, a delegate literal can access stack variables in its enclosing function, a function literal cannot.</source>
          <target state="translated">与&lt;a href=&quot;function#nested&quot;&gt;嵌套函数&lt;/a&gt;进行比较时， &lt;code&gt;function&lt;/code&gt; 形式类似于静态或非嵌套函数，而 &lt;code&gt;delegate&lt;/code&gt; 形式类似于非静态嵌套函数。换句话说，委托文字可以访问其封闭函数中的堆栈变量，而函数文字不能。</target>
        </trans-unit>
        <trans-unit id="fd9f348ed0f84700657f1faa1882de97c9d5f215" translate="yes" xml:space="preserve">
          <source>When compiled and run, it will produce the message:</source>
          <target state="translated">编译和运行时,会产生信息。</target>
        </trans-unit>
        <trans-unit id="5c8b8502e98bd1b0e213cd0332618f47d50bedee" translate="yes" xml:space="preserve">
          <source>When compiled with debug mode, this function performs an extra check to make sure the return value is a valid Unicode string.</source>
          <target state="translated">当用调试模式编译时,这个函数会执行一个额外的检查,以确保返回值是一个有效的Unicode字符串。</target>
        </trans-unit>
        <trans-unit id="cd356cab928423e5fd67844fa0607a2ecaf98686" translate="yes" xml:space="preserve">
          <source>When compiling for release, the invariant code is not generated, and the compiled program runs at maximum speed. The compiler is free to assume the invariant holds true, regardless of whether code is generated for it or not, and may optimize code accordingly.</source>
          <target state="translated">在编译发布时,不生成不变式代码,编译后的程序以最大速度运行。编译器可以自由地假设不变式成立,不管是否为其生成代码,都可以相应地优化代码。</target>
        </trans-unit>
        <trans-unit id="f10c0d6014f2fa95b1f233b08b48cbc3b9a32b36" translate="yes" xml:space="preserve">
          <source>When compiling the application remember to link with the required libraries, in this case the Foundation framework. Example:</source>
          <target state="translated">当编译应用程序时,记得与所需的库链接,在这种情况下,基金会框架。例子:在编译应用程序时,记得与所需的库链接,这里是基金会框架。</target>
        </trans-unit>
        <trans-unit id="b62e9a626abd9a9fe60a81c2acd8e6a6e782d60a" translate="yes" xml:space="preserve">
          <source>When considering matches, a class is considered to be a match for any super classes or interfaces:</source>
          <target state="translated">在考虑匹配时,一个类被认为是任何超级类或接口的匹配。</target>
        </trans-unit>
        <trans-unit id="25e7aea40035f2392fc028cbab809dceedddf2af" translate="yes" xml:space="preserve">
          <source>When converting strings to numeric types, note that the D hexadecimal and binary literals are not handled. Neither the prefixes that indicate the base, nor the horizontal bar used to separate groups of digits are recognized. This also applies to the suffixes that indicate the type.  To work around this, you can specify a radix for conversions involving numbers.</source>
          <target state="translated">当将字符串转换为数字类型时,请注意,D十六进制和二进制字元不被处理。无论是表示基数的前缀,还是用于分隔数字组的横杠,都不被识别。这也适用于表示类型的后缀。为了解决这个问题,您可以为涉及数字的转换指定一个半径。</target>
        </trans-unit>
        <trans-unit id="f20f2f5dc05d757ab38fb9ae4891dd9fae63b55d" translate="yes" xml:space="preserve">
          <source>When creating a value of type &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt;, use &lt;code&gt; Flag!&quot;Name&quot;.no&lt;/code&gt; for the negative option. When using a value of type &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt;, compare it against &lt;code&gt; Flag!&quot;Name&quot;.no&lt;/code&gt; or just &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">创建类型为 &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; 的值时，请使用 &lt;code&gt; Flag!&quot;Name&quot;.no&lt;/code&gt; 作为否定选项。当使用类型 &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; 的值时，将其与 &lt;code&gt; Flag!&quot;Name&quot;.no&lt;/code&gt; 进行比较，或者为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75b62a7e29426c0ff497e198ae5a3aa4814c266f" translate="yes" xml:space="preserve">
          <source>When creating a value of type &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt;, use &lt;code&gt; Flag!&quot;Name&quot;.yes&lt;/code&gt; for the affirmative option. When using a value of type &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt;, compare it against &lt;code&gt; Flag!&quot;Name&quot;.yes&lt;/code&gt;.</source>
          <target state="translated">当创建类型为 &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; 的值时，请使用 &lt;code&gt; Flag!&quot;Name&quot;.yes&lt;/code&gt; 作为肯定选项。使用 &lt;code&gt;Flag!&quot;Name&quot;&lt;/code&gt; 类型的值时，请将其与 &lt;code&gt; Flag!&quot;Name&quot;.yes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5052cdcf10ea7a59ad8fcab69f469387e38a545c" translate="yes" xml:space="preserve">
          <source>When defining a Scheduler, an instance of this struct must be associated with each logical thread. It contains all implementation-level information needed by the internal API.</source>
          <target state="translated">当定义一个Scheduler时,这个结构的实例必须与每个逻辑线程相关联。它包含内部API所需要的所有实现级信息。</target>
        </trans-unit>
        <trans-unit id="a5cd9eef8c2bc9dbecfebdd3358b5fd51424da8d" translate="yes" xml:space="preserve">
          <source>When e is trivial and alwaysCopy == false, e itself is returned. Otherwise, a new VarExp is returned.</source>
          <target state="translated">当e是琐碎的且alwaysCopy ==false时,返回e本身。否则,将返回一个新的VarExp。</target>
        </trans-unit>
        <trans-unit id="1714fad4c54ea032f644bd0ff2725ffe944cc8e9" translate="yes" xml:space="preserve">
          <source>When examining a data structure or interface, it is very helpful to be able to easily tell which data can be expected to not change, which data might change, and who may change that data. This is done with the aid of the language typing system. Data can be marked as const or immutable, with the default being changeable (or</source>
          <target state="translated">在检查一个数据结构或接口时,能够很容易地分辨出哪些数据可以预期不会改变,哪些数据可能会改变,以及谁可能会改变这些数据是非常有用的。这要借助于语言类型系统来完成。数据可以被标记为const或immutable,默认为可改变(或</target>
        </trans-unit>
        <trans-unit id="0859e008a01c747e02b607536b15fa5d79c1fdcb" translate="yes" xml:space="preserve">
          <source>When getting the size of a member, it is not necessary for there to be a</source>
          <target state="translated">在获取成员的大小时,不一定要有一个</target>
        </trans-unit>
        <trans-unit id="814983e81354978a67ed413c94e9b7b6f637709d" translate="yes" xml:space="preserve">
          <source>When indexing and slicing an array, an out of bounds access will cause a runtime error, in order to prevent undefined behavior.</source>
          <target state="translated">当对一个数组进行索引和切片时,为了防止出现未定义的行为,越界访问将导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="fc7c4dad5ca2cb8b81db522d7ceba34b23bb3cfe" translate="yes" xml:space="preserve">
          <source>When inheriting from &lt;code&gt;MultiLogger&lt;/code&gt; this member can be used to gain access to the stored &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;MultiLogger&lt;/code&gt; 继承时，该成员可用于访问存储的 &lt;code&gt;Logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b86472ecfbd7bd8b1de11ab8c34dee4b76f1d70d" translate="yes" xml:space="preserve">
          <source>When laying out a struct to match an externally defined layout, use align attributes to describe an exact match. Using a &lt;a href=&quot;version#static-assert&quot;&gt;Static Assert&lt;/a&gt; to ensure the result is as expected.</source>
          <target state="translated">在布局结构以匹配外部定义的布局时，请使用align属性描述完全匹配。使用&lt;a href=&quot;version#static-assert&quot;&gt;静态声明&lt;/a&gt;来确保结果符合预期。</target>
        </trans-unit>
        <trans-unit id="c69f0de2afd3d5bd4cbff71a6a8b6010bba89573" translate="yes" xml:space="preserve">
          <source>When moving a struct instance, the compiler emits a call to this function after blitting the instance and before releasing the original instance's memory.</source>
          <target state="translated">当移动一个结构体实例时,编译器在点亮实例后,在释放原实例的内存之前,会发出对该函数的调用。</target>
        </trans-unit>
        <trans-unit id="25749d61a1b645ecb81cf7a527d2528e8b1112d5" translate="yes" xml:space="preserve">
          <source>When no delimiter is provided, strings are split into an array of words, using whitespace as delimiter. Runs of whitespace are merged together (no empty words are produced).</source>
          <target state="translated">当没有提供定界符时,字符串被分割成一个字数组,使用空格作为定界符。由空格组成的字符串会被合并在一起(不会产生空字)。</target>
        </trans-unit>
        <trans-unit id="c4c9890957dc3d440a6789767a520a3402a9a5c4" translate="yes" xml:space="preserve">
          <source>When one memory location is accessible with two different types, that aliasing is considered safe in these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24002fe90670fbadfc9a04fb282387881cb74bb4" translate="yes" xml:space="preserve">
          <source>When passing a string with unicode modifiers on characters, such as &lt;code&gt;\u0301&lt;/code&gt;, this function will not properly keep the position of the modifier. For example, reversing &lt;code&gt;ba\u0301d&lt;/code&gt; (&quot;b&amp;aacute;d&quot;) will result in d\u0301ab (&quot;d́ab&quot;) instead of &lt;code&gt;da\u0301b&lt;/code&gt; (&quot;d&amp;aacute;b&quot;).</source>
          <target state="translated">当在字符上传递带有unicode修饰符的字符串时，例如 &lt;code&gt;\u0301&lt;/code&gt; ，此函数将无法正确保留修饰符的位置。例如，反转 &lt;code&gt;ba\u0301d&lt;/code&gt; （&amp;ldquo;b&amp;aacute;d&amp;rdquo;）将导致d \ u0301ab（&amp;ldquo; d́ab&amp;rdquo;）而不是 &lt;code&gt;da\u0301b&lt;/code&gt; （&amp;ldquo;d&amp;aacute;b&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="4594bf9ec9e481a017a23a91d52669a9aa1fb686" translate="yes" xml:space="preserve">
          <source>When performing type conversions, &lt;a href=&quot;std_conv#ConvException&quot;&gt;&lt;code&gt;std.conv.ConvException&lt;/code&gt;&lt;/a&gt; is stored in the &lt;code&gt;next&lt;/code&gt; field.</source>
          <target state="translated">执行类型转换时，&lt;a href=&quot;std_conv#ConvException&quot;&gt; &lt;code&gt;std.conv.ConvException&lt;/code&gt; &lt;/a&gt;存储 &lt;code&gt;next&lt;/code&gt; 字段中。</target>
        </trans-unit>
        <trans-unit id="d930594f828ce102df70231e080c643ae6db4dfc" translate="yes" xml:space="preserve">
          <source>When reading data from an external source (like a file) written in a different endian format.</source>
          <target state="translated">当从外部源(如文件)读取以不同的endian格式编写的数据时。</target>
        </trans-unit>
        <trans-unit id="4a9a422bd912cb28217d65422e937a7368680e06" translate="yes" xml:space="preserve">
          <source>When reading or writing individual bytes of a multibyte type like &lt;code&gt;long&lt;/code&gt;s or &lt;code&gt;double&lt;/code&gt;s.</source>
          <target state="translated">读取或写入多字节类型（如 &lt;code&gt;long&lt;/code&gt; 或 &lt;code&gt;double&lt;/code&gt; )的单个字节时。</target>
        </trans-unit>
        <trans-unit id="45de4a8a712e00f9f4a3855141e4d0d235915b3d" translate="yes" xml:space="preserve">
          <source>When renaming and selective importing are combined:</source>
          <target state="translated">当重命名和选择性导入相结合时。</target>
        </trans-unit>
        <trans-unit id="7cadeab2e49ad72e63d768db3fcadd9c0cd9f7e7" translate="yes" xml:space="preserve">
          <source>When representing data, the nature of that data is generally symbolic as opposed to some other kind of data (for example, visual).</source>
          <target state="translated">在表示数据时,该数据的性质一般是象征性的,而不是其他种类的数据(例如,视觉数据)。</target>
        </trans-unit>
        <trans-unit id="938265349267329f2acf92b42b29485438eaaf7b" translate="yes" xml:space="preserve">
          <source>When set to &quot;&quot;, parameters to array and associative array receivers are treated as an individual argument. That is, only one argument is appended or inserted per appearance of the option switch. If &lt;code&gt;arraySep&lt;/code&gt; is set to something else, then each parameter is first split by the separator, and the individual pieces are treated as arguments to the same option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80aa4a5b53887e0378b7c0557a102bb741248b2a" translate="yes" xml:space="preserve">
          <source>When talking about function parameters, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb193fda02d3c450532e2c4ed3ce35d59b4da16c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;maxSize&lt;/code&gt; parameter is specified, memoize will used a fixed size hash table to limit the number of cached entries.</source>
          <target state="translated">当指定 &lt;code&gt;maxSize&lt;/code&gt; 参数时，memoize将使用固定大小的哈希表来限制缓存条目的数量。</target>
        </trans-unit>
        <trans-unit id="28be91897a1b828d9ca3bf3d37a260c8b80f7f1c" translate="yes" xml:space="preserve">
          <source>When the app thinks there's data available for curl it calls this function to read/write whatever there is right now. This returns as soon as the reads and writes are done. This function does not require that there actually is data available for reading or that data can be written, it can be called just in case. It returns the number of handles that still transfer data in the second argument's integer-pointer.</source>
          <target state="translated">当应用程序认为有数据可供curl使用时,它就会调用这个函数来读取/写入现在的任何数据。读写完成后会立即返回。这个函数并不要求真的有数据可供读取,也不要求可以写入数据,它可以被调用以备不时之需。它返回第二个参数的整数指针中仍然传输数据的句柄数。</target>
        </trans-unit>
        <trans-unit id="e0b14f32551259767f4a30407e0fff8e38d4bb8d" translate="yes" xml:space="preserve">
          <source>When the compiler sees a call to a method with Objective-C linkage it will generate a call similar to how an Objective-C compiler would call the method.</source>
          <target state="translated">当编译器看到一个带有Objective-C链接的方法的调用时,它将会产生一个类似于Objective-C编译器调用方法的调用。</target>
        </trans-unit>
        <trans-unit id="83c1e44b83f0f40840e69797d87e16b92208f380" translate="yes" xml:space="preserve">
          <source>When the data to be compressed doesn't fit in one buffer, use &lt;a href=&quot;#Compress&quot;&gt;&lt;code&gt;Compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#UnCompress&quot;&gt;&lt;code&gt;UnCompress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当要压缩的数据不适合一个缓冲区时，请使用&lt;a href=&quot;#Compress&quot;&gt; &lt;code&gt;Compress&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#UnCompress&quot;&gt; &lt;code&gt;UnCompress&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="896539fdc3e45dd59ef48e379f0327b9c5844901" translate="yes" xml:space="preserve">
          <source>When the environment variable version is used, the path won't be modified if the environment variable doesn't exist or it is empty. When the database version is used, the path won't be modified if the user doesn't exist in the database or there is not enough memory to perform the query.</source>
          <target state="translated">当使用环境变量版本时,如果环境变量不存在或为空,路径不会被修改。当使用数据库版本时,如果用户在数据库中不存在或没有足够的内存进行查询,则不会修改路径。</target>
        </trans-unit>
        <trans-unit id="7c65129fadefc530bc417ed6acb8a69dec4764f6" translate="yes" xml:space="preserve">
          <source>When the fallback type is different from the Nullable type, &lt;code&gt;get(T)&lt;/code&gt; returns the common type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb534bd82a0cc54777be5e4326d6be4e7a12f475" translate="yes" xml:space="preserve">
          <source>When the owner of the graph is no longer needed, then the graph of memory objects it points to is no longer needed and can be safely disposed of. If the owner itself is no longer in use (i.e. is no longer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2705f8c4f5d477062e59510ed5eeb511cc61cb" translate="yes" xml:space="preserve">
          <source>When the sequence is a</source>
          <target state="translated">当序列是一个</target>
        </trans-unit>
        <trans-unit id="0309591ed6bc783d05be62ec41369ee1fb439157" translate="yes" xml:space="preserve">
          <source>When the slice operator appears as the left-hand side of an assignment expression, it means that the contents of the array are the target of the assignment rather than a reference to the array. Array copying happens when the left-hand side is a slice, and the right-hand side is an array of or pointer to the same type.</source>
          <target state="translated">当分片运算符作为赋值表达式的左手边出现时,意味着数组的内容是赋值的目标,而不是数组的引用。当左手边是分片,右手边是相同类型的数组或指针时,就会发生数组复制。</target>
        </trans-unit>
        <trans-unit id="0d0158e3bfad8163fe4d771bd25fbc541f126c32" translate="yes" xml:space="preserve">
          <source>When the template parameters must be deduced, the eponymous members can't rely on a &lt;a href=&quot;version#StaticIfCondition&quot;&gt;&lt;code&gt;static if&lt;/code&gt;&lt;/a&gt; condition since the deduction relies on how the in members are used:</source>
          <target state="translated">当必须推导模板参数时，同名成员不能依赖于&lt;a href=&quot;version#StaticIfCondition&quot;&gt; &lt;code&gt;static if&lt;/code&gt; &lt;/a&gt;条件，因为推导取决于in成员的使用方式：</target>
        </trans-unit>
        <trans-unit id="18a1489da8628a0eecf26996d6a9104fb7ace293" translate="yes" xml:space="preserve">
          <source>When the threads in the global task pool are waiting on a synchronization primitive (for example a mutex), and you want to parallelize the code that needs to run before these threads can be resumed.</source>
          <target state="translated">当全局任务池中的线程正在等待一个同步基元(例如mutex),而你想并行化需要在这些线程恢复之前运行的代码。</target>
        </trans-unit>
        <trans-unit id="234c7c2ced27e46dbe44f8c1d3b942116be5d1ba" translate="yes" xml:space="preserve">
          <source>When the value that is returned by this function is destroyed, &lt;code&gt;func&lt;/code&gt; will run. &lt;code&gt;func&lt;/code&gt; is a unary function that takes a &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当此函数返回的值被破坏时， &lt;code&gt;func&lt;/code&gt; 将运行。 &lt;code&gt;func&lt;/code&gt; 是一个采用&lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;的一元函数。</target>
        </trans-unit>
        <trans-unit id="f3712c7b591b91ff3f87d8d90ad3ede3c54ffd11" translate="yes" xml:space="preserve">
          <source>When the virtual-table mechanism stabilizes, we will declare the interface fixed, support it indefinitely, and remove this comment.</source>
          <target state="translated">等到虚拟表机制稳定后,我们会宣布接口固定,无限期支持,并删除此评论。</target>
        </trans-unit>
        <trans-unit id="a3cf6901b7b4052fec7ad41737841bcba23193f0" translate="yes" xml:space="preserve">
          <source>When there are more than two ranges, the above conditions apply to each adjacent pair of ranges.</source>
          <target state="translated">当有两个以上的范围时,上述条件适用于每一对相邻的范围。</target>
        </trans-unit>
        <trans-unit id="d07dc7e0a2ca5375f8d0e4ada71ece6299c4ea8d" translate="yes" xml:space="preserve">
          <source>When this function returns true, &lt;code&gt;checkValue()&lt;/code&gt; should also return true.</source>
          <target state="translated">当此函数返回true时， &lt;code&gt;checkValue()&lt;/code&gt; 也应返回true。</target>
        </trans-unit>
        <trans-unit id="0e32a64dc0a978025c37a0920a24a143d7cf1416" translate="yes" xml:space="preserve">
          <source>When transversed, the elements of a range of ranges are assumed to have different lengths (e.g. a jagged array).</source>
          <target state="translated">转置时,假设一个范围内的元素具有不同的长度(如锯齿形阵列)。</target>
        </trans-unit>
        <trans-unit id="216d54ab44b92631e631f27e0f2e599194972d30" translate="yes" xml:space="preserve">
          <source>When unit tests are enabled, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;unittest&lt;/code&gt; is predefined.</source>
          <target state="translated">启用单元测试后，将预定义&lt;a href=&quot;version#PredefinedVersions&quot;&gt;版本标识符&lt;/a&gt; &lt;code&gt;unittest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13ccf60a3ee5316c31b6b5b537a534e41d39ff06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Array&lt;/code&gt; with range-based functions like those in &lt;code&gt;std.algorithm&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt; must be sliced to get a range (for example, use &lt;code&gt;array[].map!&lt;/code&gt; instead of &lt;code&gt;array.map!&lt;/code&gt;). The container itself is not a range.</source>
          <target state="translated">当将 &lt;code&gt;Array&lt;/code&gt; 与基于范围的函数（如 &lt;code&gt;std.algorithm&lt;/code&gt; 中的函数）一起使用时，必须对 &lt;code&gt;Array&lt;/code&gt; 进行切片以获取范围（例如，使用 &lt;code&gt;array[].map!&lt;/code&gt; &lt;code&gt;array.map!&lt;/code&gt; 而不是array.map！）。容器本身不是范围。</target>
        </trans-unit>
        <trans-unit id="03cc7adf8ba709706cb35f2bb58133dcfd782ae1" translate="yes" xml:space="preserve">
          <source>When using inline assembly to correctly call a function.</source>
          <target state="translated">当使用内联装配正确调用函数时。</target>
        </trans-unit>
        <trans-unit id="774688ec36c97935b4687d1f1193e25cd82c07c5" translate="yes" xml:space="preserve">
          <source>When you want &lt;code&gt;TaskPool&lt;/code&gt; instances with multiple priorities, for example a low priority pool and a high priority pool.</source>
          <target state="translated">当您想要具有多个优先级的 &lt;code&gt;TaskPool&lt;/code&gt; 实例时，例如低优先级池和高优先级池。</target>
        </trans-unit>
        <trans-unit id="5c533eb95b7c68ca359d852388aa63c0df13caf8" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;W&lt;/code&gt; is an &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt; which accepts characters. The template type does not have to be called &lt;code&gt;W&lt;/code&gt;.  The following overloads are also accepted for legacy reasons or for use in virtual functions. It's recommended that any new code forgo these overloads if possible for speed and attribute acceptance reasons.</source>
          <target state="translated">其中 &lt;code&gt;W&lt;/code&gt; 是接受字符的&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;输出范围&lt;/a&gt;。模板类型没有被称为 &lt;code&gt;W&lt;/code&gt; 。出于传统原因或在虚拟函数中使用，也可以接受以下重载。出于速度和属性接受的原因，建议所有新代码都尽可能放弃这些重载。</target>
        </trans-unit>
        <trans-unit id="eb779ddbf577345f9139abf518ae6cd3c208a9cf" translate="yes" xml:space="preserve">
          <source>Where XX, YY and ZZ are the main version, release and patch numbers in hexadecimal (using 8 bits each). All three numbers are always represented using two digits. 1.2 would appear as &quot;0x010200&quot; while version 9.11.7 appears as &quot;0x090b07&quot;.</source>
          <target state="translated">其中 XX、YY 和 ZZ 是十六进制的主要版本、版本号和补丁号(每个版本使用 8 位)。所有三个数字总是用两个数字来表示。1.2将显示为 &quot;0x010200&quot;,而9.11.7版本则显示为 &quot;0x090b07&quot;。</target>
        </trans-unit>
        <trans-unit id="6a3d5415126b01717847c36c693a1e7515df6fdf" translate="yes" xml:space="preserve">
          <source>Where a, b are arbitrary classes, means union, set difference, symmetric set difference, and intersection respectively.</source>
          <target state="translated">其中a、b为任意类,分别指联合、集差、对称集差和交集。</target>
        </trans-unit>
        <trans-unit id="69a17bf80e2fc04c2ef5e795e322e80f59502b94" translate="yes" xml:space="preserve">
          <source>Where if &lt;code&gt;elemsPerPage&lt;/code&gt; is a power of 2 the whole process is a handful of simple instructions and 2 array reads. Subsequent levels of the trie are introduced by recursing on this notion - the index array is treated as values. The number of bits in index is then again split into 2 parts, with pages over 'current-index' and the new 'upper-index'.</source>
          <target state="translated">如果 &lt;code&gt;elemsPerPage&lt;/code&gt; 是2的幂，则整个过程只有少量的简单指令和2个数组读取。通过递归此概念来引入特里的后续级别-将索引数组视为值。然后，将索引中的位数再次分为两部分，页面分别位于&amp;ldquo; current-index&amp;rdquo;和新的&amp;ldquo; upper-index&amp;rdquo;上。</target>
        </trans-unit>
        <trans-unit id="ffd66cb2f4f10b47de2beafeec66ea7b60de2589" translate="yes" xml:space="preserve">
          <source>Where the identifier is set</source>
          <target state="translated">当标识符被设置为</target>
        </trans-unit>
        <trans-unit id="c203f2e467da276e5a5bb88a389aa547ada7fa1a" translate="yes" xml:space="preserve">
          <source>Where to copy into. The destructor, if any, is invoked before the copy is performed.</source>
          <target state="translated">复制到哪里。如果有的话,在进行复制之前,会先调用解构器。</target>
        </trans-unit>
        <trans-unit id="dae838c18b4d528d3dc79e9e2ab37bd9a763d468" translate="yes" xml:space="preserve">
          <source>Whereas classes are reference types, structs are value types. Structs and unions are simple aggregations of data and their associated operations on that data.</source>
          <target state="translated">而类是引用类型,结构是值类型。构造体和联合体是数据的简单聚合,以及它们对数据的相关操作。</target>
        </trans-unit>
        <trans-unit id="62176441139d7d91c6f66f0b49fc197cb19d61fc" translate="yes" xml:space="preserve">
          <source>Whereas the other constructors take in the given date/time, assume that it's in the given time zone, and convert it to hnsecs in UTC since midnight, January 1st, 1 A.D. UTC - i.e. std time - this constructor takes a std time, which is specifically already in UTC, so no conversion takes place. Of course, the various getter properties and functions will use the given time zone's conversion function to convert the results to that time zone, but no conversion of the arguments to this constructor takes place.</source>
          <target state="translated">而其他构造函数则是获取给定的日期/时间,假设它在给定的时区,并将其转换为公元1月1日午夜起的UTC时区的hnsecs--即标准时间--而这个构造函数获取的是标准时间,特别是已经在UTC时区的时间,所以没有进行转换。当然,各种getter属性和函数会使用给定时区的转换函数将结果转换为该时区,但这个构造函数的参数不会发生转换。</target>
        </trans-unit>
        <trans-unit id="5439ddebea3bcb8241b4a1b48a901c3a98dff5ec" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a control character.</source>
          <target state="translated">无论 &lt;code&gt;c&lt;/code&gt; 是控制字符。</target>
        </trans-unit>
        <trans-unit id="ac340e59aede6ee81d823a4cd6c5e84a932a655e" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a digit (0 .. 9).</source>
          <target state="translated">是否 &lt;code&gt;c&lt;/code&gt; 是数字（0..9）。</target>
        </trans-unit>
        <trans-unit id="7a1b20eec72209de601cdbd2eb60cdc44fe1de5c" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a digit in base 16 (0 .. 9, A .. F, a .. f).</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 是否为以16为底的数字（0..9，A..F，a..f）。</target>
        </trans-unit>
        <trans-unit id="5ef7c81488982c30dc4276356f1e35e27da46b13" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a digit in base 8 (0 .. 7).</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 是否为以8为底的数字（0 .. 7）。</target>
        </trans-unit>
        <trans-unit id="485864c1a1ee3e1f67b7c0cca59c7933fd3cba6d" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a letter or a number (0 .. 9, a .. z, A .. Z).</source>
          <target state="translated">是否 &lt;code&gt;c&lt;/code&gt; 是一个字母或一个数字（0 .. 9，.. Z，A .. Z）。</target>
        </trans-unit>
        <trans-unit id="7ed8edd047ab927ee6ae7e9b404aa1611fee1ac6" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is a lowercase ASCII letter (a .. z).</source>
          <target state="translated">无论 &lt;code&gt;c&lt;/code&gt; 是小写ASCII字母（A ... Z）。</target>
        </trans-unit>
        <trans-unit id="e45a29a9e82d832a043d4e613efe813b387b2d34" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is an ASCII letter (A .. Z, a .. z).</source>
          <target state="translated">是否 &lt;code&gt;c&lt;/code&gt; 是一个ASCII字母（A .. Z，一.. z）表示。</target>
        </trans-unit>
        <trans-unit id="4f95dae2edd2421032fe310301c2c8b1dfab82c9" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;c&lt;/code&gt; is an uppercase ASCII letter (A .. Z).</source>
          <target state="translated">是否 &lt;code&gt;c&lt;/code&gt; 是大写字母ASCII（A .. Z）。</target>
        </trans-unit>
        <trans-unit id="7e4e8211288692290b0be6dedd54932002f12b6c" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;popFront&lt;/code&gt; should be called on the range before returning it.</source>
          <target state="translated">返回范围之前是否应在范围上调用 &lt;code&gt;popFront&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81f48dc00dd66c921120fd6bdac04fd2154ca8fc" translate="yes" xml:space="preserve">
          <source>Whether a particular function can be inlined or not is implementation defined.</source>
          <target state="translated">某一特定函数是否可以内联,是由实现定义的。</target>
        </trans-unit>
        <trans-unit id="80666ab4965f448639b5b13ddb44b4b76acb3bd0" translate="yes" xml:space="preserve">
          <source>Whether a particular operation on a type is supported can be tested at compile time with:</source>
          <target state="translated">是否支持对类型的特定操作可以在编译时用以下方法测试。</target>
        </trans-unit>
        <trans-unit id="b17fe9f3bccc77f51d0d6f2eb75dfb731d9293e3" translate="yes" xml:space="preserve">
          <source>Whether a path is absolute or not.</source>
          <target state="translated">一个路径是否绝对。</target>
        </trans-unit>
        <trans-unit id="d4257757fa6c5a2c951b861ea5ebf39ab85d95e9" translate="yes" xml:space="preserve">
          <source>Whether a path starts at a root directory.  On POSIX, this function returns true if and only if the path starts with a slash (/).  On Windows, this function returns true if the path starts at the root directory of the current drive, of some other drive, or of a network drive.</source>
          <target state="translated">路径是否以根目录开始。在POSIX上,如果且仅当路径以斜线(/)开始时,这个函数返回true。在Windows上,如果路径以当前驱动器、其他驱动器或网络驱动器的根目录开始,这个函数返回true。</target>
        </trans-unit>
        <trans-unit id="47cbbb478f0753b2ad9648d6b321f84472430403" translate="yes" xml:space="preserve">
          <source>Whether a pointer is allocated memory using the GC or some other storage allocator is immaterial to OB, they are not distinguished and are handled identically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ee264abbb44915ef26b042ef0ba91b59c33f3c" translate="yes" xml:space="preserve">
          <source>Whether a type exists or not can be tested at compile time with an &lt;a href=&quot;expression#IsExpression&quot;&gt;&lt;i&gt;IsExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">可以在编译时使用&lt;a href=&quot;expression#IsExpression&quot;&gt;&lt;i&gt;IsExpression&lt;/i&gt;&lt;/a&gt;测试类型是否存在：</target>
        </trans-unit>
        <trans-unit id="0d2e8298d7375b3835488873ddc1eb261222d403" translate="yes" xml:space="preserve">
          <source>Whether all of the given strings are valid units of time.</source>
          <target state="translated">是否所有给定的字符串都是有效的时间单位。</target>
        </trans-unit>
        <trans-unit id="bddd6255fa5caa2472a10e52a62323219a833636" translate="yes" xml:space="preserve">
          <source>Whether duplicates should be allowed (optional, default: false)</source>
          <target state="translated">是否允许重复(可选,默认:false)。</target>
        </trans-unit>
        <trans-unit id="105ee00d48f41e70c224fbb448cf13e95b6d4c14" translate="yes" xml:space="preserve">
          <source>Whether matching path name components against the base path should be case-sensitive or not.</source>
          <target state="translated">与基本路径匹配的路径名组件是否应该区分大小写。</target>
        </trans-unit>
        <trans-unit id="5994712767c3b51ff98f1684ff6aac750498fbfd" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a Unicode whitespace &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;. (general Unicode category: Part of C0(tab, vertical tab, form feed, carriage return, and linefeed characters), Zs, Zl, Zp, and NEL(U+0085))</source>
          <target state="translated">无论 &lt;code&gt;c&lt;/code&gt; 是一个Unicode空白&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;。（通用Unicode类别：C0（制表符，垂直制表符，换页符，回车符和换行符），Zs，Zl，Zp和NEL（U + 0085）的一部分）</target>
        </trans-unit>
        <trans-unit id="e5176862b3796a64ee6f96c0f2cad977204be80c" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a printable character - including the space character.</source>
          <target state="translated">无论 &lt;code&gt;c&lt;/code&gt; 是可打印字符-包括空格字符。</target>
        </trans-unit>
        <trans-unit id="8d275566c08c40d417a8d0c1a542e23706cfd89d" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a printable character other than the space character.</source>
          <target state="translated">无论 &lt;code&gt;c&lt;/code&gt; 比空格字符以外的可打印字符。</target>
        </trans-unit>
        <trans-unit id="0d4466d6122843433740ac1e24f53638cd058f74" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a punctuation character. That includes all ASCII characters which are not control characters, letters, digits, or whitespace.</source>
          <target state="translated">无论 &lt;code&gt;c&lt;/code&gt; 是标点字符。其中包括不是控制字符，字母，数字或空格的所有ASCII字符。</target>
        </trans-unit>
        <trans-unit id="53aed4e21bd24c8a6a4ab614baedfcc7d4f4996f" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is a whitespace character. That includes the space, tab, vertical tab, form feed, carriage return, and linefeed characters.</source>
          <target state="translated">无论 &lt;code&gt;c&lt;/code&gt; 是一个空白字符。其中包括空格，制表符，垂直制表符，换页符，回车符和换行符。</target>
        </trans-unit>
        <trans-unit id="b615a3fb840147ddc1a8af598703baa7a19f1868" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;code&gt;c&lt;/code&gt; is in the ASCII character set - i.e. in the range 0 .. 0x7F.</source>
          <target state="translated">是否 &lt;code&gt;c&lt;/code&gt; 是ASCII字符集-即，在范围从0到0x7F的。</target>
        </trans-unit>
        <trans-unit id="4fcdd7b41031ee1cf72b913251142382d55fe4bc" translate="yes" xml:space="preserve">
          <source>Whether or not suffix matching is case-sensitive.</source>
          <target state="translated">后缀匹配是否区分大小写。</target>
        </trans-unit>
        <trans-unit id="ab7c20d3765e454b2882b3b020b5a0b203d7fc57" translate="yes" xml:space="preserve">
          <source>Whether or not to replace invalid UTF with &lt;a href=&quot;#replacementDchar&quot;&gt;&lt;code&gt;replacementDchar&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">是否要替换无效UTF &lt;a href=&quot;#replacementDchar&quot;&gt; &lt;code&gt;replacementDchar&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e89650fbf7133e4518a40c904d03fa213351ed5" translate="yes" xml:space="preserve">
          <source>Whether some pointers can be initialized with the addresses of other functions or data.</source>
          <target state="translated">是否可以用其他函数或数据的地址初始化一些指针。</target>
        </trans-unit>
        <trans-unit id="46b11fa801f28347be88f3318e7531888286afa4" translate="yes" xml:space="preserve">
          <source>Whether symbolic links which point to directories should be treated as directories and their contents iterated over.</source>
          <target state="translated">是否应将指向目录的符号链接作为目录及其内容进行迭代处理。</target>
        </trans-unit>
        <trans-unit id="cf1e4687c0d3d2d1dc253d21a37e498c8e5bdf91" translate="yes" xml:space="preserve">
          <source>Whether the</source>
          <target state="translated">是否</target>
        </trans-unit>
        <trans-unit id="2b547c643e30d803b4436c4a2410fe11d4d71937" translate="yes" xml:space="preserve">
          <source>Whether the alias this was reported as deprecated.</source>
          <target state="translated">这个别名是否报废了。</target>
        </trans-unit>
        <trans-unit id="64958592863f2f27ab327ee132cce3a7bd2ddc9b" translate="yes" xml:space="preserve">
          <source>Whether the attributes are values or types is up to the user, and whether later attributes accumulate or override earlier ones is also up to how the user interprets them.</source>
          <target state="translated">属性是值还是类型由用户决定,后来的属性是积累还是覆盖之前的属性,也取决于用户如何解释。</target>
        </trans-unit>
        <trans-unit id="63cc9d04434e2b0f371df73e94c3596c4b2795d4" translate="yes" xml:space="preserve">
          <source>Whether the current year is a date in A.D.</source>
          <target state="translated">本年是否为公元的日期。</target>
        </trans-unit>
        <trans-unit id="74f48ebfb70bd542fa649d10356abbfea0c933cd" translate="yes" xml:space="preserve">
          <source>Whether the day should be allowed to overflow, causing the month to increment.</source>
          <target state="translated">是否应该允许日溢出,导致月递增。</target>
        </trans-unit>
        <trans-unit id="e4d91a4b6609e830d213d95f93d157f35d7012ec" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow on &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, causing their month to increment.</source>
          <target state="translated">是否应允许这些天在 &lt;code&gt;begin&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 溢出，从而导致其月份增加。</target>
        </trans-unit>
        <trans-unit id="f906c90dd95bf15e29eecd5d760671025012b178" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow on &lt;code&gt;begin&lt;/code&gt;, causing its month to increment.</source>
          <target state="translated">无论是天应允许溢出的 &lt;code&gt;begin&lt;/code&gt; ，导致其每月递增。</target>
        </trans-unit>
        <trans-unit id="1cf8d3b77ba179bc4efd8d66d52696c2e6e3533e" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow on &lt;code&gt;end&lt;/code&gt;, causing its month to increment.</source>
          <target state="translated">是否应允许天数 &lt;code&gt;end&lt;/code&gt; ，从而导致其月份增加。</target>
        </trans-unit>
        <trans-unit id="75b2be390650906e0d7fdcddcbc148b30188752c" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow on &lt;code&gt;end&lt;/code&gt;, causing their month to increment.</source>
          <target state="translated">是否应允许天数 &lt;code&gt;end&lt;/code&gt; ，从而导致其月份增加。</target>
        </trans-unit>
        <trans-unit id="4f04a420fd7af3fb4659b207356841de3d274500" translate="yes" xml:space="preserve">
          <source>Whether the days should be allowed to overflow, causing the month to increment.</source>
          <target state="translated">是否应该允许天数溢出,导致月份递增。</target>
        </trans-unit>
        <trans-unit id="5edf9636ede7af2a2961293554b8a7947f2de1da" translate="yes" xml:space="preserve">
          <source>Whether the directory's sub-directories should be iterated in depth-first post-order (&lt;a href=&quot;#depth&quot;&gt;&lt;code&gt;depth&lt;/code&gt;&lt;/a&gt;), depth-first pre-order (&lt;a href=&quot;#breadth&quot;&gt;&lt;code&gt;breadth&lt;/code&gt;&lt;/a&gt;), or not at all (&lt;a href=&quot;#shallow&quot;&gt;&lt;code&gt;shallow&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">目录的子目录是否应该按深度优先（&lt;a href=&quot;#depth&quot;&gt; &lt;code&gt;depth&lt;/code&gt; &lt;/a&gt;），深度优先（&lt;a href=&quot;#breadth&quot;&gt; &lt;code&gt;breadth&lt;/code&gt; &lt;/a&gt;）或根本不（&lt;a href=&quot;#shallow&quot;&gt; &lt;code&gt;shallow&lt;/code&gt; &lt;/a&gt;）进行迭代。</target>
        </trans-unit>
        <trans-unit id="e52e8a91e4b8f750e345969fb48d6af719bcad92" translate="yes" xml:space="preserve">
          <source>Whether the elements copied should be in sorted order.</source>
          <target state="translated">复制的元素是否应该按顺序排列。</target>
        </trans-unit>
        <trans-unit id="c4ed695121f4b89d56651176a0692d94b2e93e86" translate="yes" xml:space="preserve">
          <source>Whether the elements copied should be in sorted order.  The function &lt;code&gt;largestPartialIntersection&lt;/code&gt; is useful for e.g. searching an &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverted_index&quot;&gt;inverted index&lt;/a&gt; for the documents most likely to contain some terms of interest. The complexity of the search is &amp;Omicron;(&lt;code&gt;n * log(tgt.length)&lt;/code&gt;), where &lt;code&gt;n&lt;/code&gt; is the sum of lengths of all input ranges. This approach is faster than keeping an associative array of the occurrences and then selecting its top items, and also requires less memory (&lt;code&gt;largestPartialIntersection&lt;/code&gt; builds its result directly in &lt;code&gt;tgt&lt;/code&gt; and requires no extra memory).  If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all ranges and picking the most frequent &lt;code&gt;tgt.length&lt;/code&gt; elements.</source>
          <target state="translated">复制的元素是否应按排序顺序。函数 &lt;code&gt;largestPartialIntersection&lt;/code&gt; 对于例如在&lt;a href=&quot;https://en.wikipedia.org/wiki/Inverted_index&quot;&gt;反向索引中&lt;/a&gt;搜索最有可能包含某些感兴趣项的文档很有用。搜索的复杂度为&amp;Omicron;（ &lt;code&gt;n * log(tgt.length)&lt;/code&gt; ），其中 &lt;code&gt;n&lt;/code&gt; 是所有输入范围的长度之和。这种方法比保留事件的关联数组然后选择其顶部项要快，并且所需的内存也更少（ &lt;code&gt;largestPartialIntersection&lt;/code&gt; 直接在 &lt;code&gt;tgt&lt;/code&gt; 中构建其结果并且不需要额外的内存）。如果范围中的至少一个是多集，那么将考虑重复元素的所有出现。结果等同于合并所有范围并选择最常用的 &lt;code&gt;tgt.length&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="222aaf1e209a1d1950f86d3b862f71882791518e" translate="yes" xml:space="preserve">
          <source>Whether the given Gregorian Year is a leap year.</source>
          <target state="translated">给定的公历年是否为闰年。</target>
        </trans-unit>
        <trans-unit id="0960e5d381ab24794774d7641f42ed087b4e5af5" translate="yes" xml:space="preserve">
          <source>Whether the given interval is adjacent to this interval.</source>
          <target state="translated">给定的区间是否与这个区间相邻。</target>
        </trans-unit>
        <trans-unit id="2224cd32996d6b99aba1574ce1aececc83aecc58" translate="yes" xml:space="preserve">
          <source>Whether the given interval is completely within this interval.</source>
          <target state="translated">给定的区间是否完全在这个区间内。</target>
        </trans-unit>
        <trans-unit id="3eb9c7e591a9089f7aa4ef62cbadc0d86f7ab393" translate="yes" xml:space="preserve">
          <source>Whether the given interval overlaps this interval.</source>
          <target state="translated">给定的区间是否与这个区间重叠。</target>
        </trans-unit>
        <trans-unit id="43cf734ed67d93278a33afc7cd0b9e0cc54e9d11" translate="yes" xml:space="preserve">
          <source>Whether the given time point is within this interval.</source>
          <target state="translated">给定的时间点是否在这个区间内。</target>
        </trans-unit>
        <trans-unit id="fba0a8c883b3bbb3c817280550f713f113b648ef" translate="yes" xml:space="preserve">
          <source>Whether the given type defines all of the necessary functions for it to function as a time point.</source>
          <target state="translated">给定类型是否定义了它作为时间点的所有必要功能。</target>
        </trans-unit>
        <trans-unit id="7595a2da4d09354571e7d048eb2cac04b29d2b5c" translate="yes" xml:space="preserve">
          <source>Whether the input should be considered to already be in quotes</source>
          <target state="translated">是否应该认为输入的内容已经加了引号?</target>
        </trans-unit>
        <trans-unit id="6c405afd958614c32b310c5d0cf26f852d390597" translate="yes" xml:space="preserve">
          <source>Whether the interval's length is 0, that is, whether &lt;code&gt;begin == end&lt;/code&gt;.</source>
          <target state="translated">间隔的长度是否为0，即 &lt;code&gt;begin == end&lt;/code&gt; 是否。</target>
        </trans-unit>
        <trans-unit id="fee4c582fcbd6cb7b6d78096f397a088d57f77e8" translate="yes" xml:space="preserve">
          <source>Whether the interval's length is 0. Always returns false.</source>
          <target state="translated">区间的长度是否为0,总是返回false。</target>
        </trans-unit>
        <trans-unit id="211f313086ef9b6b83422bb372a90c8c62b36199" translate="yes" xml:space="preserve">
          <source>Whether the last element has fewer elements than &lt;code&gt;windowSize&lt;/code&gt; it should be be ignored (&lt;code&gt;No.withPartial&lt;/code&gt;) or added (&lt;code&gt;Yes.withPartial&lt;/code&gt;)</source>
          <target state="translated">最后一个元素是否少于 &lt;code&gt;windowSize&lt;/code&gt; ，应将其忽略（ &lt;code&gt;No.withPartial&lt;/code&gt; ）或添加（ &lt;code&gt;Yes.withPartial&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ba9abeb7a170a01907bd30fe75c31c8934244314" translate="yes" xml:space="preserve">
          <source>Whether the matching should be case-sensitive</source>
          <target state="translated">匹配是否应该区分大小写。</target>
        </trans-unit>
        <trans-unit id="f13a37d1655eb5c02daf3aaa88f877bec24d658e" translate="yes" xml:space="preserve">
          <source>Whether the program stops on the first unit test failure, or continues running the unit tests.</source>
          <target state="translated">程序是在第一次单元测试失败时停止,还是继续运行单元测试。</target>
        </trans-unit>
        <trans-unit id="16d709e5514290422fe4701b1fcb581c1cf7c0ea" translate="yes" xml:space="preserve">
          <source>Whether the symbol represented by the string, member, exists and is a static member of T.</source>
          <target state="translated">字符串member所代表的符号是否存在,是否是T的静态成员。</target>
        </trans-unit>
        <trans-unit id="5440d07830fe58a338f1510d753f2b44ea0975da" translate="yes" xml:space="preserve">
          <source>Whether the type is modifiable</source>
          <target state="translated">该类型是否可以修改</target>
        </trans-unit>
        <trans-unit id="3f12e12092120abbb5facbde31d865f4ac9237a3" translate="yes" xml:space="preserve">
          <source>Whether there are more matches.</source>
          <target state="translated">是否有更多的匹配。</target>
        </trans-unit>
        <trans-unit id="79ba28ddb3b853b6d70a3013610438f23721a2fc" translate="yes" xml:space="preserve">
          <source>Whether this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in a leap year.</source>
          <target state="translated">此&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;是否在a年。</target>
        </trans-unit>
        <trans-unit id="cfc2c65b73e5981574242c9ea69e9d9a4065c55b" translate="yes" xml:space="preserve">
          <source>Whether this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in a leap year.</source>
          <target state="translated">此&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;是否在a年中。</target>
        </trans-unit>
        <trans-unit id="8a7bb8b28d4fed31e73e86d279c785680a5039aa" translate="yes" xml:space="preserve">
          <source>Whether this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is in a leap year.</source>
          <target state="translated">此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;是否处于a年。</target>
        </trans-unit>
        <trans-unit id="cbeb386e746809fa0b6115a9b6ed409316553ae9" translate="yes" xml:space="preserve">
          <source>Whether this &lt;code&gt;IntervalRange&lt;/code&gt; is empty.</source>
          <target state="translated">此 &lt;code&gt;IntervalRange&lt;/code&gt; 是否为空。</target>
        </trans-unit>
        <trans-unit id="b64edf6a2596a02728c1746b3074d42171989fdf" translate="yes" xml:space="preserve">
          <source>Whether this &lt;code&gt;alias this&lt;/code&gt; is deprecated or not</source>
          <target state="translated">此 &lt;code&gt;alias this&lt;/code&gt; 是否已弃用</target>
        </trans-unit>
        <trans-unit id="5f10f8b3bbf77628c34f12ea0b9275a2e7571d57" translate="yes" xml:space="preserve">
          <source>Whether this interval is after the given interval and does not intersect it.</source>
          <target state="translated">这个区间是否在给定区间之后,而不与之相交。</target>
        </trans-unit>
        <trans-unit id="3518cb2bbf874df4bb8421f23e69b77bffff6981" translate="yes" xml:space="preserve">
          <source>Whether this interval is after the given time point.</source>
          <target state="translated">这个区间是否在给定的时间点之后。</target>
        </trans-unit>
        <trans-unit id="e8beff07475e780f798cb6bfa07a9e4e3b7aa515" translate="yes" xml:space="preserve">
          <source>Whether this interval is before the given interval and does not intersect it.</source>
          <target state="translated">这个区间是否在给定区间之前,而不与之相交。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
