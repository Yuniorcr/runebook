<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">身份分配过载</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">身份表达</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">意象图形描述字符</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">习惯用法 &lt;code&gt;std.experimental.allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">如果!!为空,则 elements[]可以是稀疏的,&quot;默认 &quot;元素值使用basis。换句话说,非空的 elements[i]会覆盖这个 &quot;basis &quot;值。</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">如果'e'是一棵逗号树,则从树中剥离最右边的表达式返回。树的剩余部分通过e0返回,否则直接返回'e',并将e0设置为NULL。否则直接返回'e',并将e0设为NULL。</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">如果&lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt;！R是浮点类型，并且 &lt;code&gt;R&lt;/code&gt; 是具有长度和切片的&lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;随机访问范围&lt;/a&gt;，则 &lt;code&gt;sum&lt;/code&gt; 使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;成对求和&lt;/a&gt;算法。</target>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">如果 &lt;code&gt;!!value&lt;/code&gt; 为true，则返回 &lt;code&gt;value&lt;/code&gt; 。否则，将抛出 &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; 。 &lt;code&gt;WindowsException&lt;/code&gt; 假定最后一个操作正确设置了 &lt;code&gt;GetLastError()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">如果 &lt;code&gt;!isInfinite!Source&lt;/code&gt; 和 &lt;code&gt;source.walkLength&lt;/code&gt; 不能被 &lt;code&gt;chunkSize&lt;/code&gt; 整除，则此范围的back元素将包含少于 &lt;code&gt;chunkSize&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果 &lt;code&gt;!value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回 &lt;code&gt;value&lt;/code&gt; 。否则，将引发 &lt;code&gt;new E(msg, file, line)&lt;/code&gt; 。或者，如果 &lt;code&gt;E&lt;/code&gt; 不走的消息，可以构建 &lt;code&gt;new E(file, line)&lt;/code&gt; ，那么 &lt;code&gt;new E(file, line)&lt;/code&gt; 将被抛出。</target>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 没有状态，则将结果对象分配到静态共享存储中。</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 具有状态并且是可复制的，则结果将在&lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt;中移动提供的分配器 &lt;code&gt;A a&lt;/code&gt; 。结果本身在其自己的静态类型分配器中分配。</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 具有状态且不可复制，则结果会将传入的参数移入结果。结果本身在其自己的静态类型分配器中分配。</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 具有状态，则结果将&lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt;在其中提供的分配器 &lt;code&gt;A a&lt;/code&gt; 中。结果本身在其自己的静态类型分配器中分配。</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Allocator&lt;/code&gt; 实现 &lt;code&gt;owns&lt;/code&gt; ，则转发给它。否则，返回 &lt;code&gt;Ternary.unknown&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">如果 &lt;code&gt;BookkeepingAllocator&lt;/code&gt; 不是 &lt;code&gt;NullAllocator&lt;/code&gt; ，则 &lt;code&gt;bkalloc&lt;/code&gt; 被定义并且可以访问。</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">如果 &lt;code&gt;ElementType!R&lt;/code&gt; 是浮点类型，并且 &lt;code&gt;R&lt;/code&gt; 是有限的输入范围（但不是带有切片的随机访问范围），则 &lt;code&gt;sum&lt;/code&gt; 使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan求和&lt;/a&gt;算法。</target>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">如果 &lt;code&gt;FreeList&lt;/code&gt; 已使用 &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; 实例化，则 &lt;code&gt;max&lt;/code&gt; 属性是可写的。设置它必须在任何分配之前。</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">如果 &lt;code&gt;FreeList&lt;/code&gt; 已使用 &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; 实例化，则 &lt;code&gt;min&lt;/code&gt; 属性是可写的。设置它必须在任何分配之前。</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">如果 &lt;code&gt;Hook&lt;/code&gt; 定义了 &lt;code&gt;hookOpOpAssign&lt;/code&gt; ，则 &lt;code&gt;opOpAssign&lt;/code&gt; 会转发到 &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; ，其中 &lt;code&gt;payload&lt;/code&gt; 是对内部保留数据的引用，因此该挂钩可以更改它。</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">如果 &lt;code&gt;Hook&lt;/code&gt; 没有定义 &lt;code&gt;hookOpBinary&lt;/code&gt; 而是定义了 &lt;code&gt;onOverflow&lt;/code&gt; ， &lt;code&gt;opBinary&lt;/code&gt; 在发生溢出的情况下，opBinary会转发到 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Hook&lt;/code&gt; 没有定义 &lt;code&gt;hookOpUnary&lt;/code&gt; 而是定义了 &lt;code&gt;onOverflow&lt;/code&gt; ， &lt;code&gt;opUnary&lt;/code&gt; 在发生溢出的情况下，opUnary会转发到 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 。对于 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; ，有效载荷是从调用结果分配给 &lt;code&gt;onOverflow&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 保持状态，则 &lt;code&gt;parent&lt;/code&gt; 是 &lt;code&gt;KRRegion&lt;/code&gt; 类型的公共成员。否则， &lt;code&gt;parent&lt;/code&gt; 是一个 &lt;code&gt;alias&lt;/code&gt; 为 &lt;code&gt;ParentAllocator.instance&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 为&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt;，则仅定义接收 &lt;code&gt;data&lt;/code&gt; 的构造函数，并且如果需要，用户负责释放 &lt;code&gt;data&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 与&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt;不同，则 &lt;code&gt;Region&lt;/code&gt; 会在销毁期间取消分配内存块。</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;ParentAllocator&lt;/code&gt; 是有状态的，则 &lt;code&gt;parent&lt;/code&gt; 是允许访问 &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; 的属性。否则， &lt;code&gt;parent&lt;/code&gt; 是 &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">如果 &lt;code&gt;Prefix&lt;/code&gt; 为 &lt;code&gt;void&lt;/code&gt; ，则对齐方式是父级的对齐方式。否则，对齐方式与 &lt;code&gt;Prefix&lt;/code&gt; 的对齐方式相同。</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Prefix&lt;/code&gt; 不为 &lt;code&gt;void&lt;/code&gt; ，则 &lt;code&gt;Allocator&lt;/code&gt; 必须保证对齐至少与 &lt;code&gt;Prefix.alignof&lt;/code&gt; 一样大。</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">如果 &lt;code&gt;S&lt;/code&gt; 定义了一个析构函数，则为 &lt;code&gt;opAssign&lt;/code&gt; 生成的代码为：</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">如果 &lt;code&gt;S&lt;/code&gt; 没有postblit或de析构函数，但包含至少一个定义 &lt;code&gt;opAssign&lt;/code&gt; 函数的字段（未禁用），则主体将进行成员分配：</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;S&lt;/code&gt; 具有禁用的析构函数或至少一个字段具有禁用的 &lt;code&gt;opAssign&lt;/code&gt; ， &lt;code&gt;S.opAssign&lt;/code&gt; 生成 &lt;code&gt;@disable&lt;/code&gt; ，但标记为@disable</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">如果 &lt;code&gt;Source&lt;/code&gt; 与 &lt;code&gt;Targets&lt;/code&gt; &lt;code&gt;interface&lt;/code&gt; 具有结构上的一致性，则wrap将创建一个内部包装器类，该类将继承 &lt;code&gt;Targets&lt;/code&gt; 并包装 &lt;code&gt;src&lt;/code&gt; 对象，然后将其返回。</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Source&lt;/code&gt; 是一个正向范围，则所得范围也将是正向范围。否则，生成的块将成为使用相同输入的输入范围：在 &lt;code&gt;front&lt;/code&gt; 上进行迭代将缩小该块，以便后续对 &lt;code&gt;front&lt;/code&gt; 的调用将不再返回完整的块，并且在外部范围上调用 &lt;code&gt;popFront&lt;/code&gt; 将使对之前值的所有持久引用无效的 &lt;code&gt;front&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">如果使用 &lt;code&gt;StopWatch.init&lt;/code&gt; ，则构造的StopWatch不会运行（并且不能运行，因为没有构造函数运行）。</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Store&lt;/code&gt; 是一个范围，则 &lt;code&gt;BinaryHeap&lt;/code&gt; 不能超过该范围的大小。如果 &lt;code&gt;Store&lt;/code&gt; 是支持 &lt;code&gt;insertBack&lt;/code&gt; 的容器，则 &lt;code&gt;BinaryHeap&lt;/code&gt; 可能会通过向容器中添加元素来增长。</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是类类型，则返回对创建的 &lt;code&gt;T&lt;/code&gt; 对象的引用。否则，返回一个 &lt;code&gt;T*&lt;/code&gt; 指向创建的对象。在所有情况下，如果分配失败，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是嵌套结构，则 &lt;code&gt;T.init&lt;/code&gt; 中的上下文指针为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是具有 &lt;code&gt;@disable this();&lt;/code&gt; ， &lt;code&gt;T.init&lt;/code&gt; 可能返回逻辑上不正确的对象。</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是定义了析构函数或后遗污的结构，则将source 移入目标后将其重置为 &lt;code&gt;.init&lt;/code&gt; 值，否则将保持不变。</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是值类型，则将实现 &lt;code&gt;Unique!T&lt;/code&gt; 作为对 &lt;code&gt;T&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个内部类，其 &lt;code&gt;outer&lt;/code&gt; 字段可用于访问该封闭类的实例，则 &lt;code&gt;Args&lt;/code&gt; 不能为空，并且它的第一个成员必须是该 &lt;code&gt;outer&lt;/code&gt; 字段的有效初始化器。正确初始化此字段对于访问 &lt;code&gt;T&lt;/code&gt; 方法中外部类的成员至关重要。</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 的构造方法抛出，则释放分配的内存并传播异常。</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">如果 &lt;code&gt;U&lt;/code&gt; 也是 &lt;code&gt;Checked&lt;/code&gt; 的一个实例，则对方法 &lt;code&gt;hookOpCmp&lt;/code&gt; 内省两个钩子（左侧和右侧）。如果两者都定义，则优先级放在左侧。</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">如果 &lt;code&gt;U&lt;/code&gt; 也是 &lt;code&gt;Checked&lt;/code&gt; 的实例，则对方法 &lt;code&gt;hookOpEquals&lt;/code&gt; 的两个钩子（左侧和右侧）进行自省。如果两者都定义，则优先级放在左侧。</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">如果 &lt;code&gt;Yes.checkDns&lt;/code&gt; 则MX记录的DNS检查将进行</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">如果是 &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; ，则仅在不调用 &lt;code&gt;front&lt;/code&gt; 的情况下迭代范围就足以使 &lt;code&gt;tee&lt;/code&gt; 镜像元素输出到 &lt;code&gt;outputRange&lt;/code&gt; （或分别为 &lt;code&gt;fun&lt;/code&gt; ）。如果为 &lt;code&gt;No.pipeOnPop&lt;/code&gt; ，则仅会调用 &lt;code&gt;front&lt;/code&gt; 的元素也将发送到 &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; ，然后 &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 和叶 &lt;code&gt;a&lt;/code&gt; 不变的，而 &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; 进入 &lt;code&gt;a&lt;/code&gt; 以 &lt;code&gt;&quot;de&quot;&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; 和 &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; &lt;code&gt;bringToFront(a, b)&lt;/code&gt; ]，则BringToFront（a，b）留下 &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; 和 &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; 7、1、2、3 ]。</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; ，则 &lt;code&gt;reverse(a)&lt;/code&gt; 将其更改为 &lt;code&gt;[3, 2, 1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; &lt;code&gt;a = [double.init, double.init]&lt;/code&gt; ]，则 &lt;code&gt;initializeAll(a)&lt;/code&gt; 留下a = [double.init，double.init]。</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">如果 &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; 和 &lt;code&gt;b = [40, 6, 15]&lt;/code&gt; ，则 &lt;code&gt;completeSort(a, b)&lt;/code&gt; 留下 &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; 和 &lt;code&gt;b = [20, 30, 40]&lt;/code&gt; 。范围 &lt;code&gt;a&lt;/code&gt; 必须在调用之前进行排序，结果组合 &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; 进行了排序。</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">如果 &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; &lt;code&gt;partialSort(a, 3)&lt;/code&gt; ]，则partialSort（a，3）留下 &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; 。的其它元件 &lt;code&gt;a&lt;/code&gt; 被留在未指定的顺序。</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">如果 &lt;code&gt;allowDuplicates&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则多次插入同一元素将继续添加更多元素。如果为 &lt;code&gt;false&lt;/code&gt; ，则在插入时将忽略重复的元素。如果允许重复，则在所有现有重复元素之后插入新元素。</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">如果 &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; ，则不执行任何操作并返回 &lt;code&gt;false&lt;/code&gt; 。否则，销毁数组中最后一个 &lt;code&gt;arr.length - delta&lt;/code&gt; 元素，然后重新分配数组的缓冲区。如果重新分配失败，则使用默认初始化的数据填充阵列。</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">如果 &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; ，则不执行任何操作并返回 &lt;code&gt;false&lt;/code&gt; 。否则，销毁最后一个 &lt;code&gt;array.length - delta&lt;/code&gt; 数组中的delta元素，然后重新分配数组的缓冲区。如果重新分配失败，则使用默认初始化的数据填充阵列。</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">如果 &lt;code&gt;b is null&lt;/code&gt; ，则不执行任何操作并返回 &lt;code&gt;true&lt;/code&gt; 。否则，取消分配先前使用此分配器分配的内存，如果成功，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。一个不支持释放的实现（即始终返回 &lt;code&gt;false&lt;/code&gt; 的实现根本不应定义该原语。）</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">如果 &lt;code&gt;ba&lt;/code&gt; 为零（默认值），则现有内存的属性将用于分配。如果 &lt;code&gt;ba&lt;/code&gt; 不为零并且没有分配新的内存，则ba中的位将替换当前存储块的位。</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">如果 &lt;code&gt;block.length&lt;/code&gt; 在 &lt;code&gt;[min, max]&lt;/code&gt; 之内，或者未选中空闲列表（ &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ），则将块插入空闲列表的前面。对于所有的人，转发给 &lt;code&gt; parent.deallocate&lt;/code&gt; 如果 &lt;code&gt;Parent.deallocate&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">如果 &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; ，则 &lt;code&gt;BitmappedBlock&lt;/code&gt; 提供读/写属性 &lt;code&gt;blockSize&lt;/code&gt; 。必须在使用分配器之前将其设置。否则（即 &lt;code&gt;theBlockSize&lt;/code&gt; 是一个合法的常数）， &lt;code&gt;blockSize&lt;/code&gt; 是一个别名 &lt;code&gt;theBlockSize&lt;/code&gt; 。无论是常数还是变量，都必须是 &lt;code&gt;alignment&lt;/code&gt; 的倍数。这个约束是 &lt;code&gt;assert&lt;/code&gt; 版静态和动态。</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">如果 &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; ，则 &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 提供读/写属性 &lt;code&gt;blockSize&lt;/code&gt; 。必须在使用分配器之前将其设置。否则（即 &lt;code&gt;theBlockSize&lt;/code&gt; 是一个合法的常数）， &lt;code&gt;blockSize&lt;/code&gt; 是一个别名 &lt;code&gt;theBlockSize&lt;/code&gt; 。无论是常数还是变量，都必须是 &lt;code&gt;alignment&lt;/code&gt; 的倍数。这个约束是 &lt;code&gt;assert&lt;/code&gt; 版静态和动态。</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是Unicode小写&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;，则返回其大写形式。否则返回 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是Unicode大写&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;，则返回其小写字母。否则返回 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">如果 &lt;code&gt;dir == Direction.fwd&lt;/code&gt; ，则范围将在时间上向前迭代，而如果 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; ，则将在时间上向后迭代。因此，如果 &lt;code&gt;dir == Direction.fwd&lt;/code&gt; 则 &lt;code&gt;front == interval.begin&lt;/code&gt; ，而如果 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 则 &lt;code&gt;front == interval.end&lt;/code&gt; 。 &lt;code&gt;func&lt;/code&gt; 必须生成一个沿正确迭代方向的时间点，否则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。因此，要及时进行迭代， &lt;code&gt;func&lt;/code&gt; 生成的时间点必须晚于传递给它的时间点。如果时间相同或更早，&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;将被抛出。要向后迭代，则生成的时间点必须在传入的时间点之前。</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">如果 &lt;code&gt;filler&lt;/code&gt; 为空。</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;fun&lt;/code&gt; 是一个 &lt;code&gt;string&lt;/code&gt; ，一个新的单参数的函数如果 &lt;code&gt;fun&lt;/code&gt; 不是一个 &lt;code&gt;string&lt;/code&gt; ，别名 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;fun&lt;/code&gt; 不是字符串，则 &lt;code&gt;binaryFun&lt;/code&gt; 会将自己别名为 &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">如果 &lt;code&gt;hasLength!Range&lt;/code&gt; ，则仅返回 &lt;code&gt;range.length&lt;/code&gt; 而不检查 &lt;code&gt;upTo&lt;/code&gt; （如果指定）。</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;haystack&lt;/code&gt; 是随机访问范围，则该元组的所有三个组件都具有与 &lt;code&gt;haystack&lt;/code&gt; 相同的类型。否则， &lt;code&gt;haystack&lt;/code&gt; 必须为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围，&lt;/a&gt;并且 &lt;code&gt;result[0]&lt;/code&gt; 和 &lt;code&gt;result[1]&lt;/code&gt; 的类型与&lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;impl.alignedAllocate&lt;/code&gt; 存在，则调用它并返回结果。否则，始终返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">如果 &lt;code&gt;impl.deallocate&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt; 。否则，它将转接呼叫。</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">如果 &lt;code&gt;input&lt;/code&gt; 为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围&lt;/a&gt;， &lt;code&gt;needle&lt;/code&gt; 也可以为&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围&lt;/a&gt;。在这种情况下，每次评估都会对 &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; 进行评估。</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">如果 &lt;code&gt;less&lt;/code&gt; 是小于号运算符（这是默认选项），则 &lt;code&gt;BinaryHeap&lt;/code&gt; 定义所谓的max-heap，以优化提取操作。</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; 并且运算符没有溢出，则该函数返回的结果与内置运算符相同。在所有其他情况下，返回 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">如果 &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; ，则返回 &lt;code&gt;double.init&lt;/code&gt; 。否则，具有与默认比较相同的语义。</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">如果 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 引用相同的实例，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">如果 &lt;code&gt;line&lt;/code&gt; 类型为 &lt;code&gt;char[]&lt;/code&gt; ， &lt;code&gt;wchar[]&lt;/code&gt; ， &lt;code&gt;dchar[]&lt;/code&gt; ，则行的内容将在读取中重用（覆盖）。</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">如果 &lt;code&gt;line&lt;/code&gt; 的类型为 &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; ，则行为与情况（1）相似，不同之处在于在输入时未尝试进行UTF检查。</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">如果 &lt;code&gt;line&lt;/code&gt; 的类型为 &lt;code&gt;string&lt;/code&gt; ， &lt;code&gt;wstring&lt;/code&gt; 或 &lt;code&gt;dstring&lt;/code&gt; ，则每次读取都会分配相应类型的新字符串。</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">如果 &lt;code&gt;line&lt;/code&gt; 的类型为 &lt;code&gt;ubyte[]&lt;/code&gt; ，则行为与情况（2）相似，不同之处在于，在输入时不尝试进行UTF检查。</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">如果 &lt;code&gt;main()&lt;/code&gt; 或线程正常返回（不引发异常），则将静态析构函数添加到线程终止时要调用的函数列表中。</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">如果 &lt;code&gt;maxSize == unbounded&lt;/code&gt; ，则返回 &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; 。否则，返回 &lt;code&gt;max&lt;/code&gt; 为在间隔尺寸 &lt;code&gt;[min, max]&lt;/code&gt; ，和 &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; ，则该算法无效，并返回 &lt;code&gt;r[0 .. r.length]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 符合自由列表的资格，则返回 &lt;code&gt;max&lt;/code&gt; 。否则，返回 &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">如果未定义 &lt;code&gt;n&lt;/code&gt; ,则使用切片进行无限的随机访问。如果定义了 &lt;code&gt;n&lt;/code&gt; ,则为带切片的随机访问范围。</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">如果为该结构覆盖 &lt;code&gt;opCall&lt;/code&gt; ，并且使用不同类型的值初始化该结构，则将调用 &lt;code&gt;opCall&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">如果 &lt;code&gt;opIndex&lt;/code&gt; 只与一个说法宣称，编译时的参数 &lt;code&gt;opDollar&lt;/code&gt; 可以省略。在这种情况下，在带有多个参数的数组索引表达式中使用 &lt;code&gt;$&lt;/code&gt; 是非法的。</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是使用此分配器分配的块内某个地方的指针，则 &lt;code&gt;result&lt;/code&gt; 持有指向分配的块的开头的指针，并返回 &lt;code&gt;Ternary.yes&lt;/code&gt; 。否则， &lt;code&gt;result&lt;/code&gt; 保持 &lt;code&gt;null&lt;/code&gt; 并返回 &lt;code&gt;Ternary.no&lt;/code&gt; 。如果指针立即指向分配的块之后，则结果定义为实现。</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 是相对目录，请原样返回。</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 已经是绝对的，则将其返回。</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 为空，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 位于 &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; （UNC路径）上，则&lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt;将应用于</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 以 &lt;code&gt;\\.\&lt;/code&gt; （Win32设备名称空间）开头，则此函数返回 &lt;code&gt;false&lt;/code&gt; ；否则，返回false。这样的路径超出了本模块的范围。</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 以 &lt;code&gt;\\?\&lt;/code&gt; （长UNC路径）开头，则对字符串其余部分的唯一要求是它不包含空字符。</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">如果 &lt;code&gt;postData&lt;/code&gt; 为非null，则该方法将设置为 &lt;code&gt;post&lt;/code&gt; HTTP请求。</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">如果 &lt;code&gt;pretty&lt;/code&gt; 为假，则不会生成空格。如果 &lt;code&gt;pretty&lt;/code&gt; 是正确的，则将序列化的字符串格式化为易于阅读的格式。设置&lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; &lt;/a&gt;标志在 &lt;code&gt;options&lt;/code&gt; 设置，以将NaN / Infinity编码为字符串。</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;primary&lt;/code&gt; 不拥有 &lt;code&gt;b&lt;/code&gt; ，则尝试 &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; 。如果失败，则尝试将分配从 &lt;code&gt;fallback&lt;/code&gt; 移动到 &lt;code&gt;primary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">如果需要 &lt;code&gt;printf&lt;/code&gt; 样式的日志记录，请在日志记录调用中添加&lt;b&gt;f&lt;/b&gt;，例如 &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; 或 &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; 。函数名称后面附加的&lt;b&gt;f&lt;/b&gt;可以为显式 &lt;code&gt;LogLevel&lt;/code&gt; 和条件日志记录功能和方法的所有组合启用 &lt;code&gt;printf&lt;/code&gt; 样式的日志记录。</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 包含等效元素，则 &lt;code&gt;r&lt;/code&gt; 的多个排列满足这些约束。在这种情况下， &lt;code&gt;pivotPartition&lt;/code&gt; 会尝试在 &lt;code&gt;k&lt;/code&gt; 的左右均匀分配等效元素，以使 &lt;code&gt;k&lt;/code&gt; 保持在 &lt;code&gt;r.length / 2&lt;/code&gt; 附近。</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 具有长度，则为〇（ &lt;code&gt;1&lt;/code&gt; ）。否则，它是&amp;Omicron;（ &lt;code&gt;r.length&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 是其中包含Unicode字符的字符串，则 &lt;code&gt;padLeft&lt;/code&gt; 遵循D的关于字符串长度的规则，该规则不是字符或字素的数量，而是编码单位的数量。如果要将每个字素仅视为一个编码单位长，请在调用此函数之前调用&lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 不是可自动解码的字符串（即窄字符串或隐式转换为字符串类型的用户定义类型），则返回 &lt;code&gt;r&lt;/code&gt; 。否则， &lt;code&gt;r&lt;/code&gt; 将转换为其对应的字符串类型（如果还不是字符串），并包装在随机访问范围内，其中字符串的元素编码类型（其代码单元）是范围的元素类型，并且该范围回来。范围已切片。如果 &lt;code&gt;r&lt;/code&gt; 足够古怪到足以成为一个结构或类（其本身就是字符的输入范围）（即它具有输入范围API作为成员函数），</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;range&lt;/code&gt; 没有长度， &lt;code&gt;popFront&lt;/code&gt; 被调用时 &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; ，该指数将溢出，并从继续 &lt;code&gt;Enumerator.min&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">如果 &lt;code&gt;range&lt;/code&gt; 有长度，则传递 &lt;code&gt;start&lt;/code&gt; 的值以使 &lt;code&gt;start + range.length&lt;/code&gt; 大于 &lt;code&gt;Enumerator.max&lt;/code&gt; 是错误的，因此可以确保不会发生溢出。</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; 并且运算符没有溢出，则该函数返回的结果与内置运算符相同。在所有其他情况下，返回 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;rhs&lt;/code&gt; 是 &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; ，则返回 &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; 。否则，返回 &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">如果 &lt;code&gt;s == 0&lt;/code&gt; ，则调用可以返回任何空片（包括 &lt;code&gt;null&lt;/code&gt; ）。否则，该调用分配 &lt;code&gt;s&lt;/code&gt; 的内存字节并返回分配的块；如果无法满足请求，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">如果 &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; ，那么元素将从范围的末尾移至要填充的插槽中。在这种情况下，执行绝对最小移动。</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是函数模板，即模板的唯一成员，而该成员是函数，则返回该模板。</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">如果 &lt;code&gt;str&lt;/code&gt; 以 &lt;code&gt;delimiter&lt;/code&gt; 结尾，则返回 &lt;code&gt;str&lt;/code&gt; 时不带 &lt;code&gt;delimiter&lt;/code&gt; 。如果 &lt;code&gt;str&lt;/code&gt; 确实</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">如果 &lt;code&gt;str&lt;/code&gt; 以 &lt;code&gt;delimiter&lt;/code&gt; 开头，则返回 &lt;code&gt;str&lt;/code&gt; 在 &lt;code&gt;delimiter&lt;/code&gt; 之后的部分。如果 &lt;code&gt;str&lt;/code&gt; 确实</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">如果 &lt;code&gt;sz&lt;/code&gt; 为零，则p引用的内存将被释放，就像通过调用 &lt;code&gt;free&lt;/code&gt; 一样。如果 &lt;code&gt;p&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则将通过 &lt;code&gt;malloc&lt;/code&gt; 分配新的内存。如果 &lt;code&gt;p&lt;/code&gt; 指向未从GC分配的内存或已分配内存块的内部，则不执行任何操作，并返回null。</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">如果 &lt;code&gt;ticksPerSec&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，然后再 &lt;code&gt;TickDuration&lt;/code&gt; 未能获得价值 &lt;code&gt;ticksPerSec&lt;/code&gt; 当前系统上，并 &lt;code&gt;TickDuration&lt;/code&gt; 是行不通的。但是那将是非常异常的。</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">如果 &lt;code&gt;timeval.tv_sec&lt;/code&gt; 为int，并且结果不能适合int，则 &lt;code&gt;tv_sec&lt;/code&gt; 将使用可以保留在32位中的最接近的值。（因此 &lt;code&gt;int.max&lt;/code&gt; 如果超过， &lt;code&gt;int.min&lt;/code&gt; 如果超过）。</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">当 &lt;code&gt;opEquals&lt;/code&gt; 返回true 时，如果 &lt;code&gt;toHash&lt;/code&gt; 必须始终是相同的值。换句话说，被视为相等的两个对象应始终具有相同的哈希值。否则，将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">当 &lt;code&gt;opEquals&lt;/code&gt; 返回true 时，如果 &lt;code&gt;toHash&lt;/code&gt; 必须始终是相同的值。换句话说，被视为相等的两个结构应始终具有相同的哈希值。否则，将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">如果B到A的转换是convariant的,需要offseet调整,那么所有的返回语句都应该调整为返回A类型的表达式。</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">如果JSON值为null，则运算符使用object对其进行初始化，然后为其设置 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">如果Source是一个 &lt;code&gt;struct&lt;/code&gt; 则包装/展开将创建一个副本。不可能通过包装器影响原始 &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">如果声明</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">如果Targets只有一个条目，并且Source是显式实现它的类，则wrap仅返回上载到 &lt;code&gt;Targets[0]&lt;/code&gt; src 。</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">如果一个</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">如果提供了&lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt;，则这些字段将通过&lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt;语法进行初始化。</target>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">如果a和b都是类对象,那么表达式重写为。</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">如果请求 &lt;code&gt;onBadCast&lt;/code&gt; 转换为浮点类型并且 &lt;code&gt;Hook&lt;/code&gt; 定义onBadCast，则通过确保 &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; 来验证强制转换。如果不 &lt;code&gt;true&lt;/code&gt; ，则返回 &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">如果请求 &lt;code&gt;onBadCast&lt;/code&gt; 转换为整数类型并且 &lt;code&gt;Hook&lt;/code&gt; 定义onBadCast，则通过确保 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;cast(U) get&lt;/code&gt; 为相同的算术数来验证强制转换。（请注意， &lt;code&gt;int(-1)&lt;/code&gt; 和 &lt;code&gt;uint(1)&lt;/code&gt; 在算术上是不同的值，尽管它们具有相同的按位表示，并且通过语言规则进行比较是相等的。）如果数字在算术上不相等，则返回 &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">如果一个选择的返回类型是void,那么这个选择必须抛出一个异常,除非所有的选择都是void。在这种情况下,castSwitch本身将返回void。</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">如果一个构造函数的代码中包含一个委托构造函数的调用,那么通过该构造函数的所有可能的执行路径必须正好进行一次委托构造函数的调用。</target>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">如果定义了一个复制构造函数,那么在以下情况下将会插入对它的隐式调用。</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">如果声明后跟已记录的单元测试，则单元测试中的代码将插入到声明的&lt;b&gt;示例&lt;/b&gt;部分中：</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">如果一个声明以</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">如果通过了委托，则从 &lt;code&gt;Dg&lt;/code&gt; 的安全性和纯度推断出此功能的安全性和纯度。</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">如果将接受&lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt;的委托作为 &lt;code&gt;receive&lt;/code&gt; 的最后一个参数，则它将与早期委托未匹配的任何消息匹配。如果发送了多个参数，则 &lt;code&gt;Variant&lt;/code&gt; 将包含所有已发送值的&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">如果没有调用委托构造函数,则会对基类的默认构造函数发出调用。</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">如果派生类使用不同的&lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;覆盖基类成员函数，则缺少的属性将由编译器自动补偿。</target>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">如果声明的文档注释仅包含标识符 &lt;code&gt;ditto&lt;/code&gt; ,则在相同声明范围内的先前声明的文档注释也将应用于此声明。</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">如果一个字段的类型已经禁用了默认构造,那么它必须在构造函数中初始化。</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">如果浮动文字具有&lt;b&gt;。&lt;/b&gt;和类型后缀，中间必须至少有一个数字：</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">如果&lt;b&gt;i&lt;/b&gt;跟随浮点文字，则它是一个</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">如果一个函数试图测试自己的这些属性,那么该函数被推断为不具备这些属性。</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">如果函数调用未传递任何显式参数，即在语法上使用 &lt;code&gt;()&lt;/code&gt; ，则可以省略这些括号，类似于对&lt;a href=&quot;#property-functions&quot;&gt;属性函数&lt;/a&gt;的getter调用。</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">如果派生类中的函数从其超类中覆盖某个函数，则仅必须满足该函数及其基本函数的 &lt;code&gt;in&lt;/code&gt; 协定之一。覆盖功能然后成为一个过程</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">如果一个函数返回一个委托或函数指针,如果返回的值要被调用,则需要使用parantheses。</target>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">如果指定了一个带有非类型参数的函数,当变体包含的类型与其他函数不匹配时,就会调用这个函数。这可以用来将同一个函数应用于多个可能的类型。只允许使用一个通用函数。</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">如果指定了不带参数的函数，则当 &lt;code&gt;variant&lt;/code&gt; 不包含值时调用此函数。仅允许一个无参数功能。</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">如果使用返回自定义处理程序的旧式布尔值，则 &lt;code&gt;false&lt;/code&gt; 映射到 &lt;code&gt;UnitTestResult.fail&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 映射到 &lt;code&gt;UnitTestResult.pass&lt;/code&gt; 。这是单元测试系统的原始行为。</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">如果库例程无法处理 &lt;code&gt;TypedefType&lt;/code&gt; 类型，则可以使用TypedefType模板提取Typedef包装的类型。</target>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">如果一个混料有一个</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">如果一个模块C导入模块A和B,那么对B的任何修改都不会默默改变C中依赖A的代码。</target>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">如果嵌套类具有 &lt;code&gt;static&lt;/code&gt; 属性，则它不能访问堆栈本地的封闭范围的变量或需要 &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">如果一个选项是必需的,不通过它将导致一个错误</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">如果指定了无参数函数，则当任一 &lt;code&gt;variant&lt;/code&gt; 不包含值或访问函数无法处理的类型时，将调用该函数。</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">如果一个指针包含一个</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">如果一个属性函数没有参数,它作为一个getter工作。如果只有一个参数,则作为一个设定器工作。</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">如果省略协议名称,任何协议都会被匹配。</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;map&lt;/code&gt; 或 &lt;code&gt;asyncBuf&lt;/code&gt; 返回的范围用作 &lt;code&gt;map&lt;/code&gt; 的输入，则作为优化操作，即使 &lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;asyncBuf&lt;/code&gt; 返回的范围也避免了从第一个范围的输出缓冲区到第二个范围的输入缓冲区的复制是非随机访问范围。这意味着传递给当前对 &lt;code&gt;map&lt;/code&gt; 的调用的 &lt;code&gt;bufSize&lt;/code&gt; 参数将被忽略，缓冲区的大小将是 &lt;code&gt;source&lt;/code&gt; 的缓冲区大小。</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">如果分片运算符作为赋值表达式的左手边出现,且右手边的类型与左手边的元素类型相同,那么左手边的数组内容被设置为右手边。</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">如果一个强纯函数抛出了异常或错误,那么与备忘录和引用相关的假设不会带入抛出的异常。</target>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">如果一个表达式的子表达式抛出异常,那么直到该子表达式的评估之前所创建的所有时态都将按照上述规则被销毁。对于尚未构造的临时变量,将不会发出任何破坏器调用。</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">如果模板参数与专用模板参数匹配，则参数以前缀&lt;b&gt;H&lt;/b&gt;修饰。</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">如果一个模板包含的成员名称与模板标识符相同,并且如果这些成员的类型或参数类型至少包括所有的模板参数,那么这些成员被认为在模板实例化中被引用。</target>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">如果一个模板正好声明了一个成员,而且这个成员是一个与模板同名的类。</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">如果模板仅声明一个成员，并且该成员是一个与模板同名的函数，则它是一个函数模板声明。另外，函数模板声明是在&lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters的&lt;/i&gt;&lt;/a&gt;紧前面带有&lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;的函数声明。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">如果模板具有&lt;a href=&quot;#aliasparameters&quot;&gt;模板别名参数&lt;/a&gt;，并使用本地符号实例化，则实例化的函数将隐式嵌套，以访问给定本地符号的运行时数据。</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">如果一个模板是在集合或函数局部作用域中声明的,那么实例化的函数将隐式地捕获包围作用域的上下文。</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">如果一个变量有一个作用域的析构器调用,返回它的调用。否则,返回NULL。</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">如果在检查完所有类型参数后,还有任何类型参数没有被分配类型,它们就会被分配类型,对应于模板参数在</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">如果是同一个对象的别名，或者两者均为null =&amp;gt;等于</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">如果是 &lt;code&gt;auto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;enum&lt;/code&gt; 用作类型，则从枚举 &lt;code&gt;E&lt;/code&gt; 的任何可能值中随机抽取随机变量。</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">如果聚合声明定义了 &lt;code&gt;opCmp&lt;/code&gt; 或 &lt;code&gt;opEquals&lt;/code&gt; 方法，它将优先于该成员的别名。请注意，与 &lt;code&gt;opCmp&lt;/code&gt; 方法不同，如果未提供用户定义的声明，则会为 &lt;code&gt;struct&lt;/code&gt; 声明隐式定义 &lt;code&gt;opEquals&lt;/code&gt; 方法。这意味着，如果首选别名 &lt;code&gt;opEquals&lt;/code&gt; 成员，则应明确定义：</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">如果附加必须重新分配没有扩展可能性的片，则返回 &lt;code&gt;0&lt;/code&gt; 。当切片引用静态数组或另一个切片引用当前切片末尾的元素时，会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">如果应用程序需要自己处理 &lt;code&gt;getopt&lt;/code&gt; 不理解的参数，则可以将 &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; 指令传递给 &lt;code&gt;getopt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">如果一个枚举的基本类型是左列中的一个类型,那么它将被转换为右列中的类型。</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">如果在编译程序的过程中出现了错误,需要重新检查相关类中的重载和重载的使用情况。</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">如果在</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">如果抛出异常，但有空消息，则返回 &lt;code&gt;emptyExceptionMsg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">如果相同类型到 &lt;code&gt;type&lt;/code&gt; 是在 &lt;code&gt;type.stringtable&lt;/code&gt; ，返回后者。否则，将其添加到 &lt;code&gt;type.stringtable&lt;/code&gt; 。某些类型不会合并，而是按原样返回。</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">如果需要并且不存在身份分配过载，则将自动生成类型为 &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; 的身份分配过载函数。</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">如果表不允许隐式转换，则在以下情况下可以转换&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;表达式&lt;/i&gt;&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">如果可以使用 &lt;code&gt;opIndexAssign&lt;/code&gt; 或 &lt;code&gt;opIndexOpAssign&lt;/code&gt; 重写索引表达式，则优先于 &lt;code&gt;opIndex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">如果接口具有 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;immutable&lt;/code&gt; 存储类，则该接口的所有成员都是 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;immutable&lt;/code&gt; 。此存储类未继承。</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">如果一个选项绑定了一个数字类型,那么下一个选项就是一个数字,或者就在选项中用&quot;=&quot;号隔开。</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">如果一个选项被绑定到一个字符串上,那么下一个选项就是一个字符串,或者就在选项中用&quot;=&quot;号隔开。</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">如果一个选项被绑定到一个数组上,每次选项发生时都会有一个新的元素附加到数组中。</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">如果一个选项被绑定到一个关联数组,那么下一个选项将是一个 &quot;name=value &quot;形式的字符串,或者就在选项中用&quot;=&quot;号分隔。</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">如果一个选项被绑定到一个枚举中,那么作为字符串的枚举符号将作为下一个选项,或者就在选项中用&quot;=&quot;号分隔。</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">如果一个选项名的后缀是 &quot;+&quot;,并且绑定了一个数字类型,那么该选项的值就会跟踪该选项在命令行中出现的次数。</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">如果选项字符串后接另一个字符串，则此字符串将用作此选项的描述。该 &lt;code&gt;getopt&lt;/code&gt; 的函数返回类型的结构 &lt;code&gt;GetoptResult&lt;/code&gt; 。此返回值包含有关所有传递的选项的信息以及指示是否请求有关这些选项的信息的 &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; 标志。该 &lt;code&gt;getopt&lt;/code&gt; 的功能总是增加了一个选项 &lt;code&gt;--help|-h&lt;/code&gt; 如果选项出现在命令行上设置的标志。</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">如果任何具有非守护线程的 &lt;code&gt;TaskPool&lt;/code&gt; 处于活动状态，则必须先在其上调用 &lt;code&gt;stop&lt;/code&gt; 或 &lt;code&gt;finish&lt;/code&gt; ，然后程序才能终止。</target>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">如果任何字段的默认构造被禁用,则结构的默认构造也被禁用。</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">如果 &lt;code&gt;lead&lt;/code&gt; 和 &lt;code&gt;vowel&lt;/code&gt; 中的任何一个不是相应&lt;a href=&quot;#Character&quot;&gt;字符&lt;/a&gt;类的有效韩文字母，则返回dchar.init。</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">如果&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;中的任何&lt;i&gt;参数&lt;/i&gt;是一个</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">如果任何一项检查失败,就会出现编译错误。</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">如果任何一个键或值在</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">如果应用上述规则,每个模板参数的类型不完全相同,那么就是一个错误。</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">如果启用了断言并且已调用 &lt;code&gt;toRange&lt;/code&gt; ，则此WorkerLocalStorage实例不再是本地工作器，并且在调用此方法时将导致断言失败。如果出于性能原因禁用了断言，则不会进行检查。</target>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">如果范围中的至少一个是多集，那么将考虑重复元素的所有出现。结果等同于合并所有输入范围并选择最高的 &lt;code&gt;tgt.length&lt;/code&gt; （基于权重）的排名元素。</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">如果进行了认证或重定向,那么状态将为最后收到的响应。</target>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">如果blocking参数为true，请等待所有辅助线程终止后再返回。此选项可用于从不消耗任务结果的应用程序中-例如，当 &lt;code&gt;TaskPool&lt;/code&gt; 用作通过返回值以外的方式进行通信的任务的基本计划程序时。</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Primary&lt;/code&gt; 和 &lt;code&gt;Fallback&lt;/code&gt; 均为无状态，则 &lt;code&gt;FallbackAllocator&lt;/code&gt; 定义一个称为 &lt;code&gt;instance&lt;/code&gt; 的静态实例。</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都是整数（可以是恒定折叠的），则切片表达式可以转换为静态数组类型 &lt;code&gt;T[b - a]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">如果带序列参数的模板和不带序列参数的模板都完全匹配一个模板实例化,那么不带</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">如果两个分配器都 &lt;code&gt;shared&lt;/code&gt; ，则 &lt;code&gt;Segregator&lt;/code&gt; 还将提供 &lt;code&gt;shared&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">如果两者都是有符号的,或者两者都是无符号的,那么较小的类型将被转换为较大的类型。</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">如果两者类型相同,则不再进行转换。</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">如果两个参数都是相同类型的L值的范围，则 &lt;code&gt;SetSymmetricDifference&lt;/code&gt; 也将是该类型的L值的范围。</target>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">如果两个操作数均为整数类型，并且在计算中发生上溢或下溢，则会发生换行。也就是说， &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; 和 &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">如果两个操作数都是指针，并且运算符是 &lt;code&gt;+&lt;/code&gt; ，则它是非法的。</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">如果两个操作数都是指针，并且运算符是 &lt;code&gt;-&lt;/code&gt; ，则将指针减去，结果除以操作数所指向的类型的大小。在此计算中， &lt;code&gt;void&lt;/code&gt; 的假定大小为一个字节。如果指针指向不同的类型，则会出错。结果的类型为 &lt;code&gt;ptrdiff_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">如果两个范围都是有限的，那么一个必须（至少）是一个&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;正向范围&lt;/a&gt;，另一个必须是&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">如果两个范围都是无限的,那么两个范围一定是正向范围。</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">如果两个范围都是集合（没有重复的元素），则结果范围将是一个集合。如果范围中的至少一个是多集，元素的出现次数的数量 &lt;code&gt;x&lt;/code&gt; 在所得范围是 &lt;code&gt;abs(a-b)&lt;/code&gt; ，其中 &lt;code&gt;a&lt;/code&gt; 是OCCURENCES的数目 &lt;code&gt;x&lt;/code&gt; 中 &lt;code&gt;r1&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 是OCCURENCES的数目 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;r2&lt;/code&gt; ，而 &lt;code&gt;abs&lt;/code&gt; 是绝对值。</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">如果两个范围都具有长度成员，则此函数为&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）。否则，此函数为&amp;Omicron;（ &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">如果x和n都是0,结果是1,如果n是负数,无论x的值是多少,运行时都会出现整数除法错误。</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">如果中断之后是</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">如果开启了类不变量检查,则在构造函数的最后调用类不变量。</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">如果代码检测到&amp;ldquo;内存不足&amp;rdquo;之类的错误，则会引发错误，并显示一条消息&amp;ldquo;内存不足&amp;rdquo;。解开函数调用堆栈，为错误查找处理程序。&lt;a href=&quot;statement#TryStatement&quot;&gt;最后&lt;/a&gt;，随着堆栈的展开，执行块。如果找到错误处理程序，则从那里继续执行。如果不是，则运行默认的错误处理程序，该处理程序将显示消息并终止程序。</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">如果继续之后是</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">如果已定义，并且 &lt;code&gt;hookOpCast&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">如果定义，则 &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; 用作有效负载的默认初始化程序。</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">如果定义， &lt;code&gt;Hook.max!T&lt;/code&gt; 用作有效负载的最大值。</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">如果定义， &lt;code&gt;Hook.min!T&lt;/code&gt; 用作有效负载的最小值。</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果已定义， &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; （其中 &lt;code&gt;op&lt;/code&gt; 是运算符，而 &lt;code&gt;rhs&lt;/code&gt; 是右侧操作数）对于二进制运算符 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;^^&lt;/code&gt; ，将无条件转发。 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果已定义， &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; （其中 &lt;code&gt;op&lt;/code&gt; 是运算符， &lt;code&gt;lhs&lt;/code&gt; 是左侧操作数）将无条件转发给二进制运算符 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;^^&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">如果已定义，则在将有效载荷转换为类型 &lt;code&gt;U&lt;/code&gt; 时， &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; 将无条件转发到。</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">如果定义了 &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; 则在比较有效负载以对整数，浮点或布尔类型的值 &lt;code&gt;rhs&lt;/code&gt; 进行排序时，将无条件转发到hook.hookOpCmp（get，rhs）。</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">如果已定义，则在将有效负载与整数，浮点或布尔类型的值 &lt;code&gt;rhs&lt;/code&gt; 比较相等性时，将无条件地将 &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; 转发至。</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">如果已定义， &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; （其中 &lt;code&gt;op&lt;/code&gt; 是运算符，而 &lt;code&gt;rhs&lt;/code&gt; 是右侧操作数）对于二进制运算符 &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; ， &lt;code&gt;*=&lt;/code&gt; ， &lt;code&gt;/=&lt;/code&gt; ， &lt;code&gt;%=&lt;/code&gt; ， &lt;code&gt;^^=&lt;/code&gt; ， &lt;code&gt;&amp;amp;=&lt;/code&gt; ， &lt;code&gt;|=&lt;/code&gt; ， &lt;code&gt;^=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">如果已定义， &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; 一元运算符 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 转发给hook.hookOpUnary！op（get）（其中 &lt;code&gt;op&lt;/code&gt; 是运算符）。此外，对于一元运算符 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; ，将 &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; ，其中 &lt;code&gt;payload&lt;/code&gt; 是对 &lt;code&gt;Checked&lt;/code&gt; 包装的值的引用，以便挂钩可以对其进行更改。</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">如果已定义，则在对Checked类型调用 &lt;code&gt;toHash&lt;/code&gt; 时， &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; （ &lt;code&gt;payload&lt;/code&gt; 是对Checked包装的值的引用）转发给它。可以在 &lt;code&gt;Hook&lt;/code&gt; 中实现自定义哈希，否则将使用内置哈希。</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果已定义，则在二元运算符 &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; ， &lt;code&gt;*=&lt;/code&gt; ， &lt;code&gt;/=&lt;/code&gt; ， &lt;code&gt;%=&lt;/code&gt; ， &lt;code&gt;^^=&lt;/code&gt; ， &lt;code&gt;&amp;amp;=&lt;/code&gt; 的结果时，将 &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; （其中 &lt;code&gt;value&lt;/code&gt; 是要分配的值）转发到， &lt;code&gt;|=&lt;/code&gt; ， &lt;code&gt;^=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 小于 &lt;code&gt;T&lt;/code&gt; 表示的最小值。</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">如果已定义， &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 转发给溢出的一元运算符，但 &lt;code&gt;hookOpUnary&lt;/code&gt; 是未定义hookOpUnary。一元 &lt;code&gt;~&lt;/code&gt; 不溢出；一元 &lt;code&gt;-&lt;/code&gt; 仅当否定签名类型的最负值并返回挂钩调用的结果时才溢出。当递增或递减运算符溢出时， &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 有效载荷分配给hook.onOverflow！op（get）的结果。当二进制运算符溢出时，将返回 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; 的结果，但前提是 &lt;code&gt;Hook&lt;/code&gt; 没有定义 &lt;code&gt;hookOpBinary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果已定义，则在二元运算符 &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; ， &lt;code&gt;*=&lt;/code&gt; ， &lt;code&gt;/=&lt;/code&gt; ， &lt;code&gt;%=&lt;/code&gt; ， &lt;code&gt;^^=&lt;/code&gt; ， &lt;code&gt;&amp;amp;=&lt;/code&gt; 的结果时，将 &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; （其中 &lt;code&gt;value&lt;/code&gt; 是所分配的值）转发到， &lt;code&gt;|=&lt;/code&gt; ， &lt;code&gt;^=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 大于 &lt;code&gt;T&lt;/code&gt; 表示的最大值。</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">如果e是一个SliceExp,恒定的折叠它。</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">如果e1是一个属性函数(模板),则解析它。</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">如果其中一个为null =&amp;gt; non-equal</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">如果其中一个操作数为 &lt;code&gt;real&lt;/code&gt; ，则另一个操作数将转换为 &lt;code&gt;real&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">如果一个操作数是浮点类型，则另一个将被隐式转换为浮点，然后通过&amp;ldquo; &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;常规算术转换&amp;rdquo;&lt;/a&gt;将它们转换为通用类型。</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">如果第二个或第三个表达式的类型为 &lt;code&gt;void&lt;/code&gt; ，则结果类型为 &lt;code&gt;void&lt;/code&gt; 。否则，第二和第三表达式将隐式转换为通用类型，该通用类型成为条件表达式的结果类型。</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">如果表达式可以测试真或假,则返回修改后的表达式,否则返回ErrorExp。否则返回ErrorExp。</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">如果表达式是共享的,检查我们是否可以访问它。如果不能,则给出错误信息。</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">如果将标志 &lt;code&gt;KeepTerminator&lt;/code&gt; 设置为 &lt;code&gt;KeepTerminator.yes&lt;/code&gt; ，则分隔符将包含在返回的字符串中。</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">如果找到了,返回它是的列表条目,否则为空。</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果func生成的时间点大于或等于该范围的当前 &lt;code&gt;front&lt;/code&gt; ，则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">如果func生成的时间点大于或等于该范围的当前 &lt;code&gt;front&lt;/code&gt; ，则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。当func生成等于或小于间隔 &lt;code&gt;begin&lt;/code&gt; 的时间点时，该范围将为空且迭代完成。</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">如果func生成的时间点小于或等于该范围的当前 &lt;code&gt;front&lt;/code&gt; ，则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">如果func生成的时间点小于或等于该范围的当前 &lt;code&gt;front&lt;/code&gt; ，则将引发&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;。当func生成一个等于或超过间隔 &lt;code&gt;end&lt;/code&gt; 的时间点时，该范围将为空且迭代完成。</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">如果func保留状态被更改的状态，那么某些算法将无法正常工作，因为范围的 &lt;code&gt;save&lt;/code&gt; 将无法真正保存范围的状态。为了避免此类错误，请不要传递对 &lt;code&gt;fwdRange&lt;/code&gt; 逻辑上不纯的委托。如果通过两个不同的调用为func提供了相同的时间点，则必须两次都返回相同的结果。当然，该模块中的所有功能都没有此问题，因此仅与自定义委托相关。</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">如果func保留状态被更改的状态，那么某些算法将无法正常工作，因为范围的 &lt;code&gt;save&lt;/code&gt; 将无法真正保存范围的状态。为了避免此类错误，请不要传递对 &lt;code&gt;fwdRange&lt;/code&gt; 逻辑上不纯的委托。如果通过两个不同的调用为func提供了相同的时间点，则必须两次都返回相同的结果。当然，该模块中的所有功能都没有此问题，因此仅在创建自定义委托时才有意义。</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">如果函数是基类中的函数,则返回该基类。</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">如果在引号字段中,任何引号本身,而不是在字段的末尾,将结束该字段的处理。</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">如果用 &lt;code&gt;No.multiblock&lt;/code&gt; 实例化，它将搜索位图中的第一个零位并将其设置。</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">如果isNested()返回true,isThis()应该返回false,除非函数需要一个双上下文指针。</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则对第三个表达式求值，其结果是条件表达式的结果。</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">如果为 &lt;code&gt;true&lt;/code&gt; ，则对第二个表达式求值，其结果是条件表达式的结果。</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">如果希望将 &lt;code&gt;Unique!T&lt;/code&gt; 保留在其原始范围之外，则可以将其转移。从函数返回Unique时，可以通过调用 &lt;code&gt;release&lt;/code&gt; 来显式传输，也可以隐式进行。资源 &lt;code&gt;T&lt;/code&gt; 可以是多态类对象或接口实例，在这种情况下，Unique也具有多态行为。</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">如果只是给定类型T,而没有给定变量v,那么仍然会执行catch子句。</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">如果多个模板具有相同的</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">如果没有给出 &lt;code&gt;delimiter&lt;/code&gt; ，则尾随一个 &lt;code&gt;'\r'&lt;/code&gt; ， &lt;code&gt;'\n'&lt;/code&gt; ， &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; ， &lt;code&gt;'\f'&lt;/code&gt; ， &lt;code&gt;'\v'&lt;/code&gt; ，&lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt;从 &lt;code&gt;str&lt;/code&gt; 的末尾删除。如果 &lt;code&gt;str&lt;/code&gt; 不以这些字符中的任何一个结尾，则将其原样返回。</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">如果没有提供 &lt;code&gt;needle&lt;/code&gt; ，则将在输入范围的每个元素上评估 &lt;code&gt;pred(haystack.front)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">如果没有通过 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;super&lt;/code&gt; 的构造函数调用出现在构造函数中，并且基类具有构造函数，则在构造函数的开头插入对 &lt;code&gt;super()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">如果没有针对错误的捕获处理程序,那么程序将通过默认的错误处理程序优雅地退出,并提供适当的消息。</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">如果没有找到循环,ctors和tlsctors就会被这个算法生成的循环取代,以保留旧的不正确排序行为。</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">如果没有数据可用，并且主线程访问该范围，它将阻塞直到数据可用。一个例外是&lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; &lt;/a&gt;上的 &lt;code&gt;wait(Duration)&lt;/code&gt; 方法。此方法将最大等待指定的持续时间，如果有数据，则返回true。</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">如果没有数据可用，并且主线程访问该范围，它将阻塞直到数据可用。&lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; &lt;/a&gt;上的 &lt;code&gt;wait(Duration)&lt;/code&gt; 方法是一个例外。此方法将最大等待指定的持续时间，如果有数据，则返回true。</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">如果没有提供明确的种子,每个工作单元的第一个元素被用作种子。在最后的还原中,第一个工作单元的结果被用作种子。</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">如果未指定要调用的函数，则 &lt;code&gt;each&lt;/code&gt; 函数默认不执行任何操作，仅消耗整个范围。将评估 &lt;code&gt;r.front&lt;/code&gt; ，但是可以通过指定带有 &lt;code&gt;lazy&lt;/code&gt; 参数的lambda来避免。</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">如果没有提供针，那么只要 &lt;code&gt;pred&lt;/code&gt; 评估为 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;haystack&lt;/code&gt; 就会前进。同样，将干草堆放置在适当的位置，以便 &lt;code&gt;pred&lt;/code&gt; 对 &lt;code&gt;haystack.front&lt;/code&gt; 的求值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">如果没有随机数生成器传递给 &lt;code&gt;randomCover&lt;/code&gt; ，则将在内部使用线程全局RNG rndGen。</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">如果没有传递任何分隔符，则谓词 &lt;code&gt;isTerminator&lt;/code&gt; 决定是否接受 &lt;code&gt;r&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">如果未注册任何单元测试自定义处理程序，则将执行以下算法（该行为可能受下面的 &lt;code&gt;--DRT-testmode&lt;/code&gt; 开关影响）：1.运行所有单元测试，跟踪已执行的测试并通过。对于每个失败的对象，打印堆栈跟踪，然后继续。2.如果没有失败，请将summary标志设置为false，将runMain标志设置为true。3.如果存在故障，请将summary标志设置为true，将runMain标志设置为false。</target>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">如果不为零,则在结果前加上0x (0X)。</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">如果案例表达式都不匹配,且有缺省语句,则缺省语句转移到。</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">如果所有选项都不匹配，将引发 &lt;code&gt;SwitchError&lt;/code&gt; 。如果并非所有选择都无效，并且执行了无效选择而没有抛出任何内容，则也会引发 &lt;code&gt;SwitchError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">如果没有指定,则</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">如果一个比另一个更匹配,或者一个能编译而另一个不能,则选择第一个。</target>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">如果其中一个参数是NaN,则返回另一个参数。</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">如果一个数字是整数，另一个数字是浮点数，则且仅当可以将整数精确地（不近似地）转换为浮点数时， &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。这是为了保留相等性的传递性：如果 &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; 和 &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; 则 &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; ，如果 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 是整数和浮点数的混合。</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果一个数字是整数，另一个数字是浮点数，则 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 返回一个浮点数，如果 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 则为 &lt;code&gt;-1&lt;/code&gt; ，如果 &lt;code&gt;x == y&lt;/code&gt; 则为 &lt;code&gt;0&lt;/code&gt; ，如果 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 则为 &lt;code&gt;1&lt;/code&gt; y和 &lt;code&gt;NaN&lt;/code&gt; (如果浮点数为 &lt;code&gt;NaN&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">如果一个操作数是一个枚举,另一个是该枚举的基本类型,那么结果就是基本类型。</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">如果操作数类型中的一个或两个都是枚举,在经过上述转换后,结果类型是。</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">如果一个或两个操作数都是浮点,则进行浮点比较。</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">如果一个范围是无限的,另一个范围是有限的,那么有限的范围一定是一个正向范围,无限的范围可以是一个输入范围。</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">如果为 &lt;code&gt;Chain&lt;/code&gt; 或 &lt;code&gt;chain&lt;/code&gt; 仅提供一个范围，则 &lt;code&gt;Chain&lt;/code&gt; 类型通过直接将自身别名为该范围的类型来退出图片。</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">如果仅传递一种类型，则该类型的数组。否则，返回一个&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;数组。</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">如果操作数是积分类型</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果需要重叠，请使用&lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">如果为类覆盖 &lt;code&gt;Object.opEquals()&lt;/code&gt; ，则类成员函数签名应类似于：</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">如果为类覆盖 &lt;code&gt;Object.opCmp()&lt;/code&gt; ，则类成员函数签名应类似于：</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">如果p为空,则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">如果paramsym为空,则使用一个新的ScopeDsymbol代替paramsym。</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">如果传递的是一个码点范围,则返回一个具有同等能力的范围。</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">如果将指向D垃圾收集器分配的内存的指针传递给C函数,那么确保该内存在C函数处理完之前不会被垃圾收集器收集是至关重要的。这是通过以下方式实现的。</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">如果将D垃圾收集器堆上分配的内存的指针传递给C++函数,那么确保被引用的内存在C++函数处理完之前不会被D垃圾收集器收集是至关重要的。这是通过以下方式实现的。</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">如果可能,将数组初始化器转换为关联数组初始化器。</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">如果存在,则</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">如果range是字节范围，则在相应Base64编码的字节上迭代的 &lt;code&gt;Encoder&lt;/code&gt; 。如果range是字节范围的范围，则在该范围的每个元素的Base64编码的字符串上迭代的 &lt;code&gt;Encoder&lt;/code&gt; 。在这两种情况下，返回的 &lt;code&gt;Encoder&lt;/code&gt; 将是一个&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前进档&lt;/a&gt;如果给定的 &lt;code&gt;range&lt;/code&gt; 是至少一个前进档，否则将只输入范围。</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">如果range是字符范围，则在相应Base64解码的字节上迭代的 &lt;code&gt;Decoder&lt;/code&gt; 。如果range是字符范围的范围，则 &lt;code&gt;Decoder&lt;/code&gt; 将迭代与该范围的每个元素相对应的解码字符串。在这种情况下，每个子范围的长度必须是4的倍数；返回的解码器不会跨子范围边界跟踪Base64解码状态。在这两种情况下，返回的 &lt;code&gt;Decoder&lt;/code&gt; 将是一个&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前进档&lt;/a&gt;如果给定的 &lt;code&gt;range&lt;/code&gt; 是至少一个前进档，否则将只输入范围。如果输入数据包含在当前Base64编码方案的基本字母中找不到的字符，则返回的范围可能会引发 &lt;code&gt;Base64Exception&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">如果相同的确切类型=&amp;gt;调用方法opEquals</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">如果在运行时设置，则必须适当地初始化 &lt;code&gt;min&lt;/code&gt; 和/或 &lt;code&gt;max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">如果在运行时设置，则必须适当地初始化 &lt;code&gt;min&lt;/code&gt; 和/或 &lt;code&gt;max&lt;/code&gt; 。必须已使用此空闲列表分配了该块，并且不允许在分配和释放之间进行 &lt;code&gt;min&lt;/code&gt; 或 &lt;code&gt;max&lt;/code&gt; 动态更改。</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">如果设置为 &lt;code&gt;AllowDayOverflow.no&lt;/code&gt; ，则不允许日溢出。</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">如果设置为 &lt;code&gt;AutoStart.no&lt;/code&gt; ，则秒表在构造时不会启动。</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">如果设置为 &lt;code&gt;AutoStart.no&lt;/code&gt; ，则秒表在构造时不会启动。</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">如果设置为 &lt;code&gt;CheckDns.no&lt;/code&gt; ，则isEmail不执行DNS检查。</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">如果设置为 &lt;code&gt;OpenRight.yes&lt;/code&gt; ，则间隔向右打开（不包括最后一个元素）。</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">如果设置为 &lt;code&gt;PopFirst.no&lt;/code&gt; ，则在返回范围之前不会调用popFront。</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">如果设置为 &lt;code&gt;SortOutput.no&lt;/code&gt; ，则不应对输出进行排序。</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">如果设置，则0是唯一允许的&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;IEEE754非规范化&lt;/a&gt;数字。需要allowDenorm和storeNormalized。</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">如果设置，请选择一个指数偏差，以使max_exp = 1，即，使最大值&amp;gt; = 1.0且&amp;lt;2.0。忽略是否​​手动指定指数偏差。</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">如果设置,无符号自定义浮动被假定为负值。</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">如果不可避免要依赖大小，则在代码中放置一个 &lt;code&gt;static assert&lt;/code&gt; 以进行验证：</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">如果其中一些字段不是NULL,则是指向b_data的指针。</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">如果source有指向自己的内部指针,且没有定义opPostMove,则不能移动,会触发断言失败。</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">如果source内部有指向自己的指针,就不能移动,会触发断言失败。</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">如果需要在空白处分割字符串并进行令牌压缩，请考虑使用 &lt;code&gt;splitter&lt;/code&gt; 而不指定分隔符。</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">如果启用了数据分割传输,那么在单个数据块下载完成后会调用该回调。注意!当这个回调被设置后,它必须对所有的数据块进行调用。当这个回调被设置后,它必须为所有的chunks被调用,即使在CHUNK_BGN_FUNC中跳过了这个chunk的下载。即使在CHUNK_BGN_FUNC中跳过了这个分块的下载。这就是为什么我们在这个回调中不需要 &quot;transfer_info &quot;参数,也不需要 &quot;re remains &quot;参数的原因。</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">If语句提供了简单的条件执行语句。</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">如果struct构造函数使用 &lt;code&gt;@disable&lt;/code&gt; 注释并且具有空的&lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;，则该结构将禁用默认构造。构造它的唯一方法是通过调用另一个非空的构造函数</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">如果开启了结构变量检查,则在构造函数结束时调用结构变量。</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">如果结构声明了 &lt;code&gt;opCmp&lt;/code&gt; 成员函数，则其格式应为：</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">如果结构声明用于身份比较的 &lt;code&gt;opEquals&lt;/code&gt; 成员函数，则它可能具有多种形式，例如：</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">如果发生这样的匹配,则inout被认为是匹配的限定符的共同限定符。如果存在两个以上的参数,则递归地应用共同限定符计算。</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">如果这样的</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">如果模板类型参数与函数参数上的文字表达式相匹配,推导类型可以考虑缩小它们的转换范围。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">如果.d源文件以字符串 &quot;Ddoc &quot;开头,那么它将被视为通用文档,而不是D代码源文件。从紧接 &quot;Ddoc &quot;字符串之后到文件末尾或任何 &quot;Macros:&quot;部分构成文件。除了用------行划定的行间嵌入的D代码高亮外,不对该文本进行自动高亮处理。只做宏处理。</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">如果满足&lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;条件&lt;/i&gt;&lt;/a&gt;，则执行以下操作</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">如果在 &lt;code&gt;config&lt;/code&gt; 中设置了&lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; &lt;/a&gt;标志，则子进程将</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">如果&lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt;是一个令牌长，则可以省略括号：</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">如果&lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;为空，则默认初始化struct实例。</target>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">如果 &lt;code&gt;BitmappedBlock&lt;/code&gt; 对象为空（没有活动分配），则分配其中的所有内存并向其返回切片。否则，返回 &lt;code&gt;null&lt;/code&gt; （即不尝试分配最大的可用块）。</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">如果 &lt;code&gt;FileLogger&lt;/code&gt; 正在管理它登录的 &lt;code&gt;File&lt;/code&gt; ，则此方法将返回对该文件的引用。</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;FileLogger&lt;/code&gt; 是用文件名构造的，则此方法返回此文件名。否则，将返回一个空 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">如果 &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 对象为空（没有活动分配），则分配其中的所有内存并向其返回切片。否则，返回 &lt;code&gt;null&lt;/code&gt; （即不尝试分配最大的可用块）。</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">如果 &lt;code&gt;Task&lt;/code&gt; 尚未启动，请在当前线程中执行它。如果完成，则返回其返回值（如果有）。如果正在进行中，请忙旋转直到完成，然后返回返回值。如果引发异常，请重新引发该异常。</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">如果 &lt;code&gt;Task&lt;/code&gt; 尚未启动，请在当前线程中执行它。如果完成，则返回其返回值（如果有）。如果正在进行中，请等待条件变量。如果引发异常，请重新引发该异常。</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">如果 &lt;code&gt;VariantN&lt;/code&gt; 包含（关联）数组，则返回该数组的长度。否则，引发异常。</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">如果 &lt;code&gt;VariantN&lt;/code&gt; 包含一个数组，则将 &lt;code&gt;dg&lt;/code&gt; 依次应用于该数组的每个元素。否则，引发异常。</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">如果 &lt;code&gt;VariantN&lt;/code&gt; 对象持有的值</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">如果使用 &lt;code&gt;[ ]&lt;/code&gt; 形式，则切片是整个数组的一部分。</target>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">如果使用了CURLOPT_INFILE,可以用它来告知libcurl发送的文件到底有多大。这样可以更好地进行错误检查,更好地验证上传是否成功。-1表示未知大小。</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">如果UDA是一个类型,那么符号上任何相同类型的UDA都将匹配。如果UDA是一个类型的模板,那么任何UDA是该模板的实例都将匹配。如果UDA是一个值,那么符号上任何等于该值的UDA都将匹配。</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">如果省略[EBP]，则假定为局部变量。如果使用 &lt;code&gt;naked&lt;/code&gt; 则不再适用。</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">如果集合表达式是一个序列,可以声明一个或两个迭代符号。如果是一个,那么这个符号是一个</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">如果聚合表达式是 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;wchar&lt;/code&gt; 或 &lt;code&gt;dchar&lt;/code&gt; 的静态或动态数组，则</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">如果聚合表达式是结构或类对象，但是不存在 &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt; 或 &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;code&gt;foreach_reverse&lt;/code&gt; ，则可以使用范围原语对struct和class对象进行迭代。对于 &lt;code&gt;foreach&lt;/code&gt; ，这意味着必须定义以下属性和方法：</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">如果聚合表达式是结构或类对象，则 &lt;code&gt;foreach&lt;/code&gt; 由特殊的&lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt;成员函数定义，而 &lt;code&gt;foreach_reverse&lt;/code&gt; 行为由特殊的&lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt;成员函数定义。这些函数的类型为：</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">如果集合表达式是一个关联数组,可以声明一个或两个变量。如果有一个,那么这个变量就被称为是</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">如果集合是一个静态或动态数组,可以声明一个或两个变量。如果有一个,那么这个变量就被称为是</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">如果参数是CommaExp,则设置一个标志,以防止出现废弃信息</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">如果省略参数,则表示默认构造标量类型。</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果参数全部是抽象类的类型，或者都是抽象类的表达式，则返回 &lt;code&gt;true&lt;/code&gt; 。否则，返回 &lt;code&gt;false&lt;/code&gt; 。如果没有参数，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">如果参数是算术类型的所有类型，或者都是算术类型的表达式，则返回 &lt;code&gt;true&lt;/code&gt; 。否则，返回 &lt;code&gt;false&lt;/code&gt; 。如果没有参数，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">如果分配的值类型与AA元素类型&lt;b&gt;不&lt;/b&gt;相等，则表达式可以使用常规索引访问来调用运算符重载：</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">如果分配的值类型与AA元素类型相等。</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">如果禁用了 &lt;code&gt;@system&lt;/code&gt; 或 &lt;code&gt;@trusted&lt;/code&gt; 代码中的边界检查，则代码作者仍必须保证代码正确性。</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">如果回调不接受任何参数,每当看到选项时就会调用回调。</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">如果回调只有一个字符串参数,则选项字符串(不含前导破折号)被传递给回调。之后,该选项字符串被认为是处理过的,并从选项数组中删除。</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">如果回调接受两个字符串参数,则选项字符串会被处理为一个参数的选项,并进行相应的解析。选项及其值被传递给回调。之后,无论传递给回调的是什么,都会被视为处理,并从列表中删除。</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">如果调用者是Fiber而不是Generator,这个函数将视情况调用调度器.yield()或Fiber.yield()。</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">如果调用者是一个预定的Fiber,这将产生执行到另一个预定的Fiber。</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">如果增加容量,就应该假设所有对元素的迭代都是无效的。</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">如果管理的内存块很大，则可能希望从一开始就将管理切换到空闲列表。这样，可以以比区域模式更紧凑的方式使用存储器。要强制使用自由列表模式，请在构造后或认为合适时立即调用 &lt;code&gt;switchToFreeList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">如果连接进行得太快,则需要减慢速度。</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">如果构造函数可以创建一个唯一的对象（例如，如果它是 &lt;code&gt;pure&lt;/code&gt; ），则该对象可以隐式转换为任何限定符。</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">如果构造函数可以创建一个唯一的对象（即，如果它是 &lt;code&gt;pure&lt;/code&gt; ），则该对象可以隐式转换为任何限定符。</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">如果当前计数等于0,返回。否则,原子地将计数减一,并返回true。</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">如果声明被禁用但在禁用的函数内部，则返回 &lt;code&gt;true&lt;/code&gt; ,但不会发出错误消息。</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">如果给定了一个参数的默认值,那么下面所有的参数也必须有默认值。</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">如果定界符是一个标识符,标识符后面必须紧跟一个换行符,匹配的定界符是行首开始的同一个标识符。</target>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">如果容器的成员函数的文档采用 &lt;code&gt;Range&lt;/code&gt; 类型的参数，则它引用此容器的主要范围类型。通常会使用 &lt;code&gt;Take!Range&lt;/code&gt; ，在这种情况下，范围是指容器中元素的范围。这些参数的参数&lt;b&gt;必须&lt;/b&gt;从与所使用的容器实例相同的容器实例获得。重要的是要注意，许多通用范围算法返回的范围类型与其输入范围相同。</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">如果在 &quot;低速时间 &quot;秒内,下载接收到的字节/秒少于 &quot;低速限制&quot;,操作就会中止。如果你有一个相当高的速度连接,你可以在20秒内小于2000字节/秒时中止。</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">如果电子邮件地址有效或无效。</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">如果该枚举</target>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">如果表达式是&lt;a href=&quot;function#property-functions&quot;&gt;Property Function&lt;/a&gt;，则 &lt;code&gt;typeof&lt;/code&gt; 给出其返回类型。</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">如果注册了扩展的 unittest 处理程序,这个函数直接返回该处理程序的结果。</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果扩展名为空，则此功能等效于&lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">如果该字段在一条路径上被初始化,那么它必须在所有路径上被初始化。</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">如果字段类型具有&lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt;方法，则不会将其用于初始化。</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">如果字段类型不可变,将拒绝多次初始化。</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">如果未打开文件，则返回 &lt;code&gt;true&lt;/code&gt; 。否则，返回&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt;作为文件句柄。</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">如果文件未打开，则成功执行。否则，为文件句柄返回&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">如果模块的文件名是无效的模块名（例如 &lt;code&gt;foo-bar.d&lt;/code&gt; ），则可以使用模块声明来设置有效的模块名：</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">如果文件未打开，则成功执行。否则，关闭文件（通过调用&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;），从而引发错误。即使引发异常，此后 &lt;code&gt;File&lt;/code&gt; 对象也为空。这与 &lt;code&gt;detach&lt;/code&gt; 的不同之处在于，它始终关闭文件。因此，所有其他引用同一句柄的 &lt;code&gt;File&lt;/code&gt; 对象此后将看到一个关闭的文件。</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">如果文件名已经具有扩展名，它将被替换。如果不是，则将扩展名简单地附加到文件名中。 &lt;code&gt;ext&lt;/code&gt; 中包括前导点是可选的。</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">如果第一个</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">如果第一行以 &quot;#!&quot;开头,那么该行将被忽略。</target>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">如果第一次查找不成功，则对导入执行第二次查找。在第二个查找阶段中，将忽略继承的作用域。这包括基类和接口的范围（在此示例中， &lt;code&gt;BaseClass&lt;/code&gt; 的导入将被忽略），以及混合 &lt;code&gt;template&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">如果在函数中改变了浮点运算的取整模式,必须在函数退出前将其恢复。如果违反了这一规则(例如,使用内联asm),则后续计算中使用的四舍五入模式将无法定义。</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">如果格式字符串是固定的,那么将其作为模板参数传递,就可以在编译时检查参数的类型正确性。这也可以带来更好的性能。</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">如果x的小数部分正好是0.5,则返回值从零开始四舍五入。</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">如果以字符串形式传递函数，则状态的名称为 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 并且重复中基于零的索引的名称为 &lt;code&gt;&quot;n&quot;&lt;/code&gt; 。给定 &lt;code&gt;a[n - 1]&lt;/code&gt; ， &lt;code&gt;a[n - 2]&lt;/code&gt; ， &lt;code&gt;a[n - 3]&lt;/code&gt; ，...， &lt;code&gt;a[n - stateSize]&lt;/code&gt; ，给定的字符串必须返回 &lt;code&gt;a[n]&lt;/code&gt; 期望值。状态大小取决于传递给 &lt;code&gt;recurrence&lt;/code&gt; 调用的参数数量。该 &lt;code&gt;Recurrence&lt;/code&gt; 结构本身需要管理复发的状态，并适当地偏移的照顾。</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">如果函数返回 &lt;code&gt;void&lt;/code&gt; ，并且第一个参数是 &lt;code&gt;ref&lt;/code&gt; 或 &lt;code&gt;out&lt;/code&gt; ，则所有后续的 &lt;code&gt;return ref&lt;/code&gt; 参数都被视为已分配给第一个参数，以进行生命周期检查。结构非静态成员函数的 &lt;code&gt;this&lt;/code&gt; 引用参数被视为第一个参数。</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">如果生成的副本构造函数无法进行类型检查，它将收到 &lt;code&gt;@disable&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">如果生成的时间点在正确的方向上经过了范围的边缘，则将使用该范围的边缘。因此，如果向前迭代，并且生成的时间点超过了间隔的 &lt;code&gt;end&lt;/code&gt; ，则 &lt;code&gt;front&lt;/code&gt; 变为 &lt;code&gt;end&lt;/code&gt; 。如果向后迭代，并且生成的时间点在 &lt;code&gt;begin&lt;/code&gt; 之前，则 &lt;code&gt;front&lt;/code&gt; 变为 &lt;code&gt;begin&lt;/code&gt; 。无论哪种情况，范围都将为空。</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">如果给定的文件是一个符号链接,则返回符号链接本身的属性,而不是它所指向的文件。如果给定的文件是一个符号链接,那么这将返回符号链接本身的属性,而不是它所指向的文件。</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">如果给定的标题包含了输入中没有的列,它们将被忽略。</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">如果给定的头不符合输入中的顺序,内容将按照输入中的顺序返回。</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">如果堆有增长的空间，则将 &lt;code&gt;value&lt;/code&gt; 插入存储并返回 &lt;code&gt;true&lt;/code&gt; 。否则，如果 &lt;code&gt;less(value, front)&lt;/code&gt; ，则调用 &lt;code&gt;replaceFront(value)&lt;/code&gt; 并再次返回 &lt;code&gt;true&lt;/code&gt; 。否则，不影响堆，并返回 &lt;code&gt;false&lt;/code&gt; 。在必须收集一组候选者的最小 &lt;code&gt;k&lt;/code&gt; 个元素的情况下，此方法很有用。</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">如果AA中已经存在索引键,则设置运行正常赋值。</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">如果索引键在AA中还不存在,将分配一个新的AA条目,并以分配的值进行初始化。</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">如果无限精度结果适合结果类型，请返回该结果并且不要触摸 &lt;code&gt;overflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">如果初始化器不存在,则可以从相应的构造函数中初始化不可变物。</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">如果输入数组已经有效,则该函数返回原始数组,否则,它通过用编码方案的替换序列替换所有非法序列来构造一个新数组。</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">如果输入的字符串已经有效,该函数将返回原始的字符串,否则它将通过用编码的替换字符替换所有非法的代码单元序列来构建一个新的字符串,无效的序列将被Unicode替换字符(U+FFFD)替换,如果字符汇包含它,否则无效的序列将被替换为'?</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">如果实例 &lt;code&gt;toString&lt;/code&gt; 覆盖了 &lt;code&gt;Object.toString&lt;/code&gt; ，则使用它。</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">如果不变式不成立,则程序进入无效状态。</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">如果最后一个模板参数在</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">如果最后一个模板参数设置为 &lt;code&gt;No.multiblock&lt;/code&gt; ，分配器将只提供最多需要 &lt;code&gt;theBlockSize&lt;/code&gt; 的分配。该 &lt;code&gt;BitmappedBlock&lt;/code&gt; 对单块分配，允许更高的性能，在不能够在一次分配多个块成本的专门的实现。</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">如果左右操作数具有相同的结构类型，并且该结构类型具有&lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;，则复制操作如&lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">如果左手边的</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">如果赋值的左侧是对结构或类实例的切片操作，则可以通过实现 &lt;code&gt;opIndexAssign&lt;/code&gt; 成员函数（将 &lt;code&gt;opSlice&lt;/code&gt; 函数的返回值作为参数）来重载它。形式为 &lt;code&gt;a[&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">如果赋值的左侧是对结构或类实例的索引操作，则可以通过提供 &lt;code&gt;opIndexAssign&lt;/code&gt; 成员函数来重载该赋值。形式为 &lt;code&gt;a[&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">如果左操作数为 &lt;code&gt;false&lt;/code&gt; ，那么将评估右操作数。如果结果类型为</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">如果左操作数为 &lt;code&gt;true&lt;/code&gt; ，那么将评估右操作数。如果结果类型为</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">如果将左侧操作数转换为 &lt;code&gt;bool&lt;/code&gt; 类型，其结果为 &lt;code&gt;false&lt;/code&gt; ，则不评估右侧操作数。如果结果类型为</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">如果将左侧操作数转换为 &lt;code&gt;bool&lt;/code&gt; 类型，其结果为 &lt;code&gt;true&lt;/code&gt; ，则不评估右侧操作数。如果结果类型为</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">如果锁被其他调用者持有,则该方法返回。否则,如果锁还没有被持有,则获得锁,然后内部计数器递增1。</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">如果左值是静态数组或切片，则其行为如&lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt;和&lt;a href=&quot;array#array-setting&quot;&gt;Array Setting中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">如果左值是用户定义的属性，则其行为如&amp;ldquo; &lt;a href=&quot;function#property-functions&quot;&gt;属性函数&amp;rdquo;中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">如果左值是动态数组的 &lt;code&gt;.length&lt;/code&gt; 属性，则其行为如&lt;a href=&quot;array#resize&quot;&gt;设置动态数组长度中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">如果成员是一个类或结构,未定义的查找将被转发给</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">如果存在修饰符 &lt;code&gt;'d'&lt;/code&gt; ，则 &lt;code&gt;to&lt;/code&gt; 中的字符数可能仅为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 。如果修饰符 &lt;code&gt;'d'&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">如果需要删除范围内的某些元素，但不必保留其余元素的顺序，则可能需要传递 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; 来 &lt;code&gt;remove&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">如果新的数组长度较长,则剩余的部分用默认的初始化器填充。</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">如果一个对象的唯一指针被保存在这些区域之外,那么收集器将错过它并释放内存。</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">如果操作数是整数值，则在进行比较之前，将使用&amp;ldquo; &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;常规算术转换&amp;rdquo;&lt;/a&gt;将它们转换为通用类型。相等定义为通用类型的位模式完全匹配。</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">如果操作数是整数类型，则将它们进行&amp;ldquo; &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;常规算术转换&amp;rdquo;&lt;/a&gt;，然后使用&amp;ldquo; &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;常规算术转换&amp;rdquo;&lt;/a&gt;将其转换为普通类型。</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">如果操作数是指针,平等的定义是操作数的位模式完全匹配。</target>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">如果操作数是相同的类型,结果将是该类型。</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">如果关联运算符+或*的操作数是浮点值,则表达式不重新排序。</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果该操作导致上溢/下溢，则此函数将返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">如果运算符是 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; ，并且第一个操作数是指针，而第二个操作数是整数类型，则结果类型是第一个操作数的类型，而结果值是指针加（或减）第二个操作数乘以第一个操作数指向的类型的大小。</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">如果运算符为 &lt;code&gt;=&lt;/code&gt; ，则为简单赋值。右操作数被隐式转换为左操作数的类型，并分配给它。</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">如果选择第二个</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">如果父分配器 &lt;code&gt;Allocator&lt;/code&gt; 是有状态的，则其实例存储为成员。否则， &lt;code&gt;AffixAllocator&lt;/code&gt; 使用 &lt;code&gt;Allocator.instance&lt;/code&gt; 。无论哪种情况，名称 &lt;code&gt;_parent&lt;/code&gt; 都统一用于访问父分配器。</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">如果传递的缓冲区不是最后的分配，则 &lt;code&gt;delta&lt;/code&gt; 最多为最后一页上剩余的字节数。否则，我们可以扩展最后的分配，直到虚拟地址范围的末尾。</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">如果与 &lt;code&gt;pid&lt;/code&gt; 相关联的进程已经终止， &lt;code&gt;tryWait&lt;/code&gt; 的效果与 &lt;code&gt;wait&lt;/code&gt; 完全相同。在这种情况下，它返回一个元组，其中 &lt;code&gt;terminated&lt;/code&gt; 字段设置为 &lt;code&gt;true&lt;/code&gt; ，而 &lt;code&gt;status&lt;/code&gt; 字段的解释与 &lt;code&gt;wait&lt;/code&gt; 的返回值相同。</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">如果该进程有</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">如果进程已经终止，则此函数直接返回。退出代码被缓存，因此，如果在同一个&lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt;上多次调用wait（），它将始终返回相同的值。</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">如果该过程被信号终止，则返回值的 &lt;code&gt;status&lt;/code&gt; 字段将包含一个负数，其绝对值为信号数。（请参阅&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;详细信息。）</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">如果该过程被信号终止，则此函数返回一个负数，其绝对值为信号数。由于POSIX将正常的退出代码限制在0-255的范围内，因此负的返回值将始终指示信号终止。信号代码在 &lt;code&gt;core.sys.posix.signal&lt;/code&gt; 模块中定义（对应于 &lt;code&gt;signal.h&lt;/code&gt; POSIX标头）。</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">如果这个范围已经是词法上最大的偶数排列,那么它将被换回最小的偶数排列,并返回false;否则,返回true,并就地修改为词法上的下一个偶数排列。否则,返回true,并在原地将范围修改为词法上的下一个偶数排列。</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">如果范围当前是按字典顺序排列的最大排列，则将其排列回最小排列并返回false。否则，返回true。因此，可以通过根据 &lt;code&gt;less&lt;/code&gt; 对它进行排序来生成范围的所有排列，这会产生字典上最小的排列，然后调用nextPermutation直到返回false。这样可以保证一次生成该范围的所有不同排列。如果有</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">如果范围在 &lt;code&gt;n&lt;/code&gt; 个元素之前用完，则 &lt;code&gt;take&lt;/code&gt; 简单地返回整个范围（与&lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt;不同，如果该范围过早结束则将导致断言失败）：</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">如果范围是字符串，则 &lt;code&gt;cmp&lt;/code&gt; 会适当地执行UTF解码，并一次将一个代码点的范围进行比较。</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">如果满足上述限制,就会生成以下的复制构造函数。</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">如果返回类型是int，结果不能适合在一个int，则可以在32位被保持最接近的值将被（如此使用 &lt;code&gt;int.max&lt;/code&gt; 如果它越过和 &lt;code&gt;int.min&lt;/code&gt; 如果去下） 。但是，如果返回类型很长，则不会尝试处理整数溢出。</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">如果返回值不等于x,会引发FE_INEXACT异常。</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">如果右侧也是一个Checked,但钩子或底层类型不同,则这个Checked的钩子和底层类型优先。</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">如果第二个参数的长度小于索引范围的长度,就会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">如果 &lt;code&gt;path&lt;/code&gt; 的第二个字符是冒号（ &lt;code&gt;':'&lt;/code&gt; ），则第一个字符将被解释为驱动器号，并且必须在AZ范围内（不区分大小写）。</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">如果第二个操作数是指针，而第一个是整数类型，并且运算符是 &lt;code&gt;+&lt;/code&gt; ，则将操作数取反，并应用刚刚描述的指针算法。</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">如果以 &lt;code&gt;startIdx&lt;/code&gt; 结尾的序列不表示格式正确的代码点，则可能会引发&lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;cs&lt;/code&gt; 指示比较是否区分大小写。</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">如果该序列是一个</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">如果从 &lt;code&gt;startIdx&lt;/code&gt; 开始的序列不表示格式正确的代码点，则可能会引发&lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">如果标志位被设置(即为 &quot;负&quot;),则NAN小于任何数字;如果标志位未被设置(为 &quot;正&quot;),则NAN大于任何数字。</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">如果签名类型大于无符号类型,则将无符号类型转换为签名类型。</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">如果在编译时可以知道分片边界,那么分片表达式就隐式转换为静态数组的l值。例如</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">如果源文件不以BOM开头,那么第一个字符必须小于或等于U+0000007F。</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">如果字符串数据是UTF-8,并且可以直接访问,则返回一个指向它的指针。不要假设末端为0。</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">如果字符串中不包含安括号,将返回原文。</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">如果该字符串不是合法的IPv4地址，则返回 &lt;code&gt;ADDR_NONE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">如果字符串没有被修改,将返回原始的字符串。</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">如果该结构定义了&lt;b&gt;toString（）&lt;/b&gt;方法，则结果是此函数返回的字符串。否则，结果为StructName（field &lt;sub&gt;0&lt;/sub&gt;，field &lt;sub&gt;1&lt;/sub&gt;，...），其中field &lt;sub&gt;n&lt;/sub&gt;是使用默认格式设置的第n个元素。</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">如果switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;表达式&lt;/i&gt;&lt;/a&gt;是枚举类型，则所有枚举成员必须出现在&lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement中&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">如果将 &lt;code&gt;--DRT-testmode&lt;/code&gt; 开关传递给可执行文件，则它可以具有3个值之一：1.&amp;ldquo; run-main&amp;rdquo;：即使运行了单元测试（并全部通过），main仍在运行。这是当前的默认设置。2.&amp;ldquo; test-or-main&amp;rdquo;：存在的任何单元测试都将导致程序汇总结果并退出而不管结果如何。这将是2.080中的默认设置。3.&amp;ldquo;仅测试&amp;rdquo;，即使没有测试，运行时也将始终汇总并且永远不会运行main。</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">如果尚未启动线程，则返回&lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; 。否则，在Windows上返回 &lt;code&gt;GetCurrentThreadId&lt;/code&gt; 的结果，在POSIX 上返回 &lt;code&gt;pthread_self&lt;/code&gt; 的结果。该值在当前过程中是唯一的。</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果时区是 &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; （或认为是等同于 &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; 通过规范的第4.3节），一个&lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt;与UTC的偏移 &lt;code&gt;0&lt;/code&gt; 而不是使用&lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt;，而 &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; 使用&lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">如果两个参数都是lambda函数(或lambda函数的别名),那么它们将进行平等比较。为了正确计算比较,两个lambda函数必须满足以下条件:</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">如果两个参数都是由字元或枚举组成的表达式,并且评价为相同的值,则返回true。</target>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">如果两个操作数是不同的枚举,那么结果是两个操作数共同的最接近的基类型。最接近的基类型意味着从原始类型到基类型的转换序列更短。</target>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">如果类型是类或结构体,返回它的符号,否则为空。</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">如果一个函数文字的类型可以从它的上下文中唯一地确定,那么参数类型推理是可能的。</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">如果类型特殊化依赖于类型参数,则该参数的类型被设置为类型参数的相应部分。</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">如果联合定义了&lt;b&gt;toString（）&lt;/b&gt;方法，则结果是此函数返回的字符串。否则，结果为联合的名称，不包含其内容。</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">如果联合体大于第一个字段,则剩余的位被设置为0。</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">如果联合体大于初始化字段,则剩余的位被设置为0。</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">如果用户提供的大小为零或用户提供的缓冲区为空，则抛出 &lt;code&gt;Exception&lt;/code&gt; 。如果发生I / O错误，则抛出 &lt;code&gt;StdioException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">如果变量不存在,将被创建。如果它已经存在,则会被覆盖。</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">如果变量不在环境中,这个函数不做任何事情就成功返回。</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">如果变量参数是一个没有参数的委托数组。</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">如果在</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">如果有多个</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">如果有多个 &lt;code&gt;return ref&lt;/code&gt; 参数，则返回值的生存期是相应参数的最小生存期。</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">如果一个声明的范围内有多个UDA,则将它们连接起来。</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">如果一个函数中有多个pragma内联,则最后一个内联在词法上生效。</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果没有参数，则结果为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">如果符号没有用户定义的属性,则返回一个空元组。表达式元组可以变成一个可操作的元组。</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">如果有两个符号声明,第一个是</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">如果有一个 &lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; ，那么这些参数将在size参数之后传递给类或结构特定的&lt;a href=&quot;class#allocators&quot;&gt;分配器函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">如果有为该类定义的构造函数,则调用与参数列表匹配的构造函数。</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">如果有为结构定义的构造函数,则调用与参数列表匹配的构造函数。</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">如果存在一个&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;，则它必须求值为Object或Object的实例。</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">如果存在out后置条件（请参见&lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;），则该后置条件将在计算&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;之后且函数实际返回之前执行。</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">如果在同一点有多个 &lt;code&gt;scope&lt;/code&gt; 变量超出范围，则将以构造变量的相反顺序调用析构函数。</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">如果没有&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;并且它不是第一个</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">如果一个类没有构造函数,但基类有构造函数,则会隐式生成一个默认的构造函数,形式。</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">如果没有默认的返回表达式，并且该谓词对于任何测试表达式 &lt;code&gt;SwitchError&lt;/code&gt; 成立，则将引发SwitchError。如果在没有抛出任何内容的情况下执行了void return表达式，也会引发 &lt;code&gt;SwitchError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">如果一个声明没有文档注释,该声明可能不会出现在输出中。为了确保它确实出现在输出中,请为它加上一个空的声明注释。</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">如果字符串中没有时区，则使用&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;。如果时区为&amp;ldquo; Z&amp;rdquo;，则使用 &lt;code&gt;UTC&lt;/code&gt; 。否则，将&lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt;与给定的UTC偏移量相对应的std.datetime.timezone.SimpleTimeZone。要使返回的&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;成为特定的时区，请传递该时区，&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;将要返回的SysTime会转换为该时区（尽管仍会以其字符串中的任何时区读取它）。</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">如果参数没有类型特化,则参数的类型设置为模板参数。</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">如果匿名枚举中只有一个成员，则可以省略 &lt;code&gt;{ }&lt;/code&gt; 。从语法上来说，这是一个&lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">如果没有特定的错误处理程序,则由运行时库的默认处理程序来处理。如果一个错误被忽略了,那是因为程序员专门添加了代码来忽略错误,这大概意味着它是故意的。</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果不满足这些约束，则该函数被认为是不可比的， &lt;code&gt;isSame&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">如果它们都是空的,那么它们是相等的。如果一个是空,另一个不是,那么它们就不相等。如果它们都是非空的,那么如果它们的值是相等的,那么它们是相等的。</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">如果它们比较相等,返回0,否则返回fp的值。</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">如果它们有范围接口,格式为输入范围。</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">如果它们的ptrs相同,返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">如果此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的时区为&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;，则TZ为空。如果其时区为 &lt;code&gt;UTC&lt;/code&gt; ，则为&amp;ldquo; Z&amp;rdquo;。否则，它是与UTC的偏移量（例如+0100或-0700）。请注意，与UTC的偏移为</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">如果此&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;的时区为&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;，则TZ为空。如果其时区为 &lt;code&gt;UTC&lt;/code&gt; ，则为&amp;ldquo; Z&amp;rdquo;。否则，它是与UTC的偏移量（例如+01：00或-07：00）。请注意，与UTC的偏移为</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">如果此 &lt;code&gt;Nullable&lt;/code&gt; 包装了已经具有null值的类型（例如指针），并且没有为 &lt;code&gt;nullValue&lt;/code&gt; 给出null值，则将null值分配给此 &lt;code&gt;Nullable&lt;/code&gt; 与分配 &lt;code&gt;T&lt;/code&gt; 类型的任何其他值没有什么不同，并且结果代码看起来很奇怪。强烈建议通过将 &lt;code&gt;T&lt;/code&gt; 的&amp;ldquo;内置&amp;rdquo; null值用于 &lt;code&gt;nullValue&lt;/code&gt; 来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">如果此 &lt;code&gt;Nullable&lt;/code&gt; 包装了已经具有null值的类型（例如指针），则向此 &lt;code&gt;Nullable&lt;/code&gt; 分配null值与分配 &lt;code&gt;T&lt;/code&gt; 类型的任何其他值没有什么不同，并且结果代码看起来非常奇怪。强烈建议通过使用带有附加 &lt;code&gt;nullValue&lt;/code&gt; 模板参数的 &lt;code&gt;Nullable&lt;/code&gt; 版本来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="7febe77abd33adf57e913bf0a4a63eb358541f75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Task&lt;/code&gt; was not started yet, execute it in the current thread. If it is finished, return its result. If it is in progress, execute any other &lt;code&gt;Task&lt;/code&gt; from the &lt;code&gt;TaskPool&lt;/code&gt; instance that this &lt;code&gt;Task&lt;/code&gt; was submitted to until this one is finished. If it threw an exception, rethrow that exception. If no other tasks are available or this &lt;code&gt;Task&lt;/code&gt; was executed using &lt;code&gt;executeInNewThread&lt;/code&gt;, wait on a condition variable.</source>
          <target state="translated">如果尚未启动此 &lt;code&gt;Task&lt;/code&gt; ，请在当前线程中执行它。如果完成，则返回其结果。如果正在进行中，请从该 &lt;code&gt;Task&lt;/code&gt; 提交到的 &lt;code&gt;TaskPool&lt;/code&gt; 实例中执行其他任何 &lt;code&gt;Task&lt;/code&gt; ，直到完成该任务为止。如果引发异常，请重新引发该异常。如果没有其他任务可用，或者此 &lt;code&gt;Task&lt;/code&gt; 是使用 &lt;code&gt;executeInNewThread&lt;/code&gt; 执行的，请等待条件变量。</target>
        </trans-unit>
        <trans-unit id="02c1e520b882980c80752c1365bf55b4375ba858" translate="yes" xml:space="preserve">
          <source>If this declaration is compliant with any particular standard, the description of it goes here.</source>
          <target state="translated">如果该声明符合任何特定的标准,那么它的描述就在这里。</target>
        </trans-unit>
        <trans-unit id="13a2f9d3fe709668a2bc4c5dc3f8ab6e710fca1e" translate="yes" xml:space="preserve">
          <source>If this is a reference, dereference it.</source>
          <target state="translated">如果这是一个参考文献,请取消引用。</target>
        </trans-unit>
        <trans-unit id="4f2c995ebc62fdd08dead47122c9bc13fad7a76d" translate="yes" xml:space="preserve">
          <source>If this is a shell around another type, get that other type.</source>
          <target state="translated">如果这是一个围绕另一个类型的外壳,得到另一个类型。</target>
        </trans-unit>
        <trans-unit id="b5dc509f5b8b27fb2d7cf6170c77f1c20cada7e8" translate="yes" xml:space="preserve">
          <source>If this is a type of something, return that something.</source>
          <target state="translated">如果这是一个类型的东西,就返回那个东西。</target>
        </trans-unit>
        <trans-unit id="78983652ba5d9285bc5419929ba9f7e7d2014654" translate="yes" xml:space="preserve">
          <source>If this is a type of static array, return its base element type.</source>
          <target state="translated">如果这是一个静态数组的类型,返回它的基本元素类型。</target>
        </trans-unit>
        <trans-unit id="11053146fa2d89a0863002bf2113f6a22908ad90" translate="yes" xml:space="preserve">
          <source>If this lock is not already held by the caller, the lock is acquired, then the internal counter is incremented by one.</source>
          <target state="translated">如果这个锁还没有被调用者持有,则获得该锁,然后内部计数器增一。</target>
        </trans-unit>
        <trans-unit id="7f2c76fc93c2cea506533b01d671704af3859af8" translate="yes" xml:space="preserve">
          <source>If this statement has code that needs to run in a finally clause at the end of the current scope, return that code in the form of a Statement.</source>
          <target state="translated">如果这个语句有代码需要在当前作用域结束时的final子句中运行,则以Statement的形式返回该代码。</target>
        </trans-unit>
        <trans-unit id="0515fd6aa93cc22acea186af17b617bb6900cccc" translate="yes" xml:space="preserve">
          <source>If this symbol is really an alias for another, return that other. If needed, semantic() is invoked due to resolve forward reference.</source>
          <target state="translated">如果这个符号真的是另一个符号的别名,则返回那个别名。如果需要,由于解析前向引用,会调用semantic()。</target>
        </trans-unit>
        <trans-unit id="0d671d5e8525a56282bf3d43e4b2c8ef0fff443b" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Checked&lt;/code&gt; instances are involved in a binary operation and both define &lt;code&gt;hookOpBinary&lt;/code&gt;, the left-hand side hook has priority. If both define &lt;code&gt;onOverflow&lt;/code&gt;, a compile-time error occurs.</source>
          <target state="translated">如果两个 &lt;code&gt;Checked&lt;/code&gt; 实例涉及一个二进制操作，并且都定义了 &lt;code&gt;hookOpBinary&lt;/code&gt; ，则左侧钩子具有优先级。如果两者都定义 &lt;code&gt;onOverflow&lt;/code&gt; ，则会发生编译时错误。</target>
        </trans-unit>
        <trans-unit id="000877fa3e86af7fe8754c0a2ea9639fca32104e" translate="yes" xml:space="preserve">
          <source>If two different mixins are put in the same scope, and each define a declaration with the same name, there is an ambiguity error when the declaration is referenced:</source>
          <target state="translated">如果将两个不同的 mixins 放在同一个作用域中,并且各自定义了一个名称相同的声明,那么在引用该声明时就会出现歧义错误。</target>
        </trans-unit>
        <trans-unit id="a3bad367e89a048e204fc75a01e068c90ffc4712" translate="yes" xml:space="preserve">
          <source>If two or more functions have the same match level, then</source>
          <target state="translated">如果两个或两个以上的函数具有相同的匹配级别,那么</target>
        </trans-unit>
        <trans-unit id="329ee511107dbe6e7abc063f46dd137916ba7624" translate="yes" xml:space="preserve">
          <source>If unit tests are not enabled, the implementation is not required to check the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; for syntactic or semantic correctness. This is to reduce the compile time impact of larger unit test sections. The tokens must still be valid, and the implementation can merely count &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens to find the end of the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;'s &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">如果未启用单元测试，则不需要实现来检查&lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;的语法或语义正确性。这是为了减少较大单元测试部分的编译时间影响。令牌必须仍然有效，并且实现只能计数 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 令牌以找到&lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;的&lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement的末尾&lt;/i&gt;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9627f657eafec4f6faa68074956b9ef2912cb7d7" translate="yes" xml:space="preserve">
          <source>If variable has a const initializer, return that initializer.</source>
          <target state="translated">如果变量有一个const初始化器,返回该初始化器。</target>
        </trans-unit>
        <trans-unit id="efa87bbfad2d81b3124f9c28a0c2e92ac37d7e01" translate="yes" xml:space="preserve">
          <source>If variable has a constant expression initializer, get it. Otherwise, return null.</source>
          <target state="translated">如果变量有一个常量表达式初始化器,则获取它。否则,返回null。</target>
        </trans-unit>
        <trans-unit id="129f6b693e38ba5e18679007098a9df7fc61bc3f" translate="yes" xml:space="preserve">
          <source>If vector extensions are implemented, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;D_SIMD&lt;/code&gt; is set.</source>
          <target state="translated">如果实现了矢量扩展， &lt;code&gt;D_SIMD&lt;/code&gt; 设置&lt;a href=&quot;version#PredefinedVersions&quot;&gt;版本标识符&lt;/a&gt;D_SIMD。</target>
        </trans-unit>
        <trans-unit id="adbc7bef2337da263c5a713fbb0e840af6633adb" translate="yes" xml:space="preserve">
          <source>If we want the value of this expression, but do not want to call the destructor on it.</source>
          <target state="translated">如果我们想要这个表达式的值,但又不想调用它的析构器。</target>
        </trans-unit>
        <trans-unit id="79988e7c16e0dced67dee802d9bdb6de78ec6132" translate="yes" xml:space="preserve">
          <source>If x is not a special value, the result is the same as &lt;code&gt;cast(int) logb(x)&lt;/code&gt;.</source>
          <target state="translated">如果x不是一个特殊值，则结果与 &lt;code&gt;cast(int) logb(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bffad47163601102b19e67fa92a8c3feda0166ec" translate="yes" xml:space="preserve">
          <source>If x is subnormal, it is treated as if it were normalized. For a positive, finite x:</source>
          <target state="translated">如果x为亚正态,则按归一化处理。对于一个正的、有限的x。</target>
        </trans-unit>
        <trans-unit id="92c403e0084ea037260c41da9c4c7e544a7d2d08" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y.</source>
          <target state="translated">如果y&amp;gt; x，则结果将是下一个最大的浮点值；如果y &amp;lt;x，则结果将是下一个最小值。如果x == y，则结果为y。</target>
        </trans-unit>
        <trans-unit id="51868f820cebc5e3c544468e6d407c4bd6b45485" translate="yes" xml:space="preserve">
          <source>If you have a small buffer you can use &lt;a href=&quot;#compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#uncompress&quot;&gt;&lt;code&gt;uncompress&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">如果缓冲区较小，则可以直接使用&lt;a href=&quot;#compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#uncompress&quot;&gt; &lt;code&gt;uncompress&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b65e14bf08e45286eb114c69d33e8aa407bf4bbd" translate="yes" xml:space="preserve">
          <source>If you omit &lt;code&gt;Rhs&lt;/code&gt;, &lt;code&gt;isAssignable&lt;/code&gt; will check identity assignable of &lt;code&gt;Lhs&lt;/code&gt;.</source>
          <target state="translated">如果省略 &lt;code&gt;Rhs&lt;/code&gt; ，则 &lt;code&gt;isAssignable&lt;/code&gt; 将检查 &lt;code&gt;Lhs&lt;/code&gt; 可分配的身份。</target>
        </trans-unit>
        <trans-unit id="14961e1fccbf1736d47a52df390592d594e9109a" translate="yes" xml:space="preserve">
          <source>If you select &lt;code&gt;precise&lt;/code&gt; as the garbage collector via the options above, type information will be used to identify actual or possible pointers or references within heap allocated data objects. Non-pointer data will not be interpreted as a reference to other memory as a &quot;false pointer&quot;. The collector has to make pessimistic assumptions if a memory slot can contain both a pointer or an integer value, it will still be scanned (e.g. in a &lt;code&gt;union&lt;/code&gt;).</source>
          <target state="translated">如果通过上述选项选择 &lt;code&gt;precise&lt;/code&gt; 作为垃圾收集器，则类型信息将用于标识堆分配的数据对象中的实际或可能的指针或引用。非指针数据将不会被解释为对其他内存的&amp;ldquo;假指针&amp;rdquo;引用。如果内存插槽可以同时包含指针或整数值，则收集器必须做出悲观的假设，否则仍将对其进行扫描（例如，使用 &lt;code&gt;union&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cbade680aa6ce4b2eee3b550013b504b2359a76c" translate="yes" xml:space="preserve">
          <source>If you use the GC memory functions from &lt;code&gt;core.memory&lt;/code&gt;, and plan to use it for data with a mixture of pointers and non-pointer data you should pass the TypeInfo of your allocated struct, class or type as the optional parameter. The default &lt;code&gt;null&lt;/code&gt; is interpreted as memory that might contain pointers everywhere.</source>
          <target state="translated">如果您使用 &lt;code&gt;core.memory&lt;/code&gt; 中的GC内存函数，并计划将其用于包含指针和非指针数据的数据，则应将分配的struct，class或type的TypeInfo作为可选参数传递。默认的 &lt;code&gt;null&lt;/code&gt; 解释为可能在各处包含指针的内存。</target>
        </trans-unit>
        <trans-unit id="50a53d6760e4f33109326a6a1af782ed05797935" translate="yes" xml:space="preserve">
          <source>If:</source>
          <target state="translated">If:</target>
        </trans-unit>
        <trans-unit id="b2403005179997fdecfad41d075986e0dccac0e9" translate="yes" xml:space="preserve">
          <source>IfStatement</source>
          <target state="translated">IfStatement</target>
        </trans-unit>
        <trans-unit id="859704f6d767666630d7b805196cab9e15bc787d" translate="yes" xml:space="preserve">
          <source>IgnoreXXXX</source>
          <target state="translated">IgnoreXXXX</target>
        </trans-unit>
        <trans-unit id="ba5ba167a98858b40c030856aa4aacb94b020392" translate="yes" xml:space="preserve">
          <source>Ignores C-style / D-style variadic arguments.</source>
          <target state="translated">忽略C型/D型变量参数。</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="ed701420e7f5e55b19ea82ee452968a59b8615ea" translate="yes" xml:space="preserve">
          <source>Images have the same form as reference or inline links, but add an exclamation point &lt;code&gt;!&lt;/code&gt; before the initial square bracket. What would be the link text in a normal link is used as the image's alt text.</source>
          <target state="translated">图片的格式与参考链接或内联链接相同，但要添加一个感叹号 &lt;code&gt;!&lt;/code&gt; 在第一个方括号之前。普通链接中的链接文本将用作图像的替代文本。</target>
        </trans-unit>
        <trans-unit id="da8a47e84bd95dd590801199a512c81712152ddc" translate="yes" xml:space="preserve">
          <source>Immediately after the range argument, an optional work unit size argument may be provided. Work units as used by &lt;code&gt;amap&lt;/code&gt; are identical to those defined for parallel foreach. If no work unit size is provided, the default work unit size is used.</source>
          <target state="translated">在range参数之后，可以立即提供一个可选的工作单位大小参数。 &lt;code&gt;amap&lt;/code&gt; 使用的工作单位与为并行foreach定义的工作单位相同。如果未提供工作单位尺寸，则使用默认工作单位尺寸。</target>
        </trans-unit>
        <trans-unit id="79fa62caeafe3bd4c17315583aef1c8a23c5d46e" translate="yes" xml:space="preserve">
          <source>Immediately drop any connections and release socket resources. The &lt;code&gt;Socket&lt;/code&gt; object is no longer usable after &lt;code&gt;close&lt;/code&gt;. Calling &lt;code&gt;shutdown&lt;/code&gt; before &lt;code&gt;close&lt;/code&gt; is recommended for connection-oriented sockets.</source>
          <target state="translated">立即删除所有连接并释放套接字资源。该 &lt;code&gt;Socket&lt;/code&gt; 对象不再使用后 &lt;code&gt;close&lt;/code&gt; 。调用 &lt;code&gt;shutdown&lt;/code&gt; 前 &lt;code&gt;close&lt;/code&gt; 建议面向连接的插座。</target>
        </trans-unit>
        <trans-unit id="1473effc3e4965950f77d9acee523d95bdbf4b42" translate="yes" xml:space="preserve">
          <source>Immutability is transitive, meaning it applies to anything that can be referenced from the immutable type:</source>
          <target state="translated">不变性是转义的,这意味着它适用于任何可以从不可变类型引用的东西。</target>
        </trans-unit>
        <trans-unit id="a3901c3fc3cbd4dda7d4b5cdbdfb146ab629c087" translate="yes" xml:space="preserve">
          <source>Immutable Member Functions</source>
          <target state="translated">不可变的成员函数</target>
        </trans-unit>
        <trans-unit id="31b83cfa7707372a1c66b40c2bffbc19a9e85eb7" translate="yes" xml:space="preserve">
          <source>Immutable Storage Class</source>
          <target state="translated">不可变存储类</target>
        </trans-unit>
        <trans-unit id="bad427b56d48a9c0418ac178e3b7e5501dbeffb2" translate="yes" xml:space="preserve">
          <source>Immutable Type</source>
          <target state="translated">不变型</target>
        </trans-unit>
        <trans-unit id="7a41b36410af31e02780ae8ef8f795b4c7e5c218" translate="yes" xml:space="preserve">
          <source>Immutable associative arrays are often desirable, but sometimes initialization must be done at runtime. This can be achieved with a constructor (static constructor depending on scope), a buffer associative array and &lt;code&gt;assumeUnique&lt;/code&gt;:</source>
          <target state="translated">不可变的关联数组通常是理想的，但是有时必须在运行时进行初始化。这可以通过构造函数（取决于范围的静态构造函数），缓冲区关联数组和 &lt;code&gt;assumeUnique&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1060492cd68308e42ab0d863274ead4d94e73c72" translate="yes" xml:space="preserve">
          <source>Immutable declarations can appear as lvalues, i.e. they can have their address taken, and occupy storage.</source>
          <target state="translated">不可更改的声明可以以l值的形式出现,即可以取地址,占用存储空间。</target>
        </trans-unit>
        <trans-unit id="97deddbfb05296e5d5f6c89e8255f2cf73fed0f1" translate="yes" xml:space="preserve">
          <source>Immutable member functions are guaranteed that the object and anything referred to by the &lt;code&gt;this&lt;/code&gt; reference is immutable. They are declared as:</source>
          <target state="translated">不变的成员函数可确保 &lt;code&gt;this&lt;/code&gt; 引用所引用的对象和任何东西都是不变的。它们声明为：</target>
        </trans-unit>
        <trans-unit id="7ca47511da5cd25a571e0550ee9181f060e3ad8e" translate="yes" xml:space="preserve">
          <source>Immutable used as a storage class is equivalent to using immutable as a type qualifier for the entire type of a declaration:</source>
          <target state="translated">Immutable用作存储类,相当于用immutable作为整个声明类型的类型限定符。</target>
        </trans-unit>
        <trans-unit id="8cc79f379fb076727af30671cff8e81a7a78ac8f" translate="yes" xml:space="preserve">
          <source>Imperial Aramaic</source>
          <target state="translated">御用阿拉姆语</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="015f00e67a839cb58bb4f25641353bc270b1dc50" translate="yes" xml:space="preserve">
          <source>Impl* &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt;(const TypeInfo_AssociativeArray ti, void[] keys, void[] vals);</source>
          <target state="translated">Impl * &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt;（const TypeInfo_AssociativeArray ti，void [] keys，void [] vals）;</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="4bd31434dd702d78584ad36682fd4ce02cbe35f9" translate="yes" xml:space="preserve">
          <source>Implementation helpers</source>
          <target state="translated">执行助手</target>
        </trans-unit>
        <trans-unit id="cdc8095e33689a7350a694bb991dc5449ed4cc80" translate="yes" xml:space="preserve">
          <source>Implementation note: Many vector operations are expected to take advantage of any vector math instructions available on the target computer.</source>
          <target state="translated">实施说明:许多向量运算要利用目标计算机上可用的任何向量数学指令。</target>
        </trans-unit>
        <trans-unit id="4f7fc9a2d05fa0c5c4b7879d385797376ea8299d" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;IAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built allocator type to &lt;code&gt;IAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">用 &lt;code&gt;Allocator&lt;/code&gt; 实现 &lt;code&gt;IAllocator&lt;/code&gt; 。这 &lt;code&gt;IAllocator&lt;/code&gt; 静态构建的分配器类型改编为IAllocator，该类型可以由非模板代码直接使用。</target>
        </trans-unit>
        <trans-unit id="fafacd0c4afbb4ff4bf1edadf17fafe457e3c87e" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;ISharedAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built, shareable across threads, allocator type to &lt;code&gt;ISharedAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">使用 &lt;code&gt;Allocator&lt;/code&gt; 实现 &lt;code&gt;ISharedAllocator&lt;/code&gt; 。这使静态构建的，可跨线程共享的分配器类型适应 &lt;code&gt;ISharedAllocator&lt;/code&gt; ，该类型可由非模板代码直接使用。</target>
        </trans-unit>
        <trans-unit id="bcbaffe82dd8f12aeaf4d1ff9d3011fef84404a6" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendT&lt;/code&gt; and &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;_d_arrayappendT&lt;/code&gt; 和 &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10e497f26133fe54aedbc1b0186f76a3533b685" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; and &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; 和 &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7db4a8478e7cad025fd1104c777c36390076d0e1" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraycatnTX&lt;/code&gt; and &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;_d_arraycatnTX&lt;/code&gt; 和 &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abbaa69f0e232671973ab5e6491f136e6a29871" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; and &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</source>
          <target state="translated">实施 &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; 和 &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f9ad487b035fc97c0af04b8b66abb8578971a5f" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt; red-black tree&lt;/a&gt; container.</source>
          <target state="translated">实现一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;红黑树&lt;/a&gt;容器。</target>
        </trans-unit>
        <trans-unit id="8e7df8ae1e56f997a5b65b6b6877c23f0d64f3a3" translate="yes" xml:space="preserve">
          <source>Implementation of alloca() standard C routine.</source>
          <target state="translated">alloca()标准C例程的实现。</target>
        </trans-unit>
        <trans-unit id="1784dc78d2b897ccf07f36701bfc5665f7a4b791" translate="yes" xml:space="preserve">
          <source>Implementation of array assignment support routines.</source>
          <target state="translated">数组赋值支持例程的实现。</target>
        </trans-unit>
        <trans-unit id="a39c70c382be4565515493d462dbbec04eaf7781" translate="yes" xml:space="preserve">
          <source>Implementation of array copy support routines.</source>
          <target state="translated">数组复制支持例程的实现。</target>
        </trans-unit>
        <trans-unit id="0bdc6417eff40a113a2fe81fc65ab41a4dcaba32" translate="yes" xml:space="preserve">
          <source>Implementation of associative arrays.</source>
          <target state="translated">关联数组的实现。</target>
        </trans-unit>
        <trans-unit id="07784c9ff6fc80ea8be9db66531869c595761785" translate="yes" xml:space="preserve">
          <source>Implementation of code coverage analyzer.</source>
          <target state="translated">实现代码覆盖率分析器。</target>
        </trans-unit>
        <trans-unit id="fad1778f18239a1620ff2a279ed8dce89c92aba4" translate="yes" xml:space="preserve">
          <source>Implementation of dynamic array property support routines.</source>
          <target state="translated">动态数组属性支持例程的实现。</target>
        </trans-unit>
        <trans-unit id="1c44b949de0c9066379af30ba926638e5089c3a0" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines for Win32.</source>
          <target state="translated">实现Win32的异常处理支持例程。</target>
        </trans-unit>
        <trans-unit id="7d3ce3a8f354f9946b2098d37781419df42c1fa9" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines.</source>
          <target state="translated">异常处理支持例程的实现。</target>
        </trans-unit>
        <trans-unit id="4262710c1f4443ad04091f6eaee82248c8735a23" translate="yes" xml:space="preserve">
          <source>Implementation of invariant support routines.</source>
          <target state="translated">实现不变的支持例程。</target>
        </trans-unit>
        <trans-unit id="3dad8ae42692f0a5067da5335623cc0faae36caa" translate="yes" xml:space="preserve">
          <source>Implementation of standard Base64 encoding.</source>
          <target state="translated">实现标准Base64编码。</target>
        </trans-unit>
        <trans-unit id="8bb4407a3328a42063117ac1cd37abce98147582" translate="yes" xml:space="preserve">
          <source>Implementation of support routines for synchronized blocks.</source>
          <target state="translated">实现同步块的支持例程。</target>
        </trans-unit>
        <trans-unit id="36a7e10f19e92847926357311b55d0e017f473ef" translate="yes" xml:space="preserve">
          <source>Implementations are free to assume that GC pointers are only stored on word boundaries. Unaligned pointers may be ignored entirely.</source>
          <target state="translated">实现可以自由假设GC指针只存储在字的边界上。不对齐的指针可以完全忽略。</target>
        </trans-unit>
        <trans-unit id="a8c2ed8c7bf790ca62a6ccc79e874d26201eb456" translate="yes" xml:space="preserve">
          <source>Implementations are free to run collections at any point. It is, however, recommendable to only do so when an allocation attempt happens and there is insufficient memory available.</source>
          <target state="translated">实现可以在任何时候自由运行集合。然而,建议只有在发生分配尝试且可用内存不足时才这样做。</target>
        </trans-unit>
        <trans-unit id="7bedeb01a44e9992494ae61fc2e61ab874f0844b" translate="yes" xml:space="preserve">
          <source>Implementations are free to scan the non-root heap in a precise manner, so that fields of types like &lt;code&gt;float&lt;/code&gt; will not be considered relevant when scanning the heap. Thus, casting a GC pointer to an integral type (e.g. &lt;code&gt;size_t&lt;/code&gt;) and storing it in a field of that type inside the GC heap may mean that it will not be recognized if the memory block was allocated with precise type info or with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">实现可以自由地以精确的方式扫描非根堆，因此在扫描堆时，像 &lt;code&gt;float&lt;/code&gt; 这样的类型的字段将不被视为相关。因此，将GC指针强制转换为整数类型（例如 &lt;code&gt;size_t&lt;/code&gt; ）并将其存储在GC堆内的该类型的字段中可能意味着，如果使用精确的类型信息或 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; 分配了内存块，则无法识别该指针。 BlkAttr。NO_SCAN属性。</target>
        </trans-unit>
        <trans-unit id="3fe2d13e1a38447a1ccf3bcf63459da389a3bd8d" translate="yes" xml:space="preserve">
          <source>Implementations may restrict the file name in order to avoid directory traversal security vulnerabilities. A possible restriction might be to disallow any path components in the file name.</source>
          <target state="translated">实现可以限制文件名,以避免目录遍历的安全漏洞。一个可能的限制是不允许文件名中包含任何路径成分。</target>
        </trans-unit>
        <trans-unit id="41da860cb79fe7312e55548bf43ef9ac07ff278f" translate="yes" xml:space="preserve">
          <source>Implementations must diagnose an error for unrecognized</source>
          <target state="translated">实施时必须对未识别的</target>
        </trans-unit>
        <trans-unit id="007c721ddd0f22de039d1ec5d207cce979d8d6f0" translate="yes" xml:space="preserve">
          <source>Implementations must support interior pointers. That is, if the only reference to a GC-managed memory block points into the middle of the block rather than the beginning (for example), the GC must consider the memory block live. The exception to this rule is when a memory block is allocated with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; attribute; it is the user's responsibility to make sure such memory blocks have a proper pointer to them when they should be considered live.</source>
          <target state="translated">实现必须支持内部指针。也就是说，如果仅对GC管理的内存块的引用指向该块的中间而不是开头（例如），则GC必须考虑该内存块处于活动状态。该规则的例外情况是当使用 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; 分配了内存块时。NO_INTERIOR属性；用户有责任在应认为这些内存块处于活动状态时确保它们具有正确的指针。</target>
        </trans-unit>
        <trans-unit id="db108dbc2de097787f6ddeb0832f02909642f907" translate="yes" xml:space="preserve">
          <source>Implementations of D on different architectures, however, are free to innovate upon the memory model, function call/return conventions, argument passing conventions, etc.</source>
          <target state="translated">然而,D在不同架构上的实现,可以在内存模型、函数调用/返回约定、参数传递约定等方面自由创新。</target>
        </trans-unit>
        <trans-unit id="d7a03fc44da9f306060241398ee57db5f3a7d7aa" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; and &lt;code&gt;pthread_condition&lt;/code&gt; on Posix and &lt;code&gt;CreateEvent&lt;/code&gt; and &lt;code&gt;SetEvent&lt;/code&gt; on Windows.</source>
          <target state="translated">在Posix上使用 &lt;code&gt;pthread_mutex&lt;/code&gt; 和 &lt;code&gt;pthread_condition&lt;/code&gt; 以及在Windows 上使用 &lt;code&gt;CreateEvent&lt;/code&gt; 和 &lt;code&gt;SetEvent&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="9e4c63b7ecbb7ff73a2154a224607de77b4347f8" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; on Posix and &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; on Windows.</source>
          <target state="translated">在Posix 上使用 &lt;code&gt;pthread_mutex&lt;/code&gt; 和Windows 上使用 &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; 实施。</target>
        </trans-unit>
        <trans-unit id="cf9e08c7271694a3ffd216903295953184c6b554" translate="yes" xml:space="preserve">
          <source>Implementing a Scheduler allows the concurrency mechanism used by this module to be customized according to different needs. By default, a call to spawn will create a new kernel thread that executes the supplied routine and terminates when finished. But it is possible to create Schedulers that reuse threads, that multiplex Fibers (coroutines) across a single thread, or any number of other approaches. By making the choice of Scheduler a user-level option, std.concurrency may be used for far more types of application than if this behavior were predefined.</source>
          <target state="translated">实现Scheduler后,可以根据不同的需求定制本模块使用的并发机制。默认情况下,调用 spawn 会创建一个新的内核线程,执行所提供的例程,并在完成后终止。但是可以创建重用线程的Scheduler,在一个线程上复用Fibers(coroutine),或者其他任何数量的方法。通过将Scheduler的选择作为用户级选项,std.concurrency可以用于更多类型的应用,而不是预定义的行为。</target>
        </trans-unit>
        <trans-unit id="b264d3336b750c35148a8818568f62fa13927441" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in integers.</source>
          <target state="translated">实现 &lt;code&gt;BigInt&lt;/code&gt; 与 &lt;code&gt;BigInt&lt;/code&gt; 或 &lt;code&gt;BigInt&lt;/code&gt; 与内置整数的三向比较。</target>
        </trans-unit>
        <trans-unit id="ff4e8dcbc761da7358b8c9aa098a3c08bb0a396c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integer types.</source>
          <target state="translated">与其他 &lt;code&gt;BigInt&lt;/code&gt; 和内置整数类型一起实现 &lt;code&gt;BigInt&lt;/code&gt; 相等性测试。</target>
        </trans-unit>
        <trans-unit id="7ca26966771a4b63b83cfa749d58cb4c74bd1074" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; unary operators.</source>
          <target state="translated">实现 &lt;code&gt;BigInt&lt;/code&gt; 一元运算符。</target>
        </trans-unit>
        <trans-unit id="6a3cb51c99d7f39233c1830869fb1b564b310297" translate="yes" xml:space="preserve">
          <source>Implements a &quot;tee&quot; style pipe, wrapping an input range so that elements of the range can be passed to a provided function or &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt; as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to &lt;code&gt;front&lt;/code&gt; or &lt;code&gt;popFront&lt;/code&gt;, or diverting the elements of a range into an auxiliary &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">实现一个&amp;ldquo; tee&amp;rdquo;样式的管道，包装一个输入范围，以便该范围元素可以在迭代时传递到提供的函数或&lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt;。这对于打印一长串范围代码中的中间值，在对 &lt;code&gt;front&lt;/code&gt; 或 &lt;code&gt;popFront&lt;/code&gt; 的每次调用中执行带有副作用的某些操作，或将范围的元素转移到辅助&lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; 中很有用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edd807624e1eff53b60fc0fdcb84a1a01a914908" translate="yes" xml:space="preserve">
          <source>Implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; container on top of a given random-access range type (usually &lt;code&gt;T[]&lt;/code&gt;) or a random-access container type (usually &lt;code&gt;Array!T&lt;/code&gt;). The documentation of &lt;code&gt;BinaryHeap&lt;/code&gt; will refer to the underlying range or container as the</source>
          <target state="translated">在给定的随机访问范围类型（​​通常为 &lt;code&gt;T[]&lt;/code&gt; ）或随机访问容器类型（通常为 &lt;code&gt;Array!T&lt;/code&gt; ）的顶部实现一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;二进制堆&lt;/a&gt;容器。 &lt;code&gt;BinaryHeap&lt;/code&gt; 的文档将基础范围或容器称为</target>
        </trans-unit>
        <trans-unit id="826e19cc42c27271edbc14035290489f9b886abe" translate="yes" xml:space="preserve">
          <source>Implements a doubly-linked list.</source>
          <target state="translated">执行双链路列表。</target>
        </trans-unit>
        <trans-unit id="6c4a9e8241b5f111ea434df2fe96c036c8c94979" translate="yes" xml:space="preserve">
          <source>Implements a narrowing remainder operation with built-in integer types.</source>
          <target state="translated">实现了一个内置整数类型的缩小余数操作。</target>
        </trans-unit>
        <trans-unit id="27ed74a2d7c34a4b3c0b18b681929b4fe9236374" translate="yes" xml:space="preserve">
          <source>Implements a parallel foreach loop over a range. This works by implicitly creating and submitting one &lt;code&gt;Task&lt;/code&gt; to the &lt;code&gt;TaskPool&lt;/code&gt; for each worker thread. A work unit is a set of consecutive elements of &lt;code&gt;range&lt;/code&gt; to be processed by a worker thread between communication with any other thread. The number of elements processed per work unit is controlled by the &lt;code&gt;workUnitSize&lt;/code&gt; parameter. Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit. Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger &lt;code&gt;workUnitSize&lt;/code&gt; should be. For very expensive loop bodies, &lt;code&gt;workUnitSize&lt;/code&gt; should be 1. An overload that chooses a default work unit size is also available.</source>
          <target state="translated">在一个范围内实现并行的foreach循环。这可以通过为每个工作线程隐式创建一个 &lt;code&gt;Task&lt;/code&gt; 并将其提交到 &lt;code&gt;TaskPool&lt;/code&gt; 来实现。工作单元是工作线程与任何其他线程之间进行通信时要处理的 &lt;code&gt;range&lt;/code&gt; 连续元素。每个工作单元处理的元素数由 &lt;code&gt;workUnitSize&lt;/code&gt; 参数控制。较小的工作单元可提供更好的负载平衡，但是较大的工作单元可避免与其他线程频繁通信以获取下一个工作单元的开销。在修改范围的情况下，大型工作单位还可以避免错误共享。循环的一次迭代花费的时间越 &lt;code&gt;workUnitSize&lt;/code&gt; 越大应该。对于非常昂贵的循环体， &lt;code&gt;workUnitSize&lt;/code&gt; 应该为1。还可以选择默认工作单元大小的重载。</target>
        </trans-unit>
        <trans-unit id="826fe4a31de6fc5bfd32223112c616b546ef30ea" translate="yes" xml:space="preserve">
          <source>Implements a simple and fast singly-linked list. It can be used as a stack.</source>
          <target state="translated">实现一个简单快速的单链路列表。它可以作为一个堆栈使用。</target>
        </trans-unit>
        <trans-unit id="1e7f8a9f41236aa959250c83a21042416cfb7001" translate="yes" xml:space="preserve">
          <source>Implements an output range that appends data to an array. This is recommended over &lt;code&gt;array ~= data&lt;/code&gt; when appending many elements because it is more efficient. &lt;code&gt;Appender&lt;/code&gt; maintains its own array metadata locally, so it can avoid global locking for each append where &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; is non-zero.</source>
          <target state="translated">实现将数据追加到数组的输出范围。在附加许多元素时，建议在 &lt;code&gt;array ~= data&lt;/code&gt; ，因为这样做效率更高。 &lt;code&gt;Appender&lt;/code&gt; 会在本地维护自己的数组元数据，因此可以避免&lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;不为零的每个追加的全局锁定。</target>
        </trans-unit>
        <trans-unit id="eb1006ae1765bc7db00ba2578ee369f0e577a7bc" translate="yes" xml:space="preserve">
          <source>Implements assignment operators from built-in integers of the form &lt;code&gt;BigInt op= integer&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;BigInt op= integer&lt;/code&gt; 形式的内置整数实现赋值运算符。</target>
        </trans-unit>
        <trans-unit id="a6bf741a9ca55b772fcf287918db9b994810ba0a" translate="yes" xml:space="preserve">
          <source>Implements assignment operators of the form &lt;code&gt;BigInt op= BigInt&lt;/code&gt;.</source>
          <target state="translated">实现形式为 &lt;code&gt;BigInt op= BigInt&lt;/code&gt; 赋值运算符。</target>
        </trans-unit>
        <trans-unit id="e1ea709e7bbd408cd7bf94a6f215f7f14ae10aa2" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integers.</source>
          <target state="translated">在 &lt;code&gt;BigInt&lt;/code&gt; 和内置整数之间实现二进制运算符。</target>
        </trans-unit>
        <trans-unit id="df47e55b92aed2a9c5b877779b4fc9382af7ea1f" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;BigInt&lt;/code&gt; 之间实现二进制运算符。</target>
        </trans-unit>
        <trans-unit id="c38b2eea1063f17593adb5371b20a04e888bc589" translate="yes" xml:space="preserve">
          <source>Implements casting to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">农具铸造 &lt;code&gt;bool&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="612c7a1e4ee8aa3a5eb36e62f5d1886edb7c32a6" translate="yes" xml:space="preserve">
          <source>Implements casting to integer types.</source>
          <target state="translated">实现对整数类型的转换。</target>
        </trans-unit>
        <trans-unit id="d027822363fbfc370a577e3a5cc7b4b903013cad" translate="yes" xml:space="preserve">
          <source>Implements casting to/from qualified &lt;code&gt;BigInt&lt;/code&gt;'s.</source>
          <target state="translated">实现与合格 &lt;code&gt;BigInt&lt;/code&gt; 之间的转换。</target>
        </trans-unit>
        <trans-unit id="ff4cc4fdb32d0e79c9536f6d66d8396bbf61c41a" translate="yes" xml:space="preserve">
          <source>Implements common functionality for StaticForeachDeclaration and StaticForeachStatement This performs the necessary lowerings before dmd.statementsem.makeTupleForeach can be used to expand the corresponding &lt;code&gt;static foreach&lt;/code&gt; declaration or statement.</source>
          <target state="translated">实现StaticForeachDeclaration和StaticForeachStatement的通用功能在执行dmd.statementsem.makeTupleForeach可以用来扩展相应的 &lt;code&gt;static foreach&lt;/code&gt; 声明或语句之前，此步骤将执行必要的降低操作。</target>
        </trans-unit>
        <trans-unit id="33e291a05be91fd5868ef9b486e72f36172b61e4" translate="yes" xml:space="preserve">
          <source>Implements functionality to read Comma Separated Values and its variants from an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">工具的功能来读取逗号分隔值和它的变体从&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;输入范围&lt;/a&gt;的 &lt;code&gt;dchar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78fb12359a92b10736f7ddffd604a688feb1037" translate="yes" xml:space="preserve">
          <source>Implements logging facilities.</source>
          <target state="translated">实施伐木设施。</target>
        </trans-unit>
        <trans-unit id="1c9526ff0c5c9d17f08ea2d94e25202e075b8278" translate="yes" xml:space="preserve">
          <source>Implements low-level time primitives.</source>
          <target state="translated">实现低级时间基元。</target>
        </trans-unit>
        <trans-unit id="f10aa3fdc814d436934036f8b3d2932b2c1a116c" translate="yes" xml:space="preserve">
          <source>Implements mixin types.</source>
          <target state="translated">执行混合类型。</target>
        </trans-unit>
        <trans-unit id="5720cf3a68f9171f96627020e4e3f8a88a48971a" translate="yes" xml:space="preserve">
          <source>Implements operators with built-in integers on the left-hand side and &lt;code&gt;BigInt&lt;/code&gt; on the right-hand side.</source>
          <target state="translated">用左侧的内置整数和右侧的 &lt;code&gt;BigInt&lt;/code&gt; 实现运算符。</target>
        </trans-unit>
        <trans-unit id="7e5de803b2338c86b3532da481b13f228f6a981e" translate="yes" xml:space="preserve">
          <source>Implements routines related to exceptions.</source>
          <target state="translated">执行与异常相关的例程。</target>
        </trans-unit>
        <trans-unit id="f320bc582113b4cafa3cdb495549c72756dd174e" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; (unary and binary), &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">器具饱和度为运营商 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; （一元和二元）， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;^^&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12ddcd2c7713838aaff094e0d8442224022b567f" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This hook is called if the result of the binary operation does not fit in &lt;code&gt;Lhs&lt;/code&gt; without loss of information or a change in sign.</source>
          <target state="translated">为运算符 &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; ， &lt;code&gt;*=&lt;/code&gt; ， &lt;code&gt;/=&lt;/code&gt; ， &lt;code&gt;%=&lt;/code&gt; ， &lt;code&gt;^^=&lt;/code&gt; ， &lt;code&gt;&amp;amp;=&lt;/code&gt; ， &lt;code&gt;|=&lt;/code&gt; ， &lt;code&gt;^=&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 实现饱和。如果二进制运算的结果不适合 &lt;code&gt;Lhs&lt;/code&gt; 而不会丢失信息或更改符号，则调用此钩子。</target>
        </trans-unit>
        <trans-unit id="be45676fa18a18d1d8737b834959d03a5f13376c" translate="yes" xml:space="preserve">
          <source>Implements the 'common' IEEE CRC32 variant (LSB-first order, Initial value uint.max, complement result)</source>
          <target state="translated">实施 &quot;常见的 &quot;IEEE CRC32变体(LSB-first order,初始值uint.max,补码结果)</target>
        </trans-unit>
        <trans-unit id="c54fb55bf997400be69c40f0614b3e9b7db9616f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;secant method&lt;/a&gt; for finding a root of the function &lt;code&gt;fun&lt;/code&gt; starting from points &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (ideally close to the root). &lt;code&gt;Num&lt;/code&gt; may be &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">实现&lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;割线方法&lt;/a&gt;，以从 &lt;code&gt;[xn_1, x_n]&lt;/code&gt; 点开始（理想地靠近根）找到函数 &lt;code&gt;fun&lt;/code&gt; 的根。 &lt;code&gt;Num&lt;/code&gt; 可以是 &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 或 &lt;code&gt;real&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b80a316e588d021f8c65a6036707b88ad521159" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;OutputRange&lt;/code&gt; interface for all types E and wraps the &lt;code&gt;put&lt;/code&gt; method for each type &lt;code&gt;E&lt;/code&gt; in a virtual function.</source>
          <target state="translated">为所有类型E 实现 &lt;code&gt;OutputRange&lt;/code&gt; 接口，并在虚拟函数中包装每种类型 &lt;code&gt;E&lt;/code&gt; 的 &lt;code&gt;put&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="09d37307ce6ae6ae1585ab5db7a54050805cc742" translate="yes" xml:space="preserve">
          <source>Implements the MurmurHash3 functions. You can specify the &lt;code&gt;size&lt;/code&gt; of the hash in bit. For 128 bit hashes you can specify whether to optimize for 32 or 64 bit architectures. If you don't specify the &lt;code&gt;opt&lt;/code&gt; value it will select the fastest version of the host platform.</source>
          <target state="translated">实现MurmurHash3函数。您可以按位指定哈希的 &lt;code&gt;size&lt;/code&gt; 。对于128位哈希，您可以指定是针对32位架构还是64位架构进行优化。如果不指定 &lt;code&gt;opt&lt;/code&gt; 值，它将选择主机平台的最快版本。</target>
        </trans-unit>
        <trans-unit id="7ab18d84fa65349ea46fc1a23e6ee0555763f6a9" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json arrays.</source>
          <target state="translated">为json数组实现foreach &lt;code&gt;opApply&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="45e448d8088d50f1f95bb79e479da8d5a8f8521b" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json objects.</source>
          <target state="translated">为json对象实现foreach &lt;code&gt;opApply&lt;/code&gt; 接口。</target>
        </trans-unit>
        <trans-unit id="c7b156318387d032d75e77a645f93fbb91cfe8d1" translate="yes" xml:space="preserve">
          <source>Implements the higher order filter function. The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">实现高阶过滤器功能。谓词传递给&lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt;，可以接受字符串，也可以通过 &lt;code&gt;pred(element)&lt;/code&gt; 执行的任何可调用对象。</target>
        </trans-unit>
        <trans-unit id="881b721a1385bc8ef11d90c4f0aac7e1c9f98dea" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor.</source>
          <target state="translated">器具的谐音功能（也称为 &lt;code&gt;accumulate&lt;/code&gt; ， &lt;code&gt;compress&lt;/code&gt; ， &lt;code&gt;inject&lt;/code&gt; ，或 &lt;code&gt;foldl&lt;/code&gt; ）存在于功能性香料各种编程语言。</target>
        </trans-unit>
        <trans-unit id="2de496f11d0a61e3ec35b13526a647a0eda0aa53" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. The call &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;fold!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">器具的谐音功能（也称为 &lt;code&gt;accumulate&lt;/code&gt; ， &lt;code&gt;compress&lt;/code&gt; ， &lt;code&gt;inject&lt;/code&gt; ，或 &lt;code&gt;foldl&lt;/code&gt; ）存在于功能性香料各种编程语言。调用 &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; 首先将 &lt;code&gt;seed&lt;/code&gt; 分配给内部变量 &lt;code&gt;result&lt;/code&gt; ，也称为累加器。然后，对于每个元件 &lt;code&gt;x&lt;/code&gt; 中 &lt;code&gt;range&lt;/code&gt; ， &lt;code&gt;result = fun(result, x)&lt;/code&gt; 被评估。最后，返回 &lt;code&gt;result&lt;/code&gt; 。单参数版本 &lt;code&gt;fold!(fun)(range)&lt;/code&gt; 的工作原理类似，但是它使用范围的第一个元素作为种子（范围必须为非空）。</target>
        </trans-unit>
        <trans-unit id="3a102abac10f402f998c7a93f6d1ecbc38ae5d29" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. There is also &lt;a href=&quot;#fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; which does the same thing but with the opposite parameter order. The call &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">器具的谐音功能（也称为 &lt;code&gt;accumulate&lt;/code&gt; ， &lt;code&gt;compress&lt;/code&gt; ， &lt;code&gt;inject&lt;/code&gt; ，或 &lt;code&gt;foldl&lt;/code&gt; ）存在于功能性香料各种编程语言。也有&lt;a href=&quot;#fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt;功能相同但参数顺序相反的折叠。调用 &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; 首先将 &lt;code&gt;seed&lt;/code&gt; 分配给内部变量 &lt;code&gt;result&lt;/code&gt; ，也称为累加器。然后，对于每个元件 &lt;code&gt;x&lt;/code&gt; 中 &lt;code&gt;range&lt;/code&gt; ， &lt;code&gt;result = fun(result, x)&lt;/code&gt; 被评估。最后，返回 &lt;code&gt;result&lt;/code&gt; 。一参数版本 &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; 工作原理类似，但是它将范围的第一个元素用作种子（范围必须为非空）。</target>
        </trans-unit>
        <trans-unit id="d222f5f35083b3fe479ec859b88f2b5c2d29bc99" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;transform&lt;/code&gt;) present in many languages of functional flavor. The call &lt;code&gt;map!(fun)(range)&lt;/code&gt; returns a range of which elements are obtained by applying &lt;code&gt;fun(a)&lt;/code&gt; left to right for all elements &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. The original ranges are not changed. Evaluation is done lazily.</source>
          <target state="translated">实现许多功能丰富的语言中存在的同音异义功能（也称为 &lt;code&gt;transform&lt;/code&gt; ）。调用 &lt;code&gt;map!(fun)(range)&lt;/code&gt; 返回一个范围，该范围是通过对 &lt;code&gt;range&lt;/code&gt; 中的所有元素 &lt;code&gt;a&lt;/code&gt; 从左至右应用 &lt;code&gt;fun(a)&lt;/code&gt; 来获得的。原始范围不变。评估是懒惰的。</target>
        </trans-unit>
        <trans-unit id="38aa73eed2ebaa6990e6725195bf642f0bb7894e" translate="yes" xml:space="preserve">
          <source>Implements the most derived interface that &lt;code&gt;R&lt;/code&gt; works with and wraps all relevant range primitives in virtual functions. If &lt;code&gt;R&lt;/code&gt; is already derived from the &lt;code&gt;InputRange&lt;/code&gt; interface, aliases itself away.</source>
          <target state="translated">实现 &lt;code&gt;R&lt;/code&gt; 使用的最派生接口，并将所有相关范围原语包装在虚函数中。如果 &lt;code&gt;R&lt;/code&gt; 已经从 &lt;code&gt;InputRange&lt;/code&gt; 接口派生，则将其自身别名掉。</target>
        </trans-unit>
        <trans-unit id="0aed3bb7204f0f1333835ef5bde3ef0b25325996" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;back&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.back&lt;/code&gt; is equivalent to &lt;code&gt;back(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;back&lt;/code&gt; automatically returns the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">实现了范围接口原语 &lt;code&gt;back&lt;/code&gt; 为内置阵列。由于非成员函数可以使用点符号用第一个参数调用，因此 &lt;code&gt;array.back&lt;/code&gt; 等效于 &lt;code&gt;back(array)&lt;/code&gt; 。对于&lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;窄字符串&lt;/a&gt;， &lt;code&gt;back&lt;/code&gt; 自动返回最后一个&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;代码点&lt;/a&gt;作为 &lt;code&gt;dchar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b532541671d15b35cef77598c086f1da87e05be3" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;empty&lt;/code&gt; for types that obey &lt;a href=&quot;#hasLength&quot;&gt;&lt;code&gt;hasLength&lt;/code&gt;&lt;/a&gt; property and for narrow strings. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;a.empty&lt;/code&gt; is equivalent to &lt;code&gt;empty(a)&lt;/code&gt;.</source>
          <target state="translated">对于遵循&lt;a href=&quot;#hasLength&quot;&gt; &lt;code&gt;hasLength&lt;/code&gt; &lt;/a&gt;属性的类型和窄字符串，将range接口原语实现为 &lt;code&gt;empty&lt;/code&gt; 。由于可以使用点表示法使用第一个参数调用非成员函数，因此 &lt;code&gt;a.empty&lt;/code&gt; 等效于 &lt;code&gt;empty(a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62d00f3658d0160b41b82721ed86515030421a62" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;front&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.front&lt;/code&gt; is equivalent to &lt;code&gt;front(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;front&lt;/code&gt; automatically returns the first &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">实现了范围接口原语 &lt;code&gt;front&lt;/code&gt; 为内置阵列。由于非成员函数可以使用点符号用第一个参数调用，因此 &lt;code&gt;array.front&lt;/code&gt; 等效于 &lt;code&gt;front(array)&lt;/code&gt; 。对于&lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;窄字符串&lt;/a&gt;， &lt;code&gt;front&lt;/code&gt; 自动将第一个&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;代码点&lt;/a&gt;作为 &lt;code&gt;dchar&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="c1778775edc47d955b8410b9303b511a8ed36740" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popBack&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popBack&lt;/code&gt; is equivalent to &lt;code&gt;popBack(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically eliminates the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt;.</source>
          <target state="translated">为内置数组实现范围接口原语 &lt;code&gt;popBack&lt;/code&gt; 。由于可以使用点符号使用第一个参数来调用非成员函数， &lt;code&gt;array.popBack&lt;/code&gt; 等效于 &lt;code&gt;popBack(array)&lt;/code&gt; 。对于&lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;窄字符串&lt;/a&gt;， &lt;code&gt;popFront&lt;/code&gt; 会自动消除最后一个&lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;代码点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32e1749a7e79cab97db7229f8dfe1c2b12d27951" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popFront&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popFront&lt;/code&gt; is equivalent to &lt;code&gt;popFront(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically advances to the next code point.</source>
          <target state="translated">为内置数组实现range接口原语 &lt;code&gt;popFront&lt;/code&gt; 。由于可以使用点符号使用第一个参数来调用非成员函数， &lt;code&gt;array.popFront&lt;/code&gt; 等效于 &lt;code&gt;popFront(array)&lt;/code&gt; 。对于&lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;窄字符串&lt;/a&gt;， &lt;code&gt;popFront&lt;/code&gt; 会自动前进到下一个代码点。</target>
        </trans-unit>
        <trans-unit id="75f6fe2cdac67a27b3428234729f0d9dae7b1837" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;save&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.save&lt;/code&gt; is equivalent to &lt;code&gt;save(array)&lt;/code&gt;. The function does not duplicate the content of the array, it simply returns its argument.</source>
          <target state="translated">为内置数组实现范围接口原语 &lt;code&gt;save&lt;/code&gt; 。由于非成员函数可以使用点符号用第一个参数调用，因此 &lt;code&gt;array.save&lt;/code&gt; 等效于 &lt;code&gt;save(array)&lt;/code&gt; 。该函数不复制数组的内容，它仅返回其参数。</target>
        </trans-unit>
        <trans-unit id="03be7c6392b5500acdd65ba4a7628363c1860d1b" translate="yes" xml:space="preserve">
          <source>Implicit Conversion of Reference Types</source>
          <target state="translated">参考类型的隐式转换</target>
        </trans-unit>
        <trans-unit id="65a63aa075b83c2fd9eb74a28a95e05ff02e65a6" translate="yes" xml:space="preserve">
          <source>Implicit Conversions</source>
          <target state="translated">隐性转换</target>
        </trans-unit>
        <trans-unit id="625a5d30e95ccd8e77f05af4dd624ce180fd702c" translate="yes" xml:space="preserve">
          <source>Implicit Nesting</source>
          <target state="translated">隐性嵌套</target>
        </trans-unit>
        <trans-unit id="341437e8c6d229adb9641f4f980b4bd232dec666" translate="yes" xml:space="preserve">
          <source>Implicit Qualifier Conversions</source>
          <target state="translated">隐性限定词转换</target>
        </trans-unit>
        <trans-unit id="e71105f02c13309129677ece5605a0283f9f1fad" translate="yes" xml:space="preserve">
          <source>Implicit Type Inference</source>
          <target state="translated">隐式类型推断</target>
        </trans-unit>
        <trans-unit id="849cfc1637b33ec7b03284c956943ea3a6ee1ec6" translate="yes" xml:space="preserve">
          <source>Implicit conversions are used to automatically convert types as required.</source>
          <target state="translated">隐式转换用于根据需要自动转换类型。</target>
        </trans-unit>
        <trans-unit id="16ca50dfa8d5e344f045161409c8efa6033ef01d" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue, like &lt;code&gt;toString&lt;/code&gt;, but also passes</source>
          <target state="translated">在此JSONValue上隐式调用 &lt;code&gt;toJSON&lt;/code&gt; ，例如 &lt;code&gt;toString&lt;/code&gt; ，但也传递</target>
        </trans-unit>
        <trans-unit id="61b604cd0d4af75ee155d0f29fe03ab209cdf393" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue.</source>
          <target state="translated">在此JSONValue上隐式调用 &lt;code&gt;toJSON&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe09202f421258205fc0af0f7cc90ba8af70d44d" translate="yes" xml:space="preserve">
          <source>Import Declaration</source>
          <target state="translated">进口申报</target>
        </trans-unit>
        <trans-unit id="07b4de4b6291e3b54e69fe2f2020c76048ffb706" translate="yes" xml:space="preserve">
          <source>Import Expressions</source>
          <target state="translated">导入表达式</target>
        </trans-unit>
        <trans-unit id="9633d9e6ebf62f84de8d5fc4824a9ee44e1f1708" translate="yes" xml:space="preserve">
          <source>Import declarations may be used at any scope. For example:</source>
          <target state="translated">导入声明可以在任何作用域使用。例如:</target>
        </trans-unit>
        <trans-unit id="e0559377cfba6b8aed12863122b1b2dcc118cb64" translate="yes" xml:space="preserve">
          <source>ImportDeclaration</source>
          <target state="translated">ImportDeclaration</target>
        </trans-unit>
        <trans-unit id="015ce9a6eb4a1d7698028975a16c0fe2ee6d7aa2" translate="yes" xml:space="preserve">
          <source>Improve behavior of allocators sensitive to allocation sizes, such as &lt;code&gt;FreeList&lt;/code&gt; and &lt;code&gt;FreeTree&lt;/code&gt;. Rounding allocation requests up makes for smaller free lists/trees at the cost of slack memory (internal fragmentation).</source>
          <target state="translated">改善对分配大小敏感的分配器的行为，例如 &lt;code&gt;FreeList&lt;/code&gt; 和 &lt;code&gt;FreeTree&lt;/code&gt; 。四舍五入的分配请求以较小的空闲列表/树为代价，这以空闲内存（内部碎片）为代价。</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="dcd96af0868ef4c663e6ad3dcef261c5095893f1" translate="yes" xml:space="preserve">
          <source>In C, arrays are passed to functions as pointers even if the function prototype says its an array. In D, static arrays are passed by value, not by reference. Thus, the function prototype must be adjusted to match what C expects.</source>
          <target state="translated">在C中,数组作为指针传递给函数,即使函数原型说它是一个数组。在D中,静态数组是通过值来传递的,而不是通过引用。因此,必须调整函数原型以符合C语言的要求。</target>
        </trans-unit>
        <trans-unit id="fb107b811fc18be0d73632390771a7270ede12ef" translate="yes" xml:space="preserve">
          <source>In Expressions</source>
          <target state="translated">在表达式中</target>
        </trans-unit>
        <trans-unit id="98ab2686a50e4805c42c072cadd55e7f182ad96a" translate="yes" xml:space="preserve">
          <source>In a Windows DLL, if this function is called via DllMain with argument DLL_PROCESS_DETACH, the thread is terminated forcefully without proper cleanup as a deadlock would happen otherwise.</source>
          <target state="translated">在Windows DLL中,如果这个函数通过DllMain调用,并带有参数DLL_PROCESS_DETACH,那么这个线程就会在没有适当清理的情况下被强行终止,否则会发生死锁。</target>
        </trans-unit>
        <trans-unit id="31b5ad319495b8bf3a1c002a8507f2abf1208f6d" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegate constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegate constructor.</source>
          <target state="translated">在构造函数主体中，如果调用了委托构造函数，则所有字段分配均视为分配。否则，字段分配的第一个实例是其初始化，并且将 &lt;code&gt;field = expression&lt;/code&gt; 形式的分配视为等同于 &lt;code&gt;typeof(field)(expression)&lt;/code&gt; 。可以在初始化或使用委托构造函数构造之前读取字段的值。</target>
        </trans-unit>
        <trans-unit id="58b4b4504d8850da0fbabfc52a3239ec3b0e0a33" translate="yes" xml:space="preserve">
          <source>In a constructor body, the first instance of field assignment is its initialization.</source>
          <target state="translated">在构造函数体中,字段赋值的第一个实例是其初始化。</target>
        </trans-unit>
        <trans-unit id="3c66c503e379c4155d015b11fbc1dc5940286649" translate="yes" xml:space="preserve">
          <source>In a declaration declaring multiple symbols, all the declarations must be of the same type:</source>
          <target state="translated">在声明多个符号的声明中,所有的声明必须是相同的类型。</target>
        </trans-unit>
        <trans-unit id="9e9fe9946b014b42fb5205022b5c12ede51b25c5" translate="yes" xml:space="preserve">
          <source>In a typical application, you might also want to consider using a non-blocking socket instead of setting a timeout on a blocking one.</source>
          <target state="translated">在典型的应用中,你可能还想考虑使用一个非阻塞的套接字,而不是在阻塞的套接字上设置超时。</target>
        </trans-unit>
        <trans-unit id="190918005b49f5fd22012e2b51e50c26bb8bb06b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#Variant&quot;&gt;&lt;code&gt;Variant&lt;/code&gt;&lt;/a&gt;, this module also defines the &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; type constructor. Unlike &lt;code&gt;Variant&lt;/code&gt;, &lt;code&gt;Algebraic&lt;/code&gt; only allows a finite set of types, which are specified in the instantiation (e.g. &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; may only hold an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;).</source>
          <target state="translated">除了&lt;a href=&quot;#Variant&quot;&gt; &lt;code&gt;Variant&lt;/code&gt; 之外&lt;/a&gt;，此模块还定义了&lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt;类型的构造函数。与 &lt;code&gt;Variant&lt;/code&gt; 不同， &lt;code&gt;Algebraic&lt;/code&gt; 只允许在实例化中指定的一组有限类型（例如， &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; 只能容纳 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;string&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bd56298f652baf17103962e16813e3a6aed52cf4" translate="yes" xml:space="preserve">
          <source>In addition to convenience, these functions are slightly more efficient than manually creating an Fft object for a single use, as the Fft object is deterministically destroyed before these functions return.</source>
          <target state="translated">除了方便之外,这些函数比手动创建一个单次使用的Fft对象效率更高一些,因为Fft对象在这些函数返回之前就被确定地销毁了。</target>
        </trans-unit>
        <trans-unit id="570c956c4c6e2dbde87f61ff5e2c49153a8df2e6" translate="yes" xml:space="preserve">
          <source>In addition to random number generators, this module features distributions, which skew a generator's output statistical distribution in various ways. So far the uniform distribution for integers and real numbers have been implemented.</source>
          <target state="translated">除了随机数生成器外,这个模块还具有分布的功能,分布以各种方式倾斜生成器的输出统计分布。到目前为止,整数和实数的均匀分布已经实现。</target>
        </trans-unit>
        <trans-unit id="5295840dbe23153fe2e689d001aa6ebadfba5f26" translate="yes" xml:space="preserve">
          <source>In addition, --DRT-gcopt=help will show the list of options and their current settings.</source>
          <target state="translated">此外,--DRT-gcopt=help将显示选项列表及其当前设置。</target>
        </trans-unit>
        <trans-unit id="b2fcea4fb949d2ee554c72114c12b58084a4d18d" translate="yes" xml:space="preserve">
          <source>In addition, the data &lt;code&gt;callerSize&lt;/code&gt;, &lt;code&gt;callerModule&lt;/code&gt;, &lt;code&gt;callerFile&lt;/code&gt;, &lt;code&gt;callerLine&lt;/code&gt;, and &lt;code&gt;callerTime&lt;/code&gt; is associated with each specific allocation. This data prefixes each allocation.</source>
          <target state="translated">另外，数据 &lt;code&gt;callerSize&lt;/code&gt; ， &lt;code&gt;callerModule&lt;/code&gt; ， &lt;code&gt;callerFile&lt;/code&gt; ， &lt;code&gt;callerLine&lt;/code&gt; 和 &lt;code&gt;callerTime&lt;/code&gt; 与每个特定分配相关联。该数据为每个分配加上前缀。</target>
        </trans-unit>
        <trans-unit id="8bb9d27fa1cfa7a17c0f438e8ee45a8ac856bdb5" translate="yes" xml:space="preserve">
          <source>In algorithms partitioning ranges in two, preserve relative ordering of elements only to the left of the partition point.</source>
          <target state="translated">在将范围一分为二的算法中,只在分割点的左边保留元素的相对排序。</target>
        </trans-unit>
        <trans-unit id="a4c7a53fdd584b663429b65ac4f17edc28d07354" translate="yes" xml:space="preserve">
          <source>In all cases the function returns the built-in result of &lt;code&gt;lhs == rhs&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，该函数都会返回 &lt;code&gt;lhs == rhs&lt;/code&gt; 的内置结果。</target>
        </trans-unit>
        <trans-unit id="a66898347b51f7c1d0527a1edb8a6b3cf367a27a" translate="yes" xml:space="preserve">
          <source>In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. &lt;code&gt;ulong&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt;) tracks the zero-based number of the current line.</source>
          <target state="translated">在所有情况下，都接受两个符号的版本，在这种情况下，第一个符号（整数类型，例如 &lt;code&gt;ulong&lt;/code&gt; 或 &lt;code&gt;uint&lt;/code&gt; ）跟踪当前行的从零开始的数字。</target>
        </trans-unit>
        <trans-unit id="fb219f6585d8061af3f052a290762bb948e1e8d6" translate="yes" xml:space="preserve">
          <source>In all cases, returns &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt;. The result is not autocorrected in case of an erroneous comparison.</source>
          <target state="translated">在所有情况下，返回 &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt; 。如果比较错误，则结果不会自动校正。</target>
        </trans-unit>
        <trans-unit id="cb4bca7a9dd4559557c8f7c4ee56255838258c7f" translate="yes" xml:space="preserve">
          <source>In all cases, the concatenation of the returned ranges spans the entire &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，返回范围的串联都跨越整个 &lt;code&gt;haystack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fac8533d039fb2ca10f37bea36476dc0de1df00b" translate="yes" xml:space="preserve">
          <source>In all other cases, a simple element by element addition is done.</source>
          <target state="translated">在其他情况下,都要进行简单的逐个元素加法。</target>
        </trans-unit>
        <trans-unit id="394148797f50691adb9a270f990a5eaca722863e" translate="yes" xml:space="preserve">
          <source>In all other cases, the built-in behavior is carried out.</source>
          <target state="translated">在所有其他情况下,都会执行内置行为。</target>
        </trans-unit>
        <trans-unit id="b68e1d58907e07140ccd3efadbc43c332f170e2d" translate="yes" xml:space="preserve">
          <source>In all other respects this function works just like &lt;code&gt;spawnProcess&lt;/code&gt;. Please refer to the &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; documentation for descriptions of the other function parameters, the return value and any exceptions that may be thrown.</source>
          <target state="translated">在所有其他方面，此功能都像 &lt;code&gt;spawnProcess&lt;/code&gt; 一样工作。请参考&lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt;文档以获取其他函数参数，返回值以及可能引发的任何异常的描述。</target>
        </trans-unit>
        <trans-unit id="1cc108da5c2c3788f98a6edf95e1a63a36afb311" translate="yes" xml:space="preserve">
          <source>In all string literal forms, an &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; is regarded as a single &lt;code&gt;\n&lt;/code&gt; character.</source>
          <target state="translated">在所有字符串文字形式中，&lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;被视为单个 &lt;code&gt;\n&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="60b9a383afd7a0fd8bdda37a3d66b0a2bbb686e7" translate="yes" xml:space="preserve">
          <source>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc.</source>
          <target state="translated">在所有其他方面,这些方法和其他方法一样。它们可以是静态的,有不同的联系,有自己的地址,等等。</target>
        </trans-unit>
        <trans-unit id="4560285d4cfc645e0ef24ee3db5890ff1443ed09" translate="yes" xml:space="preserve">
          <source>In both C++ and D, if a struct has zero fields, the struct still has a size of 1 byte. But, in C++ if the struct with zero fields is used as a base struct, its size is zero (called the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt;). There are two methods for emulating this behavior in D. The first forwards references to a function returning a faked reference to the base:</source>
          <target state="translated">在C ++和D中，如果一个结构具有零个字段，则该结构的大小仍为1个字节。但是，在C ++中，如果将具有零字段的结构用作基础结构，则其大小为零（称为&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;空基础优化&lt;/a&gt;）。有两种方法可以在D中模拟此行为。第一种方法是转发对函数的引用，该函数会将伪造的引用返回给基数：</target>
        </trans-unit>
        <trans-unit id="b076421b0fbcae191c5dc3ef2368683aca391393" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier starting with &lt;code&gt; &quot;%(&quot;&lt;/code&gt; and ending with &lt;code&gt;&quot;%)&quot;&lt;/code&gt;, &lt;code&gt;_nested&lt;/code&gt; contains the string contained within the two separators.</source>
          <target state="translated">对于复合格式说明符，其开头为 &lt;code&gt; &quot;%(&quot;&lt;/code&gt; ，结尾为 &lt;code&gt;&quot;%)&quot;&lt;/code&gt; ，则 &lt;code&gt;_nested&lt;/code&gt; 包含两个分隔符中包含的字符串。</target>
        </trans-unit>
        <trans-unit id="b3a4dc18e455dc36e9fd73a88e062b9df8c0d722" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier, &lt;code&gt;_sep&lt;/code&gt; contains the string positioning after &lt;code&gt;&quot;%|&quot;&lt;/code&gt;. &lt;code&gt;sep is null&lt;/code&gt; means no separator else &lt;code&gt;sep.empty&lt;/code&gt; means 0 length separator.</source>
          <target state="translated">对于复合格式说明符， &lt;code&gt;_sep&lt;/code&gt; 包含字符串在 &lt;code&gt;&quot;%|&quot;&lt;/code&gt; 之后的位置 。 &lt;code&gt;sep is null&lt;/code&gt; 表示没有分隔符，否则 &lt;code&gt;sep.empty&lt;/code&gt; 表示长度为0的分隔符。</target>
        </trans-unit>
        <trans-unit id="c172129354e9ba73756e23e6e1f6e0e605a52cb9" translate="yes" xml:space="preserve">
          <source>In case of a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; nothing will happen.</source>
          <target state="translated">如果出现带有 &lt;code&gt;LogLevel.fatal&lt;/code&gt; 的日志消息，则不会发生任何事情。</target>
        </trans-unit>
        <trans-unit id="3ebef375cea9cd0eca25afb26b6d5c11eab7f3f0" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">如果发生I / O错误， &lt;code&gt;StdioException&lt;/code&gt; 引发StdioException。</target>
        </trans-unit>
        <trans-unit id="39a07628e75ba54420c0ee35d2d7947fae3e6e95" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;a href=&quot;#StdioException&quot;&gt;&lt;code&gt;StdioException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果发生I / O错误，则抛出&lt;a href=&quot;#StdioException&quot;&gt; &lt;code&gt;StdioException&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c94ce1719c011e5c08b47d8a880eaa8ed1ab504" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">如果发生I / O错误，则抛出 &lt;code&gt;StdioException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="072442afd2ab0da30ef9131acbdaeefa3c16749b" translate="yes" xml:space="preserve">
          <source>In case you want to only enable bundling for some of the parameters, bundling can be turned off with &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt;.</source>
          <target state="translated">如果只想对某些参数启用捆绑，则可以使用 &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt; 关闭捆绑。</target>
        </trans-unit>
        <trans-unit id="01d85046192eeac78a5da365dc7670fdea8d6e86" translate="yes" xml:space="preserve">
          <source>In cases where producing the replacement is the ultimate goal &lt;a href=&quot;#replaceFirstInto&quot;&gt;&lt;code&gt;replaceFirstInto&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAllInto&quot;&gt;&lt;code&gt;replaceAllInto&lt;/code&gt;&lt;/a&gt; could come in handy as functions that avoid allocations even for replacement.</source>
          <target state="translated">在产生替换是最终目标的情况下，&lt;a href=&quot;#replaceFirstInto&quot;&gt; &lt;code&gt;replaceFirstInto&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#replaceAllInto&quot;&gt; &lt;code&gt;replaceAllInto&lt;/code&gt; &lt;/a&gt;可以派上用场，因为这些函数即使在替换时也可以避免分配。</target>
        </trans-unit>
        <trans-unit id="e6177e81e2c8557108ce3bebc0ad228b2a46f372" translate="yes" xml:space="preserve">
          <source>In cases where the operand size is ambiguous, as in:</source>
          <target state="translated">在操作数大小不明确的情况下,如:。</target>
        </trans-unit>
        <trans-unit id="a7faf0c1f2db2bcd1f30944e523bc6e5d4329044" translate="yes" xml:space="preserve">
          <source>In cases where the string in question is already normalized, it is returned unmodified and no memory allocation happens.</source>
          <target state="translated">在相关字符串已经归一化的情况下,会不加修改地返回,不会发生内存分配。</target>
        </trans-unit>
        <trans-unit id="7c2d083ad99e82982be1c8520585485c563982d6" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;__delete(x)&lt;/code&gt; returns with no effect if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. Otherwise, it performs the following actions in sequence:</source>
          <target state="translated">详细地，如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则 &lt;code&gt;__delete(x)&lt;/code&gt; 返回无效。否则，它将按顺序执行以下操作：</target>
        </trans-unit>
        <trans-unit id="1a253df89cf875b96f6b0b99a704c14478bd5687" translate="yes" xml:space="preserve">
          <source>In effect &lt;code&gt;takeOne(r)&lt;/code&gt; is somewhat equivalent to &lt;code&gt;take(r, 1)&lt;/code&gt; but in certain interfaces it is important to know statically that the range may only have at most one element.</source>
          <target state="translated">实际上， &lt;code&gt;takeOne(r)&lt;/code&gt; 在某种程度上等同于 &lt;code&gt;take(r, 1)&lt;/code&gt; 但在某些接口中，重要的是要静态地知道该范围最多只能包含一个元素。</target>
        </trans-unit>
        <trans-unit id="c7e90e95cc2e5d025786e563cb98d86e57f261c9" translate="yes" xml:space="preserve">
          <source>In either case, the content of the buffer is reused across calls. That means &lt;code&gt;front&lt;/code&gt; will not persist after &lt;code&gt;popFront&lt;/code&gt; is called, so if retention is needed, the caller must copy its contents (e.g. by calling &lt;code&gt;buffer.dup&lt;/code&gt;).  In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  With the mentioned limitations, &lt;code&gt;byChunk&lt;/code&gt; works with any algorithm compatible with input ranges.</source>
          <target state="translated">无论哪种情况，缓冲区的内容都会在调用之间重用。这意味着 &lt;code&gt;front&lt;/code&gt; 后将不会保留 &lt;code&gt;popFront&lt;/code&gt; 被调用，所以如果需要保存，调用者必须复制的内容（例如，通过调用 &lt;code&gt;buffer.dup&lt;/code&gt; ）。在上面的示例中，对于所有迭代， &lt;code&gt;buffer.length&lt;/code&gt; 为4096（最后一次除外），在这种情况下， &lt;code&gt;buffer.length&lt;/code&gt; 可能小于4096（但始终大于零）。由于上述限制， &lt;code&gt;byChunk&lt;/code&gt; 可以与任何与输入范围兼容的算法一起使用。</target>
        </trans-unit>
        <trans-unit id="8ec7633257f9bdb307965ba1607259244c489e1d" translate="yes" xml:space="preserve">
          <source>In free list mode, &lt;code&gt;KRRegion&lt;/code&gt; embeds a free blocks list onto the chunk of memory. The free list is circular, coalesced, and sorted by address at all times. Allocations and deallocations take time proportional to the number of previously deallocated blocks. (In practice the cost may be lower, e.g. if memory is deallocated in reverse order of allocation, all operations take constant time.) Memory utilization is good (small control structure and no per-allocation overhead). The disadvantages of freelist mode include proneness to fragmentation, a minimum allocation size of two words, and linear worst-case allocation and deallocation times.</source>
          <target state="translated">在空闲列表模式下， &lt;code&gt;KRRegion&lt;/code&gt; 将空闲块列表嵌入到内存块中。空闲列表是循环的，合并的，并始终按地址排序。分配和解除分配所花费的时间与先前解除分配的块数成正比。 （实际上，成本可能较低，例如，如果以分配的相反顺序释放内存，则所有操作都将花费恒定的时间。）内存利用率良好（控制结构小且无按分配开销）。自由列表模式的缺点包括易于碎片化，两个单词的最小分配大小以及线性最坏情况分配和释放时间。</target>
        </trans-unit>
        <trans-unit id="cdf7807c516e1443dffb3bd59e60f6a917c9df07" translate="yes" xml:space="preserve">
          <source>In function scopes, imported symbols only become visible after the import declaration lexically appears in the function body. In other words, imported symbols at function scope cannot be forward referenced.</source>
          <target state="translated">在函数作用域中,导入的符号只有在导入声明以词法出现在函数体中之后才会显现。换句话说,在函数作用域的导入符号不能被前向引用。</target>
        </trans-unit>
        <trans-unit id="c0383119e4652a168035af7434f3705bce886b19" translate="yes" xml:space="preserve">
          <source>In functional programming languages this is typically called &lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;scanl&lt;/code&gt;, &lt;code&gt;scanLeft&lt;/code&gt; or &lt;code&gt;reductions&lt;/code&gt;.</source>
          <target state="translated">在函数式编程语言中，这通常被称为 &lt;code&gt;scan&lt;/code&gt; ， &lt;code&gt;scanl&lt;/code&gt; ， &lt;code&gt;scanLeft&lt;/code&gt; 或 &lt;code&gt;reductions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fb398e80e5a7daebe5fe79cc756231990bf0b4c" translate="yes" xml:space="preserve">
          <source>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag). Otherwise, they may become &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombies&lt;/a&gt;&quot; &amp;ndash; processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them.</source>
          <target state="translated">通常，除非退出该进程时已将其视为已分离（使用 &lt;code&gt;Config.detached&lt;/code&gt; 标志生成），否则在退出父进程之前，应始终等待子进程终止。否则，它们可能会变成&amp;ldquo; &lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;僵尸&lt;/a&gt; &amp;rdquo;，即已消失的进程，但仍占据OS进程表中的插槽。您不应也不应该等待分离的进程，因为您不拥有它们。</target>
        </trans-unit>
        <trans-unit id="2a9fd3d1c20814161b33ee0afa7c06fcf185414e" translate="yes" xml:space="preserve">
          <source>In general periodically 'reseeding' a PRNG does not improve its quality and in some cases may harm it. For an extreme example the Mersenne Twister has &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; distinct states but after &lt;code&gt;seed(uint)&lt;/code&gt; is called it can only be in one of &lt;code&gt;2 ^^ 32&lt;/code&gt; distinct states regardless of how excellent the source of entropy is.</source>
          <target state="translated">通常，定期&amp;ldquo;重新播种&amp;rdquo; PRNG不会提高其质量，在某些情况下可能会损害它。举一个极端的例子，梅森扭转者有 &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; 不同的状态，但是在调用 &lt;code&gt;seed(uint)&lt;/code&gt; 之后，无论熵的来源多么出色，它只能处于 &lt;code&gt;2 ^^ 32&lt;/code&gt; 个不同的状态之一。</target>
        </trans-unit>
        <trans-unit id="fc32a5290aa168583cf02dd9b13039ee5589d851" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#isValidPath&quot;&gt;&lt;code&gt;isValidPath&lt;/code&gt;&lt;/a&gt; functions to check this.</source>
          <target state="translated">通常，此模块中的功能假定输入路径格式正确。（也就是说，它们不应包含无效字符，它们应遵循文件系统的路径格式等。）在格式错误的路径上调用函数的结果是不确定的。当路径或文件名可能无效时（例如，当用户输入了路径或文件名时），有时可能希望使用&lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#isValidPath&quot;&gt; &lt;code&gt;isValidPath&lt;/code&gt; &lt;/a&gt;函数进行检查。</target>
        </trans-unit>
        <trans-unit id="7566506eebd3c530fd7b49f9458b9e3829cd9289" translate="yes" xml:space="preserve">
          <source>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</source>
          <target state="translated">在很多情况下,调用sizeof()不能直接用于获取数据类型大小,因为支持交叉编译,最终会使用主机大小而不是目标大小。</target>
        </trans-unit>
        <trans-unit id="35dd64591779170e8008d349dad053c6fa8f2446" translate="yes" xml:space="preserve">
          <source>In nested</source>
          <target state="translated">嵌套式</target>
        </trans-unit>
        <trans-unit id="8575ac5b58d78f8ffa7cfeed41b65f5b48950967" translate="yes" xml:space="preserve">
          <source>In older versions of Phobos, it used to be possible to write:</source>
          <target state="translated">在Phobos的旧版本中,以前可以写。</target>
        </trans-unit>
        <trans-unit id="2e095fc6159a0d37540c3fe665eef32c69ad9690" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;Logger&lt;/code&gt; must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的所述的 &lt;code&gt;Logger&lt;/code&gt; 必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="60952b4bdab4bfb5f5a8d1d83bb07430530eeffe" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; add the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的所述的 &lt;code&gt;sharedLog&lt;/code&gt; 必须大于或等于 &lt;code&gt;defaultLogLevel&lt;/code&gt; 添加传递必须的条件 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e11fddcd19d6f16f616c57c6e260430b0f9d9a4" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的所述的 &lt;code&gt;sharedLog&lt;/code&gt; 必须大于或等于 &lt;code&gt;defaultLogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f8c65e46c163f6fc77fddc2b9a77d78f4961ef7" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了处理数据，日志调用的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;sharedLog&lt;/code&gt; 和 &lt;code&gt;defaultLogLevel&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，另外，传递的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed49a17d9874b268342f0db2f71435916af05001" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的日志呼叫必须大于或等于所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;sharedLog&lt;/code&gt; 和 &lt;code&gt;defaultLogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c93e7b85e99ec02f5d168562dae2b831dda8259" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">为了使要处理的数据的 &lt;code&gt;LogLevel&lt;/code&gt; 的日志呼叫必须大于或等于所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;sharedLog&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f87139f757185970527b89c7ad28046b560c58f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了处理数据，日志调用的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;defaultLogLevel&lt;/code&gt; ,另外，传递的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a54f9edb0000f15c332443c24f6eb668c55c8501" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">为了处理数据，日志调用的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;defaultLogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14b107fabc6c81ab2222b96dfa0c1ecd6dfba19f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed, the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了要处理的数据，所述 &lt;code&gt;LogLevel&lt;/code&gt; 日志呼叫必须大于或等于所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;sharedLog&lt;/code&gt; 和 &lt;code&gt;defaultLogLevel&lt;/code&gt; ; 另外，通过的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bb3ac7d5c9d6c962a9241e9025396626aa9beb6" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;sharedLog&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。另外，该 &lt;code&gt;LogLevel&lt;/code&gt; 的必须大于或等于比所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;stdSharedLogger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79abe30476f4ca10a8c01c609e3f868cb8a10f27" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;. If a condition is given, it must evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。另外，该 &lt;code&gt;LogLevel&lt;/code&gt; 的必须大于或等于比所述 &lt;code&gt;LogLevel&lt;/code&gt; 所述的 &lt;code&gt;stdSharedLogger&lt;/code&gt; 。如果给出条件，则必须评估为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18e494163438a3079c18b40fa80b56a34c4d5c22" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录生成的日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; ,此外，传递的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2b84c1fc96a4a1e141069ab63dfce487512e519" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the passed condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录生成的日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; ,此外，传递的条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c8530a345a9b66847038330015135156125389c" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; ，并且条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20b9f3f3bdcf58be250caee88b15a55353fecc84" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息， &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; ，并且必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41a290703568517f05854f40487a48abaf094d9a" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息，使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; ，并且条件必须为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61c93a13b86326686a55e702c7620856cee5be12" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">为了记录结果日志消息，使用的 &lt;code&gt;Logger&lt;/code&gt; 的 &lt;code&gt;LogLevel&lt;/code&gt; 必须大于或等于全局 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9091984c8dee40a3793a920b8fc726ff3fb2b605" translate="yes" xml:space="preserve">
          <source>In order to be usable as an allocator, a type should implement the following methods with their respective semantics. Only &lt;code&gt;alignment&lt;/code&gt; and &lt;code&gt;allocate&lt;/code&gt; are required. If any of the other methods is missing, the allocator is assumed to not have that capability (for example some allocators do not offer manual deallocation of memory). Allocators should NOT implement unsupported methods to always fail. For example, an allocator that lacks the capability to implement &lt;code&gt;alignedAllocate&lt;/code&gt; should not define it at all (as opposed to defining it to always return &lt;code&gt;null&lt;/code&gt; or throw an exception). The missing implementation statically informs other components about the allocator's capabilities and allows them to make design decisions accordingly.</source>
          <target state="translated">为了可用作分配器，类型应使用其各自的语义实现以下方法。仅需要 &lt;code&gt;alignment&lt;/code&gt; 和 &lt;code&gt;allocate&lt;/code&gt; 。如果缺少任何其他方法，则认为分配器不具备该功能（例如，某些分配器不提供对内存的手动重新分配）。分配者不应实施不受支持的方法，以使其始终失败。例如，缺乏实现 &lt;code&gt;alignedAllocate&lt;/code&gt; 功能的分配器根本不应定义它（与将其定义为始终返回 &lt;code&gt;null&lt;/code&gt; 或引发异常相反）。缺少的实现将分配器的功能静态通知其他组件，并允许它们相应地做出设计决策。</target>
        </trans-unit>
        <trans-unit id="6dda110f1f25b5663505eb11f44cd82e44a8c31d" translate="yes" xml:space="preserve">
          <source>In order to determine if an object &lt;code&gt;o&lt;/code&gt; is an instance of a class &lt;code&gt;B&lt;/code&gt; use a cast:</source>
          <target state="translated">为了确定对象 &lt;code&gt;o&lt;/code&gt; 是否是 &lt;code&gt;B&lt;/code&gt; 类的实例，请使用强制转换：</target>
        </trans-unit>
        <trans-unit id="1e18ff30e3740b378cdaf28cc4934f896ccbee30" translate="yes" xml:space="preserve">
          <source>In order to disable logging at compile time, pass &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; as a version argument to the &lt;code&gt;D&lt;/code&gt; compiler when compiling your program code. This will disable all logging functionality. Specific &lt;code&gt;LogLevel&lt;/code&gt; can be disabled at compile time as well. In order to disable logging with the &lt;code&gt;trace&lt;/code&gt;&lt;code&gt;LogLevel&lt;/code&gt; pass &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; as a version. The following table shows which version statement disables which &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">为了在编译时禁用日志记录，请在编译程序代码时将 &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; 作为版本参数传递给 &lt;code&gt;D&lt;/code&gt; 编译器。这将禁用所有日志记录功能。也可以在编译时禁用特定的 &lt;code&gt;LogLevel&lt;/code&gt; 。为了禁用 &lt;code&gt;trace&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; 的日志记录，请将 &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; 作为版本传递。下表显示了哪个版本语句禁用了哪个 &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a77a52d87761074b435f02e38ba4ed22e517df1c" translate="yes" xml:space="preserve">
          <source>In order to do put the length at the front, we have to provide 16 bytes buffer space in case the block has to be aligned properly. In x86, certain SSE instructions will only work if the data is 16-byte aligned. In addition, we need the sentinel byte to prevent accidental pointers to the next block. Because of the extra overhead, we only do this for page size and above, where the overhead is minimal compared to the block size.</source>
          <target state="translated">为了做到把长度放在前面,我们必须提供16个字节的缓冲空间,以防块必须正确对齐。在x86中,某些SSE指令只有在数据是16字节对齐的情况下才会工作。此外,我们还需要哨兵字节来防止意外指向下一个块。由于额外的开销,我们只在页大小及以上的情况下这样做,与块大小相比,开销很小。</target>
        </trans-unit>
        <trans-unit id="0cc93ffa6b67fa20835799cad3635970d48f4206" translate="yes" xml:space="preserve">
          <source>In order to work, &lt;code&gt;FallbackAllocator&lt;/code&gt; requires that &lt;code&gt;Primary&lt;/code&gt; defines the &lt;code&gt;owns&lt;/code&gt; method. This is needed in order to decide which allocator was responsible for a given allocation.</source>
          <target state="translated">为了工作， &lt;code&gt;FallbackAllocator&lt;/code&gt; 要求 &lt;code&gt;Primary&lt;/code&gt; 定义了 &lt;code&gt;owns&lt;/code&gt; 方法。为了确定哪个分配器负责给定分配，这是必需的。</target>
        </trans-unit>
        <trans-unit id="3cb2dd17fb05bd389b6b34ea2ea85ffe8dc6328a" translate="yes" xml:space="preserve">
          <source>In other words, casting literal expression will change the literal type.</source>
          <target state="translated">换句话说,铸造字面表达式将改变字面类型。</target>
        </trans-unit>
        <trans-unit id="675933f346891ba4fb04a779eea3dd5e21b2c0bb" translate="yes" xml:space="preserve">
          <source>In previous versions of Phobos, this was known as &lt;code&gt;TypeTuple&lt;/code&gt;.</source>
          <target state="translated">在以前的Phobos版本中，这称为 &lt;code&gt;TypeTuple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26154800831f1a5ff6a19e1167b2ddcacfdb1c76" translate="yes" xml:space="preserve">
          <source>In principle, only thrown objects derived from this class are safe to catch inside a &lt;code&gt;catch&lt;/code&gt; block. Thrown objects not derived from Exception represent runtime errors that should not be caught, as certain runtime guarantees may not hold, making it unsafe to continue program execution.</source>
          <target state="translated">原则上，只有派生自此类的对象才能安全地捕获在 &lt;code&gt;catch&lt;/code&gt; 块内。不是从Exception派生的抛出对象表示不应捕获的运行时错误，因为某些运行时保证可能不成立，因此继续执行程序是不安全的。</target>
        </trans-unit>
        <trans-unit id="0b93464d0fbabeded10a475db02ab91f9147bd5b" translate="yes" xml:space="preserve">
          <source>In principle, this is the name of the local time zone. However, this always returns the empty string. This is because time zones cannot be uniquely identified by the attributes given by the OS (such as the &lt;code&gt;stdName&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt;), and neither Posix systems nor Windows systems provide an easy way to get the TZ Database name of the local time zone.</source>
          <target state="translated">原则上，这是本地时区的名称。但是，这总是返回空字符串。这是因为时区无法由操作系统提供的属性（例如 &lt;code&gt;stdName&lt;/code&gt; 和 &lt;code&gt;dstName&lt;/code&gt; ）唯一地标识，并且Posix系统和Windows系统都没有提供获取本地时区的TZ数据库名称的简便方法。</target>
        </trans-unit>
        <trans-unit id="0b9fb0301ede6ae1f71c55d50ab376078de554f8" translate="yes" xml:space="preserve">
          <source>In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'.</source>
          <target state="translated">在单行模式下,匹配任何字符,否则匹配除&quot;\n &quot;和&quot;\r &quot;以外的任何字符。否则它将匹配除&quot;/n &quot;和&quot;/r &quot;以外的任何字符。</target>
        </trans-unit>
        <trans-unit id="77c1db69e3f99eb322088fa8127b36e0134ab790" translate="yes" xml:space="preserve">
          <source>In some date calculations, adding months or years can cause the date to fall on a day of the month which is not valid (e.g. February 29th 2001 or June 31st 2000). If overflow is allowed (as is the default), then the month will be incremented accordingly (so, February 29th 2001 would become March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow is not allowed, then the day will be adjusted to the last valid day in that month (so, February 29th 2001 would become February 28th 2001 and June 31st 2000 would become June 30th 2000).</source>
          <target state="translated">在某些日期计算中,添加月份或年份可能会导致日期落在月份的某一天,而这一天是无效的(例如2001年2月29日或2000年6月31日)。如果允许溢出(默认情况下),那么月份将相应地递增(因此,2001年2月29日将成为2001年3月1日,2000年6月31日将成为2000年7月1日)。如果不允许溢出,那么日期将被调整到该月的最后一天(因此,2001年2月29日将成为2001年2月28日,2000年6月31日将成为2000年6月30日)。</target>
        </trans-unit>
        <trans-unit id="0f7765db47c238a56000c8a0537e8a769de4649d" translate="yes" xml:space="preserve">
          <source>In std.datetime, it is also used as the result of various arithmetic operations on time points.</source>
          <target state="translated">在std.datetime中,它也被用作对时间点进行各种算术运算的结果。</target>
        </trans-unit>
        <trans-unit id="9d8f072b0ee81fd114d71e25f9472d419503fd30" translate="yes" xml:space="preserve">
          <source>In the above situations the errors do not contain line numbers because the errors are regarding generated code.</source>
          <target state="translated">在上述情况下,错误不包含行号,因为错误是关于生成的代码。</target>
        </trans-unit>
        <trans-unit id="83c0d2545855dad1e2136f8a2d0797213523dbd3" translate="yes" xml:space="preserve">
          <source>In the case above, the element at slot &lt;code&gt;1&lt;/code&gt; is removed, but replaced with the last element of the range. Taking advantage of the relaxation of the stability requirement, &lt;code&gt;remove&lt;/code&gt; moved elements from the end of the array over the slots to be removed. This way there is less data movement to be done which improves the execution time of the function.</source>
          <target state="translated">在上述情况下，插槽 &lt;code&gt;1&lt;/code&gt; 中的元素已删除，但被范围中的最后一个元素替换。利用放宽稳定性要求的方法，从要移除的插槽上方的阵列末端 &lt;code&gt;remove&lt;/code&gt; 移动的元素。这样，减少了要执行的数据移动，从而缩短了函数的执行时间。</target>
        </trans-unit>
        <trans-unit id="d1310273f42b4567d006ba733761bffcc94a7323" translate="yes" xml:space="preserve">
          <source>In the case of multisets, considering that element &lt;code&gt;a&lt;/code&gt; appears &lt;code&gt;x&lt;/code&gt; times in &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; times and &lt;code&gt;r2&lt;/code&gt;, the number of occurences of &lt;code&gt;a&lt;/code&gt; in the resulting range is going to be &lt;code&gt;x-y&lt;/code&gt; if x &amp;gt; y or 0 otherwise.</source>
          <target state="translated">在多集的情况下，考虑到元件 &lt;code&gt;a&lt;/code&gt; 出现 &lt;code&gt;x&lt;/code&gt; 在时间 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 倍和 &lt;code&gt;r2&lt;/code&gt; ，的出现次数的数量 &lt;code&gt;a&lt;/code&gt; 在所得的范围将是 &lt;code&gt;x-y&lt;/code&gt; 如果X&amp;gt; Y，否则为0。</target>
        </trans-unit>
        <trans-unit id="574341dd05f59907247dd44e449ed7bd5386146b" translate="yes" xml:space="preserve">
          <source>In the case of multisets, the range with the minimum number of occurences of a given element, propagates the number of occurences of this element to the resulting range.</source>
          <target state="translated">在多集的情况下,给定元素出现次数最少的范围,将这个元素的出现次数传播到结果范围。</target>
        </trans-unit>
        <trans-unit id="c31bb38a42ef0f5a89fce05942de3e9a5d76ab7c" translate="yes" xml:space="preserve">
          <source>In the case of the monotonic time, &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; is templatized on &lt;code&gt;ClockType&lt;/code&gt;, whereas with &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;, its a runtime argument, since in the case of the monotonic time, the type of the clock affects the resolution of a &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; object, whereas with &lt;a href=&quot;std_datetime#SysTime&quot;&gt;&lt;code&gt;std.datetime.SysTime&lt;/code&gt;&lt;/a&gt;, its resolution is always hecto-nanoseconds regardless of the source of the time.</source>
          <target state="translated">在的单调时间的情况下，&lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;被模板化上 &lt;code&gt;ClockType&lt;/code&gt; ，而用 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; ，其运行时的参数，因为在的单调时间的情况下，时钟的类型会影响一个的分辨率&lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt;对象，而使用&lt;a href=&quot;std_datetime#SysTime&quot;&gt; &lt;code&gt;std.datetime.SysTime&lt;/code&gt; 时&lt;/a&gt;，其分辨率始终为十进制纳秒，而与时间来源无关。</target>
        </trans-unit>
        <trans-unit id="48d19d43ba624ca8d4f15f601b46da39df170632" translate="yes" xml:space="preserve">
          <source>In the corresponding D code, &lt;code&gt;foo&lt;/code&gt; is declared as having C++ linkage and function calling conventions:</source>
          <target state="translated">在相应的D代码中， &lt;code&gt;foo&lt;/code&gt; 被声明为具有C ++链接和函数调用约定：</target>
        </trans-unit>
        <trans-unit id="c2859b376d9322070e57e0df9e0b545f1ad11ef9" translate="yes" xml:space="preserve">
          <source>In the current function, we are calling 'this' function. 1. Check to see if the current function can call 'this' function, issue error if not. 2. If the current function is not the parent of 'this' function, then add the current function to the list of siblings of 'this' function. 3. If the current function is a literal, and it's accessing an uplevel scope, then mark it as a delegate. Returns true if error occurs.</source>
          <target state="translated">在当前函数中,我们调用的是'this'函数。1.检查当前函数是否可以调用'this'函数,如果不可以,发出错误。2.如果当前函数不是'this'函数的父函数,则将当前函数加入到'this'函数的兄弟姐妹列表中。3.如果当前函数是一个文字,并且它正在访问一个上级作用域,那么将其标记为委托。如果发生错误,则返回true。</target>
        </trans-unit>
        <trans-unit id="27341e1e33d3f1a9c524981309a60954fc820a69" translate="yes" xml:space="preserve">
          <source>In the example above, &quot;--foo&quot; and &quot;--bar&quot; are recognized, but &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;, etc. are rejected. The directive is active until the end of &lt;code&gt;getopt&lt;/code&gt;, or until the converse directive &lt;code&gt;caseInsensitive&lt;/code&gt; is encountered:</source>
          <target state="translated">在上面的示例中，识别了&amp;ldquo; --foo&amp;rdquo;和&amp;ldquo; --bar&amp;rdquo;，但是拒绝了&amp;ldquo; --Foo&amp;rdquo;，&amp;ldquo;-Bar&amp;rdquo;，&amp;ldquo;-FOo&amp;rdquo;，&amp;ldquo;-bAr&amp;rdquo;等。该指令一直有效，直到 &lt;code&gt;getopt&lt;/code&gt; 结束或遇到相反的指令 &lt;code&gt;caseInsensitive&lt;/code&gt; 为止：</target>
        </trans-unit>
        <trans-unit id="4dfbc2e24539434e62842bac389911ff9852ba28" translate="yes" xml:space="preserve">
          <source>In the graph above, any directed path is a legal implicit conversion. No other qualifier combinations than the ones shown is valid. If a directed path exists between two sets of qualifiers, the types thus qualified are called &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;. The same information is shown below in tabular format:</source>
          <target state="translated">在上图中，任何有向路径都是合法的隐式转换。除显示的限定符组合外，没有其他限定符组合是有效的。如果两组限定词之间存在定向路径，则这样限定的类型称为&lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;。下面以表格形式显示了相同的信息：</target>
        </trans-unit>
        <trans-unit id="02f036d56e5b0f17d6cada283807ab6e4a45c16d" translate="yes" xml:space="preserve">
          <source>In the second step, path components are compared using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">在第二步中，使用 &lt;code&gt;filenameCmp!cs&lt;/code&gt; 比较路径组件，其中 &lt;code&gt;cs&lt;/code&gt; 是一个可选的模板参数，用于确定比较是否区分大小写。有关详细信息，请参见&lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="e25b68a7396b82d8e5f58fe981088b3bb4f8c195" translate="yes" xml:space="preserve">
          <source>In the special case where only a single function is provided (&lt;code&gt;F.length == 1&lt;/code&gt;), adjoin simply aliases to the single passed function (&lt;code&gt;F[0]&lt;/code&gt;).</source>
          <target state="translated">在仅提供单个函数的特殊情况下（ &lt;code&gt;F.length == 1&lt;/code&gt; ），仅将别名附加到单个传递的函数（ &lt;code&gt;F[0]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0d9fe9a61d26a09ceb6b95fd6ad82498884dadd5" translate="yes" xml:space="preserve">
          <source>In the table below, the &lt;b&gt;exact alias&lt;/b&gt;es are types of exactly the specified number of bits. The &lt;b&gt;at least alias&lt;/b&gt;es are at least the specified number of bits large, and can be larger. The &lt;b&gt;fast alias&lt;/b&gt;es are the fastest integral type supported by the processor that is at least as wide as the specified number of bits.</source>
          <target state="translated">在下表中，&lt;b&gt;确切的别名&lt;/b&gt; es恰好是指定位数的类型。所述&lt;b&gt;至少别名&lt;/b&gt; ES是至少大位的指定数量，并且可以更大。的&lt;b&gt;快速别名&lt;/b&gt; ES是由至少一样宽的比特的指定数目的处理器支持的最快的整数类型。</target>
        </trans-unit>
        <trans-unit id="2b57bd98576c6b47e51f692ed2880671dfdcaf21" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;myAllocator&lt;/code&gt; does not obey the &lt;code&gt;IAllocator&lt;/code&gt; interface, but implements its primitives so it can work with &lt;code&gt;makeArray&lt;/code&gt; by means of duck typing.  One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through &lt;code&gt;IAllocator&lt;/code&gt;. An important rule of thumb is: &quot;assemble allocator first, adapt to &lt;code&gt;IAllocator&lt;/code&gt; after&quot;. A good allocator implements intricate logic by means of template assembly, and gets wrapped with &lt;code&gt;IAllocator&lt;/code&gt; (usually by means of &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt;) only once, at client level.</source>
          <target state="translated">在这种情况下， &lt;code&gt;myAllocator&lt;/code&gt; 不遵循 &lt;code&gt;IAllocator&lt;/code&gt; 接口，但是实现了其原语，因此可以通过鸭子类型与 &lt;code&gt;makeArray&lt;/code&gt; 一起使用。关于此设置要注意的一件事是，静态类型的组合分配器几乎总是比通过 &lt;code&gt;IAllocator&lt;/code&gt; 的分配器更快。一个重要的经验法则是：&amp;ldquo;先组装分配器，然后再适应 &lt;code&gt;IAllocator&lt;/code&gt; &amp;rdquo;。一个好的分配器通过模板组装来实现复杂的逻辑，并在客户端级别仅使用 &lt;code&gt;IAllocator&lt;/code&gt; （通常是通过&lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; &lt;/a&gt;）进行包装。</target>
        </trans-unit>
        <trans-unit id="0dbb9df98ee1772b091a23269b418c611c6689cc" translate="yes" xml:space="preserve">
          <source>In this case, the slots at positions 1, 3, 4, and 9 are removed from the array.</source>
          <target state="translated">在这种情况下,位置1、3、4和9的插槽被从阵列中移除。</target>
        </trans-unit>
        <trans-unit id="5961fb400c229a03dfc935fa996c5fe8fc78fdb9" translate="yes" xml:space="preserve">
          <source>In this implementation both arguments must be positive. The integral is evaluated by either a power series or continued fraction expansion, depending on the relative values of a and x.</source>
          <target state="translated">在这个实现中,两个参数都必须是正值。根据a和x的相对值,积分通过幂级数或持续分数展开来评估。</target>
        </trans-unit>
        <trans-unit id="bd2e85eebf3596f12832975a35b8c3545510433f" translate="yes" xml:space="preserve">
          <source>In this situation, the assignemnts are actual assign expressions (&lt;code&gt;opAssign&lt;/code&gt; is used if defined).</source>
          <target state="translated">在这种情况下，分配对象是实际的分配表达式（如果已定义，则使用 &lt;code&gt;opAssign&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cecc30a8b51b4071bb5efaef87b2c1dec1a96284" translate="yes" xml:space="preserve">
          <source>In this table &quot;doPut&quot; is a method that places &lt;code&gt;e&lt;/code&gt; into &lt;code&gt;r&lt;/code&gt;, using the correct primitive: &lt;code&gt;r.put(e)&lt;/code&gt; if &lt;code&gt;R&lt;/code&gt; defines &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;r.front = e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is an input range (followed by &lt;code&gt;r.popFront()&lt;/code&gt;), or &lt;code&gt;r(e)&lt;/code&gt; otherwise.</source>
          <target state="translated">在此表中，&amp;ldquo; doPut&amp;rdquo;是使用正确的原语将 &lt;code&gt;e&lt;/code&gt; 放入 &lt;code&gt;r&lt;/code&gt; 的方法：如果 &lt;code&gt;R&lt;/code&gt; 定义了 &lt;code&gt;put&lt;/code&gt; ，则 &lt;code&gt;r.put(e)&lt;/code&gt; ，如果 &lt;code&gt;r&lt;/code&gt; 是输入范围，则 &lt;code&gt;r.front = e&lt;/code&gt; （后跟 &lt;code&gt;r.popFront()&lt;/code&gt; )），否则返回 &lt;code&gt;r(e)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02a8b5c14dc9548c1a490e9d5960a9feca99259a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were a function.</source>
          <target state="translated">这样一来,一个结构体或类对象就可以像一个函数一样行事。</target>
        </trans-unit>
        <trans-unit id="17982ced0afda199d35d40c9d0672932dd55162a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were an array.</source>
          <target state="translated">通过这种方式,一个结构体或类对象可以像数组一样行为。</target>
        </trans-unit>
        <trans-unit id="86f8f90c18dbc0f9d343ef02fb0a4cd117e4553c" translate="yes" xml:space="preserve">
          <source>In user code. This class also provides means to add version identifier to the list of global (cross module) identifiers.</source>
          <target state="translated">在用户代码中。该类还提供了将版本标识符添加到全局(跨模块)标识符列表中的方法。</target>
        </trans-unit>
        <trans-unit id="bdee4d1acbdd89d7f24aebad7aeee092188b3727" translate="yes" xml:space="preserve">
          <source>In, Out and Inheritance</source>
          <target state="translated">进、出和继承</target>
        </trans-unit>
        <trans-unit id="783253f63cea9c514d69689860a1ae050327457b" translate="yes" xml:space="preserve">
          <source>In-order Pentium (Pentium1, PMMX, Atom)</source>
          <target state="translated">按顺序排列的奔腾(Pentium1,PMMX,Atom)</target>
        </trans-unit>
        <trans-unit id="7d5a97d89ad4a3be9582069b3310a6d0aee11430" translate="yes" xml:space="preserve">
          <source>InExpression</source>
          <target state="translated">InExpression</target>
        </trans-unit>
        <trans-unit id="6b952134a590c37c3cd245f783f0cab0b35e154b" translate="yes" xml:space="preserve">
          <source>Include all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; options.</source>
          <target state="translated">包括所有&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="21d63116a735028b1065c53175a7201eb75a690c" translate="yes" xml:space="preserve">
          <source>Include none of the above options.</source>
          <target state="translated">不包括上述任何选项。</target>
        </trans-unit>
        <trans-unit id="7fb47f835a97695060fa50d3d9efcf9e0fff9c84" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds (100 ns)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (microseconds), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;months&quot;&lt;/code&gt;, and &lt;code&gt;&quot;years&quot;&lt;/code&gt;</source>
          <target state="translated">包括 &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; （百纳秒（100 ns））， &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; （微秒）， &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; （毫秒）， &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; ， &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; ， &lt;code&gt;&quot;hours&quot;&lt;/code&gt; ， &lt;code&gt;&quot;days&quot;&lt;/code&gt; ， &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; ， &lt;code&gt;&quot;months&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;years&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660485a4ef4f2ea299a5049e5e7f68faa3ac9dd9" translate="yes" xml:space="preserve">
          <source>Includes characters a, b, c, ..., z.</source>
          <target state="translated">包括字符a,b,c,...,z。</target>
        </trans-unit>
        <trans-unit id="e622b4457bdf3ceb03f6cf725fab2a67de905818" translate="yes" xml:space="preserve">
          <source>Incomplete beta integral</source>
          <target state="translated">不完全β积分</target>
        </trans-unit>
        <trans-unit id="861a53fcf5c388edd7cf46ce6d95a43e95f0e787" translate="yes" xml:space="preserve">
          <source>Incomplete gamma integral and its complement</source>
          <target state="translated">不完全伽马积分及其补码。</target>
        </trans-unit>
        <trans-unit id="2f08d5bb658237cd92aa5a4432cb1cfef1a4c7b1" translate="yes" xml:space="preserve">
          <source>Incorporate &lt;code&gt;element_count&lt;/code&gt; and finalizes the hash.</source>
          <target state="translated">合并 &lt;code&gt;element_count&lt;/code&gt; 并完成哈希。</target>
        </trans-unit>
        <trans-unit id="d8c996a9761aab171974108da093507dfd302c9b" translate="yes" xml:space="preserve">
          <source>Increases the reference count of the concrete class that implements this interface.</source>
          <target state="translated">增加实现该接口的具体类的引用次数。</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="6179063ceb022e0b005a77ad50121ce42a8f12e0" translate="yes" xml:space="preserve">
          <source>Incremental options.</source>
          <target state="translated">递增式选择。</target>
        </trans-unit>
        <trans-unit id="84205e80c2673222d26cbdde35ee1f4333d1b71b" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;numOwns&lt;/code&gt; (per instance and and per call) and forwards to &lt;code&gt; parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">递增 &lt;code&gt;numOwns&lt;/code&gt; （按实例和按调用）并转发给 &lt;code&gt; parent.owns(b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddaf57d4b4048098b5dfe8043020c47a13b32e0a" translate="yes" xml:space="preserve">
          <source>Independent of the parameter this Logger will never log a message.</source>
          <target state="translated">与参数无关,该记录仪永远不会记录消息。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="699dc9f4598bf2c18561d09ccbeb25728c70494b" translate="yes" xml:space="preserve">
          <source>Index Assignment Operator Overloading</source>
          <target state="translated">索引赋值运算符超载</target>
        </trans-unit>
        <trans-unit id="71c97279cf83fc58467572ececa55bdae6e798a5" translate="yes" xml:space="preserve">
          <source>Index Expressions</source>
          <target state="translated">索引表达式</target>
        </trans-unit>
        <trans-unit id="d1893a899240a1b591d897768bc60814a476fa87" translate="yes" xml:space="preserve">
          <source>Index Name NULL</source>
          <target state="translated">索引名称 NULL</target>
        </trans-unit>
        <trans-unit id="e71ed4c87a94b38c5cecf345cf992053ca3a47d3" translate="yes" xml:space="preserve">
          <source>Index Name Table Name</source>
          <target state="translated">索引名称 表名</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">一个给定名称的参数的索引</target>
        </trans-unit>
        <trans-unit id="bfb09c98cfaf2d55de0462489f758021e1b3f471" translate="yes" xml:space="preserve">
          <source>Index Op Assignment Operator Overloading</source>
          <target state="translated">索引运算符赋值运算符超载</target>
        </trans-unit>
        <trans-unit id="49fe544cd53fba1ec8f72994e8cce9d496cf27f3" translate="yes" xml:space="preserve">
          <source>Index Operator Overloading</source>
          <target state="translated">指数运算符超载</target>
        </trans-unit>
        <trans-unit id="a3b9e1c8a8784dafb7f4615ab228a307d1e4a762" translate="yes" xml:space="preserve">
          <source>Index of the argument for positional parameters, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">位置参数的参数索引，从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;ubyte.max&lt;/code&gt; 。（ &lt;code&gt;0&lt;/code&gt; 表示未使用）。</target>
        </trans-unit>
        <trans-unit id="c34e327ac8e45e062b5805d3beb7a3e4caec8300" translate="yes" xml:space="preserve">
          <source>Index of the last argument for positional parameter range, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">位置参数范围（从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;ubyte.max&lt;/code&gt; )的最后一个参数的索引。（ &lt;code&gt;0&lt;/code&gt; 表示未使用）。</target>
        </trans-unit>
        <trans-unit id="235d469a267eec1b21cb41bd835ec761b3be5b4a" translate="yes" xml:space="preserve">
          <source>Index of the maximal element of a range. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">范围的最大元素的索引。 &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25975946b5389d6cd4927c54b6079d61210dbf05" translate="yes" xml:space="preserve">
          <source>Index of the minimal element of a range. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">范围的最小元素的索引。 &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a04ef38d2ddc39bb1db51cbf56276c8f962441c1" translate="yes" xml:space="preserve">
          <source>IndexExpression</source>
          <target state="translated">IndexExpression</target>
        </trans-unit>
        <trans-unit id="3b15c071f8f2a9b03d20f13f4ee4fa47f96aaf8d" translate="yes" xml:space="preserve">
          <source>Indexed!(Source, Indices) &lt;strong id=&quot;indexed&quot;&gt;indexed&lt;/strong&gt;(Source, Indices)(Source source, Indices indices);</source>
          <target state="translated">索引！（来源，指数）&lt;strong id=&quot;indexed&quot;&gt;索引&lt;/strong&gt;（来源，指数）（来源，指数）;</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="76508adf7decca48f64672d4079c15326fbc39f8" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">索引和切片操作。仅在 &lt;code&gt;hasSlicing!Source&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时提供。</target>
        </trans-unit>
        <trans-unit id="74036ccb3b85a0419f22323e1fac3915c3caf378" translate="yes" xml:space="preserve">
          <source>Indexing operators yielding or modifyng the value at the specified index.</source>
          <target state="translated">在指定的索引处产生或修改值的索引运算符。</target>
        </trans-unit>
        <trans-unit id="6d2692938b71d76efadfb2cea1bb4a83352f988a" translate="yes" xml:space="preserve">
          <source>Indexing, slicing and bidirectional operations and range primitives. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">索引，切片和双向操作以及范围原语。仅在 &lt;code&gt;hasSlicing!Source&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时提供。</target>
        </trans-unit>
        <trans-unit id="f85958353bf4bfb31d66cc4f95a9358b5bedf1c3" translate="yes" xml:space="preserve">
          <source>Indicates a direction in time. One example of its use is &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#expand&quot;&gt;&lt;code&gt;expand&lt;/code&gt;&lt;/a&gt; function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</source>
          <target state="translated">指示时间方向。其用法的一个示例是&lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;#expand&quot;&gt; &lt;code&gt;expand&lt;/code&gt; &lt;/a&gt;函数，该函数使用该函数指示该间隔是应向后（扩展为过去），向前（扩展为将来）还是同时扩展两者。</target>
        </trans-unit>
        <trans-unit id="89b0fbd07a7b5dbf8da4ba701f1805d8565d86bb" translate="yes" xml:space="preserve">
          <source>Indicates if a nested aggregate prevents or not a function to be inlined. It's used to compute the cost but also to avoid a copy of the aggregate while the inliner processes.</source>
          <target state="translated">表示嵌套的集合是否阻止或不阻止一个函数被内联。它用于计算成本,但也用于在内联器处理时,避免对集合进行复制。</target>
        </trans-unit>
        <trans-unit id="a10ebf2fd0a4ff0f019e4879f48fae2f4e5a0b0d" translate="yes" xml:space="preserve">
          <source>Indicates that the managed memory space be minimized by returning free physical memory to the operating system. The amount of free memory returned depends on the allocator design and on program behavior.</source>
          <target state="translated">表示通过将空闲的物理内存返回给操作系统,使管理的内存空间最小化。返回的空闲内存量取决于分配器设计和程序行为。</target>
        </trans-unit>
        <trans-unit id="4ec109e112fc6bfd6a9d0109f56e7e7967df8488" translate="yes" xml:space="preserve">
          <source>Indicates the checking state of various contracts.</source>
          <target state="translated">表示各种合同的检查状态。</target>
        </trans-unit>
        <trans-unit id="cb18c8046fd7efef0dda1d752fd5c6ff22b02f5d" translate="yes" xml:space="preserve">
          <source>Indicates the kind of scan being performed by &lt;code&gt;thread_scanAllType&lt;/code&gt;.</source>
          <target state="translated">指示 &lt;code&gt;thread_scanAllType&lt;/code&gt; 执行的扫描类型。</target>
        </trans-unit>
        <trans-unit id="8f13413a46338bc9d77efe386dd1970d9c61578f" translate="yes" xml:space="preserve">
          <source>Indicates the type of a &lt;code&gt;JSONValue&lt;/code&gt;.</source>
          <target state="translated">指示 &lt;code&gt;JSONValue&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="ee35c8aada8a6aa7b7217bd768effeae4d28769f" translate="yes" xml:space="preserve">
          <source>Indicates whether &lt;code&gt;T&lt;/code&gt; is a file handle, i.e. the type is implicitly convertable to &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; or a pointer to a &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt;&lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示 &lt;code&gt;T&lt;/code&gt; 是文件句柄，即类型可以隐式转换为&lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;还是指向&lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt; &lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt; &lt;/a&gt;的指针。</target>
        </trans-unit>
        <trans-unit id="16f0af9200309c4bcede9c6bd76aa0d14467a310" translate="yes" xml:space="preserve">
          <source>Indicates whether an address has been marked by the GC.</source>
          <target state="translated">表示地址是否已被GC标记。</target>
        </trans-unit>
        <trans-unit id="c7fabc24fed84961bce8996fe0ecd1e5cdad5e83" translate="yes" xml:space="preserve">
          <source>Indicates whether the comparisons are case sensitive.</source>
          <target state="translated">表示比较是否区分大小写。</target>
        </trans-unit>
        <trans-unit id="f7d28431fd9c9c5871085a5497dc7e6e1e0cf415" translate="yes" xml:space="preserve">
          <source>Indicates which contracts should be checked or not.</source>
          <target state="translated">表示哪些合同应予检查或不检查。</target>
        </trans-unit>
        <trans-unit id="4243a1f947d3219fb4149e60971ece346868e5f0" translate="yes" xml:space="preserve">
          <source>Individual characters (&lt;code&gt;char, &lt;/code&gt;wchar&lt;code&gt;, or &lt;/code&gt;dchar`) are formatted as Unicode characters with &lt;code&gt;%s&lt;/code&gt; and as integers with integral-specific format specs.</source>
          <target state="translated">各个字符（ &lt;code&gt;char, &lt;/code&gt; wchar &lt;code&gt;, or &lt;/code&gt; dchar`）的格式为带有 &lt;code&gt;%s&lt;/code&gt; 的 Unicode字符，以及具有整数特定格式的规范的整数。</target>
        </trans-unit>
        <trans-unit id="29597351771a3ef19075a67f20ee90c6ad63bea0" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not.</source>
          <target state="translated">使用 &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; 比较单个字符，其中 &lt;code&gt;cs&lt;/code&gt; 是一个可选的模板参数，确定比较是否区分大小写。</target>
        </trans-unit>
        <trans-unit id="49226687980b9cd956057b7a38e24b4e2409b256" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCharCmp&quot;&gt;&lt;code&gt;filenameCharCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">使用 &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; 比较单个字符，其中 &lt;code&gt;cs&lt;/code&gt; 是一个可选的模板参数，确定比较是否区分大小写。有关详细信息，请参见&lt;a href=&quot;#filenameCharCmp&quot;&gt; &lt;code&gt;filenameCharCmp&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="e1f361f1f9ae5992659047882bc5221a903aebb0" translate="yes" xml:space="preserve">
          <source>Individual field in the Ctor with information about its callees and location.</source>
          <target state="translated">Ctor中的单个字段,包含其被叫人和位置的信息。</target>
        </trans-unit>
        <trans-unit id="2112ae8639e7801d8cfbbdd81cd2583bb2a4a9cd" translate="yes" xml:space="preserve">
          <source>Individual tests are specified in the unit test using &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;. Unlike</source>
          <target state="translated">单个测试在使用&lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;的单元测试中指定。不像</target>
        </trans-unit>
        <trans-unit id="a1c45f8b0cd8cbcf6f1e93b6a635fb2a38dc40f6" translate="yes" xml:space="preserve">
          <source>Inequality is defined as the logical negation of equality.</source>
          <target state="translated">不平等是指平等的逻辑否定。</target>
        </trans-unit>
        <trans-unit id="65b109f015e153776d80b153da2023fd8d163d9f" translate="yes" xml:space="preserve">
          <source>Infinite ranges are compatible, provided the parameter &lt;code&gt;upTo&lt;/code&gt; is specified, in which case the implementation simply returns upTo.</source>
          <target state="translated">如果指定了参数 &lt;code&gt;upTo&lt;/code&gt; ,则无限范围是兼容的，在这种情况下，实现仅返回upTo。</target>
        </trans-unit>
        <trans-unit id="cc80f798db63ecb0ec11198be5af2b60c15e0345" translate="yes" xml:space="preserve">
          <source>Infinite ranges with slicing support must return an instance of &lt;a href=&quot;std_range#Take&quot;&gt;&lt;code&gt;std.range.Take&lt;/code&gt;&lt;/a&gt; when sliced with a specific lower and upper bound (see &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt;); &lt;code&gt;handle&lt;/code&gt; deals with this by &lt;code&gt;take&lt;/code&gt;ing 0 from the return value of the handler function and returning that when an exception is caught.</source>
          <target state="translated">具有切片支持的无限范围必须返回&lt;a href=&quot;std_range#Take&quot;&gt; &lt;code&gt;std.range.Take&lt;/code&gt; &lt;/a&gt;的实例，并在切片时具有特定的上下限（请参见&lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt;）； &lt;code&gt;handle&lt;/code&gt; 通过从处理函数的返回值中 &lt;code&gt;take&lt;/code&gt; 0并在捕获到异常时返回该值来处理此问题。</target>
        </trans-unit>
        <trans-unit id="27d9e5c1d05febee114a9f9e51dbec3780887c9a" translate="yes" xml:space="preserve">
          <source>Infiniteness of the wrapped range is not propagated.  Length is not propagated in the case of non-random access ranges.</source>
          <target state="translated">包裹范围的无限性不被传播,在非随机访问范围中,长度不被传播。在非随机访问范围的情况下,不传播长度。</target>
        </trans-unit>
        <trans-unit id="266086404e3edd52081be68722aa77ff6a65cf70" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a Posix system.</source>
          <target state="translated">文件的信息,类似于Posix系统中的统计信息。</target>
        </trans-unit>
        <trans-unit id="cd1b541e2d202e9ed7863df5d539d80a14d92db1" translate="yes" xml:space="preserve">
          <source>Information about an interface. When an object is accessed via an interface, an Interface* appears as the first entry in its vtbl.</source>
          <target state="translated">关于接口的信息。当一个对象通过接口被访问时,接口*将作为其vtbl的第一个条目出现。</target>
        </trans-unit>
        <trans-unit id="cea2e687310e3b71b249c28a49288e9fd3bfa210" translate="yes" xml:space="preserve">
          <source>Information about an option.</source>
          <target state="translated">关于一个选项的信息。</target>
        </trans-unit>
        <trans-unit id="e073c50eee2c368b573895c98fb35595e9133239" translate="yes" xml:space="preserve">
          <source>Information about errors should be logged with this level.</source>
          <target state="translated">有关错误的信息应与本级进行记录。</target>
        </trans-unit>
        <trans-unit id="928345681d20aa3d2b01bea36a816d52c33a48de" translate="yes" xml:space="preserve">
          <source>Information about the dynamic type of the class</source>
          <target state="translated">类的动态类型信息</target>
        </trans-unit>
        <trans-unit id="dc5ebb2696c4fafd1bdd1b19b9d403757258f4ad" translate="yes" xml:space="preserve">
          <source>Information about the error.</source>
          <target state="translated">关于错误的信息。</target>
        </trans-unit>
        <trans-unit id="b7329bd16608fcee8af0c9e3dcd5b29f7f17343f" translate="yes" xml:space="preserve">
          <source>Information about the target operating system, environment, and CPU.</source>
          <target state="translated">关于目标操作系统、环境和CPU的信息。</target>
        </trans-unit>
        <trans-unit id="ceccba3653730142ed262183682108d6a4b114f3" translate="yes" xml:space="preserve">
          <source>Information gathered about externally defined template member functions, member data, and member classes.</source>
          <target state="translated">收集外部定义的模板成员函数、成员数据和成员类的信息。</target>
        </trans-unit>
        <trans-unit id="908b94b8c3e2309d82de3bc12b0083b2f0550dd4" translate="yes" xml:space="preserve">
          <source>Information gathered about nested class friends.</source>
          <target state="translated">收集了嵌套类朋友的信息。</target>
        </trans-unit>
        <trans-unit id="7a43d043ba9567583c6e384e6e0ac879da254eab" translate="yes" xml:space="preserve">
          <source>Information gathered about nested explicit specializations.</source>
          <target state="translated">收集到的关于嵌套式显式专业化的信息。</target>
        </trans-unit>
        <trans-unit id="464dcc7e55ca0baa3461154f3221489d53fa204b" translate="yes" xml:space="preserve">
          <source>Information gathered about primary member template explicit specialization.</source>
          <target state="translated">收集到的主要成员模板明确专业化的信息。</target>
        </trans-unit>
        <trans-unit id="8bc70f913f6ebe36fcb59b26b1c9b07d1f380466" translate="yes" xml:space="preserve">
          <source>Information regarding the allocated memory block or BlkInfo.init on error.</source>
          <target state="translated">有关分配的内存块或BlkInfo.init错误时的信息。</target>
        </trans-unit>
        <trans-unit id="1675fcfc1cf455d10d63328190309be0fe262d03" translate="yes" xml:space="preserve">
          <source>Information regarding the memory block referenced by p or BlkInfo.init on error.</source>
          <target state="translated">关于p或BlkInfo.init错误时引用的内存块的信息。</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">初始值</target>
        </trans-unit>
        <trans-unit id="97e0f0f5459c7f9a8a0eadb6d21739e1c19dd524" translate="yes" xml:space="preserve">
          <source>Initial_Punctuation</source>
          <target state="translated">Initial_Punctuation</target>
        </trans-unit>
        <trans-unit id="e3e40f7638a489f11f1de06365e82209954d82d0" translate="yes" xml:space="preserve">
          <source>Initialization hook, called FROM each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">初始化钩子,from每个线程调用。对模块初始化状态不应做任何假设。</target>
        </trans-unit>
        <trans-unit id="a459dff3012da591453989e5860a6fd825f63ce3" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="translated">Initialize</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">初始化 SQLite 库</target>
        </trans-unit>
        <trans-unit id="748256c78e345ebbc504f121b03e80be2a80bbca" translate="yes" xml:space="preserve">
          <source>Initialize a TOK.cantExpression Expression.</source>
          <target state="translated">初始化一个TOK.cantExpression表达式。</target>
        </trans-unit>
        <trans-unit id="27911a1150c0c1d2144b25e270682254f6dac63a" translate="yes" xml:space="preserve">
          <source>Initialize config variables.</source>
          <target state="translated">初始化配置变量。</target>
        </trans-unit>
        <trans-unit id="cbe2f6d3df93f8e15ce05f5a1f98cda2b20db74a" translate="yes" xml:space="preserve">
          <source>Initialize druntime. If a C program wishes to call D code, and there's no D main(), then it must call rt_init() and rt_term().</source>
          <target state="translated">初始化druntime。如果一个C程序想调用D代码,而没有D主(),那么它必须调用rt_init()和rt_term()。</target>
        </trans-unit>
        <trans-unit id="8eb8be79e89fc0c011f24c39ee8771af00f563f7" translate="yes" xml:space="preserve">
          <source>Initialize for inferring the attributes of this function.</source>
          <target state="translated">初始化,用于推断该函数的属性。</target>
        </trans-unit>
        <trans-unit id="f721b948f9c83247c02645e5eb12893bfb899d86" translate="yes" xml:space="preserve">
          <source>Initialize list package.</source>
          <target state="translated">初始化列表包。</target>
        </trans-unit>
        <trans-unit id="de4ea7df574920c39fb3c6bd0386ce6a9cd8fd5d" translate="yes" xml:space="preserve">
          <source>Initialize the Objective-C string using a C string.</source>
          <target state="translated">使用C字符串初始化Objective-C字符串。</target>
        </trans-unit>
        <trans-unit id="ef4109d3528796628f6b2a0029715405248a578e" translate="yes" xml:space="preserve">
          <source>Initialize the Target</source>
          <target state="translated">初始化目标</target>
        </trans-unit>
        <trans-unit id="0980ce942938201d58c731edfd7b47e45dd9efe7" translate="yes" xml:space="preserve">
          <source>Initialize the dual-context array with the context pointers.</source>
          <target state="translated">用上下文指针初始化双上下文数组。</target>
        </trans-unit>
        <trans-unit id="8e023ffe90e1164684f46dc5edc97859a5680a5f" translate="yes" xml:space="preserve">
          <source>Initialize the hidden aggregate member, vthis, with the context pointer.</source>
          <target state="translated">用上下文指针初始化隐藏的聚合成员vthis。</target>
        </trans-unit>
        <trans-unit id="59c6a3b95f9730ad20a9c9db67ee73fd2a6949c4" translate="yes" xml:space="preserve">
          <source>Initialize the instance by creating a working curl handle.</source>
          <target state="translated">通过创建一个工作的curl句柄来初始化实例。</target>
        </trans-unit>
        <trans-unit id="1a30f56d1770a9dcc7fd0bb681a1c06b14ad9d91" translate="yes" xml:space="preserve">
          <source>Initialize the memory allocator</source>
          <target state="translated">初始化内存分配器</target>
        </trans-unit>
        <trans-unit id="494a02556f310d47be7c5338d8f5523416a42a2e" translate="yes" xml:space="preserve">
          <source>Initialize with a message and an error code.</source>
          <target state="translated">用信息和错误代码初始化。</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="51bf015ae2898049c8dda3ee0d3b48d0b0503aac" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;init&lt;/code&gt;</source>
          <target state="translated">初始化器 &lt;code&gt;init&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b1d1b30aa70eb127392afc002aaf56ef13eddf1" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;inx&lt;/code&gt;</source>
          <target state="translated">初始化器 &lt;code&gt;inx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376a8ae3746f3bef7e7c198b9b11401e24b7d25c" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Initializer init, Scope* sc);</source>
          <target state="translated">初始化程序&lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;（Initializer init，Scope * sc）;</target>
        </trans-unit>
        <trans-unit id="d8d2abfa30e5c4556b8e2c9d2dc62e742af966eb" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;(Initializer init, Scope* sc, Type t, NeedInterpret needInterpret);</source>
          <target state="translated">Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;（Initializer init，Scope * sc，Type t，NeedInterpret needInterpret）;</target>
        </trans-unit>
        <trans-unit id="88abdada1a9385d97517a707f4ab8a5f5a3e696d" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt;(Initializer inx);</source>
          <target state="translated">初始化&lt;strong id=&quot;syntaxCopy&quot;&gt;语法&lt;/strong&gt;（Initializer inx）;</target>
        </trans-unit>
        <trans-unit id="c33131a57d387e740aae854652440535c3dd0652" translate="yes" xml:space="preserve">
          <source>Initializer AST node</source>
          <target state="translated">初始化器AST节点</target>
        </trans-unit>
        <trans-unit id="14b021ae9bb3f976f77030248590d743674ec1b8" translate="yes" xml:space="preserve">
          <source>Initializer AST to copy</source>
          <target state="translated">要复制的AST初始化器</target>
        </trans-unit>
        <trans-unit id="3121cafc28fbd2cff06107236c3142ae39ff3c9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RefCounted&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;. The template parameter &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;RefCounted&lt;/code&gt; is inferred from &lt;code&gt;val&lt;/code&gt;. This function can be used to move non-copyable values to the heap. It also disables the &lt;code&gt;autoInit&lt;/code&gt; option of &lt;code&gt;RefCounted&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;val&lt;/code&gt; 初始化 &lt;code&gt;RefCounted&lt;/code&gt; 。模板参数 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;RefCounted&lt;/code&gt; 是从推断 &lt;code&gt;val&lt;/code&gt; 。此函数可用于将不可复制的值移动到堆。它还禁用 &lt;code&gt;RefCounted&lt;/code&gt; 的 &lt;code&gt;autoInit&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="5840e1604b436855e9916e7392a48763951eabf0" translate="yes" xml:space="preserve">
          <source>Initializes a barrier object which releases threads in groups of limit in size.</source>
          <target state="translated">初始化一个屏障对象,该对象在大小限制的组中释放线程。</target>
        </trans-unit>
        <trans-unit id="e7d8f005a4914e6f92d821d5b224a6bd9e5c292c" translate="yes" xml:space="preserve">
          <source>Initializes a condition object which is associated with the supplied mutex object.</source>
          <target state="translated">初始化一个与所提供的mutex对象相关联的条件对象。</target>
        </trans-unit>
        <trans-unit id="2e831c2f248c0c0989af9f49fabed81c26839fd7" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a dynamic D function.</source>
          <target state="translated">初始化一个与动态D函数相关联的光纤对象。</target>
        </trans-unit>
        <trans-unit id="af50363b8f7b4155835b77141de6a5c61fdd71a0" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a static D function.</source>
          <target state="translated">初始化一个光纤对象,它与一个静态D函数相关联。</target>
        </trans-unit>
        <trans-unit id="45f928a2b81b560a0de6c9239785399cedf0251c" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a dynamic D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">初始化一个与动态D函数相关联的生成器对象。该函数将被调用一次,以准备迭代的范围。</target>
        </trans-unit>
        <trans-unit id="d0a92e3c77360cd0a21c46127be86aca1b90b608" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a static D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">初始化一个生成器对象,该对象与一个静态D函数相关联。该函数将被调用一次,以准备迭代的范围。</target>
        </trans-unit>
        <trans-unit id="d3728c381d3549c70b43d294cf94f34b914968b0" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object and sets it as the monitor for &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">初始化一个互斥对象，并将其设置为 &lt;code&gt;obj&lt;/code&gt; 的监视器。</target>
        </trans-unit>
        <trans-unit id="3a70c8975cc02255930db5c1532e070f13d983d9" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object.</source>
          <target state="translated">初始化一个mutex对象。</target>
        </trans-unit>
        <trans-unit id="dc21cd96d7c298b730677d5fadf1f39d6fcdc2a3" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex object with the supplied policy.</source>
          <target state="translated">用提供的策略初始化一个读/写mutex对象。</target>
        </trans-unit>
        <trans-unit id="1bf7bde2d0e1b4605f5fcc7cecf50b8041c0ee33" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex reader proxy object.</source>
          <target state="translated">初始化一个读/写mutex阅读器代理对象。</target>
        </trans-unit>
        <trans-unit id="cac251d6ab6ce4228fd76b8f664aca1fdce466aa" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex writer proxy object.</source>
          <target state="translated">初始化一个读/写mutex写代理对象。</target>
        </trans-unit>
        <trans-unit id="e9c3d0e482ee4665047c01099490677dcee2bdf1" translate="yes" xml:space="preserve">
          <source>Initializes a semaphore object with the specified initial count.</source>
          <target state="translated">用指定的初始计数初始化一个旗语对象。</target>
        </trans-unit>
        <trans-unit id="b08f976531720c8d331b9fd2fe472f259a01f7f8" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a dynamic D function.</source>
          <target state="translated">初始化一个与动态D函数相关联的线程对象。</target>
        </trans-unit>
        <trans-unit id="6feddfb754d931f52971603d63763097e08f646e" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a static D function.</source>
          <target state="translated">初始化一个线程对象,该对象与一个静态D函数相关联。</target>
        </trans-unit>
        <trans-unit id="02e85d0a8c0d02c068e1d5736a1954b12b36920b" translate="yes" xml:space="preserve">
          <source>Initializes all elements of &lt;code&gt;range&lt;/code&gt; with their &lt;code&gt;.init&lt;/code&gt; value. Assumes that the elements of the range are uninitialized.</source>
          <target state="translated">初始化的所有元素 &lt;code&gt;range&lt;/code&gt; 与他们 &lt;code&gt;.init&lt;/code&gt; 值。假定范围的元素未初始化。</target>
        </trans-unit>
        <trans-unit id="472c952e25298d18516b57e8e37279e00d61a5fe" translate="yes" xml:space="preserve">
          <source>Initializes an event object. Does nothing if the event is already initialized.</source>
          <target state="translated">初始化一个事件对象。如果事件已经被初始化,则不做任何操作。</target>
        </trans-unit>
        <trans-unit id="eaf4287ba6b011331efecfcdf502db022ed8e9d5" translate="yes" xml:space="preserve">
          <source>Initializes each element of &lt;code&gt;range&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. Assumes that the elements of the range are uninitialized. This is of interest for structs that define copy constructors (for all other types, &lt;a href=&quot;#fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt; and uninitializedFill are equivalent).</source>
          <target state="translated">使用 &lt;code&gt;value&lt;/code&gt; 初始化 &lt;code&gt;range&lt;/code&gt; 的每个元素。假定范围的元素未初始化。这对于定义副本构造函数的结构很有用（对于所有其他类型，&lt;a href=&quot;#fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt;和uninitializedFill是等效的）。</target>
        </trans-unit>
        <trans-unit id="fc7f0006265d50c993eca80b0dee1e88b813e83a" translate="yes" xml:space="preserve">
          <source>Initializes the Symbol s with the contents of the exception handler table.</source>
          <target state="translated">用异常处理表的内容初始化Symbol s。</target>
        </trans-unit>
        <trans-unit id="ce7db86ae90730cf95765268d14c3efeca306d1a" translate="yes" xml:space="preserve">
          <source>Initializes the digest.</source>
          <target state="translated">初始化摘要。</target>
        </trans-unit>
        <trans-unit id="7cc4cbbc423778a9b3a1d152d6911455078c9956" translate="yes" xml:space="preserve">
          <source>Initializes the runtime. This call is to be used in instances where the standard program initialization process is not executed. This is most often in shared libraries or in libraries linked to a C program. If the runtime was already successfully initialized this returns true. Each call to initialize must be paired by a call to &lt;a href=&quot;#terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">初始化运行时。此调用将在未执行标准程序初始化过程的情况下使用。这通常是在共享库或链接到C程序的库中。如果运行时已经成功初始化，则返回true。每个初始化调用必须与一个&lt;a href=&quot;#terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt;调用配对。</target>
        </trans-unit>
        <trans-unit id="fd011618a7d780c02099be5bb857d574a889ced4" translate="yes" xml:space="preserve">
          <source>Initializes the thread module. This function must be called by the garbage collector on startup and before any other thread routines are called.</source>
          <target state="translated">初始化线程模块。这个函数必须在启动时和其他线程例程被调用之前被垃圾收集器调用。</target>
        </trans-unit>
        <trans-unit id="f7bf172cc09f5d408e5dbadd459ffc810fa40735" translate="yes" xml:space="preserve">
          <source>Initializes this object.</source>
          <target state="translated">初始化这个对象。</target>
        </trans-unit>
        <trans-unit id="330d0782e4b98319bc9e2fabb58b097370cccd48" translate="yes" xml:space="preserve">
          <source>Initializes var with the lazy init value in a thread-safe manner.</source>
          <target state="translated">以线程安全的方式用懒惰的init值初始化var。</target>
        </trans-unit>
        <trans-unit id="357baf1e97067fcd6c5956ff04a8aafd59f2e20c" translate="yes" xml:space="preserve">
          <source>Initializing a field more than once is an error:</source>
          <target state="translated">初始化一个字段一次以上是错误的。</target>
        </trans-unit>
        <trans-unit id="7b6a85ba00f40263892051680251fc88efc22b1f" translate="yes" xml:space="preserve">
          <source>Initially, &lt;code&gt;KRRegion&lt;/code&gt; starts in &quot;region&quot; mode: allocations are served from the memory chunk in a region fashion. Thus, as long as there is enough memory left, &lt;code&gt;KRRegion.allocate&lt;/code&gt; has the performance profile of a region allocator. Deallocation inserts (in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time) the deallocated blocks in an unstructured freelist, which is not read in region mode.</source>
          <target state="translated">最初， &lt;code&gt;KRRegion&lt;/code&gt; 以&amp;ldquo;区域&amp;rdquo;模式启动：以区域方式从内存块提供分配。因此，只要还有足够的内存， &lt;code&gt;KRRegion.allocate&lt;/code&gt; 就会具有区域分配器的性能概况。解除分配在非结构化的空闲列表中插入（在&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）时间内）被解除分配的块，该列表在区域模式下不被读取。</target>
        </trans-unit>
        <trans-unit id="6bcf5b308aa4ed1bdc1fe48856a7ba75e0842648" translate="yes" xml:space="preserve">
          <source>Initiate a search for all non-overlapping matches to the pattern &lt;code&gt;re&lt;/code&gt; in the given &lt;code&gt;input&lt;/code&gt;. The result is a lazy range of matches generated as they are encountered in the input going left to right.</source>
          <target state="translated">在给定 &lt;code&gt;input&lt;/code&gt; 搜索与模式 &lt;code&gt;re&lt;/code&gt; 的所有非重叠匹配。结果是在输入中从左到右遇到匹配时产生的延迟匹配范围。</target>
        </trans-unit>
        <trans-unit id="39a92c1c48ec637efb7a0a17e58b57967f5754ea" translate="yes" xml:space="preserve">
          <source>Initiate the shutdown</source>
          <target state="translated">开始关闭</target>
        </trans-unit>
        <trans-unit id="505f260038380736b5ec292da3beb645bc7a02ab" translate="yes" xml:space="preserve">
          <source>Inline Assembler</source>
          <target state="translated">内联装配机</target>
        </trans-unit>
        <trans-unit id="e8c0903b87db76a205d27b465bff8acf36d3a3fc" translate="yes" xml:space="preserve">
          <source>Inline Code</source>
          <target state="translated">内联代码</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">内联功能</target>
        </trans-unit>
        <trans-unit id="0e581275df3e295be9dbef35d1d241b50ed09352" translate="yes" xml:space="preserve">
          <source>Inline Links</source>
          <target state="translated">内联链接</target>
        </trans-unit>
        <trans-unit id="e928c83ba27af9a3e30934913f4f5025c9156467" translate="yes" xml:space="preserve">
          <source>Inline Status</source>
          <target state="translated">在线状态</target>
        </trans-unit>
        <trans-unit id="2a9bcb6f0852ea225d7f231f321da701f1352c4f" translate="yes" xml:space="preserve">
          <source>Inline assembler can be used to access hardware directly:</source>
          <target state="translated">内联汇编器可以用来直接访问硬件。</target>
        </trans-unit>
        <trans-unit id="79759f20677d34f63a3ad16ca748c0357029c9ef" translate="yes" xml:space="preserve">
          <source>Inline assembler implementation for DMD.</source>
          <target state="translated">DMD的内联汇编器实现。</target>
        </trans-unit>
        <trans-unit id="8bb9331db9f6ba0e169e23c73a72b91ef379fcfb" translate="yes" xml:space="preserve">
          <source>Inline assembler is supported with the asm statement:</source>
          <target state="translated">用asm语句支持内联汇编器。</target>
        </trans-unit>
        <trans-unit id="30bd67072a99e7f0e67136dac69a9f97d8fe06e6" translate="yes" xml:space="preserve">
          <source>Inline code can be written between backtick characters (`), similarly to the syntax used on GitHub, Reddit, Stack Overflow, and other websites. Both the opening and closing ` character must appear on the same line to trigger this behavior.</source>
          <target state="translated">内联代码可以写在回车字符(`)之间,类似于GitHub、Reddit、Stack Overflow和其他网站上使用的语法。开头和结尾的`字符必须出现在同一行才能触发这种行为。</target>
        </trans-unit>
        <trans-unit id="3a0d3f2169904e16efc469dbb314be7e91a83d62" translate="yes" xml:space="preserve">
          <source>Inline-style links enclose link text in square brackets and the link URL in parentheses. Like reference links, the URL may optionally be followed by title text wrapped in single or double quotes, or in parentheses:</source>
          <target state="translated">内联式链接将链接文本放在方括号内,链接URL放在括号内。像参考链接一样,URL后面可以选择用单引号或双引号包裹的标题文本,或者用括号表示。</target>
        </trans-unit>
        <trans-unit id="59987901b798d3774e680b1f2e942cf43901da46" translate="yes" xml:space="preserve">
          <source>InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78d80e54409073effd7ab616e62a68493fee350d" translate="yes" xml:space="preserve">
          <source>Inout Functions</source>
          <target state="translated">输入输出功能</target>
        </trans-unit>
        <trans-unit id="e8e7165f5b963e02cdaf54a8eb17befc2421e96a" translate="yes" xml:space="preserve">
          <source>Inout types can be implicitly converted to const or inout const, but to nothing else. Other types cannot be implicitly converted to inout. Casting to or from inout is not allowed in @safe functions.</source>
          <target state="translated">Inout类型可以隐式转换为const或inout const,但不能转换为其他类型。其他类型不能隐式转换为inout。在@safe函数中不允许向inout类型投掷或从inout类型投掷。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">输入阵列。</target>
        </trans-unit>
        <trans-unit id="805a8fb36fe255b6fb65ad6afc87bb5c87d77739" translate="yes" xml:space="preserve">
          <source>Input range primitives.</source>
          <target state="translated">输入范围基元。</target>
        </trans-unit>
        <trans-unit id="2b5a3aca97f7c0ee924c45da0b642efd3933bcec" translate="yes" xml:space="preserve">
          <source>Input range primitives. Always present.</source>
          <target state="translated">输入范围基元。始终存在。</target>
        </trans-unit>
        <trans-unit id="3ea0015c09b13077d49706cf98824e19781f5a6d" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;front&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;front&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea0417fdf24ea467e5d4948e4d2f763b6a7eef2b" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">输入范围 &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="263a897da5a7d45d98fac35624cdf4deb7cf4411" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8a5a20feb07807120b419370d56d0cc41af44e6" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;seq&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;seq&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ac91ede8a06926e9fd7701df246ece786ebf98" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, Element)(InputRange haystack, scope Element needle)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;查找&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，InputRange，元素）（InputRange干草堆，范围Element针）</target>
        </trans-unit>
        <trans-unit id="62294650ad3440bbcc9dfa642f50ca9b106dfc41" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred, InputRange)(InputRange haystack)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;查找&lt;/strong&gt;（别名pred，InputRange）（InputRange干草堆）</target>
        </trans-unit>
        <trans-unit id="cd55b74bf8e8c901c82e7777b6c9deb713ab8571" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, ForwardRange)(InputRange seq, ForwardRange choices)</source>
          <target state="translated">InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;（别名pred =&amp;ldquo; a == b&amp;rdquo;，InputRange，ForwardRange）（InputRange seq，ForwardRange选择）</target>
        </trans-unit>
        <trans-unit id="215e5e329de1e54df130b5fa8c6b834e564f901b" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;r1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249ee449e0f4478b44dc1191e22438bd70e851a5" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;src&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c677621d3536f932357d78e1812f103084e329df" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71bdacf44f1217f068320302c2f0ee3826890d58" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;tgt&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;tgt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26853b5826e342866783ec6125630078fcc1a0ef" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;（InputRange1，InputRange2）（InputRange1 src，InputRange2 tgt）</target>
        </trans-unit>
        <trans-unit id="a6d9a6e40c7583de17b5334cea373d1a6f012a01" translate="yes" xml:space="preserve">
          <source>InputRangeObject!R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;(R)(R range)</source>
          <target state="translated">InputRangeObject！R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;（R）（R范围）</target>
        </trans-unit>
        <trans-unit id="54690a68ec01cec2015c43085af22e3b7ee1fd11" translate="yes" xml:space="preserve">
          <source>Inscriptional Pahlavi</source>
          <target state="translated">巴列维铭文</target>
        </trans-unit>
        <trans-unit id="fef5264f6a30e6dcae96d08ee848ad4b86a2a3a3" translate="yes" xml:space="preserve">
          <source>Inscriptional Parthian</source>
          <target state="translated">铭文的帕提亚人</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="3c215b42cade3b7a8b98554cb505256252393b54" translate="yes" xml:space="preserve">
          <source>Insert a backtick</source>
          <target state="translated">插入一个支点</target>
        </trans-unit>
        <trans-unit id="138a4c6393efa857920b23a60fdca2a6694f91d0" translate="yes" xml:space="preserve">
          <source>Insert a dollar sign</source>
          <target state="translated">插入一个美元符号</target>
        </trans-unit>
        <trans-unit id="cecb3ad08db064401b3027bd8bdfecfd625474f6" translate="yes" xml:space="preserve">
          <source>Insert a left parenthesis</source>
          <target state="translated">插入一个左括号</target>
        </trans-unit>
        <trans-unit id="cbdb76fffabdf5eb3b5ae5b2ff4c5c2a9ba7b666" translate="yes" xml:space="preserve">
          <source>Insert a line feed (newline)</source>
          <target state="translated">插入一个换行符(换行)。</target>
        </trans-unit>
        <trans-unit id="c0306b572d5a694e3a6dd42bca0200f018f85238" translate="yes" xml:space="preserve">
          <source>Insert a range of elements in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">在容器中插入一个元素的范围。请注意,这不会使当前迭代容器的任何范围无效。</target>
        </trans-unit>
        <trans-unit id="1a917cf9fad45f42c5f9d737b6e96f9575d41832" translate="yes" xml:space="preserve">
          <source>Insert a right parenthesis</source>
          <target state="translated">插入一个右括号</target>
        </trans-unit>
        <trans-unit id="327083c1ff82497e1f646caa621a2ae2d82389b4" translate="yes" xml:space="preserve">
          <source>Insert a single element in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">在容器中插入一个单一元素。注意,这不会使当前迭代容器的任何范围无效。</target>
        </trans-unit>
        <trans-unit id="42c8592347a2b25e78dc2c81426ea39331669868" translate="yes" xml:space="preserve">
          <source>Insert current item from the source into the target.</source>
          <target state="translated">将当前项目从源项目插入到目标项目中。</target>
        </trans-unit>
        <trans-unit id="d776dcf131b9f5a24feff6fc21b29e6dcf5da88f" translate="yes" xml:space="preserve">
          <source>Insert finally block calls when doing a goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for EH_DWARF exception unwinding.</source>
          <target state="translated">插入finally块调用时,从try块里面做一个goto到外面。在生成块之后完成,因为这样我们就知道了图的所有边,但在计算Bpred的之前。只适用于EH_DWARF异常解除。</target>
        </trans-unit>
        <trans-unit id="5471bf7c7cfa66ea6e595c4758d088cf1cff366e" translate="yes" xml:space="preserve">
          <source>Insert gotos to finally blocks when doing a return or goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for functions with no exception handling. Very similar to insertFinallyBlockCalls().</source>
          <target state="translated">在做返回或从try block里面的goto到外面的时候,插入goto到finally blocks。在生成块之后完成,因为这样我们就知道了图的所有边,但在计算Bpred之前。只适用于没有异常处理的函数。与insertFinallyBlockCalls()非常相似。</target>
        </trans-unit>
        <trans-unit id="dac79eb40ab7303630f93c4973c9239f694c7c19" translate="yes" xml:space="preserve">
          <source>Insert item into list at nth position.</source>
          <target state="translated">在列表的第n位插入项目。</target>
        </trans-unit>
        <trans-unit id="e157f7049edabd9484326a29b8f9b52a72eaeb25" translate="yes" xml:space="preserve">
          <source>Inserted in place of invalid UTF sequences.</source>
          <target state="translated">在无效的UTF序列的位置插入。</target>
        </trans-unit>
        <trans-unit id="143f825d20ba520107ed764caaeba3c49e097300" translate="yes" xml:space="preserve">
          <source>Inserting if not present</source>
          <target state="translated">如果没有,则插入</target>
        </trans-unit>
        <trans-unit id="30a6615838d01663d72779532f25d77de2451cfa" translate="yes" xml:space="preserve">
          <source>Insertion failed because database is full</source>
          <target state="translated">插入失败,因为数据库已满</target>
        </trans-unit>
        <trans-unit id="20cdd78769ce43b7cb858f988154e98a6f228025" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime may be turned off with a compiler switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;code&gt;-boundscheck&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用编译器switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt; &lt;code&gt;-boundscheck&lt;/code&gt; &lt;/a&gt;关闭运行时数组边界检查代码的插入。</target>
        </trans-unit>
        <trans-unit id="4bdc47adb0591faa30b8ba1f2040d211a501160c" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime should be turned on and off with a compile time switch.</source>
          <target state="translated">在运行时插入数组边界检查代码应该通过编译时的开关来开启和关闭。</target>
        </trans-unit>
        <trans-unit id="0fe401e132558c29c269b7fd6cffd6a1dc02d7db" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; (which must be an input range or any number of implicitly convertible items) in &lt;code&gt;array&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;pos&lt;/code&gt; 位置的 &lt;code&gt;array&lt;/code&gt; 中插入 &lt;code&gt;stuff&lt;/code&gt; （必须是输入范围或任意数量的隐式可转换项）。</target>
        </trans-unit>
        <trans-unit id="ccbf9d19e58cf1e67a852d50890252788f63b174" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a non-empty range previously extracted from this container.</source>
          <target state="translated">在范围 &lt;code&gt;r&lt;/code&gt; 之后插入 &lt;code&gt;stuff&lt;/code&gt; ，该范围必须是先前从此容器提取的非空范围。</target>
        </trans-unit>
        <trans-unit id="bbcf5a5de0747fda77b1e1e1643549b4e06e5bb8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a range previously extracted from this container. Given that all ranges for a list end at the end of the list, this function essentially appends to the list and uses &lt;code&gt;r&lt;/code&gt; as a potentially fast way to reach the last node in the list. Ideally &lt;code&gt;r&lt;/code&gt; is positioned near or at the last element of the list.</source>
          <target state="translated">在范围 &lt;code&gt;r&lt;/code&gt; 之后插入 &lt;code&gt;stuff&lt;/code&gt; ，该范围必须是先前从此容器提取的范围。假定列表的所有范围都在列表的末尾，则此函数实质上会追加到列表，并使用 &lt;code&gt;r&lt;/code&gt; 作为到达列表中最后一个节点的潜在快速方法。理想情况下， &lt;code&gt;r&lt;/code&gt; 位于列表的最后一个元素附近或该列表的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="6f06bb00c64490bdfd0684d68ce1e50ed8931cf5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">在范围 &lt;code&gt;r&lt;/code&gt; 之前，之后或取而代之地插入 &lt;code&gt;stuff&lt;/code&gt; ，该范围必须是先前从此数组中提取的有效范围。 &lt;code&gt;stuff&lt;/code&gt; 可以是可转换的值 &lt;code&gt;T&lt;/code&gt; 或可转换为一定范围的对象 &lt;code&gt;T&lt;/code&gt; 。稳定版本和非稳定版本的行为相同，并保证遍历数组的范围永远不会无效。</target>
        </trans-unit>
        <trans-unit id="f08fcf4de04b5d69b89946f0b954703523fa90fc" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">在范围 &lt;code&gt;r&lt;/code&gt; 之前，之后或取而代之地插入 &lt;code&gt;stuff&lt;/code&gt; ，该范围必须是先前从此数组中提取的有效范围。 &lt;code&gt;stuff&lt;/code&gt; 可以转换为一个值 &lt;code&gt;bool&lt;/code&gt; 的或可转换为一定范围的对象 &lt;code&gt;bool&lt;/code&gt; 的。稳定版本和非稳定版本的行为相同，并保证遍历数组的范围永远不会无效。</target>
        </trans-unit>
        <trans-unit id="dcb7963cdc25fdee24c788729e6be8dd4f7e3c27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">将 &lt;code&gt;stuff&lt;/code&gt; 插入容器的前面。 &lt;code&gt;stuff&lt;/code&gt; 可以是可转换的值 &lt;code&gt;T&lt;/code&gt; 或可转换为一定范围的对象 &lt;code&gt;T&lt;/code&gt; 。稳定版本的行为相同，但是保证在容器上进行迭代的范围永远不会失效。</target>
        </trans-unit>
        <trans-unit id="70b0bd082af545b88841219b95946def84b1bde5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front/back of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">将 &lt;code&gt;stuff&lt;/code&gt; 插入容器的前面/后面。 &lt;code&gt;stuff&lt;/code&gt; 可以是可转换的值 &lt;code&gt;T&lt;/code&gt; 或可转换为一定范围的对象 &lt;code&gt;T&lt;/code&gt; 。稳定版本的行为相同，但是保证在容器上进行迭代的范围永远不会失效。</target>
        </trans-unit>
        <trans-unit id="98d4bdcdc44b42cf7f92f1b1fa3789c2aceb532f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the back of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;c&lt;/code&gt; 的后面插入 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="314547f0dd75063020e998c66bb1c080e7cc353d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the front of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;c&lt;/code&gt; 的前面插入 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b4118de001ef07d96ca9dc875bb736525602b3c" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the store. If the underlying store is a range and &lt;code&gt;length == capacity&lt;/code&gt;, throws an exception.</source>
          <target state="translated">将 &lt;code&gt;value&lt;/code&gt; 插入商店。如果基础存储区是range和 &lt;code&gt;length == capacity&lt;/code&gt; ，则抛出异常。</target>
        </trans-unit>
        <trans-unit id="7a861229c3ddec4f67c4aba3fc949701aaf45a21" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;c&lt;/code&gt; at a position (or positions) chosen by &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">插入件 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;c&lt;/code&gt; 在由所选择的位置（或位置） &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="804f9143c06ffa0aedcfc5172722337eadf6df16" translate="yes" xml:space="preserve">
          <source>Inserts a blank line.</source>
          <target state="translated">插入一个空行。</target>
        </trans-unit>
        <trans-unit id="7a0447d3d52b9161fad5aa788df5312d0c9f70f2" translate="yes" xml:space="preserve">
          <source>Inserts a comment in the output.</source>
          <target state="translated">在输出中插入注释。</target>
        </trans-unit>
        <trans-unit id="7a683c9546bcec22da2c836a994b3f342b2d3aa0" translate="yes" xml:space="preserve">
          <source>Inserts a full load/store memory fence (on platforms that need it). This ensures that all loads and stores before a call to this function are executed before any loads and stores after the call.</source>
          <target state="translated">插入一个完整的加载/存储内存栅栏(在需要它的平台上)。这确保了在调用该函数之前的所有加载和存储都在调用之后的任何加载和存储之前执行。</target>
        </trans-unit>
        <trans-unit id="a94c7ccab5212d83d09585607543df4cd0d7b0e8" translate="yes" xml:space="preserve">
          <source>Inserts a separator between overloads of a given name.</source>
          <target state="translated">在给定名称的重载之间插入一个分隔符。</target>
        </trans-unit>
        <trans-unit id="aa15c23194538bcbb65217c20c49d6e178298d1b" translate="yes" xml:space="preserve">
          <source>Inserts inline code.</source>
          <target state="translated">插入内联代码。</target>
        </trans-unit>
        <trans-unit id="be7c29e597d6483bb5cc792a0734c8430284107e" translate="yes" xml:space="preserve">
          <source>Inserts into an existing array at a given position.</source>
          <target state="translated">在给定的位置插入一个现有的数组中。</target>
        </trans-unit>
        <trans-unit id="b2e6a38a54ba983c83824eb96e11fa99e1fb236e" translate="yes" xml:space="preserve">
          <source>Inserts the separator symbols ',' every</source>
          <target state="translated">每隔一段时间就插入分隔符','。</target>
        </trans-unit>
        <trans-unit id="801258f3c2858353c18f16295039e48c4b8fb913" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">将指定的元素插入数组的后面。 &lt;code&gt;stuff&lt;/code&gt; 可以是可转换的值 &lt;code&gt;T&lt;/code&gt; 或可转换为一定范围的对象 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14cde1bdd1549aef1d369341e6d66efc2807a4bc" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">将指定的元素插入数组的后面。 &lt;code&gt;stuff&lt;/code&gt; 可以转换为一个值 &lt;code&gt;bool&lt;/code&gt; 的或可转换为一定范围的对象 &lt;code&gt;bool&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="1d605a6236091ada3048879c73c926d0efb2298d" translate="yes" xml:space="preserve">
          <source>Inside a compound format specifier, strings and characters are escaped automatically. To avoid this behavior, add &lt;b&gt;'-'&lt;/b&gt; flag to &lt;code&gt;&quot;%(&quot;&lt;/code&gt;.</source>
          <target state="translated">在复合格式说明符中，字符串和字符会自动转义。为避免此行为，请在&lt;b&gt;' &lt;/b&gt; &lt;code&gt;&quot;%(&quot;&lt;/code&gt; 添加&lt;b&gt;'-'&lt;/b&gt;标志。</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">实例变量</target>
        </trans-unit>
        <trans-unit id="6dcf70f56aa9632f46bb219a5e2ab80717bd81f1" translate="yes" xml:space="preserve">
          <source>Instance shared by all callers.</source>
          <target state="translated">实例由所有调用者共享。</target>
        </trans-unit>
        <trans-unit id="1d560aaea91ff74c40b9ba925224eb2e9cab5714" translate="yes" xml:space="preserve">
          <source>Instances of class objects are created with a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">类对象的实例是使用&lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;创建的：</target>
        </trans-unit>
        <trans-unit id="0e15b22639879009392385cbbbd0e07778e511d1" translate="yes" xml:space="preserve">
          <source>Instances of this object are constructed via calls to &lt;code&gt;regex&lt;/code&gt;. This is an intended form for caching and storage of frequently used regular expressions.</source>
          <target state="translated">通过调用 &lt;code&gt;regex&lt;/code&gt; 构造此对象的实例。这是用于缓存和存储常用正则表达式的预期形式。</target>
        </trans-unit>
        <trans-unit id="9c373dca3c1b04cc6629e642fffbe62b3a9fe4e5" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;DebugCondition&lt;/code&gt;</source>
          <target state="translated">实例化一个新的 &lt;code&gt;DebugCondition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3822674a7468f752517c5bf52d226dd0137e7bff" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;VersionCondition&lt;/code&gt;</source>
          <target state="translated">实例化一个新的 &lt;code&gt;VersionCondition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="152f1a2b9d65da1e9f82b24f153f213ef690987a" translate="yes" xml:space="preserve">
          <source>Instantiates the given template with the given parameters.</source>
          <target state="translated">用给定的参数实例化给定的模板。</target>
        </trans-unit>
        <trans-unit id="4a327f215e80d73f8ee4464a28c7b7c009445a31" translate="yes" xml:space="preserve">
          <source>Instantiation Scope</source>
          <target state="translated">实例范围</target>
        </trans-unit>
        <trans-unit id="93486e626687f1b1676b1b49e1fd6518a0b454b0" translate="yes" xml:space="preserve">
          <source>Instantiation information</source>
          <target state="translated">实例信息</target>
        </trans-unit>
        <trans-unit id="dac2b060e0095872817c2470eb8b53d6b6180adb" translate="yes" xml:space="preserve">
          <source>Instatiates a new function call expression</source>
          <target state="translated">实行一个新的函数调用表达式</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="a0905dbb5b366516614f7115449ef89eac51f289" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to not use any signal/alarm handlers, even when using timeouts. This option is useful for multi-threaded applications. See libcurl-the-guide for more background information.</source>
          <target state="translated">指示libcurl不使用任何信号/警报处理程序,即使是在使用超时的情况下。这个选项对多线程应用程序很有用。更多背景信息请参见libcurl-the-guide。</target>
        </trans-unit>
        <trans-unit id="93df39339f21a04f493609200c104dc46ba84fa9" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to use a smaller receive buffer</source>
          <target state="translated">指示libcurl使用较小的接收缓冲区。</target>
        </trans-unit>
        <trans-unit id="4e856d175354403c672463be1daf8914ce0f2b64" translate="yes" xml:space="preserve">
          <source>Instruct the thread module, when initialized, to use a different set of signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads. This function should be called at most once, prior to thread_init(). This function is Posix-only.</source>
          <target state="translated">指示线程模块在初始化时,除了SIGUSR1和SIGUSR2之外,使用一组不同的信号来暂停和恢复线程。这个函数最多调用一次,在 thread_init()之前。这个函数只适用于Posix。</target>
        </trans-unit>
        <trans-unit id="ea729c0363a2bc9c76992c1a2e2bf3e5220ecc9e" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file, suitable for input to a linker.</source>
          <target state="translated">从目标架构中选择指令来实现程序的语义。典型的结果将是一个对象文件,适合输入到链接器。</target>
        </trans-unit>
        <trans-unit id="492ad7a25e9093c89a88ab9eae0481a3d6d480b5" translate="yes" xml:space="preserve">
          <source>IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;(Expression e);</source>
          <target state="translated">IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;（式E）;</target>
        </trans-unit>
        <trans-unit id="562d27265f4183bba6926e62be0c6ce57f7e2097" translate="yes" xml:space="preserve">
          <source>Integer Literals</source>
          <target state="translated">整数字数</target>
        </trans-unit>
        <trans-unit id="bd777b837ba4f419f4b02435e27128be81023ef2" translate="yes" xml:space="preserve">
          <source>Integer Promotions</source>
          <target state="translated">整数促销</target>
        </trans-unit>
        <trans-unit id="9568ecb6786424f8ca136701942b4f686fc642d2" translate="yes" xml:space="preserve">
          <source>Integer Promotions are conversions of the following types:</source>
          <target state="translated">整数促销是以下类型的转换。</target>
        </trans-unit>
        <trans-unit id="db47076f1ac16cea001c1edc5817f57fa5127f93" translate="yes" xml:space="preserve">
          <source>Integer Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong) ['+'|'-']digit(s)[U|L|UL]</source>
          <target state="translated">整数整数。(byte,ubyte,short,ushort,int,uint,long,and ulong)['+''|'-']数字(s)[U|L|UL]。</target>
        </trans-unit>
        <trans-unit id="2c1da0fff670105eb87d89c45a8168527ceeec25" translate="yes" xml:space="preserve">
          <source>Integer comparison operators</source>
          <target state="translated">整数比较运算符</target>
        </trans-unit>
        <trans-unit id="b5ccca1ae24a500cd1c22e7e4ca7606c1848c22a" translate="yes" xml:space="preserve">
          <source>Integer comparisons</source>
          <target state="translated">整数比较</target>
        </trans-unit>
        <trans-unit id="343b406e188c4782bf6c33cf9f047756fbc9ecb9" translate="yes" xml:space="preserve">
          <source>Integer comparisons happen when both operands are integral types.</source>
          <target state="translated">整数比较发生在两个操作数都是积分类型时。</target>
        </trans-unit>
        <trans-unit id="adcbb9dbe2818c1f42e7e40cd4eb69ffc2847624" translate="yes" xml:space="preserve">
          <source>Integer values cannot be implicitly converted to another type that cannot represent the integer bit pattern after integral promotion. For example:</source>
          <target state="translated">整数值在积分推广后,不能隐性地转换为另一种不能表示整数位模式的类型。例如:</target>
        </trans-unit>
        <trans-unit id="2745c9287a60962527a82479b71c8fcdcdfee9b5" translate="yes" xml:space="preserve">
          <source>IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt;(int v)();</source>
          <target state="translated">IntegerExp &lt;strong id=&quot;literal&quot;&gt;文字&lt;/strong&gt;（int v）（）;</target>
        </trans-unit>
        <trans-unit id="9ef2cfdc220f6cdcf3fe63e63ff8a17f54977fca" translate="yes" xml:space="preserve">
          <source>IntegerExpression</source>
          <target state="translated">IntegerExpression</target>
        </trans-unit>
        <trans-unit id="17c52e79fc66bb6ecd61f1fe24bcec43e30c42c1" translate="yes" xml:space="preserve">
          <source>IntegerLiteral</source>
          <target state="translated">IntegerLiteral</target>
        </trans-unit>
        <trans-unit id="36d10f6bb46fb8657ec9f18b1e3a960789ae3c76" translate="yes" xml:space="preserve">
          <source>Integers (that may be constant-folded).</source>
          <target state="translated">整数(可以是恒定的倍数)。</target>
        </trans-unit>
        <trans-unit id="f69d4a47975b227c4173e0f25508229d914b2ec7" translate="yes" xml:space="preserve">
          <source>Integers and floating point values can be implicitly converted to their vector equivalents:</source>
          <target state="translated">整数和浮点值可以隐式转换为它们的向量等值。</target>
        </trans-unit>
        <trans-unit id="85eae330c4b91b44cc2722cee1dc4a35c6511dee" translate="yes" xml:space="preserve">
          <source>Integers can be immediately followed by one &amp;lsquo;L&amp;rsquo; or one of &amp;lsquo;u&amp;rsquo; or &amp;lsquo;U&amp;rsquo; or both. Note that there is no &amp;lsquo;l&amp;rsquo; suffix.</source>
          <target state="translated">整数后面可以紧跟一个'L'或'u'或'U'之一或两者。请注意，没有后缀&amp;ldquo; l&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="78c49e8c1cc448a9049ab277bc8754ecd4237b78" translate="yes" xml:space="preserve">
          <source>Integers can be specified in decimal, binary, or hexadecimal.</source>
          <target state="translated">整数可以用十进制、二进制或十六进制指定。</target>
        </trans-unit>
        <trans-unit id="2f0a498505f60eef0691bff5f687040cecb8e8a2" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">整数可以包含嵌入的&amp;ldquo; _&amp;rdquo;字符，这些字符将被忽略。</target>
        </trans-unit>
        <trans-unit id="e97fd09a5e159320944c7a6e53ff8dac7ae91693" translate="yes" xml:space="preserve">
          <source>Integral arithmetic operators operate on fixed width types. Results that are not representable in those fixed widths are silently truncated to fit. This module offers integral arithmetic primitives that produce the same results, but set an 'overflow' flag when such truncation occurs. The setting is sticky, meaning that numerous operations can be cascaded and then the flag need only be checked at the end. Whether the operation is signed or unsigned is indicated by an 's' or 'u' suffix, respectively. While this could be achieved without such suffixes by using overloading on the signedness of the types, the suffix makes it clear which is happening without needing to examine the types.</source>
          <target state="translated">积分算术运算符在固定宽度类型上操作。在这些固定宽度中无法表示的结果会被默默截断以适应。该模块提供了可产生相同结果的积分算术基元,但在发生此类截断时,会设置一个 &quot;溢出 &quot;标志。该设置是粘性的,这意味着可以级联许多运算,然后只需要在最后检查标志。操作是有符号的还是无符号的,分别用's'或'u'后缀表示。虽然没有这种后缀也可以通过对类型的签名性使用重载来实现,但后缀可以让人清楚地知道发生了哪种情况,而不需要检查类型。</target>
        </trans-unit>
        <trans-unit id="6c054c378c65fd28ca92392142534a3f43340caf" translate="yes" xml:space="preserve">
          <source>Integral ranges</source>
          <target state="translated">整数范围</target>
        </trans-unit>
        <trans-unit id="3c327fe3bc8ca1ef616b394085c0f88695904ee8" translate="yes" xml:space="preserve">
          <source>Integral types will remain the same sizes between 32 and 64 bit code.</source>
          <target state="translated">积分类型在32位和64位代码之间将保持相同的大小。</target>
        </trans-unit>
        <trans-unit id="58ee21eb085c257d8a08439c9aa7bd9d6570255b" translate="yes" xml:space="preserve">
          <source>Integrals</source>
          <target state="translated">Integrals</target>
        </trans-unit>
        <trans-unit id="304d073445766b9e99ba6213d6788d69fbbe285d" translate="yes" xml:space="preserve">
          <source>Integrals are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">积分的格式类似于&lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20aeee70fc77c214f263c77b05117e3b20686b33" translate="yes" xml:space="preserve">
          <source>Intel Atom 230/330 (family 6, model 0x1C) is an in-order core.</source>
          <target state="translated">英特尔Atom 230/330(家族6,型号0x1C)是一款内购核心。</target>
        </trans-unit>
        <trans-unit id="25a734a01cad152ff48222d53e7362444f3ac6cd" translate="yes" xml:space="preserve">
          <source>Intel NetBurst (Pentium 4, Pentium D).</source>
          <target state="translated">英特尔NetBurst(奔腾4、奔腾D)。</target>
        </trans-unit>
        <trans-unit id="40d218fe001ffffff82fbf964a99f28c6e816245" translate="yes" xml:space="preserve">
          <source>Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</source>
          <target state="translated">英特尔P6(PentiumPro、PII、PIII、PM、Core、Core2)。</target>
        </trans-unit>
        <trans-unit id="ffc1549d5dca52e99aa4ab17a1e6e08f96cd5245" translate="yes" xml:space="preserve">
          <source>Intel and AMD 32-bit processors</source>
          <target state="translated">英特尔和AMD 32位处理器</target>
        </trans-unit>
        <trans-unit id="3eaebee622e08211c80a68d4d6c79b54e2adb573" translate="yes" xml:space="preserve">
          <source>Intel and AMD 64-bit processors</source>
          <target state="translated">英特尔和AMD 64位处理器</target>
        </trans-unit>
        <trans-unit id="d9d20cde548a0781b6cf33434f83eb6eb5ef95f8" translate="yes" xml:space="preserve">
          <source>Intended as the range equivalent of the Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt; utility. When the length of &lt;code&gt;range&lt;/code&gt; is less than or equal to &lt;code&gt;_n&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; is returned as-is.</source>
          <target state="translated">目的是与Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt;实用程序等效的范围。当 &lt;code&gt;range&lt;/code&gt; 的长度小于或等于 &lt;code&gt;_n&lt;/code&gt; 时，将按原样返回 &lt;code&gt;range&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="d88c1e8acf6c80eddca147502d3048d176708e8b" translate="yes" xml:space="preserve">
          <source>Interface for a bidirectional range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;E&lt;/code&gt; 的双向范围的接口。</target>
        </trans-unit>
        <trans-unit id="d0e1da15b0eee348c354776c7e919fb0b891bd0d" translate="yes" xml:space="preserve">
          <source>Interface for a finite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;E&lt;/code&gt; 的有限随机访问范围的接口。</target>
        </trans-unit>
        <trans-unit id="7a634a284850ac6bc64c6899e29c994e3e0d76a1" translate="yes" xml:space="preserve">
          <source>Interface for a forward range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;E&lt;/code&gt; 的正向范围的接口。</target>
        </trans-unit>
        <trans-unit id="9a821a67cbe42a25dc97be41d2bf278fa2b3f8d9" translate="yes" xml:space="preserve">
          <source>Interface for an infinite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;E&lt;/code&gt; 的无限随机访问范围的接口。</target>
        </trans-unit>
        <trans-unit id="c9d0cf57e850156d9f049479c7169bad62b9af52" translate="yes" xml:space="preserve">
          <source>Interface for an output range of type &lt;code&gt;E&lt;/code&gt;. Usage is similar to the &lt;code&gt;InputRange&lt;/code&gt; interface and descendants.</source>
          <target state="translated">类型为 &lt;code&gt;E&lt;/code&gt; 的输出范围的接口。用法类似于 &lt;code&gt;InputRange&lt;/code&gt; 接口及其后代。</target>
        </trans-unit>
        <trans-unit id="9460943add2d33f93432076ae984835cefe527f7" translate="yes" xml:space="preserve">
          <source>Interface for diagnostic reporting.</source>
          <target state="translated">诊断报告的接口。</target>
        </trans-unit>
        <trans-unit id="3a1df4ab19b1c423cdf62882763fa74c4af37e82" translate="yes" xml:space="preserve">
          <source>Interface member functions can have contracts even though there is no body for the function. The contracts are inherited by any class member function that implements that interface member function.</source>
          <target state="translated">接口成员函数即使没有函数主体,也可以有合同。这些合同被任何实现该接口成员函数的类成员函数继承。</target>
        </trans-unit>
        <trans-unit id="f3be3896196c198c957ce4d700b0918b399182de" translate="yes" xml:space="preserve">
          <source>Interface to C++</source>
          <target state="translated">与C++的接口</target>
        </trans-unit>
        <trans-unit id="d7b35a8578bedf4b2033b8a1d3efb36b51c26426" translate="yes" xml:space="preserve">
          <source>Interface to ODBC C library.</source>
          <target state="translated">ODBC C库的接口。</target>
        </trans-unit>
        <trans-unit id="621522c8d929097b62eb853aff27378218dcc932" translate="yes" xml:space="preserve">
          <source>Interface to OS-specific allocators that support specifying alignment: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt;&lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt;&lt;code&gt;__aligned_xxx&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">与支持指定对齐方式的特定于操作系统的分配器的接口：Posix 上的&lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt;和Windows 上的&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_xxx&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da8580df0429b0473e5e3791367530334b73829e" translate="yes" xml:space="preserve">
          <source>Interface to SQLite C library.</source>
          <target state="translated">SQLite C库的接口。</target>
        </trans-unit>
        <trans-unit id="7de306419630810feb8071066cf5e31bb55e01fb" translate="yes" xml:space="preserve">
          <source>Interface to libcurl C library.</source>
          <target state="translated">libcurl C库的接口。</target>
        </trans-unit>
        <trans-unit id="f42fa13806030306bbca72d2c1d02ced3c60299a" translate="yes" xml:space="preserve">
          <source>Interface to the C linked list type.</source>
          <target state="translated">C链接列表类型的接口。</target>
        </trans-unit>
        <trans-unit id="e3744c2b6a83f2ded743b60e48109853d6af0029" translate="yes" xml:space="preserve">
          <source>Interface to zlib C library.</source>
          <target state="translated">zlib C库的接口。</target>
        </trans-unit>
        <trans-unit id="0e4b1bcf55c79cee225ecf64df995188b37f85a9" translate="yes" xml:space="preserve">
          <source>Interface[] &lt;strong id=&quot;interfaces&quot;&gt;interfaces&lt;/strong&gt;;</source>
          <target state="translated">Interface [] &lt;strong id=&quot;interfaces&quot;&gt;接口&lt;/strong&gt;；</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="87ef706c8b2c0856ee57ff234b67b63ee3440c74" translate="yes" xml:space="preserve">
          <source>Interfaces can be inherited and functions overridden:</source>
          <target state="translated">接口可以被继承,功能可以被重写。</target>
        </trans-unit>
        <trans-unit id="5c38dbc7db84c5be19893f9ea37a5e4e03b244d7" translate="yes" xml:space="preserve">
          <source>Interfaces can be reimplemented in derived classes:</source>
          <target state="translated">接口可以在派生类中重新实现。</target>
        </trans-unit>
        <trans-unit id="5c369ab8b0d4a9f58e24c8d22b04e27527c78058" translate="yes" xml:space="preserve">
          <source>Interfaces can have function templates in the members. All instantiated functions are implicitly &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">接口的成员中可以具有功能模板。所有实例化的函数都是隐式 &lt;code&gt;final&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdf123e52e487e317a85601aa2c062c8ae21bd83" translate="yes" xml:space="preserve">
          <source>Interfaces cannot derive from classes; only from other interfaces. Classes cannot derive from an interface multiple times.</source>
          <target state="translated">接口不能从类派生,只能从其他接口派生。类不能多次从一个接口派生。</target>
        </trans-unit>
        <trans-unit id="233b20e42a18eec431d3cd18cbd18fa45bf5e124" translate="yes" xml:space="preserve">
          <source>Interfaces describe a list of functions that a class that inherits from the interface must implement. A class that implements an interface can be converted to a reference to that interface.</source>
          <target state="translated">接口描述了继承自接口的类必须实现的功能列表。实现接口的类可以转换为对该接口的引用。</target>
        </trans-unit>
        <trans-unit id="c99b66b1687d267b80c156d483b9207e87aa2612" translate="yes" xml:space="preserve">
          <source>Interfaces to extend FTS5.</source>
          <target state="translated">扩展FTS5的接口。</target>
        </trans-unit>
        <trans-unit id="737865cc9d40029ada2522214f2743a9901cb1cf" translate="yes" xml:space="preserve">
          <source>Interfaces with Contracts</source>
          <target state="translated">与合同的接口</target>
        </trans-unit>
        <trans-unit id="772a604c8c3d9a084a30e26beb308940804e19fb" translate="yes" xml:space="preserve">
          <source>Interfacing Garbage Collected Objects With Foreign Code</source>
          <target state="translated">将垃圾收集的对象与外部代码对接。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
