<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="dfd76a7086e3cc42170f403e6e55cc09afe26cb2" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; satisfies the following properties: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&amp;nbsp;*&amp;nbsp;y&amp;nbsp;+&amp;nbsp;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; and &lt;code&gt;abs(x&amp;nbsp;mod&amp;nbsp;y)&amp;nbsp;&amp;lt;=&amp;nbsp;abs(y)&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;. Note that &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; is negative only if &lt;code&gt;x&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">整数余数。如果 &lt;code&gt;y&lt;/code&gt; 不为零，则 &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; 的结果满足以下属性： &lt;code&gt;x&amp;nbsp;=&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&amp;nbsp;*&amp;nbsp;y&amp;nbsp;+&amp;nbsp;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; 和 &lt;code&gt;abs(x&amp;nbsp;mod&amp;nbsp;y)&amp;nbsp;&amp;lt;=&amp;nbsp;abs(y)&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 。如果 &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; ，则 &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; 引发 &lt;code&gt;Division_by_zero&lt;/code&gt; 。注意，只有当 &lt;code&gt;x&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt; ， &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; 为负。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b01a6a7b79fbcb183062af64aaaa63eeb3f2718" translate="yes" xml:space="preserve">
          <source>Integer subtraction.</source>
          <target state="translated">整数减法。</target>
        </trans-unit>
        <trans-unit id="80d24914c47006eb02f4dff06d0cd904dc2d2c7e" translate="yes" xml:space="preserve">
          <source>Integer subtraction. Left-associative operator, , see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">整数减法。左关联运算符，请参阅&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;以获得更多信息。</target>
        </trans-unit>
        <trans-unit id="7ee1ee4b4f11b2969952d343f112afa9881a1bab" translate="yes" xml:space="preserve">
          <source>Integer values are integer numbers from &amp;minus;2&lt;sup&gt;30&lt;/sup&gt; to 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1, that is &amp;minus;1073741824 to 1073741823. The implementation may support a wider range of integer values: on 64-bit platforms, the current implementation supports integers ranging from &amp;minus;2&lt;sup&gt;62&lt;/sup&gt; to 2&lt;sup&gt;62&lt;/sup&gt;&amp;minus;1.</source>
          <target state="translated">整数值是从-2 &lt;sup&gt;30&lt;/sup&gt;到2 &lt;sup&gt;30&lt;/sup&gt; -1的整数，即-1073741824到1073741823。该实现可能支持更大范围的整数值：在64位平台上，当前实现支持从-2 &lt;sup&gt;62&lt;/sup&gt;到范围为-2的整数。2 &lt;sup&gt;62&lt;/sup&gt; -1。</target>
        </trans-unit>
        <trans-unit id="712ee29f7fc5c28dea5cc603b21eca7741d78fbd" translate="yes" xml:space="preserve">
          <source>Integer values encode 63-bit signed integers (31-bit on 32-bit architectures). They are unboxed (unallocated).</source>
          <target state="translated">整数值对63位有符号的整数进行编码(32位架构下为31位)。它们是未装箱的(未分配的)。</target>
        </trans-unit>
        <trans-unit id="f83aa7411530d0444302d56a388b902fdce29d91" translate="yes" xml:space="preserve">
          <source>Integer values.</source>
          <target state="translated">整数值。</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="bc497571cb33f7c1a8b4b38e571f47e9c94eb5e7" translate="yes" xml:space="preserve">
          <source>Integers are &lt;a href=&quot;sys#VALint_size&quot;&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/a&gt; bits wide and use two's complement representation. All operations are taken modulo 2&lt;sup&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/sup&gt;. They do not fail on overflow.</source>
          <target state="translated">整数为&lt;a href=&quot;sys#VALint_size&quot;&gt; &lt;code&gt;Sys.int_size&lt;/code&gt; &lt;/a&gt;位宽，并使用二进制补码表示。所有操作均以&lt;sup&gt; &lt;code&gt;Sys.int_size&lt;/code&gt; &lt;/sup&gt; 2为模。它们不会在溢出时失败。</target>
        </trans-unit>
        <trans-unit id="c4241877025d1966580ad7c3f3b0ff442755310e" translate="yes" xml:space="preserve">
          <source>Integers are &lt;code&gt;Sys.int_size&lt;/code&gt; bits wide. All operations are taken modulo 2&lt;sup&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/sup&gt;. They do not fail on overflow.</source>
          <target state="translated">整数为 &lt;code&gt;Sys.int_size&lt;/code&gt; 位宽。所有操作均以&lt;sup&gt; &lt;code&gt;Sys.int_size&lt;/code&gt; &lt;/sup&gt; 2为模。它们不会在溢出时失败。</target>
        </trans-unit>
        <trans-unit id="f4a102c4a574ecfadd9a7c5f1722bd0399b5d2cd" translate="yes" xml:space="preserve">
          <source>Integers are not allocated and cannot be stored in weak arrays.</source>
          <target state="translated">整数没有分配,不能存储在弱数组中。</target>
        </trans-unit>
        <trans-unit id="935ae25e71bde4c78ba85d5dac1b5c31c4661273" translate="yes" xml:space="preserve">
          <source>Interactive interrupt (ctrl-C)</source>
          <target state="translated">交互式中断(ctrl-C)</target>
        </trans-unit>
        <trans-unit id="04543475f0af93a9b1f70f2a38be6ff47c43ef12" translate="yes" xml:space="preserve">
          <source>Interactive stop</source>
          <target state="translated">互动式停止</target>
        </trans-unit>
        <trans-unit id="9cc0bc31a21623037df91a449af1758c1ea53779" translate="yes" xml:space="preserve">
          <source>Interactive termination</source>
          <target state="translated">互动式终止</target>
        </trans-unit>
        <trans-unit id="152a2569e2c91ee227ddb8f5534f2eae5eb0d12f" translate="yes" xml:space="preserve">
          <source>Interface to the Unix system.</source>
          <target state="translated">与Unix系统的接口。</target>
        </trans-unit>
        <trans-unit id="b9f4c23d2b8212406b51e7046c93c96a1a7f1146" translate="yes" xml:space="preserve">
          <source>Interface to the Unix system. To use as replacement to default &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module, add &lt;code&gt;module&amp;nbsp;Unix&amp;nbsp;=&amp;nbsp;UnixLabels&lt;/code&gt; in your implementation.</source>
          <target state="translated">与Unix系统的接口。要用作默认&lt;a href=&quot;unix&quot;&gt; &lt;code&gt;Unix&lt;/code&gt; &lt;/a&gt;模块的替代品， &lt;code&gt;module&amp;nbsp;Unix&amp;nbsp;=&amp;nbsp;UnixLabels&lt;/code&gt; 在您的实现中添加模块Unix = UnixLabels。</target>
        </trans-unit>
        <trans-unit id="467f8304012cd505625c260277e4cae411499ca2" translate="yes" xml:space="preserve">
          <source>Interfacing with the standard input/output library</source>
          <target state="translated">与标准输入/输出库的接口。</target>
        </trans-unit>
        <trans-unit id="8d7c946b4a793edf3af449c46e4c2c299d575469" translate="yes" xml:space="preserve">
          <source>Internet addresses</source>
          <target state="translated">互联网地址</target>
        </trans-unit>
        <trans-unit id="c4ecff40bc2b8c11c2e5679d0ffe558077996225" translate="yes" xml:space="preserve">
          <source>Internet domain (IPv4)</source>
          <target state="translated">网域</target>
        </trans-unit>
        <trans-unit id="857d078139ed411f7ba1150677d3393807432577" translate="yes" xml:space="preserve">
          <source>Internet domain (IPv6)</source>
          <target state="translated">互联网域名</target>
        </trans-unit>
        <trans-unit id="b995e53883804fd20a387b321cb4b4c4302563e5" translate="yes" xml:space="preserve">
          <source>Interrupt character (usually ctrl-C).</source>
          <target state="translated">中断字符(通常为ctrl-C)。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="279042ba487b938485f08f0399290c5d0cf49331" translate="yes" xml:space="preserve">
          <source>Intuition: a &amp;ldquo;blocking section&amp;rdquo; is a piece of C code that does not use the OCaml run-time system, typically a blocking input/output operation.</source>
          <target state="translated">直觉：&amp;ldquo;阻塞部分&amp;rdquo;是一段不使用OCaml运行时系统的C代码，通常是阻塞输入/输出操作。</target>
        </trans-unit>
        <trans-unit id="50d8afba7764b4a5e45be2c963d38829c02898a1" translate="yes" xml:space="preserve">
          <source>Intuitively, a value of type 'a nested is a list of list &amp;hellip;of list of elements a with k nested list. We can then adapt the maximal_depth function defined on regular_depth into a depth function that computes this k. As a first try, we may define</source>
          <target state="translated">直观地，嵌套类型为'a'的值是列表列表&amp;hellip;具有k个嵌套列表的元素列表a的列表。然后，我们可以将对regular_depth定义的maximal_depth函数改编为计算该k的深度函数。第一次尝试，我们可以定义</target>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="translated">无效参数</target>
        </trans-unit>
        <trans-unit id="eb51873a166a0ca612be5e39e25b496f16f0edd3" translate="yes" xml:space="preserve">
          <source>Invalid hardware instruction</source>
          <target state="translated">无效的硬件指令</target>
        </trans-unit>
        <trans-unit id="3aaeaeb6ec3f8154506ce18b333531c275dcb035" translate="yes" xml:space="preserve">
          <source>Invalid link</source>
          <target state="translated">无效链接</target>
        </trans-unit>
        <trans-unit id="1835382968f46a5f88dff8462ccb2b244e21516d" translate="yes" xml:space="preserve">
          <source>Invalid memory reference</source>
          <target state="translated">无效的内存引用</target>
        </trans-unit>
        <trans-unit id="9851d3714a00331607464ec1db51c684493f3fde" translate="yes" xml:space="preserve">
          <source>Invalid seek e.g. on a pipe</source>
          <target state="translated">无效寻找,例如在管道上的寻找</target>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="translated">是一个目录</target>
        </trans-unit>
        <trans-unit id="d246b366cbb2a7b87d693c8eb7b14afb327f18c3" translate="yes" xml:space="preserve">
          <source>Is_block(v) is true if value v is a pointer to a block, and false if it is an immediate integer.</source>
          <target state="translated">如果值v是一个指向块的指针,则Is_block(v)为真,如果是一个立即整数,则为假。</target>
        </trans-unit>
        <trans-unit id="162a91bb1ae1511c1a14b48fc9b99ad1c1b64c87" translate="yes" xml:space="preserve">
          <source>Is_long(v) is true if value v is an immediate integer, false otherwise</source>
          <target state="translated">如果值v是立即整数,则Is_long(v)为真,否则为假。</target>
        </trans-unit>
        <trans-unit id="9aad919330ed2554ad6efa2615b1d05980c4a1fa" translate="yes" xml:space="preserve">
          <source>Is_none(v) is true if value v is None.</source>
          <target state="translated">如果值v为None,则Is_none(v)为真。</target>
        </trans-unit>
        <trans-unit id="805c7256b88b9f3f6f1e903639b0f13116fe3e22" translate="yes" xml:space="preserve">
          <source>Is_some(v) is true if value v (assumed to be of option type) corresponds to the Some constructor.</source>
          <target state="translated">如果值v(假设为选项类型)对应于Some构造函数,则Is_some(v)为真。</target>
        </trans-unit>
        <trans-unit id="90960e35ff8d0e1edddd78784b82e7ac0c892d5d" translate="yes" xml:space="preserve">
          <source>It becomes more straightforward to optimise closure allocations since the layout of closures does not have to be estimated in any way: it is known. Similarly, it becomes more straightforward to control which variables end up in which closures, helping to avoid closure bloat.</source>
          <target state="translated">由于不需要以任何方式估计闭包的布局:它是已知的,因此优化闭包分配变得更加直接。同样,控制哪些变量最终会出现在哪些闭包中也变得更加简单,有助于避免闭包的膨胀。</target>
        </trans-unit>
        <trans-unit id="e7c1a2b53a967f6be04a8b2e559ade5c3657e377" translate="yes" xml:space="preserve">
          <source>It can be given the following specification:</source>
          <target state="translated">它可以被赋予以下规格:</target>
        </trans-unit>
        <trans-unit id="82b604d7f25795726169718eb6d7ffbabff67881" translate="yes" xml:space="preserve">
          <source>It generates the following outputs:</source>
          <target state="translated">它产生以下产出:</target>
        </trans-unit>
        <trans-unit id="4d9fb0522efe7d2a9a2092136c5f0cb0eceb5547" translate="yes" xml:space="preserve">
          <source>It is a natural choice in the API of generic functions where values could fall in two different cases, possibly at different types, without assigning a specific meaning to what each case should be.</source>
          <target state="translated">在通用函数的API中,值可以落在两种不同的情况下,可能是不同的类型,而不给每一种情况赋予特定的意义,这是一种自然的选择。</target>
        </trans-unit>
        <trans-unit id="af8b480dde6b5f3c81553f985c24b6d8054d15cf" translate="yes" xml:space="preserve">
          <source>It is also extremely useful for first-class modules (see section &amp;zwj;&lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;) and generalized algebraic datatypes (GADTs: see section &amp;zwj;&lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;).</source>
          <target state="translated">它也是一类模块（见节极其有用&lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;）和广义代数数据类型（GADTs：见&lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="044d9b1336b13c24f31c6087a0884aa833908413" translate="yes" xml:space="preserve">
          <source>It is also extremely useful for first-class modules (see section &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;) and generalized algebraic datatypes (GADTs: see section &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;).</source>
          <target state="translated">对于一流的模块（请参阅第&lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;节）和广义代数数据类型（GADT：请参阅第&lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;节），它也非常有用。</target>
        </trans-unit>
        <trans-unit id="bea3ffa0da3a6a64e26d92217f56bc5dc0ee88ad" translate="yes" xml:space="preserve">
          <source>It is also possible to copy the components of a module inside another module by using an include statement. This can be particularly useful to extend existing modules. As an illustration, we could add functions that returns an optional value rather than an exception when the priority queue is empty.</source>
          <target state="translated">也可以通过使用include语句将一个模块的组件复制到另一个模块中。这对扩展现有的模块特别有用。举个例子,我们可以添加一些函数,当优先级队列为空时,返回一个可选的值,而不是一个异常。</target>
        </trans-unit>
        <trans-unit id="8b378569adc4da470dbea88424425ba33922ddf5" translate="yes" xml:space="preserve">
          <source>It is also possible to specify attributes using an infix syntax. For instance:</source>
          <target state="translated">也可以使用下位机语法来指定属性。例如:</target>
        </trans-unit>
        <trans-unit id="47fcca3d515f217455ee5cbe30c0a352c5140f35" translate="yes" xml:space="preserve">
          <source>It is also possible to use a virtual class. Inheriting from this class simultaneously forces all methods of c to have the same type as the methods of c'.</source>
          <target state="translated">也可以使用一个虚拟类。从这个类继承的同时,强制c的所有方法与c'的方法具有相同的类型。</target>
        </trans-unit>
        <trans-unit id="cd58beaddeffd7ca4bb4171ee18d2d1d171993da" translate="yes" xml:space="preserve">
          <source>It is assumed in the compiler that expressions with no effects, whose results are not used, may be eliminated. (This typically happens where the expression in question is the defining expression of a let; in such cases the let-expression will be eliminated.) It is further assumed that such expressions with no effects may be duplicated (and thus possibly executed more than once).</source>
          <target state="translated">编译器中假定没有效果的表达式,其结果没有被使用,可能会被消除。这通常发生在有关表达式是let的定义表达式的情况下;在这种情况下,let表达式将被消除。进一步假设这种没有效果的表达式可能会被重复(因此可能会被执行一次以上)。</target>
        </trans-unit>
        <trans-unit id="13d2ff83781a8a7489c112130f8ee70344794950" translate="yes" xml:space="preserve">
          <source>It is assumed in the compiler that, subject to data dependencies, expressions with neither effects nor coeffects may be reordered with respect to other expressions.</source>
          <target state="translated">编译器中假定,在数据依赖性的前提下,既没有效果也没有系数的表达式可以相对于其他表达式重新排序。</target>
        </trans-unit>
        <trans-unit id="ac5a661dd59eecff9dd10ceec465f901059e4cc2" translate="yes" xml:space="preserve">
          <source>It is automatically &amp;ldquo;opened&amp;rdquo; when a compilation starts, or when the toplevel system is launched. Hence, it is possible to use unqualified identifiers to refer to the functions provided by the Stdlib module, without adding a open Stdlib directive.</source>
          <target state="translated">当编译开始或顶层系统启动时，它会自动&amp;ldquo;打开&amp;rdquo;。因此，可以使用不合格的标识符来引用Stdlib模块提供的功能，而无需添加开放的Stdlib指令。</target>
        </trans-unit>
        <trans-unit id="fd50e36d45c2c70d3b44b44f6b93ceca5aaed4e3" translate="yes" xml:space="preserve">
          <source>It is automatically linked with the user&amp;rsquo;s object code files by the ocamlc command (chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">它自动由ocamlc命令（章用户的目标代码文件链接&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2cd4849d026298aa7f6ab63f07e5240537d04447" translate="yes" xml:space="preserve">
          <source>It is automatically linked with the user&amp;rsquo;s object code files by the ocamlc command (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">它通过ocamlc命令自动与用户的目标代码文件链接（第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章）。</target>
        </trans-unit>
        <trans-unit id="a83064bce61d18a3c463038ddbd763bdd7b618f8" translate="yes" xml:space="preserve">
          <source>It is defined as &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;stdlib#VALstderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它定义为&lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;stdlib#VALstderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de9bd2e9555690ad21a6a0c4218827b24b71e84a" translate="yes" xml:space="preserve">
          <source>It is defined as &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;stdlib#VALstdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它定义为&lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;stdlib#VALstdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b06674c64e7087d6cd54c0e34bb489d7d00dd20" translate="yes" xml:space="preserve">
          <source>It is easier to integrate with cross-module optimisation, since imported information about other modules is already in the correct intermediate language.</source>
          <target state="translated">由于导入的其他模块的信息已经在正确的中间语言中,所以更容易与跨模块优化整合。</target>
        </trans-unit>
        <trans-unit id="8c7e38f3c9e1798fbab9e90c5865cda5877abcfa" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;print_tbreak&amp;nbsp;0&amp;nbsp;0&lt;/code&gt;.</source>
          <target state="translated">它等效于 &lt;code&gt;print_tbreak&amp;nbsp;0&amp;nbsp;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f1f54bf27ff0a3758919f394790ff7b25c9d1f8" translate="yes" xml:space="preserve">
          <source>It is however possible to define functions that manipulate objects of type either money or money2: the function min will return the minimum of any two objects whose type unifies with #comparable. The type of min is not the same as #comparable -&amp;gt; #comparable -&amp;gt; #comparable, as the abbreviation #comparable hides a type variable (an ellipsis). Each occurrence of this abbreviation generates a new variable.</source>
          <target state="translated">但是，可以定义用于操作money或money2类型的对象的函数：函数min将返回其类型与#comparable统一的两个对象中的最小值。min的类型与#comparable-&amp;gt; #comparable-&amp;gt; #comparable不同，因为缩写#comparable隐藏类型变量（省略号）。每次出现此缩写都会生成一个新变量。</target>
        </trans-unit>
        <trans-unit id="06505630dc097368cdf81588999cb42bce21605e" translate="yes" xml:space="preserve">
          <source>It is important to note that the exported front-end interface follows the evolution of the OCaml language and implementation, and thus does not provide any backwards compatibility guarantees.</source>
          <target state="translated">需要注意的是,导出的前端接口是跟随OCaml语言和实现的演变而演变的,因此不提供任何向后的兼容性保证。</target>
        </trans-unit>
        <trans-unit id="df425a65ea13fa3de15879ad0ff948e700f992b5" translate="yes" xml:space="preserve">
          <source>It is important to provide the client&amp;rsquo;s view as a functor Client so that client accounts can still be built after a possible specialization of the bank. The functor Client may remain unchanged and be passed the new definition to initialize a client&amp;rsquo;s view of the extended account.</source>
          <target state="translated">重要的是要提供客户作为函子客户的视图，以便在可能的银行专业化之后仍可以建立客户帐户。函子客户端可以保持不变，并被传递新的定义以初始化客户端对扩展帐户的视图。</target>
        </trans-unit>
        <trans-unit id="a013a33299e01ccd1972c4a799393bbe9b322fa8" translate="yes" xml:space="preserve">
          <source>It is important to remark that the function eval is using the polymorphic syntax for locally abstract types. When defining a recursive function that manipulates a GADT, explicit polymorphic recursion should generally be used. For instance, the following definition fails with a type error:</source>
          <target state="translated">需要注意的是,函数eval使用的是局部抽象类型的多态语法。当定义一个操作GADT的递归函数时,一般应该使用显式多态递归。例如,下面的定义因类型错误而失败。</target>
        </trans-unit>
        <trans-unit id="33f0de9451006df17669b54818c85d11fb78b04d" translate="yes" xml:space="preserve">
          <source>It is not possible to mix native-code object files produced by ocamlopt with bytecode object files produced by ocamlc: a program must be compiled entirely with ocamlopt or entirely with ocamlc. Native-code object files produced by ocamlopt cannot be loaded in the toplevel system ocaml.</source>
          <target state="translated">不可能将ocamlopt产生的本地代码对象文件和ocamlc产生的字节码对象文件混合在一起:一个程序必须完全用ocamlopt或完全用ocamlc编译。ocamlopt产生的本地代码对象文件不能加载到toplevel系统ocaml中。</target>
        </trans-unit>
        <trans-unit id="cf6d73db6c27ba0773eb0db381d42efb65e8e409" translate="yes" xml:space="preserve">
          <source>It is often a security hole to leak file descriptors opened on, say, a private file to an external program: the program, then, gets access to the private file and can do bad things with it. Hence, it is highly recommended to set all file descriptors ``close-on-exec'', except in the very few cases where a file descriptor actually needs to be transmitted to another program.</source>
          <target state="translated">泄露文件描述符是一个安全漏洞,比如说,将私人文件上打开的文件描述符泄露给外部程序:然后,该程序可以访问私人文件,并对其做坏事。因此,强烈建议将所有的文件描述符设置为 &quot;执行时关闭&quot;,除非在极少数情况下,文件描述符实际上需要传输给另一个程序。</target>
        </trans-unit>
        <trans-unit id="79cb04a19a396d38be69e08c2821e7ce44154b03" translate="yes" xml:space="preserve">
          <source>It is only possible to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, if the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; (like for a type annotation), and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The type of the coerced expression is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. If the types contain variables, they may be instantiated by the subtyping algorithm, but this is only done after determining whether &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a potential subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This means that typing may fail during this latter unification step, even if some instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of some instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. In the following paragraphs we describe the subtyping relation used.</source>
          <target state="translated">它是唯一可能强迫表达&lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;从类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;输入&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;，若类型&lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;是的实例&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;（像类型注释），和&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;是的一个亚型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。强制表达式的类型是&lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;的实例。如果类型包含变量，则它们可以由子类型算法被实例化，但是这仅是确定是否之后完成&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;是一个潜在的亚型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。这意味着输入可以在该后者的统一步骤失败，即使一些实例&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;是一些实例的亚型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。在以下段落中，我们描述了所使用的子类型关系。</target>
        </trans-unit>
        <trans-unit id="ebc436df5f472c76f9b857cad66e30b424d794e2" translate="yes" xml:space="preserve">
          <source>It is possible to declare a method without actually defining it, using the keyword virtual. This method will be provided later in subclasses. A class containing virtual methods must be flagged virtual, and cannot be instantiated (that is, no object of this class can be created). It still defines type abbreviations (treating virtual methods as other methods.)</source>
          <target state="translated">可以使用关键字virtual来声明一个方法,而不实际定义它。这种方法将在以后的子类中提供。一个包含虚拟方法的类必须标记为虚拟,并且不能被实例化(也就是说,不能创建这个类的任何对象)。它仍然定义了类型缩写(将虚拟方法视为其他方法。</target>
        </trans-unit>
        <trans-unit id="21e850727b9f6478bee4607ccc53d1de385121ba" translate="yes" xml:space="preserve">
          <source>It is possible to define a generator class in several modules, which are defined in several files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], file&lt;sub&gt;2&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i]. A .cma library file must be created, including all these files.</source>
          <target state="translated">可以在多个模块中定义生成器类，这些模块在文件&lt;sub&gt;1&lt;/sub&gt; .ml [i]，文件&lt;sub&gt;2&lt;/sub&gt; .ml [i]，...，文件&lt;sub&gt;n&lt;/sub&gt; .ml [i]中定义。必须创建一个.cma库文件，包括所有这些文件。</target>
        </trans-unit>
        <trans-unit id="2faea6818157cac9f0988b494ec9a1fb10a63786" translate="yes" xml:space="preserve">
          <source>It is possible to define local exceptions in expressions: letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; . The syntactic scope of the exception constructor is the inner expression, but nothing prevents exception values created with this constructor from escaping this scope. Two executions of the definition above result in two incompatible exception constructors (as for any exception definition). For instance, the following assertion is true:</source>
          <target state="translated">这是可能的表达式定义本地异常：letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;构造-DECL&lt;/a&gt;在&lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;。异常构造函数的语法范围是内部表达式，但是没有什么可以阻止由此构造函数创建的异常值转义该范围。上面定义的两次执行导致两个不兼容的异常构造函数（对于任何异常定义）。例如，以下断言为真：</target>
        </trans-unit>
        <trans-unit id="61c1a7eb6e17934cbe039ce2d9565c2d1a043e49" translate="yes" xml:space="preserve">
          <source>It is possible to write a version of class point without assignments on the instance variables. The override construct {&amp;lt; ... &amp;gt;} returns a copy of &amp;ldquo;self&amp;rdquo; (that is, the current object), possibly changing the value of some instance variables.</source>
          <target state="translated">可以编写类点的版本，而无需在实例变量上进行赋值。覆盖构造{&amp;lt;...&amp;gt;}返回&amp;ldquo; self&amp;rdquo;（即当前对象）的副本，可能会更改某些实例变量的值。</target>
        </trans-unit>
        <trans-unit id="c2b8c74a40907020aea23679f7d3a1e47e89c876" translate="yes" xml:space="preserve">
          <source>It is recommended that applications or Web frameworks that need to protect themselves against the denial-of-service attack described in &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; call &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; at initialization time.</source>
          <target state="translated">建议在初始化时需要保护自己免受&lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; 中&lt;/a&gt;描述的拒绝服务攻击的应用程序或Web框架调用 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a0223e5551045af3ae0aff910678f36144e4dbc" translate="yes" xml:space="preserve">
          <source>It is recommended that applications or Web frameworks that need to protect themselves against the denial-of-service attack described in &lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt;&lt;/a&gt; call &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; at initialization time.</source>
          <target state="translated">建议需要保护自身免受&lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt; 中&lt;/a&gt;描述的拒绝服务攻击的应用程序或Web框架在初始化时调用 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de79eca76d0232a8de08f10b0fc7e60c155d206d" translate="yes" xml:space="preserve">
          <source>It is recommended to inherit from the current generator of the same kind as the one you want to define. Doing so, it is possible to load various custom generators to combine improvements brought by each one.</source>
          <target state="translated">建议从当前的生成器中继承与你要定义的生成器相同的种类。这样做,可以加载各种自定义生成器,以结合每个生成器带来的改进。</target>
        </trans-unit>
        <trans-unit id="dfaad68f50ca8cd128072213cb8026032d1a1ddb" translate="yes" xml:space="preserve">
          <source>It is sometimes inconvenient to build a custom runtime system each time OCaml code is linked with C libraries, like ocamlc -custom does. For one thing, the building of the runtime system is slow on some systems (that have bad linkers or slow remote file systems); for another thing, the platform-independence of bytecode files is lost, forcing to perform one ocamlc -custom link per platform of interest.</source>
          <target state="translated">每次将OCaml代码与C库链接时,像ocamlc -custom那样建立一个自定义的运行时系统有时很不方便。一来,在某些系统上,运行时系统的构建速度很慢(这些系统的链接器不好,或者远程文件系统速度很慢);二来,字节码文件的平台独立性丧失了,被迫在每个感兴趣的平台上执行一次ocamlc -custom链接。</target>
        </trans-unit>
        <trans-unit id="1ccaf02d4a67360ff683564b219f17b5312faf2d" translate="yes" xml:space="preserve">
          <source>It may also be useful to relay an optional argument from a function call to another. This can be done by prefixing the applied argument with ?. This question mark disables the wrapping of optional argument in an option type.</source>
          <target state="translated">将一个函数调用中的可选参数转发到另一个函数中可能也很有用。这可以通过在应用的参数前加上 ? 这个问号禁止在选项类型中包裹可选参数。</target>
        </trans-unit>
        <trans-unit id="db2ae4f4dfef6ee049420fc585397e822cd1841d" translate="yes" xml:space="preserve">
          <source>It may become the case during compilation that one or more invariant arguments to a function become specialised to a particular value. When such values are themselves boxed the corresponding specialised arguments may be split into more specialised arguments corresponding to the projections out of the boxed value that occur within the function body. This transformation is called &lt;em&gt;unboxing of specialised arguments&lt;/em&gt;. It is only applied when there is reasonable certainty that the boxed argument itself is unused within the function.</source>
          <target state="translated">在编译过程中，函数的一个或多个不变参数可能会变为专用于特定值的情况。当将这样的值本身装箱时，可以将对应的专用自变量拆分为更多的专用自变量，这些自变量对应于在函数体内出现的装箱值之外的投影。这种转换称为&lt;em&gt;特殊参数的拆箱&lt;/em&gt;。仅在有合理确定性的情况下，才应用盒装参数本身在函数中未使用的情况。</target>
        </trans-unit>
        <trans-unit id="2113b64361ed06b2fb660d291ef792f576530d08" translate="yes" xml:space="preserve">
          <source>It particular, it provides the basic operations over the built-in types (numbers, booleans, byte sequences, strings, exceptions, references, lists, arrays, input-output channels, ...) and the &lt;a href=&quot;stdlib#modules&quot;&gt;standard library modules&lt;/a&gt;.</source>
          <target state="translated">特别是，它提供了对内置类型（数字，布尔值，字节序列，字符串，异常，引用，列表，数组，输入输出通道等）和&lt;a href=&quot;stdlib#modules&quot;&gt;标准库模块的基本操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72e1bb8314f0b54fe82043439ead06c77dd005bd" translate="yes" xml:space="preserve">
          <source>It permits higher-order inlining, for example when a non-inlinable function always returns the same function yet with different environments of definition. Not all such cases are supported yet, but it is intended that such support will be improved in future.</source>
          <target state="translated">它允许高阶内联,例如,当一个不可内联的函数总是返回相同的函数,但定义的环境不同时。目前还不支持所有的这种情况,但打算将来改进这种支持。</target>
        </trans-unit>
        <trans-unit id="d62dc081b8f1528625d07f7e633e0a268ec1a67b" translate="yes" xml:space="preserve">
          <source>It raises &lt;code&gt;End_of_file&lt;/code&gt; if the function has already reached the end of file when starting to read from the channel, and raises &lt;code&gt;Failure&amp;nbsp;&quot;input_value:&amp;nbsp;truncated&amp;nbsp;object&quot;&lt;/code&gt; if it reaches the end of file later during the unmarshalling.</source>
          <target state="translated">如果从通道开始读取时函数已经到达文件末尾，则引发 &lt;code&gt;End_of_file&lt;/code&gt; ;如果在解组期间稍后到达文件末尾，则引发 &lt;code&gt;Failure&amp;nbsp;&quot;input_value:&amp;nbsp;truncated&amp;nbsp;object&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7eeb9110a841ac9d46371abdaeea4230b064629" translate="yes" xml:space="preserve">
          <source>It should be noted that the &lt;em&gt;unboxing of closures&lt;/em&gt; pass (see below) can introduce specialised arguments on non-recursive functions. (No other place in the compiler currently does this.)</source>
          <target state="translated">应当注意，&lt;em&gt;闭包&lt;/em&gt;传递的&lt;em&gt;取消装箱&lt;/em&gt;（请参阅下文）可能会在非递归函数上引入专门的参数。（目前，编译器中没有其他地方可以执行此操作。）</target>
        </trans-unit>
        <trans-unit id="5f1b6ac17c7b6c87ec71a416499d7641064d1ab8" translate="yes" xml:space="preserve">
          <source>It should be noted that the blocks corresponding to initialise-symbol bindings are kept alive forever, by virtue of them occurring in a static table of GC roots within the object file. This extended lifetime of expressions may on occasion be surprising. If it is desired to create some non-constant value (for example when writing GC tests) that does not have this extended lifetime, then it may be created and used inside a function, with the application point of that function (perhaps at toplevel)&amp;mdash;or indeed the function declaration itself&amp;mdash;marked as to never be inlined. This technique prevents lifting of the definition of the value in question (assuming of course that it is not constant).</source>
          <target state="translated">应该注意的是，与初始化符号绑定相对应的块会永久保留，因为它们出现在目标文件内的GC根静态表中。这种延长的表达式寿命有时可能令人惊讶。如果希望创建一些不具有延长寿命的非恒定值（例如，在编写GC测试时），则可以在函数内部创建和使用它，以及该函数的应用点（也许在顶层） （或者实际上是函数声明本身）标记为永不内联。此技术可防止取消所讨论的值的定义（当然，假定它不是恒定的）。</target>
        </trans-unit>
        <trans-unit id="d67c39d8ce8aefbd00cfb85541a53fdf588caae0" translate="yes" xml:space="preserve">
          <source>It will be accepted if each one of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; is statically constructive with respect to name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, is not immediately linked to any of name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, and is not an array constructor whose arguments have abstract type.</source>
          <target state="translated">它将被接受，如果每个人&lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ... &lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;&amp;ntilde;&lt;/sub&gt;是静态建设性相对于命名&lt;sub&gt;1个&lt;/sub&gt;...名称&lt;sub&gt;ň&lt;/sub&gt;，不会立即链接到任何的名称&lt;sub&gt;1个&lt;/sub&gt;...名称&lt;sub&gt;&amp;ntilde;&lt;/sub&gt;，而不是一个数组构造方法的参数有抽象类型。</target>
        </trans-unit>
        <trans-unit id="c1efde60809be61ee856277b8eeaecd2343156c0" translate="yes" xml:space="preserve">
          <source>It would be incorrect to perform Field(r, 1) = tail directly, because the allocation of tail has taken place since r was allocated.</source>
          <target state="translated">直接执行Field(r,1)=尾巴是不正确的,因为尾巴的分配在r被分配后就已经发生了。</target>
        </trans-unit>
        <trans-unit id="6e56ebc8d92919227f4b41f4b34fc2bd72f5bbb0" translate="yes" xml:space="preserve">
          <source>It would be natural to factorize these two definitions as:</source>
          <target state="translated">将这两个定义自然而然地因式化为:</target>
        </trans-unit>
        <trans-unit id="033f25fa120ee864f9ba41bac8624f68584547d1" translate="yes" xml:space="preserve">
          <source>It would be unsound to apply this fake_id function to values with different types. The function fake_id is therefore rightfully assigned the type '_weak3 -&amp;gt; '_weak3 rather than 'a -&amp;gt; 'a. At the same time, it ought to be possible to use a local mutable state without impacting the type of a function.</source>
          <target state="translated">将此fake_id函数应用于具有不同类型的值是不明智的。因此，为fake_id函数正确地分配了类型'_weak3-&amp;gt;'_weak3而不是'a-&amp;gt;'a。同时，应该可以使用局部可变状态而不影响功能的类型。</target>
        </trans-unit>
        <trans-unit id="2da9a22f0bb03dc04334b781283f4d9b2b79cd9d" translate="yes" xml:space="preserve">
          <source>Items produced by symbolic pretty-printers</source>
          <target state="translated">象征性的漂亮印刷厂生产的物品</target>
        </trans-unit>
        <trans-unit id="3c475641298983202fb5bb4c85bf773502af819b" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order</source>
          <target state="translated">按递增顺序对数组进行迭代。</target>
        </trans-unit>
        <trans-unit id="c4e251fe0eee2437464dec9a234fc1b325f32052" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements</source>
          <target state="translated">按递增顺序对数组进行迭代,产生沿元素的索引。</target>
        </trans-unit>
        <trans-unit id="b6d6cc59b755b47fc8e1cdb410adb3abe777160d" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements.</source>
          <target state="translated">对数组进行迭代,按递增顺序,产生沿元素的索引。</target>
        </trans-unit>
        <trans-unit id="74fa1984f98f87ade05a77d2d30ccf29617c61c6" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements. Modifications of the array during iteration will be reflected in the iterator.</source>
          <target state="translated">按递增顺序对数组进行迭代,产生沿元素的索引。迭代过程中对数组的修改将反映在迭代器中。</target>
        </trans-unit>
        <trans-unit id="cc753a1a200932eacd72d4b7ac2810d8ee977b0f" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order.</source>
          <target state="translated">按递增顺序对数组进行迭代。</target>
        </trans-unit>
        <trans-unit id="72365e84c44abbdabda346bfd2a72b67f6a2f040" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order. Modifications of the array during iteration will be reflected in the iterator.</source>
          <target state="translated">按递增顺序对数组进行迭代。迭代过程中对数组的修改将反映在迭代器中。</target>
        </trans-unit>
        <trans-unit id="57d6da7fff2897e2fdb9323a2fa6acc42d8e4f3c" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order, yielding indices along chars.</source>
          <target state="translated">对缓冲区进行迭代,依次递增,产生沿chars的指数。</target>
        </trans-unit>
        <trans-unit id="a59b1457067d268a42e29eef63f4228e79bc1f79" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order, yielding indices along chars. Modification of the buffer during iteration is undefined behavior.</source>
          <target state="translated">按递增顺序对缓冲区进行迭代,产生沿chars的索引。在迭代过程中对缓冲区的修改是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="53111c31562ee5692d94ba95750e9d8128aa9335" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order.</source>
          <target state="translated">按递增顺序对缓冲区进行迭代。</target>
        </trans-unit>
        <trans-unit id="52718e109f8ea9e93b899d8a8c03df0ab8a5e288" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order. Modification of the buffer during iteration is undefined behavior.</source>
          <target state="translated">按递增顺序对缓冲区进行迭代。在迭代过程中对缓冲区的修改是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="3f7e2d0218e27b69ec7b7e2712b13e76087fea47" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order, yielding indices along elements.</source>
          <target state="translated">按递增顺序对浮动数组进行迭代,产生沿元素的索引。</target>
        </trans-unit>
        <trans-unit id="4c13a9362e94273776029d2c08f652f705e4760a" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order, yielding indices along elements. Modifications of the floatarray during iteration will be reflected in the iterator.</source>
          <target state="translated">按递增顺序对浮动数组进行迭代,产生沿元素的索引。在迭代过程中对浮动数组的修改将反映在迭代器中。</target>
        </trans-unit>
        <trans-unit id="8b731e40512294d27a66934701878da5e53e3950" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order.</source>
          <target state="translated">按递增顺序对浮动数组进行迭代。</target>
        </trans-unit>
        <trans-unit id="e6a301a25721beaf25e58fa63b6a4fc32321de99" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order. Modifications of the floatarray during iteration will be reflected in the iterator.</source>
          <target state="translated">按递增顺序对浮动数组进行迭代。在迭代过程中对浮动数组的修改将反映在迭代器中。</target>
        </trans-unit>
        <trans-unit id="08358549ccfddcf0b104c824624f18dbe99ff7fa" translate="yes" xml:space="preserve">
          <source>Iterate on the list</source>
          <target state="translated">在列表中迭代</target>
        </trans-unit>
        <trans-unit id="7b0a0ebdb168df270cb3d5064d01e17c0b56bb4a" translate="yes" xml:space="preserve">
          <source>Iterate on the list.</source>
          <target state="translated">在列表上迭代。</target>
        </trans-unit>
        <trans-unit id="8b0797886b2f424b48d1cd58859fb9af00b7784b" translate="yes" xml:space="preserve">
          <source>Iterate on the queue, in front-to-back order.</source>
          <target state="translated">在队列上按从前到后的顺序进行迭代。</target>
        </trans-unit>
        <trans-unit id="c25db6012c3533afa619b7a8a7742b0a42cb7afd" translate="yes" xml:space="preserve">
          <source>Iterate on the queue, in front-to-back order. The behavior is not defined if the queue is modified during the iteration.</source>
          <target state="translated">按照从前到后的顺序对队列进行迭代。如果队列在迭代过程中被修改,则不定义行为。</target>
        </trans-unit>
        <trans-unit id="6f0bd8ad0f81cad6d96bacf14d0331f3a6e12dbd" translate="yes" xml:space="preserve">
          <source>Iterate on the sequence, calling the (imperative) function on every element.</source>
          <target state="translated">对序列进行迭代,对每个元素调用(命令式)函数。</target>
        </trans-unit>
        <trans-unit id="7ff7477ff445e072b84d4239e6c7d7c3aa347e47" translate="yes" xml:space="preserve">
          <source>Iterate on the sequence, calling the (imperative) function on every element. The traversal happens immediately and will not terminate on infinite sequences.</source>
          <target state="translated">在序列上迭代,在每个元素上调用(命令式)函数。遍历立即发生,并且不会在无限序列上终止。</target>
        </trans-unit>
        <trans-unit id="f8c886336160d913779eb591bdee0d4b0e15e45e" translate="yes" xml:space="preserve">
          <source>Iterate on the stack, top to bottom.</source>
          <target state="translated">迭代堆栈,从上到下。</target>
        </trans-unit>
        <trans-unit id="e94cac5480ab8007065d1c6001b6f46bf9c31673" translate="yes" xml:space="preserve">
          <source>Iterate on the stack, top to bottom. It is safe to modify the stack during iteration.</source>
          <target state="translated">在堆栈上从上到下进行迭代。在迭代过程中修改堆栈是安全的。</target>
        </trans-unit>
        <trans-unit id="6f621778fd05a26d4f34ddb7acf9a152913cceff" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing index order.</source>
          <target state="translated">按递增的索引顺序对字符串进行迭代。</target>
        </trans-unit>
        <trans-unit id="edcd995c03b85f6200cad5b28912c76d3ebd838a" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the iterator.</source>
          <target state="translated">以递增的索引顺序对字符串进行迭代。迭代过程中对字符串的修改会反映在迭代器中。</target>
        </trans-unit>
        <trans-unit id="83efc6c1259a0086cd4741e82ac58d922ad5c76a" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing order, yielding indices along chars</source>
          <target state="translated">按递增顺序对字符串进行迭代,产生沿字符的索引。</target>
        </trans-unit>
        <trans-unit id="d2b702d271270fdfb0f8e97fdc65aa27aa84c7e5" translate="yes" xml:space="preserve">
          <source>Iterate on the whole map, in ascending order of keys</source>
          <target state="translated">按键的升序在整个地图上迭代。</target>
        </trans-unit>
        <trans-unit id="3a1597c7ed9610370a35252cf68c470142228c66" translate="yes" xml:space="preserve">
          <source>Iterate on the whole map, in descending order of keys</source>
          <target state="translated">按键的降序在整个地图上迭代。</target>
        </trans-unit>
        <trans-unit id="c0fbfcbff3c4717a90de3169e97500f554fe0e8f" translate="yes" xml:space="preserve">
          <source>Iterate on the whole set, in ascending order</source>
          <target state="translated">按升序对整个集合进行迭代。</target>
        </trans-unit>
        <trans-unit id="73226e9d1bfa69238bca027c8fc049d38fc1ddb2" translate="yes" xml:space="preserve">
          <source>Iterate on the whole set, in descending order</source>
          <target state="translated">按降序对整个集合进行迭代。</target>
        </trans-unit>
        <trans-unit id="e7d061daf3db9ad7ba0961da1a7a84cd239402bf" translate="yes" xml:space="preserve">
          <source>Iterate on the whole table.</source>
          <target state="translated">在整张桌子上迭代。</target>
        </trans-unit>
        <trans-unit id="e9d8c94aa5374233499af2d9864d692b5eaf8400" translate="yes" xml:space="preserve">
          <source>Iterate on the whole table. The order in which the bindings appear in the sequence is unspecified. However, if the table contains several bindings for the same key, they appear in reversed order of introduction, that is, the most recent binding appears first.</source>
          <target state="translated">对整个表进行迭代。绑定在序列中出现的顺序是没有规定的。但是,如果表中包含了同一键的多个绑定,那么它们以相反的顺序出现,也就是说,最近的绑定先出现。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="92a60e08e4214743467aeef16832efbb28d68b7b" translate="yes" xml:space="preserve">
          <source>Iterators on two arrays</source>
          <target state="translated">两个数组的迭代器</target>
        </trans-unit>
        <trans-unit id="cf924725c2b8039b9d275152dc025994654f8e3d" translate="yes" xml:space="preserve">
          <source>Iterators on two lists</source>
          <target state="translated">两个清单上的迭代器</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="91ad1acf9ee2be52d2d52e1b2736deba62d38e52" translate="yes" xml:space="preserve">
          <source>January &amp;zwj;27, 2021</source>
          <target state="translated">2021年1月27日</target>
        </trans-unit>
        <trans-unit id="ffb8b7268bc0ef366e246e15fb194af699da0d9a" translate="yes" xml:space="preserve">
          <source>Jump to the given time.</source>
          <target state="translated">跳到指定时间。</target>
        </trans-unit>
        <trans-unit id="1e7561e05c5b18318690fb04c12d71c9e371b509" translate="yes" xml:space="preserve">
          <source>Just as in the toplevel system (section &amp;zwj;&lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;), the user can register functions for printing values of certain types. For technical reasons, the debugger cannot call printing functions that reside in the program being debugged. The code for the printing functions must therefore be loaded explicitly in the debugger.</source>
          <target state="translated">正如在顶层系统（部分&lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;），用户可以打印某些类型的值寄存器的功能。由于技术原因，调试器无法调用被调试程序中的打印功能。因此，必须在调试器中显式加载用于打印功能的代码。</target>
        </trans-unit>
        <trans-unit id="624a232e29c6285e85daf176c56dfb635d3dd7fd" translate="yes" xml:space="preserve">
          <source>Just as in the toplevel system (section &lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;), the user can register functions for printing values of certain types. For technical reasons, the debugger cannot call printing functions that reside in the program being debugged. The code for the printing functions must therefore be loaded explicitly in the debugger.</source>
          <target state="translated">就像在顶级系统中一样（第&lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;节），用户可以注册用于打印某些类型的值的功能。由于技术原因，调试器无法调用被调试程序中的打印功能。因此，必须在调试器中显式加载用于打印功能的代码。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="a940001b3198e7ae1e643d753be086d8c3542efb" translate="yes" xml:space="preserve">
          <source>Keep connection active</source>
          <target state="translated">保持连接有效</target>
        </trans-unit>
        <trans-unit id="136012b6c6d58edff8f132cf6ce26d59cc8f9982" translate="yes" xml:space="preserve">
          <source>Keep elements placed after/between the (**/**) special comment(s) (see section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;15.2&lt;/a&gt;).</source>
          <target state="translated">将元素放置在（** / **）特殊注释之后/之间（请参阅第&lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;15.2&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="274136e14622e37b8b6331a086d3f3366e3831f5" translate="yes" xml:space="preserve">
          <source>Keep elements placed after/between the (**/**) special comment(s) (see section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;).</source>
          <target state="translated">将元素放置在（** / **）特殊注释之后/之间（请参阅第&lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="4d62255be0ec9f781a5f40b46da0c3024c36bab8" translate="yes" xml:space="preserve">
          <source>Keep the assembly code produced during the compilation. The assembly code for the source file x.ml is saved in the file x.s.</source>
          <target state="translated">保留编译过程中产生的汇编代码。源文件x.ml的汇编代码保存在文件x.s中。</target>
        </trans-unit>
        <trans-unit id="14983f1a3e8d2301fc0a539f434e69ec9ea45c93" translate="yes" xml:space="preserve">
          <source>Kill line character (usually ctrl-U).</source>
          <target state="translated">杀线字符(通常是ctrl-U)。</target>
        </trans-unit>
        <trans-unit id="c60b8fa8d42c209a51f605ad6c17c5d3484a13de" translate="yes" xml:space="preserve">
          <source>Kill the program being executed. This command is mainly useful if you wish to recompile the program without leaving the debugger.</source>
          <target state="translated">杀掉正在执行的程序。如果你想在不离开调试器的情况下重新编译程序,这个命令主要是有用的。</target>
        </trans-unit>
        <trans-unit id="c67374519f2f22eab63c039c77b42da37349cc81" translate="yes" xml:space="preserve">
          <source>Kind of the file</source>
          <target state="translated">文件的种类</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="74341e3c271df3c784e595b804b1f90be0f80429" translate="yes" xml:space="preserve">
          <source>Label</source>
          <target state="translated">Label</target>
        </trans-unit>
        <trans-unit id="ce4744e6d2befcbbcee49b587ff32fe4d8b6dfef" translate="yes" xml:space="preserve">
          <source>Label names, tag names, method names and instance variable names need not be qualified: the former three are global labels, while the latter are local to a class.</source>
          <target state="translated">标签名、标签名、方法名和实例变量名无需限定:前三者是全局标签,而后者是类的局部标签。</target>
        </trans-unit>
        <trans-unit id="f7566409fe33db7c1382047b4b33d525174722c1" translate="yes" xml:space="preserve">
          <source>Label omitted in function application.</source>
          <target state="translated">在函数应用中省略标签。</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="09193ca3e31ac574fb94c2e9ba86583737f30c6d" translate="yes" xml:space="preserve">
          <source>Labels are not ignored in types, labels may be used in applications, and labelled parameters can be given in any order. This is the default.</source>
          <target state="translated">在类型中标签不会被忽略,标签可以在应用程序中使用,标签参数可以按任何顺序给出。这是默认的。</target>
        </trans-unit>
        <trans-unit id="2d07567828d6157c7a0bbfacdccc17fbf690bde4" translate="yes" xml:space="preserve">
          <source>Labels obey the same rules as other identifiers in OCaml, that is you cannot use a reserved keyword (like in or to) as label.</source>
          <target state="translated">标签与OCaml中的其他标识符遵守相同的规则,即您不能使用保留关键字(如in或to)作为标签。</target>
        </trans-unit>
        <trans-unit id="ac290ed377f5383ec5a1609fac7d51da07b74769" translate="yes" xml:space="preserve">
          <source>Large, multi-dimensional, numerical arrays.</source>
          <target state="translated">大型、多维、数值阵列。</target>
        </trans-unit>
        <trans-unit id="d27ea870e756a4996b6e5548e72dad903dff893f" translate="yes" xml:space="preserve">
          <source>Last access time</source>
          <target state="translated">最后访问时间</target>
        </trans-unit>
        <trans-unit id="97ae7c6bdca85d087ad5892abd46d332ae4415d4" translate="yes" xml:space="preserve">
          <source>Last modification time</source>
          <target state="translated">最后修改时间</target>
        </trans-unit>
        <trans-unit id="5bd551a9da615e1f482b38b0b5800894d52c749c" translate="yes" xml:space="preserve">
          <source>Last status change time</source>
          <target state="translated">最后一次状态变化时间</target>
        </trans-unit>
        <trans-unit id="96a1892b560a2dae03d58c477f42a35e2fc92bf8" translate="yes" xml:space="preserve">
          <source>Last-in first-out stacks.</source>
          <target state="translated">最后进先出的堆栈。</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="7f09861439451aa36330c7bf95178c6ddcb46e50" translate="yes" xml:space="preserve">
          <source>Lazy patterns provide another way to force a lazy expression.</source>
          <target state="translated">懒人模式提供了另一种强行表达的方式。</target>
        </trans-unit>
        <trans-unit id="634afef2094c369bdd48d1f752631ea2a14a676c" translate="yes" xml:space="preserve">
          <source>Leave out-of-band data in line</source>
          <target state="translated">将带外数据留在行内</target>
        </trans-unit>
        <trans-unit id="85f5ed01117b556dfcfb05f94fe84491fe8dcbb5" translate="yes" xml:space="preserve">
          <source>Less commonly-used options:</source>
          <target state="translated">较少使用的选项。</target>
        </trans-unit>
        <trans-unit id="bf1097315573ec76e509abe7102d689a6563ecc3" translate="yes" xml:space="preserve">
          <source>Let custom.ml be the file defining a new generator class. Compilation of custom.ml can be performed by the following command &amp;zwj;:</source>
          <target state="translated">令custom.ml为定义新生成器类的文件。可以通过以下命令&amp;zwj;来执行custom.ml的编译：</target>
        </trans-unit>
        <trans-unit id="f8e205d5e74a87e2d51ce5ba5fc4154c84a89a9f" translate="yes" xml:space="preserve">
          <source>Let custom.ml be the file defining a new generator class. Compilation of custom.ml can be performed by the following command :</source>
          <target state="translated">让custom.ml成为定义一个新的生成器类的文件。编译custom.ml可以通过以下命令进行。</target>
        </trans-unit>
        <trans-unit id="a90f57fc3563e16d5d28640fa27a45b5626288d1" translate="yes" xml:space="preserve">
          <source>Let us consider a more complex example: define a circle, whose center may be any kind of point. We put an additional type constraint in method move, since no free variables must remain unaccounted for by the class type parameters.</source>
          <target state="translated">让我们考虑一个更复杂的例子:定义一个圆,其中心可以是任何一种点。我们在方法move中加入了一个额外的类型约束,因为类类型参数不能有任何自由变量未被计算。</target>
        </trans-unit>
        <trans-unit id="97ad92c4c358eba8bbc5b8a0969daf464a03c61f" translate="yes" xml:space="preserve">
          <source>Let-bindings within class definitions are evaluated before the object is constructed. It is also possible to evaluate an expression immediately after the object has been built. Such code is written as an anonymous hidden method called an initializer. Therefore, it can access self and the instance variables.</source>
          <target state="translated">类定义中的Let-bindings在对象构建之前就被评估了。也可以在对象被构建后立即评估一个表达式。这种代码被写成一个匿名的隐藏方法,称为初始化器。因此,它可以访问self和实例变量。</target>
        </trans-unit>
        <trans-unit id="c78e74717b8e8ca45266657c33dd0aa134152b63" translate="yes" xml:space="preserve">
          <source>Lexer buffers</source>
          <target state="translated">Lexer缓冲器</target>
        </trans-unit>
        <trans-unit id="4b9b887a7274d537cc019ca8a98c797f62c81ee3" translate="yes" xml:space="preserve">
          <source>Lexer buffers are an abstract data type implemented in the standard library module Lexing. The functions Lexing.from_channel, Lexing.from_string and Lexing.from_function create lexer buffers that read from an input channel, a character string, or any reading function, respectively. (See the description of module Lexing in chapter &amp;zwj;&lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;23&lt;/a&gt;.)</source>
          <target state="translated">Lexer缓冲区是在标准库模块Lexing中实现的抽象数据类型。Lexing.from_channel，Lexing.from_string和Lexing.from_function函数创建分别从输入通道，字符串或任何读取函数读取的词法分析器缓冲区。（见模块乐星的章节中的描述&lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;23&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="eba638f354cbd4eea4869aa7af64033d01e9baca" translate="yes" xml:space="preserve">
          <source>Lexer buffers are an abstract data type implemented in the standard library module Lexing. The functions Lexing.from_channel, Lexing.from_string and Lexing.from_function create lexer buffers that read from an input channel, a character string, or any reading function, respectively. (See the description of module Lexing in chapter &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;.)</source>
          <target state="translated">Lexer缓冲区是在标准库模块Lexing中实现的抽象数据类型。 Lexing.from_channel，Lexing.from_string和Lexing.from_function函数创建分别从输入通道，字符串或任何读取函数读取的词法分析器缓冲区。 （请参阅第&lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;章中对模块Lexing的描述。）</target>
        </trans-unit>
        <trans-unit id="92672530b6de1c7c2b6aa008abe880f35c25185c" translate="yes" xml:space="preserve">
          <source>Lexers can optionally maintain the &lt;code&gt;lex_curr_p&lt;/code&gt; and &lt;code&gt;lex_start_p&lt;/code&gt; position fields. This &quot;position tracking&quot; mode is the default, and it corresponds to passing &lt;code&gt;~with_position:true&lt;/code&gt; to functions that create lexer buffers. In this mode, the lexing engine and lexer actions are co-responsible for properly updating the position fields, as described in the next paragraph. When the mode is explicitly disabled (with &lt;code&gt;~with_position:false&lt;/code&gt;), the lexing engine will not touch the position fields and the lexer actions should be careful not to do it either; the &lt;code&gt;lex_curr_p&lt;/code&gt; and &lt;code&gt;lex_start_p&lt;/code&gt; field will then always hold the &lt;code&gt;dummy_pos&lt;/code&gt; invalid position. Not tracking positions avoids allocations and memory writes and can significantly improve the performance of the lexer in contexts where &lt;code&gt;lex_start_p&lt;/code&gt; and &lt;code&gt;lex_curr_p&lt;/code&gt; are not needed.</source>
          <target state="translated">词法分析器可以选择维护 &lt;code&gt;lex_curr_p&lt;/code&gt; 和 &lt;code&gt;lex_start_p&lt;/code&gt; 位置字段。此&amp;ldquo;位置跟踪&amp;rdquo;模式是默认模式，它对应于将 &lt;code&gt;~with_position:true&lt;/code&gt; 传递给创建词法分析器缓冲区的函数。在此模式下，词法引擎和词法分析器动作共同负责正确更新位置字段，如下一节所述。当显式禁用该模式（使用 &lt;code&gt;~with_position:false&lt;/code&gt; ）时，词法引擎将不会触摸位置字段，并且词法器操作也应注意不要这样做；然后 &lt;code&gt;lex_curr_p&lt;/code&gt; 和 &lt;code&gt;lex_start_p&lt;/code&gt; 字段将始终保存 &lt;code&gt;dummy_pos&lt;/code&gt; 无效的位置。不跟踪位置可以避免分配和内存写入，并且可以在不需要 &lt;code&gt;lex_start_p&lt;/code&gt; 和 &lt;code&gt;lex_curr_p&lt;/code&gt; 的情况下显着提高lexer的性能。</target>
        </trans-unit>
        <trans-unit id="a3917223ea7504c595a7ef33cb226700969d3360" translate="yes" xml:space="preserve">
          <source>Lexical ambiguities are resolved according to the &amp;ldquo;longest match&amp;rdquo; rule: when a character sequence can be decomposed into two tokens in several different ways, the decomposition retained is the one with the longest first token.</source>
          <target state="translated">词汇歧义根据&amp;ldquo;最长匹配&amp;rdquo;规则解决：当可以用几种不同方式将一个字符序列分解为两个标记时，保留的分解是第一个标记最长的分解。</target>
        </trans-unit>
        <trans-unit id="c0a202cc33085b7bb25725a4f379636b34841789" translate="yes" xml:space="preserve">
          <source>Lexing</source>
          <target state="translated">Lexing</target>
        </trans-unit>
        <trans-unit id="a70e713317076c077fd1641566d360708f118d2a" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme lexbuf</source>
          <target state="translated">Lexing.lexeme lexbuf</target>
        </trans-unit>
        <trans-unit id="16bbfe7d8b55633595dd6244e6f0439507cf30e5" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_char lexbuf n</source>
          <target state="translated">Lexing.lexeme_char lexbuf n</target>
        </trans-unit>
        <trans-unit id="c74ea0f938e819ae2026560af60f9bf7b4293e6d" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_end lexbuf</source>
          <target state="translated">Lexing.lexeme_end lexbuf</target>
        </trans-unit>
        <trans-unit id="dbd5d51aa0344b0018430731ae4cef689fd5ac6c" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_start lexbuf</source>
          <target state="translated">Lexing.lexeme_start lexbuf</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="29af859893fdcdadf9189b04f68a9abe34f1c20e" translate="yes" xml:space="preserve">
          <source>Lifting of constants to toplevel reduces allocation at runtime.</source>
          <target state="translated">将常量提升到toplevel,减少了运行时的分配。</target>
        </trans-unit>
        <trans-unit id="ccb0377305aff6b2536761bb8210a8352e72ce63" translate="yes" xml:space="preserve">
          <source>Lightweight threads for Posix &lt;code&gt;1003.1c&lt;/code&gt; and Win32.</source>
          <target state="translated">Posix &lt;code&gt;1003.1c&lt;/code&gt; 和Win32的轻量级线程。</target>
        </trans-unit>
        <trans-unit id="850af4b7ba532914fbbab5d04f50f07c734c1799" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALget&quot;&gt;&lt;code&gt;Bigarray.Array1.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">类似于&lt;a href=&quot;bigarray.array1#VALget&quot;&gt; &lt;code&gt;Bigarray.Array1.get&lt;/code&gt; &lt;/a&gt;，但并不总是执行边界检查。</target>
        </trans-unit>
        <trans-unit id="10e8e123fe0b1dc99bead7adea2aec6a3d1ac2c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALget&quot;&gt;&lt;code&gt;Bigarray.Array1.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</source>
          <target state="translated">类似于&lt;a href=&quot;bigarray.array1#VALget&quot;&gt; &lt;code&gt;Bigarray.Array1.get&lt;/code&gt; &lt;/a&gt;，但并不总是执行边界检查。仅当程序逻辑保证访问在范围之内时，请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="17cf409f10899743c833d44d422e8ce9982b9a92" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALset&quot;&gt;&lt;code&gt;Bigarray.Array1.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">类似于&lt;a href=&quot;bigarray.array1#VALset&quot;&gt; &lt;code&gt;Bigarray.Array1.set&lt;/code&gt; &lt;/a&gt;，但并不总是执行边界检查。</target>
        </trans-unit>
        <trans-unit id="0d6c54b020c7c7d74936820b2eb4bd3d379258c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALset&quot;&gt;&lt;code&gt;Bigarray.Array1.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</source>
          <target state="translated">类似于&lt;a href=&quot;bigarray.array1#VALset&quot;&gt; &lt;code&gt;Bigarray.Array1.set&lt;/code&gt; &lt;/a&gt;，但并不总是执行边界检查。仅当程序逻辑保证访问在范围之内时，请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="bfadb351771bde10f24fe7abed8ab6142dcbd0a1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array2#VALget&quot;&gt;&lt;code&gt;Bigarray.Array2.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">类似于&lt;a href=&quot;bigarray.array2#VALget&quot;&gt; &lt;code&gt;Bigarray.Array2.get&lt;/code&gt; &lt;/a&gt;，但并不总是执行边界检查。</target>
        </trans-unit>
        <trans-unit id="221178edad17fc6894a4c266434a7aa9bc5afe69" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array2#VALset&quot;&gt;&lt;code&gt;Bigarray.Array2.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">类似于&lt;a href=&quot;bigarray.array2#VALset&quot;&gt; &lt;code&gt;Bigarray.Array2.set&lt;/code&gt; &lt;/a&gt;，但并不总是执行边界检查。</target>
        </trans-unit>
        <trans-unit id="ffbb6f02cca19cfee80223b75c549f0acb3031ee" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array3#VALget&quot;&gt;&lt;code&gt;Bigarray.Array3.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">类似于&lt;a href=&quot;bigarray.array3#VALget&quot;&gt; &lt;code&gt;Bigarray.Array3.get&lt;/code&gt; &lt;/a&gt;，但并不总是执行边界检查。</target>
        </trans-unit>
        <trans-unit id="36ea99c63be240916526a60717058a5a7e0e8f87" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array3#VALset&quot;&gt;&lt;code&gt;Bigarray.Array3.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">类似于&lt;a href=&quot;bigarray.array3#VALset&quot;&gt; &lt;code&gt;Bigarray.Array3.set&lt;/code&gt; &lt;/a&gt;，但并不总是执行边界检查。</target>
        </trans-unit>
        <trans-unit id="7b9e4e4e60b86cce032b0d708e5c35fefc9ea9ae" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt;&lt;code&gt;Spacetime.Series.save_event&lt;/code&gt;&lt;/a&gt;, but writes to the automatic snapshot file.</source>
          <target state="translated">类似于&lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt; &lt;code&gt;Spacetime.Series.save_event&lt;/code&gt; &lt;/a&gt;，但是写入自动快照文件。</target>
        </trans-unit>
        <trans-unit id="9bbbb7a679272947e8eb9d35cbee8a2de10a3c47" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt;&lt;code&gt;Spacetime.Series.save_event&lt;/code&gt;&lt;/a&gt;, but writes to the automatic snapshot file. This function is a no-op if OCAML_SPACETIME_INTERVAL was not set.</source>
          <target state="translated">类似于&lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt; &lt;code&gt;Spacetime.Series.save_event&lt;/code&gt; &lt;/a&gt;，但是写入自动快照文件。如果未设置OCAML_SPACETIME_INTERVAL，则此功能为空操作。</target>
        </trans-unit>
        <trans-unit id="285f14140f3588801dee3a1d5fb94c57e5e969c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_end&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="translated">类似于 &lt;code&gt;lexeme_end&lt;/code&gt; ，但返回完整 &lt;code&gt;position&lt;/code&gt; 而不是偏移量。</target>
        </trans-unit>
        <trans-unit id="89e8a3b2000bfdbec151fc2e1f14f86877e2c204" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_end&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset. When position tracking is disabled, the function returns &lt;code&gt;dummy_pos&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;lexeme_end&lt;/code&gt; ，但返回完整 &lt;code&gt;position&lt;/code&gt; 而不是偏移量。禁用位置跟踪后，该函数将返回 &lt;code&gt;dummy_pos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d05df27d0e208419cdd29b6ff60273cb7cdd7768" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_start&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="translated">类似于 &lt;code&gt;lexeme_start&lt;/code&gt; ，但返回完整 &lt;code&gt;position&lt;/code&gt; 而不是偏移量。</target>
        </trans-unit>
        <trans-unit id="b4e5ff07d8ec0b1c6d8bcaabede4dea51cec8d1b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_start&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset. When position tracking is disabled, the function returns &lt;code&gt;dummy_pos&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;lexeme_start&lt;/code&gt; ，但返回完整 &lt;code&gt;position&lt;/code&gt; 而不是偏移量。禁用位置跟踪后，该函数将返回 &lt;code&gt;dummy_pos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b1c55d58c17c31347619f0f98121afaee022313" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;raw_backtrace_entry&lt;/code&gt;, values of this type are process-specific and must absolutely not be marshalled, and are unsafe to use for this reason (marshalling them may not fail, but un-marshalling and using the result will result in undefined behavior).</source>
          <target state="translated">像 &lt;code&gt;raw_backtrace_entry&lt;/code&gt; 一样，这种类型的值是特定于进程的，并且绝对不能进行编组，并且由于这个原因是不安全的（将它们编组可能不会失败，但是取消编组和使用结果将导致不确定的行为）。</target>
        </trans-unit>
        <trans-unit id="7bc734516e0de9e6a8e3e99a4330cf58d7f961f5" translate="yes" xml:space="preserve">
          <source>Like constructed terms, polymorphic variant values are represented either as integers (for polymorphic variants without argument), or as blocks (for polymorphic variants with an argument). Unlike constructed terms, variant constructors are not numbered starting from 0, but identified by a hash value (an OCaml integer), as computed by the C function hash_variant (declared in &amp;lt;caml/mlvalues.h&amp;gt;): the hash value for a variant constructor named, say, VConstr is hash_variant(&quot;VConstr&quot;).</source>
          <target state="translated">像构造的术语一样，多态变体值用整数（对于不带参数的多态变体）或块（对于带参数的多态变体）表示。与构造术语不同，变体构造函数的编号不是从0开始，而是由C函数hash_variant（在&amp;lt;caml / mlvalues.h&amp;gt;中声明）计算的哈希值（OCaml整数）标识的：名为VConstr的构造函数是hash_variant（&amp;ldquo; VConstr&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="84db1f1935fb847355e19d1183905165a54092aa" translate="yes" xml:space="preserve">
          <source>Like for modules, it is possible to include a signature to copy its components inside the current signature. For instance, we can extend the PRIOQUEUE signature with the extract_opt function:</source>
          <target state="translated">就像模块一样,我们可以在当前签名中包含一个签名来复制其组件。例如,我们可以用extract_opt函数扩展PRIOQUEUE签名。</target>
        </trans-unit>
        <trans-unit id="7bed73780596b7f834ced053725e46c0df1f9817" translate="yes" xml:space="preserve">
          <source>Like for names, choosing labels for functions is not an easy task. A good labeling is a labeling which</source>
          <target state="translated">和名字一样,为函数选择标签也不是一件容易的事。一个好的标签是一个能</target>
        </trans-unit>
        <trans-unit id="43e1d0d1bfc15d7766298ee68fb31b046e1b23e5" translate="yes" xml:space="preserve">
          <source>Like in function definitions, the definition above can be abbreviated as:</source>
          <target state="translated">和函数定义一样,上面的定义可以简写为:。</target>
        </trans-unit>
        <trans-unit id="7ffd97eca67dfa1c7ecded513f14bd0f5af7f65f" translate="yes" xml:space="preserve">
          <source>Likewise.</source>
          <target state="translated">Likewise.</target>
        </trans-unit>
        <trans-unit id="d6a89f5f5aab1dc9ec97d86beabe3da25c8f6ddd" translate="yes" xml:space="preserve">
          <source>Limit the number of value nodes printed to at most n. Remaining parts of values are printed as ... (ellipsis).</source>
          <target state="translated">将打印的值节点数限制为最多n个,值的剩余部分打印为...(省略号)。(省略号)。</target>
        </trans-unit>
        <trans-unit id="8ad9b678b8122b484b49d4fd677c60e7b110f651" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to a maximal depth of d.</source>
          <target state="translated">限制打印数值的最大深度为d。</target>
        </trans-unit>
        <trans-unit id="fe294dbc375ee535fc34452b44543c9389175384" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to a maximal depth of n. The parts of values whose depth exceeds n are printed as ... (ellipsis).</source>
          <target state="translated">限制打印数值的最大深度为n。深度超过n的数值部分打印为...(省略号)。(省略号)。</target>
        </trans-unit>
        <trans-unit id="12c82d004dcdb36148874aaf0cae92f27ef7fbfb" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to at most l nodes printed.</source>
          <target state="translated">限制值的打印,最多只能打印l个节点。</target>
        </trans-unit>
        <trans-unit id="5922b9004440d60d364efc1c8981f83c8e0a5a20" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. In the default linking mode, the linker produces bytecode that is intended to be executed with the shared runtime system, ocamlrun. In the custom runtime mode, the linker produces an output file that contains both the runtime system and the bytecode for the program. The resulting file is larger, but it can be executed directly, even if the ocamlrun command is not installed. Moreover, the &amp;ldquo;custom runtime&amp;rdquo; mode enables static linking of OCaml code with user-defined C functions, as described in chapter &amp;zwj;&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;.</source>
          <target state="translated">以&amp;ldquo;自定义运行系统&amp;rdquo;模式链接。在默认链接模式下，链接器生成旨在与共享运行时系统ocamlrun执行的字节码。在自定义运行时模式下，链接器将生成一个输出文件，其中包含运行时系统和程序的字节码。生成的文件较大，但是即使未安装ocamlrun命令，也可以直接执行。此外，&amp;ldquo;自定义运行时&amp;rdquo;模式使得能够OCaml的代码静态链接与用户定义的C函数，如在章节中描述&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e07f2e960f4ea462077ce5669747d94a6df33827" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. In the default linking mode, the linker produces bytecode that is intended to be executed with the shared runtime system, ocamlrun. In the custom runtime mode, the linker produces an output file that contains both the runtime system and the bytecode for the program. The resulting file is larger, but it can be executed directly, even if the ocamlrun command is not installed. Moreover, the &amp;ldquo;custom runtime&amp;rdquo; mode enables static linking of OCaml code with user-defined C functions, as described in chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;.</source>
          <target state="translated">以&amp;ldquo;自定义运行系统&amp;rdquo;模式链接。在默认链接模式下，链接器生成旨在与共享运行时系统ocamlrun执行的字节码。在自定义运行时模式下，链接器将生成一个输出文件，其中包含运行时系统和程序的字节码。生成的文件较大，但是即使未安装ocamlrun命令，也可以直接执行。此外，&amp;ldquo;自定义运行时&amp;rdquo;模式允许将OCaml代码与用户定义的C函数进行静态链接，如第&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;章所述。</target>
        </trans-unit>
        <trans-unit id="3e5da713196db5ef014749220895ab23bcef20fe" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">以&amp;ldquo;自定义运行系统&amp;rdquo;模式链接。见ocamlc相应的选项，在章&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90e15b2364cc575d6dbc34984468f8d6d885901b" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">以&amp;ldquo;自定义运行系统&amp;rdquo;模式链接。请参阅第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章中的ocamlc的相应选项。</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="dc3d988645b4957d3dd83740735d0cb6d66953cf" translate="yes" xml:space="preserve">
          <source>List concatenation.</source>
          <target state="translated">列表串联。</target>
        </trans-unit>
        <trans-unit id="dbd013775c64eff58dc6132a245c0ce270a850c6" translate="yes" xml:space="preserve">
          <source>List concatenation. Not tail-recursive (length of the first argument). Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">列表串联。不是尾递归的（第一个参数的长度）。右关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0365ae410f8457307452f898da684eba14b29c5f" translate="yes" xml:space="preserve">
          <source>List of directories searched to find the bytecode executable file.</source>
          <target state="translated">为寻找字节码可执行文件而搜索的目录列表。</target>
        </trans-unit>
        <trans-unit id="9eaa95db5646e28fe7153c07d0f70fa876dd1b94" translate="yes" xml:space="preserve">
          <source>List of format elements.</source>
          <target state="translated">格式要素清单。</target>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="translated">列表操作</target>
        </trans-unit>
        <trans-unit id="2136f9decb402dc033169190742a9590a2e8171a" translate="yes" xml:space="preserve">
          <source>List operations.</source>
          <target state="translated">列表操作。</target>
        </trans-unit>
        <trans-unit id="3b37d6672e7f341dcb945c17aabc1b419dec4f50" translate="yes" xml:space="preserve">
          <source>List reversal.</source>
          <target state="translated">名单反转。</target>
        </trans-unit>
        <trans-unit id="637c60434c34ad7a7432343dd717e34e34be9418" translate="yes" xml:space="preserve">
          <source>List scanning</source>
          <target state="translated">名单扫描</target>
        </trans-unit>
        <trans-unit id="76ca755f57f387a8fa5a689d0657d056de2dbb3e" translate="yes" xml:space="preserve">
          <source>List searching</source>
          <target state="translated">列表搜索</target>
        </trans-unit>
        <trans-unit id="6e130b5fdd6ede5933f5e364b277835f131b8204" translate="yes" xml:space="preserve">
          <source>List the source of module module, from line number beginning to line number end. By default, 20 lines of the current module are displayed, starting 10 lines before the current position.</source>
          <target state="translated">列出模块模块的来源,从行号开始到行号结束。默认情况下,显示当前模块的20行,从当前位置前10行开始。</target>
        </trans-unit>
        <trans-unit id="6ca5f98ec9772c0239bb1a06bbafbaa7dccb5d4c" translate="yes" xml:space="preserve">
          <source>ListLabels</source>
          <target state="translated">ListLabels</target>
        </trans-unit>
        <trans-unit id="caa56fb279e78a5e60984ad896e4f99d33cd9ba0" translate="yes" xml:space="preserve">
          <source>Lists of pairs</source>
          <target state="translated">成对名单</target>
        </trans-unit>
        <trans-unit id="7c9984cdc3b0e43d1b8e01a6016b6b16f60122a8" translate="yes" xml:space="preserve">
          <source>Literals for 32-bit integers are suffixed by l:</source>
          <target state="translated">32位整数的字后缀为l。</target>
        </trans-unit>
        <trans-unit id="0f376ff18d781ef4e7ce630da2eb8cc5e0867f63" translate="yes" xml:space="preserve">
          <source>Literals for 64-bit integers are suffixed by L:</source>
          <target state="translated">64位整数的字后缀为L。</target>
        </trans-unit>
        <trans-unit id="6259c5bb5a0b49cb897bdeab6a0b94ebf736355f" translate="yes" xml:space="preserve">
          <source>Literals for native integers are suffixed by n:</source>
          <target state="translated">本位整数的字后缀为n。</target>
        </trans-unit>
        <trans-unit id="68b1043a802b867b1154a51397b46d475fcc1b1c" translate="yes" xml:space="preserve">
          <source>Little-endian (resp. big-endian) encoding means that least (resp. most) significant bytes are stored first. Big-endian is also known as network byte order. Native-endian encoding is either little-endian or big-endian depending on &lt;a href=&quot;sys#VALbig_endian&quot;&gt;&lt;code&gt;Sys.big_endian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Little-endian（resp。big-endian）编码意味着首先存储最低（最高）字节。Big-endian也称为网络字节顺序。本机字节序编码是little-endian或big-endian，具体取决于&lt;a href=&quot;sys#VALbig_endian&quot;&gt; &lt;code&gt;Sys.big_endian&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6cf6da19f9240117d92be77adf519c48a64293ee" translate="yes" xml:space="preserve">
          <source>Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc.</source>
          <target state="translated">在内存中加载由批量编译器ocamlc产生的字节码对象文件(.cmo文件)或库文件(.cma文件)。</target>
        </trans-unit>
        <trans-unit id="10cbe4ea6dac6abfc435470246f61cb80c7ae677" translate="yes" xml:space="preserve">
          <source>Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc. When loading an object file that depends on other modules which have not been loaded yet, the .cmo files for these modules are searched and loaded as well, recursively. The loading order is not specified.</source>
          <target state="translated">在内存中加载由批量编译器ocamlc产生的字节码对象文件(.cmo文件)或库文件(.cma文件)。当加载一个依赖于其他模块的对象文件时,这些模块的.cmo文件也会被搜索并递归加载。加载顺序没有指定。</target>
        </trans-unit>
        <trans-unit id="8b5246ec3fd3ea63c509be27737c36d3be01173e" translate="yes" xml:space="preserve">
          <source>Load in the debugger the indicated .cmo or .cma object file. The file is loaded in an environment consisting only of the OCaml standard library plus the definitions provided by object files previously loaded using load_printer. If this file depends on other object files not yet loaded, the debugger automatically loads them if it is able to find them in the search path. The loaded file does not have direct access to the modules of the program being debugged.</source>
          <target state="translated">在调试器中加载指定的.cmo或.cma对象文件。该文件的加载环境仅由OCaml标准库加上之前使用load_printer加载的对象文件提供的定义组成。如果这个文件依赖于其他尚未加载的对象文件,如果调试器能够在搜索路径中找到它们,就会自动加载它们。加载的文件不能直接访问被调试程序的模块。</target>
        </trans-unit>
        <trans-unit id="9554426e849ebccce273355d09330acd0af5f810" translate="yes" xml:space="preserve">
          <source>Load information from file, which has been produced by ocamldoc -dump. Several -load options can be given.</source>
          <target state="translated">从文件中加载信息,这些信息是由ocamldoc -dump产生的。可以给出几个-load选项。</target>
        </trans-unit>
        <trans-unit id="1468bdc0578724ddc204f4a8076fd367c4f00ada" translate="yes" xml:space="preserve">
          <source>Load the given file instead of the default initialization file. The default file is .ocamlinit in the current directory if it exists, otherwise XDG_CONFIG_HOME/ocaml/init.ml or .ocamlinit in the user&amp;rsquo;s home directory.</source>
          <target state="translated">加载给定的文件，而不是默认的初始化文件。默认文件是当前目录中的.ocamlinit（如果存在），否则为XDG_CONFIG_HOME / ocaml / init.ml或用户主目录中的.ocamlinit。</target>
        </trans-unit>
        <trans-unit id="56a34ca10bffd479d41682ae72278c33fd620c73" translate="yes" xml:space="preserve">
          <source>Load the program and execute it until the given time. Useful when you already know approximately at what time the problem appears. Also useful to set breakpoints on function values that have not been computed at time 0 (see section &amp;zwj;&lt;a href=&quot;#s%3Abreakpoints&quot;&gt;16.5&lt;/a&gt;).</source>
          <target state="translated">加载程序并执行直到给定时间。当您大约已经知道问题何时出现时，此功能非常有用。也是有用的，但没有计算在时间0上的函数值设置断点（见第&lt;a href=&quot;#s%3Abreakpoints&quot;&gt;16.5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="22c136cf2e9c1518388c865d582646bebe003932" translate="yes" xml:space="preserve">
          <source>Load the program and execute it until the given time. Useful when you already know approximately at what time the problem appears. Also useful to set breakpoints on function values that have not been computed at time 0 (see section &lt;a href=&quot;#s%3Abreakpoints&quot;&gt;17.5&lt;/a&gt;).</source>
          <target state="translated">加载程序并执行直到给定时间。当您大约已经知道问题何时出现时，此功能非常有用。在时间0尚未计算的函数值上设置断点也很有用（请参见&lt;a href=&quot;#s%3Abreakpoints&quot;&gt;17.5&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="3e63214a47f4377c1d66c127f747b02a52318db2" translate="yes" xml:space="preserve">
          <source>Load the program and stop on the first event.</source>
          <target state="translated">加载程序并在第一个事件上停止。</target>
        </trans-unit>
        <trans-unit id="06d5cb576439af064f31b513f860fdcf129f485b" translate="yes" xml:space="preserve">
          <source>Loading codes</source>
          <target state="translated">加载代码</target>
        </trans-unit>
        <trans-unit id="f75d20b246e4621320b31b1c098e452853a4ac67" translate="yes" xml:space="preserve">
          <source>Local opens are supported in class expressions since OCaml 4.06.</source>
          <target state="translated">从OCaml 4.06开始,在类表达式中支持本地打开。</target>
        </trans-unit>
        <trans-unit id="570b10f925c51b325fdc93e2d97c8848252648e2" translate="yes" xml:space="preserve">
          <source>Local opens are supported in class types since OCaml 4.06.</source>
          <target state="translated">从OCaml 4.06开始,在类类型中支持本地打开。</target>
        </trans-unit>
        <trans-unit id="7a006a52c95463d27833642d291aafafbbe657d6" translate="yes" xml:space="preserve">
          <source>Local substitutions behave like destructive substitutions (with ... := ...) but instead of being applied to a whole signature after the fact, they are introduced during the specification of the signature, and will apply to all the items that follow.</source>
          <target state="translated">局部替换的行为类似于破坏性替换(用...:=...),但它们不是在事后应用于整个签名,而是在签名的规范过程中引入的,并将应用于后面的所有项目。</target>
        </trans-unit>
        <trans-unit id="a3b9f4a56a716ca3242cf294551816b0edc61b5d" translate="yes" xml:space="preserve">
          <source>Lock a region for reading, and block if already locked</source>
          <target state="translated">锁定一个区域进行读取,如果已经锁定,则封锁该区域。</target>
        </trans-unit>
        <trans-unit id="46f366a2b18c94da3f95550dd69540c8a030c1d1" translate="yes" xml:space="preserve">
          <source>Lock a region for reading, or fail if already locked</source>
          <target state="translated">锁定一个区域进行读取,如果已经锁定则失败</target>
        </trans-unit>
        <trans-unit id="7b934b756e8fc53911807eb32d2b56437692262d" translate="yes" xml:space="preserve">
          <source>Lock a region for writing, and block if already locked</source>
          <target state="translated">锁定一个区域进行写入,如果已经锁定,则进行封堵。</target>
        </trans-unit>
        <trans-unit id="c93a16a3ed8e2fb19e43651da0d9564d29f64855" translate="yes" xml:space="preserve">
          <source>Lock a region for writing, or fail if already locked</source>
          <target state="translated">锁定一个区域进行写入,如果已经锁定则失败。</target>
        </trans-unit>
        <trans-unit id="4c7af655541e99448e1ec9e27d57b823c87c4cdc" translate="yes" xml:space="preserve">
          <source>Lock the given mutex.</source>
          <target state="translated">锁定指定的mutex。</target>
        </trans-unit>
        <trans-unit id="ef84af5a92860b1f205389a08e46e19c1d0376bf" translate="yes" xml:space="preserve">
          <source>Lock the given mutex. Only one thread can have the mutex locked at any time. A thread that attempts to lock a mutex already locked by another thread will suspend until the other thread unlocks the mutex.</source>
          <target state="translated">锁定指定的mutex。任何时候只有一个线程可以锁定mutex。试图锁定已经被另一个线程锁定的mutex的线程将暂停,直到另一个线程解锁该mutex。</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="d744573647f56d06b5b86078a49e94460efb4548" translate="yes" xml:space="preserve">
          <source>Locks for mutual exclusion.</source>
          <target state="translated">互相排斥的锁。</target>
        </trans-unit>
        <trans-unit id="2911f8b42aa989ed16139a00c9d592e0e4e835c2" translate="yes" xml:space="preserve">
          <source>Long_val(v) returns the long int encoded in value v.</source>
          <target state="translated">Long_val(v)返回用值 v 编码的长 int。</target>
        </trans-unit>
        <trans-unit id="911e3c5ea58f72e14fe5b81b5acd435c6c333d4f" translate="yes" xml:space="preserve">
          <source>Low-level functions</source>
          <target state="translated">低级职能</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="c934410bd452bcb5e709691c6c967b3dbcd37b50" translate="yes" xml:space="preserve">
          <source>MD5 message digest.</source>
          <target state="translated">MD5信息摘要。</target>
        </trans-unit>
        <trans-unit id="c6426140160e26a1863b2e621495d7c29a1605e0" translate="yes" xml:space="preserve">
          <source>Make inlining decisions at the point of definition of a function rather than at the call site(s). This mirrors the behaviour of OCaml compilers not using Flambda. Compared to compilation using the new Flambda inlining heuristics (for example at -O2) it produces smaller .cmx files, shorter compilation times and code that probably runs rather slower. When using -Oclassic, only the following options described in this section are relevant: -inlining-report and -inline. If any other of the options described in this section are used, the behaviour is undefined and may cause an error in future versions of the compiler.</source>
          <target state="translated">在函数的定义点而不是在调用点上做内联决定。这反映了不使用Flambda的OCaml编译器的行为。与使用新的Flambda内联启发式编译相比(例如在-O2下),它产生的.cmx文件更小,编译时间更短,代码运行可能更慢。当使用-Oclassic时,只有本节中描述的以下选项是相关的:-inlining-report和-inline。如果使用了本节中描述的任何其他选项,其行为是未定义的,可能会在未来版本的编译器中导致错误。</target>
        </trans-unit>
        <trans-unit id="10f29834334520e37b98f6237ca25333d059bd2e" translate="yes" xml:space="preserve">
          <source>Making a custom generator handle custom tags (see &lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;15.2.5&lt;/a&gt;) is very simple.</source>
          <target state="translated">使自定义生成器处理自定义标签（请参见&lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;15.2.5&lt;/a&gt;）非常简单。</target>
        </trans-unit>
        <trans-unit id="be8c42ef87bb8b55a6444a52383572cda55e1591" translate="yes" xml:space="preserve">
          <source>Making a custom generator handle custom tags (see &lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;16.2.5&lt;/a&gt;) is very simple.</source>
          <target state="translated">使自定义生成器处理自定义标签（请参见&lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;16.2.5&lt;/a&gt;）非常简单。</target>
        </trans-unit>
        <trans-unit id="fee138b412931aab18dbc01608d4cef40bddbdba" translate="yes" xml:space="preserve">
          <source>Management of signals</source>
          <target state="translated">信号的管理</target>
        </trans-unit>
        <trans-unit id="e8766772088c50c0ea69ddcc9e68cc232fadded3" translate="yes" xml:space="preserve">
          <source>Manipulation of backtrace information</source>
          <target state="translated">操纵回溯信息</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c43329032df3d96e24d72c385d12a422e571b619" translate="yes" xml:space="preserve">
          <source>Map CR to NL on input.</source>
          <target state="translated">将输入的CR映射到NL。</target>
        </trans-unit>
        <trans-unit id="62b1ed02cf5951695363e86b8efaae11f6285d79" translate="yes" xml:space="preserve">
          <source>Map NL to CR on input.</source>
          <target state="translated">将输入的NL映射到CR。</target>
        </trans-unit>
        <trans-unit id="face92f1c006ac531f226f881711266fcb0854d2" translate="yes" xml:space="preserve">
          <source>Map each element to a subsequence, then return each element of this sub-sequence in turn.</source>
          <target state="translated">将每个元素映射到一个子序列,然后依次返回这个子序列的每个元素。</target>
        </trans-unit>
        <trans-unit id="9d1e9a2774804659a435bcd137155a2fc9950a33" translate="yes" xml:space="preserve">
          <source>Map each element to a subsequence, then return each element of this sub-sequence in turn. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="translated">将每个元素映射到一个子序列,然后依次返回这个子序列的每个元素。这种变换是懒惰的,它只在结果被遍历时才适用。</target>
        </trans-unit>
        <trans-unit id="874e0cf467c242a8715d382d0113f4ffe8e8b9dc" translate="yes" xml:space="preserve">
          <source>Mapping files into memory</source>
          <target state="translated">将文件映射到内存中</target>
        </trans-unit>
        <trans-unit id="792fe4aaafb220da5ab17388e5844c93f1d95290" translate="yes" xml:space="preserve">
          <source>Margin</source>
          <target state="translated">Margin</target>
        </trans-unit>
        <trans-unit id="4e68d70db4cb0c9f7b47b7e8261347a139a40f40" translate="yes" xml:space="preserve">
          <source>Mark as fatal the warnings specified in the argument warning-list. The compiler will stop with an error when one of these warnings is emitted. The warning-list has the same meaning as for the -w option: a + sign (or an uppercase letter) marks the corresponding warnings as fatal, a - sign (or a lowercase letter) turns them back into non-fatal warnings, and a @ sign both enables and marks as fatal the corresponding warnings.</source>
          <target state="translated">将参数 warning-list 中指定的警告标记为 fatal。当其中一个警告发出时,编译器将以错误停止。warning-list的含义与-w选项相同:+号(或大写字母)将相应的警告标记为fatal,-号(或小写字母)将它们恢复为非fatal警告,@号既可以启用相应的警告,也可以将其标记为fatal。</target>
        </trans-unit>
        <trans-unit id="9651ed6afe7f40f844d844247a351f306f618725" translate="yes" xml:space="preserve">
          <source>Mark parity errors.</source>
          <target state="translated">标记奇偶性错误。</target>
        </trans-unit>
        <trans-unit id="9cdfbcba7d735bd862886d7bc92cdad6e808e063" translate="yes" xml:space="preserve">
          <source>Marshal</source>
          <target state="translated">Marshal</target>
        </trans-unit>
        <trans-unit id="facd64ea9fa3010a0e9705a9b4261b78f3ecb660" translate="yes" xml:space="preserve">
          <source>Marshaling of data structures.</source>
          <target state="translated">数据结构的调集。</target>
        </trans-unit>
        <trans-unit id="dad9eec833cc64e444f260559ec864ea918d9fe7" translate="yes" xml:space="preserve">
          <source>Match any single character belonging to the given character set. Valid character sets are: single character constants 'c'; ranges of characters 'c&lt;sub&gt;1&lt;/sub&gt;'-'c&lt;sub&gt;2&lt;/sub&gt;' (all characters between c&lt;sub&gt;1&lt;/sub&gt; and c&lt;sub&gt;2&lt;/sub&gt;, inclusive); and the union of two or more character sets, denoted by concatenation.</source>
          <target state="translated">匹配属于给定字符集的任何单个字符。有效字符集为：单字符常量'c'；字符'c &lt;sub&gt;1&lt;/sub&gt; '- 'c &lt;sub&gt;2&lt;/sub&gt; '的范围（c &lt;sub&gt;1&lt;/sub&gt;和c &lt;sub&gt;2&lt;/sub&gt;之间的所有字符，包括两端）；以及两个或两个以上字符集的并集，以串联表示。</target>
        </trans-unit>
        <trans-unit id="9ff233319bdf1bc966fa073a62017cfcf28311ec" translate="yes" xml:space="preserve">
          <source>Match any single character not belonging to the given character set.</source>
          <target state="translated">匹配任何不属于给定字符集的单个字符。</target>
        </trans-unit>
        <trans-unit id="f7ad8e08bddf311e1561c76915c116ddac2c9064" translate="yes" xml:space="preserve">
          <source>Match the end of the lexer input.</source>
          <target state="translated">匹配词典输入端。</target>
        </trans-unit>
        <trans-unit id="624939b9202c5d64193aa77b5ed57d3e219078ff" translate="yes" xml:space="preserve">
          <source>Match the same strings as &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;.</source>
          <target state="translated">匹配与&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;相同的字符串。</target>
        </trans-unit>
        <trans-unit id="6d643dda70d07a9bff87dc40b34a36dca7c58f10" translate="yes" xml:space="preserve">
          <source>Matching &lt;em&gt;any&lt;/em&gt; amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call &lt;code&gt;bscanf&amp;nbsp;ib&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;Price&amp;nbsp;=&amp;nbsp;%d&amp;nbsp;$&quot;&amp;nbsp;(fun&amp;nbsp;p&amp;nbsp;-&amp;gt;&amp;nbsp;p)&lt;/code&gt; succeeds and returns &lt;code&gt;1&lt;/code&gt; when reading an input with various whitespace in it, such as &lt;code&gt;Price&amp;nbsp;=&amp;nbsp;1&amp;nbsp;$&lt;/code&gt;, &lt;code&gt;Price&amp;nbsp;&amp;nbsp;=&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$&lt;/code&gt;, or even &lt;code&gt;Price=1$&lt;/code&gt;.</source>
          <target state="translated">匹配&lt;em&gt;任何&lt;/em&gt;数量的空格，格式字符串中的空格也根本不匹配任何数量的空格。因此，调用 &lt;code&gt;bscanf&amp;nbsp;ib&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;Price&amp;nbsp;=&amp;nbsp;%d&amp;nbsp;$&quot;&amp;nbsp;(fun&amp;nbsp;p&amp;nbsp;-&amp;gt;&amp;nbsp;p)&lt;/code&gt; 成功并在读取带有各种空白的输入时返回 &lt;code&gt;1&lt;/code&gt; ，例如 &lt;code&gt;Price&amp;nbsp;=&amp;nbsp;1&amp;nbsp;$&lt;/code&gt; ， &lt;code&gt;Price&amp;nbsp;&amp;nbsp;=&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$&lt;/code&gt; 甚至是 &lt;code&gt;Price=1$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9ba4e48291cd2cf0b811e179ed03624617f0f18" translate="yes" xml:space="preserve">
          <source>Matching proceeds as described before, except that if the value matches some pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; which has a guard cond&lt;sub&gt;i&lt;/sub&gt;, then the expression cond&lt;sub&gt;i&lt;/sub&gt; is evaluated (in an environment enriched by the bindings performed during matching). If cond&lt;sub&gt;i&lt;/sub&gt; evaluates to true, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is evaluated and its value returned as the result of the matching, as usual. But if cond&lt;sub&gt;i&lt;/sub&gt; evaluates to false, the matching is resumed against the patterns following &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;.</source>
          <target state="translated">如前所述进行匹配，除了如果该值匹配具有保护cond &lt;sub&gt;i的&lt;/sub&gt;某些模式&lt;a href=&quot;patterns#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;，则将对表达式cond &lt;sub&gt;i&lt;/sub&gt;进行求值（在通过匹配过程中执行的绑定充实的环境中）。如果cond &lt;sub&gt;i&lt;/sub&gt;评估为true，则照常评估&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;并将其值作为匹配结果返回。但是，如果cond &lt;sub&gt;i的&lt;/sub&gt;计算结果为false，则针对&lt;a href=&quot;patterns#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;之后的模式恢复匹配。&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="b4fe7526fed514734906dd56f0808fdf64d5c5e7" translate="yes" xml:space="preserve">
          <source>Material inside boxes nested deeper is printed as an ellipsis (more precisely as the text returned by &lt;a href=&quot;format#VALget_ellipsis_text&quot;&gt;&lt;code&gt;Format.get_ellipsis_text&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">嵌套在更深的盒子内部的材料被打印为省略号（更确切地说，是&lt;a href=&quot;format#VALget_ellipsis_text&quot;&gt; &lt;code&gt;Format.get_ellipsis_text&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; 返回的文本）。</target>
        </trans-unit>
        <trans-unit id="8c775e0b631e27aa872cba9538a7ad38db0e8382" translate="yes" xml:space="preserve">
          <source>Maximal number of bindings per bucket.</source>
          <target state="translated">每个桶的最大绑定数量。</target>
        </trans-unit>
        <trans-unit id="de4aecc225c29a9b00684b7a91e8d4a7c0c4fcf7" translate="yes" xml:space="preserve">
          <source>Maximum amount of out-of-heap memory for each custom value allocated in the minor heap. When a custom value is allocated on the minor heap and holds more than this many bytes, only this value is counted against &lt;code&gt;custom_minor_ratio&lt;/code&gt; and the rest is directly counted against &lt;code&gt;custom_major_ratio&lt;/code&gt;. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 8192 bytes.</source>
          <target state="translated">次要堆中分配的每个自定义值的最大堆外内存量。当在次要堆上分配了一个自定义值并保存了 &lt;code&gt;custom_minor_ratio&lt;/code&gt; 字节时，只会将此值计入custom_minor_ratio中，其余的则直接计入 &lt;code&gt;custom_major_ratio&lt;/code&gt; 中。注意：这仅适用于用 &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; 分配的值（例如bigarrays）。默认值：8192字节。</target>
        </trans-unit>
        <trans-unit id="3a4b693ac7f8f148df9e57169d08a10429066cdc" translate="yes" xml:space="preserve">
          <source>Maximum formatting depth</source>
          <target state="translated">最大格式化深度</target>
        </trans-unit>
        <trans-unit id="43e8208d3223642a44e274b068fe9167dea74624" translate="yes" xml:space="preserve">
          <source>Maximum indentation limit</source>
          <target state="translated">最大压痕限制</target>
        </trans-unit>
        <trans-unit id="57d9251c94f60be5c0a454afa29832266764bb87" translate="yes" xml:space="preserve">
          <source>Maximum length of a floatarray.</source>
          <target state="translated">浮动数组的最大长度。</target>
        </trans-unit>
        <trans-unit id="0a82d8640ca6e8be934710976326d9e3d41c21e3" translate="yes" xml:space="preserve">
          <source>Maximum length of a floatarray. This is also the maximum length of a &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; when OCaml is configured with &lt;code&gt;--enable-flat-float-array&lt;/code&gt;.</source>
          <target state="translated">浮点数组的最大长度。当OCaml配置了 &lt;code&gt;--enable-flat-float-array&lt;/code&gt; 时，这也是 &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; 的最大长度。</target>
        </trans-unit>
        <trans-unit id="75f830d8170e15a87cf9b64f314629724f342359" translate="yes" xml:space="preserve">
          <source>Maximum length of a normal array (i.e.</source>
          <target state="translated">普通数组的最大长度(即...)</target>
        </trans-unit>
        <trans-unit id="9e07a269e552f76233aa4f04ad4c80b7015574f5" translate="yes" xml:space="preserve">
          <source>Maximum length of a normal array (i.e. any array whose elements are not of type &lt;code&gt;float&lt;/code&gt;). The maximum length of a &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; is &lt;code&gt;max_floatarray_length&lt;/code&gt; if OCaml was configured with &lt;code&gt;--enable-flat-float-array&lt;/code&gt; and &lt;code&gt;max_array_length&lt;/code&gt; if configured with &lt;code&gt;--disable-flat-float-array&lt;/code&gt;.</source>
          <target state="translated">普通数组（即，其元素不是 &lt;code&gt;float&lt;/code&gt; 类型的任何数组）的最大长度。一个的最大长度 &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; 是 &lt;code&gt;max_floatarray_length&lt;/code&gt; 如果OCaml的用配置 &lt;code&gt;--enable-flat-float-array&lt;/code&gt; 和 &lt;code&gt;max_array_length&lt;/code&gt; 如果配置有 &lt;code&gt;--disable-flat-float-array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4de1705370b8992fe2eac57ca9e570d5b6fdbf4" translate="yes" xml:space="preserve">
          <source>Maximum length of an ephemeron, ie the maximum number of keys an ephemeron could contain</source>
          <target state="translated">一个星历的最大长度,即一个星历可能包含的最大键数。</target>
        </trans-unit>
        <trans-unit id="c8d2ea9cbf5aa25afab320da73d2cb8746b9c6ea" translate="yes" xml:space="preserve">
          <source>Maximum length of strings and byte sequences.</source>
          <target state="translated">字符串和字节序列的最大长度。</target>
        </trans-unit>
        <trans-unit id="111798f4ee1440503f39a9ca5e215b57ed0edd0d" translate="yes" xml:space="preserve">
          <source>Maximum read wait (in 0.1s units).</source>
          <target state="translated">最大读取等待时间(以0.1s为单位)。</target>
        </trans-unit>
        <trans-unit id="421dda9f026ffda8002440f413ce7dac542281cc" translate="yes" xml:space="preserve">
          <source>Maximum size reached by the major heap, in words.</source>
          <target state="translated">主要堆达到的最大尺寸,字。</target>
        </trans-unit>
        <trans-unit id="0867fadb65552799103f1e2c59b6996e3bca055e" translate="yes" xml:space="preserve">
          <source>Maybe the most frequent examples of non-genericity derive from the interactions between polymorphic types and mutation. A simple example appears when typing the following expression</source>
          <target state="translated">也许最常见的非通用性的例子来自于多态类型和突变之间的相互作用。当键入以下表达式时,就会出现一个简单的例子</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="58b588830d79aaa6edd4ede9d25c9ec5e38ae494" translate="yes" xml:space="preserve">
          <source>Mechanisms are available to control event collection at runtime.</source>
          <target state="translated">有机制可以在运行时控制事件收集。</target>
        </trans-unit>
        <trans-unit id="d5747d498a7435bd2232d8a279011040168fdf61" translate="yes" xml:space="preserve">
          <source>Memory management control and statistics; finalised values.</source>
          <target state="translated">内存管理控制和统计;最终确定数值。</target>
        </trans-unit>
        <trans-unit id="e1d5fee5c92276c92276efd0e44640e46a30110a" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray.</source>
          <target state="translated">将一个文件作为Bigarray的内存映射。</target>
        </trans-unit>
        <trans-unit id="9ac1a6209785502b12f1048680ede77f0350462f" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; returns a Bigarray of kind &lt;code&gt;kind&lt;/code&gt;, layout &lt;code&gt;layout&lt;/code&gt;, and dimensions as specified in &lt;code&gt;dims&lt;/code&gt;. The data contained in this Bigarray are the contents of the file referred to by the file descriptor &lt;code&gt;fd&lt;/code&gt; (as opened previously with &lt;a href=&quot;unix#VALopenfile&quot;&gt;&lt;code&gt;Unix.openfile&lt;/code&gt;&lt;/a&gt;, for example). The optional &lt;code&gt;pos&lt;/code&gt; parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</source>
          <target state="translated">文件作为Bigarray的内存映射。 &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; 返回一个种类 &lt;code&gt;kind&lt;/code&gt; ，布局 &lt;code&gt;layout&lt;/code&gt; 和尺寸的Bigarray，它们以 &lt;code&gt;dims&lt;/code&gt; 指定。此Bigarray中包含的数据是文件描述符 &lt;code&gt;fd&lt;/code&gt; 所引用的文件的内容（例如，先前使用&lt;a href=&quot;unix#VALopenfile&quot;&gt; &lt;code&gt;Unix.openfile&lt;/code&gt; &lt;/a&gt;打开的文件）。可选的 &lt;code&gt;pos&lt;/code&gt; 参数是要映射的数据文件中的字节偏移量；它默认为0（从文件开头开始映射）。</target>
        </trans-unit>
        <trans-unit id="d453e5fd051d62abb4952e6dce9f9a70c5c2e73f" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; returns a Bigarray of kind &lt;code&gt;kind&lt;/code&gt;, layout &lt;code&gt;layout&lt;/code&gt;, and dimensions as specified in &lt;code&gt;dims&lt;/code&gt;. The data contained in this Bigarray are the contents of the file referred to by the file descriptor &lt;code&gt;fd&lt;/code&gt; (as opened previously with &lt;code&gt;Unix.openfile&lt;/code&gt;, for example). The optional &lt;code&gt;pos&lt;/code&gt; parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</source>
          <target state="translated">文件作为Bigarray的内存映射。 &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; 返回一个种类 &lt;code&gt;kind&lt;/code&gt; ，布局 &lt;code&gt;layout&lt;/code&gt; 和尺寸的Bigarray，它们以 &lt;code&gt;dims&lt;/code&gt; 指定。此Bigarray中包含的数据是文件描述符 &lt;code&gt;fd&lt;/code&gt; 所引用的文件的内容（例如，先前使用 &lt;code&gt;Unix.openfile&lt;/code&gt; 打开的文件）。可选的 &lt;code&gt;pos&lt;/code&gt; 参数是要映射的数据文件中的字节偏移量；它默认为0（从文件开头开始映射）。</target>
        </trans-unit>
        <trans-unit id="687a2f280f91251cb46ba017b7b6d351d9f7b57a" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;~kind&amp;nbsp;~layout&amp;nbsp;~shared&amp;nbsp;~dims&lt;/code&gt; returns a Bigarray of kind &lt;code&gt;kind&lt;/code&gt;, layout &lt;code&gt;layout&lt;/code&gt;, and dimensions as specified in &lt;code&gt;dims&lt;/code&gt;. The data contained in this Bigarray are the contents of the file referred to by the file descriptor &lt;code&gt;fd&lt;/code&gt; (as opened previously with &lt;a href=&quot;unixlabels#VALopenfile&quot;&gt;&lt;code&gt;UnixLabels.openfile&lt;/code&gt;&lt;/a&gt;, for example). The optional &lt;code&gt;pos&lt;/code&gt; parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</source>
          <target state="translated">文件作为Bigarray的内存映射。 &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;~kind&amp;nbsp;~layout&amp;nbsp;~shared&amp;nbsp;~dims&lt;/code&gt; 返回类型的Bigarray &lt;code&gt;kind&lt;/code&gt; ，布局 &lt;code&gt;layout&lt;/code&gt; ，并且如在规定尺寸 &lt;code&gt;dims&lt;/code&gt; 。此Bigarray中包含的数据是文件描述符 &lt;code&gt;fd&lt;/code&gt; 所引用的文件的内容（例如，以前使用&lt;a href=&quot;unixlabels#VALopenfile&quot;&gt; &lt;code&gt;UnixLabels.openfile&lt;/code&gt; &lt;/a&gt;打开）。可选的 &lt;code&gt;pos&lt;/code&gt; 参数是要映射的数据文件中的字节偏移量；它默认为0（从文件开头开始映射）。</target>
        </trans-unit>
        <trans-unit id="880d9fe17162cdc8dbe19eec2a7dab314180b634" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;.</source>
          <target state="translated">合并两个列表：假设 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 根据比较函数 &lt;code&gt;cmp&lt;/code&gt; 排序，则 &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 将返回包含 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 的所有元素的排序列表。</target>
        </trans-unit>
        <trans-unit id="f82c912801fa2f38788ef8f80f6481aca333a281" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;. If several elements compare equal, the elements of &lt;code&gt;l1&lt;/code&gt; will be before the elements of &lt;code&gt;l2&lt;/code&gt;. Not tail-recursive (sum of the lengths of the arguments).</source>
          <target state="translated">合并两个列表：假设 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 根据比较函数 &lt;code&gt;cmp&lt;/code&gt; 排序，则 &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 将返回包含 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 的所有元素的排序列表。如果几个元素比较相等，则 &lt;code&gt;l1&lt;/code&gt; 的元素将在 &lt;code&gt;l2&lt;/code&gt; 的元素之前。不是尾递归的（参数长度的总和）。</target>
        </trans-unit>
        <trans-unit id="3146b01bddaff3613fcbac8db0c98762beac5c7b" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;~cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;.</source>
          <target state="translated">合并两个列表：假设 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 是根据比较函数 &lt;code&gt;cmp&lt;/code&gt; 排序的， &lt;code&gt;merge&amp;nbsp;~cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 将返回一个包含 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 的所有元素的排序列表。</target>
        </trans-unit>
        <trans-unit id="7521d4a01b5a820f9494840a903097972d0cd3be" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;~cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;. If several elements compare equal, the elements of &lt;code&gt;l1&lt;/code&gt; will be before the elements of &lt;code&gt;l2&lt;/code&gt;. Not tail-recursive (sum of the lengths of the arguments).</source>
          <target state="translated">合并两个列表：假设 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 是根据比较函数 &lt;code&gt;cmp&lt;/code&gt; 排序的， &lt;code&gt;merge&amp;nbsp;~cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 将返回一个包含 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 的所有元素的排序列表。如果几个元素比较相等，则 &lt;code&gt;l1&lt;/code&gt; 的元素将在 &lt;code&gt;l2&lt;/code&gt; 的元素之前。不是尾递归的（参数长度的总和）。</target>
        </trans-unit>
        <trans-unit id="6bf991e7854ed942e57f7a8ae958526d710e4851" translate="yes" xml:space="preserve">
          <source>Message too long</source>
          <target state="translated">信息太长</target>
        </trans-unit>
        <trans-unit id="fe901f98d707d8893028273fbe15a247b6dc752f" translate="yes" xml:space="preserve">
          <source>Method calls to objects are not at present inlined by Flambda.</source>
          <target state="translated">对对象的方法调用目前不被Flambda内联。</target>
        </trans-unit>
        <trans-unit id="725d48f23a2318240368857da2dd4a836394a9b1" translate="yes" xml:space="preserve">
          <source>Method overridden.</source>
          <target state="translated">方法被覆盖。</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="73d77f95747bb6c235ba5d9d8dd5594481b601b7" translate="yes" xml:space="preserve">
          <source>Methods may have an explicitly polymorphic type, allowing them to be used polymorphically in programs (even for the same object). The explicit declaration may be done in one of three ways: (1) by giving an explicit polymorphic type in the method definition, immediately after the method name, &lt;em&gt;i.e.&lt;/em&gt;method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;: {'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;}&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;; (2) by a forward declaration of the explicit polymorphic type through a virtual method definition; (3) by importing such a declaration through inheritance and/or constraining the type of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">方法可能具有显式多态类型，从而允许它们在程序中使用多态（即使对于同一对象）。可以通过以下三种方式之一来进行显式声明：（1）通过在方法名称之后&lt;em&gt;即&lt;/em&gt;方法[private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;：{' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; } &lt;sup&gt;+&lt;/sup&gt;之后，在方法定义中提供显式多态类型。&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; ; （2）通过虚拟方法定义对显式多态类型进行前向声明； （3）通过继承和/或约束&lt;em&gt;self&lt;/em&gt;的类型来导入这样的声明。</target>
        </trans-unit>
        <trans-unit id="977a75b1b527cafb43a310b768323025de5a89bf" translate="yes" xml:space="preserve">
          <source>Methods need not be declared previously, as shown by the example:</source>
          <target state="translated">方法不需要事先声明,如本例所示。</target>
        </trans-unit>
        <trans-unit id="48a374e74161047aa235fbb3100763be5b812693" translate="yes" xml:space="preserve">
          <source>Middle mouse button</source>
          <target state="translated">鼠标中键</target>
        </trans-unit>
        <trans-unit id="0d193e7dfe2ad2529b4896dcc5d46972be46e952" translate="yes" xml:space="preserve">
          <source>Minimum number of bytes to process for input operations</source>
          <target state="translated">处理输入操作的最小字节数。</target>
        </trans-unit>
        <trans-unit id="d481070b2cfb403e278c0dca62449244848cbded" translate="yes" xml:space="preserve">
          <source>Minimum number of bytes to process for output operations</source>
          <target state="translated">处理输出操作的最小字节数。</target>
        </trans-unit>
        <trans-unit id="d5be9f6d96fb9719bc05c3c57eba753a99104553" translate="yes" xml:space="preserve">
          <source>Minimum number of characters to read before the read request is satisfied.</source>
          <target state="translated">在满足读取请求之前,读取的最小字符数。</target>
        </trans-unit>
        <trans-unit id="1858c250815195a7d6f8064ba7ae2ae308e2c946" translate="yes" xml:space="preserve">
          <source>Minor collection and major GC slice.</source>
          <target state="translated">小收藏,大GC片。</target>
        </trans-unit>
        <trans-unit id="ba7f64b06da5b1e4fcb3453af263375fd663c205" translate="yes" xml:space="preserve">
          <source>Minutes 0..59</source>
          <target state="translated">分钟0.59</target>
        </trans-unit>
        <trans-unit id="314bb4fc83d55b365225efaa4fc333e95057e960" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions</source>
          <target state="translated">杂项职能</target>
        </trans-unit>
        <trans-unit id="39b08ec421dc1322ebeee3c79275c01cc8b3d8fe" translate="yes" xml:space="preserve">
          <source>Missing cmx file.</source>
          <target state="translated">缺少cmx文件。</target>
        </trans-unit>
        <trans-unit id="d081333d4e9bb27d1f44459f14c2d45dd9f81b1c" translate="yes" xml:space="preserve">
          <source>Missing fields in a record pattern.</source>
          <target state="translated">记录模式中缺少的字段。</target>
        </trans-unit>
        <trans-unit id="37f242d312b71edb3517a2032fd66710ec76680c" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;Format&lt;/code&gt; provides a complete set of &lt;code&gt;printf&lt;/code&gt; like functions for pretty-printing using format string specifications.</source>
          <target state="translated">模块 &lt;code&gt;Format&lt;/code&gt; 提供了一套完整的类似于 &lt;code&gt;printf&lt;/code&gt; 的功能，用于使用格式字符串规范进行漂亮的打印。</target>
        </trans-unit>
        <trans-unit id="bad989c3e6325882d6507e66e3602a4dd7dd1950" translate="yes" xml:space="preserve">
          <source>Module Arg</source>
          <target state="translated">模块Arg</target>
        </trans-unit>
        <trans-unit id="6abf3bb1d160573e61d46e6b5f81e5508ae82e88" translate="yes" xml:space="preserve">
          <source>Module Arg: parsing of command line arguments</source>
          <target state="translated">模块Arg:解析命令行参数。</target>
        </trans-unit>
        <trans-unit id="a56fcb800d5771af9f080dd53abe44c449867565" translate="yes" xml:space="preserve">
          <source>Module Array</source>
          <target state="translated">模块阵列</target>
        </trans-unit>
        <trans-unit id="dc2ddb4a440e52c266e257d745c23b9dadfa5b3d" translate="yes" xml:space="preserve">
          <source>Module Array: array operations</source>
          <target state="translated">模块阵列:阵列操作</target>
        </trans-unit>
        <trans-unit id="0d18ab309cc5cd2e46cd375092084b640f8135f4" translate="yes" xml:space="preserve">
          <source>Module ArrayLabels</source>
          <target state="translated">模块 ArrayLabels</target>
        </trans-unit>
        <trans-unit id="cc6ff72196a05305dab9e2db994ea05cd60e104b" translate="yes" xml:space="preserve">
          <source>Module ArrayLabels: array operations (with labels)</source>
          <target state="translated">模块ArrayLabels:数组操作(带标签)</target>
        </trans-unit>
        <trans-unit id="f93c03acf357c6454b6e5285450c3f3f3f30bb2c" translate="yes" xml:space="preserve">
          <source>Module Ast_helper: helper functions for AST construction</source>
          <target state="translated">模块Ast_helper:用于AST构造的帮助函数。</target>
        </trans-unit>
        <trans-unit id="4f633b64e1901b821e83c2d2917c9c7dfe7b2811" translate="yes" xml:space="preserve">
          <source>Module Ast_mapper: -ppx rewriter interface</source>
          <target state="translated">模块Ast_mapper:-ppx重写器接口。</target>
        </trans-unit>
        <trans-unit id="523d5c8f5c6bb7605890429c1f11b8c345bdf0a9" translate="yes" xml:space="preserve">
          <source>Module Asttypes: auxiliary types used by Parsetree</source>
          <target state="translated">模块Asttypes:Parsetree使用的辅助类型。</target>
        </trans-unit>
        <trans-unit id="466cc01746b0ce14da9c3101dbcb89de8c254f25" translate="yes" xml:space="preserve">
          <source>Module Atomic</source>
          <target state="translated">原子模块</target>
        </trans-unit>
        <trans-unit id="14944e195276656a6b2e991b8c449794b3b7e562" translate="yes" xml:space="preserve">
          <source>Module Atomic: atomic references</source>
          <target state="translated">模块原子:原子引用</target>
        </trans-unit>
        <trans-unit id="cc643dfec1e07f16e63a2f5d40439c635b5a0da0" translate="yes" xml:space="preserve">
          <source>Module Bigarray</source>
          <target state="translated">模块Bigarray</target>
        </trans-unit>
        <trans-unit id="8b457fad35d3c5733311bed4d1abc1928bb9ab28" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array0</source>
          <target state="translated">模块Bigarray.Array0</target>
        </trans-unit>
        <trans-unit id="0606447c86667b05a149e8ca96cc9d366dcdc45f" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array1</source>
          <target state="translated">模块Bigarray.Array1</target>
        </trans-unit>
        <trans-unit id="4e9d1f71e428cb53a57134b56fbd980b03c94e2c" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array2</source>
          <target state="translated">模块Bigarray.Array2</target>
        </trans-unit>
        <trans-unit id="27d48e9da9c33900ca44d6ecad351863f7bdaf5c" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array3</source>
          <target state="translated">模块Bigarray.Array3</target>
        </trans-unit>
        <trans-unit id="d4d26b36f6d58ffaea1f504565e46f4f60567d67" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Genarray</source>
          <target state="translated">模块Bigarray.Genarray</target>
        </trans-unit>
        <trans-unit id="f3762282f9caa555d54286fbb90a1e96b4c7c432" translate="yes" xml:space="preserve">
          <source>Module Bigarray: large, multi-dimensional, numerical arrays</source>
          <target state="translated">模块Bigarray:大型的、多维的、数值化的数组。</target>
        </trans-unit>
        <trans-unit id="8ecd3446e16a821dd5e1adff2cc82cb3a5130a89" translate="yes" xml:space="preserve">
          <source>Module Bool</source>
          <target state="translated">模块Bool</target>
        </trans-unit>
        <trans-unit id="6c3e715d33fc29b958efa37ae69668a59a1706ff" translate="yes" xml:space="preserve">
          <source>Module Bool: boolean values</source>
          <target state="translated">模块Bool:布尔值</target>
        </trans-unit>
        <trans-unit id="bddc2144c4c529dd8430235937580a143554e16c" translate="yes" xml:space="preserve">
          <source>Module Buffer</source>
          <target state="translated">模块缓冲区</target>
        </trans-unit>
        <trans-unit id="43c2c38aaa41d7ed5d989a9cc184b3794181c9f7" translate="yes" xml:space="preserve">
          <source>Module Buffer: extensible buffers</source>
          <target state="translated">模块缓冲器:可扩展缓冲器</target>
        </trans-unit>
        <trans-unit id="72216591b14162977cfdb1c07def7995da644395" translate="yes" xml:space="preserve">
          <source>Module Bytes</source>
          <target state="translated">模块字节</target>
        </trans-unit>
        <trans-unit id="9c11fb2e91c5b00fbb9701a94d4424a17d04a49c" translate="yes" xml:space="preserve">
          <source>Module Bytes: byte sequences</source>
          <target state="translated">模块字节:字节序列</target>
        </trans-unit>
        <trans-unit id="a85f0c0beeed2c6b8ad5ef29ccdfab63a21b9d52" translate="yes" xml:space="preserve">
          <source>Module BytesLabels</source>
          <target state="translated">模块 字节标签</target>
        </trans-unit>
        <trans-unit id="f6cf68f0aad404a1f34cfeef9f8dc2bc6273085e" translate="yes" xml:space="preserve">
          <source>Module BytesLabels: byte sequences (with labels)</source>
          <target state="translated">模块BytesLabels:字节序列(带标签)。</target>
        </trans-unit>
        <trans-unit id="f99b095fc3c2466d64fae5588a546e997e1e5f16" translate="yes" xml:space="preserve">
          <source>Module Callback</source>
          <target state="translated">模块回调</target>
        </trans-unit>
        <trans-unit id="559eafeaa053a08996c324cd386ae9221fc17b97" translate="yes" xml:space="preserve">
          <source>Module Callback: registering OCaml values with the C runtime</source>
          <target state="translated">模块回调:在C运行时注册OCaml值。</target>
        </trans-unit>
        <trans-unit id="6dbdcb25b8c3385ccca990f6993d3f200b6c8d9d" translate="yes" xml:space="preserve">
          <source>Module CamlinternalAtomic</source>
          <target state="translated">模块CamlinternalAtomic</target>
        </trans-unit>
        <trans-unit id="d1355614e6d5e948afbb68e8c6119679a9a45955" translate="yes" xml:space="preserve">
          <source>Module CamlinternalFormat</source>
          <target state="translated">模块CamlinternalFormat</target>
        </trans-unit>
        <trans-unit id="b4d1db84ed7881aa6f76ae9db16693820f6725ae" translate="yes" xml:space="preserve">
          <source>Module CamlinternalFormatBasics</source>
          <target state="translated">模块CamlinternalFormatBasics。</target>
        </trans-unit>
        <trans-unit id="93e7f0366b4e8dbdb121c6899472d74fc9e300ed" translate="yes" xml:space="preserve">
          <source>Module CamlinternalLazy</source>
          <target state="translated">模块CamlinternalLazy</target>
        </trans-unit>
        <trans-unit id="030e686bde89aa913f3dbe8fe375396e5953e5e6" translate="yes" xml:space="preserve">
          <source>Module CamlinternalMod</source>
          <target state="translated">模块CamlinternalMod</target>
        </trans-unit>
        <trans-unit id="dd6ad5c3473f26f582d139567a98ea0e9d3d3b4e" translate="yes" xml:space="preserve">
          <source>Module CamlinternalOO</source>
          <target state="translated">模块CamlinternalOO</target>
        </trans-unit>
        <trans-unit id="79e77ccf8fe8cad52d93078cb896ef207ae08837" translate="yes" xml:space="preserve">
          <source>Module Char</source>
          <target state="translated">模块图表</target>
        </trans-unit>
        <trans-unit id="eb75d51c88cc6b02cf6aca6015384b8720d875a9" translate="yes" xml:space="preserve">
          <source>Module Char: character operations</source>
          <target state="translated">模块Char:字符操作</target>
        </trans-unit>
        <trans-unit id="5548e02ff9068a8bd2671e455dd9adf27f571d77" translate="yes" xml:space="preserve">
          <source>Module Complex</source>
          <target state="translated">复杂模块</target>
        </trans-unit>
        <trans-unit id="142a8ecd6426e808bdec26ab206584b15b18b324" translate="yes" xml:space="preserve">
          <source>Module Complex: Complex numbers</source>
          <target state="translated">复数模块。复数</target>
        </trans-unit>
        <trans-unit id="6616c10e3d84b4d6c6f90344d150f834e185fcae" translate="yes" xml:space="preserve">
          <source>Module Complex: complex numbers</source>
          <target state="translated">复杂模块:复数</target>
        </trans-unit>
        <trans-unit id="bf0d5f1ae3231eea0973a205c212df89a0b65712" translate="yes" xml:space="preserve">
          <source>Module Condition</source>
          <target state="translated">模块条件</target>
        </trans-unit>
        <trans-unit id="a6a62a2154dc372d92c88ec0dfbedc61b73cd367" translate="yes" xml:space="preserve">
          <source>Module Condition: condition variables to synchronize between threads</source>
          <target state="translated">模块条件:线程间同步的条件变量。</target>
        </trans-unit>
        <trans-unit id="c923312ef4200761b1302981bacdcb52bccc44f9" translate="yes" xml:space="preserve">
          <source>Module Digest</source>
          <target state="translated">模块摘要</target>
        </trans-unit>
        <trans-unit id="8bbfa8ae15ecab1209610ac5a66a651f78875a78" translate="yes" xml:space="preserve">
          <source>Module Digest: MD5 message digest</source>
          <target state="translated">模块摘要:MD5信息摘要</target>
        </trans-unit>
        <trans-unit id="02c49caa12242dda259d7307d31dd98fda25b90d" translate="yes" xml:space="preserve">
          <source>Module Dynlink</source>
          <target state="translated">Dynlink模块</target>
        </trans-unit>
        <trans-unit id="17df668e4cee0361dd61ce759ea047d4ccf6ce2f" translate="yes" xml:space="preserve">
          <source>Module Dynlink: dynamic loading of bytecode object files</source>
          <target state="translated">模块Dynlink:动态加载字节码对象文件。</target>
        </trans-unit>
        <trans-unit id="b077e55507ea365c5713901e6a0e01092935292a" translate="yes" xml:space="preserve">
          <source>Module Either</source>
          <target state="translated">模块</target>
        </trans-unit>
        <trans-unit id="46a3d2172baa76706a9eb32021eb67f6a8824d3b" translate="yes" xml:space="preserve">
          <source>Module Either: either values</source>
          <target state="translated">模块二:任一数值</target>
        </trans-unit>
        <trans-unit id="9c62be44cefe5016fcac970fcb981646c02e96b6" translate="yes" xml:space="preserve">
          <source>Module Ephemeron</source>
          <target state="translated">模块星历</target>
        </trans-unit>
        <trans-unit id="306ceb414fe45593e76183fffc1c6e8063a97af7" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.GenHashTable</source>
          <target state="translated">模块Ephemeron.GenHashTable。</target>
        </trans-unit>
        <trans-unit id="3c0d413a4c6a68f4547228b7fbcd4303cea78dd7" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.K1</source>
          <target state="translated">模块Ephemeron.K1</target>
        </trans-unit>
        <trans-unit id="cc37a3b6fff03344d782218dfc93f84de56f0454" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.K2</source>
          <target state="translated">模块Ephemeron.K2</target>
        </trans-unit>
        <trans-unit id="4dbed2786938f2a0e76b0e83d9e7aee1f6ba1c21" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.Kn</source>
          <target state="translated">模块Ephemeron.Kn</target>
        </trans-unit>
        <trans-unit id="9bc16c26307d248abe81e5774136cc291bdc2f67" translate="yes" xml:space="preserve">
          <source>Module Ephemeron: Ephemerons and weak hash table</source>
          <target state="translated">模块Ephemeron。星历和弱哈希表</target>
        </trans-unit>
        <trans-unit id="965c3d92c5cef899a73c03e9b00b354453a07c58" translate="yes" xml:space="preserve">
          <source>Module Event</source>
          <target state="translated">模块事件</target>
        </trans-unit>
        <trans-unit id="f6dd977ad9cdd9e33bfa766d7ff4615d50d92bac" translate="yes" xml:space="preserve">
          <source>Module Event: first-class synchronous communication</source>
          <target state="translated">模块事件:一流的同步通信</target>
        </trans-unit>
        <trans-unit id="95908861b116393327d9f6360c9aa8ce9f3fc3d9" translate="yes" xml:space="preserve">
          <source>Module Filename</source>
          <target state="translated">模块文件名</target>
        </trans-unit>
        <trans-unit id="2a2de638ce58f0d0a702b4d4f313c4f37216533f" translate="yes" xml:space="preserve">
          <source>Module Filename: operations on file names</source>
          <target state="translated">模块文件名:对文件名的操作</target>
        </trans-unit>
        <trans-unit id="dbf4558ebef769a096f39fa6c0312334a381fec2" translate="yes" xml:space="preserve">
          <source>Module Float</source>
          <target state="translated">模块浮动</target>
        </trans-unit>
        <trans-unit id="c0ebb1cca64e0c8f91ce7a3e1f3ba4030ed3b8f4" translate="yes" xml:space="preserve">
          <source>Module Float.Array</source>
          <target state="translated">模块 Float.Array</target>
        </trans-unit>
        <trans-unit id="445a0b0a1771a9581127d17829402c08430bebed" translate="yes" xml:space="preserve">
          <source>Module Float.ArrayLabels</source>
          <target state="translated">模块 Float.ArrayLabels</target>
        </trans-unit>
        <trans-unit id="a3600f92b6696937343502269bc8090397c0e51e" translate="yes" xml:space="preserve">
          <source>Module Float: Floating-point numbers</source>
          <target state="translated">模块浮点数。浮点数</target>
        </trans-unit>
        <trans-unit id="313822257f2621ba0ec98af8aadf8d2638a5326a" translate="yes" xml:space="preserve">
          <source>Module Float: floating-point numbers</source>
          <target state="translated">浮点数模块:浮点数</target>
        </trans-unit>
        <trans-unit id="f2cecfe8e0ae9b3a901adc050a10fa4ea0c7797d" translate="yes" xml:space="preserve">
          <source>Module Format</source>
          <target state="translated">模块格式</target>
        </trans-unit>
        <trans-unit id="12bb5435b16c5c8b6ab86cf0323be7dcc9f30566" translate="yes" xml:space="preserve">
          <source>Module Format: pretty printing</source>
          <target state="translated">模块格式:精美印刷</target>
        </trans-unit>
        <trans-unit id="acb444a56b618a584c9cdb2f01ce73257415d59a" translate="yes" xml:space="preserve">
          <source>Module Fun</source>
          <target state="translated">模组乐趣</target>
        </trans-unit>
        <trans-unit id="40b410ee83d227d662e6b02df5f6cd601cb1762f" translate="yes" xml:space="preserve">
          <source>Module Fun: function values</source>
          <target state="translated">模块趣味:函数值</target>
        </trans-unit>
        <trans-unit id="d07aebf1d4ebd5c2e42b08423a93172511323b0f" translate="yes" xml:space="preserve">
          <source>Module Gc</source>
          <target state="translated">模块Gc</target>
        </trans-unit>
        <trans-unit id="ac86c6af7ac7bc4fc4841fea39b50ce532e9eae3" translate="yes" xml:space="preserve">
          <source>Module Gc.Memprof</source>
          <target state="translated">模块Gc.Memprof</target>
        </trans-unit>
        <trans-unit id="017db642bb8f1e27af62b289d7afc0311dfb9b9d" translate="yes" xml:space="preserve">
          <source>Module Gc: memory management control and statistics; finalized values</source>
          <target state="translated">模块Gc:内存管理控制和统计;最终确定的数值。</target>
        </trans-unit>
        <trans-unit id="13184731a834066fef8c861de2b8b904d78a2c40" translate="yes" xml:space="preserve">
          <source>Module Genlex</source>
          <target state="translated">模块Genlex</target>
        </trans-unit>
        <trans-unit id="4ee3df3538f22bd946cb81aed2d740d6af4e43d7" translate="yes" xml:space="preserve">
          <source>Module Genlex: a generic lexical analyzer</source>
          <target state="translated">模块Genlex:一个通用词汇分析器。</target>
        </trans-unit>
        <trans-unit id="6d8fffbaf37dc886f091f1fcec194d70a8a56139" translate="yes" xml:space="preserve">
          <source>Module Hashtbl</source>
          <target state="translated">模块Hashtbl</target>
        </trans-unit>
        <trans-unit id="45ea31d5ad955fa4490b30ef1a1270d2c6392bda" translate="yes" xml:space="preserve">
          <source>Module Hashtbl: hash tables and hash functions</source>
          <target state="translated">模块Hashtbl:哈希表和哈希函数。</target>
        </trans-unit>
        <trans-unit id="49f5fed72bf1186b3606fcd64d3620ad4b5e6d3f" translate="yes" xml:space="preserve">
          <source>Module Int</source>
          <target state="translated">模块Int</target>
        </trans-unit>
        <trans-unit id="acab9c65663172b6b3cf63cdb91db7c853666939" translate="yes" xml:space="preserve">
          <source>Module Int32</source>
          <target state="translated">模块Int32</target>
        </trans-unit>
        <trans-unit id="59af84ad710fb152c38038123bed434bcda5ee5d" translate="yes" xml:space="preserve">
          <source>Module Int32: 32-bit integers</source>
          <target state="translated">模块Int32:32位整数</target>
        </trans-unit>
        <trans-unit id="afb57e65a2c5001e2ebbf893ab00402f586e67a7" translate="yes" xml:space="preserve">
          <source>Module Int64</source>
          <target state="translated">模块Int64</target>
        </trans-unit>
        <trans-unit id="b5dcbf9b29416b9da9d5777bc0cbfff746fd3bff" translate="yes" xml:space="preserve">
          <source>Module Int64: 64-bit integers</source>
          <target state="translated">Int64模块:64位整数</target>
        </trans-unit>
        <trans-unit id="c67951c6b0d56d43a8d0b9f4a75238e26b84e176" translate="yes" xml:space="preserve">
          <source>Module Int: integers</source>
          <target state="translated">模块Int:整数</target>
        </trans-unit>
        <trans-unit id="6cbdc748b0a834da10d99ca83f0f783ca0b5c0b5" translate="yes" xml:space="preserve">
          <source>Module Lazy</source>
          <target state="translated">懒人模块</target>
        </trans-unit>
        <trans-unit id="6ed3c69956723eb0ea9cccf3b3f808a1e740d7bd" translate="yes" xml:space="preserve">
          <source>Module Lazy: deferred computations</source>
          <target state="translated">模块Lazy:延迟计算</target>
        </trans-unit>
        <trans-unit id="9d9af75cdf4a76dd0ace806f7dd01595ce9a4e7f" translate="yes" xml:space="preserve">
          <source>Module Lexing</source>
          <target state="translated">模块拼写</target>
        </trans-unit>
        <trans-unit id="cda606f5e00de0f84675796ae085f4bffba696d6" translate="yes" xml:space="preserve">
          <source>Module Lexing: the run-time library for lexers generated by ocamllex</source>
          <target state="translated">模块Lexing:由ocamllex生成的词库的运行时库。</target>
        </trans-unit>
        <trans-unit id="0ba47168d0ea302d6485e2bceea2a3d5ea07497a" translate="yes" xml:space="preserve">
          <source>Module List</source>
          <target state="translated">模块列表</target>
        </trans-unit>
        <trans-unit id="d95ac15be64ca43f1623a9f9232b997c5bf2c1d4" translate="yes" xml:space="preserve">
          <source>Module List: list operations</source>
          <target state="translated">模块列表:列表操作</target>
        </trans-unit>
        <trans-unit id="daeda2f1f3fc9215afe3219e87ce40a8a991bc71" translate="yes" xml:space="preserve">
          <source>Module ListLabels</source>
          <target state="translated">模块列表标签</target>
        </trans-unit>
        <trans-unit id="9abd62669e68c48ade8c878e63da864a392f2017" translate="yes" xml:space="preserve">
          <source>Module ListLabels: list operations (with labels)</source>
          <target state="translated">模块ListLabels:列表操作(带标签)</target>
        </trans-unit>
        <trans-unit id="41eb27b154c8a0a9fe8b6fcd4251fc8ecd2542f7" translate="yes" xml:space="preserve">
          <source>Module Location: source code locations</source>
          <target state="translated">模块位置:源代码位置</target>
        </trans-unit>
        <trans-unit id="09ea5f0fd44fa46552a5f30cbf18b1bf609af0ea" translate="yes" xml:space="preserve">
          <source>Module Longident: long identifiers</source>
          <target state="translated">模块Longident:长标识符</target>
        </trans-unit>
        <trans-unit id="10b6935577db632331cb02bf7fee39599c44a34e" translate="yes" xml:space="preserve">
          <source>Module Map</source>
          <target state="translated">模块地图</target>
        </trans-unit>
        <trans-unit id="723c875a6e9814d580d5129ea7f70d98fe17170f" translate="yes" xml:space="preserve">
          <source>Module Map: association tables over ordered types</source>
          <target state="translated">模块图:有序类型的关联表</target>
        </trans-unit>
        <trans-unit id="996a073e0bd0499fc31006fad291c31374a4ad0a" translate="yes" xml:space="preserve">
          <source>Module Marshal</source>
          <target state="translated">模块元帅</target>
        </trans-unit>
        <trans-unit id="937c5df760edcb5aeb3c943766622a05d26ea688" translate="yes" xml:space="preserve">
          <source>Module Marshal: marshaling of data structures</source>
          <target state="translated">模块Marshal:数据结构的集结。</target>
        </trans-unit>
        <trans-unit id="2d7a3c934043e76f7e6aa5bab83a410c8b18ba72" translate="yes" xml:space="preserve">
          <source>Module MoreLabels</source>
          <target state="translated">模块更多标签</target>
        </trans-unit>
        <trans-unit id="4b77f1b995f3d850723fe2d5f0d94f538cb8bc90" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Hashtbl</source>
          <target state="translated">模块MoreLabels.Hashtbl</target>
        </trans-unit>
        <trans-unit id="760a84c4680b6780dd84d385973bbf20f33f4210" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Map</source>
          <target state="translated">模块MoreLabels.Map</target>
        </trans-unit>
        <trans-unit id="25069e19c5b1b2db1e702799063dde780224c560" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Set</source>
          <target state="translated">模块MoreLabels.Set</target>
        </trans-unit>
        <trans-unit id="1b19605374bddf60dcda0218ce57f2d6c6393746" translate="yes" xml:space="preserve">
          <source>Module MoreLabels: Include modules Hashtbl, Map and Set with labels</source>
          <target state="translated">模块MoreLabels。包括带标签的Hashtbl、Map和Set模块。</target>
        </trans-unit>
        <trans-unit id="98637b2b2a158224bf07282ac080de51fa6cf0bc" translate="yes" xml:space="preserve">
          <source>Module MoreLabels: include modules Hashtbl, Map and Set with labels</source>
          <target state="translated">模块MoreLabels:包括带标签的Hashtbl、Map和Set模块。</target>
        </trans-unit>
        <trans-unit id="699fda78007ab6ee795d1ec46cb5ba0fadbcd152" translate="yes" xml:space="preserve">
          <source>Module Mutex</source>
          <target state="translated">模块互换</target>
        </trans-unit>
        <trans-unit id="9441c63e9620994d64788047f899a67dff634072" translate="yes" xml:space="preserve">
          <source>Module Mutex: locks for mutual exclusion</source>
          <target state="translated">模块互斥:相互排斥的锁。</target>
        </trans-unit>
        <trans-unit id="1838869d8ec86c1a2d37dff5dc780f83b0fec1d6" translate="yes" xml:space="preserve">
          <source>Module Nativeint</source>
          <target state="translated">模块 Nativeint</target>
        </trans-unit>
        <trans-unit id="cc1d1c0c97415413ce2342a3f6f55d45834011c5" translate="yes" xml:space="preserve">
          <source>Module Nativeint: processor-native integers</source>
          <target state="translated">模块Nativeint:处理器原生整数。</target>
        </trans-unit>
        <trans-unit id="7b4ea02830398a7975c1360e1989452b5c984a6e" translate="yes" xml:space="preserve">
          <source>Module Obj</source>
          <target state="translated">模块目标</target>
        </trans-unit>
        <trans-unit id="859ef67380ce711f1e2680e67b72fd41777bfb0f" translate="yes" xml:space="preserve">
          <source>Module Obj.Closure</source>
          <target state="translated">模块Obj.Closure</target>
        </trans-unit>
        <trans-unit id="272ea9eeccbd009ebb96e6b41a649184070812a9" translate="yes" xml:space="preserve">
          <source>Module Obj.Ephemeron</source>
          <target state="translated">模块Obj.Ephemeron</target>
        </trans-unit>
        <trans-unit id="85d7d19a5339d91797722162ab420ee924fd4061" translate="yes" xml:space="preserve">
          <source>Module Obj.Extension_constructor</source>
          <target state="translated">模块Obj.Extension_constructor</target>
        </trans-unit>
        <trans-unit id="5fe9ce284b5e4679d29a8e61897d87de3d56edfa" translate="yes" xml:space="preserve">
          <source>Module Oo</source>
          <target state="translated">模块Oo</target>
        </trans-unit>
        <trans-unit id="5ab66589e35c123c9f9433f57b4d129d3e642f10" translate="yes" xml:space="preserve">
          <source>Module Oo: object-oriented extension</source>
          <target state="translated">模块Oo:面向对象的扩展</target>
        </trans-unit>
        <trans-unit id="552e8a4259199d9b2043147a832aca29c2875d9a" translate="yes" xml:space="preserve">
          <source>Module Option</source>
          <target state="translated">模块选项</target>
        </trans-unit>
        <trans-unit id="aa8d3db6fe714bb3b01fd318b7f50f3a7d37c609" translate="yes" xml:space="preserve">
          <source>Module Option: option values</source>
          <target state="translated">模块选项:选项值</target>
        </trans-unit>
        <trans-unit id="ee462040d70476901068cb4b27d7246c72808b85" translate="yes" xml:space="preserve">
          <source>Module Parse: OCaml syntax parsing</source>
          <target state="translated">模块解析。OCaml语法解析</target>
        </trans-unit>
        <trans-unit id="caf367dbe7aff2e9ccc52d81e33ebb4ebae22ff7" translate="yes" xml:space="preserve">
          <source>Module Parsetree: OCaml syntax tree</source>
          <target state="translated">模块Parsetree.OCaml语法树 OCaml语法树</target>
        </trans-unit>
        <trans-unit id="7614cdd9f0ec33aa4685f6bd34afeb038456c5ae" translate="yes" xml:space="preserve">
          <source>Module Parsing</source>
          <target state="translated">模块解析</target>
        </trans-unit>
        <trans-unit id="674971f0c437aab44e4076ee335788a7f95f2d06" translate="yes" xml:space="preserve">
          <source>Module Parsing: the run-time library for parsers generated by ocamlyacc</source>
          <target state="translated">Module Parsing:由ocamlyacc生成的解析器的运行库。</target>
        </trans-unit>
        <trans-unit id="c5588d487861f64669575fcb69cb5b074b4f41fb" translate="yes" xml:space="preserve">
          <source>Module Pervasives: deprecated alias for Stdlib</source>
          <target state="translated">模块Pervasives:Stdlib的弃用别名。</target>
        </trans-unit>
        <trans-unit id="1a1dc73aec1ccbac02b8e8f43ee58892b59b0745" translate="yes" xml:space="preserve">
          <source>Module Pprintast: OCaml syntax printing</source>
          <target state="translated">模块Pprintast。OCaml语法打印</target>
        </trans-unit>
        <trans-unit id="b5e430425b7a707621c40fc5db568b1422825347" translate="yes" xml:space="preserve">
          <source>Module Printexc</source>
          <target state="translated">打印模块</target>
        </trans-unit>
        <trans-unit id="c879b5b58ad9c94051bbfc78df7ae8670b40859d" translate="yes" xml:space="preserve">
          <source>Module Printexc.Slot</source>
          <target state="translated">模块 Printexc.Slot</target>
        </trans-unit>
        <trans-unit id="72f9916225d741d402336a087d22708a6a08547d" translate="yes" xml:space="preserve">
          <source>Module Printexc: facilities for printing exceptions</source>
          <target state="translated">模块Printexc:打印例外情况的设施</target>
        </trans-unit>
        <trans-unit id="8ef8e2302f5298816f3c9a62eb7ff84ee4558dc9" translate="yes" xml:space="preserve">
          <source>Module Printf</source>
          <target state="translated">模块打印</target>
        </trans-unit>
        <trans-unit id="0f2f2beac76b39281ec8d02c364037eaeb98cbcb" translate="yes" xml:space="preserve">
          <source>Module Printf: formatting printing functions</source>
          <target state="translated">模块Printf:格式化打印功能</target>
        </trans-unit>
        <trans-unit id="e12960179cefb13cef1a39ceeab8802831a8d8f8" translate="yes" xml:space="preserve">
          <source>Module Queue</source>
          <target state="translated">模块队列</target>
        </trans-unit>
        <trans-unit id="053310d8755ceed37f1727f1d1a1abcfeefaea2f" translate="yes" xml:space="preserve">
          <source>Module Queue: first-in first-out queues</source>
          <target state="translated">模块队列:先进先出队列。</target>
        </trans-unit>
        <trans-unit id="ef161e448a0a073f4c747dde06ec44412c5ae309" translate="yes" xml:space="preserve">
          <source>Module Random</source>
          <target state="translated">模块随机</target>
        </trans-unit>
        <trans-unit id="1b8723087c253ef44125a63809350dd54cc9e5e8" translate="yes" xml:space="preserve">
          <source>Module Random.State</source>
          <target state="translated">模块Random.State</target>
        </trans-unit>
        <trans-unit id="0dfee50267f747d0f1636dd29878bc9fbb3994b9" translate="yes" xml:space="preserve">
          <source>Module Random: pseudo-random number generator (PRNG)</source>
          <target state="translated">模块Random:伪随机数生成器(PRNG)。</target>
        </trans-unit>
        <trans-unit id="14e0c591450e8a2f60ddb8562b4eb14af09e5b51" translate="yes" xml:space="preserve">
          <source>Module Result</source>
          <target state="translated">模块结果</target>
        </trans-unit>
        <trans-unit id="5eafde20b375d72096c25a3285f206655630e2ae" translate="yes" xml:space="preserve">
          <source>Module Result: result values</source>
          <target state="translated">模块结果:结果值</target>
        </trans-unit>
        <trans-unit id="49dde4ae279ace1dea00b588ae3d4054f614e24e" translate="yes" xml:space="preserve">
          <source>Module Scanf</source>
          <target state="translated">模块扫描f</target>
        </trans-unit>
        <trans-unit id="9aa3fa82fa6bc6d8e6dabdd6356bda9b0137aefa" translate="yes" xml:space="preserve">
          <source>Module Scanf.Scanning</source>
          <target state="translated">模块Scanf.Scanning</target>
        </trans-unit>
        <trans-unit id="93459bcb89eeedf8df411de000f7c2b7c9780503" translate="yes" xml:space="preserve">
          <source>Module Scanf: formatted input functions</source>
          <target state="translated">模块Scanf:格式化输入功能</target>
        </trans-unit>
        <trans-unit id="e539c5a64e74abf12fbc1f4b60209168d4716984" translate="yes" xml:space="preserve">
          <source>Module Semaphore</source>
          <target state="translated">模块语义器</target>
        </trans-unit>
        <trans-unit id="7688008138dadcacc66b763e30777b6d0d699616" translate="yes" xml:space="preserve">
          <source>Module Semaphore.Binary</source>
          <target state="translated">模块Semaphore.Binary</target>
        </trans-unit>
        <trans-unit id="6bd5cecccc783dc01eb0a29e9c5b25b59e399bba" translate="yes" xml:space="preserve">
          <source>Module Semaphore.Counting</source>
          <target state="translated">模块Semaphore.Counting</target>
        </trans-unit>
        <trans-unit id="7e1eab6a93a86c214bcaac7b7a7a9fa747c2741e" translate="yes" xml:space="preserve">
          <source>Module Semaphore: semaphores, another thread synchronization mechanism</source>
          <target state="translated">模块Semaphore:semaphores,另一种线程同步机制。</target>
        </trans-unit>
        <trans-unit id="f5360c938c49ae1cd63d56a4fc35fd3890f06a01" translate="yes" xml:space="preserve">
          <source>Module Seq</source>
          <target state="translated">模块序列</target>
        </trans-unit>
        <trans-unit id="745c27dde866b15642e25a8b7002225f218d5efe" translate="yes" xml:space="preserve">
          <source>Module Seq: functional iterators</source>
          <target state="translated">模块序列:功能迭代器</target>
        </trans-unit>
        <trans-unit id="2e0b5bb25d996e8a2a59e644edb186eb56df4a38" translate="yes" xml:space="preserve">
          <source>Module Set</source>
          <target state="translated">模块组</target>
        </trans-unit>
        <trans-unit id="67541933874b03516f40829e2167ebbae9f49f77" translate="yes" xml:space="preserve">
          <source>Module Set: sets over ordered types</source>
          <target state="translated">模块集:有序类型的集合</target>
        </trans-unit>
        <trans-unit id="eb15bed9d67a6d8605a1857d27cc2f85878fa8b5" translate="yes" xml:space="preserve">
          <source>Module Spacetime</source>
          <target state="translated">模块时空</target>
        </trans-unit>
        <trans-unit id="34b13666199abdbce5a1c2329aac36b498b7e871" translate="yes" xml:space="preserve">
          <source>Module Spacetime.Series</source>
          <target state="translated">模块Spacetime.系列</target>
        </trans-unit>
        <trans-unit id="4ed586d95f752bc00d8837393fbda372cb0681cb" translate="yes" xml:space="preserve">
          <source>Module Spacetime.Snapshot</source>
          <target state="translated">模块Spacetime.Snapshot</target>
        </trans-unit>
        <trans-unit id="c3ff8e88da485589309cef464360394198823612" translate="yes" xml:space="preserve">
          <source>Module Spacetime: memory profiler</source>
          <target state="translated">模块空间:内存剖析器</target>
        </trans-unit>
        <trans-unit id="49d4f336aa17896a5ff3ff9448ea7a4608c970ea" translate="yes" xml:space="preserve">
          <source>Module Stack</source>
          <target state="translated">模块栈</target>
        </trans-unit>
        <trans-unit id="ecef102202227813e5a4bf6e1e72dfe223f093c2" translate="yes" xml:space="preserve">
          <source>Module Stack: last-in first-out stacks</source>
          <target state="translated">模块堆栈:后进先出堆栈</target>
        </trans-unit>
        <trans-unit id="958de5433af391dd3de782eaa1308532356d8dda" translate="yes" xml:space="preserve">
          <source>Module StdLabels</source>
          <target state="translated">模块StdLabels</target>
        </trans-unit>
        <trans-unit id="5c6cfb9453daaec927ca632937f9ea620e55191b" translate="yes" xml:space="preserve">
          <source>Module StdLabels.Array</source>
          <target state="translated">模块StdLabels.Array</target>
        </trans-unit>
        <trans-unit id="18fabd24c30510aa2b8a03d1edb5b5d1ecd2653b" translate="yes" xml:space="preserve">
          <source>Module StdLabels.Bytes</source>
          <target state="translated">模块StdLabels.Bytes</target>
        </trans-unit>
        <trans-unit id="6d01f040c78ef0b845f05e2b484d4280c974e590" translate="yes" xml:space="preserve">
          <source>Module StdLabels.List</source>
          <target state="translated">模块StdLabels.List</target>
        </trans-unit>
        <trans-unit id="1cd5288d0fdc22e9eb53ef8ba091154cc4f412a2" translate="yes" xml:space="preserve">
          <source>Module StdLabels.String</source>
          <target state="translated">模块StdLabels.String</target>
        </trans-unit>
        <trans-unit id="6319cdcea700dd1fcd120036bbd03d1e43944c48" translate="yes" xml:space="preserve">
          <source>Module StdLabels: Include modules Array, List and String with labels</source>
          <target state="translated">模块StdLabels。包括带有标签的Array,List和String模块。</target>
        </trans-unit>
        <trans-unit id="d39a9c6c78d95bf885f759f67a81d80cda893b5f" translate="yes" xml:space="preserve">
          <source>Module StdLabels: include modules Array, List and String with labels</source>
          <target state="translated">模块StdLabels:包括带标签的Array、List和String模块。</target>
        </trans-unit>
        <trans-unit id="ec7ff76184d2e7ae3e758550a03699c6d8049bc7" translate="yes" xml:space="preserve">
          <source>Module Stdlib</source>
          <target state="translated">模块Stdlib</target>
        </trans-unit>
        <trans-unit id="2c4a0131cb2ed42ae1c9005e8a590e1a54091746" translate="yes" xml:space="preserve">
          <source>Module Stdlib: the initially opened module</source>
          <target state="translated">模块Stdlib:最初打开的模块</target>
        </trans-unit>
        <trans-unit id="c5e94b392b5c848b46e6e013f4fd8019d3c00a4e" translate="yes" xml:space="preserve">
          <source>Module Str</source>
          <target state="translated">模块结构</target>
        </trans-unit>
        <trans-unit id="7a5614285483e72abcf9faabc441c693739ffb77" translate="yes" xml:space="preserve">
          <source>Module Str: regular expressions and string processing</source>
          <target state="translated">模块Str:正则表达式和字符串处理</target>
        </trans-unit>
        <trans-unit id="7f7138e5bba47e7b41c63652637ee7a8b037bea0" translate="yes" xml:space="preserve">
          <source>Module Stream</source>
          <target state="translated">模块流</target>
        </trans-unit>
        <trans-unit id="a10278f414b080e077e13858c56aa56fde51bd41" translate="yes" xml:space="preserve">
          <source>Module Stream: streams and parsers</source>
          <target state="translated">模块流:流和解析器</target>
        </trans-unit>
        <trans-unit id="14ab9c78a29a26ab6d1cdf26aea5144a4e15f83e" translate="yes" xml:space="preserve">
          <source>Module String</source>
          <target state="translated">模块字符串</target>
        </trans-unit>
        <trans-unit id="70d219088316f00d44e6354f32e38b06be5fe6f8" translate="yes" xml:space="preserve">
          <source>Module String: string operations</source>
          <target state="translated">模块字符串:字符串操作</target>
        </trans-unit>
        <trans-unit id="cc3e85713ed5e07464558eda70637c5642cbf379" translate="yes" xml:space="preserve">
          <source>Module StringLabels</source>
          <target state="translated">模块StringLabels</target>
        </trans-unit>
        <trans-unit id="ac95abe374ec440091969c5ee120b8542ebb8f77" translate="yes" xml:space="preserve">
          <source>Module StringLabels: string operations (with labels)</source>
          <target state="translated">模块StringLabels:字符串操作(带标签)</target>
        </trans-unit>
        <trans-unit id="6d5b8544f315aab96f8817d79bb089eae9451184" translate="yes" xml:space="preserve">
          <source>Module Sys</source>
          <target state="translated">模块系统</target>
        </trans-unit>
        <trans-unit id="958984972bc48fce8fefbe326a85479ad724c6a0" translate="yes" xml:space="preserve">
          <source>Module Sys.Immediate64</source>
          <target state="translated">模块Sys.Immediate64</target>
        </trans-unit>
        <trans-unit id="629ea4ee2faa04c5bb6a3adf93e15571e0d8394e" translate="yes" xml:space="preserve">
          <source>Module Sys: system interface</source>
          <target state="translated">模块Sys:系统接口</target>
        </trans-unit>
        <trans-unit id="48051dde4d899f8ff82f4d3479ec93c3c7647b0f" translate="yes" xml:space="preserve">
          <source>Module Thread</source>
          <target state="translated">模块线程</target>
        </trans-unit>
        <trans-unit id="a862836a470588219a4249125bd8f10755fd16b0" translate="yes" xml:space="preserve">
          <source>Module Thread: lightweight threads</source>
          <target state="translated">模块线程:轻量级线程</target>
        </trans-unit>
        <trans-unit id="9156d38a7fa11dbaedc16f3d0706294aac2ebee0" translate="yes" xml:space="preserve">
          <source>Module ThreadUnix</source>
          <target state="translated">模块ThreadUnix</target>
        </trans-unit>
        <trans-unit id="a6798276f98df7d87c62baea2b0202dd5654a1c0" translate="yes" xml:space="preserve">
          <source>Module ThreadUnix: thread-compatible system calls</source>
          <target state="translated">模块ThreadUnix:线程兼容的系统调用。</target>
        </trans-unit>
        <trans-unit id="dd9e553dcec01d6ecdaeef8c6bce2f1ed535807c" translate="yes" xml:space="preserve">
          <source>Module Uchar</source>
          <target state="translated">模块Uchar</target>
        </trans-unit>
        <trans-unit id="61e8da370a37852b69424f5d308f6e8b6a190cbb" translate="yes" xml:space="preserve">
          <source>Module Uchar: Unicode characters</source>
          <target state="translated">Uchar模块。Unicode字符</target>
        </trans-unit>
        <trans-unit id="16ecb69a288aecc5495371b2c1779751b68e31b4" translate="yes" xml:space="preserve">
          <source>Module Unit</source>
          <target state="translated">模块股</target>
        </trans-unit>
        <trans-unit id="2ba1b1b3ef272d41eba2286920064169778f337d" translate="yes" xml:space="preserve">
          <source>Module Unit: unit values</source>
          <target state="translated">模块单位:单位价值</target>
        </trans-unit>
        <trans-unit id="1792b1adb6606ac02ca5a4965131d6116d82599a" translate="yes" xml:space="preserve">
          <source>Module Unix</source>
          <target state="translated">模块Unix</target>
        </trans-unit>
        <trans-unit id="68685cf371d09d0be037c8891fdbb041a6955bb4" translate="yes" xml:space="preserve">
          <source>Module Unix.LargeFile</source>
          <target state="translated">模块Unix.LargeFile</target>
        </trans-unit>
        <trans-unit id="c09a1e52642105e9e7b0b8457efac3458d40b0f0" translate="yes" xml:space="preserve">
          <source>Module Unix: Unix system calls</source>
          <target state="translated">模块Unix。Unix系统调用</target>
        </trans-unit>
        <trans-unit id="e446500e934433078817abf2e14140a9f2567531" translate="yes" xml:space="preserve">
          <source>Module UnixLabels</source>
          <target state="translated">模块UnixLabels</target>
        </trans-unit>
        <trans-unit id="29d97bc7771ac286b2f7fa8d869eb8a2a0f2e806" translate="yes" xml:space="preserve">
          <source>Module UnixLabels.LargeFile</source>
          <target state="translated">模块UnixLabels.LargeFile</target>
        </trans-unit>
        <trans-unit id="bbc3a336379a1ab64349969278912adaf93249f4" translate="yes" xml:space="preserve">
          <source>Module UnixLabels: Labeled Unix system calls</source>
          <target state="translated">模块UnixLabels。标签化的Unix系统调用</target>
        </trans-unit>
        <trans-unit id="d87aa68b013503ed8844fab06b1f94a6cf80b676" translate="yes" xml:space="preserve">
          <source>Module Weak</source>
          <target state="translated">模块弱点</target>
        </trans-unit>
        <trans-unit id="c0fbea6de11552e58adf74acc30f65573ee8b35b" translate="yes" xml:space="preserve">
          <source>Module Weak: arrays of weak pointers</source>
          <target state="translated">弱模块:弱指针数组。</target>
        </trans-unit>
        <trans-unit id="331d2760734f7e482dfad8fe98cac289cb021696" translate="yes" xml:space="preserve">
          <source>Module expressions are the module-level equivalent of value expressions: they evaluate to modules, thus providing implementations for the specifications expressed in module types.</source>
          <target state="translated">模块表达式相当于模块级的值表达式:它们评估到模块,从而为模块类型表达的规范提供了实现。</target>
        </trans-unit>
        <trans-unit id="bbd0d4a8e429ad9704ed8561d8b8ccf363cf691b" translate="yes" xml:space="preserve">
          <source>Module type Ephemeron.S</source>
          <target state="translated">模块类型 Ephemeron.S</target>
        </trans-unit>
        <trans-unit id="5ba5bbb64dc581113ae02747f71e2e95524ad670" translate="yes" xml:space="preserve">
          <source>Module type Ephemeron.SeededS</source>
          <target state="translated">模块类型 Ephemeron.SeededS</target>
        </trans-unit>
        <trans-unit id="e7fc3d9e09cfcef4e28717f43e53f614492c4a07" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.HashedType</source>
          <target state="translated">模块类型:Hashtbl.HashedType</target>
        </trans-unit>
        <trans-unit id="553e3c5393f8ee87abd320792f53df0480a89437" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.S</source>
          <target state="translated">模块类型 Hashtbl.S</target>
        </trans-unit>
        <trans-unit id="d4f4885e8e252ac679a71b98e38ae6b36bec3794" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.SeededHashedType</source>
          <target state="translated">模块类型Hashtbl.SeededHashedType。</target>
        </trans-unit>
        <trans-unit id="19a7fd61f14defb9b6e4cfd12105dcf424fb68dc" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.SeededS</source>
          <target state="translated">模块类型 Hashtbl.SeededS</target>
        </trans-unit>
        <trans-unit id="c3a914203d81a68cd8f34d38dd3525c65fb9c5ba" translate="yes" xml:space="preserve">
          <source>Module type Map.OrderedType</source>
          <target state="translated">模块类型Map.OrderedType</target>
        </trans-unit>
        <trans-unit id="d326bc02f7f0598bde27deba9a371a4e51379f13" translate="yes" xml:space="preserve">
          <source>Module type Map.S</source>
          <target state="translated">模块类型Map.S</target>
        </trans-unit>
        <trans-unit id="d9f4fc879c6159477aa40865bb89618115962c18" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.HashedType</source>
          <target state="translated">模块类型 MoreLabels.Hashtbl.HashedType。</target>
        </trans-unit>
        <trans-unit id="fac1d1343fd73a7f1801158d9ea0bc13f5f2438e" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.S</source>
          <target state="translated">模块类型 MoreLabels.Hashtbl.S</target>
        </trans-unit>
        <trans-unit id="227008c4795726cb8535f817b67718075184d4b4" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.SeededHashedType</source>
          <target state="translated">模块类型 MoreLabels.Hashtbl.SeededHashedType。</target>
        </trans-unit>
        <trans-unit id="378116ae1fbf467ddaea54a32b51349c6761a1c1" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.SeededS</source>
          <target state="translated">模块类型MoreLabels.Hashtbl.SeededS型</target>
        </trans-unit>
        <trans-unit id="3ae291b8f1ed6643e66aaa62f2bc341a327d4675" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Map.OrderedType</source>
          <target state="translated">模块类型MoreLabels.Map.OrderedType。</target>
        </trans-unit>
        <trans-unit id="7154f17264fbac973b9fa0370b2c6d6369cde11d" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Map.S</source>
          <target state="translated">模块类型 MoreLabels.Map.S</target>
        </trans-unit>
        <trans-unit id="a999b8bf8010daee6d4715724a5de3c63e349192" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Set.OrderedType</source>
          <target state="translated">模块类型MoreLabels.Set.OrderedType。</target>
        </trans-unit>
        <trans-unit id="10f02d0b490b6bd1c3b28accd09985393baabab9" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Set.S</source>
          <target state="translated">模块类型 MoreLabels.Set.S</target>
        </trans-unit>
        <trans-unit id="05df05949b4417b3b5d633c96eec842e5cc5a73c" translate="yes" xml:space="preserve">
          <source>Module type Set.OrderedType</source>
          <target state="translated">模块类型 Set.OrderedType</target>
        </trans-unit>
        <trans-unit id="0540217cacc40a66bb6b0dcbe128de08a49bb684" translate="yes" xml:space="preserve">
          <source>Module type Set.S</source>
          <target state="translated">模块类型 Set.S</target>
        </trans-unit>
        <trans-unit id="6682efa59e414919e3f347ffa12dbd5a9ef7d4b0" translate="yes" xml:space="preserve">
          <source>Module type Sys.Immediate64.Immediate</source>
          <target state="translated">模块类型 Sys.Immediate64.Immediate</target>
        </trans-unit>
        <trans-unit id="c6a12e0efd39177b624b9104a3d6be80c5fdf8d7" translate="yes" xml:space="preserve">
          <source>Module type Sys.Immediate64.Non_immediate</source>
          <target state="translated">模块类型 Sys.Immediate64.Non_immediate。</target>
        </trans-unit>
        <trans-unit id="4946361a74879d2b9ef81babbb5a11b0fd75747a" translate="yes" xml:space="preserve">
          <source>Module type Weak.S</source>
          <target state="translated">模块类型弱.S</target>
        </trans-unit>
        <trans-unit id="e18ca9fec937a1c5383f1670e1007cb899397310" translate="yes" xml:space="preserve">
          <source>Module types</source>
          <target state="translated">模块类型</target>
        </trans-unit>
        <trans-unit id="c5882558195a629df9610d22ab7a2bb696dfa08e" translate="yes" xml:space="preserve">
          <source>Module types are the module-level equivalent of type expressions: they specify the general shape and type properties of modules.</source>
          <target state="translated">模块类型相当于模块级的类型表达式:它们规定了模块的一般形状和类型属性。</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="1bdeaa58662002456132d5e4df075bf678e694ae" translate="yes" xml:space="preserve">
          <source>Modules are typically thought of as static components. This extension makes it possible to pack a module as a first-class value, which can later be dynamically unpacked into a module.</source>
          <target state="translated">模块通常被认为是静态组件。这个扩展可以将一个模块打包成一个一级值,以后可以动态地解包成一个模块。</target>
        </trans-unit>
        <trans-unit id="bb3f2d6730fda28eebf828a1b5d994ee25cda13c" translate="yes" xml:space="preserve">
          <source>Month of year 0..11</source>
          <target state="translated">年月0...11</target>
        </trans-unit>
        <trans-unit id="7368e316821f8931f19a457402e063b7f5ee9a7c" translate="yes" xml:space="preserve">
          <source>More character operations are provided in module &lt;a href=&quot;char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt;模块中提供了更多字符操作。</target>
        </trans-unit>
        <trans-unit id="b7bfe303800e6bfff75b4a2a864eabaac9c1ba04" translate="yes" xml:space="preserve">
          <source>More complex standalone OCaml programs are typically composed of multiple source files, and can link with precompiled libraries. Chapters &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &amp;zwj;&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; explain how to use the batch compilers ocamlc and ocamlopt. Recompilation of multi-file OCaml projects can be automated using third-party build systems, such as &lt;a href=&quot;https://github.com/ocaml/dune&quot;&gt;dune&lt;/a&gt;.</source>
          <target state="translated">更复杂的独立OCaml程序通常由多个源文件组成，并且可以与预编译的库链接。章&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;和&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;解释如何使用批处理编译器ocamlc和ocamlopt。可以使用第三方构建系统（例如&lt;a href=&quot;https://github.com/ocaml/dune&quot;&gt;dune）&lt;/a&gt;自动重新编译OCaml项目的多文件。</target>
        </trans-unit>
        <trans-unit id="98c4048d66ba3c4b91263b34fa74fb272d60a783" translate="yes" xml:space="preserve">
          <source>More complex standalone OCaml programs are typically composed of multiple source files, and can link with precompiled libraries. Chapters &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; explain how to use the batch compilers ocamlc and ocamlopt. Recompilation of multi-file OCaml projects can be automated using third-party build systems, such as the &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;ocamlbuild&lt;/a&gt; compilation manager.</source>
          <target state="translated">更复杂的独立OCaml程序通常由多个源文件组成，并且可以与预编译的库链接。章&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;和&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;解释如何使用批处理编译器ocamlc和ocamlopt。多文件OCaml项目的重新编译可以使用第三方构建系统（例如&lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;ocamlbuild&lt;/a&gt;编译管理器）自动进行。</target>
        </trans-unit>
        <trans-unit id="b78f1fdb280b815afafea05758a2cf808b129b60" translate="yes" xml:space="preserve">
          <source>More examples of binary methods can be found in sections &amp;zwj;&lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt; and &amp;zwj;&lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;.</source>
          <target state="translated">二进制方法的更多例子可以在章节中找到&lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;和&lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="561b0023eb18eba22354cdb393742a8b59c73c03" translate="yes" xml:space="preserve">
          <source>More examples of binary methods can be found in sections &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt; and &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;和&lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;节中可以找到更多关于二进制方法的示例。</target>
        </trans-unit>
        <trans-unit id="51d19b2b2f97ccba7609ee2b5ad377c0b117b048" translate="yes" xml:space="preserve">
          <source>More formatters can be created with &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_buffer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;format#VALformatter_of_symbolic_output_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_symbolic_output_buffer&lt;/code&gt;&lt;/a&gt; or using &lt;a href=&quot;format#formatter&quot;&gt;custom formatters&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt; &lt;code&gt;Format.formatter_of_buffer&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;format#VALformatter_of_symbolic_output_buffer&quot;&gt; &lt;code&gt;Format.formatter_of_symbolic_output_buffer&lt;/code&gt; &lt;/a&gt;或使用&lt;a href=&quot;format#formatter&quot;&gt;自定义格式化&lt;/a&gt;程序来创建更多格式化程序。</target>
        </trans-unit>
        <trans-unit id="6948d057e07078f31d8b94099955db506d318be0" translate="yes" xml:space="preserve">
          <source>More generally, as soon as a type variable appears in a position describing mutable state it becomes invariant. As a corollary, covariant variables will never denote mutable locations and can be safely generalized. For a better description, interested readers can consult the original article by Jacques Garrigue on &lt;a href=&quot;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&quot;&gt;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&lt;/a&gt;</source>
          <target state="translated">更一般地，一旦类型变量出现在描述可变状态的位置，它就变成不变的。作为必然结果，协变变量将永远不会表示可变位置，并且可以安全地进行概括。为了获得更好的描述，有兴趣的读者可以在&lt;a href=&quot;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&quot;&gt;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&lt;/a&gt;上参考Jacques Garrigue的原始文章</target>
        </trans-unit>
        <trans-unit id="c805dcb67ff19c680fa8d577587f09aa3b1df1b0" translate="yes" xml:space="preserve">
          <source>More important is the fact that polymorphic variants, while being type-safe, result in a weaker type discipline. That is, core language variants do actually much more than ensuring type-safety, they also check that you use only declared constructors, that all constructors present in a data-structure are compatible, and they enforce typing constraints to their parameters.</source>
          <target state="translated">更重要的是,多态变体虽然是类型安全的,但会导致类型纪律较弱。也就是说,核心语言变体的作用其实远不止确保类型安全,它们还检查你是否只使用已声明的构造函数,是否存在于数据结构中的所有构造函数都是兼容的,并且它们对其参数实施类型约束。</target>
        </trans-unit>
        <trans-unit id="e832f6beb4577f420972cdf48bcfee3bb6d20aec" translate="yes" xml:space="preserve">
          <source>More list operations are provided in module &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;模块中提供了更多列表操作。</target>
        </trans-unit>
        <trans-unit id="e0c233b3a7dba4306b68b837cdcd9f763220099a" translate="yes" xml:space="preserve">
          <source>More precisely, consider the expression:</source>
          <target state="translated">更准确的说,请考虑这样的表述:</target>
        </trans-unit>
        <trans-unit id="2403a8574f06c5e570469506e110ecacf6fc95f8" translate="yes" xml:space="preserve">
          <source>More precisely: when a semantic tag is opened or closed then both and successive 'tag-printing' and 'tag-marking' operations occur:</source>
          <target state="translated">更准确地说:当一个语义标签被打开或关闭时,那么同时和连续的 &quot;标签打印 &quot;和 &quot;标签标记 &quot;操作就会发生。</target>
        </trans-unit>
        <trans-unit id="f9eabc59e9a2d75ca1154fdc14a5cb14b6f18138" translate="yes" xml:space="preserve">
          <source>More string operations are provided in module &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">模块&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;中提供了更多字符串操作。</target>
        </trans-unit>
        <trans-unit id="20302dcfb13e0aacdfb918a9998d06e11ec681a9" translate="yes" xml:space="preserve">
          <source>MoreLabels</source>
          <target state="translated">MoreLabels</target>
        </trans-unit>
        <trans-unit id="f2d9c7352bab5b013f1b4948abc890b999a592c8" translate="yes" xml:space="preserve">
          <source>Moreover, being the last defined type is a quite unstable position that may change surreptitiously after adding or moving around a type definition, or after opening a module (see chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;). Consequently, adding explicit type annotations to guide disambiguation is more robust than relying on the last defined type disambiguation.</source>
          <target state="translated">此外，最后定义的类型是一个非常不稳定的位置，在添加或移动类型定义后或打开模块后，该位置可能会秘密更改（请参见第&lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;章）。因此，添加显式类型注释以指导歧义消除比依赖于最后定义的类型歧义消除更鲁棒。</target>
        </trans-unit>
        <trans-unit id="b575cbbaf8906b9c5a5ee4c9f1a89643a318a7a5" translate="yes" xml:space="preserve">
          <source>Moreover, opening a box after the &lt;a href=&quot;format#maxindent&quot;&gt;maximum indentation limit&lt;/a&gt; splits the line whether or not the box would end up fitting on the line.</source>
          <target state="translated">此外，在&lt;a href=&quot;format#maxindent&quot;&gt;最大缩进极限&lt;/a&gt;之后打开盒子会分割线，无论盒子最终是否适合该线。</target>
        </trans-unit>
        <trans-unit id="4bacee78a2fc3a758d3d73b2a613831022d03403" translate="yes" xml:space="preserve">
          <source>Moreover, the table shouldn't be modified during a call to &lt;code&gt;iter&lt;/code&gt;. Use &lt;code&gt;filter_map_inplace&lt;/code&gt; in this case.</source>
          <target state="translated">此外，在调用 &lt;code&gt;iter&lt;/code&gt; 的过程中不应修改表。在这种情况下，请使用 &lt;code&gt;filter_map_inplace&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="938a8c4d2e6fe32d5784eafdd62df55fa7c40576" translate="yes" xml:space="preserve">
          <source>Moreover, weak types cannot appear in the signature of toplevel modules: types must be known at compilation time. Otherwise, different compilation units could replace the weak type with different and incompatible types. For this reason, compiling the following small piece of code</source>
          <target state="translated">此外,弱类型不能出现在toplevel模块的签名中:类型必须在编译时已知。否则,不同的编译单元可能会用不同的、不兼容的类型来替换弱类型。基于这个原因,编译以下一小段代码</target>
        </trans-unit>
        <trans-unit id="3770beeb0150f7b961905b2a3287d7d10a959428" translate="yes" xml:space="preserve">
          <source>Moreover, when the type definitions are exposed, the type checker is able to infer variance information on its own and one can benefit from the relaxed value restriction even unknowingly. However, this is not the case anymore when defining new abstract types. As an illustration, we can define a module type collection as:</source>
          <target state="translated">此外,当类型定义暴露时,类型检查器能够自行推断出差异信息,人们即使在不知情的情况下也能从放宽的值限制中获益。然而,在定义新的抽象类型时,情况就不是这样了。作为一个例子,我们可以将一个模块类型集合定义为:。</target>
        </trans-unit>
        <trans-unit id="ce25d2287fa6866cf43b250692213d18a00fc939" translate="yes" xml:space="preserve">
          <source>Most functions in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module come in two variants: a short version that operates on &lt;a href=&quot;format#VALstd_formatter&quot;&gt;&lt;code&gt;Format.std_formatter&lt;/code&gt;&lt;/a&gt; and the generic version prefixed by &lt;code&gt;pp_&lt;/code&gt; that takes a formatter as its first argument.</source>
          <target state="translated">&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;模块中的大多数函数有两个变体：在&lt;a href=&quot;format#VALstd_formatter&quot;&gt; &lt;code&gt;Format.std_formatter&lt;/code&gt; &lt;/a&gt;上运行的简短版本和以 &lt;code&gt;pp_&lt;/code&gt; 为前缀的通用版本，该通用版本以格式化程序作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="60ca906dcdb56968f58923bddaabb17961cb58f1" translate="yes" xml:space="preserve">
          <source>Multi-index are also supported through a second variant of indexing operators</source>
          <target state="translated">多索引也是通过第二个变体的索引操作符来支持的。</target>
        </trans-unit>
        <trans-unit id="ac17c3be367cdf7b78ca9f7d7c50f262d3737c1d" translate="yes" xml:space="preserve">
          <source>Multiple inheritance is allowed. Only the last definition of a method is kept: the redefinition in a subclass of a method that was visible in the parent class overrides the definition in the parent class. Previous definitions of a method can be reused by binding the related ancestor. Below, super is bound to the ancestor printable_point. The name super is a pseudo value identifier that can only be used to invoke a super-class method, as in super#print.</source>
          <target state="translated">允许多重继承。只保留方法的最后一个定义:在父类中可见的方法的子类中的重新定义会覆盖父类中的定义。一个方法的前一个定义可以通过绑定相关的祖先来重用。下面,super被绑定到祖先printable_point上。名字super是一个伪值标识符,只能用于调用超级类方法,如super#print。</target>
        </trans-unit>
        <trans-unit id="de3d99d65d2f00ba5445685c943974a51e9484a3" translate="yes" xml:space="preserve">
          <source>Multiple levels of packing can be achieved by combining -pack with -for-pack. Consider the following example:</source>
          <target state="translated">通过结合-pack和-for-pack,可以实现多级打包。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="549313c817d85e3b3f930b86928b72bbc44715d8" translate="yes" xml:space="preserve">
          <source>Multiplication.</source>
          <target state="translated">Multiplication.</target>
        </trans-unit>
        <trans-unit id="0d9a3f742b2bc9ffe56449aed4b901aa2ce9a0f4" translate="yes" xml:space="preserve">
          <source>Multiplicative inverse (&lt;code&gt;1/z&lt;/code&gt;).</source>
          <target state="translated">乘法逆（ &lt;code&gt;1/z&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bd2b0f087b02e413546a53c4f93f4cdf1581cc30" translate="yes" xml:space="preserve">
          <source>Mutex</source>
          <target state="translated">Mutex</target>
        </trans-unit>
        <trans-unit id="ff8d388bea0cae09717df1b41a4b4c493e6970fa" translate="yes" xml:space="preserve">
          <source>Mutexes (mutual-exclusion locks) are used to implement critical sections and protect shared mutable data structures against concurrent accesses. The typical use is (if &lt;code&gt;m&lt;/code&gt; is the mutex associated with the data structure &lt;code&gt;D&lt;/code&gt;):</source>
          <target state="translated">互斥锁（互斥锁）用于实现关键部分并保护共享的可变数据结构免受并发访问。典型的用法是（如果 &lt;code&gt;m&lt;/code&gt; 是与数据结构 &lt;code&gt;D&lt;/code&gt; 关联的互斥锁）：</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="e353e4d6aad1380c87ec233564134a4a344dffe7" translate="yes" xml:space="preserve">
          <source>Name of service or port number</source>
          <target state="translated">服务名称或端口号</target>
        </trans-unit>
        <trans-unit id="ae264d14a11c34ace5fbb1bb8a6dd75bfdb17d89" translate="yes" xml:space="preserve">
          <source>Name or IP address of host</source>
          <target state="translated">主机的名称或IP地址</target>
        </trans-unit>
        <trans-unit id="549333ca0fbff4a493ab5e0bc0f95428f0fc7de0" translate="yes" xml:space="preserve">
          <source>Name space</source>
          <target state="translated">名称空间</target>
        </trans-unit>
        <trans-unit id="756b76addd8adeb70cb127b2a93c3fa37d752c2d" translate="yes" xml:space="preserve">
          <source>Name the output files prefix.ml, prefix.mli, prefix.output, instead of the default naming convention.</source>
          <target state="translated">命名输出文件 prefix.ml、prefix.mli、prefix.output,而不是默认的命名习惯。</target>
        </trans-unit>
        <trans-unit id="8c095b2219367daec6dcc1e5087ff4061bfc41c9" translate="yes" xml:space="preserve">
          <source>Named pipe</source>
          <target state="translated">名管</target>
        </trans-unit>
        <trans-unit id="296294d67daa5c2f7bd477f7158b245e13beb631" translate="yes" xml:space="preserve">
          <source>Namely, the inferred remaining case is Some _, which is split into Some (Int, _) and Some (Bool, _), which are both untypable because deep expects a non-existing char t as the first element of the tuple. Note that the refutation case could be omitted here, because it is automatically added when there is only one case in the pattern matching.</source>
          <target state="translated">即,推理剩下的情况是Some _,它被拆分为Some (Int,_)和Some (Bool,_),这两种情况都是不可类型化的,因为deep期望一个不存在的char t作为元组的第一个元素。注意,这里可以省略反驳情况,因为当模式匹配中只有一个情况时,会自动添加。</target>
        </trans-unit>
        <trans-unit id="e162aabfb0fa43d82b67a374234c4cb74d9be965" translate="yes" xml:space="preserve">
          <source>Names that are defined as abstract types in a signature can be implemented in a matching structure by any kind of type definition (provided it has the same number of type parameters). The exact implementation of the type will be hidden to the users of the structure. In particular, if the type is implemented as a variant type or record type, the associated constructors and fields will not be accessible to the users; if the type is implemented as an abbreviation, the type equality between the type name and the right-hand side of the abbreviation will be hidden from the users of the structure. Users of the structure consider that type as incompatible with any other type: a fresh type has been generated.</source>
          <target state="translated">在签名中被定义为抽象类型的名称可以通过任何类型定义在匹配结构中实现(只要它有相同数量的类型参数)。类型的具体实现将对结构的用户隐藏。特别是,如果该类型被实现为变体类型或记录类型,那么相关的构造函数和字段将不被用户访问;如果该类型被实现为缩写,那么类型名和缩写右边的类型平等将被结构的用户隐藏。该结构的用户认为该类型与任何其他类型不兼容:一个新的类型已经生成。</target>
        </trans-unit>
        <trans-unit id="9e848993d9abd7bcd0da1a886c50f6a34ca40770" translate="yes" xml:space="preserve">
          <source>Naming labels come in two flavours: &lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt; for normal arguments and &lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt; for optional ones. They are simply distinguished by their first character, either ~ or ?.</source>
          <target state="translated">命名标签有两种：正常参数的&lt;a href=&quot;#label&quot;&gt;标签&lt;/a&gt;和可选参数的&lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt;。它们仅通过第一个字符〜或？来区分。</target>
        </trans-unit>
        <trans-unit id="be64c74e17dde72651549865ed8544a38961913d" translate="yes" xml:space="preserve">
          <source>Nativeint</source>
          <target state="translated">Nativeint</target>
        </trans-unit>
        <trans-unit id="6121887e44c8bb72f2cd96f891df9010238c7905" translate="yes" xml:space="preserve">
          <source>Nativeint_val(v) returns the long integer contained in the nativeintv.</source>
          <target state="translated">Nativeint_val(v)返回 nativeintv 中包含的长整数。</target>
        </trans-unit>
        <trans-unit id="fe99dc11adcd3f4c5eeceb4413e82bcd56b5ef61" translate="yes" xml:space="preserve">
          <source>Natural logarithm (in base &lt;code&gt;e&lt;/code&gt;).</source>
          <target state="translated">自然对数（以 &lt;code&gt;e&lt;/code&gt; 为底）。</target>
        </trans-unit>
        <trans-unit id="2f187f5dc4cb75173c53a77254bdd4b7078911c3" translate="yes" xml:space="preserve">
          <source>Natural logarithm.</source>
          <target state="translated">自然对数。</target>
        </trans-unit>
        <trans-unit id="b710ee6a1b2df5b06e260b4de6bc7921f957917e" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(=)&quot;&gt;&lt;code&gt;(=)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">取反&lt;a href=&quot;stdlib#VAL(=)&quot;&gt; &lt;code&gt;(=)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8919121a4837a7384f394582f637a0af70744796" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(=)&quot;&gt;&lt;code&gt;(=)&lt;/code&gt;&lt;/a&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">取反&lt;a href=&quot;stdlib#VAL(=)&quot;&gt; &lt;code&gt;(=)&lt;/code&gt; &lt;/a&gt;。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9befaab36628d9f7863760f1639c08f6661eaa9f" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(==)&quot;&gt;&lt;code&gt;(==)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">取反&lt;a href=&quot;stdlib#VAL(==)&quot;&gt; &lt;code&gt;(==)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4f78c719756b0216b5efd59f9661b9e8b62f6c6" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(==)&quot;&gt;&lt;code&gt;(==)&lt;/code&gt;&lt;/a&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">取反&lt;a href=&quot;stdlib#VAL(==)&quot;&gt; &lt;code&gt;(==)&lt;/code&gt; &lt;/a&gt;。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77f939047f0ba0a97a64071a5a435763eb58f7bd" translate="yes" xml:space="preserve">
          <source>Negative infinity.</source>
          <target state="translated">负无穷大。</target>
        </trans-unit>
        <trans-unit id="8ba9abe745a8f0e4e877cc69abc52cdee83e48b7" translate="yes" xml:space="preserve">
          <source>Network dropped connection on reset</source>
          <target state="translated">复位时网络掉线</target>
        </trans-unit>
        <trans-unit id="ea849e260b8735345217e4f53f113c9fcde5b394" translate="yes" xml:space="preserve">
          <source>Network is down</source>
          <target state="translated">网络瘫痪</target>
        </trans-unit>
        <trans-unit id="d34a1412dd6535ceabe7960d72728113a96b875c" translate="yes" xml:space="preserve">
          <source>Network is unreachable</source>
          <target state="translated">网络无法连接</target>
        </trans-unit>
        <trans-unit id="c006cf01dc92514d04743559daf156d417fe5f82" translate="yes" xml:space="preserve">
          <source>New applications that need arbitrary-precision arithmetic should use the Zarith library (&lt;a href=&quot;https://github.com/ocaml/Zarith&quot;&gt;https://github.com/ocaml/Zarith&lt;/a&gt;) instead of the Num library, and older applications that already use Num are encouraged to switch to Zarith. Zarith delivers much better performance than Num and has a nicer API.</source>
          <target state="translated">需要任意精度算术的新应用程序应使用Zarith库（&lt;a href=&quot;https://github.com/ocaml/Zarith&quot;&gt;https://github.com/ocaml/Zarith&lt;/a&gt;）代替Num库，鼓励已使用Num的旧应用程序切换到Zarith。Zarith提供了比Num更好的性能，并且具有更好的API。</target>
        </trans-unit>
        <trans-unit id="280be44a9152ebadb2bdb39840c63ece14ec70f7" translate="yes" xml:space="preserve">
          <source>New variant type or record type: no equation, a representation.</source>
          <target state="translated">新的变种类型或记录类型:没有等式,是一种表示方法。</target>
        </trans-unit>
        <trans-unit id="7e1039fc69f9291b60d0860a59005e4bab261192" translate="yes" xml:space="preserve">
          <source>Next, we run the program under afl-fuzz:</source>
          <target state="translated">接下来,我们在 afl-fuzz 下运行程序。</target>
        </trans-unit>
        <trans-unit id="2981f6fc6fe648e38aa58e8e417c3c2d93457ab6" translate="yes" xml:space="preserve">
          <source>No attempt has been made at mathematical rigor: words are employed with their intuitive meaning, without further definition. As a consequence, the typing rules have been left out, by lack of the mathematical framework required to express them, while they are definitely part of a full formal definition of the language.</source>
          <target state="translated">没有尝试过数学上的严格性:单词的使用是凭直觉,没有进一步的定义。因此,由于缺乏表达这些规则所需的数学框架,类型规则被排除在外,而这些规则无疑是语言的完整正式定义的一部分。</target>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="translated">没有可用的缓冲空间</target>
        </trans-unit>
        <trans-unit id="aa02cb7a520e805604b436b26d2e3b0230ac3573" translate="yes" xml:space="preserve">
          <source>No child process</source>
          <target state="translated">无子女程序</target>
        </trans-unit>
        <trans-unit id="4b716f8eaa691d689900e51bfb7cf3470f97f3d4" translate="yes" xml:space="preserve">
          <source>No coeffects:</source>
          <target state="translated">不受影响。</target>
        </trans-unit>
        <trans-unit id="4e0b86ee8d4ae90b6347fb23a23aee01ef7d1ad2" translate="yes" xml:space="preserve">
          <source>No effects:</source>
          <target state="translated">无影响。</target>
        </trans-unit>
        <trans-unit id="ac84bf2f78b29d7fcdb0dbd9e9503065301a53a2" translate="yes" xml:space="preserve">
          <source>No locks available</source>
          <target state="translated">无锁</target>
        </trans-unit>
        <trans-unit id="62c6526007299ca03f778b5b7ce0d726354cae0d" translate="yes" xml:space="preserve">
          <source>No route to host</source>
          <target state="translated">没有通往主机的路线</target>
        </trans-unit>
        <trans-unit id="5c0580667d6055e92a026b8c67fa943060b2c89d" translate="yes" xml:space="preserve">
          <source>No space left on device</source>
          <target state="translated">设备上没有剩余空间</target>
        </trans-unit>
        <trans-unit id="7e7d314f83d9dd80d3f3a1d2cf49d2c2861bf468" translate="yes" xml:space="preserve">
          <source>No string in the result contains the &lt;code&gt;sep&lt;/code&gt; character.</source>
          <target state="translated">结果中没有字符串包含 &lt;code&gt;sep&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="e5feee0204f5532e0cb04d5be298f4c467c05e6f" translate="yes" xml:space="preserve">
          <source>No such device</source>
          <target state="translated">没有这种装置</target>
        </trans-unit>
        <trans-unit id="112765ee706d5c7ea20d7309d6bf892b8a5aa7eb" translate="yes" xml:space="preserve">
          <source>No such device or address</source>
          <target state="translated">没有这种设备或地址</target>
        </trans-unit>
        <trans-unit id="8a6cb568f806ffae868a77b519003a5df95ec0c3" translate="yes" xml:space="preserve">
          <source>No such file or directory</source>
          <target state="translated">没有这样的文件或目录</target>
        </trans-unit>
        <trans-unit id="0cf4a772e5ca24befae7ddee66e425eeaa8130aa" translate="yes" xml:space="preserve">
          <source>No such process</source>
          <target state="translated">没有这种程序</target>
        </trans-unit>
        <trans-unit id="db516bd236f8b19cb9f7f134b81fc52a48b48cab" translate="yes" xml:space="preserve">
          <source>Non-Flambda versions of the compiler cannot inline functions that contain a definition of another function. However -Oclassic does permit this. Further, non-Flambda versions also cannot inline functions that are only themselves exposed as a result of a previous pass of inlining, but again this is permitted by -Oclassic. For example:</source>
          <target state="translated">非Flambda版本的编译器不能内联包含另一个函数定义的函数。然而-Oclassic允许这样做。此外,非Flambda版本也不能内联那些只在前一次内联的结果中暴露出来的函数,但是-Oclassic同样允许这样做。例如:-Oclassic</target>
        </trans-unit>
        <trans-unit id="5a7fec4c0093183b651e94da8602d12888a9798d" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;a href=&quot;event#VALsync&quot;&gt;&lt;code&gt;Event.sync&lt;/code&gt;&lt;/a&gt;: offer all the communication possibilities specified in the event to the outside world, and if one can take place immediately, perform it and return &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is the result value of that communication.</source>
          <target state="translated">&lt;a href=&quot;event#VALsync&quot;&gt; &lt;code&gt;Event.sync&lt;/code&gt; &lt;/a&gt;的非阻塞版本：将事件中指定的所有通信可能性提供给外界，如果可以立即进行，请执行并返回 &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; ，其中 &lt;code&gt;r&lt;/code&gt; 是该通信的结果值。</target>
        </trans-unit>
        <trans-unit id="e1c495fe7e42478c735910f07114d91295ddc81f" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;a href=&quot;event#VALsync&quot;&gt;&lt;code&gt;Event.sync&lt;/code&gt;&lt;/a&gt;: offer all the communication possibilities specified in the event to the outside world, and if one can take place immediately, perform it and return &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is the result value of that communication. Otherwise, return &lt;code&gt;None&lt;/code&gt; without blocking.</source>
          <target state="translated">&lt;a href=&quot;event#VALsync&quot;&gt; &lt;code&gt;Event.sync&lt;/code&gt; &lt;/a&gt;的非阻塞版本：将事件中指定的所有通信可能性提供给外界，如果可以立即进行，请执行并返回 &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; ，其中 &lt;code&gt;r&lt;/code&gt; 是该通信的结果值。否则，返回 &lt;code&gt;None&lt;/code&gt; 而不会阻塞。</target>
        </trans-unit>
        <trans-unit id="f7955c5f7147285808f393b0a2f015ae8bfdf418" translate="yes" xml:space="preserve">
          <source>Non-generalized type variables in a type cause no difficulties inside a given structure or compilation unit (the contents of a .ml file, or an interactive session), but they cannot be allowed inside signatures nor in compiled interfaces (.cmi file), because they could be used inconsistently later. Therefore, the compiler flags an error when a structure or compilation unit defines a value name whose type contains non-generalized type variables. There are two ways to fix this error:</source>
          <target state="translated">类型中的非通用类型变量在给定的结构或编译单元(.ml文件的内容,或交互式会话)中不会造成任何困难,但在签名或编译接口(.cmi文件)中不能允许它们,因为它们可能在以后被不一致地使用。因此,当一个结构或编译单元定义了一个类型包含非泛型类型变量的值名时,编译器会标记一个错误。有两种方法可以解决这个错误。</target>
        </trans-unit>
        <trans-unit id="74b76795e362f5a2898817253827ed1f46066a45" translate="yes" xml:space="preserve">
          <source>Non-principal type.</source>
          <target state="translated">非主要类型。</target>
        </trans-unit>
        <trans-unit id="552623d2d3482ef2ceb23ffcc0f0d612c140eb4c" translate="yes" xml:space="preserve">
          <source>Non-regular recursive algebraic data types correspond to polymorphic algebraic data types whose parameter types vary between the left and right side of the type definition. For instance, it might be interesting to define a datatype that ensures that all lists are nested at the same depth:</source>
          <target state="translated">非规则递归代数数据类型对应于多态代数数据类型,其参数类型在类型定义的左右两边有所不同。例如,定义一个数据类型可能是有趣的,它可以确保所有的列表都嵌套在相同的深度。</target>
        </trans-unit>
        <trans-unit id="4722a32b4738403c181ac5e3a12ee6eb896bca7c" translate="yes" xml:space="preserve">
          <source>Non-returning statement.</source>
          <target state="translated">不返回的声明。</target>
        </trans-unit>
        <trans-unit id="187ac81e9effe553285ccadbb88b811d43fd0c04" translate="yes" xml:space="preserve">
          <source>Nonoptional label applied as optional.</source>
          <target state="translated">非选项标签作为选项应用。</target>
        </trans-unit>
        <trans-unit id="af7065271027eca5c68630d7333cfc9de2dd8678" translate="yes" xml:space="preserve">
          <source>Nonterminal symbols are like regular OCaml symbols, except that they cannot end with ' (single quote).</source>
          <target state="translated">非终端符号与常规OCaml符号一样,只是不能以'(单引号)结尾。</target>
        </trans-unit>
        <trans-unit id="8c779683d49742e5580a38345a8dbcc07ab2e152" translate="yes" xml:space="preserve">
          <source>Norm squared: given &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;x^2&amp;nbsp;+&amp;nbsp;y^2&lt;/code&gt;.</source>
          <target state="translated">范数平方：给定 &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; ，返回 &lt;code&gt;x^2&amp;nbsp;+&amp;nbsp;y^2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddc420b7c8d61b9e4310ab8493f4d729522accc5" translate="yes" xml:space="preserve">
          <source>Norm: given &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;sqrt(x^2&amp;nbsp;+&amp;nbsp;y^2)&lt;/code&gt;.</source>
          <target state="translated">范数：给定 &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; ，返回 &lt;code&gt;sqrt(x^2&amp;nbsp;+&amp;nbsp;y^2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="517d7530daae5b9c5977ddf4fbfb276d8be8264d" translate="yes" xml:space="preserve">
          <source>Normal number, none of the below</source>
          <target state="translated">正常数,以下都没有</target>
        </trans-unit>
        <trans-unit id="36fb1748b422ce3ad94d8a06d8205b349c379068" translate="yes" xml:space="preserve">
          <source>Normally the compiler generates a type error if you attempt to pass to a function a parameter whose type is different from the expected one. However, in the specific case where the expected type is a non-labeled function type, and the argument is a function expecting optional parameters, the compiler will attempt to transform the argument to have it match the expected type, by passing None for all optional parameters.</source>
          <target state="translated">通常情况下,如果试图将一个类型与预期类型不同的参数传递给函数,编译器会产生类型错误。然而,在特定情况下,当预期类型是一个非标记的函数类型,而参数是一个期望有可选参数的函数时,编译器将尝试转换参数,使其与预期类型相匹配,为所有可选参数传递None。</target>
        </trans-unit>
        <trans-unit id="c792fa3c18a06a015ea04948e5b4604135e35115" translate="yes" xml:space="preserve">
          <source>Normally, the allocation rate is measured by counting the in-heap size of allocated blocks. However, it often happens that finalized objects contain pointers to out-of-heap memory blocks and other resources (such as file descriptors, X Windows bitmaps, etc.). For those blocks, the in-heap size of blocks is not a good measure of the quantity of resources allocated by the program.</source>
          <target state="translated">通常,分配率是通过计算分配块的堆内大小来衡量的。但是,经常会出现这样的情况:最终确定的对象中包含了指向堆外内存块和其他资源(如文件描述符、X Windows位图等)的指针。对于这些块,块的堆内大小并不能很好地衡量程序分配的资源数量。</target>
        </trans-unit>
        <trans-unit id="1ff9300a83f8a35da371237256262716296f049b" translate="yes" xml:space="preserve">
          <source>Normally, the debugger takes checkpoints of the program state from time to time. That is, it makes a copy of the current state of the program (using the Unix system call fork). If the variable checkpoints is set to off, the debugger will not take any checkpoints.</source>
          <target state="translated">通常情况下,调试器会不时地对程序状态进行检查点。也就是说,它对程序的当前状态进行复制(使用Unix系统调用fork)。如果将变量checkpoints设置为off,则调试器将不会采取任何检查点。</target>
        </trans-unit>
        <trans-unit id="338469a733ebda5aa0e30bb1db80e0e157e51892" translate="yes" xml:space="preserve">
          <source>Not a directory</source>
          <target state="translated">不是目录</target>
        </trans-unit>
        <trans-unit id="9faeba3fc7b5c9d7e01764096168b9e8e374411d" translate="yes" xml:space="preserve">
          <source>Not a number: result of an undefined operation</source>
          <target state="translated">不是数字:未定义操作的结果。</target>
        </trans-unit>
        <trans-unit id="4c8ae112a2e8df4e520ecf91813337acb821264b" translate="yes" xml:space="preserve">
          <source>Not all functions are provided by all Unix variants. If some functions are not available, they will raise Invalid_arg when called.</source>
          <target state="translated">并非所有的Unix变体都提供所有的函数,如果有些函数不可用,它们会在调用时引发Invalid_arg。如果有些函数不可用,它们在调用时将引发Invalid_arg。</target>
        </trans-unit>
        <trans-unit id="a251fde2cab1783fbc45a17d3491954f07532d2e" translate="yes" xml:space="preserve">
          <source>Not all header available in the caml/ directory were described in previous sections. All those unmentioned headers are part of the internal runtime API, for which there is &lt;em&gt;no&lt;/em&gt; stability guarantee. If you really need access to this internal runtime API, this section provides some guidelines that may help you to write code that might not break on every new version of OCaml.</source>
          <target state="translated">前面的部分中并未描述caml /目录中所有可用的标头。所有这些未提及的标头都是内部运行时API的一部分，因此&lt;em&gt;无法&lt;/em&gt;保证稳定性。如果您确实需要访问此内部运行时API，则本节提供了一些准则，可以帮助您编写在每个新版本的OCaml上不会中断的代码。</target>
        </trans-unit>
        <trans-unit id="a9199f21841e17aae508bebd4889b3a7dc1d36c6" translate="yes" xml:space="preserve">
          <source>Not an executable file</source>
          <target state="translated">不是可执行文件</target>
        </trans-unit>
        <trans-unit id="facd4c2d5bdce52a545593e87469a809ac0e1231" translate="yes" xml:space="preserve">
          <source>Not enough memory</source>
          <target state="translated">记忆力不够</target>
        </trans-unit>
        <trans-unit id="cf34be1f750ab01dd0f009456dd21934f44155fb" translate="yes" xml:space="preserve">
          <source>Not for the casual user.</source>
          <target state="translated">不适合普通用户。</target>
        </trans-unit>
        <trans-unit id="4152727c8d99325fa09c8beae5e73e4b8bd46f0c" translate="yes" xml:space="preserve">
          <source>Not the normal way of pretty-printing, since imperative line splitting may interfere with current line counters and box size calculation. Using break hints within an enclosing vertical box is a better alternative.</source>
          <target state="translated">不是正常的漂亮打印方式,因为必要的分线可能会干扰当前的行计数器和框体大小计算。在一个封闭的垂直框内使用断点提示是一个更好的选择。</target>
        </trans-unit>
        <trans-unit id="a819c9b54780bf0db302a106d8d765a494007de9" translate="yes" xml:space="preserve">
          <source>Note as well that parent directories in the given path will not be created when opening the trace. The runtime assumes the path is accessible for creating and writing the trace. The program will fail to start if this requirement isn&amp;rsquo;t met.</source>
          <target state="translated">还要注意的是，打开跟踪时，将不会在给定路径中创建父目录。运行时假定该路径可用于创建和写入跟踪。如果不满足此要求，程序将无法启动。</target>
        </trans-unit>
        <trans-unit id="037c57d3261561d20c1db3424456e04def230f71" translate="yes" xml:space="preserve">
          <source>Note here the (self : int #iterator) idiom, which ensures that this object implements the interface iterator.</source>
          <target state="translated">注意这里的(self:int #iterator)成语,它确保这个对象实现了接口迭代器。</target>
        </trans-unit>
        <trans-unit id="c3ce8074b0d7cbaefabb1e3d3e4d3c74808df3a8" translate="yes" xml:space="preserve">
          <source>Note here the special syntax (#point0 as 'a) we have to use to quantify the extensible part of #point0. As for the variable binder, it can be omitted in class specifications. If you want polymorphism inside object field it must be quantified independently.</source>
          <target state="translated">注意这里我们要用特殊的语法(#point0为'a)来量化#point0的可扩展部分。至于变量binder,在类规范中可以省略。如果你想在对象字段内部实现多态性,就必须将其独立量化。</target>
        </trans-unit>
        <trans-unit id="ab69a65854dd6fec6962d0e2d5e4784cf692204e" translate="yes" xml:space="preserve">
          <source>Note in particular that -inline does not have the meaning that it has in the previous compiler or in -Oclassic mode. In both of those situations -inline was effectively some kind of basic assessment of inlining benefit. However in Flambda inlining mode it corresponds to a constraint on the search; the assessment of benefit is independent, as described above.</source>
          <target state="translated">特别要注意的是,-inline并不具有它在以前的编译器中或在-Oclassic模式下的意义。在这两种情况下,-inline实际上是对内联收益的某种基本评估。然而在Flambda内联模式中,它对应的是对搜索的约束;利益评估是独立的,如上所述。</target>
        </trans-unit>
        <trans-unit id="90e7c8c1273c2167af15e26d1e579c38f8f99528" translate="yes" xml:space="preserve">
          <source>Note on polymorphic variant tags: the current implementation accepts lowercase variant tags in addition to capitalized variant tags, but we suggest you avoid lowercase variant tags for portability and compatibility with future OCaml versions.</source>
          <target state="translated">关于多态变体标签的说明:当前的实现除了接受大写的变体标签外,还接受小写的变体标签,但我们建议你避免使用小写的变体标签,以保证移植性和与未来OCaml版本的兼容性。</target>
        </trans-unit>
        <trans-unit id="8abc6d55c7e6502cb76253097a56d727be818505" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;dynlink#VALloadfile&quot;&gt;&lt;code&gt;Dynlink.loadfile&lt;/code&gt;&lt;/a&gt; changes the allowed-units list.</source>
          <target state="translated">请注意，&lt;a href=&quot;dynlink#VALloadfile&quot;&gt; &lt;code&gt;Dynlink.loadfile&lt;/code&gt; &lt;/a&gt;更改了允许的单位列表。</target>
        </trans-unit>
        <trans-unit id="08d26a6dbdf7cb76c9e11d80524e91dc7d0ef610" translate="yes" xml:space="preserve">
          <source>Note that entering open Mod merely accesses the compiled interface (.cmi file) for Mod, but does not load the implementation of Mod, and does not cause any error if no implementation of Mod has been loaded. The error &amp;ldquo;reference to undefined global Mod&amp;rdquo; will occur only when executing a value or module definition that refers to Mod.</source>
          <target state="translated">请注意，输入open Mod仅会访问Mod的已编译接口（.cmi文件），但不会加载Mod的实现，并且如果未加载Mod的实现也不会导致任何错误。仅当执行引用Mod的值或模块定义时，才会发生错误&amp;ldquo;对未定义的全局Mod的引用&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2165fbecefe21675865f5a8f169aa75121b7dd25" translate="yes" xml:space="preserve">
          <source>Note that for clarity&amp;rsquo;s sake, the method print is explicitly marked as overriding another definition by annotating the method keyword with an exclamation mark !. If the method print were not overriding the print method of printable_point, the compiler would raise an error:</source>
          <target state="translated">请注意，为清楚起见，通过使用感叹号！注释method关键字，将方法print显式标记为覆盖另一个定义。如果方法print没有覆盖printable_point的打印方法，则编译器将引发错误：</target>
        </trans-unit>
        <trans-unit id="d9f7f9990a4c81187469986363cda35568351830" translate="yes" xml:space="preserve">
          <source>Note that if no arguments follow a &lt;code&gt;Rest&lt;/code&gt; keyword then the function is not called at all whereas the function for a &lt;code&gt;Rest_all&lt;/code&gt; keyword is called with an empty list.</source>
          <target state="translated">请注意，如果没有参数跟随 &lt;code&gt;Rest&lt;/code&gt; 关键字，则根本不调用该函数，而 &lt;code&gt;Rest_all&lt;/code&gt; 关键字的函数以空列表调用。</target>
        </trans-unit>
        <trans-unit id="0c8b0cd07d8b3eb1cb5c73f85a9b93dce5e210f3" translate="yes" xml:space="preserve">
          <source>Note that in this case you should not compute dependencies for mylib.mli together with the other files, hence the need to pass explicitly the list of files to process. If mylib.mli itself has dependencies, you should compute them using -as-map.</source>
          <target state="translated">注意,在这种情况下,你不应该把mylib.mli的依赖关系和其他文件一起计算,因此需要明确地传递要处理的文件列表。如果mylib.mli本身有依赖关系,你应该使用-as-map来计算它们。</target>
        </trans-unit>
        <trans-unit id="63274ceec059ea43f06cf7d5143c9d0f279449fe" translate="yes" xml:space="preserve">
          <source>Note that it would be unsafe if &lt;code&gt;s&lt;/code&gt; was passed as an additional parameter to the function &lt;code&gt;f&lt;/code&gt; as it could escape this way and be mutated in the future -- &lt;code&gt;string_init&lt;/code&gt; would give up ownership of &lt;code&gt;s&lt;/code&gt; to pass it to &lt;code&gt;f&lt;/code&gt;, and could not call &lt;code&gt;unsafe_to_string&lt;/code&gt; safely.</source>
          <target state="translated">请注意，如果将 &lt;code&gt;s&lt;/code&gt; 作为附加参数传递给函数 &lt;code&gt;f&lt;/code&gt; 是不安全的，因为它可能会以这种方式逸出并在将来进行 &lt;code&gt;string_init&lt;/code&gt; 将放弃 &lt;code&gt;s&lt;/code&gt; 的所有权以将其传递给 &lt;code&gt;f&lt;/code&gt; ，并且无法调用 &lt;code&gt;unsafe_to_string&lt;/code&gt; 安全地。</target>
        </trans-unit>
        <trans-unit id="b4753a1c807609006c1cb1222f68e354a9ec0d33" translate="yes" xml:space="preserve">
          <source>Note that label comments take precedence over item comments, so:</source>
          <target state="translated">请注意,标签注释优先于项目注释,所以。</target>
        </trans-unit>
        <trans-unit id="a919535701ff97d2e364548f37fa537e17d9cc03" translate="yes" xml:space="preserve">
          <source>Note that lazy_two has type int lazy_t. However, the type 'a lazy_t is an internal type name, so the type 'a Lazy.t should be preferred when possible.</source>
          <target state="translated">注意,lazy_two的类型为int lazy_t。但是,类型'a lazy_t是一个内部类型名,所以在可能的情况下,应该首选类型'a Lazy.t。</target>
        </trans-unit>
        <trans-unit id="bdbd6ed5e065f79a1664cc5e3d9e396319783be3" translate="yes" xml:space="preserve">
          <source>Note that line splitting policy is box specific: the policy of a box does not rule the policy of inner boxes. For instance, if a vertical box is nested in an horizontal box, all break hints within the vertical box will split the line.</source>
          <target state="translated">请注意,拆行策略是针对盒子的:盒子的策略并不统治内部盒子的策略。例如,如果一个垂直框嵌套在一个水平框中,那么垂直框内的所有断线提示都会拆线。</target>
        </trans-unit>
        <trans-unit id="0ce52db53f4883581f49385acd3aa04301c1b07b" translate="yes" xml:space="preserve">
          <source>Note that no information is propagated about the contents of strings, even in safe-string mode, because it cannot yet be guaranteed that they are immutable throughout a given program.</source>
          <target state="translated">请注意,即使在安全字符串模式下,也不会传播有关字符串内容的信息,因为还不能保证它们在整个给定程序中是不可改变的。</target>
        </trans-unit>
        <trans-unit id="9ecfaba3e31b928fe62c543cf4b58b08adf9f38d" translate="yes" xml:space="preserve">
          <source>Note that once &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; was called, there is no way to revert to the non-randomized default behavior of &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt;. This is intentional. Non-randomized hash tables can still be created using &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt;.</source>
          <target state="translated">请注意，一旦 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; ，就无法恢复为&lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; &lt;/a&gt;的非随机默认行为。这是故意的。仍然可以使用 &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt; 来创建非随机哈希表。</target>
        </trans-unit>
        <trans-unit id="078cdfb36f419462d48005d3185623168e74775b" translate="yes" xml:space="preserve">
          <source>Note that once &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; was called, there is no way to revert to the non-randomized default behavior of &lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt;&lt;/a&gt;. This is intentional. Non-randomized hash tables can still be created using &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt;.</source>
          <target state="translated">请注意，一旦 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; ，就无法恢复为&lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt; &lt;/a&gt;的非随机默认行为。这是故意的。仍然可以使用 &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt; 来创建非随机哈希表。</target>
        </trans-unit>
        <trans-unit id="d3eb4400a3041e1bc0872d4c6fadfee7b45a0533" translate="yes" xml:space="preserve">
          <source>Note that only top-level structures can be mapped to separately-compiled files, but neither functors nor module types. However, all module-class objects can appear as components of a structure, so the solution is to put the functor or module type inside a structure, which can then be mapped to a file.</source>
          <target state="translated">请注意,只有顶层结构可以被映射到单独编译的文件中,但漏斗和模块类型都不能。然而,所有模块类对象都可以作为结构的组成部分出现,所以解决方案是将放函数或模块类型放在结构中,然后可以将其映射到文件中。</target>
        </trans-unit>
        <trans-unit id="45d50cbdd93bc0057831e01783483dc11563f7c4" translate="yes" xml:space="preserve">
          <source>Note that since immediate objects do not define a class type, they have no such restriction.</source>
          <target state="translated">请注意,由于立即对象没有定义类类型,所以它们没有这种限制。</target>
        </trans-unit>
        <trans-unit id="2bd433ffb5b0bba6a711c0ea5bb3b1c7a88c90b0" translate="yes" xml:space="preserve">
          <source>Note that the callback can be postponed slightly after the actual event. The callstack passed to the callback is always accurate, but the program state may have evolved.</source>
          <target state="translated">请注意,回调可以在实际事件后稍微推迟。传递给回调的callstack总是准确的,但程序状态可能已经发生了变化。</target>
        </trans-unit>
        <trans-unit id="c2ef9b9d1aff860780f332e0b33c8e88450455d7" translate="yes" xml:space="preserve">
          <source>Note that the coercion (&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) is actually an abbreviated form, and will only work in presence of private abbreviations if neither the type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; nor &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; contain any type variables. If they do, you must use the full form (&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) where &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is the expected type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Concretely, this would be (x : N.t :&amp;gt; int) and (l : N.t list :&amp;gt; int list) for the above examples.</source>
          <target state="translated">请注意，强制（&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;：&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）实际上是缩写形式，并且只有在&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;的类型均不包含任何类型变量的情况下，强制转换才有效。如果这样做，则必须使用完整格式（&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;），其中&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;是预期的&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;类型。具体来说，对于上述示例，这将是（x：Nt：&amp;gt; int）和（l：Nt列表：&amp;gt; int列表）。</target>
        </trans-unit>
        <trans-unit id="50817e39131d67a96275cac53949dd6c7173b3db" translate="yes" xml:space="preserve">
          <source>Note that the following identifiers are keywords of the Camlp4 extensions and should be avoided for compatibility reasons.</source>
          <target state="translated">请注意,以下标识符是Camlp4扩展的关键字,出于兼容性考虑,应避免使用。</target>
        </trans-unit>
        <trans-unit id="b4a3babe539fe240e495a53999452fd839e7e6f6" translate="yes" xml:space="preserve">
          <source>Note that the following identifiers are keywords of the now unmaintained Camlp4 system and should be avoided for backwards compatibility reasons.</source>
          <target state="translated">请注意,以下标识符是现在未维护的Camlp4系统的关键字,出于向后兼容的原因,应避免使用。</target>
        </trans-unit>
        <trans-unit id="6d6f602690ce2c063c471eee010ebbe59f6bbddc" translate="yes" xml:space="preserve">
          <source>Note that the instrumented runtime is an alternative runtime for OCaml programs. It is only referenced during the linking stage of the final executable. This means that the compilation stage does not need to be altered to enable instrumentation.</source>
          <target state="translated">请注意,工具化运行时是 OCaml 程序的替代运行时。它只在最终可执行文件的链接阶段被引用。这意味着不需要改变编译阶段来启用工具化。</target>
        </trans-unit>
        <trans-unit id="5971f9da22f0faace6bfec873b81d408ac540d78" translate="yes" xml:space="preserve">
          <source>Note that the new type &lt;code&gt;'a&amp;nbsp;IntHashtbl.t&lt;/code&gt; is not compatible with the type &lt;code&gt;('a,'b)&amp;nbsp;Hashtbl.t&lt;/code&gt; of the generic interface. For example, &lt;code&gt;Hashtbl.length&amp;nbsp;h&lt;/code&gt; would not type-check, you must use &lt;code&gt;IntHashtbl.length&lt;/code&gt;.</source>
          <target state="translated">请注意，新类型 &lt;code&gt;'a&amp;nbsp;IntHashtbl.t&lt;/code&gt; 与通用接口的类型 &lt;code&gt;('a,'b)&amp;nbsp;Hashtbl.t&lt;/code&gt; 不兼容。例如， &lt;code&gt;Hashtbl.length&amp;nbsp;h&lt;/code&gt; 不会进行类型检查，您必须使用 &lt;code&gt;IntHashtbl.length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f01438030239e56aa11911507a85c74b4e412af5" translate="yes" xml:space="preserve">
          <source>Note that the relationship between object, class and type in OCaml is different than in mainstream object-oriented languages such as Java and C++, so you shouldn&amp;rsquo;t assume that similar keywords mean the same thing. Object-oriented features are used much less frequently in OCaml than in those languages. OCaml has alternatives that are often more appropriate, such as modules and functors. Indeed, many OCaml programs do not use objects at all.</source>
          <target state="translated">请注意，OCaml中的对象，类和类型之间的关系与主流的面向对象的语言（例如Java和C ++）不同，因此您不应假定相似的关键字是同一件事。与那些语言相比，在OCaml中使用面向对象的功能的频率要低得多。OCaml具有通常更合适的替代方法，例如模块和函子。实际上，许多OCaml程序根本不使用对象。</target>
        </trans-unit>
        <trans-unit id="4c7b8526d94d8c27ed35f7c7cec40a0edae7df3f" translate="yes" xml:space="preserve">
          <source>Note that the two types AbstractStringSet.set and NoCaseStringSet.set are not compatible, and values of these two types do not match. This is the correct behavior: even though both set types contain elements of the same type (strings), they are built upon different orderings of that type, and different invariants need to be maintained by the operations (being strictly increasing for the standard ordering and for the case-insensitive ordering). Applying operations from AbstractStringSet to values of type NoCaseStringSet.set could give incorrect results, or build lists that violate the invariants of NoCaseStringSet.</source>
          <target state="translated">请注意,AbstractStringSet.set和NoCaseStringSet.set这两种类型是不兼容的,这两种类型的值是不匹配的。这是正确的行为:即使这两个集合类型包含相同类型的元素(字符串),但它们是建立在该类型的不同排序上的,操作需要维护不同的不变量(对于标准排序和不区分大小写的排序是严格的递增)。将来自AbstractStringSet的操作应用于NoCaseStringSet.set类型的值,可能会得到不正确的结果,或者建立的列表违反了NoCaseStringSet的不变量。</target>
        </trans-unit>
        <trans-unit id="c3e9f41fd86b1c950c9ef81d22b068692eccf75f" translate="yes" xml:space="preserve">
          <source>Note that the type constructor regular_nested always appears as 'a regular_nested in the definition above, with the same parameter 'a. Equipped with this type, one can compute a maximal depth with a classic recursive function</source>
          <target state="translated">请注意,在上面的定义中,类型构造函数regular_nested总是以'a regular_nested的形式出现,参数'a相同。有了这个类型,我们就可以用一个经典的递归函数来计算最大的深度</target>
        </trans-unit>
        <trans-unit id="f894cfb3f87405bfa359dfc278dfe88f62a0e6bb" translate="yes" xml:space="preserve">
          <source>Note that the type money is not a subtype of type comparable, as the self type appears in contravariant position in the type of method leq. Indeed, an object m of class money has a method leq that expects an argument of type money since it accesses its value method. Considering m of type comparable would allow a call to method leq on m with an argument that does not have a method value, which would be an error.</source>
          <target state="translated">请注意,类型money不是类型可比的子类型,因为self类型出现在方法leq的类型中的反变量位置。事实上,一个类money的对象m有一个方法leq,它期望一个类型money的参数,因为它访问它的值方法。如果认为m的类型是可比较的,那么就会允许用一个没有方法值的参数来调用m上的方法leq,这将是一个错误。</target>
        </trans-unit>
        <trans-unit id="95b3888a7e3a6dd69b6635ff1d23f6223d9986c2" translate="yes" xml:space="preserve">
          <source>Note that the type of p is point. This is an abbreviation automatically defined by the class definition above. It stands for the object type &amp;lt;get_x : int; move : int -&amp;gt; unit&amp;gt;, listing the methods of class point along with their types.</source>
          <target state="translated">请注意，p的类型是点。这是上面的类定义自动定义的缩写。它代表对象类型&amp;lt;get_x：int; move：int-&amp;gt; unit&amp;gt;，列出类指向方法及其类型。</target>
        </trans-unit>
        <trans-unit id="66b9f6fff51ab2e45034f690441bdecd68df53d9" translate="yes" xml:space="preserve">
          <source>Note that the word-delimited form, for example {sql|...|sql}, should not be used for signaling that an extension is in use. Indeed, the user cannot see from the code whether this string literal has different semantics than they expect. Moreover, giving semantics to a specific delimiter limits the freedom to change the delimiter to avoid escaping issues.</source>
          <target state="translated">请注意,字限定的形式,例如{sql|...|sql},不应该用来表示正在使用扩展。事实上,用户无法从代码中看出这个字符串文字形式的语义是否与他们期望的不同。此外,将语义赋予一个特定的定界符,限制了改变定界符的自由度,以避免逃避问题。</target>
        </trans-unit>
        <trans-unit id="5daea91835e86ffb05aea9cef4296c3068906517" translate="yes" xml:space="preserve">
          <source>Note that this construction is only useful if the exception is raised between match&amp;hellip;with. Exception patterns can be combined with ordinary patterns at the toplevel,</source>
          <target state="translated">请注意，只有当match&amp;hellip;with之间引发异常时，此构造才有用。异常模式可以与顶层的普通模式结合使用，</target>
        </trans-unit>
        <trans-unit id="16ffac9391573364c371a7957c46dea2fc876529" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as private and protected methods in Java or C++, which can be called from other objects of the same class. This is a direct consequence of the independence between types and classes in OCaml: two unrelated classes may produce objects of the same type, and there is no way at the type level to ensure that an object comes from a specific class. However a possible encoding of friend methods is given in section &amp;zwj;&lt;a href=&quot;#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="translated">请注意，这与Java或C ++中的私有方法和受保护方法不同，后者可以从同一类的其他对象中调用。这是OCaml中类型和类之间独立性的直接结果：两个不相关的类可能会产生相同类型的对象，并且在类型级别上无法确保对象来自特定的类。然而朋友的方法可能在编码部分给出&lt;a href=&quot;#s%3Afriends&quot;&gt;3.17&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c35684e12f57c72020fa856c51c0081aec8613e" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as private and protected methods in Java or C++, which can be called from other objects of the same class. This is a direct consequence of the independence between types and classes in OCaml: two unrelated classes may produce objects of the same type, and there is no way at the type level to ensure that an object comes from a specific class. However a possible encoding of friend methods is given in section &lt;a href=&quot;#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="translated">请注意，这与Java或C ++中的私有方法和受保护方法不同，后者可以从同一类的其他对象中调用。这是OCaml中类型和类之间的独立性的直接结果：两个不相关的类可能会产生相同类型的对象，并且在类型级别上无法确保对象来自特定的类。但是，在&lt;a href=&quot;#s%3Afriends&quot;&gt;3.17&lt;/a&gt;节中给出了对方法的可能编码。</target>
        </trans-unit>
        <trans-unit id="5301e9ce9eaee70b52bc0e30c461f8dc4f50979b" translate="yes" xml:space="preserve">
          <source>Note that this syntax is not valid within OCaml: average has an universally quantified type 'a inside the type of one of its argument whereas for polymorphic recursion the universally quantified type was introduced before the rest of the type. This position of the universally quantified type means that average is a second-rank polymorphic function. This kind of higher-rank functions is not directly supported by OCaml: type inference for second-rank polymorphic function and beyond is undecidable; therefore using this kind of higher-rank functions requires to handle manually these universally quantified types.</source>
          <target state="translated">请注意,这种语法在OCaml内是无效的:average在它的一个参数的类型里面有一个普遍量化的类型'a,而对于多态递归来说,普遍量化的类型是在其他类型之前引入的。这种普遍量化类型的位置意味着平均数是一个二阶多态函数。OCaml 并不直接支持这种高阶函数:二阶多态函数和更高阶函数的类型推理是无法确定的,因此使用这种高阶函数需要手动处理这些普遍量化的类型。</target>
        </trans-unit>
        <trans-unit id="0537a61ab3006dae26fac6b5f19a889d7c194bae" translate="yes" xml:space="preserve">
          <source>Note that this will only affect the prefix of the trace file, there is no option to specify the full effective file name. This restriction is in place to make room for future improvements to the instrumented runtime, where the single trace file per session design may be replaced.</source>
          <target state="translated">请注意,这只会影响跟踪文件的前缀,没有指定完整有效文件名的选项。这个限制是为了给将来改进工具化运行时留有余地,每个会话设计的单一跟踪文件可能会被取代。</target>
        </trans-unit>
        <trans-unit id="e53f78797414436c28938372fd25e7a220604184" translate="yes" xml:space="preserve">
          <source>Note that we can rewrite the type of f and f' as</source>
          <target state="translated">请注意,我们可以将f和f'的类型重写为</target>
        </trans-unit>
        <trans-unit id="9855ac639cc02bb505afbab05f1ffccd97cf7fa0" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;fn&lt;/code&gt; is called all the functions registered with &lt;a href=&quot;stdlib#VALat_exit&quot;&gt;&lt;code&gt;at_exit&lt;/code&gt;&lt;/a&gt; have already been called. Because of this you must make sure any output channel &lt;code&gt;fn&lt;/code&gt; writes on is flushed.</source>
          <target state="translated">请注意，调用 &lt;code&gt;fn&lt;/code&gt; 时,已经调用了所有在&lt;a href=&quot;stdlib#VALat_exit&quot;&gt; &lt;code&gt;at_exit&lt;/code&gt; &lt;/a&gt;注册的函数。因此，必须确保 &lt;code&gt;fn&lt;/code&gt; 写入的所有输出通道都已刷新。</target>
        </trans-unit>
        <trans-unit id="5902b468c9420c576a1090e7ba4580b19535ba05" translate="yes" xml:space="preserve">
          <source>Note that when you don&amp;rsquo;t need an argument, you can still use a wildcard pattern, but you must prefix it with the label.</source>
          <target state="translated">请注意，当不需要参数时，仍可以使用通配符模式，但是必须在其前面加上标签。</target>
        </trans-unit>
        <trans-unit id="42951dc6e5e061dd8581c9cd3e18ab7ff1122703" translate="yes" xml:space="preserve">
          <source>Note that you can also remove manifest types, by substituting with the same type.</source>
          <target state="translated">请注意,您也可以通过用相同的类型代替来删除清单类型。</target>
        </trans-unit>
        <trans-unit id="6d24bd50ee40c13de42decb018fafac2cc30412b" translate="yes" xml:space="preserve">
          <source>Note that, if a comment appears immediately next to multiple items, as in:</source>
          <target state="translated">请注意,如果一个注释紧挨着多个项目出现,如。</target>
        </trans-unit>
        <trans-unit id="579e1ef453daed542dee9b6448ed260939315131" translate="yes" xml:space="preserve">
          <source>Note that, in the &lt;a href=&quot;modtypes#specification&quot;&gt;specification&lt;/a&gt; case, the &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;s must be parenthesized if they use the with&lt;a href=&quot;modtypes#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; construct.</source>
          <target state="translated">请注意，在&lt;a href=&quot;modtypes#specification&quot;&gt;规范&lt;/a&gt;情况下，如果&lt;a href=&quot;modtypes#module-type&quot;&gt;模块类型&lt;/a&gt;s使用with with &lt;a href=&quot;modtypes#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt;构造，则必须将其括在括号中。</target>
        </trans-unit>
        <trans-unit id="9ecccd058b8859c03de2fd449f57787fc6750b3c" translate="yes" xml:space="preserve">
          <source>Note that, unlike type declarations, type substitution declarations are not recursive, so substitutions like the following are rejected:</source>
          <target state="translated">请注意,与类型声明不同,类型替换声明不是递归的,所以像下面这样的替换会被拒绝。</target>
        </trans-unit>
        <trans-unit id="1d71401130598be60ae748ad0081c1eff34da4af" translate="yes" xml:space="preserve">
          <source>Note the difference between these two coercions: in the case of to_c2, the type #c2 = &amp;lt; m : 'a; .. &amp;gt; as 'a is polymorphically recursive (according to the explicit recursion in the class type of c2); hence the success of applying this coercion to an object of class c0. On the other hand, in the first case, c1 was only expanded and unrolled twice to obtain &amp;lt; m : &amp;lt; m : c1; .. &amp;gt;; .. &amp;gt; (remember #c1 = &amp;lt; m : c1; .. &amp;gt;), without introducing recursion. You may also note that the type of to_c2 is #c2 -&amp;gt; c2 while the type of to_c1 is more general than #c1 -&amp;gt; c1. This is not always true, since there are class types for which some instances of #c are not subtypes of c, as explained in section &amp;zwj;&lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;. Yet, for parameterless classes the coercion (_ :&amp;gt; c) is always more general than (_ : #c :&amp;gt; c).</source>
          <target state="translated">注意这两个强制之间的区别：在to_c2的情况下，类型＃c2 = &amp;lt;m：'a; ..&amp;gt;因为'a是多态递归的（根据c2类类型的显式递归）；因此，成功将此强制应用于c0类的对象。另一方面，在第一种情况下，仅将c1展开和展开两次，以获得&amp;lt;m：&amp;lt;m：c1; ..&amp;gt;; ..&amp;gt;（请记住＃c1 = &amp;lt;m：c1; ..&amp;gt;），而无需引入递归。您可能还注意到to_c2的类型是＃c2-&amp;gt; c2，而to_c1的类型比＃c1-&amp;gt; c1更通用。这并不总是正确的，因为有类类型其中#C的某些情况下是不是C亚型，如部分解释&lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;。但是，对于无参数类，强制（_：&amp;gt; c）总是比（_：#c：&amp;gt;C）。</target>
        </trans-unit>
        <trans-unit id="78d522de17989d9555a8bbce2b8df8ef04eb9f91" translate="yes" xml:space="preserve">
          <source>Note the difference between these two coercions: in the case of to_c2, the type #c2 = &amp;lt; m : 'a; .. &amp;gt; as 'a is polymorphically recursive (according to the explicit recursion in the class type of c2); hence the success of applying this coercion to an object of class c0. On the other hand, in the first case, c1 was only expanded and unrolled twice to obtain &amp;lt; m : &amp;lt; m : c1; .. &amp;gt;; .. &amp;gt; (remember #c1 = &amp;lt; m : c1; .. &amp;gt;), without introducing recursion. You may also note that the type of to_c2 is #c2 -&amp;gt; c2 while the type of to_c1 is more general than #c1 -&amp;gt; c1. This is not always true, since there are class types for which some instances of #c are not subtypes of c, as explained in section &lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;. Yet, for parameterless classes the coercion (_ :&amp;gt; c) is always more general than (_ : #c :&amp;gt; c).</source>
          <target state="translated">注意这两个强制之间的区别：在to_c2的情况下，类型＃c2 = &amp;lt;m：'a; ..&amp;gt;因为'a是多态递归的（根据c2类类型的显式递归）；因此，成功将此强制应用于c0类的对象。另一方面，在第一种情况下，仅将c1展开和展开两次，以获得&amp;lt;m：&amp;lt;m：c1; ..&amp;gt;; ..&amp;gt;（请记住＃c1 = &amp;lt;m：c1; ..&amp;gt;），而无需引入递归。您可能还注意到to_c2的类型是＃c2-&amp;gt; c2，而to_c1的类型比＃c1-&amp;gt; c1更通用。这并不总是正确的，因为在某些类类型中，#c的某些实例不是c的子类型，如&lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;节所述。但是，对于无参数类，强制（_：&amp;gt; c）总是比（_：#c：&amp;gt;C）。</target>
        </trans-unit>
        <trans-unit id="75c5273bc385a2bc73dec61088cee3a19dd057d4" translate="yes" xml:space="preserve">
          <source>Note the use of double underscores in Mylib__A and Mylib__B. These were chosen on purpose; the compiler uses the following heuristic when printing paths: given a path Lib__fooBar, if Lib.FooBar exists and is an alias for Lib__fooBar, then the compiler will always display Lib.FooBar instead of Lib__fooBar. This way the long Mylib__ names stay hidden and all the user sees is the nicer dot names. This is how the OCaml standard library is compiled.</source>
          <target state="translated">请注意在Mylib__A和Mylib__B中使用了双下划线。这些都是故意选择的;编译器在打印路径时使用了以下的启发式方法:给定一个路径Lib__fooBar,如果Lib.FooBar存在并且是Lib__fooBar的别名,那么编译器将总是显示Lib.FooBar而不是Lib__fooBar。这样一来,长长的Mylib__名字就会被隐藏起来,用户看到的只是比较好听的点名。这就是OCaml标准库的编译方式。</target>
        </trans-unit>
        <trans-unit id="dd1d07e0d8f7923bb8cef98de8decf201a2336ee" translate="yes" xml:space="preserve">
          <source>Note the use of override for method times. Writing new money2 (k *. repr) instead of {&amp;lt; repr = k *. repr &amp;gt;} would not behave well with inheritance: in a subclass money3 of money2 the times method would return an object of class money2 but not of class money3 as would be expected.</source>
          <target state="translated">注意方法时间使用替代。编写新的money2（k *。repr）而不是{&amp;lt;repr = k *。repr&amp;gt;}在继承方面表现不佳：在money2的子类money3中，times方法将返回类money2的对象，但返回的对象不是类money3的对象。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="a7c6195c71846fafbab4e4cc00dfd41c54465d1b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Lazy.force&lt;/code&gt; is not thread-safe. If you use this module in a multi-threaded program, you will need to add some locks.</source>
          <target state="translated">注意： &lt;code&gt;Lazy.force&lt;/code&gt; 不是线程安全的。如果在多线程程序中使用此模块，则需要添加一些锁。</target>
        </trans-unit>
        <trans-unit id="6ee1f0993f734f3d32255902fa4253dbe8464720" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;lazy_t&lt;/code&gt; is the built-in type constructor used by the compiler for the &lt;code&gt;lazy&lt;/code&gt; keyword. You should not use it directly. Always use &lt;code&gt;Lazy.t&lt;/code&gt; instead.</source>
          <target state="translated">注意： &lt;code&gt;lazy_t&lt;/code&gt; 是编译器用于 &lt;code&gt;lazy&lt;/code&gt; 关键字的内置类型构造函数。您不应该直接使用它。始终使用 &lt;code&gt;Lazy.t&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="c65beeb77bdc7dc7ee42cc9da173d89eac9e501e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;open_in&lt;/code&gt; returns a formatted input channel that efficiently reads characters in large chunks; in contrast, &lt;code&gt;from_channel&lt;/code&gt; below returns formatted input channels that must read one character at a time, leading to a much slower scanning rate.</source>
          <target state="translated">注意： &lt;code&gt;open_in&lt;/code&gt; 返回格式化的输入通道，该通道可以有效地读取大块字符；相反，下面的 &lt;code&gt;from_channel&lt;/code&gt; 返回格式化的输入通道，这些通道必须一次读取一个字符，从而导致扫描速度大大降低。</target>
        </trans-unit>
        <trans-unit id="fbb80132052a566980a3f39541caf9bc002b1c90" translate="yes" xml:space="preserve">
          <source>Note: Existing command line options can be redefined using this function.</source>
          <target state="translated">注意:现有的命令行选项可以使用这个函数重新定义。</target>
        </trans-unit>
        <trans-unit id="f8f6141fe67a802e7e2bf4927ccb64d0289512ae" translate="yes" xml:space="preserve">
          <source>Note: For maximum backwards compatibility in Unicode mode, if the argument is not a valid UTF-8 string, this function will fall back to assuming that it is encoded in the current code page.</source>
          <target state="translated">注意:为了最大限度的向后兼容Unicode模式,如果参数不是一个有效的UTF-8字符串,这个函数将回到假设它是在当前代码页中编码。</target>
        </trans-unit>
        <trans-unit id="2ae74bcb6937d84acfff2f5cc371f0df0a9df245" translate="yes" xml:space="preserve">
          <source>Note: If lazy patterns appear in multiple cases in a pattern-matching, lazy expressions may be forced even outside of the case ultimately selected by the pattern matching. In the example above, the suspension &lt;code&gt;x&lt;/code&gt; is always computed.</source>
          <target state="translated">注意：如果在模式匹配中在多种情况下出现了惰性模式，则即使在模式匹配最终选择的大小写之外，也可能会强制使用惰性表达式。在上面的示例中，总是计算悬架 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d7d69b5a35fb8fdd2ec3a14decb5554cdfa109f" translate="yes" xml:space="preserve">
          <source>Note: Including the header files without first defining CAML_NAME_SPACE introduces in scope short names for most functions. Those short names are deprecated, and may be removed in the future because they usually produce clashes with names defined by other C libraries.</source>
          <target state="translated">注意:在没有定义CAML_NAME_SPACE的情况下加入头文件,会在范围内引入大多数函数的短名。这些短名已经被废弃,将来可能会被删除,因为它们通常会与其他C库定义的名称发生冲突。</target>
        </trans-unit>
        <trans-unit id="51519ebae7f9975b891bddfc046ca788658aed4d" translate="yes" xml:space="preserve">
          <source>Note: It is a &lt;em&gt;programming error&lt;/em&gt; if other kinds of exceptions are raised by &lt;code&gt;finally&lt;/code&gt;, as any exception raised in &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; will be lost in the event of a &lt;a href=&quot;fun#EXCEPTIONFinally_raised&quot;&gt;&lt;code&gt;Fun.Finally_raised&lt;/code&gt;&lt;/a&gt; exception. Therefore, one should make sure to handle those inside the finally.</source>
          <target state="translated">注意：如果 &lt;code&gt;finally&lt;/code&gt; 引发了其他类型的异常，则是&lt;em&gt;编程错误&lt;/em&gt;，因为在发生&lt;a href=&quot;fun#EXCEPTIONFinally_raised&quot;&gt; &lt;code&gt;Fun.Finally_raised&lt;/code&gt; &lt;/a&gt;异常的情况下， &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; 引发的任何异常都将丢失。因此，应该确保最终处理这些内容。</target>
        </trans-unit>
        <trans-unit id="bedbf1279049e8ebd79ce828d1966e381406da84" translate="yes" xml:space="preserve">
          <source>Note: OCaml strings used to be modifiable in place, for instance via the &lt;a href=&quot;string#VALset&quot;&gt;&lt;code&gt;String.set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#VALblit&quot;&gt;&lt;code&gt;String.blit&lt;/code&gt;&lt;/a&gt; functions described below. This usage is only possible when the compiler is put in &quot;unsafe-string&quot; mode by giving the &lt;code&gt;-unsafe-string&lt;/code&gt; command-line option. This compatibility mode makes the types &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;bytes&lt;/code&gt; (see module &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;) interchangeable so that functions expecting byte sequences can also accept strings as arguments and modify them.</source>
          <target state="translated">注意：OCaml字符串以前可以通过以下描述的&lt;a href=&quot;string#VALset&quot;&gt; &lt;code&gt;String.set&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;string#VALblit&quot;&gt; &lt;code&gt;String.blit&lt;/code&gt; &lt;/a&gt;函数进行修改。仅当通过提供 &lt;code&gt;-unsafe-string&lt;/code&gt; 命令行选项将编译器置于&amp;ldquo; unsafe-string&amp;rdquo;模式时，才可以使用此用法。这种兼容模式使 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;bytes&lt;/code&gt; 类型（请参阅模块&lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt;）可以互换，以便期望字节序列的函数也可以接受字符串作为参数并对其进行修改。</target>
        </trans-unit>
        <trans-unit id="c72b40ee4e5477e5f7d6e7553ca34de54319049d" translate="yes" xml:space="preserve">
          <source>Note: On some systems, with interactive input, an end-of-file may be followed by more characters. However, ocamllex will not correctly handle regular expressions that contain eof followed by something else.</source>
          <target state="translated">注意:在某些系统中,如果使用交互式输入,文件末尾可能会有更多的字符。然而,ocamllex不会正确地处理包含eof和其他字符的正则表达式。</target>
        </trans-unit>
        <trans-unit id="01558340b88b057d42608e1a6ec3ca0cfdf079a7" translate="yes" xml:space="preserve">
          <source>Note: The strings returned by caml_stat_strdup_to_os and caml_stat_strdup_of_os are allocated using caml_stat_alloc, so they need to be deallocated using caml_stat_free when they are no longer needed.</source>
          <target state="translated">注意:caml_stat_strdup_to_os和caml_stat_strdup_of_os返回的字符串是用caml_stat_alloc分配的,所以当它们不再需要时,需要用caml_stat_free来重新分配。</target>
        </trans-unit>
        <trans-unit id="7848f4c2eb8f564919b210b8bbfed2cdf5ec566d" translate="yes" xml:space="preserve">
          <source>Note: This example is on a Unix system. The exact command lines may be different on other systems.</source>
          <target state="translated">注意:这个例子是在Unix系统上进行的。在其他系统上,确切的命令行可能有所不同。</target>
        </trans-unit>
        <trans-unit id="84be470836b2d22c5aa15438ce95fd6f0d863631" translate="yes" xml:space="preserve">
          <source>Note: This is an experimental feature of OCaml: the set of APIs below, as well as their exact semantics are not final and subject to change in future releases.</source>
          <target state="translated">注意:这是OCaml的一个实验性功能:下面的一组API,以及它们的确切语义都不是最终的,在未来的版本中可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="823ecd73e96dee992922fa24d09d174fea0a6e57" translate="yes" xml:space="preserve">
          <source>Note: To prevent the interpretation of a &lt;code&gt;@&lt;/code&gt; character as a pretty-printing indication, escape it with a &lt;code&gt;%&lt;/code&gt; character. Old quotation mode &lt;code&gt;@@&lt;/code&gt; is deprecated since it is not compatible with formatted input interpretation of character &lt;code&gt;'@'&lt;/code&gt;.</source>
          <target state="translated">注意：为防止将 &lt;code&gt;@&lt;/code&gt; 字符解释为漂亮的印刷指示，请使用 &lt;code&gt;%&lt;/code&gt; 字符对其进行转义。不建议使用旧的报价模式 &lt;code&gt;@@&lt;/code&gt; ，因为它与字符 &lt;code&gt;'@'&lt;/code&gt; 的格式化输入解释不兼容。</target>
        </trans-unit>
        <trans-unit id="6d9bd6a881cbdf7f9df1e298990c77110c41a774" translate="yes" xml:space="preserve">
          <source>Note: When changing to a low-fragmentation policy, you may need to augment the &lt;code&gt;space_overhead&lt;/code&gt; setting, for example using &lt;code&gt;100&lt;/code&gt; instead of the default &lt;code&gt;80&lt;/code&gt; which is tuned for next-fit. Indeed, the difference in fragmentation behavior means that different policies will have different proportion of &quot;wasted space&quot; for a given program. Less fragmentation means a smaller heap so, for the same amount of wasted space, a higher proportion of wasted space. This makes the GC work harder, unless you relax it by increasing &lt;code&gt;space_overhead&lt;/code&gt;.</source>
          <target state="translated">注意：当更改为低碎片策略时，您可能需要增加 &lt;code&gt;space_overhead&lt;/code&gt; 设置，例如使用 &lt;code&gt;100&lt;/code&gt; 而不是为下一个调整调整的默认 &lt;code&gt;80&lt;/code&gt; 。实际上，碎片行为的差异意味着对于给定的程序，不同的策略将具有不同比例的&amp;ldquo;浪费空间&amp;rdquo;。较少的碎片意味着较小的堆，因此，对于相同数量的浪费空间，更高比例的浪费空间。除非您通过增加 &lt;code&gt;space_overhead&lt;/code&gt; 放松它，否则这会使GC更加努力地工作。</target>
        </trans-unit>
        <trans-unit id="e1c53f545ae2f49916857c5dbc74afbbb3f17b01" translate="yes" xml:space="preserve">
          <source>Note: a scanning action may often require to examine one character in advance; when this 'lookahead' character does not belong to the token read, it is stored back in the scanning buffer and becomes the next character yet to be read.</source>
          <target state="translated">注意:扫描操作可能经常需要提前检查一个字符;当这个 &quot;lookahead &quot;字符不属于读取的令牌时,它将被存储回扫描缓冲区,成为下一个尚未读取的字符。</target>
        </trans-unit>
        <trans-unit id="1704bf03b020589de313c230890a2e46b48b94e8" translate="yes" xml:space="preserve">
          <source>Note: all directives start with a # (sharp) symbol. This # must be typed before the directive, and must not be confused with the # prompt displayed by the interactive loop. For instance, typing #quit;; will exit the toplevel loop, but typing quit;; will result in an &amp;ldquo;unbound value quit&amp;rdquo; error.</source>
          <target state="translated">注意：所有指令均以＃（尖锐）符号开头。该＃必须在指令之前键入，并且不得与交互式循环显示的＃提示混淆。例如，键入#quit ;;。将退出顶层循环，但键入quit ;; 将导致&amp;ldquo;未绑定值退出&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="661bb9a4a4fadd61ccae3d7f4cea4d69fb6a3c2a" translate="yes" xml:space="preserve">
          <source>Note: all input/output functions can raise &lt;code&gt;Sys_error&lt;/code&gt; when the system calls they invoke fail.</source>
          <target state="translated">注意：当系统调用调用失败时，所有输入/输出函数都会引发 &lt;code&gt;Sys_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f409c4273c4016899888e40b1686a702c39d6ff" translate="yes" xml:space="preserve">
          <source>Note: all the functions of this module (except &lt;a href=&quot;unix#VALerror_message&quot;&gt;&lt;code&gt;Unix.error_message&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALhandle_unix_error&quot;&gt;&lt;code&gt;Unix.handle_unix_error&lt;/code&gt;&lt;/a&gt;) are liable to raise the &lt;a href=&quot;unix#EXCEPTIONUnix_error&quot;&gt;&lt;code&gt;Unix.Unix_error&lt;/code&gt;&lt;/a&gt; exception whenever the underlying system call signals an error.</source>
          <target state="translated">注意：每当基础系统调用发出错误信号时，此模块的所有功能（&lt;a href=&quot;unix#VALerror_message&quot;&gt; &lt;code&gt;Unix.error_message&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unix#VALhandle_unix_error&quot;&gt; &lt;code&gt;Unix.handle_unix_error&lt;/code&gt; &lt;/a&gt;除外）都可能引发&lt;a href=&quot;unix#EXCEPTIONUnix_error&quot;&gt; &lt;code&gt;Unix.Unix_error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="79908ccb7a82d0caccd2893700ccad147b944a43" translate="yes" xml:space="preserve">
          <source>Note: all the functions of this module (except &lt;a href=&quot;unixlabels#VALerror_message&quot;&gt;&lt;code&gt;UnixLabels.error_message&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALhandle_unix_error&quot;&gt;&lt;code&gt;UnixLabels.handle_unix_error&lt;/code&gt;&lt;/a&gt;) are liable to raise the &lt;a href=&quot;unixlabels#EXCEPTIONUnix_error&quot;&gt;&lt;code&gt;UnixLabels.Unix_error&lt;/code&gt;&lt;/a&gt; exception whenever the underlying system call signals an error.</source>
          <target state="translated">注意：只要基础系统调用发出错误信号，此模块的所有功能（&lt;a href=&quot;unixlabels#VALerror_message&quot;&gt; &lt;code&gt;UnixLabels.error_message&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unixlabels#VALhandle_unix_error&quot;&gt; &lt;code&gt;UnixLabels.handle_unix_error&lt;/code&gt; &lt;/a&gt;除外）都可能引发&lt;a href=&quot;unixlabels#EXCEPTIONUnix_error&quot;&gt; &lt;code&gt;UnixLabels.Unix_error&lt;/code&gt; &lt;/a&gt;异常。</target>
        </trans-unit>
        <trans-unit id="9881244812e43ce519dbdb2a33d7a86a78dc2b73" translate="yes" xml:space="preserve">
          <source>Note: changing the allocation policy at run-time forces a heap compaction, which is a lengthy operation unless the heap is small (e.g. at the start of the program).</source>
          <target state="translated">注意:在运行时改变分配策略会强制进行堆压缩,这是一个漫长的操作,除非堆很小(例如在程序开始时)。</target>
        </trans-unit>
        <trans-unit id="8e740cc9128b3de503776a812fd3bb3f85d80f59" translate="yes" xml:space="preserve">
          <source>Note: do not use the C int type in correspondence with (int [@untagged]). This is because they often differ in size.</source>
          <target state="translated">注意:不要用C int类型与(int [@untagged])对应。因为它们的大小往往不同。</target>
        </trans-unit>
        <trans-unit id="32f28c1f397eec585fd0b2e1caaaf11772a9b784" translate="yes" xml:space="preserve">
          <source>Note: if the program is compiled with the &lt;code&gt;-rectypes&lt;/code&gt; option, ill-founded recursive definitions of the form &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy&amp;nbsp;x&lt;/code&gt; or &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy(lazy(...(lazy&amp;nbsp;x)))&lt;/code&gt; are accepted by the type-checker and lead, when forced, to ill-formed values that trigger infinite loops in the garbage collector and other parts of the run-time system. Without the &lt;code&gt;-rectypes&lt;/code&gt; option, such ill-founded recursive definitions are rejected by the type-checker.</source>
          <target state="translated">注意：如果使用 &lt;code&gt;-rectypes&lt;/code&gt; 选项编译程序，则该类型将接受格式为 &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy&amp;nbsp;x&lt;/code&gt; 或 &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy(lazy(...(lazy&amp;nbsp;x)))&lt;/code&gt; 不当发现的递归定义-checker并在强制使用时导致格式错误的值，这些值会触发垃圾回收器和运行时系统其他部分中的无限循环。如果不使用 &lt;code&gt;-rectypes&lt;/code&gt; 选项，则类型检查器将拒绝这种根基不确的递归定义。</target>
        </trans-unit>
        <trans-unit id="ebef76f46f02ed8c6dbb4a7a51649415bd9b78c4" translate="yes" xml:space="preserve">
          <source>Note: in order to insure that the dynamically-loaded modules have access to all the libraries that are visible to the main program (and not just to the parts of those libraries that are actually used in the main program), programs using the dynlink library should be linked with -linkall.</source>
          <target state="translated">注意:为了确保动态加载的模块能够访问主程序可见的所有库(而不仅仅是主程序中实际使用的那些库的部分),使用dynlink库的程序应该用-linkall链接。</target>
        </trans-unit>
        <trans-unit id="38ff267a2f14d6dd07cded0766c39d2aeb6bc63e" translate="yes" xml:space="preserve">
          <source>Note: in the case of &lt;code&gt;global_substitute&lt;/code&gt; and &lt;code&gt;substitute_first&lt;/code&gt;, a call to &lt;code&gt;matched_string&lt;/code&gt; is only valid within the &lt;code&gt;subst&lt;/code&gt; argument, not after &lt;code&gt;global_substitute&lt;/code&gt; or &lt;code&gt;substitute_first&lt;/code&gt; returns.</source>
          <target state="translated">注：在的情况下 &lt;code&gt;global_substitute&lt;/code&gt; 和 &lt;code&gt;substitute_first&lt;/code&gt; ，将呼叫 &lt;code&gt;matched_string&lt;/code&gt; 只是内有效 &lt;code&gt;subst&lt;/code&gt; 的说法，而不是之后 &lt;code&gt;global_substitute&lt;/code&gt; 或 &lt;code&gt;substitute_first&lt;/code&gt; 回报。</target>
        </trans-unit>
        <trans-unit id="922b543ff896ef77cd9d8044969360c9a53c3cbf" translate="yes" xml:space="preserve">
          <source>Note: in the interactive system, when input is read from &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, the newline character that triggers evaluation is part of the input; thus, the scanning specifications must properly skip this additional newline character (for instance, simply add a &lt;code&gt;'\n'&lt;/code&gt; as the last character of the format string).</source>
          <target state="translated">注意：在交互式系统中，当从&lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; 中&lt;/a&gt;读取输入时，触发评估的换行符是输入的一部分；因此，扫描规范必须正确跳过此附加的换行符（例如，只需添加 &lt;code&gt;'\n'&lt;/code&gt; 作为格式字符串的最后一个字符）。</target>
        </trans-unit>
        <trans-unit id="145e7cd4d750ab522e65fe8e15a2f8018a1e2e0d" translate="yes" xml:space="preserve">
          <source>Note: installation of signal handlers is performed via the functions &lt;a href=&quot;sys#VALsignal&quot;&gt;&lt;code&gt;Sys.signal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#VALset_signal&quot;&gt;&lt;code&gt;Sys.set_signal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意：信号处理程序的安装是通过&lt;a href=&quot;sys#VALsignal&quot;&gt; &lt;code&gt;Sys.signal&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;sys#VALset_signal&quot;&gt; &lt;code&gt;Sys.set_signal&lt;/code&gt; &lt;/a&gt;函数执行的。</target>
        </trans-unit>
        <trans-unit id="629c5048579fb0ed4f8a77f6a5cbc67a5d0b3404" translate="yes" xml:space="preserve">
          <source>Note: it is not recommended to use warning sets (i.e. letters) as arguments to -warn-error in production code, because this can break your build when future versions of OCaml add some new warnings.</source>
          <target state="translated">注意:不建议在生产代码中使用警告集(即字母)作为-warn-error的参数,因为当未来的OCaml版本添加一些新的警告时,这会破坏你的构建。</target>
        </trans-unit>
        <trans-unit id="443e1ada797e5067adc60f24f10b243b6714e1e3" translate="yes" xml:space="preserve">
          <source>Note: never use &lt;code&gt;print_flush&lt;/code&gt; in the normal course of a pretty-printing routine, since the pretty-printer uses a complex buffering machinery to properly indent the output; manually flushing those buffers at random would conflict with the pretty-printer strategy and result to poor rendering.</source>
          <target state="translated">注意：绝不 &lt;code&gt;print_flush&lt;/code&gt; 在漂亮打印例程的正常过程中使用print_flush，因为漂亮打印机使用复杂的缓冲机制来适当地缩进输出。手动随机刷新这些缓冲区将与漂亮打印机策略冲突，并导致较差的渲染。</target>
        </trans-unit>
        <trans-unit id="9341c4536efd6e856d0cfcbf40db0f74c45c131a" translate="yes" xml:space="preserve">
          <source>Note: printing within tabulation box is line directed, so arbitrary line splitting inside a tabulation box leads to poor rendering. Yet, controlled use of tabulation boxes allows simple printing of columns within module &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意：在列表框中进行的打印是沿行方向进行的，因此在列表框中进行任意的行分割会导致渲染效果较差。然而，制表盒的受控使用允许在模块&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; 中&lt;/a&gt;简单地打印列。</target>
        </trans-unit>
        <trans-unit id="63aac78a82348d2aa75442bb5d55e79ba31ac133" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;cmp&lt;/code&gt; function will be called even if the lists have different lengths.</source>
          <target state="translated">注意：即使列表的长度不同，也会调用 &lt;code&gt;cmp&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="aebffc51f9fb16239843be4e6722cccd39a9129f" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;eq&lt;/code&gt; function may be called even if the lists have different length. If you know your equality function is costly, you may want to check &lt;a href=&quot;list#VALcompare_lengths&quot;&gt;&lt;code&gt;List.compare_lengths&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">注意：即使列表的长度不同，也可以调用 &lt;code&gt;eq&lt;/code&gt; 函数。如果您知道相等函数的成本&lt;a href=&quot;list#VALcompare_lengths&quot;&gt; &lt;code&gt;List.compare_lengths&lt;/code&gt; &lt;/a&gt;，则可能需要首先检查List.compare_lengths。</target>
        </trans-unit>
        <trans-unit id="517276021ef1d214b7e49458c6978d5ac4a8067f" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;eq&lt;/code&gt; function may be called even if the lists have different length. If you know your equality function is costly, you may want to check &lt;a href=&quot;listlabels#VALcompare_lengths&quot;&gt;&lt;code&gt;ListLabels.compare_lengths&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">注意：即使列表的长度不同，也可以调用 &lt;code&gt;eq&lt;/code&gt; 函数。如果您知道相等函数的成本&lt;a href=&quot;listlabels#VALcompare_lengths&quot;&gt; &lt;code&gt;ListLabels.compare_lengths&lt;/code&gt; &lt;/a&gt;，则可能需要首先检查ListLabels.compare_lengths。</target>
        </trans-unit>
        <trans-unit id="d9834335cf6fe5fc53b95c18382af756506e19d5" translate="yes" xml:space="preserve">
          <source>Note: the acquire and release functions described above were introduced in OCaml 3.12. Older code uses the following historical names, declared in &amp;lt;caml/signals.h&amp;gt;:</source>
          <target state="translated">注意：OCaml 3.12中引入了上述获取和释放功能。较旧的代码使用在&amp;lt;caml / signals.h&amp;gt;中声明的以下历史名称：</target>
        </trans-unit>
        <trans-unit id="2177e9bf34eb19b28eb32c96470882b643de2040" translate="yes" xml:space="preserve">
          <source>Note: the argument to &lt;code&gt;regexp&lt;/code&gt; is usually a string literal. In this case, any backslash character in the regular expression must be doubled to make it past the OCaml string parser. For example, the following expression:</source>
          <target state="translated">注意： &lt;code&gt;regexp&lt;/code&gt; 的参数通常是字符串文字。在这种情况下，正则表达式中的任何反斜杠字符都必须加倍以使其超过OCaml字符串解析器。例如，以下表达式：</target>
        </trans-unit>
        <trans-unit id="ffd47f5e6d4b6f57e31724916a1771922f810447" translate="yes" xml:space="preserve">
          <source>Note: the finalize, compare, hash, serialize and deserialize functions attached to custom block descriptors must never trigger a garbage collection. Within these functions, do not call any of the OCaml allocation functions, and do not perform a callback into OCaml code. Do not use CAMLparam to register the parameters to these functions, and do not use CAMLreturn to return the result.</source>
          <target state="translated">注意:附加在自定义块描述符上的finalize、compare、hash、serialize和deserialize函数绝对不能触发垃圾收集。在这些函数中,不要调用任何OCaml分配函数,也不要向OCaml代码中执行回调。不要使用CAMLparam来注册这些函数的参数,也不要使用CAMLreturn来返回结果。</target>
        </trans-unit>
        <trans-unit id="2fa124181f0ab52f95d5aba93b0fc5a2ffbf20f4" translate="yes" xml:space="preserve">
          <source>Note: the notions of space and line splitting are abstract for the pretty-printing engine, since those notions can be completely redefined by the programmer. However, in the pretty-printer default setting, ``output a space'' simply means printing a space character (ASCII code 32) and ``split the line'' means printing a newline character (ASCII code 10).</source>
          <target state="translated">注意:空格和分行的概念对于pretty-printing引擎来说是抽象的,因为这些概念完全可以由程序员重新定义。然而,在pretty-printer的默认设置中,&quot;输出空格 &quot;仅仅意味着打印一个空格字符(ASCII码32),&quot;分行 &quot;意味着打印一个换行字符(ASCII码10)。</target>
        </trans-unit>
        <trans-unit id="8057d5d098672ea84c975196f3af91fed42a2aa5" translate="yes" xml:space="preserve">
          <source>Note: the operators &amp;amp;&amp;amp;, ||, and ~- are handled specially and it is not advisable to change their meaning.</source>
          <target state="translated">注意：运算符&amp;amp;&amp;amp;，||和〜-是经过特殊处理的，不建议更改其含义。</target>
        </trans-unit>
        <trans-unit id="7efcff7406c86de78d66a3b54bdcef50f38f8039" translate="yes" xml:space="preserve">
          <source>Note: this API is EXPERIMENTAL. It may change without prior notice.</source>
          <target state="translated">注意:这个API是实验性的。它可能会改变,恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="6965dbae3f43f8571341ee41d021ab34917b0487" translate="yes" xml:space="preserve">
          <source>Note: this is not the normal way to output a new line; the preferred method is using break hints within a vertical pretty-printing box.</source>
          <target state="translated">注意:这不是正常的输出新行的方法,首选的方法是在一个垂直的漂亮打印框内使用断点提示。</target>
        </trans-unit>
        <trans-unit id="c7ebc2b8878898c4c60d71b3c20e680a573cda23" translate="yes" xml:space="preserve">
          <source>Note: this only applies to the native compiler. So whenever you use any of these methods, you have to provide an alternative byte-code stub that ignores all the special annotations.</source>
          <target state="translated">注意:这只适用于本地编译器。所以无论何时使用这些方法,你都必须提供一个替代的字节码存根,以忽略所有的特殊注解。</target>
        </trans-unit>
        <trans-unit id="87c9f2b925633b8f6e73b9bf63c5cdc7777edeca" translate="yes" xml:space="preserve">
          <source>Note: this possibility is offered only for backward compatibility with older versions of OCaml and will be removed in a future version. New code should use byte sequences and the Bytes.set function.</source>
          <target state="translated">注意:这种可能性只是为了向后兼容旧版本的OCaml而提供的,并将在未来的版本中删除。新代码应该使用字节序列和Bytes.set函数。</target>
        </trans-unit>
        <trans-unit id="4d8d829c25ab6089d7e4980f899718094fb71afc" translate="yes" xml:space="preserve">
          <source>Note: when a label declaration is followed by a semi-colon, attributes can also be put after the semi-colon (in which case they are merged to those specified before).</source>
          <target state="translated">注意:当标签声明后面有分号时,属性也可以放在分号后面(在这种情况下,它们会被合并到前面指定的属性)。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="d5e45a48a978d6899712bd076f72479aeea810fa" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;d&lt;/code&gt; is smaller than 2.</source>
          <target state="translated">如果 &lt;code&gt;d&lt;/code&gt; 小于2，则什么也不会发生。</target>
        </trans-unit>
        <trans-unit id="39fb7c03e6cb136de7fbdb71a619368064c85b64" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;max&lt;/code&gt; is smaller than 2.</source>
          <target state="translated">如果 &lt;code&gt;max&lt;/code&gt; 小于2，则不会发生任何事情。</target>
        </trans-unit>
        <trans-unit id="cfa95920bb8194bd4a2ebe309a76e0b3b76edccd" translate="yes" xml:space="preserve">
          <source>Notice that in the vec case, we are calling the single index operator, (.%{}), and not the multi-index variant, (.{;..}). For this reason, it is expected that most users of multi-index operators will need to define conjointly a single index variant</source>
          <target state="translated">请注意,在 vec 的情况下,我们调用的是单索引操作符 (.%{}),而不是多索引变体 (.{;...})。出于这个原因,预计大多数多索引操作符的用户将需要共同定义一个单索引变体。</target>
        </trans-unit>
        <trans-unit id="dc088a60c877ce62f962886fe65bf44f1be80800" translate="yes" xml:space="preserve">
          <source>Notice that it is not possible to pass options to ocamlrun when invoking a.out directly.</source>
          <target state="translated">注意,当直接调用a.out时,不可能向ocamlrun传递选项。</target>
        </trans-unit>
        <trans-unit id="74aaf1392791cdacd5b251b350a4fa759d0daf50" translate="yes" xml:space="preserve">
          <source>Notice that our function call above prints &amp;ldquo;lazy_two evaluation&amp;rdquo; and then returns the plain value of the computation.</source>
          <target state="translated">请注意，上面的函数调用将打印&amp;ldquo; lazy_two评估&amp;rdquo;，然后返回计算的纯值。</target>
        </trans-unit>
        <trans-unit id="4c42130e4cbfad9b1ab31f04d64c0912792bf5e1" translate="yes" xml:space="preserve">
          <source>Notice that the bytecode libraries unix.cma and threads.cma must be given twice: when building the runtime system (so that ocamlc knows which C primitives are required) and also when building the bytecode executable (so that the bytecode from unix.cma and threads.cma is actually linked in).</source>
          <target state="translated">请注意,字节码库unix.cma和threads.cma必须给出两次:在构建运行时系统时(这样ocamlc就知道需要哪些C基元),以及在构建字节码可执行文件时(这样unix.cma和threads.cma的字节码才会真正链接进来)。</target>
        </trans-unit>
        <trans-unit id="6f0646640caf022897bba768e601eae5583de16c" translate="yes" xml:space="preserve">
          <source>Now for a real symbolic processing, we define the derivative of an expression with respect to a variable dv:</source>
          <target state="translated">现在对于真正的符号处理,我们定义一个表达式相对于变量dv的导数。</target>
        </trans-unit>
        <trans-unit id="d31c772d9b3d93fe10a1d16923ec1381b4e0e40a" translate="yes" xml:space="preserve">
          <source>Now if we annotate the arguments and result with [@unboxed], the native-code compiler will be able to avoid all these allocations:</source>
          <target state="translated">现在,如果我们用[@unboxed]注释参数和结果,本地代码编译器将能够避免所有这些分配。</target>
        </trans-unit>
        <trans-unit id="4c9da36ea65d19919b99ea34d11ca3b1c7c4a4a7" translate="yes" xml:space="preserve">
          <source>Now if we look at the value of lazy_two, we see that it is not displayed as &amp;lt;lazy&amp;gt; anymore but as lazy 2.</source>
          <target state="translated">现在，如果我们看一下lazy_two的值，我们会发现它不再显示为&amp;lt;lazy&amp;gt;，而是显示为lazy 2。</target>
        </trans-unit>
        <trans-unit id="e70cad05eff4f060c1122a9df879ce632eabd808" translate="yes" xml:space="preserve">
          <source>Now, here is a sample OCaml program prog.ml that uses the curses module:</source>
          <target state="translated">现在,这里有一个使用curses模块的OCaml示例程序prog.ml。</target>
        </trans-unit>
        <trans-unit id="bb1a9455d741ea437460b8735fa1fd8568d51cbd" translate="yes" xml:space="preserve">
          <source>Now, we can use the two functions fib and format_result in any C program, just like regular C functions. Just remember to call caml_startup (or caml_startup_exn) once before.</source>
          <target state="translated">现在,我们可以在任何C程序中使用fib和format_result这两个函数,就像普通的C函数一样。只要记得在调用caml_startup(或caml_startup_exn)之前,先调用一次caml_startup。</target>
        </trans-unit>
        <trans-unit id="3138d7df51fb63c0581ea81498fd68c3e05c37c6" translate="yes" xml:space="preserve">
          <source>Number is 0.0 or -0.0</source>
          <target state="translated">数字为0.0或-0.0。</target>
        </trans-unit>
        <trans-unit id="599fcc81bb79a4df28a99bc27dc454bdb406e359" translate="yes" xml:space="preserve">
          <source>Number is positive or negative infinity</source>
          <target state="translated">数字是正负无穷大</target>
        </trans-unit>
        <trans-unit id="dd6a12894e1886f16551dce8aa6a476046e0e378" translate="yes" xml:space="preserve">
          <source>Number of bindings present in the table. Same value as returned by &lt;a href=&quot;hashtbl#VALlength&quot;&gt;&lt;code&gt;Hashtbl.length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">表中存在的绑定数。与&lt;a href=&quot;hashtbl#VALlength&quot;&gt; &lt;code&gt;Hashtbl.length&lt;/code&gt; &lt;/a&gt;返回的值相同。</target>
        </trans-unit>
        <trans-unit id="c3019c43254ba4df6dd4a5febe0a3c1e3603da20" translate="yes" xml:space="preserve">
          <source>Number of bindings present in the table. Same value as returned by &lt;a href=&quot;morelabels.hashtbl#VALlength&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">表中存在的绑定数。与&lt;a href=&quot;morelabels.hashtbl#VALlength&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.length&lt;/code&gt; &lt;/a&gt;返回的值相同。</target>
        </trans-unit>
        <trans-unit id="6c993eaebae88d7a870c6aedb7b2959b80e3c4ac" translate="yes" xml:space="preserve">
          <source>Number of bits per character (5-8).</source>
          <target state="translated">每个字符的位数(5-8)。</target>
        </trans-unit>
        <trans-unit id="556c7d37711ec6f2f70fe3dcea838b8ca1371010" translate="yes" xml:space="preserve">
          <source>Number of blocks in the free list.</source>
          <target state="translated">自由列表中的块数。</target>
        </trans-unit>
        <trans-unit id="b30e61fc6036da5db3f139d2340ea9277079b7a3" translate="yes" xml:space="preserve">
          <source>Number of buckets in the table.</source>
          <target state="translated">表中的桶数。</target>
        </trans-unit>
        <trans-unit id="fd43d1f40b17a39ffbd688d74199162e00feb899" translate="yes" xml:space="preserve">
          <source>Number of contiguous pieces of memory that make up the major heap.</source>
          <target state="translated">构成主要堆的连续内存片数。</target>
        </trans-unit>
        <trans-unit id="35ee259bd3c41fa404a37a53bd7edb78724bd92e" translate="yes" xml:space="preserve">
          <source>Number of forced full major collections completed since the program was started.</source>
          <target state="translated">自方案启动以来完成的强制全额大额收款的数量。</target>
        </trans-unit>
        <trans-unit id="22bfd01520799f6fb0b893646db43e4eff4024a4" translate="yes" xml:space="preserve">
          <source>Number of heap compactions since the program was started.</source>
          <target state="translated">自程序启动以来的堆压缩次数。</target>
        </trans-unit>
        <trans-unit id="a3275a16ef5f550e3a9777e377a1e501bfdab390" translate="yes" xml:space="preserve">
          <source>Number of links</source>
          <target state="translated">链接数</target>
        </trans-unit>
        <trans-unit id="ea1a2280ac441cab2cdb5c0495373425c8df6602" translate="yes" xml:space="preserve">
          <source>Number of live blocks in the major heap.</source>
          <target state="translated">主要堆中的活块数。</target>
        </trans-unit>
        <trans-unit id="f456114fcb5877ccbceb91eb404b219b9ce44ade" translate="yes" xml:space="preserve">
          <source>Number of major collection cycles completed since the program was started.</source>
          <target state="translated">自方案开始以来完成的主要收集周期的数量。</target>
        </trans-unit>
        <trans-unit id="9386df61202e08b36cb678baacc9b23f2a02d67b" translate="yes" xml:space="preserve">
          <source>Number of minor collections since the program was started.</source>
          <target state="translated">自该方案开始以来,小规模收藏的数量。</target>
        </trans-unit>
        <trans-unit id="809a46ad96dee431d9a0e29595d29eae99894471" translate="yes" xml:space="preserve">
          <source>Number of stop bits (1-2).</source>
          <target state="translated">停止位数(1-2)。</target>
        </trans-unit>
        <trans-unit id="68d3ddb5d0c96281ae43ec9c22a0b4e3422e79bf" translate="yes" xml:space="preserve">
          <source>Number of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.</source>
          <target state="translated">由于碎片化造成的浪费字数。这些是放在两个活块之间的1个字的自由块。它们不能用于分配。</target>
        </trans-unit>
        <trans-unit id="ce81b5c3bd146557576eb8ed07acd1dffea0dab3" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the major heap, including the promoted words, since the program was started.</source>
          <target state="translated">自程序启动以来,主要堆中分配的字数,包括推广的字数。</target>
        </trans-unit>
        <trans-unit id="d5ca08671f1b43ba25ac654a59ea877d2a2b67a5" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap since the program was started.</source>
          <target state="translated">自程序启动以来,小堆中分配的字数。</target>
        </trans-unit>
        <trans-unit id="2252886aac21fa9ff4a9c573d75468a53aea2f8b" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap since the program was started. This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.</source>
          <target state="translated">自程序启动以来,在小堆中分配的字数,这个数字在字节码程序中是准确的,但在编译为本地代码的程序中只是近似值。这个数字在字节码程序中是准确的,但在编译成本地代码的程序中只是一个近似值。</target>
        </trans-unit>
        <trans-unit id="f7984519fd15afeac8c64ab5080cc953cb9c00a2" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.</source>
          <target state="translated">在小堆中分配的字数,这些字数在小堆中存活下来,并在程序开始后被移到大堆中。</target>
        </trans-unit>
        <trans-unit id="c8f31dc5c12c1a7f06ec7bd177c5b77d43639c8d" translate="yes" xml:space="preserve">
          <source>Number of words in the free list.</source>
          <target state="translated">自由列表中的字数。</target>
        </trans-unit>
        <trans-unit id="89158a98cc97e9ec991a351e0adf4b876875a73a" translate="yes" xml:space="preserve">
          <source>Number of words of live data in the major heap, including the header words.</source>
          <target state="translated">主要堆中活数据的字数,包括头字。</target>
        </trans-unit>
        <trans-unit id="4497ca18a980559e81799d511efa2fbf2cfc2a06" translate="yes" xml:space="preserve">
          <source>Number very close to 0.0, has reduced precision</source>
          <target state="translated">数值非常接近0.0,精度下降</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="7a33aed24260554ed4044e957096dba2b5814942" translate="yes" xml:space="preserve">
          <source>OCAMLLIB</source>
          <target state="translated">OCAMLLIB</target>
        </trans-unit>
        <trans-unit id="18f162a99ff8d53ff64a6b4e151cb31d5e551861" translate="yes" xml:space="preserve">
          <source>OCAMLPARAM (environment variable)</source>
          <target state="translated">OCAMLPARAM(可变环境)</target>
        </trans-unit>
        <trans-unit id="63bde53850374ed2ceaca560296ca5ae4288cfc9" translate="yes" xml:space="preserve">
          <source>OCAMLRUNPARAM</source>
          <target state="translated">OCAMLRUNPARAM</target>
        </trans-unit>
        <trans-unit id="5a645a796dc3a615a92ec7a9d69a83018587cfd3" translate="yes" xml:space="preserve">
          <source>OCAMLTOP_INCLUDE_PATH</source>
          <target state="translated">OCAMLTOP_INCLUDE_PATH</target>
        </trans-unit>
        <trans-unit id="8d2f44eaaa8da1e94f7c788d8bdd29ded4da06e4" translate="yes" xml:space="preserve">
          <source>OCAMLTOP_UTF_8</source>
          <target state="translated">OCAMLTOP_UTF_8</target>
        </trans-unit>
        <trans-unit id="ad1263844890ea6d4fa757c36f64dd4aa02ae452" translate="yes" xml:space="preserve">
          <source>OCAML_EVENTLOG_ENABLED can be set to the p flag in order to start the program with event collection paused.</source>
          <target state="translated">OCAML_EVENTLOG_ENABLED可以设置为p标志,以便在暂停事件收集的情况下启动程序。</target>
        </trans-unit>
        <trans-unit id="5452f25317c588b2d021a1ead667fb17370d1d55" translate="yes" xml:space="preserve">
          <source>OCAML_FLEXLINK</source>
          <target state="translated">OCAML_FLEXLINK</target>
        </trans-unit>
        <trans-unit id="180089a275079837ea5e6f4afd0b87d27e4469c6" translate="yes" xml:space="preserve">
          <source>OCAML_FLEXLINK (environment variable)</source>
          <target state="translated">OCAML_FLEXLINK (环境变量)</target>
        </trans-unit>
        <trans-unit id="0cdddb7074ce2b9a9f470e52afd10a9b95816171" translate="yes" xml:space="preserve">
          <source>OCaml allows us to defer some computation until later when we need the result of that computation.</source>
          <target state="translated">OCaml允许我们将一些计算推迟到以后需要计算结果的时候进行。</target>
        </trans-unit>
        <trans-unit id="40aa7560087d20b8f8199f53d34735d850d308b1" translate="yes" xml:space="preserve">
          <source>OCaml code executing in the traditional toplevel system uses the bytecode interpreter. When increased performance is required, or for testing programs that will only execute correctly when compiled to native code, the &lt;em&gt;native toplevel&lt;/em&gt; may be used instead.</source>
          <target state="translated">在传统顶级系统中执行的OCaml代码使用字节码解释器。如果需要提高性能，或者要测试仅在编译为本机代码后才能正确执行的程序，则可以使用本&lt;em&gt;机顶级&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="267c01d6c4260bac5e8f28a01de2593eca32db2c" translate="yes" xml:space="preserve">
          <source>OCaml has no built-in notion of variable &amp;ndash; identifiers whose current value can be changed by assignment. (The let binding is not an assignment, it introduces a new identifier with a new scope.) However, the standard library provides references, which are mutable indirection cells, with operators ! to fetch the current contents of the reference and := to assign the contents. Variables can then be emulated by let-binding a reference. For instance, here is an in-place insertion sort over arrays:</source>
          <target state="translated">OCaml没有内置的变量概念，即可以通过赋值更改其当前值的标识符。（let绑定不是赋值，它引入了具有新作用域的新标识符。）但是，标准库提供了引用，这些引用是带有操作符的可变间接单元格！获取引用的当前内容，并使用：=分配内容。然后可以通过让绑定绑定引用来模拟变量。例如，这是对数组的就地插入排序：</target>
        </trans-unit>
        <trans-unit id="5cb3adc8841417401cbe5cbf1dccabafc62d9c42" translate="yes" xml:space="preserve">
          <source>OCaml integers (signed, 31 bits on 32-bit architectures, 63 bits on 64-bit architectures) (&lt;a href=&quot;bigarray#TYPEint_elt&quot;&gt;&lt;code&gt;Bigarray.int_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">OCaml整数（带符号，在32位架构上为31位，在64位架构上为63位）（&lt;a href=&quot;bigarray#TYPEint_elt&quot;&gt; &lt;code&gt;Bigarray.int_elt&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="64a9ccb34887b4bee6ea9726429d33718de72371" translate="yes" xml:space="preserve">
          <source>OCaml is a functional language: functions in the full mathematical sense are supported and can be passed around freely just as any other piece of data. For instance, here is a deriv function that takes any float function as argument and returns an approximation of its derivative function:</source>
          <target state="translated">OCaml是一种函数式语言:支持完全数学意义上的函数,并且可以像其他数据一样自由传递。例如,这里有一个导数函数,它接受任何浮动函数作为参数,并返回其导数函数的近似值。</target>
        </trans-unit>
        <trans-unit id="3ef8c1d2377beafebd9185056587e4432d10a17d" translate="yes" xml:space="preserve">
          <source>OCaml provides exceptions for signalling and handling exceptional conditions. Exceptions can also be used as a general-purpose non-local control structure, although this should not be overused since it can make the code harder to understand. Exceptions are declared with the exception construct, and signalled with the raise operator. For instance, the function below for taking the head of a list uses an exception to signal the case where an empty list is given.</source>
          <target state="translated">OCaml提供了用于信号和处理特殊情况的异常。异常也可以作为一种通用的非局部控制结构,不过不应该过度使用,因为这会使代码更难理解。异常用异常结构来声明,并用 raise 操作符发出信号。例如,下面的取列表头的函数在给出空列表的情况下使用异常信号。</target>
        </trans-unit>
        <trans-unit id="5bb9dff10bdb65bfb239e824ad6d8af0b7cc9004" translate="yes" xml:space="preserve">
          <source>OCaml runs on several operating systems. The parts of this manual that are specific to one operating system are presented as shown below:</source>
          <target state="translated">OCaml可以在多个操作系统上运行。本手册中特定于某一操作系统的部分如下所示。</target>
        </trans-unit>
        <trans-unit id="1726ed3129ec43182a952dcd0e32f27c1495a2bf" translate="yes" xml:space="preserve">
          <source>OCaml source files and object files (.cmo, .cmx, .ml) comprising the OCaml part of the library;</source>
          <target state="translated">OCaml源文件和对象文件(.cmo,.cmx,.ml)组成库的OCaml部分。</target>
        </trans-unit>
        <trans-unit id="f9b33a87ea85672b2f3dc3cc175ebdefe40c9d34" translate="yes" xml:space="preserve">
          <source>OCaml supports the assert construct to check debugging assertions. The expression assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and returns () if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to true. If it evaluates to false the exception Assert_failure is raised with the source file name and the location of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as arguments. Assertion checking can be turned off with the -noassert compiler option. In this case, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at all.</source>
          <target state="translated">OCaml支持断言构造以检查调试断言。表达式assert &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;评估表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;，如果&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;评估为true ，则返回（）。如果它的计算结果为false，则会引发Assert_failure异常，并将源文件名和&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的位置作为参数。可以使用-noassert编译器选项关闭断言检查。在这种情况下，根本不会评估&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c85e2232603a9909d0b7ff1b3926fe7e6d893e4" translate="yes" xml:space="preserve">
          <source>OCaml type</source>
          <target state="translated">OCaml型</target>
        </trans-unit>
        <trans-unit id="62d72b1edf8e07e587e3d50ac25c27ae51c1a8cd" translate="yes" xml:space="preserve">
          <source>OCaml's floating-point numbers follow the IEEE 754 standard, using double precision (64 bits) numbers. Floating-point operations never raise an exception on overflow, underflow, division by zero, etc. Instead, special IEEE numbers are returned as appropriate, such as &lt;code&gt;infinity&lt;/code&gt; for &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, &lt;code&gt;neg_infinity&lt;/code&gt; for &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, and &lt;code&gt;nan&lt;/code&gt; ('not a number') for &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;. These special numbers then propagate through floating-point computations as expected: for instance, &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; is &lt;code&gt;0.0&lt;/code&gt;, and any arithmetic operation with &lt;code&gt;nan&lt;/code&gt; as argument returns &lt;code&gt;nan&lt;/code&gt; as result.</source>
          <target state="translated">OCaml的浮点数遵循IEEE 754标准，使用双精度（64位）数字。浮点运算永远不会被零提高对溢，下溢，分裂异常，等等。相反，特殊的IEEE号将返回适当的，如 &lt;code&gt;infinity&lt;/code&gt; 为 &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; ， &lt;code&gt;neg_infinity&lt;/code&gt; 为 &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; 和 &lt;code&gt;nan&lt;/code&gt; （'not a number'）表示 &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; 。然后，这些特殊数字将按预期方式通过浮点计算传播：例如 &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; 是 &lt;code&gt;0.0&lt;/code&gt; ，任何以 &lt;code&gt;nan&lt;/code&gt; 作为参数的算术运算都将 &lt;code&gt;nan&lt;/code&gt; 作为结果返回。</target>
        </trans-unit>
        <trans-unit id="5200ab6029faacafa8905f9af598bec7c22a9ce3" translate="yes" xml:space="preserve">
          <source>OCaml's floating-point numbers follow the IEEE 754 standard, using double precision (64 bits) numbers. Floating-point operations never raise an exception on overflow, underflow, division by zero, etc. Instead, special IEEE numbers are returned as appropriate, such as &lt;code&gt;infinity&lt;/code&gt; for &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, &lt;code&gt;neg_infinity&lt;/code&gt; for &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, and &lt;code&gt;nan&lt;/code&gt; ('not a number') for &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;. These special numbers then propagate through floating-point computations as expected: for instance, &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; is &lt;code&gt;0.0&lt;/code&gt;, basic arithmetic operations (&lt;code&gt;+.&lt;/code&gt;, &lt;code&gt;-.&lt;/code&gt;, &lt;code&gt;*.&lt;/code&gt;, &lt;code&gt;/.&lt;/code&gt;) with &lt;code&gt;nan&lt;/code&gt; as an argument return &lt;code&gt;nan&lt;/code&gt;, ...</source>
          <target state="translated">OCaml的浮点数遵循IEEE 754标准，使用双精度（64位）数字。浮点运算永远不会被零提高对溢，下溢，分裂异常，等等。相反，特殊的IEEE号将返回适当的，如 &lt;code&gt;infinity&lt;/code&gt; 为 &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; ， &lt;code&gt;neg_infinity&lt;/code&gt; 为 &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; 和 &lt;code&gt;nan&lt;/code&gt; （'not a number'）表示 &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; 。然后，这些特殊数字将按预期方式通过浮点计算传播：例如 &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; 是 &lt;code&gt;0.0&lt;/code&gt; ，是基本的算术运算符（ &lt;code&gt;+.&lt;/code&gt; ， &lt;code&gt;-.&lt;/code&gt; ， &lt;code&gt;*.&lt;/code&gt; ， &lt;code&gt;/.&lt;/code&gt; ）以 &lt;code&gt;nan&lt;/code&gt; 作为参数返回 &lt;code&gt;nan&lt;/code&gt; ，...</target>
        </trans-unit>
        <trans-unit id="bd9ec7fcee833e36e4b14ae69e1e560823d2194a" translate="yes" xml:space="preserve">
          <source>OCamldoc calls the OCaml type-checker to obtain type information. The following options impact the type-checking phase. They have the same meaning as for the ocamlc and ocamlopt commands.</source>
          <target state="translated">OCamldoc调用OCaml类型检查器来获取类型信息。以下选项会影响类型检查阶段。它们的意义与ocamlc和ocamlopt命令相同。</target>
        </trans-unit>
        <trans-unit id="e9fd7b104be92b2bbccb12043665773616dd39a8" translate="yes" xml:space="preserve">
          <source>OCamldoc can associate comments to some elements of the language encountered in the source files. The association is made according to the locations of comments with respect to the language elements. The locations of comments in .mli and .ml files are different.</source>
          <target state="translated">OCamldoc可以将注释与源文件中遇到的一些语言元素相关联。这种关联是根据注释相对于语言元素的位置进行的。.mli和.ml文件中注释的位置是不同的。</target>
        </trans-unit>
        <trans-unit id="b300cd09621c9734759f5eb8f185eb95b76cf98e" translate="yes" xml:space="preserve">
          <source>OCamldoc can produce documentation in various formats: HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X, TeXinfo, Unix man pages, and dot dependency graphs. Moreover, users can add their own custom generators, as explained in section &lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;15.3&lt;/a&gt;.</source>
          <target state="translated">OCamldoc可以在各种格式的文档制作：HTML，L&lt;sup&gt;一&lt;/sup&gt;牛逼&lt;sub&gt;&amp;eacute;&lt;/sub&gt; X，TEXINFO，Unix手册页和点的依赖关系图。此外，用户可以添加自己的自定义生成器，如&lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;15.3&lt;/a&gt;节中所述。</target>
        </trans-unit>
        <trans-unit id="faec01ad8468873527336baad11c51145d082115" translate="yes" xml:space="preserve">
          <source>OCamldoc can produce documentation in various formats: HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X, TeXinfo, Unix man pages, and dot dependency graphs. Moreover, users can add their own custom generators, as explained in section &lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;16.3&lt;/a&gt;.</source>
          <target state="translated">OCamldoc可以在各种格式的文档制作：HTML，L&lt;sup&gt;一&lt;/sup&gt;牛逼&lt;sub&gt;&amp;eacute;&lt;/sub&gt; X，TEXINFO，Unix手册页和点的依赖关系图。此外，用户可以添加自己的自定义生成器，如&lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;16.3&lt;/a&gt;节中所述。</target>
        </trans-unit>
        <trans-unit id="4a97a33abb490cfa006083e0758a66c65ccefd2d" translate="yes" xml:space="preserve">
          <source>OCamldoc is invoked via the command ocamldoc, as follows:</source>
          <target state="translated">OCamldoc是通过命令ocamldoc调用的,具体如下。</target>
        </trans-unit>
        <trans-unit id="4a9e742b8c79265cdf1d7a881feb63c658daf697" translate="yes" xml:space="preserve">
          <source>OCamldoc operates in two steps:</source>
          <target state="translated">OCamldoc分两步操作。</target>
        </trans-unit>
        <trans-unit id="62d31081ef8855113f2a0517703c8269e167e955" translate="yes" xml:space="preserve">
          <source>OPAM switches will be provided for Spacetime-configured compilers.</source>
          <target state="translated">将为空间配置的编译器提供OPAM开关。</target>
        </trans-unit>
        <trans-unit id="cdb8f90af03d5b6035972034e7db2381c61fb84c" translate="yes" xml:space="preserve">
          <source>Obj</source>
          <target state="translated">Obj</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="7a7417369b52b8eb7878a369c0569d594dbf4af1" translate="yes" xml:space="preserve">
          <source>Objects are composed of a hidden internal state which is a record of instance variables, and a set of methods for accessing and modifying these variables. The structure of an object is described by the toplevel class that created it.</source>
          <target state="translated">对象由一个隐藏的内部状态组成,这个状态是一个实例变量的记录,以及一组用于访问和修改这些变量的方法。对象的结构由创建它的toplevel类来描述。</target>
        </trans-unit>
        <trans-unit id="7d201edcc8c7a34735ba42eb0dde4de7ae96dbd1" translate="yes" xml:space="preserve">
          <source>Objects are represented as blocks with tag Object_tag. The first field of the block refers to the object&amp;rsquo;s class and associated method suite, in a format that cannot easily be exploited from C. The second field contains a unique object ID, used for comparisons. The remaining fields of the object contain the values of the instance variables of the object. It is unsafe to access directly instance variables, as the type system provides no guarantee about the instance variables contained by an object.</source>
          <target state="translated">对象以带有标签Object_tag的块表示。块的第一个字段引用对象的类和关联的方法套件，其格式无法从C中轻易利用。第二个字段包含用于比较的唯一对象ID。对象的其余字段包含对象的实例变量的值。直接访问实例变量是不安全的，因为类型系统不能保证对象所包含的实例变量。</target>
        </trans-unit>
        <trans-unit id="b4792dc04542c4957b7299aef2bdc36a1978fd6e" translate="yes" xml:space="preserve">
          <source>Objects can also be cloned, whether they are functional or imperative. The library function Oo.copy makes a shallow copy of an object. That is, it returns a new object that has the same methods and instance variables as its argument. The instance variables are copied but their contents are shared. Assigning a new value to an instance variable of the copy (using a method call) will not affect instance variables of the original, and conversely. A deeper assignment (for example if the instance variable is a reference cell) will of course affect both the original and the copy.</source>
          <target state="translated">对象也可以被克隆,无论它们是函数式还是命令式。库函数Oo.copy可以对一个对象进行浅层复制,也就是说,它返回一个新的对象,这个对象的方法和实例变量与它的参数相同。也就是说,它返回一个新的对象,这个对象的方法和实例变量与它的参数相同。实例变量被复制,但其内容是共享的。给副本的实例变量赋一个新的值(使用方法调用)不会影响到原来的实例变量,反之。更深层次的赋值(例如实例变量是一个引用单元格)当然会影响原始变量和副本。</target>
        </trans-unit>
        <trans-unit id="f6212b229fd84e14b8e1bd78d95275e70aab5b8c" translate="yes" xml:space="preserve">
          <source>Objects can be compared using the generic comparison functions = and &amp;lt;&amp;gt;. Two objects are equal if and only if they are physically equal. In particular, an object and its copy are not equal.</source>
          <target state="translated">可以使用通用比较函数=和&amp;lt;&amp;gt;来比较对象。当且仅当它们在物理上相等时，两个对象才相等。特别是，对象及其副本不相等。</target>
        </trans-unit>
        <trans-unit id="70e562beb45bc84c915a01804d2101ba51908f44" translate="yes" xml:space="preserve">
          <source>Ocaml_operators</source>
          <target state="translated">Ocaml_operators</target>
        </trans-unit>
        <trans-unit id="ee3ae917b76500c4d6f5198aee13dfba5343c14b" translate="yes" xml:space="preserve">
          <source>Of course the constraint may also be an explicit method type. Only occurrences of quantified variables are required.</source>
          <target state="translated">当然约束条件也可以是一个明确的方法类型。只要求量化变量的出现。</target>
        </trans-unit>
        <trans-unit id="390a64456209ce68498258cb6922119e7dbf8e07" translate="yes" xml:space="preserve">
          <source>Of course, not all abstract types can be refined, as this would contradict the exhaustiveness check. Namely, builtin types (those defined by the compiler itself, such as int or array), and abstract types defined by the local module, are non-instantiable, and as such cause a type error rather than introduce an equation.</source>
          <target state="translated">当然,并不是所有的抽象类型都可以被细化,因为这将与穷尽性检查相矛盾。也就是说,内置类型(由编译器自己定义的类型,如int或数组),以及由本地模块定义的抽象类型,都是不可反转的,因此会引起类型错误,而不是引入一个公式。</target>
        </trans-unit>
        <trans-unit id="fcd38f73712f3f921494c6d0ba6b9d46d4b7cbdf" translate="yes" xml:space="preserve">
          <source>Of course, private methods can also be virtual. Then, the keywords must appear in this order method private virtual.</source>
          <target state="translated">当然,私有方法也可以是虚拟的。那么,关键词必须按照这样的顺序出现 method private virtual。</target>
        </trans-unit>
        <trans-unit id="61f10114972b3e32658bfd9f3e9aeeb732ce426d" translate="yes" xml:space="preserve">
          <source>Of course, this applies to all sorts of accounts.</source>
          <target state="translated">当然,这适用于各种账户。</target>
        </trans-unit>
        <trans-unit id="9ce8d8c0b88abbfc440d3dc4b57a2cf0a75a3a5f" translate="yes" xml:space="preserve">
          <source>Of course, you will always encounter this error if you have mutually recursive functions across modules. That is, function Mod1.f calls function Mod2.g, and function Mod2.g calls function Mod1.f. In this case, no matter what permutations you perform on the command line, the program will be rejected at link-time. Fixes:</source>
          <target state="translated">当然,如果你有跨模块的相互递归函数,你总会遇到这个错误,即函数Mod1.f调用函数Mod2.g,函数Mod2.g调用函数Mod1.f。也就是说,函数Mod1.f调用函数Mod2.g,而函数Mod2.g调用函数Mod1.f。在这种情况下,无论你在命令行上执行什么排列组合,程序都会在链接时被拒绝。修正了这一问题。</target>
        </trans-unit>
        <trans-unit id="3abc8fb824d1ca26c79cf75a199925a3994ef82b" translate="yes" xml:space="preserve">
          <source>On ARM and PowerPC processors (32 and 64 bits), fused multiply-add (FMA) instructions can be generated for a floating-point multiplication followed by a floating-point addition or subtraction, as in x *. y +. z. The FMA instruction avoids rounding the intermediate result x *. y, which is generally beneficial, but produces floating-point results that differ slightly from those produced by the bytecode interpreter.</source>
          <target state="translated">在ARM和PowerPC处理器(32位和64位)上,可以为浮点乘法和浮点加减法生成融合乘加(FMA)指令,如x *.y +.z。FMA指令避免了中间结果x *.y的四舍五入,这通常是有益的,但产生的浮点结果与字节码解释器产生的结果略有不同。</target>
        </trans-unit>
        <trans-unit id="7e4743b988a9d2c98b0f15c07522d89801266295" translate="yes" xml:space="preserve">
          <source>On IA32 processors only (Intel and AMD x86 processors in 32-bit mode), some intermediate results in floating-point computations are kept in extended precision rather than being rounded to double precision like the bytecode compiler always does. Floating-point results can therefore differ slightly between bytecode and native code.</source>
          <target state="translated">在IA32处理器上(英特尔和AMD x86处理器的32位模式),浮点计算的一些中间结果被保留为扩展精度,而不是像字节码编译器那样四舍五入为双精度。因此,浮点计算结果在字节码和原生代码之间可能会略有不同。</target>
        </trans-unit>
        <trans-unit id="f508fe5288f2a0aa709949918760a561ec1bb382" translate="yes" xml:space="preserve">
          <source>On Intel/AMD x86 processors in 32-bit mode, some intermediate results in floating-point computations are kept in extended precision rather than being rounded to double precision like the bytecode compiler always does. Floating-point results can therefore differ slightly between bytecode and native code.</source>
          <target state="translated">在英特尔/AMD x86处理器的32位模式下,浮点计算中的一些中间结果被保留为扩展精度,而不是像字节码编译器那样四舍五入为双精度。因此,浮点计算结果在字节码和原生代码之间可能略有不同。</target>
        </trans-unit>
        <trans-unit id="5dbf10944f284d7a264460f6a902cd99abf3e37d" translate="yes" xml:space="preserve">
          <source>On Windows, it is not implemented. Use threads.</source>
          <target state="translated">在Windows上,它没有实现。使用线程。</target>
        </trans-unit>
        <trans-unit id="dade53b6a22945b59c406518b5b7ced4711e03de" translate="yes" xml:space="preserve">
          <source>On Windows, not implemented.</source>
          <target state="translated">在Windows上,没有实现。</target>
        </trans-unit>
        <trans-unit id="8906e1dc157f50b42f72e0cd4030336afb142f2b" translate="yes" xml:space="preserve">
          <source>On Windows, this function can only wait for a given PID, not any child process.</source>
          <target state="translated">在Windows上,这个函数只能等待给定的PID,不能等待任何子进程。</target>
        </trans-unit>
        <trans-unit id="1ac6ad13ca209e474dd5d7f27daf61cf7c33de3b" translate="yes" xml:space="preserve">
          <source>On Windows: &lt;code&gt;PF_UNIX&lt;/code&gt; not implemented.</source>
          <target state="translated">在Windows上：未实现 &lt;code&gt;PF_UNIX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61ea9a621768303ff6efcb50e8aaf24bb46111f6" translate="yes" xml:space="preserve">
          <source>On Windows: &lt;code&gt;set_binary_mode_in&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="translated">在Windows上： &lt;code&gt;set_binary_mode_in&lt;/code&gt; 始终在使用此函数创建的通道上失败。</target>
        </trans-unit>
        <trans-unit id="bdc95dfa2349250ffde726f36b97030136e7f6c2" translate="yes" xml:space="preserve">
          <source>On Windows: &lt;code&gt;set_binary_mode_out&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="translated">在Windows上： &lt;code&gt;set_binary_mode_out&lt;/code&gt; 始终在使用此函数创建的通道上失败。</target>
        </trans-unit>
        <trans-unit id="8acef991e8908183d9940b463de2698612bbf4fe" translate="yes" xml:space="preserve">
          <source>On Windows: Not implemented, use &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Windows上：未实现，请使用&lt;a href=&quot;unix#VALwaitpid&quot;&gt; &lt;code&gt;Unix.waitpid&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da523720ddd934f446918d027605931e5c5127b8" translate="yes" xml:space="preserve">
          <source>On Windows: always returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">在Windows上：始终返回 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d57ce5674b64a4e3616d137976975a2bc57a74ff" translate="yes" xml:space="preserve">
          <source>On Windows: always returns &lt;code&gt;[|1|]&lt;/code&gt;.</source>
          <target state="translated">在Windows上：始终返回 &lt;code&gt;[|1|]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecb08db5b0219df69daea475e5cecf6bc85db53e" translate="yes" xml:space="preserve">
          <source>On Windows: can only wait for a given PID, not any child process.</source>
          <target state="translated">在Windows上:只能等待给定的PID,不能等待任何子进程。</target>
        </trans-unit>
        <trans-unit id="fef01eb224510c2a665dca3b58ffa03a7e7fb688" translate="yes" xml:space="preserve">
          <source>On Windows: execute permission &lt;code&gt;X_OK&lt;/code&gt; cannot be tested, just tests for read permission instead.</source>
          <target state="translated">在Windows上：无法测试执行许可 &lt;code&gt;X_OK&lt;/code&gt; ，只能测试读取许可。</target>
        </trans-unit>
        <trans-unit id="80f81ce21e2dfe02264da50945ccef7a68e9401c" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented (because it is meaningless).</source>
          <target state="translated">在Windows上:没有实现(因为它没有意义)。</target>
        </trans-unit>
        <trans-unit id="b247888acfd86ad89effa228bc273bc912c169cc" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented (no inter-process signals on Windows).</source>
          <target state="translated">在Windows上:没有实现(Windows上没有进程间信号)。</target>
        </trans-unit>
        <trans-unit id="8f29aabd74d2a481962357f52a86cac6b3a1664c" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented (use threads).</source>
          <target state="translated">在Windows上:没有实现(使用线程)。</target>
        </trans-unit>
        <trans-unit id="5b7ecaf2e67d2e221d004d06c969e40c1f3fa6b9" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unix#VALcreate_process&quot;&gt;&lt;code&gt;Unix.create_process&lt;/code&gt;&lt;/a&gt; or threads.</source>
          <target state="translated">在Windows上：未实现，请使用&lt;a href=&quot;unix#VALcreate_process&quot;&gt; &lt;code&gt;Unix.create_process&lt;/code&gt; &lt;/a&gt;或线程。</target>
        </trans-unit>
        <trans-unit id="eb9a785f9bfc7be0ac004adbbac251dd0fd7a11d" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Windows上：未实现，请使用&lt;a href=&quot;unix#VALwaitpid&quot;&gt; &lt;code&gt;Unix.waitpid&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5cc38279706572b8aec00ed072b6a09f30ba31d" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unixlabels#VALcreate_process&quot;&gt;&lt;code&gt;UnixLabels.create_process&lt;/code&gt;&lt;/a&gt; or threads.</source>
          <target state="translated">在Windows上：未实现，请使用&lt;a href=&quot;unixlabels#VALcreate_process&quot;&gt; &lt;code&gt;UnixLabels.create_process&lt;/code&gt; &lt;/a&gt;或线程。</target>
        </trans-unit>
        <trans-unit id="e6184afb14529e272fde289ddcc0c79bc44e53b1" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unixlabels#VALwaitpid&quot;&gt;&lt;code&gt;UnixLabels.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Windows上：未实现，请使用&lt;a href=&quot;unixlabels#VALwaitpid&quot;&gt; &lt;code&gt;UnixLabels.waitpid&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="275242bb70c12d899890264c377bf0698c3fd50b" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented.</source>
          <target state="translated">在Windows上:未实施。</target>
        </trans-unit>
        <trans-unit id="e80d45ffbea9730a03ea9d292e86a7f33ca75082" translate="yes" xml:space="preserve">
          <source>On Windows: only the &lt;a href=&quot;sys#VALsigkill&quot;&gt;&lt;code&gt;Sys.sigkill&lt;/code&gt;&lt;/a&gt; signal is emulated.</source>
          <target state="translated">在Windows上：仅模拟&lt;a href=&quot;sys#VALsigkill&quot;&gt; &lt;code&gt;Sys.sigkill&lt;/code&gt; &lt;/a&gt;信号。</target>
        </trans-unit>
        <trans-unit id="33f346325fc833b7dd2d5cbc6251af254465b155" translate="yes" xml:space="preserve">
          <source>On Windows: partially implemented, will not report timings for child processes.</source>
          <target state="translated">在Windows上:部分实施,将不报告子进程的时间。</target>
        </trans-unit>
        <trans-unit id="29d73771d5997e1e56b96cce84c556b6aa2f143d" translate="yes" xml:space="preserve">
          <source>On each case of a pattern-matching definition (function, match&amp;hellip;with construct, try&amp;hellip;with construct):</source>
          <target state="translated">在模式匹配定义的每种情况下（函数，使用构造函数进行匹配，使用构造函数进行尝试）：</target>
        </trans-unit>
        <trans-unit id="8e88170bb615e04bffb73dc9ab941d16c68ec80f" translate="yes" xml:space="preserve">
          <source>On entrance to a function:</source>
          <target state="translated">在参加活动的入口处。</target>
        </trans-unit>
        <trans-unit id="e06905e7e7cd277c45d37ec140ed32c4c8da539c" translate="yes" xml:space="preserve">
          <source>On most systems, the file produced by the linking phase can be run directly, as in:</source>
          <target state="translated">在大多数系统中,链接阶段产生的文件可以直接运行,如:。</target>
        </trans-unit>
        <trans-unit id="f81f9f71a735722a72705b16087220b85ed634fb" translate="yes" xml:space="preserve">
          <source>On native Windows, the following environment variable is also consulted:</source>
          <target state="translated">在本机Windows上,也会参考以下环境变量。</target>
        </trans-unit>
        <trans-unit id="8007c691da700e3ae4175b6d76c73c8fb4dfce47" translate="yes" xml:space="preserve">
          <source>On one example that was known to be bad for next-fit and first-fit, next-fit takes 28s using 855Mio of memory, first-fit takes 47s using 566Mio of memory, best-fit takes 27s using 545Mio of memory.</source>
          <target state="translated">在一个已知对next-fit和first-fit不好的例子上,next-fit用855Mio的内存需要28s,first-fit用566Mio的内存需要47s,best-fit用545Mio的内存需要27s。</target>
        </trans-unit>
        <trans-unit id="d5948507ff40bc2323b67783b3e4e95bc1723dae" translate="yes" xml:space="preserve">
          <source>On platforms that support dynamic loading, ocamlrun can link dynamically with C shared libraries (DLLs) providing additional C primitives beyond those provided by the standard runtime system. The names for these libraries are provided at link time as described in section &amp;zwj;&lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;18.1.4&lt;/a&gt;), and recorded in the bytecode executable file; ocamlrun, then, locates these libraries and resolves references to their primitives when the bytecode executable program starts.</source>
          <target state="translated">在支持动态加载的平台上，ocamlrun可以与C共享库（DLL）动态链接，从而提供标准运行时系统提供的C原语以外的其他C原语。在链接时提供用于这些库的名称作为部分所述&lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;18.1.4&lt;/a&gt;），并记录在字节码的可执行文件;然后，ocamlrun查找这些库，并在字节码可执行程序启动时解析对它们原语的引用。</target>
        </trans-unit>
        <trans-unit id="be6baf20c0bc95c4d024106e11bc89c9ce694fe9" translate="yes" xml:space="preserve">
          <source>On platforms that support dynamic loading, ocamlrun can link dynamically with C shared libraries (DLLs) providing additional C primitives beyond those provided by the standard runtime system. The names for these libraries are provided at link time as described in section &lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt;), and recorded in the bytecode executable file; ocamlrun, then, locates these libraries and resolves references to their primitives when the bytecode executable program starts.</source>
          <target state="translated">在支持动态加载的平台上，ocamlrun可以与C共享库（DLL）动态链接，从而提供标准运行时系统提供的C原语以外的其他C原语。这些库的名称如第&lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt;节中所述在链接时提供，并记录在字节码可执行文件中；然后，ocamlrun查找这些库，并在字节码可执行程序启动时解析对它们原语的引用。</target>
        </trans-unit>
        <trans-unit id="2f23214a8cc0b25426327d7520ebefaf7e3dc98b" translate="yes" xml:space="preserve">
          <source>On some ports, special options are required on the final linking phase that links together the object file produced by the -output-obj option and the remainder of the program. Those options are shown in the configuration file Makefile.config generated during compilation of OCaml, as the variable OC_LDFLAGS.</source>
          <target state="translated">在某些 port 上,在最后的链接阶段需要一些特殊的选项,将 -output-obj 选项产生的对象文件和程序的其余部分链接在一起。这些选项在 OCaml 编译过程中生成的配置文件 Makefile.config 中显示为变量 OC_LDFLAGS。</target>
        </trans-unit>
        <trans-unit id="30d9b385e6328adefa96c7b5d8b00ab42f09a2ff" translate="yes" xml:space="preserve">
          <source>On start-up (before the first phrase is read), if the file .ocamlinit exists in the current directory, its contents are read as a sequence of OCaml phrases and executed as per the #use directive described in section &amp;zwj;&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;. The evaluation outcode for each phrase are not displayed. If the current directory does not contain an .ocamlinit file, the file XDG_CONFIG_HOME/ocaml/init.ml is looked up according to the XDG base directory specification and used instead (on Windows this is skipped). If that file doesn&amp;rsquo;t exist then an [.ocamlinit] file in the users&amp;rsquo; home directory (determined via environment variable HOME) is used if existing.</source>
          <target state="translated">在启动时（在读取第一短语之前），如果在当前的目录中存在的文件.ocamlinit，它的内容被读取为OCaml的短语的序列，并且作为每＃使用指令执行部分中描述的&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;。不显示每个短语的评估输出代码。如果当前目录不包含.ocamlinit文件，则会根据XDG基本目录规范查找文件XDG_CONFIG_HOME / ocaml / init.ml并使用它（在Windows上，将跳过该文件）。如果该文件不存在，则使用用户主目录中的[.ocamlinit]文件（通过环境变量HOME确定）（如果存在）。</target>
        </trans-unit>
        <trans-unit id="cd1d4e4f1b5f80e398835cf87ca32c2f6861e659" translate="yes" xml:space="preserve">
          <source>On start-up (before the first phrase is read), if the file .ocamlinit exists in the current directory, its contents are read as a sequence of OCaml phrases and executed as per the #use directive described in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;. The evaluation outcode for each phrase are not displayed. If the current directory does not contain an .ocamlinit file, the file XDG_CONFIG_HOME/ocaml/init.ml is looked up according to the XDG base directory specification and used instead (on Windows this is skipped). If that file doesn&amp;rsquo;t exist then an [.ocamlinit] file in the users&amp;rsquo; home directory (determined via environment variable HOME) is used if existing.</source>
          <target state="translated">在启动时（在读取第一个短语之前），如果文件.ocamlinit在当前目录中存在，则其内容作为OCaml短语序列读取，并按照&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;节中描述的#use指令执行。不显示每个短语的评估输出代码。如果当前目录不包含.ocamlinit文件，则会根据XDG基本目录规范查找文件XDG_CONFIG_HOME / ocaml / init.ml并使用它（在Windows上，将跳过该文件）。如果该文件不存在，则使用用户主目录中的[.ocamlinit]文件（通过环境变量HOME确定）（如果存在）。</target>
        </trans-unit>
        <trans-unit id="06b84befbd60a3041accf5742277784b546af6a5" translate="yes" xml:space="preserve">
          <source>On start-up, the debugger will read commands from an initialization file before giving control to the user. The default file is .ocamldebug in the current directory if it exists, otherwise .ocamldebug in the user&amp;rsquo;s home directory.</source>
          <target state="translated">启动时，调试器将从初始化文件中读取命令，然后再将控制权交给用户。如果存在，则默认文件在当前目录中为.ocamldebug（如果存在），否则在用户主目录中为.ocamldebug。</target>
        </trans-unit>
        <trans-unit id="4cd11bf07751e14f362666e5c1bd69ee93954cd1" translate="yes" xml:space="preserve">
          <source>On the C side, a pointer to the value registered under name n is obtained by calling caml_named_value(n). The returned pointer must then be dereferenced to recover the actual OCaml value. If no value is registered under the name n, the null pointer is returned. For example, here is a C wrapper that calls the OCaml function f above:</source>
          <target state="translated">在C端,通过调用caml_named_value(n)来获得一个指向name n下注册的值的指针。然后,必须对返回的指针进行反引用,以恢复实际的OCaml值。如果没有在名称n下注册的值,则返回null指针。例如,这里是一个调用上面OCaml函数f的C包装器。</target>
        </trans-unit>
        <trans-unit id="064af06a1d91392c727df0b16b39810d1213c9db" translate="yes" xml:space="preserve">
          <source>On the OCaml side, registration is performed by evaluating Callback.registern v. Here, n is the global name (an arbitrary string) and v the OCaml value. For instance:</source>
          <target state="translated">在 OCaml 方面,注册是通过评估 Callback.registern v 来进行的。这里,n 是全局名称(任意字符串),v 是 OCaml 值。例如</target>
        </trans-unit>
        <trans-unit id="5de3701f349d27c7db926bd7951f46017d144e8d" translate="yes" xml:space="preserve">
          <source>On the debugged program side, the socket name is passed through the CAML_DEBUG_SOCKET environment variable.</source>
          <target state="translated">在调试程序端,套接字名称通过CAML_DEBUG_SOCKET环境变量传递。</target>
        </trans-unit>
        <trans-unit id="8c3a47d696ce0714f9f1c41b24081abcae43afd6" translate="yes" xml:space="preserve">
          <source>On the other hand, a class for polymorphic references must explicitly list the type parameters in its declaration. Class type parameters are listed between [ and ]. The type parameters must also be bound somewhere in the class body by a type constraint.</source>
          <target state="translated">另一方面,多态引用的类必须在声明中明确列出类型参数。类的类型参数列在[和]之间。类型参数也必须在类体中的某个地方通过类型约束来绑定。</target>
        </trans-unit>
        <trans-unit id="fde94d852235534ebe9a07117621ba74b29f99ae" translate="yes" xml:space="preserve">
          <source>Once a runtime is unloaded, it cannot be started up again without reloading the shared library and reinitializing its static data. Therefore, at the moment, the facility is only useful for building reloadable shared libraries.</source>
          <target state="translated">一旦运行时被卸载,如果不重新加载共享库并重新初始化其静态数据,就无法再次启动。因此,目前该设施只对构建可重载共享库有用。</target>
        </trans-unit>
        <trans-unit id="91fcb0d46bf0fa0b289db31330eb16f274c3b00f" translate="yes" xml:space="preserve">
          <source>Once compiled and linked with the instrumented runtime, any OCaml program can generate &lt;em&gt;trace files&lt;/em&gt; that can then be read and analyzed by users in order to understand specific runtime behaviors.</source>
          <target state="translated">一旦编译并与检测的运行时链接，任何OCaml程序都可以生成&lt;em&gt;跟踪文件&lt;/em&gt;，然后用户可以读取和分析&lt;em&gt;跟踪文件&lt;/em&gt;，以了解特定的运行时行为。</target>
        </trans-unit>
        <trans-unit id="d1d1a0a00f7b028b377134ebb6383b1db4d55c3d" translate="yes" xml:space="preserve">
          <source>Once the appropriate compiler has been selected the program should be built as normal (ensuring that all files are built with the Spacetime compiler&amp;mdash;there is currently no protection to ensure this is the case, but it is essential). For many uses it will not be necessary to change the code of the program to use the profiler.</source>
          <target state="translated">一旦选择了适当的编译器，就应该按常规方式构建程序（确保所有文件都是使用Spacetime编译器构建的-目前尚无任何保护措施来确保确实如此，但这是必不可少的）。对于许多用途，无需更改程序代码即可使用事件探查器。</target>
        </trans-unit>
        <trans-unit id="40c6b2bb41ee454dbfaccf9b93d05b18a714000d" translate="yes" xml:space="preserve">
          <source>One can also use this to completely remove a field:</source>
          <target state="translated">也可以用它来完全删除一个字段。</target>
        </trans-unit>
        <trans-unit id="0de9b9cc70a42dc4f700bcc1de9462f06fdcb0c2" translate="yes" xml:space="preserve">
          <source>One can write</source>
          <target state="translated">可以写</target>
        </trans-unit>
        <trans-unit id="e15e35f605f634d4dc006143de05c9a72bf8ebe2" translate="yes" xml:space="preserve">
          <source>One could think of defining the type abbreviation directly:</source>
          <target state="translated">可以考虑直接定义类型缩写。</target>
        </trans-unit>
        <trans-unit id="75c4aedb3397880f828378b13f6f7ae32fd18ccd" translate="yes" xml:space="preserve">
          <source>One could think that a private method should remain private in a subclass. However, since the method is visible in a subclass, it is always possible to pick its code and define a method of the same name that runs that code, so yet another (heavier) solution would be:</source>
          <target state="translated">我们可以认为,一个私有方法在子类中应该保持私有。然而,由于该方法在子类中是可见的,因此总是可以选择它的代码,并定义一个运行该代码的同名方法,因此另一个(更重的)解决方案是:</target>
        </trans-unit>
        <trans-unit id="99f1bbfebca36b804f1d02940b9fe648bbeb9dc0" translate="yes" xml:space="preserve">
          <source>One important restriction is that types introduced by openstruct ... end cannot appear in the signature of the enclosing structure, unless they are defined equal to some non-local type. So:</source>
          <target state="translated">一个重要的限制是,由openstruct ...end引入的类型不能出现在外层结构的签名中,除非它们被定义为等于某个非本地类型。所以。</target>
        </trans-unit>
        <trans-unit id="dae76e80271c4a94dd62fcba165e22dd596cb51b" translate="yes" xml:space="preserve">
          <source>One may extract a public method from an object using the C function caml_get_public_method (declared in &amp;lt;caml/mlvalues.h&amp;gt;.) Since public method tags are hashed in the same way as variant tags, and methods are functions taking self as first argument, if you want to do the method call foo#bar from the C side, you should call:</source>
          <target state="translated">可以使用C函数caml_get_public_method（在&amp;lt;caml / mlvalues.h&amp;gt;中声明）从对象中提取公共方法。由于公共方法标签的散列方式与变体标签相同，因此方法是将self作为第一个参数的函数，如果要从C端执行方法调用foo＃bar，则应调用：</target>
        </trans-unit>
        <trans-unit id="e8c0b5251da945468988a280889faaa02e2f8010" translate="yes" xml:space="preserve">
          <source>One may wish to open an account and simultaneously deposit some initial amount. Although the initial implementation did not address this requirement, it can be achieved by using an initializer.</source>
          <target state="translated">人们可能希望开立一个账户并同时存入一些初始金额。虽然最初的实施没有解决这一要求,但可以通过使用初始化器来实现。</target>
        </trans-unit>
        <trans-unit id="ac45b2b8f5570a34d56bdec8e442987bb58c7b07" translate="yes" xml:space="preserve">
          <source>One may wonder whether it is possible to treat primitive types such as integers and strings as objects. Although this is usually uninteresting for integers or strings, there may be some situations where this is desirable. The class money above is such an example. We show here how to do it for strings.</source>
          <target state="translated">人们可能会问,是否可以将整数和字符串等基元类型作为对象来处理。虽然这对于整数或字符串来说通常是无趣的,但在某些情况下,这可能是可取的。上面的类money就是这样一个例子。我们在这里展示如何为字符串做这件事。</target>
        </trans-unit>
        <trans-unit id="b3a6da4a2194d9a62f8ff334748a426441e352b3" translate="yes" xml:space="preserve">
          <source>One should notice that the use of the &lt;code&gt;parser&lt;/code&gt; keyword and associated notation for streams are only available through camlp4 extensions. This means that one has to preprocess its sources</source>
          <target state="translated">应该注意的是，只有通过camlp4扩展名才能使用 &lt;code&gt;parser&lt;/code&gt; 关键字和流的关联表示法。这意味着必须预处理其来源</target>
        </trans-unit>
        <trans-unit id="0c4137e328694d44e01b837a396be545fdedd151" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays</source>
          <target state="translated">一维数组</target>
        </trans-unit>
        <trans-unit id="6073cf4225ea4cf9fd99b377fa082aad9eea6d61" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays.</source>
          <target state="translated">一维数组。</target>
        </trans-unit>
        <trans-unit id="19597e0daea38469940aa2541294449599b19f03" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays. The &lt;code&gt;Array1&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of one-dimensional arrays. (The &lt;a href=&quot;bigarray.array2&quot;&gt;&lt;code&gt;Bigarray.Array2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray.array3&quot;&gt;&lt;code&gt;Bigarray.Array3&lt;/code&gt;&lt;/a&gt; structures below provide operations specialized for two- and three-dimensional arrays.) Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</source>
          <target state="translated">一维数组。该 &lt;code&gt;Array1&lt;/code&gt; 结构提供了类似于那些的操作&lt;a href=&quot;bigarray.genarray&quot;&gt; &lt;code&gt;Bigarray.Genarray&lt;/code&gt; &lt;/a&gt;，但专用于一维阵列的情况下。（下面的&lt;a href=&quot;bigarray.array2&quot;&gt; &lt;code&gt;Bigarray.Array2&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;bigarray.array3&quot;&gt; &lt;code&gt;Bigarray.Array3&lt;/code&gt; &lt;/a&gt;结构提供了专门用于二维和三维数组的操作。）静态知道数组的维数可以更快地进行操作，并且可以进行更精确的静态类型检查。</target>
        </trans-unit>
        <trans-unit id="5e57737797ac7cce48fd7410f424583fc8513250" translate="yes" xml:space="preserve">
          <source>Only consider using &lt;code&gt;print_flush&lt;/code&gt; when displaying all pending material is mandatory (for instance in case of interactive use when you want the user to read some text) and when resetting the pretty-printer state will not disturb further pretty-printing.</source>
          <target state="translated">仅当必须显示所有待处理的材料时才考虑使用 &lt;code&gt;print_flush&lt;/code&gt; （例如，在交互式使用的情况下，当您希望用户阅读一些文本时），并且当重置美工打印机状态不会干扰进一步的美工打印时。</target>
        </trans-unit>
        <trans-unit id="57c1f2f7c1cbc3df8fd97de870c8cc67eed2b309" translate="yes" xml:space="preserve">
          <source>Only elements (values, types, classes, ...) declared in the .mli file are kept. In other terms, definitions from the .ml file that are not exported in the .mli file are not documented.</source>
          <target state="translated">只有在.mli文件中声明的元素(值、类型、类...)才会被保留。换句话说,没有在.mli文件中导出的.ml文件中的定义不会被记录下来。</target>
        </trans-unit>
        <trans-unit id="9b33e1f6fc9c9ddf7561ddbbf58ce1315c78aa84" translate="yes" xml:space="preserve">
          <source>Only generative effects:</source>
          <target state="translated">只有产生效果。</target>
        </trans-unit>
        <trans-unit id="5fd27083a589b2ea8c548b530eaf11c8f07666db" translate="yes" xml:space="preserve">
          <source>Only the override can be used to actually override fields, and only the Oo.copy primitive can be used externally.</source>
          <target state="translated">只有覆盖才能用于实际覆盖字段,只有Oo.copy基元才能在外部使用。</target>
        </trans-unit>
        <trans-unit id="39d7997d1c51094c34071c019aa4016ceac60919" translate="yes" xml:space="preserve">
          <source>Oo</source>
          <target state="translated">Oo</target>
        </trans-unit>
        <trans-unit id="879894b2b7b07e597e8cd61a26bfd25635e3e7b3" translate="yes" xml:space="preserve">
          <source>Open a descriptor on a directory</source>
          <target state="translated">在目录上打开描述符</target>
        </trans-unit>
        <trans-unit id="42cdbc4aac5165559359ac8e455a8abf3fb22ee2" translate="yes" xml:space="preserve">
          <source>Open for append</source>
          <target state="translated">打开附加</target>
        </trans-unit>
        <trans-unit id="f22f60235dedec7386d0bead1c3c094a8425cdd5" translate="yes" xml:space="preserve">
          <source>Open for reading</source>
          <target state="translated">开放阅读</target>
        </trans-unit>
        <trans-unit id="9fe9ee1f7787491ffb2ce2a09f2e3a1c47b49760" translate="yes" xml:space="preserve">
          <source>Open for reading and writing</source>
          <target state="translated">开放阅读和写作</target>
        </trans-unit>
        <trans-unit id="e02c2958f8bca2d69a22cec109cddef10f1b7f6a" translate="yes" xml:space="preserve">
          <source>Open for writing</source>
          <target state="translated">开放写作</target>
        </trans-unit>
        <trans-unit id="0c50ee9bdb83bc2966178eb9517aa2ed3bb705c2" translate="yes" xml:space="preserve">
          <source>Open in non-blocking mode</source>
          <target state="translated">以非阻塞模式打开</target>
        </trans-unit>
        <trans-unit id="be813666b3c7520ae92cd0a1c6783279f682b877" translate="yes" xml:space="preserve">
          <source>Open statement shadows an already defined identifier.</source>
          <target state="translated">打开语句会对已经定义的标识符进行阴影处理。</target>
        </trans-unit>
        <trans-unit id="50ebdf1219ecd6520cbac717e097eb9be6c3aaca" translate="yes" xml:space="preserve">
          <source>Open statement shadows an already defined label or constructor.</source>
          <target state="translated">打开语句对已经定义的标签或构造函数进行阴影处理。</target>
        </trans-unit>
        <trans-unit id="12f7d6bffbe087ced7c1077d53f97324fb2738f7" translate="yes" xml:space="preserve">
          <source>Open the named file for reading, and return a new input channel on that file, positioned at the beginning of the file.</source>
          <target state="translated">打开命名的文件进行读取,并在该文件上返回一个新的输入通道,定位在文件的开头。</target>
        </trans-unit>
        <trans-unit id="6cca06bc653ed2aa9b9ca617abff820d8ae7223d" translate="yes" xml:space="preserve">
          <source>Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file.</source>
          <target state="translated">打开命名的文件进行写入,并在该文件上返回一个新的输出通道,定位在文件的开头。</target>
        </trans-unit>
        <trans-unit id="8ff1c4e694cef020d3159f32a866f2a047386814" translate="yes" xml:space="preserve">
          <source>Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file. The file is truncated to zero length if it already exists. It is created if it does not already exists.</source>
          <target state="translated">打开命名的文件进行写入,并在该文件上返回一个新的输出通道,定位在文件的开头。如果文件已经存在,则将其截断为零长度。如果文件不存在,则创建该文件。</target>
        </trans-unit>
        <trans-unit id="855fccd9cd030742446f7fcafaafb5b0c12184d8" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags.</source>
          <target state="translated">用给定的标志打开命名的文件。</target>
        </trans-unit>
        <trans-unit id="df722ec03c209e9326d618d229491b24151a9084" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;). Return a file descriptor on the named file.</source>
          <target state="translated">使用给定的标志打开命名的文件。第三个参数是文件创建后的权限（请参见&lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; &lt;/a&gt;）。返回命名文件上的文件描述符。</target>
        </trans-unit>
        <trans-unit id="6b0b0770f8c14a1fd210c4ac33013fabb355dc35" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created (see &lt;a href=&quot;unixlabels#VALumask&quot;&gt;&lt;code&gt;UnixLabels.umask&lt;/code&gt;&lt;/a&gt;). Return a file descriptor on the named file.</source>
          <target state="translated">使用给定的标志打开命名的文件。第三个参数是文件创建后的权限（请参见&lt;a href=&quot;unixlabels#VALumask&quot;&gt; &lt;code&gt;UnixLabels.umask&lt;/code&gt; &lt;/a&gt;）。返回命名文件上的文件描述符。</target>
        </trans-unit>
        <trans-unit id="f49f1f535c925238e318a33c608a939bf58bc5fe" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created. Return a file descriptor on the named file.</source>
          <target state="translated">用给定的标志打开命名的文件。第三个参数是创建文件时赋予文件的权限。返回命名文件的文件描述符。</target>
        </trans-unit>
        <trans-unit id="83c183b6c4d6c2979639b113137c57ec0de409f0" translate="yes" xml:space="preserve">
          <source>Opening a module enables lighter access to its components, at the cost of making it harder to identify in which module a identifier has been defined. In particular, opened modules can shadow identifiers present in the current scope, potentially leading to confusing errors:</source>
          <target state="translated">打开一个模块可以更容易地访问它的组件,但代价是更难确定标识符是在哪个模块中定义的。特别是,打开的模块可能会影响当前范围内存在的标识符,有可能导致混乱的错误。</target>
        </trans-unit>
        <trans-unit id="f5209b9452f8161599a2a771725ad2ccd16a6bec" translate="yes" xml:space="preserve">
          <source>Opening modes for &lt;a href=&quot;stdlib#VALopen_out_gen&quot;&gt;&lt;code&gt;open_out_gen&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALopen_in_gen&quot;&gt;&lt;code&gt;open_in_gen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALopen_out_gen&quot;&gt; &lt;code&gt;open_out_gen&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;stdlib#VALopen_in_gen&quot;&gt; &lt;code&gt;open_in_gen&lt;/code&gt; 的&lt;/a&gt;打开模式。</target>
        </trans-unit>
        <trans-unit id="f9f27f60f5932e4abb4b4ed37257f5c7c5328157" translate="yes" xml:space="preserve">
          <source>Opens the given module before processing the interface or implementation files. If several -open options are given, they are processed in order, just as if the statements open!Module1;;...open!ModuleN;; were added at the top of each file.</source>
          <target state="translated">在处理接口文件或实现文件之前,打开给定的模块。如果给出了多个-open选项,那么它们将按顺序被处理,就像在每个文件的顶部添加了open!Module1;;...open!ModuleN;;等语句一样。</target>
        </trans-unit>
        <trans-unit id="785a4531dce5036578aea8e49ed353d58a926529" translate="yes" xml:space="preserve">
          <source>Operating system currently executing the OCaml program.</source>
          <target state="translated">当前执行OCaml程序的操作系统。</target>
        </trans-unit>
        <trans-unit id="21abc6dbd0063cb952c1cc150a7203c29ccc476d" translate="yes" xml:space="preserve">
          <source>Operating system currently executing the OCaml program. One of</source>
          <target state="translated">当前正在执行OCaml程序的操作系统。其中一个</target>
        </trans-unit>
        <trans-unit id="0fc51a5c314382c855158eda38ff5409a7e69535" translate="yes" xml:space="preserve">
          <source>Operation already in progress</source>
          <target state="translated">行动已在进行中</target>
        </trans-unit>
        <trans-unit id="25ef925607b43bca64c3829868d9989b76540d3a" translate="yes" xml:space="preserve">
          <source>Operation not permitted</source>
          <target state="translated">不允许操作</target>
        </trans-unit>
        <trans-unit id="c49e2a256113761881fb1a1fa41d066e27d70d15" translate="yes" xml:space="preserve">
          <source>Operation not supported on socket</source>
          <target state="translated">在插座上不支持操作</target>
        </trans-unit>
        <trans-unit id="8fdc938d87d0b18a567701392c335d0c883fa4b7" translate="yes" xml:space="preserve">
          <source>Operation now in progress</source>
          <target state="translated">行动正在进行中</target>
        </trans-unit>
        <trans-unit id="db648ff618df972b87b0f378a6996fcda48575ee" translate="yes" xml:space="preserve">
          <source>Operation would block</source>
          <target state="translated">行动将阻止</target>
        </trans-unit>
        <trans-unit id="66d4b9b2ab0289179c7507e1de79db969d3d4674" translate="yes" xml:space="preserve">
          <source>Operations on binary trees are naturally expressed as recursive functions following the same structure as the type definition itself. For instance, here are functions performing lookup and insertion in ordered binary trees (elements increase from left to right):</source>
          <target state="translated">对二叉树的操作自然而然地表示为递归函数,其结构与类型定义本身相同。例如,这里是在有序二叉树(元素从左到右增加)中执行查找和插入的函数。</target>
        </trans-unit>
        <trans-unit id="46ba0f6e1bd0b179a386572eb306814fd822f312" translate="yes" xml:space="preserve">
          <source>Operations on file descriptors</source>
          <target state="translated">对文件描述符的操作</target>
        </trans-unit>
        <trans-unit id="d8dd6735ea7932a85dd5996051b8e28bae8e00af" translate="yes" xml:space="preserve">
          <source>Operations on file names</source>
          <target state="translated">对文件名的操作</target>
        </trans-unit>
        <trans-unit id="cb3fabd6bce5c3e474e507106204018aa930b99e" translate="yes" xml:space="preserve">
          <source>Operations on file names.</source>
          <target state="translated">对文件名的操作。</target>
        </trans-unit>
        <trans-unit id="d0e7fd3b17cf5a9396bca0fcd458a4b1c3357462" translate="yes" xml:space="preserve">
          <source>Operations on format strings</source>
          <target state="translated">对格式字符串的操作</target>
        </trans-unit>
        <trans-unit id="62d745537237adfa18d0a04a59f915fbeb6922d1" translate="yes" xml:space="preserve">
          <source>Operations on internal representations of values.</source>
          <target state="translated">对价值的内部表示的操作。</target>
        </trans-unit>
        <trans-unit id="ef05a420fdb91696847263f07548f0822231b601" translate="yes" xml:space="preserve">
          <source>Operations on large files</source>
          <target state="translated">对大型文件的操作</target>
        </trans-unit>
        <trans-unit id="884b46ea59004fc7b9feee6503d70fe0de517a3c" translate="yes" xml:space="preserve">
          <source>Operations on large files.</source>
          <target state="translated">对大文件的操作。</target>
        </trans-unit>
        <trans-unit id="392a9d3b032591e4ff18dd78bdf784b52dd45f89" translate="yes" xml:space="preserve">
          <source>Operations on objects</source>
          <target state="translated">对物体的操作</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="c4083b8c5eac166a2a2acd9a240e21f33de8bf2b" translate="yes" xml:space="preserve">
          <source>Operator class</source>
          <target state="translated">操作员类</target>
        </trans-unit>
        <trans-unit id="2866cf078fa7e1a2f2d0a2ea0ea2b67ee507cc6b" translate="yes" xml:space="preserve">
          <source>Operator names starting with a # character and containing more than one # character are reserved for extensions.</source>
          <target state="translated">以#字符开头且包含一个以上#字符的操作符名称为扩展名保留。</target>
        </trans-unit>
        <trans-unit id="45483f2ad274c0501b5ffbf4bf59ee7cd50884a0" translate="yes" xml:space="preserve">
          <source>Optimisation with Flambda is not currently supported when generating bytecode.</source>
          <target state="translated">在生成字节码时,目前不支持使用Flambda进行优化。</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="9d029eff2b929a5ac0d4af743cee64e78c8571a4" translate="yes" xml:space="preserve">
          <source>Optimize the produced code for space rather than for time. This results in slightly smaller but slightly slower programs. The default is to optimize for speed.</source>
          <target state="translated">针对空间而不是时间优化生成的代码。这样做的结果是程序略小但速度略慢。默认情况下是针对速度进行优化。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="b4461387353942c5c9a36536dba32b4583899a32" translate="yes" xml:space="preserve">
          <source>Option values explicitly indicate the presence or absence of a value.</source>
          <target state="translated">选项值明确表示有无数值。</target>
        </trans-unit>
        <trans-unit id="eed9d5149119da92f8108cc447b5c8a63bc1983d" translate="yes" xml:space="preserve">
          <source>Option values.</source>
          <target state="translated">选项值:</target>
        </trans-unit>
        <trans-unit id="b72c0a2e7190e2eb7aaa162394774f42f8444781" translate="yes" xml:space="preserve">
          <source>Optional arguments are actually implemented as option types. If you do not give a default value, you have access to their internal representation, type 'a option = None | Some of 'a. You can then provide different behaviors when an argument is present or not.</source>
          <target state="translated">可选参数实际上是作为选项类型实现的。如果你不给一个默认值,你可以访问它们的内部表示,类型为'a option=None | Some of 'a。然后,当一个参数存在或不存在时,你可以提供不同的行为。</target>
        </trans-unit>
        <trans-unit id="57beea4dfffda43497b4bb0d9bd857b0df0104e1" translate="yes" xml:space="preserve">
          <source>Optional parameters may also commute with non-optional or unlabeled ones, as long as they are applied simultaneously. By nature, optional arguments do not commute with unlabeled arguments applied independently.</source>
          <target state="translated">可选参数也可以与非可选参数或未标记的参数共通,只要它们同时应用。从性质上讲,可选参数不与独立应用的非标记参数共通。</target>
        </trans-unit>
        <trans-unit id="659fd3897d334a8024280ea2db630f05a96e06e0" translate="yes" xml:space="preserve">
          <source>Optionally, missing fields can be made explicit by ending the list of fields with a trailing wildcard _::</source>
          <target state="translated">也可以通过在字段列表的末尾使用通配符_:来明确缺失的字段。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="de973f948db8258d8d749bfe279d72496cf0c025" translate="yes" xml:space="preserve">
          <source>Options selecting a built-in generator to ocamldoc, such as -html, have no effect if a custom generator of the same kind is provided using -g. If the kinds do not match, the selected built-in generator is used and the custom one is ignored.</source>
          <target state="translated">如果使用-g提供了同类的自定义生成器,那么选择内置生成器的选项,如-html,就没有任何效果。如果种类不匹配,则使用选定的内置生成器,而忽略自定义生成器。</target>
        </trans-unit>
        <trans-unit id="ecfdbe107bba41b0abba570531e3c3d244ee7166" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt;&lt;code&gt;Unix.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt; &lt;code&gt;Unix.getaddrinfo&lt;/code&gt; 的&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="acbc13cd4094c5e7aa7a8e52fa68629dbf0813f9" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unix#VALgetnameinfo&quot;&gt;&lt;code&gt;Unix.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetnameinfo&quot;&gt; &lt;code&gt;Unix.getnameinfo&lt;/code&gt; 的&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="c9a94dd4d94b5377208a7fb921f37e8e691cbccf" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unixlabels#VALgetaddrinfo&quot;&gt;&lt;code&gt;UnixLabels.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALgetaddrinfo&quot;&gt; &lt;code&gt;UnixLabels.getaddrinfo&lt;/code&gt; 的&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="d8d70fdc1d8443e456faa3f18ac9f4cce1786955" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unixlabels#VALgetnameinfo&quot;&gt;&lt;code&gt;UnixLabels.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALgetnameinfo&quot;&gt; &lt;code&gt;UnixLabels.getnameinfo&lt;/code&gt; 的&lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="cabf18c33657daede436c9425e69c4a2df9c4ba4" translate="yes" xml:space="preserve">
          <source>Or, equivalently:</source>
          <target state="translated">或者,等价交换。</target>
        </trans-unit>
        <trans-unit id="1c2251dba4688a589e898c162858a821fdb5b816" translate="yes" xml:space="preserve">
          <source>Other comments for &lt;a href=&quot;hashtbl#VALiter&quot;&gt;&lt;code&gt;Hashtbl.iter&lt;/code&gt;&lt;/a&gt; apply as well.</source>
          <target state="translated">&lt;a href=&quot;hashtbl#VALiter&quot;&gt; &lt;code&gt;Hashtbl.iter&lt;/code&gt; 的&lt;/a&gt;其他注释也适用。</target>
        </trans-unit>
        <trans-unit id="7ad21b6c76995f078551fec35633e00c1a8b9aa0" translate="yes" xml:space="preserve">
          <source>Other comments for &lt;a href=&quot;morelabels.hashtbl#VALiter&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.iter&lt;/code&gt;&lt;/a&gt; apply as well.</source>
          <target state="translated">&lt;a href=&quot;morelabels.hashtbl#VALiter&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.iter&lt;/code&gt; &lt;/a&gt;适用于MoreLabels.Hashtbl.iter的其他注释。</target>
        </trans-unit>
        <trans-unit id="f72667213aa60e61b77943168bfb7d9b47ab1a35" translate="yes" xml:space="preserve">
          <source>Other generic comparisons such as (&amp;lt;, &amp;lt;=, ...) can also be used on objects. The relation &amp;lt; defines an unspecified but strict ordering on objects. The ordering relationship between two objects is fixed once for all after the two objects have been created and it is not affected by mutation of fields.</source>
          <target state="translated">其他通用比较，例如（&amp;lt;，&amp;lt;=，...）也可以在对象上使用。关系&amp;lt;定义了对象上未指定但严格的顺序。创建两个对象之后，两个对象之间的排序关系将全部固定一次，并且不受字段突变的影响。</target>
        </trans-unit>
        <trans-unit id="6e8efe1d345866aae01ed21ce80800454a7ab6f8" translate="yes" xml:space="preserve">
          <source>Other types do not introduce new subtyping, but they may propagate the subtyping of their arguments. For instance, &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; when &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; are respectively subtypes of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For function types, the relation is more subtle: &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; &amp;zwj;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a supertype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For this reason, function types are covariant in their second argument (like tuples), but contravariant in their first argument. Mutable types, like array or ref are neither covariant nor contravariant, they are nonvariant, that is they do not propagate subtyping.</source>
          <target state="translated">其他类型不引入新的子类型，但是它们可以传播其参数的子类型。例如，&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; *&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;是的子类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt; *&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;时&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;分别是亚型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;。为函数类型，所述关系是更微妙：&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; - &amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;是的子类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt; - &amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;如果&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;是的超类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;是的子类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;。因此，函数类型在第二个参数中是协变的（如元组），但在第一个参数中是协变的。可变类型（例如array或ref）既不是协变也不是协变，它们是不变的，也就是说，它们不会传播子类型。</target>
        </trans-unit>
        <trans-unit id="8d3a931554b88e85d13e345dd0998e69549806d3" translate="yes" xml:space="preserve">
          <source>Other types do not introduce new subtyping, but they may propagate the subtyping of their arguments. For instance, &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; when &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; are respectively subtypes of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For function types, the relation is more subtle: &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a supertype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For this reason, function types are covariant in their second argument (like tuples), but contravariant in their first argument. Mutable types, like array or ref are neither covariant nor contravariant, they are nonvariant, that is they do not propagate subtyping.</source>
          <target state="translated">其他类型不引入新的子类型，但是它们可以传播其参数的子类型。例如，&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; *&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;是的子类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt; *&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;时&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;TYP &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;分别是亚型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;。为函数类型，所述关系是更微妙：&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; - &amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;是的子类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt; - &amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;如果&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;是的超类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;是的子类型&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;' &lt;sub&gt;2&lt;/sub&gt;。因此，函数类型在第二个参数中是协变的（如元组），但在第一个参数中是协变的。可变类型（例如array或ref）既不是协变也不是协变，它们是不变的，也就是说，它们不会传播子类型。</target>
        </trans-unit>
        <trans-unit id="88cb471cac1651f6cd901864ed749958654b7d77" translate="yes" xml:space="preserve">
          <source>Otherwise the function being called is substituted at the call site with its body having been rewritten such that any recursive calls to that function &lt;em&gt;or any others in the same mutually-recursive group&lt;/em&gt; are annotated with the attribute unrolled(n &amp;minus; 1). Inlining may continue on that body.</source>
          <target state="translated">否则，被调用的函数在调用位置被替换为其主体，从而使对该函数&lt;em&gt;或同一相互递归组&lt;/em&gt;中的&lt;em&gt;任何其他递归调用&lt;/em&gt;的注释属性为unrolled（n-1）。内联可能会继续在该主体上进行。</target>
        </trans-unit>
        <trans-unit id="5cf7d27ce868f52e567b02e4ec391690c62f134e" translate="yes" xml:space="preserve">
          <source>Otherwise, nothing happens.</source>
          <target state="translated">否则,什么都不会发生。</target>
        </trans-unit>
        <trans-unit id="4c86b00df30e667ed3c1e54e980a320c6bfb8e87" translate="yes" xml:space="preserve">
          <source>Otherwise, the initialising array is lifted out and subject to the normal constant sharing procedure; creation of the array consists of bulk copying the initialising array into a fresh value on the OCaml heap.</source>
          <target state="translated">否则,初始化数组就会被抬出,并受到正常的常量共享程序的约束;数组的创建包括将初始化数组批量复制到OCaml堆上的一个新值中。</target>
        </trans-unit>
        <trans-unit id="aafa7eee672f6b85c088cd2cb345b72adf66f904" translate="yes" xml:space="preserve">
          <source>Otherwise, the symbol is bound to a (statically-allocated) &lt;em&gt;preallocated block&lt;/em&gt; containing one field. At runtime, the defining expression will be evaluated and the first field of the block filled with the resulting value. This &lt;em&gt;initialise-symbol&lt;/em&gt; binding causes one extra indirection but ensures, by virtue of the symbol&amp;rsquo;s address being known at compile time, that uses of the value are not captured by closures.</source>
          <target state="translated">否则，将符号绑定到包含一个字段的（静态分配的）&lt;em&gt;预分配块&lt;/em&gt;。在运行时，将评估定义表达式，并用结果值填充块的第一个字段。这种&lt;em&gt;初始化符号&lt;/em&gt;绑定引起了一个额外的间接访问，但是由于在编译时知道该符号的地址，因此可以确保闭包不会捕获该值的使用。</target>
        </trans-unit>
        <trans-unit id="1e89ee3a810516da1f61deb1e918aa6f94233ccf" translate="yes" xml:space="preserve">
          <source>Our iterator works, as shows its first use for summation. However, since objects themselves are not polymorphic (only their constructors are), using the fold method fixes its type for this individual object. Our next attempt to use it as a string iterator fails.</source>
          <target state="translated">我们的迭代器工作了,这表明它第一次用于求和。然而,由于对象本身并不是多态的(只有它们的构造函数是多态的),所以使用折叠方法固定了它对这个单独对象的类型。我们下一次尝试将其作为字符串迭代器使用时失败了。</target>
        </trans-unit>
        <trans-unit id="0be297b561141a6a2d82a7108dddc36e1cc22dba" translate="yes" xml:space="preserve">
          <source>Out of memory</source>
          <target state="translated">不记得了</target>
        </trans-unit>
        <trans-unit id="6e02b9b7b5116b9cf2721c4e3f0f7bdbc58079e4" translate="yes" xml:space="preserve">
          <source>Output GC statistics at program exit.</source>
          <target state="translated">在程序退出时输出GC统计数据。</target>
        </trans-unit>
        <trans-unit id="7671f0341e3d098b8c9393d0300f5e4d7f5c6621" translate="yes" xml:space="preserve">
          <source>Output baud rate (0 means close connection).</source>
          <target state="translated">输出波特率(0表示紧密连接)。</target>
        </trans-unit>
        <trans-unit id="0c09cf6b42600a87ca03143becccdcb8b33419e1" translate="yes" xml:space="preserve">
          <source>Output code that does not use OCaml&amp;rsquo;s built-in automata interpreter. Instead, the automaton is encoded by OCaml functions. This option improves performance when using the native compiler, but decreases it when using the bytecode compiler.</source>
          <target state="translated">不使用OCaml的内置自动机解释器的输出代码。取而代之的是，自动机由OCaml函数编码。使用本机编译器时，此选项可提高性能，但使用字节码编译器时，该选项会降低性能。</target>
        </trans-unit>
        <trans-unit id="743a4b6a0ace04e22a3f7d73badb17283ccbd3bc" translate="yes" xml:space="preserve">
          <source>Output dot code describing the type dependency graph instead of the module dependency graph.</source>
          <target state="translated">输出描述类型依赖关系图的点码,而不是模块依赖关系图。</target>
        </trans-unit>
        <trans-unit id="2da5f56773c68337139a5eca245caeacb63ae861" translate="yes" xml:space="preserve">
          <source>Output functions on standard error</source>
          <target state="translated">标准误差的输出功能</target>
        </trans-unit>
        <trans-unit id="99ab5418296d95f226bfcd5834dc0e99eb65877d" translate="yes" xml:space="preserve">
          <source>Output functions on standard output</source>
          <target state="translated">标准输出的输出功能</target>
        </trans-unit>
        <trans-unit id="2900df23d8753bef8ba40bb95924b811a8a31a30" translate="yes" xml:space="preserve">
          <source>Output one line per file, regardless of the length.</source>
          <target state="translated">每个文件输出一行,无论长度如何。</target>
        </trans-unit>
        <trans-unit id="052a1c1bf420fd7d12e0f3d0ea009ebee9739c3a" translate="yes" xml:space="preserve">
          <source>Output raw dependencies of the form</source>
          <target state="translated">输出原始的依赖关系,形式为</target>
        </trans-unit>
        <trans-unit id="49bd2e99d5d5374f1bd9969053ecf288c36f827f" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 的&lt;/a&gt;输出签名。</target>
        </trans-unit>
        <trans-unit id="fce15cc8d58fabc956c6b1932886db9d314a2ae5" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;morelabels.map.make&quot;&gt;&lt;code&gt;MoreLabels.Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;morelabels.map.make&quot;&gt; &lt;code&gt;MoreLabels.Map.Make&lt;/code&gt; 的&lt;/a&gt;输出签名。</target>
        </trans-unit>
        <trans-unit id="4100ed2d22cb3ae26b1477b3891fbe93d1b79c17" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;morelabels.set.make&quot;&gt;&lt;code&gt;MoreLabels.Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;morelabels.set.make&quot;&gt; &lt;code&gt;MoreLabels.Set.Make&lt;/code&gt; 的&lt;/a&gt;输出签名。</target>
        </trans-unit>
        <trans-unit id="5145c8c79a32654b4778e9f93670595bbd8d1719" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; 的&lt;/a&gt;输出签名。</target>
        </trans-unit>
        <trans-unit id="d31f223f57817b5e1d76b337263e2c889f885c49" translate="yes" xml:space="preserve">
          <source>Output the generated documentation to file instead of ocamldoc.out. This option is meaningful only in conjunction with the -latex, -texi, or -dot options.</source>
          <target state="translated">将生成的文档输出到文件中,而不是ocamldoc.out。这个选项只有与-latex、-texi或-dot选项一起使用才有意义。</target>
        </trans-unit>
        <trans-unit id="95791b995af7b93d84b0104e38a8bf231ca37bde" translate="yes" xml:space="preserve">
          <source>Outside of this domain, &lt;code&gt;pp_set_geometry&lt;/code&gt; raises an invalid argument exception whereas &lt;code&gt;pp_safe_set_geometry&lt;/code&gt; does nothing.</source>
          <target state="translated">在此域之外， &lt;code&gt;pp_set_geometry&lt;/code&gt; 引发无效的参数异常，而 &lt;code&gt;pp_safe_set_geometry&lt;/code&gt; 不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="b6d1264bc905918faeda24a1a224e8b90ab0b9d7" translate="yes" xml:space="preserve">
          <source>Outside the structure, its components can be referred to using the &amp;ldquo;dot notation&amp;rdquo;, that is, identifiers qualified by a structure name. For instance, PrioQueue.insert is the function insert defined inside the structure PrioQueue and PrioQueue.queue is the type queue defined in PrioQueue.</source>
          <target state="translated">在结构外部，可以使用&amp;ldquo;点符号&amp;rdquo;来引用其组件，即通过结构名称限定的标识符。例如，PrioQueue.insert是在结构PrioQueue内部定义的函数插入，而PrioQueue.queue是在PrioQueue中定义的类型队列。</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="09bd6a353a7bb8a33e37cfee71ada9fc9ce37d89" translate="yes" xml:space="preserve">
          <source>PATH</source>
          <target state="translated">PATH</target>
        </trans-unit>
        <trans-unit id="da18ad2a8cc0702f3ea2d5253be6cbd4ca251be5" translate="yes" xml:space="preserve">
          <source>PF_INET is fully supported; PF_INET6 is fully supported (since 4.01.0); PF_UNIX is not supported</source>
          <target state="translated">完全支持PF_INET;完全支持PF_INET6(从4.01.0开始);不支持PF_UNIX。</target>
        </trans-unit>
        <trans-unit id="4dc6925c70ec89b041de02dd5e2ee478c8a2fff1" translate="yes" xml:space="preserve">
          <source>Pair operations</source>
          <target state="translated">对子操作</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="06f18dad25a25477df3046f706b5e47ba6a1cff9" translate="yes" xml:space="preserve">
          <source>Parameterize one function by the other. That is, instead of having</source>
          <target state="translated">用一个函数的参数化,另一个函数的参数化。也就是说,不需要将</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="917b2a251560fc0829ba549ae43c67440509e02d" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can also contain coercions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] :&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) (see subsection &amp;zwj;&lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt; below).</source>
          <target state="translated">括号内的表达式也可以包含的强制（&lt;a href=&quot;#expr&quot;&gt;expr的&lt;/a&gt;[：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ]：&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）（参见第&lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt;下文）。</target>
        </trans-unit>
        <trans-unit id="da3863839aefaac9ffd796e91309941e5a0aabf4" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can also contain coercions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] :&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) (see subsection &lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt; below).</source>
          <target state="translated">带括号的表达式也可以包含强制（&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ]：&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）（请参见下面的&lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt;小节）。</target>
        </trans-unit>
        <trans-unit id="78e82529fec7a054cadaa05482779b54cccd0e7d" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can contain a type constraint, as in (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">带括号的表达式可以包含类型约束，如（&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）。这个约束迫使&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的类型与&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;兼容。</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="b2eda9d52f18e0568a63bc181bcaa6ee3a98404e" translate="yes" xml:space="preserve">
          <source>Parsing of command line arguments.</source>
          <target state="translated">对命令行参数的解析。</target>
        </trans-unit>
        <trans-unit id="7a5f54d8070d9bc8013738e6b516352edaed2ca3" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;&lt;a href=&quot;index#p%3Acommands&quot;&gt;III&lt;/a&gt;, &amp;ldquo;The OCaml tools&amp;rdquo;, documents the compilers, toplevel system, and programming utilities.</source>
          <target state="translated">部分&lt;a href=&quot;index#p%3Acommands&quot;&gt;三&lt;/a&gt;，&amp;ldquo;OCaml的工具&amp;rdquo;，文件的编译器，顶层系统和编程工具。</target>
        </trans-unit>
        <trans-unit id="19238d57dd0b585bfed6e7ad8133742326ec59ac" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;&lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;, &amp;ldquo;The OCaml library&amp;rdquo;, describes the modules provided in the standard library.</source>
          <target state="translated">部分&lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;，&amp;ldquo;OCaml的图书馆&amp;rdquo;，描述了在标准库中提供的模块。</target>
        </trans-unit>
        <trans-unit id="9acfeea4b9543fefe3bae0d4e85f92629ac3ad50" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;&lt;a href=&quot;index#p%3Arefman&quot;&gt;II&lt;/a&gt;, &amp;ldquo;The OCaml language&amp;rdquo;, is the reference description of the language.</source>
          <target state="translated">部分&lt;a href=&quot;index#p%3Arefman&quot;&gt;二&lt;/a&gt;，&amp;ldquo;OCaml的语言&amp;rdquo;，是语言的参考描述。</target>
        </trans-unit>
        <trans-unit id="25fb4bbb0a4f774cd23019ab4a347d036de5427b" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;&lt;a href=&quot;index#p%3Atutorials&quot;&gt;I&lt;/a&gt;, &amp;ldquo;An introduction to OCaml&amp;rdquo;, gives an overview of the language.</source>
          <target state="translated">第一部分&lt;a href=&quot;index#p%3Atutorials&quot;&gt;我&lt;/a&gt;，&amp;ldquo;来OCaml的介绍&amp;rdquo;，给出了语言的概述。</target>
        </trans-unit>
        <trans-unit id="d38a98ee2d74d13c07933d22667a73fadfb813b1" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;I An introduction to OCaml</source>
          <target state="translated">第I部分OCaml简介</target>
        </trans-unit>
        <trans-unit id="a0a0af2c91d9271afdf61c522b100141d883d23e" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;II The OCaml language</source>
          <target state="translated">第二部分OCaml语言</target>
        </trans-unit>
        <trans-unit id="63d9ac25931ce230c248c31708f02b35b21928fb" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;III The OCaml tools</source>
          <target state="translated">第三部分OCaml工具</target>
        </trans-unit>
        <trans-unit id="41f44b93036e9ab25420868aabe5d6e167b279f5" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;IV The OCaml library</source>
          <target state="translated">第四部分OCaml库</target>
        </trans-unit>
        <trans-unit id="5d808f75d0801383a43b1615503577d5f6b97062" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;V Indexes</source>
          <target state="translated">第五部分索引</target>
        </trans-unit>
        <trans-unit id="6c9e17bd7715006188f45f1708aaf0fea52ec4f8" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Acommands&quot;&gt;III&lt;/a&gt;, &amp;ldquo;The OCaml tools&amp;rdquo;, documents the compilers, toplevel system, and programming utilities.</source>
          <target state="translated">部分&lt;a href=&quot;index#p%3Acommands&quot;&gt;三&lt;/a&gt;，&amp;ldquo;OCaml的工具&amp;rdquo;，文件的编译器，顶层系统和编程工具。</target>
        </trans-unit>
        <trans-unit id="18c889dcbcc02d29f2665be2a7454d8a1987503b" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;, &amp;ldquo;The OCaml library&amp;rdquo;, describes the modules provided in the standard library.</source>
          <target state="translated">部分&lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;，&amp;ldquo;OCaml的图书馆&amp;rdquo;，描述了在标准库中提供的模块。</target>
        </trans-unit>
        <trans-unit id="2f0668847ca907120f5188c16ff537453a2eafe0" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Arefman&quot;&gt;II&lt;/a&gt;, &amp;ldquo;The OCaml language&amp;rdquo;, is the reference description of the language.</source>
          <target state="translated">部分&lt;a href=&quot;index#p%3Arefman&quot;&gt;二&lt;/a&gt;，&amp;ldquo;OCaml的语言&amp;rdquo;，是语言的参考描述。</target>
        </trans-unit>
        <trans-unit id="903f9019ed78ac57cfad4f904e7657f4fe68eff9" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Atutorials&quot;&gt;I&lt;/a&gt;, &amp;ldquo;An introduction to OCaml&amp;rdquo;, gives an overview of the language.</source>
          <target state="translated">第一部分&lt;a href=&quot;index#p%3Atutorials&quot;&gt;我&lt;/a&gt;，&amp;ldquo;来OCaml的介绍&amp;rdquo;，给出了语言的概述。</target>
        </trans-unit>
        <trans-unit id="b1a2c5985aa86cde57c2ecbbc6cbc8380d79481d" translate="yes" xml:space="preserve">
          <source>Part I An introduction to OCaml</source>
          <target state="translated">第一部分 OCaml简介</target>
        </trans-unit>
        <trans-unit id="a62eaed854d7e70fe37691fb3a427228618bcb89" translate="yes" xml:space="preserve">
          <source>Part II The OCaml language</source>
          <target state="translated">第二部分 OCaml语言</target>
        </trans-unit>
        <trans-unit id="6b5891d0deb20c4e4a3137af20b7932727b436b5" translate="yes" xml:space="preserve">
          <source>Part III The OCaml tools</source>
          <target state="translated">第三部分 OCaml工具</target>
        </trans-unit>
        <trans-unit id="a29da75cd43003faab118a1eb6915f585144a3e6" translate="yes" xml:space="preserve">
          <source>Part IV The OCaml library</source>
          <target state="translated">第四部分 OCaml库</target>
        </trans-unit>
        <trans-unit id="952bed16abbd7542df79c253d7d2a383bf3f6501" translate="yes" xml:space="preserve">
          <source>Part V Appendix</source>
          <target state="translated">第五部分 附录</target>
        </trans-unit>
        <trans-unit id="259899217f837489155c6afc61bda7baa0892067" translate="yes" xml:space="preserve">
          <source>Partial match: missing cases in pattern-matching.</source>
          <target state="translated">部分匹配:模式匹配中的缺失案例。</target>
        </trans-unit>
        <trans-unit id="ae3a92949ce10ed0b574a754bc455be19981923a" translate="yes" xml:space="preserve">
          <source>Partially applied function: expression whose result has function type and is ignored.</source>
          <target state="translated">部分应用函数:表达式,其结果具有函数类型,被忽略。</target>
        </trans-unit>
        <trans-unit id="ce8f0a0917978c15b665028676a364a22bd18fe0" translate="yes" xml:space="preserve">
          <source>Pass free variables via specialised arguments rather than closures (an optimisation for reducing allocation). See section &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;19.9.3&lt;/a&gt;. This may have a small performance penalty.</source>
          <target state="translated">通过专用参数而不是闭包传递自由变量（减少分配的优化）。参见第&lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;19.9.3&lt;/a&gt;节。这可能会降低性能。</target>
        </trans-unit>
        <trans-unit id="122dc2b1a442a4492301d7cfaae94e0455545b63" translate="yes" xml:space="preserve">
          <source>Pass free variables via specialised arguments rather than closures (an optimisation for reducing allocation). See section &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3&lt;/a&gt;. This may have a small performance penalty.</source>
          <target state="translated">通过专用参数而不是闭包传递自由变量（减少分配的优化）。参见第&lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3&lt;/a&gt;节。这可能会降低性能。</target>
        </trans-unit>
        <trans-unit id="8139f1329d56ecac27be1fc05605291efd738915" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode (see the -custom option). This causes the given C library to be linked with the program.</source>
          <target state="translated">在&amp;ldquo;自定义运行时&amp;rdquo;模式下链接时，将-llibname选项传递给C链接器（请参见-custom选项）。这将使给定的C库与程序链接。</target>
        </trans-unit>
        <trans-unit id="34ec306fd1c4422e97cfa2ee48b0b9b8261921e1" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">在&amp;ldquo;自定义运行时&amp;rdquo;模式下链接时，将-llibname选项传递给C链接器。见ocamlc相应的选项，在章&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df106032363559c3f40628cbdd6ff4a26fa7fd35" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">在&amp;ldquo;自定义运行时&amp;rdquo;模式下链接时，将-llibname选项传递给C链接器。请参阅第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章中的ocamlc的相应选项。</target>
        </trans-unit>
        <trans-unit id="ceed386065448933a097ec35067876966e85d14f" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the linker . This causes the given C library to be linked with the program.</source>
          <target state="translated">传递-llibname选项给链接器。这将导致给定的C库与程序链接。</target>
        </trans-unit>
        <trans-unit id="62a98fab69c5b411c299526b9c9f34cd1b6787ac" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker, when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">在&amp;ldquo;自定义运行时&amp;rdquo;模式下进行链接时，将给定的选项传递给C编译器和链接器。见ocamlc相应的选项，在章&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a59af1bc11afda37b34f10079d3a9dec8ef0d8df" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker, when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">在&amp;ldquo;自定义运行时&amp;rdquo;模式下进行链接时，将给定的选项传递给C编译器和链接器。请参阅第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章中的ocamlc的相应选项。</target>
        </trans-unit>
        <trans-unit id="b35478fccd7fbafbf25aff91256c23a1c032cf84" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker. For instance,-ccopt -Ldir causes the C linker to search for C libraries in directory dir.</source>
          <target state="translated">将给定的选项传递给C语言编译器和链接器,例如,-ccopt -Ldir会使C语言链接器搜索目录dir中的C语言库。例如,-ccopt -Ldir使C语言链接器搜索目录dir中的C语言库。</target>
        </trans-unit>
        <trans-unit id="273a7a00d3bf42c46d56c858df14b11822928560" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker. When linking in &amp;ldquo;custom runtime&amp;rdquo; mode, for instance-ccopt -Ldir causes the C linker to search for C libraries in directory dir.(See the -custom option.)</source>
          <target state="translated">将给定的选项传递给C编译器和链接器。在&amp;ldquo;自定义运行时&amp;rdquo;模式下进行链接时，例如，-ccopt -Ldir使C链接程序在目录dir中搜索C库。（请参见-custom选项。）</target>
        </trans-unit>
        <trans-unit id="72dfe02cbb8cc21321b311387b88011ec8835c71" translate="yes" xml:space="preserve">
          <source>Pattern matching on an extensible variant type requires a default case to handle unknown variant constructors:</source>
          <target state="translated">在可扩展变体类型上的模式匹配需要一个默认情况来处理未知的变体构造函数。</target>
        </trans-unit>
        <trans-unit id="7196102a3d9bcbd2b6117c4975e2514a2f279f02" translate="yes" xml:space="preserve">
          <source>Pattern-matching depending on mutable state prevents the remaining arguments from being uncurried.</source>
          <target state="translated">根据可变状态进行模式匹配,可以防止剩余的参数不被加密。</target>
        </trans-unit>
        <trans-unit id="93c3d48bb09ccd90e9aae3bcf8d34d9478c3b2ab" translate="yes" xml:space="preserve">
          <source>Patterns are &lt;em&gt;linear&lt;/em&gt;: a variable cannot be bound several times by a given pattern. In particular, there is no way to test for equality between two parts of a data structure using only a pattern (but when guards can be used for this purpose).</source>
          <target state="translated">模式是&lt;em&gt;线性的&lt;/em&gt;：一个给定的模式不能多次绑定一个变量。特别是，没有办法仅使用模式来测试数据结构的两个部分之间的相等性（但是何时可以将防护措施用于此目的）。</target>
        </trans-unit>
        <trans-unit id="e3abd39dc618aa8814823785a44aa53f573df633" translate="yes" xml:space="preserve">
          <source>Patterns are templates that allow selecting data structures of a given shape, and binding identifiers to components of the data structure. This selection operation is called pattern matching; its outcome is either &amp;ldquo;this value does not match this pattern&amp;rdquo;, or &amp;ldquo;this value matches this pattern, resulting in the following bindings of names to values&amp;rdquo;.</source>
          <target state="translated">模式是允许选择给定形状的数据结构以及将标识符绑定到数据结构的组件的模板。此选择操作称为模式匹配；此操作称为模式匹配。其结果是&amp;ldquo;此值与该模式不匹配&amp;rdquo;​​或&amp;ldquo;此值与该模式匹配，从而导致名称与值的以下绑定&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7c689af30d05364792d515c0faaa88a9ab2da162" translate="yes" xml:space="preserve">
          <source>Perform a full major collection and compact the heap.</source>
          <target state="translated">进行一次完整的大集合,并对堆进行压缩。</target>
        </trans-unit>
        <trans-unit id="d3d568817e2f7ecd125459c14fd92de23c2c2e40" translate="yes" xml:space="preserve">
          <source>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</source>
          <target state="translated">进行一次完整的大集合,并对堆进行压实。注意,堆压实是一个漫长的操作。</target>
        </trans-unit>
        <trans-unit id="055dbe4520a583e58ae39a293f647d64d4770ec6" translate="yes" xml:space="preserve">
          <source>Perform a transitive reduction of the dependency graph before outputting the dot code. This can be useful if there are a lot of transitive dependencies that clutter the graph.</source>
          <target state="translated">在输出点码之前,先对依赖关系图进行转义还原。如果有大量的转折依赖关系使图变得杂乱无章,这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="f7a67fe1a67339dfb0ee43e9f1cd0038c969bd66" translate="yes" xml:space="preserve">
          <source>Perform even more optimisation than usual, possibly including unrolling of recursive functions. Compilation times may be significantly lengthened.</source>
          <target state="translated">执行比平常更多的优化,可能包括递归函数的展开。编译时间可能会显著延长。</target>
        </trans-unit>
        <trans-unit id="03ae6f3e3a5dfa3cf5ca340a83e5ff43e4d7561e" translate="yes" xml:space="preserve">
          <source>Perform more optimisation than usual. Compilation times may be lengthened. (This flag is an abbreviation for a certain set of parameters described in section &lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;19.5&lt;/a&gt;.)</source>
          <target state="translated">比平常执行更多优化。编译时间可能会延长。（此标志是&lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;19.5&lt;/a&gt;节中描述的某些参数的缩写。）</target>
        </trans-unit>
        <trans-unit id="b87d065999353ac9c7a4517b1177b42e5b1d7054" translate="yes" xml:space="preserve">
          <source>Perform more optimisation than usual. Compilation times may be lengthened. (This flag is an abbreviation for a certain set of parameters described in section &lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;21.5&lt;/a&gt;.)</source>
          <target state="translated">比平常执行更多优化。编译时间可能会延长。（此标志是&lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;21.5&lt;/a&gt;节中描述的某些参数集的缩写。）</target>
        </trans-unit>
        <trans-unit id="22610c9aaccb16a1bee9b7cee9dfb32918779ba0" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;int32&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;int32&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;int32&lt;/code&gt; only when the application requires exact 32-bit arithmetic.</source>
          <target state="translated">性能说明： &lt;code&gt;int32&lt;/code&gt; 类型的值比 &lt;code&gt;int&lt;/code&gt; 类型的值占用更多的内存空间，并且 &lt;code&gt;int32&lt;/code&gt; 上的算术运算通常比 &lt;code&gt;int&lt;/code&gt; 上的算术运算慢。仅当应用程序需要精确的32位算术时才使用 &lt;code&gt;int32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="662740b47a420ed740a0039a0fb0aa90dd4e339b" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;int64&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;int64&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;int64&lt;/code&gt; only when the application requires exact 64-bit arithmetic.</source>
          <target state="translated">性能注意事项： &lt;code&gt;int64&lt;/code&gt; 类型的值比 &lt;code&gt;int&lt;/code&gt; 类型的值占用更多的内存空间，并且 &lt;code&gt;int64&lt;/code&gt; 上的算术运算通常比 &lt;code&gt;int&lt;/code&gt; 上的算术运算慢。仅当应用程序需要精确的64位算术运算时，才使用 &lt;code&gt;int64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9583bec530f000172f8c0f05a57970fabee45e7c" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;nativeint&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;nativeint&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;nativeint&lt;/code&gt; only when the application requires the extra bit of precision over the &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">性能说明： &lt;code&gt;nativeint&lt;/code&gt; 类型的值比 &lt;code&gt;int&lt;/code&gt; 类型的值占用更多的内存空间，并且 &lt;code&gt;nativeint&lt;/code&gt; 上的算术运算通常比 &lt;code&gt;int&lt;/code&gt; 上的算术运算慢。仅当应用程序需要比 &lt;code&gt;int&lt;/code&gt; 类型更多的精度时，才使用 &lt;code&gt;nativeint&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="170a28a9db6d27d7212fc6dc249434a57517e7bc" translate="yes" xml:space="preserve">
          <source>Period</source>
          <target state="translated">Period</target>
        </trans-unit>
        <trans-unit id="d016004473e0e58d7682856755147e33256bb813" translate="yes" xml:space="preserve">
          <source>Permission denied</source>
          <target state="translated">拒绝批准</target>
        </trans-unit>
        <trans-unit id="ca053ed9d5deaad2a727eb5b9ce7480cd5b49c87" translate="yes" xml:space="preserve">
          <source>Permit sending of broadcast messages</source>
          <target state="translated">允许发送广播信息</target>
        </trans-unit>
        <trans-unit id="29e98f8d6c9356b9f9b3cb0dd0fac5d3d678c8e6" translate="yes" xml:space="preserve">
          <source>Physical equality test.</source>
          <target state="translated">身体平等测试;</target>
        </trans-unit>
        <trans-unit id="764dcc2a562c9da7446795d50aa77b7dbdc6bc96" translate="yes" xml:space="preserve">
          <source>Physical inequality test.</source>
          <target state="translated">物理不平等测试。</target>
        </trans-unit>
        <trans-unit id="9077104dc61ea39ed76dd5e6b7f00ad4f53b057c" translate="yes" xml:space="preserve">
          <source>Pipe abstract syntax trees through preprocessor command.</source>
          <target state="translated">通过预处理器命令管抽象语法树。</target>
        </trans-unit>
        <trans-unit id="258a386ac1d80ecc73cf9133d40fece735aa3f44" translate="yes" xml:space="preserve">
          <source>Pipe sources through preprocessor command.</source>
          <target state="translated">通过预处理机命令管源。</target>
        </trans-unit>
        <trans-unit id="8c0094bdf1788f2095a6baf0ac9fd3dc283b5db4" translate="yes" xml:space="preserve">
          <source>Pipes and redirections</source>
          <target state="translated">管道和改道</target>
        </trans-unit>
        <trans-unit id="48afc6d396ff51a5ed35b5868fabdc57f1c9fb87" translate="yes" xml:space="preserve">
          <source>Pollable event</source>
          <target state="translated">可污染事件</target>
        </trans-unit>
        <trans-unit id="4044893229fcfc93927dd395fda2603f25cbf9b0" translate="yes" xml:space="preserve">
          <source>Polling</source>
          <target state="translated">Polling</target>
        </trans-unit>
        <trans-unit id="b87c82743d31a59fa081b4b5917f7e5fb9a91553" translate="yes" xml:space="preserve">
          <source>Polymorphic methods are called in exactly the same way as normal methods, but you should be aware of some limitations of type inference. Namely, a polymorphic method can only be called if its type is known at the call site. Otherwise, the method will be assumed to be monomorphic, and given an incompatible type.</source>
          <target state="translated">多态方法的调用方式与普通方法完全相同,但你应该注意类型推理的一些限制。也就是说,多态方法只有在调用站点知道其类型时才能被调用。否则,该方法将被认为是单态的,并被赋予一个不兼容的类型。</target>
        </trans-unit>
        <trans-unit id="9825069b45f85b17a181b73e838bf2e21e0bf759" translate="yes" xml:space="preserve">
          <source>Polymorphic type annotations in let-definitions behave in a way similar to polymorphic methods:</source>
          <target state="translated">let-定义中的多态类型注解的行为方式与多态方法类似。</target>
        </trans-unit>
        <trans-unit id="213691ff9b4dc02fdb3bf4a27f4eb612ef11f926" translate="yes" xml:space="preserve">
          <source>Polymorphic variant tags</source>
          <target state="translated">多态变异标签</target>
        </trans-unit>
        <trans-unit id="22aa46a8a43e1108e30e6c20c787a6de9123751d" translate="yes" xml:space="preserve">
          <source>Polymorphic variant types describe the values a polymorphic variant may take.</source>
          <target state="translated">多态变体类型描述了一个多态变体可能采取的值。</target>
        </trans-unit>
        <trans-unit id="2029098a5b14173ba88c69574469d4e0ce8f59cd" translate="yes" xml:space="preserve">
          <source>Polymorphic variants are an alternate form of variant values, not belonging explicitly to a predefined variant type, and following specific typing rules. They can be either constant, written `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, or non-constant, written `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;(v).</source>
          <target state="translated">多态变体是变体值的另一种形式，不明确地属于预定义的变体类型，并且遵循特定的输入规则。它们可以是常量的书面&lt;a href=&quot;names#tag-name&quot;&gt;标记名&lt;/a&gt;，也可以是非恒定的书面&lt;a href=&quot;names#tag-name&quot;&gt;标记名&lt;/a&gt;（v）。</target>
        </trans-unit>
        <trans-unit id="2610209437f25d35cbd42b41c775ccdcaf3af336" translate="yes" xml:space="preserve">
          <source>Position (in &lt;a href=&quot;sys#VALargv&quot;&gt;&lt;code&gt;Sys.argv&lt;/code&gt;&lt;/a&gt;) of the argument being processed.</source>
          <target state="translated">正在处理的参数的位置（在&lt;a href=&quot;sys#VALargv&quot;&gt; &lt;code&gt;Sys.argv&lt;/code&gt; 中&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="45f6ef1f36c845706de35765267136890ed1fd7c" translate="yes" xml:space="preserve">
          <source>Position (in &lt;a href=&quot;sys#VALargv&quot;&gt;&lt;code&gt;Sys.argv&lt;/code&gt;&lt;/a&gt;) of the argument being processed. You can change this value, e.g. to force &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt; to skip some arguments. &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt; uses the initial value of &lt;a href=&quot;arg#VALcurrent&quot;&gt;&lt;code&gt;Arg.current&lt;/code&gt;&lt;/a&gt; as the index of argument 0 (the program name) and starts parsing arguments at the next element.</source>
          <target state="translated">正在处理的参数的位置（在&lt;a href=&quot;sys#VALargv&quot;&gt; &lt;code&gt;Sys.argv&lt;/code&gt; 中&lt;/a&gt;）。您可以更改此值，例如，强制&lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; &lt;/a&gt;跳过某些参数。&lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; &lt;/a&gt;使用的初始值&lt;a href=&quot;arg#VALcurrent&quot;&gt; &lt;code&gt;Arg.current&lt;/code&gt; &lt;/a&gt;作为参数0（节目名称）和开始于下一个元素解析参数的索引。</target>
        </trans-unit>
        <trans-unit id="48fd514253c1577755278adb384c498032582797" translate="yes" xml:space="preserve">
          <source>Position tracking mode works as follows. At each token, the lexing engine will copy &lt;code&gt;lex_curr_p&lt;/code&gt; to &lt;code&gt;lex_start_p&lt;/code&gt;, then change the &lt;code&gt;pos_cnum&lt;/code&gt; field of &lt;code&gt;lex_curr_p&lt;/code&gt; by updating it with the number of characters read since the start of the &lt;code&gt;lexbuf&lt;/code&gt;. The other fields are left unchanged by the lexing engine. In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also &lt;code&gt;new_line&lt;/code&gt;).</source>
          <target state="translated">位置跟踪模式的工作方式如下。在每个令牌时，乐星引擎将复制 &lt;code&gt;lex_curr_p&lt;/code&gt; 到 &lt;code&gt;lex_start_p&lt;/code&gt; ，然后改变 &lt;code&gt;pos_cnum&lt;/code&gt; 领域 &lt;code&gt;lex_curr_p&lt;/code&gt; 用的字符数更新它自开始读 &lt;code&gt;lexbuf&lt;/code&gt; 。词典引擎使其他字段保持不变。为了保持它们的准确性，必须在首次使用lexbuf之前对其进行初始化，并通过相关的lexer操作对其进行更新（即，在每一行的末尾，另请参见 &lt;code&gt;new_line&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d2013d98249e5e8bcfd7d895cc29b28e763b3a92" translate="yes" xml:space="preserve">
          <source>Positioning modes for &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALlseek&quot;&gt; &lt;code&gt;Unix.lseek&lt;/code&gt; 的&lt;/a&gt;定位模式。</target>
        </trans-unit>
        <trans-unit id="22c07ff7a6172b892fe2ca9c53ec2061c8855ce1" translate="yes" xml:space="preserve">
          <source>Positioning modes for &lt;a href=&quot;unixlabels#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALlseek&quot;&gt; &lt;code&gt;UnixLabels.lseek&lt;/code&gt; 的&lt;/a&gt;定位模式。</target>
        </trans-unit>
        <trans-unit id="cd4683fadf7005eca07e4d6267ddbb19ebcb91fa" translate="yes" xml:space="preserve">
          <source>Positions</source>
          <target state="translated">Positions</target>
        </trans-unit>
        <trans-unit id="653a3645251575bf9279abc23fa56dfc34058739" translate="yes" xml:space="preserve">
          <source>Positive infinity.</source>
          <target state="translated">正无穷大。</target>
        </trans-unit>
        <trans-unit id="f86a729c53a1915ca3654adc8aae51c101d917df" translate="yes" xml:space="preserve">
          <source>Power function.</source>
          <target state="translated">电源功能。</target>
        </trans-unit>
        <trans-unit id="8fbbe41e74c44588da3a875aa227d393b9e7e864" translate="yes" xml:space="preserve">
          <source>Power function. &lt;code&gt;pow&amp;nbsp;z1&amp;nbsp;z2&lt;/code&gt; returns &lt;code&gt;z1&lt;/code&gt; to the &lt;code&gt;z2&lt;/code&gt; power.</source>
          <target state="translated">电源功能。 &lt;code&gt;pow&amp;nbsp;z1&amp;nbsp;z2&lt;/code&gt; 回报 &lt;code&gt;z1&lt;/code&gt; 到 &lt;code&gt;z2&lt;/code&gt; 动力。</target>
        </trans-unit>
        <trans-unit id="5789da79b475d584d15053c8dde659f5c24e3de1" translate="yes" xml:space="preserve">
          <source>Precedence level and associativity of operators</source>
          <target state="translated">操作符的优先级和关联性</target>
        </trans-unit>
        <trans-unit id="ef8a0e66b4c1574357482510c167de122caee2aa" translate="yes" xml:space="preserve">
          <source>Predecessor.</source>
          <target state="translated">Predecessor.</target>
        </trans-unit>
        <trans-unit id="b3d4df1b4fc8bba29600c89de44c71635c187145" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Int32.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int32.sub&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt;.</source>
          <target state="translated">前任。 &lt;code&gt;Int32.pred&amp;nbsp;x&lt;/code&gt; 是 &lt;code&gt;Int32.sub&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a365fc68958b3868521e16be1f99a37de6553c7a" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Int64.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int64.sub&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt;.</source>
          <target state="translated">前任。 &lt;code&gt;Int64.pred&amp;nbsp;x&lt;/code&gt; 是 &lt;code&gt;Int64.sub&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3760cb7859c8cbaa586b1b23829a81faa04f5005" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Nativeint.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Nativeint.sub&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt;.</source>
          <target state="translated">前任。 &lt;code&gt;Nativeint.pred&amp;nbsp;x&lt;/code&gt; 是 &lt;code&gt;Nativeint.sub&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a72b78329d76d9323072a7e5e631c531e356e518" translate="yes" xml:space="preserve">
          <source>Predefined data structures include tuples, arrays, and lists. There are also general mechanisms for defining your own data structures, such as records and variants, which will be covered in more detail later; for now, we concentrate on lists. Lists are either given in extension as a bracketed list of semicolon-separated elements, or built from the empty list [] (pronounce &amp;ldquo;nil&amp;rdquo;) by adding elements in front using the :: (&amp;ldquo;cons&amp;rdquo;) operator.</source>
          <target state="translated">预定义的数据结构包括元组，数组和列表。还有一些通用的机制可以定义您自己的数据结构，例如记录和变体，稍后将对其进行详细介绍。目前，我们专注于列表。列表以扩展名的形式给出，以方括号括起来的分号分隔的列表形式提供，或通过使用::（&amp;ldquo; cons&amp;rdquo;）运算符在前面添加元素而从空列表[]（发音为&amp;ldquo; nil&amp;rdquo;）构建。</target>
        </trans-unit>
        <trans-unit id="2d1410f8fbd254f890a3355e9bcb2305c86175f5" translate="yes" xml:space="preserve">
          <source>Predefined parsers</source>
          <target state="translated">预定义解析器</target>
        </trans-unit>
        <trans-unit id="1f3e08e9e6eb753141109ff66d4be4a3ea38babd" translate="yes" xml:space="preserve">
          <source>Predicates and comparisons</source>
          <target state="translated">预言和比较</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="a46adfa85b9e12a0f2b4120e9bc73717dcfc0bd1" translate="yes" xml:space="preserve">
          <source>Preprocessor warning.</source>
          <target state="translated">前处理程序警告。</target>
        </trans-unit>
        <trans-unit id="9d8c2216bf58d48c75b9b44385be2473949e9115" translate="yes" xml:space="preserve">
          <source>Preprocessors that generate OCaml source code can insert line number directives in their output so that error messages produced by the compiler contain line numbers and file names referring to the source file before preprocessing, instead of after preprocessing. A line number directive is composed of a # (sharp sign), followed by a positive integer (the source line number), optionally followed by a character string (the source file name). Line number directives are treated as blanks during lexical analysis.</source>
          <target state="translated">生成OCaml源代码的预处理器可以在其输出中插入行号指令,这样编译器产生的错误信息就包含了预处理前而不是预处理后引用源文件的行号和文件名。一个行号指令由#(尖号)组成,后面是一个正整数(源文件行号),可选的后面是一个字符串(源文件名)。在词汇分析过程中,行号指令被视为空白。</target>
        </trans-unit>
        <trans-unit id="bace76147e38ae19d3a0c11609fc9d38e774f7e8" translate="yes" xml:space="preserve">
          <source>Pretty-printing</source>
          <target state="translated">Pretty-printing</target>
        </trans-unit>
        <trans-unit id="1cccabcdd6a358d979939998cc033a04308c5cf5" translate="yes" xml:space="preserve">
          <source>Pretty-printing boxes</source>
          <target state="translated">漂亮的印刷盒</target>
        </trans-unit>
        <trans-unit id="b2a4462f39466982126a74de486bca0779a059f3" translate="yes" xml:space="preserve">
          <source>Pretty-printing termination</source>
          <target state="translated">靓印终止</target>
        </trans-unit>
        <trans-unit id="fb3bd5a8a477c68713e4b63b07bf86de7633d445" translate="yes" xml:space="preserve">
          <source>Pretty-printing.</source>
          <target state="translated">Pretty-printing.</target>
        </trans-unit>
        <trans-unit id="8dc354dacf2179400fda256bb8b5273768f4fa0d" translate="yes" xml:space="preserve">
          <source>Primitives with several arguments are always curried. The C function does not necessarily have the same name as the ML function.</source>
          <target state="translated">有几个参数的基元总是被诅咒的。C函数与ML函数的名称不一定相同。</target>
        </trans-unit>
        <trans-unit id="4927a230a7393e58f700f3b895b9a8e2141e1502" translate="yes" xml:space="preserve">
          <source>Print a boolean in the current pretty-printing box.</source>
          <target state="translated">在当前的漂亮打印框中打印一个布尔值。</target>
        </trans-unit>
        <trans-unit id="429be0de1bf187c6aed029fd0f262066cde03fe6" translate="yes" xml:space="preserve">
          <source>Print a byte sequence on standard error.</source>
          <target state="translated">在标准误差上打印一个字节序列。</target>
        </trans-unit>
        <trans-unit id="c9b40235213e3b9b233db12ee353ee4db3cf9b5e" translate="yes" xml:space="preserve">
          <source>Print a byte sequence on standard output.</source>
          <target state="translated">在标准输出上打印一个字节序列。</target>
        </trans-unit>
        <trans-unit id="a6c581c84ffe95bc9ceacf3ea66bdfc3a0500bac" translate="yes" xml:space="preserve">
          <source>Print a character in the current pretty-printing box.</source>
          <target state="translated">在当前的漂亮打印框中打印一个字符。</target>
        </trans-unit>
        <trans-unit id="af319c36a4f3c8916104f4d0b89b33a561567553" translate="yes" xml:space="preserve">
          <source>Print a character on standard error.</source>
          <target state="translated">在标准误差上打印一个字符。</target>
        </trans-unit>
        <trans-unit id="26d52b245107b56716114cb4df780a3991c94880" translate="yes" xml:space="preserve">
          <source>Print a character on standard output.</source>
          <target state="translated">在标准输出上打印一个字符。</target>
        </trans-unit>
        <trans-unit id="3800dc392ff64d7282401e28ec9718d894a98136" translate="yes" xml:space="preserve">
          <source>Print a floating point number in the current pretty-printing box.</source>
          <target state="translated">在当前的漂亮打印框中打印一个浮点数。</target>
        </trans-unit>
        <trans-unit id="d1d3361cbb609b643a25135cfa13aaa39fdd8216" translate="yes" xml:space="preserve">
          <source>Print a floating-point number, in decimal, on standard error.</source>
          <target state="translated">打印一个浮点数,以十进制为单位,标准误差。</target>
        </trans-unit>
        <trans-unit id="1f593ed3a39b6bcdd833537c6e2868f7d6bbca3c" translate="yes" xml:space="preserve">
          <source>Print a floating-point number, in decimal, on standard output.</source>
          <target state="translated">在标准输出上打印一个十进制的浮点数。</target>
        </trans-unit>
        <trans-unit id="d6af9922bfeade8a893e020a9b67b642c05b2584" translate="yes" xml:space="preserve">
          <source>Print a list of checkpoints.</source>
          <target state="translated">打印检查点清单。</target>
        </trans-unit>
        <trans-unit id="87b79eb900647a5ec2eb44f25634fcf150fb96e4" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard error, and flush standard error.</source>
          <target state="translated">打印标准错误上的换行字符,并刷新标准错误。</target>
        </trans-unit>
        <trans-unit id="d02b6c71fe25d1c006f404421e4a18e508b909cb" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard output, and flush standard output.</source>
          <target state="translated">在标准输出上打印一个新行字符,并刷新标准输出。</target>
        </trans-unit>
        <trans-unit id="51802e08b4337c0255ed47927f1d410b8ef886cb" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.</source>
          <target state="translated">在标准输出上打印一个新行字符,并刷新标准输出。这可以用来模拟标准输出的行缓冲。</target>
        </trans-unit>
        <trans-unit id="57b23be15f00e2b2a766ad074fcad3032022f804" translate="yes" xml:space="preserve">
          <source>Print a raw backtrace in the same format &lt;code&gt;Printexc.print_backtrace&lt;/code&gt; uses.</source>
          <target state="translated">以与 &lt;code&gt;Printexc.print_backtrace&lt;/code&gt; 使用的相同格式打印原始回溯。</target>
        </trans-unit>
        <trans-unit id="c59315f70ac13c50e613039426e9b1da6c2b46f5" translate="yes" xml:space="preserve">
          <source>Print a string on standard error.</source>
          <target state="translated">在标准错误上打印一个字符串。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
