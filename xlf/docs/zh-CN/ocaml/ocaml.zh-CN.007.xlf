<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="7fe36a70c00075434c397a228dd28b19a5b40291" translate="yes" xml:space="preserve">
          <source>Add a type constraint or a .mli file to give a monomorphic type (without type variables) to name. For instance, instead of writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d460cb8c37089106d003c1064dc954647c1bde" translate="yes" xml:space="preserve">
          <source>Add chars to the buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affd53b88d19affb53002eff0f7ab10e5f0630fe" translate="yes" xml:space="preserve">
          <source>Add debugging information while compiling and linking. This option is required in order to be able to debug the program with ocamldebug (see chapter &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;), and to produce stack backtraces when the program terminates on an uncaught exception (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f703a0da73682e7d141b1e27a7036a264d64a0be" translate="yes" xml:space="preserve">
          <source>Add debugging information while compiling and linking. This option is required in order to produce stack backtraces when the program terminates on an uncaught exception (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455a2ac695c6d841be54d9f6f0655b40013388f9" translate="yes" xml:space="preserve">
          <source>Add dir to the search path for support libraries (-llib).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116b0bc4c5e306f590fdd8ab71c4f3dc593b0c74" translate="yes" xml:space="preserve">
          <source>Add directory to the list of directories search for compiled interface files (.cmi files).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878c236c047eba2ad1017cde59fa0100f152504e" translate="yes" xml:space="preserve">
          <source>Add directory to the list of directories searched for source files and compiled files. (See also the directory command.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be49e6e9b0eecf83542277ada9d3da7115d88260" translate="yes" xml:space="preserve">
          <source>Add information about character encoding being charset (default is iso-8859-1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6ef14ba006276ead07154782672d0457bf2569" translate="yes" xml:space="preserve">
          <source>Add the elements from the generator to the end of the queue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac5528706d79b74ed1b9c9192758668ff8b43c2" translate="yes" xml:space="preserve">
          <source>Add the elements from the iterator on the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7dc7879ac55573a76496ddd53427351b0d604a9" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the map, in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fad10cd0ddb0c2dfbda0638ff0f97fa42bff42" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the table, using &lt;a href=&quot;hashtbl#VALadd&quot;&gt;&lt;code&gt;Hashtbl.add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd7c11fca19595f5a44b83f3967232eedefd40a" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the table, using &lt;a href=&quot;hashtbl#VALreplace&quot;&gt;&lt;code&gt;Hashtbl.replace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a38a85af367f6bd745ea024df2117e2ce32273" translate="yes" xml:space="preserve">
          <source>Add the given directories to the search path. These directories are added at the front, and will therefore be searched first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2a498cca321b2fed042a8d0a9f1d47b869451f" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmx), and libraries (.cmxa). By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8aa612e0bd4e90878648990b0d60b2f8b470f23" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled interface files (.cmi), compiled object code files .cmo, libraries (.cma) and C libraries specified with -cclib -lxxx. By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cdc17897cdef0ea127e80a815a02cb302ed598" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled object code files (.cmo and .cma).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21f70a2b309db4bc3ef2020833733d08aefdc27" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source and compiled files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b72349c349661191e6ab2b2f4321482a5c93cf" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source and compiled files. By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55301a601e766daeea1fded3c06e3dc26a7f2ce1" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source files. If a source file foo.ml mentions an external compilation unit Bar, a dependency on that unit&amp;rsquo;s interface bar.cmi is generated only if the source for bar is found in the current directory or in one of the directories specified with -I. Otherwise, Bar is assumed to be a module from the standard library, and no dependencies are generated. For programs that span multiple directories, it is recommended to pass ocamldep the same -I options that are passed to the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e7020b45f1262cb41170e433ca8235ad7c946e" translate="yes" xml:space="preserve">
          <source>Add the given directory to the path where to look for custom generators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0af8f38e88eae6f30e6f6e5ee8f246c3bf179e" translate="yes" xml:space="preserve">
          <source>Add the given elements to the set, in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddbfb3e864dea530a3009f02fcf2d7ae593b572" translate="yes" xml:space="preserve">
          <source>Add the suffix string to the name of the runtime library used by the program. Currently, only one such suffix is supported: d, and only if the OCaml compiler was configured with option -with-debug-runtime. This suffix gives the debug version of the runtime, which is useful for debugging pointer problems in low-level code such as C stubs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde07839c2e1ab1f3cdd8033814a37ff821e5c7d" translate="yes" xml:space="preserve">
          <source>Adding such a wrapper will penalise indirect calls to the function (which might exist in arbitrary places; remember that this transformation is not for example applied only on functions the compiler has produced as a result of specialisation) since such calls will bounce through the wrapper. To mitigate this, if a function is small enough when weighed up against the number of free variables being removed, it will be duplicated by the transformation to obtain two versions: the original (used for indirect calls, since we can do no better) and the wrapper/rewritten function pair as described in the previous paragraph. The wrapper/rewritten function pair will only be used at direct call sites of the function. (The wrapper in this case is known as a &lt;em&gt;direct call surrogate&lt;/em&gt;, since it takes the place of another function&amp;mdash;the unchanged version used for indirect calls&amp;mdash;at direct call sites.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="e372ea45fd570b0859356c6972474a58f8da3b86" translate="yes" xml:space="preserve">
          <source>Addition.</source>
          <target state="translated">Addition.</target>
        </trans-unit>
        <trans-unit id="b36e2f53930600a65d8f90fb7c04d3c68cb6a078" translate="yes" xml:space="preserve">
          <source>Additional directories to search for compiled object code files (.cmi, .cmo and .cma). The specified directories are considered from left to right, after the include directories specified on the command line via -I have been searched. Available since OCaml 4.08.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020cf7d20693ee54765c9f2fb5a0cc253fce23c6" translate="yes" xml:space="preserve">
          <source>Additional directories to search for dynamically-loaded libraries (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0a4e8cb19afd44c38722faacb960225f305ceb" translate="yes" xml:space="preserve">
          <source>Additionally, built-in exceptions with a structured argument that includes a string also have the attribute set: Assert_failure and Match_failure will raise the warning for a pattern that uses a literal string to match the first element of their tuple argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70f93df5e8f9b55be44fbeee9d203972e3383d4" translate="yes" xml:space="preserve">
          <source>Address</source>
          <target state="translated">Address</target>
        </trans-unit>
        <trans-unit id="53cce0631f5ba4546493e150cc5ef970434eef7f" translate="yes" xml:space="preserve">
          <source>Address already in use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3745f20c2bcb9c33dec185e795a8e5bec761e0" translate="yes" xml:space="preserve">
          <source>Address family not supported by protocol family</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b449a1c0e4b819e90ee96bb46539dc08f8d4fc" translate="yes" xml:space="preserve">
          <source>Address information returned by &lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt;&lt;code&gt;Unix.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5270967f8aa725bc38f8d3001d92c3c290cfd4e3" translate="yes" xml:space="preserve">
          <source>Adds the directory dir to the run-time search path for shared C libraries. At link-time, shared libraries are searched in the standard search path (the one corresponding to the -I option). The -dllpath option simply stores dir in the produced executable file, where ocamlrun can find it and use it as described in section &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d4ba924eb9ae0cdf52c36ae7d6177d243e3d97" translate="yes" xml:space="preserve">
          <source>Advanced functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be1dccb0ebeabdbef35b5315c8f47e16cedaecc" translate="yes" xml:space="preserve">
          <source>Advanced options, only needed for detailed tuning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd85ae0c465f1d173aeb4b1bcfa8f8c49970ca7" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;Hashtbl.randomize()&lt;/code&gt;, hash tables are created in randomized mode by default: &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; returns randomized hash tables, unless the &lt;code&gt;~random:false&lt;/code&gt; optional parameter is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e705c02a6171a4c6d4fea54dc86bfd5ddbe3e1" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;Hashtbl.randomize()&lt;/code&gt;, hash tables are created in randomized mode by default: &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; returns randomized hash tables, unless the &lt;code&gt;~random:false&lt;/code&gt; optional parameter is given. The same effect can be achieved by setting the &lt;code&gt;R&lt;/code&gt; parameter in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac648fcd20415a281eac85d7cfc4129ef642c1e4" translate="yes" xml:space="preserve">
          <source>After caml_release_runtime_system() was called and until caml_acquire_runtime_system() is called, the C code must not access any OCaml data, nor call any function of the run-time system, nor call back into OCaml code. Consequently, arguments provided by OCaml to the C primitive must be copied into C data structures before calling caml_release_runtime_system(), and results to be returned to OCaml must be encoded as OCaml values after caml_acquire_runtime_system() returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f3f0c73dbb8d47c45b8752a616d7f9c2523dbd" translate="yes" xml:space="preserve">
          <source>After executing this directive, all calls to the function named function-name will be &amp;ldquo;traced&amp;rdquo;. That is, the argument and the result are displayed for each call, as well as the exceptions escaping out of the function, raised either by the function itself or by another function it calls. If the function is curried, each argument is printed as it is passed to the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="257160058fb41d4072933c8170fd8f8c677a4ecd" translate="yes" xml:space="preserve">
          <source>After having described two different ways of linking C code with OCaml code, we now review the pros and cons of each, to help developers of mixed OCaml/C libraries decide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b712f12ee962e9088425b2d7e23377568c3262" translate="yes" xml:space="preserve">
          <source>After parsing, pipe the abstract syntax tree through the preprocessor command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee48a1ecc4cbaee8ef092b9aba20f2e0cf9fdf5e" translate="yes" xml:space="preserve">
          <source>After parsing, pipe the abstract syntax tree through the preprocessor command. The module Ast_mapper, described in chapter &lt;a href=&quot;parsing#c%3Aparsinglib&quot;&gt;27&lt;/a&gt;: &lt;a href=&quot;https://www.ocaml.org/releases/4.11/htmlman/compilerlibref/Ast_mapper.html&quot;&gt; Ast_mapper &lt;/a&gt; , implements the external interface of a preprocessor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd92f6a0efeae359634460366d11e9ed96823d66" translate="yes" xml:space="preserve">
          <source>After seeing the power of polymorphic variants, one may wonder why they were added to core language variants, rather than replacing them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98077527fdcfbdc6101af79b0d0d9c0e8c053b7f" translate="yes" xml:space="preserve">
          <source>After some simplification one obtains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dfd6ec974bc59afe5b3477ea504301f11b2496" translate="yes" xml:space="preserve">
          <source>After storing an int inside another_store, the type of another_store has been updated from '_weak2 option ref to int option ref. This distinction between weakly and generic polymorphic type variable protects OCaml programs from unsoundness and runtime errors. To understand from where unsoundness might come, consider this simple function which swaps a value x with the value stored inside a store reference, if there is such value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2424914b6a7484490fab4a07f86daa99ea2b9c" translate="yes" xml:space="preserve">
          <source>After these three swaps the stored value is 3. Everything is fine up to now. We can then try to swap 3 with a more interesting value, for instance a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9ebba0b459da8f8a959c4937a6826b5bb4adc4" translate="yes" xml:space="preserve">
          <source>After these two transformations, expressions are of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b46d92c4b3bfc51be50c9bc62acab867d8d2bb" translate="yes" xml:space="preserve">
          <source>Again, there is nothing magical with references: they are implemented as a single-field mutable record, as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd0fa8e76723ac77809d90f781cf47149c2c8dc" translate="yes" xml:space="preserve">
          <source>Alert categories are identified by a symbolic identifier (a lowercase identifier, following the usual lexical rules) and an optional message. The identifier is used to control which alerts are enabled, and which ones are turned into fatal errors. The message is reported to the user when the alert is triggered (i.e. when the marked component is referenced).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821334d0607e9afb49ba329bf32f1077eb433ccf" translate="yes" xml:space="preserve">
          <source>Alias for warning 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5faefdecb0d6fd295593a70f0d88b7f5386973" translate="yes" xml:space="preserve">
          <source>Alias for warning 13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eece4bf4c590c7dca347390d3119eb2ce22ea01" translate="yes" xml:space="preserve">
          <source>Alias for warning 26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4163b3aea847321829d86afa31a4866fa132ed79" translate="yes" xml:space="preserve">
          <source>Alias for warning 27.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32df4d86c18ecdcc1901160c34d77742ec601179" translate="yes" xml:space="preserve">
          <source>Alias for warning 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd24a64bfd177df95e265236817244ef9d001bc3" translate="yes" xml:space="preserve">
          <source>Alias for warning 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7880efc4150138dded4fa14b7a41acde0e894e3f" translate="yes" xml:space="preserve">
          <source>Alias for warning 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c8d2d8da2b271f2b475dfe61c813fbeffb3ca5" translate="yes" xml:space="preserve">
          <source>Alias for warning 6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215bcb589afee870a003884e4452475af7c5ed14" translate="yes" xml:space="preserve">
          <source>Alias for warning 7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963fdff6a5307cc304547c984bd4142a3b4696d5" translate="yes" xml:space="preserve">
          <source>Alias for warning 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088453e73019790a41f30c40d4205f51a852ec4c" translate="yes" xml:space="preserve">
          <source>Alias for warning 9.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd069e9b1f6d0a212cf41e18091994c486044df3" translate="yes" xml:space="preserve">
          <source>Align the documentation strings by inserting spaces at the first alignment separator (tab or, if tab is not found, space), according to the length of the keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3d3b738466251ab926226a86221e4d1ccacf36" translate="yes" xml:space="preserve">
          <source>Align the documentation strings by inserting spaces at the first alignment separator (tab or, if tab is not found, space), according to the length of the keyword. Use a alignment separator as the first character in a doc string if you want to align the whole string. The doc strings corresponding to &lt;code&gt;Symbol&lt;/code&gt; arguments are aligned on the next line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e67b08d6e3d9f789945f9c7fdbe8a81e2fa03b" translate="yes" xml:space="preserve">
          <source>All OCaml objects are represented by the C type value, defined in the include file caml/mlvalues.h, along with macros to manipulate values of that type. An object of type value is either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df48daa3b9798ecd1f34fe9ea2fad4646f39d23f" translate="yes" xml:space="preserve">
          <source>All characters in an identifier are meaningful. The current implementation accepts identifiers up to 16000000 characters in length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6df6defb9629939a8b8045bff562a3ca8d0bf6b" translate="yes" xml:space="preserve">
          <source>All examples given so far were executed under the interactive system. OCaml code can also be compiled separately and executed non-interactively using the batch compilers ocamlc and ocamlopt. The source code must be put in a file with extension .ml. It consists of a sequence of phrases, which will be evaluated at runtime in their order of appearance in the source file. Unlike in interactive mode, types and values are not printed automatically; the program must call printing functions explicitly to produce some output. The ;; used in the interactive examples is not required in source files created for use with OCaml compilers, but can be helpful to mark the end of a top-level expression unambiguously even when there are syntax errors. Here is a sample standalone program to print the greatest common divisor (gcd) of two numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5470f7fbad01a79cf6d9fb16235ab7f64f936b" translate="yes" xml:space="preserve">
          <source>All examples of modules so far have been given in the context of the interactive system. However, modules are most useful for large, batch-compiled programs. For these programs, it is a practical necessity to split the source into several files, called compilation units, that can be compiled separately, thus minimizing recompilation after changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c8d1b1c4caf1c601b893772f4974723068b285" translate="yes" xml:space="preserve">
          <source>All following functions raise &lt;code&gt;Invalid_argument&lt;/code&gt; if the space needed at index &lt;code&gt;i&lt;/code&gt; to decode or encode the integer is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4350dcd576a4e74e66f577f6d6df18a6f84b5433" translate="yes" xml:space="preserve">
          <source>All identifiers starting with __ocaml_lex are reserved for use by ocamllex; do not use any such identifier in your programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e79e2a4589c52dc85926f87b5a7800dc39bd3b" translate="yes" xml:space="preserve">
          <source>All of this contrasts with the normal Flambda mode, that is to say without -Oclassic, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c797607c91b085bf9b06812cc7196d849ff516b3" translate="yes" xml:space="preserve">
          <source>All open pretty-printing boxes are closed, all pending text is printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b207b88f6d453906fd55cf2a3659eb2c4f68c8" translate="yes" xml:space="preserve">
          <source>All open pretty-printing boxes are closed, all pending text is printed. In addition, the pretty-printer low level output device is flushed to ensure that all pending text is really displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6551aef0a45b5b4f68c9d4cf5ba28e52be6a56df" translate="yes" xml:space="preserve">
          <source>All other expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c885373b4f263d43af575175d00b5ef8dd474226" translate="yes" xml:space="preserve">
          <source>All the already tracked blocks are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206daea334aed98570a738274bdc211c4eba092a" translate="yes" xml:space="preserve">
          <source>All the macros described in this section are declared in the memory.h header file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcce04f333a29fbbb1662957786419fcadd58918" translate="yes" xml:space="preserve">
          <source>All the types defined in this module cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; or the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a19322561e155e0a2ce027d9a7b57fb495aafc3" translate="yes" xml:space="preserve">
          <source>All these are only suggestions, but keep in mind that the choice of labels is essential for readability. Bizarre choices will make the program harder to maintain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ff6b82a7573e6fc2606123d9479ee9046c5f88" translate="yes" xml:space="preserve">
          <source>All toplevel expressions in the loaded compilation units are evaluated. No facilities are provided to access value names defined by the unit. Therefore, the unit must itself register its entry points with the main program (or a previously-loaded library) e.g. by modifying tables of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff492aa66c39fd91b14adc9bbf1e9b13c1f3ced" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. By default, only recursive types where the recursion goes through an object type are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfccfe308745d0b85e1ddbf443fd40e1997b55e3" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. By default, only recursive types where the recursion goes through an object type are supported.Note that once you have created an interface using this flag, you must use it again for all dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacfe39edb68023f9b53979cfb137d43eb38557f" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. Note: once enabled, this option cannot be disabled because that would lead to unsoundness of the type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16d714ce85383f7fc519249166d89d83b1fed95" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types. (See the -rectypes option to ocamlc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6cfa8f1f0745980bd8e3a9df75ee4c71720548" translate="yes" xml:space="preserve">
          <source>Allow falling back on a lexer-based approximation when parsing fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a7ba8579f52788429ec3c986d236f094628562" translate="yes" xml:space="preserve">
          <source>Allow reuse of local addresses for bind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7adde246f249f8dc82789201ca6af6580832c5" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use some optimizations that are valid only for code that is never dynlinked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca705a2ff6c8f1e818a0c819bb67a88c184d39c" translate="yes" xml:space="preserve">
          <source>Also note that exceptions raised by user code in the interactive toplevel are not passed to this function as they are caught by the toplevel itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c938c60afba012453b4b0c8907a74c515465fa" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;list#VALfold_left&quot;&gt;&lt;code&gt;List.fold_left&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b2c25bebd20c1df230a4e4e8766f8390e7df9e" translate="yes" xml:space="preserve">
          <source>Also, finalization can be performed by trapping all exceptions, performing the finalization, then re-raising the exception:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762745851a3dbf826d56e09e22e9a0b4a5051807" translate="yes" xml:space="preserve">
          <source>Alternate end-of-line char. (usually none).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8e1724ceb669eb15e9b85abbb432d9fd0962e04" translate="yes" xml:space="preserve">
          <source>Alternative executable to use instead of the configured value. Primarily used for bootstrapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a3dd320f432929619399edc970bd7bc9279557" translate="yes" xml:space="preserve">
          <source>Alternative executable to use on native Windows for flexlink instead of the configured value. Primarily used for bootstrapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e397bee97f159dc7f7a7adecb64951a2a4af03" translate="yes" xml:space="preserve">
          <source>Alternatively, given &lt;code&gt;out_funs&lt;/code&gt;, a complete set of output functions for a formatter, then &lt;a href=&quot;format#VALformatter_of_out_functions&quot;&gt;&lt;code&gt;Format.formatter_of_out_functions&lt;/code&gt;&lt;/a&gt;&lt;code&gt;out_funs&lt;/code&gt; computes a new formatter using those functions for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2378a94f2955b1ab0316e6ec9c0c06da7e7f400" translate="yes" xml:space="preserve">
          <source>Alternatively, out-of-heap pointers can be treated as &amp;ldquo;native&amp;rdquo; integers, that is, boxed 32-bit integers on a 32-bit platform and boxed 64-bit integers on a 64-bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22956d1c15dfacc465b97fb1216a724af81628b4" translate="yes" xml:space="preserve">
          <source>Alternatively, the selection can be performed within a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af98d4c955e2ccef6756948db1dc2a57c6318273" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;Format.fprintf&lt;/code&gt; with a formatter writing to a buffer of your own: flushing the formatter and the buffer at the end of pretty-printing returns the desired string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4726692b1723191b531b8e035b61a6c25efd7572" translate="yes" xml:space="preserve">
          <source>Although their types are mutually recursive, the classes widget and window are themselves independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c908f24c3f9127570182550db0e5d68e44a44f0" translate="yes" xml:space="preserve">
          <source>Always keep the source code for values, methods and instance variables, when available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e311d4a9e00e01c3467c09939095dc2e546b21f9" translate="yes" xml:space="preserve">
          <source>Always return a copy of the argument, even if there is no escape sequence in the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a65be1ce8c39c33cb18ddead7b98c2d7c382ae6" translate="yes" xml:space="preserve">
          <source>Always return host as IP address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad666310edb265f674bc11f8775c66a735702bac" translate="yes" xml:space="preserve">
          <source>Always return service as port number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9929d854921839b4c7c71e3b9b8cd03f9593e78" translate="yes" xml:space="preserve">
          <source>Ambiguous constructor or label name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ea978f8642bd9c15dc5c2e1359af1c0f49c808" translate="yes" xml:space="preserve">
          <source>Ambiguous or-pattern variables under guard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e2d740f02490dab43c8609e88cb1c2412ec0e6" translate="yes" xml:space="preserve">
          <source>American fuzzy lop (&amp;ldquo;afl-fuzz&amp;rdquo;) is a &lt;em&gt;fuzzer&lt;/em&gt;, a tool for testing software by providing randomly-generated inputs, searching for those inputs which cause the program to crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87e40750c7790bbaecda1715323b2a074993318" translate="yes" xml:space="preserve">
          <source>An OCaml bytecode library .cma incorporating the .cmo and .ml OCaml files given as arguments, and automatically referencing the C library generated with the C object files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec67d9125ab88dc6496a757820db820c3fd6614c" translate="yes" xml:space="preserve">
          <source>An OCaml native-code library .cmxa incorporating the .cmx and .ml OCaml files given as arguments, and automatically referencing the C library generated with the C object files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da66ccddbbcfc69305f9b4de6de7b35a0a2c218" translate="yes" xml:space="preserve">
          <source>An abstract module type specification moduletype&lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; allows the name &lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; to be implemented by any module type in a matching signature, but hides the implementation of the module type to all users of the signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dda98608502104a1eef0559ef406e0808aa2e72" translate="yes" xml:space="preserve">
          <source>An alarm is a piece of data that calls a user function at the end of each major GC cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fceb9745728936fccfd146268101c81198650cd" translate="yes" xml:space="preserve">
          <source>An alarm is a piece of data that calls a user function at the end of each major GC cycle. The following functions are provided to create and delete alarms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f6cdde9216626eff9ef96ec87f6e970e7b2170" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;scanf.scanning#VALopen_in&quot;&gt;&lt;code&gt;Scanf.Scanning.open_in&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94611d8043a8545b1e3bbc68d41c964950c9b2a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;scanf.scanning#VALopen_in_bin&quot;&gt;&lt;code&gt;Scanf.Scanning.open_in_bin&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6d78a4f564a612f02eb3e53a69348dfb2281bc" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d62a81c2fb2390b9c75965ab9fc1bcdf2f00c8e" translate="yes" xml:space="preserve">
          <source>An alias for the type of 32-bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ad5e4e644da616967cd0761ef38fc4fa930352" translate="yes" xml:space="preserve">
          <source>An alias for the type of 64-bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffd43f5a6ac5577677a3e5c18ebc5c3c0e13f18" translate="yes" xml:space="preserve">
          <source>An alias for the type of arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf287949a68ee4658b6d4c3e3ffed4775da1907" translate="yes" xml:space="preserve">
          <source>An alias for the type of byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7684332c689d34b944c7cc9c560de0bb8ee46fb6" translate="yes" xml:space="preserve">
          <source>An alias for the type of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059f0dfd54c481e45b90ac7f1f5e71ce3f8423cf" translate="yes" xml:space="preserve">
          <source>An alias for the type of floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82332069f6fb0eaa86c82b6251782c31af87810" translate="yes" xml:space="preserve">
          <source>An alias for the type of lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c247acfde9a1c78ec191af8d28b66b8a3b355b2d" translate="yes" xml:space="preserve">
          <source>An alias for the type of native integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccdacab8e7fee56a7a0223a9c11b8b3c6770334" translate="yes" xml:space="preserve">
          <source>An alias for the type of strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618bfd3d18801f1e655e28f356be63bd7b8562e3" translate="yes" xml:space="preserve">
          <source>An alternate definition of circle, using a constraint clause in the class definition, is shown below. The type #point used below in the constraint clause is an abbreviation produced by the definition of class point. This abbreviation unifies with the type of any object belonging to a subclass of class point. It actually expands to &amp;lt; get_x : int; move : int -&amp;gt; unit; .. &amp;gt;. This leads to the following alternate definition of circle, which has slightly stronger constraints on its argument, as we now expect center to have a method get_x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b47cacb3bfd9fd1aba0d42f40eff979b6e704b9" translate="yes" xml:space="preserve">
          <source>An alternate solution would have been to define the adjustment in a special allocation function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129be3c9c278634e0d586c38102180489ee3087c" translate="yes" xml:space="preserve">
          <source>An alternate syntax is provided for the above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e37cc574f0bc60ac62ba6fcfb9007dcb2805bd8" translate="yes" xml:space="preserve">
          <source>An alternate syntax is provided to bind variables to functional values: instead of writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c7f98b5cff9fff6fb1cf1038c9406754cd6c8f" translate="yes" xml:space="preserve">
          <source>An alternative definition is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc3ea4727cbb968c6cf582f484a4b8e18d853df" translate="yes" xml:space="preserve">
          <source>An alternative is to embed the bytecode in the C code. The -output-obj option to ocamlc is provided for this purpose. It causes the ocamlc compiler to output a C object file (.o file, .obj under Windows) containing the bytecode for the OCaml part of the program, as well as a caml_startup function. The C object file produced by ocamlc -output-obj can then be linked with C code using the standard C compiler, or stored in a C library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ade0a1f9ad45bcd451d104ffbe3e9e40771842" translate="yes" xml:space="preserve">
          <source>An alternative to ocamlc -custom is to build separately a custom runtime system integrating the desired C libraries, then generate &amp;ldquo;pure&amp;rdquo; bytecode executables (not containing their own runtime system) that can run on this custom runtime. This is achieved by the -make-runtime and -use-runtime flags to ocamlc. For example, to build a custom runtime system integrating the C parts of the &amp;ldquo;Unix&amp;rdquo; and &amp;ldquo;Threads&amp;rdquo; libraries, do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55d8d7fa1b47cf10b362effa434052f1405ea7c" translate="yes" xml:space="preserve">
          <source>An alternative to try&amp;hellip;with is to catch the exception while pattern matching:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440131e5b5bff0388b1ca084c1c73f82f7b75cfe" translate="yes" xml:space="preserve">
          <source>An ancestor can be bound by appending as&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; to the inheritance construct. &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; is not a true variable and can only be used to select a method, i.e. in an expression &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;. This gives access to the method &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; as it was defined in the parent class even if it is redefined in the current class. The scope of this ancestor binding is limited to the current class. The ancestor method may be called from a subclass but only indirectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc69c843c1bcd58389ebb2099cebb2fafcfd92a" translate="yes" xml:space="preserve">
          <source>An applicative should provide a module implementing the following interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006daedb74f512410dc697574b790c690eac412a" translate="yes" xml:space="preserve">
          <source>An argument to a function that is known to always hold a particular value at runtime. These are introduced by the inliner when specialising recursive functions; and the unbox-closures pass. (See section &lt;a href=&quot;#s%3Aflambda-specialisation&quot;&gt;21.4&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a60b893728b3292dec521dfb12ae61670dfbaf" translate="yes" xml:space="preserve">
          <source>An array or record of double-precision floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de099d6b9bf898b11e949a8188e992306f13f2b6" translate="yes" xml:space="preserve">
          <source>An attribute ([@@boxed] or [@@unboxed]) on the type declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d66ba6e7828a1111bf1a161c41ab1d141e5ef9" translate="yes" xml:space="preserve">
          <source>An exception will also be raised if the given library defines toplevel modules whose name matches that of an interface depended on by a module existing in either the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. This applies even if such dependency is only a &quot;module alias&quot; dependency (i.e. just on the name rather than the contents of the interface).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5375646ebb366bf5116bc2ae873c1a496825dc9f" translate="yes" xml:space="preserve">
          <source>An exception will be raised if the given library defines toplevel modules whose names clash with modules existing either in the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. Modules from shared libraries previously loaded with &lt;code&gt;loadfile_private&lt;/code&gt; are not included in this restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e9adb3f15c17f5fbeab56e0dab47efabe68d43" translate="yes" xml:space="preserve">
          <source>An exception will be raised if the given library defines toplevel modules whose names clash with modules existing in either the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. Modules from shared libraries previously loaded with &lt;code&gt;loadfile_private&lt;/code&gt; are not included in this restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90025c98f5b4890323289b196947781e6340b557" translate="yes" xml:space="preserve">
          <source>An expression consisting in a constant evaluates to this constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace90c1621b08aa00c8a96b15f6d30d331d6e13d" translate="yes" xml:space="preserve">
          <source>An expression consisting in an access path evaluates to the value bound to this path in the current evaluation environment. The path can be either a value name or an access path to a value component of a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cfae8499d582540d3d82d2b347d5585283e5c5" translate="yes" xml:space="preserve">
          <source>An expression e is said to be &lt;em&gt;immediately linked to&lt;/em&gt; the variable name in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c225cbf4f764068b682bb84533296870c62e4bb3" translate="yes" xml:space="preserve">
          <source>An expression e is said to be &lt;em&gt;statically constructive with respect to&lt;/em&gt; the variables name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt; if at least one of the following conditions is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8924323657caeb3c679eee6ea2840479395084ba" translate="yes" xml:space="preserve">
          <source>An expression in the current program which is not enclosed within any function declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0596299a4f05385df32ae22667956b3d842ca85" translate="yes" xml:space="preserve">
          <source>An important remark here is that it is not needed to explicit fully the type of depth: it is sufficient to add annotations only for the universally quantified type variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52648597fa8dcc7ffc682bd503ba0967a3f2392b" translate="yes" xml:space="preserve">
          <source>An infix form is available for extension nodes when the payload is of the same kind (expression with expression, pattern with pattern ...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d344863eeb9df892e71ea50feb4a625f576874f" translate="yes" xml:space="preserve">
          <source>An instance of the class point is now a function that expects an initial parameter to create a point object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aabcf4fb88a6b9ab3702ebe7eaa0626b8c43f86" translate="yes" xml:space="preserve">
          <source>An instance variable can only be used in the methods and initializers that follow its definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfec687c7cd2e25fe15cf75db3a2694a19473d5" translate="yes" xml:space="preserve">
          <source>An instance variable specification will hide any previous specification of an instance variable of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41b8be11a84d152d295d2336d67b91e8d2c3060" translate="yes" xml:space="preserve">
          <source>An integer literal is a sequence of one or more digits, optionally preceded by a minus sign. By default, integer literals are in decimal (radix 10). The following prefixes select a different radix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d626a896ab2f190fc7998987ce76e7091c1c26" translate="yes" xml:space="preserve">
          <source>An interesting feature of labeled arguments is that they can be made optional. For optional parameters, the question mark ? replaces the tilde ~ of non-optional ones, and the label is also prefixed by ? in the function type. Default values may be given for such optional parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f65036af4512f44ececdc3f62c446b6b61294da" translate="yes" xml:space="preserve">
          <source>An object can be duplicated using the library function Oo.copy (see module &lt;a href=&quot;libref/oo&quot;&gt;Oo&lt;/a&gt;). Inside a method, the expression {&amp;lt; [&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] { ;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] }] &amp;gt;} returns a copy of self with the given instance variables replaced by the values of the associated expressions. A single instance variable name id stands for id=id. Other instance variables have the same value in the returned object as in self.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8fca591c68a23ba5ea157e601f3721c015e06e3" translate="yes" xml:space="preserve">
          <source>An object of type t can be seen as an object of type t' only if t is a subtype of t'. For instance, a point cannot be seen as a colored point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a053fc34f79e3900acd980c4393bdf188d2ba6" translate="yes" xml:space="preserve">
          <source>An object type &amp;lt; [&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; { ;&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; }] &amp;gt; is a record of method types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e06bba980b7f45d05db95ce6a7fd85388df6efe" translate="yes" xml:space="preserve">
          <source>An optional ;; is allowed after each specification in a signature. It serves as a syntactic separator with no semantic meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66032c41f549bccac9d0b6f0351898e608c2cda4" translate="yes" xml:space="preserve">
          <source>An optional type constraint &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; can be added before -&amp;gt; to enforce the type of the result to be compatible with the constraint &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2fcf6b100ec44acc00a333e7fc5f05e4b0696a" translate="yes" xml:space="preserve">
          <source>Analogous to a let-expression but working at the level of symbols defined in the object file. The address of a symbol is fixed, but it may be bound to both constant and non-constant expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9da5adc9da340a9bff818430088217c4a6bb634" translate="yes" xml:space="preserve">
          <source>And here is another example as a floating attribute on top of an &amp;ldquo;.mli&amp;rdquo; file (i.e. before any other non-attribute item) or on top of an &amp;ldquo;.ml&amp;rdquo; file without a corresponding interface file, so that any reference to that unit will trigger the alert:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce86f92e74f90bcfd232c04d5cf35384550f0a84" translate="yes" xml:space="preserve">
          <source>Another addition is that the redundancy check is now aware of GADTs: a case will be detected as redundant if it could be replaced by a refutation case using the same pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11568aaad65fc90346f51e27ec62e346c87f9060" translate="yes" xml:space="preserve">
          <source>Another advantage of dynamic linking is that the final users of the library do not need to have a C compiler, C linker, and C runtime libraries installed on their machines. This is no big deal under Unix and Cygwin, but many Windows users are reluctant to install Microsoft Visual C just to be able to do ocamlc -custom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379ccd865ef9bf08d87e4fe3728fcd421c371281" translate="yes" xml:space="preserve">
          <source>Another application where the absence of strengthening comes handy, is to provide an alternative implementation for an existing module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b204a1efbf2c2ea400dd0dffecaa4d167d1127" translate="yes" xml:space="preserve">
          <source>Another constructor of the class string can be defined to return a new string of a given length:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3008a5155b842268cb1cca835a9c65bc01d33f21" translate="yes" xml:space="preserve">
          <source>Another derived form is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7fc62ee868df41b11c6605c1d3d1e9e51b532e5" translate="yes" xml:space="preserve">
          <source>Another difficulty is the implementation of the method concat. In order to concatenate a string with another string of the same class, one must be able to access the instance variable externally. Thus, a method repr returning s must be defined. Here is the correct definition of strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960c7f9039396fdf9b6183a614ddd5ba1364d740" translate="yes" xml:space="preserve">
          <source>Another example of friend functions may be found in section &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;. These examples occur when a group of objects (here objects of the same class) and functions should see each others internal representation, while their representation should be hidden from the outside. The solution is always to define all friends in the same module, give access to the representation and use a signature constraint to make the representation abstract outside the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17374fb3064ba6870c538e1b446bdebf215dc251" translate="yes" xml:space="preserve">
          <source>Another frequent application of GADTs is equality witnesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b8b9dedc14e6b1cd6fe0e01857af1aa6404068" translate="yes" xml:space="preserve">
          <source>Another interesting example of variant type is the built-in 'a option type which represents either a value of type 'a or an absence of value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98e486b7a409b5e3ad08f1b7aa8b7aed3ea6303" translate="yes" xml:space="preserve">
          <source>Another method of the class Odoc_html.info will look for the function associated to a custom tag and apply it to the text given to the tag. If no function is associated to a custom tag, then the method prints a warning message on stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0ec1f90755688bc1d5656265057eb9e769167b" translate="yes" xml:space="preserve">
          <source>Another possibility is to immediately open the result of a functor application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e716b700e6f647eba563f1ccf76da8c18bce9786" translate="yes" xml:space="preserve">
          <source>Another possibility is to open the module, which brings all identifiers defined inside the module in the scope of the current structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cb70ba16214437ff5bfea383ebc35af2799280" translate="yes" xml:space="preserve">
          <source>Another possibility is to use the registration mechanism provided by OCaml. This registration mechanism enables OCaml code to register OCaml functions under some global name, and C code to retrieve the corresponding closure by this global name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34661685e35893e694d0332d27bae708ed4c0a2" translate="yes" xml:space="preserve">
          <source>Another use of polymorphic methods is to allow some form of implicit subtyping in method arguments. We have already seen in section &lt;a href=&quot;#s%3Ainheritance&quot;&gt;3.8&lt;/a&gt; how some functions may be polymorphic in the class of their argument. This can be extended to methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42742cf10f5bbb6d6cd3179117e1520377a19a5b" translate="yes" xml:space="preserve">
          <source>Another way to describe the effect of the used and max parameters is in terms of full GC cycles. If you allocate many custom blocks with used / max = 1 / N, the GC will then do one full cycle (examining every object in the heap and calling finalization functions on those that are unreachable) every N allocations. For instance, if used = 1 and max = 1000, the GC will do one full cycle at least every 1000 allocations of custom blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad308b9fe900c0c0e039593bedec472af636fdb" translate="yes" xml:space="preserve">
          <source>Anything reachable from the closure of finalisation functions is considered reachable, so the following code will not work as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604a218f5f4aab645a4a1009e1f31b43f5ed165f" translate="yes" xml:space="preserve">
          <source>Application operator: &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; is exactly equivalent to &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2efc8b148be52f9c8ed183190fada16314613f" translate="yes" xml:space="preserve">
          <source>Application operator: &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; is exactly equivalent to &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt;. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa4b8e03aa156418c5cda350eaad3455e137511" translate="yes" xml:space="preserve">
          <source>Application-defined signal 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c1a4dff4fd312fdfb5fb1c0029c4b22bf24f5e" translate="yes" xml:space="preserve">
          <source>Application-defined signal 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e847f0c9cb6ddd254ec9bee8f6186c8f3855b9" translate="yes" xml:space="preserve">
          <source>Applications of functors at toplevel are biased in favour of inlining. (This bias may be adjusted: see the documentation for -inline-lifting-benefit below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd544829c5c539d781194c7e44400d0c1a9dda50" translate="yes" xml:space="preserve">
          <source>Applications of functors at toplevel will be given an additional benefit (which may be controlled by the -inline-lifting-benefit flag) to bias inlining in such situations towards keeping the inlined version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e0674aabf5c4d680c8d5e09367402b58266d96" translate="yes" xml:space="preserve">
          <source>Applications of functors not at toplevel, for example in a local module inside some other expression, are treated by the inliner identically to normal function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11dd7ffe23599b55aaefbac7a8a5cc476bbdddf" translate="yes" xml:space="preserve">
          <source>Apply the function to every element; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt; is dropped; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; then &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df0a0fae2dc98bab23f83a8fda3ec3235322c88" translate="yes" xml:space="preserve">
          <source>Apply the function to every element; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt; is dropped; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; then &lt;code&gt;y&lt;/code&gt; is returned. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9203406f752d0f2cd60c227bf6f44b27a75accdc" translate="yes" xml:space="preserve">
          <source>Arbitrary effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5271441f98aeb358bf2d4f9a6f13e679fe628438" translate="yes" xml:space="preserve">
          <source>Arc cosine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6663925560899dfcf830b9356632b7066599ce" translate="yes" xml:space="preserve">
          <source>Arc cosine. The argument must fall within the range &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt;. Result is in radians and is between &lt;code&gt;0.0&lt;/code&gt; and &lt;code&gt;pi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e8ba2c58206d6af15ec8c8ce21d9d4340480e6" translate="yes" xml:space="preserve">
          <source>Arc sine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e664c763343c0ce420ab4f8b7918cc8fec98013" translate="yes" xml:space="preserve">
          <source>Arc sine. The argument must fall within the range &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt;. Result is in radians and is between &lt;code&gt;-pi/2&lt;/code&gt; and &lt;code&gt;pi/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266c8124a574fe03155e38f56dd49a8f10def8a9" translate="yes" xml:space="preserve">
          <source>Arc tangent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2997407cb014180b9ea6377f06c6afb487aba39" translate="yes" xml:space="preserve">
          <source>Arc tangent. Result is in radians and is between &lt;code&gt;-pi/2&lt;/code&gt; and &lt;code&gt;pi/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cb7fb1af71b4cc6c9c97447cc986c742906de1" translate="yes" xml:space="preserve">
          <source>Arg</source>
          <target state="translated">Arg</target>
        </trans-unit>
        <trans-unit id="b8bc95515466bfd1d5820bfea495f62a49211b2b" translate="yes" xml:space="preserve">
          <source>Argument list too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33eb8c83de075f26368d8d83e467d02a06fefb8" translate="yes" xml:space="preserve">
          <source>Argument.</source>
          <target state="translated">Argument.</target>
        </trans-unit>
        <trans-unit id="94e2cab63df34c564db734a97c71978e506fbdc1" translate="yes" xml:space="preserve">
          <source>Argument. The argument of a complex number is the angle in the complex plane between the positive real axis and a line passing through zero and the number. This angle ranges from &lt;code&gt;-pi&lt;/code&gt; to &lt;code&gt;pi&lt;/code&gt;. This function has a discontinuity along the negative real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc3ed9a0a50398139b12d56cc9eb1c8aad70aa4" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;r1&lt;/code&gt; to &lt;code&gt;rN&lt;/code&gt; are user-defined input functions that read the argument corresponding to the &lt;code&gt;%r&lt;/code&gt; conversions specified in the format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bddb1ca12c5cd34d740d1681c0e6da5090d8ebc1" translate="yes" xml:space="preserve">
          <source>Arguments and parameters are matched according to their respective labels. Argument order is irrelevant, except among arguments with the same label, or no label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4aa3dace9de47afa590535c6430637432fcb775" translate="yes" xml:space="preserve">
          <source>Arguments ending in .c are passed to the C compiler, which generates a .o object file (.obj under Windows). This object file is linked with the program if the -custom flag is set (see the description of -custom below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e64866919ffd0c1908ab66afb8bab953b71239c" translate="yes" xml:space="preserve">
          <source>Arguments ending in .c are passed to the C compiler, which generates a .o/.obj object file. This object file is linked with the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11692d0c25badb1d4399f0c388c3baf4a014789" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cma are taken to be libraries of object bytecode. A library of object bytecode packs in a single file a set of object bytecode files (.cmo files). Libraries are built with ocamlc -a (see the description of the -a option below). The object files contained in the library are linked as regular .cmo files (see above), in the order specified when the .cma file was built. The only difference is that if an object file contained in a library is not referenced anywhere in the program, then it is not linked in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd46a96b2deb69174fd6074578fbde3a1033ca71" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmo are taken to be compiled object bytecode. These files are linked together, along with the object files obtained by compiling .ml arguments (if any), and the OCaml standard library, to produce a standalone executable program. The order in which .cmo and .ml arguments are presented on the command line is relevant: compilation units are initialized in that order at run-time, and it is a link-time error to use a component of a unit before having initialized it. Hence, a given x.cmo file must come before all .cmo files that refer to the unit x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c51513642c4d98fce646f2cf850e04390e54e5" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmx are taken to be compiled object code. These files are linked together, along with the object files obtained by compiling .ml arguments (if any), and the OCaml standard library, to produce a native-code executable program. The order in which .cmx and .ml arguments are presented on the command line is relevant: compilation units are initialized in that order at run-time, and it is a link-time error to use a component of a unit before having initialized it. Hence, a given x.cmx file must come before all .cmx files that refer to the unit x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753f2485fe970a0539a08cbdcdd898a19f368dff" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmxa are taken to be libraries of object code. Such a library packs in two files (lib.cmxa and lib.a/.lib) a set of object files (.cmx and .o/.obj files). Libraries are build with ocamlopt -a (see the description of the -a option below). The object files contained in the library are linked as regular .cmx files (see above), in the order specified when the library was built. The only difference is that if an object file contained in a library is not referenced anywhere in the program, then it is not linked in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15608ca7cbe9709e52f1f2a1ead35427cf44c51" translate="yes" xml:space="preserve">
          <source>Arguments ending in .ml are taken to be source files for compilation unit implementations. Implementations provide definitions for the names exported by the unit, and also contain expressions to be evaluated for their side-effects. From the file x.ml, the ocamlc compiler produces compiled object bytecode in the file x.cmo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927a384236546c16bb894121e3e38006a9e3ec5f" translate="yes" xml:space="preserve">
          <source>Arguments ending in .ml are taken to be source files for compilation unit implementations. Implementations provide definitions for the names exported by the unit, and also contain expressions to be evaluated for their side-effects. From the file x.ml, the ocamlopt compiler produces two files: x.o, containing native object code, and x.cmx, containing extra information for linking and optimization of the clients of the unit. The compiled implementation should always be referred to under the name x.cmx (when given a .o or .obj file, ocamlopt assumes that it contains code compiled from C, not from OCaml).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5a1961767c9a016aad419b660ee2c45f6b243d" translate="yes" xml:space="preserve">
          <source>Arguments ending in .mli are taken to be source files for compilation unit interfaces. Interfaces specify the names exported by compilation units: they declare value names with their types, define public data types, declare abstract data types, and so on. From the file x.mli, the ocamlc compiler produces a compiled interface in the file x.cmi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f655c44ea5ff1321183c50ad8e4c5f74128d49" translate="yes" xml:space="preserve">
          <source>Arguments ending in .mli are taken to be source files for compilation unit interfaces. Interfaces specify the names exported by compilation units: they declare value names with their types, define public data types, declare abstract data types, and so on. From the file x.mli, the ocamlopt compiler produces a compiled interface in the file x.cmi. The interface produced is identical to that produced by the bytecode compiler ocamlc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7173e5b0967ce88f54ecd20d265aa72b4f28c658" translate="yes" xml:space="preserve">
          <source>Arguments ending in .o or .a (.obj or .lib under Windows) are assumed to be C object files and libraries. They are passed to the C linker when linking in -custom mode (see the description of -custom below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c067102e7e1c8c13a1e6e57ba950d7491209f87" translate="yes" xml:space="preserve">
          <source>Arguments ending in .o, .a or .so (.obj, .lib and .dll under Windows) are assumed to be C object files and libraries. They are linked with the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1ab2c6381764fbe6cadd894bd7ef8c2b84a0f9" translate="yes" xml:space="preserve">
          <source>Arguments ending in .so (.dll under Windows) are assumed to be C shared libraries (DLLs). During linking, they are searched for external C functions referenced from the OCaml code, and their names are written in the generated bytecode executable. The run-time system ocamlrun then loads them dynamically at program start-up time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad3d398f9ad29c4fd230211d5ebfa56a0ba7f1c" translate="yes" xml:space="preserve">
          <source>Arithmetic exception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185bf7f331062c4c3e9e4a6aba44aec8b810f20a" translate="yes" xml:space="preserve">
          <source>Arrange for the C shared library dlllibname.so (dlllibname.dll under Windows) to be loaded dynamically by the run-time system ocamlrun at program start-up time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="431205b0376562fedb6d7afe64934615b543a4b4" translate="yes" xml:space="preserve">
          <source>Array accesses are bounds-checked, but the bounds are determined by the initial call to &lt;code&gt;map_file&lt;/code&gt;. Therefore, you should make sure no other process modifies the mapped file while you're accessing it, or a SIGBUS signal may be raised. This happens, for instance, if the file is shrunk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a80d94da93b9720aae715b13c57b162feacae54" translate="yes" xml:space="preserve">
          <source>Array layouts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb3c7a55000274933287d81122c47cc23dd9bcf" translate="yes" xml:space="preserve">
          <source>Array operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3f55326329e50888cc261427317ad3c95e07c6" translate="yes" xml:space="preserve">
          <source>Array operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac52c7170210e2cde0563a8a7cc378d8d3bab67e" translate="yes" xml:space="preserve">
          <source>Array scanning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1302b4894cb1cf89e91ae78809a8c87e194848ee" translate="yes" xml:space="preserve">
          <source>ArrayLabels</source>
          <target state="translated">ArrayLabels</target>
        </trans-unit>
        <trans-unit id="993b203e29af9582fe002cf1c0a611c787dcb4d5" translate="yes" xml:space="preserve">
          <source>Arrays are finite, variable-sized sequences of values of the same type. The current implementation supports arrays containing up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 elements (4194303 elements) unless the elements are floating-point numbers (2097151 elements in this case); on 64-bit platforms, the limit is 2&lt;sup&gt;54&lt;/sup&gt; &amp;minus; 1 for all arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dbf05ada7bef68e8d497df01ba4407cb02175f1" translate="yes" xml:space="preserve">
          <source>Arrays of floating-point numbers (type float array) have a special, unboxed, more efficient representation. These arrays are represented by pointers to blocks with tag Double_array_tag. They should be accessed with the Double_field and Store_double_field macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac7294b1d303d14c1ea81ae76623f8e989d7450" translate="yes" xml:space="preserve">
          <source>Arrays of integers and pointers are represented like tuples, that is, as pointers to blocks tagged 0. They are accessed with the Field macro for reading and the caml_modify function for writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16f611272747884cf686e3d446de513132a0e8d" translate="yes" xml:space="preserve">
          <source>Arrays of values declared using CAMLlocalN must not be written to using Store_field. Use the normal C array syntax instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80832a08a4bc7a800951f197511d4c16855f54d1" translate="yes" xml:space="preserve">
          <source>Arrays of weak pointers and hash sets of weak pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9312b18524288526ab3bb3e65773d033af7e75d" translate="yes" xml:space="preserve">
          <source>As a consequence, if the coercion is applied to self, as in the following example, the type of self is unified with the closed type c (a closed object type is an object type without ellipsis). This would constrain the type of self be closed and is thus rejected. Indeed, the type of self cannot be closed: this would prevent any further extension of the class. Therefore, a type error is generated when the unification of this type with another type would result in a closed object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236760b37470c1f5e34cd659fbad69bc911cec3c" translate="yes" xml:space="preserve">
          <source>As a convenience, caml/mlvalues.h defines the macros Val_unit, Val_false and Val_true to refer to (), false and true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6708b84bc9659abee628ea692bfc6191fdb3835" translate="yes" xml:space="preserve">
          <source>As a shared library may have several clients simultaneously, it is made for convenience that caml_startup (and caml_startup_pooled) may be called multiple times, given that each such call is paired with a corresponding call to caml_shutdown (in a nested fashion). The runtime will be unloaded once there are no outstanding calls to caml_startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d9ea1b251e88997b679926917f2a4432728a0f" translate="yes" xml:space="preserve">
          <source>As a side-effect of this generativity, one is allowed to unpack first-class modules in the body of generative functors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c21716682d59482dd8cc66a86332eb9340c37df" translate="yes" xml:space="preserve">
          <source>As a side-effect, these 3 keywords avoid the warnings 7 (method override) and 13 (instance variable override). Note that warning 7 is disabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81290b5b966f9efcf2c6b0cb0f65e7caee04d82" translate="yes" xml:space="preserve">
          <source>As a special case, assert false is reduced to raise(Assert_failure ...), which gives it a polymorphic type. This means that it can be used in place of any expression (for example as a branch of any pattern-matching). It also means that the assert false &amp;ldquo;assertions&amp;rdquo; cannot be turned off by the -noassert option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf0e568489d8aa1699963c95f2533d75f92737b" translate="yes" xml:space="preserve">
          <source>As a special case, if id is all, it stands for all alerts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52ed11f3bffe509a76486b6deece909f9053706" translate="yes" xml:space="preserve">
          <source>As a special case, if the function has a known arity, all the arguments are unlabeled, and their number matches the number of non-optional parameters, then labels are ignored and non-optional parameters are matched in their definition order. Optional arguments are defaulted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a938adb6f0aea5e4af4fb92f58e17c47a9825ed3" translate="yes" xml:space="preserve">
          <source>As an example, consider the following lexer that is parametrized over an arbitrary monad:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d510e5dbaebaaf3fcb5f83b6a111b4d9ae064d" translate="yes" xml:space="preserve">
          <source>As an example, this code will return the integer 1:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f90f529d98bdc2a64de636cdc4ec8125e7bb221" translate="yes" xml:space="preserve">
          <source>As an example, we fuzz-test the following program, readline.ml:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e17b3e7ef6d5d7fd46be15fe9cc1c0f4c1ec6b" translate="yes" xml:space="preserve">
          <source>As an exception to the above parameter matching rules, if an application is total (omitting all optional arguments), labels may be omitted. In practice, many applications are total, so that labels can often be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90091a05125db96622a5dd1550905e80e47ce30" translate="yes" xml:space="preserve">
          <source>As an optimization, records whose fields all have static type float are represented as arrays of floating-point numbers, with tag Double_array_tag. (See the section below on arrays.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b07ba0ea2f0d698023e6db84093874e3feaa2a" translate="yes" xml:space="preserve">
          <source>As an optimization, unboxable concrete data types are represented specially; a concrete data type is unboxable if it has exactly one constructor and this constructor has exactly one argument. Unboxable concrete data types are represented in the same ways as unboxable record types: see the description in section &lt;a href=&quot;#ss%3Ac-tuples-and-records&quot;&gt;20.3.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e389f44aa5a062928a493d520912df25e67b105" translate="yes" xml:space="preserve">
          <source>As another optimization, unboxable record types are represented specially; unboxable record types are the immutable record types that have only one field. An unboxable type will be represented in one of two ways: boxed or unboxed. Boxed record types are represented as described above (by a block with tag 0 or Double_array_tag). An unboxed record type is represented directly by the value of its field (i.e. there is no block to represent the record itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0914c80dac70311bbc335c79d02e0ca7dabf33" translate="yes" xml:space="preserve">
          <source>As can be expected, the type of window is recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36451f7154d544b297a165c4f3d0b643fc88da62" translate="yes" xml:space="preserve">
          <source>As checkpointing is quite expensive, it must not be done too often. On the other hand, backward execution is faster when checkpoints are taken more often. In particular, backward single-stepping is more responsive when many checkpoints have been taken just before the current time. To fine-tune the checkpointing strategy, the debugger does not take checkpoints at the same frequency for long displacements (e.g. run) and small ones (e.g. step). The two variables bigstep and smallstep contain the number of events between two checkpoints in each case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2e49921371c9b9ceab2b2609b751d4d8a6ae6b" translate="yes" xml:space="preserve">
          <source>As described above, there are three parameters that restrict the search for inlining opportunities during speculation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ce6fc5d3fc7d51652851a17e88a921906c733e" translate="yes" xml:space="preserve">
          <source>As in the PrioQueue example, it would be good style to hide the actual implementation of the type set, so that users of the structure will not rely on sets being lists, and we can switch later to another, more efficient representation of sets without breaking their code. This can be achieved by restricting Set by a suitable functor signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7636d82194e3efe6c5e09ed9156713f2d8407a4" translate="yes" xml:space="preserve">
          <source>As in the case of simple structures, an alternate syntax is provided for defining functors and restricting their result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95375c7ef1a71d2bf1c6e19c4cf628da86c59bbb" translate="yes" xml:space="preserve">
          <source>As in the case of static linking, it is possible (and recommended) to record the names of C libraries in an OCaml .cma library archive. Consider again an OCaml library mylib.cma, built from the OCaml object files a.cmo and b.cmo, which reference C code in dllmylib.so. If the library is built as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d584f24e6917e93c9448a575b3606f6a5980280" translate="yes" xml:space="preserve">
          <source>As mentioned above, a plain character in the format string is just matched with the next character of the input; however, two characters are special exceptions to this rule: the space character (&lt;code&gt;'&amp;nbsp;'&lt;/code&gt; or ASCII code 32) and the line feed character (&lt;code&gt;'\n'&lt;/code&gt; or ASCII code 10). A space does not match a single space character, but any amount of 'whitespace' in the input. More precisely, a space inside the format string matches &lt;em&gt;any number&lt;/em&gt; of tab, space, line feed and carriage return characters. Similarly, a line feed character in the format string matches either a single line feed or a carriage return followed by a line feed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910ea56dc6edf679b6fb9258db1d763027e94506" translate="yes" xml:space="preserve">
          <source>As mentioned in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;, the bytecode executable files produced by the ocamlc command are self-executable, and manage to launch the ocamlrun command on themselves automatically. That is, assuming a.out is a bytecode executable file,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a210b9b840985d0d92278ed85640a6045dd1b85" translate="yes" xml:space="preserve">
          <source>As mentioned in section &lt;a href=&quot;expr#sss%3Aexpr-localdef&quot;&gt;7.7.2&lt;/a&gt;, the letrec binding construct, in addition to the definition of recursive functions, also supports a certain class of recursive definitions of non-functional values, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bca80111a01f2e351f1111c7ac3f009fc572ff" translate="yes" xml:space="preserve">
          <source>As previously with polymorphic recursion, the problem stems from the fact that type variables are introduced only at the start of the let definitions. When we compute both f x and f y, the type of x and y are unified together. To avoid this unification, we need to indicate to the type checker that f is polymorphic in its first argument. In some sense, we would want average to have type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc8c1d2e201eb9b8575e1d067fe0b0a35105b61" translate="yes" xml:space="preserve">
          <source>As seen in section &lt;a href=&quot;objectexamples#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;, the solution is to use functional update instead. We need to create an instance variable containing the representation s of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146268ca5c35e116ecdc1071a5c5b8b50d37a961" translate="yes" xml:space="preserve">
          <source>As shown above, prefix and infix symbols as well as some keywords can be used as value names, provided they are written between parentheses. The capitalization rules are summarized in the table below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d83d9e79f521c6e091052dc06397df06c37842" translate="yes" xml:space="preserve">
          <source>As shown by the last item, the current behavior is imperfect and may be improved in future versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f52e265c35555d5dd6376d7c8518f28bfcf8591" translate="yes" xml:space="preserve">
          <source>As shown by the types of the values above, Bigarrays of kind &lt;code&gt;float32_elt&lt;/code&gt; and &lt;code&gt;float64_elt&lt;/code&gt; are accessed using the OCaml type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8476c185d0c89ce2f99fd45d0702217ddcf47f6c" translate="yes" xml:space="preserve">
          <source>As shown by the types of the values above, Bigarrays of kind &lt;code&gt;float32_elt&lt;/code&gt; and &lt;code&gt;float64_elt&lt;/code&gt; are accessed using the OCaml type &lt;code&gt;float&lt;/code&gt;. Bigarrays of complex kinds &lt;code&gt;complex32_elt&lt;/code&gt;, &lt;code&gt;complex64_elt&lt;/code&gt; are accessed with the OCaml type &lt;a href=&quot;complex#TYPEt&quot;&gt;&lt;code&gt;Complex.t&lt;/code&gt;&lt;/a&gt;. Bigarrays of integer kinds are accessed using the smallest OCaml integer type large enough to represent the array elements: &lt;code&gt;int&lt;/code&gt; for 8- and 16-bit integer Bigarrays, as well as OCaml-integer Bigarrays; &lt;code&gt;int32&lt;/code&gt; for 32-bit integer Bigarrays; &lt;code&gt;int64&lt;/code&gt; for 64-bit integer Bigarrays; and &lt;code&gt;nativeint&lt;/code&gt; for platform-native integer Bigarrays. Finally, Bigarrays of kind &lt;code&gt;int8_unsigned_elt&lt;/code&gt; can also be accessed as arrays of characters instead of arrays of small integers, by using the kind value &lt;code&gt;char&lt;/code&gt; instead of &lt;code&gt;int8_unsigned&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a7da1695c3c5352050cfec39a769dbb674cfcd" translate="yes" xml:space="preserve">
          <source>As shown in the examples above, the internal representation (also called &lt;em&gt;abstract syntax&lt;/em&gt;) of expressions quickly becomes hard to read and write as the expressions get larger. We need a printer and a parser to go back and forth between the abstract syntax and the &lt;em&gt;concrete syntax&lt;/em&gt;, which in the case of expressions is the familiar algebraic notation (e.g. 2*x+1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59652ec2d12ee8e1992d0d09b42d5fef7eaa31f9" translate="yes" xml:space="preserve">
          <source>As shown in the inferred type, the methods escaped and sub now return objects of the same type as the one of the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1677cf6090ca5f51486302f94edd1cbfae80aa0e" translate="yes" xml:space="preserve">
          <source>As such, n behaves as the &amp;ldquo;maximum depth of unrolling&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f163934b9085a82e3861515a2a64c2855047ac0e" translate="yes" xml:space="preserve">
          <source>As suggested above, the expression &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%d&quot;&amp;nbsp;f&lt;/code&gt; reads a decimal integer &lt;code&gt;n&lt;/code&gt; from the source of characters &lt;code&gt;ic&lt;/code&gt; and returns &lt;code&gt;f&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63ec4df080300cfa9da6aea74b52a0e1970e4f4" translate="yes" xml:space="preserve">
          <source>As usual in format strings, &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters must be escaped using &lt;code&gt;%%&lt;/code&gt; and &lt;code&gt;%@&lt;/code&gt;; this rule still holds within range specifications and scanning indications. For instance, format &lt;code&gt;&quot;%s@%%&quot;&lt;/code&gt; reads a string up to the next &lt;code&gt;%&lt;/code&gt; character, and format &lt;code&gt;&quot;%s@%@&quot;&lt;/code&gt; reads a string up to the next &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9513a3413b439631dd1d7bb4477ddee65ef66765" translate="yes" xml:space="preserve">
          <source>As with all other OCaml data structures, lists do not need to be explicitly allocated and deallocated from memory: all memory management is entirely automatic in OCaml. Similarly, there is no explicit handling of pointers: the OCaml compiler silently introduces pointers where necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa7b814a8e7a19b930b22e13ead91aad6715db7" translate="yes" xml:space="preserve">
          <source>As with most OCaml data structures, inspecting and destructuring lists is performed by pattern-matching. List patterns have exactly the same form as list expressions, with identifiers representing unspecified parts of the list. As an example, here is insertion sort on a list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1eb0836959399cedd4347276c1b98d0ca3d0c82" translate="yes" xml:space="preserve">
          <source>As with records, the form {&amp;lt; x &amp;gt;} is an elided version of {&amp;lt; x = x &amp;gt;} which avoids the repetition of the instance variable name. Note that the type abbreviation functional_point is recursive, which can be seen in the class type of functional_point: the type of self is 'a and 'a appears inside the type of the method move.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f13c41da6e3c55107056baa15f8a3dbb68f91b" translate="yes" xml:space="preserve">
          <source>As x is a subtype of xy, we can convert a value of type x to a value of type xy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d585775436817b8bbfb4935a528c62bb777faa" translate="yes" xml:space="preserve">
          <source>As you can see in the class type shown by the compiler, while polymorphic method types must be fully explicit in class definitions (appearing immediately after the method name), quantified type variables can be left implicit in class descriptions. Why require types to be explicit? The problem is that (int -&amp;gt; int -&amp;gt; int) -&amp;gt; int -&amp;gt; int would also be a valid type for fold, and it happens to be incompatible with the polymorphic type we gave (automatic instantiation only works for toplevel types variables, not for inner quantifiers, where it becomes an undecidable problem.) So the compiler cannot choose between those two types, and must be helped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d6e59058333963706b9356b3eee7ab6f10414a" translate="yes" xml:space="preserve">
          <source>As you move through the program, the debugger maintains an history of the successive times you stop at. The last command can be used to revisit these times: each last command moves one step back through the history. That is useful mainly to undo commands such as step and next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65354bb2656ea18d389b5fe5b411f5ee0d5e3d75" translate="yes" xml:space="preserve">
          <source>Assign an element of a generic Bigarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511e2f6557588ce6cb49fae5b91217ffb45c65de" translate="yes" xml:space="preserve">
          <source>Assign an element of a generic Bigarray. &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt; stores the value &lt;code&gt;v&lt;/code&gt; in the element of &lt;code&gt;a&lt;/code&gt; whose coordinates are &lt;code&gt;i1&lt;/code&gt; in the first dimension, &lt;code&gt;i2&lt;/code&gt; in the second dimension, ..., &lt;code&gt;iN&lt;/code&gt; in the &lt;code&gt;N&lt;/code&gt;-th dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4441e6b01109409d7db5b3985d7033187d4a2e" translate="yes" xml:space="preserve">
          <source>Assignment to non-mutable value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693b1e8e0efde6572420480f71fd8ac02e79cc56" translate="yes" xml:space="preserve">
          <source>Associate precedences and associativities to the given symbols. All symbols on the same line are given the same precedence. They have higher precedence than symbols declared before in a &lt;code&gt;%left&lt;/code&gt;, &lt;code&gt;%right&lt;/code&gt; or &lt;code&gt;%nonassoc&lt;/code&gt; line. They have lower precedence than symbols declared after in a &lt;code&gt;%left&lt;/code&gt;, &lt;code&gt;%right&lt;/code&gt; or &lt;code&gt;%nonassoc&lt;/code&gt; line. The symbols are declared to associate to the left (&lt;code&gt;%left&lt;/code&gt;), to the right (&lt;code&gt;%right&lt;/code&gt;), or to be non-associative (&lt;code&gt;%nonassoc&lt;/code&gt;). The symbols are usually tokens. They can also be dummy nonterminals, for use with the &lt;code&gt;%prec&lt;/code&gt; directive inside the rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd5b4fd5a802d12133439bb6c727c5550f6bdba" translate="yes" xml:space="preserve">
          <source>Associate style number n to the given L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X sectioning command style, e.g. section or subsection. (L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X only.) This is useful when including the generated document in another L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document, at a given sectioning level. The default association is 1 for section, 2 for subsection, 3 for subsubsection, 4 for paragraph and 5 for subparagraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c524fc36c86bd0a5d156287f9e272e9da389f023" translate="yes" xml:space="preserve">
          <source>Associate the given description (&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;) to the given parameter name id. This tag is used for functions, methods, classes and functors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec8233ec4293e18af80d1bdb5a2abfd01936116" translate="yes" xml:space="preserve">
          <source>Associate the given description (&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;) to the given version in order to document compatibility issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55db56ff500f9ca6b11e56023800331829b479b0" translate="yes" xml:space="preserve">
          <source>Association lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933443d0e9517ae1d7a08acaa81c31f178831777" translate="yes" xml:space="preserve">
          <source>Association tables over ordered types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="2a1741771c0cc3890682eb4ba730ff53f9e9d5dd" translate="yes" xml:space="preserve">
          <source>Assume that module module is opened before parsing each of the following files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="732d31f2e28996ce7c1526a4c29db2def23d8755" translate="yes" xml:space="preserve">
          <source>Assuming &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; denotes a signature, the expression &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;with&lt;a href=&quot;#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; { and&lt;a href=&quot;#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; } denotes the same signature where type equations have been added to some of the type specifications, as described by the constraints following the with keyword. The constraint type [&lt;a href=&quot;classes#type-parameters&quot;&gt;type-parameters&lt;/a&gt;] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; adds the type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; to the specification of the type component named &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; of the constrained signature. The constraint module&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;=&lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt; adds type equations to all type components of the sub-structure denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;, making them equivalent to the corresponding type components of the structure denoted by &lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abe40bc093a635fe5f2393dd098c162da653457" translate="yes" xml:space="preserve">
          <source>Assuming unique ownership of strings that are not string literals, but are (partly) built from string literals, is also incorrect. For example, mutating &lt;code&gt;unsafe_of_string&amp;nbsp;(&quot;foo&quot;&amp;nbsp;^&amp;nbsp;s)&lt;/code&gt; could mutate the shared string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; -- assuming a rope-like representation of strings. More generally, functions operating on strings will assume shared ownership, they do not preserve unique ownership. It is thus incorrect to assume unique ownership of the result of &lt;code&gt;unsafe_of_string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf8057d6f5fa665b07dbede310cfe4a69c03150" translate="yes" xml:space="preserve">
          <source>Astute readers may have wondered what happens when two or more record fields or constructors share the same name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1c0634cae4469e9d81ecf95e188f347608b54f" translate="yes" xml:space="preserve">
          <source>At any point, the parsing, compilation or evaluation of the current phrase can be interrupted by pressing ctrl-C (or, more precisely, by sending the INTR signal to the ocaml process). The toplevel then immediately returns to the # prompt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f954f80a0891f6d5cf340cf9dd1de0665d55eb" translate="yes" xml:space="preserve">
          <source>At any time, one of the stack frames is &amp;ldquo;selected&amp;rdquo; by the debugger; several debugger commands refer implicitly to the selected frame. In particular, whenever you ask the debugger for the value of a local variable, the value is found in the selected frame. The commands frame, up and down select whichever frame you are interested in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc1f362156648d6f2461a3991beac3755f48ca1" translate="yes" xml:space="preserve">
          <source>At first look, we seem to have a polymorphic iterator, however this does not work in practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b360f9d1eec9c2be338db85e91ea4dcbd8c92d8" translate="yes" xml:space="preserve">
          <source>At last, (**) is the empty documentation comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75750c4cc5cbc3e0ac4fdd64ce772e90747028f1" translate="yes" xml:space="preserve">
          <source>At last, it is possible to update few fields of a record at once:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a9bd7e79cc365e9058d6659c3e41e323547e2e" translate="yes" xml:space="preserve">
          <source>At present there may be a small penalty in terms of actual runtime performance when this transformation is enabled, although more stable performance may be obtained due to reduced allocation. It is recommended that developers experiment to determine whether the option is beneficial for their code. (It is expected that in the future it will be possible for the performance degradation to be removed.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54dd7dd52291d1b6f1c195771e2d20eb9e881245" translate="yes" xml:space="preserve">
          <source>At run-time, the ocamlyacc-generated parser can be debugged by setting the p option in the OCAMLRUNPARAM environment variable (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;). This causes the pushdown automaton executing the parser to print a trace of its action (tokens shifted, rules reduced, etc). The trace mentions rule numbers and state numbers that can be interpreted by looking at the file grammar.output generated by ocamlyacc -v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f00cca88cba919167a69aefb8aca0e72bd25ac" translate="yes" xml:space="preserve">
          <source>At runtime, &lt;code&gt;opaque_identity&lt;/code&gt; disappears altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9dc01fd9b8fd2388a520e411cae0d934f399e38" translate="yes" xml:space="preserve">
          <source>At some point, the C code must call caml_main(argv) to initialize the OCaml code. The argv argument is a C array of strings (type char **), terminated with a NULL pointer, which represents the command-line arguments, as passed as second argument to main. The OCaml array Sys.argv will be initialized from this parameter. For the bytecode compiler, argv[0] and argv[1] are also consulted to find the file containing the bytecode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6144d2f50b69132b6f0e43a3d8df29f0e099b424" translate="yes" xml:space="preserve">
          <source>At the beginning of each iteration of a loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276d173e91530ea988de8831effc50db36e2cd99" translate="yes" xml:space="preserve">
          <source>At this point, the type checker rightfully complains that it is not possible to swap an integer and a function, and that an int should always be traded for another int. Furthermore, the type checker prevents us to change manually the type of the value stored by store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baefb49296d510841d2323ca6269711e7aab517d" translate="yes" xml:space="preserve">
          <source>Atom(t) returns an &amp;ldquo;atom&amp;rdquo; (zero-sized block) with tag t. Zero-sized blocks are preallocated outside of the heap. It is incorrect to try and allocate a zero-sized block using the functions below. For instance, Atom(0) represents the empty array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4596b982bdd8c86e98fef6030471fc19a2011ab4" translate="yes" xml:space="preserve">
          <source>Attached to a &lt;em&gt;declaration&lt;/em&gt; of a function or functor, these direct the inliner to either always or never inline, irrespective of the size/benefit calculation. (If the function is recursive then the body is substituted and no special action is taken for the recursive call site(s).) @@inline with no argument is equivalent to @@inline always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802fa8cc9235819a2e3ca4b7e5ad5a55102ca722" translate="yes" xml:space="preserve">
          <source>Attached to a declaration of a function or functor, this directs the inliner to either always or never specialise the function so long as it has appropriate contextual knowledge, irrespective of the size/benefit calculation. @@specialise with no argument is equivalent to @@specialise always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01f52df1214db8e3914c14829a8d5d286049aea" translate="yes" xml:space="preserve">
          <source>Attached to a function &lt;em&gt;application&lt;/em&gt;, these direct the inliner likewise. These attributes at call sites override any other attribute that may be present on the corresponding declaration. @inlined with no argument is equivalent to @inlined always. @@inlined hint is equivalent to @@inline always except that it will not trigger warning 55 if the function application cannot be inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577cc545cd56605f7a335573934c186d1c5c7a5e" translate="yes" xml:space="preserve">
          <source>Attached to a function application, this directs the inliner likewise. This attribute at a call site overrides any other attribute that may be present on the corresponding declaration. (Note that the function will still only be specialised if there exist one or more invariant parameters whose values are known.) @specialised with no argument is equivalent to @specialised always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1728583c4e4935b573475fde344d9528bb9ac187" translate="yes" xml:space="preserve">
          <source>Attribute cannot appear in this context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4070acc0b0373988065e52262412987a5bd978b2" translate="yes" xml:space="preserve">
          <source>Attribute used more than once on an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5990efd0ab5779ce4f416b7925179828c4ee7318" translate="yes" xml:space="preserve">
          <source>Attributes are &amp;ldquo;decorations&amp;rdquo; of the syntax tree which are mostly ignored by the type-checker but can be used by external tools. An attribute is made of an identifier and a payload, which can be a structure, a type expression (prefixed with :), a signature (prefixed with :) or a pattern (prefixed with ?) optionally followed by a when clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1f8b09e882b8bdbac720d714a972f55a4914cb" translate="yes" xml:space="preserve">
          <source>August 19, 2020</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681b5b5ae10b994e61d9fc53cf8a95498ff0df39" translate="yes" xml:space="preserve">
          <source>Availability</source>
          <target state="translated">Availability</target>
        </trans-unit>
        <trans-unit id="24aced72f5f433a578a6c9a6998684afc743e91e" translate="yes" xml:space="preserve">
          <source>Avoid the following construction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="603bfbbca70684e9b081257d12079a348cfb4ae1" translate="yes" xml:space="preserve">
          <source>Backend type currently executing the OCaml program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d27fc57dc9d9f238fc65173552cc838eeef367" translate="yes" xml:space="preserve">
          <source>Bad argument to routine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100269e198b12a051ab659ff66bd324a08031278" translate="yes" xml:space="preserve">
          <source>Bad file descriptor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8951a0674378b9d01744b0df5ceff44c017f170d" translate="yes" xml:space="preserve">
          <source>Bad module name: the source file name is not a valid OCaml module name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb2f5b83ca06e2054445f5793507dccb214e76c" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d2d5bc5f9c1c788a0de9d9941705860dc2b3ce" translate="yes" xml:space="preserve">
          <source>Basic file input/output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7074f9544472955bb39bd2591371cef9276556d5" translate="yes" xml:space="preserve">
          <source>Basic input/output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51905526a8ccdb787933df456dfe816843d0ee8" translate="yes" xml:space="preserve">
          <source>Be aware that subtyping and inheritance are not related. Inheritance is a syntactic relation between classes while subtyping is a semantic relation between types. For instance, the class of colored points could have been defined directly, without inheriting from the class of points; the type of colored points would remain unchanged and thus still be a subtype of points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc8260c792f0fd4d9bb961f3934f71b326ac1eb" translate="yes" xml:space="preserve">
          <source>Before 4.10, it was not fully implemented by the native-code compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74f4732c6818d44f09006d1f07ce5f4af4c8740" translate="yes" xml:space="preserve">
          <source>Before 4.10, stack overflows, typically caused by excessively deep recursion, are not always turned into a Stack_overflow exception like with the bytecode compiler. The runtime system makes a best effort to trap stack overflows and raise the Stack_overflow exception, but sometimes it fails and a &amp;ldquo;segmentation fault&amp;rdquo; or another system fault occurs instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb21f986b61750e9afb09c606ad7c4cb297548ed" translate="yes" xml:space="preserve">
          <source>Before OCaml 4.08, there was support for a single kind of deprecation alert. It is now known as the deprecated alert, but legacy attributes to trigger it and the legacy ways to control it as warning 3 are still supported. For instance, passing -w +3 on the command-line is equivant to -alert +deprecated, and:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de7f66ef195f2ee3a503b74c10b402e912c79ce" translate="yes" xml:space="preserve">
          <source>Before OCaml 4.09, this package simply ensures that the graphics library was installed by the compiler, and starting from OCaml 4.09 this package effectively provides the graphics library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e622083eb29748ddeeec3a04799aa00ee19ac13f" translate="yes" xml:space="preserve">
          <source>Before including any of these files, you should define the OCAML_NAME_SPACE macro. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4184edb42a26ccfe7484a8b5fb01a18a764ebd" translate="yes" xml:space="preserve">
          <source>Before profiling an execution, the program must be compiled in profiling mode, using the ocamlcp front-end to the ocamlc compiler (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;) or the ocamloptp front-end to the ocamlopt compiler (see chapter &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;). When compiling modules separately, ocamlcp or ocamloptp must be used when compiling the modules (production of .cmo or .cmx files), and can also be used (though this is not strictly necessary) when linking them together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51fe98572851ae3a2060aa9cce6148029d326e3" translate="yes" xml:space="preserve">
          <source>Before the debugger can be used, the program must be compiled and linked with the -g option: all .cmo and .cma files that are part of the program should have been created with ocamlc -g, and they must be linked together with ocamlc -g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7224b7ef29ead465950bd04b8cbe2bc5541ba937" translate="yes" xml:space="preserve">
          <source>Behave as &lt;a href=&quot;threadunix#VALread&quot;&gt;&lt;code&gt;ThreadUnix.read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;threadunix#VALwrite&quot;&gt;&lt;code&gt;ThreadUnix.write&lt;/code&gt;&lt;/a&gt;, except that &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; is raised if no data is available for reading or ready for writing after &lt;code&gt;d&lt;/code&gt; seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62be5fdf722fa0cb2c996d270b26e047fd26ba0" translate="yes" xml:space="preserve">
          <source>Behave as &lt;a href=&quot;threadunix#VALread&quot;&gt;&lt;code&gt;ThreadUnix.read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;threadunix#VALwrite&quot;&gt;&lt;code&gt;ThreadUnix.write&lt;/code&gt;&lt;/a&gt;, except that &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; is raised if no data is available for reading or ready for writing after &lt;code&gt;d&lt;/code&gt; seconds. The delay &lt;code&gt;d&lt;/code&gt; is given in the fifth argument, in seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3044d7453db8cbe2dec3a026dd466846b73be035" translate="yes" xml:space="preserve">
          <source>Being written directly into the output device of the formatter, semantic tag marker strings are not considered as part of the printing material that drives line splitting (in other words, the length of the strings corresponding to tag markers is considered as zero for line splitting).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bf3db7f530d816adacc226db72ff8b952d7e77" translate="yes" xml:space="preserve">
          <source>Between subexpressions of a sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01187252d64e42965e1df4b1a6807e200efab0e" translate="yes" xml:space="preserve">
          <source>Between the header and the entry points, one can give names to frequently-occurring regular expressions. This is written let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;. In regular expressions that follow this declaration, the identifier ident can be used as shorthand for regexp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0762b857edb23abb186d37a5e2a1cf9b1db82d70" translate="yes" xml:space="preserve">
          <source>Beware also that some idioms make trivial errors very hard to find. For instance, the following code is probably wrong but the compiler has no way to see it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96e5378f7f04072916e26ed0422a2ca7fee4ed6" translate="yes" xml:space="preserve">
          <source>Beware of the small syntactic difference between a type constraint on the last parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0863d7cb6a04fad42cda06f67cbcf747fb4740c8" translate="yes" xml:space="preserve">
          <source>Beware that channels are buffered so more characters may have been read from the file descriptor than those accessed using channel functions. Channels also keep a copy of the current position in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7e376571acd2b703f175df9ba62834f1210318" translate="yes" xml:space="preserve">
          <source>Beware that channels are buffered so you may have to &lt;code&gt;flush&lt;/code&gt; them to ensure that all data has been sent to the file descriptor. Channels also keep a copy of the current position in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbdc1b64ef7dc2e9165f4238a760cb0019a726a" translate="yes" xml:space="preserve">
          <source>Beware that this extension is not available inside class definitions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c29307b11084a93c6603a32d5d737b8390831ae" translate="yes" xml:space="preserve">
          <source>Beware that this last resort disambiguation is local: once Ocaml has chosen a disambiguation, it sticks to this choice, even if it leads to an ulterior type error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b2a8eecc3712331ab94305233f63d504f21583" translate="yes" xml:space="preserve">
          <source>Bigarray</source>
          <target state="translated">Bigarray</target>
        </trans-unit>
        <trans-unit id="7380a093245acf7191eec9ec92e09a46e18e884e" translate="yes" xml:space="preserve">
          <source>Bigarray.Array1.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4836645873279d91f4ef6d2469cebce7bf5a1513" translate="yes" xml:space="preserve">
          <source>Bigarray.Array1.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294760cd59cde90db4052169e314f7fd0306af03" translate="yes" xml:space="preserve">
          <source>Bigarray.Array2.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8ad3137dd1b9a26a9779ee12d030fac6493896" translate="yes" xml:space="preserve">
          <source>Bigarray.Array2.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99bb9e3898bd689c37ba94b52b1bc73b90a6f4ab" translate="yes" xml:space="preserve">
          <source>Bigarray.Array3.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4b044934c55212e0d48ca2144367b12b0b6cdc" translate="yes" xml:space="preserve">
          <source>Bigarray.Array3.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfde812cd151ad76b57b0ef94c12067805e1b7a8" translate="yes" xml:space="preserve">
          <source>Bigarray.Genarray.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5eae93e4a3f09b82ba2713ee1b9fab39405ccae" translate="yes" xml:space="preserve">
          <source>Bigarray.Genarray.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164b37e902bccec375adcec6ac207f8d8528851b" translate="yes" xml:space="preserve">
          <source>Bigarrays are multi-dimensional. Any number of dimensions between 0 and 16 is supported. In contrast, OCaml arrays are mono-dimensional and require encoding multi-dimensional arrays as arrays of arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b10643bcaf2c18dffa1745f8ce67e9efe32a9b7" translate="yes" xml:space="preserve">
          <source>Bigarrays are not limited in size, unlike OCaml arrays. (Normal float arrays are limited to 2,097,151 elements on a 32-bit platform, and normal arrays of other types to 4,194,303 elements.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c068760255c39d7cfb8804626af3c6a04134aa" translate="yes" xml:space="preserve">
          <source>Bigarrays can contain elements of the following kinds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06bbb03d095ef0403ef39ce3bec731f64c4edc60" translate="yes" xml:space="preserve">
          <source>Bigarrays can only contain integers and floating-point numbers, while OCaml arrays can contain arbitrary OCaml data types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde73a8c5eb1bd7ebbe27f805e2f18a62417b5de" translate="yes" xml:space="preserve">
          <source>Bigarrays provide more space-efficient storage of integer and floating-point elements than normal OCaml arrays, in particular because they support 'small' types such as single-precision floats and 8 and 16-bit integers, in addition to the standard OCaml types of double-precision floats and 32 and 64-bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b30eba7780f6a33ce03c9072c579c3a782adda9" translate="yes" xml:space="preserve">
          <source>Bigarrays returned by &lt;code&gt;Genarray.create&lt;/code&gt; are not initialized: the initial values of array elements is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062335b880b9c90adbbcca33a681878e4c2f925f" translate="yes" xml:space="preserve">
          <source>Bigarrays support all the OCaml ad-hoc polymorphic operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78c464588eab46be79b11f66000060a0a82592e" translate="yes" xml:space="preserve">
          <source>Bigarrays support interesting high-level operations that normal arrays do not provide efficiently, such as extracting sub-arrays and 'slicing' a multi-dimensional array along certain dimensions, all without any copying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7ba9c56ac265afa1c83c3f5860425f6f8d05c6" translate="yes" xml:space="preserve">
          <source>Binary encoding of integers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb694c389c0cdbf75c25a19ef2b17058523cf0a" translate="yes" xml:space="preserve">
          <source>Binary encoding/decoding of integers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67c6977825a3171348c86b630d52532cd50075d" translate="yes" xml:space="preserve">
          <source>Bind a socket to an address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d545537631f4daa805af6977069a1ae659ac89fa" translate="yes" xml:space="preserve">
          <source>Bind the substring matched by &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; to identifier &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98010387d59d504f717882ee0e29ce9561ef02f7" translate="yes" xml:space="preserve">
          <source>Bitwise arithmetic shift right on integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad662d09220d0d46d46b6bfecb1798cd38adcc0" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;and&amp;rdquo; on integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49aac382b8e35200a9044197b1ea4c4df4708643" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;exclusive or&amp;rdquo; on integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286b2e0f11888729ecb5275bfd01f89e609e86af" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;or&amp;rdquo; on integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f47fa82a9e81696cb44cafa1b49f3b15a8d783" translate="yes" xml:space="preserve">
          <source>Bitwise logical and.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8120788c98e6228e8b9d7bcf0ec24a6003d5162" translate="yes" xml:space="preserve">
          <source>Bitwise logical and. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12d57bf21bac825baf9ff63c9856f69ab644445" translate="yes" xml:space="preserve">
          <source>Bitwise logical exclusive or.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b30b925799da28ec0ac76d3e01a3f81148da08" translate="yes" xml:space="preserve">
          <source>Bitwise logical exclusive or. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e959911aefbddc80325181098fb38e48a8332ea" translate="yes" xml:space="preserve">
          <source>Bitwise logical negation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b2038f4572ce60bed7fe655e3af57ae6849b39" translate="yes" xml:space="preserve">
          <source>Bitwise logical or.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f0ebc0438d2a8b3f7d8ab17a47e2fc7e9a6733" translate="yes" xml:space="preserve">
          <source>Bitwise logical or. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e629b6c338431a80d282be3b9738ea06d447a3" translate="yes" xml:space="preserve">
          <source>Bitwise logical shift left on integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1d051215d4090b7e416aa0c5b96654c34c3df3" translate="yes" xml:space="preserve">
          <source>Bitwise logical shift right on integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67445a8812f7cd259e3b6e21272d2fddff30a9e2" translate="yes" xml:space="preserve">
          <source>Bitwise operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f8396020dfba14aa5dc6b1bd83f4647bd8ef67" translate="yes" xml:space="preserve">
          <source>Block device</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44f089c39b56e3f8dc6fad275cc2d75db99650b" translate="yes" xml:space="preserve">
          <source>Block with size = 2 and tag = 0; first field contains h, second field t.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d4367bfac6247903d75f1f870462ae73cd80c5" translate="yes" xml:space="preserve">
          <source>Blocks in the heap are garbage-collected, and therefore have strict structure constraints. Each block includes a header containing the size of the block (in words), and the tag of the block. The tag governs how the contents of the blocks are structured. A tag lower than No_scan_tag indicates a structured block, containing well-formed values, which is recursively traversed by the garbage collector. A tag greater than or equal to No_scan_tag indicates a raw block, whose contents are not scanned by the garbage collector. For the benefit of ad-hoc polymorphic primitives such as equality and structured input-output, structured and raw blocks are further classified according to their tags as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52377d4f36f405cfd1e7a45f168ae549d215d39" translate="yes" xml:space="preserve">
          <source>Blocks with tag Custom_tag contain both arbitrary user data and a pointer to a C struct, with type struct custom_operations, that associates user-provided finalization, comparison, hashing, serialization and deserialization functions to this block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c46ad79d1dd84b74158fed8d17c80696f45ae5" translate="yes" xml:space="preserve">
          <source>Blocks with tag Custom_tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12647fc73d7d1c9966497cc2c05ac43b902e3a4" translate="yes" xml:space="preserve">
          <source>Blocks with tag Double_tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7474968263988ef1fdd02a5d43ba5d0ef74d1f29" translate="yes" xml:space="preserve">
          <source>Blocks with tag String_tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf760a167a8047cee872015a8e80002f3b67442" translate="yes" xml:space="preserve">
          <source>Bool</source>
          <target state="translated">Bool</target>
        </trans-unit>
        <trans-unit id="72c318f119ab639d07f13e4bb5d9f5319d190b18" translate="yes" xml:space="preserve">
          <source>Bool_val(v) returns 0 if v is the OCaml boolean false, 1 if v is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec6611901208bd78d162029849792816f5b2deb" translate="yes" xml:space="preserve">
          <source>Boolean conjunction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfcfb577d5e30b5e6899078780ad10f83147239" translate="yes" xml:space="preserve">
          <source>Boolean disjunction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e29add877007424818746892be55cde474c75bba" translate="yes" xml:space="preserve">
          <source>Boolean values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="e117da47e3d7be3e9e0a3f82f9b8350253013973" translate="yes" xml:space="preserve">
          <source>Bound on floating garbage for out-of-heap memory held by custom values in the minor heap. A minor GC is triggered when this much memory is held by custom values located in the minor heap. Expressed as a percentage of minor heap size. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b716c0794dbc0057215ee2f154e80bba251c2e" translate="yes" xml:space="preserve">
          <source>Break hints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310549596be621bab70cac3b1e9df753e4f4a81d" translate="yes" xml:space="preserve">
          <source>Break hints are used to separate printing items and are mandatory to let the pretty-printer correctly split lines and indent items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82e2d18efe99fcf7dc512f1f1e8d815a8811ce1" translate="yes" xml:space="preserve">
          <source>Break hints in a horizontal box never split the line. (Line splitting may still occur inside boxes nested deeper).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dfd8323fd5e72ce649953eb9bbb100abdbf328" translate="yes" xml:space="preserve">
          <source>Broken pipe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="a22edc1d8185e0421ca424eaf16cf9e2dafd3a13" translate="yes" xml:space="preserve">
          <source>Build a bytecode object file (.cmo file) and its associated compiled interface (.cmi) that combines the object files given on the command line, making them appear as sub-modules of the output .cmo file. The name of the output .cmo file must be given with the -o option. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c491ef5b62f19f72f7c09ad96021606366a71f4" translate="yes" xml:space="preserve">
          <source>Build a custom runtime system (in the file specified by option -o) incorporating the C object files and libraries given on the command line. This custom runtime system can be used later to execute bytecode executables produced with the ocamlc -use-runtimeruntime-name option. See section &lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689a03030d28c2fe2318c8c8f9722c5b8054bdb7" translate="yes" xml:space="preserve">
          <source>Build a library(.cma file) with the object files ( .cmo files) given on the command line, instead of linking them into an executable file. The name of the library must be set with the -o option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c6d896e003bfea1990e747dab4717403d4a43c" translate="yes" xml:space="preserve">
          <source>Build a library(.cmxa and .a/.lib files) with the object files (.cmx and .o/.obj files) given on the command line, instead of linking them into an executable file. The name of the library must be set with the -o option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fc2d180dacf6e6dc88e07dfb99b1916ef75f25" translate="yes" xml:space="preserve">
          <source>Build a map from the given bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7291990c98b91f383cf392959b02f1108bd054ae" translate="yes" xml:space="preserve">
          <source>Build a one-dimensional Bigarray initialized from the given array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cd8e2d3ddf697fe8d31528763b8007962db336" translate="yes" xml:space="preserve">
          <source>Build a plugin (usually .cmxs) that can be dynamically loaded with the Dynlink module. The name of the plugin must be set with the -o option. A plugin can include a number of OCaml modules and libraries, and extra native objects (.o, .obj, .a, .lib files). Building native plugins is only supported for some operating system. Under some systems (currently, only Linux AMD 64), all the OCaml code linked in a plugin must have been compiled without the -nodynlink flag. Some constraints might also apply to the way the extra native objects have been compiled (under Linux AMD 64, they must contain only position-independent code).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069a1c0c668653aee76345e068c67b55843bbe6f" translate="yes" xml:space="preserve">
          <source>Build a self-contained executable by linking a C object file containing the bytecode program, the OCaml runtime system and any other static C code given to ocamlc. The resulting effect is similar to -custom, except that the bytecode is embedded in the C code so it is no longer accessible to tools such as ocamldebug. On the other hand, the resulting binary is resistant to strip.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12091461d26b4a9178ef9b7fb79d4ea74a7322de" translate="yes" xml:space="preserve">
          <source>Build a sequence from a step function and an initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89302c14cbe821b3cc65efb42319c0731273420e" translate="yes" xml:space="preserve">
          <source>Build a sequence from a step function and an initial value. &lt;code&gt;unfold&amp;nbsp;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;empty&lt;/code&gt; if &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, or &lt;code&gt;fun&amp;nbsp;()&amp;nbsp;-&amp;gt;&amp;nbsp;Cons&amp;nbsp;(x,&amp;nbsp;unfold&amp;nbsp;f&amp;nbsp;y)&lt;/code&gt; if &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;Some&amp;nbsp;(x,&amp;nbsp;y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f99ba2c885b0621a0361f7903d103f89a1bcdc" translate="yes" xml:space="preserve">
          <source>Build a set from the given bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7703cf54010e3d2a2a46e2aa34796e3417727340" translate="yes" xml:space="preserve">
          <source>Build a table from the given bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed507cdc786047af911f4641801d1284f48b787" translate="yes" xml:space="preserve">
          <source>Build a table from the given bindings. The bindings are added in the same order they appear in the sequence, using &lt;a href=&quot;hashtbl#VALreplace_seq&quot;&gt;&lt;code&gt;Hashtbl.replace_seq&lt;/code&gt;&lt;/a&gt;, which means that if two pairs have the same key, only the latest one will appear in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef17975a5143add151e0e399318d7995c25ed2ae" translate="yes" xml:space="preserve">
          <source>Build a three-dimensional Bigarray initialized from the given array of arrays of arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21da3902ed80a10d9124a19e5502821d530b38d" translate="yes" xml:space="preserve">
          <source>Build a two-dimensional Bigarray initialized from the given array of arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0baba8d3207ccbde756c21e219772188993d76ba" translate="yes" xml:space="preserve">
          <source>Build a zero-dimensional Bigarray initialized from the given value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1263e4d5769f672b1f15f28232e6f937c00bc59" translate="yes" xml:space="preserve">
          <source>Build an object file (.cmx and .o/.obj files) and its associated compiled interface (.cmi) that combines the .cmx object files given on the command line, making them appear as sub-modules of the output .cmx file. The name of the output .cmx file must be given with the -o option. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2635951b3208897985aea8ec1147e0e9b763177" translate="yes" xml:space="preserve">
          <source>Builtins to reduce code size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6160c6225b900be02bb14ce176681dae0c8f8da" translate="yes" xml:space="preserve">
          <source>Bus error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6c2475ca710215707c319b5b130842b36b44da" translate="yes" xml:space="preserve">
          <source>But beware that functions like ListLabels.fold_left whose result type is a type variable will never be considered as totally applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d51ba5b49681459c1a354add2ac5d24ca30fd49" translate="yes" xml:space="preserve">
          <source>By applying the Set functor to a structure implementing an ordered type, we obtain set operations for this type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0113e077a12f76985e5f478d2a05438d5de8f770" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;parse&lt;/code&gt; recognizes two unit options, &lt;code&gt;-help&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt;, which will print to standard output &lt;code&gt;usage_msg&lt;/code&gt; and the list of options, and exit the program. You can override this behaviour by specifying your own &lt;code&gt;-help&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt; options in &lt;code&gt;speclist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b1de1205669f7876e1c1fd966de8ff32344e89" translate="yes" xml:space="preserve">
          <source>By default, when ocamllex reaches the end of its lexing buffer, it will silently call the refill_buff function of lexbuf structure and continue lexing. It is sometimes useful to be able to take control of refilling action; typically, if you use a library for asynchronous computation, you may want to wrap the refilling action in a delaying function to avoid blocking synchronous operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd008e3d3a06d94fef9fb0520a149f7342a3b92" translate="yes" xml:space="preserve">
          <source>By default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571d97b05671e800889e1f8be66af8e1839c41a3" translate="yes" xml:space="preserve">
          <source>By inspecting instrumentation output, the fuzzer finds the crashing input quickly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb1ab62b1d1a61cd2bf6abb826d55b2452baa20" translate="yes" xml:space="preserve">
          <source>Bypass the standard routing algorithms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a27c85cc78cf7082f8f4aa81367cc7aa73bbd6" translate="yes" xml:space="preserve">
          <source>Byte sequence operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3dcbe0c430e581c3ba7ac724f0f6e253c1162e" translate="yes" xml:space="preserve">
          <source>Byte sequences can be modified in place, for instance via the &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;blit&lt;/code&gt; functions described below. See also strings (module &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;), which are almost the same data structure, but cannot be modified in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb4a16c1c179874a37042f14ee4006ef6638ed6" translate="yes" xml:space="preserve">
          <source>Byte(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; byte of the string or byte sequence v, with type char. Bytes are numbered from 0 to string_length(v)&amp;minus;1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56c24ce60fe3442e00e45a21c6a40ce9981947b" translate="yes" xml:space="preserve">
          <source>Byte_u(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; byte of the string or byte sequence v, with type unsigned char. Bytes are numbered from 0 to string_length(v)&amp;minus;1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="ee4b734d209787513981ac3c4587edcc9fd97576" translate="yes" xml:space="preserve">
          <source>Bytes are represented by the OCaml type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f1a4abc7d926b88b0ebb920ad333dc56ea8d84" translate="yes" xml:space="preserve">
          <source>BytesLabels</source>
          <target state="translated">BytesLabels</target>
        </trans-unit>
        <trans-unit id="f88d6f50d25613e6ba9716a6ec32d0fac19418c8" translate="yes" xml:space="preserve">
          <source>Bytes_val(v) returns a pointer to the first byte of the byte sequence v, with type unsigned char *.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="5cdbd402c1d7266786e985245bde0656f198525c" translate="yes" xml:space="preserve">
          <source>C expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e4b97f10fef4bff0c780402b8dd25cf8309940" translate="yes" xml:space="preserve">
          <source>C functions can apply OCaml function values (closures) to OCaml values. The following functions are provided to perform the applications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5854e4455891ebb06ded2070bbca910df9ff80" translate="yes" xml:space="preserve">
          <source>C object files (.o, .a, respectively, .obj, .lib) comprising the C part of the library;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2691a3da47675d7786da9056ed654e4329e370" translate="yes" xml:space="preserve">
          <source>C-c &amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5895e3b6464a2f42c548ae3a42edfd0331e5913" translate="yes" xml:space="preserve">
          <source>C-c &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d94b505b28b164240bf9389a0b04f654a4efe7" translate="yes" xml:space="preserve">
          <source>C-c C-d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b336d22bd8ba7c961026c225d6dae53a99180fe" translate="yes" xml:space="preserve">
          <source>C-c C-f</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e157811222162c64e14516608ab7ec113770f6cc" translate="yes" xml:space="preserve">
          <source>C-c C-k</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35aab979b96b2084fb79f26513be2807d179fa9d" translate="yes" xml:space="preserve">
          <source>C-c C-l</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703476705fbc5c81f1fcd2e97899e90376b8bb77" translate="yes" xml:space="preserve">
          <source>C-c C-n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b8a659d5ecf6f6de2e42c686ddf4655002e381" translate="yes" xml:space="preserve">
          <source>C-c C-p</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a5eefc071272ad5677c99c4db64e5fe4dc5d2d" translate="yes" xml:space="preserve">
          <source>C-c C-r</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d45f9433ffa51171e234792f3e833fd92a28ea" translate="yes" xml:space="preserve">
          <source>C-c C-s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7afd726a50bc021ba933c58863ceeb5085e993" translate="yes" xml:space="preserve">
          <source>C-c C-t</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f8ced1b6f72805535bc35bcfb934e6a1af5d91" translate="yes" xml:space="preserve">
          <source>C-c C-v</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7600b59263607e2e35bc0920247fd20391c74a2" translate="yes" xml:space="preserve">
          <source>C-x C-a C-b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5cfbe7597b16e6935dc781b66c74990211b37b" translate="yes" xml:space="preserve">
          <source>C-x C-a C-d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb356c30fbc883e430534abb90e0f8ff779ffa95" translate="yes" xml:space="preserve">
          <source>C-x C-a C-p</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0428d8d3b172e413bd41a84ee63c3aa76341d6f4" translate="yes" xml:space="preserve">
          <source>CAMLRUNPARAM</source>
          <target state="translated">CAMLRUNPARAM</target>
        </trans-unit>
        <trans-unit id="06ef60af17229bb84ed6cf51b34ad6a256455e79" translate="yes" xml:space="preserve">
          <source>CAML_BA_CAML_INT</source>
          <target state="translated">CAML_BA_CAML_INT</target>
        </trans-unit>
        <trans-unit id="29bf970ee1f3dcd0c4d491bf35cc1f3f5d511fb6" translate="yes" xml:space="preserve">
          <source>CAML_BA_FLOAT32</source>
          <target state="translated">CAML_BA_FLOAT32</target>
        </trans-unit>
        <trans-unit id="b0b45028fc165a76fdf7ef3c4b9544abf779f48e" translate="yes" xml:space="preserve">
          <source>CAML_BA_FLOAT64</source>
          <target state="translated">CAML_BA_FLOAT64</target>
        </trans-unit>
        <trans-unit id="c0a392f0c20d6938ed691222ff33a9ed03be26ee" translate="yes" xml:space="preserve">
          <source>CAML_BA_INT32</source>
          <target state="translated">CAML_BA_INT32</target>
        </trans-unit>
        <trans-unit id="28d3388f7484b35006ab4e33d099e8b1394d2ada" translate="yes" xml:space="preserve">
          <source>CAML_BA_INT64</source>
          <target state="translated">CAML_BA_INT64</target>
        </trans-unit>
        <trans-unit id="4ae0dcc3f1cb59220d53e50caf55af1eec638efe" translate="yes" xml:space="preserve">
          <source>CAML_BA_NATIVE_INT</source>
          <target state="translated">CAML_BA_NATIVE_INT</target>
        </trans-unit>
        <trans-unit id="12d8a9c4f45f9611251c206d7770c086b489bd77" translate="yes" xml:space="preserve">
          <source>CAML_BA_SINT16</source>
          <target state="translated">CAML_BA_SINT16</target>
        </trans-unit>
        <trans-unit id="4f8b28cf737d73c2546166e229b3ed6d00a4ec46" translate="yes" xml:space="preserve">
          <source>CAML_BA_SINT8</source>
          <target state="translated">CAML_BA_SINT8</target>
        </trans-unit>
        <trans-unit id="42c72be3c2d002cde18ad0cc888645508241b618" translate="yes" xml:space="preserve">
          <source>CAML_BA_UINT16</source>
          <target state="translated">CAML_BA_UINT16</target>
        </trans-unit>
        <trans-unit id="0b4fdfc80a15bdaea2467c74579a11c08063d303" translate="yes" xml:space="preserve">
          <source>CAML_BA_UINT8</source>
          <target state="translated">CAML_BA_UINT8</target>
        </trans-unit>
        <trans-unit id="862e38c8fdffac6697987f398fd840cb4757c5c6" translate="yes" xml:space="preserve">
          <source>CAML_LD_LIBRARY_PATH</source>
          <target state="translated">CAML_LD_LIBRARY_PATH</target>
        </trans-unit>
        <trans-unit id="1efcd7218656916b1a34ec7ace30f76879ccc769" translate="yes" xml:space="preserve">
          <source>Call site</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="439ff774888e42456ac505657951f952d4018c9c" translate="yes" xml:space="preserve">
          <source>Call the function with a bool argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54d32e84799e629832cc3cf6d3d70a7415a5e3d" translate="yes" xml:space="preserve">
          <source>Call the function with a float argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1194b8c4e54a903611beb2fc6666d747a1e0e365" translate="yes" xml:space="preserve">
          <source>Call the function with a string argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1362db1cb4c46430a08897ce0bd10b0e6ea8a20d" translate="yes" xml:space="preserve">
          <source>Call the function with an int argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b1b5aaabaa5c8dc3fa786515c78609ee362d34" translate="yes" xml:space="preserve">
          <source>Call the function with unit argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="5e3acd60f1a3a903622de6021e3383b98e3f2383" translate="yes" xml:space="preserve">
          <source>Callbacks from C to OCaml are possible only if the calling thread is known to the OCaml run-time system. Threads created from OCaml (through the Thread.create function of the system threads library) are automatically known to the run-time system. If the application creates additional threads from C and wishes to callback into OCaml code from these threads, it must first register them with the run-time system. The following functions are declared in the include file &amp;lt;caml/threads.h&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6bc26cd9de8a0ee5e063309082a78314bbdfd7" translate="yes" xml:space="preserve">
          <source>Callbacks from C to OCaml must be performed while holding the master lock to the OCaml run-time system. This is naturally the case if the callback is performed by a C primitive that did not release the run-time system. If the C primitive released the run-time system previously, or the callback is performed from other C code that was not invoked from OCaml (e.g. an event loop in a GUI application), the run-time system must be acquired before the callback and released after:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f420b0e05a7d24397a2c4cbac41b11132d82dc0" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;Thread.exit&lt;/code&gt; in a callback is currently unsafe and can result in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8b6fad857d73ca89a28b745d68e7d25285cbc2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;stop&lt;/code&gt; when a callback is running can lead to callbacks not being called even though some events happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d0bd91811ae57feae3dc49557f93b46fb40091" translate="yes" xml:space="preserve">
          <source>Calling ocamlcp or ocamloptp without the -P option defaults to -P fm, meaning that only function calls and pattern matching are profiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76f4f235bcaa15b4e9e55e904d12a0353c6937f" translate="yes" xml:space="preserve">
          <source>Calling of finalization functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320ce4f3dd86e7b41979fa738908cf8ebc9f4093" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;dim[i]</source>
          <target state="translated">Caml_ba_array_val(v)-&amp;gt;dim[i]</target>
        </trans-unit>
        <trans-unit id="4965db9dfe36a2388ff16d79621b65a90fdc3268" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;flags &amp;amp; BIGARRAY_KIND_MASK</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8153f9a1f29a01a8d1e13a9a8facbe074e41d60" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;num_dims</source>
          <target state="translated">Caml_ba_array_val(v)-&amp;gt;num_dims</target>
        </trans-unit>
        <trans-unit id="b0826ae23f5c2aa6ec97d420d36156941be754c2" translate="yes" xml:space="preserve">
          <source>CamlinternalFormat</source>
          <target state="translated">CamlinternalFormat</target>
        </trans-unit>
        <trans-unit id="bb3e916c18c2e6c422542bf46f49c0d62f6e3c8f" translate="yes" xml:space="preserve">
          <source>CamlinternalFormatBasics</source>
          <target state="translated">CamlinternalFormatBasics</target>
        </trans-unit>
        <trans-unit id="481a5bc3eb5c42fe3b8d720d5e80798ff2509a6f" translate="yes" xml:space="preserve">
          <source>CamlinternalLazy</source>
          <target state="translated">CamlinternalLazy</target>
        </trans-unit>
        <trans-unit id="c3c09679073e3d5fb5469d0ee68e0dda2efb23c6" translate="yes" xml:space="preserve">
          <source>CamlinternalMod</source>
          <target state="translated">CamlinternalMod</target>
        </trans-unit>
        <trans-unit id="de3a6cdf4fe88074a43fdcad59d0f8af4cd7f6fd" translate="yes" xml:space="preserve">
          <source>CamlinternalOO</source>
          <target state="translated">CamlinternalOO</target>
        </trans-unit>
        <trans-unit id="d4281385821580139685e13cccf01eef5faad5fd" translate="yes" xml:space="preserve">
          <source>Can't assign requested address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b11fa6f27d953791f239e466488fe3cc3dab71f" translate="yes" xml:space="preserve">
          <source>Can't send after socket shutdown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa179cda87a1dfd4a3c00c1a3a16ee3fa6ec361b" translate="yes" xml:space="preserve">
          <source>Cannot exec ocamlrun</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76131d25b0f2f61dc3ec32dd51584863650417b" translate="yes" xml:space="preserve">
          <source>Cannot find file filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e970cebe7ef506f91128a59d1bb09ee8b8b3c86" translate="yes" xml:space="preserve">
          <source>Cannot find the bytecode file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20838d73bbc97dc3bb06bd228fc74b46a7848212" translate="yes" xml:space="preserve">
          <source>Canonical host name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2176321ef1668ac2925aa2334216301b069265ea" translate="yes" xml:space="preserve">
          <source>Case of first letter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152c573fc4d3829f2755ceb071de4e226c7a2b55" translate="yes" xml:space="preserve">
          <source>Cases with such a toplevel pattern are called &amp;ldquo;exception cases&amp;rdquo;, as opposed to regular &amp;ldquo;value cases&amp;rdquo;. Exception cases are applied when the evaluation of the matched expression raises an exception. The exception value is then matched against all the exception cases and re-raised if none of them accept the exception (as with a try...with block). Since the bodies of all exception and value cases are outside the scope of the exception handler, they are all considered to be in tail-position: if the match...with block itself is in tail position in the current function, any function call in tail position in one of the case bodies results in an actual tail call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7bfa68b59ae09ff7937d27d80909654e0911df3" translate="yes" xml:space="preserve">
          <source>Catenate two lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6d1257bb5471d1a26f3650edf26a9b7ce4748e" translate="yes" xml:space="preserve">
          <source>Catenate two lists. Same function as the infix operator &lt;code&gt;@&lt;/code&gt;. Not tail-recursive (length of the first argument). The &lt;code&gt;@&lt;/code&gt; operator is not tail-recursive either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3927eac7c0bbd9cb2a05b8b9b1bc048f32eed24a" translate="yes" xml:space="preserve">
          <source>Cause ocamldep to call the given command as a preprocessor for each source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d65060239114c8da1c3ee5f06497c9c0388478" translate="yes" xml:space="preserve">
          <source>Cause the compiler to call the given command as a preprocessor for each source file. The output of command is redirected to an intermediate file, which is compiled. If there are no compilation errors, the intermediate file is deleted afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ad0bc61108fd0f03730d7b8c62d48c4504661e" translate="yes" xml:space="preserve">
          <source>Cause the compiler to print all defined names (with their inferred types or their definitions) when compiling an implementation (.ml file). No compiled files (.cmo and .cmi files) are produced. This can be useful to check the types inferred by the compiler. Also, since the output follows the syntax of interfaces, it can help in writing an explicit interface (.mli file) for a file: just redirect the standard output of the compiler to a .mli file, and edit that file to remove all declarations of unexported names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e7e3cc29834386322cdfd94e38c57364643191" translate="yes" xml:space="preserve">
          <source>Cause the linker to produce a C object file instead of a bytecode executable file. This is useful to wrap OCaml code as a C library, callable from any C program. See chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, section &lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt;. The name of the output object file must be set with the -o option. This option can also be used to produce a C source file (.c extension) or a compiled shared/dynamic library (.so extension, .dll under Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2d52792e36f929afa45992d5b9371329947d44" translate="yes" xml:space="preserve">
          <source>Cause the linker to produce a C object file instead of an executable file. This is useful to wrap OCaml code as a C library, callable from any C program. See chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, section &lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt;. The name of the output object file must be set with the -o option. This option can also be used to produce a compiled shared/dynamic library (.so extension, .dll under Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b850e3fb0d5b46820871c2935dfe3766bdbb938d" translate="yes" xml:space="preserve">
          <source>Change of GC parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ddb2f3053e5e3a61aa51801cc581d3f377f0ca" translate="yes" xml:space="preserve">
          <source>Change the current working directory of the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a59a356a5fb89b1c7225a986140a24f071468d3" translate="yes" xml:space="preserve">
          <source>Change the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc8ee486e678a2b93da90c36026c5c882c13c46" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of an opened file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff1b3a39f21500ee841c3b355ca9394dab29e7f" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of an opened file. On Windows: not implemented (make no sense on a DOS file system).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6826ef95971c6bcc713d9272d2f3957ce4e077" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff00fe5b2a8e18dd9ab37b5013d51ebb074f663" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of the named file. On Windows: not implemented (make no sense on a DOS file system).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed0198ddea8ebff0f55e60936d9d3744ed76277" translate="yes" xml:space="preserve">
          <source>Change the permissions of an opened file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2f04cee52320988b31c4157241e0ae0e8b9395" translate="yes" xml:space="preserve">
          <source>Change the permissions of an opened file. On Windows: not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfd116dac46b84058c527a10dea8d7eb9d90f28" translate="yes" xml:space="preserve">
          <source>Change the permissions of the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059df7ed36823c0a5f15c733d667630994b09dfc" translate="yes" xml:space="preserve">
          <source>Change the process priority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af895b8fed10993d46dc76e555515a59117c378" translate="yes" xml:space="preserve">
          <source>Change the process priority. The integer argument is added to the ``nice'' value. (Higher values of the ``nice'' value mean lower priorities.) Return the new nice value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525fb07cd9a161e6eede24edf36a6f523c0304e8" translate="yes" xml:space="preserve">
          <source>Change the process root directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7679db58768be2f4e8b5dcad79023cb2410bef" translate="yes" xml:space="preserve">
          <source>Change the process root directory. On Windows: not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22f0bfd902da519c120d02a47bbc28f988fe88b" translate="yes" xml:space="preserve">
          <source>Change the process working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6247262a4ca64128524a7b46fe29e0adce2d3a4" translate="yes" xml:space="preserve">
          <source>Change the temporary directory returned by &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt;&lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt;&lt;/a&gt; and used by &lt;a href=&quot;filename#VALtemp_file&quot;&gt;&lt;code&gt;Filename.temp_file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;filename#VALopen_temp_file&quot;&gt;&lt;code&gt;Filename.open_temp_file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed43f5a28f32e3c670541a45ef01f44121648f3" translate="yes" xml:space="preserve">
          <source>Chapter 1 The core language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b85dee7429fe72c76a05950f827ee16db3524d" translate="yes" xml:space="preserve">
          <source>Chapter 10 The toplevel system or REPL (ocaml)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001839bacc443f251cfd2c927f4f6758c410072e" translate="yes" xml:space="preserve">
          <source>Chapter 11 The runtime system (ocamlrun)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410707e0a197616d24db0cf28623150b0fd9bbf1" translate="yes" xml:space="preserve">
          <source>Chapter 12 Native-code compilation (ocamlopt)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6c191b9a4d617a739da661e8ae774b6ea4bf3b" translate="yes" xml:space="preserve">
          <source>Chapter 13 Lexer and parser generators (ocamllex, ocamlyacc)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43aac2b85afd5512793e5351074e2a49b841dd1f" translate="yes" xml:space="preserve">
          <source>Chapter 14 Dependency generator (ocamldep)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3749109d031480d3bd81dbe0edd1a4e6240de1d" translate="yes" xml:space="preserve">
          <source>Chapter 15 The browser/editor (ocamlbrowser)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a554141c94c8a595a0ef2d51b365bc92da3410" translate="yes" xml:space="preserve">
          <source>Chapter 16 The documentation generator (ocamldoc)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="795917bcc2fe3d841a2020a62bda17476ffc5bab" translate="yes" xml:space="preserve">
          <source>Chapter 17 The debugger (ocamldebug)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9798fdf8ebfc25a72ac812bc7bebb20f7bb87cf3" translate="yes" xml:space="preserve">
          <source>Chapter 18 Profiling (ocamlprof)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5bc6351790005d4d54dd018de1ed7222e66ff92" translate="yes" xml:space="preserve">
          <source>Chapter 19 The ocamlbuild compilation manager</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c269d97f2761aea9b7eaea373eec2819293a83aa" translate="yes" xml:space="preserve">
          <source>Chapter 2 The module system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de06f01aba4e638c618d8a261f9859d128cb1e0d" translate="yes" xml:space="preserve">
          <source>Chapter 20 Interfacing C with OCaml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076a91db60f3e8f0cac45b804159393c0f3106d6" translate="yes" xml:space="preserve">
          <source>Chapter 21 Optimisation with Flambda</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15de4a495e291c78283893fc4e762621d85a00d" translate="yes" xml:space="preserve">
          <source>Chapter 22 Memory profiling with Spacetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cd41c063dcd4b4438b8dbdb483110eb38bd31d" translate="yes" xml:space="preserve">
          <source>Chapter 23 Fuzzing with afl-fuzz</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a791f8f6f8c0d8a4ad00bed731a1667316e104" translate="yes" xml:space="preserve">
          <source>Chapter 24 Runtime tracing with the instrumented runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5072f88a3e588aa13c91fd059d66f2d6f5ab85" translate="yes" xml:space="preserve">
          <source>Chapter 25 The core library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1e656bf488be3aeb94f939e1a3a6ce5c39307f" translate="yes" xml:space="preserve">
          <source>Chapter 26 The standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b882a43356571b7b90c97eef6ad2c38753586fc" translate="yes" xml:space="preserve">
          <source>Chapter 27 The compiler front-end</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9b946afe127a69a4a6fd1e867c3901de646cce" translate="yes" xml:space="preserve">
          <source>Chapter 28 The unix library: Unix system calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e77b1c65a3b715d2db33e651d357a448b28637" translate="yes" xml:space="preserve">
          <source>Chapter 29 The num library: arbitrary-precision rational arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e30811f338538f3c0d38f9d6d42248053bfbe1d" translate="yes" xml:space="preserve">
          <source>Chapter 3 Objects in OCaml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a3a02a9cae42ecda284ccbe84e3c4056117fcd" translate="yes" xml:space="preserve">
          <source>Chapter 30 The str library: regular expressions and string processing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa16c195ce280b138dd01abe2b38e59c60633da6" translate="yes" xml:space="preserve">
          <source>Chapter 31 The threads library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa73c279162cd152d0c19a54753ed4b092a6f44" translate="yes" xml:space="preserve">
          <source>Chapter 32 The graphics library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7273034c7b0640dc1b3db6600c2ce523db39d3c4" translate="yes" xml:space="preserve">
          <source>Chapter 33 The dynlink library: dynamic loading and linking of object files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45f56f7818d55915c239211feb596da3ef30b64" translate="yes" xml:space="preserve">
          <source>Chapter 34 The bigarray library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d169dd1a467fd491bd155eb638e1ccdc56f2688" translate="yes" xml:space="preserve">
          <source>Chapter 4 Labels and variants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47acd2509ab08220cd88716a4d5adad74e851efa" translate="yes" xml:space="preserve">
          <source>Chapter 5 Polymorphism and its limitations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea957655c2d829d612062883bdcdc3375bb972f9" translate="yes" xml:space="preserve">
          <source>Chapter 6 Advanced examples with classes and modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21be5d98e1e33b0bbdf4ea2e078c6d2b805d67b9" translate="yes" xml:space="preserve">
          <source>Chapter 7 The OCaml language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ab86a56b7497600bb8e714a88e9abef74c7fa3" translate="yes" xml:space="preserve">
          <source>Chapter 8 Language extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391b169f6153a4b9d3a6bcce4a613a60664189dd" translate="yes" xml:space="preserve">
          <source>Chapter 9 Batch compilation (ocamlc)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9ba953e35135a3f8ec268817cc92f2557202a9" translate="yes" xml:space="preserve">
          <source>Char</source>
          <target state="translated">Char</target>
        </trans-unit>
        <trans-unit id="b2f83f280f0ba4673ff9b860af0167edcb7dc5eb" translate="yes" xml:space="preserve">
          <source>Character denoted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11b0e685f81f6a610a7012ef3b9b40a0b7893d9" translate="yes" xml:space="preserve">
          <source>Character device</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cda61e490d068bb818a82546143deb1856eba54" translate="yes" xml:space="preserve">
          <source>Character literals are delimited by ' (single quote) characters. The two single quotes enclose either one character different from ' and \, or one of the escape sequences below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d160e081a31096ac20a234dcd5857d1dd2c533" translate="yes" xml:space="preserve">
          <source>Character operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed87e23d6eb7a0d480742eab3f278ad3edc9072" translate="yes" xml:space="preserve">
          <source>Character operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb3c3d69869dc4d46c112661656a874dc159d9e" translate="yes" xml:space="preserve">
          <source>Character values are represented as 8-bit integers between 0 and 255. Character codes between 0 and 127 are interpreted following the ASCII standard. The current implementation interprets character codes between 128 and 255 following the ISO 8859-1 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c6a1aad15eafbbc861ff217eae35aa29ad75f6" translate="yes" xml:space="preserve">
          <source>Check if the formatter geometry is valid: &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf0c2762d6bb5f500fd8d57ef70e961f0d11397" translate="yes" xml:space="preserve">
          <source>Check information path during type-checking, to make sure that all types are derived in a principal way. When using labelled arguments and/or polymorphic methods, this flag is required to ensure future versions of the compiler will be able to infer types correctly, even if internal algorithms change. All programs accepted in -principal mode are also accepted in the default mode with equivalent types, but different binary signatures, and this may slow down type checking; yet it is a good idea to use it once before publishing source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e981f123821139261d30477b7436fc5a55b64f1b" translate="yes" xml:space="preserve">
          <source>Check that the generated bytecode executable can run on 32-bit platforms and signal an error if it cannot. This is useful when compiling bytecode on a 64-bit machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605d9d3370c8fb91a9c430b3f8bc3429e0117aa7" translate="yes" xml:space="preserve">
          <source>Check that the process has the given permissions over the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83dfb869c6a27841e790ad08cb50f233ca1f4045" translate="yes" xml:space="preserve">
          <source>Check that the process has the given permissions over the named file. Raise &lt;code&gt;Unix_error&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6097bb19d940e5685334990aa89b56295b3b220" translate="yes" xml:space="preserve">
          <source>Child process terminated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceda17985ac6b3f5a4c93ac5d7c217a8d28d7bcb" translate="yes" xml:space="preserve">
          <source>Class application is denoted by juxtaposition of (possibly labeled) expressions. It denotes the class whose constructor is the first expression applied to the given arguments. The arguments are evaluated as for expression application, but the constructor itself will only be evaluated when objects are created. In particular, side-effects caused by the application of the constructor will only occur at object creation time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8876b2e72d29d328da5ecb8760743ad996296c94" translate="yes" xml:space="preserve">
          <source>Class expressions are the class-level equivalent of value expressions: they evaluate to classes, thus providing implementations for the specifications expressed in class types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108c4260793c1e17098c25078141189b9f80ad27" translate="yes" xml:space="preserve">
          <source>Class interfaces are inferred from class definitions. They may also be defined directly and used to restrict the type of a class. Like class declarations, they also define a new type abbreviation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c857b3c0f35a1cf445f8db99a25973f3c3b2e890" translate="yes" xml:space="preserve">
          <source>Class specifications are described more precisely in section &lt;a href=&quot;classes#ss%3Aclass-spec&quot;&gt;7.9.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cac64186cec5136028f17ddf4f650c957d03d5d" translate="yes" xml:space="preserve">
          <source>Class types are the class-level equivalent of type expressions: they specify the general shape and type properties of classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="47bea575c5d9baad367210dd15b04c4c182dce19" translate="yes" xml:space="preserve">
          <source>Classes are defined using a small language, similar to the module language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afd240a4acd3b80e8530e285fba9a2f238dc1dc" translate="yes" xml:space="preserve">
          <source>Classes window_observer and window_subject can still be extended by inheritance. For instance, one may enrich the subject with new behaviors and refine the behavior of the observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01eb9463326201b62bd18afc119f471a20a46d3" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc43d79488f3b27bccafdf17c420f0d747526c8" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a59376799f540da74c603bc50f48227a56704df" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor. See &lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt;&lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0843662a0ae553306f085b13e4737ae2561db27" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1c73dfdb7d3867700cd7ea86d4dd6c48d8ee02" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor. See &lt;a href=&quot;unix#VALset_nonblock&quot;&gt;&lt;code&gt;Unix.set_nonblock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ed5871b75d708804ee3f41ea756675082150ec" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor. See &lt;a href=&quot;unixlabels#VALset_nonblock&quot;&gt;&lt;code&gt;UnixLabels.set_nonblock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4c990b5652dae59a6be6a792769aef18fde455" translate="yes" xml:space="preserve">
          <source>Clear the close-on-exec flag. This is currently the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb21a46e06b56087078be6b4aff4ce68b24daea" translate="yes" xml:space="preserve">
          <source>Cloning and override have a non empty intersection. They are interchangeable when used within an object and without overriding any field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbe69f4a604ebda49f0c8e440a558ccd8966474" translate="yes" xml:space="preserve">
          <source>Cloning can also be used to provide facilities for saving and restoring the state of objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241b9beb2f7204a7ae1316941e73e2b9fa4afd0c" translate="yes" xml:space="preserve">
          <source>Close a directory descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd2c6b2e7b89772b6708c7aca8a6d5a888f5146" translate="yes" xml:space="preserve">
          <source>Close a file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab162827cb467aeef1cfdbabbced6f4ac7ae6731" translate="yes" xml:space="preserve">
          <source>Close both</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca279507e900048762edd58a735705649ef1441a" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process&quot;&gt;&lt;code&gt;Unix.open_process&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4ea9d16cdeb07884420e45a9b4a955b46da461" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_full&quot;&gt;&lt;code&gt;Unix.open_process_full&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5848e9973d58846ccebfcc487fe6068111200e" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7c2328f3cb9873b3f974f2c82eac788b54581c" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_out&quot;&gt;&lt;code&gt;Unix.open_process_out&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40dccb11bde36cc9d87578fff4b5574199a6f237" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process&quot;&gt;&lt;code&gt;UnixLabels.open_process&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104a97fe326dc92db83909431482619107f79d7f" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_full&quot;&gt;&lt;code&gt;UnixLabels.open_process_full&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2ac483e1e28bbc2dae7a1dcbdb428a53ea65db" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt;&lt;code&gt;UnixLabels.open_process_in&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987835cf216c09d3d3659c353042acf47eb82cb6" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt;&lt;code&gt;UnixLabels.open_process_out&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5708310a7ccde2ea99739644bf345de4466c25" translate="yes" xml:space="preserve">
          <source>Close for receiving</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805fb7fdd53fdd68744184a36444efa2cf87c672" translate="yes" xml:space="preserve">
          <source>Close for sending</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3f52183f139b54fa0f6f2fbb72a62dd79a1c1a" translate="yes" xml:space="preserve">
          <source>Close the given channel, flushing all buffered write operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f5ceda25cbace756e58b1de142e130a58c7a95" translate="yes" xml:space="preserve">
          <source>Close the given channel, flushing all buffered write operations. Output functions raise a &lt;code&gt;Sys_error&lt;/code&gt; exception when they are applied to a closed output channel, except &lt;code&gt;close_out&lt;/code&gt; and &lt;code&gt;flush&lt;/code&gt;, which do nothing when applied to an already closed channel. Note that &lt;code&gt;close_out&lt;/code&gt; may raise &lt;code&gt;Sys_error&lt;/code&gt; if the operating system signals an error when flushing or closing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5befc2f5b4184ff319029954a3ebf8773fc60aa3" translate="yes" xml:space="preserve">
          <source>Close the given channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855dc6dc2be39d04f3f61cd8c3fd1df32f67ae63" translate="yes" xml:space="preserve">
          <source>Close the given channel. Input functions raise a &lt;code&gt;Sys_error&lt;/code&gt; exception when they are applied to a closed input channel, except &lt;code&gt;close_in&lt;/code&gt;, which does nothing when applied to an already closed channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baa0ea016defeba1648df1c2d1bbcade0cfb062" translate="yes" xml:space="preserve">
          <source>Closed function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e571180f5e0fe0a1fdd6d813d79acaf0ccfafa6" translate="yes" xml:space="preserve">
          <source>Closes the &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; associated with the given &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b5986b3d61e6de67170fcc909df02aeafde6d5" translate="yes" xml:space="preserve">
          <source>Closes the most recently open pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca307b38101cc962b95e89e6fb0f008aaea2cbd9" translate="yes" xml:space="preserve">
          <source>Closes the most recently opened tabulation box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e5fec7b2f5ac26ce08ec9bc3f5ffc7a6bf53c7" translate="yes" xml:space="preserve">
          <source>Closing an account can be done with the following polymorphic function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e77ec95c5a92eb909c6ac217e1a65e9bf9d350" translate="yes" xml:space="preserve">
          <source>Closure</source>
          <target state="translated">Closure</target>
        </trans-unit>
        <trans-unit id="ab1d845e18aa99c6b3ee6f2e85015ce183551e94" translate="yes" xml:space="preserve">
          <source>Closure variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd8c868a0be56feb09ac75a044fb7f0ae532487" translate="yes" xml:space="preserve">
          <source>Closure_tag</source>
          <target state="translated">Closure_tag</target>
        </trans-unit>
        <trans-unit id="1ebf4e3e7bbb419f530260ca7275b893d6cbb63a" translate="yes" xml:space="preserve">
          <source>Code_val(v) returns the code part of the closure v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fcd900e853fff06e8f7a1bd2e3f903467af8dcd" translate="yes" xml:space="preserve">
          <source>Coercions between generic Bigarrays and fixed-dimension Bigarrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d11cb9b589ffcbe8510661b59242a872e6798ab" translate="yes" xml:space="preserve">
          <source>Collected metrics include time spent executing the &lt;em&gt;garbage collector&lt;/em&gt;. The overall execution time of individual pauses are measured down to the time spent in specific parts of the garbage collection. Insight is also given on memory allocation and motion by recording the size of allocated memory blocks, as well as value promotions from the &lt;em&gt;minor heap&lt;/em&gt; to the &lt;em&gt;major heap&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87dcdd72a40f6bb0a5079a52dd8623dedfe7f0f" translate="yes" xml:space="preserve">
          <source>Colorize the OCaml code enclosed in [ ] and {[ ]}, using colors to emphasize keywords, etc. If the code fragments are not syntactically correct, no color is added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e719594fe4392044efc80322d910ef4492ead1" translate="yes" xml:space="preserve">
          <source>Combinators</source>
          <target state="translated">Combinators</target>
        </trans-unit>
        <trans-unit id="6c17ee03a306b91971412221a882fcd419f9e636" translate="yes" xml:space="preserve">
          <source>Command-line flags that may apply per round, for example those with -cost in the name, accept arguments of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25ddda331004e4397b9f28e2859119842f8dc5d" translate="yes" xml:space="preserve">
          <source>Commands for &lt;a href=&quot;unix#VALlockf&quot;&gt;&lt;code&gt;Unix.lockf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe2bb252511c0dcd32f92897ba3957e1e2a7bb9" translate="yes" xml:space="preserve">
          <source>Commands for &lt;a href=&quot;unixlabels#VALlockf&quot;&gt;&lt;code&gt;UnixLabels.lockf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="a3122e7df96ccf5ef3d6e6a21777fc3539282091" translate="yes" xml:space="preserve">
          <source>Comments are delimited by (* and *), as in OCaml. The parse keyword, can be replaced by the shortest keyword, with the semantic consequences explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c1fef4daa2204e1362a69f73112badb4d24614" translate="yes" xml:space="preserve">
          <source>Comments are enclosed between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; (as in C) in the &amp;ldquo;declarations&amp;rdquo; and &amp;ldquo;rules&amp;rdquo; sections, and between &lt;code&gt;(*&lt;/code&gt; and &lt;code&gt;*)&lt;/code&gt; (as in OCaml) in the &amp;ldquo;header&amp;rdquo; and &amp;ldquo;trailer&amp;rdquo; sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc11b72dffe0da3e8d97afd6ad9a45f16491b95" translate="yes" xml:space="preserve">
          <source>Comments are introduced by the two characters (*, with no intervening blanks, and terminated by the characters *), with no intervening blanks. Comments are treated as blank characters. Comments do not occur inside string or character literals. Nested comments are handled correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75c107f6586a424d755198fc82176b1d5f1dff9" translate="yes" xml:space="preserve">
          <source>Comments containing documentation material are called &lt;em&gt;special comments&lt;/em&gt; and are written between (** and *). Special comments must start exactly with (**. Comments beginning with ( and more than two * are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e0a1731c9889297d187cff3225ed905ba87b0e" translate="yes" xml:space="preserve">
          <source>Comments surrounded by blank lines that appear within structures, signatures, classes or class types are converted into &lt;a href=&quot;attributes#floating-attribute&quot;&gt;floating-attribute&lt;/a&gt;s. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d590b93e87bc1ca65038f4d51e929c8c079658f0" translate="yes" xml:space="preserve">
          <source>Comments which appear &lt;em&gt;immediately after&lt;/em&gt; a labelled argument, record field, variant constructor, object method or polymorphic variant constructor are are converted into &lt;a href=&quot;attributes#attribute&quot;&gt;attribute&lt;/a&gt;s. Immediately after means that there must be no blank lines or other documentation comments between them. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b07191143ad093b41ed81db204e258405ef704d" translate="yes" xml:space="preserve">
          <source>Comments which appear &lt;em&gt;immediately before&lt;/em&gt; or &lt;em&gt;immediately after&lt;/em&gt; a structure item, signature item, class item or class type item are converted into &lt;a href=&quot;attributes#item-attribute&quot;&gt;item-attribute&lt;/a&gt;s. Immediately before or immediately after means that there must be no blank lines, ;;, or other documentation comments between them. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e64151aaa26674586f987552e2a0ae124e42ca" translate="yes" xml:space="preserve">
          <source>Comments which start with ** are also used by the ocamldoc documentation generator (see &lt;a href=&quot;ocamldoc#c%3Aocamldoc&quot;&gt;16&lt;/a&gt;). The three comment forms recognised by the compiler are a subset of the forms accepted by ocamldoc (see &lt;a href=&quot;ocamldoc#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547a2cc3c515433ea933b36b097f47f32287dbd8" translate="yes" xml:space="preserve">
          <source>Comments which start with ** are treated specially by the compiler. They are automatically converted during parsing into attributes (see &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;) to allow tools to process them as documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13ad45db1dc27f552c9c8e0654c622cd0ecc95b" translate="yes" xml:space="preserve">
          <source>Common usage of semantic tags is text decoration to get specific font or text size rendering for a display device, or marking delimitation of entities (e.g. HTML or TeX elements or terminal escape sequences). More sophisticated usage of semantic tags could handle dynamic modification of the pretty-printer behavior to properly print the material within some specific tags. For instance, we can define an RGB tag like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97496bca65dfa73c8db0f1c633b8c699b9ca1bae" translate="yes" xml:space="preserve">
          <source>Commonly-used options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e3408c9830bff719edb4bd317094b20c392982" translate="yes" xml:space="preserve">
          <source>Compare the length of a list to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160a38d938d09531dcc37101c8a48af67237c4f6" translate="yes" xml:space="preserve">
          <source>Compare the length of a list to an integer. &lt;code&gt;compare_length_with&amp;nbsp;l&amp;nbsp;n&lt;/code&gt; is equivalent to &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l)&amp;nbsp;n&lt;/code&gt;, except that the computation stops after at most &lt;code&gt;n&lt;/code&gt; iterations on the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b86b090c0daa980723dd4a0e6e2467eeba31e6" translate="yes" xml:space="preserve">
          <source>Compare the lengths of two lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbac14054ab6f68fcc3f6240710fbda158a49236" translate="yes" xml:space="preserve">
          <source>Compare the lengths of two lists. &lt;code&gt;compare_lengths&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; is equivalent to &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l1)&amp;nbsp;(length&amp;nbsp;l2)&lt;/code&gt;, except that the computation stops after itering on the shortest list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="5087a62fc321853c1ed733d0f0c235d307ad40e8" translate="yes" xml:space="preserve">
          <source>Compilation of modules that are able to be statically allocated (for example, the module corresponding to an entire compilation unit, as opposed to a first class module dependent on values computed at runtime) initially follows the strategy used for bytecode. A sequence of let-bindings, which may be interspersed with arbitrary effects, surrounds a record creation that becomes the module block. The Flambda-specific transformation follows: these bindings are lifted to toplevel symbols, as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89736122b4f9e6c854312216700fafb53d78c2c9" translate="yes" xml:space="preserve">
          <source>Compilation units bridge the module system and the separate compilation system. A compilation unit is composed of two parts: an interface and an implementation. The interface contains a sequence of specifications, just as the inside of a sig &amp;hellip; end signature expression. The implementation contains a sequence of definitions and expressions, just as the inside of a struct &amp;hellip; end module expression. A compilation unit also has a name unit-name, derived from the names of the files containing the interface and the implementation (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; for more details). A compilation unit behaves roughly as the module definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d0c7b86e662ef638a28a1ba63b2bf600c9a068" translate="yes" xml:space="preserve">
          <source>Compilation units that use the threads library must also be compiled with the -I +threads option (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5561032adf17bb14b32847302c46e8b6f2562175" translate="yes" xml:space="preserve">
          <source>Compile Mylib.ml using -no-alias-deps, and the other files using -no-alias-deps and -openMylib (the last one is equivalent to adding the line open!Mylib at the top of each file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0781426396e8d6e4ddff539e7a4bd1c018f11c8a" translate="yes" xml:space="preserve">
          <source>Compile a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379347737d11075d4adc510a0c49219cd575a386" translate="yes" xml:space="preserve">
          <source>Compile a regular expression. The following constructs are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e82ad175e2f5dacb9db3b9f212ed757afd81633" translate="yes" xml:space="preserve">
          <source>Compile only. Suppress the linking phase of the compilation. Source code files are turned into compiled files, but no executable file is produced. This option is useful to compile modules separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75f188aa5bbb4470a9e0906d4ab6e6752a8b3a3" translate="yes" xml:space="preserve">
          <source>Compile the file filename as an implementation file, even if its extension is not .ml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899b4c58ed78c400dbe712c3db1a649a9c6d6a72" translate="yes" xml:space="preserve">
          <source>Compile the file filename as an interface file, even if its extension is not .mli.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299b080c443dece1ea245d410a53d3e92be360bb" translate="yes" xml:space="preserve">
          <source>Compiled bytecode files (.cmo files), on the other hand, can be freely renamed once created. That&amp;rsquo;s because the linker never attempts to find by itself the .cmo file that implements a module with a given name: it relies instead on the user providing the list of .cmo files by hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d36c73ee25d65a59259585e736e00c1c87f0a3" translate="yes" xml:space="preserve">
          <source>Compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d018534cc6444c276f058ff3cb2e0e87d24e89" translate="yes" xml:space="preserve">
          <source>Compiling with -g entails no penalty on the running time of programs: object files and bytecode executable files are bigger and take longer to produce, but the executable files run at exactly the same speed as if they had been compiled without -g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b26b96b1c573965f14a325ef88109f84be8e3b" translate="yes" xml:space="preserve">
          <source>Complex</source>
          <target state="translated">Complex</target>
        </trans-unit>
        <trans-unit id="7611b3d644720e341343c4b145fe3d01e8fd3e09" translate="yes" xml:space="preserve">
          <source>Complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41458c6695371dbb3a5a9986252d1ee23df137d" translate="yes" xml:space="preserve">
          <source>Composition operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0f112d5883b3ed0b4cd635980e9b3e4954b4d1" translate="yes" xml:space="preserve">
          <source>Computation of compaction-triggering condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d679feceea0c84fcb7b9d34d0e5bd48c86acaa87" translate="yes" xml:space="preserve">
          <source>Computation of major GC slice size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ead95ccbb832522b24581d6c389102a9d297f79" translate="yes" xml:space="preserve">
          <source>Compute dependencies, as the ocamldep command would do. The remaining arguments are interpreted as if they were given to the ocamldep command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd62d65b81816c32e4d92808204724e2d5c82fc" translate="yes" xml:space="preserve">
          <source>Computes the total size (in words, including the headers) of all heap blocks accessible from the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518143af77e23baf0875a2af2ee9be3bba904a09" translate="yes" xml:space="preserve">
          <source>Computes the total size (in words, including the headers) of all heap blocks accessible from the argument. Statically allocated blocks are excluded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e753af33c5e8b0b810748b18ff7f60b83d5a7d0" translate="yes" xml:space="preserve">
          <source>Concatenate a list of lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4261005ac92aba9c70cd9071850bc5e978c5334" translate="yes" xml:space="preserve">
          <source>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21ae36c663b5598bb7f776455d5f7afa5edba88" translate="yes" xml:space="preserve">
          <source>Concatenate two lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf199bfa330ffd5961a47d9da430fec2620a9ae5" translate="yes" xml:space="preserve">
          <source>Concatenate two lists. Same as the infix operator &lt;code&gt;@&lt;/code&gt;. Not tail-recursive (length of the first argument).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1119e8da11a04af6ca0a753792995fcee08b2edc" translate="yes" xml:space="preserve">
          <source>Concatenating its elements using &lt;code&gt;sep&lt;/code&gt; as a separator returns a string equal to the input (&lt;code&gt;String.concat&amp;nbsp;(String.make&amp;nbsp;1&amp;nbsp;sep)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(String.split_on_char&amp;nbsp;sep&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ff79974f16dba8d693a91da2e607160a4f439a" translate="yes" xml:space="preserve">
          <source>Concerning the precedences of operators, # has the highest precedence, followed by *, + and ?, then concatenation, then | (alternation), then as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="ae369e3bb89711211abac6ae92d6ff255dbe265e" translate="yes" xml:space="preserve">
          <source>Condition variables are used when one thread wants to wait until another thread has finished doing something: the former thread 'waits' on the condition variable, the latter thread 'signals' the condition when it is done. Condition variables should always be protected by a mutex. The typical use is (if &lt;code&gt;D&lt;/code&gt; is a shared data structure, &lt;code&gt;m&lt;/code&gt; its mutex, and &lt;code&gt;c&lt;/code&gt; is a condition variable):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9f5175bc76dab872dcca0a8f4945ab47e57882" translate="yes" xml:space="preserve">
          <source>Condition variables to synchronize between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee141f68e4704140703200ef223fa3472ef6c33" translate="yes" xml:space="preserve">
          <source>Conjugate: given the complex &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;x&amp;nbsp;-&amp;nbsp;i.y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8479889b89034bc022c57bd8893185ae0364f595" translate="yes" xml:space="preserve">
          <source>Connect a socket to an address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06164f137b6b54ef3d5592c316dbf54c71cfc6d" translate="yes" xml:space="preserve">
          <source>Connect to a server at the given address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80bf1adde48d120cd79946b31d85d02da38b97cb" translate="yes" xml:space="preserve">
          <source>Connect to a server at the given address. Return a pair of buffered channels connected to the server. Remember to call &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; on the output channel at the right times to ensure correct synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f7e671b1e48da4a2700769f8225126847b97cf" translate="yes" xml:space="preserve">
          <source>Connection refused</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2986a51d253e6221052722aab2efbc181246b417" translate="yes" xml:space="preserve">
          <source>Connection reset by peer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c871ea22dada6554a1363ee61f9567c44efd80" translate="yes" xml:space="preserve">
          <source>Connection timed out</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f72e1d193c8d460ed969566e06ff72f178f5e73" translate="yes" xml:space="preserve">
          <source>Consider an OCaml interface to the standard libz C library for reading and writing compressed files. Assume this library resides in /usr/local/zlib. This interface is composed of an OCaml part zip.cmo/zip.cmx and a C part zipstubs.o containing the stub code around the libz entry points. The following command builds the OCaml libraries zip.cma and zip.cmxa, as well as the companion C libraries dllzip.so and libzip.a:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f229a35ad8b444a6b385bd0bbc84911cc773a8ae" translate="yes" xml:space="preserve">
          <source>Consider the given extension (with leading dot) to be a synonym for .ml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f60faccd60355e261afc4acf9b9359997518724" translate="yes" xml:space="preserve">
          <source>Consider the given extension (with leading dot) to be a synonym for .mli.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e850dfc5bd591d629fab1f8c55c2012ff29b5daf" translate="yes" xml:space="preserve">
          <source>Consider the service as UDP-based instead of the default TCP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733fd2b4c4e1bca4c7d0e3c2e1c341bcd1d34269" translate="yes" xml:space="preserve">
          <source>Constant</source>
          <target state="translated">Constant</target>
        </trans-unit>
        <trans-unit id="adcae46226442190d49d512a839dba8c470eb3cd" translate="yes" xml:space="preserve">
          <source>Constant closure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2ef079e6ae98b281f8cdb764b9043d153c622f" translate="yes" xml:space="preserve">
          <source>Constant float arrays at the toplevel are mutable and never shared. (That is to say, for each such definition there is a distinct symbol in the data section of the object file pointing at the array.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091bc5369699349a2b7818b4093bfda40449b4e6" translate="yes" xml:space="preserve">
          <source>Constant float arrays not at toplevel are mutable and are created each time the expression is evaluated. This can be thought of as an operation that takes an immutable array (which in the source code has no associated name; let us call it the &lt;em&gt;initialising array&lt;/em&gt;) and duplicates it into a fresh mutable array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df73dfd589730df5a6d45da4297228a1572f788f" translate="yes" xml:space="preserve">
          <source>Constraints are added left to right. After each constraint has been applied, the resulting signature must be a subtype of the signature before the constraint was applied. Thus, the with operator can only add information on the type components of a signature, but never remove information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e8eac434f49462f355fa784ffa70e49747333e" translate="yes" xml:space="preserve">
          <source>Construct the lexer function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a061bb0abb78e79e2f6fd7d764e9b588faff175a" translate="yes" xml:space="preserve">
          <source>Construct the lexer function. The first argument is the list of keywords. An identifier &lt;code&gt;s&lt;/code&gt; is returned as &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; belongs to this list, and as &lt;code&gt;Ident&amp;nbsp;s&lt;/code&gt; otherwise. A special character &lt;code&gt;s&lt;/code&gt; is returned as &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; belongs to this list, and cause a lexical error (exception &lt;a href=&quot;stream#EXCEPTIONError&quot;&gt;&lt;code&gt;Stream.Error&lt;/code&gt;&lt;/a&gt; with the offending lexeme as its parameter) otherwise. Blanks and newlines are skipped. Comments delimited by &lt;code&gt;(*&lt;/code&gt; and &lt;code&gt;*)&lt;/code&gt; are skipped as well, and can be nested. A &lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt;&lt;code&gt;Stream.Failure&lt;/code&gt;&lt;/a&gt; exception is raised if end of stream is unexpectedly reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ce4c1c12e94557da36c6eead56b4b8c0febfb9" translate="yes" xml:space="preserve">
          <source>Constructed term</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecff4df31a7f2f32be511ceea60554afcb2a1798" translate="yes" xml:space="preserve">
          <source>Constructed terms are represented either by unboxed integers (for constant constructors) or by blocks whose tag encode the constructor (for non-constant constructors). The constant constructors and the non-constant constructors for a given concrete type are numbered separately, starting from 0, in the order in which they appear in the concrete type declaration. A constant constructor is represented by the unboxed integer equal to its constructor number. A non-constant constructor declared with n arguments is represented by a block of size n, tagged with the constructor number; the n fields contain its arguments. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c0fcb39098c99481dbabaef595556e1d6382af" translate="yes" xml:space="preserve">
          <source>Construction or operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="4dcc0e86f7ec49506f86ec0239fe32f8d5ecfc33" translate="yes" xml:space="preserve">
          <source>Constructor application, Tag application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57a499db413be645296d9a22122e646866b53d6" translate="yes" xml:space="preserve">
          <source>Constructor or label name used out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="b1aff6232fa572c823b5ca4e0a0129e7ab716449" translate="yes" xml:space="preserve">
          <source>Consult the &lt;em&gt;Glossary&lt;/em&gt; at the end of this chapter for definitions of technical terms used below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="4dfc2782cd72d273592670acab33392686fa763f" translate="yes" xml:space="preserve">
          <source>Contents of the block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef50d03cf1626a58aa34b0e16915da06db0ad2e" translate="yes" xml:space="preserve">
          <source>Contextual control of command-line options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e02623966f9391facf6eaefc8b079ed5b630bee" translate="yes" xml:space="preserve">
          <source>Continue</source>
          <target state="translated">Continue</target>
        </trans-unit>
        <trans-unit id="a5765b37016775dde6c6f0a25c6231ac5868c966" translate="yes" xml:space="preserve">
          <source>Contrarily, if we have a function that can handle values of type xy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e574919fb4b279c4aa016ee88a030406704659" translate="yes" xml:space="preserve">
          <source>Control debugging support for &lt;code&gt;ocamlyacc&lt;/code&gt;-generated parsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8016b69c5c63c94758b8d9afd091d63f269088" translate="yes" xml:space="preserve">
          <source>Control debugging support for &lt;code&gt;ocamlyacc&lt;/code&gt;-generated parsers. After &lt;code&gt;Parsing.set_trace&amp;nbsp;true&lt;/code&gt;, the pushdown automaton that executes the parsers prints a trace of its actions (reading a token, shifting a state, reducing by a rule) on standard output. &lt;code&gt;Parsing.set_trace&amp;nbsp;false&lt;/code&gt; turns this debugging trace off. The boolean returned is the previous state of the trace flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a581af7c17aaf436ca9b9d0b8cc4b52024e23c6c" translate="yes" xml:space="preserve">
          <source>Control the Nagle algorithm for TCP sockets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f6ce64b088c1d86a1cc628890b28def1724c57" translate="yes" xml:space="preserve">
          <source>Control the way error messages and warnings are printed. The following modes are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54c927dcfd25ea6169be951e934da94f9e3db5c" translate="yes" xml:space="preserve">
          <source>Control whether the OCaml runtime system can emit warnings on stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158cedb78544ff7bbffffff2c57e102bc5772791" translate="yes" xml:space="preserve">
          <source>Control whether the OCaml runtime system can emit warnings on stderr. Currently, the only supported warning is triggered when a channel created by &lt;code&gt;open_*&lt;/code&gt; functions is finalized without being closed. Runtime warnings are disabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60df4ef37e363b7e927a63a861aa42ec8b55d7e9" translate="yes" xml:space="preserve">
          <source>Controlling which alerts are enabled and whether they are turned into fatal errors is done either through the compiler&amp;rsquo;s command-line option -alert &amp;lt;spec&amp;gt; or locally in the code through the alert or ocaml.alert attribute taking a single string payload &amp;lt;spec&amp;gt;. In both cases, the syntax for &amp;lt;spec&amp;gt; is a concatenation of items of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933cc834a01ad3244115777194487cf144f0ecdd" translate="yes" xml:space="preserve">
          <source>Controls how the inliner assesses the runtime performance penalties associated with various operations. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21ecd4fcc9a8d4ea30185fe486acd99672a553f" translate="yes" xml:space="preserve">
          <source>Controls how the inliner assesses whether a code path is likely to be hot or cold. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fa7a499f4a55d9e4e13932642f1433a08a09c0" translate="yes" xml:space="preserve">
          <source>Controls inlining of functors at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293ff2efcde405fd53b38d3396adbe0390c9bd33" translate="yes" xml:space="preserve">
          <source>Convenience formatting functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="5cd6a9211102cdfa59a068840e929afa53f5eabc" translate="yes" xml:space="preserve">
          <source>Conversely, the module expression (val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) evaluates the core language expression &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; to a value, which must have type module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;, and extracts the module that was encapsulated in this value. Again &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; can be omitted if the type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is known. If the module expression is already parenthesized, like the arguments of functors are, no additional parens are needed: Map.Make(val key).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76f66df18ce8edc9efd1881966c3c39e47be201" translate="yes" xml:space="preserve">
          <source>Conversely, whitespace or special shell characters occurring in command names or in their arguments must be quoted or escaped so that the shell does not interpret them. The quoting rules vary between the POSIX shell and the Windows shell. The &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; performs the appropriate quoting given a command name, a list of arguments, and optional file redirections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a64eefe7afd3acbb2a3fcb4bbbe7751fd9c8af3" translate="yes" xml:space="preserve">
          <source>Conversion from functions with default values to functions with patterns only works identically for class functions as for normal functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91ad5abdc78b39b4ce92904e5396ec1f786248c" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b79bd86888a46b8955becf95db977c77d0ac25" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation. The argument string consists of 4 numbers separated by periods (&lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt;) for IPv4 addresses, and up to 8 numbers separated by colons for IPv6 addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ea1a5bd106d39445b87322996d86ec7c632630" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation. The argument string consists of 4 numbers separated by periods (&lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt;) for IPv4 addresses, and up to 8 numbers separated by colons for IPv6 addresses. Raise &lt;code&gt;Failure&lt;/code&gt; when given a string that does not match these formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d97210aeab0bd3ebce234df3ec8fe7e4a70ca7f" translate="yes" xml:space="preserve">
          <source>Conversion specifications consist in the &lt;code&gt;%&lt;/code&gt; character, followed by an optional flag, an optional field width, and followed by one or two conversion characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab980193d03ab0985dd1b4bc77c12b22e232db45" translate="yes" xml:space="preserve">
          <source>Conversion specifications have the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c06747952c1535df9eef8f493a0e2f59c85b975" translate="yes" xml:space="preserve">
          <source>Conversion specifications in format strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c32e11691d111083462c54b49004696a9a09d1" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c792e891ce8ae61fdaebbd94276bd3662c41af32" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;tm_isdst&lt;/code&gt;, &lt;code&gt;tm_wday&lt;/code&gt; and &lt;code&gt;tm_yday&lt;/code&gt; fields of &lt;code&gt;tm&lt;/code&gt; are ignored. Also return a normalized copy of the given &lt;code&gt;tm&lt;/code&gt; record, with the &lt;code&gt;tm_wday&lt;/code&gt;, &lt;code&gt;tm_yday&lt;/code&gt;, and &lt;code&gt;tm_isdst&lt;/code&gt; fields recomputed from the other fields, and the other fields normalized (so that, e.g., 40 October is changed into 9 November). The &lt;code&gt;tm&lt;/code&gt; argument is interpreted in the local time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166e14cf3638ad0b673e006de2b94c19860f26cb" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7836de995e3285dfa0c8406853b5347a044422f1" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;tm_isdst&lt;/code&gt;, &lt;code&gt;tm_wday&lt;/code&gt; and &lt;code&gt;tm_yday&lt;/code&gt; fields of &lt;code&gt;tm&lt;/code&gt; are ignored. Also return a normalized copy of the given &lt;code&gt;tm&lt;/code&gt; record, with the &lt;code&gt;tm_wday&lt;/code&gt;, &lt;code&gt;tm_yday&lt;/code&gt;, and &lt;code&gt;tm_isdst&lt;/code&gt; fields recomputed from the other fields, and the other fields normalized (so that, e.g., 40 October is changed into 9 November). The &lt;code&gt;tm&lt;/code&gt; argument is interpreted in the local time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ed34778c74b1876e28a09ef2bb4037d0b1602b" translate="yes" xml:space="preserve">
          <source>Convert a hexadecimal representation back into the corresponding digest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ace682affc7ecae8d4105bd127d456bb9e4912" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2edee9666a075f72e6c7a588f50ef593d07338fc" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT. To perform the inverse conversion, set the TZ environment variable to &quot;UTC&quot;, use &lt;a href=&quot;unix#VALmktime&quot;&gt;&lt;code&gt;Unix.mktime&lt;/code&gt;&lt;/a&gt;, and then restore the original value of TZ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a03657cb3a62a7760f59bceeacb0c77fd66446" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes the local time zone. The function performing the inverse conversion is &lt;a href=&quot;unix#VALmktime&quot;&gt;&lt;code&gt;Unix.mktime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc9a0b90092a31e3fd77ab9bbe39a71117dbb38" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb5627989cc9828b7f0b2b5062d617c78dd2e67" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e49f724bd9a1b75ab1bd5c379646f6a4ff69bc3" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes the local time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93ecd2ce5ab11da436caae653e82540aed74786" translate="yes" xml:space="preserve">
          <source>Convert an error description to a printable message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03cb0b9780f37bd211d882819f132343734c8465" translate="yes" xml:space="preserve">
          <source>Convert an integer to floating-point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cef616f14d50a47152db143f35cc307563ca92" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411b3a0b25ac912caaa9c2f1d7ed837e3af70f3f" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to a native integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be3acecc320ef8bb4b8ad656c48b398c14be616" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f62b9cc8d76e35705b0ce4bdbf71d21a9df25e" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). On 32-bit platforms, the 32-bit integer is taken modulo 2&lt;sup&gt;31&lt;/sup&gt;, i.e. the high-order bit is lost during the conversion. On 64-bit platforms, the conversion is exact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014bbb3bbf0643a138bb48038c7eaab32ae13c44" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer to a floating-point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f59aef95dedbe83b6777c4e724a128aced4162e" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8c52d49afae53eeb13c5e454150dfee5751bcf" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). The 64-bit integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;, i.e. the top 32 bits are lost during the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54dd450fd275471e93b471cb0a1d306996989fe" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a native integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cca923cfddf0036de4f3e2ea85fc94c1f82ef40" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a native integer. On 32-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;. On 64-bit platforms, the conversion is exact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8506d7c598044a6201c1a0f6c8f93251b1073a0" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b8e9bc57fe5a67ea7ffcefe1594c337c38a927" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). On 64-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;63&lt;/sup&gt;, i.e. the high-order bit is lost during the conversion. On 32-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;31&lt;/sup&gt;, i.e. the top 33 bits are lost during the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6929450b6383bc9247464a59404dd3a1bdd763" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer to a floating-point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64aaae03809d3b5a65a5b282cb97472c52416af" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent lowercase character, using the ISO Latin-1 (8859-1) character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cef781019641479d8714145b7af1e60404822ad" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent lowercase character, using the US-ASCII character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10738094bd74009109a3d94ef91c5ed6b5c299bf" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent uppercase character, using the ISO Latin-1 (8859-1) character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc257554c0317b3dd5566d489ad3fde9331403d9" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent uppercase character, using the US-ASCII character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf675d948a6aff1ee29c25ddcb8bee6dd88d8aec" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 32-bit integer, discarding the fractional part (truncate towards 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2af0a4c1e0f6e2efe957e1a8efff3d2473b8403" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 32-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;int32#VALmin_int&quot;&gt;&lt;code&gt;Int32.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;int32#VALmax_int&quot;&gt;&lt;code&gt;Int32.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcb051564865ed8de2eb491570af0a4f45f4edd" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 64-bit integer, discarding the fractional part (truncate towards 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580bb45852738cdd647d7446f484386b0a804244" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 64-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;int64#VALmin_int&quot;&gt;&lt;code&gt;Int64.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;int64#VALmax_int&quot;&gt;&lt;code&gt;Int64.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5031b270a977528f20d0e7a11194d07248c96172" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a native integer, discarding the fractional part (truncate towards 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1725d3597c69c9439f05f46ee38743a2c137c782" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a native integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;nativeint#VALmin_int&quot;&gt;&lt;code&gt;Nativeint.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;nativeint#VALmax_int&quot;&gt;&lt;code&gt;Nativeint.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6050cb5e0048524aee2d160ae0cce485161ded2d" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3887945b57ea121fcdf0f14b5a759fdbaad36e7" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). On 64-bit platforms, the argument is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4debd3cb988d635b8f41534836b6a2b48d409ed0" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4921b162e3c39cc7cd9396df60a318a087afa590" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a native integer (type &lt;code&gt;nativeint&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3c57e865f3508e17aade52701128e682c09fd7" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c44f46b0858567098c36f81e612d99fcc9adc8" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da94aa8d40c08299bdebdd7ca1f19bdf6f8a60cb" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). The high-order bit is lost during the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc4c17f687227c32c9382b73f0b0e3cba1ffd79" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14b0131a571b73ccad1485e208ed7eab1af27b0" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). On 64-bit platforms, the 64-bit native integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;, i.e. the top 32 bits are lost. On 32-bit platforms, the conversion is exact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84b8167237f0e84a7eba52f0611f41b25ced1e1" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a floating-point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7d3886a056c01164226ca8f21d8885519399a9" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 32-bit integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2799240478510b8655a29381484f108391a1adb" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 32-bit integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d4202b90328e10c2df68813b3b1f8eb79b0f98" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 64-bit integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd390af034ba87ea38383f34f7b32709bfd5568f" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 64-bit integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046905d098af9c9b18df1bfb0e99207e44814271" translate="yes" xml:space="preserve">
          <source>Convert the given string to a boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb27f7eac6e919033f75b4bb9b0ad927cf3a2cc" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e405970d44a177d8f59d8de438813e89e623f942" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float. The string is read in decimal (by default) or in hexadecimal (marked by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c724ac3d5dc6e9e705e1e17a5f0ea7c150159b6b" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float. The string is read in decimal (by default) or in hexadecimal (marked by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;). The format of decimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; stands for a decimal digit. The format of hexadecimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; stands for an hexadecimal digit and &lt;code&gt;d&lt;/code&gt; for a decimal digit. In both cases, at least one of the integer and fractional parts must be given; the exponent part is optional. The &lt;code&gt;_&lt;/code&gt; (underscore) character can appear anywhere in the string and is ignored. Depending on the execution platforms, other representations of floating-point numbers can be accepted, but should not be relied upon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9970fe070e5622757e45b32117233a0163be3ba" translate="yes" xml:space="preserve">
          <source>Convert the given string to a native integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a3df43f4c2b1e962a393e752d6bbadfbb2aff4" translate="yes" xml:space="preserve">
          <source>Convert the given string to a native integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debd9a11f6bb577291b4caf3926d0227e1808f46" translate="yes" xml:space="preserve">
          <source>Convert the given string to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7206df3c20e1d25190b72034c967fc58a3ca235" translate="yes" xml:space="preserve">
          <source>Convert the given string to an integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;), in hexadecimal (if it begins with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;), in octal (if it begins with &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or in binary (if it begins with &lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bcef0a610e933857faac2e83c490abb8af3cab1" translate="yes" xml:space="preserve">
          <source>Converting</source>
          <target state="translated">Converting</target>
        </trans-unit>
        <trans-unit id="796fed19f815a7871b9f55ad1bb6d03d63143aee" translate="yes" xml:space="preserve">
          <source>Converts a format string into a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714801eba41aa2625b2a713ececaf6f421fd187f" translate="yes" xml:space="preserve">
          <source>Copy all elements of a Bigarray in another Bigarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33c856c6fe179d2a83dff4070691e79ceca7dae" translate="yes" xml:space="preserve">
          <source>Copy all elements of a Bigarray in another Bigarray. &lt;code&gt;Genarray.blit&amp;nbsp;src&amp;nbsp;dst&lt;/code&gt; copies all elements of &lt;code&gt;src&lt;/code&gt; into &lt;code&gt;dst&lt;/code&gt;. Both arrays &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; must have the same number of dimensions and equal dimensions. Copying a sub-array of &lt;code&gt;src&lt;/code&gt; to a sub-array of &lt;code&gt;dst&lt;/code&gt; can be achieved by applying &lt;code&gt;Genarray.blit&lt;/code&gt; to sub-array or slices of &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f98913bf026616eee1f70a64e0abe6968048030" translate="yes" xml:space="preserve">
          <source>Copy the first Bigarray to the second Bigarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e63802c10caf95b9698af675ba70745b8440d3c" translate="yes" xml:space="preserve">
          <source>Copy the first Bigarray to the second Bigarray. See &lt;a href=&quot;bigarray.genarray#VALblit&quot;&gt;&lt;code&gt;Bigarray.Genarray.blit&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749a2a1ff67c24e1aaefeb4893cf456a09300335" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2020 Institut National de Recherche en Informatique et en Automatique</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f0ee0d8c723707d5631f23f004103955272851" translate="yes" xml:space="preserve">
          <source>Correct use of exceptional return, in particular in the presence of garbage collection, is further detailed in Section &lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9221f888b1436de6082936ddd6d55309f806fb1b" translate="yes" xml:space="preserve">
          <source>Corrupted compiled interface filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a82a6d806181e70fe9be0edf237bd49a8998364" translate="yes" xml:space="preserve">
          <source>Cosine.</source>
          <target state="translated">Cosine.</target>
        </trans-unit>
        <trans-unit id="3909ef6abac31cfe9a35b22ea080c9d194f203ef" translate="yes" xml:space="preserve">
          <source>Cosine. Argument is in radians.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72cd010c4394bea276d4bdb151886625642b9b8b" translate="yes" xml:space="preserve">
          <source>Count the number of elements in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e082d8bf67432c245dd736e9ca7132061f24ca80" translate="yes" xml:space="preserve">
          <source>Count the number of elements in the table. &lt;code&gt;count&amp;nbsp;t&lt;/code&gt; gives the same result as &lt;code&gt;fold&amp;nbsp;(fun&amp;nbsp;_&amp;nbsp;n&amp;nbsp;-&amp;gt;&amp;nbsp;n+1)&amp;nbsp;t&amp;nbsp;0&lt;/code&gt; but does not delay the deallocation of the dead elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5cab66331e1f63a891d845b54e584c2f2ac037" translate="yes" xml:space="preserve">
          <source>Create a buffer from the generator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e34d2262662f5708968cd7624e835c13757358" translate="yes" xml:space="preserve">
          <source>Create a directory with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d3168ae617afccee2b8028fe4d89dc16e329c7" translate="yes" xml:space="preserve">
          <source>Create a directory with the given permissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc44996afbaa5cd1d76fa615bb2991b6a12175a4" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer on the given input channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5143503b6006ea03b7e3bd6f9b08f1d8aa2fdea1" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer on the given input channel. &lt;code&gt;Lexing.from_channel&amp;nbsp;inchan&lt;/code&gt; returns a lexer buffer which reads from the input channel &lt;code&gt;inchan&lt;/code&gt;, at the current reading position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81abb60f55d65a6d038b5d9a363404318029de3" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer which reads from the given string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6407d31fa51c4c55eb4598c03876535a93c6952f" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer which reads from the given string. Reading starts from the first character in the string. An end-of-input condition is generated when the end of the string is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190ca8ac4f2c64e047dbc76197c1ff595fa6b031" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer with the given function as its reading method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8735b8a50290dcf794da46bfe74dd3527a8550a" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer with the given function as its reading method. When the scanner needs more characters, it will call the given function, giving it a byte sequence &lt;code&gt;s&lt;/code&gt; and a byte count &lt;code&gt;n&lt;/code&gt;. The function should put &lt;code&gt;n&lt;/code&gt; bytes or fewer in &lt;code&gt;s&lt;/code&gt;, starting at index 0, and return the number of bytes provided. A return value of 0 means end of input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ba288a50ae1fece1cf0423426f78280eed622a" translate="yes" xml:space="preserve">
          <source>Create a list from the iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3456a1163b51311f839b8cf00cd30de750a651d3" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d10d804380675a899416b24f92318eeb66d264" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;). On Windows: not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fdff70665a56d05f0ee5d27d9da24708eb1894" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1a16120ae466a832076e7d380310e5ff6301b8" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093f73e0ca46114cb3907dbd3c6ba4b8e4823414" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3cf678cd161d0a98fd3f5d42b3cb008ce1a48a" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a14162d305ff52f22126d9ba6cafa4d78574a8" translate="yes" xml:space="preserve">
          <source>Create a new state and initialize it with a system-dependent low-entropy seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db61f76a5c74fd7a62aa832c9c1832527ee6e66" translate="yes" xml:space="preserve">
          <source>Create a new state and initialize it with the given seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2f60955c649908da20c0760f6c08367ad20db1" translate="yes" xml:space="preserve">
          <source>Create a packing interface Mylib.ml, containing the following lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533abcfd8c9a401ae37bd05c83664abd41b3978f" translate="yes" xml:space="preserve">
          <source>Create a pair of unnamed sockets, connected together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b413102c7a4e886a94cd1ccf3432e8ee8a268c" translate="yes" xml:space="preserve">
          <source>Create a pair of unnamed sockets, connected together. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ecb3637f50b940e9ab5fbcaa7d0e3d9d8adca50" translate="yes" xml:space="preserve">
          <source>Create a pipe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30af9bcb81b48bf202dd963116fe928f0c53fcfd" translate="yes" xml:space="preserve">
          <source>Create a pipe. The first component of the result is opened for reading, that's the exit to the pipe. The second component is opened for writing, that's the entrance to the pipe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd252b1ca191e7bced4e2176974be7bd120d4a47" translate="yes" xml:space="preserve">
          <source>Create a pipe. The first component of the result is opened for reading, that's the exit to the pipe. The second component is opened for writing, that's the entrance to the pipe. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21dc9f570d12477a38ca2a08e98e4c0750a86675" translate="yes" xml:space="preserve">
          <source>Create a queue from the generator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a770574699ea3d33080750f7cc2703aad4c9a772" translate="yes" xml:space="preserve">
          <source>Create a stack from the iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee45c92ea429789a619f70851af380b2976438fe" translate="yes" xml:space="preserve">
          <source>Create a string from the generator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d42ea6eec79d2dc2d2ce4ff68459ef19908da18" translate="yes" xml:space="preserve">
          <source>Create an array from the generator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa3a15a2bb90fcfee2212ff47808afd2d02c456" translate="yes" xml:space="preserve">
          <source>Create an array from the generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a23ab49072d38a59b186d4a3917b754a37143e" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be3c0896f6ff928d2c5d93f64972c34596328b6" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; if text mode is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b45b6f8c3f7cfba77d056c3802a69e5892dcce" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; if text mode is desired. Text mode is supported only if the descriptor refers to a file or pipe, but is not supported if it refers to a socket. On Windows, &lt;code&gt;set_binary_mode_in&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117259bf956aec536c5e186ca77e9ac5c916fcea" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef56a146856b79a283846092c16431e8f33cd0e" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; if text mode is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b9a3797ea26619d3139009eea19109e07b38e3" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; if text mode is desired. Text mode is supported only if the descriptor refers to a file or pipe, but is not supported if it refers to a socket. On Windows, &lt;code&gt;set_binary_mode_out&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6800f26660081a63257b90928fee7fe0195a50" translate="yes" xml:space="preserve">
          <source>Create if nonexistent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2f57520b3f8b6769816f831656e126cef6ab78" translate="yes" xml:space="preserve">
          <source>Creating directly an object through the object&lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;end construct is operationally equivalent to defining locally a class&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;=object&lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;end &amp;mdash;see sections &lt;a href=&quot;classes#sss%3Aclass-body&quot;&gt;7.9.2&lt;/a&gt; and following for the syntax of &lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;&amp;mdash; and immediately creating a single object from it by new&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601cb9beb4be7bd6b430fc5e8f28883c4379c1d3" translate="yes" xml:space="preserve">
          <source>Cross-references are fully qualified element names, as in the example {!Foo.Bar.t}. This is an ambiguous reference as it may designate a type name, a value name, a class name, etc. It is possible to make explicit the intended syntactic class, using {!type:Foo.Bar.t} to designate a type, and {!val:Foo.Bar.t} a value of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fe7fe65c32d93c2ca449d110fef079f2b333b8" translate="yes" xml:space="preserve">
          <source>Current call stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560d25076243183549a3366eeffb8ff8432d896d" translate="yes" xml:space="preserve">
          <source>Current size of the stack, in words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfd3c4c638243840bd240275ac5f3fed807c54e" translate="yes" xml:space="preserve">
          <source>Current value of the timer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812249ab55025e47f0d8297bf9cf8f98c1593c35" translate="yes" xml:space="preserve">
          <source>Currently, the compiler requires that all dependency cycles between the recursively-defined module identifiers go through at least one &amp;ldquo;safe&amp;rdquo; module. A module is &amp;ldquo;safe&amp;rdquo; if all value definitions that it contains have function types &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. Evaluation of a recursive module definition proceeds by building initial values for the safe modules involved, binding all (functional) values to fun_-&amp;gt;raiseUndefined_recursive_module. The defining module expressions are then evaluated, and the initial values for the safe modules are replaced by the values thus computed. If a function component of a safe module is applied during this computation (which corresponds to an ill-founded recursive definition), the Undefined_recursive_module exception is raised at runtime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38664408d8c3d30f0a6346765b3283aa12c40bf5" translate="yes" xml:space="preserve">
          <source>Currently, the official distribution only supports &lt;code&gt;Native&lt;/code&gt; and &lt;code&gt;Bytecode&lt;/code&gt;, but it can be other backends with alternative compilers, for example, javascript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bda26164af65ad302861503513ecff5571b51a" translate="yes" xml:space="preserve">
          <source>Custom blocks generalize the finalized blocks that were present in OCaml prior to version 3.00. For backward compatibility, the format of custom blocks is compatible with that of finalized blocks, and the alloc_final function is still available to allocate a custom block with a given finalization function, but default comparison, hashing and serialization functions. caml_alloc_final(n, f, used, max) returns a fresh custom block of size n+1 words, with finalization function f. The first word is reserved for storing the custom operations; the other n words are available for your data. The two parameters used and max are used to control the speed of garbage collection, as described for caml_alloc_custom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d420f0c61810f3ee6a674eb6f4cdb6097699b24" translate="yes" xml:space="preserve">
          <source>Custom blocks must be allocated via caml_alloc_custom or caml_alloc_custom_mem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0696943310470dcd9412c58452a376f47cd4d8e7" translate="yes" xml:space="preserve">
          <source>Custom_tag</source>
          <target state="translated">Custom_tag</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="876131551ef5b34a0ae26c45b8606a6d1e20f0ec" translate="yes" xml:space="preserve">
          <source>Damien Doligez, Alain Frisch, Jacques Garrigue, Didier R&amp;eacute;my and J&amp;eacute;r&amp;ocirc;me Vouillon</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb8e492ef8785784d3763a2dd035cbcb3a6f48d" translate="yes" xml:space="preserve">
          <source>Data_custom_val(v) returns a pointer to the data part of the custom block v. This pointer has type void * and must be cast to the type of the data contained in the custom block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c61aac6c59c97a9391046663cc1f0a559430d2b" translate="yes" xml:space="preserve">
          <source>Datagram socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5e1b484adfb0832aee424b80fdbf0749c94471" translate="yes" xml:space="preserve">
          <source>Day of month 1..31</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b30c19d064061d359d4bd864a0a544b299c73f" translate="yes" xml:space="preserve">
          <source>Day of week (Sunday is 0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b762515612697efddec23840f7a8446cf18c9759" translate="yes" xml:space="preserve">
          <source>Day of year 0..365</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0dbb1420972511e036436a9980700df7df5ce2" translate="yes" xml:space="preserve">
          <source>Daylight time savings in effect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fadfd27832ae372bd710d8badba7a9b539b27e1" translate="yes" xml:space="preserve">
          <source>Deactivates the applicative behaviour of functors. With this option, each functor application generates new types in its result and applying the same functor twice to the same argument yields two incompatible structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751472bbc1120d8b191832a2b8fcc18014817d7f" translate="yes" xml:space="preserve">
          <source>Deactivates the constant propagation for floating-point operations. This option should be given if the program changes the float rounding mode during its execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="2678ad56aeb7875f3c2d5de90981064d8f642b7a" translate="yes" xml:space="preserve">
          <source>Declarations are given one per line. They all start with a &lt;code&gt;%&lt;/code&gt; sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea55cd40a5af4aaba5005b973e60323ff6e05fa" translate="yes" xml:space="preserve">
          <source>Declare the given symbols &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; as tokens (terminal symbols). These symbols are added as constant constructors for the token concrete type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ce3434b9f14435902a3d78ef46a7ad71688c6e" translate="yes" xml:space="preserve">
          <source>Declare the given symbols &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; as tokens with an attached attribute of the given type. These symbols are added as constructors with arguments of the given type for the token concrete type. The &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part is an arbitrary OCaml type expression, except that all type constructor names must be fully qualified (e.g. Modname.typename) for all types except standard built-in types, even if the proper &lt;code&gt;open&lt;/code&gt; directives (e.g. &lt;code&gt;open Modname&lt;/code&gt;) were given in the header section. That&amp;rsquo;s because the header is copied only to the .ml output file, but not to the .mli output file, while the &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part of a &lt;code&gt;%token&lt;/code&gt; declaration is copied to both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae20b0b5091f27b6010031e7c755cac286e05951" translate="yes" xml:space="preserve">
          <source>Declare the given symbols as entry points for the grammar. For each entry point, a parsing function with the same name is defined in the output module. Non-terminals that are not declared as entry points have no such parsing function. Start symbols must be given a type with the &lt;code&gt;%type&lt;/code&gt; directive below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e036180d7b4330c36ccc46169e89f1d9c0e3c6b6" translate="yes" xml:space="preserve">
          <source>Decrement the integer contained in the given reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c2c2f15d575288567819a78318c5d8b38a36ce" translate="yes" xml:space="preserve">
          <source>Decrement the integer contained in the given reference. Equivalent to &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;pred&amp;nbsp;!r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c11b83f7c1a5251b3d34dbe51f9955f77470d6d" translate="yes" xml:space="preserve">
          <source>Default callbacks simply return &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80afbff2abe8c0d7fd33c9ccd7830a6e8695af59" translate="yes" xml:space="preserve">
          <source>Default directories searched by the system dynamic loader. Under Unix, these generally include /lib and /usr/lib, plus the directories listed in the file /etc/ld.so.conf and the environment variable LD_LIBRARY_PATH. Under Windows, these include the Windows system directories, plus the directories listed in the PATH environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3a0856d835d1235dff9d8788c3557c03ede792" translate="yes" xml:space="preserve">
          <source>Default tag-marking functions behave the HTML way: &lt;a href=&quot;format#TYPEtag&quot;&gt;string tags&lt;/a&gt; are enclosed in &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; while other tags are ignored; hence, opening marker for tag string &lt;code&gt;&quot;t&quot;&lt;/code&gt; is &lt;code&gt;&quot;&amp;lt;t&amp;gt;&quot;&lt;/code&gt; and closing marker is &lt;code&gt;&quot;&amp;lt;/t&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a62a2e3e7ee2c9c2ee80559a4f3229d3577d48f" translate="yes" xml:space="preserve">
          <source>Default tag-printing functions just do nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eed4a181452e1959a48bc782bac0f8f566e7c0f" translate="yes" xml:space="preserve">
          <source>Default: 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9082a1e7f923e7fce6486c509c1beb8c25f7fe15" translate="yes" xml:space="preserve">
          <source>Deferred computations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf39e9d321a7d8c8984215b8972f37f40d07337" translate="yes" xml:space="preserve">
          <source>Define a hash table on generic containers which have a notion of &quot;death&quot; and aliveness. If a binding is dead the hash table can automatically remove it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21fc769210bfcaf86eb46d5f61d271368778b97" translate="yes" xml:space="preserve">
          <source>Defining expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4de55230924b0c3c5fc761cc7d4686a36f7dc3" translate="yes" xml:space="preserve">
          <source>Defining formatters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4911c404436a822d9f0fbfab26950a91ad559e29" translate="yes" xml:space="preserve">
          <source>Defining new formatters permits unrelated output of material in parallel on several output devices. All the parameters of a formatter are local to the formatter: right margin, maximum indentation limit, maximum number of pretty-printing boxes simultaneously open, ellipsis, and so on, are specific to each formatter and may be fixed independently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0b554ed773f7f64c570b11feb5887c9cc07fe5" translate="yes" xml:space="preserve">
          <source>Delete the specified breakpoints. Without argument, all breakpoints are deleted (after asking for confirmation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97978b86bb138adaba2fd837574900d5922d00e" translate="yes" xml:space="preserve">
          <source>Dependencies are generated both for compiling with the bytecode compiler ocamlc and with the native-code compiler ocamlopt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d4c46a17ce0b5e730857044f9bf49c709590e2" translate="yes" xml:space="preserve">
          <source>Depending on the execution platforms, other representations of floating-point numbers can be accepted, but should not be relied upon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="74254f9d66f6a56051d0eaae6dea96f7d55c67a0" translate="yes" xml:space="preserve">
          <source>Deprecated since OCaml 4.11. Please use -bin-annot instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0c6a5ddb045b6ece785229e78cf805f0b1a89d" translate="yes" xml:space="preserve">
          <source>Deprecated synonym for the &amp;rsquo;deprecated&amp;rsquo; alert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e967cec8e8fdbe014b3a9f6bbf388f62bb46fa7" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;a href=&quot;unix#VALgetsockopt_error&quot;&gt;&lt;code&gt;Unix.getsockopt_error&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2224f5d5269c5bc0b6728399953ed547eb0d09f0" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;a href=&quot;arraylabels#VALmake_float&quot;&gt;&lt;code&gt;ArrayLabels.make_float&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;arraylabels#VALcreate_float&quot;&gt;&lt;code&gt;ArrayLabels.create_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778bc3674d64e797ac3bcdc24c0d0ca9cba0734e" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;a href=&quot;stdlib#VAL(&amp;amp;&amp;amp;)&quot;&gt;&lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt;&lt;/a&gt; should be used instead. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fca9f421cfdb9f0454d469cdb1dcaa8ace5429e" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;(||)&lt;/code&gt; should be used instead. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a150df40019aac9b002359089017a86258f19d9f" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.create&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e89b4c51bb7679bf855f7c9eec368867486ddd1" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.create_matrix&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALmake_matrix&quot;&gt;&lt;code&gt;Array.make_matrix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50bae5862dab3413cad88ccda1ead1a473864665" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.make_float&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALcreate_float&quot;&gt;&lt;code&gt;Array.create_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea64d85c2e594370c18faa8e1d13550273cdb567" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Scanf.fscanf&lt;/code&gt; is error prone and deprecated since 4.03.0. This function violates the following invariant of the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: To preserve scanning semantics, all scanning functions defined in &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; must read from a user defined &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel. If you need to read from a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; input channel &lt;code&gt;ic&lt;/code&gt;, simply define a &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel as in &lt;code&gt;let&amp;nbsp;ib&amp;nbsp;=&amp;nbsp;Scanning.from_channel&amp;nbsp;ic&lt;/code&gt;, then use &lt;code&gt;Scanf.bscanf&amp;nbsp;ib&lt;/code&gt; as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce9cc4e47d57231b6a0bca0e76722fe4b7860a4" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Scanf.kfscanf&lt;/code&gt; is error prone and deprecated since 4.03.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f594cb170e0e9c8ecd301b0b815c721b26b065d" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;create&lt;/code&gt; is an alias for &lt;a href=&quot;arraylabels#VALmake&quot;&gt;&lt;code&gt;ArrayLabels.make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce71a4bfc97c24d6d8d5947007a2b7beb8109c0" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;create_matrix&lt;/code&gt; is an alias for &lt;a href=&quot;arraylabels#VALmake_matrix&quot;&gt;&lt;code&gt;ArrayLabels.make_matrix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19939082fb7f2eee871d26aedbf72b901c3112f7" translate="yes" xml:space="preserve">
          <source>Deprecated.An alias for &lt;code&gt;ksprintf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5109e0782a729eff640730e6ab1a3e754505085" translate="yes" xml:space="preserve">
          <source>Deprecated.Because strings are immutable, it doesn't make much sense to make identical copies of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750ec831f3c087b18622dc178ec61b7cb38e9e32" translate="yes" xml:space="preserve">
          <source>Deprecated.Functions operating on Latin-1 character set are deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea75bf6e5b032cf8e893592df0f821c5e5f96d64" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#TYPEformatter_stag_functions&quot;&gt;&lt;code&gt;Format.formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c97116701943fcfc6c2f740afe560b14ec3898d" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALclose_stag&quot;&gt;&lt;code&gt;Format.close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca73c717756fa77071fb29946903b95deed41a6" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALget_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.get_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93054ebdf71f3812384f734ddd0e2d1f78da6e2" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALopen_stag&quot;&gt;&lt;code&gt;Format.open_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281c574fe529db292e92addfbf152b24d9bdbbf3" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_close_stag&quot;&gt;&lt;code&gt;Format.pp_close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641c68cac8b19078637ee0e40e70a3a5d64a22f6" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_get_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.pp_get_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ccb247c568c8d05554c40ee2105c8bf4f8476b4" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_open_stag&quot;&gt;&lt;code&gt;Format.pp_open_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2602cd2b6f3d43929ce834f849335fcef5dae37" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_set_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.pp_set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa368f3af7d6061271ddaa3583db9fd9dfb7bca" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33425025d507c5cd7b36ca43602379d421c4dc9" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;get_formatter_out_functions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2a76881889cf4cb991a8f48ab00eec047820ff" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;pp_get_formatter_out_functions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027d489c4ef0ad9d201d300c80987ca970dd611d" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;pp_set_formatter_out_functions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3dcb5b6debc7e2c15801aa508b5d41a02ae9fc" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;set_formatter_out_functions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f8f5969e6b8a63fecae4c32ed1ceb9fde348db" translate="yes" xml:space="preserve">
          <source>Deprecated.The functionality of this module has been merged back into the &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module. Threaded programs can now call the functions from module &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; directly, and still get the correct behavior (block the calling thread, if required, but do not block all threads in the process).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3242d82a29f5555016d27f6fdf4642b2322aa5a3" translate="yes" xml:space="preserve">
          <source>Deprecated.This function is error prone. Do not use it. This function is neither compositional nor incremental, since it flushes the pretty-printer queue at each call. If you need to print to some buffer &lt;code&gt;b&lt;/code&gt;, you must first define a formatter writing to &lt;code&gt;b&lt;/code&gt;, using &lt;code&gt;let&amp;nbsp;to_b&amp;nbsp;=&amp;nbsp;formatter_of_buffer&amp;nbsp;b&lt;/code&gt;; then use regular calls to &lt;code&gt;Format.fprintf&lt;/code&gt; with formatter &lt;code&gt;to_b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d129f235645dc88a9f2ee69c1b366ec77d5e6af0" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0d72f83cc5b5f92d01d7c247da799f1cf025dd" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALfill&quot;&gt;&lt;code&gt;Bytes.fill&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1d7aec9a40e9b929be4e8acc4d6af5f1afb54e" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALset&quot;&gt;&lt;code&gt;Bytes.set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94967cc879b015aef449bb6fdb01c7b7b10b4307" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALcreate&quot;&gt;&lt;code&gt;BytesLabels.create&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aaa67606a221f7b76061f12289e38192d36dab" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALfill&quot;&gt;&lt;code&gt;BytesLabels.fill&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97555fc7a6d84d213dab655a6b7779fcd3941c9" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALset&quot;&gt;&lt;code&gt;BytesLabels.set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb4d0a700ae5d08d5df97d7d36b72776b3f990e" translate="yes" xml:space="preserve">
          <source>Deprecated.You should use &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt;&lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288e17a817fd8dee0e659a5930d009274e344a1a" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;from_fun&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc633f74d2489b4a203e2ddf0b1d55195cf9e76" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;from_val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f1d014a7b64bfd88ddaa57f0c63ab52af2c740" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;is_val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c61ae75bfda87e7eb880e442b4f35b49765a4e6" translate="yes" xml:space="preserve">
          <source>Deprecated: now part of warning 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c30d33385a5d3cd74cc6904ab3e2c26ba272b0c" translate="yes" xml:space="preserve">
          <source>Dereferencing (return the current contents of a reference).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556c70c19023a2dd4cddc34ffa2fb962927700b6" translate="yes" xml:space="preserve">
          <source>Describe the currently selected stack frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30204445e59c24675d5d45718f49e0d965ced7fa" translate="yes" xml:space="preserve">
          <source>Describe the return value and its possible values. This tag is used for functions and methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6067c118d1f66def5a1a8be905127318b0e21e" translate="yes" xml:space="preserve">
          <source>Descriptions of elements and descriptions in @-tags are handled as follows. If a description for the same element or in the same @-tag of the same element is present in both files, then the description of the .ml file is concatenated to the one in the .mli file, if the corresponding -m flag is given on the command line. If a description is present in the .ml file and not in the .mli file, the .ml description is kept. In either case, all the information given in the .mli file is kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d799aee373a2f6c263ebf58e0280d66136d9e5" translate="yes" xml:space="preserve">
          <source>Despite &lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt; and &lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt; being lexical entities in expressions, their expansions ~&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;: and ?&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;: will be used in grammars, for the sake of readability. Note also that inside type expressions, this expansion can be taken literally, &lt;em&gt;i.e.&lt;/em&gt; there are really 3 tokens, with optional blanks between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f646066bdf4b1ec66764f189ea43f9555404f9" translate="yes" xml:space="preserve">
          <source>Destination address required</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d38e034fc41445f66a84bbc7421aae75cb369d" translate="yes" xml:space="preserve">
          <source>Determine whether it is clear that inlining would be beneficial without, for the moment, doing any inlining within the function itself. (The exact assessment of &lt;em&gt;benefit&lt;/em&gt; is described below.) If so, the function is inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe861f03852b09cf76716d7e041be8378ee86f6e" translate="yes" xml:space="preserve">
          <source>Device ID (if special file)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa7dda8b47dbe32f43cc7e7cbb154977cdd4b4b" translate="yes" xml:space="preserve">
          <source>Device number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47fdd58bee4dc86df2b978107102a22b9c44345b" translate="yes" xml:space="preserve">
          <source>Digest</source>
          <target state="translated">Digest</target>
        </trans-unit>
        <trans-unit id="03b5690384bc40a11bbb9c00e423e54e65806954" translate="yes" xml:space="preserve">
          <source>Direct call site</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6511f8b22675dad2defbfb3fe082bbb561af35ab" translate="yes" xml:space="preserve">
          <source>Direct the memory manager to print some progress messages on standard error. This is equivalent to setting v=63 in the OCAMLRUNPARAM environment variable (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1029544ae8b46287a52a74595462c217cf60a5a9" translate="yes" xml:space="preserve">
          <source>Directories</source>
          <target state="translated">Directories</target>
        </trans-unit>
        <trans-unit id="6c8a1a100ae0fc810383f2b9a2878d99ecc4ed7c" translate="yes" xml:space="preserve">
          <source>Directories added with the #directory directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d54c02b2c2c47443482e970156b799ac791785a" translate="yes" xml:space="preserve">
          <source>Directories can also be added to the list once the toplevel is running with the #directory directive (section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa1af9dcf811b5cb577d789120d5a9a8e401eb8" translate="yes" xml:space="preserve">
          <source>Directories given on the command line with -I options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fca1322bb244459d6be50257fca52fdf7eac5df" translate="yes" xml:space="preserve">
          <source>Directories specified at link-time via the -dllpath option to ocamlc. (These directories are recorded in the bytecode executable file.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff079471e218f45b2873844ac43f1b9da8c17ff6" translate="yes" xml:space="preserve">
          <source>Directories specified in the CAML_LD_LIBRARY_PATH environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fea42a5c86d3619520a1c10b093343dc1f30f5a2" translate="yes" xml:space="preserve">
          <source>Directories specified in the file ld.conf. This file resides in the OCaml standard library directory, and lists directory names (one per line) to be searched. Typically, it contains only one line naming the stublibs subdirectory of the OCaml standard library directory. Users can add there the names of other directories containing frequently-used shared libraries; however, for consistency of installation, we recommend that shared libraries are installed directly in the system stublibs directory, rather than adding lines to the ld.conf file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4425c83626ad0d492312630fa584010dc2ea7687" translate="yes" xml:space="preserve">
          <source>Directories specified on the ocamlrun command line with the -I option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b892fe0c040fa8a944037d1d2817c41ab7da958" translate="yes" xml:space="preserve">
          <source>Directory</source>
          <target state="translated">Directory</target>
        </trans-unit>
        <trans-unit id="ca827528d6904965fcebbbcad976a987f5f845b3" translate="yes" xml:space="preserve">
          <source>Directory not empty</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ccc74e22667a82ec8374d5503fa0741496e682" translate="yes" xml:space="preserve">
          <source>Disable flush after INTR, QUIT, SUSP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4bdf9a6eacfa2697016cd0108d461fcf7421b2" translate="yes" xml:space="preserve">
          <source>Disable the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcea52c1515117c58919743de2a2da57c540121" translate="yes" xml:space="preserve">
          <source>Disable the set of warnings corresponding to lowercase-letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19f04c2757dbb7f8de14c35e1cce96d6a55c8a6" translate="yes" xml:space="preserve">
          <source>Disable warning number num.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec8cd3e0abf9d3de01b24e3782506475ae87211" translate="yes" xml:space="preserve">
          <source>Disable warnings in the given range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff551fe5c7d7e0f50ac103c39a57bea5895ef26" translate="yes" xml:space="preserve">
          <source>Disambiguated constructor or label name (compatibility warning).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b228a139422f11ea4357c7d2efc32f85d808b19b" translate="yes" xml:space="preserve">
          <source>Discard all elements from a queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a763423157ebaef14af264de95dfd62aeae53cfc" translate="yes" xml:space="preserve">
          <source>Discard all elements from a stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ac75ec9ac382b61445173e38bfa779b2b19f5c" translate="yes" xml:space="preserve">
          <source>Discard data written on the given file descriptor but not yet transmitted, or data received but not yet read, depending on the second argument: &lt;code&gt;TCIFLUSH&lt;/code&gt; flushes data received but not read, &lt;code&gt;TCOFLUSH&lt;/code&gt; flushes data written but not transmitted, and &lt;code&gt;TCIOFLUSH&lt;/code&gt; flushes both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57521250b5897b35eb18446005dde0a337ba5726" translate="yes" xml:space="preserve">
          <source>Discard the contents of the buffer and reset the current position to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c324ee3bd77d8cdc9882e8d0fc0aa86700e2b4ff" translate="yes" xml:space="preserve">
          <source>Discard the contents of the buffer and reset the current position to 0. The next use of the lexbuf will trigger a refill.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3793c75090c266feef9865c31883fbe011f366" translate="yes" xml:space="preserve">
          <source>Discard the value of its argument and return &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e4d950f2d4305046840b504d37718518d243de" translate="yes" xml:space="preserve">
          <source>Discard the value of its argument and return &lt;code&gt;()&lt;/code&gt;. For instance, &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; discards the result of the side-effecting function &lt;code&gt;f&lt;/code&gt;. It is equivalent to &lt;code&gt;f&amp;nbsp;x;&amp;nbsp;()&lt;/code&gt;, except that the latter may generate a compiler warning; writing &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; instead avoids the warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3db82a71cdff092fe3c4e674d2cf59d344c98c" translate="yes" xml:space="preserve">
          <source>Display a short usage summary and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35dc839559848f5eb2c3fe73488f70904e3ae41c" translate="yes" xml:space="preserve">
          <source>Display the complete list of parameters for functions and methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83946df95c85b27e03a0eceda28c6b18faddcf0" translate="yes" xml:space="preserve">
          <source>Display the custom generators default directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="c1615505a10cd0a8a96dbd7380ce2c53780aa017" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; set the -custom flag, otherwise you&amp;rsquo;re back to static linking as described in section &lt;a href=&quot;#ss%3Astaticlink-c-code&quot;&gt;20.1.3&lt;/a&gt;. The ocamlmklib tool (see section &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;) automates steps 2 and 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c47225fbda414465a615e36d4177b55dd3eaa1c" translate="yes" xml:space="preserve">
          <source>Do a minor collection and finish the current major collection cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e67bacde12033f167102017edabc6ea724d07c0" translate="yes" xml:space="preserve">
          <source>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b6ceedb393ff292e5063adf221897afc4e187a" translate="yes" xml:space="preserve">
          <source>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daaabef3025f3c8281acefcdc36265b713e5d45" translate="yes" xml:space="preserve">
          <source>Do not add current working directory to the list of include directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd6861951e2b753da997ead7a08426d22baa2a3" translate="yes" xml:space="preserve">
          <source>Do not allow custom @-tags (see section &lt;a href=&quot;#ss%3Aocamldoc-tags&quot;&gt;16.2.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ddb859954f4b0f1267022be18664ce369f4d72a" translate="yes" xml:space="preserve">
          <source>Do not automatically add the standard library directory to the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmx), and libraries (.cmxa). See also option -I.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b22d46ee16ff416c80772315f7396494ea3fc5e" translate="yes" xml:space="preserve">
          <source>Do not block if no child has died yet, but immediately return with a pid equal to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031865d55aa41b6e70421f3ce5c1a293a99cbfc7" translate="yes" xml:space="preserve">
          <source>Do not build index for Info files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd45f175e92b8eaae1b91c01a1d09ad1da05182" translate="yes" xml:space="preserve">
          <source>Do not call name resolver, expect numeric IP address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f826060748a4f9075bc43b6d058cc0ba05d77389" translate="yes" xml:space="preserve">
          <source>Do not compile assertion checks. Note that the special form assert false is always compiled because it is typed specially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28cdfa96ccebfb982ad25f616a5461bcce5db594" translate="yes" xml:space="preserve">
          <source>Do not compile assertion checks. Note that the special form assert false is always compiled because it is typed specially. This flag has no effect when linking already-compiled files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4151d019da73db9b1b47237e17df5a70d431b4" translate="yes" xml:space="preserve">
          <source>Do not display any prompt when waiting for input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4587f67b20caed188543780983919bc73577d989" translate="yes" xml:space="preserve">
          <source>Do not display the secondary prompt when waiting for continuation lines in multi-line inputs. This should be used e.g. when running ocaml in an emacs window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cc23e1ce95050f53c83e4fc4b5197b57a26719" translate="yes" xml:space="preserve">
          <source>Do not generate a table of contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19a0b4c326541165d9a51372f39e571198ccf18" translate="yes" xml:space="preserve">
          <source>Do not include the standard library directory in the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmo), libraries (.cma), and C libraries specified with -cclib -lxxx. See also option -I.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064821cea7940442efa1520725382b3b4955526f" translate="yes" xml:space="preserve">
          <source>Do not include the standard library directory in the list of directories searched for source and compiled files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253be060206824d9b4dd7af9b8790b6551c7c9cd" translate="yes" xml:space="preserve">
          <source>Do not print OCamldoc warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e3c326d3220da0354ae7c4e91ad6fb36af0dbe" translate="yes" xml:space="preserve">
          <source>Do not print the version banner at startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a518f2812d3306324e4ce68e86acbedd313390cc" translate="yes" xml:space="preserve">
          <source>Do not qualify local host names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15165b95be0530c8689212758b6f87ed55a19591" translate="yes" xml:space="preserve">
          <source>Do not record dependencies for module aliases. See section &lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;8.8&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c810b750e959c8744be3fb11ef3f3b863e75d1" translate="yes" xml:space="preserve">
          <source>Do not unbox arguments to which functions have been specialised. See section &lt;a href=&quot;#ss%3Aflambda-unbox-spec-args&quot;&gt;21.9.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94446f6fa3c2614682fdb6a2f38f1eea9d15a5cd" translate="yes" xml:space="preserve">
          <source>Do not unbox closure variables. See section &lt;a href=&quot;#ss%3Aflambda-unbox-fvs&quot;&gt;21.9.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83efe30f6e83b800163ecbaf2a13c9f7320f78be" translate="yes" xml:space="preserve">
          <source>Do note that the indices passed to &lt;code&gt;f&lt;/code&gt; may not start at &lt;code&gt;0&lt;/code&gt; in the general case. For example, &lt;code&gt;[&amp;lt;&amp;nbsp;'0;&amp;nbsp;'1;&amp;nbsp;Stream.from&amp;nbsp;f&amp;nbsp;&amp;gt;]&lt;/code&gt; would call &lt;code&gt;f&lt;/code&gt; the first time with count &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e115cdb1fc49a35afc65cded140e7aac8702d30d" translate="yes" xml:space="preserve">
          <source>Documentation and user&amp;rsquo;s manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ee6007715742773c38d4eb75befc2fcd192d39" translate="yes" xml:space="preserve">
          <source>Domain error for math functions, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb4365752b3a355adb85f2c09fa26922f6de928" translate="yes" xml:space="preserve">
          <source>Don't make this dev a controlling tty</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c9fea25fd7a1fe50f26d27cf3ecd6a65b6a25b" translate="yes" xml:space="preserve">
          <source>Don't preserve sharing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c809cff2d695209e704f8197dab6f54e225936" translate="yes" xml:space="preserve">
          <source>Double the default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e85994c9a5443f990f6afb5b898c774627a852" translate="yes" xml:space="preserve">
          <source>Double_array_tag</source>
          <target state="translated">Double_array_tag</target>
        </trans-unit>
        <trans-unit id="ca8bf75e9f0596d733ef4d95e5e307e4a331e94d" translate="yes" xml:space="preserve">
          <source>Double_field(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; element of the array of floating-point numbers v (a block tagged Double_array_tag).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c671ea4bfc33386e2575fa5b03150428efb4ede" translate="yes" xml:space="preserve">
          <source>Double_tag</source>
          <target state="translated">Double_tag</target>
        </trans-unit>
        <trans-unit id="bbc4dbcceef59b6f089abaa4a71a66bb23b3e7be" translate="yes" xml:space="preserve">
          <source>Double_val(v) returns the floating-point number contained in value v, with type double.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e07ec423183b97e7e54906d287288e1be1ffc2" translate="yes" xml:space="preserve">
          <source>Due to the way that format string are build, storing a format string requires an explicit type annotation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38da2b2f7c5e5067497c455981267218324b40aa" translate="yes" xml:space="preserve">
          <source>Dump collected information into file. This information can be read with the -load option in a subsequent invocation of ocamldoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7d57f9e20eda3c41fb941c658194cfee284a2a" translate="yes" xml:space="preserve">
          <source>Dump detailed information about the compilation (types, bindings, tail-calls, etc) in binary format. The information for file src.ml (resp. src.mli) is put into file src.cmt (resp. src.cmti). In case of a type error, dump all the information inferred by the type-checker before the error. The *.cmt and *.cmti files produced by -bin-annot contain more information and are much more compact than the files produced by -annot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d734c14d897b78ff2c878be1ef4830dddaf75aad" translate="yes" xml:space="preserve">
          <source>Dump the delayed dependency map for each map file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11fe1c6936a32f898ab53021b1b505b77ad3f51" translate="yes" xml:space="preserve">
          <source>During execution of an ocamlopt-generated executable, the following environment variables are also consulted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a527567660be56f12ce37a951df19c1ce6570fac" translate="yes" xml:space="preserve">
          <source>During execution, a trace file will be generated in the program&amp;rsquo;s current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52da08cd6051434fc2f3b7662122ca9fcd53bd40" translate="yes" xml:space="preserve">
          <source>During program execution, a counter is incremented at each event encountered. The value of this counter is referred as the &lt;em&gt;current time&lt;/em&gt;. Thanks to reverse execution, it is possible to jump back and forth to any time of the execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45953970e1ac64460d95053cf011f3147fc2549a" translate="yes" xml:space="preserve">
          <source>Dynamic loading of .cmo, .cma and .cmxs files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade230ae2af559c6a2da6c3d0adbdf4a6b8d6c90" translate="yes" xml:space="preserve">
          <source>Dynamic loading of compiled files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ae303d73198569285e7493b0488fa5e452c626" translate="yes" xml:space="preserve">
          <source>Dynamically load the given file, which defines a custom documentation generator. See section &lt;a href=&quot;#ss%3Aocamldoc-compilation-and-usage&quot;&gt;16.4.1&lt;/a&gt;. This option is supported by the ocamldoc command (to load .cmo and .cma files) and by its native-code version ocamldoc.opt (to load .cmxs files). If the given file is a simple one and does not exist in the current directory, then ocamldoc looks for it in the custom generators default directory, and in the directories specified with optional -i options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b629ad314d21b66226424fb0bb2acf4d780051" translate="yes" xml:space="preserve">
          <source>Dynamically, the variable s is bound at the invocation of a method. In particular, when the class printable_point is inherited, the variable s will be correctly bound to the object of the subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1033247aecb214d97e3f11b5184ebfb54ae7b8" translate="yes" xml:space="preserve">
          <source>Dynlink</source>
          <target state="translated">Dynlink</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="5c6318466a052c1420b0b08a980cddb451bd6d60" translate="yes" xml:space="preserve">
          <source>Each different pretty-printing box kind introduces a specific line splitting policy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c16499eb0943acc5eb62a31f9bc88221763dc01" translate="yes" xml:space="preserve">
          <source>Each element kind is represented at the type level by one of the &lt;code&gt;*_elt&lt;/code&gt; types defined below (defined with a single constructor instead of abstract types for technical injectivity reasons).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1caee92a2ad2725943710d2a2bd8290a46c8e471" translate="yes" xml:space="preserve">
          <source>Each layout style is identified at the type level by the phantom types &lt;a href=&quot;bigarray#VALc_layout&quot;&gt;&lt;code&gt;Bigarray.c_layout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray#VALfortran_layout&quot;&gt;&lt;code&gt;Bigarray.fortran_layout&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd355e1568c837c2d8a8aa22882d7a019020c0f" translate="yes" xml:space="preserve">
          <source>Each method may have an explicit polymorphic type: { '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;. Explicit polymorphic variables have a local scope, and an explicit polymorphic type can only be unified to an equivalent one, where only the order and names of polymorphic variables may change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5d98785b7743a02a2a0703c996991daf64afaa" translate="yes" xml:space="preserve">
          <source>Each time a program is started in the debugger, it inherits its working directory from the current working directory of the debugger. This working directory is initially whatever it inherited from its parent process (typically the shell), but you can specify a new working directory in the debugger with the cd command or the -cd command-line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb29aeedb459a9843173566eb9da0953840aa4b6" translate="yes" xml:space="preserve">
          <source>Each time the program performs a function application, it saves the location of the application (the return address) in a block of data called a stack frame. The frame also contains the local variables of the caller function. All the frames are allocated in a region of memory called the call stack. The command backtrace (or bt) displays parts of the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a82f869d0845906f5636307dfedb10af696ef7" translate="yes" xml:space="preserve">
          <source>Each type definition in the signature specifies an optional type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; and an optional type representation =&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; &amp;hellip; or ={&lt;a href=&quot;typedecl#field-decl&quot;&gt;field-decl&lt;/a&gt; &amp;hellip; }. The implementation of the type name in a matching structure must be compatible with the type expression specified in the equation (if given), and have the specified representation (if given). Conversely, users of that signature will be able to rely on the type equation or type representation, if given. More precisely, we have the following four situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7aa85b74327e7f9399b7bfe326e5c61749ad3fe" translate="yes" xml:space="preserve">
          <source>Echo ERASE (to erase previous character).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59905cd91eac129936169f92306974b7eb5df3e3" translate="yes" xml:space="preserve">
          <source>Echo KILL (to erase the current line).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818b41a3180b8626f2b705affbca4a9bb2d1edf0" translate="yes" xml:space="preserve">
          <source>Echo NL even if c_echo is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b12403c7dc9b7aed8fe8263fa437f6a29922cd13" translate="yes" xml:space="preserve">
          <source>Echo input characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790ff9d91988a9f91bae9a1e80b3ea470a8793a7" translate="yes" xml:space="preserve">
          <source>Effects are classified as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fe848d140abbda761fcab4b0a8ee4bff9b5618" translate="yes" xml:space="preserve">
          <source>Element kind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c901356ec250da6646a0d255d0a5012286fed26" translate="yes" xml:space="preserve">
          <source>Element kinds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773ebef232798eb1bcd798e64d46f5fd4d344ed8" translate="yes" xml:space="preserve">
          <source>Elements of this type can still be compared and hashed: when two elements are equal, then they represent the same source location (the converse is not necessarily true in presence of inlining, for example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff0f4a868ef59be803181103a0f8dacda1099dd" translate="yes" xml:space="preserve">
          <source>Ellipsis</source>
          <target state="translated">Ellipsis</target>
        </trans-unit>
        <trans-unit id="a951b7cdcb19dc8f856bf6e83e270d878bd2aebe" translate="yes" xml:space="preserve">
          <source>Emit .inlining files (one per round of optimisation) showing all of the inliner&amp;rsquo;s decisions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b66f486cf8274cb9bca30676fc931fad21f1de5" translate="yes" xml:space="preserve">
          <source>Emit XON/XOFF chars to control input flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6d8285d87efe002dc771b241b8d06271e73877" translate="yes" xml:space="preserve">
          <source>Empty a hash table and shrink the size of the bucket table to its initial size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37b57ef58e23b53c8f30296b9c000edeef1ce74" translate="yes" xml:space="preserve">
          <source>Empty a hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00055027ec241f03bc3323a54fed41f0a8808bad" translate="yes" xml:space="preserve">
          <source>Empty a hash table. Use &lt;code&gt;reset&lt;/code&gt; instead of &lt;code&gt;clear&lt;/code&gt; to shrink the size of the bucket table to its initial size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e879386eb7dfd68165ba47fe880a837898c987" translate="yes" xml:space="preserve">
          <source>Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with the initial internal byte sequence of length &lt;code&gt;n&lt;/code&gt; that was allocated by &lt;a href=&quot;buffer#VALcreate&quot;&gt;&lt;code&gt;Buffer.create&lt;/code&gt;&lt;/a&gt;&lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2a8448f140b28c370341466e87e932ee8786a1" translate="yes" xml:space="preserve">
          <source>Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with the initial internal byte sequence of length &lt;code&gt;n&lt;/code&gt; that was allocated by &lt;a href=&quot;buffer#VALcreate&quot;&gt;&lt;code&gt;Buffer.create&lt;/code&gt;&lt;/a&gt;&lt;code&gt;n&lt;/code&gt;. For long-lived buffers that may have grown a lot, &lt;code&gt;reset&lt;/code&gt; allows faster reclamation of the space used by the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf089f9c5c1c0373c6ce76e0a9cc360bcd1ef69" translate="yes" xml:space="preserve">
          <source>Empty the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00390bd2f9505f4d62d808cec4546f6464f7fed" translate="yes" xml:space="preserve">
          <source>Empty the parser stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f101e78b0fa42d75dcdc4adb6d4084b4a601834d" translate="yes" xml:space="preserve">
          <source>Empty the parser stack. Call it just after a parsing function has returned, to remove all pointers from the parser stack to structures that were built by semantic actions during parsing. This is optional, but lowers the memory requirements of the programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0074df63c6d023e7952d43a2b914df91ffff8c57" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3599d807d73244d1d2b2c6bbb5870d2aa02d3a1a" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal warning number num.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d07d21892b973a86c258d424467b16d34fb15e" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal warnings in the given range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78968437d3375a093ddfb521ecf6242e8d1eedd" translate="yes" xml:space="preserve">
          <source>Enable canonical processing (line buffering and editing)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929680a8eee524b77121874d47b6662082176d5c" translate="yes" xml:space="preserve">
          <source>Enable or disable colors in compiler messages (especially warnings and errors). The following modes are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3548fe32ed1474e82f947e74c5e0161162ca1d4" translate="yes" xml:space="preserve">
          <source>Enable or disable warnings according to the argument.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
