<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="30204445e59c24675d5d45718f49e0d965ced7fa" translate="yes" xml:space="preserve">
          <source>Describe the return value and its possible values. This tag is used for functions and methods.</source>
          <target state="translated">描述返回值及其可能的值。这个标签用于函数和方法。</target>
        </trans-unit>
        <trans-unit id="df6067c118d1f66def5a1a8be905127318b0e21e" translate="yes" xml:space="preserve">
          <source>Descriptions of elements and descriptions in @-tags are handled as follows. If a description for the same element or in the same @-tag of the same element is present in both files, then the description of the .ml file is concatenated to the one in the .mli file, if the corresponding -m flag is given on the command line. If a description is present in the .ml file and not in the .mli file, the .ml description is kept. In either case, all the information given in the .mli file is kept.</source>
          <target state="translated">元素的描述和@标签中的描述按以下方式处理。如果两个文件中都有同一元素的描述或同一元素的 @-tag 中的描述,那么如果在命令行中给出了相应的 -m 标志,那么 .ml 文件中的描述将与 .mli 文件中的描述连接起来。如果在.ml文件中存在描述,而在.mli文件中没有,则保留.ml的描述。无论是哪种情况,都会保留.mli文件中给出的所有信息。</target>
        </trans-unit>
        <trans-unit id="67d799aee373a2f6c263ebf58e0280d66136d9e5" translate="yes" xml:space="preserve">
          <source>Despite &lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt; and &lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt; being lexical entities in expressions, their expansions ~&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;: and ?&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;: will be used in grammars, for the sake of readability. Note also that inside type expressions, this expansion can be taken literally, &lt;em&gt;i.e.&lt;/em&gt; there are really 3 tokens, with optional blanks between them.</source>
          <target state="translated">尽管&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt;和&lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt;在表达式中是词法实体，但它们的扩展〜label &lt;a href=&quot;#label-name&quot;&gt;-name&lt;/a&gt;：和？&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;：出于可读性考虑，将在语法中使用。还要注意，在类型表达式内部，可以按字面意义进行这种扩展，&lt;em&gt;即&lt;/em&gt;实际上有3个标记，它们之间带有可选的空格。</target>
        </trans-unit>
        <trans-unit id="f6f646066bdf4b1ec66764f189ea43f9555404f9" translate="yes" xml:space="preserve">
          <source>Destination address required</source>
          <target state="translated">要求提供目的地地址</target>
        </trans-unit>
        <trans-unit id="70d38e034fc41445f66a84bbc7421aae75cb369d" translate="yes" xml:space="preserve">
          <source>Determine whether it is clear that inlining would be beneficial without, for the moment, doing any inlining within the function itself. (The exact assessment of &lt;em&gt;benefit&lt;/em&gt; is described below.) If so, the function is inlined.</source>
          <target state="translated">确定是否当前无需在函数本身中进行任何内联操作是否显然会有利于内联代码。（对&lt;em&gt;收益&lt;/em&gt;的确切评估如下所述。）如果是，则内联函数。</target>
        </trans-unit>
        <trans-unit id="fe861f03852b09cf76716d7e041be8378ee86f6e" translate="yes" xml:space="preserve">
          <source>Device ID (if special file)</source>
          <target state="translated">设备ID(如果是特殊文件)</target>
        </trans-unit>
        <trans-unit id="6fa7dda8b47dbe32f43cc7e7cbb154977cdd4b4b" translate="yes" xml:space="preserve">
          <source>Device number</source>
          <target state="translated">设备编号</target>
        </trans-unit>
        <trans-unit id="47fdd58bee4dc86df2b978107102a22b9c44345b" translate="yes" xml:space="preserve">
          <source>Digest</source>
          <target state="translated">Digest</target>
        </trans-unit>
        <trans-unit id="03b5690384bc40a11bbb9c00e423e54e65806954" translate="yes" xml:space="preserve">
          <source>Direct call site</source>
          <target state="translated">直接调用网站</target>
        </trans-unit>
        <trans-unit id="6511f8b22675dad2defbfb3fe082bbb561af35ab" translate="yes" xml:space="preserve">
          <source>Direct the memory manager to print some progress messages on standard error. This is equivalent to setting v=63 in the OCAMLRUNPARAM environment variable (see below).</source>
          <target state="translated">指导内存管理器在标准错误上打印一些进度信息。这相当于在OCAMLRUNPARAM环境变量中设置v=63(见下文)。</target>
        </trans-unit>
        <trans-unit id="1029544ae8b46287a52a74595462c217cf60a5a9" translate="yes" xml:space="preserve">
          <source>Directories</source>
          <target state="translated">Directories</target>
        </trans-unit>
        <trans-unit id="6c8a1a100ae0fc810383f2b9a2878d99ecc4ed7c" translate="yes" xml:space="preserve">
          <source>Directories added with the #directory directive.</source>
          <target state="translated">用#directory指令添加的目录。</target>
        </trans-unit>
        <trans-unit id="4a48b55c29dbb8b43614e52d542f4945826048dc" translate="yes" xml:space="preserve">
          <source>Directories can also be added to the list once the toplevel is running with the #directory directive (section &amp;zwj;&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;).</source>
          <target state="translated">目录还可以一次性顶层与#directory指令（区间行驶添加到列表&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2d54c02b2c2c47443482e970156b799ac791785a" translate="yes" xml:space="preserve">
          <source>Directories can also be added to the list once the toplevel is running with the #directory directive (section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;).</source>
          <target state="translated">一旦使用#directory指令（第&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;节）运行顶层，目录也可以添加到列表中。</target>
        </trans-unit>
        <trans-unit id="baa1af9dcf811b5cb577d789120d5a9a8e401eb8" translate="yes" xml:space="preserve">
          <source>Directories given on the command line with -I options.</source>
          <target state="translated">在命令行上用-I选项给出的目录。</target>
        </trans-unit>
        <trans-unit id="4fca1322bb244459d6be50257fca52fdf7eac5df" translate="yes" xml:space="preserve">
          <source>Directories specified at link-time via the -dllpath option to ocamlc. (These directories are recorded in the bytecode executable file.)</source>
          <target state="translated">ocamlc在链接时通过-dllpath选项指定的目录。(这些目录记录在bytecode可执行文件中。)</target>
        </trans-unit>
        <trans-unit id="ff079471e218f45b2873844ac43f1b9da8c17ff6" translate="yes" xml:space="preserve">
          <source>Directories specified in the CAML_LD_LIBRARY_PATH environment variable.</source>
          <target state="translated">在环境变量CAML_LD_LIBRARY_PATH中指定的目录。</target>
        </trans-unit>
        <trans-unit id="fea42a5c86d3619520a1c10b093343dc1f30f5a2" translate="yes" xml:space="preserve">
          <source>Directories specified in the file ld.conf. This file resides in the OCaml standard library directory, and lists directory names (one per line) to be searched. Typically, it contains only one line naming the stublibs subdirectory of the OCaml standard library directory. Users can add there the names of other directories containing frequently-used shared libraries; however, for consistency of installation, we recommend that shared libraries are installed directly in the system stublibs directory, rather than adding lines to the ld.conf file.</source>
          <target state="translated">ld.conf文件中指定的目录。这个文件驻留在OCaml标准库目录中,列出了要搜索的目录名(每行一个)。通常,它只包含一行命名为OCaml标准库目录下的stublibs子目录。用户可以在那里添加包含经常使用的共享库的其他目录的名称;但是,为了安装的一致性,我们建议将共享库直接安装在系统stublibs目录中,而不是在ld.conf文件中添加行。</target>
        </trans-unit>
        <trans-unit id="4425c83626ad0d492312630fa584010dc2ea7687" translate="yes" xml:space="preserve">
          <source>Directories specified on the ocamlrun command line with the -I option.</source>
          <target state="translated">ocamlrun命令行中使用-I选项指定的目录。</target>
        </trans-unit>
        <trans-unit id="4b892fe0c040fa8a944037d1d2817c41ab7da958" translate="yes" xml:space="preserve">
          <source>Directory</source>
          <target state="translated">Directory</target>
        </trans-unit>
        <trans-unit id="ca827528d6904965fcebbbcad976a987f5f845b3" translate="yes" xml:space="preserve">
          <source>Directory not empty</source>
          <target state="translated">目录不为空</target>
        </trans-unit>
        <trans-unit id="77ccc74e22667a82ec8374d5503fa0741496e682" translate="yes" xml:space="preserve">
          <source>Disable flush after INTR, QUIT, SUSP.</source>
          <target state="translated">在INTR、QUIT、SUSP之后禁止刷新。</target>
        </trans-unit>
        <trans-unit id="8e4bdf9a6eacfa2697016cd0108d461fcf7421b2" translate="yes" xml:space="preserve">
          <source>Disable the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="translated">禁用与字母对应的一组警告。字母可以是大写或小写。</target>
        </trans-unit>
        <trans-unit id="1dcea52c1515117c58919743de2a2da57c540121" translate="yes" xml:space="preserve">
          <source>Disable the set of warnings corresponding to lowercase-letter.</source>
          <target state="translated">禁用与小写字母相对应的一组警告。</target>
        </trans-unit>
        <trans-unit id="9ef4164464d22d55593d17035a42a776c7313713" translate="yes" xml:space="preserve">
          <source>Disable warning name.</source>
          <target state="translated">禁用警告名称。</target>
        </trans-unit>
        <trans-unit id="c19f04c2757dbb7f8de14c35e1cce96d6a55c8a6" translate="yes" xml:space="preserve">
          <source>Disable warning number num.</source>
          <target state="translated">禁用警告编号。</target>
        </trans-unit>
        <trans-unit id="aec8cd3e0abf9d3de01b24e3782506475ae87211" translate="yes" xml:space="preserve">
          <source>Disable warnings in the given range.</source>
          <target state="translated">在给定范围内禁用警告。</target>
        </trans-unit>
        <trans-unit id="eff551fe5c7d7e0f50ac103c39a57bea5895ef26" translate="yes" xml:space="preserve">
          <source>Disambiguated constructor or label name (compatibility warning).</source>
          <target state="translated">已拆分的构造函数或标签名称(兼容性警告)。</target>
        </trans-unit>
        <trans-unit id="b228a139422f11ea4357c7d2efc32f85d808b19b" translate="yes" xml:space="preserve">
          <source>Discard all elements from a queue.</source>
          <target state="translated">丢弃队列中的所有元素。</target>
        </trans-unit>
        <trans-unit id="a763423157ebaef14af264de95dfd62aeae53cfc" translate="yes" xml:space="preserve">
          <source>Discard all elements from a stack.</source>
          <target state="translated">丢弃堆栈中的所有元素。</target>
        </trans-unit>
        <trans-unit id="85ac75ec9ac382b61445173e38bfa779b2b19f5c" translate="yes" xml:space="preserve">
          <source>Discard data written on the given file descriptor but not yet transmitted, or data received but not yet read, depending on the second argument: &lt;code&gt;TCIFLUSH&lt;/code&gt; flushes data received but not read, &lt;code&gt;TCOFLUSH&lt;/code&gt; flushes data written but not transmitted, and &lt;code&gt;TCIOFLUSH&lt;/code&gt; flushes both.</source>
          <target state="translated">丢弃写在给定文件描述符上但尚未发送的数据，或已接收但尚未读取的数据，这取决于第二个参数： &lt;code&gt;TCIFLUSH&lt;/code&gt; 刷新已接收但未读取的数据， &lt;code&gt;TCOFLUSH&lt;/code&gt; 刷新已写入但未发送的数据，而 &lt;code&gt;TCIOFLUSH&lt;/code&gt; 刷新了两者。</target>
        </trans-unit>
        <trans-unit id="57521250b5897b35eb18446005dde0a337ba5726" translate="yes" xml:space="preserve">
          <source>Discard the contents of the buffer and reset the current position to 0.</source>
          <target state="translated">丢弃缓冲区的内容,并将当前位置重置为0。</target>
        </trans-unit>
        <trans-unit id="c324ee3bd77d8cdc9882e8d0fc0aa86700e2b4ff" translate="yes" xml:space="preserve">
          <source>Discard the contents of the buffer and reset the current position to 0. The next use of the lexbuf will trigger a refill.</source>
          <target state="translated">丢弃缓冲区的内容,并将当前位置重置为0,下一次使用lexbuf将触发重新填充。</target>
        </trans-unit>
        <trans-unit id="3a3793c75090c266feef9865c31883fbe011f366" translate="yes" xml:space="preserve">
          <source>Discard the value of its argument and return &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">舍弃其参数的值，然后返回 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59e4d950f2d4305046840b504d37718518d243de" translate="yes" xml:space="preserve">
          <source>Discard the value of its argument and return &lt;code&gt;()&lt;/code&gt;. For instance, &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; discards the result of the side-effecting function &lt;code&gt;f&lt;/code&gt;. It is equivalent to &lt;code&gt;f&amp;nbsp;x;&amp;nbsp;()&lt;/code&gt;, except that the latter may generate a compiler warning; writing &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; instead avoids the warning.</source>
          <target state="translated">舍弃其参数的值，然后返回 &lt;code&gt;()&lt;/code&gt; 。例如， &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; 丢弃副作用函数 &lt;code&gt;f&lt;/code&gt; 的结果。等效于 &lt;code&gt;f&amp;nbsp;x;&amp;nbsp;()&lt;/code&gt; ，但后者可能会生成编译器警告；编写 &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; 可以避免该警告。</target>
        </trans-unit>
        <trans-unit id="7e3db82a71cdff092fe3c4e674d2cf59d344c98c" translate="yes" xml:space="preserve">
          <source>Display a short usage summary and exit.</source>
          <target state="translated">显示简短的使用总结并退出。</target>
        </trans-unit>
        <trans-unit id="35dc839559848f5eb2c3fe73488f70904e3ae41c" translate="yes" xml:space="preserve">
          <source>Display the complete list of parameters for functions and methods.</source>
          <target state="translated">显示函数和方法的完整参数列表。</target>
        </trans-unit>
        <trans-unit id="d83946df95c85b27e03a0eceda28c6b18faddcf0" translate="yes" xml:space="preserve">
          <source>Display the custom generators default directory.</source>
          <target state="translated">显示自定义生成器的默认目录。</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="bb0b39421708c74d96ba3086b89cc7167e7a950b" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; set the -custom flag, otherwise you&amp;rsquo;re back to static linking as described in section &amp;zwj;&lt;a href=&quot;#ss%3Astaticlink-c-code&quot;&gt;18.1.3&lt;/a&gt;. The ocamlmklib tool (see section &amp;zwj;&lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;18.14&lt;/a&gt;) automates steps 2 and 3.</source>
          <target state="translated">难道&lt;em&gt;不&lt;/em&gt;设置-custom标志，否则你在节中描述又回到静态链接&lt;a href=&quot;#ss%3Astaticlink-c-code&quot;&gt;18.1.3&lt;/a&gt;。所述ocamlmklib工具（见&lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;18.14&lt;/a&gt;）自动化步骤2和3。</target>
        </trans-unit>
        <trans-unit id="c1615505a10cd0a8a96dbd7380ce2c53780aa017" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; set the -custom flag, otherwise you&amp;rsquo;re back to static linking as described in section &lt;a href=&quot;#ss%3Astaticlink-c-code&quot;&gt;20.1.3&lt;/a&gt;. The ocamlmklib tool (see section &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;) automates steps 2 and 3.</source>
          <target state="translated">难道&lt;em&gt;不&lt;/em&gt;设置-custom标志，否则你在节中描述又回到静态链接&lt;a href=&quot;#ss%3Astaticlink-c-code&quot;&gt;20.1.3&lt;/a&gt;。ocamlmklib工具（请参阅第&lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;节）可自动执行步骤2和3。</target>
        </trans-unit>
        <trans-unit id="4c47225fbda414465a615e36d4177b55dd3eaa1c" translate="yes" xml:space="preserve">
          <source>Do a minor collection and finish the current major collection cycle.</source>
          <target state="translated">做一个小收藏,完成当前的大收藏周期。</target>
        </trans-unit>
        <trans-unit id="7e67bacde12033f167102017edabc6ea724d07c0" translate="yes" xml:space="preserve">
          <source>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle.</source>
          <target state="translated">做一个小收藏,完成当前的大收藏周期,再进行一个完整的新周期。</target>
        </trans-unit>
        <trans-unit id="04b6ceedb393ff292e5063adf221897afc4e187a" translate="yes" xml:space="preserve">
          <source>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.</source>
          <target state="translated">进行小规模采集,完成当前的大采集周期,并执行一个完整的新周期。这将收集所有当前无法到达的区块。</target>
        </trans-unit>
        <trans-unit id="0daaabef3025f3c8281acefcdc36265b713e5d45" translate="yes" xml:space="preserve">
          <source>Do not add current working directory to the list of include directories.</source>
          <target state="translated">不要将当前工作目录添加到包含目录列表中。</target>
        </trans-unit>
        <trans-unit id="3dd7890c2ce3ba2fa05e54db340e3592fbf7c610" translate="yes" xml:space="preserve">
          <source>Do not allow custom @-tags (see section &lt;a href=&quot;#ss%3Aocamldoc-tags&quot;&gt;15.2.5&lt;/a&gt;).</source>
          <target state="translated">不允许使用自定义@标签（请参见&lt;a href=&quot;#ss%3Aocamldoc-tags&quot;&gt;15.2.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0dd6861951e2b753da997ead7a08426d22baa2a3" translate="yes" xml:space="preserve">
          <source>Do not allow custom @-tags (see section &lt;a href=&quot;#ss%3Aocamldoc-tags&quot;&gt;16.2.5&lt;/a&gt;).</source>
          <target state="translated">不允许使用自定义@标签（请参阅第&lt;a href=&quot;#ss%3Aocamldoc-tags&quot;&gt;16.2.5&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="7ddb859954f4b0f1267022be18664ce369f4d72a" translate="yes" xml:space="preserve">
          <source>Do not automatically add the standard library directory to the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmx), and libraries (.cmxa). See also option -I.</source>
          <target state="translated">不要自动将标准库目录添加到搜索编译接口文件(.cmi)、编译对象代码文件(.cmx)和库(.cmxa)的目录列表中。也请参见选项-I。</target>
        </trans-unit>
        <trans-unit id="4b22d46ee16ff416c80772315f7396494ea3fc5e" translate="yes" xml:space="preserve">
          <source>Do not block if no child has died yet, but immediately return with a pid equal to 0.</source>
          <target state="translated">如果还没有孩子死亡,不要阻挡,而是立即返回,pid等于0。</target>
        </trans-unit>
        <trans-unit id="031865d55aa41b6e70421f3ce5c1a293a99cbfc7" translate="yes" xml:space="preserve">
          <source>Do not build index for Info files.</source>
          <target state="translated">不要为信息文件建立索引。</target>
        </trans-unit>
        <trans-unit id="3dd45f175e92b8eaae1b91c01a1d09ad1da05182" translate="yes" xml:space="preserve">
          <source>Do not call name resolver, expect numeric IP address</source>
          <target state="translated">不要调用名称解析器,要调用数字IP地址</target>
        </trans-unit>
        <trans-unit id="f826060748a4f9075bc43b6d058cc0ba05d77389" translate="yes" xml:space="preserve">
          <source>Do not compile assertion checks. Note that the special form assert false is always compiled because it is typed specially.</source>
          <target state="translated">不要编译断言检查。请注意,特殊形式的 assert false 总是被编译,因为它是特殊类型。</target>
        </trans-unit>
        <trans-unit id="28cdfa96ccebfb982ad25f616a5461bcce5db594" translate="yes" xml:space="preserve">
          <source>Do not compile assertion checks. Note that the special form assert false is always compiled because it is typed specially. This flag has no effect when linking already-compiled files.</source>
          <target state="translated">不要编译断言检查。请注意,特殊形式的 assert false 总是被编译,因为它是特殊输入的。这个标志在链接已经编译的文件时没有效果。</target>
        </trans-unit>
        <trans-unit id="6b4151d019da73db9b1b47237e17df5a70d431b4" translate="yes" xml:space="preserve">
          <source>Do not display any prompt when waiting for input.</source>
          <target state="translated">等待输入时不显示任何提示。</target>
        </trans-unit>
        <trans-unit id="4587f67b20caed188543780983919bc73577d989" translate="yes" xml:space="preserve">
          <source>Do not display the secondary prompt when waiting for continuation lines in multi-line inputs. This should be used e.g. when running ocaml in an emacs window.</source>
          <target state="translated">在多行输入中等待续行时,不显示辅助提示。例如,在emacs窗口中运行ocaml时,应该使用这个功能。</target>
        </trans-unit>
        <trans-unit id="87cc23e1ce95050f53c83e4fc4b5197b57a26719" translate="yes" xml:space="preserve">
          <source>Do not generate a table of contents.</source>
          <target state="translated">不要生成目录。</target>
        </trans-unit>
        <trans-unit id="c19a0b4c326541165d9a51372f39e571198ccf18" translate="yes" xml:space="preserve">
          <source>Do not include the standard library directory in the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmo), libraries (.cma), and C libraries specified with -cclib -lxxx. See also option -I.</source>
          <target state="translated">不要将标准库目录包含在搜索编译接口文件(.cmi)、编译对象代码文件(.cmo)、库(.cma)和用-cclib -lxxx指定的C库的目录列表中。也请参见选项-I。</target>
        </trans-unit>
        <trans-unit id="064821cea7940442efa1520725382b3b4955526f" translate="yes" xml:space="preserve">
          <source>Do not include the standard library directory in the list of directories searched for source and compiled files.</source>
          <target state="translated">在搜索源文件和编译文件的目录列表中不要包含标准库目录。</target>
        </trans-unit>
        <trans-unit id="253be060206824d9b4dd7af9b8790b6551c7c9cd" translate="yes" xml:space="preserve">
          <source>Do not print OCamldoc warnings.</source>
          <target state="translated">不要打印OCamldoc警告。</target>
        </trans-unit>
        <trans-unit id="d0e3c326d3220da0354ae7c4e91ad6fb36af0dbe" translate="yes" xml:space="preserve">
          <source>Do not print the version banner at startup.</source>
          <target state="translated">不要在启动时打印版本横幅。</target>
        </trans-unit>
        <trans-unit id="a518f2812d3306324e4ce68e86acbedd313390cc" translate="yes" xml:space="preserve">
          <source>Do not qualify local host names</source>
          <target state="translated">不要限定本地主机名</target>
        </trans-unit>
        <trans-unit id="16b56f76422b5467ff2de7356baf0b5b88e576be" translate="yes" xml:space="preserve">
          <source>Do not record dependencies for module aliases. See section &amp;zwj;&lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;8.8&lt;/a&gt; for more information.</source>
          <target state="translated">不要记录模块别名的依赖性。见&lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;8.8&lt;/a&gt;获取更多信息。</target>
        </trans-unit>
        <trans-unit id="15165b95be0530c8689212758b6f87ed55a19591" translate="yes" xml:space="preserve">
          <source>Do not record dependencies for module aliases. See section &lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;8.8&lt;/a&gt; for more information.</source>
          <target state="translated">不要记录模块别名的依赖性。有关更多信息，请参见第&lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;8.8&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="0db8b04be0905bec57639b1ec69a076541e4c89e" translate="yes" xml:space="preserve">
          <source>Do not unbox arguments to which functions have been specialised. See section &lt;a href=&quot;#ss%3Aflambda-unbox-spec-args&quot;&gt;19.9.2&lt;/a&gt;.</source>
          <target state="translated">请勿取消对已专门处理功能的参数进行开箱。参见第&lt;a href=&quot;#ss%3Aflambda-unbox-spec-args&quot;&gt;19.9.2&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="17c810b750e959c8744be3fb11ef3f3b863e75d1" translate="yes" xml:space="preserve">
          <source>Do not unbox arguments to which functions have been specialised. See section &lt;a href=&quot;#ss%3Aflambda-unbox-spec-args&quot;&gt;21.9.2&lt;/a&gt;.</source>
          <target state="translated">请勿取消对已专门处理功能的参数进行开箱。参见第&lt;a href=&quot;#ss%3Aflambda-unbox-spec-args&quot;&gt;21.9.2&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="dfc7ce8fc64c8fb7fb74caa7f49fd703ae2af2a3" translate="yes" xml:space="preserve">
          <source>Do not unbox closure variables. See section &lt;a href=&quot;#ss%3Aflambda-unbox-fvs&quot;&gt;19.9.1&lt;/a&gt;.</source>
          <target state="translated">不要取消封闭变量的装箱。参见第&lt;a href=&quot;#ss%3Aflambda-unbox-fvs&quot;&gt;19.9.1&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="94446f6fa3c2614682fdb6a2f38f1eea9d15a5cd" translate="yes" xml:space="preserve">
          <source>Do not unbox closure variables. See section &lt;a href=&quot;#ss%3Aflambda-unbox-fvs&quot;&gt;21.9.1&lt;/a&gt;.</source>
          <target state="translated">不要取消封闭变量的装箱。参见第&lt;a href=&quot;#ss%3Aflambda-unbox-fvs&quot;&gt;21.9.1&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="83efe30f6e83b800163ecbaf2a13c9f7320f78be" translate="yes" xml:space="preserve">
          <source>Do note that the indices passed to &lt;code&gt;f&lt;/code&gt; may not start at &lt;code&gt;0&lt;/code&gt; in the general case. For example, &lt;code&gt;[&amp;lt;&amp;nbsp;'0;&amp;nbsp;'1;&amp;nbsp;Stream.from&amp;nbsp;f&amp;nbsp;&amp;gt;]&lt;/code&gt; would call &lt;code&gt;f&lt;/code&gt; the first time with count &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">请注意，通常情况下，传递给 &lt;code&gt;f&lt;/code&gt; 的索引可能不会从 &lt;code&gt;0&lt;/code&gt; 开始。例如， &lt;code&gt;[&amp;lt;&amp;nbsp;'0;&amp;nbsp;'1;&amp;nbsp;Stream.from&amp;nbsp;f&amp;nbsp;&amp;gt;]&lt;/code&gt; 将第一次调用 &lt;code&gt;f&lt;/code&gt; ，计数为 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e115cdb1fc49a35afc65cded140e7aac8702d30d" translate="yes" xml:space="preserve">
          <source>Documentation and user&amp;rsquo;s manual</source>
          <target state="translated">文档和用户手册</target>
        </trans-unit>
        <trans-unit id="35ee6007715742773c38d4eb75befc2fcd192d39" translate="yes" xml:space="preserve">
          <source>Domain error for math functions, etc.</source>
          <target state="translated">数学函数的域误差等。</target>
        </trans-unit>
        <trans-unit id="cbb4365752b3a355adb85f2c09fa26922f6de928" translate="yes" xml:space="preserve">
          <source>Don't make this dev a controlling tty</source>
          <target state="translated">不要让这个开发成为一个控制型的TTY。</target>
        </trans-unit>
        <trans-unit id="e2c9fea25fd7a1fe50f26d27cf3ecd6a65b6a25b" translate="yes" xml:space="preserve">
          <source>Don't preserve sharing</source>
          <target state="translated">不要保存分享</target>
        </trans-unit>
        <trans-unit id="50c809cff2d695209e704f8197dab6f54e225936" translate="yes" xml:space="preserve">
          <source>Double the default</source>
          <target state="translated">双倍的默认值</target>
        </trans-unit>
        <trans-unit id="15e85994c9a5443f990f6afb5b898c774627a852" translate="yes" xml:space="preserve">
          <source>Double_array_tag</source>
          <target state="translated">Double_array_tag</target>
        </trans-unit>
        <trans-unit id="ca8bf75e9f0596d733ef4d95e5e307e4a331e94d" translate="yes" xml:space="preserve">
          <source>Double_field(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; element of the array of floating-point numbers v (a block tagged Double_array_tag).</source>
          <target state="translated">Double_field（v，n）返回浮点数v数组（标记为Double_array_tag的块）的第n&lt;sup&gt;个&lt;/sup&gt;元素。</target>
        </trans-unit>
        <trans-unit id="1c671ea4bfc33386e2575fa5b03150428efb4ede" translate="yes" xml:space="preserve">
          <source>Double_tag</source>
          <target state="translated">Double_tag</target>
        </trans-unit>
        <trans-unit id="bbc4dbcceef59b6f089abaa4a71a66bb23b3e7be" translate="yes" xml:space="preserve">
          <source>Double_val(v) returns the floating-point number contained in value v, with type double.</source>
          <target state="translated">Double_val(v)返回值 v 中包含的浮点数,类型为 double。</target>
        </trans-unit>
        <trans-unit id="85e07ec423183b97e7e54906d287288e1be1ffc2" translate="yes" xml:space="preserve">
          <source>Due to the way that format string are build, storing a format string requires an explicit type annotation:</source>
          <target state="translated">由于格式字符串的构建方式,存储格式字符串需要一个显式类型注释。</target>
        </trans-unit>
        <trans-unit id="38da2b2f7c5e5067497c455981267218324b40aa" translate="yes" xml:space="preserve">
          <source>Dump collected information into file. This information can be read with the -load option in a subsequent invocation of ocamldoc.</source>
          <target state="translated">将收集到的信息转储到文件中。这些信息可以在后续调用ocamldoc时用-load选项读取。</target>
        </trans-unit>
        <trans-unit id="3f7d57f9e20eda3c41fb941c658194cfee284a2a" translate="yes" xml:space="preserve">
          <source>Dump detailed information about the compilation (types, bindings, tail-calls, etc) in binary format. The information for file src.ml (resp. src.mli) is put into file src.cmt (resp. src.cmti). In case of a type error, dump all the information inferred by the type-checker before the error. The *.cmt and *.cmti files produced by -bin-annot contain more information and are much more compact than the files produced by -annot.</source>
          <target state="translated">以二进制格式转储有关编译的详细信息 (类型、绑定、尾部调用等)。文件 src.ml (resp.src.mli)的信息被放入文件 src.cmt (resp.src.cmti)。如果出现类型错误,则转储类型检查器在错误前推断的所有信息。由 -bin-annot 产生的 *.cmt 和 *.cmti 文件包含更多信息,而且比 -annot 产生的文件更紧凑。</target>
        </trans-unit>
        <trans-unit id="d734c14d897b78ff2c878be1ef4830dddaf75aad" translate="yes" xml:space="preserve">
          <source>Dump the delayed dependency map for each map file.</source>
          <target state="translated">为每个地图文件转储延迟的依赖关系图。</target>
        </trans-unit>
        <trans-unit id="e11fe1c6936a32f898ab53021b1b505b77ad3f51" translate="yes" xml:space="preserve">
          <source>During execution of an ocamlopt-generated executable, the following environment variables are also consulted:</source>
          <target state="translated">在执行ocamlopt生成的可执行文件的过程中,也会参考以下环境变量。</target>
        </trans-unit>
        <trans-unit id="a527567660be56f12ce37a951df19c1ce6570fac" translate="yes" xml:space="preserve">
          <source>During execution, a trace file will be generated in the program&amp;rsquo;s current working directory.</source>
          <target state="translated">在执行过程中，将在程序的当前工作目录中生成跟踪文件。</target>
        </trans-unit>
        <trans-unit id="52da08cd6051434fc2f3b7662122ca9fcd53bd40" translate="yes" xml:space="preserve">
          <source>During program execution, a counter is incremented at each event encountered. The value of this counter is referred as the &lt;em&gt;current time&lt;/em&gt;. Thanks to reverse execution, it is possible to jump back and forth to any time of the execution.</source>
          <target state="translated">在程序执行期间，每个遇到的事件都会增加一个计数器。该计数器的值称为&lt;em&gt;当前时间&lt;/em&gt;。得益于反向执行，可以来回跳转到执行的任何时间。</target>
        </trans-unit>
        <trans-unit id="45953970e1ac64460d95053cf011f3147fc2549a" translate="yes" xml:space="preserve">
          <source>Dynamic loading of .cmo, .cma and .cmxs files.</source>
          <target state="translated">动态加载.cmo、.cma和.cmxs文件。</target>
        </trans-unit>
        <trans-unit id="ade230ae2af559c6a2da6c3d0adbdf4a6b8d6c90" translate="yes" xml:space="preserve">
          <source>Dynamic loading of compiled files</source>
          <target state="translated">动态加载编译后的文件</target>
        </trans-unit>
        <trans-unit id="98aeff1158e04a667ddf49829087d0f2b6adbd56" translate="yes" xml:space="preserve">
          <source>Dynamically load the given file, which defines a custom documentation generator. See section &lt;a href=&quot;#ss%3Aocamldoc-compilation-and-usage&quot;&gt;15.4.1&lt;/a&gt;. This option is supported by the ocamldoc command (to load .cmo and .cma files) and by its native-code version ocamldoc.opt (to load .cmxs files). If the given file is a simple one and does not exist in the current directory, then ocamldoc looks for it in the custom generators default directory, and in the directories specified with optional -i options.</source>
          <target state="translated">动态加载给定文件，该文件定义了自定义文档生成器。参见&lt;a href=&quot;#ss%3Aocamldoc-compilation-and-usage&quot;&gt;15.4.1&lt;/a&gt;节。ocamldoc命令（用于加载.cmo和.cma文件）及其本机代码版本ocamldoc.opt（用于加载.cmxs文件）都支持此选项。如果给定文件是简单文件，并且在当前目录中不存在，则ocamldoc在自定义生成器默认目录以及使用可选-i选项指定的目录中查找该文件。</target>
        </trans-unit>
        <trans-unit id="00ae303d73198569285e7493b0488fa5e452c626" translate="yes" xml:space="preserve">
          <source>Dynamically load the given file, which defines a custom documentation generator. See section &lt;a href=&quot;#ss%3Aocamldoc-compilation-and-usage&quot;&gt;16.4.1&lt;/a&gt;. This option is supported by the ocamldoc command (to load .cmo and .cma files) and by its native-code version ocamldoc.opt (to load .cmxs files). If the given file is a simple one and does not exist in the current directory, then ocamldoc looks for it in the custom generators default directory, and in the directories specified with optional -i options.</source>
          <target state="translated">动态加载给定文件，该文件定义了自定义文档生成器。参见&lt;a href=&quot;#ss%3Aocamldoc-compilation-and-usage&quot;&gt;16.4.1&lt;/a&gt;节。ocamldoc命令（用于加载.cmo和.cma文件）及其本机代码版本ocamldoc.opt（用于加载.cmxs文件）都支持此选项。如果给定文件是简单文件，并且在当前目录中不存在，则ocamldoc在自定义生成器默认目录以及使用可选-i选项指定的目录中查找该文件。</target>
        </trans-unit>
        <trans-unit id="72b629ad314d21b66226424fb0bb2acf4d780051" translate="yes" xml:space="preserve">
          <source>Dynamically, the variable s is bound at the invocation of a method. In particular, when the class printable_point is inherited, the variable s will be correctly bound to the object of the subclass.</source>
          <target state="translated">动态地,变量s在方法调用时就会被绑定。特别是当类printable_point被继承时,变量s将被正确地绑定到子类的对象上。</target>
        </trans-unit>
        <trans-unit id="1f1033247aecb214d97e3f11b5184ebfb54ae7b8" translate="yes" xml:space="preserve">
          <source>Dynlink</source>
          <target state="translated">Dynlink</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="70db15ec7bed556e4633764535385f7e74ef7b9e" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;raw_backtrace_entry&lt;/code&gt; is an opaque integer, whose value is not stable between different programs, or even between different runs of the same binary.</source>
          <target state="translated">每个 &lt;code&gt;raw_backtrace_entry&lt;/code&gt; 是一个不透明的整数，其值在不同程序之间甚至在同一二进制文件的不同运行之间均不稳定。</target>
        </trans-unit>
        <trans-unit id="5c6318466a052c1420b0b08a980cddb451bd6d60" translate="yes" xml:space="preserve">
          <source>Each different pretty-printing box kind introduces a specific line splitting policy:</source>
          <target state="translated">每一种不同的漂亮印刷盒种类都会推出具体的分线政策。</target>
        </trans-unit>
        <trans-unit id="0503547a4c6634bc9fe4455fc2d6a9b990047b2c" translate="yes" xml:space="preserve">
          <source>Each element &lt;code&gt;Array1.get&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; of the array is initialized to the result of &lt;code&gt;f&amp;nbsp;i&lt;/code&gt;.</source>
          <target state="translated">数组的每个元素 &lt;code&gt;Array1.get&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; 都初始化为 &lt;code&gt;f&amp;nbsp;i&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="029dd58f101f6688e68809f371f374ffac4c91a8" translate="yes" xml:space="preserve">
          <source>Each element &lt;code&gt;Array2.get&amp;nbsp;b&amp;nbsp;i&amp;nbsp;j&lt;/code&gt; of the array is initialized to the result of &lt;code&gt;f&amp;nbsp;i&amp;nbsp;j&lt;/code&gt;.</source>
          <target state="translated">将数组的每个元素 &lt;code&gt;Array2.get&amp;nbsp;b&amp;nbsp;i&amp;nbsp;j&lt;/code&gt; 初始化为 &lt;code&gt;f&amp;nbsp;i&amp;nbsp;j&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="ecfafd4656fbe1fd5eafc5840e7eca8ca0f6b851" translate="yes" xml:space="preserve">
          <source>Each element &lt;code&gt;Array3.get&amp;nbsp;b&amp;nbsp;i&amp;nbsp;j&amp;nbsp;k&lt;/code&gt; of the array is initialized to the result of &lt;code&gt;f&amp;nbsp;i&amp;nbsp;j&amp;nbsp;k&lt;/code&gt;.</source>
          <target state="translated">数组的每个元素 &lt;code&gt;Array3.get&amp;nbsp;b&amp;nbsp;i&amp;nbsp;j&amp;nbsp;k&lt;/code&gt; 都初始化为 &lt;code&gt;f&amp;nbsp;i&amp;nbsp;j&amp;nbsp;k&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="fd84c12828239ce3844f7ffbe84b5f46c226047b" translate="yes" xml:space="preserve">
          <source>Each element &lt;code&gt;Genarray.get&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is initialized to the result of &lt;code&gt;f&amp;nbsp;i&lt;/code&gt;. In other words, &lt;code&gt;Genarray.init&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;dimensions&amp;nbsp;f&lt;/code&gt; tabulates the results of &lt;code&gt;f&lt;/code&gt; applied to the indices of a new Bigarray whose layout is described by &lt;code&gt;kind&lt;/code&gt;, &lt;code&gt;layout&lt;/code&gt; and &lt;code&gt;dimensions&lt;/code&gt;. The index array &lt;code&gt;i&lt;/code&gt; may be shared and mutated between calls to f.</source>
          <target state="translated">每个元素 &lt;code&gt;Genarray.get&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; 都初始化为 &lt;code&gt;f&amp;nbsp;i&lt;/code&gt; 的结果。换句话说， &lt;code&gt;Genarray.init&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;dimensions&amp;nbsp;f&lt;/code&gt; 制成表格的结果 &lt;code&gt;f&lt;/code&gt; 施加到一个新的Bigarray其布局是由描述的索引 &lt;code&gt;kind&lt;/code&gt; ， &lt;code&gt;layout&lt;/code&gt; 和 &lt;code&gt;dimensions&lt;/code&gt; 。索引数组 &lt;code&gt;i&lt;/code&gt; 可以在对f的调用之间共享和变异。</target>
        </trans-unit>
        <trans-unit id="2c16499eb0943acc5eb62a31f9bc88221763dc01" translate="yes" xml:space="preserve">
          <source>Each element kind is represented at the type level by one of the &lt;code&gt;*_elt&lt;/code&gt; types defined below (defined with a single constructor instead of abstract types for technical injectivity reasons).</source>
          <target state="translated">每种元素类型在类型级别上由以下定义的 &lt;code&gt;*_elt&lt;/code&gt; 类型之一表示（出于技术上的可插入性原因，使用单个构造函数而不是抽象类型进行定义）。</target>
        </trans-unit>
        <trans-unit id="1caee92a2ad2725943710d2a2bd8290a46c8e471" translate="yes" xml:space="preserve">
          <source>Each layout style is identified at the type level by the phantom types &lt;a href=&quot;bigarray#VALc_layout&quot;&gt;&lt;code&gt;Bigarray.c_layout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray#VALfortran_layout&quot;&gt;&lt;code&gt;Bigarray.fortran_layout&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">每种布局样式都在幻影类型&lt;a href=&quot;bigarray#VALc_layout&quot;&gt; &lt;code&gt;Bigarray.c_layout&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;bigarray#VALfortran_layout&quot;&gt; &lt;code&gt;Bigarray.fortran_layout&lt;/code&gt; &lt;/a&gt;的类型级别上进行标识。</target>
        </trans-unit>
        <trans-unit id="afd355e1568c837c2d8a8aa22882d7a019020c0f" translate="yes" xml:space="preserve">
          <source>Each method may have an explicit polymorphic type: { '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;. Explicit polymorphic variables have a local scope, and an explicit polymorphic type can only be unified to an equivalent one, where only the order and names of polymorphic variables may change.</source>
          <target state="translated">每种方法都可以具有显式的多态类型：{' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; } &lt;sup&gt;+&lt;/sup&gt;。&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;。显式多态变量具有局部范围，并且显式多态类型只能统一为等效变量，其中仅多态变量的顺序和名称可以更改。</target>
        </trans-unit>
        <trans-unit id="7c5d98785b7743a02a2a0703c996991daf64afaa" translate="yes" xml:space="preserve">
          <source>Each time a program is started in the debugger, it inherits its working directory from the current working directory of the debugger. This working directory is initially whatever it inherited from its parent process (typically the shell), but you can specify a new working directory in the debugger with the cd command or the -cd command-line option.</source>
          <target state="translated">每次在调试器中启动一个程序时,它都会从调试器的当前工作目录中继承其工作目录。这个工作目录最初是它从父进程(通常是shell)继承的任何目录,但你可以用cd命令或-cd命令行选项在调试器中指定一个新的工作目录。</target>
        </trans-unit>
        <trans-unit id="cb29aeedb459a9843173566eb9da0953840aa4b6" translate="yes" xml:space="preserve">
          <source>Each time the program performs a function application, it saves the location of the application (the return address) in a block of data called a stack frame. The frame also contains the local variables of the caller function. All the frames are allocated in a region of memory called the call stack. The command backtrace (or bt) displays parts of the call stack.</source>
          <target state="translated">程序每次执行函数应用时,都会将应用的位置(返回地址)保存在一个称为栈帧的数据块中。该帧还包含调用函数的局部变量。所有的帧都分配在内存的一个区域,称为调用栈。命令backtrace(或bt)显示调用栈的部分内容。</target>
        </trans-unit>
        <trans-unit id="58a82f869d0845906f5636307dfedb10af696ef7" translate="yes" xml:space="preserve">
          <source>Each type definition in the signature specifies an optional type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; and an optional type representation =&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; &amp;hellip; or ={&lt;a href=&quot;typedecl#field-decl&quot;&gt;field-decl&lt;/a&gt; &amp;hellip; }. The implementation of the type name in a matching structure must be compatible with the type expression specified in the equation (if given), and have the specified representation (if given). Conversely, users of that signature will be able to rely on the type equation or type representation, if given. More precisely, we have the following four situations:</source>
          <target state="translated">签名中的每个类型定义都指定一个可选的类型方程式= &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;和一个可选的类型表示形式= constr &lt;a href=&quot;typedecl#constr-decl&quot;&gt;-decl&lt;/a&gt; &amp;hellip;或= { &lt;a href=&quot;typedecl#field-decl&quot;&gt;field-decl&lt;/a&gt; &amp;hellip;}。匹配结构中类型名称的实现必须与等式中指定的类型表达式（如果给定）兼容，并具有指定的表示形式（如果给定）。相反，该签名的用户将能够依靠类型方程式或类型表示（如果给出）。更准确地说，我们有以下四种情况：</target>
        </trans-unit>
        <trans-unit id="f7aa85b74327e7f9399b7bfe326e5c61749ad3fe" translate="yes" xml:space="preserve">
          <source>Echo ERASE (to erase previous character).</source>
          <target state="translated">回声ERASE(擦除前一个字符)。</target>
        </trans-unit>
        <trans-unit id="59905cd91eac129936169f92306974b7eb5df3e3" translate="yes" xml:space="preserve">
          <source>Echo KILL (to erase the current line).</source>
          <target state="translated">Echo KILL(删除当前行)。</target>
        </trans-unit>
        <trans-unit id="818b41a3180b8626f2b705affbca4a9bb2d1edf0" translate="yes" xml:space="preserve">
          <source>Echo NL even if c_echo is not set.</source>
          <target state="translated">即使没有设置c_echo,也要回声NL。</target>
        </trans-unit>
        <trans-unit id="b12403c7dc9b7aed8fe8263fa437f6a29922cd13" translate="yes" xml:space="preserve">
          <source>Echo input characters.</source>
          <target state="translated">回声输入字符。</target>
        </trans-unit>
        <trans-unit id="790ff9d91988a9f91bae9a1e80b3ea470a8793a7" translate="yes" xml:space="preserve">
          <source>Effects are classified as follows:</source>
          <target state="translated">影响分类如下:</target>
        </trans-unit>
        <trans-unit id="3bb3b33251059cb5f93747019aa489c21ce5547c" translate="yes" xml:space="preserve">
          <source>Either</source>
          <target state="translated">Either</target>
        </trans-unit>
        <trans-unit id="197992a8995b28b87bdfe412fe32a9839a7425a2" translate="yes" xml:space="preserve">
          <source>Either is the simplest and most generic sum/variant type: a value of &lt;code&gt;('a,&amp;nbsp;'b)&amp;nbsp;Either.t&lt;/code&gt; is either a &lt;code&gt;Left&amp;nbsp;(v&amp;nbsp;:&amp;nbsp;'a)&lt;/code&gt; or a &lt;code&gt;Right&amp;nbsp;(v&amp;nbsp;:&amp;nbsp;'b)&lt;/code&gt;.</source>
          <target state="translated">要么是最简单，最通用的求和/变量类型：（ &lt;code&gt;('a,&amp;nbsp;'b)&amp;nbsp;Either.t&lt;/code&gt; 值要么是 &lt;code&gt;Left&amp;nbsp;(v&amp;nbsp;:&amp;nbsp;'a)&lt;/code&gt; 要么是 &lt;code&gt;Right&amp;nbsp;(v&amp;nbsp;:&amp;nbsp;'b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="856a8a9f7c633b659bdfeb09aa81c8ade7458ab9" translate="yes" xml:space="preserve">
          <source>Either type.</source>
          <target state="translated">任何一种类型。</target>
        </trans-unit>
        <trans-unit id="a1fe848d140abbda761fcab4b0a8ee4bff9b5618" translate="yes" xml:space="preserve">
          <source>Element kind</source>
          <target state="translated">元素种类</target>
        </trans-unit>
        <trans-unit id="0c901356ec250da6646a0d255d0a5012286fed26" translate="yes" xml:space="preserve">
          <source>Element kinds</source>
          <target state="translated">元素种类</target>
        </trans-unit>
        <trans-unit id="773ebef232798eb1bcd798e64d46f5fd4d344ed8" translate="yes" xml:space="preserve">
          <source>Elements of this type can still be compared and hashed: when two elements are equal, then they represent the same source location (the converse is not necessarily true in presence of inlining, for example).</source>
          <target state="translated">这种类型的元素仍然可以进行比较和散列:当两个元素相等时,它们就代表同一个源位置(反之则不一定,例如,在有内衬的情况下)。</target>
        </trans-unit>
        <trans-unit id="6ff0f4a868ef59be803181103a0f8dacda1099dd" translate="yes" xml:space="preserve">
          <source>Ellipsis</source>
          <target state="translated">Ellipsis</target>
        </trans-unit>
        <trans-unit id="a951b7cdcb19dc8f856bf6e83e270d878bd2aebe" translate="yes" xml:space="preserve">
          <source>Emit .inlining files (one per round of optimisation) showing all of the inliner&amp;rsquo;s decisions.</source>
          <target state="translated">发出.inlining文件（每轮优化一次），显示所有内线决策。</target>
        </trans-unit>
        <trans-unit id="0b66f486cf8274cb9bca30676fc931fad21f1de5" translate="yes" xml:space="preserve">
          <source>Emit XON/XOFF chars to control input flow.</source>
          <target state="translated">发出XON/XOFF字符来控制输入流。</target>
        </trans-unit>
        <trans-unit id="2a3a2782316485396d1a6cffc0632cb5a45ba4b4" translate="yes" xml:space="preserve">
          <source>Emphemerons with arbitrary number of keys of the same type.</source>
          <target state="translated">具有任意数量的同类型键的Emphemerons。</target>
        </trans-unit>
        <trans-unit id="3385ab3a154cb8290ca5014f616b49a59d1fbfcd" translate="yes" xml:space="preserve">
          <source>Emphemerons with two keys.</source>
          <target state="translated">有两个键的Emphemerons。</target>
        </trans-unit>
        <trans-unit id="ae6d8285d87efe002dc771b241b8d06271e73877" translate="yes" xml:space="preserve">
          <source>Empty a hash table and shrink the size of the bucket table to its initial size.</source>
          <target state="translated">清空一个哈希表,并将桶表的大小缩小到初始大小。</target>
        </trans-unit>
        <trans-unit id="e37b57ef58e23b53c8f30296b9c000edeef1ce74" translate="yes" xml:space="preserve">
          <source>Empty a hash table.</source>
          <target state="translated">清空一个哈希表。</target>
        </trans-unit>
        <trans-unit id="00055027ec241f03bc3323a54fed41f0a8808bad" translate="yes" xml:space="preserve">
          <source>Empty a hash table. Use &lt;code&gt;reset&lt;/code&gt; instead of &lt;code&gt;clear&lt;/code&gt; to shrink the size of the bucket table to its initial size.</source>
          <target state="translated">清空哈希表。使用 &lt;code&gt;reset&lt;/code&gt; 而不是 &lt;code&gt;clear&lt;/code&gt; 可以将存储桶表的大小缩小到其初始大小。</target>
        </trans-unit>
        <trans-unit id="41e879386eb7dfd68165ba47fe880a837898c987" translate="yes" xml:space="preserve">
          <source>Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with the initial internal byte sequence of length &lt;code&gt;n&lt;/code&gt; that was allocated by &lt;a href=&quot;buffer#VALcreate&quot;&gt;&lt;code&gt;Buffer.create&lt;/code&gt;&lt;/a&gt;&lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">清空缓冲区，并释放包含缓冲区内容的内部字节序列，将其替换为由&lt;a href=&quot;buffer#VALcreate&quot;&gt; &lt;code&gt;Buffer.create&lt;/code&gt; &lt;/a&gt; &lt;code&gt;n&lt;/code&gt; 分配的长度为 &lt;code&gt;n&lt;/code&gt; 的初始内部字节序列。</target>
        </trans-unit>
        <trans-unit id="fc2a8448f140b28c370341466e87e932ee8786a1" translate="yes" xml:space="preserve">
          <source>Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with the initial internal byte sequence of length &lt;code&gt;n&lt;/code&gt; that was allocated by &lt;a href=&quot;buffer#VALcreate&quot;&gt;&lt;code&gt;Buffer.create&lt;/code&gt;&lt;/a&gt;&lt;code&gt;n&lt;/code&gt;. For long-lived buffers that may have grown a lot, &lt;code&gt;reset&lt;/code&gt; allows faster reclamation of the space used by the buffer.</source>
          <target state="translated">清空缓冲区，并释放包含缓冲区内容的内部字节序列，将其替换为由&lt;a href=&quot;buffer#VALcreate&quot;&gt; &lt;code&gt;Buffer.create&lt;/code&gt; &lt;/a&gt; &lt;code&gt;n&lt;/code&gt; 分配的长度为 &lt;code&gt;n&lt;/code&gt; 的初始内部字节序列。对于可能增长很多的长寿命缓冲区， &lt;code&gt;reset&lt;/code&gt; 可以更快地回收缓冲区使用的空间。</target>
        </trans-unit>
        <trans-unit id="ebf089f9c5c1c0373c6ce76e0a9cc360bcd1ef69" translate="yes" xml:space="preserve">
          <source>Empty the buffer.</source>
          <target state="translated">清空缓冲区。</target>
        </trans-unit>
        <trans-unit id="b00390bd2f9505f4d62d808cec4546f6464f7fed" translate="yes" xml:space="preserve">
          <source>Empty the parser stack.</source>
          <target state="translated">清空解析器堆栈。</target>
        </trans-unit>
        <trans-unit id="f101e78b0fa42d75dcdc4adb6d4084b4a601834d" translate="yes" xml:space="preserve">
          <source>Empty the parser stack. Call it just after a parsing function has returned, to remove all pointers from the parser stack to structures that were built by semantic actions during parsing. This is optional, but lowers the memory requirements of the programs.</source>
          <target state="translated">清空解析器堆栈。在解析函数返回后调用它,以删除解析器栈中所有指向解析过程中由语义操作建立的结构的指针。这是可选的,但可以降低程序的内存需求。</target>
        </trans-unit>
        <trans-unit id="0074df63c6d023e7952d43a2b914df91ffff8c57" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="translated">启用与字母相对应的一组警告,并将其标记为致命警告。字母可以是大写或小写。</target>
        </trans-unit>
        <trans-unit id="fcdd970d5666c8141a3cce0f73a9dad92f944239" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal warning name.</source>
          <target state="translated">启用并标记为致命警告名称。</target>
        </trans-unit>
        <trans-unit id="3599d807d73244d1d2b2c6bbb5870d2aa02d3a1a" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal warning number num.</source>
          <target state="translated">启用并标记为致命警告号码num。</target>
        </trans-unit>
        <trans-unit id="a8d07d21892b973a86c258d424467b16d34fb15e" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal warnings in the given range.</source>
          <target state="translated">启用并标记为给定范围内的致命警告。</target>
        </trans-unit>
        <trans-unit id="c78968437d3375a093ddfb521ecf6242e8d1eedd" translate="yes" xml:space="preserve">
          <source>Enable canonical processing (line buffering and editing)</source>
          <target state="translated">启用规范化处理(行缓冲和编辑)。</target>
        </trans-unit>
        <trans-unit id="929680a8eee524b77121874d47b6662082176d5c" translate="yes" xml:space="preserve">
          <source>Enable or disable colors in compiler messages (especially warnings and errors). The following modes are supported:</source>
          <target state="translated">启用或禁用编译器消息中的颜色(尤其是警告和错误)。支持以下模式。</target>
        </trans-unit>
        <trans-unit id="c3548fe32ed1474e82f947e74c5e0161162ca1d4" translate="yes" xml:space="preserve">
          <source>Enable or disable warnings according to the argument.</source>
          <target state="translated">根据参数启用或禁用警告。</target>
        </trans-unit>
        <trans-unit id="4bab6b7179d748b7bd5e0233cc4bee7fd29fef76" translate="yes" xml:space="preserve">
          <source>Enable output processing.</source>
          <target state="translated">启用输出处理。</target>
        </trans-unit>
        <trans-unit id="412d02d844a8c91867b64526a04ce736b5034569" translate="yes" xml:space="preserve">
          <source>Enable parity check on input.</source>
          <target state="translated">启用输入的奇偶校验。</target>
        </trans-unit>
        <trans-unit id="ac72b92dafda7ef51841541aaa002e202a5f9ecb" translate="yes" xml:space="preserve">
          <source>Enable parity generation and detection.</source>
          <target state="translated">启用奇偶校验生成和检测。</target>
        </trans-unit>
        <trans-unit id="770fcb2eeb894c2e9d37a541226e5eca47597530" translate="yes" xml:space="preserve">
          <source>Enable the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="translated">启用与字母对应的一组警告。字母可以是大写或小写。</target>
        </trans-unit>
        <trans-unit id="58f210fa0832e7afc94eb19ba465c6cfb9687d2d" translate="yes" xml:space="preserve">
          <source>Enable the set of warnings corresponding to uppercase-letter.</source>
          <target state="translated">启用大写字母对应的警告集。</target>
        </trans-unit>
        <trans-unit id="91485ceaa105fc027422a047a3547f325cfb99b2" translate="yes" xml:space="preserve">
          <source>Enable warning name.</source>
          <target state="translated">启用警告名称。</target>
        </trans-unit>
        <trans-unit id="47140cbacce9eae9e7a7806fc75b0c141d4a9ebc" translate="yes" xml:space="preserve">
          <source>Enable warning number num.</source>
          <target state="translated">启用警告数。</target>
        </trans-unit>
        <trans-unit id="265fc90bc531f6f35f959332fc17890c9912c555" translate="yes" xml:space="preserve">
          <source>Enable warnings in the given range.</source>
          <target state="translated">启用给定范围内的警告。</target>
        </trans-unit>
        <trans-unit id="a218e074ec01ec172f8afd6aad1e646363974278" translate="yes" xml:space="preserve">
          <source>Enable, disable, or mark as fatal the warnings specified by the argument warning-list. Each warning can be &lt;em&gt;enabled&lt;/em&gt; or &lt;em&gt;disabled&lt;/em&gt;, and each warning can be &lt;em&gt;fatal&lt;/em&gt; or &lt;em&gt;non-fatal&lt;/em&gt;. If a warning is disabled, it isn&amp;rsquo;t displayed and doesn&amp;rsquo;t affect compilation in any way (even if it is fatal). If a warning is enabled, it is displayed normally by the compiler whenever the source code triggers it. If it is enabled and fatal, the compiler will also stop with an error after displaying it.</source>
          <target state="translated">启用，禁用或将警告警告列表指定的警告标记为致命警告。每一个警告，可以&lt;em&gt;启用&lt;/em&gt;或&lt;em&gt;禁用&lt;/em&gt;，并且每个警告可能是&lt;em&gt;致命的&lt;/em&gt;或者&lt;em&gt;非致命&lt;/em&gt;。如果禁用了警告，则不会显示警告，也不会以任何方式影响编译（即使它是致命的）。如果启用了警告，则只要源代码触发警告，编译器就会正常显示警告。如果启用它并致命，则编译器在显示它之后也将停止并显示错误。</target>
        </trans-unit>
        <trans-unit id="14b271b15e5841b95bcc16da04d7676aa55f327e" translate="yes" xml:space="preserve">
          <source>Enables the PowerPC large model allowing the TOC (table of contents) to be arbitrarily large. This is the default since 4.11.</source>
          <target state="translated">启用PowerPC大模型,允许TOC(目录)任意大。这是自4.11以来的默认值。</target>
        </trans-unit>
        <trans-unit id="03401ca3edfdb4128312d6293c8a35421e582859" translate="yes" xml:space="preserve">
          <source>Enables the PowerPC small model allowing the TOC to be up to 64 kbytes per compilation unit. Prior to 4.11 this was the default behaviour.</source>
          <target state="translated">启用PowerPC小型模型,允许每个编译单元的TOC达到64 kbytes。在4.11之前,这是默认行为。</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="de8640801b22a0d8a7941409721bb3a98cd33e94" translate="yes" xml:space="preserve">
          <source>End of pretty-printing: resets the pretty-printer to initial state.</source>
          <target state="translated">漂亮打印结束:将漂亮打印机重置为初始状态。</target>
        </trans-unit>
        <trans-unit id="c50b618f1beb796972a9fd07d7599cf8ab8e9054" translate="yes" xml:space="preserve">
          <source>End-of-file character (usually ctrl-D).</source>
          <target state="translated">文件结束符(通常是ctrl-D)。</target>
        </trans-unit>
        <trans-unit id="3b725184f8cc36a4f8ee2394c69c2dd8fd868d7e" translate="yes" xml:space="preserve">
          <source>Enforce the separation between types string and bytes, thereby making strings read-only. This is the default.</source>
          <target state="translated">强制执行字符串和字节类型之间的分离,从而使字符串成为只读类型。这是默认的。</target>
        </trans-unit>
        <trans-unit id="0036f2b2e208fafb5dfcdf20fc4bf2ebd0e85c42" translate="yes" xml:space="preserve">
          <source>Ensure 32-bit compatibility</source>
          <target state="translated">确保32位的兼容性</target>
        </trans-unit>
        <trans-unit id="541ccf2eac21a70a4145827ccb7cd6a05e98125f" translate="yes" xml:space="preserve">
          <source>Enumerated types are a special case of variant types, where all alternatives are constants:</source>
          <target state="translated">枚举类型是变体类型的一个特例,其中所有的替代类型都是常数。</target>
        </trans-unit>
        <trans-unit id="5b52f0dc6b40b4c37e2f81f6f54bc6aa05c7bffc" translate="yes" xml:space="preserve">
          <source>Environment queries</source>
          <target state="translated">环境查询</target>
        </trans-unit>
        <trans-unit id="31712ff509a3de90defb9dc714b99a9f1ce278f8" translate="yes" xml:space="preserve">
          <source>Ephemeron</source>
          <target state="translated">Ephemeron</target>
        </trans-unit>
        <trans-unit id="d8381b886ce8e021a29bdc573e5df829fee81936" translate="yes" xml:space="preserve">
          <source>Ephemeron with arbitrary arity and untyped</source>
          <target state="translated">具有任意性和非类型的Ephemeron。</target>
        </trans-unit>
        <trans-unit id="9483411c3a45e44db6a73f050d8e84f9ac980a3c" translate="yes" xml:space="preserve">
          <source>Ephemerons and weak hash tables</source>
          <target state="translated">星历和弱哈希表</target>
        </trans-unit>
        <trans-unit id="68dcdfc77c7716500d652b8b54eddd5f8823b37a" translate="yes" xml:space="preserve">
          <source>Ephemerons and weak hash tables are useful when one wants to cache or memorize the computation of a function, as long as the arguments and the function are used, without creating memory leaks by continuously keeping old computation results that are not useful anymore because one argument or the function is freed. An implementation using &lt;a href=&quot;hashtbl#TYPEt&quot;&gt;&lt;code&gt;Hashtbl.t&lt;/code&gt;&lt;/a&gt; is not suitable because all associations would keep the arguments and the result in memory.</source>
          <target state="translated">只要使用参数和函数，只要想缓存或记住函数的计算，星历表和弱哈希表就非常有用，而不会由于连续保留不再有用的旧计算结果而造成内存泄漏，因为一个或多个参数该功能已释放。使用&lt;a href=&quot;hashtbl#TYPEt&quot;&gt; &lt;code&gt;Hashtbl.t&lt;/code&gt; &lt;/a&gt;的实现不适合，因为所有关联会将参数和结果保留在内存中。</target>
        </trans-unit>
        <trans-unit id="442197cf0f210355aaaf4d6d5dda23c7904cedfc" translate="yes" xml:space="preserve">
          <source>Ephemerons and weak hash tables.</source>
          <target state="translated">星历和弱哈希表。</target>
        </trans-unit>
        <trans-unit id="8055532213ae7a60925ad194d9e4810c98071c69" translate="yes" xml:space="preserve">
          <source>Ephemerons are defined in a language agnostic way in this paper: B. Hayes, Ephemerons: A New Finalization Mechanism, OOPSLA'97</source>
          <target state="translated">本文以语言不可知的方式对Ephemerons进行了定义。B.Hayes,Ephemerons:A New Finalization Mechanism,OOPSLA'97。</target>
        </trans-unit>
        <trans-unit id="41096c468df31c97917965c8d891ad108e26d1fc" translate="yes" xml:space="preserve">
          <source>Ephemerons can also be used for &quot;adding&quot; a field to an arbitrary boxed OCaml value: you can attach some information to a value created by an external library without memory leaks.</source>
          <target state="translated">Ephemerons也可以用于将一个字段 &quot;添加 &quot;到一个任意框定的OCaml值中:您可以将一些信息附加到一个由外部库创建的值上,而不会出现内存泄漏。</target>
        </trans-unit>
        <trans-unit id="509e85975836d7ac50cc9b68b081f475f1b2961c" translate="yes" xml:space="preserve">
          <source>Ephemerons hold some keys and one or no data. They are all boxed OCaml values. The keys of an ephemeron have the same behavior as weak pointers according to the garbage collector. In fact OCaml weak pointers are implemented as ephemerons without data.</source>
          <target state="translated">Ephemerons持有一些键和一个或没有数据。它们都是盒装的OCaml值。根据垃圾收集器的规定,表象的键与弱指针的行为相同。事实上,OCaml弱指针被实现为没有数据的星历子。</target>
        </trans-unit>
        <trans-unit id="3678f708bb7acd9cab4482ec011dc840f1179a85" translate="yes" xml:space="preserve">
          <source>Ephemerons with one key.</source>
          <target state="translated">瞤息一键。</target>
        </trans-unit>
        <trans-unit id="f749997472bd5134a97950c6d780f4f1c597e624" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;format#VALprint_flush&quot;&gt;&lt;code&gt;Format.print_flush&lt;/code&gt;&lt;/a&gt; followed by a new line. See corresponding words of caution for &lt;a href=&quot;format#VALprint_flush&quot;&gt;&lt;code&gt;Format.print_flush&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;format#VALprint_flush&quot;&gt; &lt;code&gt;Format.print_flush&lt;/code&gt; &lt;/a&gt;等效，后跟新行。请参阅&lt;a href=&quot;format#VALprint_flush&quot;&gt; &lt;code&gt;Format.print_flush&lt;/code&gt; 的&lt;/a&gt;相应注意事项。</target>
        </trans-unit>
        <trans-unit id="132ad0d3139178d3cc06065a05035275b2ff94c6" translate="yes" xml:space="preserve">
          <source>Erase character (usually DEL or ctrl-H).</source>
          <target state="translated">擦除字符(通常是 DEL 或 ctrl-H)。</target>
        </trans-unit>
        <trans-unit id="e96e1ad38c0966dc375be617296d87a44b956217" translate="yes" xml:space="preserve">
          <source>Erroneous printed signature.</source>
          <target state="translated">错误的打印签名。</target>
        </trans-unit>
        <trans-unit id="08f25135109ebab1ec1d489737e84df517dc0927" translate="yes" xml:space="preserve">
          <source>Error in environment variable.</source>
          <target state="translated">环境变量出错。</target>
        </trans-unit>
        <trans-unit id="ee7ccdbc8221cdeaf56848e96bf3b929db5cb197" translate="yes" xml:space="preserve">
          <source>Error recovery is supported as follows: when the parser reaches an error state (no grammar rules can apply), it calls a function named parse_error with the string &quot;syntax error&quot; as argument. The default parse_error function does nothing and returns, thus initiating error recovery (see below). The user can define a customized parse_error function in the header section of the grammar file.</source>
          <target state="translated">支持的错误恢复方式如下:当解析器达到错误状态时(不能应用语法规则),它会调用一个名为parse_error的函数,参数为字符串 &quot;语法错误&quot;。默认的parse_error函数什么都不做,并返回,从而启动错误恢复(见下文)。用户可以在语法文件的头部分定义一个自定义的parse_error函数。</target>
        </trans-unit>
        <trans-unit id="4e31c347b987a17f7cb3d98f8aa8b10ea251a784" translate="yes" xml:space="preserve">
          <source>Error report</source>
          <target state="translated">错误报告</target>
        </trans-unit>
        <trans-unit id="c933b897af92835c337f8c15d042afda6a862cd4" translate="yes" xml:space="preserve">
          <source>Error reporting</source>
          <target state="translated">错误报告</target>
        </trans-unit>
        <trans-unit id="29ed179aaaaf044198d2d4b099b8f9cdd60f5ea6" translate="yes" xml:space="preserve">
          <source>Errors in dynamic linking are reported by raising the &lt;code&gt;Error&lt;/code&gt; exception with a description of the error.</source>
          <target state="translated">通过引发带有 &lt;code&gt;Error&lt;/code&gt; 描述的Error异常来报告动态链接中的错误。</target>
        </trans-unit>
        <trans-unit id="0efc5d69dd69fd2174db30c880c7b6bb09d8c0c9" translate="yes" xml:space="preserve">
          <source>Errors in dynamic linking are reported by raising the &lt;code&gt;Error&lt;/code&gt; exception with a description of the error. A common case is the dynamic library not being found on the system: this is reported via &lt;code&gt;Cannot_open_dynamic_library&lt;/code&gt; (the enclosed exception may be platform-specific).</source>
          <target state="translated">通过引发带有 &lt;code&gt;Error&lt;/code&gt; 描述的Error异常来报告动态链接中的错误。常见的情况是在系统上找不到动态库：这是通过 &lt;code&gt;Cannot_open_dynamic_library&lt;/code&gt; 报告的（附带的异常可能是特定于平台的）。</target>
        </trans-unit>
        <trans-unit id="505e7e8c7959ad784a122d78879a599b96f2bf97" translate="yes" xml:space="preserve">
          <source>Escape accented characters in Info files.</source>
          <target state="translated">在信息文件中转义重音字符。</target>
        </trans-unit>
        <trans-unit id="fde05190b55a3eed2e7dcfc6d80db47e06a76f0e" translate="yes" xml:space="preserve">
          <source>Especially when writing benchmarking suites that run non-side-effecting algorithms in loops, it may be found that the optimiser entirely elides the code being benchmarked. This behaviour can be prevented by using the Sys.opaque_identity function (which indeed behaves as a normal OCaml function and does not possess any &amp;ldquo;magic&amp;rdquo; semantics). The documentation of the Sys module should be consulted for further details.</source>
          <target state="translated">尤其是在编写循环运行非副作用算法的基准测试套件时，可能会发现优化器完全取代了被基准测试的代码。可以通过使用Sys.opaque_identity函数（该函数确实充当常规OCaml函数并且不具有任何&amp;ldquo;魔术&amp;rdquo;语义）来防止此行为。有关更多详细信息，请查阅Sys模块的文档。</target>
        </trans-unit>
        <trans-unit id="709722b0c7e8d8e13600ac9f62e2965e7a3f0dc3" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address.</source>
          <target state="translated">在给定的地址上建立一个服务器。</target>
        </trans-unit>
        <trans-unit id="0f1ae88cb41c8981c081c8dce853cd4b9948f674" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address. The function given as first argument is called for each connection with two buffered channels connected to the client. A new process is created for each connection. The function &lt;a href=&quot;unix#VALestablish_server&quot;&gt;&lt;code&gt;Unix.establish_server&lt;/code&gt;&lt;/a&gt; never returns normally.</source>
          <target state="translated">在给定的地址上建立服务器。对于具有两个连接到客户端的缓冲通道的每个连接，将调用作为第一个参数给出的函数。为每个连接创建一个新的过程。函数&lt;a href=&quot;unix#VALestablish_server&quot;&gt; &lt;code&gt;Unix.establish_server&lt;/code&gt; &lt;/a&gt;从不正常返回。</target>
        </trans-unit>
        <trans-unit id="560d397e92aaad3554bd23d10de9d5e52de2dee9" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address. The function given as first argument is called for each connection with two buffered channels connected to the client. A new process is created for each connection. The function &lt;a href=&quot;unixlabels#VALestablish_server&quot;&gt;&lt;code&gt;UnixLabels.establish_server&lt;/code&gt;&lt;/a&gt; never returns normally.</source>
          <target state="translated">在给定的地址上建立服务器。对于具有两个连接到客户端的缓冲通道的每个连接，将调用作为第一个参数给出的函数。为每个连接创建一个新的过程。函数&lt;a href=&quot;unixlabels#VALestablish_server&quot;&gt; &lt;code&gt;UnixLabels.establish_server&lt;/code&gt; &lt;/a&gt;永远不会正常返回。</target>
        </trans-unit>
        <trans-unit id="40a6caa3a0a19447950f461ddf1293d94c142f80" translate="yes" xml:space="preserve">
          <source>Even function composition is definable:</source>
          <target state="translated">甚至函数组成也是可以定义的。</target>
        </trans-unit>
        <trans-unit id="7c21414076c7e3bcf34bf847855694be0bc01134" translate="yes" xml:space="preserve">
          <source>Even if a value has a fixed variant type, one can still give it a larger type through coercions. Coercions are normally written with both the source type and the destination type, but in simple cases the source type may be omitted.</source>
          <target state="translated">即使一个值有一个固定的变体类型,也可以通过胁迫给它一个更大的类型。胁迫通常同时写上源类型和目的类型,但在简单的情况下,源类型可以省略。</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="002a13e663c95fdf83e648de45960c94bd85c63d" translate="yes" xml:space="preserve">
          <source>Events are &amp;ldquo;interesting&amp;rdquo; locations in the source code, corresponding to the beginning or end of evaluation of &amp;ldquo;interesting&amp;rdquo; sub-expressions. Events are the unit of single-stepping (stepping goes to the next or previous event encountered in the program execution). Also, breakpoints can only be set at events. Thus, events play the role of line numbers in debuggers for conventional languages.</source>
          <target state="translated">事件是源代码中的&amp;ldquo;有趣&amp;rdquo;位置，与&amp;ldquo;有趣&amp;rdquo;子表达式的评估开始或结束相对应。事件是单步执行的单元（单步执行到程序执行中遇到的下一个或上一个事件）。同样，只能在事件中设置断点。因此，事件在常规语言的调试器中起着行号的作用。</target>
        </trans-unit>
        <trans-unit id="39f8fea95f2f905afaf5702b20b4c2af865028ce" translate="yes" xml:space="preserve">
          <source>Every break hint in a vertical box splits the line.</source>
          <target state="translated">竖框中的每一个断点提示都会分割线。</target>
        </trans-unit>
        <trans-unit id="c43eedd80f49a7cd19f66f688554ddc3114ee51c" translate="yes" xml:space="preserve">
          <source>Every function in this module raises &lt;code&gt;Sys_error&lt;/code&gt; with an informative message when the underlying system call signal an error.</source>
          <target state="translated">当基础系统调用发出错误信号时，此模块中的每个函数都会以信息性消息引发 &lt;code&gt;Sys_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fa85591eb4e3709828aec09ddda444c23ec731b" translate="yes" xml:space="preserve">
          <source>Every other keyword takes the following word on the command line as argument. For compatibility with GNU getopt_long, &lt;code&gt;keyword=arg&lt;/code&gt; is also allowed. Arguments not preceded by a keyword are called anonymous arguments.</source>
          <target state="translated">其他每个关键字都将命令行中的以下单词作为参数。为了与GNU getopt_long兼容，还允许使用 &lt;code&gt;keyword=arg&lt;/code&gt; 。不带关键字的参数称为匿名参数。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="53c17e0e359a4c32fb2e90ba769249f80da0ed09" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%d@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt; is equivalent to &lt;code&gt;open_box&amp;nbsp;();&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt;. It prints &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; within a pretty-printing 'horizontal-or-vertical' box.</source>
          <target state="translated">例如： &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%d@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt; 等效于 &lt;code&gt;open_box&amp;nbsp;();&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt; 。它在漂亮打印的&amp;ldquo;水平或垂直&amp;rdquo;框中打印 &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7867675b155e93124d37b927a09603512264fe69" translate="yes" xml:space="preserve">
          <source>Example: a lexer suitable for a desk calculator is obtained by</source>
          <target state="translated">例子:通过以下方式得到一个适合桌面计算器的词典</target>
        </trans-unit>
        <trans-unit id="895e8f203a6495776734a740f015692cd2b3b1aa" translate="yes" xml:space="preserve">
          <source>Example: the following C primitive invokes gethostbyname to find the IP address of a host name. The gethostbyname function can block for a long time, so we choose to release the OCaml run-time system while it is running.</source>
          <target state="translated">例子:下面的C语言基元调用gethostbyname来查找主机名的IP地址。gethostbyname函数可能会阻塞很长时间,所以我们选择在运行OCaml运行时系统释放。</target>
        </trans-unit>
        <trans-unit id="811da335fb02658aeea8e581a3a2ee5c053b4621" translate="yes" xml:space="preserve">
          <source>Examples (&lt;code&gt;cmd&lt;/code&gt; is assumed to be the command name):</source>
          <target state="translated">示例（假定 &lt;code&gt;cmd&lt;/code&gt; 为命令名称）：</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="3f519a0ed2ab9c204d38ec6035c856c982aaeca9" translate="yes" xml:space="preserve">
          <source>Exception definitions add new constructors to the built-in variant type &lt;code&gt;exn&lt;/code&gt; of exception values. The constructors are declared as for a definition of a variant type.</source>
          <target state="translated">异常定义将新的构造函数添加到异常值的内置变量类型 &lt;code&gt;exn&lt;/code&gt; 中。构造函数声明为变量类型的定义。</target>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="d431d2533016ca9ad29f4d173d1b14c07b74bb13" translate="yes" xml:space="preserve">
          <source>Exception raised by input functions to signal that the end of file has been reached.</source>
          <target state="translated">由输入函数引发的异常,用于提示文件已经结束。</target>
        </trans-unit>
        <trans-unit id="82978f55e4581497009424eb5b42bd93b3ca7e49" translate="yes" xml:space="preserve">
          <source>Exception raised by integer division and remainder operations when their second argument is zero.</source>
          <target state="translated">当整数除法和余数运算的第二个参数为零时,引发异常。</target>
        </trans-unit>
        <trans-unit id="20d4510a4445338226928ea929221d7a1a2b7357" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that the given arguments do not make sense.</source>
          <target state="translated">由库函数引发的异常,以表明给定的参数没有意义。</target>
        </trans-unit>
        <trans-unit id="7ce3e5fe0fb1d8b41956476928546ec08a9de8a9" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that the given arguments do not make sense. The string gives some information to the programmer. As a general rule, this exception should not be caught, it denotes a programming error and the code should be modified not to trigger it.</source>
          <target state="translated">由库函数引发的异常,以表明给定的参数没有意义。该字符串给程序员提供了一些信息。一般来说,这种异常不应该被捕获,它表示一个编程错误,应该修改代码以不触发它。</target>
        </trans-unit>
        <trans-unit id="dd340ed580df2f3db47ef85feb52884932b1b6a4" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments.</source>
          <target state="translated">由库函数引发的异常,以表明它们在给定参数上未定义。</target>
        </trans-unit>
        <trans-unit id="8fa93c3585b8f661e83ab6ba8e4b8cff0539794a" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments. The string is meant to give some information to the programmer; you must &lt;em&gt;not&lt;/em&gt; pattern match on the string literal because it may change in future versions (use &lt;code&gt;Failure _&lt;/code&gt; instead).</source>
          <target state="translated">库函数引发的异常表示在给定参数上未定义它们。该字符串旨在为程序员提供一些信息。您&lt;em&gt;不得&lt;/em&gt;在字符串文字上进行模式匹配，因为它可能在将来的版本中更改（请使用 &lt;code&gt;Failure _&lt;/code&gt; 代替）。</target>
        </trans-unit>
        <trans-unit id="797259d42c53292ad6d9cae5fe9499225a450501" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments. The string is meant to give some information to the programmer; you must not pattern match on the string literal because it may change in future versions (use Failure _ instead).</source>
          <target state="translated">由库函数引发的异常,以表明它们在给定参数上未定义。字符串是为了给程序员提供一些信息;你不能在字符串文字上进行模式匹配,因为它可能在未来的版本中发生变化(使用Failure _代替)。</target>
        </trans-unit>
        <trans-unit id="6a939c6f19243a7a27b33817d6c3cccd399f0471" translate="yes" xml:space="preserve">
          <source>Exception raised by search functions when the desired object could not be found.</source>
          <target state="translated">当找不到所需对象时,由搜索函数引发的异常。</target>
        </trans-unit>
        <trans-unit id="74e471d3322f6cf64419d195e08e460252e2c212" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size.</source>
          <target state="translated">当评估栈达到最大大小时,由字节码解释器引发的异常。</target>
        </trans-unit>
        <trans-unit id="a5e572e45624dcdfce646146b1c59f0702b1de31" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size. This often indicates infinite or excessively deep recursion in the user&amp;rsquo;s program. Before 4.10, it was not fully implemented by the native-code compiler.</source>
          <target state="translated">当评估堆栈达到其最大大小时，字节码解释器将引发异常。这通常表示用户程序中的无限递归或过深的递归。在4.10之前，本机代码编译器尚未完全实现它。</target>
        </trans-unit>
        <trans-unit id="eafbe2aa6287023677ed95d39e464d69f627603a" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size. This often indicates infinite or excessively deep recursion in the user's program.</source>
          <target state="translated">当评估堆栈达到最大大小时,由字节码解释器引发的异常。这通常表明用户程序中存在无限或过深的递归。</target>
        </trans-unit>
        <trans-unit id="25c82737838d58bf71651d2fbaaf6dcd90b0e977" translate="yes" xml:space="preserve">
          <source>Exception raised by the garbage collector when there is insufficient memory to complete the computation.</source>
          <target state="translated">当内存不足,无法完成计算时,由垃圾回收器引发的异常。</target>
        </trans-unit>
        <trans-unit id="86afff90609a22e194dc3619fb61e1382a6dfa8b" translate="yes" xml:space="preserve">
          <source>Exception raised by the garbage collector when there is insufficient memory to complete the computation. (Not reliable for allocations on the minor heap.)</source>
          <target state="translated">当没有足够的内存来完成计算时,由垃圾回收器引发的异常。(对于小堆上的分配不可靠。)</target>
        </trans-unit>
        <trans-unit id="04f61cd268d77caa95705043d94ff400c1717740" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error.</source>
          <target state="translated">由输入/输出函数引发的异常,报告操作系统错误。</target>
        </trans-unit>
        <trans-unit id="e3bf7bb486274539ef14aee9c61a39c45080f2b2" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error. The string is meant to give some information to the programmer; you must &lt;em&gt;not&lt;/em&gt; pattern match on the string literal because it may change in future versions (use &lt;code&gt;Sys_error _&lt;/code&gt; instead).</source>
          <target state="translated">输入/输出功能引发的异常，用于报告操作系统错误。该字符串旨在为程序员提供一些信息。您&lt;em&gt;不能&lt;/em&gt;在字符串文字上进行模式匹配，因为在将来的版本中它可能会更改（请改用 &lt;code&gt;Sys_error _&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0581cb33548055979f48d1861e6b229eba7ab670" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error. The string is meant to give some information to the programmer; you must not pattern match on the string literal because it may change in future versions (use Sys_error _ instead).</source>
          <target state="translated">由输入/输出函数引发的异常,用于报告操作系统错误。字符串是为了给程序员提供一些信息;你不能在字符串上进行模式匹配,因为它在未来的版本中可能会改变(使用Sys_error _代替)。</target>
        </trans-unit>
        <trans-unit id="cf3b34162fd333f111fabc4e1219ee5b7ee0f141" translate="yes" xml:space="preserve">
          <source>Exception raised on interactive interrupt if &lt;a href=&quot;sys#VALcatch_break&quot;&gt;&lt;code&gt;Sys.catch_break&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">如果&lt;a href=&quot;sys#VALcatch_break&quot;&gt; &lt;code&gt;Sys.catch_break&lt;/code&gt; 打开,&lt;/a&gt;则在交互式中断上引发异常。</target>
        </trans-unit>
        <trans-unit id="7be295586a8b968373c605fa23bab4f0788068a9" translate="yes" xml:space="preserve">
          <source>Exception raised when an assertion fails.</source>
          <target state="translated">断言失败时引发异常。</target>
        </trans-unit>
        <trans-unit id="6b18713a9f11df2a32a9f4552d5cc9de4147090a" translate="yes" xml:space="preserve">
          <source>Exception raised when an assertion fails. The arguments are the location of the assert keyword in the source code (file name, line number, column number).</source>
          <target state="translated">当一个断言失败时引发的异常。参数是断言关键字在源代码中的位置(文件名、行号、列号)。</target>
        </trans-unit>
        <trans-unit id="3f697fde1fd79527c41f5e00a6e22980baa8cb48" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated.</source>
          <target state="translated">递归模块定义被评估时出现异常。</target>
        </trans-unit>
        <trans-unit id="d47c81a731b2b28b1bf429014237b634999ac235" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated. (See section &amp;zwj;&lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;8.2&lt;/a&gt;.) The arguments are the location of the definition in the source code (file name, line number, column number).</source>
          <target state="translated">在评估错误的递归模块定义时引发异常。（见&lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;8.2&lt;/a&gt;。）的参数是在源代码中定义（文件名，行号，列数）的位置。</target>
        </trans-unit>
        <trans-unit id="2a113d2a72fa73bfe6280e7724ea7861fe51a705" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated. (See section &lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;8.2&lt;/a&gt;.) The arguments are the location of the definition in the source code (file name, line number, column number).</source>
          <target state="translated">在评估错误的递归模块定义时引发异常。（请参阅第&lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;8.2&lt;/a&gt;节。）参数是定义在源代码中的位置（文件名，行号，列号）。</target>
        </trans-unit>
        <trans-unit id="fdb4b79613ced915c490c09e8d6900bf35cdc038" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated. The arguments are the location of the definition in the source code (file name, line number, column number).</source>
          <target state="translated">递归模块定义被评估时,出现异常。参数是定义在源代码中的位置(文件名、行号、列号)。</target>
        </trans-unit>
        <trans-unit id="a6a958202f1e3608e7a8ea01d2ca2751bd4bea07" translate="yes" xml:space="preserve">
          <source>Exception raised when none of the cases of a pattern-matching apply.</source>
          <target state="translated">当模式匹配的所有情况都不适用时,引发异常。</target>
        </trans-unit>
        <trans-unit id="de14bb71c34237905f8dcebb811a688e4de7f45d" translate="yes" xml:space="preserve">
          <source>Exception raised when none of the cases of a pattern-matching apply. The arguments are the location of the match keyword in the source code (file name, line number, column number).</source>
          <target state="translated">当模式匹配的所有情况都不适用时引发的异常。参数是匹配关键字在源代码中的位置(文件名、行号、列号)。</target>
        </trans-unit>
        <trans-unit id="3e3cff116501149a61e1bc172f77a1f0dc84b3e9" translate="yes" xml:space="preserve">
          <source>Exception slots</source>
          <target state="translated">例外槽</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="2238f9897bfd70f8e17c597ae32443c2178f3778" translate="yes" xml:space="preserve">
          <source>Exceptions are defined with the syntax exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; or exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;.</source>
          <target state="translated">异常是使用语法exception &lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;或exception &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; = &lt;a href=&quot;names#constr&quot;&gt;constr定义的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd41474f597589f8ce75091ee7c9d450a6dace1b" translate="yes" xml:space="preserve">
          <source>Exceptions are used throughout the standard library to signal cases where the library functions cannot complete normally. For instance, the List.assoc function, which returns the data associated with a given key in a list of (key, data) pairs, raises the predefined exception Not_found when the key does not appear in the list:</source>
          <target state="translated">在整个标准库中,异常被用来提示库函数不能正常完成的情况。例如,List.assoc函数在(key,data)对的列表中返回与给定键相关联的数据,当键没有出现在列表中时,会引发预定义的异常Not_found。</target>
        </trans-unit>
        <trans-unit id="dedd1c7c976e1735c5590d9e4db8485865a74ba0" translate="yes" xml:space="preserve">
          <source>Exceptions arising from allocation points, for example &amp;ldquo;out of memory&amp;rdquo; or exceptions propagated from finalizers or signal handlers, are treated as &amp;ldquo;effects out of the ether&amp;rdquo; and thus ignored for our determination here of effectfulness. The same goes for floating point operations that may cause hardware traps on some platforms.</source>
          <target state="translated">由分配点引起的异常，例如&amp;ldquo;内存不足&amp;rdquo;或从终结器或信号处理程序传播的异常，被视为&amp;ldquo;以太坊效应&amp;rdquo;，因此在这里我们将其确定为无效。对于可能在某些平台上引起硬件陷阱的浮点操作也是如此。</target>
        </trans-unit>
        <trans-unit id="991e714f33417fc77efb0b8c274e6fb8c4a2e225" translate="yes" xml:space="preserve">
          <source>Exceptions can be trapped with the try&amp;hellip;with construct:</source>
          <target state="translated">可以使用try&amp;hellip;with构造来捕获异常：</target>
        </trans-unit>
        <trans-unit id="372172c1d79adf3d5e9eda6ccfe3f8d90f9945ca" translate="yes" xml:space="preserve">
          <source>Exceptions during scanning</source>
          <target state="translated">扫描过程中的异常情况</target>
        </trans-unit>
        <trans-unit id="e2554291b193ac0bbead288da0987203e8cf0cef" translate="yes" xml:space="preserve">
          <source>Exceptions: A function application followed by a function return is replaced by the compiler by a jump (tail-call optimization). In this case, no event is put after the function application.</source>
          <target state="translated">例外情况。一个函数应用后的函数返回被编译器用跳转代替(尾部调用优化)。在这种情况下,函数应用后不放任何事件。</target>
        </trans-unit>
        <trans-unit id="6a8396b2656b2d03ab3b6f1d6e1517dcf7f9323c" translate="yes" xml:space="preserve">
          <source>Executables generated by ocamlopt are native, stand-alone executable files that can be invoked directly. They do not depend on the ocamlrun bytecode runtime system nor on dynamically-loaded C/OCaml stub libraries.</source>
          <target state="translated">ocamlopt生成的可执行文件是本机的、独立的、可直接调用的可执行文件,它们不依赖于ocamlrun字节码运行时系统,也不依赖于动态加载的C/OCaml存根库。它们不依赖于ocamlrun字节码运行时系统,也不依赖于动态加载的C/OCaml存根库。</target>
        </trans-unit>
        <trans-unit id="a75cb0fbe6e1f95d107a45c86db811a6af245781" translate="yes" xml:space="preserve">
          <source>Execute a command and evaluate its output as if it had been captured to a file and passed to #use.</source>
          <target state="translated">执行一个命令,并评估它的输出,就像它已经被捕获到一个文件并传递给#use一样。</target>
        </trans-unit>
        <trans-unit id="cd6abf7887c4d2e28797ef14bbf252bcefcb389d" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status.</source>
          <target state="translated">执行给定的命令,等到其终止,并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="574778ff914e7f066648409df6d7571f66b0628f" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status. The string is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (or the command interpreter &lt;code&gt;cmd.exe&lt;/code&gt; on Windows) and therefore can contain redirections, quotes, variables, etc. To properly quote whitespace and shell special characters occurring in file names or command arguments, the use of &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; is recommended. The result &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; indicates that the shell couldn't be executed.</source>
          <target state="translated">执行给定命令，等待其终止，然后返回其终止状态。该字符串由外壳程序 &lt;code&gt;/bin/sh&lt;/code&gt; （或Windows上的命令解释程序 &lt;code&gt;cmd.exe&lt;/code&gt; ）解释，因此可以包含重定向，引号，变量等。要正确地引用文件名或命令参数中出现的空格和外壳程序特殊字符，建议使用&lt;a href=&quot;filename#VALquote_command&quot;&gt; &lt;code&gt;Filename.quote_command&lt;/code&gt; &lt;/a&gt;。结果 &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; 表示无法执行该Shell。</target>
        </trans-unit>
        <trans-unit id="f7d77de49a824f25b1c29a5f4eec5fd988f90820" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status. The string is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; and therefore can contain redirections, quotes, variables, etc. The result &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; indicates that the shell couldn't be executed.</source>
          <target state="translated">执行给定命令，等待其终止，然后返回其终止状态。该字符串由外壳程序 &lt;code&gt;/bin/sh&lt;/code&gt; 解释，因此可以包含重定向，引号，变量等。结果 &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; 表示无法执行该外壳程序。</target>
        </trans-unit>
        <trans-unit id="0608baa8a78b5ae914f3003511af7be2c2c93014" translate="yes" xml:space="preserve">
          <source>Execute the given shell command and return its exit code.</source>
          <target state="translated">执行给定的shell命令并返回其退出代码。</target>
        </trans-unit>
        <trans-unit id="0af194ef467afd2c1974b37ed62f0bacbfce09b8" translate="yes" xml:space="preserve">
          <source>Execute the next formatting command if the preceding line has just been split.</source>
          <target state="translated">如果前一行刚刚被拆分,则执行下一条格式化命令。</target>
        </trans-unit>
        <trans-unit id="a7de809064d068ca06042492cbbecc713a130fb0" translate="yes" xml:space="preserve">
          <source>Execute the next formatting command if the preceding line has just been split. Otherwise, ignore the next formatting command.</source>
          <target state="translated">如果前一行刚刚被分割,则执行下一条格式化命令。否则,忽略下一个格式化命令。</target>
        </trans-unit>
        <trans-unit id="e6f74a11401cd4113f73bb69746c60cbce990f88" translate="yes" xml:space="preserve">
          <source>Execute the program backward from current time. Mostly useful to go to the last breakpoint encountered before the current time.</source>
          <target state="translated">从当前时间开始向后执行程序。主要用于回到当前时间之前遇到的最后一个断点。</target>
        </trans-unit>
        <trans-unit id="df078a291452a67568ddc09970c248124955e570" translate="yes" xml:space="preserve">
          <source>Execute the program forward from current time. Stops at next breakpoint or when the program terminates.</source>
          <target state="translated">从当前时间向前执行程序。在下一个断点或程序终止时停止。</target>
        </trans-unit>
        <trans-unit id="c02112c85adf1b08f7e5853b39572e0ee9bc6c34" translate="yes" xml:space="preserve">
          <source>Execution permission</source>
          <target state="translated">执行许可</target>
        </trans-unit>
        <trans-unit id="3e880ccfcb55dc69e7de8a37d9266e752fe53e6d" translate="yes" xml:space="preserve">
          <source>Execution speed of instrumented programs may be increased by using a compiler configured with the -disable-libunwind option. This prevents collection of profiling information from C stubs.</source>
          <target state="translated">通过使用配置了-disable-libunwind选项的编译器,可以提高检测程序的执行速度。这可以防止从C存根中收集分析信息。</target>
        </trans-unit>
        <trans-unit id="6612d96f1b19e6fcd3bf9e1ca12e32ac3e408b29" translate="yes" xml:space="preserve">
          <source>Exit the toplevel loop and terminate the ocaml command.</source>
          <target state="translated">退出toplevel循环,终止ocaml命令。</target>
        </trans-unit>
        <trans-unit id="4613952597a60f36dc738da2fc8adbdc7b73e160" translate="yes" xml:space="preserve">
          <source>Explain that the element may raise the exception Exc.</source>
          <target state="translated">解释该元素可能会引发例外情况Exc.</target>
        </trans-unit>
        <trans-unit id="2bbb0891217ae52a1ab104fe98d015359de8bd2c" translate="yes" xml:space="preserve">
          <source>Explicit polymorphic annotations are however not sufficient to cover all the cases where the inferred type of a function is less general than expected. A similar problem arises when using polymorphic functions as arguments of higher-order functions. For instance, we may want to compute the average depth or length of two nested lists:</source>
          <target state="translated">然而,明确的多态注解并不足以涵盖所有的情况,在这些情况下,一个函数的推断类型比预期的要少。当使用多态函数作为高阶函数的参数时,也会出现类似的问题。例如,我们可能想计算两个嵌套列表的平均深度或长度。</target>
        </trans-unit>
        <trans-unit id="4e27dcc67d74da822483f4a87bdb412456ae6c72" translate="yes" xml:space="preserve">
          <source>Exponential.</source>
          <target state="translated">Exponential.</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="19211cb05426c63a6dfeb4df4f1124b3d1c45b8a" translate="yes" xml:space="preserve">
          <source>Exponentiation. &lt;code&gt;exp&amp;nbsp;z&lt;/code&gt; returns &lt;code&gt;e&lt;/code&gt; to the &lt;code&gt;z&lt;/code&gt; power.</source>
          <target state="translated">求幂。 &lt;code&gt;exp&amp;nbsp;z&lt;/code&gt; 返回 &lt;code&gt;e&lt;/code&gt; 到 &lt;code&gt;z&lt;/code&gt; 的幂。</target>
        </trans-unit>
        <trans-unit id="c8d13444fe741e7b3307739c09714d1365b0f345" translate="yes" xml:space="preserve">
          <source>Exponentiation. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">求幂。右关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c203b1d6525313f2263e8e1944c32119cb764891" translate="yes" xml:space="preserve">
          <source>Expression on the left-hand side of a sequence that doesn&amp;rsquo;t have type unit (and that is not a function, see warning number 5).</source>
          <target state="translated">没有类型单位（并且不是函数，请参见警告编号5）的序列左侧的表达式。</target>
        </trans-unit>
        <trans-unit id="60f1705d75bccd5f48e15260577376d17aae18ac" translate="yes" xml:space="preserve">
          <source>Expressions can be evaluated and bound before defining the object body of the class. This is useful to enforce invariants. For instance, points can be automatically adjusted to the nearest point on a grid, as follows:</source>
          <target state="translated">在定义类的对象体之前,可以对表达式进行评估和绑定。这对于强制执行不变性是很有用的。例如,点可以自动调整到网格上最近的点,如下所示。</target>
        </trans-unit>
        <trans-unit id="23bad0bff2cfb9167ce61cc77278d82a1d641c32" translate="yes" xml:space="preserve">
          <source>Expressions found to be constant will be lifted to symbol bindings&amp;mdash;that is to say, they will be statically allocated in the object file&amp;mdash;when they evaluate to boxed values. Such constants may be straightforward numeric constants, such as the floating-point number 42.0, or more complicated values such as constant closures.</source>
          <target state="translated">当发现表达式为常数时，当它们的计算结果为带框值时，它们将被提升为符号绑定（也就是说，它们将被静态分配在目标文件中）。这样的常数可以是简单的数字常数，例如浮点数42.0，也可以是更复杂的值，例如常数闭包。</target>
        </trans-unit>
        <trans-unit id="3ad4d4956756b40be94add29cb72479307f0f0b9" translate="yes" xml:space="preserve">
          <source>Expressions that can be printed are a subset of OCaml expressions, as described by the following grammar:</source>
          <target state="translated">可以打印的表达式是OCaml表达式的一个子集,由以下语法描述。</target>
        </trans-unit>
        <trans-unit id="3dc85e1b2d1a796e6a7518d332650d75cedd74aa" translate="yes" xml:space="preserve">
          <source>Expressions whose type contains object or polymorphic variant types can be explicitly coerced (weakened) to a supertype. The expression (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) coerces the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. The expression (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) coerces the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">类型包含对象或多态变体类型的表达式可以显式强制（削弱）为超类型。表达式（&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;：&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）将表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;types#typexpr&quot;&gt;强制&lt;/a&gt;为typexpr类型。表达式（&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）将表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;从&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;类型&lt;a href=&quot;types#typexpr&quot;&gt;强制&lt;/a&gt;转换为typexpr &lt;sub&gt;2&lt;/sub&gt;类型。</target>
        </trans-unit>
        <trans-unit id="61b81693815dc1bf7299ce7a39fbde9dd09e2888" translate="yes" xml:space="preserve">
          <source>Extensible buffers.</source>
          <target state="translated">可扩展的缓冲器。</target>
        </trans-unit>
        <trans-unit id="a7bb5fa60fa6d03a7e762271e49bf8b6f67aabc7" translate="yes" xml:space="preserve">
          <source>Extensible variant constructors can be declared private. As with regular variants, this prevents them from being constructed directly by constructor application while still allowing them to be de-structured in pattern-matching.</source>
          <target state="translated">可扩展的变体构造函数可以被声明为私有。与普通变体一样,这可以防止它们被构造函数应用直接构造,同时仍然允许它们在模式匹配中被去结构化。</target>
        </trans-unit>
        <trans-unit id="a751b1c007eb71d24f98009b78b3028fcfd142ad" translate="yes" xml:space="preserve">
          <source>Extensible variant constructors can be rebound to a different name. This allows exporting variants from another module.</source>
          <target state="translated">可扩展的变体构造函数可以被重定向为不同的名称。这允许从另一个模块导出变体。</target>
        </trans-unit>
        <trans-unit id="bb163e8407915a65efaeea5f20e5a40195d135d5" translate="yes" xml:space="preserve">
          <source>Extensible variant types are variant types which can be extended with new variant constructors. Extensible variant types are defined using ... New variant constructors are added using +=.</source>
          <target state="translated">可扩展的变体类型是指可以用新的变体构造函数来扩展的变体类型。可扩展的变体类型是用...来定义的。使用+=添加新的变体构造函数。</target>
        </trans-unit>
        <trans-unit id="bbae4e45fe35ccd27009a7f6ac4d50b75dc776ba" translate="yes" xml:space="preserve">
          <source>Extensible variant types can be declared private. This prevents new constructors from being declared directly, but allows extension constructors to be referred to in interfaces.</source>
          <target state="translated">可扩展变体类型可以被声明为私有。这防止了新的构造函数被直接声明,但允许扩展构造函数在接口中被引用。</target>
        </trans-unit>
        <trans-unit id="abad3f737769af1c5381da23ef9ef6b76a078836" translate="yes" xml:space="preserve">
          <source>Extension nodes are generic placeholders in the syntax tree. They are rejected by the type-checker and are intended to be &amp;ldquo;expanded&amp;rdquo; by external tools such as -ppx rewriters.</source>
          <target state="translated">扩展节点是语法树中的通用占位符。它们被类型检查器拒绝，并打算由-ppx重写器之类的外部工具&amp;ldquo;扩展&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ea65aab9d82e10709488254e9311c132af2c2b4c" translate="yes" xml:space="preserve">
          <source>Extension nodes share the same notion of identifier and payload as attributes &amp;zwj;&lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;.</source>
          <target state="translated">扩展节点共享标识符和有效载荷作为属性的相同的概念&lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d5c126d6514cf4043869b49a67a530848a05b30" translate="yes" xml:space="preserve">
          <source>Extension nodes share the same notion of identifier and payload as attributes &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;.</source>
          <target state="translated">扩展节点与属性&lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;共享相同的标识符和有效负载概念。</target>
        </trans-unit>
        <trans-unit id="4cf67e72b2f02af1dfb2d6ba5dfec301a7a98be7" translate="yes" xml:space="preserve">
          <source>External functions thus defined can be specified in interface files or sig&amp;hellip;end signatures either as regular values</source>
          <target state="translated">这样定义的外部功能可以在接口文件或sig&amp;hellip;end签名中指定为常规值</target>
        </trans-unit>
        <trans-unit id="ac72a44ed810b210da3e88f1a54857ee291d450b" translate="yes" xml:space="preserve">
          <source>Extra labeled libraries.</source>
          <target state="translated">额外标注的图书馆。</target>
        </trans-unit>
        <trans-unit id="f790fb266cf755446d7f9e758cc6eb9851e8e4a0" translate="yes" xml:space="preserve">
          <source>Extract a column (one-dimensional slice) of the given two-dimensional Bigarray.</source>
          <target state="translated">提取给定二维Bigarray的一列(一维切片)。</target>
        </trans-unit>
        <trans-unit id="833297ee7526e57b208b20f4c18e1d5dca4a7686" translate="yes" xml:space="preserve">
          <source>Extract a column (one-dimensional slice) of the given two-dimensional Bigarray. The integer parameter is the index of the column to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.slice_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">提取给定二维Bigarray的列（一维切片）。整数参数是要提取的列的索引。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array2.slice_right&lt;/code&gt; 仅适用于具有Fortran布局的阵列。</target>
        </trans-unit>
        <trans-unit id="bb22154616f00f2f011552b3ea60d6b2aecf319e" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the first two coordinates.</source>
          <target state="translated">通过固定前两个坐标,提取给定三维Bigarray的一维切片。</target>
        </trans-unit>
        <trans-unit id="ad37ffd1656e9bfa0f39271771a3d21b053f2b47" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the first two coordinates. The integer parameters are the coordinates of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_left_1&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">通过固定前两个坐标来提取给定三维Bigarray的一维切片。整数参数是要提取的切片的坐标。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array3.slice_left_1&lt;/code&gt; 仅适用于具有C布局的数组。</target>
        </trans-unit>
        <trans-unit id="d6010cd1774b0e36289453cc1e6dfe0970661753" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the last two coordinates.</source>
          <target state="translated">通过固定最后两个坐标,提取给定三维Bigarray的一维切片。</target>
        </trans-unit>
        <trans-unit id="cf737c09a505d01b3f96a5a97197df81b81dd1a3" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the last two coordinates. The integer parameters are the coordinates of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_right_1&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">通过固定最后两个坐标，提取给定三维Bigarray的一维切片。整数参数是要提取的切片的坐标。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array3.slice_right_1&lt;/code&gt; 仅适用于具有Fortran布局的阵列。</target>
        </trans-unit>
        <trans-unit id="a0e5512943bae825f5c013cca4f39482aa0889f2" translate="yes" xml:space="preserve">
          <source>Extract a row (one-dimensional slice) of the given two-dimensional Bigarray.</source>
          <target state="translated">从给定的二维Bigarray中提取一行(一维切片)。</target>
        </trans-unit>
        <trans-unit id="26d59417fe2650d9c47ddc3625b1cd42e8be0565" translate="yes" xml:space="preserve">
          <source>Extract a row (one-dimensional slice) of the given two-dimensional Bigarray. The integer parameter is the index of the row to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.slice_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">提取给定二维Bigarray的一行（一维切片）。整数参数是要提取的行的索引。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array2.slice_left&lt;/code&gt; 仅适用于具有C布局的数组。</target>
        </trans-unit>
        <trans-unit id="f298454ec85bb5b2575358f7258eca1d4945ff16" translate="yes" xml:space="preserve">
          <source>Extract a scalar (zero-dimensional slice) of the given one-dimensional Bigarray.</source>
          <target state="translated">提取给定一维Bigarray的一个标量(零维切片)。</target>
        </trans-unit>
        <trans-unit id="4d9a56c0a314a42963df6eba68beda2c406199e0" translate="yes" xml:space="preserve">
          <source>Extract a scalar (zero-dimensional slice) of the given one-dimensional Bigarray. The integer parameter is the index of the scalar to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">提取给定的一维Bigarray的标量（零维切片）。整数参数是要提取的标量的索引。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4890dc1e2a164bc3bd30e8680621df9dc17f4f52" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the first (left-most) coordinates.</source>
          <target state="translated">从给定的Bigarray中提取一个较低维度的子数组,方法是固定第一个(最左边)坐标的一个或几个。</target>
        </trans-unit>
        <trans-unit id="40d6af71cee95b994ed1e0170824c34a05edad4a" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the first (left-most) coordinates. &lt;code&gt;Genarray.slice_left&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; returns the 'slice' of &lt;code&gt;a&lt;/code&gt; obtained by setting the first &lt;code&gt;M&lt;/code&gt; coordinates to &lt;code&gt;i1&lt;/code&gt;, ..., &lt;code&gt;iM&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has &lt;code&gt;N&lt;/code&gt; dimensions, the slice has dimension &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt;, and the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the slice is identical to the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iM;&amp;nbsp;j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the original array &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the slice and the original array share the same storage space.</source>
          <target state="translated">通过固定一个或几个第一个（最左边的）坐标，从给定的Bigarray中提取一个较小维度的子数组。 &lt;code&gt;Genarray.slice_left&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; 返回通过将第一个 &lt;code&gt;M&lt;/code&gt; 坐标设置为 &lt;code&gt;i1&lt;/code&gt; ，...， &lt;code&gt;iM&lt;/code&gt; 所获得的 &lt;code&gt;a&lt;/code&gt; 的&amp;ldquo;切片&amp;rdquo; 。如果 &lt;code&gt;a&lt;/code&gt; 具有 &lt;code&gt;N&lt;/code&gt; 维，则切片的维数为 &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt; ，并且元素的坐标为 &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; ...; 切片中的j（NM）|]与坐标 &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iM;&amp;nbsp;j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; ...; 我是; j1; ...; 原始数组 &lt;code&gt;a&lt;/code&gt; 中的j（NM）|]。不涉及元素的复制：切片和原始数组共享相同的存储空间。</target>
        </trans-unit>
        <trans-unit id="4991d63b98b224377a908b9a4d6c71e3eaac9a4c" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the last (right-most) coordinates.</source>
          <target state="translated">通过固定最后(最右边)的一个或几个坐标,从给定的Bigarray中提取一个低维的子数组。</target>
        </trans-unit>
        <trans-unit id="3da691a1efc9418f8852a37e8c7a82a916c26169" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the last (right-most) coordinates. &lt;code&gt;Genarray.slice_right&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; returns the 'slice' of &lt;code&gt;a&lt;/code&gt; obtained by setting the last &lt;code&gt;M&lt;/code&gt; coordinates to &lt;code&gt;i1&lt;/code&gt;, ..., &lt;code&gt;iM&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has &lt;code&gt;N&lt;/code&gt; dimensions, the slice has dimension &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt;, and the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the slice is identical to the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M);&amp;nbsp;i1;&amp;nbsp;...;&amp;nbsp;iM|]&lt;/code&gt; in the original array &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the slice and the original array share the same storage space.</source>
          <target state="translated">通过修复最后一个（最右端）坐标中的一个或几个，从给定的Bigarray中提取维数较低的子数组。 &lt;code&gt;Genarray.slice_right&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; 返回通过将最后一个 &lt;code&gt;M&lt;/code&gt; 坐标设置为 &lt;code&gt;i1&lt;/code&gt; ，...， &lt;code&gt;iM&lt;/code&gt; 所获得的 &lt;code&gt;a&lt;/code&gt; 的&amp;ldquo;切片&amp;rdquo; 。如果 &lt;code&gt;a&lt;/code&gt; 具有 &lt;code&gt;N&lt;/code&gt; 维，则切片的维数为 &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt; ，并且元素的坐标为 &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; ...; 切片中的j（NM）|]与坐标 &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M);&amp;nbsp;i1;&amp;nbsp;...;&amp;nbsp;iM|]&lt;/code&gt; ...; j（NM）；i1; ...; iM时|]在原来的阵列 &lt;code&gt;a&lt;/code&gt; 。不涉及元素的复制：切片和原始数组共享相同的存储空间。</target>
        </trans-unit>
        <trans-unit id="c46828383a7b610302db9977200dc3af956d9d40" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the first (left-most) dimension.</source>
          <target state="translated">通过限制第一个(最左)维度来提取给定Bigarray的一个子数组。</target>
        </trans-unit>
        <trans-unit id="4aff802ef1d94d3ecbad0ecdb29da0e7d90a7532" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the first (left-most) dimension. &lt;code&gt;Genarray.sub_left&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; returns a Bigarray with the same number of dimensions as &lt;code&gt;a&lt;/code&gt;, and the same dimensions as &lt;code&gt;a&lt;/code&gt;, except the first dimension, which corresponds to the interval &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; of the first dimension of &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the sub-array and the original array share the same storage space. In other terms, the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the sub-array is identical to the element at coordinates &lt;code&gt;[|i1+ofs;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">通过限制第一个（最左侧）维来提取给定Bigarray的子​​数组。 &lt;code&gt;Genarray.sub_left&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; 返回Bigarray具有相同数量的尺寸的 &lt;code&gt;a&lt;/code&gt; 和相同的尺寸 &lt;code&gt;a&lt;/code&gt; ，除了第一维，其对应于所述间隔 &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; 第一尺寸的的 &lt;code&gt;a&lt;/code&gt; 。不涉及元素复制：子阵列和原始阵列共享相同的存储空间。换句话说，元素位于坐标 &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; 子数组的iN |]与坐标 &lt;code&gt;[|i1+ofs;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; 原始数组的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec56516e6aae1f3b317a5b584d2632b8a7b8895e" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the last (right-most) dimension.</source>
          <target state="translated">通过限制最后一个(最右边)维度来提取给定Bigarray的一个子数组。</target>
        </trans-unit>
        <trans-unit id="a34e0eda1631250d817bcac2137b343bc89c7dd1" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the last (right-most) dimension. &lt;code&gt;Genarray.sub_right&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; returns a Bigarray with the same number of dimensions as &lt;code&gt;a&lt;/code&gt;, and the same dimensions as &lt;code&gt;a&lt;/code&gt;, except the last dimension, which corresponds to the interval &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; of the last dimension of &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the sub-array and the original array share the same storage space. In other terms, the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the sub-array is identical to the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN+ofs|]&lt;/code&gt; of the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">通过限制最后一个（最右边）维来提取给定Bigarray的子​​数组。 &lt;code&gt;Genarray.sub_right&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; 返回Bigarray具有相同数量的尺寸的 &lt;code&gt;a&lt;/code&gt; 和相同的尺寸 &lt;code&gt;a&lt;/code&gt; ，除了最后尺寸，这对应于间隔 &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; 的最后一维的的 &lt;code&gt;a&lt;/code&gt; 。不涉及元素复制：子阵列和原始阵列共享相同的存储空间。换句话说，元素位于坐标 &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; 子数组的iN |]与坐标 &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN+ofs|]&lt;/code&gt; 原始数组 &lt;code&gt;a&lt;/code&gt; 的iN + ofs |]。</target>
        </trans-unit>
        <trans-unit id="f5554ff9dda92542b6f7561e6614060047356a2b" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given one-dimensional Bigarray.</source>
          <target state="translated">提取给定一维Bigarray的一个子数组。</target>
        </trans-unit>
        <trans-unit id="d0974dd62db48917a734039db3543ccc1edaf6d5" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given one-dimensional Bigarray. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">提取给定的一维Bigarray的子​​数组。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e53e9d490ec58fcd840b3ecff5aa4d740c5a251b" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the first dimension.</source>
          <target state="translated">通过限制第一维,提取给定三维Bigarray的三维子阵列。</target>
        </trans-unit>
        <trans-unit id="2dbaf2cc98d146044211330545282dd4bf053e2b" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the first dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.sub_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">通过限制第一维，提取给定三维Bigarray的三维子数组。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array3.sub_left&lt;/code&gt; 仅适用于具有C布局的数组。</target>
        </trans-unit>
        <trans-unit id="c7316b8d9a713505a81c0b289dbb0aa52b6e1f01" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the second dimension.</source>
          <target state="translated">通过限制二维,提取给定三维Bigarray的三维子阵列。</target>
        </trans-unit>
        <trans-unit id="056b02ba98ed67c31e20bd342a4e027d66f1e6cc" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the second dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.sub_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">通过限制第二维，提取给定三维Bigarray的三维子数组。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array3.sub_right&lt;/code&gt; 仅适用于具有Fortran布局的阵列。</target>
        </trans-unit>
        <trans-unit id="6c50856385dbad4b307a8ae71cadaf999e22cc35" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the first coordinate.</source>
          <target state="translated">通过固定第一坐标,提取给定三维Bigarray的二维切片。</target>
        </trans-unit>
        <trans-unit id="d59aaaea254d72dfb6345bd1442c286d26075296" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the first coordinate. The integer parameter is the first coordinate of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_left_2&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">通过固定第一个坐标，提取给定三维Bigarray的二维切片。整数参数是要提取的切片的第一个坐标。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array3.slice_left_2&lt;/code&gt; 仅适用于具有C布局的数组。</target>
        </trans-unit>
        <trans-unit id="5d3c305334b5904d71fa016401a34c6c315c3352" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the last coordinate.</source>
          <target state="translated">通过固定最后一个坐标,提取给定三维Bigarray的二维切片。</target>
        </trans-unit>
        <trans-unit id="3884aec3f88c9f1f2b2e3b25f39bd946908fcc74" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the last coordinate. The integer parameter is the coordinate of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_right_2&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">通过固定最后一个坐标，提取给定三维Bigarray的二维切片。整数参数是要提取的切片的坐标。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array3.slice_right_2&lt;/code&gt; 仅适用于具有Fortran布局的阵列。</target>
        </trans-unit>
        <trans-unit id="d60284e2482e2e7da314ae1de64dae482731ef85" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the first dimension.</source>
          <target state="translated">通过限制第一维,提取给定的二维Bigarray的二维子数组。</target>
        </trans-unit>
        <trans-unit id="3a423ddd0f0211bed822fd7dfab480315f3a9a59" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the first dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.sub_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">通过限制第一维来提取给定二维Bigarray的二维子数组。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array2.sub_left&lt;/code&gt; 仅适用于具有C布局的数组。</target>
        </trans-unit>
        <trans-unit id="3ed998f4ffe6b722cf6d8ef34b19960eb7ede4ad" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the second dimension.</source>
          <target state="translated">通过限制二维Bigarray的二维子数组提取。</target>
        </trans-unit>
        <trans-unit id="ccaeebe42f0e1c15c6787813703cfa497e76749e" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the second dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.sub_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">通过限制第二维，提取给定二维Bigarray的二维子数组。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Array2.sub_right&lt;/code&gt; 仅适用于具有Fortran布局的阵列。</target>
        </trans-unit>
        <trans-unit id="5ad5026b7dc3bacdd43b7f246a7f6d355abdaa47" translate="yes" xml:space="preserve">
          <source>Extracting substrings</source>
          <target state="translated">提取子序列</target>
        </trans-unit>
        <trans-unit id="99b9db1548668247eee1e8880959fa3591e3a3f0" translate="yes" xml:space="preserve">
          <source>Extracts the user-friendly &lt;code&gt;backtrace_slot&lt;/code&gt; from a low-level &lt;code&gt;raw_backtrace_slot&lt;/code&gt;.</source>
          <target state="translated">从低级别的 &lt;code&gt;raw_backtrace_slot&lt;/code&gt; 提取用户友好的 &lt;code&gt;backtrace_slot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="9b227096d517556947fe5ddf19ad842bf0317b23" translate="yes" xml:space="preserve">
          <source>Facilities for printing exceptions and inspecting current call stack.</source>
          <target state="translated">打印异常和检查当前调用栈的功能。</target>
        </trans-unit>
        <trans-unit id="5ea25d08286e5c67d1bfdcc8c7290314f442be43" translate="yes" xml:space="preserve">
          <source>Fail if existing</source>
          <target state="translated">如果存在,则失败</target>
        </trans-unit>
        <trans-unit id="ecb4bd69a6ae63ba2585855d8e2360544daa005f" translate="yes" xml:space="preserve">
          <source>Fail if host name cannot be determined</source>
          <target state="translated">如果不能确定主机名,则失败</target>
        </trans-unit>
        <trans-unit id="49181351ef86b5c339057ac4b44372106d23409e" translate="yes" xml:space="preserve">
          <source>Fall back to building a statically linked library if a problem occurs while building the shared library (e.g. some of the support libraries are not available as shared libraries).</source>
          <target state="translated">如果在构建共享库的时候出现问题(如某些支持库不能作为共享库使用),则退回到构建静态链接库。</target>
        </trans-unit>
        <trans-unit id="7f914367bce8b82c6d2195d3b60d9769e3807c9c" translate="yes" xml:space="preserve">
          <source>Field(v, n) returns the value contained in the n&lt;sup&gt;th&lt;/sup&gt; field of the structured block v. Fields are numbered from 0 to Wosize_val(v)&amp;minus;1.</source>
          <target state="translated">Field（v，n）返回结构化块v的&lt;sup&gt;第&lt;/sup&gt;n&lt;sup&gt;个&lt;/sup&gt;字段中包含的值。字段的编号从0到Wosize_val（v）-1。</target>
        </trans-unit>
        <trans-unit id="1357f987d25405bca293332f1eeee71384be4553" translate="yes" xml:space="preserve">
          <source>File descriptor for standard error.</source>
          <target state="translated">标准误差的文件描述符。</target>
        </trans-unit>
        <trans-unit id="77574dc3227cd0b3aba7be8d0ef544f784522a63" translate="yes" xml:space="preserve">
          <source>File descriptor for standard input.</source>
          <target state="translated">标准输入的文件描述符。</target>
        </trans-unit>
        <trans-unit id="9e96c4faba360baae26988330ca973ca4d0050a8" translate="yes" xml:space="preserve">
          <source>File descriptor for standard output.</source>
          <target state="translated">标准输出的文件描述符。</target>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="translated">文件存在</target>
        </trans-unit>
        <trans-unit id="af796a734908b2af6a033fc6dd399e38e2271966" translate="yes" xml:space="preserve">
          <source>File operations on large files</source>
          <target state="translated">大文件的文件操作</target>
        </trans-unit>
        <trans-unit id="c76015cd07e74ef92d5b2a92fce2d1e110d93be0" translate="yes" xml:space="preserve">
          <source>File operations on large files.</source>
          <target state="translated">对大文件进行文件操作。</target>
        </trans-unit>
        <trans-unit id="5216af1ac5b2e2dabbd11ec27979253222912a30" translate="yes" xml:space="preserve">
          <source>File operations on large files. This sub-module provides 64-bit variants of the functions &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt; (for positioning a file descriptor), &lt;a href=&quot;unix#VALtruncate&quot;&gt;&lt;code&gt;Unix.truncate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALftruncate&quot;&gt;&lt;code&gt;Unix.ftruncate&lt;/code&gt;&lt;/a&gt; (for changing the size of a file), and &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALlstat&quot;&gt;&lt;code&gt;Unix.lstat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALfstat&quot;&gt;&lt;code&gt;Unix.fstat&lt;/code&gt;&lt;/a&gt; (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type &lt;code&gt;int64&lt;/code&gt;) instead of regular integers (type &lt;code&gt;int&lt;/code&gt;), thus allowing operating on files whose sizes are greater than &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">大文件的文件操作。此子模块提供&lt;a href=&quot;unix#VALlseek&quot;&gt; &lt;code&gt;Unix.lseek&lt;/code&gt; &lt;/a&gt;函数（用于定位文件描述符），&lt;a href=&quot;unix#VALtruncate&quot;&gt; &lt;code&gt;Unix.truncate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unix#VALftruncate&quot;&gt; &lt;code&gt;Unix.ftruncate&lt;/code&gt; &lt;/a&gt;（用于更改文件大小）以及&lt;a href=&quot;unix#VALstat&quot;&gt; &lt;code&gt;Unix.stat&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;unix#VALlstat&quot;&gt; &lt;code&gt;Unix.lstat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unix#VALfstat&quot;&gt; &lt;code&gt;Unix.fstat&lt;/code&gt; &lt;/a&gt;64位变体。.fstat（用于获取文件信息）。这些替代函数用64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）而不是规则整数（类型 &lt;code&gt;int&lt;/code&gt; ）表示位置和大小，从而允许对大小大于 &lt;code&gt;max_int&lt;/code&gt; 的文件进行操作。</target>
        </trans-unit>
        <trans-unit id="53574d32c7c0ae07a80262aff1e28132a5ad38d9" translate="yes" xml:space="preserve">
          <source>File operations on large files. This sub-module provides 64-bit variants of the functions &lt;a href=&quot;unix.largefile#VALlseek&quot;&gt;&lt;code&gt;Unix.LargeFile.lseek&lt;/code&gt;&lt;/a&gt; (for positioning a file descriptor), &lt;a href=&quot;unix.largefile#VALtruncate&quot;&gt;&lt;code&gt;Unix.LargeFile.truncate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix.largefile#VALftruncate&quot;&gt;&lt;code&gt;Unix.LargeFile.ftruncate&lt;/code&gt;&lt;/a&gt; (for changing the size of a file), and &lt;a href=&quot;unix.largefile#VALstat&quot;&gt;&lt;code&gt;Unix.LargeFile.stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix.largefile#VALlstat&quot;&gt;&lt;code&gt;Unix.LargeFile.lstat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix.largefile#VALfstat&quot;&gt;&lt;code&gt;Unix.LargeFile.fstat&lt;/code&gt;&lt;/a&gt; (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type &lt;code&gt;int64&lt;/code&gt;) instead of regular integers (type &lt;code&gt;int&lt;/code&gt;), thus allowing operating on files whose sizes are greater than &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">大文件的文件操作。此子模块提供&lt;a href=&quot;unix.largefile#VALlseek&quot;&gt; &lt;code&gt;Unix.LargeFile.lseek&lt;/code&gt; &lt;/a&gt;（用于定位文件描述符），&lt;a href=&quot;unix.largefile#VALtruncate&quot;&gt; &lt;code&gt;Unix.LargeFile.truncate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unix.largefile#VALftruncate&quot;&gt; &lt;code&gt;Unix.LargeFile.ftruncate&lt;/code&gt; &lt;/a&gt;（用于更改文件大小）和&lt;a href=&quot;unix.largefile#VALstat&quot;&gt; &lt;code&gt;Unix.LargeFile.stat&lt;/code&gt; &lt;/a&gt;64位变体。.stat，&lt;a href=&quot;unix.largefile#VALlstat&quot;&gt; &lt;code&gt;Unix.LargeFile.lstat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unix.largefile#VALfstat&quot;&gt; &lt;code&gt;Unix.LargeFile.fstat&lt;/code&gt; &lt;/a&gt;（用于获取文件信息）。这些替代函数用64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）而不是规则整数（类型 &lt;code&gt;int&lt;/code&gt; ）表示位置和大小，从而允许对大小大于 &lt;code&gt;max_int&lt;/code&gt; 的文件进行操作。</target>
        </trans-unit>
        <trans-unit id="ebe66056a71a2dfbc4eea74801f25159274efcb1" translate="yes" xml:space="preserve">
          <source>File operations on large files. This sub-module provides 64-bit variants of the functions &lt;a href=&quot;unixlabels#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.lseek&lt;/code&gt;&lt;/a&gt; (for positioning a file descriptor), &lt;a href=&quot;unixlabels#VALtruncate&quot;&gt;&lt;code&gt;UnixLabels.truncate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALftruncate&quot;&gt;&lt;code&gt;UnixLabels.ftruncate&lt;/code&gt;&lt;/a&gt; (for changing the size of a file), and &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALlstat&quot;&gt;&lt;code&gt;UnixLabels.lstat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALfstat&quot;&gt;&lt;code&gt;UnixLabels.fstat&lt;/code&gt;&lt;/a&gt; (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type &lt;code&gt;int64&lt;/code&gt;) instead of regular integers (type &lt;code&gt;int&lt;/code&gt;), thus allowing operating on files whose sizes are greater than &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">大文件的文件操作。该子模块提供&lt;a href=&quot;unixlabels#VALlseek&quot;&gt; &lt;code&gt;UnixLabels.lseek&lt;/code&gt; &lt;/a&gt;（用于定位文件描述符），&lt;a href=&quot;unixlabels#VALtruncate&quot;&gt; &lt;code&gt;UnixLabels.truncate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unixlabels#VALftruncate&quot;&gt; &lt;code&gt;UnixLabels.ftruncate&lt;/code&gt; &lt;/a&gt;（用于更改文件大小）以及&lt;a href=&quot;unixlabels#VALstat&quot;&gt; &lt;code&gt;UnixLabels.stat&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;unixlabels#VALlstat&quot;&gt; &lt;code&gt;UnixLabels.lstat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unixlabels#VALfstat&quot;&gt; &lt;code&gt;UnixLabels.fstat&lt;/code&gt; &lt;/a&gt;函数的64位变体。.fstat（用于获取文件信息）。这些替代函数用64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）而不是规则整数（类型 &lt;code&gt;int&lt;/code&gt; ）表示位置和大小，从而允许对大小大于 &lt;code&gt;max_int&lt;/code&gt; 的文件进行操作。</target>
        </trans-unit>
        <trans-unit id="8cbbb93007d56f414c91bcdef18ef37885c246e7" translate="yes" xml:space="preserve">
          <source>File operations on large files. This sub-module provides 64-bit variants of the functions &lt;a href=&quot;unixlabels.largefile#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.LargeFile.lseek&lt;/code&gt;&lt;/a&gt; (for positioning a file descriptor), &lt;a href=&quot;unixlabels.largefile#VALtruncate&quot;&gt;&lt;code&gt;UnixLabels.LargeFile.truncate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels.largefile#VALftruncate&quot;&gt;&lt;code&gt;UnixLabels.LargeFile.ftruncate&lt;/code&gt;&lt;/a&gt; (for changing the size of a file), and &lt;a href=&quot;unixlabels.largefile#VALstat&quot;&gt;&lt;code&gt;UnixLabels.LargeFile.stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels.largefile#VALlstat&quot;&gt;&lt;code&gt;UnixLabels.LargeFile.lstat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels.largefile#VALfstat&quot;&gt;&lt;code&gt;UnixLabels.LargeFile.fstat&lt;/code&gt;&lt;/a&gt; (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type &lt;code&gt;int64&lt;/code&gt;) instead of regular integers (type &lt;code&gt;int&lt;/code&gt;), thus allowing operating on files whose sizes are greater than &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">大文件的文件操作。该子模块提供&lt;a href=&quot;unixlabels.largefile#VALlseek&quot;&gt; &lt;code&gt;UnixLabels.LargeFile.lseek&lt;/code&gt; &lt;/a&gt;（用于定位文件描述符），&lt;a href=&quot;unixlabels.largefile#VALtruncate&quot;&gt; &lt;code&gt;UnixLabels.LargeFile.truncate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unixlabels.largefile#VALftruncate&quot;&gt; &lt;code&gt;UnixLabels.LargeFile.ftruncate&lt;/code&gt; &lt;/a&gt;（用于更改文件的大小）以及&lt;a href=&quot;unixlabels.largefile#VALstat&quot;&gt; &lt;code&gt;UnixLabels.LargeFile.stat&lt;/code&gt; &lt;/a&gt;的功能的64位变体。.stat，&lt;a href=&quot;unixlabels.largefile#VALlstat&quot;&gt; &lt;code&gt;UnixLabels.LargeFile.lstat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unixlabels.largefile#VALfstat&quot;&gt; &lt;code&gt;UnixLabels.LargeFile.fstat&lt;/code&gt; &lt;/a&gt;（用于获取文件信息）。这些替代函数用64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）而不是规则整数（类型 &lt;code&gt;int&lt;/code&gt; ）表示位置和大小，从而允许对大小大于 &lt;code&gt;max_int&lt;/code&gt; 的文件进行操作。</target>
        </trans-unit>
        <trans-unit id="2fbef3ee3d6f5c033c6b0bfc9ab2581751e1aa6e" translate="yes" xml:space="preserve">
          <source>File permissions and ownership</source>
          <target state="translated">文件权限和所有权</target>
        </trans-unit>
        <trans-unit id="28350cca828096efd67f5a171372164c14d8d2d6" translate="yes" xml:space="preserve">
          <source>File size limit exceeded</source>
          <target state="translated">超过文件大小限制</target>
        </trans-unit>
        <trans-unit id="ce8eb49cc7bfa53c4610e26085f92f61b9a4f0a4" translate="yes" xml:space="preserve">
          <source>File size or position not representable</source>
          <target state="translated">文件大小或位置无法表示</target>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="translated">文件状态</target>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="translated">文件太大</target>
        </trans-unit>
        <trans-unit id="a3cbb98ddf5ee976bc1c3be5221d66ce3ca2e867" translate="yes" xml:space="preserve">
          <source>Filename</source>
          <target state="translated">Filename</target>
        </trans-unit>
        <trans-unit id="5ba8d30ffba45db4e2f3f220829fe902e2fd990f" translate="yes" xml:space="preserve">
          <source>Filename too long</source>
          <target state="translated">文件名太长</target>
        </trans-unit>
        <trans-unit id="81d0bcfe0109818a103380175b84cf616a760f08" translate="yes" xml:space="preserve">
          <source>Fill the &lt;code&gt;ai_canonname&lt;/code&gt; field of the result</source>
          <target state="translated">填写结果的 &lt;code&gt;ai_canonname&lt;/code&gt; 字段</target>
        </trans-unit>
        <trans-unit id="8ecdaab3e6d2d606bd8449af095659f45138d642" translate="yes" xml:space="preserve">
          <source>Fill the given Bigarray with the given value.</source>
          <target state="translated">用给定的值填充给定的Bigarray。</target>
        </trans-unit>
        <trans-unit id="6426f6cf359319ede0b204876e95f5ca2c6e0acd" translate="yes" xml:space="preserve">
          <source>Fill the given Bigarray with the given value. See &lt;a href=&quot;bigarray.genarray#VALfill&quot;&gt;&lt;code&gt;Bigarray.Genarray.fill&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">用给定的值填充给定的Bigarray。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALfill&quot;&gt; &lt;code&gt;Bigarray.Genarray.fill&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93a587be0d1e238f9acba4f84df57908d1acb443" translate="yes" xml:space="preserve">
          <source>Finally, a phrase can also consist in a toplevel directive, starting with # (the sharp sign). These directives control the behavior of the toplevel; they are listed below in section &amp;zwj;&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;.</source>
          <target state="translated">最后，短语也可以包含在以＃（尖号）开头的顶级指令中。这些指令控制顶层的行为。他们在节中列出以下&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9fc75d6ebb6ea7b34fae8807788459e575487d7" translate="yes" xml:space="preserve">
          <source>Finally, a phrase can also consist in a toplevel directive, starting with # (the sharp sign). These directives control the behavior of the toplevel; they are listed below in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;.</source>
          <target state="translated">最后，短语也可以包含在以＃（尖号）开头的顶级指令中。这些指令控制顶层的行为。它们在下面的&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;节中列出。</target>
        </trans-unit>
        <trans-unit id="3f8b257b998bf370bb0864536531b33eb161b3e4" translate="yes" xml:space="preserve">
          <source>Finally, create a library containing all the compilation units, and export all the compiled interfaces.</source>
          <target state="translated">最后,创建一个包含所有编译单元的库,并导出所有编译后的接口。</target>
        </trans-unit>
        <trans-unit id="50d88cc7e5d915fe4d69c0be69de0f08fe1b0b62" translate="yes" xml:space="preserve">
          <source>Finally, if including the right headers is not enough, or if you need to support version older than OCaml 4.04, the header file caml/version.h should help you to define your own compatibility layer. This file provides few macros defining the current OCaml version. In particular, the OCAML_VERSION macro describes the current version, its format is MmmPP. For example, if you need some specific handling for versions older than 4.10.0, you could write</source>
          <target state="translated">最后,如果包含正确的头文件还不够,或者你需要支持比OCaml 4.04更老的版本,头文件caml/version.h应该可以帮助你定义自己的兼容层。这个文件提供了一些宏来定义当前的OCaml版本。特别是OCAML_VERSION宏描述了当前的版本,其格式是MmPP。例如,如果你需要对比4.10.0老的版本进行一些特殊的处理,你可以写道</target>
        </trans-unit>
        <trans-unit id="9372cdb14bc15de60bc5e7493ee69b5c137db75b" translate="yes" xml:space="preserve">
          <source>Finally, we gather several versions of the account into a module Account abstracted over some currency.</source>
          <target state="translated">最后,我们将账户的几个版本收集到一个模块中,账户抽象在一些货币上。</target>
        </trans-unit>
        <trans-unit id="ad882b96aa31ea8bc7379f773276601fa589c285" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given group id, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="translated">在具有给定组ID的 &lt;code&gt;group&lt;/code&gt; 找到一个条目，如果找不到匹配的条目，则引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d26059b49746e12250bbbdde11904eb0a2908b9" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given group id.</source>
          <target state="translated">在具有给定组ID的 &lt;code&gt;group&lt;/code&gt; 找到一个条目。</target>
        </trans-unit>
        <trans-unit id="415672a50455cf18e72d28b263ffd7e70776bbce" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="translated">在给定名称的 &lt;code&gt;group&lt;/code&gt; 找到一个条目，如果找不到匹配的条目，则引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92938192f2f9c813f7a89a800c2c6c6ea821e47d" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given name.</source>
          <target state="translated">在 &lt;code&gt;group&lt;/code&gt; 找到具有给定名称的条目。</target>
        </trans-unit>
        <trans-unit id="a0dce113945863d2224b0beb1e150e7180b7e955" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given address, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">在具有给定地址的 &lt;code&gt;hosts&lt;/code&gt; 查找条目，或引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30ddd89ef5b82ec68bbf502dfb947c7b9bd0e70b" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given address.</source>
          <target state="translated">在具有给定地址的 &lt;code&gt;hosts&lt;/code&gt; 查找条目。</target>
        </trans-unit>
        <trans-unit id="81a3eb4a551ad19524b170ab21163001e6371bac" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">在具有给定名称的 &lt;code&gt;hosts&lt;/code&gt; 查找条目，或引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b86d33490f4cae6fae2da0fe5ecd27bc2fc74df" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given name.</source>
          <target state="translated">在具有给定名称的 &lt;code&gt;hosts&lt;/code&gt; 查找条目。</target>
        </trans-unit>
        <trans-unit id="6cc118e247a8d977a586a8aed063f755749a92c5" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="translated">在 &lt;code&gt;passwd&lt;/code&gt; 中找到具有给定名称的条目，如果找不到匹配的条目，则引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2239e5756daa56658451b2b6060633b9a9cbe318" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given name.</source>
          <target state="translated">在 &lt;code&gt;passwd&lt;/code&gt; 中找到具有给定名称的条目。</target>
        </trans-unit>
        <trans-unit id="c4956c4aaa9568df15a5e919f5fa7dbcb39bfe35" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given user id, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="translated">在 &lt;code&gt;passwd&lt;/code&gt; 中找到具有给定用户ID的条目，如果找不到匹配的条目，则引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc1c8ede71044655837ceea95734b149dfdb1446" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given user id.</source>
          <target state="translated">在 &lt;code&gt;passwd&lt;/code&gt; 中找到具有给定用户ID的条目。</target>
        </trans-unit>
        <trans-unit id="2491f8eb89441b7ffa07d073b5e5195dba3665c0" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;protocols&lt;/code&gt; 找到具有给定名称的条目，或引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="325fdfe66274840cb9feff3f357702550e5e78f1" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given name.</source>
          <target state="translated">在 &lt;code&gt;protocols&lt;/code&gt; 找到具有给定名称的条目。</target>
        </trans-unit>
        <trans-unit id="c7c982b244a847e041753c0f4d8e15cef7f19d9c" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given protocol number, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">在具有给定协议编号的 &lt;code&gt;protocols&lt;/code&gt; 查找条目，或引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47dd1860c6bae894b93ee4c1a2019df843e7ab0e" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given protocol number.</source>
          <target state="translated">在具有给定协议编号的 &lt;code&gt;protocols&lt;/code&gt; 找到一个条目。</target>
        </trans-unit>
        <trans-unit id="aa44dc4c834bf5ab60c686285de2c6235d10c301" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">在给定名称的 &lt;code&gt;services&lt;/code&gt; 查找条目，或引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d662695744400a189d48c36205ae8921c8e43f1" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given name.</source>
          <target state="translated">在给定名称的 &lt;code&gt;services&lt;/code&gt; 找到一个条目。</target>
        </trans-unit>
        <trans-unit id="b9c773c60870eda8ae407ffce7a213a96aeb9ce7" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given service number, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">在具有给定服务编号的 &lt;code&gt;services&lt;/code&gt; 查找条目，或引发 &lt;code&gt;Not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="711cd41753b69e36be6081e673e29c9bba5549ef" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given service number.</source>
          <target state="translated">查找具有给定服务编号的 &lt;code&gt;services&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="224b0f27dd417f552000763b5bba3875baadfe82" translate="yes" xml:space="preserve">
          <source>First, types whose name starts with a $ are existentials.</source>
          <target state="translated">首先,名字以$开头的类型是存在式。</target>
        </trans-unit>
        <trans-unit id="de6dd7f2a65d07b376909c34498631be78cbdea7" translate="yes" xml:space="preserve">
          <source>First-class synchronous communication.</source>
          <target state="translated">一流的同步通信。</target>
        </trans-unit>
        <trans-unit id="1f6ff868642ca48eb4b81c33bcd5b9b519321189" translate="yes" xml:space="preserve">
          <source>First-in first-out queues.</source>
          <target state="translated">先入先出的队列。</target>
        </trans-unit>
        <trans-unit id="12c38d1674ad0209e2429c06f4b4d86c81433a53" translate="yes" xml:space="preserve">
          <source>Flags for &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALwaitpid&quot;&gt; &lt;code&gt;Unix.waitpid&lt;/code&gt; 的&lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="91c7e7cca135a02bd447cc6e7d8f0122b119c272" translate="yes" xml:space="preserve">
          <source>Flags for &lt;a href=&quot;unixlabels#VALwaitpid&quot;&gt;&lt;code&gt;UnixLabels.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALwaitpid&quot;&gt; &lt;code&gt;UnixLabels.waitpid&lt;/code&gt; 的&lt;/a&gt;标志。</target>
        </trans-unit>
        <trans-unit id="4a84fb5772adecead6ba93384fad981b2515026b" translate="yes" xml:space="preserve">
          <source>Flags for the &lt;a href=&quot;unix#VALaccess&quot;&gt;&lt;code&gt;Unix.access&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">&lt;a href=&quot;unix#VALaccess&quot;&gt; &lt;code&gt;Unix.access&lt;/code&gt; &lt;/a&gt;调用的标志。</target>
        </trans-unit>
        <trans-unit id="c04b5e36ad94721fdf773f89577544e40df649c7" translate="yes" xml:space="preserve">
          <source>Flags for the &lt;a href=&quot;unixlabels#VALaccess&quot;&gt;&lt;code&gt;UnixLabels.access&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALaccess&quot;&gt; &lt;code&gt;UnixLabels.access&lt;/code&gt; &lt;/a&gt;调用的标志。</target>
        </trans-unit>
        <trans-unit id="5fcd3d30dcc0ef0e2661f1baca5e3584ddbdad0c" translate="yes" xml:space="preserve">
          <source>Flambda aims to make it easier to write idiomatic OCaml code without incurring performance penalties.</source>
          <target state="translated">Flambda的目的是使其更容易编写习惯的OCaml代码,而不会造成性能上的损失。</target>
        </trans-unit>
        <trans-unit id="8594db97e2953372022ef97b5a0aa23e010af265" translate="yes" xml:space="preserve">
          <source>Flambda does not yet optimise array or string bounds checks. Neither does it take hints for optimisation from any assertions written by the user in the code.</source>
          <target state="translated">Flambda还没有对数组或字符串边界检查进行优化。它也不会从用户在代码中编写的任何断言中获取优化的提示。</target>
        </trans-unit>
        <trans-unit id="9f181cc9d2dc162d147e6a4c0a48c733ee687d31" translate="yes" xml:space="preserve">
          <source>Flambda operates in &lt;em&gt;rounds&lt;/em&gt;: one round consists of a certain sequence of transformations that may then be repeated in order to achieve more satisfactory results. The number of rounds can be set manually using the -rounds parameter (although this is not necessary when using predefined optimisation levels such as with -O2 and -O3). For high optimisation the number of rounds might be set at 3 or 4.</source>
          <target state="translated">Flambda工作在&lt;em&gt;回合&lt;/em&gt;：一个轮包括变换的特定的顺序，其可以然后以达到更满意的结果可重复的。可以使用-rounds参数手动设置轮数（尽管在使用预定义的优化级别（例如-O2和-O3）时，这不是必需的）。为了进行高度优化，可以将回合数设置为3或4。</target>
        </trans-unit>
        <trans-unit id="2a5104c85ccca5769d7427f3784e8923de3f98aa" translate="yes" xml:space="preserve">
          <source>Flambda performs a simple analysis analogous to that performed elsewhere in the compiler that can transform refs into mutable variables that may then be held in registers (or on the stack as appropriate) rather than being allocated on the OCaml heap. This only happens so long as the reference concerned can be shown to not escape from its defining scope.</source>
          <target state="translated">Flambda 执行一个简单的分析,类似于编译器中其他地方执行的分析,它可以将 refs 转化为可变变量,然后可以将其保存在寄存器中(或堆栈中),而不是在 OCaml 堆中分配。只有当相关的引用被证明没有从其定义的作用域中逃逸时,这种情况才会发生。</target>
        </trans-unit>
        <trans-unit id="efb9d7aff651e52ca05571e619d1613ce6de9b63" translate="yes" xml:space="preserve">
          <source>Flambda provides full optimisation across different compilation units, so long as the .cmx files for the dependencies of the unit currently being compiled are available. (A compilation unit corresponds to a single .ml source file.) However it does not yet act entirely as a whole-program compiler: for example, elimination of dead code across a complete set of compilation units is not supported.</source>
          <target state="translated">只要当前正在编译的单元的依赖关系的.cmx文件可用,Flambda就能在不同的编译单元中提供全面的优化。(一个编译单元对应一个.ml源文件)然而,它还不能完全作为一个整体的程序编译器。(一个编译单元对应一个单一的.ml源文件。)然而,它还不能完全作为一个全程序编译器:例如,不支持在一个完整的编译单元中消除死代码。</target>
        </trans-unit>
        <trans-unit id="a889b00bf27975324866ab0b134e19b27ed12786" translate="yes" xml:space="preserve">
          <source>Flambda provides significantly enhanced inlining capabilities relative to previous versions of the compiler.</source>
          <target state="translated">相对于以前版本的编译器,Flambda提供了显著增强的内联功能。</target>
        </trans-unit>
        <trans-unit id="83fc5d0d47e89499dddacc507c5a4ada2b7015ab" translate="yes" xml:space="preserve">
          <source>Flambda should not in general affect the semantics of existing programs. Two exceptions to this rule are: possible elimination of pure code that is being benchmarked (see section &lt;a href=&quot;#s%3Aflambda-inhibition&quot;&gt;19.14&lt;/a&gt;) and changes in behaviour of code using unsafe operations (see section &lt;a href=&quot;#s%3Aflambda-unsafe&quot;&gt;19.15&lt;/a&gt;).</source>
          <target state="translated">Flambda通常不应影响现有程序的语义。该规则的两个例外是：可能消除正在基准测试的纯代码（请参阅第&lt;a href=&quot;#s%3Aflambda-inhibition&quot;&gt;19.14&lt;/a&gt;节）和使用不安全的操作来更改代码的行为（请参阅第&lt;a href=&quot;#s%3Aflambda-unsafe&quot;&gt;19.15&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="61063e2e8cd24e333286a73b0688eea6bacd5de4" translate="yes" xml:space="preserve">
          <source>Flambda should not in general affect the semantics of existing programs. Two exceptions to this rule are: possible elimination of pure code that is being benchmarked (see section &lt;a href=&quot;#s%3Aflambda-inhibition&quot;&gt;21.14&lt;/a&gt;) and changes in behaviour of code using unsafe operations (see section &lt;a href=&quot;#s%3Aflambda-unsafe&quot;&gt;21.15&lt;/a&gt;).</source>
          <target state="translated">Flambda通常不应影响现有程序的语义。该规则的两个例外是：可能消除正在基准测试的纯代码（请参阅第&lt;a href=&quot;#s%3Aflambda-inhibition&quot;&gt;21.14&lt;/a&gt;节）和使用不安全的操作来更改代码的行为（请参见第&lt;a href=&quot;#s%3Aflambda-unsafe&quot;&gt;21.15&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="219d126ce0d3a407f2d7b93cc5f4b89615a19194" translate="yes" xml:space="preserve">
          <source>Flambda-specific flags are silently accepted even when the -flambda option was not provided to the configure script. (There is no means provided to change this behaviour.) This is intended to make it more straightforward to run benchmarks with and without the Flambda optimisers in effect.</source>
          <target state="translated">即使在配置脚本中没有提供-flambda选项,Flambda特定的标志也会被默默地接受。(没有提供改变这种行为的方法。)这是为了让运行有或没有Flambda优化器的基准更加直接。</target>
        </trans-unit>
        <trans-unit id="ef48c1926ca51bd2de8c60212500cb953953e6a1" translate="yes" xml:space="preserve">
          <source>Flambda-specific flags do not affect linking with the exception of affecting the optimisation of code in the startup file (containing generated functions such as currying helpers). Typically such optimisation will not be significant, so eliding such flags at link time might be reasonable.</source>
          <target state="translated">Flambda特有的标志不会影响链接,但会影响启动文件中代码的优化(包含生成的函数,如currying helpers)。通常情况下,这样的优化并不显著,所以在链接时省略这样的标志可能是合理的。</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="6ffeb4861d9e563d23963be8720e425492dd6b6d" translate="yes" xml:space="preserve">
          <source>Float arrays are unboxed in OCaml, however the C function foo expect its arguments as boxed floats and returns a boxed float. Hence the OCaml compiler has no choice but to box a.(i) and b.(i) and unbox the result of foo. This results in the allocation of 3 * len temporary float values.</source>
          <target state="translated">在OCaml中,浮动数组是不装箱的,但是C函数foo期望它的参数是装箱的浮动数,并返回一个装箱的浮动数。因此,OCaml编译器别无选择,只能将a.(i)和b.(i)装箱,并解箱foo的结果。这就导致了3*len临时浮点数的分配。</target>
        </trans-unit>
        <trans-unit id="7c4b72128bf46428882a55bf178e9d3551764d17" translate="yes" xml:space="preserve">
          <source>Float arrays with packed representation (labeled functions).</source>
          <target state="translated">具有打包表示的浮点数组(标记函数)。</target>
        </trans-unit>
        <trans-unit id="f943c89063237a1362ef723623577eeb888a17f9" translate="yes" xml:space="preserve">
          <source>Float arrays with packed representation.</source>
          <target state="translated">浮动数组的包装表示。</target>
        </trans-unit>
        <trans-unit id="1a46defc33b52ea1fd99787071741a560caaf453" translate="yes" xml:space="preserve">
          <source>Floating-point addition.</source>
          <target state="translated">浮点加法。</target>
        </trans-unit>
        <trans-unit id="b0e8ad1ad83559c0c5808e64187ad5bb46bccbb8" translate="yes" xml:space="preserve">
          <source>Floating-point addition. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">浮点加法。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5548b469c373345d73eac57637c80c81b15b6bd5" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic</source>
          <target state="translated">浮点算术</target>
        </trans-unit>
        <trans-unit id="64f0748aba5360143ce00933ddcf47abaa24c33b" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic.</source>
          <target state="translated">浮点运算。</target>
        </trans-unit>
        <trans-unit id="82bbccf62a08df179a146bbe466cb94a3dbaa8e5" translate="yes" xml:space="preserve">
          <source>Floating-point decimal literals consist in an integer part, a fractional part and an exponent part. The integer part is a sequence of one or more digits, optionally preceded by a minus sign. The fractional part is a decimal point followed by zero, one or more digits. The exponent part is the character e or E followed by an optional + or - sign, followed by one or more digits. It is interpreted as a power of 10. The fractional part or the exponent part can be omitted but not both, to avoid ambiguity with integer literals. The interpretation of floating-point literals that fall outside the range of representable floating-point values is undefined.</source>
          <target state="translated">浮点小数字由整数部分、小数部分和指数部分组成。整数部分是一个由一位或多位数字组成的序列,前面可选择加减号。小数部分是一个小数点,后面是零,一个或多个数字。指数部分是字符e或E,后面是可选的+或-号,后面是一个或多个数字。它被解释为10的幂。小数部分和指数部分可以省略,但不能同时省略,以避免与整数字 符产生歧义。如果浮点字面数超出了可表示的浮点值范围,则无法解释。</target>
        </trans-unit>
        <trans-unit id="16456ba987f358b0776a485f82949a05fc38ee78" translate="yes" xml:space="preserve">
          <source>Floating-point division.</source>
          <target state="translated">浮点除法。</target>
        </trans-unit>
        <trans-unit id="118ec0967c6c4699de4c4f7b7fda2a6e7b561167" translate="yes" xml:space="preserve">
          <source>Floating-point division. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">浮点除法。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ede89b6074416fcf7162abe3bb4236d8bee181aa" translate="yes" xml:space="preserve">
          <source>Floating-point exponentiation.</source>
          <target state="translated">浮点指数。</target>
        </trans-unit>
        <trans-unit id="0dc9d81781f770a9fc1d9a06be148d35f363d87c" translate="yes" xml:space="preserve">
          <source>Floating-point hexadecimal literals are denoted with the 0x or 0X prefix. The syntax is similar to that of floating-point decimal literals, with the following differences. The integer part and the fractional part use hexadecimal digits. The exponent part starts with the character p or P. It is written in decimal and interpreted as a power of 2.</source>
          <target state="translated">浮点十六进制字符用0x或0X表示。语法与浮点十进制字元相似,但有以下区别。整数部分和小数部分使用十六进制数字。指数部分以字符p或P开头,用十进制书写,解释为2的幂。</target>
        </trans-unit>
        <trans-unit id="9e5d932dc924f91fa346a44f4dc03694cd49183a" translate="yes" xml:space="preserve">
          <source>Floating-point multiplication.</source>
          <target state="translated">浮点乘法。</target>
        </trans-unit>
        <trans-unit id="b556a86592a9630ea4fbca18c7d08e9fc3c949d9" translate="yes" xml:space="preserve">
          <source>Floating-point multiplication. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">浮点乘法。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1149ab45a20d6e882aa6782cb72e44b70e97f03" translate="yes" xml:space="preserve">
          <source>Floating-point negation.</source>
          <target state="translated">浮点否定法。</target>
        </trans-unit>
        <trans-unit id="73f034cf9e5de13353e55867f163be1f87c7d920" translate="yes" xml:space="preserve">
          <source>Floating-point subtraction.</source>
          <target state="translated">浮点减法。</target>
        </trans-unit>
        <trans-unit id="0d7e0c17deed8b8d3fb7e4c7f3f78d69fa0c9040" translate="yes" xml:space="preserve">
          <source>Floating-point subtraction. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">浮点减法。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df61acf8521b8784a6eac17abf66a88f13856f14" translate="yes" xml:space="preserve">
          <source>Floating-point values are numbers in floating-point representation. The current implementation uses double-precision floating-point numbers conforming to the IEEE 754 standard, with 53 bits of mantissa and an exponent ranging from &amp;minus;1022 to 1023.</source>
          <target state="translated">浮点值是浮点表示形式中的数字。当前实现使用符合IEEE 754标准的双精度浮点数，尾数为53位，指数范围为&amp;minus;1022至1023。</target>
        </trans-unit>
        <trans-unit id="85b4ec19158158ac7f6dbb77dc432e2d531582f9" translate="yes" xml:space="preserve">
          <source>Flush all open output channels; ignore errors.</source>
          <target state="translated">冲洗所有打开的输出通道;忽略错误。</target>
        </trans-unit>
        <trans-unit id="2b5f8a08a46ed12d56a1e210ad48361645fed373" translate="yes" xml:space="preserve">
          <source>Flush file buffers to disk.</source>
          <target state="translated">将文件缓冲区刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="23c758f9a0907444c6837d8b7f0fb71eaee1124e" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read characters from standard input until a newline character is encountered.</source>
          <target state="translated">刷新标准输出,然后从标准输入中读取字符,直到遇到一个换行字符。</target>
        </trans-unit>
        <trans-unit id="e2f82045180a47247f213825886ff12b05d6ecc9" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read characters from standard input until a newline character is encountered. Return the string of all characters read, without the newline character at the end.</source>
          <target state="translated">刷新标准输出,然后从标准输入中读取字符,直到遇到换行符。返回读取到的所有字符的字符串,最后不包括换行符。</target>
        </trans-unit>
        <trans-unit id="cbd185b6d4bbe3f64d1306999887965c95045eef" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read one line from standard input and convert it to a floating-point number.</source>
          <target state="translated">刷新标准输出,然后从标准输入中读取一行,并将其转换为浮点数。</target>
        </trans-unit>
        <trans-unit id="72f1a6e603eff2a865514ec6cd7588b58a57b5c3" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read one line from standard input and convert it to an integer.</source>
          <target state="translated">刷新标准输出,然后从标准输入中读取一行并将其转换为整数。</target>
        </trans-unit>
        <trans-unit id="560c3ecff79a18ab3e691bb4c8af82a10b26ee5d" translate="yes" xml:space="preserve">
          <source>Flush the buffer associated with the given output channel, performing all pending writes on that channel.</source>
          <target state="translated">刷新与给定输出通道相关联的缓冲区,在该通道上执行所有待处理的写入。</target>
        </trans-unit>
        <trans-unit id="8b26c6acfdd5ca2fd64e7704f6ddb8ef3f40e2eb" translate="yes" xml:space="preserve">
          <source>Flush the buffer associated with the given output channel, performing all pending writes on that channel. Interactive programs must be careful about flushing standard output and standard error at the right time.</source>
          <target state="translated">冲洗与给定输出通道相关联的缓冲区,在该通道上执行所有待处理的写入。交互式程序必须注意在正确的时间刷新标准输出和标准误差。</target>
        </trans-unit>
        <trans-unit id="becd01c004b1c1adc714fa5f5a61b400195543a6" translate="yes" xml:space="preserve">
          <source>Following a function application:</source>
          <target state="translated">在函数应用之后。</target>
        </trans-unit>
        <trans-unit id="1486f893b1fa18a37d5aac444c9bb86be10dc16e" translate="yes" xml:space="preserve">
          <source>Following the &lt;code&gt;%&lt;/code&gt; character that introduces a conversion, there may be the special flag &lt;code&gt;_&lt;/code&gt;: the conversion that follows occurs as usual, but the resulting value is discarded. For instance, if &lt;code&gt;f&lt;/code&gt; is the function &lt;code&gt;fun&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;, and &lt;code&gt;s&lt;/code&gt; is the string &lt;code&gt;&quot;x&amp;nbsp;=&amp;nbsp;1&quot;&lt;/code&gt;, then &lt;code&gt;Scanf.sscanf&amp;nbsp;s&amp;nbsp;&quot;%_s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">在引入转换的 &lt;code&gt;%&lt;/code&gt; 字符之后，可能会有特殊标志 &lt;code&gt;_&lt;/code&gt; ：随后的转换照常发生，但结果值将被丢弃。例如，如果 &lt;code&gt;f&lt;/code&gt; 是函数 &lt;code&gt;fun&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; ，并且 &lt;code&gt;s&lt;/code&gt; 是字符串 &lt;code&gt;&quot;x&amp;nbsp;=&amp;nbsp;1&quot;&lt;/code&gt; ，则 &lt;code&gt;Scanf.sscanf&amp;nbsp;s&amp;nbsp;&quot;%_s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a590e523ffcfaed89183301d6dd22ee5be58604e" translate="yes" xml:space="preserve">
          <source>For a gentle introduction to the basics of pretty-printing using &lt;code&gt;Format&lt;/code&gt;, read &lt;a href=&quot;http://caml.inria.fr/resources/doc/guides/format.en.html&quot;&gt; http://caml.inria.fr/resources/doc/guides/format.en.html&lt;/a&gt;.</source>
          <target state="translated">有关使用 &lt;code&gt;Format&lt;/code&gt; 进行漂亮打印的基础的简要介绍，请阅读&lt;a href=&quot;http://caml.inria.fr/resources/doc/guides/format.en.html&quot;&gt;http://caml.inria.fr/resources/doc/guides/format.en.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9fce93886551abb9ce788db94f91b9982821506" translate="yes" xml:space="preserve">
          <source>For a program with an extended running time where the collection of only a small sample of events is required, using the &lt;em&gt;eventlog_resume&lt;/em&gt; and &lt;em&gt;eventlog_pause&lt;/em&gt; primitives may help relieve some of the tracing induced performance impact.</source>
          <target state="translated">对于运行时间较长的程序，其中仅需要收集少量事件样本，使用&lt;em&gt;eventlog_resume&lt;/em&gt;和&lt;em&gt;eventlog_pause&lt;/em&gt;原语可能有助于减轻某些跟踪对性能的影响。</target>
        </trans-unit>
        <trans-unit id="d15720a480acc3d4e8c66981b163dda12c3ec8be" translate="yes" xml:space="preserve">
          <source>For compatibility with previous releases, ocamlcp also accepts the -p option, with the same arguments and behaviour as -P.</source>
          <target state="translated">为了与以前的版本兼容,ocamlcp也接受-p选项,其参数和行为与-P相同。</target>
        </trans-unit>
        <trans-unit id="58628e5bccedee4dc2935d0fd33c89e836621a11" translate="yes" xml:space="preserve">
          <source>For compatibility with toplevel phrases (chapter &amp;zwj;&lt;a href=&quot;toplevel#c%3Acamllight&quot;&gt;10&lt;/a&gt;), optional ;; are allowed after and before each definition in a structure. These ;; have no semantic meanings. Similarly, an &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; preceded by ;; is allowed as a component of a structure. It is equivalent to let_=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;, i.e. &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is evaluated for its side-effects but is not bound to any identifier. If &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is the first component of a structure, the preceding ;; can be omitted.</source>
          <target state="translated">用于与顶层的短语（章兼容性&lt;a href=&quot;toplevel#c%3Acamllight&quot;&gt;10&lt;/a&gt;），可选;;允许在结构中的每个定义之后和之前。这些 ;;没有语义。同样，&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;前面带有;;。允许作为结构的组成部分。它等效于let_ = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;，即对&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;的副作用进行了评估，但未绑定到任何标识符。如果&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;是结构的第一个组件，则前面的;;可以省略。</target>
        </trans-unit>
        <trans-unit id="d87cc1fd5174e33b97151dfeeb14c60cfa60df82" translate="yes" xml:space="preserve">
          <source>For compatibility with toplevel phrases (chapter &lt;a href=&quot;toplevel#c%3Acamllight&quot;&gt;10&lt;/a&gt;), optional ;; are allowed after and before each definition in a structure. These ;; have no semantic meanings. Similarly, an &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; preceded by ;; is allowed as a component of a structure. It is equivalent to let_=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;, i.e. &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is evaluated for its side-effects but is not bound to any identifier. If &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is the first component of a structure, the preceding ;; can be omitted.</source>
          <target state="translated">为了与顶级短语（第&lt;a href=&quot;toplevel#c%3Acamllight&quot;&gt;10&lt;/a&gt;章）兼容，可选;;。允许在结构中的每个定义之后和之前。这些 ;;没有语义。同样，&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;前面带有;;。允许作为结构的组成部分。它等效于let_ = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;，即对&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;的副作用进行了评估，但未绑定到任何标识符。如果&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;是结构的第一个组件，则前面的;;可以省略。</target>
        </trans-unit>
        <trans-unit id="8d5a74d2294717e9f00b62a89200b1ae35d6a075" translate="yes" xml:space="preserve">
          <source>For convenicence, when all arguments and the result are annotated with [@unboxed], it is possible to put the attribute only once on the declaration itself. So we can also write instead:</source>
          <target state="translated">为了方便起见,当所有的参数和结果都用[@unboxed]来注释时,可以只在声明本身加上一次属性。所以我们也可以写成</target>
        </trans-unit>
        <trans-unit id="536cfe27f79288497ed369a6675bd6604800b397" translate="yes" xml:space="preserve">
          <source>For convenience and readability, underscore characters (_) are accepted (and ignored) within floating-point literals.</source>
          <target state="translated">为了方便和可读性,在浮点文字中,下划线字符(_)被接受(而忽略)。</target>
        </trans-unit>
        <trans-unit id="be43f583e22841e0ae2a3b643c27e327a6714b66" translate="yes" xml:space="preserve">
          <source>For convenience and readability, underscore characters (_) are accepted (and ignored) within integer literals.</source>
          <target state="translated">为了方便和可读性,整数中的下划线字符(_)被接受(而忽略)。</target>
        </trans-unit>
        <trans-unit id="a076a95603e961e007851488ad739744499a3a22" translate="yes" xml:space="preserve">
          <source>For convenience, when all arguments and the result are annotated with [@unboxed], it is possible to put the attribute only once on the declaration itself. So we can also write instead:</source>
          <target state="translated">为了方便起见,当所有的参数和结果都用[@unboxed]注释时,可以只在声明本身上放一次属性。所以我们也可以写成</target>
        </trans-unit>
        <trans-unit id="838d471f3710333420afe459f6352b41b3ee184b" translate="yes" xml:space="preserve">
          <source>For directives that take file names as arguments, if the given file name specifies no directory, the file is searched in the following directories:</source>
          <target state="translated">对于以文件名作为参数的指令,如果给定的文件名没有指定目录,则在以下目录中搜索文件。</target>
        </trans-unit>
        <trans-unit id="93af2f267be6958b0eb68cd4c18a340833d38fe2" translate="yes" xml:space="preserve">
          <source>For easy reference, the modules are listed below in alphabetical order of module names. For each module, the declarations from its signature are printed one by one in typewriter font, followed by a short comment. All modules and the identifiers they export are indexed at the end of this report.</source>
          <target state="translated">为了便于参考,下面按模块名称的字母顺序列出模块。每一个模块的签名中的声明都以打字机字体逐一打印,然后是简短的注释。所有模块及其输出的标识符均在本报告末尾列出索引。</target>
        </trans-unit>
        <trans-unit id="68c41afc8eaf8ac4f5e1db0cdcc821f1a67ead25" translate="yes" xml:space="preserve">
          <source>For example given the following code:</source>
          <target state="translated">例如给定以下代码。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="87c9f97659bbc1005f4870ae62bce8f4807d2d04" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;e&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;s&lt;/code&gt; will return the first element &lt;code&gt;e&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; where &lt;code&gt;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; (intuitively: &lt;code&gt;e&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt;), or raise &lt;code&gt;Not_found&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is greater than any element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;e&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;s&lt;/code&gt; 将返回第一元件 &lt;code&gt;e&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 其中 &lt;code&gt;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; （直观地： &lt;code&gt;e&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt; ），或加注 &lt;code&gt;Not_found&lt;/code&gt; 如果 &lt;code&gt;x&lt;/code&gt; 大于比 &lt;code&gt;s&lt;/code&gt; 的任何元素大。</target>
        </trans-unit>
        <trans-unit id="00ef4fa9fc5360d62b1c94aa516c65ad36494ff8" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;k&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;m&lt;/code&gt; will return the first binding &lt;code&gt;k,&amp;nbsp;v&lt;/code&gt; of &lt;code&gt;m&lt;/code&gt; where &lt;code&gt;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; (intuitively: &lt;code&gt;k&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt;), or raise &lt;code&gt;Not_found&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is greater than any element of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;k&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;m&lt;/code&gt; 将返回第一个绑定 &lt;code&gt;k,&amp;nbsp;v&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 的v，其中 &lt;code&gt;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; （直觉： &lt;code&gt;k&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt; ），或者如果 &lt;code&gt;x&lt;/code&gt; 则引发 &lt;code&gt;Not_found&lt;/code&gt; 大于 &lt;code&gt;m&lt;/code&gt; 的任何元素。</target>
        </trans-unit>
        <trans-unit id="aa7ea3a77b2622ee6a146e8cc0a886c6052f7d06" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;unfold&amp;nbsp;(function&amp;nbsp;[]&amp;nbsp;-&amp;gt;&amp;nbsp;None&amp;nbsp;|&amp;nbsp;h::t&amp;nbsp;-&amp;gt;&amp;nbsp;Some&amp;nbsp;(h,t))&amp;nbsp;l&lt;/code&gt; is equivalent to &lt;code&gt;List.to_seq&amp;nbsp;l&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;unfold&amp;nbsp;(function&amp;nbsp;[]&amp;nbsp;-&amp;gt;&amp;nbsp;None&amp;nbsp;|&amp;nbsp;h::t&amp;nbsp;-&amp;gt;&amp;nbsp;Some&amp;nbsp;(h,t))&amp;nbsp;l&lt;/code&gt; 等同于 &lt;code&gt;List.to_seq&amp;nbsp;l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8681ad0bc326c2d10abfd81e1d8d51f3f545e5ec" translate="yes" xml:space="preserve">
          <source>For example, on a 32-bit machine, under bash the command</source>
          <target state="translated">例如,在32位的机器上,在bash下执行以下命令</target>
        </trans-unit>
        <trans-unit id="584aecfa53603994f1cf6a98815016088d92742e" translate="yes" xml:space="preserve">
          <source>For example, string literals are implicitly shared by the compiler, so you never uniquely own them.</source>
          <target state="translated">例如,字符串字元是由编译器隐式共享的,所以你永远不会唯一地拥有它们。</target>
        </trans-unit>
        <trans-unit id="75ec36932e874a0857807a9a9cf34d66fdff1115" translate="yes" xml:space="preserve">
          <source>For example, the following function on maps whose values are lists</source>
          <target state="translated">例如,在值为列表的地图上使用以下函数</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="e07ee358d5cb6c26c5c1a633d2d3ce795afcd785" translate="yes" xml:space="preserve">
          <source>For experts only: &lt;code&gt;set_field&lt;/code&gt; et al can be made safe by first wrapping the block in &lt;a href=&quot;sys#VALopaque_identity&quot;&gt;&lt;code&gt;Sys.opaque_identity&lt;/code&gt;&lt;/a&gt;, so any information about its contents will not be propagated.</source>
          <target state="translated">仅对于专家： &lt;code&gt;set_field&lt;/code&gt; 等人可以通过首先将块包装在&lt;a href=&quot;sys#VALopaque_identity&quot;&gt; &lt;code&gt;Sys.opaque_identity&lt;/code&gt; 中&lt;/a&gt;来确保安全，因此不会传播有关其内容的任何信息。</target>
        </trans-unit>
        <trans-unit id="f54deaf4ec2c70a7011f50eff9d2285fdad7e767" translate="yes" xml:space="preserve">
          <source>For functions to decode the information recorded by the profiler, see the Spacetime offline library in otherlibs/.</source>
          <target state="translated">关于剖析器记录的信息解码功能,请参见otherlibs/中的Spacetime offline库。</target>
        </trans-unit>
        <trans-unit id="070398a78bcfebe5c401a9687fd0dd0a09274ac7" translate="yes" xml:space="preserve">
          <source>For instance let&amp;rsquo;s consider this example:</source>
          <target state="translated">例如，让我们考虑这个例子：</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="3ec0bc79713c604935cc8be72edeaf053af246af" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;(float,&amp;nbsp;float32_elt,&amp;nbsp;fortran_layout)&amp;nbsp;Genarray.t&lt;/code&gt; is the type of generic Bigarrays containing 32-bit floats in Fortran layout; reads and writes in this array use the OCaml type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;(float,&amp;nbsp;float32_elt,&amp;nbsp;fortran_layout)&amp;nbsp;Genarray.t&lt;/code&gt; 是通用Bigarray的类型，在Fortran布局中包含32位浮点；使用OCaml类型 &lt;code&gt;float&lt;/code&gt; 对该数组进行读取和写入。</target>
        </trans-unit>
        <trans-unit id="483a4414986412b8b6120205236d6d13002c06a3" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;Genarray.create&amp;nbsp;int32&amp;nbsp;c_layout&amp;nbsp;[|4;6;8|]&lt;/code&gt; returns a fresh Bigarray of 32-bit integers, in C layout, having three dimensions, the three dimensions being 4, 6 and 8 respectively.</source>
          <target state="translated">例如， &lt;code&gt;Genarray.create&amp;nbsp;int32&amp;nbsp;c_layout&amp;nbsp;[|4;6;8|]&lt;/code&gt; 在C布局中返回具有32个整数的3位大数组，该数组具有三个维度，三个维度分别为4、6和8。</target>
        </trans-unit>
        <trans-unit id="120484b1bfef022878939d19f62dec63165e4c62" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;Genarray.init&amp;nbsp;int&amp;nbsp;c_layout&amp;nbsp;[|2;&amp;nbsp;1;&amp;nbsp;3|]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(Array.fold_left&amp;nbsp;(+)&amp;nbsp;0)&lt;/code&gt; returns a fresh Bigarray of integers, in C layout, having three dimensions (2, 1, 3, respectively), with the element values 0, 1, 2, 1, 2, 3.</source>
          <target state="translated">例如， &lt;code&gt;Genarray.init&amp;nbsp;int&amp;nbsp;c_layout&amp;nbsp;[|2;&amp;nbsp;1;&amp;nbsp;3|]&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(Array.fold_left&amp;nbsp;(+)&amp;nbsp;0)&lt;/code&gt; 返回C布局中具有三个维度（分别为2、1、3、3）且元素值为0、1、2、1、2、3的新鲜整数Bigarray。 3。</target>
        </trans-unit>
        <trans-unit id="53f092886c491eb1e8ce0e4ca3d4d961ae0d2d09" translate="yes" xml:space="preserve">
          <source>For instance, a module can be constrained when opened with</source>
          <target state="translated">例如,一个模块可以在使用</target>
        </trans-unit>
        <trans-unit id="a0f95c0ca2f0669635f59d67f76dce1ba345c8a8" translate="yes" xml:space="preserve">
          <source>For instance, compiling with ocamlcp -P film profiles function calls, if&amp;hellip;then&amp;hellip;else&amp;hellip;, loops and pattern matching.</source>
          <target state="translated">例如，使用ocamlcp -P影片配置文件进行编译时会调用函数，如果&amp;hellip;&amp;hellip;则&amp;hellip;&amp;hellip;否则&amp;hellip;&amp;hellip;循环和模式匹配。</target>
        </trans-unit>
        <trans-unit id="62237974c29e3d511bf080a9b8f7425ffcc10235" translate="yes" xml:space="preserve">
          <source>For instance, given a &lt;a href=&quot;buffer#TYPEt&quot;&gt;&lt;code&gt;Buffer.t&lt;/code&gt;&lt;/a&gt; buffer &lt;code&gt;b&lt;/code&gt;, &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_buffer&lt;/code&gt;&lt;/a&gt;&lt;code&gt;b&lt;/code&gt; returns a new formatter using buffer &lt;code&gt;b&lt;/code&gt; as its output device. Similarly, given a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; output channel &lt;code&gt;oc&lt;/code&gt;, &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;code&gt;oc&lt;/code&gt; returns a new formatter using channel &lt;code&gt;oc&lt;/code&gt; as its output device.</source>
          <target state="translated">例如，给定&lt;a href=&quot;buffer#TYPEt&quot;&gt; &lt;code&gt;Buffer.t&lt;/code&gt; &lt;/a&gt;缓冲区 &lt;code&gt;b&lt;/code&gt; ，&lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt; &lt;code&gt;Format.formatter_of_buffer&lt;/code&gt; &lt;/a&gt; &lt;code&gt;b&lt;/code&gt; 返回一个使用缓冲区 &lt;code&gt;b&lt;/code&gt; 作为其输出设备的新格式化程序。类似地，给定&lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt; &lt;code&gt;out_channel&lt;/code&gt; &lt;/a&gt;输出通道 &lt;code&gt;oc&lt;/code&gt; ，&lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; &lt;/a&gt; &lt;code&gt;oc&lt;/code&gt; 返回一个使用channel &lt;code&gt;oc&lt;/code&gt; 作为其输出设备的新格式化程序。</target>
        </trans-unit>
        <trans-unit id="41e374315bd8271c505be4e5174fd509da4383f5" translate="yes" xml:space="preserve">
          <source>For instance, if &lt;code&gt;f&lt;/code&gt; is the function &lt;code&gt;fun&amp;nbsp;s&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;, then &lt;code&gt;Scanf.sscanf&amp;nbsp;&quot;x=&amp;nbsp;1&quot;&amp;nbsp;&quot;%s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">例如，如果 &lt;code&gt;f&lt;/code&gt; 是函数 &lt;code&gt;fun&amp;nbsp;s&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; ，则 &lt;code&gt;Scanf.sscanf&amp;nbsp;&quot;x=&amp;nbsp;1&quot;&amp;nbsp;&quot;%s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ada3238f384f9a83a9a0095d4afa6a65d12f78" translate="yes" xml:space="preserve">
          <source>For instance, if the module type name S is bound to the signature</source>
          <target state="translated">例如,如果模块类型名S与签名</target>
        </trans-unit>
        <trans-unit id="313fce915b91c1b76f4ab6d75d2a8fd584e24576" translate="yes" xml:space="preserve">
          <source>For instance, if you are allocating a finalized block holding an X Windows bitmap of w by h pixels, and you&amp;rsquo;d rather not have more than 1 mega-pixels of unreclaimed bitmaps, specify used = w * h and max = 1000000.</source>
          <target state="translated">例如，如果您要分配一个固定的块，该块包含一个x Windows的w x h像素的位图，而您宁愿不超过1兆像素的未使用位图，请指定used = w * h和max = 1000000。</target>
        </trans-unit>
        <trans-unit id="aa39538e599aa28212b48c635f444fbb356477cb" translate="yes" xml:space="preserve">
          <source>For instance, in ('a' as x) | ( 'a' (_ as x) ) the variable x is of type char, whereas in (&quot;ab&quot; as x) | ( 'a' (_ as x) ? ) the variable x is of type string option.</source>
          <target state="translated">例如,在('a' as x)|('a' (_as x))中,变量x的类型是char,而在(&quot;ab&quot; as x)|('a' (_as x)? )中,变量x的类型是字符串选项。</target>
        </trans-unit>
        <trans-unit id="2c8e2bf323177696f201e4d65a89fe9a6376e58c" translate="yes" xml:space="preserve">
          <source>For instance, in the case of add_nat, the declaration is:</source>
          <target state="translated">例如,在add_nat的情况下,声明是。</target>
        </trans-unit>
        <trans-unit id="30e031fb5cea37ca6a741ad15e3c21518c5b98ed" translate="yes" xml:space="preserve">
          <source>For instance, one might want to specialize a table for integer keys:</source>
          <target state="translated">例如,人们可能希望专门为整数键设计一张表。</target>
        </trans-unit>
        <trans-unit id="ec3b52fde3e16586ca37ede9c046fc9f0a2cf0ce" translate="yes" xml:space="preserve">
          <source>For instance, rather than redefining caml_young_limit:</source>
          <target state="translated">例如,与其重新定义caml_young_limit。</target>
        </trans-unit>
        <trans-unit id="b2c4a72ef20876d65a567d804865d99313488768" translate="yes" xml:space="preserve">
          <source>For instance, the &lt;a href=&quot;scanf#VALscanf&quot;&gt;&lt;code&gt;Scanf.scanf&lt;/code&gt;&lt;/a&gt; function below has type &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt;, since it is a formatted input function that reads from &lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt;&lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;scanf&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to the arguments specified by &lt;code&gt;fmt&lt;/code&gt;, reading those arguments from &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; as expected.</source>
          <target state="translated">例如，下面的&lt;a href=&quot;scanf#VALscanf&quot;&gt; &lt;code&gt;Scanf.scanf&lt;/code&gt; &lt;/a&gt;函数具有 &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt; ，因为它是从&lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt; &lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt; &lt;/a&gt;读取的格式化输入函数： &lt;code&gt;scanf&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; 将 &lt;code&gt;f&lt;/code&gt; 应用于参数由 &lt;code&gt;fmt&lt;/code&gt; 指定，按预期从&lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;读取这些参数。</target>
        </trans-unit>
        <trans-unit id="d79fda01c9ead474ffcd0f48c1cb8618d654db68" translate="yes" xml:space="preserve">
          <source>For instance, the sequence &lt;code&gt;open_box&amp;nbsp;0;&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt; that prints &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; within a pretty-printing box, can be abbreviated as &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%i@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt;, or even shorter &lt;code&gt;printf&amp;nbsp;&quot;@[x&amp;nbsp;=@&amp;nbsp;%i@]@.&quot;&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">例如，序列 &lt;code&gt;open_box&amp;nbsp;0;&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt; 在漂亮打印框中打印 &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; print_newline（）可以缩写为 &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%i@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt; ，或更短的 &lt;code&gt;printf&amp;nbsp;&quot;@[x&amp;nbsp;=@&amp;nbsp;%i@]@.&quot;&amp;nbsp;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="512b11c86beb8f337cea3cd6a56846b5135a314c" translate="yes" xml:space="preserve">
          <source>For instance, type +'a t declares t as an abstract type that is covariant in its parameter; this means that if the type &amp;tau; is a subtype of the type &amp;sigma;, then &amp;tau;  t is a subtype of &amp;sigma;  t. Similarly, type -'a t declares that the abstract type t is contravariant in its parameter: if &amp;tau; is a subtype of &amp;sigma;, then &amp;sigma;  t is a subtype of &amp;tau;  t. If no + or - variance annotation is given, the type constructor is assumed non-variant in the corresponding parameter. For instance, the abstract type declaration type 'a t means that &amp;tau;  t is neither a subtype nor a supertype of &amp;sigma;  t if &amp;tau; is subtype of &amp;sigma;.</source>
          <target state="translated">例如，类型+'at将t声明为其参数是协变的抽象类型；这意味着如果类型&amp;tau;是类型&amp;sigma;的子类型，则&amp;tau;t是&amp;sigma;t的子类型。类似地，类型-'at声明抽象类型t在其参数上是互变的：如果&amp;tau;是&amp;sigma;的子类型，则&amp;sigma;t是&amp;tau;t的子类型。如果没有给出+或-variance注释，则假定类型构造函数在相应的参数中是不变的。例如，抽象类型声明类型'at表示，如果&amp;tau;是&amp;sigma;的子类型，则&amp;tau;t既不是&amp;sigma;t的子类型也不是&amp;sigma;t的超类型。</target>
        </trans-unit>
        <trans-unit id="2f9a2d4de3a321ed1ced899fb52be83e582b336c" translate="yes" xml:space="preserve">
          <source>For instance, you can use {%sql|...|} to represent arbitrary SQL statements &amp;ndash; assuming you have a ppx-rewriter that recognizes the %sql extension.</source>
          <target state="translated">例如，您可以使用{％sql | ... |}表示任意SQL语句-假设您有一个识别％sql扩展名的ppx-rewriter。</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f06f4a1629e356fbed3dca17ffbbc00b47ee8f6a" translate="yes" xml:space="preserve">
          <source>For interactive use of the bigarray compatibility library, do:</source>
          <target state="translated">为交互式使用bigarray兼容库,做。</target>
        </trans-unit>
        <trans-unit id="0f35fd96a6a5a2ac581557d5abe5d3d602ccdd36" translate="yes" xml:space="preserve">
          <source>For interactive use of the compiler-libs library, start ocaml and type</source>
          <target state="translated">为了交互式使用编译器-libs库,启动ocaml并输入</target>
        </trans-unit>
        <trans-unit id="c316cf9a16e0fa7fc1229baa23a24494a5548cb8" translate="yes" xml:space="preserve">
          <source>For interactive use of the str library, do:</source>
          <target state="translated">为交互式使用str库,做。</target>
        </trans-unit>
        <trans-unit id="699e3e7671ce8003396b2ad0dfb9479eb8a59585" translate="yes" xml:space="preserve">
          <source>For interactive use of the unix library, do:</source>
          <target state="translated">为了交互式使用unix库,做。</target>
        </trans-unit>
        <trans-unit id="aab7d183ac64c6f5627d01cb1a929c8a0cc3c3d8" translate="yes" xml:space="preserve">
          <source>For let, the attributes are applied to each bindings:</source>
          <target state="translated">对于让,属性被应用到每个绑定。</target>
        </trans-unit>
        <trans-unit id="dde1e7361b04b1aa4b5279b99eac062b8cfc93f4" translate="yes" xml:space="preserve">
          <source>For lists, some syntactic sugar is provided. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;::&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; stands for the constructor (::) applied to the arguments (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;), and therefore evaluates to the list whose head is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and whose tail is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The expression [&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] is equivalent to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:: &amp;hellip; ::&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;::[], and therefore evaluates to the list whose elements are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">对于列表，提供了一些语法糖。表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; :: &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;代表应用于参数（&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）的构造函数（：:) ，因此计算得出的列表的头部为&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;的值，而尾部为&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的值&lt;sub&gt;2&lt;/sub&gt;。表达式[ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;；&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt; ]等价于&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; :: ... :: &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt; :: []，因此计算结果为，其元素的值列表&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;至&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="e8a86e99ce6f9ce032dc05c5a6a2ecf3f7ba6b26" translate="yes" xml:space="preserve">
          <source>For more information about &lt;em&gt;eventlog-tools&lt;/em&gt;, refer to the project&amp;rsquo;s main page: &lt;a href=&quot;https://github.com/ocaml-multicore/eventlog-tools&quot;&gt;https://github.com/ocaml-multicore/eventlog-tools&lt;/a&gt;</source>
          <target state="translated">有关&lt;em&gt;eventlog-tools的&lt;/em&gt;更多信息，请参阅项目的主页：&lt;a href=&quot;https://github.com/ocaml-multicore/eventlog-tools&quot;&gt;https&lt;/a&gt; : //github.com/ocaml-multicore/eventlog-tools</target>
        </trans-unit>
        <trans-unit id="e3fdaa3af3a3833df037c917261156243c0a3426" translate="yes" xml:space="preserve">
          <source>For more information about conversion specifications and formatting indications available, read the documentation of modules &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关可用的转换规范和格式指示的更多信息，请阅读模块&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="c98a7299a1e114d6c8fcd25e0f9ad620f2b15437" translate="yes" xml:space="preserve">
          <source>For more information on &lt;em&gt;babeltrace&lt;/em&gt;, see the website at: &lt;a href=&quot;https://babeltrace.org/&quot;&gt;https://babeltrace.org/&lt;/a&gt;</source>
          <target state="translated">有关&lt;em&gt;babeltrace的&lt;/em&gt;更多信息，请访问以下网站：&lt;a href=&quot;https://babeltrace.org/&quot;&gt;https&lt;/a&gt; : &lt;em&gt;//babeltrace.org/&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eded1ae5f4e85162d085a1067ff14d61f49ceb5d" translate="yes" xml:space="preserve">
          <source>For more information on afl-fuzz, see the website at &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;http://lcamtuf.coredump.cx/afl/&lt;/a&gt;.</source>
          <target state="translated">有关afl-fuzz的更多信息，请访问&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;http://lcamt​​uf.coredump.cx/afl/上&lt;/a&gt;的网站。</target>
        </trans-unit>
        <trans-unit id="9e368ef71e03b57e9465a3c040880f0c3f8f7488" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;em&gt;Common Trace Format&lt;/em&gt;, see &lt;a href=&quot;https://diamon.org/ctf/&quot;&gt;https://diamon.org/ctf/&lt;/a&gt;.</source>
          <target state="translated">有关&amp;ldquo;&lt;em&gt;通用跟踪格式&amp;rdquo;的&lt;/em&gt;更多信息，请参见&lt;a href=&quot;https://diamon.org/ctf/&quot;&gt;https://diamon.org/ctf/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6047f289f64afe60d156adbc2d91f375cf39e18f" translate="yes" xml:space="preserve">
          <source>For more information, see the description of module Lazy in the standard library (module &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt;).</source>
          <target state="translated">有关更多信息，请参见标准库（模块&lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt;）中对模块Lazy的描述。</target>
        </trans-unit>
        <trans-unit id="4c4464097eb1cea9b9bac89b09a00caecac51a81" translate="yes" xml:space="preserve">
          <source>For patterns, local opens are limited to the &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.(&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;) construction. This construction locally opens the module referred to by the module path &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in the scope of the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;.</source>
          <target state="translated">对于模式，局部打开仅限于&lt;a href=&quot;names#module-path&quot;&gt;模块路径&lt;/a&gt;。（&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;）的构造。此构造在模式&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;的范围内局部打开由模块路径&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;引用的模块。</target>
        </trans-unit>
        <trans-unit id="aef2b59d23fff41131044485051539866a8c3ac8" translate="yes" xml:space="preserve">
          <source>For pointers that are at least 2-aligned (the low bit is guaranteed to be zero), we have yet another valid representation as an OCaml tagged integer.</source>
          <target state="translated">对于至少2位对齐的指针(低位保证为零),我们还有另一种有效的表示方式,即OCaml标记整数。</target>
        </trans-unit>
        <trans-unit id="73f3879c76d10b585df3a2eafc7157a6760d3bbd" translate="yes" xml:space="preserve">
          <source>For recursive functions the relevant attributes are:</source>
          <target state="translated">对于递归函数来说,相关的属性有。</target>
        </trans-unit>
        <trans-unit id="6ebf1588f6cdfdc9ffed9431d4da1f119970c3bc" translate="yes" xml:space="preserve">
          <source>For scripting purpose, matching against &amp;lsquo;{PID}&amp;lsquo;, as well as the .eventlog file extension should provide enough control over the generated files.</source>
          <target state="translated">出于脚本目的，与&amp;ldquo; {PID}&amp;rdquo;匹配以及.eventlog文件扩展名应提供对生成文件的足够控制。</target>
        </trans-unit>
        <trans-unit id="9bacd61a039be387b51c55da04596de123bfecf5" translate="yes" xml:space="preserve">
          <source>For small functions that are called repeatedly, this indirection can have a big impact on performances. However this is not needed if we know that the C function doesn&amp;rsquo;t allocate, doesn&amp;rsquo;t raise exceptions, and doesn&amp;rsquo;t release the master lock (see section &amp;zwj;&lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;18.12.2&lt;/a&gt;). We can instruct the OCaml native-code compiler of this fact by annotating the external declaration with the attribute [@@noalloc]:</source>
          <target state="translated">对于反复调用的小功能，此间接影响性能。然而，这并不需要，如果我们知道C函数不分配，不抛出异常，并且不释放主锁（见第&lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;18.12.2&lt;/a&gt;）。我们可以通过使用属性[@@ noalloc]注释外部声明来指示OCaml本机代码编译器：</target>
        </trans-unit>
        <trans-unit id="2d009d07e3cdd357f1da6c6c41490e4b69ddef46" translate="yes" xml:space="preserve">
          <source>For small functions that are called repeatedly, this indirection can have a big impact on performances. However this is not needed if we know that the C function doesn&amp;rsquo;t allocate, doesn&amp;rsquo;t raise exceptions, and doesn&amp;rsquo;t release the master lock (see section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;). We can instruct the OCaml native-code compiler of this fact by annotating the external declaration with the attribute [@@noalloc]:</source>
          <target state="translated">对于反复调用的小功能，此间接影响性能。但是，如果我们知道C函数不会分配，不会引发异常并且不会释放主锁，则不需&lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;要这样做&lt;/a&gt;（请参见20.12.2节）。我们可以通过使用属性[@@ noalloc]注释外部声明来指示OCaml本机代码编译器：</target>
        </trans-unit>
        <trans-unit id="1e528ec5a4e42d84e77d36a471eae26958b074f6" translate="yes" xml:space="preserve">
          <source>For specifying a module component that is a functor, one may write</source>
          <target state="translated">如果指定一个模块组件是一个漏斗,可以写成</target>
        </trans-unit>
        <trans-unit id="51c50a9c50ed7f2e407b8a69772825eb202f692f" translate="yes" xml:space="preserve">
          <source>For the final linking phase, in addition to the object file produced by -output-obj, you will have to provide the OCaml runtime library (libcamlrun.a for bytecode, libasmrun.a for native-code), as well as all C libraries that are required by the OCaml libraries used. For instance, assume the OCaml part of your program uses the Unix library. With ocamlc, you should do:</source>
          <target state="translated">在最后的链接阶段,除了由-output-obj产生的对象文件外,还需要提供OCaml运行库(bytecode的libcamlrun.a,native-code的libasmrun.a),以及所使用的OCaml库所需要的所有C库。例如,假设程序的OCaml部分使用Unix库。对于ocamlc,你应该这样做。</target>
        </trans-unit>
        <trans-unit id="7da283fed0922afd4ea51a82bd3ebbaecf48b3da" translate="yes" xml:space="preserve">
          <source>For the following examples, we will use the following example program:</source>
          <target state="translated">在下面的例子中,我们将使用以下示例程序。</target>
        </trans-unit>
        <trans-unit id="8462057be99ab190b24cbcda3c885f2c8e84c711" translate="yes" xml:space="preserve">
          <source>For the following files, do not include delayed dependencies for module aliases. This option assumes that they are compiled using options -no-alias-deps -w -49, and that those files or their interface are passed with the -map option when computing dependencies for other files. Note also that for dependencies to be correct in the implementation of a map file, its interface should not coerce any of the aliases it contains.</source>
          <target state="translated">对于以下文件,不包含模块别名的延迟依赖关系。这个选项的前提是,它们是使用选项 -no-alias-deps -w -49 编译的,并且在计算其他文件的依赖关系时,这些文件或它们的接口是用 -map 选项传递的。还需要注意的是,为了使依赖关系在 map 文件的实现中正确无误,它的接口不应该胁迫它所包含的任何别名。</target>
        </trans-unit>
        <trans-unit id="d34193bb871e307746e89150d6b73785a0ab6119" translate="yes" xml:space="preserve">
          <source>For the majority of installations the native toplevel will not have been installed along with the rest of the OCaml toolchain. In such circumstances it will be necessary to build the OCaml distribution from source. From the built source tree of the distribution you may use make natruntop to build and execute a native toplevel. (Alternatively make ocamlnat can be used, which just performs the build step.)</source>
          <target state="translated">对于大多数的安装来说,原生的toplevel不会和其他的OCaml工具链一起安装。在这种情况下,有必要从源码中构建OCaml发行版。你可以使用 make natruntop 来构建和执行一个本地的 toplevel。(也可以使用make ocamlnat,它只是执行构建步骤。)</target>
        </trans-unit>
        <trans-unit id="6ea68bef1bfd3292b6bb1895b9e027db0dba7842" translate="yes" xml:space="preserve">
          <source>For the printing function, we take into account the usual precedence rules (i.e. * binds tighter than +) to avoid printing unnecessary parentheses. To this end, we maintain the current operator precedence and print parentheses around an operator only if its precedence is less than the current precedence.</source>
          <target state="translated">对于打印功能,我们考虑到通常的优先级规则(即*比+绑定得更紧),以避免打印不必要的小括号。为此,我们保持当前运算符的优先级,只有当一个运算符的优先级小于当前的优先级时,我们才会在该运算符周围打印小括号。</target>
        </trans-unit>
        <trans-unit id="51b39efa922285a3273b661042d8cdef22ef9a84" translate="yes" xml:space="preserve">
          <source>For the purposes of optimization, &lt;code&gt;opaque_identity&lt;/code&gt; behaves like an unknown (and thus possibly side-effecting) function.</source>
          <target state="translated">出于优化目的， &lt;code&gt;opaque_identity&lt;/code&gt; 的行为类似于未知函数（因此可能会产生副作用）。</target>
        </trans-unit>
        <trans-unit id="1e267fe9f8c40f023788aff73390761c297ce2ff" translate="yes" xml:space="preserve">
          <source>For the user to be able to specify anonymous arguments starting with a &lt;code&gt;-&lt;/code&gt;, include for example &lt;code&gt;(&quot;-&quot;,&amp;nbsp;String&amp;nbsp;anon_fun,&amp;nbsp;doc)&lt;/code&gt; in &lt;code&gt;speclist&lt;/code&gt;.</source>
          <target state="translated">为了使用户能够指定以 &lt;code&gt;-&lt;/code&gt; 开头的匿名参数 &lt;code&gt;(&quot;-&quot;,&amp;nbsp;String&amp;nbsp;anon_fun,&amp;nbsp;doc)&lt;/code&gt; 在 &lt;code&gt;speclist&lt;/code&gt; 中添加例如（&amp;ldquo;-&amp;rdquo;，字符串anon_fun，doc）。</target>
        </trans-unit>
        <trans-unit id="4ea3e60a68a19b7dec23948987060d7f5d7c1cd9" translate="yes" xml:space="preserve">
          <source>For this overview of OCaml, we use the interactive system, which is started by running ocaml from the Unix shell or Windows command prompt. This tutorial is presented as the transcript of a session with the interactive system: lines starting with # represent user input; the system responses are printed below, without a leading #.</source>
          <target state="translated">对于OCaml的概述,我们使用交互式系统,它是通过在Unix shell或Windows命令提示符下运行ocaml来启动的。本教程是以交互式系统会话的记录来呈现的:以#开头的行代表用户的输入;系统的响应打印在下面,没有前面的#。</target>
        </trans-unit>
        <trans-unit id="19c1a10da802041b9fb470f3102a59cc151979bc" translate="yes" xml:space="preserve">
          <source>For this overview of OCaml, we use the interactive system, which is started by running ocaml from the Unix shell, or by launching the OCamlwin.exe application under Windows. This tutorial is presented as the transcript of a session with the interactive system: lines starting with # represent user input; the system responses are printed below, without a leading #.</source>
          <target state="translated">对于OCaml的概述,我们使用交互式系统,它是通过从Unix shell中运行ocaml或在Windows下启动OCamlwin.exe应用程序来启动的。本教程是以交互式系统会话的形式呈现的:以#开头的行代表用户的输入;系统的响应打印在下面,没有前面的#。</target>
        </trans-unit>
        <trans-unit id="0a580402e4ad9306e87473671cf0faf7d2f7ab1a" translate="yes" xml:space="preserve">
          <source>For this reason, you must be more careful about making types explicit when you use polymorphic variants. When you write a library, this is easy since you can describe exact types in interfaces, but for simple programs you are probably better off with core language variants.</source>
          <target state="translated">出于这个原因,当你使用多态变体时,你必须更加小心地将类型明确化。当你编写一个库时,这很容易,因为你可以在接口中描述精确的类型,但对于简单的程序,你可能最好使用核心语言变体。</target>
        </trans-unit>
        <trans-unit id="af957d60ed570105b0b392af1c056d6167910718" translate="yes" xml:space="preserve">
          <source>For type-checking purposes (and starting from OCaml 4.02), package types are compared using the structural comparison of module types.</source>
          <target state="translated">为了进行类型检查(从OCaml 4.02开始),使用模块类型的结构比较来比较包的类型。</target>
        </trans-unit>
        <trans-unit id="66b762c1c6419b85bbcfadcb1224a4635c6e3a4f" translate="yes" xml:space="preserve">
          <source>For user-defined types, the variance is automatically inferred: a parameter is covariant if it has only covariant occurrences, contravariant if it has only contravariant occurrences, variance-free if it has no occurrences, and nonvariant otherwise. A variance-free parameter may change freely through subtyping, it does not have to be a subtype or a supertype. For abstract and private types, the variance must be given explicitly (see section &amp;zwj;&lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;), otherwise the default is nonvariant. This is also the case for constrained arguments in type definitions.</source>
          <target state="translated">对于用户定义的类型，自动推断出方差：如果参数仅具有协变出现，则参数是协变的；如果仅具有协变出现，则参数是协变的；如果没有出现则无方差，否则为非变量。无方差参数可以通过子类型自由更改，它不必是子类型或超类型。对于抽象和私有类型，方差必须明确给出（参见&lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;），否则默认为非变体。类型定义中的受约束参数也是如此。</target>
        </trans-unit>
        <trans-unit id="34f5bb35507ceece551d8584537a151ed8d0b764" translate="yes" xml:space="preserve">
          <source>For user-defined types, the variance is automatically inferred: a parameter is covariant if it has only covariant occurrences, contravariant if it has only contravariant occurrences, variance-free if it has no occurrences, and nonvariant otherwise. A variance-free parameter may change freely through subtyping, it does not have to be a subtype or a supertype. For abstract and private types, the variance must be given explicitly (see section &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;), otherwise the default is nonvariant. This is also the case for constrained arguments in type definitions.</source>
          <target state="translated">对于用户定义的类型，自动推断出方差：如果参数仅具有协变出现，则参数是协变的；如果仅具有协变出现，则参数是协变的；如果没有出现则无方差，否则为非变量。无方差参数可以通过子类型自由更改，它不必是子类型或超类型。对于抽象类型和私有类型，必须显式给出方差（请参见&lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;节），否则默认为非变量。类型定义中的受约束参数也是如此。</target>
        </trans-unit>
        <trans-unit id="6424726f5a111f674b5264a50bb99313ad270bad" translate="yes" xml:space="preserve">
          <source>Forbid binding an IPv6 socket to an IPv4 address</source>
          <target state="translated">禁止将IPv6套接字绑定到IPv4地址。</target>
        </trans-unit>
        <trans-unit id="5cb81eb5ee90252463cf66685d1856591ccc439a" translate="yes" xml:space="preserve">
          <source>Force a new line in the current pretty-printing box.</source>
          <target state="translated">强制在当前的漂亮打印框中新建一行。</target>
        </trans-unit>
        <trans-unit id="125afb80bbeb391648654a9060fd49b75954e783" translate="yes" xml:space="preserve">
          <source>Force all modules contained in libraries to be linked in. If this flag is not given, unreferenced modules are not linked in. When building a library (option -a), setting the -linkall option forces all subsequent links of programs involving that library to link all the modules contained in the library. When compiling a module (option -c), setting the -linkall option ensures that this module will always be linked if it is put in a library and this library is linked.</source>
          <target state="translated">强制所有包含在库中的模块被链接进来。如果没有给出这个标志,未引用的模块不会被链接进来。当建立一个库(选项-a)时,设置-linkall选项会强制所有后续涉及该库的程序链接到该库中的所有模块。当编译一个模块时(选项-c),设置-linkall选项可以确保这个模块被放入一个库中并且这个库被链接时,这个模块将始终被链接。</target>
        </trans-unit>
        <trans-unit id="035f3fa8787b038845df69761d559e46584335ee" translate="yes" xml:space="preserve">
          <source>Force error messages to show absolute paths for file names.</source>
          <target state="translated">强制错误信息显示文件名的绝对路径。</target>
        </trans-unit>
        <trans-unit id="b18cad2a21c9b98f70be09ebac9958393c7c0edc" translate="yes" xml:space="preserve">
          <source>Force the construction of a statically linked library only, even if dynamic linking is supported.</source>
          <target state="translated">即使支持动态链接,也只强制构建静态链接库。</target>
        </trans-unit>
        <trans-unit id="46882fa3a62ce5fc4e4b0d025aabceb392c26854" translate="yes" xml:space="preserve">
          <source>Force the left-hand part of each sequence to have type unit.</source>
          <target state="translated">强制每个序列的左手部分有类型单位。</target>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="304eeec5641ac1e5522186b7555dcdb91736d26d" translate="yes" xml:space="preserve">
          <source>Fork a new process.</source>
          <target state="translated">叉一个新的过程。</target>
        </trans-unit>
        <trans-unit id="236e1aa20d58ae0da8f5448ac108dbc6e91a6c14" translate="yes" xml:space="preserve">
          <source>Fork a new process. The returned integer is 0 for the child process, the pid of the child process for the parent process.</source>
          <target state="translated">分叉一个新进程。返回的整数是子进程的0,子进程的pid是父进程的pid。</target>
        </trans-unit>
        <trans-unit id="1a98756856d684441ecaf6f9fd69f196389c0e67" translate="yes" xml:space="preserve">
          <source>Formal parameters and arguments are matched according to their respective labels&lt;sup&gt;&lt;a href=&quot;#note1&quot; id=&quot;text1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, the absence of label being interpreted as the empty label. This allows commuting arguments in applications. One can also partially apply a function on any argument, creating a new function of the remaining parameters.</source>
          <target state="translated">形式参数和自变量根据其各自的标签&lt;sup&gt;&lt;a href=&quot;#note1&quot; id=&quot;text1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;进行匹配，如果没有标签，则将其解释为空标签。这允许在应用程序中交换参数。也可以将一个函数部分地应用于任何自变量，从而创建其余参数的新函数。</target>
        </trans-unit>
        <trans-unit id="72fa715b4b39687a4ab854f098fbf8e891debee4" translate="yes" xml:space="preserve">
          <source>Formally, an estimate of runtime performance benefit is computed by first summing the cost of the operations that are known to be removed as a result of the inlining and subsequent simplification of the inlined body. The individual costs for the various kinds of operations may be adjusted using the various -inline-...-cost flags as follows. Costs are specified as integers. All of these flags accept a single argument describing such integers using the conventions detailed in section &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;19.2.1&lt;/a&gt;.</source>
          <target state="translated">形式上，运行时性能收益的估算是通过首先对已知由于内联和随后简化内联主体而要删除的操作的成本进行求和来计算的。可以使用以下各种inline -...- cost标志来调整各种操作的个人成本。成本指定为整数。所有这些标志都接受一个单独的参数，使用第&lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;19.2.1&lt;/a&gt;节中详述的约定来描述此类整数。</target>
        </trans-unit>
        <trans-unit id="58a23074c162bcd840e8739dd410d344b7804635" translate="yes" xml:space="preserve">
          <source>Formally, an estimate of runtime performance benefit is computed by first summing the cost of the operations that are known to be removed as a result of the inlining and subsequent simplification of the inlined body. The individual costs for the various kinds of operations may be adjusted using the various -inline-...-cost flags as follows. Costs are specified as integers. All of these flags accept a single argument describing such integers using the conventions detailed in section &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1&lt;/a&gt;.</source>
          <target state="translated">形式上，运行时性能收益的估算是通过首先对已知由于内联和随后简化内联主体而要删除的操作的成本进行求和来计算的。可以使用以下各种inline -...- cost标志来调整各种操作的个人成本。成本指定为整数。所有这些标志都接受一个单独的参数，该参数使用&lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1&lt;/a&gt;节中详述的约定来描述此类整数。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="cd766e4c3a23f7c2da8587cebfb482091c1dccb5" translate="yes" xml:space="preserve">
          <source>Format string description</source>
          <target state="translated">格式字符串说明</target>
        </trans-unit>
        <trans-unit id="fb420b10080f1dd9257bcd67f1d8aee25cf5a4f3" translate="yes" xml:space="preserve">
          <source>Format strings are character strings with special lexical conventions that defines the functionality of formatted input/output functions. Format strings are used to read data with formatted input functions from module &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; and to print data with formatted output functions from modules &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">格式字符串是具有特殊词汇约定的字符串，这些约定定义了格式化输入/输出功能的功能。格式字符串用于从&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;模块读取带有格式化输入功能的数据，并从&lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;模块打印带有格式化输出功能的数据。</target>
        </trans-unit>
        <trans-unit id="c62c8f7675da4c277f6225623ec0c47dda029d6d" translate="yes" xml:space="preserve">
          <source>Format strings are made of three kinds of entities:</source>
          <target state="translated">格式字符串由三种实体组成。</target>
        </trans-unit>
        <trans-unit id="f06a845dc5cb646f90245c5fc3022aea03416143" translate="yes" xml:space="preserve">
          <source>Format strings have a general and highly polymorphic type &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d,&amp;nbsp;'e,&amp;nbsp;'f)&amp;nbsp;format6&lt;/code&gt;. The two simplified types, &lt;code&gt;format&lt;/code&gt; and &lt;code&gt;format4&lt;/code&gt; below are included for backward compatibility with earlier releases of OCaml.</source>
          <target state="translated">格式字符串具有通用且高度多态的类型 &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d,&amp;nbsp;'e,&amp;nbsp;'f)&amp;nbsp;format6&lt;/code&gt; 。为了简化与OCaml的早期版本的兼容性，下面提供了两种简化类型，即 &lt;code&gt;format&lt;/code&gt; 和 &lt;code&gt;format4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="252c8b72c38b953722001b0d7e1faa8cdee47d48" translate="yes" xml:space="preserve">
          <source>Formatted Pretty-Printing with continuations.</source>
          <target state="translated">格式化的漂亮-印刷与延续。</target>
        </trans-unit>
        <trans-unit id="3a2d3f703bd5b043248ec990cc1f4c5007ff3f0e" translate="yes" xml:space="preserve">
          <source>Formatted input as a functional feature</source>
          <target state="translated">格式化输入作为一种功能特征</target>
        </trans-unit>
        <trans-unit id="77bd2d9934254f11979d82347140567c1ddb102e" translate="yes" xml:space="preserve">
          <source>Formatted input channel</source>
          <target state="translated">格式化的输入通道</target>
        </trans-unit>
        <trans-unit id="be2d12d3c9bb417bd5c2c00ad2a7d80739b67fe6" translate="yes" xml:space="preserve">
          <source>Formatted input functions.</source>
          <target state="translated">格式化的输入功能。</target>
        </trans-unit>
        <trans-unit id="3f2c32e9b045d340dc3d1db20b06b3312b9dffe7" translate="yes" xml:space="preserve">
          <source>Formatted output functions with continuations.</source>
          <target state="translated">格式化的输出函数,具有连续性。</target>
        </trans-unit>
        <trans-unit id="711a36aaf3243301d4bdbe36c688f9d583325bf4" translate="yes" xml:space="preserve">
          <source>Formatted output functions.</source>
          <target state="translated">格式化输出功能。</target>
        </trans-unit>
        <trans-unit id="2f3ced1470e4fb0a82a21db25542a6f1c80d4639" translate="yes" xml:space="preserve">
          <source>Formatted pretty-printing</source>
          <target state="translated">格式化的漂亮打印</target>
        </trans-unit>
        <trans-unit id="f51b052e6b6929080b4b2c0e3ee6499327d38158" translate="yes" xml:space="preserve">
          <source>Formatting functions</source>
          <target state="translated">格式化功能</target>
        </trans-unit>
        <trans-unit id="b31bab41071c2ba216bb20fa4ecdf43ff5be0ae1" translate="yes" xml:space="preserve">
          <source>Fragile constant pattern.</source>
          <target state="translated">脆弱的恒定模式。</target>
        </trans-unit>
        <trans-unit id="733886e0c1a7b21f20a0e73b04dc5e1666cb2517" translate="yes" xml:space="preserve">
          <source>Fragile pattern matching: matching that will remain complete even if additional constructors are added to one of the variant types matched.</source>
          <target state="translated">脆弱的模式匹配:即使在匹配的变体类型之一中添加了额外的构造函数,也会保持完整的匹配。</target>
        </trans-unit>
        <trans-unit id="103d90d5cbdf56cc8c46155df2e012b9e7f0d6e6" translate="yes" xml:space="preserve">
          <source>Freeing the memory blocks that were allocated by the runtime with malloc. Inside C primitives, it is advised to use caml_stat_* functions from memory.h for managing static (that is, non-moving) blocks of heap memory, as all the blocks allocated with these functions are automatically freed by caml_shutdown. For ensuring compatibility with legacy C stubs that have used caml_stat_* incorrectly, this behaviour is only enabled if the runtime is started with a specialized caml_startup_pooled function.</source>
          <target state="translated">释放运行时用 malloc 分配的内存块。在 C 基元中,建议使用 memory.h 中的 caml_stat_*函数来管理堆内存的静态(即非移动)块,因为使用这些函数分配的所有块都会被 caml_shutdown 自动释放。为了确保与那些错误使用caml_stat_*的传统C存的兼容性,只有在运行时用专门的caml_startup_pooled函数启动时,才会启用这种行为。</target>
        </trans-unit>
        <trans-unit id="381e8105b7f65611bdbccad4e376930184ddb809" translate="yes" xml:space="preserve">
          <source>From the point of view of the writer of C stubs, the challenges of interacting with Windows Unicode APIs are twofold:</source>
          <target state="translated">从C存根的编写者的角度来看,与Windows Unicode APIs交互的挑战有两个方面。</target>
        </trans-unit>
        <trans-unit id="5006d76ef1ff0edee9bb268edecad3b64ee9a5fb" translate="yes" xml:space="preserve">
          <source>From the standpoint of the allocation functions, blocks are divided according to their size as zero-sized blocks, small blocks (with size less than or equal to &lt;code&gt;Max_young_wosize&lt;/code&gt;), and large blocks (with size greater than &lt;code&gt;Max_young_wosize&lt;/code&gt;). The constant &lt;code&gt;Max_young_wosize&lt;/code&gt; is declared in the include file mlvalues.h. It is guaranteed to be at least 64 (words), so that any block with constant size less than or equal to 64 can be assumed to be small. For blocks whose size is computed at run-time, the size must be compared against &lt;code&gt;Max_young_wosize&lt;/code&gt; to determine the correct allocation procedure.</source>
          <target state="translated">从分配函数的角度来看，块按大小划分为零大小块，小块（大小小于或等于 &lt;code&gt;Max_young_wosize&lt;/code&gt; ）和大块（大小大于 &lt;code&gt;Max_young_wosize&lt;/code&gt; ）。常量 &lt;code&gt;Max_young_wosize&lt;/code&gt; 在包含文件mlvalues.h中声明。保证至少为64（字），因此任何大小小于或等于64的恒定块都可以视为较小的块。对于在运行时计算大小的块，必须将大小与 &lt;code&gt;Max_young_wosize&lt;/code&gt; 进行比较，以确定正确的分配过程。</target>
        </trans-unit>
        <trans-unit id="56fb6077bdf4f3c5cdb464d60eaad6a7f0d65be3" translate="yes" xml:space="preserve">
          <source>Full specifications of variant tags are only used for non-exact closed types. They can be understood as a conjunctive type for the argument: it is intended to have all the types enumerated in the specification.</source>
          <target state="translated">变体标签的完整规范只用于非完全封闭类型。它们可以理解为参数的共轭类型:它的目的是拥有规范中列举的所有类型。</target>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="f13929b48377daed175f9b82a9945ecfe03b8a18" translate="yes" xml:space="preserve">
          <source>Function application is denoted by juxtaposition of (possibly labeled) expressions. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and those appearing in &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; must evaluate to a functional value f, which is then applied to the values of &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">函数应用程序由（可能带有标签的）表达式的并置表示。表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#argument&quot;&gt;参数&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#argument&quot;&gt;参数&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;计算表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;以及出现在&lt;a href=&quot;#argument&quot;&gt;参数&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;中的&lt;a href=&quot;#argument&quot;&gt;表达式&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;。表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;必须求值为函数值f，然后将其应用于&lt;a href=&quot;#argument&quot;&gt;参数&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;#argument&quot;&gt;参数&lt;/a&gt;&lt;sub&gt;n的值&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="ce30592d34081e4a1fbc6e1b75d58f079f9285a9" translate="yes" xml:space="preserve">
          <source>Function call annotated with an incorrect @tailcall attribute</source>
          <target state="translated">函数调用被注解了一个错误的@tailcall属性。</target>
        </trans-unit>
        <trans-unit id="9f41d8a2104aaa68d4125738c3fccd8fde3ee5b3" translate="yes" xml:space="preserve">
          <source>Function interrupted by signal</source>
          <target state="translated">功能被信号打断</target>
        </trans-unit>
        <trans-unit id="d2c76e1ede161471ccd802e477febd466535fb41" translate="yes" xml:space="preserve">
          <source>Function manipulation.</source>
          <target state="translated">功能操纵。</target>
        </trans-unit>
        <trans-unit id="bc8a59f44f5ba9847650733c0cafd473c4eed11f" translate="yes" xml:space="preserve">
          <source>Function not supported</source>
          <target state="translated">不支持该功能</target>
        </trans-unit>
        <trans-unit id="5ef8a9128beb0af02eff674dd02f5540cdf4c052" translate="yes" xml:space="preserve">
          <source>Functional Iterators</source>
          <target state="translated">功能迭代器</target>
        </trans-unit>
        <trans-unit id="13fe4e6e39b49747e662e4d40927c17b0001a35e" translate="yes" xml:space="preserve">
          <source>Functional input with format strings</source>
          <target state="translated">带格式字符串的功能输入</target>
        </trans-unit>
        <trans-unit id="2ebca6e07088b7983ad320f772117c7a21d8a3ef" translate="yes" xml:space="preserve">
          <source>Functional iterators.</source>
          <target state="translated">功能性迭代器。</target>
        </trans-unit>
        <trans-unit id="0fabf5e8499f027d17171e2a2ac468b81f15ff3d" translate="yes" xml:space="preserve">
          <source>Functional update is often used in conjunction with binary methods as illustrated in section &amp;zwj;&lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;.</source>
          <target state="translated">功能更新经常与二进制方法结合使用，如部分示出的&lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c0cf6a585e5822f9daed0b884effec99c37c70" translate="yes" xml:space="preserve">
          <source>Functional update is often used in conjunction with binary methods as illustrated in section &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;.</source>
          <target state="translated">功能更新通常与&lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;节中说明的二进制方法结合使用。</target>
        </trans-unit>
        <trans-unit id="994ce6abbd94a0acd9b9688ad57d717223e20bb2" translate="yes" xml:space="preserve">
          <source>Functional values are mappings from values to values.</source>
          <target state="translated">功能值是由值到值的映射。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="594192b50b04507e237e1cfb87230a7ae4c1d67b" translate="yes" xml:space="preserve">
          <source>Functions for lexer semantic actions</source>
          <target state="translated">词典语义行动的功能</target>
        </trans-unit>
        <trans-unit id="8c55c9cbdceda57907c400a338a436f167c64fd5" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;spec&lt;/code&gt; or &lt;code&gt;anon_fun&lt;/code&gt; can raise &lt;code&gt;Arg.Bad&lt;/code&gt; with an error message to reject invalid arguments.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; 或 &lt;code&gt;anon_fun&lt;/code&gt; 中的函数可以使用错误消息引发 &lt;code&gt;Arg.Bad&lt;/code&gt; 来拒绝无效的参数。</target>
        </trans-unit>
        <trans-unit id="8248c90bba77a29916a1cdfddf8e3aba54354454" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;spec&lt;/code&gt; or &lt;code&gt;anon_fun&lt;/code&gt; can raise &lt;code&gt;Arg.Bad&lt;/code&gt; with an error message to reject invalid arguments. &lt;code&gt;Arg.Bad&lt;/code&gt; is also raised by &lt;a href=&quot;arg#VALparse_argv&quot;&gt;&lt;code&gt;Arg.parse_argv&lt;/code&gt;&lt;/a&gt; in case of an error.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; 或 &lt;code&gt;anon_fun&lt;/code&gt; 中的函数可以使用错误消息引发 &lt;code&gt;Arg.Bad&lt;/code&gt; 来拒绝无效的参数。 &lt;code&gt;Arg.Bad&lt;/code&gt; 也被提出&lt;a href=&quot;arg#VALparse_argv&quot;&gt; &lt;code&gt;Arg.parse_argv&lt;/code&gt; &lt;/a&gt;在错误的情况下。</target>
        </trans-unit>
        <trans-unit id="1b86afa845a1585328545e5f3991b68610497328" translate="yes" xml:space="preserve">
          <source>Functions that decode signed (resp. unsigned) 8-bit or 16-bit integers represented by &lt;code&gt;int&lt;/code&gt; values sign-extend (resp. zero-extend) their result.</source>
          <target state="translated">解码由 &lt;code&gt;int&lt;/code&gt; 值表示的有符号（无符号的整数）8位或16位整数的函数对它们的结果进行符号扩展（零扩展）。</target>
        </trans-unit>
        <trans-unit id="e3b7f5c27f44d3411501edb47a9a661138103758" translate="yes" xml:space="preserve">
          <source>Functions that encode 8-bit or 16-bit integers represented by &lt;code&gt;int&lt;/code&gt; values truncate their input to their least significant bytes.</source>
          <target state="translated">编码由 &lt;code&gt;int&lt;/code&gt; 值表示的8位或16位整数的函数将其输入截断为它们的最低有效字节。</target>
        </trans-unit>
        <trans-unit id="2f86e81c17a3239f2ed2ba7a90d878f1fcd2d69d" translate="yes" xml:space="preserve">
          <source>Functions that take other functions as arguments are called &amp;ldquo;functionals&amp;rdquo;, or &amp;ldquo;higher-order functions&amp;rdquo;. Functionals are especially useful to provide iterators or similar generic operations over a data structure. For instance, the standard OCaml library provides a List.map functional that applies a given function to each element of a list, and returns the list of the results:</source>
          <target state="translated">将其他函数作为参数的函数称为&amp;ldquo;函数&amp;rdquo;或&amp;ldquo;高阶函数&amp;rdquo;。功能对于在数据结构上提供迭代器或类似的通用操作特别有用。例如，标准的OCaml库提供List.map函数，该函数将给定函数应用于列表的每个元素，并返回结果列表：</target>
        </trans-unit>
        <trans-unit id="3ea47ba4b29a471c05740d1b6b2aef7fcf7b007e" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.GenHashTable.MakeSeeded</source>
          <target state="translated">函数Ephemeron.GenHashTable.MakeSeeded。</target>
        </trans-unit>
        <trans-unit id="2ba75f98b1daeb726f09c0d9b8ebf4ca742bd9a0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K1.Make</source>
          <target state="translated">Functor Ephemeron.K1.Make</target>
        </trans-unit>
        <trans-unit id="791c73df8d4dc4a293cb5fc5df93e2d713e170be" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K1.MakeSeeded</source>
          <target state="translated">向量Ephemeron.K1.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="13076ed4adc02650a2456124fd63360d574f170b" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K2.Make</source>
          <target state="translated">函数Ephemeron.K2.Make</target>
        </trans-unit>
        <trans-unit id="9f37977f2244653f5138488517907c339e2caad0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K2.MakeSeeded</source>
          <target state="translated">向量Ephemeron.K2.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="eb798cabd754ea8bd143b300b9c00949f911c4d0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.Kn.Make</source>
          <target state="translated">向量Ephemeron.Kn.Make。</target>
        </trans-unit>
        <trans-unit id="95ecfc616841fe061e9170e804dc5953460e4e22" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.Kn.MakeSeeded</source>
          <target state="translated">向量Ephemeron.Kn.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="3844df36a31614de4703ed307f9104110c66c133" translate="yes" xml:space="preserve">
          <source>Functor Hashtbl.Make</source>
          <target state="translated">函数Hashtbl.Make</target>
        </trans-unit>
        <trans-unit id="743dbedb9473f776f428bc156c6dc4f18a3c7c2c" translate="yes" xml:space="preserve">
          <source>Functor Hashtbl.MakeSeeded</source>
          <target state="translated">Functor Hashtbl.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="6a14323bcc1d6553a2f876a23442561ccf9a8898" translate="yes" xml:space="preserve">
          <source>Functor Map.Make</source>
          <target state="translated">向量Map.Make</target>
        </trans-unit>
        <trans-unit id="32b02c18c6fd2de2991bdf0f998f4324f7413b8e" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Hashtbl.Make</source>
          <target state="translated">函数 MoreLabels.Hashtbl.Make</target>
        </trans-unit>
        <trans-unit id="ae21d10a3065dbf4c56f4f993cd9e0afc7222c78" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Hashtbl.MakeSeeded</source>
          <target state="translated">函数 MoreLabels.Hashtbl.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="e35d41c98a0f8cb263549b344d89e05e0044a9a8" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Map.Make</source>
          <target state="translated">Functor MoreLabels.Map.Make</target>
        </trans-unit>
        <trans-unit id="d7b37e87c0ae76c5e486380751816f2b5ce6f130" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Set.Make</source>
          <target state="translated">Functor MoreLabels.Set.Make</target>
        </trans-unit>
        <trans-unit id="aa7642967c480650911cf8ff0961dfdebfe66970" translate="yes" xml:space="preserve">
          <source>Functor Set.Make</source>
          <target state="translated">Functor Set.Make</target>
        </trans-unit>
        <trans-unit id="7d4d7c62aec0f8b013f1e8a2e51f494583ed6792" translate="yes" xml:space="preserve">
          <source>Functor Sys.Immediate64.Make</source>
          <target state="translated">函数 Sys.Immediate64.Make</target>
        </trans-unit>
        <trans-unit id="c626045c07d526e8e111e54420d804ac453b7f39" translate="yes" xml:space="preserve">
          <source>Functor Weak.Make</source>
          <target state="translated">Functor Weak.Make</target>
        </trans-unit>
        <trans-unit id="b699610366ffb2bc1456841560d326de9dd34f9f" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table</source>
          <target state="translated">构建一个弱哈希表的实现函数</target>
        </trans-unit>
        <trans-unit id="389dbe43bbc83f6add8186ac8132f778ad57371f" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table.</source>
          <target state="translated">构建一个弱哈希表的实现函数。</target>
        </trans-unit>
        <trans-unit id="cbb9434445367d8b10366b98ee9760b028541c96" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table. The seed is similar to the one of &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函数构建弱哈希表的实现。种子类似于&lt;a href=&quot;hashtbl.makeseeded&quot;&gt; &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt;的种子。</target>
        </trans-unit>
        <trans-unit id="4ad5d99d5b99b9109a80f197da9462e8c2eb0f11" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of an hash table that use the container for keeping the information given</source>
          <target state="translated">建立一个哈希表的实现函数,使用容器来保存给定的信息。</target>
        </trans-unit>
        <trans-unit id="ff02a7e7b2976b75351293a5e3b0329ad3b5e347" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure.</source>
          <target state="translated">构建一个哈希塔结构的实现函数。</target>
        </trans-unit>
        <trans-unit id="e736518d7c53ed3a67bef9cb74bed1672d054303" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure. The functor &lt;code&gt;Hashtbl.Make&lt;/code&gt; returns a structure containing a type &lt;code&gt;key&lt;/code&gt; of keys and a type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; of hash tables associating data of type &lt;code&gt;'a&lt;/code&gt; to keys of type &lt;code&gt;key&lt;/code&gt;. The operations perform similarly to those of the generic interface, but use the hashing and equality functions specified in the functor argument &lt;code&gt;H&lt;/code&gt; instead of generic equality and hashing. Since the hash function is not seeded, the &lt;code&gt;create&lt;/code&gt; operation of the result structure always returns non-randomized hash tables.</source>
          <target state="translated">函子构建哈希表结构的实现。仿函数 &lt;code&gt;Hashtbl.Make&lt;/code&gt; 返回包含一个类型的结构 &lt;code&gt;key&lt;/code&gt; 密钥和一个类型 &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; 哈希表型的数据相关联的 &lt;code&gt;'a&lt;/code&gt; 到类型的键 &lt;code&gt;key&lt;/code&gt; 。这些操作的执行方式与通用接口的操作类似，但是使用函子参数 &lt;code&gt;H&lt;/code&gt; 中指定的哈希和等于函数，而不是通用等于和哈希。由于没有散列函数，结果结构的 &lt;code&gt;create&lt;/code&gt; 操作总是返回非随机散列表。</target>
        </trans-unit>
        <trans-unit id="22d60ff60f88d6953e80b991b7bc78a0b9262116" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure. The functor &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; returns a structure containing a type &lt;code&gt;key&lt;/code&gt; of keys and a type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; of hash tables associating data of type &lt;code&gt;'a&lt;/code&gt; to keys of type &lt;code&gt;key&lt;/code&gt;. The operations perform similarly to those of the generic interface, but use the seeded hashing and equality functions specified in the functor argument &lt;code&gt;H&lt;/code&gt; instead of generic equality and hashing. The &lt;code&gt;create&lt;/code&gt; operation of the result structure supports the &lt;code&gt;~&lt;/code&gt;&lt;code&gt;random&lt;/code&gt; optional parameter and returns randomized hash tables if &lt;code&gt;~random:true&lt;/code&gt; is passed or if randomization is globally on (see &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt;&lt;code&gt;Hashtbl.randomize&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">函子构建哈希表结构的实现。仿函数 &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; 返回包含一个类型的结构 &lt;code&gt;key&lt;/code&gt; 密钥和一个类型 &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; 哈希表型的数据相关联的 &lt;code&gt;'a&lt;/code&gt; 到类型的键 &lt;code&gt;key&lt;/code&gt; 。这些操作的执行方式与通用接口的操作相似，但是使用函子参数 &lt;code&gt;H&lt;/code&gt; 中指定的种子哈希和相等函数，而不是通用相等和哈希。结果结构的 &lt;code&gt;create&lt;/code&gt; 操作支持 &lt;code&gt;~&lt;/code&gt; &lt;code&gt;random&lt;/code&gt; 可选参数，如果 &lt;code&gt;~random:true&lt;/code&gt; ，则返回随机哈希表传递，或者如果全局启用了随机化（请参见&lt;a href=&quot;hashtbl#VALrandomize&quot;&gt; &lt;code&gt;Hashtbl.randomize&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7fa7f1ef8b7a2c11e209c2793d5c2dd4a871de19" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure. The functor &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; returns a structure containing a type &lt;code&gt;key&lt;/code&gt; of keys and a type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; of hash tables associating data of type &lt;code&gt;'a&lt;/code&gt; to keys of type &lt;code&gt;key&lt;/code&gt;. The operations perform similarly to those of the generic interface, but use the seeded hashing and equality functions specified in the functor argument &lt;code&gt;H&lt;/code&gt; instead of generic equality and hashing. The &lt;code&gt;create&lt;/code&gt; operation of the result structure supports the &lt;code&gt;~random&lt;/code&gt; optional parameter and returns randomized hash tables if &lt;code&gt;~random:true&lt;/code&gt; is passed or if randomization is globally on (see &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt;&lt;code&gt;Hashtbl.randomize&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">函子构建哈希表结构的实现。仿函数 &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; 返回包含一个类型的结构 &lt;code&gt;key&lt;/code&gt; 密钥和一个类型 &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; 哈希表型的数据相关联的 &lt;code&gt;'a&lt;/code&gt; 到类型的键 &lt;code&gt;key&lt;/code&gt; 。这些操作的执行方式与通用接口的操作相似，但是使用函子参数 &lt;code&gt;H&lt;/code&gt; 中指定的种子哈希和相等函数，而不是通用相等和哈希。结果结构的 &lt;code&gt;create&lt;/code&gt; 操作支持 &lt;code&gt;~random&lt;/code&gt; 可选参数，如果传递了 &lt;code&gt;~random:true&lt;/code&gt; 或如果随机化处于全局开启状态，则返回随机化的哈希表（请参见&lt;a href=&quot;hashtbl#VALrandomize&quot;&gt; &lt;code&gt;Hashtbl.randomize&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f83ea0beecbcf2f703dd91eb33b58d38977c526c" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the map structure given a totally ordered type.</source>
          <target state="translated">构建一个给定完全有序类型的映射结构的实现函数。</target>
        </trans-unit>
        <trans-unit id="5c59513445794edf5f86a24f7a69c2e920f5ea85" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the set structure given a totally ordered type.</source>
          <target state="translated">给定一个完全有序的类型,构建一个集结构的实现函数。</target>
        </trans-unit>
        <trans-unit id="d7ee355281f6ad25a690b039e1ce78ea8323eda0" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the weak hash set structure.</source>
          <target state="translated">构建弱哈希集结构的实现函数。</target>
        </trans-unit>
        <trans-unit id="14416cb42fb32afba2f0aa5e6b2e714075343250" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the weak hash set structure. &lt;code&gt;H.equal&lt;/code&gt; can't be the physical equality, since only shallow copies of the elements in the set are given to it.</source>
          <target state="translated">Functor构建弱哈希集结构的实现。 &lt;code&gt;H.equal&lt;/code&gt; 不能是物理相等，因为只给了集合中元素的浅表副本。</target>
        </trans-unit>
        <trans-unit id="0eb68f70b3b05995b7d69acf8715b7a8bfc794f9" translate="yes" xml:space="preserve">
          <source>Functorial interface</source>
          <target state="translated">功能性接口</target>
        </trans-unit>
        <trans-unit id="40cacb900d73a801423574b27a6596efb4e78908" translate="yes" xml:space="preserve">
          <source>Functors are &amp;ldquo;functions&amp;rdquo; from modules to modules. Functors let you create parameterized modules and then provide other modules as parameter(s) to get a specific implementation. For instance, a Set module implementing sets as sorted lists could be parameterized to work with any module that provides an element type and a comparison function compare (such as OrderedString):</source>
          <target state="translated">函子是模块之间的&amp;ldquo;功能&amp;rdquo;。函数使您可以创建参数化的模块，然后提供其他模块作为参数来获得特定的实现。例如，可以将设置为排序列表的集合的Set模块的参数设置为可与任何提供元素类型和比较函数compare的模块（例如OrderedString）一起使用：</target>
        </trans-unit>
        <trans-unit id="e2aa3173a1816096d6ad12168dbc1f9f4f467900" translate="yes" xml:space="preserve">
          <source>Furthermore, quoted strings {|...|} can be combined with extension nodes to embed foreign syntax fragments. Those fragments can be interpreted by a preprocessor and turned into OCaml code without requiring escaping quotes. A syntax shortcut is available for them:</source>
          <target state="translated">此外,引号字符串{|...|}可以与扩展节点相结合,以嵌入外来语法片段。这些片段可以被预处理器解释,并转化为OCaml代码,而不需要转义引号。为它们提供了一个语法快捷方式。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="2e0c6454c25618b51c33652f1af456d60881e227" translate="yes" xml:space="preserve">
          <source>GADT pattern-matching may also add type equations to non-local abstract types. The behaviour is the same as with local abstract types. Reusing the above eq type, one can write:</source>
          <target state="translated">GADT模式匹配也可以给非本地抽象类型添加类型等式。其行为与本地抽象类型相同。重用上面的eq类型,我们可以写。</target>
        </trans-unit>
        <trans-unit id="e770dda21552fdb9094fb60f7cc36a895a76025d" translate="yes" xml:space="preserve">
          <source>Gc</source>
          <target state="translated">Gc</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="67069e1d09b05959a8399aadc22a86b8f23aaa51" translate="yes" xml:space="preserve">
          <source>General input functions</source>
          <target state="translated">一般输入功能</target>
        </trans-unit>
        <trans-unit id="87ca3ca5de8ba6c9c5bd65df11e3e917c3bc1a34" translate="yes" xml:space="preserve">
          <source>General output functions</source>
          <target state="translated">一般输出功能</target>
        </trans-unit>
        <trans-unit id="92e8a116a60d135308df04f70f6a61a19de331d5" translate="yes" xml:space="preserve">
          <source>Generalized algebraic datatypes, or GADTs, extend usual sum types in two ways: constraints on type parameters may change depending on the value constructor, and some type variables may be existentially quantified. Adding constraints is done by giving an explicit return type (the rightmost &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; in the above syntax), where type parameters are instantiated. This return type must use the same type constructor as the type being defined, and have the same number of parameters. Variables are made existential when they appear inside a constructor&amp;rsquo;s argument, but not in its return type.</source>
          <target state="translated">通用代数数据类型或GADT以两种方式扩展了常规的求和类型：对类型参数的约束可能会根据值构造函数而改变，并且某些类型变量可能会被存在地量化。通过给出显式的返回类型（上述语法中最右边的&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）来完成添加约束，在该类型中实例化类型参数。此返回类型必须使用与要定义的类型相同的类型构造函数，并具有相同数量的参数。当变量出现在构造函数的参数中但不在其返回类型中时，它们将变为存在的。</target>
        </trans-unit>
        <trans-unit id="0692177f9aa82986e7e68bb21bd552d660b0fb2a" translate="yes" xml:space="preserve">
          <source>Generally speaking, the formatted input functions have 3 arguments:</source>
          <target state="translated">一般来说,格式化输入函数有3个参数。</target>
        </trans-unit>
        <trans-unit id="c2ed21a61b5e55e8caf4d423c87b86952c6a815c" translate="yes" xml:space="preserve">
          <source>Generate a bytecode executable file that can be executed on the custom runtime system runtime-name, built earlier with ocamlc -make-runtimeruntime-name. See section &amp;zwj;&lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;18.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">生成可在自定义运行时系统运行时名称上执行的字节码可执行文件，该文件先前使用ocamlc -make-runtimeruntime-name构建。请参见&lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;18.1.6&lt;/a&gt;获取更多信息。</target>
        </trans-unit>
        <trans-unit id="ae547ac3f788ba5ce6bb43946b8b3189c176f64a" translate="yes" xml:space="preserve">
          <source>Generate a bytecode executable file that can be executed on the custom runtime system runtime-name, built earlier with ocamlc -make-runtimeruntime-name. See section &lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">生成可在自定义运行时系统运行时名称上执行的字节码可执行文件，该文件先前使用ocamlc -make-runtimeruntime-name构建。有关更多信息，请参见第&lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="e7384f4e0f133518743705b706281153ceace0aa" translate="yes" xml:space="preserve">
          <source>Generate a dependency graph for the toplevel modules, in a format suitable for displaying and processing by dot. The dot tool is available from &lt;a href=&quot;https://graphviz.org/&quot;&gt;https://graphviz.org/&lt;/a&gt;. The textual representation of the graph is written to the file ocamldoc.out, or to the file specified with the -o option. Use dot ocamldoc.out to display it.</source>
          <target state="translated">以适合于按点显示和处理的格式，为顶层模块生成依赖关系图。点工具可从&lt;a href=&quot;https://graphviz.org/&quot;&gt;https://graphviz.org/获得&lt;/a&gt;。图形的文本表示形式将写入文件ocamldoc.out或使用-o选项指定的文件中。使用点ocamldoc.out来显示它。</target>
        </trans-unit>
        <trans-unit id="156fdd8d300b8c00d971004d85456ef8219690af" translate="yes" xml:space="preserve">
          <source>Generate a description of the parsing tables and a report on conflicts resulting from ambiguities in the grammar. The description is put in file grammar.output.</source>
          <target state="translated">生成对解析表的描述和对语法中的歧义造成的冲突的报告。该说明放在文件 grammar.output 中。</target>
        </trans-unit>
        <trans-unit id="49a9fa22c03767adb75add693dfa90c38c0ebdbe" translate="yes" xml:space="preserve">
          <source>Generate an object file (.cmo) that can later be included as a sub-module (with the given access path) of a compilation unit constructed with -pack. For instance, ocamlc -for-pack P -c A.ml will generate a..cmo that can later be used with ocamlc -pack -o P.cmo a.cmo. Note: you can still pack a module that was compiled without -for-pack but in this case exceptions will be printed with the wrong names.</source>
          <target state="translated">生成一个对象文件(.cmo),以后可以作为一个子模块(使用给定的访问路径)包含在用-pack构建的编译单元中。例如,ocamlc -for-pack P -c A.ml将生成一个.cmo,以后可以使用ocamlc -pack -o P.cmo a.cmo。注意:你仍然可以打包一个没有使用-for-pack编译的模块,但是在这种情况下,异常的名字会被打印出来。</target>
        </trans-unit>
        <trans-unit id="7103fb059f2d362dcfc616012cde802b4f623d5e" translate="yes" xml:space="preserve">
          <source>Generate an object file (.cmx and .o/.obj files) that can later be included as a sub-module (with the given access path) of a compilation unit constructed with -pack. For instance, ocamlopt -for-pack P -c A.ml will generate a..cmx and a.o files that can later be used with ocamlopt -pack -o P.cmx a.cmx. Note: you can still pack a module that was compiled without -for-pack but in this case exceptions will be printed with the wrong names.</source>
          <target state="translated">生成一个对象文件(.cmx和.o/.obj文件),以后可以作为一个子模块(使用给定的访问路径)包含在用-pack构建的编译单元中。例如,ocamlopt -for-pack P -c A.ml将生成a..cmx和a.o文件,这些文件可以在以后被ocamlopt -pack -o P.cmx a.cmx使用。注意:你仍然可以打包一个没有使用 -for-pack编译的模块,但是在这种情况下,会以错误的名称打印异常。</target>
        </trans-unit>
        <trans-unit id="266d7ee3cde25ec4eb6f33154bf1ffb8dd2f15a2" translate="yes" xml:space="preserve">
          <source>Generate dependencies for a pure native-code program (no bytecode version). When an implementation file (.ml file) has no explicit interface file (.mli file), ocamldep generates dependencies on the bytecode compiled file (.cmo file) to reflect interface changes. This can cause unnecessary bytecode recompilations for programs that are compiled to native-code only. The flag -native causes dependencies on native compiled files (.cmx) to be generated instead of on .cmo files. (This flag makes no difference if all source files have explicit .mli interface files.)</source>
          <target state="translated">为一个纯本机代码程序生成依赖关系(没有字节码版本)。当一个实现文件(.ml文件)没有明确的接口文件(.mli文件)时,ocamldep会在字节码编译文件(.cmo文件)上生成依赖关系,以反映接口变化。这对于只编译成本地代码的程序来说,会导致不必要的字节码重新编译。标志-native会导致依赖性在本地编译文件(.cmx)上生成,而不是在.cmo文件上生成。(如果所有的源文件都有明确的.mli接口文件,这个标志就没有区别了。)</target>
        </trans-unit>
        <trans-unit id="f287ec97b2026108a81dd10e2f4d965c4671c59e" translate="yes" xml:space="preserve">
          <source>Generate dependencies for native plugin files (.cmxs) in addition to native compiled files (.cmx).</source>
          <target state="translated">除了本地编译文件(.cmx)外,还为本地插件文件(.cmxs)生成依赖关系。</target>
        </trans-unit>
        <trans-unit id="d376a113a8253e681531eb700236c93f62c7c75e" translate="yes" xml:space="preserve">
          <source>Generate dependencies on all required files, rather than assuming implicit dependencies.</source>
          <target state="translated">在所有需要的文件上生成依赖关系,而不是假设隐含的依赖关系。</target>
        </trans-unit>
        <trans-unit id="aea577157b1392082ac83b9fe585387f3b557796" translate="yes" xml:space="preserve">
          <source>Generate documentation as a set of Unix man pages. The generated pages are stored in the current directory, or in the directory specified with the -d option.</source>
          <target state="translated">生成一组Unix手册页的文档。生成的页面存储在当前目录下,或用-d选项指定的目录下。</target>
        </trans-unit>
        <trans-unit id="e5d87db23ea095f4cc3759103db7592876ea4306" translate="yes" xml:space="preserve">
          <source>Generate documentation in HTML default format. The generated HTML pages are stored in the current directory, or in the directory specified with the -d option. You can customize the style of the generated pages by editing the generated style.css file, or by providing your own style sheet using option -css-style. The file style.css is not generated if it already exists or if -css-style is used.</source>
          <target state="translated">生成HTML默认格式的文档。生成的HTML页面存储在当前目录下,或用-d选项指定的目录下。你可以通过编辑生成的style.css文件或使用选项-css-style提供你自己的样式表来定制生成的页面的样式。如果style.css文件已经存在或者使用了-css-style,则不会生成该文件。</target>
        </trans-unit>
        <trans-unit id="f58b7853c614a36ff0c342792e60a65dbe4ad9b5" translate="yes" xml:space="preserve">
          <source>Generate documentation in L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X default format. The generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document is saved in file ocamldoc.out, or in the file specified with the -o option. The document uses the style file ocamldoc.sty. This file is generated when using the -latex option, if it does not already exist. You can change this file to customize the style of your L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X documentation.</source>
          <target state="translated">以L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X默认格式生成文档。所生成的大号&lt;sup&gt;甲&lt;/sup&gt;Ť &lt;sub&gt;&amp;eacute;&lt;/sub&gt; X文档保存在文件ocamldoc.out，或者与-o选项指定的文件中。该文档使用样式文件ocamldoc.sty。如果使用-latex选项，则该文件将生成（如果尚不存在）。您可以更改这个文件来定制您L的风格&lt;sup&gt;一个&lt;/sup&gt;牛逼&lt;sub&gt;&amp;eacute;&lt;/sub&gt; X文档。</target>
        </trans-unit>
        <trans-unit id="129f3a9bee36c9ea1bf962aa07ce63970022d326" translate="yes" xml:space="preserve">
          <source>Generate documentation in TeXinfo default format. The generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document is saved in file ocamldoc.out, or in the file specified with the -o option.</source>
          <target state="translated">以TeXinfo默认格式生成文档。所生成的大号&lt;sup&gt;甲&lt;/sup&gt;Ť &lt;sub&gt;&amp;eacute;&lt;/sub&gt; X文档保存在文件ocamldoc.out，或者与-o选项指定的文件中。</target>
        </trans-unit>
        <trans-unit id="c9fc266b6949eb96df1f7eb844b75ca64039217c" translate="yes" xml:space="preserve">
          <source>Generate files in directory dir, rather than the current directory.</source>
          <target state="translated">在目录dir中生成文件,而不是当前目录。</target>
        </trans-unit>
        <trans-unit id="285e44cc7e6dbcf78a91ff365658da2f4d1959ff" translate="yes" xml:space="preserve">
          <source>Generate man pages only for modules, module types, classes and class types, instead of pages for all elements.</source>
          <target state="translated">只为模块、模块类型、类和类类型生成man页面,而不是为所有元素生成页面。</target>
        </trans-unit>
        <trans-unit id="f9864da8bda2a0e22bc4b39c31b0e724fe7a1a47" translate="yes" xml:space="preserve">
          <source>Generate one .tex file per toplevel module, instead of the global ocamldoc.out file.</source>
          <target state="translated">为每个toplevel模块生成一个.tex文件,而不是全局的ocamldoc.out文件。</target>
        </trans-unit>
        <trans-unit id="ff2e0a3174325a031b5ee70731f141a8ca8cc0cd" translate="yes" xml:space="preserve">
          <source>Generate only index files.</source>
          <target state="translated">只生成索引文件。</target>
        </trans-unit>
        <trans-unit id="98e76556f478e02273e6352c5a860d5aa13d870c" translate="yes" xml:space="preserve">
          <source>Generate position-dependent machine code.</source>
          <target state="translated">生成与位置有关的机器代码。</target>
        </trans-unit>
        <trans-unit id="73e6af12f0ccf65fb7a1459aa5aac3451674ec09" translate="yes" xml:space="preserve">
          <source>Generate position-independent machine code. This is the default.</source>
          <target state="translated">生成与位置无关的机器代码。这是默认的。</target>
        </trans-unit>
        <trans-unit id="39c8ea337bb1a13e369fcb0e566aaf3fd0c0a061" translate="yes" xml:space="preserve">
          <source>Generate signal on INTR, QUIT, SUSP.</source>
          <target state="translated">在INTR、QUIT、SUSP时产生信号。</target>
        </trans-unit>
        <trans-unit id="44c2b556ff44e4d16b71ff51d7440841b3fbf5c4" translate="yes" xml:space="preserve">
          <source>Generic arrays (of arbitrarily many dimensions)</source>
          <target state="translated">通用数组(任意多维)</target>
        </trans-unit>
        <trans-unit id="a9003821b402d9b7458c8ef820262746bf0c5a25" translate="yes" xml:space="preserve">
          <source>Generic interface</source>
          <target state="translated">通用接口</target>
        </trans-unit>
        <trans-unit id="ca8b79d76f57f976b0d3a762bfe49c3a3887f695" translate="yes" xml:space="preserve">
          <source>Genlex</source>
          <target state="translated">Genlex</target>
        </trans-unit>
        <trans-unit id="9e32ad0c42ab8bdae8747cff4350874077b93e6d" translate="yes" xml:space="preserve">
          <source>Geometric functions can be used to manipulate simultaneously the coupled variables, margin and maxixum indentation limit.</source>
          <target state="translated">几何函数可以用来同时操作耦合变量、边距和最大压痕极限。</target>
        </trans-unit>
        <trans-unit id="9d1226717c2fc305626512b0a1ae618fddfee0b9" translate="yes" xml:space="preserve">
          <source>Geometry</source>
          <target state="translated">Geometry</target>
        </trans-unit>
        <trans-unit id="1191afd5022f1dd10193c8bdc209b97228409cc2" translate="yes" xml:space="preserve">
          <source>Get the current value of the atomic reference.</source>
          <target state="translated">获取原子引用的当前值。</target>
        </trans-unit>
        <trans-unit id="6ea2b05a0cc3942bd2ab24dd1445538e05f32023" translate="yes" xml:space="preserve">
          <source>Get the n-th character of the buffer.</source>
          <target state="translated">获取缓冲区的第n个字符。</target>
        </trans-unit>
        <trans-unit id="5785aa5d35936984cbd882807965031baa875625" translate="yes" xml:space="preserve">
          <source>Give a prefix to use for the labels of the values in the generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document. The default prefix is the empty string. You can also use the options -latex-type-prefix, -latex-exception-prefix, -latex-module-prefix, -latex-module-type-prefix, -latex-class-prefix, -latex-class-type-prefix, -latex-attribute-prefix and -latex-method-prefix.</source>
          <target state="translated">给前缀以用于生成L的值的标签&lt;sup&gt;甲&lt;/sup&gt;Ť &lt;sub&gt;&amp;eacute;&lt;/sub&gt; X文件。默认前缀是空字符串。您还可以使用选项-latex-type-prefix，-latex-exception-prefix，-latex-module-prefix，-latex-module-type-prefix，-latex-class-prefix，-latex-class-type-前缀-latex-attribute-prefix和-latex-method-prefix。</target>
        </trans-unit>
        <trans-unit id="038e7979ee15f8f5c9e696afa315dfe00ad4b50f" translate="yes" xml:space="preserve">
          <source>Give arguments as command-line arguments for the program.</source>
          <target state="translated">将参数作为程序的命令行参数。</target>
        </trans-unit>
        <trans-unit id="58fb754d9855207400580560fa5a499d34953865" translate="yes" xml:space="preserve">
          <source>Give help about the command command.</source>
          <target state="translated">给予有关命令指令的帮助。</target>
        </trans-unit>
        <trans-unit id="05560101179d8cd9a5824eb9bc4979bd6dc98da1" translate="yes" xml:space="preserve">
          <source>Give help about the variable variable. The list of all debugger variables can be obtained with help set.</source>
          <target state="translated">给予关于变量的帮助。所有调试器变量的列表可以通过帮助集获得。</target>
        </trans-unit>
        <trans-unit id="371d25ecfb079465a60b6b0a5de188a1933588cb" translate="yes" xml:space="preserve">
          <source>Give help about topic. Use help info to get a list of known topics.</source>
          <target state="translated">提供关于主题的帮助。使用帮助信息来获取已知主题的列表。</target>
        </trans-unit>
        <trans-unit id="604df0eab7062b6f55919a0389be07618d669c2c" translate="yes" xml:space="preserve">
          <source>Give information about the given subject. For instance, info breakpoints will print the list of all breakpoints.</source>
          <target state="translated">给出关于给定主题的信息。例如,info breakpoints将打印所有断点的列表。</target>
        </trans-unit>
        <trans-unit id="1454ccaeebb872ec2b102caf5995ceb3ec79caa0" translate="yes" xml:space="preserve">
          <source>Given a byte sequence &lt;code&gt;s&lt;/code&gt; of length &lt;code&gt;l&lt;/code&gt;, we can access each of the &lt;code&gt;l&lt;/code&gt; bytes of &lt;code&gt;s&lt;/code&gt; via its index in the sequence. Indexes start at &lt;code&gt;0&lt;/code&gt;, and we will call an index valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l-1]&lt;/code&gt; (inclusive). A position is the point between two bytes or at the beginning or end of the sequence. We call a position valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l]&lt;/code&gt; (inclusive). Note that the byte at index &lt;code&gt;n&lt;/code&gt; is between positions &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;n+1&lt;/code&gt;.</source>
          <target state="translated">给定一个长度为 &lt;code&gt;l&lt;/code&gt; 的字节序列 &lt;code&gt;s&lt;/code&gt; ，我们可以通过序列中 &lt;code&gt;s&lt;/code&gt; 的索引访问s的 &lt;code&gt;l&lt;/code&gt; 个字节中的每一个。索引从 &lt;code&gt;0&lt;/code&gt; 开始，如果索引在 &lt;code&gt;[0...l-1]&lt;/code&gt; （包括）范围内，我们将在 &lt;code&gt;s&lt;/code&gt; 中调用有效索引。位置是两个字节之间或序列开头或结尾处的点。如果位置在 &lt;code&gt;[0...l]&lt;/code&gt; （含）范围内，我们称该位置为 &lt;code&gt;s&lt;/code&gt; 。注意，索引 &lt;code&gt;n&lt;/code&gt; 处的字节在位置 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;n+1&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="2adb0b9ad2ceb5bfe49b0ecb92caf5f3fae05f4f" translate="yes" xml:space="preserve">
          <source>Given a string &lt;code&gt;s&lt;/code&gt; of length &lt;code&gt;l&lt;/code&gt;, we can access each of the &lt;code&gt;l&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt; via its index in the sequence. Indexes start at &lt;code&gt;0&lt;/code&gt;, and we will call an index valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l-1]&lt;/code&gt; (inclusive). A position is the point between two characters or at the beginning or end of the string. We call a position valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l]&lt;/code&gt; (inclusive). Note that the character at index &lt;code&gt;n&lt;/code&gt; is between positions &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;n+1&lt;/code&gt;.</source>
          <target state="translated">给定长度为 &lt;code&gt;l&lt;/code&gt; 的字符串 &lt;code&gt;s&lt;/code&gt; ，我们可以通过序列中的 &lt;code&gt;s&lt;/code&gt; 索引访问s的 &lt;code&gt;l&lt;/code&gt; 个字符中的每个字符。索引从 &lt;code&gt;0&lt;/code&gt; 开始，如果索引在 &lt;code&gt;[0...l-1]&lt;/code&gt; （包括）范围内，我们将在 &lt;code&gt;s&lt;/code&gt; 中调用有效索引。位置是两个字符之间或字符串开头或结尾的点。如果位置在 &lt;code&gt;[0...l]&lt;/code&gt; （含）范围内，我们称该位置为 &lt;code&gt;s&lt;/code&gt; 。注意，索引 &lt;code&gt;n&lt;/code&gt; 处的字符在位置 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;n+1&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="6aa38b172ec5c9d2284f131cd775ec188b5d8628" translate="yes" xml:space="preserve">
          <source>Go back to the latest time recorded in the execution history. With an argument, do it count times.</source>
          <target state="translated">回到执行历史中记录的最新时间。有了论据,就做次数计算。</target>
        </trans-unit>
        <trans-unit id="9b60e6e076c005d616d2d916072eb065e52ae28e" translate="yes" xml:space="preserve">
          <source>Going further, this construction can introduce local components inside a structure,</source>
          <target state="translated">再进一步,这种结构可以在结构内部引入局部组件。</target>
        </trans-unit>
        <trans-unit id="0aeace163a6adb474f8a266503a9076db84dd3da" translate="yes" xml:space="preserve">
          <source>Govern whether unsafe object files are allowed to be dynamically linked.</source>
          <target state="translated">规定是否允许动态链接不安全的对象文件。</target>
        </trans-unit>
        <trans-unit id="d84ed49173cfa176fb1c99f2a3dec80f80b0aba6" translate="yes" xml:space="preserve">
          <source>Govern whether unsafe object files are allowed to be dynamically linked. A compilation unit is 'unsafe' if it contains declarations of external functions, which can break type safety. By default, dynamic linking of unsafe object files is not allowed. In native code, this function does nothing; object files with external functions are always allowed to be dynamically linked.</source>
          <target state="translated">规定是否允许动态链接不安全的对象文件。如果一个编译单元包含了外部函数的声明,那么它就是 &quot;不安全的&quot;,这会破坏类型安全。默认情况下,不允许动态链接不安全的对象文件。在本地代码中,这个函数什么也不做;带有外部函数的对象文件总是被允许动态链接。</target>
        </trans-unit>
        <trans-unit id="c9c481167a949ba9541e5157f33a16bc75dec6fe" translate="yes" xml:space="preserve">
          <source>Grammar definitions have the following format:</source>
          <target state="translated">语法定义的格式如下:</target>
        </trans-unit>
        <trans-unit id="6f1e950667e2e44adf45b58bf09492bae226c4f8" translate="yes" xml:space="preserve">
          <source>Group ID of the file's group</source>
          <target state="translated">文件组的组别ID</target>
        </trans-unit>
        <trans-unit id="6419b6179edfb45b0221e7cd7ed865964d5bab58" translate="yes" xml:space="preserve">
          <source>Growing and shrinking of the heap.</source>
          <target state="translated">增长和收缩的堆积。</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="b8ec02c8c64e872c7dd1918af95f84fc205739fb" translate="yes" xml:space="preserve">
          <source>Hang up on last close.</source>
          <target state="translated">最后收盘时挂断。</target>
        </trans-unit>
        <trans-unit id="92d2f449cc1e7472e355886e114b989d0112305b" translate="yes" xml:space="preserve">
          <source>Hangup on controlling terminal</source>
          <target state="translated">控制终端挂起</target>
        </trans-unit>
        <trans-unit id="f156c0d6e4e285c95352406b7047bb7ecc056fb3" translate="yes" xml:space="preserve">
          <source>Hardware I/O error</source>
          <target state="translated">硬件I/O错误</target>
        </trans-unit>
        <trans-unit id="c5989bb5f874fe020eb5b05197afeb1595f9e30f" translate="yes" xml:space="preserve">
          <source>Hash tables and hash functions.</source>
          <target state="translated">哈希表和哈希函数。</target>
        </trans-unit>
        <trans-unit id="5152ba26a0f6c91803db8e6e54eb626e6caf15e9" translate="yes" xml:space="preserve">
          <source>Hash tables are hashed association tables, with in-place modification.</source>
          <target state="translated">哈希表是哈希关联表,有就地修改。</target>
        </trans-unit>
        <trans-unit id="40eccfdcd3a6ae41d207d7bfa40b24bd7e9f58a3" translate="yes" xml:space="preserve">
          <source>Hash tables on generic containers with notion of death and aliveness.</source>
          <target state="translated">具有死亡和生命力概念的通用容器的哈希表。</target>
        </trans-unit>
        <trans-unit id="92bab01eaa07991ec1d5268ad63bfd41d8f81ce4" translate="yes" xml:space="preserve">
          <source>Hashtbl</source>
          <target state="translated">Hashtbl</target>
        </trans-unit>
        <trans-unit id="8de9b03544fae209b6d485a82f3fb0bc61712994" translate="yes" xml:space="preserve">
          <source>Having been given the following code, the compiler will inline loop into f, and then observe inv being invariant and always the pair formed by adding 42 and 43 to the argument x of the function f.</source>
          <target state="translated">给出下面的代码后,编译器将内联循环到f中,然后观察到inv是不变的,总是在函数f的参数x上加上42和43所形成的对。</target>
        </trans-unit>
        <trans-unit id="00999d5419281dc73a86b97d51f054b1c30f6f29" translate="yes" xml:space="preserve">
          <source>Heap compaction is triggered when the estimated amount of &quot;wasted&quot; memory is more than &lt;code&gt;max_overhead&lt;/code&gt; percent of the amount of live data. If &lt;code&gt;max_overhead&lt;/code&gt; is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If &lt;code&gt;max_overhead&amp;nbsp;&amp;gt;=&amp;nbsp;1000000&lt;/code&gt;, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set &lt;code&gt;allocation_policy&lt;/code&gt; to 2. Default: 500.</source>
          <target state="translated">当估计的&amp;ldquo;浪费&amp;rdquo;内存量超过实时数据量的 &lt;code&gt;max_overhead&lt;/code&gt; 百分比时，将触发堆压缩。如果将 &lt;code&gt;max_overhead&lt;/code&gt; 设置为0，则在每个主要GC周期结束时触发堆压缩（此设置仅用于测试目的）。如果 &lt;code&gt;max_overhead&amp;nbsp;&amp;gt;=&amp;nbsp;1000000&lt;/code&gt; ，则永远不会触发压缩。如果永久禁用压缩，则强烈建议将 &lt;code&gt;allocation_policy&lt;/code&gt; 设置为2。默认值：500。</target>
        </trans-unit>
        <trans-unit id="f9c50122226f9d6dcf71b56ac7a7f8d8b4c3c78a" translate="yes" xml:space="preserve">
          <source>Heap compaction.</source>
          <target state="translated">堆积压实。</target>
        </trans-unit>
        <trans-unit id="758afbd2a13c2682e468e247eb3f98ab9f95fabf" translate="yes" xml:space="preserve">
          <source>Hence, a typical call to the formatted input function &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt;, where:</source>
          <target state="translated">因此，对格式化输入函数&lt;a href=&quot;scanf#VALbscanf&quot;&gt; &lt;code&gt;Scanf.bscanf&lt;/code&gt; &lt;/a&gt;的典型调用是 &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; ，其中：</target>
        </trans-unit>
        <trans-unit id="14ac05929489e0ffc8dddd667d63b054e933d010" translate="yes" xml:space="preserve">
          <source>Hence, the clients do not have direct access to the balance, nor the history of their own accounts. Their only way to change their balance is to deposit or withdraw money. It is important to give the clients a class and not just the ability to create accounts (such as the promotional discount account), so that they can personalize their account. For instance, a client may refine the deposit and withdraw methods so as to do his own financial bookkeeping, automatically. On the other hand, the function discount is given as such, with no possibility for further personalization.</source>
          <target state="translated">因此,客户无法直接查看自己账户的余额或历史记录。他们改变自己余额的唯一途径是存款或提款。重要的是,要给客户一个类,而不仅仅是创建账户的能力(如促销折扣账户),这样客户就可以对自己的账户进行个性化改造。比如,客户可以细化存款和取款方式,让自己的财务记账,自动完成。另一方面,打折这个功能就这样被赋予了,没有进一步个性化的可能。</target>
        </trans-unit>
        <trans-unit id="03570ac90dade998e56b554e41239c2460db8925" translate="yes" xml:space="preserve">
          <source>Hence, this conversion always succeeds: it returns an empty string if the bounding condition holds when the scan begins.</source>
          <target state="translated">因此,这种转换总是成功的:如果在扫描开始时边界条件成立,则返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="c78f7a697615de15b124ff10dc612688faeddea6" translate="yes" xml:space="preserve">
          <source>Here (test () ()) is already (0,0,0) and cannot be further applied.</source>
          <target state="translated">这里(测试()())已经是(0,0,0),不能再应用。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="c2d3820c838ff6ce0440d2b2700f2e77ee57f5a5" translate="yes" xml:space="preserve">
          <source>Here are some of the label names you will find throughout the libraries.</source>
          <target state="translated">以下是你在整个图书馆中会发现的一些标签名称。</target>
        </trans-unit>
        <trans-unit id="a24a6072e91fffecf48135b656042082bc3b6e9a" translate="yes" xml:space="preserve">
          <source>Here f1 and f2 both accept the variant tags `A and `B, but the argument of `A is int for f1 and string for f2. In f&amp;rsquo;s type `C, only accepted by f1, disappears, but both argument types appear for `A as int &amp;amp; string. This means that if we pass the variant tag `A to f, its argument should be &lt;em&gt;both&lt;/em&gt;int and string. Since there is no such value, f cannot be applied to `A, and `B is the only accepted input.</source>
          <target state="translated">这里f1和f2都接受变量标签A和B，但是A的参数对于f1是int，对于f2是字符串。在f的类型C中，仅被f1接受的类型消失了，但是对于A的两种参数类型都以int＆string的形式出现。这意味着，如果我们将变量标签A传递给f，则其参数应&lt;em&gt;同时为&lt;/em&gt;int和string。由于没有这样的值，因此无法将f应用于`A，并且`B是唯一接受的输入。</target>
        </trans-unit>
        <trans-unit id="561164ceab5ebc70c0d64deefe4330729b9658fb" translate="yes" xml:space="preserve">
          <source>Here is a concrete example:</source>
          <target state="translated">下面是一个具体的例子。</target>
        </trans-unit>
        <trans-unit id="aba64a5365a5818e1799acb408be84f8f2c8e9d4" translate="yes" xml:space="preserve">
          <source>Here is a naive decoder example, using &lt;em&gt;babeltrace&lt;/em&gt;&amp;rsquo;s Python library, and &lt;em&gt;Python 3.8&lt;/em&gt;:</source>
          <target state="translated">这是一个天真的解码器示例，使用了&lt;em&gt;babeltrace&lt;/em&gt;的Python库和&lt;em&gt;Python 3.8&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="59957446a4d33ae4c96bc863ccc6ed285dc68c5a" translate="yes" xml:space="preserve">
          <source>Here is a template Makefile for a OCaml program.</source>
          <target state="translated">这里是一个 OCaml 程序的模板 Makefile。</target>
        </trans-unit>
        <trans-unit id="f39d81d7a3d048698fdf682899353d5db74f1a73" translate="yes" xml:space="preserve">
          <source>Here is an example of a polymorphic function that takes the runtime representation of some type t and a value of the same type, then pretty-prints the value as a string:</source>
          <target state="translated">下面是一个多态函数的例子,该函数接收某个类型t的运行时表示和一个相同类型的值,然后将该值漂亮地打印成一个字符串。</target>
        </trans-unit>
        <trans-unit id="94c58fafa88c1f0f0b0be0a6b490aeafbe73e10f" translate="yes" xml:space="preserve">
          <source>Here is an example of encapsulation of out-of-heap pointers of C type ty * inside Abstract_tag blocks. Section &amp;zwj;&lt;a href=&quot;#s%3Ac-intf-example&quot;&gt;18.6&lt;/a&gt; gives a more complete example using Custom_tag blocks.</source>
          <target state="translated">这是在Abstract_tag块中封装C类型ty *的堆外指针的示例。第&lt;a href=&quot;#s%3Ac-intf-example&quot;&gt;18.6&lt;/a&gt;给出了使用Custom_tag块一个更完整的例子。</target>
        </trans-unit>
        <trans-unit id="89e03958ef86650f0911d60b7395939fdf73500e" translate="yes" xml:space="preserve">
          <source>Here is an example of encapsulation of out-of-heap pointers of C type ty * inside Abstract_tag blocks. Section &lt;a href=&quot;#s%3Ac-intf-example&quot;&gt;20.6&lt;/a&gt; gives a more complete example using Custom_tag blocks.</source>
          <target state="translated">这是在Abstract_tag块中封装C类型ty *的堆外指针的示例。第&lt;a href=&quot;#s%3Ac-intf-example&quot;&gt;20.6&lt;/a&gt;节提供了使用Custom_tag块的更完整示例。</target>
        </trans-unit>
        <trans-unit id="308b0d78062d0ad0003e582da279f23acb702da1" translate="yes" xml:space="preserve">
          <source>Here is an example using both singleton types and equality witnesses to implement dynamic types.</source>
          <target state="translated">这里是一个使用单子类型和平等证人来实现动态类型的例子。</target>
        </trans-unit>
        <trans-unit id="a225c0d46c3cbb924c84a138670dbc8f06f0cc3e" translate="yes" xml:space="preserve">
          <source>Here is another example:</source>
          <target state="translated">这里还有一个例子。</target>
        </trans-unit>
        <trans-unit id="284f8d0b01b42153fa84e0b1f00a100c6214fbc8" translate="yes" xml:space="preserve">
          <source>Here is how to develop a HTML generator handling your custom tags.</source>
          <target state="translated">下面是如何开发一个HTML生成器来处理你的自定义标签。</target>
        </trans-unit>
        <trans-unit id="c2dbaf9de1c69f014cb64b41bd3b7343fac784a8" translate="yes" xml:space="preserve">
          <source>Here is how to rewrite the pretty-printer using fprintf:</source>
          <target state="translated">下面是使用fprintf重写pretty-printer的方法。</target>
        </trans-unit>
        <trans-unit id="8aa1b2114ba8ea9e3cf06e2d4912d6761acbe4be" translate="yes" xml:space="preserve">
          <source>Here is the BNF grammar for the simple markup language used to format text descriptions.</source>
          <target state="translated">这里是BNF语法,用于格式化文本描述的简单标记语言。</target>
        </trans-unit>
        <trans-unit id="388da24303f96c71ff151f75e86ac54ea859531d" translate="yes" xml:space="preserve">
          <source>Here is the C stub code for calling these functions from C:</source>
          <target state="translated">这里是用C语言调用这些函数的C语言存根代码。</target>
        </trans-unit>
        <trans-unit id="7e741bd10b766cf1796a36394a51e7d62035fecd" translate="yes" xml:space="preserve">
          <source>Here is the definition for the corresponding lexer:</source>
          <target state="translated">下面是相应词典的定义。</target>
        </trans-unit>
        <trans-unit id="056f1f0f51eab79857c6e29e42baa016f78d2977" translate="yes" xml:space="preserve">
          <source>Here is the main program, that combines the parser with the lexer:</source>
          <target state="translated">这里是主程序,它结合了解析器和词法器。</target>
        </trans-unit>
        <trans-unit id="446b11c3be57d6c60ef1fd0ac52fa6e52063c114" translate="yes" xml:space="preserve">
          <source>Here is the same function written using the low-level allocation functions. We notice that the cons cells are small blocks and can be allocated with caml_alloc_small, and filled by direct assignments on their fields.</source>
          <target state="translated">这里是使用低级分配函数编写的相同函数。我们注意到cons单元格是小块,可以用caml_alloc_small进行分配,并通过对其字段的直接赋值来填充。</target>
        </trans-unit>
        <trans-unit id="18941c3984943cc307db931410d47e92fe4df6de" translate="yes" xml:space="preserve">
          <source>Here is where the debugger events (written ǧ) are located in the source code:</source>
          <target state="translated">这里是调试器事件(写成ǧ)在源代码中的位置。</target>
        </trans-unit>
        <trans-unit id="5b08d25e0d333e96aba2f91f119d4d2b7bffff20" translate="yes" xml:space="preserve">
          <source>Here the return type int is never mixed with a, so it is seen as non-ambiguous, and can be inferred. When using such partial type annotations we strongly suggest specifying the -principal mode, to check that inference is principal.</source>
          <target state="translated">在这里,返回类型int从不与a混合,所以它被视为非歧义的,可以被推断。当使用这种部分类型注释时,我们强烈建议指定-principal模式,以检查推理是否是主模式。</target>
        </trans-unit>
        <trans-unit id="10cb8cd98c3cdedd87ca3af31d62baffc2ee326e" translate="yes" xml:space="preserve">
          <source>Here type eq has only one constructor, and by matching on it one adds a local constraint allowing the conversion between a and b. By building such equality witnesses, one can make equal types which are syntactically different.</source>
          <target state="translated">这里eq类型只有一个构造函数,通过对它的匹配,可以增加一个允许a和b之间转换的局部约束,通过建立这样的平等证人,可以使语法上不同的平等类型。</target>
        </trans-unit>
        <trans-unit id="8b271b0c3304eb3ee95f254204f52094adf07587" translate="yes" xml:space="preserve">
          <source>Here unix is the identifier for the alert. If this alert category is enabled, any reference to U.fork will produce a message at compile time, which can be turned or not into a fatal error.</source>
          <target state="translated">这里unix是警报的标识符。如果启用了这一警报类别,任何对U.fork的引用都会在编译时产生一条消息,这可以变成或不变成一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="e022f6709dae55bc7a223efa347b05eb7e8f59f3" translate="yes" xml:space="preserve">
          <source>Here we are seeing two phenomena. First, since this matching is open (the last case catches any tag), we obtain the type [&amp;gt; `A | `B] rather than [&amp;lt; `A | `B] in a closed matching. Then, since x is returned as is, input and return types are identical. The notation as 'a denotes such type sharing. If we apply f to yet another tag `E, it gets added to the list.</source>
          <target state="translated">在这里，我们看到了两种现象。首先，由于此匹配是开放的（最后一种情况捕获了任何标签），我们获得类型[&amp;gt;`A | `B]而不是[&amp;lt;`A | 'B'在一个封闭的匹配中。然后，由于x照原样返回，因此输入和返回类型相同。符号&amp;ldquo; a&amp;rdquo;表示这种类型的共享。如果我们将f应用于另一个标签`E，它将被添加到列表中。</target>
        </trans-unit>
        <trans-unit id="fc63fa497589a6334b111c69df1747a0dd97fc2a" translate="yes" xml:space="preserve">
          <source>Here, OCaml has inferred that the possible choices for the type of {x;z} are first_record and middle_record, since the type last_record has no field z. Ocaml then picks the type middle_record as the last defined type between the two possibilities.</source>
          <target state="translated">这里,OCaml推断{x;z}的类型可能的选择是first_record和middle_record,因为类型last_record没有字段z,于是Ocaml在这两种可能的类型中选择了middle_record作为最后定义的类型。</target>
        </trans-unit>
        <trans-unit id="e9ad79e7f5e8745df73965ac6283aa221a2cfb1b" translate="yes" xml:space="preserve">
          <source>Here, exposing the representation of strings is probably harmless. We do could also hide the representation of strings as we hid the currency in the class money of section &amp;zwj;&lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="translated">在这里，暴露字符串的表示形式可能是无害的。我们做的还可以隐藏的字符串的表现正如我们在部分的类钱藏币&lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b060c78130d7f93cdd27667dbd10437fa706949d" translate="yes" xml:space="preserve">
          <source>Here, exposing the representation of strings is probably harmless. We do could also hide the representation of strings as we hid the currency in the class money of section &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="translated">在这里，暴露字符串的表示形式可能是无害的。当我们将货币隐藏在&lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;节的类货币中时，我们也可以隐藏字符串的表示形式。</target>
        </trans-unit>
        <trans-unit id="acd4519239484578811a092a4daeaa544e7eb37d" translate="yes" xml:space="preserve">
          <source>Here, the private declaration ensures that in any value of type M.t, the argument to the B constructor is always a positive integer.</source>
          <target state="translated">在这里,private声明确保在M.t类型的任何值中,B构造函数的参数总是一个正整数。</target>
        </trans-unit>
        <trans-unit id="1ee51e87098916ce5e24ed6b88b7de69de869c00" translate="yes" xml:space="preserve">
          <source>Here, the registering of result is not strictly needed, because no allocation takes place after it gets its value, but it&amp;rsquo;s easier and safer to simply register all the local variables that have type value.</source>
          <target state="translated">在这里，并不需要严格注册结果，因为在获得结果值后就不会进行分配，但是简单地注册所有具有类型值的局部变量会更容易，更安全。</target>
        </trans-unit>
        <trans-unit id="e432da26179fd3758bb19dd844fa23eec9ba8078" translate="yes" xml:space="preserve">
          <source>Here, the representation of the object is known only to a particular object. To make it available to other objects of the same class, we are forced to make it available to the whole world. However we can easily restrict the visibility of the representation using the module system.</source>
          <target state="translated">在这里,对象的表征只为某一对象所知。为了使它对同一类的其他对象可用,我们不得不使它对整个世界可用。然而我们可以利用模块系统轻松地限制表示的可见性。</target>
        </trans-unit>
        <trans-unit id="2fa5773c339f395510cdd47c4eb05d1e72c299e1" translate="yes" xml:space="preserve">
          <source>Hide the given complete module names in the generated documentation. modules is a list of complete module names separated by &amp;rsquo;,&amp;rsquo;, without blanks. For instance: Stdlib,M2.M3.</source>
          <target state="translated">在生成的文档中隐藏给定的完整模块名称。modules是由&amp;ldquo;，&amp;rdquo;分隔的完整模块名称的列表，不带空格。例如：Stdlib，M2.M3。</target>
        </trans-unit>
        <trans-unit id="29ab4f5df7d32ff189d23eeac09eea791a2f04d4" translate="yes" xml:space="preserve">
          <source>High levels of inlining performed by Flambda may expose bugs in code thought previously to be correct. Take care, for example, not to add type annotations that claim some mutable value is always immediate if it might be possible for an unsafe operation to update it to a boxed value.</source>
          <target state="translated">由Flambda执行的高水平内联可能会暴露以前认为正确的代码中的错误。例如,如果不安全的操作有可能将其更新为一个框定值,则要注意不要添加类型注释,声称某些可变值总是立即的。</target>
        </trans-unit>
        <trans-unit id="660cd8080dffe58889ce5763038bf5300dc31acd" translate="yes" xml:space="preserve">
          <source>High-level network connection functions</source>
          <target state="translated">高级网络连接功能</target>
        </trans-unit>
        <trans-unit id="64fc91bf4f5322a745e7df5d0f9481f4d5653b51" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management.</source>
          <target state="translated">高水平的管道和工艺管理。</target>
        </trans-unit>
        <trans-unit id="d630cd51e2ab49c23404375744103dcb9ddf12c0" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. The first argument specifies the command to run, and the second argument specifies the argument array passed to the command. This function runs the command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel.</source>
          <target state="translated">高层管道和进程管理。第一个参数指定要运行的命令,第二个参数指定传递给命令的参数数组。该函数将命令与程序并行运行。命令的标准输出被重定向到管道,可以通过返回的输入通道读取。</target>
        </trans-unit>
        <trans-unit id="a31d961a8252f33564ca1cdad952791054058fa6" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (cf. &lt;code&gt;system&lt;/code&gt;).</source>
          <target state="translated">高级管道和过程管理。此函数与程序并行运行给定命令。命令的标准输出重定向到管道，可以通过返回的输入通道读取该管道。该命令由外壳程序 &lt;code&gt;/bin/sh&lt;/code&gt; 解释（参见 &lt;code&gt;system&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3a456b402f5a87f65dd79e5881fc3236030290cf" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (or &lt;code&gt;cmd.exe&lt;/code&gt; on Windows), cf. &lt;a href=&quot;unix#VALsystem&quot;&gt;&lt;code&gt;Unix.system&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; function can be used to quote the command and its arguments as appropriate for the shell being used. If the command does not need to be run through the shell, &lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt;&lt;code&gt;Unix.open_process_args_in&lt;/code&gt;&lt;/a&gt; can be used as a more robust and more efficient alternative to &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">高级管道和过程管理。此函数与程序并行运行给定命令。命令的标准输出重定向到管道，可以通过返回的输入通道读取该管道。该命令由外壳程序 &lt;code&gt;/bin/sh&lt;/code&gt; （或Windows上的 &lt;code&gt;cmd.exe&lt;/code&gt; ）解释。&lt;a href=&quot;unix#VALsystem&quot;&gt; &lt;code&gt;Unix.system&lt;/code&gt; &lt;/a&gt;。该&lt;a href=&quot;filename#VALquote_command&quot;&gt; &lt;code&gt;Filename.quote_command&lt;/code&gt; &lt;/a&gt;函数可用于引用所使用的命令和它的以适合壳参数。如果该命令不需要通过外壳运行，&lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt; &lt;code&gt;Unix.open_process_args_in&lt;/code&gt; &lt;/a&gt;可以将Unix.open_process_args_in用作Unix.open_process_in的更强大，更高效的替代&lt;a href=&quot;unix#VALopen_process_in&quot;&gt; &lt;code&gt;Unix.open_process_in&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce83c28cf3544cd84c9803d0a76d7b72d31fa6a3" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (or &lt;code&gt;cmd.exe&lt;/code&gt; on Windows), cf. &lt;a href=&quot;unixlabels#VALsystem&quot;&gt;&lt;code&gt;UnixLabels.system&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; function can be used to quote the command and its arguments as appropriate for the shell being used. If the command does not need to be run through the shell, &lt;a href=&quot;unixlabels#VALopen_process_args_in&quot;&gt;&lt;code&gt;UnixLabels.open_process_args_in&lt;/code&gt;&lt;/a&gt; can be used as a more robust and more efficient alternative to &lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt;&lt;code&gt;UnixLabels.open_process_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">高级管道和过程管理。此函数与程序并行运行给定命令。命令的标准输出重定向到管道，可以通过返回的输入通道读取该管道。该命令由外壳程序 &lt;code&gt;/bin/sh&lt;/code&gt; （或Windows上的 &lt;code&gt;cmd.exe&lt;/code&gt; ）解释。&lt;a href=&quot;unixlabels#VALsystem&quot;&gt; &lt;code&gt;UnixLabels.system&lt;/code&gt; &lt;/a&gt;。该&lt;a href=&quot;filename#VALquote_command&quot;&gt; &lt;code&gt;Filename.quote_command&lt;/code&gt; &lt;/a&gt;函数可用于引用所使用的命令和它的以适合壳参数。如果该命令不需要通过外壳运行，&lt;a href=&quot;unixlabels#VALopen_process_args_in&quot;&gt; &lt;code&gt;UnixLabels.open_process_args_in&lt;/code&gt; &lt;/a&gt;可以将UnixLabels.open_process_args_in用作UnixLabels.open_process_in的更强大，更高效的替代&lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt; &lt;code&gt;UnixLabels.open_process_in&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a29172035d6d85dc663ba7e39082390589b775be" translate="yes" xml:space="preserve">
          <source>High-level process and redirection management</source>
          <target state="translated">高层流程和重定向管理</target>
        </trans-unit>
        <trans-unit id="2a33c2b6a314329b777f9efd6ddae94062b493db" translate="yes" xml:space="preserve">
          <source>Histogram of bucket sizes. This array &lt;code&gt;histo&lt;/code&gt; has length &lt;code&gt;max_bucket_length&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;. The value of &lt;code&gt;histo.(i)&lt;/code&gt; is the number of buckets whose size is &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">铲斗尺寸的直方图。这个数组 &lt;code&gt;histo&lt;/code&gt; 具有长度 &lt;code&gt;max_bucket_length&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 。 &lt;code&gt;histo.(i)&lt;/code&gt; 的值是大小为 &lt;code&gt;i&lt;/code&gt; 的存储桶数。</target>
        </trans-unit>
        <trans-unit id="9fc8eded9808dd321a05fbe7b423579b8ee46feb" translate="yes" xml:space="preserve">
          <source>Host and protocol databases</source>
          <target state="translated">主机和协议数据库</target>
        </trans-unit>
        <trans-unit id="7e44bbbaded72ef9b5085984836ab8806136eb0e" translate="yes" xml:space="preserve">
          <source>Host and service information returned by &lt;a href=&quot;unix#VALgetnameinfo&quot;&gt;&lt;code&gt;Unix.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetnameinfo&quot;&gt; &lt;code&gt;Unix.getnameinfo&lt;/code&gt; &lt;/a&gt;返回的主机和服务信息。</target>
        </trans-unit>
        <trans-unit id="bba39b666694c191c5a86c56276e30c25ce84002" translate="yes" xml:space="preserve">
          <source>Host and service information returned by &lt;a href=&quot;unixlabels#VALgetnameinfo&quot;&gt;&lt;code&gt;UnixLabels.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALgetnameinfo&quot;&gt; &lt;code&gt;UnixLabels.getnameinfo&lt;/code&gt; &lt;/a&gt;返回的主机和服务信息。</target>
        </trans-unit>
        <trans-unit id="a5a7e131a5cb8762553101bda765297974113fa2" translate="yes" xml:space="preserve">
          <source>Host is down</source>
          <target state="translated">主机故障</target>
        </trans-unit>
        <trans-unit id="e6b20c4f18fba11bf22b7eb25c422f7383d8a3f3" translate="yes" xml:space="preserve">
          <source>Hours 0..23</source>
          <target state="translated">0.23小时</target>
        </trans-unit>
        <trans-unit id="1c2e7e04df5e1f8935731260449f2e4dff010f63" translate="yes" xml:space="preserve">
          <source>How many rounds of optimisation to perform. See section &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;19.2.1&lt;/a&gt;.</source>
          <target state="translated">要执行多少轮优化。参见第&lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;19.2.1&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="a3b35a8d557fc5292ba116b9b094f27e8f1f0b10" translate="yes" xml:space="preserve">
          <source>How many rounds of optimisation to perform. See section &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1&lt;/a&gt;.</source>
          <target state="translated">要执行多少轮优化。参见第&lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="54107178e78d43729885a7720437da1670a7ca51" translate="yes" xml:space="preserve">
          <source>How much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.</source>
          <target state="translated">增加主要堆时要增加多少。如果这个数字小于或等于1000,则是当前堆大小的百分比(即设置为100,则每次增加时,堆的大小将增加一倍)。如果它大于1000,则是一个固定的字数,将被添加到堆中。默认值:15。</target>
        </trans-unit>
        <trans-unit id="3e08adcc4e52311113e7bfcb35cebc7fc05cb528" translate="yes" xml:space="preserve">
          <source>However the following code will still return 42:</source>
          <target state="translated">但是下面的代码仍然会返回42。</target>
        </trans-unit>
        <trans-unit id="8da81d46307b91fff8fddf943d3b6f54904f4acb" translate="yes" xml:space="preserve">
          <source>However, another semantics may be considered more natural here: any pair that has one side passing the test will take the branch. With this semantics the previous code fragment would be equivalent to</source>
          <target state="translated">然而,另一种语义在这里可能被认为是更自然的:任何有一方通过测试的对子都将采取分支。有了这种语义,前面的代码片段就相当于</target>
        </trans-unit>
        <trans-unit id="b11631e4eb742b73778c9e3a1a94f9ec22cd9e49" translate="yes" xml:space="preserve">
          <source>However, before referencing another compilation unit, an implementation of that unit must be present in memory. At start-up, the toplevel system contains implementations for all the modules in the the standard library. Implementations for user modules can be entered with the #load directive described above. Referencing a unit for which no implementation has been provided results in the error Reference to undefined global `...'.</source>
          <target state="translated">然而,在引用另一个编译单元之前,内存中必须有该单元的实现。在启动时,toplevel系统包含了标准库中所有模块的实现,用户模块的实现可以通过上面描述的#load指令输入。用户模块的实现可以通过上面描述的#load指令来输入。引用一个没有提供实现的单元会导致错误Reference to undefined global `...'。</target>
        </trans-unit>
        <trans-unit id="41e8753db777bb602f194cf91bcdc0dd3f1d1843" translate="yes" xml:space="preserve">
          <source>However, if lexer rules are introduced with the shortest keyword in place of the parse keyword, then the &amp;ldquo;shortest match&amp;rdquo; rule applies: the shortest prefix of the input is selected. In case of tie, the regular expression that occurs earlier in the rule is still selected. This feature is not intended for use in ordinary lexical analyzers, it may facilitate the use of ocamllex as a simple text processing tool.</source>
          <target state="translated">但是，如果使用最短关键字代替parse关键字引入词法分析器规则，则将应用&amp;ldquo;最短匹配&amp;rdquo;规则：选择输入的最短前缀。在平局的情况下，仍会选择规则中较早出现的正则表达式。此功能不适用于普通词法分析器，它可能有助于将ocamllex用作简单的文本处理工具。</target>
        </trans-unit>
        <trans-unit id="944f5f03f5c76a0cf57976a0a3d9c3e3e582504a" translate="yes" xml:space="preserve">
          <source>However, if the program is changed to include a call to Gc.eventlog_resume, events payloads can be seen again in the trace file.</source>
          <target state="translated">但是,如果改变程序,加入对Gc.eventlog_resume的调用,在跟踪文件中又可以看到事件的有效载荷。</target>
        </trans-unit>
        <trans-unit id="76abd1d96d1c865f566606abb7355db8f0cf0b1f" translate="yes" xml:space="preserve">
          <source>However, the abbreviation #c' cannot be defined directly in a similar way. It can only be defined by a class or a class-type definition. This is because a #-abbreviation carries an implicit anonymous variable .. that cannot be explicitly named. The closer you get to it is:</source>
          <target state="translated">然而,缩写#c'不能以类似的方式直接定义。它只能由一个类或一个类类型定义来定义。这是因为#-缩写带有一个隐含的匿名变量......不能显式命名。越接近它就是。</target>
        </trans-unit>
        <trans-unit id="453dcc94eeb7e578d8082b01f6ebd6cec66637be" translate="yes" xml:space="preserve">
          <source>However, the bug might be fixed more safely by the following definition:</source>
          <target state="translated">然而,通过以下定义可以更安全地修复这个错误。</target>
        </trans-unit>
        <trans-unit id="c720d37ad34c33bb2deaffa9bd67b5537585a52d" translate="yes" xml:space="preserve">
          <source>However, the domain of the coercion cannot always be omitted. In that case, the solution is to use the explicit form. Sometimes, a change in the class-type definition can also solve the problem</source>
          <target state="translated">但是,不能总是省略胁迫的领域。在这种情况下,解决的办法是使用显式。有时,改变类型定义也可以解决这个问题。</target>
        </trans-unit>
        <trans-unit id="c0ee79bd6d9b251f8a82a82d67365c84132c706f" translate="yes" xml:space="preserve">
          <source>However, the former pattern is generally more appropriate, since the code for adjustment is part of the definition of the class and will be inherited.</source>
          <target state="translated">不过,一般来说,前一种模式比较合适,因为调整的代码是类定义的一部分,会被继承。</target>
        </trans-unit>
        <trans-unit id="87a9a30d2a6c456b46a8651fb0691f17ba51e44f" translate="yes" xml:space="preserve">
          <source>However, the method escaped returns an object of the class ostring, and not an object of the current class. Hence, if the class is further extended, the method escaped will only return an object of the parent class.</source>
          <target state="translated">然而,方法 escaped 返回的是类 ostring 的对象,而不是当前类的对象。因此,如果类被进一步扩展,方法escaped将只返回父类的一个对象。</target>
        </trans-unit>
        <trans-unit id="de0a5f6db4da9e37735ab3e4188716aa13cde57d" translate="yes" xml:space="preserve">
          <source>However, the method fold of a given object can only be applied to functions that all have the same type:</source>
          <target state="translated">但是,给定对象的方法折叠只能应用于所有类型相同的函数。</target>
        </trans-unit>
        <trans-unit id="a60f20a882847a637b446acbd0fe979a6ba07d99" translate="yes" xml:space="preserve">
          <source>However, the most common instance of this problem, coercing self to its current class, is detected as a special case by the type checker, and properly typed.</source>
          <target state="translated">然而,这个问题最常见的实例,将self胁迫到它的当前类,被类型检查器检测为特殊情况,并正确地进行了类型检查。</target>
        </trans-unit>
        <trans-unit id="64a966fbd7bd3413811c97fa093d7055e1ad7af5" translate="yes" xml:space="preserve">
          <source>However, the two classes of window_subject and window_observer are not mutually recursive.</source>
          <target state="translated">但是,window_subject和window_observer这两个类并不是相互递归的。</target>
        </trans-unit>
        <trans-unit id="e88098ed1eace82320b4d12264fb903f3a2eedeb" translate="yes" xml:space="preserve">
          <source>However, the type can be completely omitted in the class definition if it is already known, through inheritance or type constraints on self. Here is an example of method overriding.</source>
          <target state="translated">但是,如果已经知道了类型,在类定义中可以完全省略,通过继承或对self的类型约束。下面是一个方法覆盖的例子。</target>
        </trans-unit>
        <trans-unit id="03d00554dc54be9a5828e5bbe84dea5a6534accc" translate="yes" xml:space="preserve">
          <source>However, the type of average len is less generic than the type of average_len, since it requires the type of the first and second argument to be the same:</source>
          <target state="translated">然而,average len的类型不如average_len的类型通用,因为它要求第一个和第二个参数的类型相同。</target>
        </trans-unit>
        <trans-unit id="7404314c946d8e6c9565bd2a5ce313929c2a9744" translate="yes" xml:space="preserve">
          <source>However, when there is only one argument, it is often left unlabeled.</source>
          <target state="translated">但是,当只有一个论点时,往往不加标注。</target>
        </trans-unit>
        <trans-unit id="2c2bbe2630aa2be12c44f2d61e0d58373ebbab9e" translate="yes" xml:space="preserve">
          <source>However, writing a method for iterating over a stack is more problematic. A method fold would have type ('b -&amp;gt; 'a -&amp;gt; 'b) -&amp;gt; 'b -&amp;gt; 'b. Here 'a is the parameter of the stack. The parameter 'b is not related to the class 'a stack but to the argument that will be passed to the method fold. A naive approach is to make 'b an extra parameter of class stack:</source>
          <target state="translated">但是，编写用于遍历堆栈的方法更成问题。方法折叠的类型为（'b-&amp;gt;'a-&amp;gt;'b）-&amp;gt;'b-&amp;gt;'b。这里'a是堆栈的参数。参数'b与类'a不相关，而是与将传递给方法fold的参数有关。天真的方法是使'b成为类堆栈的额外参数：</target>
        </trans-unit>
        <trans-unit id="c05320fb14f6e5d064c5c867a6851bf5b8c0cc4a" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine.</source>
          <target state="translated">双曲余弦。</target>
        </trans-unit>
        <trans-unit id="4416a526cde7aaa7102f8da4d2d9fa9ab04023c8" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine. Argument is in radians.</source>
          <target state="translated">双曲余弦。参数以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="50ede5ec0ac7aaa68576130553561ac3c86fd2ea" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine.</source>
          <target state="translated">双曲正弦。</target>
        </trans-unit>
        <trans-unit id="1d254284446de08654124bede74d08ac424f8d08" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine. Argument is in radians.</source>
          <target state="translated">双曲正弦。论证的单位是弧度。</target>
        </trans-unit>
        <trans-unit id="b717ac903ad6476810dfdda159430e764de6cda7" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent.</source>
          <target state="translated">双曲切线。</target>
        </trans-unit>
        <trans-unit id="9f8a0e2dc65ee66bc03be8ca221132887633049c" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent. Argument is in radians.</source>
          <target state="translated">双曲切线。论证的单位是弧度。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="e121a2cf51a1e00de2e2696e63934fe06010dee8" translate="yes" xml:space="preserve">
          <source>IEEE double precision (2 * 64 bits) floating-point complex numbers (&lt;a href=&quot;bigarray#TYPEcomplex64_elt&quot;&gt;&lt;code&gt;Bigarray.complex64_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IEEE双精度（2 * 64位）浮点复数（&lt;a href=&quot;bigarray#TYPEcomplex64_elt&quot;&gt; &lt;code&gt;Bigarray.complex64_elt&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="11bfef51ab97ad183ddf039572bf34ff80a7c9de" translate="yes" xml:space="preserve">
          <source>IEEE double precision (64 bits) floating-point numbers (&lt;a href=&quot;bigarray#TYPEfloat64_elt&quot;&gt;&lt;code&gt;Bigarray.float64_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IEEE双精度（64位）浮点数（&lt;a href=&quot;bigarray#TYPEfloat64_elt&quot;&gt; &lt;code&gt;Bigarray.float64_elt&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="54ee940288ca134cc7cc56200b21d07e91766c05" translate="yes" xml:space="preserve">
          <source>IEEE single precision (2 * 32 bits) floating-point complex numbers (&lt;a href=&quot;bigarray#TYPEcomplex32_elt&quot;&gt;&lt;code&gt;Bigarray.complex32_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IEEE单精度（2 * 32位）浮点复数（&lt;a href=&quot;bigarray#TYPEcomplex32_elt&quot;&gt; &lt;code&gt;Bigarray.complex32_elt&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="e57793d87153a9ff4dbb8b05395ad2a5ce3baeca" translate="yes" xml:space="preserve">
          <source>IEEE single precision (32 bits) floating-point numbers (&lt;a href=&quot;bigarray#TYPEfloat32_elt&quot;&gt;&lt;code&gt;Bigarray.float32_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IEEE单精度（32位）浮点数（&lt;a href=&quot;bigarray#TYPEfloat32_elt&quot;&gt; &lt;code&gt;Bigarray.float32_elt&lt;/code&gt; &lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="73cbb2fc3a0a2ebb88df2442c2ac6e1ecdf80a05" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;arg#VALread_arg&quot;&gt;&lt;code&gt;Arg.read_arg&lt;/code&gt;&lt;/a&gt; but assumes null character terminated command line arguments.</source>
          <target state="translated">与&lt;a href=&quot;arg#VALread_arg&quot;&gt; &lt;code&gt;Arg.read_arg&lt;/code&gt; &lt;/a&gt;相同，但假定以空字符终止的命令行参数为空。</target>
        </trans-unit>
        <trans-unit id="379fe7f50ad648171482ca58ad0ca76b53a14cbd" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;arg#VALwrite_arg&quot;&gt;&lt;code&gt;Arg.write_arg&lt;/code&gt;&lt;/a&gt; but uses the null character for terminator instead of newline.</source>
          <target state="translated">与&lt;a href=&quot;arg#VALwrite_arg&quot;&gt; &lt;code&gt;Arg.write_arg&lt;/code&gt; &lt;/a&gt;相同，但是使用空字符作为终止符而不是换行符。</target>
        </trans-unit>
        <trans-unit id="19fbdf2c6cc1f0d599912101bcc2320f7df6346b" translate="yes" xml:space="preserve">
          <source>Identifiers are sequences of letters, digits, _ (the underscore character), and ' (the single quote), starting with a letter or an underscore. Letters contain at least the 52 lowercase and uppercase letters from the ASCII set. The current implementation also recognizes as letters some characters from the ISO 8859-1 set (characters 192&amp;ndash;214 and 216&amp;ndash;222 as uppercase letters; characters 223&amp;ndash;246 and 248&amp;ndash;255 as lowercase letters). This feature is deprecated and should be avoided for future compatibility.</source>
          <target state="translated">标识符是字母，数字，_（下划线字符）和'（单引号）的序列，以字母或下划线开头。字母至少包含ASCII集合中的52个小写和大写字母。当前的实现还将ISO 8859-1集中的某些字符识别为字母（字符192-214和216-222为大写字母；字符223-246和248-255为小写字母）。不推荐使用此功能，为将来的兼容性应避免使用此功能。</target>
        </trans-unit>
        <trans-unit id="bf2182b3c192855891eae1040965f486e80e675f" translate="yes" xml:space="preserve">
          <source>Identifiers are used to give names to several classes of language objects and refer to these objects by name later:</source>
          <target state="translated">标识符用来给几类语言对象命名,并在以后用名称来引用这些对象。</target>
        </trans-unit>
        <trans-unit id="252dcf0638748c4bce9e1885e5ea0b583d3a4258" translate="yes" xml:space="preserve">
          <source>Identifiers in struct custom_operations must be chosen carefully, since they must identify uniquely the data structure for serialization and deserialization operations. In particular, consider including a version number in the identifier; this way, the format of the data can be changed later, yet backward-compatible deserialisation functions can be provided.</source>
          <target state="translated">必须谨慎选择custom_operations结构中的标识符,因为它们必须唯一地标识序列化和反序列化操作的数据结构。特别是要考虑在标识符中包含一个版本号;这样一来,数据的格式可以在以后改变,但又可以提供向后兼容的反序列化功能。</target>
        </trans-unit>
        <trans-unit id="a9eef2b3f53493dc9c8afc794fc2b6d8165407f3" translate="yes" xml:space="preserve">
          <source>Identifiers starting with _ (an underscore character) are reserved for the OCaml runtime system; do not use them for your custom data. We recommend to use a URL (http://mymachine.mydomain.com/mylibrary/version-number) or a Java-style package name (com.mydomain.mymachine.mylibrary.version-number) as identifiers, to minimize the risk of identifier collision.</source>
          <target state="translated">以 _(下划线字符)开头的标识符是为 OCaml 运行时系统保留的,请不要将其用于您的自定义数据。我们建议使用URL(http://mymachine.mydomain.com/mylibrary/version-number)或Java风格的包名(com.mydomain.mymachine.mylibrary.version-number)作为标识符,以减少标识符碰撞的风险。</target>
        </trans-unit>
        <trans-unit id="1e9520ba53b50a96883830ad8837005fe5c1553f" translate="yes" xml:space="preserve">
          <source>Identify the types string and bytes, thereby making strings writable. This is intended for compatibility with old source code and should not be used with new software.</source>
          <target state="translated">识别字符串和字节的类型,从而使字符串可以写入。这是为了与旧的源代码兼容,不应该用于新软件。</target>
        </trans-unit>
        <trans-unit id="d30bcc4516a3f540514e40999e656b1a8b2df5e6" translate="yes" xml:space="preserve">
          <source>Identifying the exact context in which polymorphic types should be replaced by weak types in a modular way is a difficult question. Indeed the type system must handle the possibility that functions may hide persistent mutable states. For instance, the following function uses an internal reference to implement a delayed identity function</source>
          <target state="translated">确定在什么情况下多态类型应该以模块化的方式被弱类型取代是一个困难的问题。事实上,类型系统必须处理函数可能隐藏持久的可变状态的可能性。例如,下面的函数使用一个内部引用来实现一个延迟标识函数</target>
        </trans-unit>
        <trans-unit id="29f7c4df05ef0f7f20a0f4baf77fac76b9a430dd" translate="yes" xml:space="preserve">
          <source>If '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; denotes an explicit polymorphic variable, and &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; denotes either an object or polymorphic variant type, the row variable of &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; is captured by '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, and quantified upon.</source>
          <target state="translated">如果' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;表示显式多态变量，并且&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;表示对象或多态变体类型，则&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;的行变量由' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;捕获，并对其进行量化。</target>
        </trans-unit>
        <trans-unit id="1af83e49192d3b9055cda1d966bf6a005de3d634" translate="yes" xml:space="preserve">
          <source>If -cclib or -ccopt options are passed on the command line, these options are stored in the resulting .cmxalibrary. Then, linking with this library automatically adds back the -cclib and -ccopt options as if they had been provided on the command line, unless the -noautolink option is given.</source>
          <target state="translated">如果在命令行中传递了 -cclib 或 -ccopt 选项,这些选项会存储在生成的 .cmxalibrary 中。然后,除非给出 -noautolink 选项,否则与这个库的链接会自动添加回 -cclib 和 -ccopt 选项,就像它们是在命令行中提供的一样。</target>
        </trans-unit>
        <trans-unit id="e7bf1c478aa7887dedd7adc474f78a180f3a1e68" translate="yes" xml:space="preserve">
          <source>If -custom, -cclib or -ccopt options are passed on the command line, these options are stored in the resulting .cmalibrary. Then, linking with this library automatically adds back the -custom, -cclib and -ccopt options as if they had been provided on the command line, unless the -noautolink option is given.</source>
          <target state="translated">如果在命令行中传递了 -custom,-cclib 或 -ccopt 选项,这些选项会存储在生成的 .cmalibrary 中。然后,除非给出-noautolink选项,否则与这个库的链接会自动将-custom、-cclib和-ccopt选项添加回来,就像它们是在命令行中提供的一样。</target>
        </trans-unit>
        <trans-unit id="dfecdd4c68900c96970ac5e52ae011bd5e9a0e2a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is a polymorphic method, its type should be known at the invocation site. This is true for instance if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is the name of a fresh object (let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; &amp;hellip; ) or if there is a type constraint. Principality of the derivation can be checked in the -principal mode.</source>
          <target state="translated">如果&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;是多态方法，则应在调用站点上知道其类型。例如，如果&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;是新对象的名称（let &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = new &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; &amp;hellip;）或存在类型约束，则为true 。可以在-principal模式下检查派生的公有性。</target>
        </trans-unit>
        <trans-unit id="bc3a54443b9c753a78e2f01944d38b93f7a5164e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt;, alternate syntax is provided: you can write &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; instead of &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt;. (The syntax &lt;code&gt;a.{...}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; with one, two or three coordinates is reserved for updating one-, two- and three-dimensional arrays as described below.)</source>
          <target state="translated">如果 &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt; ，则提供备用语法：您可以编写 &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; 代替 &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt; 。（具有一，二或三个坐标的语法 &lt;code&gt;a.{...}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; 保留用于更新一维，二维和三维数组，如下所述。）</target>
        </trans-unit>
        <trans-unit id="4203c94450a640c56f05a68d1e3adc5328030de4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt;, alternate syntax is provided: you can write &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&lt;/code&gt; instead of &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt;. (The syntax &lt;code&gt;a.{...}&lt;/code&gt; with one, two or three coordinates is reserved for accessing one-, two- and three-dimensional arrays as described below.)</source>
          <target state="translated">如果 &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt; ，则提供备用语法：您可以写 &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&lt;/code&gt; 代替 &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; 。（具有一，二或三个坐标的语法 &lt;code&gt;a.{...}&lt;/code&gt; 保留用于访问一维，二维和三维数组，如下所述。）</target>
        </trans-unit>
        <trans-unit id="809bd12920c48726136236802722ab0be08e88f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has C layout, the coordinates must be greater or equal than 0 and strictly less than the corresponding dimensions of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has Fortran layout, the coordinates must be greater or equal than 1 and less or equal than the corresponding dimensions of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 具有C布局，则坐标必须大于或等于0且严格小于 &lt;code&gt;a&lt;/code&gt; 的相应尺寸。如果 &lt;code&gt;a&lt;/code&gt; 具有Fortran布局，则坐标必须大于或等于1且小于或等于 &lt;code&gt;a&lt;/code&gt; 的相应尺寸。</target>
        </trans-unit>
        <trans-unit id="0d4132333c30642f60620cc9c7ac94c15c80f1f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d&lt;/code&gt; is greater or equal than the current margin, it is ignored, and the current maximum indentation limit is kept.</source>
          <target state="translated">如果 &lt;code&gt;d&lt;/code&gt; 大于或等于当前边距，则将其忽略，并保留当前的最大压痕极限。</target>
        </trans-unit>
        <trans-unit id="e9c0840202ac828ab864cc2fb33a9e5dc2f4e78e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d&lt;/code&gt; is too large, the limit is set to the maximum admissible value (which is greater than &lt;code&gt;10&amp;nbsp;^&amp;nbsp;9&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;d&lt;/code&gt; 太大，则将限制设置为最大允许值（大于 &lt;code&gt;10&amp;nbsp;^&amp;nbsp;9&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ead1963ff555b5cb572c908c83e685f09cbbeebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.Compat_32&lt;/code&gt;, marshaling fails when it encounters an integer value outside the range &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; of integers that are representable on a 32-bit platform. This ensures that marshaled data generated on a 64-bit platform can be safely read back on a 32-bit platform. If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.Compat_32&lt;/code&gt;, integer values outside the range &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; are marshaled, and can be read back on a 64-bit platform, but will cause an error at un-marshaling time when read back on a 32-bit platform. The &lt;code&gt;Mashal.Compat_32&lt;/code&gt; flag only matters when marshaling is performed on a 64-bit platform; it has no effect if marshaling is performed on a 32-bit platform.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 包含 &lt;code&gt;Marshal.Compat_32&lt;/code&gt; ，则封送处理遇到的整数值超出32位平台上可表示的整数范围 &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; 时，编组将失败。这样可确保可以在32位平台上安全地读回在64位平台上生成的封送数据。如果 &lt;code&gt;flags&lt;/code&gt; 不包含 &lt;code&gt;Marshal.Compat_32&lt;/code&gt; ，则将封送 &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; 范围以外的整数值，并且可以在64位平台上读取该整数值，但会导致错误在32位平台上读回时，在非编组时。该 &lt;code&gt;Mashal.Compat_32&lt;/code&gt; 仅当在64位平台上执行封送处理时，标记才有意义；如果在32位平台上执行封送处理，则无效。</target>
        </trans-unit>
        <trans-unit id="5f3049c4d97c242e2115fb288272135a4ad280a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.Closures&lt;/code&gt;, marshaling fails when it encounters a functional value inside &lt;code&gt;v&lt;/code&gt;: only 'pure' data structures, containing neither functions nor objects, can safely be transmitted between different programs. If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.Closures&lt;/code&gt;, functional values will be marshaled as a the position in the code of the program together with the values corresponding to the free variables captured in the closure. In this case, the output of marshaling can only be read back in processes that run exactly the same program, with exactly the same compiled code. (This is checked at un-marshaling time, using an MD5 digest of the code transmitted along with the code position.)</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 不包含 &lt;code&gt;Marshal.Closures&lt;/code&gt; ，则封送处理在 &lt;code&gt;v&lt;/code&gt; 内遇到函数值时将失败：只有不包含函数和对象的&amp;ldquo;纯&amp;rdquo;数据结构可以在不同程序之间安全地传输。如果 &lt;code&gt;flags&lt;/code&gt; 包含 &lt;code&gt;Marshal.Closures&lt;/code&gt; ，则将把函数值与对应于闭包中捕获的自由变量的值一起编组为程序代码中的位置。在这种情况下，封送处理的输出只能在运行完全相同的程序且具有完全相同的编译代码的进程中读取。 （这在取消编组时使用与代码位置一起发送的代码的MD5摘要进行检查。）</target>
        </trans-unit>
        <trans-unit id="1603f8892a112133f08e3aa42f06e2938ef7d3e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.No_sharing&lt;/code&gt;, circularities and sharing inside the value &lt;code&gt;v&lt;/code&gt; are detected and preserved in the sequence of bytes produced. In particular, this guarantees that marshaling always terminates. Sharing between values marshaled by successive calls to &lt;code&gt;Marshal.to_channel&lt;/code&gt; is neither detected nor preserved, though. If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.No_sharing&lt;/code&gt;, sharing is ignored. This results in faster marshaling if &lt;code&gt;v&lt;/code&gt; contains no shared substructures, but may cause slower marshaling and larger byte representations if &lt;code&gt;v&lt;/code&gt; actually contains sharing, or even non-termination if &lt;code&gt;v&lt;/code&gt; contains cycles.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 不包含 &lt;code&gt;Marshal.No_sharing&lt;/code&gt; ，则在值 &lt;code&gt;v&lt;/code&gt; 内检测到圆度和共享并按生成的字节顺序保留。特别是，这保证了封送始终终止。但是，既不会检测到也不会保留因连续调用 &lt;code&gt;Marshal.to_channel&lt;/code&gt; 而编组的值之间的共享。如果 &lt;code&gt;flags&lt;/code&gt; 包含 &lt;code&gt;Marshal.No_sharing&lt;/code&gt; ，则共享将被忽略。如果 &lt;code&gt;v&lt;/code&gt; 不包含共享子结构，这将导致更快的封送处理，但是如果 &lt;code&gt;v&lt;/code&gt; 实际上包含共享，则可能导致较慢的封送处理和较大的字节表示，如果 &lt;code&gt;v&lt;/code&gt; 包含循环，则可能导致不终止。</target>
        </trans-unit>
        <trans-unit id="c639bd784b8f54da115e8e01089e6eaa4c4437c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; raises an exception, both the exceptions passed to &lt;code&gt;fn&lt;/code&gt; and raised by &lt;code&gt;fn&lt;/code&gt; will be printed with their respective backtrace.</source>
          <target state="translated">如果 &lt;code&gt;fn&lt;/code&gt; 引发了异常，都传递到异常 &lt;code&gt;fn&lt;/code&gt; 并提出 &lt;code&gt;fn&lt;/code&gt; 将印有各自的回溯。</target>
        </trans-unit>
        <trans-unit id="16c27e9ffbfb7a1b0d49335a6eaeccc52715afa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is nonnegative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; characters from channel &lt;code&gt;ic&lt;/code&gt; and returns their digest, or raises &lt;code&gt;End_of_file&lt;/code&gt; if end-of-file is reached before &lt;code&gt;len&lt;/code&gt; characters are read.</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 为非负数，则 &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; 从通道 &lt;code&gt;ic&lt;/code&gt; 读取 &lt;code&gt;len&lt;/code&gt; 个字符并返回其摘要，如果在读取 &lt;code&gt;len&lt;/code&gt; 个字符之前已到达文件结尾，则引发 &lt;code&gt;End_of_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63c13d957f65e898b543bbbae2d79a73a515bf1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is nonnegative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; characters from channel &lt;code&gt;ic&lt;/code&gt; and returns their digest, or raises &lt;code&gt;End_of_file&lt;/code&gt; if end-of-file is reached before &lt;code&gt;len&lt;/code&gt; characters are read. If &lt;code&gt;len&lt;/code&gt; is negative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads all characters from &lt;code&gt;ic&lt;/code&gt; until end-of-file is reached and return their digest.</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 为非负数，则 &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; 从通道 &lt;code&gt;ic&lt;/code&gt; 读取 &lt;code&gt;len&lt;/code&gt; 个字符并返回其摘要，如果在读取 &lt;code&gt;len&lt;/code&gt; 个字符之前已到达文件结尾，则引发 &lt;code&gt;End_of_file&lt;/code&gt; 。如果 &lt;code&gt;len&lt;/code&gt; 为负，则 &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; 会从 &lt;code&gt;ic&lt;/code&gt; 中读取所有字符，直到到达文件末尾并返回其摘要。</target>
        </trans-unit>
        <trans-unit id="5c5226280b1d5d0eb026f180e4fc7ada42aef4f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seq&amp;nbsp;=&amp;nbsp;[1;2;3]&lt;/code&gt;, then &lt;code&gt;map&amp;nbsp;f&amp;nbsp;seq&amp;nbsp;=&amp;nbsp;[f&amp;nbsp;1;&amp;nbsp;f&amp;nbsp;2;&amp;nbsp;f&amp;nbsp;3]&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;seq&amp;nbsp;=&amp;nbsp;[1;2;3]&lt;/code&gt; ，则 &lt;code&gt;map&amp;nbsp;f&amp;nbsp;seq&amp;nbsp;=&amp;nbsp;[f&amp;nbsp;1;&amp;nbsp;f&amp;nbsp;2;&amp;nbsp;f&amp;nbsp;3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1398dea40559c8782ca5a31856feff2954ca0102" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shared&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, all modifications performed on the array are reflected in the file. This requires that &lt;code&gt;fd&lt;/code&gt; be opened with write permissions. If &lt;code&gt;shared&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, modifications performed on the array are done in memory only, using copy-on-write of the modified pages; the underlying file is not affected.</source>
          <target state="translated">如果 &lt;code&gt;shared&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则对阵列执行的所有修改都将反映在文件中。这要求使用写入权限打开 &lt;code&gt;fd&lt;/code&gt; 。如果 &lt;code&gt;shared&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则对阵列执行的修改仅在内存中使用修改后的页面的写时复制进行；否则，将仅在内存中进行修改。基础文件不受影响。</target>
        </trans-unit>
        <trans-unit id="8e714373b0cf3d52636fccd7cd853dd106784943" translate="yes" xml:space="preserve">
          <source>If OCAMLRUNPARAM is not found in the environment, then CAMLRUNPARAM will be used instead. If CAMLRUNPARAM is also not found, then the default values will be used.</source>
          <target state="translated">如果在环境中没有找到OCAMLRUNPARAM,那么将使用CAMLRUNPARAM。如果也找不到CAMLRUNPARAM,那么将使用默认值。</target>
        </trans-unit>
        <trans-unit id="1e527c776a333861fa6472e7246947c15efddcc3" translate="yes" xml:space="preserve">
          <source>If OCAMLRUNPARAM is not found in the environment, then CAMLRUNPARAM will be used instead. If CAMLRUNPARAM is not found, then the default values will be used.</source>
          <target state="translated">如果在环境中没有找到OCAMLRUNPARAM,那么将使用CAMLRUNPARAM。如果没有找到CAMLRUNPARAM,那么将使用默认值。</target>
        </trans-unit>
        <trans-unit id="52f378a118e070cfc5dc38fe1dedd97d46322a83" translate="yes" xml:space="preserve">
          <source>If a C primitive runs for a long time or performs potentially blocking input-output operations, it can explicitly release the master lock, enabling other OCaml threads to run concurrently with its operations. The C code must re-acquire the master lock before returning to OCaml. This is achieved with the following functions, declared in the include file &amp;lt;caml/threads.h&amp;gt;.</source>
          <target state="translated">如果C原语长时间运行或执行潜在的阻塞输入输出操作，则它可以显式释放主锁，从而使其他OCaml线程可以与其操作同时运行。在返回OCaml之前，C代码必须重新获取主锁。这是通过以下功能实现的，这些功能在包含文件&amp;lt;caml / threads.h&amp;gt;中声明。</target>
        </trans-unit>
        <trans-unit id="144bd9ae4b17d62ca7c4dd2000f8e45755b76c41" translate="yes" xml:space="preserve">
          <source>If a compatible dump file already exists in the current directory, then the profiling information is accumulated in this dump file. This allows, for instance, the profiling of several executions of a program on different inputs. Note that dump files produced by byte-code executables (compiled with ocamlcp) are compatible with the dump files produced by native executables (compiled with ocamloptp).</source>
          <target state="translated">如果当前目录下已经存在一个兼容的转储文件,那么剖析信息就会积累在这个转储文件中。例如,这允许在不同的输入上对一个程序的多次执行进行剖析。请注意,由字节码可执行文件(用ocamlcp编译)产生的转储文件与本地可执行文件(用ocamloptp编译)产生的转储文件是兼容的。</target>
        </trans-unit>
        <trans-unit id="a268efd3934421fc54ada79e5bb503d1d9c1baf3" translate="yes" xml:space="preserve">
          <source>If a local definition occurs at the very beginning of a class definition, it will be evaluated when the class is created (just as if the definition was outside of the class). Otherwise, it will be evaluated when the object constructor is called.</source>
          <target state="translated">如果局部定义出现在类定义的最开始,那么当类被创建时,它将被评估(就像定义在类的外部一样)。否则,它将在调用对象构造函数时被评估。</target>
        </trans-unit>
        <trans-unit id="db03536423f4f4f52cd6fcffd6bb81f40d46d972" translate="yes" xml:space="preserve">
          <source>If a module (.ml file) doesn&amp;rsquo;t have a corresponding interface (.mli file), then compiling it with ocamlcp will produce object files (.cmi and .cmo) that are not compatible with the ones produced by ocamlc, which may lead to problems (if the .cmi or .cmo is still around) when switching between profiling and non-profiling compilations. To avoid this problem, you should always have a .mli file for each .ml file. The same problem exists with ocamloptp.</source>
          <target state="translated">如果模块（.ml文件）没有相应的接口（.mli文件），则使用ocamlcp进行编译将生成与ocamlc生成的文件不兼容的目标文件（.cmi和.cmo）。在概要分析和非概要分析编译之间切换时会导致问题（如果.cmi或.cmo仍然存在）。为避免此问题，每个.ml文件都应始终具有.mli文件。ocamloptp存在相同的问题。</target>
        </trans-unit>
        <trans-unit id="361ced0e78aa187459f0f204ee3347fb375be201" translate="yes" xml:space="preserve">
          <source>If a parameter is specified as optional (label prefixed by ?) in the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the corresponding argument will be automatically wrapped with the constructor Some, except if the argument itself is also prefixed by ?, in which case it is passed as is. If a non-labeled argument is passed, and its corresponding parameter is preceded by one or several optional parameters, then these parameters are &lt;em&gt;defaulted&lt;/em&gt;, &lt;em&gt;i.e.&lt;/em&gt; the value None will be passed for them. All other missing parameters (without corresponding argument), both optional and non-optional, will be kept, and the result of the function will still be a function of these missing parameters to the body of f.</source>
          <target state="translated">如果将参数指定为&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;类型的可选参数（带有？前缀的标签），则相应的参数将自动被构造函数Some包裹，除非参数本身也带有？前缀，在这种情况下将按原样传递。如果未标记的参数被传递，并且其对应的参数是由一个或多个可选参数之前，然后这些参数被&lt;em&gt;默认&lt;/em&gt;，&lt;em&gt;即&lt;/em&gt;该值没有将他们被传递。所有其他缺少的参数（没有相应的参数），无论是可选的还是非可选的，都将保留，并且函数的结果仍将是f主体中这些缺少的参数的函数。</target>
        </trans-unit>
        <trans-unit id="037083f7231a68d14836692b419032967beaefec" translate="yes" xml:space="preserve">
          <source>If all dimensions of the Bigarray are given, the file size is matched against the size of the Bigarray. If the file is larger than the Bigarray, only the initial portion of the file is mapped to the Bigarray. If the file is smaller than the big array, the file is automatically grown to the size of the Bigarray. This requires write permissions on &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">如果给出了Bigarray的所有尺寸，则文件大小将与Bigarray的大小匹配。如果文件大于Bigarray，则仅文件的初始部分映射到Bigarray。如果文件小于大数组，则文件会自动增长到Bigarray的大小。这需要对 &lt;code&gt;fd&lt;/code&gt; 具有写权限。</target>
        </trans-unit>
        <trans-unit id="f1ff51fc7a2f5a64a4761a8119a652dcd1f52ad5" translate="yes" xml:space="preserve">
          <source>If an allocation-tracking or promotion-tracking function returns &lt;code&gt;None&lt;/code&gt;, memprof stops tracking the corresponding value.</source>
          <target state="translated">如果分配跟踪或升级跟踪函数返回 &lt;code&gt;None&lt;/code&gt; ，则memprof停止跟踪相应的值。</target>
        </trans-unit>
        <trans-unit id="c69093d47c505a2742c6e9e51b6c1bedfd5d8eaa" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;code&gt;Arg.parse&lt;/code&gt; exits the program, after printing to standard error an error message as follows:</source>
          <target state="translated">如果发生错误，则 &lt;code&gt;Arg.parse&lt;/code&gt; 会在打印为标准错误后显示以下错误消息，并退出程序：</target>
        </trans-unit>
        <trans-unit id="7467ecdd482037d95bee094a12bc474e7d7c71fc" translate="yes" xml:space="preserve">
          <source>If dynamic linking is supported on the target platform, a .so (respectively, .dll) shared library built from the C object files given as arguments, and automatically referencing the support libraries.</source>
          <target state="translated">如果目标平台上支持动态链接,则由作为参数给出的C对象文件构建一个.so(分别是.dll)共享库,并自动引用支持库。</target>
        </trans-unit>
        <trans-unit id="30089f87216cb371be1de9772b23268664fcb2e2" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmi, this means you have referenced the compilation unit mod, but its compiled interface could not be found. Fix: compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.</source>
          <target state="translated">如果文件名的格式为mod.cmi,这意味着你已经引用了编译单元mod,但找不到它的编译接口。修正:先编译mod.mli或mod.ml,以创建编译后的接口mod.cmi。</target>
        </trans-unit>
        <trans-unit id="e9686537313707922f0bda205e9360d942cceb1a" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmo, this means you are trying to link a bytecode object file that does not exist yet. Fix: compile mod.ml first.</source>
          <target state="translated">如果文件名的格式为mod.cmo,这意味着你正在尝试链接一个还不存在的字节码对象文件。修正:先编译mod.ml。</target>
        </trans-unit>
        <trans-unit id="ea2277b8c214def4154d2529e1b31435dc3cac3a" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmo, this means you are trying to load with #load a bytecode object file that does not exist yet. Fix: compile mod.ml first.</source>
          <target state="translated">如果文件名的格式是mod.cmo,这意味着你正试图用#加载一个还不存在的字节码对象文件。修正:先编译mod.ml。</target>
        </trans-unit>
        <trans-unit id="a3b22a28469371f7e82ec0e9c892a2ff1b6f3dae" translate="yes" xml:space="preserve">
          <source>If filename is the name of a self-executable bytecode file, this means that either that file does not exist, or that it failed to run the ocamlrun bytecode interpreter on itself. The second possibility indicates that OCaml has not been properly installed on your system.</source>
          <target state="translated">如果filename是一个可自执行的字节码文件的名称,这意味着要么该文件不存在,要么该文件未能在自身上运行ocamlrun字节码解释器。第二种可能表明OCaml没有正确地安装在你的系统上。</target>
        </trans-unit>
        <trans-unit id="4bcfc607ddea008cb5d00122be6715bc9b44adf1" translate="yes" xml:space="preserve">
          <source>If inlining the function is not clearly beneficial, then inlining will be performed &lt;em&gt;speculatively&lt;/em&gt; inside the function itself. The search for speculative inlining possibilities is controlled by two parameters: the &lt;em&gt;inlining threshold&lt;/em&gt; and the &lt;em&gt;inlining depth&lt;/em&gt;. (These are described in more detail below.)</source>
          <target state="translated">如果内联函数显然没有好处，那么内联将在函数本身内部进行&lt;em&gt;推测性&lt;/em&gt;执行。投机内联可能性的搜索受两个参数控制：&lt;em&gt;内联阈值&lt;/em&gt;和&lt;em&gt;内联深度&lt;/em&gt;。（这些将在下面更详细地描述。）</target>
        </trans-unit>
        <trans-unit id="b44e70f5ebb940c1b0391784dfe69b24f75a37ab" translate="yes" xml:space="preserve">
          <source>If it does not split the line, then the &lt;code&gt;s1&lt;/code&gt; is emitted, then &lt;code&gt;n&lt;/code&gt; spaces, then &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">如果不分割线，则发出 &lt;code&gt;s1&lt;/code&gt; ，然后发出 &lt;code&gt;n&lt;/code&gt; 个空格，然后发出 &lt;code&gt;s2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e489f470887d376d32aea06970fd61f3751f9ee5" translate="yes" xml:space="preserve">
          <source>If it must be the case that code has to be written that triggers warning 59, but the code is known to actually be correct (for some definition of correct), then Sys.opaque_identity may be used to wrap the value before unsafe operations are performed upon it. Great care must be taken when doing this to ensure that the opacity is added at the correct place. It must be emphasised that this use of Sys.opaque_identity is only for exceptional cases. It should not be used in normal code or to try to guide the optimiser.</source>
          <target state="translated">如果一定要写出触发警告59的代码,但已知代码实际上是正确的(对于正确的某些定义),那么可以使用Sys.opaque_identity在对其进行不安全的操作之前对该值进行封装。在这样做的时候,必须非常小心,以确保不透明度被添加在正确的位置。必须强调的是,Sys.opaque_identity的这种用法只适用于特殊情况。它不应该在正常的代码中使用,也不应该试图引导优化器。</target>
        </trans-unit>
        <trans-unit id="686a1fa801a7187be3913a423d2506998f796f50" translate="yes" xml:space="preserve">
          <source>If it splits the line, then it emits the &lt;code&gt;s3&lt;/code&gt; string, then an indent (according to the box rules), then an offset of &lt;code&gt;m&lt;/code&gt; spaces, then the &lt;code&gt;s4&lt;/code&gt; string.</source>
          <target state="translated">如果将行分开，则会发出 &lt;code&gt;s3&lt;/code&gt; 字符串，然后是缩进（根据Box规则），然后是 &lt;code&gt;m&lt;/code&gt; 个空格的偏移量，然后是 &lt;code&gt;s4&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="72c5657376e07c2d9a3e4b1acbffce97186b2022" translate="yes" xml:space="preserve">
          <source>If n is zero or less, nothing happens.</source>
          <target state="translated">如果n为零或更少,则不会发生任何事情。</target>
        </trans-unit>
        <trans-unit id="2336d71434989479cbe58cf7ebe309409422e6bc" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;~&lt;/code&gt;&lt;code&gt;random&lt;/code&gt; parameter is given, hash tables are created in non-random mode by default. This default can be changed either programmatically by calling &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt;&lt;code&gt;Hashtbl.randomize&lt;/code&gt;&lt;/a&gt; or by setting the &lt;code&gt;R&lt;/code&gt; flag in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="translated">如果没有 &lt;code&gt;~&lt;/code&gt; &lt;code&gt;random&lt;/code&gt; 指定参数，在非随机模式下默认创建哈希表。可以通过调用&lt;a href=&quot;hashtbl#VALrandomize&quot;&gt; &lt;code&gt;Hashtbl.randomize&lt;/code&gt; &lt;/a&gt;或通过在 &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 环境变量中设置 &lt;code&gt;R&lt;/code&gt; 标志来以编程方式更改此默认值。</target>
        </trans-unit>
        <trans-unit id="1fe1d3cbd3f88524d2f4458db6e377354e28778c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;~&lt;/code&gt;&lt;code&gt;random&lt;/code&gt; parameter is given, hash tables are created in non-random mode by default. This default can be changed either programmatically by calling &lt;a href=&quot;morelabels.hashtbl#VALrandomize&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.randomize&lt;/code&gt;&lt;/a&gt; or by setting the &lt;code&gt;R&lt;/code&gt; flag in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="translated">如果没有 &lt;code&gt;~&lt;/code&gt; &lt;code&gt;random&lt;/code&gt; 指定参数，在非随机模式下默认创建哈希表。可以通过调用&lt;a href=&quot;morelabels.hashtbl#VALrandomize&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.randomize&lt;/code&gt; &lt;/a&gt;或通过在 &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 环境变量中设置 &lt;code&gt;R&lt;/code&gt; 标志来以编程方式更改此默认值。</target>
        </trans-unit>
        <trans-unit id="8f705b48d406f77c738cb668c2876820fc083247" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;~random&lt;/code&gt; parameter is given, hash tables are created in non-random mode by default. This default can be changed either programmatically by calling &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt;&lt;code&gt;Hashtbl.randomize&lt;/code&gt;&lt;/a&gt; or by setting the &lt;code&gt;R&lt;/code&gt; flag in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="translated">如果未提供 &lt;code&gt;~random&lt;/code&gt; 参数，则默认情况下以非随机模式创建哈希表。可以通过调用&lt;a href=&quot;hashtbl#VALrandomize&quot;&gt; &lt;code&gt;Hashtbl.randomize&lt;/code&gt; &lt;/a&gt;或通过在 &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 环境变量中设置 &lt;code&gt;R&lt;/code&gt; 标志来以编程方式更改此默认值。</target>
        </trans-unit>
        <trans-unit id="6a0c0ccea27bc9150aae629a6c3346f36d1efee2" translate="yes" xml:space="preserve">
          <source>If no element of &lt;code&gt;s&lt;/code&gt; is changed by &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; is returned unchanged. (If each output of &lt;code&gt;f&lt;/code&gt; is physically equal to its input, the returned set is physically equal to &lt;code&gt;s&lt;/code&gt;.)</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 的元素没有被 &lt;code&gt;f&lt;/code&gt; 更改，则 &lt;code&gt;s&lt;/code&gt; 不变地返回。（如果 &lt;code&gt;f&lt;/code&gt; 的每个输出在物理上等于其输入，则返回的集合在物理上等于 &lt;code&gt;s&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="6eb7e9f1e3b33fc029b525d2db6314c65ae09453" translate="yes" xml:space="preserve">
          <source>If no element of &lt;code&gt;s&lt;/code&gt; is changed or dropped by &lt;code&gt;f&lt;/code&gt; (if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;x&lt;/code&gt; for each element &lt;code&gt;x&lt;/code&gt;), then &lt;code&gt;s&lt;/code&gt; is returned unchanged: the result of the function is then physically equal to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">如果没有 &lt;code&gt;s&lt;/code&gt; 的元素被 &lt;code&gt;f&lt;/code&gt; 更改或删除（如果 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;x&lt;/code&gt; 每个元素 &lt;code&gt;x&lt;/code&gt; 的某些x），则 &lt;code&gt;s&lt;/code&gt; 不变地返回：函数的结果在物理上等于 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b5ce85d95eb4fbe13f80a3c8ec12e54d03b7200" translate="yes" xml:space="preserve">
          <source>If no scriptfile is given on the command line, the toplevel system enters interactive mode: phrases are read on standard input, results are printed on standard output, errors on standard error. End-of-file on standard input terminates ocaml (see also the #quit directive in section &amp;zwj;&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;).</source>
          <target state="translated">如果在命令行上未提供脚本文件，那么顶级系统将进入交互模式：在标准输入上读取短语，在标准输出上打印结果，在标准错误上显示错误。档案结尾在标准输入终止ocaml的（另见节#quit指令&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="daf74767dc0fd113b13b0f693b209b1bddcc18bd" translate="yes" xml:space="preserve">
          <source>If no scriptfile is given on the command line, the toplevel system enters interactive mode: phrases are read on standard input, results are printed on standard output, errors on standard error. End-of-file on standard input terminates ocaml (see also the #quit directive in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;).</source>
          <target state="translated">如果在命令行上未提供脚本文件，那么顶级系统将进入交互模式：在标准输入上读取短语，在标准输出上打印结果，在标准错误上显示错误。标准输入上的文件结束会终止ocaml（另请参见第&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;节中的#quit指令）。</target>
        </trans-unit>
        <trans-unit id="00843a889b066ce4bbfdb0caf01e681f6e157c16" translate="yes" xml:space="preserve">
          <source>If not already set on a tabulation marker, the insertion point moves to the first tabulation marker on the right and the pretty-printer prints &lt;code&gt;nspaces&lt;/code&gt; spaces.</source>
          <target state="translated">如果尚未在制表标记上设置，插入点将移至右侧的第一个制表标记，漂亮打印机将打印 &lt;code&gt;nspaces&lt;/code&gt; 个空格。</target>
        </trans-unit>
        <trans-unit id="3d68028592d04a4d3224c7790eb73143280d4b3b" translate="yes" xml:space="preserve">
          <source>If scriptfile is given on the command-line to ocaml, the toplevel system enters script mode: the contents of the file are read as a sequence of OCaml phrases and executed, as per the #use directive (section &amp;zwj;&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;). The outcome of the evaluation is not printed. On reaching the end of file, the ocaml command exits immediately. No commands are read from standard input. Sys.argv is transformed, ignoring all OCaml parameters, and starting with the script file name in Sys.argv.(0).</source>
          <target state="translated">如果脚本文件是在命令行到ocaml的给定的，顶层系统进入脚本模式：该文件的内容被读为OCaml的短语的序列，并且执行，如每＃使用指令（部分&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;）。不打印评估结果。到达文件末尾时，ocaml命令立即退出。没有从标准输入中读取命令。 Sys.argv将被转换，忽略所有OCaml参数，并以Sys.argv。（0）中的脚本文件名开头。</target>
        </trans-unit>
        <trans-unit id="94467592d909a5e6ff672d3db0301b49ec0281fc" translate="yes" xml:space="preserve">
          <source>If scriptfile is given on the command-line to ocaml, the toplevel system enters script mode: the contents of the file are read as a sequence of OCaml phrases and executed, as per the #use directive (section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;). The outcome of the evaluation is not printed. On reaching the end of file, the ocaml command exits immediately. No commands are read from standard input. Sys.argv is transformed, ignoring all OCaml parameters, and starting with the script file name in Sys.argv.(0).</source>
          <target state="translated">如果在命令行上将脚本文件指定给ocaml，则顶级系统进入脚本模式：根据#use指令（第&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;节），将文件内容作为OCaml短语序列读取并执行。不打印评估结果。到达文件末尾时，ocaml命令立即退出。没有从标准输入中读取命令。 Sys.argv将被转换，忽略所有OCaml参数，并以Sys.argv。（0）中的脚本文件名开头。</target>
        </trans-unit>
        <trans-unit id="2363061063be15ef51f3f1a53b8b361078b64015" translate="yes" xml:space="preserve">
          <source>If several arguments of a function bear the same label (or no label), they will not commute among themselves, and order matters. But they can still commute with other arguments.</source>
          <target state="translated">如果一个函数的几个参数带有相同的标签(或者没有标签),它们之间不会互换,顺序很重要。但它们仍然可以与其他参数换算。</target>
        </trans-unit>
        <trans-unit id="96cd48975e8c5184733565898c33a2f04befd578" translate="yes" xml:space="preserve">
          <source>If several locally abstract types need to be introduced, it is possible to use the syntax fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; as syntactic sugar for fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt; &amp;hellip; -&amp;gt;fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. For instance,</source>
          <target state="translated">如果需要引入几种本地抽象类型，则可以使用语法fun（type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;作为fun（type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;）-&amp;gt;&amp;hellip;-&amp;gt;的语法糖fun（type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;。例如，</target>
        </trans-unit>
        <trans-unit id="c10affbc46bccdf7827eee5ed3b04a7a8c3bd654" translate="yes" xml:space="preserve">
          <source>If several patterns match the argument v, the one that occurs first in the function definition is selected. If none of the patterns matches the argument, the exception Match_failure is raised.</source>
          <target state="translated">如果有几个模式与参数v相匹配,则选择在函数定义中最先出现的那个模式。如果没有一个模式与参数匹配,则会引发异常Match_failure。</target>
        </trans-unit>
        <trans-unit id="ebba3b8dc9a7c52a91ba9cffdda6fc1e415cedf9" translate="yes" xml:space="preserve">
          <source>If several regular expressions match a prefix of the input, the &amp;ldquo;longest match&amp;rdquo; rule applies: the regular expression that matches the longest prefix of the input is selected. In case of tie, the regular expression that occurs earlier in the rule is selected.</source>
          <target state="translated">如果多个正则表达式与输入的前缀匹配，则适用&amp;ldquo;最长匹配&amp;rdquo;规则：选择与输入的最长前缀匹配的正则表达式。如果出现平局，则选择规则中较早出现的正则表达式。</target>
        </trans-unit>
        <trans-unit id="33304e670e9c468dea25676c51b9d5272c2372ac" translate="yes" xml:space="preserve">
          <source>If several specifications are present for the same method, they must have compatible types. Any non-private specification of a method forces it to be public.</source>
          <target state="translated">如果同一方法有多个规范,它们必须有兼容的类型。一个方法的任何非私有规格都会迫使它成为公共的。</target>
        </trans-unit>
        <trans-unit id="c4e1e876c6319fc9f155e179bfdf47b95b75ca18" translate="yes" xml:space="preserve">
          <source>If shared libraries are not supported, the following commands are performed instead:</source>
          <target state="translated">如果不支持共享库,则执行以下命令。</target>
        </trans-unit>
        <trans-unit id="ba2e2086c5f2a5e933519c52e53ae93fb624fa5d" translate="yes" xml:space="preserve">
          <source>If shared libraries are supported, this performs the following commands:</source>
          <target state="translated">如果支持共享库,则会执行以下命令。</target>
        </trans-unit>
        <trans-unit id="13e2923fd0864337da7b7bba91620b61b5fbb40a" translate="yes" xml:space="preserve">
          <source>If such a suffix does not exist, &lt;code&gt;extension&amp;nbsp;name&lt;/code&gt; is the empty string.</source>
          <target state="translated">如果不存在这样的后缀，则 &lt;code&gt;extension&amp;nbsp;name&lt;/code&gt; 空字符串。</target>
        </trans-unit>
        <trans-unit id="8535daa443a5878fa88dbc8284c870ced5360d87" translate="yes" xml:space="preserve">
          <source>If such speculation shows that performing some inlining inside the function would be beneficial, then such inlining is performed and the resulting function inlined at the original call site.</source>
          <target state="translated">如果这样的推测表明在函数内部执行一些内联是有益的,那么就会执行这样的内联,并在原来的调用站点对产生的函数进行内联。</target>
        </trans-unit>
        <trans-unit id="35d741725edfca4bf5d082c545ffd10d25a7dc01" translate="yes" xml:space="preserve">
          <source>If the -inlining-report option is provided to the compiler then a file will be emitted corresponding to each round of optimisation. For the OCaml source file &lt;em&gt;basename&lt;/em&gt;.ml the files are named &lt;em&gt;basename&lt;/em&gt;.&lt;em&gt;round&lt;/em&gt;.inlining.org, with &lt;em&gt;round&lt;/em&gt; a zero-based integer. Inside the files, which are formatted as &amp;ldquo;org mode&amp;rdquo;, will be found English prose describing the decisions that the inliner took.</source>
          <target state="translated">如果将-inlining-report选项提供给编译器，则将发出与每个优化回合相对应的文件。对于OCaml源文件&lt;em&gt;basename&lt;/em&gt; .ml，文件名为&lt;em&gt;basename&lt;/em&gt;。&lt;em&gt;舍&lt;/em&gt;入.inlining.org，并&lt;em&gt;舍入&lt;/em&gt;从零开始的整数。在格式为&amp;ldquo;组织模式&amp;rdquo;的文件中，将找到英文散文，描述了内线人做出的决定。</target>
        </trans-unit>
        <trans-unit id="02572179ec480974381c99532d430d9fdd5784e0" translate="yes" xml:space="preserve">
          <source>If the C code wishes to catch exceptions escaping the OCaml function, it can use the functions caml_callback_exn, caml_callback2_exn, caml_callback3_exn, caml_callbackN_exn. These functions take the same arguments as their non-_exn counterparts, but catch escaping exceptions and return them to the C code. The return value v of the caml_callback*_exn functions must be tested with the macro Is_exception_result(v). If the macro returns &amp;ldquo;false&amp;rdquo;, no exception occurred, and v is the value returned by the OCaml function. If Is_exception_result(v) returns &amp;ldquo;true&amp;rdquo;, an exception escaped, and its value (the exception descriptor) can be recovered using Extract_exception(v).</source>
          <target state="translated">如果C代码希望捕获转义为OCaml函数的异常，则可以使用函数caml_callback_exn，caml_callback2_exn，caml_callback3_exn，caml_callbackN_exn。这些函数与非_exn对应函数采用相同的参数，但是捕获转义的异常并将其返回给C代码。 caml_callback * _exn函数的返回值v必须使用宏Is_exception_result（v）进行测试。如果宏返回&amp;ldquo; false&amp;rdquo;，则不会发生异常，并且v是OCaml函数返回的值。如果Is_exception_result（v）返回&amp;ldquo; true&amp;rdquo;，则转义了一个异常，可以使用Extract_exception（v）恢复其值（异常描述符）。</target>
        </trans-unit>
        <trans-unit id="630c7dca602616b8abb79db5171a1e3090693e64" translate="yes" xml:space="preserve">
          <source>If the OCaml function returned with an exception, Extract_exception should be applied to the exception result prior to calling a function that may trigger garbage collection. Otherwise, if v is reachable during garbage collection, the runtime can crash since v does not contain a valid value.</source>
          <target state="translated">如果OCaml函数返回时出现异常,那么在调用可能触发垃圾收集的函数之前,应该对异常结果应用Extract_exception。否则,如果v在垃圾收集过程中可以到达,运行时可能会崩溃,因为v不包含有效值。</target>
        </trans-unit>
        <trans-unit id="d0b4dadfc6f13fd380794c2f3f44ed17e6443186" translate="yes" xml:space="preserve">
          <source>If the argument is true, check information paths during type-checking, to make sure that all types are derived in a principal way. If the argument is false, do not check information paths.</source>
          <target state="translated">如果参数为真,则在类型检查时检查信息路径,以确保所有类型都是以本金方式导出的。如果参数为假,不检查信息路径。</target>
        </trans-unit>
        <trans-unit id="e1a5cad8cc059522a4fee23706b19131d9a15d23" translate="yes" xml:space="preserve">
          <source>If the array is of size four or less, the expression will create a fresh block and write the values into it one by one. There is no reference to the initialising array as a whole.</source>
          <target state="translated">如果数组大小为4或更小,该表达式将创建一个新的块,并将值逐一写入其中。没有对整个初始化数组的引用。</target>
        </trans-unit>
        <trans-unit id="87ba360226aef14289ad1c74a68816339b211735" translate="yes" xml:space="preserve">
          <source>If the call is not inside an exception handler, the returned backtrace is unspecified. If the call is after some exception-catching code (before in the handler, or in a when-guard during the matching of the exception handler), the backtrace may correspond to a later exception than the handled one.</source>
          <target state="translated">如果调用不在异常处理程序中,那么返回的回溯是未指定的。如果调用是在某些异常捕获代码之后(在处理程序之前,或在异常处理程序匹配期间的when-guard中),则回溯可能对应于比被处理的异常更晚的异常。</target>
        </trans-unit>
        <trans-unit id="3699887b7248910d086e978d7aa47ea89c5f6bf9" translate="yes" xml:space="preserve">
          <source>If the computation of &lt;code&gt;x&lt;/code&gt; raises an exception, it is unspecified whether &lt;code&gt;force_val&amp;nbsp;x&lt;/code&gt; raises the same exception or &lt;a href=&quot;lazy#EXCEPTIONUndefined&quot;&gt;&lt;code&gt;Lazy.Undefined&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 的计算引发异常，则不确定 &lt;code&gt;force_val&amp;nbsp;x&lt;/code&gt; 引发相同的异常还是&lt;a href=&quot;lazy#EXCEPTIONUndefined&quot;&gt; &lt;code&gt;Lazy.Undefined&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9cc33d7f4560db5b0839b107c0565d6921cb731" translate="yes" xml:space="preserve">
          <source>If the contents of the global variable v are seldom modified after registration, better performance can be achieved by calling caml_register_generational_global_root(&amp;amp;v) to register v (after its initialization with a valid value, but before any allocation or call to the GC functions), and caml_remove_generational_global_root(&amp;amp;v) to un-register it. In this case, you must not modify the value of v directly, but you must use caml_modify_generational_global_root(&amp;amp;v,x) to set it to x. The garbage collector takes advantage of the guarantee that v is not modified between calls to caml_modify_generational_global_root to scan it less often. This improves performance if the modifications of v happen less often than minor collections.</source>
          <target state="translated">如果在注册后很少修改全局变量v的内容，则可以通过调用caml_register_generational_global_root（＆v）来注册v（在使用有效值进行初始化之后，但在对GC函数进行任何分配或调用之前）来实现更好的性能，并且caml_remove_generational_global_root（＆v）取消注册。在这种情况下，您不能直接修改v的值，而必须使用caml_modify_generational_global_root（＆v，x）将其设置为x。垃圾收集器利用保证在调用caml_modify_generational_global_root之间不修改v的方式来减少对它的扫描。如果v的修改发生的次数少于次要集合的次数，则可以提高性能。</target>
        </trans-unit>
        <trans-unit id="9bd80053dd21abc2f1786fb591aa8cce37e37cef" translate="yes" xml:space="preserve">
          <source>If the element is a custom block it is not copied.</source>
          <target state="translated">如果该元素是自定义块,则不会被复制。</target>
        </trans-unit>
        <trans-unit id="86e7bd7a523ed97a9611f3d74bd5a6534bba8424" translate="yes" xml:space="preserve">
          <source>If the environment variable OCAMLPROF_DUMP is set when the program exits, its value is used as the file name instead of ocamlprof.dump.</source>
          <target state="translated">如果在程序退出时设置了环境变量OCAMLPROF_DUMP,那么它的值将被用作文件名而不是ocamlprof.dump。</target>
        </trans-unit>
        <trans-unit id="59b3e7898281ba717abfe0d4e0cfd223c49314a7" translate="yes" xml:space="preserve">
          <source>If the estimated benefit exceeds the increase in code size then the inlined version of the function will be kept. Otherwise the function will not be inlined.</source>
          <target state="translated">如果估计的收益超过了代码大小的增加,那么函数的内联版本将被保留。否则函数将不内嵌。</target>
        </trans-unit>
        <trans-unit id="526eae114b014fd19cf9658190d7f52e6cfa38d8" translate="yes" xml:space="preserve">
          <source>If the first form is used, with a single integer specified, the value will apply to all rounds.</source>
          <target state="translated">如果使用第一种形式,指定一个整数,该值将适用于所有回合。</target>
        </trans-unit>
        <trans-unit id="928707051883035a6a2490616c9c4666b3b8054b" translate="yes" xml:space="preserve">
          <source>If the format &lt;code&gt;fmt&lt;/code&gt; has some &lt;code&gt;%r&lt;/code&gt; indications, the corresponding formatted input functions must be provided &lt;em&gt;before&lt;/em&gt; receiver function &lt;code&gt;f&lt;/code&gt;. For instance, if &lt;code&gt;read_elem&lt;/code&gt; is an input function for values of type &lt;code&gt;t&lt;/code&gt;, then &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%r;&quot;&amp;nbsp;read_elem&amp;nbsp;f&lt;/code&gt; reads a value &lt;code&gt;v&lt;/code&gt; of type &lt;code&gt;t&lt;/code&gt; followed by a &lt;code&gt;';'&lt;/code&gt; character, and returns &lt;code&gt;f&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="translated">如果格式 &lt;code&gt;fmt&lt;/code&gt; 带有 &lt;code&gt;%r&lt;/code&gt; 指示，则必须&lt;em&gt;在&lt;/em&gt;接收器功能 &lt;code&gt;f&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;提供相应的格式化输入功能。例如，如果 &lt;code&gt;read_elem&lt;/code&gt; 是类型 &lt;code&gt;t&lt;/code&gt; 的值的输入函数，则 &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%r;&quot;&amp;nbsp;read_elem&amp;nbsp;f&lt;/code&gt; 读取类型为 &lt;code&gt;t&lt;/code&gt; 的值 &lt;code&gt;v&lt;/code&gt; ，后跟 &lt;code&gt;';'&lt;/code&gt; 字符，并返回 &lt;code&gt;f&amp;nbsp;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eaebb55224d923b372338ae66433b2e72d6c1dbb" translate="yes" xml:space="preserve">
          <source>If the function f does not return, but raises an exception that escapes the scope of the application, then this exception is propagated to the next enclosing OCaml code, skipping over the C code. That is, if an OCaml function f calls a C function g that calls back an OCaml function h that raises a stray exception, then the execution of g is interrupted and the exception is propagated back into f.</source>
          <target state="translated">如果函数f没有返回,而是引发了一个逃离应用范围的异常,那么这个异常就会传播到下一个包围的OCaml代码中,跳过C代码。也就是说,如果一个OCaml函数f调用了一个C函数g,而g又回调了一个OCaml函数h,引发了一个游离异常,那么g的执行就会被打断,异常又会传播到f中。</target>
        </trans-unit>
        <trans-unit id="83eb3ec9e1e3f016668f3beedc828600400ab1c4" translate="yes" xml:space="preserve">
          <source>If the function in question is involved in a recursive group then unboxing of specialised arguments may be immediately replicated across the group based on the dataflow between invariant arguments.</source>
          <target state="translated">如果相关函数涉及到一个递归组,那么根据不变参数之间的数据流,可以立即在整个组中复制专用参数的解箱。</target>
        </trans-unit>
        <trans-unit id="2217874359b71d84901f80859119f98479923fa3" translate="yes" xml:space="preserve">
          <source>If the given directory starts with +, it is taken relative to the standard library directory. For instance, -I +unix adds the subdirectory unix of the standard library to the search path.</source>
          <target state="translated">如果给定的目录以+开头,则取相对于标准库目录。例如,-I +unix将标准库的子目录unix添加到搜索路径中。</target>
        </trans-unit>
        <trans-unit id="031818e3fc1bf521466078fbb8e8be0fa0c0fb91" translate="yes" xml:space="preserve">
          <source>If the hash table was created in non-randomized mode, the order in which the bindings are enumerated is reproducible between successive runs of the program, and even between minor versions of OCaml. For randomized hash tables, the order of enumeration is entirely random.</source>
          <target state="translated">如果哈希表是以非随机模式创建的,那么在程序的连续运行之间,甚至在OCaml的不同小版本之间,列举绑定的顺序都是可以重复的。对于随机化的哈希表,枚举的顺序是完全随机的。</target>
        </trans-unit>
        <trans-unit id="cea4ad36d0decb77c4fb5241f963c83815372664" translate="yes" xml:space="preserve">
          <source>If the interface file x.mli exists, the implementation x.ml is checked against the corresponding compiled interface x.cmi, which is assumed to exist. If no interface x.mli is provided, the compilation of x.ml produces a compiled interface file x.cmi in addition to the compiled object code file x.cmo. The file x.cmi produced corresponds to an interface that exports everything that is defined in the implementation x.ml.</source>
          <target state="translated">如果接口文件x.mli存在,则根据相应的编译接口x.cmi检查实现x.ml,并假定该接口存在。如果没有提供接口x.mli,编译x.ml时,除了编译对象代码文件x.cmo外,还会产生一个编译后的接口文件x.cmi。产生的文件x.cmi对应于一个接口,这个接口导出了在实现x.ml中定义的所有内容。</target>
        </trans-unit>
        <trans-unit id="269f2549d5b0381849a3b6047e9fc8dbb8d0667d" translate="yes" xml:space="preserve">
          <source>If the libunwind library is not available on the system then it will not be possible for Spacetime to profile allocations occurring within C stubs. If the libunwind library is available but in an unusual location then that location may be specified to the configure script using the -libunwinddir option (or alternatively, using separate -libunwindinclude and -libunwindlib options).</source>
          <target state="translated">如果libunwind库在系统中不可用,那么Spacetime将无法对C存根中的分配进行配置。如果libunwind库是可用的,但是在一个不寻常的位置,那么这个位置可以使用-libunwinddir选项(或者使用单独的-libunwindinclude和-libunwindlib选项)指定给configure脚本。</target>
        </trans-unit>
        <trans-unit id="60d15c75ed47033c0e5c57361e18bc1a28cba287" translate="yes" xml:space="preserve">
          <source>If the make install command is run after having built the native toplevel then the ocamlnat program (either from the source or the installation directory) may be invoked directly rather than using make natruntop.</source>
          <target state="translated">如果make install命令是在构建了native toplevel之后运行的,那么就可以直接调用ocamlnat程序(无论是从源码还是安装目录),而不是使用make natruntop。</target>
        </trans-unit>
        <trans-unit id="57209cae8f03f39e03c3475e4a102e0e7a017631" translate="yes" xml:space="preserve">
          <source>If the named file is a directory, raises:</source>
          <target state="translated">如果命名的文件是一个目录,则引发。</target>
        </trans-unit>
        <trans-unit id="bfd36587a150830740da4e5b8e12155c63eb3d08" translate="yes" xml:space="preserve">
          <source>If the option letter is not recognized, the whole parameter is ignored; if the equal sign or the number is missing, the value is taken as 1; if the multiplier is not recognized, it is ignored.</source>
          <target state="translated">如果不识别选项字母,则忽略整个参数;如果缺少等号或数字,则取值为1;如果不识别乘数,则忽略。</target>
        </trans-unit>
        <trans-unit id="c6cd58692278da4b786278a83770b1d8a2642045" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line in the box, &lt;code&gt;d&lt;/code&gt; is added to the current indentation.</source>
          <target state="translated">如果漂亮打印机在框中分割行，则将 &lt;code&gt;d&lt;/code&gt; 添加到当前缩进中。</target>
        </trans-unit>
        <trans-unit id="7ef6acdf03d0f87940ead45d51f79d17fc14180f" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line in the box, offset &lt;code&gt;d&lt;/code&gt; is added to the current indentation.</source>
          <target state="translated">如果漂亮打印机在框中分割行，则将偏移 &lt;code&gt;d&lt;/code&gt; 添加到当前缩进中。</target>
        </trans-unit>
        <trans-unit id="361c4ed6a2a48ff1b42271ec1d3dc181183d0467" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line, &lt;code&gt;offset&lt;/code&gt; is added to the current indentation.</source>
          <target state="translated">如果漂亮打印机将行拆分，则将 &lt;code&gt;offset&lt;/code&gt; 添加到当前缩进中。</target>
        </trans-unit>
        <trans-unit id="4599aba8403a5552d8717f0e5fce41f734d86310" translate="yes" xml:space="preserve">
          <source>If the previous command has been successful, a blank line (typing just RET) will repeat it.</source>
          <target state="translated">如果前面的命令已经成功,空行(只输入RET)将重复该命令。</target>
        </trans-unit>
        <trans-unit id="0350c5cb5c18afaa3af79f9ae281828c0226be68" translate="yes" xml:space="preserve">
          <source>If the remaining arguments to process are of the form &lt;code&gt;[&quot;-foo&quot;;&amp;nbsp;&quot;arg&quot;]&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; where &quot;foo&quot; is registered as &lt;code&gt;Expand&amp;nbsp;f&lt;/code&gt;, then the arguments &lt;code&gt;f&amp;nbsp;&quot;arg&quot;&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; are processed. Only allowed in &lt;code&gt;parse_and_expand_argv_dynamic&lt;/code&gt;.</source>
          <target state="translated">如果要处理的其余参数的格式为 &lt;code&gt;[&quot;-foo&quot;;&amp;nbsp;&quot;arg&quot;]&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; ，其中&amp;ldquo; foo&amp;rdquo;被注册为 &lt;code&gt;Expand&amp;nbsp;f&lt;/code&gt; ，然后处理参数 &lt;code&gt;f&amp;nbsp;&quot;arg&quot;&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; 。仅在 &lt;code&gt;parse_and_expand_argv_dynamic&lt;/code&gt; 中允许。</target>
        </trans-unit>
        <trans-unit id="f3dc02053bcf7f04a6a9f0b8d70f87bdfcc90ced" translate="yes" xml:space="preserve">
          <source>If the second form is used, zero-based &lt;em&gt;round&lt;/em&gt; integers specify values which are to be used only for those rounds.</source>
          <target state="translated">如果使用第二种形式，则从零开始的&lt;em&gt;舍入&lt;/em&gt;整数将指定仅用于这些&lt;em&gt;舍入的&lt;/em&gt;值。</target>
        </trans-unit>
        <trans-unit id="23147d67da9a3357fd714ad7bd712b354fdbe027" translate="yes" xml:space="preserve">
          <source>If the type [('a,'b,&amp;hellip;)] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; = [`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] is defined, then the pattern #&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a shorthand for the following or-pattern: (`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;(_:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)| &amp;hellip; |`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;(_:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)). It matches all values of type [&amp;lt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;].</source>
          <target state="translated">如果类型[（'a，'b，...）] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; = [`&lt;a href=&quot;names#tag-name&quot;&gt;标签名&lt;/a&gt;&lt;sub&gt;1 &lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; | &amp;hellip;|`&lt;a href=&quot;names#tag-name&quot;&gt;标签名&lt;/a&gt;&lt;sub&gt;n &lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]被定义，则模式&lt;a href=&quot;names#typeconstr&quot;&gt;＃typeconstr&lt;/a&gt;是以下or-pattern的简写：（`&lt;a href=&quot;names#tag-name&quot;&gt;标签名&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;（_：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;）|&amp;hellip;|`&lt;a href=&quot;names#tag-name&quot;&gt;标签名&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;（_ ：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;））。它匹配类型[&amp;lt; &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; ]的所有值。</target>
        </trans-unit>
        <trans-unit id="6934c8c175e921d36d82df098f9aaaaba6060c8a" translate="yes" xml:space="preserve">
          <source>If the value of its argument its None, the printer returned by pp_option printer prints None otherwise it uses the provided printer to print Some .</source>
          <target state="translated">如果参数值为None,则pp_option printer返回的打印机打印None,否则使用提供的打印机打印Some。</target>
        </trans-unit>
        <trans-unit id="02bfb791a4aefd529589de31a34af8d62fb05206" translate="yes" xml:space="preserve">
          <source>If there are no safe modules along a dependency cycle, an error is raised</source>
          <target state="translated">如果在一个依赖周期内没有安全的模块,就会引发一个错误。</target>
        </trans-unit>
        <trans-unit id="0a28412182364c49d7b1c7ff896cdb24ffe2090a" translate="yes" xml:space="preserve">
          <source>If there is no next tabulation marker on the right, the pretty-printer splits the line at this point, then insertion point moves to the leftmost tabulation marker of the box.</source>
          <target state="translated">如果右边没有下一个制表标记,漂亮打印机就在此时分割线,然后插入点移动到方框最左边的制表标记上。</target>
        </trans-unit>
        <trans-unit id="93e986ba889d48b83a3b585c29a13d802a48e88f" translate="yes" xml:space="preserve">
          <source>If there is no special character in the argument that needs escaping, return the original string itself, not a copy.</source>
          <target state="translated">如果参数中没有需要转义的特殊字符,则返回原始字符串本身,而不是副本。</target>
        </trans-unit>
        <trans-unit id="650636821137156f9b89bf7d83008b87c146680c" translate="yes" xml:space="preserve">
          <source>If using automatic snapshots the presence of the &lt;code&gt;save_event_for_automatic_snapshots&lt;/code&gt; function, below, should be noted.</source>
          <target state="translated">如果使用自动快照，则应注意以下 &lt;code&gt;save_event_for_automatic_snapshots&lt;/code&gt; 函数的存在。</target>
        </trans-unit>
        <trans-unit id="af7f9f8dc289a45aa7abb853b1e6e0f99bdabaa2" translate="yes" xml:space="preserve">
          <source>If v is a OCaml value representing a Bigarray, the expression Caml_ba_data_val(v) returns a pointer to the data part of the array. This pointer is of type void * and can be cast to the appropriate C type for the array (e.g. double [], char [][10], etc).</source>
          <target state="translated">如果v是代表Bigarray的OCaml值,表达式Caml_ba_data_val(v)返回一个指向数组数据部分的指针。这个指针的类型是void *,并且可以投向数组的适当的C类型(例如double []、char [][10]等)。</target>
        </trans-unit>
        <trans-unit id="e57d1cd0be66bfd79fceee72f6e460b8f16042be" translate="yes" xml:space="preserve">
          <source>If we ignore labels, which will only be meaningful at function application, this is equivalent to</source>
          <target state="translated">如果我们忽略标签,而标签只有在函数应用时才有意义,这就相当于</target>
        </trans-unit>
        <trans-unit id="a12dddd1ed24396bf32965cc98f1c85d9b5a043d" translate="yes" xml:space="preserve">
          <source>If we were able to coerce x to the type xy ref as a variable xy, we could use xy to store the value `Y inside the reference and then use the x value to read this content as a value of type x, which would break the type system.</source>
          <target state="translated">如果我们能够将x胁迫到类型xy ref作为一个变量xy,我们就可以用xy在引用里面存储值`Y,然后用x的值将这个内容读成类型x的值,这样就打破了类型体系。</target>
        </trans-unit>
        <trans-unit id="e9ac75e77f2bdbf6513fcd0f5eb458c2a45208f1" translate="yes" xml:space="preserve">
          <source>If you are looking for a parametrized type where one alternative means success and the other means failure, you should use the more specific type &lt;a href=&quot;result#TYPEt&quot;&gt;&lt;code&gt;Result.t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您正在寻找一种参数化类型，其中一种选择表示​​成功，另一种表示失败，则应使用更具体的类型&lt;a href=&quot;result#TYPEt&quot;&gt; &lt;code&gt;Result.t&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="938dc89ad7bb75f8b6b5234d0f82aeee4a2b6b87" translate="yes" xml:space="preserve">
          <source>If you are using internal C variables, do not redefine them by hand. You should import those variables by including the corresponding header files. The representation of those variables has already changed once in OCaml 4.10, and is still under evolution. If your code relies on such internal and brittle properties, it will be broken at some point in time.</source>
          <target state="translated">如果你使用的是内部C变量,不要用手重新定义它们。你应该通过包含相应的头文件来导入这些变量。这些变量的表示方式在OCaml 4.10中已经改变过一次,而且还在进化中。如果你的代码依赖于这样的内部和脆性属性,它将在某个时间点被破坏。</target>
        </trans-unit>
        <trans-unit id="4684963cdc7330d90fbde44bf1de388d5ea4d30c" translate="yes" xml:space="preserve">
          <source>If you are using the native-code compiler ocamlopt, the -custom flag is not needed, as the final linking phase of ocamlopt always builds a standalone executable. To build a mixed OCaml/C executable, execute the ocamlopt command with:</source>
          <target state="translated">如果你使用的是本地代码编译器ocamlopt,则不需要使用-custom标志,因为ocamlopt的最后链接阶段总是构建一个独立的可执行文件。要建立一个混合的 OCaml/C 可执行文件,请执行 ocamlopt 命令,并使用:</target>
        </trans-unit>
        <trans-unit id="a9e51a95e1449f47a9a997884fd92f2e9640f19f" translate="yes" xml:space="preserve">
          <source>If you are using the opam package manager, you should install the corresponding graphics package:</source>
          <target state="translated">如果你使用的是opam包管理器,你应该安装相应的图形包。</target>
        </trans-unit>
        <trans-unit id="6e2b19145c81285ba95d5206a4aef01e47305c6b" translate="yes" xml:space="preserve">
          <source>If you choose to use the compatibility library, you must link your programs as follows:</source>
          <target state="translated">如果您选择使用兼容性库,您必须按以下方式链接您的程序。</target>
        </trans-unit>
        <trans-unit id="a7aae036d3d0305ff1e81bf7e09e7219b84487d6" translate="yes" xml:space="preserve">
          <source>If you have a look at modules ending in Labels in the standard library, you will see that function types have annotations you did not have in the functions you defined yourself.</source>
          <target state="translated">如果你看一下标准库中以Labels结尾的模块,你会发现函数类型有你自己定义的函数中没有的注释。</target>
        </trans-unit>
        <trans-unit id="0d8ec7283da5154d3c5f9741853ea4731d05f757" translate="yes" xml:space="preserve">
          <source>If you really need name to have a polymorphic type, turn its defining expression into a function by adding an extra parameter. For instance, instead of writing</source>
          <target state="translated">如果你真的需要name有一个多态类型,可以通过添加一个额外的参数将其定义表达式变成一个函数。例如,我们不需要写</target>
        </trans-unit>
        <trans-unit id="584ae084b62d035171468566819a455d2183819f" translate="yes" xml:space="preserve">
          <source>If you really need to allocate before the fields can receive their final value, first initialize with a constant value (e.g. Val_unit), then allocate, then modify the fields with the correct value (see rule &amp;zwj;6).</source>
          <target state="translated">如果您确实需要在字段可以接收其最终值之前进行分配，请首先使用常量值（例如Val_unit）进行初始化，然后分配，然后使用正确的值修改字段（请参见规则&amp;zwj;6）。</target>
        </trans-unit>
        <trans-unit id="3cc2b54b4fe8b9babd50993b19aa3de4b1112f06" translate="yes" xml:space="preserve">
          <source>If you really need to allocate before the fields can receive their final value, first initialize with a constant value (e.g. Val_unit), then allocate, then modify the fields with the correct value (see rule 6).</source>
          <target state="translated">如果真的需要在字段接受最终值之前进行分配,首先用一个常量值(例如Val_unit)初始化,然后进行分配,再以正确的值修改字段(见规则6)。</target>
        </trans-unit>
        <trans-unit id="5a4f00d7d346ec3d9a159649e84ffda00feee562" translate="yes" xml:space="preserve">
          <source>If you use module aliases to give shorter names to modules, you need to change the above definitions. Assuming that your map file is called mylib.mli, here are minimal modifications.</source>
          <target state="translated">如果你使用模块别名来给模块起更短的名字,你需要修改上面的定义。假设你的map文件叫做mylib.mli,这里是最小的修改。</target>
        </trans-unit>
        <trans-unit id="445ff9fe29411614baa1aba0c77e6b3c07963936" translate="yes" xml:space="preserve">
          <source>If your code raises this warning, you should &lt;em&gt;not&lt;/em&gt; change the way you test for the specific string to avoid the warning (for example using a string equality inside the right-hand-side instead of a literal pattern), as your code would remain fragile. You should instead enlarge the scope of the pattern by matching on all possible values.</source>
          <target state="translated">如果你的代码中引发了这样的警告，你应该&lt;em&gt;不会&lt;/em&gt;改变你测试的特定字符串，以避免该警告（例如使用右手边，而不是文字图案内的字符串相等）的方式，为您的代码将仍然是脆弱的。您应该通过匹配所有可能的值来扩大模式的范围。</target>
        </trans-unit>
        <trans-unit id="b87ed6fde2df7c4b454ca4c9bbdd14667b228435" translate="yes" xml:space="preserve">
          <source>If your finalized blocks contain no pointers to out-of-heap resources, or if the previous discussion made little sense to you, just take used = 0 and max = 1. But if you later find that the finalization functions are not called &amp;ldquo;often enough&amp;rdquo;, consider increasing the used / max ratio.</source>
          <target state="translated">如果您的完成块不包含指向堆外资源的指针，或者如果前面的讨论对您没有多大意义，则只使用used = 0和max = 1。足够&amp;rdquo;，请考虑增加已用/最大比例。</target>
        </trans-unit>
        <trans-unit id="192602c36fe264c7bb72e181d69fc51ec2ab7ac6" translate="yes" xml:space="preserve">
          <source>If your program spans several directories, this error can also appear because you haven&amp;rsquo;t specified the directories to look into. Fix: add the correct -I options to the command line.</source>
          <target state="translated">如果您的程序跨越多个目录，则由于未指定要查找的目录，也会出现此错误。修复：在命令行中添加正确的-I选项。</target>
        </trans-unit>
        <trans-unit id="a4413f87552659e0c51237304101e749ef0f1523" translate="yes" xml:space="preserve">
          <source>If your program spans several directories, this error can also appear because you haven&amp;rsquo;t specified the directories to look into. Fix: use the #directory directive to add the correct directories to the search path.</source>
          <target state="translated">如果您的程序跨越多个目录，则由于未指定要查找的目录，也会出现此错误。修复：使用#directory指令将正确的目录添加到搜索路径。</target>
        </trans-unit>
        <trans-unit id="04dca8ad26b4c54518389383583f6a6c77bac6ff" translate="yes" xml:space="preserve">
          <source>Ignore CR on input.</source>
          <target state="translated">忽略输入的CR。</target>
        </trans-unit>
        <trans-unit id="c5bdb39e4b8dd017918a8e726872a7f1642a7810" translate="yes" xml:space="preserve">
          <source>Ignore characters with parity errors.</source>
          <target state="translated">忽略有奇偶校验错误的字符。</target>
        </trans-unit>
        <trans-unit id="0c2318243f67f315a4b8a9f29efe92c076e89ddd" translate="yes" xml:space="preserve">
          <source>Ignore labels in function types if argument is false, or switch back to default behaviour (commuting style) if argument is true.</source>
          <target state="translated">如果参数为false,则忽略函数类型中的标签,如果参数为true,则切换回默认行为(换算方式)。</target>
        </trans-unit>
        <trans-unit id="236cc3c9f521b0fbfe59c2c79bd30f8c85081542" translate="yes" xml:space="preserve">
          <source>Ignore modem status lines.</source>
          <target state="translated">忽略调制解调器状态线。</target>
        </trans-unit>
        <trans-unit id="cc25631b490cc9dc3eae61a416673381002ebaea" translate="yes" xml:space="preserve">
          <source>Ignore non-optional labels in types.</source>
          <target state="translated">忽略类型中的非选择标签。</target>
        </trans-unit>
        <trans-unit id="8221a4e278c3aef5f3541066115c1b84f80bf481" translate="yes" xml:space="preserve">
          <source>Ignore non-optional labels in types. Labels cannot be used in applications, and parameter order becomes strict.</source>
          <target state="translated">忽略类型中的非选项标签。在应用程序中不能使用标签,而且参数顺序变得严格。</target>
        </trans-unit>
        <trans-unit id="8f8ed3358c226fa964cfafc27575cd3a5ffdead1" translate="yes" xml:space="preserve">
          <source>Ignore the break condition.</source>
          <target state="translated">忽略休息条件。</target>
        </trans-unit>
        <trans-unit id="97a2e0248ded1dacda641b2fd0e32c78a1469949" translate="yes" xml:space="preserve">
          <source>Ignored: now part of warning 8.</source>
          <target state="translated">忽略:现在是警告的一部分8。</target>
        </trans-unit>
        <trans-unit id="73e3cd2bf31dccb18ec366d4ab12d7eebaea2ee2" translate="yes" xml:space="preserve">
          <source>Illegal attribute payload.</source>
          <target state="translated">非法的属性有效载荷。</target>
        </trans-unit>
        <trans-unit id="8e292013c5db7783c6e4d84fc6547a66bca7ad0b" translate="yes" xml:space="preserve">
          <source>Illegal backslash escape in a string constant.</source>
          <target state="translated">字符串常量中非法反斜杠转义。</target>
        </trans-unit>
        <trans-unit id="3ad48d23e5988a78accd5d9e97f80d2e494170e6" translate="yes" xml:space="preserve">
          <source>Immediate objects have two weaknesses compared to classes: their types are not abbreviated, and you cannot inherit from them. But these two weaknesses can be advantages in some situations, as we will see in sections &amp;zwj;&lt;a href=&quot;#s%3Areference-to-self&quot;&gt;3.3&lt;/a&gt; and &amp;zwj;&lt;a href=&quot;#s%3Aparameterized-classes&quot;&gt;3.10&lt;/a&gt;.</source>
          <target state="translated">与类相比，直接对象有两个缺点：它们的类型不缩写，并且您不能从它们继承。但是这两个弱点可能是优势，在某些情况下，我们将在部分看到&lt;a href=&quot;#s%3Areference-to-self&quot;&gt;3.3&lt;/a&gt;和&lt;a href=&quot;#s%3Aparameterized-classes&quot;&gt;3.10&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a2a7f348bbdc4825046979cfd8b768f4fac13a7" translate="yes" xml:space="preserve">
          <source>Immediate objects have two weaknesses compared to classes: their types are not abbreviated, and you cannot inherit from them. But these two weaknesses can be advantages in some situations, as we will see in sections &lt;a href=&quot;#s%3Areference-to-self&quot;&gt;3.3&lt;/a&gt; and &lt;a href=&quot;#s%3Aparameterized-classes&quot;&gt;3.10&lt;/a&gt;.</source>
          <target state="translated">与类相比，直接对象有两个缺点：它们的类型不缩写，并且您不能从它们继承。但是，这两个弱点在某些情况下可能是优点，正如我们将在&lt;a href=&quot;#s%3Areference-to-self&quot;&gt;3.3&lt;/a&gt;和&lt;a href=&quot;#s%3Aparameterized-classes&quot;&gt;3.10&lt;/a&gt;节中看到的那样。</target>
        </trans-unit>
        <trans-unit id="54ba8c8554c6b105de4bb1e2e2bd6ecba60273ca" translate="yes" xml:space="preserve">
          <source>Implementing a user primitive is actually two separate tasks: on the one hand, decoding the arguments to extract C values from the given OCaml values, and encoding the return value as an OCaml value; on the other hand, actually computing the result from the arguments. Except for very simple primitives, it is often preferable to have two distinct C functions to implement these two tasks. The first function actually implements the primitive, taking native C values as arguments and returning a native C value. The second function, often called the &amp;ldquo;stub code&amp;rdquo;, is a simple wrapper around the first function that converts its arguments from OCaml values to C values, call the first function, and convert the returned C value to OCaml value. For instance, here is the stub code for the input primitive:</source>
          <target state="translated">实现用户原语实际上是两个单独的任务：一方面，对自变量进行解码以从给定的OCaml值中提取C值；将返回值编码为OCaml值；另一方面，实际上是根据自变量计算结果。除了非常简单的原语以外，通常最好具有两个不同的C函数来实现这两个任务。第一个函数实际上实现了原语，将本机C值作为参数并返回了本机C值。第二个函数通常称为&amp;ldquo;存根代码&amp;rdquo;，它是第一个函数的简单包装，将其参数从OCaml值转换为C值，调用第一个函数，然后将返回的C值转换为OCaml值。例如，这是输入原语的存根代码：</target>
        </trans-unit>
        <trans-unit id="30dd7b027ecbf0176e983b1c6d8e3ff43f86ac1a" translate="yes" xml:space="preserve">
          <source>Implementing sets leads to another difficulty. Indeed, the method union needs to be able to access the internal representation of another object of the same class.</source>
          <target state="translated">实现集合会导致另一个困难。事实上,方法联合需要能够访问同一类的另一个对象的内部表示。</target>
        </trans-unit>
        <trans-unit id="cb06de5305a8cd588b4b2090243c7c818837829e" translate="yes" xml:space="preserve">
          <source>Implicit elimination of optional arguments.</source>
          <target state="translated">隐性消除可选参数。</target>
        </trans-unit>
        <trans-unit id="9320eec5e654eb93a5ec38ac96a5b6831671bb90" translate="yes" xml:space="preserve">
          <source>Impose the given protocol</source>
          <target state="translated">实施给定协议</target>
        </trans-unit>
        <trans-unit id="f84f9ef20beeb6870c2739752e2d02c1ffd0734c" translate="yes" xml:space="preserve">
          <source>Impose the given socket domain</source>
          <target state="translated">强加给定的套接字域</target>
        </trans-unit>
        <trans-unit id="49c1a4ccb12bf83d3c389505eddce7022eb2d2f8" translate="yes" xml:space="preserve">
          <source>Impose the given socket type</source>
          <target state="translated">强加给定的插座类型</target>
        </trans-unit>
        <trans-unit id="3aa5755d0f34cd51e5c3972bcf24783ddea62c5f" translate="yes" xml:space="preserve">
          <source>In -Oclassic mode the behaviour of the Flambda inliner mimics previous versions of the compiler. (Code may still be subject to further optimisations not performed by previous versions of the compiler: functors may be inlined, constants are lifted and unused code is eliminated all as described elsewhere in this chapter. See sections &lt;a href=&quot;#sss%3Aflambda-functors&quot;&gt;19.3.3&lt;/a&gt;, &lt;a href=&quot;#ss%3Aflambda-lift-const&quot;&gt;19.8.1&lt;/a&gt; and &lt;a href=&quot;#s%3Aflambda-remove-unused&quot;&gt;19.10&lt;/a&gt;. At the definition site of a function, the body of the function is measured. It will then be marked as eligible for inlining (and hence inlined at every direct call site) if:</source>
          <target state="translated">在-Oclassic模式下，Flambda内衬的行为模仿了编译器的早期版本。 （代码仍可能受到不是由编译器的先前版本进行进一步的优化：仿函数可以被内联，常数被提升和未使用的代码被消除所有如本章中别处描述见章节&lt;a href=&quot;#sss%3Aflambda-functors&quot;&gt;19.3.3&lt;/a&gt;，&lt;a href=&quot;#ss%3Aflambda-lift-const&quot;&gt;19.8.1&lt;/a&gt;和&lt;a href=&quot;#s%3Aflambda-remove-unused&quot;&gt;19.10&lt;/a&gt;在函数的定义位置，测量函数的主体，然后将其标记为有资格进行内联（并因此在每个直接调用位置进行内联）：</target>
        </trans-unit>
        <trans-unit id="9f01d5e440fa709806dd2194e638ac6c655d4223" translate="yes" xml:space="preserve">
          <source>In -Oclassic mode the behaviour of the Flambda inliner mimics previous versions of the compiler. (Code may still be subject to further optimisations not performed by previous versions of the compiler: functors may be inlined, constants are lifted and unused code is eliminated all as described elsewhere in this chapter. See sections &lt;a href=&quot;#sss%3Aflambda-functors&quot;&gt;21.3.3&lt;/a&gt;, &lt;a href=&quot;#ss%3Aflambda-lift-const&quot;&gt;21.8.1&lt;/a&gt; and &lt;a href=&quot;#s%3Aflambda-remove-unused&quot;&gt;21.10&lt;/a&gt;. At the definition site of a function, the body of the function is measured. It will then be marked as eligible for inlining (and hence inlined at every direct call site) if:</source>
          <target state="translated">在-Oclassic模式下，Flambda内衬的行为模仿了编译器的早期版本。（代码仍可能受到不是由编译器的先前版本进行进一步的优化：仿函数可以被内联，常数被提升和未使用的代码被消除所有如本章中别处描述见章节&lt;a href=&quot;#sss%3Aflambda-functors&quot;&gt;21.3.3&lt;/a&gt;，&lt;a href=&quot;#ss%3Aflambda-lift-const&quot;&gt;21.8.1&lt;/a&gt;和&lt;a href=&quot;#s%3Aflambda-remove-unused&quot;&gt;21.10&lt;/a&gt;在函数的定义位置，测量函数的主体，然后将其标记为有资格进行内联（并因此在每个直接调用位置进行内联）：</target>
        </trans-unit>
        <trans-unit id="7b7e88e3104809cced60ca047035fc79d790e127" translate="yes" xml:space="preserve">
          <source>In OCaml, compilation units are special cases of structures and signatures, and the relationship between the units can be explained easily in terms of the module system. A compilation unit A comprises two files:</source>
          <target state="translated">在OCaml中,编译单元是结构和签名的特例,单元之间的关系可以很容易地用模块系统来解释。一个编译单元A由两个文件组成。</target>
        </trans-unit>
        <trans-unit id="145f72b5a6e94195611949a3aeaa2a7ac11729f1" translate="yes" xml:space="preserve">
          <source>In OCaml, there are two ways to introduce this kind of explicit universally quantified types: universally quantified record fields,</source>
          <target state="translated">在OCaml中,有两种方法可以引入这种显式的普遍量化类型:普遍量化的记录字段。</target>
        </trans-unit>
        <trans-unit id="bc3a2778a1685965f7577f444b98e2832d2ae8ce" translate="yes" xml:space="preserve">
          <source>In a class body, the pattern (&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] ) is matched against self, therefore providing a binding for self and self type. Self can only be used in method and initializers.</source>
          <target state="translated">在类主体中，模式（&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ]）与self匹配，因此为self和self类型提供了绑定。Self只能在方法和初始化程序中使用。</target>
        </trans-unit>
        <trans-unit id="70397c150edca7640c04b63beb83552a9ba1f06e" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two classes, two class types or a class and a class type with the same name.</source>
          <target state="translated">在一个模块中,不能有两个类、两个类型或一个类和一个类型同名。</target>
        </trans-unit>
        <trans-unit id="40aee30082742b60c78c6aa0f902e60e3255ab7f" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two modules, two module types or a module and a module type with the same name. In the default HTML generator, modules ab and AB will be printed to the same file on case insensitive file systems.</source>
          <target state="translated">在一个模块中,不能有两个模块,两个模块类型,或者一个模块和一个模块类型同名。在默认的HTML生成器中,在不区分大小写的文件系统中,模块ab和AB将被打印到同一个文件中。</target>
        </trans-unit>
        <trans-unit id="d7e6cfb9260eacd797ec6d4742da8c29b966e366" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two values, two types, or two exceptions with the same name.</source>
          <target state="translated">在一个模块中,不能有两个值,两个类型,或者两个名字相同的异常。</target>
        </trans-unit>
        <trans-unit id="ab874b0f502ca4c39dea57d7a6a911eaeb837510" translate="yes" xml:space="preserve">
          <source>In absence of an explicit polymorphic annotation, a monomorphic type is inferred for the recursive function. If a recursive call occurs inside the function definition at a type that involves an existential GADT type variable, this variable flows to the type of the recursive function, and thus escapes its scope. In the above example, this happens in the branch App(f,x) when eval is called with f as an argument. In this branch, the type of f is ($App_ 'b-&amp;gt; a). The prefix $ in $App_ 'b denotes an existential type named by the compiler (see &amp;zwj;&lt;a href=&quot;#p%3Aexistential-names&quot;&gt;8.10&lt;/a&gt;). Since the type of eval is 'a term -&amp;gt; 'a, the call eval f makes the existential type $App_'b flow to the type variable 'a and escape its scope. This triggers the above error.</source>
          <target state="translated">在没有显式多态注释的情况下，将为递归函数推断出单态类型。如果在函数定义内部以涉及存在的GADT类型变量的类型进行递归调用，则此变量将流向递归函数的类型，因此会转义其范围。在上面的示例中，当使用f作为参数调用eval时，这会在分支App（f，x）中发生。在此分支中，f的类型为（$ App_'b-&amp;gt; a）。在$ APP_&amp;ldquo;B前缀$表示由编译器名为存在的类型（见&lt;a href=&quot;#p%3Aexistential-names&quot;&gt;8.10&lt;/a&gt;）。由于eval的类型为'a term-&amp;gt;'a，因此调用eval f使存在类型$ App_'b流入类型变量'a，并转义其范围。这将触发上述错误。</target>
        </trans-unit>
        <trans-unit id="9eaaa21ac3ef3ccade4409a2792f201883504cc8" translate="yes" xml:space="preserve">
          <source>In absence of an explicit polymorphic annotation, a monomorphic type is inferred for the recursive function. If a recursive call occurs inside the function definition at a type that involves an existential GADT type variable, this variable flows to the type of the recursive function, and thus escapes its scope. In the above example, this happens in the branch App(f,x) when eval is called with f as an argument. In this branch, the type of f is ($App_ 'b-&amp;gt; a). The prefix $ in $App_ 'b denotes an existential type named by the compiler (see &lt;a href=&quot;#p%3Aexistential-names&quot;&gt;8.10&lt;/a&gt;). Since the type of eval is 'a term -&amp;gt; 'a, the call eval f makes the existential type $App_'b flow to the type variable 'a and escape its scope. This triggers the above error.</source>
          <target state="translated">在没有显式多态注释的情况下，将为递归函数推断出单态类型。如果在函数定义内部以涉及存在的GADT类型变量的类型进行递归调用，则此变量将流向递归函数的类型，因此会转义其范围。在上面的示例中，当使用f作为参数调用eval时，这会在分支App（f，x）中发生。在此分支中，f的类型为（$ App_'b-&amp;gt; a）。 $ App_'b中的前缀$表示由编译器命名的存在类型（请参见&lt;a href=&quot;#p%3Aexistential-names&quot;&gt;8.10&lt;/a&gt;）。由于eval的类型为'a term-&amp;gt;'a，因此调用eval f使存在类型$ App_'b流入类型变量'a，并转义其范围。这将触发上述错误。</target>
        </trans-unit>
        <trans-unit id="83a4780fdda72224bf7c404686bee6b0dd38a00f" translate="yes" xml:space="preserve">
          <source>In addition to integers and floating-point numbers, OCaml offers the usual basic data types:</source>
          <target state="translated">除了整数和浮点数,OCaml还提供了常用的基本数据类型。</target>
        </trans-unit>
        <trans-unit id="6f1c1d50be627c43f3ca0ba8417dadf3c27859e0" translate="yes" xml:space="preserve">
          <source>In addition to program documentation, class interfaces can be used to constrain the type of a class. Both concrete instance variables and concrete private methods can be hidden by a class type constraint. Public methods and virtual members, however, cannot.</source>
          <target state="translated">除了程序文档,类接口还可以用来约束类的类型。具体的实例变量和具体的私有方法都可以通过类类型约束来隐藏。但是,公共方法和虚拟成员却不能。</target>
        </trans-unit>
        <trans-unit id="ff972760c30a42809d4bcb7b88b56d292a034872" translate="yes" xml:space="preserve">
          <source>In addition, Emacs displays the source files containing the current event (the current position in the program execution) and highlights the location of the event. This display is updated synchronously with the debugger action.</source>
          <target state="translated">此外,Emacs还会显示包含当前事件的源文件(程序执行中的当前位置),并突出显示事件的位置。这种显示是与调试器的动作同步更新的。</target>
        </trans-unit>
        <trans-unit id="c7116193945dcb705fd31b47667c53f6ed878fa4" translate="yes" xml:space="preserve">
          <source>In addition, the following options are recognized:</source>
          <target state="translated">此外,还承认以下选项:</target>
        </trans-unit>
        <trans-unit id="02a9d67825df2ad654535d9305a175a49c2e92ae" translate="yes" xml:space="preserve">
          <source>In all buffers in OCaml editing mode, the following debugger commands are also available:</source>
          <target state="translated">在OCaml编辑模式的所有缓冲区中,还可以使用以下调试器命令。</target>
        </trans-unit>
        <trans-unit id="34fa2ed3ea28bd96a31c074309c173fda8ea3d66" translate="yes" xml:space="preserve">
          <source>In all cases but exact match of order and labels, without optional parameters, the function type should be known at the application point. This can be ensured by adding a type constraint. Principality of the derivation can be checked in the -principal mode.</source>
          <target state="translated">在所有情况下,除了顺序和标签的精确匹配,没有可选的参数,函数类型应该在应用点被知道。这可以通过添加一个类型约束来保证。派生的公有制可以在-principal模式下检查。</target>
        </trans-unit>
        <trans-unit id="8df4f3c4b7e3901c28cc625ce0fcca37b5cf5b16" translate="yes" xml:space="preserve">
          <source>In all three cases, tags may be either specified directly in the `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [of&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;] form, or indirectly through a type expression, which must expand to an exact variant type, whose tag specifications are inserted in its place.</source>
          <target state="translated">在这三种情况下，都可以直接以` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [ &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ]形式指定标签，也可以通过类型表达式间接指定标签，该类型表达式必须扩展为确切的变量类型，并在其位置插入标签规范。</target>
        </trans-unit>
        <trans-unit id="d7baa740e37d7218dfa915e6dbf869155b1be9ec" translate="yes" xml:space="preserve">
          <source>In an attempt to write the type constraint above more elegantly, one may wish to name the signature of the structure returned by the functor, then use that signature in the constraint:</source>
          <target state="translated">为了更优雅地写出上面的类型约束,我们可能希望命名漏斗返回的结构的签名,然后在约束中使用该签名。</target>
        </trans-unit>
        <trans-unit id="a30f385b51a5770584633407723813633df87fa2" translate="yes" xml:space="preserve">
          <source>In both cases, at least one of the integer and fractional parts must be given; the exponent part is optional.</source>
          <target state="translated">在这两种情况下,必须至少给出整数和分数部分中的一个,指数部分是可选的。</target>
        </trans-unit>
        <trans-unit id="aeab98a5938308a7ca7c5d621826d698eeb35974" translate="yes" xml:space="preserve">
          <source>In both cases, the whole for expression evaluates to the unit value ().</source>
          <target state="translated">在这两种情况下,整个for表达式都评价为单位值()。</target>
        </trans-unit>
        <trans-unit id="eb7d81806d62938e65661891480f3bf1c340bdef" translate="yes" xml:space="preserve">
          <source>In bytecode, the identity function.</source>
          <target state="translated">在字节码中,身份函数。</target>
        </trans-unit>
        <trans-unit id="8eef554bc6e9693f24dc173cd6cec6650313f5d0" translate="yes" xml:space="preserve">
          <source>In bytecode, the identity function. In native code, replace the last extension with &lt;code&gt;.cmxs&lt;/code&gt;.</source>
          <target state="translated">在字节码中，身份功能。在本机代码中，将最后一个扩展名替换为 &lt;code&gt;.cmxs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a627abf55d958271115777925dd0ee4cea9f6d0" translate="yes" xml:space="preserve">
          <source>In bytecode: load the given bytecode object file (&lt;code&gt;.cmo&lt;/code&gt; file) or bytecode library file (&lt;code&gt;.cma&lt;/code&gt; file), and link it with the running program.</source>
          <target state="translated">在字节码中：加载给定的字节码目标文件（ &lt;code&gt;.cmo&lt;/code&gt; 文件）或字节码库文件（ &lt;code&gt;.cma&lt;/code&gt; 文件），并将其与正在运行的程序链接。</target>
        </trans-unit>
        <trans-unit id="b1240e451018dbc380a6a35faaf32c3363a7ae3c" translate="yes" xml:space="preserve">
          <source>In bytecode: load the given bytecode object file (&lt;code&gt;.cmo&lt;/code&gt; file) or bytecode library file (&lt;code&gt;.cma&lt;/code&gt; file), and link it with the running program. In native code: load the given OCaml plugin file (usually &lt;code&gt;.cmxs&lt;/code&gt;), and link it with the running program.</source>
          <target state="translated">在字节码中：加载给定的字节码目标文件（ &lt;code&gt;.cmo&lt;/code&gt; 文件）或字节码库文件（ &lt;code&gt;.cma&lt;/code&gt; 文件），并将其与正在运行的程序链接。在本机代码中：加载给定的OCaml插件文件（通常是 &lt;code&gt;.cmxs&lt;/code&gt; ），并将其链接到正在运行的程序。</target>
        </trans-unit>
        <trans-unit id="c05a5ebf291f79b9d8204d27a74aaf7e66a3bd26" translate="yes" xml:space="preserve">
          <source>In case of interactive use, each phrase is executed in the initial state of the standard pretty-printer: after each phrase execution, the interactive system closes all open pretty-printing boxes, flushes all pending text, and resets the standard pretty-printer.</source>
          <target state="translated">在交互式使用的情况下,每个短语都是在标准漂亮打印机的初始状态下执行的:在每个短语执行完毕后,交互式系统会关闭所有打开的漂亮打印框,刷新所有待处理的文本,并重新设置标准漂亮打印机。</target>
        </trans-unit>
        <trans-unit id="4492c5d50795eada8a5ec4ba7632113061a4720c" translate="yes" xml:space="preserve">
          <source>In case of multiple and related calls to &lt;code&gt;sprintf&lt;/code&gt; to output material on a single string, you should consider using &lt;code&gt;fprintf&lt;/code&gt; with the predefined formatter &lt;code&gt;str_formatter&lt;/code&gt; and call &lt;code&gt;flush_str_formatter&amp;nbsp;()&lt;/code&gt; to get the final result.</source>
          <target state="translated">如果对 &lt;code&gt;sprintf&lt;/code&gt; 进行了多个相关调用以在单个字符串上输出素材，则应考虑将 &lt;code&gt;fprintf&lt;/code&gt; 与预定义的格式化程序 &lt;code&gt;str_formatter&lt;/code&gt; 一起使用，并调用 &lt;code&gt;flush_str_formatter&amp;nbsp;()&lt;/code&gt; 获得最终结果。</target>
        </trans-unit>
        <trans-unit id="1d2984bfe0a6d541921bf01ae808e7774f69005e" translate="yes" xml:space="preserve">
          <source>In case the shared library produced with -output-obj is to be loaded and unloaded repeatedly by a single process, care must be taken to unload the OCaml runtime explicitly, in order to avoid various system resource leaks.</source>
          <target state="translated">如果用-output-obj产生的共享库要被一个进程反复加载和卸载,必须注意显式卸载OCaml运行时,以避免各种系统资源泄露。</target>
        </trans-unit>
        <trans-unit id="44b7cbadbf1b0a98e780a49d929bc95e7c7a1618" translate="yes" xml:space="preserve">
          <source>In conclusion: dynamic linking is highly recommended under the native Windows port, because there are no portability problems and it is much more convenient for the end users. Under Unix, dynamic linking should be considered for mature, frequently used libraries because it enhances platform-independence of bytecode executables. For new or rarely-used libraries, static linking is much simpler to set up in a portable way.</source>
          <target state="translated">总结:在Windows原生移植下,强烈推荐使用动态链接,因为不存在可移植性问题,而且对最终用户来说更方便。在Unix下,对于成熟的、经常使用的库,应该考虑使用动态链接,因为它增强了字节码可执行文件的平台独立性。对于新的或很少使用的库,静态链接的设置要简单得多,便于移植。</target>
        </trans-unit>
        <trans-unit id="d29d579e5fcb07ee03fdf350892fb2426fe79f73" translate="yes" xml:space="preserve">
          <source>In earlier versions of OCaml, it was possible to use word-aligned pointers to addresses outside the heap as OCaml values, just by casting the pointer to type value. Starting with OCaml 4.11, this usage is deprecated and will stop being supported in OCaml 5.00.</source>
          <target state="translated">在OCaml的早期版本中,可以使用字对齐的指向堆外地址的指针作为OCaml值,只需将指针投向类型值即可。从OCaml 4.11开始,这种用法被废弃,并将在OCaml 5.00中停止支持。</target>
        </trans-unit>
        <trans-unit id="93d3688e1bbb7be44366be8e265ab0e92df16094" translate="yes" xml:space="preserve">
          <source>In error recovery mode, the parser discards states from the stack until it reaches a place where the error token can be shifted. It then discards tokens from the input until it finds three successive tokens that can be accepted, and starts processing with the first of these. If no state can be uncovered where the error token can be shifted, then the parser aborts by raising the Parsing.Parse_error exception.</source>
          <target state="translated">在错误恢复模式下,解析器从堆栈中丢弃状态,直到它到达一个可以转移错误令牌的地方。然后,它从输入中丢弃令牌,直到找到三个可以接受的连续令牌,并从其中的第一个开始处理。如果没有发现可以转移错误标记的状态,那么解析器就会通过引发Parsing.Parse_error异常来中止。</target>
        </trans-unit>
        <trans-unit id="0052f286e501146744357d1f715c84752a4801d2" translate="yes" xml:space="preserve">
          <source>In fact, Oo.copy p will behave as p#copy assuming that a public method copy with body {&amp;lt; &amp;gt;} has been defined in the class of p.</source>
          <target state="translated">实际上，假设在p类中定义了带有主体{&amp;lt;&amp;gt;}的公共方法副本，Oo.copy p的行为将与p＃copy相同。</target>
        </trans-unit>
        <trans-unit id="1dff7b1c599aa9378d80644ce26ec235912280ac" translate="yes" xml:space="preserve">
          <source>In general, the module expression (val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) cannot be used in the body of a functor, because this could cause unsoundness in conjunction with applicative functors. Since OCaml 4.02, this is relaxed in two ways: if &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; does not contain nominal type declarations (&lt;em&gt;i.e.&lt;/em&gt; types that are created with a proper identity), then this expression can be used anywhere, and even if it contains such types it can be used inside the body of a generative functor, described in section &amp;zwj;&lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;8.15&lt;/a&gt;. It can also be used anywhere in the context of a local module binding letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=(val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;)in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">通常，模块表达式（val &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）不能在函子的主体中使用，因为这可能与应用函子一起导致不健全。从OCaml 4.02开始，可以通过两种方式放宽此条件：如果&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;不包含名义上的类型声明（&lt;em&gt;即&lt;/em&gt;，使用适当身份创建的类型），则此表达式可以在任何地方使用，即使包含此类类型，一个生成函子的主体内被使用，在部分中描述&lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;8.15&lt;/a&gt;。也可以在本地模块绑定上下文中的任何地方使用letmodule &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; =（val &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）in&lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="88b998217306cf98a0431358725952a2c40a0011" translate="yes" xml:space="preserve">
          <source>In general, the module expression (val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) cannot be used in the body of a functor, because this could cause unsoundness in conjunction with applicative functors. Since OCaml 4.02, this is relaxed in two ways: if &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; does not contain nominal type declarations (&lt;em&gt;i.e.&lt;/em&gt; types that are created with a proper identity), then this expression can be used anywhere, and even if it contains such types it can be used inside the body of a generative functor, described in section &lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;8.15&lt;/a&gt;. It can also be used anywhere in the context of a local module binding letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=(val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;)in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">通常，模块表达式（val &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）不能在函子的主体中使用，因为这可能与应用函子一起导致不健全。从OCaml 4.02开始，可以通过两种方式放宽此条件：如果&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;不包含名义上的类型声明（&lt;em&gt;即&lt;/em&gt;，使用适当标识创建的类型），则此表达式可以在任何地方使用，即使它包含此类类型，也可以如第&lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;8.15&lt;/a&gt;节所述，可在生殖功能器的体内使用。也可以在本地模块绑定上下文中的任何地方使用letmodule &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; =（val &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）in&lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="e5c98ff88089f23a3d0986fcd57f4fffdbd72c5c" translate="yes" xml:space="preserve">
          <source>In last resort, if there is not enough information to disambiguate between different fields or constructors, Ocaml picks the last defined type amongst all locally valid choices:</source>
          <target state="translated">最后,如果没有足够的信息来区分不同的字段或构造函数,Ocaml会在所有本地有效的选择中选择最后定义的类型。</target>
        </trans-unit>
        <trans-unit id="d6bffcb3669ad49ba8135b0e8be4c55178bd1806" translate="yes" xml:space="preserve">
          <source>In many places, OCaml makes a distinction between capitalized identifiers and identifiers that begin with a lowercase letter. The underscore character is considered a lowercase letter for this purpose.</source>
          <target state="translated">在许多地方,OCaml对大写标识符和以小写字母开头的标识符进行了区分。为此,下划线字符被认为是小写字母。</target>
        </trans-unit>
        <trans-unit id="216e9b10a826eed18b60a2c7b92a349ea1836a4e" translate="yes" xml:space="preserve">
          <source>In method m1, o must be an object with at least a method n1, itself polymorphic. In method m2, the argument of n2 and x must have the same type, which is quantified at the same level as 'a.</source>
          <target state="translated">在方法m1中,o必须是一个对象,至少有一个方法n1,本身是多态的。在方法m2中,n2和x的参数必须具有相同的类型,它与'a在同一层次上被量化。</target>
        </trans-unit>
        <trans-unit id="a4879ead4b7fe51c64df3dc284efd5b46cf97cbb" translate="yes" xml:space="preserve">
          <source>In more detail, at each call site the following procedure is followed:</source>
          <target state="translated">更详细地说,在每个呼叫点,都要遵循以下程序。</target>
        </trans-unit>
        <trans-unit id="e4a5218af84a08375004a9b8c8f30976425e0ea1" translate="yes" xml:space="preserve">
          <source>In native code this function does not allocate.</source>
          <target state="translated">在原生代码中,这个函数不进行分配。</target>
        </trans-unit>
        <trans-unit id="46e607d66b5b324deff28adfb00c36b67e461bd5" translate="yes" xml:space="preserve">
          <source>In normal operation, a mixed OCaml/C program starts by executing the OCaml initialization code, which then may proceed to call C functions. We say that the main program is the OCaml code. In some applications, it is desirable that the C code plays the role of the main program, calling OCaml functions when needed. This can be achieved as follows:</source>
          <target state="translated">在正常的操作中,一个OCaml/C混合程序的开始是执行OCaml初始化代码,然后可能继续调用C函数。我们说,主程序就是OCaml代码。在某些应用中,希望C代码扮演主程序的角色,在需要时调用OCaml函数。这可以通过以下方式实现。</target>
        </trans-unit>
        <trans-unit id="5d6c0bbded532eaac460fed9f095eb72cfd28e5f" translate="yes" xml:space="preserve">
          <source>In order to be able to run the garbage collector in the middle of a C function, the OCaml native-code compiler generates some bookkeeping code around C calls. Technically it wraps every C call with the C function caml_c_call which is part of the OCaml runtime.</source>
          <target state="translated">为了能够在C函数中间运行垃圾回收器,OCaml原生代码编译器围绕C调用生成一些记账代码。从技术上讲,它用C函数caml_c_call包装每一个C调用,这是OCaml运行时的一部分。</target>
        </trans-unit>
        <trans-unit id="705f0d7e5ce98c35ddf45a8b90e4166d527197ef" translate="yes" xml:space="preserve">
          <source>In order to properly delimit printed entities, a semantic tag must be opened before and closed after the entity. Semantic tags must be properly nested like parentheses using &lt;a href=&quot;format#VALpp_open_stag&quot;&gt;&lt;code&gt;Format.pp_open_stag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format#VALpp_close_stag&quot;&gt;&lt;code&gt;Format.pp_close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">为了正确界定打印的实体，必须在实体之前打开语义标签，并在实体之后关闭语义标签。必须使用&lt;a href=&quot;format#VALpp_open_stag&quot;&gt; &lt;code&gt;Format.pp_open_stag&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;format#VALpp_close_stag&quot;&gt; &lt;code&gt;Format.pp_close_stag&lt;/code&gt; &lt;/a&gt;像括号一样正确嵌套语义标签。</target>
        </trans-unit>
        <trans-unit id="8dffd84c29fa25251b21a64eafa4ff535e46c794" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;Array1.init&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;dimensions&amp;nbsp;f&lt;/code&gt; tabulates the results of &lt;code&gt;f&lt;/code&gt; applied to the indices of a new Bigarray whose layout is described by &lt;code&gt;kind&lt;/code&gt;, &lt;code&gt;layout&lt;/code&gt; and &lt;code&gt;dim&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;Array1.init&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;dimensions&amp;nbsp;f&lt;/code&gt; 制成表格的结果 &lt;code&gt;f&lt;/code&gt; 施加到一个新的Bigarray其布局是由描述的索引 &lt;code&gt;kind&lt;/code&gt; ， &lt;code&gt;layout&lt;/code&gt; 和 &lt;code&gt;dim&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e659cdbb6e3145e3071099d7ceb87a59c58f10" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;Array2.init&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;dim1&amp;nbsp;dim2&amp;nbsp;f&lt;/code&gt; tabulates the results of &lt;code&gt;f&lt;/code&gt; applied to the indices of a new Bigarray whose layout is described by &lt;code&gt;kind&lt;/code&gt;, &lt;code&gt;layout&lt;/code&gt;, &lt;code&gt;dim1&lt;/code&gt; and &lt;code&gt;dim2&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;Array2.init&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;dim1&amp;nbsp;dim2&amp;nbsp;f&lt;/code&gt; 制成表格的结果 &lt;code&gt;f&lt;/code&gt; 施加到一个新的Bigarray其布局是由描述的索引 &lt;code&gt;kind&lt;/code&gt; ， &lt;code&gt;layout&lt;/code&gt; ， &lt;code&gt;dim1&lt;/code&gt; 和 &lt;code&gt;dim2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="882bb8ff27cc09b8b5ebfa7b015a5e24402b7b01" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;Array3.init&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;dim1&amp;nbsp;dim2&amp;nbsp;dim3&amp;nbsp;f&lt;/code&gt; tabulates the results of &lt;code&gt;f&lt;/code&gt; applied to the indices of a new Bigarray whose layout is described by &lt;code&gt;kind&lt;/code&gt;, &lt;code&gt;layout&lt;/code&gt;, &lt;code&gt;dim1&lt;/code&gt;, &lt;code&gt;dim2&lt;/code&gt; and &lt;code&gt;dim3&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;Array3.init&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;dim1&amp;nbsp;dim2&amp;nbsp;dim3&amp;nbsp;f&lt;/code&gt; 制成表格的结果 &lt;code&gt;f&lt;/code&gt; 施加到一个新的Bigarray其布局是由描述的索引 &lt;code&gt;kind&lt;/code&gt; ， &lt;code&gt;layout&lt;/code&gt; ， &lt;code&gt;dim1&lt;/code&gt; ， &lt;code&gt;dim2&lt;/code&gt; 和 &lt;code&gt;dim3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c99bae7df15a0847fae04eb1c0499dc97289ad36" translate="yes" xml:space="preserve">
          <source>In other words, x :&amp;gt; xy implies that x list :&amp;gt; xy list, therefore the type constructor 'a list is covariant (it preserves subtyping) in its parameter 'a.</source>
          <target state="translated">换句话说，x：&amp;gt; xy表示x list：&amp;gt; xy list，因此类型构造函数'a list在其参数'a中是协变的（保留子类型）。</target>
        </trans-unit>
        <trans-unit id="b5f46ca739529e04a39f1aab5af3dba32a684971" translate="yes" xml:space="preserve">
          <source>In particular this multi-index notation makes it possible to uniformly handle indexing Genarray and other implementations of multidimensional arrays.</source>
          <target state="translated">特别是这种多索引符号使得统一处理Genarray和其他多维数组的实现索引成为可能。</target>
        </trans-unit>
        <trans-unit id="a865a9ad74cc8a2373c2665d5012b07fb6e3a718" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;partition_map&amp;nbsp;(fun&amp;nbsp;x&amp;nbsp;-&amp;gt;&amp;nbsp;if&amp;nbsp;f&amp;nbsp;x&amp;nbsp;then&amp;nbsp;Left&amp;nbsp;x&amp;nbsp;else&amp;nbsp;Right&amp;nbsp;x)&amp;nbsp;l&lt;/code&gt; is equivalent to &lt;code&gt;partition&amp;nbsp;f&amp;nbsp;l&lt;/code&gt;.</source>
          <target state="translated">特别是， &lt;code&gt;partition_map&amp;nbsp;(fun&amp;nbsp;x&amp;nbsp;-&amp;gt;&amp;nbsp;if&amp;nbsp;f&amp;nbsp;x&amp;nbsp;then&amp;nbsp;Left&amp;nbsp;x&amp;nbsp;else&amp;nbsp;Right&amp;nbsp;x)&amp;nbsp;l&lt;/code&gt; 等效于 &lt;code&gt;partition&amp;nbsp;f&amp;nbsp;l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0aab86acd922ebcbea9163dc56fc9283939f580d" translate="yes" xml:space="preserve">
          <source>In particular, Main can refer to Aux: the definitions and declarations contained in Main.ml and Main.mli can refer to definition in Aux.ml, using the Aux.ident notation, provided these definitions are exported in Aux.mli.</source>
          <target state="translated">特别是,Main可以引用Aux:Main.ml和Main.mli中包含的定义和声明可以引用Aux.ml中的定义,使用Aux.ident符号,条件是这些定义是以Aux.mli导出的。</target>
        </trans-unit>
        <trans-unit id="ae0710f72489debbe41f038cbacd70ca72e1c4ed" translate="yes" xml:space="preserve">
          <source>In particular, all built-in exceptions with a string argument have this attribute set: Invalid_argument, Failure, Sys_error will all raise this warning if you match for a specific string argument.</source>
          <target state="translated">特别是,所有内置的带有字符串参数的异常都设置了这个属性。Invalid_argument,Failure,Sys_error都会发出这样的警告 如果你匹配到一个特定的字符串参数的话</target>
        </trans-unit>
        <trans-unit id="b074470bc685e81d978d3c12fec323bc92cacce4" translate="yes" xml:space="preserve">
          <source>In particular, if you want a regular expression that matches a single backslash character, you need to quote it in the argument to &lt;code&gt;regexp&lt;/code&gt; (according to the last item of the list above) by adding a second backslash. Then you need to quote both backslashes (according to the syntax of string constants in OCaml) by doubling them again, so you need to write four backslash characters: &lt;code&gt;Str.regexp&amp;nbsp;&quot;\\\\&quot;&lt;/code&gt;.</source>
          <target state="translated">特别是，如果您想要一个与单个反斜杠字符匹配的正则表达式，则需要通过添加第二个反斜杠在 &lt;code&gt;regexp&lt;/code&gt; 的参数中对其进行引用（根据上面列表的最后一项）。然后，您需要通过再次将它们加倍来引用两个反斜杠（根据OCaml中的字符串常量的语法），因此您需要编写四个反斜杠字符： &lt;code&gt;Str.regexp&amp;nbsp;&quot;\\\\&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7e072637e54b00ab8fa95f737650edcfbf010b" translate="yes" xml:space="preserve">
          <source>In particular, it is forbidden to change any value (for example using Obj.set_field or Obj.set_tag) that is not mutable. (Values returned from C stubs are always treated as mutable.) The compiler will emit warning 59 if it detects such a write&amp;mdash;but it cannot warn in all cases. Here is an example of code that will trigger the warning:</source>
          <target state="translated">特别是，禁止更改任何不可更改的值（例如，使用Obj.set_field或Obj.set_tag）。（从C存根返回的值始终被视为可变的。）如果编译器检测到这样的写操作，则它将发出警告59，但不能在所有情况下发出警告。这是将触发警告的代码示例：</target>
        </trans-unit>
        <trans-unit id="ade5ca771cb6e9b09d87215a726868aac65e1c3f" translate="yes" xml:space="preserve">
          <source>In particular, this does not require the knowledge of the implementation of the method deposit.</source>
          <target state="translated">尤其是,这不需要知道方法存款的实施。</target>
        </trans-unit>
        <trans-unit id="a5fc135baac0c5f362e717cdfa21fa7d3c9fdb0d" translate="yes" xml:space="preserve">
          <source>In practice, first define a symbolic output buffer &lt;code&gt;b&lt;/code&gt; using:</source>
          <target state="translated">实际上，首先使用以下命令定义符号输出缓冲区 &lt;code&gt;b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="071912257bcdf51deb295b9dfc5fee29b88e66d1" translate="yes" xml:space="preserve">
          <source>In practice, such problems appear mostly when using objects whose methods have optional arguments, so that writing the type of object arguments is often a good idea.</source>
          <target state="translated">在实践中,这样的问题多出现在使用方法有可选参数的对象时,因此,写出对象参数的类型往往是一个好主意。</target>
        </trans-unit>
        <trans-unit id="231cbc44094ac9d8485720744f05b0f46784e83e" translate="yes" xml:space="preserve">
          <source>In practice, type inference is a bit more clever than that: type annotations do not need to be immediately on the pattern-matching, and the types do not have to be always closed. As a result, it is usually enough to only annotate functions, as in the example above. Type annotations are propagated in two ways: for the scrutinee, they follow the flow of type inference, in a way similar to polymorphic methods; for the return type, they follow the structure of the program, they are split on functions, propagated to all branches of a pattern matching, and go through tuples, records, and sum types. Moreover, the notion of ambiguity used is stronger: a type is only seen as ambiguous if it was mixed with incompatible types (equated by constraints), without type annotations between them. For instance, the following program types correctly.</source>
          <target state="translated">在实践中,类型推理比这更聪明一些:类型注释不需要立即在模式匹配上,类型也不需要总是封闭的。因此,通常只对函数进行注释就可以了,就像上面的例子一样。类型注释的传播方式有两种:对于被审查者来说,它们遵循类型推理的流程,类似于多态方法;对于返回类型来说,它们遵循程序的结构,它们在函数上被拆分,传播到模式匹配的所有分支,并经过tuple、记录和类型。此外,使用的模糊性概念更强:只有当一个类型与不兼容的类型混合在一起(由约束条件等价),它们之间没有类型注释时,才会被视为模糊性。例如,以下程序类型正确的是。</target>
        </trans-unit>
        <trans-unit id="b4ec2dc15612b4e9552fe86a4c1e5b9778f4b360" translate="yes" xml:space="preserve">
          <source>In practice, unique ownership of string values is extremely difficult to reason about correctly. You should always assume strings are shared, never uniquely owned.</source>
          <target state="translated">在实践中,字符串值的唯一所有权是极难正确推理的。你应该始终假设字符串是共享的,绝不是唯一拥有的。</target>
        </trans-unit>
        <trans-unit id="675c86cc7771a8adaaf8916ec39061e81a549695" translate="yes" xml:space="preserve">
          <source>In presence of a refutation case, the exhaustiveness check will first compute the intersection of the pattern with the complement of the cases preceding it. It then checks whether the resulting patterns can really match any concrete values by trying to type-check them. Wild cards in the generated patterns are handled in a special way: if their type is a variant type with only GADT constructors, then the pattern is split into the different constructors, in order to check whether any of them is possible (this splitting is not done for arguments of these constructors, to avoid non-termination). We also split tuples and variant types with only one case, since they may contain GADTs inside. For instance, the following code is deemed exhaustive:</source>
          <target state="translated">在存在反驳情况下,穷尽性检查将首先计算模式与前面的情况补全的交集。然后,它通过尝试对它们进行类型检查来检查生成的模式是否真的可以匹配任何具体的值。生成的模式中的通配符会以一种特殊的方式处理:如果它们的类型是只有 GADT 构造函数的变体类型,那么模式会被分割成不同的构造函数,以检查它们中是否有任何一个是可能的(对于这些构造函数的参数,这种分割不会进行,以避免非终止)。我们还对只有一种情况的元组和变体类型进行拆分,因为它们内部可能包含GADT。例如,下面的代码被认为是详尽的。</target>
        </trans-unit>
        <trans-unit id="5162e7ccdac1a4d75bd7ab724a1804dfb5ac71c9" translate="yes" xml:space="preserve">
          <source>In programs, polymorphic variants work like usual ones. You just have to prefix their names with a backquote character `.</source>
          <target state="translated">在程序中,多态变体和普通变体一样工作。你只需要在它们的名字前加上一个反引号字符`。</target>
        </trans-unit>
        <trans-unit id="8e52f850e1e21d53f51e85e344a1dc361b2df51a" translate="yes" xml:space="preserve">
          <source>In rare cases, it is useful to control the amount of instrumentation generated. By passing the -afl-inst-ratio N argument to ocamlopt with N less than 100, instrumentation can be generated for only N% of branches. (See the afl-fuzz documentation on the parameter AFL_INST_RATIO for the precise effect of this).</source>
          <target state="translated">在极少数情况下,控制生成的仪表量是很有用的。通过将 -afl-inst-ratio N 参数传递给 ocamlopt,当 N 小于 100 时,可以只为 N% 的分支生成文书。(具体效果请参考 afl-fuzz 文档中关于参数 afl_INST_RATIO 的说明)。</target>
        </trans-unit>
        <trans-unit id="34098be7f93d78af7d951548f23b26575531f537" translate="yes" xml:space="preserve">
          <source>In script mode, the directory containing the script currently executing; in interactive mode, the current working directory.</source>
          <target state="translated">在脚本模式下,是包含当前正在执行的脚本的目录;在交互模式下,是当前的工作目录。</target>
        </trans-unit>
        <trans-unit id="0910a7b3a20b997c573d806f5d3f327bd2180db6" translate="yes" xml:space="preserve">
          <source>In script mode, the first line of the script is ignored if it starts with #!. Thus, it should be possible to make the script itself executable and put as first line #!/usr/local/bin/ocaml, thus calling the toplevel system automatically when the script is run. However, ocaml itself is a #! script on most installations of OCaml, and Unix kernels usually do not handle nested #! scripts. A better solution is to put the following as the first line of the script:</source>
          <target state="translated">在脚本模式下,如果脚本的第一行以#!开头,则会被忽略。因此,应该可以将脚本本身做成可执行的,并将其作为第一行#!/usr/local/bin/ocaml,从而在脚本运行时自动调用toplevel系统。但是,在大多数OCaml的安装中,ocaml本身是一个#!脚本,而Unix内核通常不会处理嵌套的#!脚本。一个更好的解决方案是把下面的内容作为脚本的第一行。</target>
        </trans-unit>
        <trans-unit id="b3ca139fc0e78af6203d9e577fcd6f73d39da1eb" translate="yes" xml:space="preserve">
          <source>In short, a conversion specification consists in the &lt;code&gt;%&lt;/code&gt; character, followed by optional modifiers and a type which is made of one or two characters.</source>
          <target state="translated">简而言之，转换规范由 &lt;code&gt;%&lt;/code&gt; 字符组成，后跟可选修饰符和由一个或两个字符组成的类型。</target>
        </trans-unit>
        <trans-unit id="dfc44adbe1d76bbb9087ab9eb6bae00365f83692" translate="yes" xml:space="preserve">
          <source>In some cases, a successful match may not yield a unique set of bindings. For instance the matching of &lt;code&gt;aba&lt;/code&gt; by the regular expression (('a'|&quot;ab&quot;) as x) ((&quot;ba&quot;|'a') as y) may result in binding either &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;&quot;ab&quot;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&quot;a&quot;&lt;/code&gt;, or &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&quot;ba&quot;&lt;/code&gt;. The automata produced ocamllex on such ambiguous regular expressions will select one of the possible resulting sets of bindings. The selected set of bindings is purposely left unspecified.</source>
          <target state="translated">在某些情况下，成功的匹配可能不会产生唯一的绑定集。例如，用正则表达式（（''a'|&amp;ldquo; ab&amp;rdquo;）如x）（{（ba&amp;ldquo; |'a'）如y）匹配 &lt;code&gt;aba&lt;/code&gt; 可能导致将 &lt;code&gt;x&lt;/code&gt; 绑定到 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; ，将 &lt;code&gt;y&lt;/code&gt; 绑定到 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ，或者 &lt;code&gt;x&lt;/code&gt; 表示 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 表示 &lt;code&gt;&quot;ba&quot;&lt;/code&gt; 。在这种模棱两可的正则表达式上自动生成的ocamllex将选择可能的绑定结果集之一。故意将选定的绑定集设为未指定。</target>
        </trans-unit>
        <trans-unit id="5e5f8acb11224ef16504bf821b1a4f3846e25f8a" translate="yes" xml:space="preserve">
          <source>In some cases, it is hard to understand why the two types t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;2&lt;/sub&gt; are incompatible. For instance, the compiler can report that &amp;ldquo;expression of type foo cannot be used with type foo&amp;rdquo;, and it really seems that the two types foo are compatible. This is not always true. Two type constructors can have the same name, but actually represent different types. This can happen if a type constructor is redefined. Example:</source>
          <target state="translated">在某些情况下，很难理解为什么两种类型的t &lt;sub&gt;1&lt;/sub&gt;和t &lt;sub&gt;2&lt;/sub&gt;不兼容。例如，编译器可以报告&amp;ldquo;不能将foo类型的表达式与foo类型一起使用&amp;rdquo;，实际上这两个foo类型似乎是兼容的。这并非总是如此。两个类型构造函数可以具有相同的名称，但实际上表示不同的类型。如果重新定义类型构造函数，则可能会发生这种情况。例子：</target>
        </trans-unit>
        <trans-unit id="79e640798597484a7600545dc82e4c33ed1a5752" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to turn reverse execution off. This speeds up the program execution, and is also sometimes useful for interactive programs.</source>
          <target state="translated">在某些情况下,你可能想关闭反向执行。这样可以加快程序的执行速度,有时对交互式程序也很有用。</target>
        </trans-unit>
        <trans-unit id="72952c8f05afa090a6398eb7a7e68cd59e600681" translate="yes" xml:space="preserve">
          <source>In some special cases, you may need to store a polymorphic function in a data structure, keeping its polymorphism. Doing this requires user-provided type annotations, since polymorphism is only introduced automatically for global definitions. However, you can explicitly give polymorphic types to record fields.</source>
          <target state="translated">在一些特殊情况下,您可能需要将一个多态函数存储在数据结构中,并保留其多态性。这样做需要用户提供类型注释,因为多态性只对全局定义自动引入。但是,你可以明确地给记录字段赋予多态类型。</target>
        </trans-unit>
        <trans-unit id="7d8bd8bd0c73e5581100c0f0fdc21cf6dc82fc9c" translate="yes" xml:space="preserve">
          <source>In terms of char_os, both functions take an argument of type char_os * and return a result of the same type. We begin by choosing the right implementation of the function to bind:</source>
          <target state="translated">就char_os而言,两个函数都接受一个类型为char_os *的参数,并返回一个相同类型的结果。我们首先要选择正确的函数实现来进行绑定。</target>
        </trans-unit>
        <trans-unit id="922859d863be18c8537dbf92ff8a561e25d814f1" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;custom runtime&amp;rdquo; mode, the OCaml linker scans the object files and determines the set of required primitives. Then, it builds a suitable runtime system, by calling the native code linker with:</source>
          <target state="translated">在&amp;ldquo;自定义运行时&amp;rdquo;模式下，OCaml链接程序将扫描目标文件并确定所需的原语集。然后，通过调用以下代码的本机代码链接器，构建合适的运行时系统：</target>
        </trans-unit>
        <trans-unit id="ad74914aa0f5096cdf7ded3e98edc3fa9085e8eb" translate="yes" xml:space="preserve">
          <source>In the C-style layout, array indices start at 0, and multi-dimensional arrays are laid out in row-major format. That is, for a two-dimensional array, all elements of row 0 are contiguous in memory, followed by all elements of row 1, etc. In other terms, the array elements at &lt;code&gt;(x,y)&lt;/code&gt; and &lt;code&gt;(x,&amp;nbsp;y+1)&lt;/code&gt; are adjacent in memory.</source>
          <target state="translated">在C样式的布局中，数组索引从0开始，多维数组以行优先格式进行布局。也就是说，对于二维数组，行0的所有元素在内存中是连续的，随后是行1的所有元素，依此类推。换句话说，数组元素在 &lt;code&gt;(x,y)&lt;/code&gt; 和 &lt;code&gt;(x,&amp;nbsp;y+1)&lt;/code&gt; 在内存中相邻。</target>
        </trans-unit>
        <trans-unit id="726cf9559718642bb4a9ce924e67bf43e58f9a8d" translate="yes" xml:space="preserve">
          <source>In the Fortran-style layout, array indices start at 1, and multi-dimensional arrays are laid out in column-major format. That is, for a two-dimensional array, all elements of column 0 are contiguous in memory, followed by all elements of column 1, etc. In other terms, the array elements at &lt;code&gt;(x,y)&lt;/code&gt; and &lt;code&gt;(x+1,&amp;nbsp;y)&lt;/code&gt; are adjacent in memory.</source>
          <target state="translated">在Fortran样式的布局中，数组索引从1开始，而多维数组以列主格式进行布局。也就是说，对于二维数组，列0的所有元素在内存中是连续的，列1的所有元素在其后，依此类推。换句话说，数组元素在 &lt;code&gt;(x,y)&lt;/code&gt; 和 &lt;code&gt;(x+1,&amp;nbsp;y)&lt;/code&gt; 在内存中相邻。</target>
        </trans-unit>
        <trans-unit id="f15460569b3a60b9b987dcfbbdfd52711922333e" translate="yes" xml:space="preserve">
          <source>In the absence of meaningful comment on the last constructor of a type, an empty comment &amp;zwj;(**) can be used instead:</source>
          <target state="translated">如果没有对类型的最后一个构造函数进行有意义的注释，则可以使用空注释&amp;zwj;（**）代替：</target>
        </trans-unit>
        <trans-unit id="e2cea060daca649c697673805c9646270333dad7" translate="yes" xml:space="preserve">
          <source>In the absence of meaningful comment on the last constructor of a type, an empty comment (**) can be used instead:</source>
          <target state="translated">如果一个类型的最后一个构造函数没有意义的注释,可以使用空注释(**)代替。</target>
        </trans-unit>
        <trans-unit id="f44983950ca3c3197004ea73c999cd5259f3070f" translate="yes" xml:space="preserve">
          <source>In the case of variant constructors or record field, the constructor or field name should be preceded by the name of the correspond type &amp;ndash; to avoid the ambiguity of several types having the same constructor names. For example, the constructor Node of the type tree will be referenced as {!tree.Node} or {!const:tree.Node}, or possibly {!Mod1.Mod2.tree.Node} from outside the module.</source>
          <target state="translated">对于变型构造函数或记录字段，应在构造函数或字段名称之前加上对应类型的名称-以避免具有相同构造函数名称的几种类型的歧义。例如，类型树的构造函数Node将在模块外部被引用为{！tree.Node}或{！const：tree.Node}，或者可能是{！Mod1.Mod2.tree.Node}。</target>
        </trans-unit>
        <trans-unit id="e1533d03df2a92eef93b15786474fc6f9f0fc618" translate="yes" xml:space="preserve">
          <source>In the default mode, the OCaml linker produces bytecode for the standard runtime system, with a standard set of primitives. References to primitives that are not in this standard set result in the &amp;ldquo;unavailable C primitive&amp;rdquo; error. (Unless dynamic loading of C libraries is supported &amp;ndash; see section &amp;zwj;&lt;a href=&quot;#ss%3Adynlink-c-code&quot;&gt;18.1.4&lt;/a&gt; below.)</source>
          <target state="translated">在默认模式下，OCaml链接器会为标准运行时系统生成字节码，并带有一组标准原语。引用不在此标准集中的原语会导致&amp;ldquo;不可用的C原语&amp;rdquo;错误。（除非被支撑C库的动态加载-见&lt;a href=&quot;#ss%3Adynlink-c-code&quot;&gt;18.1.4&lt;/a&gt;下文）。</target>
        </trans-unit>
        <trans-unit id="f10b0cb476350af30f28ed8856736d1b9672116b" translate="yes" xml:space="preserve">
          <source>In the default mode, the OCaml linker produces bytecode for the standard runtime system, with a standard set of primitives. References to primitives that are not in this standard set result in the &amp;ldquo;unavailable C primitive&amp;rdquo; error. (Unless dynamic loading of C libraries is supported &amp;ndash; see section &lt;a href=&quot;#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt; below.)</source>
          <target state="translated">在默认模式下，OCaml链接器会为标准运行时系统生成字节码，并带有一组标准原语。引用不在此标准集中的原语会导致&amp;ldquo;不可用的C原语&amp;rdquo;错误。（除非支持动态加载C库-参见下面的&lt;a href=&quot;#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt;节。）</target>
        </trans-unit>
        <trans-unit id="ada7794c2f0108a93984c8df43895634c9cecfad" translate="yes" xml:space="preserve">
          <source>In the description of a value, type, exception, module, module type, class or class type, the &lt;em&gt;first sentence&lt;/em&gt; is sometimes used in indexes, or when just a part of the description is needed. The first sentence is composed of the first characters of the description, until</source>
          <target state="translated">在对值，类型，异常，模块，模块类型，类或类类型的描述中，有时在索引中使用&lt;em&gt;第一句&lt;/em&gt;，或者仅在描述的一部分时使用。第一个句子由描述的第一个字符组成，直到</target>
        </trans-unit>
        <trans-unit id="f380b30f7f2a3bd63aab448ca63ae784823c0a52" translate="yes" xml:space="preserve">
          <source>In the first example, (r:first_record) is an explicit annotation telling OCaml that the type of r is first_record. With this annotation, Ocaml knows that r.x refers to the x field of the first record type. Similarly, the type annotation in the second example makes it clear to OCaml that the constructors A, B and C come from the first variant type. Contrarily, in the last example, OCaml has inferred by itself that the type of r can only be first_record and there are no needs for explicit type annotations.</source>
          <target state="translated">在第一个例子中,(r:first_record)是一个显式注解,告诉OCaml r的类型是first_record。有了这个注解,Ocaml知道r.x指的是第一个记录类型的x字段。同样,第二个例子中的类型注解让OCaml清楚地知道构造函数A、B和C来自第一变体类型。相反,在最后一个例子中,OCaml已经自己推断出r的类型只能是first_record,不需要明确的类型注释。</target>
        </trans-unit>
        <trans-unit id="72414e01b80ae620788634a295dac8455ca20b7c" translate="yes" xml:space="preserve">
          <source>In the following code (which might typically occur when g is too large to inline) the value of x would usually be communicated to the application of the + function via the closure of g.</source>
          <target state="translated">在下面的代码中(通常会出现在g太大而无法内联的情况下),x的值通常会通过g的闭包传达给+函数的应用。</target>
        </trans-unit>
        <trans-unit id="d393b54aa4ad994d5181f438481ee687fee1c9c4" translate="yes" xml:space="preserve">
          <source>In the following code, the compiler observes that the closure returned from the function f contains a variable pair (free in the body of f) that may be split into two separate variables.</source>
          <target state="translated">在下面的代码中,编译器观察到从函数f返回的闭包中包含了一个变量对(在f的主体中是自由的),这个变量对可能被分割成两个独立的变量。</target>
        </trans-unit>
        <trans-unit id="7bc6fdbc296fa731282af07ad9f312e34ebb596f" translate="yes" xml:space="preserve">
          <source>In the following code, there are two closure variables that would typically cause closure allocations. One is called fv and occurs inside the function baz; the other is called z and occurs inside the function bar. In this toy (yet sophisticated) example we again use an attribute to simulate the typical situation where the first argument of baz is too large to inline.</source>
          <target state="translated">在下面的代码中,有两个闭包变量通常会引起闭包分配。一个叫做fv,发生在函数baz里面;另一个叫做z,发生在函数bar里面。在这个玩具(但又很复杂)的例子中,我们再次使用一个属性来模拟典型的情况,即 baz 的第一个参数太大,无法内联。</target>
        </trans-unit>
        <trans-unit id="721fe5ea332cbc9570673fd6bb094c20e430f05a" translate="yes" xml:space="preserve">
          <source>In the ideal, the right function name with right labels should be enough to understand the function&amp;rsquo;s meaning. Since one can get this information with OCamlBrowser or the ocaml toplevel, the documentation is only used when a more detailed specification is needed.</source>
          <target state="translated">理想情况下，带有正确标签的正确函数名称应足以理解函数的含义。由于可以使用OCamlBrowser或ocaml顶层获取此信息，因此仅在需要更详细的规范时才使用该文档。</target>
        </trans-unit>
        <trans-unit id="2d0067298cd5d40acc2465837dd4dda28acd2d1e" translate="yes" xml:space="preserve">
          <source>In the object-oriented version of sets, we only need to add an additional method tag to return the representation of a set. Since sets are parametric in the type of elements, the method tag has a parametric type 'a tag, concrete within the module definition but abstract in its signature. From outside, it will then be guaranteed that two objects with a method tag of the same type will share the same representation.</source>
          <target state="translated">在面向对象版本的set中,我们只需要增加一个方法标签来返回集合的表示。由于集合的元素类型是参数化的,所以方法标签的类型是参数化的'a标签,在模块定义中是具体的,但在签名中是抽象的。从外部来看,就可以保证两个具有相同类型的方法标签的对象将共享相同的表示。</target>
        </trans-unit>
        <trans-unit id="291e0dbbf80eac70186d0d4251b427b33b48b1bf" translate="yes" xml:space="preserve">
          <source>In the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.</source>
          <target state="translated">在存在多个OCaml线程的情况下,应该假定任何特定的定稿器可以在任何线程中执行。</target>
        </trans-unit>
        <trans-unit id="91ffcab04046ac0c20cbcca9068d8e573beb8496" translate="yes" xml:space="preserve">
          <source>In the return array, the slot at index &lt;code&gt;0&lt;/code&gt; corresponds to the most recent function call, raise, or primitive &lt;code&gt;get_backtrace&lt;/code&gt; call in the trace.</source>
          <target state="translated">在返回数组中，索引为 &lt;code&gt;0&lt;/code&gt; 的插槽对应于跟踪中最近的函数调用，raise或原始 &lt;code&gt;get_backtrace&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="f04d4bfc534031b19b244ea21cf28affe8b39664" translate="yes" xml:space="preserve">
          <source>In the right-hand side of type definitions, references to one of the type constructor name being defined are considered as recursive, unless type is followed by nonrec. The nonrec keyword was introduced in OCaml 4.02.2.</source>
          <target state="translated">在类型定义的右侧,对被定义的类型构造函数名称之一的引用被认为是递归的,除非type后面有nonrec。nonrec关键字是在OCaml 4.02.2中引入的。</target>
        </trans-unit>
        <trans-unit id="a5f2952289734f5793eb520f8e1b35b465c9b780" translate="yes" xml:space="preserve">
          <source>In the second form, when the body of a local open is itself delimited by parentheses, braces or bracket, the parentheses of the local open can be omitted. For instance,</source>
          <target state="translated">在第二种形式中,当局部开放的主体本身是由括号、大括号或括弧来限定的,局部开放的括号可以省略。例如:</target>
        </trans-unit>
        <trans-unit id="95d2831b55ddf61b23e5bb88d88a73ddc646b145" translate="yes" xml:space="preserve">
          <source>In the two branches of a conditional expression:</source>
          <target state="translated">在条件表达式的两个分支中。</target>
        </trans-unit>
        <trans-unit id="7637452d36fadd2ef81ce53e1a83c6e0f70ac963" translate="yes" xml:space="preserve">
          <source>In the two examples above, the list is built bottom-up. Here is an alternate way, that proceeds top-down. It is less efficient, but illustrates the use of caml_modify.</source>
          <target state="translated">在上面的两个例子中,列表是自下而上建立的。下面是另一种方法,即自上而下地进行。它的效率较低,但可以说明caml_modify的用途。</target>
        </trans-unit>
        <trans-unit id="13ef23781b1ec2de1604fab5007923acd1ad0364" translate="yes" xml:space="preserve">
          <source>In the type expression _&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; , the anonymous type expression _ stands in for anonymous type parameters and is equivalent to (_, &amp;hellip;,_) with as many repetitions of _ as the arity of &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;.</source>
          <target state="translated">在类型表达式_ &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr中&lt;/a&gt;，匿名类型表达式_代表匿名类型参数，并且等效于（_，&amp;hellip;，_），其中_的重复次数与&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr的偶数相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aeaa83fc28e0aae7a51149b7a6b03865bb7a3a40" translate="yes" xml:space="preserve">
          <source>In the type of depth, 'a.'a nested -&amp;gt; int, the type variable 'a is universally quantified. In other words, 'a.'a nested -&amp;gt; int reads as &amp;ldquo;for all type 'a, depth maps 'a nested values to integers&amp;rdquo;. Whereas the standard type 'a nested -&amp;gt; int can be interpreted as &amp;ldquo;let be a type variable 'a, then depth maps 'a nested values to integers&amp;rdquo;. There are two major differences with these two type expressions. First, the explicit polymorphic annotation indicates to the type checker that it needs to introduce a new type variable every times the function depth is applied. This solves our problem with the definition of the function depth.</source>
          <target state="translated">在深度类型'a。'a nested-&amp;gt; int中，类型变量'a被普遍量化。换句话说，&amp;ldquo; a。&amp;rdquo;嵌套-&amp;gt; int读为&amp;ldquo;对于所有类型'a，深度将'a嵌套的值映射为整数&amp;rdquo;。标准类型'a nested-&amp;gt; int可以解释为&amp;ldquo;让类型变量为'a，然后深度将'嵌套值映射为整数&amp;rdquo;。这两个类型表达式有两个主要区别。首先，显式多态注释向类型检查器指示每次应用功能深度时都需要引入一个新的类型变量。这解决了函数深度定义的问题。</target>
        </trans-unit>
        <trans-unit id="baf32ca6edcb79b806067cc323225825f9b58ce1" translate="yes" xml:space="preserve">
          <source>In this case calling bar from OCaml is as cheap as calling any other OCaml function, except for the fact that the OCaml compiler can&amp;rsquo;t inline C functions...</source>
          <target state="translated">在这种情况下，从OCaml调用bar与调用任何其他OCaml函数一样便宜，除了OCaml编译器无法内联C函数...</target>
        </trans-unit>
        <trans-unit id="f00477d2b2741ddd83a9732844ec5d63894429c4" translate="yes" xml:space="preserve">
          <source>In this case the C functions must look like:</source>
          <target state="translated">在这种情况下,C函数必须是这样的。</target>
        </trans-unit>
        <trans-unit id="46b3277155ed08f7a13b1d39181a22abf8d356af" translate="yes" xml:space="preserve">
          <source>In this case, OCamldoc will associate Bar.x to the x of module Foo defined just above, instead of to the Bar.x defined in the opened module Foo.</source>
          <target state="translated">在这种情况下,OCamldoc将把Bar.x关联到刚才定义的Foo模块的x上,而不是关联到打开的Foo模块中定义的Bar.x上。</target>
        </trans-unit>
        <trans-unit id="2c7d87e16fce5514152b5af5de0d55e2067da6ca" translate="yes" xml:space="preserve">
          <source>In this case, the function colored_point_to_point is an instance of the function to_point. This is not always true, however. The fully explicit coercion is more precise and is sometimes unavoidable. Consider, for example, the following class:</source>
          <target state="translated">在这种情况下,函数colored_point_to_point是函数to_point的一个实例。然而,这并不总是正确的。完全显式的胁迫更精确,有时是不可避免的。例如,考虑以下类。</target>
        </trans-unit>
        <trans-unit id="9a4b829ccac478d8513bb46a453a748cf8017f00" translate="yes" xml:space="preserve">
          <source>In this case, the type constructor is defined as an abbreviation for the type expression given in the equation, but in addition the constructors or fields given in the representation remain attached to the defined type constructor. The type expression in the equation part must agree with the representation: it must be of the same kind (record or variant) and have exactly the same constructors or fields, in the same order, with the same arguments. Moreover, the new type constructor must have the same arity and the same type constraints as the original type constructor.</source>
          <target state="translated">在这种情况下,类型构造函数被定义为方程中给出的类型表达式的缩写,但除此之外,表征中给出的构造函数或字段仍然附属于定义的类型构造函数。等式部分的类型表达式必须与表示法一致:它必须是相同的种类(记录或变体),并且具有完全相同的构造函数或字段,顺序相同,参数相同。此外,新的类型构造函数必须与原类型构造函数具有相同的数理和相同的类型约束。</target>
        </trans-unit>
        <trans-unit id="7bed9185f2bb4af262638e20c9572165f24df5d4" translate="yes" xml:space="preserve">
          <source>In this case, we have x :&amp;gt; xy implies xy proc :&amp;gt; x proc. Notice that the second subtyping relation reverse the order of x and xy: the type constructor 'a proc is contravariant in its parameter 'a. More generally, the function type constructor 'a -&amp;gt; 'b is covariant in its return type 'b and contravariant in its argument type 'a.</source>
          <target state="translated">在这种情况下，我们有x：&amp;gt; xy暗含xy proc：&amp;gt; x proc。注意，第二个子类型关系颠倒了x和xy的顺序：类型构造函数'a proc在其参数'a中是相反的。更一般地，函数类型构造函数'a-&amp;gt;'b在其返回类型'b中是协变的，而在其参数类型'a中是协变的。</target>
        </trans-unit>
        <trans-unit id="4508d1c66982f1ffb116edbbf95e424005c3367c" translate="yes" xml:space="preserve">
          <source>In this case, we would like to inline f into g, because a conditional jump can be eliminated and the code size should reduce. If the inlining decision has been made after the declaration of f without seeing the use, its size would have probably made it ineligible for inlining; but at the call site, its final size can be known. Further, this function should probably not be inlined systematically: if b is unknown, or indeed false, there is little benefit to trade off against a large increase in code size. In the existing non-Flambda inliner this isn&amp;rsquo;t a great problem because chains of inlining were cut off fairly quickly. However it has led to excessive use of overly-large inlining parameters such as -inline 10000.</source>
          <target state="translated">在这种情况下，我们希望将f内联到g，因为可以消除条件跳转，并且代码大小应该减小。如果内联决策是在声明f之后做出的，但没有看到它的用法，则其大小可能使它不符合内联的条件；但在呼叫站点，其最终大小是已知的。此外，可能不应该系统地内联此函数：如果b是未知的，或者实际上是false，那么在代码量大幅增加的情况下进行权衡几乎没有好处。在现有的非Flambda衬里中，这不是一个大问题，因为内联链被相当快地切断了。但是，它导致过度使用过大的内联参数，例如-inline 10000。</target>
        </trans-unit>
        <trans-unit id="ed102dfb8d13fe24c7ee911f7ad9ad616344d097" translate="yes" xml:space="preserve">
          <source>In this chapter, we show some larger examples using objects, classes and modules. We review many of the object features simultaneously on the example of a bank account. We show how modules taken from the standard library can be expressed as classes. Lastly, we describe a programming pattern known as &lt;em&gt;virtual types&lt;/em&gt; through the example of window managers.</source>
          <target state="translated">在本章中，我们将展示一些使用对象，类和模块的较大示例。我们以银行帐户为例同时回顾许多对象特征。我们展示了如何将从标准库中提取的模块表示为类。最后，我们通过窗口管理器的示例描述一种称为&lt;em&gt;虚拟类型&lt;/em&gt;的编程模式。</target>
        </trans-unit>
        <trans-unit id="a536879627c56054020a13fd4e78494ffa306676" translate="yes" xml:space="preserve">
          <source>In this chapter, we use the word &lt;em&gt;element&lt;/em&gt; to refer to any of the following parts of an OCaml source file: a type declaration, a value, a module, an exception, a module type, a type constructor, a record field, a class, a class type, a class method, a class value or a class inheritance clause.</source>
          <target state="translated">在本章中，我们使用词&lt;em&gt;元素&lt;/em&gt;来指代OCaml源文件的以下任何部分：类型声明，值，模块，异常，模块类型，类型构造函数，记录字段，类，类类型，类方法，类值或类继承子句。</target>
        </trans-unit>
        <trans-unit id="984f3b4b8f15c43c4ecf6aaa09632d698c5d7be4" translate="yes" xml:space="preserve">
          <source>In this example, the trace will be available at path /tmp/a_prefix.{PID}.eventlog.</source>
          <target state="translated">在这个例子中,跟踪将在路径/tmp/a_prefix.{PID}.eventlog中可用。</target>
        </trans-unit>
        <trans-unit id="95aee246af8504819e1c181916cdf924848bcae6" translate="yes" xml:space="preserve">
          <source>In this section, we illustrate most aspects of Object and inheritance by refining, debugging, and specializing the following initial naive definition of a simple bank account. (We reuse the module Euro defined at the end of chapter &amp;zwj;&lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt;.)</source>
          <target state="translated">在本节中，我们将通过优化，调试和专门化以下简单银行帐户的初始定义来说明对象和继承的大多数方面。（我们再使用章节的末端限定的模块欧元&lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cdb410675373da3ea9d54a5f332e8f794b09205d" translate="yes" xml:space="preserve">
          <source>In this section, we illustrate most aspects of Object and inheritance by refining, debugging, and specializing the following initial naive definition of a simple bank account. (We reuse the module Euro defined at the end of chapter &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt;.)</source>
          <target state="translated">在本节中，我们将通过优化，调试和专门化以下简单银行帐户的初始定义来说明对象和继承的大多数方面。（我们重用了第&lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt;章末尾定义的Euro模块。）</target>
        </trans-unit>
        <trans-unit id="7539064d77e16b304225f0f906a69a083f243dd9" translate="yes" xml:space="preserve">
          <source>In this situation, when coercing the module List2 to the module type COLLECTION, the type checker forgets that 'a List2.t was covariant in 'a. Consequently, the relaxed value restriction does not apply anymore:</source>
          <target state="translated">在这种情况下,当把模块List2强制到模块类型COLLECTION时,类型检查器忘记了'a List2.t在'a中是共变的。因此,放宽的值限制不再适用。</target>
        </trans-unit>
        <trans-unit id="f55d180a28b55d335204d82281bbcb00ea879279" translate="yes" xml:space="preserve">
          <source>In this use-case, we do not promise that &lt;code&gt;s&lt;/code&gt; will never be mutated after the call to &lt;code&gt;bytes_length&amp;nbsp;s&lt;/code&gt;. The &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; function temporarily borrows unique ownership of the byte sequence (and sees it as a &lt;code&gt;string&lt;/code&gt;), but returns this ownership back to the caller, which may assume that &lt;code&gt;s&lt;/code&gt; is still a valid byte sequence after the call. Note that this is only correct because we know that &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; does not capture its argument -- it could escape by a side-channel such as a memoization combinator.</source>
          <target state="translated">在此用例中，我们不保证在调用 &lt;code&gt;bytes_length&amp;nbsp;s&lt;/code&gt; 之后， &lt;code&gt;s&lt;/code&gt; 绝不会发生突变。该&lt;a href=&quot;string#VALlength&quot;&gt; &lt;code&gt;String.length&lt;/code&gt; &lt;/a&gt;函数暂时借用字节序列的唯一所有权（并认为这是一个 &lt;code&gt;string&lt;/code&gt; ），但返回这个所有权返回给调用者，这可以假设 &lt;code&gt;s&lt;/code&gt; 仍然是调用后有效的字节序列。请注意，这仅是正确的，因为我们知道&lt;a href=&quot;string#VALlength&quot;&gt; &lt;code&gt;String.length&lt;/code&gt; &lt;/a&gt;不能捕获其参数-可能会通过辅助通道（如备注组合器）逃脱。</target>
        </trans-unit>
        <trans-unit id="7981d44158719efab0bd42ae90948f53010bea2f" translate="yes" xml:space="preserve">
          <source>In those situations, local substitutions(see &lt;a href=&quot;signaturesubstitution#ss%3Alocal-substitution&quot;&gt;8.7.2&lt;/a&gt;) can be used instead.</source>
          <target state="translated">在这种情况下，可以使用局部替换（请参见&lt;a href=&quot;signaturesubstitution#ss%3Alocal-substitution&quot;&gt;8.7.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="90a54a6c41b6e2f305dbef8e3cddea03753f6bf7" translate="yes" xml:space="preserve">
          <source>In what follows, we say that a string has the &lt;em&gt;OCaml encoding&lt;/em&gt; if it is encoded in UTF-8 when in Unicode mode, in the current code page in legacy mode, or is an arbitrary string under Unix. A string has the &lt;em&gt;platform encoding&lt;/em&gt; if it is encoded in UTF-16 under Windows or is an arbitrary string under Unix.</source>
          <target state="translated">在下面的内容中，我们说一个字符串具有&lt;em&gt;OCaml编码，&lt;/em&gt;如果它是在Unicode模式下，在当前代码页中在旧模式下以UTF-8编码，或者在Unix下是任意字符串。如果字符串在Windows下以UTF-16编码，或者在Unix下为任意字符串，则具有&lt;em&gt;平台编码&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7790a0c7a8cccc64f38d56e2325db218d5c6811d" translate="yes" xml:space="preserve">
          <source>Inappropriate I/O control operation</source>
          <target state="translated">不恰当的I/O控制操作</target>
        </trans-unit>
        <trans-unit id="2167632468a6eb19b88638f904885e75bed8e2c3" translate="yes" xml:space="preserve">
          <source>Include all modules in the dot output, not only modules given on the command line or loaded with the -load option.</source>
          <target state="translated">在点阵输出中包含所有模块,而不仅仅是命令行给出的模块或用-load选项加载的模块。</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">包含文件</target>
        </trans-unit>
        <trans-unit id="936808b03c5417ee614099d8cff4070db8f25a29" translate="yes" xml:space="preserve">
          <source>Include the runtime system in the generated program. This is the default.</source>
          <target state="translated">在生成的程序中包含运行时系统。这是默认的。</target>
        </trans-unit>
        <trans-unit id="15fc1b72deb0a330387cb4254adc44132b197dbf" translate="yes" xml:space="preserve">
          <source>Increment the integer contained in the given reference.</source>
          <target state="translated">递增给定引用中的整数。</target>
        </trans-unit>
        <trans-unit id="59d0461a6012e030af72a2a2731fc0dc665abb6d" translate="yes" xml:space="preserve">
          <source>Increment the integer contained in the given reference. Equivalent to &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;succ&amp;nbsp;!r&lt;/code&gt;.</source>
          <target state="translated">递增给定引用中包含的整数。等效于 &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;succ&amp;nbsp;!r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b11b483c20b98095c6b381f3de3e92d1855cc71" translate="yes" xml:space="preserve">
          <source>Indeed, looking at the type of store, we see that the weak type '_weak1 has been replaced by the type int</source>
          <target state="translated">事实上,从存储的类型来看,我们看到弱类型'_weak1已经被int类型所取代了</target>
        </trans-unit>
        <trans-unit id="76cd4494b768ff6e2b09ff91039093a0249d5c70" translate="yes" xml:space="preserve">
          <source>Indeed, narrowing coercions without runtime checks would be unsafe. Runtime type checks might raise exceptions, and they would require the presence of type information at runtime, which is not the case in the OCaml system. For these reasons, there is no such operation available in the language.</source>
          <target state="translated">事实上,在没有运行时检查的情况下缩小胁迫范围是不安全的。运行时类型检查可能会引起异常,而且它们需要在运行时存在类型信息,而OCaml系统中并不存在这种情况。由于这些原因,语言中没有这样的操作。</target>
        </trans-unit>
        <trans-unit id="4b1073844359beadf5a16114b4cc53a73e228c78" translate="yes" xml:space="preserve">
          <source>Indeed, the latter is safer since the call to deposit will automatically benefit from safety checks and from the trace. Let&amp;rsquo;s test it:</source>
          <target state="translated">确实，后者更安​​全，因为存款通知将自动从安全检查和跟踪中受益。让我们测试一下：</target>
        </trans-unit>
        <trans-unit id="cf6cab5c3dce9df70b18150162d696626edc8f58" translate="yes" xml:space="preserve">
          <source>Index of exceptions</source>
          <target state="translated">例外情况索引</target>
        </trans-unit>
        <trans-unit id="acdc0800d0656472ebfb5222d7328b080a5b1896" translate="yes" xml:space="preserve">
          <source>Index of keywords</source>
          <target state="translated">关键字索引</target>
        </trans-unit>
        <trans-unit id="ec495fbe379a155a1562a723fa634c92e4aadb45" translate="yes" xml:space="preserve">
          <source>Index of module types</source>
          <target state="translated">模块类型索引</target>
        </trans-unit>
        <trans-unit id="bbeb088aa2e1f48a2526d4af87412592cfa16c85" translate="yes" xml:space="preserve">
          <source>Index of modules</source>
          <target state="translated">模块索引</target>
        </trans-unit>
        <trans-unit id="f3c5f25fe0170a55faf806d3bc5e16c8e3ad5961" translate="yes" xml:space="preserve">
          <source>Index of types</source>
          <target state="translated">类型索引</target>
        </trans-unit>
        <trans-unit id="47c7c1963655c5cb95aa9b1b9fed86c5ce38b1fc" translate="yes" xml:space="preserve">
          <source>Index of values</source>
          <target state="translated">价值指数</target>
        </trans-unit>
        <trans-unit id="25c63fb7555ce1007deae3f494c7de8045880005" translate="yes" xml:space="preserve">
          <source>Indicate when the element was introduced.</source>
          <target state="translated">说明该要素何时引入。</target>
        </trans-unit>
        <trans-unit id="8e8bd8b065fdca29c6a5b91240b13af0f286f2c2" translate="yes" xml:space="preserve">
          <source>Indirect call site</source>
          <target state="translated">间接呼叫站点</target>
        </trans-unit>
        <trans-unit id="191d440868ddc01217ec4c3c696c8932eaf72c0e" translate="yes" xml:space="preserve">
          <source>Infix and prefix symbols do not have a fixed meaning: they are simply interpreted as applications of functions bound to the names corresponding to the symbols. The expression &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is interpreted as the application (&lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;)&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Similarly, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is interpreted as the application (&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;)&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">前缀和前缀符号没有固定的含义：它们仅被解释为绑定到与符号相对应的名称的功能的应用程序。表达式&lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;被解释为应用程序（&lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;）&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;。类似地，表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1 &lt;/sub&gt;&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;被解释为应用程序（&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;）&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1 &lt;/sub&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="fe7734c62845cd6e1a492fb7d09067d4ff38b544" translate="yes" xml:space="preserve">
          <source>Information on a module can be extracted either from the .mli or .ml file, or both, depending on the files given on the command line. When both .mli and .ml files are given for the same module, information extracted from these files is merged according to the following rules:</source>
          <target state="translated">一个模块的信息可以从.mli或.ml文件中提取,也可以同时从这两个文件中提取,具体取决于命令行中给出的文件。当同一模块同时给出.mli和.ml文件时,从这些文件中提取的信息将按照以下规则进行合并。</target>
        </trans-unit>
        <trans-unit id="2d1caa25b463767e262eac6152e176e3ab952570" translate="yes" xml:space="preserve">
          <source>Initial meaning</source>
          <target state="translated">初始含义</target>
        </trans-unit>
        <trans-unit id="9dbb564f9dda009f80e001d3b6ad4b6730abcccc" translate="yes" xml:space="preserve">
          <source>Initialize the generator with a random seed chosen in a system-dependent way.</source>
          <target state="translated">用一个随机种子来初始化生成器,这个种子的选择方式与系统有关。</target>
        </trans-unit>
        <trans-unit id="e3705fbbfc33bff4987a51058b1e193b68718b84" translate="yes" xml:space="preserve">
          <source>Initialize the generator with a random seed chosen in a system-dependent way. If &lt;code&gt;/dev/urandom&lt;/code&gt; is available on the host machine, it is used to provide a highly random initial seed. Otherwise, a less random seed is computed from system parameters (current time, process IDs).</source>
          <target state="translated">使用以依赖于系统的方式选择的随机种子初始化生成器。如果 &lt;code&gt;/dev/urandom&lt;/code&gt; 在主机上可用，它将用于提供高度随机的初始种子。否则，将从系统参数（当前时间，进程ID）计算出较少随机的种子。</target>
        </trans-unit>
        <trans-unit id="d0558cb2a265a245a0a77457b30a3ebd5743bac6" translate="yes" xml:space="preserve">
          <source>Initialize the generator, using the argument as a seed.</source>
          <target state="translated">将参数作为种子,初始化生成器。</target>
        </trans-unit>
        <trans-unit id="9a062ab889be546ba6ce3373ed6772b07b5c2ea5" translate="yes" xml:space="preserve">
          <source>Initialize the generator, using the argument as a seed. The same seed will always yield the same sequence of numbers.</source>
          <target state="translated">使用参数作为种子,初始化生成器。相同的种子总是会产生相同的数字序列。</target>
        </trans-unit>
        <trans-unit id="aea28f5f058c3cb752bcc8776cf67ef0d3492493" translate="yes" xml:space="preserve">
          <source>Initializers cannot be overridden. On the contrary, all initializers are evaluated sequentially. Initializers are particularly useful to enforce invariants. Another example can be seen in section &amp;zwj;&lt;a href=&quot;advexamples#s%3Aextended-bank-accounts&quot;&gt;6.1&lt;/a&gt;.</source>
          <target state="translated">初始化程序不能被覆盖。相反，所有初始化程序都将按顺序求值。初始化程序对于强制不变式特别有用。另一个例子可以在部分看到&lt;a href=&quot;advexamples#s%3Aextended-bank-accounts&quot;&gt;6.1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e19123dd5402986d7ab5c0b5abd27d1fded34ec" translate="yes" xml:space="preserve">
          <source>Initializers cannot be overridden. On the contrary, all initializers are evaluated sequentially. Initializers are particularly useful to enforce invariants. Another example can be seen in section &lt;a href=&quot;advexamples#s%3Aextended-bank-accounts&quot;&gt;6.1&lt;/a&gt;.</source>
          <target state="translated">初始化程序不能被覆盖。相反，所有初始化程序都将按顺序求值。初始化程序对于强制不变式特别有用。在&lt;a href=&quot;advexamples#s%3Aextended-bank-accounts&quot;&gt;6.1&lt;/a&gt;节中可以看到另一个示例。</target>
        </trans-unit>
        <trans-unit id="62be43bf10903b9dc899eb01b40be45122b8d091" translate="yes" xml:space="preserve">
          <source>Initially all compilation units composing the program currently running are available for reference from dynamically-linked units. &lt;code&gt;set_allowed_units&lt;/code&gt; can be used to restrict access to a subset of these units, e.g. to the units that compose the API for dynamically-linked code, and prevent access to all other units, e.g. private, internal modules of the running program.</source>
          <target state="translated">最初，构成当前正在运行的程序的所有编译单元都可以从动态链接的单元中获得参考。 &lt;code&gt;set_allowed_units&lt;/code&gt; 可用于限制对这些单元的子集的访问，例如，限制构成用于动态链接代码的API的单元，并阻止对所有其他单元（例如，正在运行的程序的私有内部模块）的访问。</target>
        </trans-unit>
        <trans-unit id="b04358901f0c2b1cc965658b8d2705ff3a050af0" translate="yes" xml:space="preserve">
          <source>Injectivity annotations are only necessary for abstract types and private row types, since they can otherwise be deduced from the type declaration: all parameters are injective for record and variant type declarations (including extensible types); for type abbreviations a parameter is injective if it has an injective occurrence in its defining equation (be it private or not). For constrained type parameters in type abbreviations, they are injective if either they appear at an injective position in the body, or if all their type variables are injective; in particular, if a constrained type parameter contains a variable that doesn&amp;rsquo;t appear in the body, it cannot be injective.</source>
          <target state="translated">注入性注释仅对于抽象类型和私有行类型是必需的，因为否则可以从类型声明中推导它们：所有参数对于记录和变量类型声明（包括可扩展类型）都是注入性的；对于类型缩写，如果参数在其定义方程式中出现内射（无论是否私有），则该参数为内射。对于类型缩写中的受约束类型参数，如果它们出现在体内的内插位置，或者它们的所有类型变量都是内射，则为内射。特别是，如果受约束的类型参数包含在体内没有出现的变量，则它不能是内射的。</target>
        </trans-unit>
        <trans-unit id="2b06c7e11e0b9786df67b9cc22d90d3a95785831" translate="yes" xml:space="preserve">
          <source>Inlining impossible.</source>
          <target state="translated">内衬不可能。</target>
        </trans-unit>
        <trans-unit id="3b0e45ff90a6d9597b56ccc3164ed9d48a57e6e5" translate="yes" xml:space="preserve">
          <source>Inlining is performed together with all of the other Flambda optimisation passes, that is to say, after closure conversion. This has three particular advantages over a potentially more straightforward implementation prior to closure conversion:</source>
          <target state="translated">内嵌是与所有其他Flambda优化通道一起执行的,也就是说,在闭包转换之后。与闭包转换前可能更直接的实现相比,这有三个特别的优势。</target>
        </trans-unit>
        <trans-unit id="6913b13f09c798d326ff4e05ee1ae94c7cf9c288" translate="yes" xml:space="preserve">
          <source>Inlining typically results in an increase in code size, which if left unchecked, may not only lead to grossly large executables and excessive compilation times but also a decrease in performance due to worse locality. As such, the Flambda inliner trades off the change in code size against the expected runtime performance benefit, with the benefit being computed based on the number of operations that the compiler observes may be removed as a result of inlining.</source>
          <target state="translated">内联通常会导致代码大小的增加,如果不加控制,不仅会导致可执行文件过大和编译时间过长,而且还会由于位置性的恶化而导致性能下降。因此,Flambda inliner将代码大小的变化与预期的运行时性能收益进行权衡,收益是根据编译器观察到的可能因内联而被删除的操作数量计算的。</target>
        </trans-unit>
        <trans-unit id="b56e2846e27a402309f12b5d96bce8a00e3f7444" translate="yes" xml:space="preserve">
          <source>Inlining within recursive functions of calls to other functions in the same mutually-recursive group is kept in check by an &lt;em&gt;unrolling depth&lt;/em&gt;, described below. This ensures that functions are not unrolled to excess. (Unrolling is only enabled if -O3 optimisation level is selected and/or the -inline-max-unroll flag is passed with an argument greater than zero.)</source>
          <target state="translated">如下所述，通过&lt;em&gt;展开深度&lt;/em&gt;来阻止对在同一相互递归组中的其他函数的调用的递归函数内进行内联。这样可以确保功能不会过度展开。（如果选择-O3优化水平和/或-inline-MAX-UNROLL标志与一个参数大于零传递开卷才启用。）</target>
        </trans-unit>
        <trans-unit id="f4ae3ab2d64c2a48b49309cd566806beea18ab73" translate="yes" xml:space="preserve">
          <source>Innocuous unused variable: unused variable that is not bound with let nor as, and doesn&amp;rsquo;t start with an underscore (_) character.</source>
          <target state="translated">无歧义的未使用变量：未与let或as绑定且未以下划线（_）字符开头的未使用变量。</target>
        </trans-unit>
        <trans-unit id="18969234f3dbfdf448abc9f07e07414d5833db11" translate="yes" xml:space="preserve">
          <source>Inode number</source>
          <target state="translated">节点号</target>
        </trans-unit>
        <trans-unit id="2e286662d51034aaf951f8c590e939c61a0c7752" translate="yes" xml:space="preserve">
          <source>Input baud rate.</source>
          <target state="translated">输入波特率。</target>
        </trans-unit>
        <trans-unit id="2af110399d643ab732597b92ca411b83ee621406" translate="yes" xml:space="preserve">
          <source>Input functions on standard input</source>
          <target state="translated">标准输入的输入功能</target>
        </trans-unit>
        <trans-unit id="fb0a243ff8f728fbc19eee3b8e30be0cbc1fada8" translate="yes" xml:space="preserve">
          <source>Input signature of the functor &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 的&lt;/a&gt;输入签名。</target>
        </trans-unit>
        <trans-unit id="b9b106594998daff6106e753f93569c57df403c5" translate="yes" xml:space="preserve">
          <source>Input signature of the functor &lt;a href=&quot;morelabels.map.make&quot;&gt;&lt;code&gt;MoreLabels.Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;morelabels.map.make&quot;&gt; &lt;code&gt;MoreLabels.Map.Make&lt;/code&gt; 的&lt;/a&gt;输入签名。</target>
        </trans-unit>
        <trans-unit id="a7a4de9671b93af6076ae7e36782ec84cefe41e0" translate="yes" xml:space="preserve">
          <source>Input signature of the functor &lt;a href=&quot;morelabels.set.make&quot;&gt;&lt;code&gt;MoreLabels.Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;morelabels.set.make&quot;&gt; &lt;code&gt;MoreLabels.Set.Make&lt;/code&gt; 的&lt;/a&gt;输入签名。</target>
        </trans-unit>
        <trans-unit id="106aa4d5f66d17b870cd55da1c3ba9108d80de1e" translate="yes" xml:space="preserve">
          <source>Input signature of the functor &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; 的&lt;/a&gt;输入签名。</target>
        </trans-unit>
        <trans-unit id="cb4637425273984e359cae1faec33aab011257fa" translate="yes" xml:space="preserve">
          <source>Input to the toplevel can span several lines. It is terminated by ;; (a double-semicolon). The toplevel input consists in one or several toplevel phrases, with the following syntax:</source>
          <target state="translated">对toplevel的输入可以跨越几行。它以;;(双分号)结束。toplevel输入由一个或几个toplevel短语组成,其语法如下。</target>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="3bbbd8e97ab8a67ba17de562bff8af90fa53faaf" translate="yes" xml:space="preserve">
          <source>Input/output with timeout</source>
          <target state="translated">输入/输出超时</target>
        </trans-unit>
        <trans-unit id="bb706c985ba3ad0bfe191f4ce7255d21cd26c340" translate="yes" xml:space="preserve">
          <source>Inside a class definition, newly defined types are not available for subtyping, as the type abbreviations are not yet completely defined. There is an exception for coercing self to the (exact) type of its class: this is allowed if the type of self does not appear in a contravariant position in the class type, &lt;em&gt;i.e.&lt;/em&gt; if there are no binary methods.</source>
          <target state="translated">在类定义内部，新定义的类型不能用于子类型化，因为类型缩写尚未完全定义。强制将self强制为其类的（精确）类型是一个例外：如果self的类型未出现在类类型的对立位置，&lt;em&gt;即&lt;/em&gt;没有二进制方法，则允许这样做。</target>
        </trans-unit>
        <trans-unit id="a205e6f672b9fdfb59c252492e5d0840aba8c432" translate="yes" xml:space="preserve">
          <source>Inside a tabulation box, special &lt;em&gt;tabulation markers&lt;/em&gt; defines points of interest on the line (for instance to delimit cell boundaries). Function &lt;a href=&quot;format#VALset_tab&quot;&gt;&lt;code&gt;Format.set_tab&lt;/code&gt;&lt;/a&gt; sets a tabulation marker at insertion point.</source>
          <target state="translated">在列表框中，特殊的&lt;em&gt;列表标记&lt;/em&gt;定义了线上的兴趣点（例如，界定单元格边界）。函数&lt;a href=&quot;format#VALset_tab&quot;&gt; &lt;code&gt;Format.set_tab&lt;/code&gt; &lt;/a&gt;在插入点设置一个制表标记。</target>
        </trans-unit>
        <trans-unit id="d4bc21673d22d7a226cf1a154d1dc9f5b82d92ea" translate="yes" xml:space="preserve">
          <source>Inside signatures, extended opens are limited to extended module paths,</source>
          <target state="translated">在签名里面,扩展开放仅限于扩展模块路径。</target>
        </trans-unit>
        <trans-unit id="08d3888f1ab23958e132facd2acfbe644974db97" translate="yes" xml:space="preserve">
          <source>Instance variable overridden.</source>
          <target state="translated">实例变量被覆盖。</target>
        </trans-unit>
        <trans-unit id="22f04c4ba964874db6809362b1a8926b072c78c2" translate="yes" xml:space="preserve">
          <source>Instance variables</source>
          <target state="translated">实例变量</target>
        </trans-unit>
        <trans-unit id="f37452f8cdfca7d287d0436f2a77363400920136" translate="yes" xml:space="preserve">
          <source>Instance variables can also be declared as virtual, with the same effect as with methods.</source>
          <target state="translated">实例变量也可以声明为虚拟变量,与方法的效果相同。</target>
        </trans-unit>
        <trans-unit id="6cbf3c792bd63a3e48e2769ecf3367f834405f89" translate="yes" xml:space="preserve">
          <source>Instead of building simultaneously the bytecode library, the native-code library and the C libraries, ocamlmklib can be called three times to build each separately. Thus,</source>
          <target state="translated">ocamlmklib不需要同时构建字节码库、本机代码库和C库,而是可以调用三次来分别构建每个库。因此。</target>
        </trans-unit>
        <trans-unit id="5c04639e128bd9a951383bb5ff32e6f5c8aaf672" translate="yes" xml:space="preserve">
          <source>Instead of manually taking profiling heap snapshots with this module it is possible to use an automatic snapshot facility that writes profiling information at fixed intervals to a file. To enable this, all that needs to be done is to build the relevant program using a compiler configured with -spacetime; and set the environment variable OCAML_SPACETIME_INTERVAL to an integer number of milliseconds giving the interval between profiling heap snapshots. This interval should not be made excessively small relative to the running time of the program. A typical interval to start with might be 1/100 of the running time of the program. The program must exit &quot;normally&quot; (i.e. by calling &lt;code&gt;exit&lt;/code&gt;, with whatever exit code, rather than being abnormally terminated by a signal) so that the snapshot file is correctly completed.</source>
          <target state="translated">代替使用此模块手动获取概要分析堆快照，可以使用自动快照工具，该工具以固定的时间间隔将概要分析信息写入文件。为此，所有需要做的就是使用配置了-spacetime的编译器来构建相关程序。并将环境变量OCAML_SPACETIME_INTERVAL设置为整数毫秒，以提供分析堆快照之间的间隔。相对于程序的运行时间，不应使此间隔过小。开始的典型时间间隔可能是程序运行时间的1/100。程序必须&amp;ldquo;正常&amp;rdquo;退出（即通过使用退出代码调用 &lt;code&gt;exit&lt;/code&gt; ，而不是被信号异常终止），以便正确完成快照文件。</target>
        </trans-unit>
        <trans-unit id="e943b527aa4ff5b9d82f9025dbdd34ab27b52c5d" translate="yes" xml:space="preserve">
          <source>Instead of using the automatic snapshot facility described above it is also possible to manually control Spacetime profiling. (The environment variables OCAML_SPACETIME_INTERVAL and OCAML_SPACETIME_SNAPSHOT_DIR are then not relevant.) Full documentation as regards this method of profiling is provided in the standard library documentation (section &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;) for the Spacetime module.</source>
          <target state="translated">除了使用上述自动快照功能外，还可以手动控制时空分析。（然后，环境变量OCAML_SPACETIME_INTERVAL和OCAML_SPACETIME_SNAPSHOT_DIR不相关。）在时空模块的标准库文档（第&lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;节）中提供了有关此分析方法的完整文档。</target>
        </trans-unit>
        <trans-unit id="00c73f5f7ad74401722214f0974a3eff4d870dcf" translate="yes" xml:space="preserve">
          <source>Instead you should make sure that &lt;code&gt;v&lt;/code&gt; is not in the closure of the finalisation function by writing:</source>
          <target state="translated">相反，您应该通过编写以下命令来确保 &lt;code&gt;v&lt;/code&gt; 不在终结函数中：</target>
        </trans-unit>
        <trans-unit id="25f985c284e754031dd21f1a5c5f41e90ae95c89" translate="yes" xml:space="preserve">
          <source>Instead, we compile with afl-fuzz instrumentation enabled:</source>
          <target state="translated">相反,我们在编译时启用了 afl-fuzz 工具。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="15381ff97a37fb400782fdaa2c7388f15a9ffe29" translate="yes" xml:space="preserve">
          <source>Int and float literals followed by an one-letter identifier in the range [g..z∣ G..Z] are extension-only literals.</source>
          <target state="translated">Int 和 float 字符后跟一个字母标识符的范围 [g..z∣ G..Z]是扩展专用字符。</target>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="2ce3094d56f1473f235bddadb9d8bc7ef3c8506c" translate="yes" xml:space="preserve">
          <source>Int32_val(v) returns the 32-bit integer contained in the int32v.</source>
          <target state="translated">Int32_val(v)返回 int32v 中包含的 32 位整数。</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="01401a6dfc8f66f16b91660dc052300e61a41944" translate="yes" xml:space="preserve">
          <source>Int64_val(v) returns the 64-bit integer contained in the int64v.</source>
          <target state="translated">Int64_val(v)返回 int64v 中包含的 64 位整数。</target>
        </trans-unit>
        <trans-unit id="ca17dea0b5499b7267626775e6fb9adb332e238d" translate="yes" xml:space="preserve">
          <source>Int_val(v) returns the int encoded in value v.</source>
          <target state="translated">Int_val(v)返回用值 v 编码的 int。</target>
        </trans-unit>
        <trans-unit id="32ddd0cbe8aab89d143f0365d7027496f8c8f9b4" translate="yes" xml:space="preserve">
          <source>Integer addition.</source>
          <target state="translated">整数加法。</target>
        </trans-unit>
        <trans-unit id="51469f7cf19f5aef555ff312b610dd3233d7b502" translate="yes" xml:space="preserve">
          <source>Integer addition. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">整数加法。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="799eea857bb7f3051065789cb42f9d772482ce76" translate="yes" xml:space="preserve">
          <source>Integer arithmetic</source>
          <target state="translated">整数算术</target>
        </trans-unit>
        <trans-unit id="7b97f0e3b005e1c50bd3f2e901953649a16fbfda" translate="yes" xml:space="preserve">
          <source>Integer division.</source>
          <target state="translated">整数除法。</target>
        </trans-unit>
        <trans-unit id="497f091783378895fdc4d9e7953e5a08e182ce5c" translate="yes" xml:space="preserve">
          <source>Integer division. Integer division rounds the real quotient of its arguments towards zero. More precisely, if &lt;code&gt;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;y&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;x&amp;nbsp;/&amp;nbsp;y&lt;/code&gt; is the greatest integer less than or equal to the real quotient of &lt;code&gt;x&lt;/code&gt; by &lt;code&gt;y&lt;/code&gt;. Moreover, &lt;code&gt;(-&amp;nbsp;x)&amp;nbsp;/&amp;nbsp;y&amp;nbsp;=&amp;nbsp;x&amp;nbsp;/&amp;nbsp;(-&amp;nbsp;y)&amp;nbsp;=&amp;nbsp;-&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">整数除法。整数除法会将其参数的实数取整为零。更准确地说，如果 &lt;code&gt;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; 且 &lt;code&gt;y&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt; ，则 &lt;code&gt;x&amp;nbsp;/&amp;nbsp;y&lt;/code&gt; 是小于或等于 &lt;code&gt;x&lt;/code&gt; 的实商乘以 &lt;code&gt;y&lt;/code&gt; 的最大整数。此外， &lt;code&gt;(-&amp;nbsp;x)&amp;nbsp;/&amp;nbsp;y&amp;nbsp;=&amp;nbsp;x&amp;nbsp;/&amp;nbsp;(-&amp;nbsp;y)&amp;nbsp;=&amp;nbsp;-&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&lt;/code&gt; 。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd2f1f4758df5a6c46bd95dca7106b6f2bd262a0" translate="yes" xml:space="preserve">
          <source>Integer division. Raise Division_by_zero if second argument is zero.</source>
          <target state="translated">整数除法。如果第二个参数为0,则引发Division_by_zero。</target>
        </trans-unit>
        <trans-unit id="9277b24b9c7ec7c2802db27cc9cc0d888c4a2627" translate="yes" xml:space="preserve">
          <source>Integer division. This division rounds the real quotient of its arguments towards zero, as specified for &lt;a href=&quot;stdlib#VAL(/)&quot;&gt;&lt;code&gt;(/)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">整数除法。该除法将其自变量的实商四舍五入为零，如&lt;a href=&quot;stdlib#VAL(/)&quot;&gt; &lt;code&gt;(/)&lt;/code&gt; &lt;/a&gt;所指定。</target>
        </trans-unit>
        <trans-unit id="a70bb5f8ea15b1d1eb87ef3499d1ad101d2ec5ac" translate="yes" xml:space="preserve">
          <source>Integer modulus. Raise Division_by_zero if second argument is zero.</source>
          <target state="translated">整数模数。如果第二个参数为0,则引发Division_by_zero。</target>
        </trans-unit>
        <trans-unit id="4e1c23fc1293a5342dcbb3f224d5a8468fa0f38f" translate="yes" xml:space="preserve">
          <source>Integer multiplication.</source>
          <target state="translated">整数乘法。</target>
        </trans-unit>
        <trans-unit id="8648a8d2bc260aeaf65eefba9783a89ca4ed0085" translate="yes" xml:space="preserve">
          <source>Integer multiplication. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">整数乘法。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="032eaf1313070ba2c07142e51665d3b149104407" translate="yes" xml:space="preserve">
          <source>Integer negation.</source>
          <target state="translated">整数否定。</target>
        </trans-unit>
        <trans-unit id="02df94240577ba3af6cd59998f11bcb26c753b82" translate="yes" xml:space="preserve">
          <source>Integer remainder.</source>
          <target state="translated">整数余量。</target>
        </trans-unit>
        <trans-unit id="608e0fbf1419a8074d877b3d35e821cc489e0512" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following property: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int32.add&amp;nbsp;(Int32.mul&amp;nbsp;(Int32.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int32.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="translated">整数余数。如果 &lt;code&gt;y&lt;/code&gt; 不为零，则 &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 的结果满足以下属性： &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int32.add&amp;nbsp;(Int32.mul&amp;nbsp;(Int32.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int32.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt; 。如果 &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; ，则 &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 升高 &lt;code&gt;Division_by_zero&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="487f9e5fe125fb675e3c64cef0e69cc68128df1c" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following property: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int64.add&amp;nbsp;(Int64.mul&amp;nbsp;(Int64.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int64.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="translated">整数余数。如果 &lt;code&gt;y&lt;/code&gt; 不为零，则 &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 的结果满足以下属性： &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int64.add&amp;nbsp;(Int64.mul&amp;nbsp;(Int64.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int64.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt; 。如果 &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; ，则 &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 引发 &lt;code&gt;Division_by_zero&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3fbea780e541621ae7cf3f5b034731f03103fd9" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following properties: &lt;code&gt;Nativeint.zero&amp;nbsp;&amp;lt;=&amp;nbsp;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&amp;nbsp;&amp;lt;&amp;nbsp;Nativeint.abs&amp;nbsp;y&lt;/code&gt; and &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Nativeint.add&amp;nbsp;(Nativeint.mul&amp;nbsp;(Nativeint.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(Nativeint.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="translated">整数余数。如果 &lt;code&gt;y&lt;/code&gt; 不为零，则 &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 的结果满足以下属性： &lt;code&gt;Nativeint.zero&amp;nbsp;&amp;lt;=&amp;nbsp;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&amp;nbsp;&amp;lt;&amp;nbsp;Nativeint.abs&amp;nbsp;y&lt;/code&gt; 和 &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Nativeint.add&amp;nbsp;(Nativeint.mul&amp;nbsp;(Nativeint.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(Nativeint.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt; 。如果 &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; ，则 &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 引发 &lt;code&gt;Division_by_zero&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
