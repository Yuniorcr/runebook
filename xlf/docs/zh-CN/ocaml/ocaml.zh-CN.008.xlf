<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="b3e3bbc9103b04d543a6204da8e18664e43f77be" translate="yes" xml:space="preserve">
          <source>Access control</source>
          <target state="translated">访问控制</target>
        </trans-unit>
        <trans-unit id="5939fde4330b1c7029b735347e474f73f8bfba71" translate="yes" xml:space="preserve">
          <source>Access rights</source>
          <target state="translated">访问权</target>
        </trans-unit>
        <trans-unit id="5367a3707b1d296277995b49887d8cc22e70b51a" translate="yes" xml:space="preserve">
          <source>Access to the process environment</source>
          <target state="translated">进入过程环境</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="0d060c3891e011a2fc5b2b74a61a28c05d71f546" translate="yes" xml:space="preserve">
          <source>Actions occurring in the middle of rules are not supported.</source>
          <target state="translated">不支持发生在规则中间的动作。</target>
        </trans-unit>
        <trans-unit id="f95df08a7b4d8f422073eef0468427baea699a3e" translate="yes" xml:space="preserve">
          <source>Add a reference to the URL with the given &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; as comment.</source>
          <target state="translated">添加对URL的引用，并以给定的&lt;a href=&quot;#text&quot;&gt;文本&lt;/a&gt;作为注释。</target>
        </trans-unit>
        <trans-unit id="69f456d980f30fb1b1e2a132126c468303326960" translate="yes" xml:space="preserve">
          <source>Add a reference to the given document name (written between double quotes), with the given &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; as comment.</source>
          <target state="translated">添加对给定文档名称的引用（写在双引号之间），并将给定&lt;a href=&quot;#text&quot;&gt;文本&lt;/a&gt;作为注释。</target>
        </trans-unit>
        <trans-unit id="e455fdb6e163518a8a9c0f60519a0f880236caf0" translate="yes" xml:space="preserve">
          <source>Add a reference to the given file name (written between single quotes), with the given &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; as comment.</source>
          <target state="translated">添加对给定文件名的引用（写在单引号之间），给定&lt;a href=&quot;#text&quot;&gt;文本&lt;/a&gt;作为注释。</target>
        </trans-unit>
        <trans-unit id="7fe36a70c00075434c397a228dd28b19a5b40291" translate="yes" xml:space="preserve">
          <source>Add a type constraint or a .mli file to give a monomorphic type (without type variables) to name. For instance, instead of writing</source>
          <target state="translated">添加一个类型约束或一个.mli文件来给一个单态类型(没有类型变量)命名。例如,不需要写</target>
        </trans-unit>
        <trans-unit id="d8d460cb8c37089106d003c1064dc954647c1bde" translate="yes" xml:space="preserve">
          <source>Add chars to the buffer</source>
          <target state="translated">向缓冲区添加字符</target>
        </trans-unit>
        <trans-unit id="b816bb5460a6255ac8865d6c83554a3e1f6825bd" translate="yes" xml:space="preserve">
          <source>Add debugging information while compiling and linking. This option is required in order to be able to debug the program with ocamldebug (see chapter &amp;zwj;&lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;16&lt;/a&gt;), and to produce stack backtraces when the program terminates on an uncaught exception (see section &amp;zwj;&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;).</source>
          <target state="translated">在编译和链接时添加调试信息。该选项是为了能够与ocamldebug调试程序所需（见章节&lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;16&lt;/a&gt;），和以产生堆栈回溯当在未捕获的异常的程序终止（见第&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="affd53b88d19affb53002eff0f7ab10e5f0630fe" translate="yes" xml:space="preserve">
          <source>Add debugging information while compiling and linking. This option is required in order to be able to debug the program with ocamldebug (see chapter &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;), and to produce stack backtraces when the program terminates on an uncaught exception (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;).</source>
          <target state="translated">在编译和链接时添加调试信息。这个选项是必需的，以便能够使用ocamldebug调试程序（请参阅第&lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;章），并在程序因未捕获的异常终止时产生堆栈回溯（请参见&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="52a428547d887fa88f06aeae32c0350c69f7ed5e" translate="yes" xml:space="preserve">
          <source>Add debugging information while compiling and linking. This option is required in order to produce stack backtraces when the program terminates on an uncaught exception (see section &amp;zwj;&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;).</source>
          <target state="translated">在编译和链接时添加调试信息。该选项是必需以产生堆栈回溯当在未捕获的异常的程序终止（见第&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f703a0da73682e7d141b1e27a7036a264d64a0be" translate="yes" xml:space="preserve">
          <source>Add debugging information while compiling and linking. This option is required in order to produce stack backtraces when the program terminates on an uncaught exception (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;).</source>
          <target state="translated">在编译和链接时添加调试信息。当程序因未捕获的异常而终止时，此选项是必需的，以便产生堆栈回溯（请参见&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="455a2ac695c6d841be54d9f6f0655b40013388f9" translate="yes" xml:space="preserve">
          <source>Add dir to the search path for support libraries (-llib).</source>
          <target state="translated">将dir添加到支持库的搜索路径中(-llib)。</target>
        </trans-unit>
        <trans-unit id="116b0bc4c5e306f590fdd8ab71c4f3dc593b0c74" translate="yes" xml:space="preserve">
          <source>Add directory to the list of directories search for compiled interface files (.cmi files).</source>
          <target state="translated">添加目录到搜索编译界面文件(.cmi文件)的目录列表。</target>
        </trans-unit>
        <trans-unit id="878c236c047eba2ad1017cde59fa0100f152504e" translate="yes" xml:space="preserve">
          <source>Add directory to the list of directories searched for source files and compiled files. (See also the directory command.)</source>
          <target state="translated">在搜索源文件和编译文件的目录列表中添加目录。(也请参见目录命令。)</target>
        </trans-unit>
        <trans-unit id="be49e6e9b0eecf83542277ada9d3da7115d88260" translate="yes" xml:space="preserve">
          <source>Add information about character encoding being charset (default is iso-8859-1).</source>
          <target state="translated">添加有关字符编码的信息(默认为iso-8859-1)。</target>
        </trans-unit>
        <trans-unit id="3b6ef14ba006276ead07154782672d0457bf2569" translate="yes" xml:space="preserve">
          <source>Add the elements from the generator to the end of the queue</source>
          <target state="translated">将生成器中的元素添加到队列的末端。</target>
        </trans-unit>
        <trans-unit id="6ac5528706d79b74ed1b9c9192758668ff8b43c2" translate="yes" xml:space="preserve">
          <source>Add the elements from the iterator on the top of the stack.</source>
          <target state="translated">将迭代器中的元素添加到堆栈的顶部。</target>
        </trans-unit>
        <trans-unit id="f7dc7879ac55573a76496ddd53427351b0d604a9" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the map, in order.</source>
          <target state="translated">按顺序将给定的绑定添加到地图中。</target>
        </trans-unit>
        <trans-unit id="e0fad10cd0ddb0c2dfbda0638ff0f97fa42bff42" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the table, using &lt;a href=&quot;hashtbl#VALadd&quot;&gt;&lt;code&gt;Hashtbl.add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;hashtbl#VALadd&quot;&gt; &lt;code&gt;Hashtbl.add&lt;/code&gt; &lt;/a&gt;将给定的绑定添加到表中</target>
        </trans-unit>
        <trans-unit id="abd7c11fca19595f5a44b83f3967232eedefd40a" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the table, using &lt;a href=&quot;hashtbl#VALreplace&quot;&gt;&lt;code&gt;Hashtbl.replace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;hashtbl#VALreplace&quot;&gt; &lt;code&gt;Hashtbl.replace&lt;/code&gt; &lt;/a&gt;将给定的绑定添加到表中</target>
        </trans-unit>
        <trans-unit id="4b62858e6f3c61afb4c5208e0d2b059532e983df" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the table, using &lt;a href=&quot;morelabels.hashtbl#VALadd&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;morelabels.hashtbl#VALadd&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.add&lt;/code&gt; &lt;/a&gt;将给定的绑定添加到表中</target>
        </trans-unit>
        <trans-unit id="ed3eb6ecf2cc8e594362b72219af0d809f0184a6" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the table, using &lt;a href=&quot;morelabels.hashtbl#VALreplace&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.replace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;morelabels.hashtbl#VALreplace&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.replace&lt;/code&gt; &lt;/a&gt;将给定的绑定添加到表中</target>
        </trans-unit>
        <trans-unit id="a1a38a85af367f6bd745ea024df2117e2ce32273" translate="yes" xml:space="preserve">
          <source>Add the given directories to the search path. These directories are added at the front, and will therefore be searched first.</source>
          <target state="translated">将给定的目录添加到搜索路径中。这些目录被添加在前面,因此将首先被搜索。</target>
        </trans-unit>
        <trans-unit id="7c2a498cca321b2fed042a8d0a9f1d47b869451f" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmx), and libraries (.cmxa). By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="translated">将给定的目录添加到搜索编译接口文件(.cmi)、编译对象代码文件(.cmx)和库(.cmxa)的目录列表中。默认情况下,首先搜索当前目录,然后搜索标准库目录。用 -I 添加的目录会按照命令行中给出的顺序,在当前目录之后搜索,但在标准库目录之前搜索。也可以参考选项-nostdlib。</target>
        </trans-unit>
        <trans-unit id="c8aa612e0bd4e90878648990b0d60b2f8b470f23" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled interface files (.cmi), compiled object code files .cmo, libraries (.cma) and C libraries specified with -cclib -lxxx. By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="translated">将给定的目录添加到搜索编译接口文件(.cmi)、编译对象代码文件.cmo、库(.cma)和用-cclib -lxxx指定的C库的目录列表中。默认情况下,首先搜索当前目录,然后搜索标准库目录。用-I添加的目录会按照命令行中给出的顺序,在当前目录之后搜索,但在标准库目录之前搜索。也可以参考选项-nostdlib。</target>
        </trans-unit>
        <trans-unit id="80cdc17897cdef0ea127e80a815a02cb302ed598" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled object code files (.cmo and .cma).</source>
          <target state="translated">将给定的目录添加到搜索编译对象代码文件(.cmo和.cma)的目录列表中。</target>
        </trans-unit>
        <trans-unit id="f21f70a2b309db4bc3ef2020833733d08aefdc27" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source and compiled files.</source>
          <target state="translated">将给定目录添加到搜索源文件和编译文件的目录列表中。</target>
        </trans-unit>
        <trans-unit id="e9b72349c349661191e6ab2b2f4321482a5c93cf" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source and compiled files. By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="translated">将给定的目录添加到搜索源文件和编译文件的目录列表中,默认情况下,先搜索当前目录,然后搜索标准库目录。默认情况下,先搜索当前目录,然后搜索标准库目录。用-I添加的目录按照命令行中给出的顺序,在当前目录之后搜索,但在标准库目录之前搜索。也可以参考选项-nostdlib。</target>
        </trans-unit>
        <trans-unit id="55301a601e766daeea1fded3c06e3dc26a7f2ce1" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source files. If a source file foo.ml mentions an external compilation unit Bar, a dependency on that unit&amp;rsquo;s interface bar.cmi is generated only if the source for bar is found in the current directory or in one of the directories specified with -I. Otherwise, Bar is assumed to be a module from the standard library, and no dependencies are generated. For programs that span multiple directories, it is recommended to pass ocamldep the same -I options that are passed to the compiler.</source>
          <target state="translated">将给定目录添加到搜索源文件的目录列表中。如果源文件foo.ml提到了外部编译单元Bar，则只有在当前目录或-I指定的目录之一中找到bar的源时，才会生成对该单元接口bar.cmi的依赖关系。否则，假定Bar是标准库中的模块，并且不会生成任何依赖项。对于跨多个目录的程序，建议将ocamldep传递给编译器的-I选项传递给ocamldep。</target>
        </trans-unit>
        <trans-unit id="29e7020b45f1262cb41170e433ca8235ad7c946e" translate="yes" xml:space="preserve">
          <source>Add the given directory to the path where to look for custom generators.</source>
          <target state="translated">将给定目录添加到寻找自定义生成器的路径中。</target>
        </trans-unit>
        <trans-unit id="5d0af8f38e88eae6f30e6f6e5ee8f246c3bf179e" translate="yes" xml:space="preserve">
          <source>Add the given elements to the set, in order.</source>
          <target state="translated">将给定的元素按顺序添加到集合中。</target>
        </trans-unit>
        <trans-unit id="1ddbfb3e864dea530a3009f02fcf2d7ae593b572" translate="yes" xml:space="preserve">
          <source>Add the suffix string to the name of the runtime library used by the program. Currently, only one such suffix is supported: d, and only if the OCaml compiler was configured with option -with-debug-runtime. This suffix gives the debug version of the runtime, which is useful for debugging pointer problems in low-level code such as C stubs.</source>
          <target state="translated">将后缀字符串添加到程序使用的运行时库的名称中。目前,只支持一个这样的后缀:d,而且只有在OCaml编译器配置了选项-with-debug-runtime的情况下。这个后缀给出了运行时的调试版本,这对于调试C存根等低级代码中的指针问题很有用。</target>
        </trans-unit>
        <trans-unit id="fde07839c2e1ab1f3cdd8033814a37ff821e5c7d" translate="yes" xml:space="preserve">
          <source>Adding such a wrapper will penalise indirect calls to the function (which might exist in arbitrary places; remember that this transformation is not for example applied only on functions the compiler has produced as a result of specialisation) since such calls will bounce through the wrapper. To mitigate this, if a function is small enough when weighed up against the number of free variables being removed, it will be duplicated by the transformation to obtain two versions: the original (used for indirect calls, since we can do no better) and the wrapper/rewritten function pair as described in the previous paragraph. The wrapper/rewritten function pair will only be used at direct call sites of the function. (The wrapper in this case is known as a &lt;em&gt;direct call surrogate&lt;/em&gt;, since it takes the place of another function&amp;mdash;the unchanged version used for indirect calls&amp;mdash;at direct call sites.)</source>
          <target state="translated">添加这样的包装器将对函数的间接调用（可能存在于任意位置；请记住，这种转换不只适用于由于专业化而导致的编译器生成的函数）的惩罚，因为此类调用会通过包装器反弹。为了减轻这种情况，如果在权衡要删除的自由变量数量的情况下某个函数足够小，则该函数将通过转换进行复制以获得两个版本：原始版本（用于间接调用，因为我们无法做得更好）和如上一段所述的包装器/重写函数对。包装器/重写的功能对将仅在该功能的直接调用位置使用。 （在这种情况下，包装器称为&lt;em&gt;直接调用代理&lt;/em&gt;，因为它代替了直接调用站点上的另一个函数（用于间接调用的不变版本）。）</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="e372ea45fd570b0859356c6972474a58f8da3b86" translate="yes" xml:space="preserve">
          <source>Addition.</source>
          <target state="translated">Addition.</target>
        </trans-unit>
        <trans-unit id="b36e2f53930600a65d8f90fb7c04d3c68cb6a078" translate="yes" xml:space="preserve">
          <source>Additional directories to search for compiled object code files (.cmi, .cmo and .cma). The specified directories are considered from left to right, after the include directories specified on the command line via -I have been searched. Available since OCaml 4.08.</source>
          <target state="translated">搜索编译后的对象代码文件(.cmi、.cmo和.cma)的附加目录。在命令行中通过-I指定的include目录被搜索过后,指定的目录从左到右被考虑。从OCaml 4.08开始提供。</target>
        </trans-unit>
        <trans-unit id="83a0f23d7925cb31cba960fa7fcba1f4825446d3" translate="yes" xml:space="preserve">
          <source>Additional directories to search for dynamically-loaded libraries (see section &amp;zwj;&lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;).</source>
          <target state="translated">附加目录搜索动态加载库（见第&lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="020cf7d20693ee54765c9f2fb5a0cc253fce23c6" translate="yes" xml:space="preserve">
          <source>Additional directories to search for dynamically-loaded libraries (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;).</source>
          <target state="translated">其他目录，用于搜索动态加载的库（请参见&lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="2e0a4e8cb19afd44c38722faacb960225f305ceb" translate="yes" xml:space="preserve">
          <source>Additionally, built-in exceptions with a structured argument that includes a string also have the attribute set: Assert_failure and Match_failure will raise the warning for a pattern that uses a literal string to match the first element of their tuple argument.</source>
          <target state="translated">此外,包含字符串的结构化参数的内置异常也有属性集。Assert_failure和Match_failure会对使用字面字符串来匹配元组参数第一个元素的模式发出警告。</target>
        </trans-unit>
        <trans-unit id="d70f93df5e8f9b55be44fbeee9d203972e3383d4" translate="yes" xml:space="preserve">
          <source>Address</source>
          <target state="translated">Address</target>
        </trans-unit>
        <trans-unit id="53cce0631f5ba4546493e150cc5ef970434eef7f" translate="yes" xml:space="preserve">
          <source>Address already in use</source>
          <target state="translated">已使用的地址</target>
        </trans-unit>
        <trans-unit id="cf3745f20c2bcb9c33dec185e795a8e5bec761e0" translate="yes" xml:space="preserve">
          <source>Address family not supported by protocol family</source>
          <target state="translated">协议族不支持的地址族</target>
        </trans-unit>
        <trans-unit id="84b449a1c0e4b819e90ee96bb46539dc08f8d4fc" translate="yes" xml:space="preserve">
          <source>Address information returned by &lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt;&lt;code&gt;Unix.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt; &lt;code&gt;Unix.getaddrinfo&lt;/code&gt; &lt;/a&gt;返回的地址信息。</target>
        </trans-unit>
        <trans-unit id="7200f838d0d51ee1b13f7e58cb82696602e150a5" translate="yes" xml:space="preserve">
          <source>Address information returned by &lt;a href=&quot;unixlabels#VALgetaddrinfo&quot;&gt;&lt;code&gt;UnixLabels.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALgetaddrinfo&quot;&gt; &lt;code&gt;UnixLabels.getaddrinfo&lt;/code&gt; &lt;/a&gt;返回的地址信息。</target>
        </trans-unit>
        <trans-unit id="437f5bf76096253ec5e607400ed8854d25d29c9a" translate="yes" xml:space="preserve">
          <source>Adds the directory dir to the run-time search path for shared C libraries. At link-time, shared libraries are searched in the standard search path (the one corresponding to the -I option). The -dllpath option simply stores dir in the produced executable file, where ocamlrun can find it and use it as described in section &amp;zwj;&lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;.</source>
          <target state="translated">将目录dir添加到共享C库的运行时搜索路径中。在链接时，将在标准搜索路径（与-I选项相对应的路径）中搜索共享库。所述-dllpath选项简单地存储目录中所产生的可执行文件中，其中ocamlrun可以找到并使用它作为在部分所述&lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5270967f8aa725bc38f8d3001d92c3c290cfd4e3" translate="yes" xml:space="preserve">
          <source>Adds the directory dir to the run-time search path for shared C libraries. At link-time, shared libraries are searched in the standard search path (the one corresponding to the -I option). The -dllpath option simply stores dir in the produced executable file, where ocamlrun can find it and use it as described in section &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;.</source>
          <target state="translated">将目录dir添加到共享C库的运行时搜索路径中。在链接时，将在标准搜索路径（与-I选项相对应的路径）中搜索共享库。-dllpath选项只是将dir存储在生成的可执行文件中，ocamlrun可以在其中找到它并按照&lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;节中的描述使用它。</target>
        </trans-unit>
        <trans-unit id="b8d4ba924eb9ae0cdf52c36ae7d6177d243e3d97" translate="yes" xml:space="preserve">
          <source>Advanced functions</source>
          <target state="translated">高级功能</target>
        </trans-unit>
        <trans-unit id="5be1dccb0ebeabdbef35b5315c8f47e16cedaecc" translate="yes" xml:space="preserve">
          <source>Advanced options, only needed for detailed tuning:</source>
          <target state="translated">高级选项,只需要详细的调整。</target>
        </trans-unit>
        <trans-unit id="7fd85ae0c465f1d173aeb4b1bcfa8f8c49970ca7" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;Hashtbl.randomize()&lt;/code&gt;, hash tables are created in randomized mode by default: &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; returns randomized hash tables, unless the &lt;code&gt;~random:false&lt;/code&gt; optional parameter is given.</source>
          <target state="translated">调用 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 之后，默认情况下&lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; &lt;/a&gt;随机模式创建哈希表：Hashtbl.create返回随机哈希表，除非给出〜random &lt;code&gt;~random:false&lt;/code&gt; 可选参数。</target>
        </trans-unit>
        <trans-unit id="02e705c02a6171a4c6d4fea54dc86bfd5ddbe3e1" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;Hashtbl.randomize()&lt;/code&gt;, hash tables are created in randomized mode by default: &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; returns randomized hash tables, unless the &lt;code&gt;~random:false&lt;/code&gt; optional parameter is given. The same effect can be achieved by setting the &lt;code&gt;R&lt;/code&gt; parameter in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="translated">调用 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 之后，默认情况下&lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; &lt;/a&gt;随机模式创建哈希表：Hashtbl.create返回随机哈希表，除非给出〜random &lt;code&gt;~random:false&lt;/code&gt; 可选参数。通过在 &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 环境变量中设置 &lt;code&gt;R&lt;/code&gt; 参数，可以达到相同的效果。</target>
        </trans-unit>
        <trans-unit id="61caa4de5eff64223a8029ed1e92b7011572790a" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;Hashtbl.randomize()&lt;/code&gt;, hash tables are created in randomized mode by default: &lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt;&lt;/a&gt; returns randomized hash tables, unless the &lt;code&gt;~random:false&lt;/code&gt; optional parameter is given.</source>
          <target state="translated">调用 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 之后，默认情况下&lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt; &lt;/a&gt;随机模式创建哈希表：MoreLabels.Hashtbl.create返回随机哈希表，除非指定了〜random &lt;code&gt;~random:false&lt;/code&gt; 可选参数。</target>
        </trans-unit>
        <trans-unit id="98629826bbd94512968cb2fb2555a7bcbaa51c6d" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;Hashtbl.randomize()&lt;/code&gt;, hash tables are created in randomized mode by default: &lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt;&lt;/a&gt; returns randomized hash tables, unless the &lt;code&gt;~random:false&lt;/code&gt; optional parameter is given. The same effect can be achieved by setting the &lt;code&gt;R&lt;/code&gt; parameter in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="translated">调用 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 之后，默认情况下&lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt; &lt;/a&gt;随机模式创建哈希表：MoreLabels.Hashtbl.create返回随机哈希表，除非指定了〜random &lt;code&gt;~random:false&lt;/code&gt; 可选参数。通过在 &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 环境变量中设置 &lt;code&gt;R&lt;/code&gt; 参数，可以达到相同的效果。</target>
        </trans-unit>
        <trans-unit id="ac648fcd20415a281eac85d7cfc4129ef642c1e4" translate="yes" xml:space="preserve">
          <source>After caml_release_runtime_system() was called and until caml_acquire_runtime_system() is called, the C code must not access any OCaml data, nor call any function of the run-time system, nor call back into OCaml code. Consequently, arguments provided by OCaml to the C primitive must be copied into C data structures before calling caml_release_runtime_system(), and results to be returned to OCaml must be encoded as OCaml values after caml_acquire_runtime_system() returns.</source>
          <target state="translated">在caml_release_runtime_system()被调用之后,直到caml_acquire_runtime_system()被调用之前,C代码不能访问任何OCaml数据,也不能调用运行时系统的任何函数,也不能调用回OCaml代码。因此,OCaml提供给C基元的参数必须在调用caml_release_runtime_system()之前复制到C数据结构中,而要返回给OCaml的结果必须在caml_acquire_runtime_system()返回后编码为OCaml值。</target>
        </trans-unit>
        <trans-unit id="22f3f0c73dbb8d47c45b8752a616d7f9c2523dbd" translate="yes" xml:space="preserve">
          <source>After executing this directive, all calls to the function named function-name will be &amp;ldquo;traced&amp;rdquo;. That is, the argument and the result are displayed for each call, as well as the exceptions escaping out of the function, raised either by the function itself or by another function it calls. If the function is curried, each argument is printed as it is passed to the function.</source>
          <target state="translated">执行完此指令后，将对所有名为function-name的函数的调用进行&amp;ldquo;跟踪&amp;rdquo;。也就是说，将为每个调用显示参数和结果，以及由函数本身或由其调用的另一个函数引发的从函数中逸出的异常。如果函数是咖喱的，则每个参数在传递给函数时都会打印出来。</target>
        </trans-unit>
        <trans-unit id="257160058fb41d4072933c8170fd8f8c677a4ecd" translate="yes" xml:space="preserve">
          <source>After having described two different ways of linking C code with OCaml code, we now review the pros and cons of each, to help developers of mixed OCaml/C libraries decide.</source>
          <target state="translated">在介绍了两种不同的C代码与OCaml代码的链接方式后,我们现在回顾一下每种方式的优缺点,以帮助OCaml/C混合库的开发人员做出决定。</target>
        </trans-unit>
        <trans-unit id="f4b712f12ee962e9088425b2d7e23377568c3262" translate="yes" xml:space="preserve">
          <source>After parsing, pipe the abstract syntax tree through the preprocessor command.</source>
          <target state="translated">解析完毕后,通过预处理器命令管好抽象语法树。</target>
        </trans-unit>
        <trans-unit id="66040e8fc6deb97be0082ccf3aba90dc5ea7ac73" translate="yes" xml:space="preserve">
          <source>After parsing, pipe the abstract syntax tree through the preprocessor command. The module Ast_mapper, described in chapter &amp;zwj;&lt;a href=&quot;parsing#c%3Aparsinglib&quot;&gt;24&lt;/a&gt;: &lt;a href=&quot;https://www.ocaml.org/releases/4.12/htmlman/compilerlibref/Ast_mapper.html&quot;&gt; Ast_mapper &lt;/a&gt; , implements the external interface of a preprocessor.</source>
          <target state="translated">解析之后，通过预处理器命令通过管道传递抽象语法树。该模块Ast_mapper，在章节描述&lt;a href=&quot;parsing#c%3Aparsinglib&quot;&gt;24&lt;/a&gt;：&lt;a href=&quot;https://www.ocaml.org/releases/4.12/htmlman/compilerlibref/Ast_mapper.html&quot;&gt;Ast_mapper&lt;/a&gt;，实施预处理器的外部接口。</target>
        </trans-unit>
        <trans-unit id="ee48a1ecc4cbaee8ef092b9aba20f2e0cf9fdf5e" translate="yes" xml:space="preserve">
          <source>After parsing, pipe the abstract syntax tree through the preprocessor command. The module Ast_mapper, described in chapter &lt;a href=&quot;parsing#c%3Aparsinglib&quot;&gt;27&lt;/a&gt;: &lt;a href=&quot;https://www.ocaml.org/releases/4.11/htmlman/compilerlibref/Ast_mapper.html&quot;&gt; Ast_mapper &lt;/a&gt; , implements the external interface of a preprocessor.</source>
          <target state="translated">解析之后，通过预处理器命令通过管道传递抽象语法树。在第&lt;a href=&quot;parsing#c%3Aparsinglib&quot;&gt;27&lt;/a&gt;章：&lt;a href=&quot;https://www.ocaml.org/releases/4.11/htmlman/compilerlibref/Ast_mapper.html&quot;&gt;Ast_mapper中&lt;/a&gt;描述的模块Ast_mapper实现了预处理器的外部接口。</target>
        </trans-unit>
        <trans-unit id="dd92f6a0efeae359634460366d11e9ed96823d66" translate="yes" xml:space="preserve">
          <source>After seeing the power of polymorphic variants, one may wonder why they were added to core language variants, rather than replacing them.</source>
          <target state="translated">看到多态变体的威力后,可能有人会问,为什么要把多态变体加入核心语言变体,而不是取代核心语言变体呢?</target>
        </trans-unit>
        <trans-unit id="98077527fdcfbdc6101af79b0d0d9c0e8c053b7f" translate="yes" xml:space="preserve">
          <source>After some simplification one obtains:</source>
          <target state="translated">经过一些简化后,可以得到:</target>
        </trans-unit>
        <trans-unit id="a7dfd6ec974bc59afe5b3477ea504301f11b2496" translate="yes" xml:space="preserve">
          <source>After storing an int inside another_store, the type of another_store has been updated from '_weak2 option ref to int option ref. This distinction between weakly and generic polymorphic type variable protects OCaml programs from unsoundness and runtime errors. To understand from where unsoundness might come, consider this simple function which swaps a value x with the value stored inside a store reference, if there is such value:</source>
          <target state="translated">在another_store里面存储一个int后,another_store的类型已经从'_weak2 option ref更新为int option ref。弱类型变量和通用多态类型变量之间的这种区别,保护了OCaml程序的不健全性和运行时错误。要了解不健全性可能来自哪里,请考虑这个简单的函数,它将一个值 x 与存储在 store 引用中的值交换,如果有这样的值的话。</target>
        </trans-unit>
        <trans-unit id="de2424914b6a7484490fab4a07f86daa99ea2b9c" translate="yes" xml:space="preserve">
          <source>After these three swaps the stored value is 3. Everything is fine up to now. We can then try to swap 3 with a more interesting value, for instance a function:</source>
          <target state="translated">经过这三次交换,存储的值是3。然后我们可以尝试用一个更有趣的值来交换3,例如一个函数。</target>
        </trans-unit>
        <trans-unit id="8b9ebba0b459da8f8a959c4937a6826b5bb4adc4" translate="yes" xml:space="preserve">
          <source>After these two transformations, expressions are of the form</source>
          <target state="translated">经过这两次转换,表达式的形式为</target>
        </trans-unit>
        <trans-unit id="6abac20e5141bcf76b8ded1230cdbf8efd381047" translate="yes" xml:space="preserve">
          <source>Again due to inlining, there may be multiple distinct raw_backtrace_entry values that convert to equal &lt;code&gt;backtrace_slot&lt;/code&gt;s. However, if two &lt;code&gt;raw_backtrace_entry&lt;/code&gt;s are equal as integers, then they represent the same &lt;code&gt;backtrace_slot&lt;/code&gt;s.</source>
          <target state="translated">同样由于内联，可能会有多个不同的raw_backtrace_entry值转换为相等的 &lt;code&gt;backtrace_slot&lt;/code&gt; 。但是，如果两个 &lt;code&gt;raw_backtrace_entry&lt;/code&gt; 等于整数，则它们表示相同的 &lt;code&gt;backtrace_slot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68b46d92c4b3bfc51be50c9bc62acab867d8d2bb" translate="yes" xml:space="preserve">
          <source>Again, there is nothing magical with references: they are implemented as a single-field mutable record, as follows.</source>
          <target state="translated">同样,引用也没有什么神奇的地方:它们被实现为一个单字段的可变记录,如下所示。</target>
        </trans-unit>
        <trans-unit id="ecd0fa8e76723ac77809d90f781cf47149c2c8dc" translate="yes" xml:space="preserve">
          <source>Alert categories are identified by a symbolic identifier (a lowercase identifier, following the usual lexical rules) and an optional message. The identifier is used to control which alerts are enabled, and which ones are turned into fatal errors. The message is reported to the user when the alert is triggered (i.e. when the marked component is referenced).</source>
          <target state="translated">警报类别由一个符号标识符(小写标识符,遵循通常的词汇规则)和一条可选的信息来标识。该标识符用于控制哪些警报被启用,以及哪些警报被转化为致命错误。当警报被触发时(即当被标记的组件被引用时),消息会报告给用户。</target>
        </trans-unit>
        <trans-unit id="821334d0607e9afb49ba329bf32f1077eb433ccf" translate="yes" xml:space="preserve">
          <source>Alias for warning 10.</source>
          <target state="translated">警告的别称10。</target>
        </trans-unit>
        <trans-unit id="4b5faefdecb0d6fd295593a70f0d88b7f5386973" translate="yes" xml:space="preserve">
          <source>Alias for warning 13.</source>
          <target state="translated">警告的别称 13.</target>
        </trans-unit>
        <trans-unit id="6eece4bf4c590c7dca347390d3119eb2ce22ea01" translate="yes" xml:space="preserve">
          <source>Alias for warning 26.</source>
          <target state="translated">警告的别称 26.</target>
        </trans-unit>
        <trans-unit id="4163b3aea847321829d86afa31a4866fa132ed79" translate="yes" xml:space="preserve">
          <source>Alias for warning 27.</source>
          <target state="translated">警告的别称 27.</target>
        </trans-unit>
        <trans-unit id="32df4d86c18ecdcc1901160c34d77742ec601179" translate="yes" xml:space="preserve">
          <source>Alias for warning 3.</source>
          <target state="translated">警告3的别名。</target>
        </trans-unit>
        <trans-unit id="bd24a64bfd177df95e265236817244ef9d001bc3" translate="yes" xml:space="preserve">
          <source>Alias for warning 4.</source>
          <target state="translated">警告的别称4。</target>
        </trans-unit>
        <trans-unit id="7880efc4150138dded4fa14b7a41acde0e894e3f" translate="yes" xml:space="preserve">
          <source>Alias for warning 5.</source>
          <target state="translated">警告的别称5。</target>
        </trans-unit>
        <trans-unit id="77c8d2d8da2b271f2b475dfe61c813fbeffb3ca5" translate="yes" xml:space="preserve">
          <source>Alias for warning 6.</source>
          <target state="translated">警告的别称6。</target>
        </trans-unit>
        <trans-unit id="215bcb589afee870a003884e4452475af7c5ed14" translate="yes" xml:space="preserve">
          <source>Alias for warning 7.</source>
          <target state="translated">警告的别称 7.</target>
        </trans-unit>
        <trans-unit id="963fdff6a5307cc304547c984bd4142a3b4696d5" translate="yes" xml:space="preserve">
          <source>Alias for warning 8.</source>
          <target state="translated">警告的别称8。</target>
        </trans-unit>
        <trans-unit id="088453e73019790a41f30c40d4205f51a852ec4c" translate="yes" xml:space="preserve">
          <source>Alias for warning 9.</source>
          <target state="translated">警告的别称 9.</target>
        </trans-unit>
        <trans-unit id="cd069e9b1f6d0a212cf41e18091994c486044df3" translate="yes" xml:space="preserve">
          <source>Align the documentation strings by inserting spaces at the first alignment separator (tab or, if tab is not found, space), according to the length of the keyword.</source>
          <target state="translated">根据关键字的长度,在第一个对齐分隔符(tab或,如果找不到tab,则为空格)处插入空格来对齐文档字符串。</target>
        </trans-unit>
        <trans-unit id="7e3d3b738466251ab926226a86221e4d1ccacf36" translate="yes" xml:space="preserve">
          <source>Align the documentation strings by inserting spaces at the first alignment separator (tab or, if tab is not found, space), according to the length of the keyword. Use a alignment separator as the first character in a doc string if you want to align the whole string. The doc strings corresponding to &lt;code&gt;Symbol&lt;/code&gt; arguments are aligned on the next line.</source>
          <target state="translated">根据关键字的长度，在第一个对齐分隔符（制表符，如果未找到制表符，则为空格）处插入空格，以对齐文档字符串。如果要对齐整个字符串，请使用对齐分隔符作为文档字符串中的第一个字符。与 &lt;code&gt;Symbol&lt;/code&gt; 参数相对应的doc字符串在下一行对齐。</target>
        </trans-unit>
        <trans-unit id="50e67b08d6e3d9f789945f9c7fdbe8a81e2fa03b" translate="yes" xml:space="preserve">
          <source>All OCaml objects are represented by the C type value, defined in the include file caml/mlvalues.h, along with macros to manipulate values of that type. An object of type value is either:</source>
          <target state="translated">所有的OCaml对象都是由C类型值来表示的,它定义在包含文件caml/mlvalues.h中,同时还有宏来操作该类型的值。一个类型值的对象要么是。</target>
        </trans-unit>
        <trans-unit id="df48daa3b9798ecd1f34fe9ea2fad4646f39d23f" translate="yes" xml:space="preserve">
          <source>All characters in an identifier are meaningful. The current implementation accepts identifiers up to 16000000 characters in length.</source>
          <target state="translated">一个标识符中的所有字符都是有意义的。目前的实现接受的标识符长度不超过1600万字符。</target>
        </trans-unit>
        <trans-unit id="e7e8354ee505ccbb4f53abb22215035e97f6f70d" translate="yes" xml:space="preserve">
          <source>All characters outside the US-ASCII printable range [0x20;0x7E] are escaped, as well as backslash (0x2F) and double-quote (0x22).</source>
          <target state="translated">US-ASCII可打印范围[0x20;0x7E]以外的所有字符,以及反斜杠(0x2F)和双引号(0x22)都被转义。</target>
        </trans-unit>
        <trans-unit id="f6df6defb9629939a8b8045bff562a3ca8d0bf6b" translate="yes" xml:space="preserve">
          <source>All examples given so far were executed under the interactive system. OCaml code can also be compiled separately and executed non-interactively using the batch compilers ocamlc and ocamlopt. The source code must be put in a file with extension .ml. It consists of a sequence of phrases, which will be evaluated at runtime in their order of appearance in the source file. Unlike in interactive mode, types and values are not printed automatically; the program must call printing functions explicitly to produce some output. The ;; used in the interactive examples is not required in source files created for use with OCaml compilers, but can be helpful to mark the end of a top-level expression unambiguously even when there are syntax errors. Here is a sample standalone program to print the greatest common divisor (gcd) of two numbers:</source>
          <target state="translated">目前给出的所有例子都是在交互式系统下执行的。OCaml代码也可以单独编译,并使用批处理编译器ocamlc和ocamlopt进行非交互式执行。源代码必须放在一个扩展名为.ml的文件中。它由一连串的短语组成,这些短语将在运行时按照它们在源文件中出现的顺序进行评估。与交互式模式不同的是,类型和值不会自动打印;程序必须显式调用打印函数来产生一些输出。在交互式示例中使用的;;在为与OCaml编译器一起使用而创建的源文件中并不是必需的,但即使在存在语法错误时,也可以帮助明确地标记顶层表达式的结束。下面是一个打印两个数的最大公除数(gcd)的独立程序示例。</target>
        </trans-unit>
        <trans-unit id="ca5470f7fbad01a79cf6d9fb16235ab7f64f936b" translate="yes" xml:space="preserve">
          <source>All examples of modules so far have been given in the context of the interactive system. However, modules are most useful for large, batch-compiled programs. For these programs, it is a practical necessity to split the source into several files, called compilation units, that can be compiled separately, thus minimizing recompilation after changes.</source>
          <target state="translated">到目前为止,所有模块的例子都是在交互式系统的背景下给出的。然而,模块对于大型的、批量编译的程序是最有用的。对于这些程序,实际需要将源码分割成若干个文件,称为编译单元,可以分别编译,从而最大限度地减少修改后的重新编译。</target>
        </trans-unit>
        <trans-unit id="39c8d1b1c4caf1c601b893772f4974723068b285" translate="yes" xml:space="preserve">
          <source>All following functions raise &lt;code&gt;Invalid_argument&lt;/code&gt; if the space needed at index &lt;code&gt;i&lt;/code&gt; to decode or encode the integer is not available.</source>
          <target state="translated">如果索引 &lt;code&gt;i&lt;/code&gt; 解码或编码整数所需的空间不可用，则所有以下所有函数都会引发 &lt;code&gt;Invalid_argument&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4350dcd576a4e74e66f577f6d6df18a6f84b5433" translate="yes" xml:space="preserve">
          <source>All identifiers starting with __ocaml_lex are reserved for use by ocamllex; do not use any such identifier in your programs.</source>
          <target state="translated">所有以__ocaml_lex开头的标识符都是由ocamllex保留使用的,不要在你的程序中使用任何这样的标识符。</target>
        </trans-unit>
        <trans-unit id="71e79e2a4589c52dc85926f87b5a7800dc39bd3b" translate="yes" xml:space="preserve">
          <source>All of this contrasts with the normal Flambda mode, that is to say without -Oclassic, where:</source>
          <target state="translated">所有这些都与正常的Flambda模式形成了鲜明的对比,也就是说没有-Oclassic,其中。</target>
        </trans-unit>
        <trans-unit id="c797607c91b085bf9b06812cc7196d849ff516b3" translate="yes" xml:space="preserve">
          <source>All open pretty-printing boxes are closed, all pending text is printed.</source>
          <target state="translated">所有打开的漂亮打印框都是关闭的,所有待打印的文字都是打印的。</target>
        </trans-unit>
        <trans-unit id="d0b207b88f6d453906fd55cf2a3659eb2c4f68c8" translate="yes" xml:space="preserve">
          <source>All open pretty-printing boxes are closed, all pending text is printed. In addition, the pretty-printer low level output device is flushed to ensure that all pending text is really displayed.</source>
          <target state="translated">所有打开的漂亮打印框都被关闭,所有待打印的文字都被打印出来。另外,漂亮打印箱低电平输出设备被刷新,以确保所有待打印文字真正显示出来。</target>
        </trans-unit>
        <trans-unit id="6551aef0a45b5b4f68c9d4cf5ba28e52be6a56df" translate="yes" xml:space="preserve">
          <source>All other expressions.</source>
          <target state="translated">其他所有的表达方式。</target>
        </trans-unit>
        <trans-unit id="c885373b4f263d43af575175d00b5ef8dd474226" translate="yes" xml:space="preserve">
          <source>All the already tracked blocks are discarded.</source>
          <target state="translated">所有已经跟踪的区块都被丢弃。</target>
        </trans-unit>
        <trans-unit id="89ce9c04ef612cfe47b0f97ee0f6297c501a4eee" translate="yes" xml:space="preserve">
          <source>All the already tracked blocks are discarded. If there are pending postponed callbacks, they may be discarded.</source>
          <target state="translated">所有已经跟踪的块都被丢弃。如果有待定的推迟回调,它们可能会被丢弃。</target>
        </trans-unit>
        <trans-unit id="206daea334aed98570a738274bdc211c4eba092a" translate="yes" xml:space="preserve">
          <source>All the macros described in this section are declared in the memory.h header file.</source>
          <target state="translated">本节中描述的所有宏都在memory.h头文件中声明。</target>
        </trans-unit>
        <trans-unit id="fcce04f333a29fbbb1662957786419fcadd58918" translate="yes" xml:space="preserve">
          <source>All the types defined in this module cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; or the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">不能使用&lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt;模块的功能来整理此模块中定义的所有类型。</target>
        </trans-unit>
        <trans-unit id="5a19322561e155e0a2ce027d9a7b57fb495aafc3" translate="yes" xml:space="preserve">
          <source>All these are only suggestions, but keep in mind that the choice of labels is essential for readability. Bizarre choices will make the program harder to maintain.</source>
          <target state="translated">所有这些都只是建议,但请记住,标签的选择对可读性至关重要。怪异的选择会让程序更难维护。</target>
        </trans-unit>
        <trans-unit id="17ff6b82a7573e6fc2606123d9479ee9046c5f88" translate="yes" xml:space="preserve">
          <source>All toplevel expressions in the loaded compilation units are evaluated. No facilities are provided to access value names defined by the unit. Therefore, the unit must itself register its entry points with the main program (or a previously-loaded library) e.g. by modifying tables of functions.</source>
          <target state="translated">所有加载的编译单元中的toplevel表达式都会被评估。没有提供任何设施来访问单元定义的值名。因此,单元必须自己向主程序(或之前加载的库)注册它的入口点,例如通过修改函数表。</target>
        </trans-unit>
        <trans-unit id="cff492aa66c39fd91b14adc9bbf1e9b13c1f3ced" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. By default, only recursive types where the recursion goes through an object type are supported.</source>
          <target state="translated">在类型检查过程中允许任意递归类型。默认情况下,只支持递归通过对象类型的递归类型。</target>
        </trans-unit>
        <trans-unit id="bfccfe308745d0b85e1ddbf443fd40e1997b55e3" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. By default, only recursive types where the recursion goes through an object type are supported.Note that once you have created an interface using this flag, you must use it again for all dependencies.</source>
          <target state="translated">允许在类型检查过程中使用任意递归类型,默认情况下,只支持递归通过对象类型的递归类型。默认情况下,只支持递归通过对象类型的递归类型。注意,一旦你使用这个标志创建了一个接口,你必须对所有的依赖关系再次使用它。</target>
        </trans-unit>
        <trans-unit id="aacfe39edb68023f9b53979cfb137d43eb38557f" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. Note: once enabled, this option cannot be disabled because that would lead to unsoundness of the type system.</source>
          <target state="translated">在类型检查过程中允许任意递归类型。注意:一旦启用,这个选项不能被禁用,因为这会导致类型系统的不健全。</target>
        </trans-unit>
        <trans-unit id="d16d714ce85383f7fc519249166d89d83b1fed95" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types. (See the -rectypes option to ocamlc.)</source>
          <target state="translated">允许任意递归类型。(参见 ocamlc 的 -rectypes 选项)</target>
        </trans-unit>
        <trans-unit id="9e6cfa8f1f0745980bd8e3a9df75ee4c71720548" translate="yes" xml:space="preserve">
          <source>Allow falling back on a lexer-based approximation when parsing fails.</source>
          <target state="translated">当解析失败时,允许回到基于词法的近似。</target>
        </trans-unit>
        <trans-unit id="85da47a281df6548dd01179f6fb7cd171470ae40" translate="yes" xml:space="preserve">
          <source>Allow reuse of address and port bindings</source>
          <target state="translated">允许重复使用地址和端口绑定。</target>
        </trans-unit>
        <trans-unit id="f6a7ba8579f52788429ec3c986d236f094628562" translate="yes" xml:space="preserve">
          <source>Allow reuse of local addresses for bind</source>
          <target state="translated">允许重复使用本地地址进行绑定</target>
        </trans-unit>
        <trans-unit id="bb7adde246f249f8dc82789201ca6af6580832c5" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use some optimizations that are valid only for code that is never dynlinked.</source>
          <target state="translated">允许编译器使用一些只对从未dynlinked的代码有效的优化。</target>
        </trans-unit>
        <trans-unit id="07c0b8b3a49f3e742ee31b0470b6ac246240b750" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use some optimizations that are valid only for code that is statically linked to produce a non-relocatable executable. The generated code cannot be linked to produce a shared library nor a position-independent executable (PIE). Many operating systems produce PIEs by default, causing errors when linking code compiled with -nodynlink. Either do not use -nodynlink or pass the option -ccopt -no-pie at link-time.</source>
          <target state="translated">允许编译器使用一些优化,这些优化只对静态链接的代码有效,以产生一个不可重定位的可执行文件。生成的代码不能链接生成共享库,也不能链接生成位置无关的可执行文件(PIE)。许多操作系统在默认情况下会产生PIE,当链接用-nodynlink编译的代码时,会导致错误。要么不使用-nodynlink,要么在链接时传递选项-ccopt -no-pie。</target>
        </trans-unit>
        <trans-unit id="1ca705a2ff6c8f1e818a0c819bb67a88c184d39c" translate="yes" xml:space="preserve">
          <source>Also note that exceptions raised by user code in the interactive toplevel are not passed to this function as they are caught by the toplevel itself.</source>
          <target state="translated">同时注意,用户代码在交互式toplevel中引发的异常不会传递给这个函数,因为它们是由toplevel本身捕获的。</target>
        </trans-unit>
        <trans-unit id="73c938c60afba012453b4b0c8907a74c515465fa" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;list#VALfold_left&quot;&gt;&lt;code&gt;List.fold_left&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">另请参见&lt;a href=&quot;list#VALfold_left&quot;&gt; &lt;code&gt;List.fold_left&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4b2c25bebd20c1df230a4e4e8766f8390e7df9e" translate="yes" xml:space="preserve">
          <source>Also, finalization can be performed by trapping all exceptions, performing the finalization, then re-raising the exception:</source>
          <target state="translated">另外,还可以通过捕获所有异常,进行最终化,然后重新提出异常。</target>
        </trans-unit>
        <trans-unit id="762745851a3dbf826d56e09e22e9a0b4a5051807" translate="yes" xml:space="preserve">
          <source>Alternate end-of-line char. (usually none).</source>
          <target state="translated">备用行尾字符。(通常没有)。</target>
        </trans-unit>
        <trans-unit id="a8e1724ceb669eb15e9b85abbb432d9fd0962e04" translate="yes" xml:space="preserve">
          <source>Alternative executable to use instead of the configured value. Primarily used for bootstrapping.</source>
          <target state="translated">用来代替配置值的替代可执行文件。主要用于引导。</target>
        </trans-unit>
        <trans-unit id="20a3dd320f432929619399edc970bd7bc9279557" translate="yes" xml:space="preserve">
          <source>Alternative executable to use on native Windows for flexlink instead of the configured value. Primarily used for bootstrapping.</source>
          <target state="translated">在本机Windows上使用的替代可执行文件,代替配置值的flexlink。主要用于引导。</target>
        </trans-unit>
        <trans-unit id="c9e397bee97f159dc7f7a7adecb64951a2a4af03" translate="yes" xml:space="preserve">
          <source>Alternatively, given &lt;code&gt;out_funs&lt;/code&gt;, a complete set of output functions for a formatter, then &lt;a href=&quot;format#VALformatter_of_out_functions&quot;&gt;&lt;code&gt;Format.formatter_of_out_functions&lt;/code&gt;&lt;/a&gt;&lt;code&gt;out_funs&lt;/code&gt; computes a new formatter using those functions for output.</source>
          <target state="translated">或者，给定 &lt;code&gt;out_funs&lt;/code&gt; ，为格式化程序提供完整的输出函数集，然后&lt;a href=&quot;format#VALformatter_of_out_functions&quot;&gt; &lt;code&gt;Format.formatter_of_out_functions&lt;/code&gt; &lt;/a&gt; &lt;code&gt;out_funs&lt;/code&gt; 使用这些函数输出一个新的格式化程序。</target>
        </trans-unit>
        <trans-unit id="a2378a94f2955b1ab0316e6ec9c0c06da7e7f400" translate="yes" xml:space="preserve">
          <source>Alternatively, out-of-heap pointers can be treated as &amp;ldquo;native&amp;rdquo; integers, that is, boxed 32-bit integers on a 32-bit platform and boxed 64-bit integers on a 64-bit platform.</source>
          <target state="translated">或者，可以将堆外指针视为&amp;ldquo;本机&amp;rdquo;整数，即在32位平台上装箱的32位整数和在64位平台上装箱的64位整数。</target>
        </trans-unit>
        <trans-unit id="22956d1c15dfacc465b97fb1216a724af81628b4" translate="yes" xml:space="preserve">
          <source>Alternatively, the selection can be performed within a function:</source>
          <target state="translated">另外,也可以在一个函数中进行选择。</target>
        </trans-unit>
        <trans-unit id="babc527500b81de3000bdcf9d68c44443c7e9cb0" translate="yes" xml:space="preserve">
          <source>Alternatively, warning-list can specify a single warning using its mnemonic name (see below), as follows:</source>
          <target state="translated">另外,warning-list可以使用它的记号名称(见下文)指定一个单一的警告,如下所示。</target>
        </trans-unit>
        <trans-unit id="af98d4c955e2ccef6756948db1dc2a57c6318273" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;Format.fprintf&lt;/code&gt; with a formatter writing to a buffer of your own: flushing the formatter and the buffer at the end of pretty-printing returns the desired string.</source>
          <target state="translated">另外，也可以将 &lt;code&gt;Format.fprintf&lt;/code&gt; 与格式化程序一起使用，以写入自己的缓冲区：在格式化打印结束时刷新格式化程序和缓冲区将返回所需的字符串。</target>
        </trans-unit>
        <trans-unit id="4726692b1723191b531b8e035b61a6c25efd7572" translate="yes" xml:space="preserve">
          <source>Although their types are mutually recursive, the classes widget and window are themselves independent.</source>
          <target state="translated">虽然它们的类型是相互递归的,但widget和window这两个类本身是独立的。</target>
        </trans-unit>
        <trans-unit id="7c908f24c3f9127570182550db0e5d68e44a44f0" translate="yes" xml:space="preserve">
          <source>Always keep the source code for values, methods and instance variables, when available.</source>
          <target state="translated">如果有值、方法和实例变量,一定要保留源代码。</target>
        </trans-unit>
        <trans-unit id="e311d4a9e00e01c3467c09939095dc2e546b21f9" translate="yes" xml:space="preserve">
          <source>Always return a copy of the argument, even if there is no escape sequence in the argument.</source>
          <target state="translated">即使参数中没有转义序列,也总是返回一个参数的副本。</target>
        </trans-unit>
        <trans-unit id="2a65be1ce8c39c33cb18ddead7b98c2d7c382ae6" translate="yes" xml:space="preserve">
          <source>Always return host as IP address</source>
          <target state="translated">始终将主机作为IP地址返回</target>
        </trans-unit>
        <trans-unit id="ad666310edb265f674bc11f8775c66a735702bac" translate="yes" xml:space="preserve">
          <source>Always return service as port number</source>
          <target state="translated">总是以端口号返回服务</target>
        </trans-unit>
        <trans-unit id="f9929d854921839b4c7c71e3b9b8cd03f9593e78" translate="yes" xml:space="preserve">
          <source>Ambiguous constructor or label name.</source>
          <target state="translated">含糊不清的构造函数或标签名称。</target>
        </trans-unit>
        <trans-unit id="10ea978f8642bd9c15dc5c2e1359af1c0f49c808" translate="yes" xml:space="preserve">
          <source>Ambiguous or-pattern variables under guard.</source>
          <target state="translated">暧昧的或模式变量的防范。</target>
        </trans-unit>
        <trans-unit id="86e2d740f02490dab43c8609e88cb1c2412ec0e6" translate="yes" xml:space="preserve">
          <source>American fuzzy lop (&amp;ldquo;afl-fuzz&amp;rdquo;) is a &lt;em&gt;fuzzer&lt;/em&gt;, a tool for testing software by providing randomly-generated inputs, searching for those inputs which cause the program to crash.</source>
          <target state="translated">American Fuzzy Lop（&amp;ldquo; afl-fuzz&amp;rdquo;）是一种模糊&lt;em&gt;器&lt;/em&gt;，一种通过提供随机生成的输入来搜索软件的工具，可以搜索导致程序崩溃的输入。</target>
        </trans-unit>
        <trans-unit id="a81b2ff4decb6b38b93db069e3be04ea968bfc9c" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;index&lt;/em&gt;&lt;code&gt;i&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; is an integer in the range [&lt;code&gt;0&lt;/code&gt;;&lt;code&gt;n-1&lt;/code&gt;]. It represents the &lt;code&gt;i&lt;/code&gt;th byte (character) of &lt;code&gt;s&lt;/code&gt; which can be accessed using the constant time string indexing operator &lt;code&gt;s.[i]&lt;/code&gt;.</source>
          <target state="translated">一个&lt;em&gt;索引&lt;/em&gt; &lt;code&gt;i&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 是在范围[整数 &lt;code&gt;0&lt;/code&gt; ; &lt;code&gt;n-1&lt;/code&gt; ]。它代表了 &lt;code&gt;i&lt;/code&gt; 个字节的（字符） &lt;code&gt;s&lt;/code&gt; 这可以使用恒定的时间字符串索引操作符来访问 &lt;code&gt;s.[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c87e40750c7790bbaecda1715323b2a074993318" translate="yes" xml:space="preserve">
          <source>An OCaml bytecode library .cma incorporating the .cmo and .ml OCaml files given as arguments, and automatically referencing the C library generated with the C object files.</source>
          <target state="translated">OCaml字节码库.cma包含了作为参数的.cmo和.ml OCaml文件,并自动引用C对象文件生成的C库。</target>
        </trans-unit>
        <trans-unit id="ec67d9125ab88dc6496a757820db820c3fd6614c" translate="yes" xml:space="preserve">
          <source>An OCaml native-code library .cmxa incorporating the .cmx and .ml OCaml files given as arguments, and automatically referencing the C library generated with the C object files.</source>
          <target state="translated">OCaml本地代码库.cmxa包含了作为参数的.cmx和.ml OCaml文件,并自动引用C对象文件生成的C库。</target>
        </trans-unit>
        <trans-unit id="2da66ccddbbcfc69305f9b4de6de7b35a0a2c218" translate="yes" xml:space="preserve">
          <source>An abstract module type specification moduletype&lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; allows the name &lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; to be implemented by any module type in a matching signature, but hides the implementation of the module type to all users of the signature.</source>
          <target state="translated">抽象模块类型规范moduletype &lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt;允许名称&lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt;由匹配签名中的任何模块类型实现，但对签名的所有用户隐藏该模块类型的实现。</target>
        </trans-unit>
        <trans-unit id="2dda98608502104a1eef0559ef406e0808aa2e72" translate="yes" xml:space="preserve">
          <source>An alarm is a piece of data that calls a user function at the end of each major GC cycle.</source>
          <target state="translated">报警是在每个主要GC周期结束时调用用户函数的一个数据。</target>
        </trans-unit>
        <trans-unit id="4fceb9745728936fccfd146268101c81198650cd" translate="yes" xml:space="preserve">
          <source>An alarm is a piece of data that calls a user function at the end of each major GC cycle. The following functions are provided to create and delete alarms.</source>
          <target state="translated">警报是在每个主要GC周期结束时调用用户功能的数据。以下函数用于创建和删除警报。</target>
        </trans-unit>
        <trans-unit id="b6f6cdde9216626eff9ef96ec87f6e970e7b2170" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;scanf.scanning#VALopen_in&quot;&gt;&lt;code&gt;Scanf.Scanning.open_in&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">上面的&lt;a href=&quot;scanf.scanning#VALopen_in&quot;&gt; &lt;code&gt;Scanf.Scanning.open_in&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="d94611d8043a8545b1e3bbc68d41c964950c9b2a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;scanf.scanning#VALopen_in_bin&quot;&gt;&lt;code&gt;Scanf.Scanning.open_in_bin&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">上面的&lt;a href=&quot;scanf.scanning#VALopen_in_bin&quot;&gt; &lt;code&gt;Scanf.Scanning.open_in_bin&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="cc6d78a4f564a612f02eb3e53a69348dfb2281bc" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="9d62a81c2fb2390b9c75965ab9fc1bcdf2f00c8e" translate="yes" xml:space="preserve">
          <source>An alias for the type of 32-bit integers.</source>
          <target state="translated">32位整数类型的别称。</target>
        </trans-unit>
        <trans-unit id="70ad5e4e644da616967cd0761ef38fc4fa930352" translate="yes" xml:space="preserve">
          <source>An alias for the type of 64-bit integers.</source>
          <target state="translated">64位整数类型的别称。</target>
        </trans-unit>
        <trans-unit id="0ffd43f5a6ac5577677a3e5c18ebc5c3c0e13f18" translate="yes" xml:space="preserve">
          <source>An alias for the type of arrays.</source>
          <target state="translated">数组类型的别称。</target>
        </trans-unit>
        <trans-unit id="ecf287949a68ee4658b6d4c3e3ffed4775da1907" translate="yes" xml:space="preserve">
          <source>An alias for the type of byte sequences.</source>
          <target state="translated">字节序列类型的别称。</target>
        </trans-unit>
        <trans-unit id="7684332c689d34b944c7cc9c560de0bb8ee46fb6" translate="yes" xml:space="preserve">
          <source>An alias for the type of characters.</source>
          <target state="translated">字符类型的别称。</target>
        </trans-unit>
        <trans-unit id="059f0dfd54c481e45b90ac7f1f5e71ce3f8423cf" translate="yes" xml:space="preserve">
          <source>An alias for the type of floating-point numbers.</source>
          <target state="translated">浮点数类型的别称。</target>
        </trans-unit>
        <trans-unit id="f82332069f6fb0eaa86c82b6251782c31af87810" translate="yes" xml:space="preserve">
          <source>An alias for the type of lists.</source>
          <target state="translated">清单类型的别称。</target>
        </trans-unit>
        <trans-unit id="c247acfde9a1c78ec191af8d28b66b8a3b355b2d" translate="yes" xml:space="preserve">
          <source>An alias for the type of native integers.</source>
          <target state="translated">本机整数类型的别称。</target>
        </trans-unit>
        <trans-unit id="eccdacab8e7fee56a7a0223a9c11b8b3c6770334" translate="yes" xml:space="preserve">
          <source>An alias for the type of strings.</source>
          <target state="translated">字符串类型的别称。</target>
        </trans-unit>
        <trans-unit id="618bfd3d18801f1e655e28f356be63bd7b8562e3" translate="yes" xml:space="preserve">
          <source>An alternate definition of circle, using a constraint clause in the class definition, is shown below. The type #point used below in the constraint clause is an abbreviation produced by the definition of class point. This abbreviation unifies with the type of any object belonging to a subclass of class point. It actually expands to &amp;lt; get_x : int; move : int -&amp;gt; unit; .. &amp;gt;. This leads to the following alternate definition of circle, which has slightly stronger constraints on its argument, as we now expect center to have a method get_x.</source>
          <target state="translated">下面显示了在类定义中使用约束子句的圆的替代定义。约束子句中以下使用的#point类型是由类point的定义产生的缩写。该缩写与属于类点的子类的任何对象的类型统一。实际上，它扩展为&amp;lt;get_x：int;移动：int-&amp;gt; unit; ..&amp;gt;。这就导致了以下关于circle的替代定义，它对自变量的约束稍强，因为我们现在期望center具有get_x方法。</target>
        </trans-unit>
        <trans-unit id="7b47cacb3bfd9fd1aba0d42f40eff979b6e704b9" translate="yes" xml:space="preserve">
          <source>An alternate solution would have been to define the adjustment in a special allocation function:</source>
          <target state="translated">另一个解决办法是在一个特别分配函数中定义调整。</target>
        </trans-unit>
        <trans-unit id="129be3c9c278634e0d586c38102180489ee3087c" translate="yes" xml:space="preserve">
          <source>An alternate syntax is provided for the above:</source>
          <target state="translated">为上述内容提供了另一种语法。</target>
        </trans-unit>
        <trans-unit id="6e37cc574f0bc60ac62ba6fcfb9007dcb2805bd8" translate="yes" xml:space="preserve">
          <source>An alternate syntax is provided to bind variables to functional values: instead of writing</source>
          <target state="translated">提供了一种替代的语法来将变量绑定到函数值上:不需要编写</target>
        </trans-unit>
        <trans-unit id="37c7f98b5cff9fff6fb1cf1038c9406754cd6c8f" translate="yes" xml:space="preserve">
          <source>An alternative definition is</source>
          <target state="translated">另一个定义是:</target>
        </trans-unit>
        <trans-unit id="6dc3ea4727cbb968c6cf582f484a4b8e18d853df" translate="yes" xml:space="preserve">
          <source>An alternative is to embed the bytecode in the C code. The -output-obj option to ocamlc is provided for this purpose. It causes the ocamlc compiler to output a C object file (.o file, .obj under Windows) containing the bytecode for the OCaml part of the program, as well as a caml_startup function. The C object file produced by ocamlc -output-obj can then be linked with C code using the standard C compiler, or stored in a C library.</source>
          <target state="translated">另一种方法是将字节码嵌入到C代码中。ocamlc的-output-obj选项就是为了这个目的而提供的。它使ocamlc编译器输出一个C对象文件(.o文件,在Windows下为.obj),其中包含程序中OCaml部分的字节码,以及一个caml_startup函数。ocamlc -output-obj产生的C对象文件可以使用标准的C编译器与C代码链接,或者存储在C库中。</target>
        </trans-unit>
        <trans-unit id="95ade0a1f9ad45bcd451d104ffbe3e9e40771842" translate="yes" xml:space="preserve">
          <source>An alternative to ocamlc -custom is to build separately a custom runtime system integrating the desired C libraries, then generate &amp;ldquo;pure&amp;rdquo; bytecode executables (not containing their own runtime system) that can run on this custom runtime. This is achieved by the -make-runtime and -use-runtime flags to ocamlc. For example, to build a custom runtime system integrating the C parts of the &amp;ldquo;Unix&amp;rdquo; and &amp;ldquo;Threads&amp;rdquo; libraries, do:</source>
          <target state="translated">ocamlc -custom的替代方法是单独构建一个集成了所需C库的自定义运行时系统，然后生成可在此自定义运行时上运行的&amp;ldquo;纯&amp;rdquo;字节码可执行文件（不包含其自己的运行时系统）。这是通过ocamlc的-make-runtime和-use-runtime标志实现的。例如，要构建一个集成了&amp;ldquo; Unix&amp;rdquo;和&amp;ldquo; Threads&amp;rdquo;库的C部分的自定义运行时系统，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="c55d8d7fa1b47cf10b362effa434052f1405ea7c" translate="yes" xml:space="preserve">
          <source>An alternative to try&amp;hellip;with is to catch the exception while pattern matching:</source>
          <target state="translated">try&amp;hellip;with的替代方法是在模式匹配时捕获异常：</target>
        </trans-unit>
        <trans-unit id="440131e5b5bff0388b1ca084c1c73f82f7b75cfe" translate="yes" xml:space="preserve">
          <source>An ancestor can be bound by appending as&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; to the inheritance construct. &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; is not a true variable and can only be used to select a method, i.e. in an expression &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;. This gives access to the method &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; as it was defined in the parent class even if it is redefined in the current class. The scope of this ancestor binding is limited to the current class. The ancestor method may be called from a subclass but only indirectly.</source>
          <target state="translated">可以通过将&lt;a href=&quot;lex#lowercase-ident&quot;&gt;小写身份&lt;/a&gt;附加到继承结构来绑定祖先。&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;不是一个真正的变量，只能用于选择一个方法，即在表达式中的&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;＃&lt;a href=&quot;names#method-name&quot;&gt;method-name中&lt;/a&gt;。这样就可以访问在父类中定义的方法&lt;a href=&quot;names#method-name&quot;&gt;方法名&lt;/a&gt;，即使它在当前类中已重新定义。此祖先绑定的范围限于当前类。可以从子类中调用祖先方法，但只能间接调用它。</target>
        </trans-unit>
        <trans-unit id="8bc69c843c1bcd58389ebb2099cebb2fafcfd92a" translate="yes" xml:space="preserve">
          <source>An applicative should provide a module implementing the following interface:</source>
          <target state="translated">一个应用者应该提供一个实现以下接口的模块:</target>
        </trans-unit>
        <trans-unit id="8164cb7c49543188ed8a5173f717b428711b14e7" translate="yes" xml:space="preserve">
          <source>An argument to a function that is known to always hold a particular value at runtime. These are introduced by the inliner when specialising recursive functions; and the unbox-closures pass. (See section &lt;a href=&quot;#s%3Aflambda-specialisation&quot;&gt;19.4&lt;/a&gt;.)</source>
          <target state="translated">一个函数的参数，该参数在运行时始终保持特定的值。这些是由内线在专门处理递归函数时引入的；然后开箱关闭。（请参阅第&lt;a href=&quot;#s%3Aflambda-specialisation&quot;&gt;19.4&lt;/a&gt;节。）</target>
        </trans-unit>
        <trans-unit id="006daedb74f512410dc697574b790c690eac412a" translate="yes" xml:space="preserve">
          <source>An argument to a function that is known to always hold a particular value at runtime. These are introduced by the inliner when specialising recursive functions; and the unbox-closures pass. (See section &lt;a href=&quot;#s%3Aflambda-specialisation&quot;&gt;21.4&lt;/a&gt;.)</source>
          <target state="translated">一个函数的参数，该参数在运行时始终保持特定的值。这些是由内线在专门处理递归函数时引入的；然后开箱关闭。（请参阅第&lt;a href=&quot;#s%3Aflambda-specialisation&quot;&gt;21.4&lt;/a&gt;节。）</target>
        </trans-unit>
        <trans-unit id="68a60b893728b3292dec521dfb12ae61670dfbaf" translate="yes" xml:space="preserve">
          <source>An array or record of double-precision floating-point numbers.</source>
          <target state="translated">一个双精度浮点数字的数组或记录。</target>
        </trans-unit>
        <trans-unit id="ca29b133df1fc1dbb688bf20b4430e478e70f647" translate="yes" xml:space="preserve">
          <source>An atomic (mutable) reference to a value of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">对类型 &lt;code&gt;'a&lt;/code&gt; 的值的原子（可变）引用。</target>
        </trans-unit>
        <trans-unit id="de099d6b9bf898b11e949a8188e992306f13f2b6" translate="yes" xml:space="preserve">
          <source>An attribute ([@@boxed] or [@@unboxed]) on the type declaration.</source>
          <target state="translated">类型声明中的属性([@@boxed]或[@@unboxed])。</target>
        </trans-unit>
        <trans-unit id="a7d66ba6e7828a1111bf1a161c41ab1d141e5ef9" translate="yes" xml:space="preserve">
          <source>An exception will also be raised if the given library defines toplevel modules whose name matches that of an interface depended on by a module existing in either the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. This applies even if such dependency is only a &quot;module alias&quot; dependency (i.e. just on the name rather than the contents of the interface).</source>
          <target state="translated">如果给定的库定义名称与接口名称匹配的顶级模块，则该异常将取决于主程序或先前加载了 &lt;code&gt;loadfile&lt;/code&gt; 的共享库中存在的模块所依赖的顶级模块。即使这样的依赖关系仅是&amp;ldquo;模块别名&amp;rdquo;依赖关系（即，仅依赖于名称而不是接口的内容），也是如此。</target>
        </trans-unit>
        <trans-unit id="5375646ebb366bf5116bc2ae873c1a496825dc9f" translate="yes" xml:space="preserve">
          <source>An exception will be raised if the given library defines toplevel modules whose names clash with modules existing either in the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. Modules from shared libraries previously loaded with &lt;code&gt;loadfile_private&lt;/code&gt; are not included in this restriction.</source>
          <target state="translated">如果给定的库定义了顶级模块，这些顶级模块的名称与主程序或先前加载了 &lt;code&gt;loadfile&lt;/code&gt; 的共享库中存在的模块冲突，则会引发异常。此限制中不包括先前由 &lt;code&gt;loadfile_private&lt;/code&gt; 加载的共享库中的模块。</target>
        </trans-unit>
        <trans-unit id="b0e9adb3f15c17f5fbeab56e0dab47efabe68d43" translate="yes" xml:space="preserve">
          <source>An exception will be raised if the given library defines toplevel modules whose names clash with modules existing in either the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. Modules from shared libraries previously loaded with &lt;code&gt;loadfile_private&lt;/code&gt; are not included in this restriction.</source>
          <target state="translated">如果给定库定义了顶级模块，这些顶级模块的名称与主程序或先前由 &lt;code&gt;loadfile&lt;/code&gt; 加载的共享库中存在的模块冲突，则会引发异常。此限制中不包括先前由 &lt;code&gt;loadfile_private&lt;/code&gt; 加载的共享库中的模块。</target>
        </trans-unit>
        <trans-unit id="90025c98f5b4890323289b196947781e6340b557" translate="yes" xml:space="preserve">
          <source>An expression consisting in a constant evaluates to this constant.</source>
          <target state="translated">一个由常数组成的表达式对这个常数进行评价。</target>
        </trans-unit>
        <trans-unit id="ace90c1621b08aa00c8a96b15f6d30d331d6e13d" translate="yes" xml:space="preserve">
          <source>An expression consisting in an access path evaluates to the value bound to this path in the current evaluation environment. The path can be either a value name or an access path to a value component of a module.</source>
          <target state="translated">由访问路径构成的表达式,在当前的评估环境中,评估为与该路径绑定的值。这个路径可以是一个值名,也可以是一个模块的值组件的访问路径。</target>
        </trans-unit>
        <trans-unit id="73cfae8499d582540d3d82d2b347d5585283e5c5" translate="yes" xml:space="preserve">
          <source>An expression e is said to be &lt;em&gt;immediately linked to&lt;/em&gt; the variable name in the following cases:</source>
          <target state="translated">在以下情况下，可以说表达式e&lt;em&gt;立即链接到&lt;/em&gt;变量名：</target>
        </trans-unit>
        <trans-unit id="c225cbf4f764068b682bb84533296870c62e4bb3" translate="yes" xml:space="preserve">
          <source>An expression e is said to be &lt;em&gt;statically constructive with respect to&lt;/em&gt; the variables name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt; if at least one of the following conditions is true:</source>
          <target state="translated">如果至少满足以下条件之一，则表达式e&lt;em&gt;对于&lt;/em&gt;变量name &lt;sub&gt;1&lt;/sub&gt; &amp;hellip;name &lt;sub&gt;n&lt;/sub&gt;是&lt;em&gt;静态构造的&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="8924323657caeb3c679eee6ea2840479395084ba" translate="yes" xml:space="preserve">
          <source>An expression in the current program which is not enclosed within any function declaration.</source>
          <target state="translated">当前程序中没有包含在任何函数声明中的表达式。</target>
        </trans-unit>
        <trans-unit id="f0596299a4f05385df32ae22667956b3d842ca85" translate="yes" xml:space="preserve">
          <source>An important remark here is that it is not needed to explicit fully the type of depth: it is sufficient to add annotations only for the universally quantified type variables:</source>
          <target state="translated">这里有一个重要的说明,就是不需要完全明确深度的类型:只需要为普遍量化的类型变量添加注释即可。</target>
        </trans-unit>
        <trans-unit id="52648597fa8dcc7ffc682bd503ba0967a3f2392b" translate="yes" xml:space="preserve">
          <source>An infix form is available for extension nodes when the payload is of the same kind (expression with expression, pattern with pattern ...).</source>
          <target state="translated">当有效载荷为同类(表达式与表达式、模式与模式......)时,扩展节点可使用infix形式。</target>
        </trans-unit>
        <trans-unit id="6d344863eeb9df892e71ea50feb4a625f576874f" translate="yes" xml:space="preserve">
          <source>An instance of the class point is now a function that expects an initial parameter to create a point object:</source>
          <target state="translated">点类的实例现在是一个函数,它期望一个初始参数来创建一个点对象。</target>
        </trans-unit>
        <trans-unit id="0aabcf4fb88a6b9ab3702ebe7eaa0626b8c43f86" translate="yes" xml:space="preserve">
          <source>An instance variable can only be used in the methods and initializers that follow its definition.</source>
          <target state="translated">实例变量只能在其定义之后的方法和初始化器中使用。</target>
        </trans-unit>
        <trans-unit id="7cfec687c7cd2e25fe15cf75db3a2694a19473d5" translate="yes" xml:space="preserve">
          <source>An instance variable specification will hide any previous specification of an instance variable of the same name.</source>
          <target state="translated">实例变量规范将隐藏之前对同名实例变量的任何规范。</target>
        </trans-unit>
        <trans-unit id="a41b8be11a84d152d295d2336d67b91e8d2c3060" translate="yes" xml:space="preserve">
          <source>An integer literal is a sequence of one or more digits, optionally preceded by a minus sign. By default, integer literals are in decimal (radix 10). The following prefixes select a different radix:</source>
          <target state="translated">整数文字是一个由一个或多个数字组成的序列,前面有一个减号。默认情况下,整数文字是以十进制为单位的(半径10)。下面的前缀选择不同的半径。</target>
        </trans-unit>
        <trans-unit id="d9d626a896ab2f190fc7998987ce76e7091c1c26" translate="yes" xml:space="preserve">
          <source>An interesting feature of labeled arguments is that they can be made optional. For optional parameters, the question mark ? replaces the tilde ~ of non-optional ones, and the label is also prefixed by ? in the function type. Default values may be given for such optional parameters.</source>
          <target state="translated">标签参数的一个有趣的特点是,它们可以成为可选的参数。对于可选参数,用问号 ? 取代非可选参数的小括号 ~,在函数类型中,标签也用 ? 前缀。对于这种可选参数,可以给出默认值。</target>
        </trans-unit>
        <trans-unit id="1f65036af4512f44ececdc3f62c446b6b61294da" translate="yes" xml:space="preserve">
          <source>An object can be duplicated using the library function Oo.copy (see module &lt;a href=&quot;libref/oo&quot;&gt;Oo&lt;/a&gt;). Inside a method, the expression {&amp;lt; [&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] { ;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] }] &amp;gt;} returns a copy of self with the given instance variables replaced by the values of the associated expressions. A single instance variable name id stands for id=id. Other instance variables have the same value in the returned object as in self.</source>
          <target state="translated">可以使用库函数Oo.copy复制对象（请参见模块&lt;a href=&quot;libref/oo&quot;&gt;Oo&lt;/a&gt;）。在方法内部，表达式{&amp;lt;[ &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ] {; &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ]}]&amp;gt;}返回self的副本，其中给定的实例变量被关联表达式的值替换。单个实例变量名称id代表id = id。其他实例变量在返回的对象中具有与self相同的值。</target>
        </trans-unit>
        <trans-unit id="f8fca591c68a23ba5ea157e601f3721c015e06e3" translate="yes" xml:space="preserve">
          <source>An object of type t can be seen as an object of type t' only if t is a subtype of t'. For instance, a point cannot be seen as a colored point.</source>
          <target state="translated">只有当t是t'的一个子类型时,类型t的对象才能被看作是类型t'的对象。例如,一个点不能被看作是一个彩色的点。</target>
        </trans-unit>
        <trans-unit id="b5a053fc34f79e3900acd980c4393bdf188d2ba6" translate="yes" xml:space="preserve">
          <source>An object type &amp;lt; [&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; { ;&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; }] &amp;gt; is a record of method types.</source>
          <target state="translated">对象类型&amp;lt;[&lt;a href=&quot;#method-type&quot;&gt;方法类型&lt;/a&gt;{; &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; }]&amp;gt;是方法类型的记录。</target>
        </trans-unit>
        <trans-unit id="7e06bba980b7f45d05db95ce6a7fd85388df6efe" translate="yes" xml:space="preserve">
          <source>An optional ;; is allowed after each specification in a signature. It serves as a syntactic separator with no semantic meaning.</source>
          <target state="translated">允许在签名中的每一个规格之后有一个可选的;;。它是一个没有语义的句法分隔符。</target>
        </trans-unit>
        <trans-unit id="66032c41f549bccac9d0b6f0351898e608c2cda4" translate="yes" xml:space="preserve">
          <source>An optional type constraint &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; can be added before -&amp;gt; to enforce the type of the result to be compatible with the constraint &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;:</source>
          <target state="translated">可以在-&amp;gt;之前添加可选的类型约束类型&lt;a href=&quot;types#typexpr&quot;&gt;xpr，&lt;/a&gt;以强制结果类型与约束类型&lt;a href=&quot;types#typexpr&quot;&gt;xpr&lt;/a&gt;兼容：</target>
        </trans-unit>
        <trans-unit id="dc2fcf6b100ec44acc00a333e7fc5f05e4b0696a" translate="yes" xml:space="preserve">
          <source>Analogous to a let-expression but working at the level of symbols defined in the object file. The address of a symbol is fixed, but it may be bound to both constant and non-constant expressions.</source>
          <target state="translated">类似于let表达式,但在对象文件中定义的符号层次上工作。符号的地址是固定的,但它可以与常量和非常量表达式绑定。</target>
        </trans-unit>
        <trans-unit id="a9da5adc9da340a9bff818430088217c4a6bb634" translate="yes" xml:space="preserve">
          <source>And here is another example as a floating attribute on top of an &amp;ldquo;.mli&amp;rdquo; file (i.e. before any other non-attribute item) or on top of an &amp;ldquo;.ml&amp;rdquo; file without a corresponding interface file, so that any reference to that unit will trigger the alert:</source>
          <target state="translated">这是另一个示例，作为浮动属性位于&amp;ldquo; .mli&amp;rdquo;文件之上（即，在任何其他非属性项之前）或位于没有相应接口文件的&amp;ldquo; .ml&amp;rdquo;文件之上，因此对此的任何引用单元将触发警报：</target>
        </trans-unit>
        <trans-unit id="ce86f92e74f90bcfd232c04d5cf35384550f0a84" translate="yes" xml:space="preserve">
          <source>Another addition is that the redundancy check is now aware of GADTs: a case will be detected as redundant if it could be replaced by a refutation case using the same pattern.</source>
          <target state="translated">另一个补充是,冗余检查现在意识到了GADTs:如果一个案例可以被一个使用相同模式的反驳案例所取代,那么它将被检测为冗余。</target>
        </trans-unit>
        <trans-unit id="11568aaad65fc90346f51e27ec62e346c87f9060" translate="yes" xml:space="preserve">
          <source>Another advantage of dynamic linking is that the final users of the library do not need to have a C compiler, C linker, and C runtime libraries installed on their machines. This is no big deal under Unix and Cygwin, but many Windows users are reluctant to install Microsoft Visual C just to be able to do ocamlc -custom.</source>
          <target state="translated">动态链接的另一个好处是,库的最终用户不需要在他们的机器上安装C编译器、C链接器和C运行时库。这在Unix和Cygwin下并不是什么大问题,但是很多Windows用户不愿意为了能够进行ocamlc -custom而安装Microsoft Visual C。</target>
        </trans-unit>
        <trans-unit id="379ccd865ef9bf08d87e4fe3728fcd421c371281" translate="yes" xml:space="preserve">
          <source>Another application where the absence of strengthening comes handy, is to provide an alternative implementation for an existing module.</source>
          <target state="translated">另一个没有加强的应用是很方便的,就是为现有的模块提供一个替代的实现。</target>
        </trans-unit>
        <trans-unit id="35b204a1efbf2c2ea400dd0dffecaa4d167d1127" translate="yes" xml:space="preserve">
          <source>Another constructor of the class string can be defined to return a new string of a given length:</source>
          <target state="translated">另一个string类的构造函数可以被定义为返回一个给定长度的新字符串。</target>
        </trans-unit>
        <trans-unit id="3008a5155b842268cb1cca835a9c65bc01d33f21" translate="yes" xml:space="preserve">
          <source>Another derived form is</source>
          <target state="translated">另一种派生形式是</target>
        </trans-unit>
        <trans-unit id="d7fc62ee868df41b11c6605c1d3d1e9e51b532e5" translate="yes" xml:space="preserve">
          <source>Another difficulty is the implementation of the method concat. In order to concatenate a string with another string of the same class, one must be able to access the instance variable externally. Thus, a method repr returning s must be defined. Here is the correct definition of strings:</source>
          <target state="translated">另一个困难是方法concat的实现。为了将一个字符串与同一类的另一个字符串连接起来,必须能够从外部访问实例变量。因此,必须定义一个repr返回s的方法。下面是字符串的正确定义。</target>
        </trans-unit>
        <trans-unit id="a9be82a84aa2970b0f614e195c443acf584f6a07" translate="yes" xml:space="preserve">
          <source>Another example of friend functions may be found in section &amp;zwj;&lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;. These examples occur when a group of objects (here objects of the same class) and functions should see each others internal representation, while their representation should be hidden from the outside. The solution is always to define all friends in the same module, give access to the representation and use a signature constraint to make the representation abstract outside the module.</source>
          <target state="translated">的朋友功能的另一示例可以在一节中找到&lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;。当一组对象（此处为同一类的对象）和函数应相互查看内部表示，而其表示应从外部隐藏时，将发生这些示例。解决方案始终是在同一模块中定义所有好友，允许访问表示形式，并使用签名约束使表示形式抽象于模块外部。</target>
        </trans-unit>
        <trans-unit id="960c7f9039396fdf9b6183a614ddd5ba1364d740" translate="yes" xml:space="preserve">
          <source>Another example of friend functions may be found in section &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;. These examples occur when a group of objects (here objects of the same class) and functions should see each others internal representation, while their representation should be hidden from the outside. The solution is always to define all friends in the same module, give access to the representation and use a signature constraint to make the representation abstract outside the module.</source>
          <target state="translated">朋友功能的另一个示例可以在第&lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;节中找到。当一组对象（此处为同一类的对象）和函数应相互查看内部表示，而其表示应从外部隐藏时，将发生这些示例。解决方案始终是在同一模块中定义所有好友，允许访问表示形式，并使用签名约束使表示形式抽象于模块外部。</target>
        </trans-unit>
        <trans-unit id="17374fb3064ba6870c538e1b446bdebf215dc251" translate="yes" xml:space="preserve">
          <source>Another frequent application of GADTs is equality witnesses.</source>
          <target state="translated">GADTs的另一个频繁应用是平等证人。</target>
        </trans-unit>
        <trans-unit id="00b8b9dedc14e6b1cd6fe0e01857af1aa6404068" translate="yes" xml:space="preserve">
          <source>Another interesting example of variant type is the built-in 'a option type which represents either a value of type 'a or an absence of value:</source>
          <target state="translated">变体类型的另一个有趣的例子是内置的'a选项类型,它表示'a类型的值或没有值。</target>
        </trans-unit>
        <trans-unit id="e98e486b7a409b5e3ad08f1b7aa8b7aed3ea6303" translate="yes" xml:space="preserve">
          <source>Another method of the class Odoc_html.info will look for the function associated to a custom tag and apply it to the text given to the tag. If no function is associated to a custom tag, then the method prints a warning message on stderr.</source>
          <target state="translated">Odoc_html.info 类的另一个方法将寻找与自定义标记相关联的函数,并将其应用到给定标记的文本中。如果没有函数关联到自定义标签,那么该方法会在stderr上打印一条警告信息。</target>
        </trans-unit>
        <trans-unit id="ae0ec1f90755688bc1d5656265057eb9e769167b" translate="yes" xml:space="preserve">
          <source>Another possibility is to immediately open the result of a functor application</source>
          <target state="translated">另一种可能是立即打开一个漏斗应用的结果。</target>
        </trans-unit>
        <trans-unit id="e716b700e6f647eba563f1ccf76da8c18bce9786" translate="yes" xml:space="preserve">
          <source>Another possibility is to open the module, which brings all identifiers defined inside the module in the scope of the current structure.</source>
          <target state="translated">另一种可能是打开模块,将模块内定义的所有标识符都纳入当前结构的范围。</target>
        </trans-unit>
        <trans-unit id="f4cb70ba16214437ff5bfea383ebc35af2799280" translate="yes" xml:space="preserve">
          <source>Another possibility is to use the registration mechanism provided by OCaml. This registration mechanism enables OCaml code to register OCaml functions under some global name, and C code to retrieve the corresponding closure by this global name.</source>
          <target state="translated">另一种可能是使用OCaml提供的注册机制。这种注册机制使得OCaml代码可以在某个全局名下注册OCaml函数,C代码可以通过这个全局名检索相应的闭包。</target>
        </trans-unit>
        <trans-unit id="a4a25eeac3ff8c3ee8c702db2e25111e6be9bd82" translate="yes" xml:space="preserve">
          <source>Another use of polymorphic methods is to allow some form of implicit subtyping in method arguments. We have already seen in section &amp;zwj;&lt;a href=&quot;#s%3Ainheritance&quot;&gt;3.8&lt;/a&gt; how some functions may be polymorphic in the class of their argument. This can be extended to methods.</source>
          <target state="translated">多态方法的另一种用法是在方法参数中允许某种形式的隐式子类型化。我们已经看到在第&lt;a href=&quot;#s%3Ainheritance&quot;&gt;3.8&lt;/a&gt;如何某些功能可能会在其类的说法多态性。这可以扩展到方法。</target>
        </trans-unit>
        <trans-unit id="d34661685e35893e694d0332d27bae708ed4c0a2" translate="yes" xml:space="preserve">
          <source>Another use of polymorphic methods is to allow some form of implicit subtyping in method arguments. We have already seen in section &lt;a href=&quot;#s%3Ainheritance&quot;&gt;3.8&lt;/a&gt; how some functions may be polymorphic in the class of their argument. This can be extended to methods.</source>
          <target state="translated">多态方法的另一种用法是在方法参数中允许某种形式的隐式子类型化。我们已经在&lt;a href=&quot;#s%3Ainheritance&quot;&gt;3.8&lt;/a&gt;节中看到了某些函数在其参数类中可能是多态的。这可以扩展到方法。</target>
        </trans-unit>
        <trans-unit id="42742cf10f5bbb6d6cd3179117e1520377a19a5b" translate="yes" xml:space="preserve">
          <source>Another way to describe the effect of the used and max parameters is in terms of full GC cycles. If you allocate many custom blocks with used / max = 1 / N, the GC will then do one full cycle (examining every object in the heap and calling finalization functions on those that are unreachable) every N allocations. For instance, if used = 1 and max = 1000, the GC will do one full cycle at least every 1000 allocations of custom blocks.</source>
          <target state="translated">另一种描述used和max参数效果的方式是用GC全周期来描述。如果你在 used/max=1/N 的情况下分配了许多自定义块,那么 GC 将会每 N 次分配做一个完整的循环(检查堆中的每一个对象,并对那些无法到达的对象调用最终化函数)。例如,如果 used=1,max=1000,GC 将至少每 1000 次分配自定义块做一个完整的循环。</target>
        </trans-unit>
        <trans-unit id="dad308b9fe900c0c0e039593bedec472af636fdb" translate="yes" xml:space="preserve">
          <source>Anything reachable from the closure of finalisation functions is considered reachable, so the following code will not work as expected:</source>
          <target state="translated">凡是从最终化函数的闭合中可以达到的东西都被认为是可以达到的,所以下面的代码将无法达到预期的效果。</target>
        </trans-unit>
        <trans-unit id="604a218f5f4aab645a4a1009e1f31b43f5ed165f" translate="yes" xml:space="preserve">
          <source>Application operator: &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; is exactly equivalent to &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt;.</source>
          <target state="translated">应用程序运算符： &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; 完全等于 &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df2efc8b148be52f9c8ed183190fada16314613f" translate="yes" xml:space="preserve">
          <source>Application operator: &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; is exactly equivalent to &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt;. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">应用程序运算符： &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; 完全等于 &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt; 。右关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1fa4b8e03aa156418c5cda350eaad3455e137511" translate="yes" xml:space="preserve">
          <source>Application-defined signal 1</source>
          <target state="translated">应用定义信号1</target>
        </trans-unit>
        <trans-unit id="26c1a4dff4fd312fdfb5fb1c0029c4b22bf24f5e" translate="yes" xml:space="preserve">
          <source>Application-defined signal 2</source>
          <target state="translated">应用定义信号2</target>
        </trans-unit>
        <trans-unit id="61e847f0c9cb6ddd254ec9bee8f6186c8f3855b9" translate="yes" xml:space="preserve">
          <source>Applications of functors at toplevel are biased in favour of inlining. (This bias may be adjusted: see the documentation for -inline-lifting-benefit below.)</source>
          <target state="translated">在toplevel的漏斗函数的应用是偏向于内联的。(这个偏向可以调整:参见下面的-内联-提升-好处的文档)。</target>
        </trans-unit>
        <trans-unit id="bd544829c5c539d781194c7e44400d0c1a9dda50" translate="yes" xml:space="preserve">
          <source>Applications of functors at toplevel will be given an additional benefit (which may be controlled by the -inline-lifting-benefit flag) to bias inlining in such situations towards keeping the inlined version.</source>
          <target state="translated">在toplevel上的漏斗函数的应用将被赋予额外的好处(可以由-inline-lifting-benefit标志控制),以使内联在这种情况下偏向于保留内联版本。</target>
        </trans-unit>
        <trans-unit id="a3e0674aabf5c4d680c8d5e09367402b58266d96" translate="yes" xml:space="preserve">
          <source>Applications of functors not at toplevel, for example in a local module inside some other expression, are treated by the inliner identically to normal function calls.</source>
          <target state="translated">不在toplevel的漏斗函数的应用,例如在本地模块中的其他表达式中的应用,被inliner处理得和普通函数调用一样。</target>
        </trans-unit>
        <trans-unit id="e11dd7ffe23599b55aaefbac7a8a5cc476bbdddf" translate="yes" xml:space="preserve">
          <source>Apply the function to every element; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt; is dropped; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; then &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">将函数应用于每个元素；如果 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; 则 &lt;code&gt;x&lt;/code&gt; 被丢弃；如果 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; 则返回 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4df0a0fae2dc98bab23f83a8fda3ec3235322c88" translate="yes" xml:space="preserve">
          <source>Apply the function to every element; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt; is dropped; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; then &lt;code&gt;y&lt;/code&gt; is returned. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="translated">将函数应用于每个元素；如果 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; 则 &lt;code&gt;x&lt;/code&gt; 被丢弃；如果 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; 则返回 &lt;code&gt;y&lt;/code&gt; 。这种转换是惰性的，仅在遍历结果时才适用。</target>
        </trans-unit>
        <trans-unit id="9203406f752d0f2cd60c227bf6f44b27a75accdc" translate="yes" xml:space="preserve">
          <source>Arbitrary effects:</source>
          <target state="translated">任意效果。</target>
        </trans-unit>
        <trans-unit id="5271441f98aeb358bf2d4f9a6f13e679fe628438" translate="yes" xml:space="preserve">
          <source>Arc cosine.</source>
          <target state="translated">弧度余弦。</target>
        </trans-unit>
        <trans-unit id="be6663925560899dfcf830b9356632b7066599ce" translate="yes" xml:space="preserve">
          <source>Arc cosine. The argument must fall within the range &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt;. Result is in radians and is between &lt;code&gt;0.0&lt;/code&gt; and &lt;code&gt;pi&lt;/code&gt;.</source>
          <target state="translated">反余弦。参数必须在 &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt; 范围内。结果以弧度表示，介于 &lt;code&gt;0.0&lt;/code&gt; 和 &lt;code&gt;pi&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="b8e8ba2c58206d6af15ec8c8ce21d9d4340480e6" translate="yes" xml:space="preserve">
          <source>Arc sine.</source>
          <target state="translated">弧正弦。</target>
        </trans-unit>
        <trans-unit id="2e664c763343c0ce420ab4f8b7918cc8fec98013" translate="yes" xml:space="preserve">
          <source>Arc sine. The argument must fall within the range &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt;. Result is in radians and is between &lt;code&gt;-pi/2&lt;/code&gt; and &lt;code&gt;pi/2&lt;/code&gt;.</source>
          <target state="translated">反正弦。参数必须在 &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt; 范围内。结果以弧度表示，并且在 &lt;code&gt;-pi/2&lt;/code&gt; 和 &lt;code&gt;pi/2&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="266c8124a574fe03155e38f56dd49a8f10def8a9" translate="yes" xml:space="preserve">
          <source>Arc tangent.</source>
          <target state="translated">弧形切线。</target>
        </trans-unit>
        <trans-unit id="e2997407cb014180b9ea6377f06c6afb487aba39" translate="yes" xml:space="preserve">
          <source>Arc tangent. Result is in radians and is between &lt;code&gt;-pi/2&lt;/code&gt; and &lt;code&gt;pi/2&lt;/code&gt;.</source>
          <target state="translated">圆弧切线。结果以弧度表示，并且在 &lt;code&gt;-pi/2&lt;/code&gt; 和 &lt;code&gt;pi/2&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="27cb7fb1af71b4cc6c9c97447cc986c742906de1" translate="yes" xml:space="preserve">
          <source>Arg</source>
          <target state="translated">Arg</target>
        </trans-unit>
        <trans-unit id="b8bc95515466bfd1d5820bfea495f62a49211b2b" translate="yes" xml:space="preserve">
          <source>Argument list too long</source>
          <target state="translated">争论列表太长</target>
        </trans-unit>
        <trans-unit id="a33eb8c83de075f26368d8d83e467d02a06fefb8" translate="yes" xml:space="preserve">
          <source>Argument.</source>
          <target state="translated">Argument.</target>
        </trans-unit>
        <trans-unit id="94e2cab63df34c564db734a97c71978e506fbdc1" translate="yes" xml:space="preserve">
          <source>Argument. The argument of a complex number is the angle in the complex plane between the positive real axis and a line passing through zero and the number. This angle ranges from &lt;code&gt;-pi&lt;/code&gt; to &lt;code&gt;pi&lt;/code&gt;. This function has a discontinuity along the negative real axis.</source>
          <target state="translated">争论。复数的自变量是正实轴与穿过零和该数的线之间的复平面中的角度。此角度的范围是 &lt;code&gt;-pi&lt;/code&gt; 到 &lt;code&gt;pi&lt;/code&gt; 。该函数沿负实轴具有不连续性。</target>
        </trans-unit>
        <trans-unit id="cbc3ed9a0a50398139b12d56cc9eb1c8aad70aa4" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;r1&lt;/code&gt; to &lt;code&gt;rN&lt;/code&gt; are user-defined input functions that read the argument corresponding to the &lt;code&gt;%r&lt;/code&gt; conversions specified in the format string.</source>
          <target state="translated">参数 &lt;code&gt;r1&lt;/code&gt; 至 &lt;code&gt;rN&lt;/code&gt; 是用户定义的输入函数，它们读取与格式字符串中指定的 &lt;code&gt;%r&lt;/code&gt; 转换相对应的参数。</target>
        </trans-unit>
        <trans-unit id="bddb1ca12c5cd34d740d1681c0e6da5090d8ebc1" translate="yes" xml:space="preserve">
          <source>Arguments and parameters are matched according to their respective labels. Argument order is irrelevant, except among arguments with the same label, or no label.</source>
          <target state="translated">参数和参数根据各自的标签进行匹配。除了具有相同标签或没有标签的参数外,参数顺序无关紧要。</target>
        </trans-unit>
        <trans-unit id="e4aa3dace9de47afa590535c6430637432fcb775" translate="yes" xml:space="preserve">
          <source>Arguments ending in .c are passed to the C compiler, which generates a .o object file (.obj under Windows). This object file is linked with the program if the -custom flag is set (see the description of -custom below).</source>
          <target state="translated">以.c结尾的参数被传递给C编译器,编译器会生成一个.o对象文件(Windows下的.obj)。如果设置了-custom标志,这个对象文件就会与程序链接起来(参见下面对-custom的描述)。</target>
        </trans-unit>
        <trans-unit id="7e64866919ffd0c1908ab66afb8bab953b71239c" translate="yes" xml:space="preserve">
          <source>Arguments ending in .c are passed to the C compiler, which generates a .o/.obj object file. This object file is linked with the program.</source>
          <target state="translated">以.c结尾的参数被传递给C编译器,编译器会生成一个.o/.obj对象文件。这个对象文件与程序链接。</target>
        </trans-unit>
        <trans-unit id="c11692d0c25badb1d4399f0c388c3baf4a014789" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cma are taken to be libraries of object bytecode. A library of object bytecode packs in a single file a set of object bytecode files (.cmo files). Libraries are built with ocamlc -a (see the description of the -a option below). The object files contained in the library are linked as regular .cmo files (see above), in the order specified when the .cma file was built. The only difference is that if an object file contained in a library is not referenced anywhere in the program, then it is not linked in.</source>
          <target state="translated">以.cma结尾的参数被认为是对象字节码库,一个对象字节码库将一组对象字节码文件(.cmo文件)打包在一个文件中。一个对象字节码库将一组对象字节码文件(.cmo文件)打包在一个文件中。库是用ocamlc -a建立的(参见下面的-a选项描述)。库中包含的对象文件和普通的.cmo文件(见上文)一样,按照建立.cma文件时指定的顺序进行链接。唯一不同的是,如果一个库中包含的对象文件没有在程序中的任何地方被引用,那么它就不会被链接进来。</target>
        </trans-unit>
        <trans-unit id="cd46a96b2deb69174fd6074578fbde3a1033ca71" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmo are taken to be compiled object bytecode. These files are linked together, along with the object files obtained by compiling .ml arguments (if any), and the OCaml standard library, to produce a standalone executable program. The order in which .cmo and .ml arguments are presented on the command line is relevant: compilation units are initialized in that order at run-time, and it is a link-time error to use a component of a unit before having initialized it. Hence, a given x.cmo file must come before all .cmo files that refer to the unit x.</source>
          <target state="translated">以.cmo结尾的参数被认为是编译后的对象字节码。这些文件与通过编译.ml参数(如果有的话)获得的对象文件以及OCaml标准库连接在一起,生成一个独立的可执行程序。.cmo和.ml参数在命令行中的显示顺序是相关的:编译单元在运行时按该顺序初始化,在初始化单元之前使用该单元的某个组件是链接时错误。因此,一个给定的x.cmo文件必须在所有引用单元x的.cmo文件之前。</target>
        </trans-unit>
        <trans-unit id="27c51513642c4d98fce646f2cf850e04390e54e5" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmx are taken to be compiled object code. These files are linked together, along with the object files obtained by compiling .ml arguments (if any), and the OCaml standard library, to produce a native-code executable program. The order in which .cmx and .ml arguments are presented on the command line is relevant: compilation units are initialized in that order at run-time, and it is a link-time error to use a component of a unit before having initialized it. Hence, a given x.cmx file must come before all .cmx files that refer to the unit x.</source>
          <target state="translated">以.cmx结尾的参数被认为是编译后的对象代码。这些文件与编译 .ml 参数(如果有的话)获得的对象文件以及 OCaml 标准库连接在一起,生成一个本地代码的可执行程序。.cmx 和 .ml 参数在命令行上的显示顺序是相关的:编译单元在运行时按该顺序初始化,在初始化单元之前使用该单元的某个组件是链接时错误。因此,一个给定的 x.cmx 文件必须排在所有引用单元 x 的 .cmx 文件之前。</target>
        </trans-unit>
        <trans-unit id="753f2485fe970a0539a08cbdcdd898a19f368dff" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmxa are taken to be libraries of object code. Such a library packs in two files (lib.cmxa and lib.a/.lib) a set of object files (.cmx and .o/.obj files). Libraries are build with ocamlopt -a (see the description of the -a option below). The object files contained in the library are linked as regular .cmx files (see above), in the order specified when the library was built. The only difference is that if an object file contained in a library is not referenced anywhere in the program, then it is not linked in.</source>
          <target state="translated">以.cmxa结尾的参数被认为是对象代码库。这样的库在两个文件(lib.cmxa和lib.a/.lib)中包含了一组对象文件(.cmx和.o/.obj文件)。库是用ocamlopt -a来构建的(参见下面的-a选项的描述)。库中包含的对象文件就像普通的.cmx文件一样被链接起来(见上文),按照建库时指定的顺序。唯一不同的是,如果一个库中包含的对象文件在程序中的任何地方都没有被引用,那么它就不会被链接进来。</target>
        </trans-unit>
        <trans-unit id="b15608ca7cbe9709e52f1f2a1ead35427cf44c51" translate="yes" xml:space="preserve">
          <source>Arguments ending in .ml are taken to be source files for compilation unit implementations. Implementations provide definitions for the names exported by the unit, and also contain expressions to be evaluated for their side-effects. From the file x.ml, the ocamlc compiler produces compiled object bytecode in the file x.cmo.</source>
          <target state="translated">以.ml结尾的参数被认为是编译单元实现的源文件。实现提供了单元导出的名称的定义,也包含了要对其副作用进行评估的表达式。ocamlc编译器从文件x.ml中产生编译后的对象字节码,文件x.cmo。</target>
        </trans-unit>
        <trans-unit id="927a384236546c16bb894121e3e38006a9e3ec5f" translate="yes" xml:space="preserve">
          <source>Arguments ending in .ml are taken to be source files for compilation unit implementations. Implementations provide definitions for the names exported by the unit, and also contain expressions to be evaluated for their side-effects. From the file x.ml, the ocamlopt compiler produces two files: x.o, containing native object code, and x.cmx, containing extra information for linking and optimization of the clients of the unit. The compiled implementation should always be referred to under the name x.cmx (when given a .o or .obj file, ocamlopt assumes that it contains code compiled from C, not from OCaml).</source>
          <target state="translated">以.ml结尾的参数被认为是编译单元实现的源文件。实现提供了单元导出的名称的定义,也包含了要对其副作用进行评估的表达式。从文件x.ml中,ocamlopt编译器产生两个文件:x.o,包含本机对象代码,x.cmx,包含额外的信息,用于链接和优化单元的客户端。编译后的实现应始终以x.cmx的名字来引用(当给定一个.o或.obj文件时,ocamlopt假定它包含从C编译的代码,而不是从OCaml编译的代码)。</target>
        </trans-unit>
        <trans-unit id="2b5a1961767c9a016aad419b660ee2c45f6b243d" translate="yes" xml:space="preserve">
          <source>Arguments ending in .mli are taken to be source files for compilation unit interfaces. Interfaces specify the names exported by compilation units: they declare value names with their types, define public data types, declare abstract data types, and so on. From the file x.mli, the ocamlc compiler produces a compiled interface in the file x.cmi.</source>
          <target state="translated">以.mli结尾的参数被认为是编译单元接口的源文件。接口指定了编译单元导出的名称:它们声明值名及其类型,定义公共数据类型,声明抽象数据类型,等等。从文件x.mli中,ocamlc编译器产生一个编译后的接口,文件x.cmi。</target>
        </trans-unit>
        <trans-unit id="25f655c44ea5ff1321183c50ad8e4c5f74128d49" translate="yes" xml:space="preserve">
          <source>Arguments ending in .mli are taken to be source files for compilation unit interfaces. Interfaces specify the names exported by compilation units: they declare value names with their types, define public data types, declare abstract data types, and so on. From the file x.mli, the ocamlopt compiler produces a compiled interface in the file x.cmi. The interface produced is identical to that produced by the bytecode compiler ocamlc.</source>
          <target state="translated">以.mli结尾的参数被认为是编译单元接口的源文件。接口指定了编译单元输出的名称:它们声明值名及其类型,定义公共数据类型,声明抽象数据类型,等等。从文件x.mli中,ocamlopt编译器会产生一个编译后的接口,文件x.cmi。产生的接口与字节码编译器ocamlc产生的接口相同。</target>
        </trans-unit>
        <trans-unit id="7173e5b0967ce88f54ecd20d265aa72b4f28c658" translate="yes" xml:space="preserve">
          <source>Arguments ending in .o or .a (.obj or .lib under Windows) are assumed to be C object files and libraries. They are passed to the C linker when linking in -custom mode (see the description of -custom below).</source>
          <target state="translated">以.o或.a结尾的参数(在Windows下是.obj或.lib)被认为是C对象文件和库。当在-custom模式下进行链接时,它们会被传递给C链接器(参见下面关于-custom的描述)。</target>
        </trans-unit>
        <trans-unit id="1c067102e7e1c8c13a1e6e57ba950d7491209f87" translate="yes" xml:space="preserve">
          <source>Arguments ending in .o, .a or .so (.obj, .lib and .dll under Windows) are assumed to be C object files and libraries. They are linked with the program.</source>
          <target state="translated">以.o、.a或.so结尾的参数(Windows下的.obj、.lib和.dll)被认为是C对象文件和库。它们与程序相连接。</target>
        </trans-unit>
        <trans-unit id="fc1ab2c6381764fbe6cadd894bd7ef8c2b84a0f9" translate="yes" xml:space="preserve">
          <source>Arguments ending in .so (.dll under Windows) are assumed to be C shared libraries (DLLs). During linking, they are searched for external C functions referenced from the OCaml code, and their names are written in the generated bytecode executable. The run-time system ocamlrun then loads them dynamically at program start-up time.</source>
          <target state="translated">以.so(Windows下的.dll)结尾的参数被认为是C共享库(DLL)。在链接过程中,它们会被搜索到从OCaml代码中引用的外部C函数,它们的名字会被写入生成的字节码可执行文件中。然后运行时系统ocamlrun在程序启动时动态加载它们。</target>
        </trans-unit>
        <trans-unit id="8ad3d398f9ad29c4fd230211d5ebfa56a0ba7f1c" translate="yes" xml:space="preserve">
          <source>Arithmetic exception</source>
          <target state="translated">算术异常</target>
        </trans-unit>
        <trans-unit id="185bf7f331062c4c3e9e4a6aba44aec8b810f20a" translate="yes" xml:space="preserve">
          <source>Arrange for the C shared library dlllibname.so (dlllibname.dll under Windows) to be loaded dynamically by the run-time system ocamlrun at program start-up time.</source>
          <target state="translated">安排C共享库dlllibname.so(Windows下的dlllibname.dll)在程序启动时由运行时系统ocamlrun动态加载。</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="431205b0376562fedb6d7afe64934615b543a4b4" translate="yes" xml:space="preserve">
          <source>Array accesses are bounds-checked, but the bounds are determined by the initial call to &lt;code&gt;map_file&lt;/code&gt;. Therefore, you should make sure no other process modifies the mapped file while you're accessing it, or a SIGBUS signal may be raised. This happens, for instance, if the file is shrunk.</source>
          <target state="translated">数组访问是经过边界检查的，但是边界是由对 &lt;code&gt;map_file&lt;/code&gt; 的初始调用确定的。因此，在访问映射文件时，应确保没有其他进程修改该文件，否则可能会引发SIGBUS信号。例如，如果文件缩小，就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="6a80d94da93b9720aae715b13c57b162feacae54" translate="yes" xml:space="preserve">
          <source>Array layouts</source>
          <target state="translated">阵列布局</target>
        </trans-unit>
        <trans-unit id="3bb3c7a55000274933287d81122c47cc23dd9bcf" translate="yes" xml:space="preserve">
          <source>Array operations</source>
          <target state="translated">阵列操作</target>
        </trans-unit>
        <trans-unit id="cc3f55326329e50888cc261427317ad3c95e07c6" translate="yes" xml:space="preserve">
          <source>Array operations.</source>
          <target state="translated">阵列操作。</target>
        </trans-unit>
        <trans-unit id="ac52c7170210e2cde0563a8a7cc378d8d3bab67e" translate="yes" xml:space="preserve">
          <source>Array scanning</source>
          <target state="translated">阵列扫描</target>
        </trans-unit>
        <trans-unit id="1302b4894cb1cf89e91ae78809a8c87e194848ee" translate="yes" xml:space="preserve">
          <source>ArrayLabels</source>
          <target state="translated">ArrayLabels</target>
        </trans-unit>
        <trans-unit id="993b203e29af9582fe002cf1c0a611c787dcb4d5" translate="yes" xml:space="preserve">
          <source>Arrays are finite, variable-sized sequences of values of the same type. The current implementation supports arrays containing up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 elements (4194303 elements) unless the elements are floating-point numbers (2097151 elements in this case); on 64-bit platforms, the limit is 2&lt;sup&gt;54&lt;/sup&gt; &amp;minus; 1 for all arrays.</source>
          <target state="translated">数组是有限的，可变大小的相同类型值的序列。当前的实现支持最​​多包含2 &lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1个元素（4194303个元素）的数组，除非这些元素是浮点数（在这种情况下为2097151个元素）；否则，默认为0。在64位平台上，所有阵列的限制为2 &lt;sup&gt;54&lt;/sup&gt; &amp;minus; 1。</target>
        </trans-unit>
        <trans-unit id="3dbf05ada7bef68e8d497df01ba4407cb02175f1" translate="yes" xml:space="preserve">
          <source>Arrays of floating-point numbers (type float array) have a special, unboxed, more efficient representation. These arrays are represented by pointers to blocks with tag Double_array_tag. They should be accessed with the Double_field and Store_double_field macros.</source>
          <target state="translated">浮点数的数组(类型为浮点数组)有一个特殊的、未装箱的、更有效的表示方法,这些数组由带有标签Double_array_tag的块指针表示。这些数组用指向带有Double_array_tag标签的块的指针来表示,它们应该用Double_field和Store_double_field宏来访问。它们应该用Double_field和Store_double_field宏来访问。</target>
        </trans-unit>
        <trans-unit id="eeb5d22677db1ca99964d11b5a456b2ea6d06b2e" translate="yes" xml:space="preserve">
          <source>Arrays of integers and pointers are represented like tuples, that is, as pointers to blocks tagged &amp;zwj;0. They are accessed with the Field macro for reading and the caml_modify function for writing.</source>
          <target state="translated">整数和指针的数组像元组一样表示，即表示为标记为&amp;zwj;0的块的指针。可通过Field宏（用于读取）和caml_modify函数（用于写入）对其进行访问。</target>
        </trans-unit>
        <trans-unit id="1ac7294b1d303d14c1ea81ae76623f8e989d7450" translate="yes" xml:space="preserve">
          <source>Arrays of integers and pointers are represented like tuples, that is, as pointers to blocks tagged 0. They are accessed with the Field macro for reading and the caml_modify function for writing.</source>
          <target state="translated">整数和指针的数组就像元组一样,也就是指向标记为0的块的指针,读取时使用Field宏,写入时使用caml_modify函数。</target>
        </trans-unit>
        <trans-unit id="f16f611272747884cf686e3d446de513132a0e8d" translate="yes" xml:space="preserve">
          <source>Arrays of values declared using CAMLlocalN must not be written to using Store_field. Use the normal C array syntax instead.</source>
          <target state="translated">使用CAMLlocalN声明的值的数组不能用Store_field写入。请使用正常的C数组语法。</target>
        </trans-unit>
        <trans-unit id="80832a08a4bc7a800951f197511d4c16855f54d1" translate="yes" xml:space="preserve">
          <source>Arrays of weak pointers and hash sets of weak pointers.</source>
          <target state="translated">弱指针的数组和弱指针的哈希集。</target>
        </trans-unit>
        <trans-unit id="a9312b18524288526ab3bb3e65773d033af7e75d" translate="yes" xml:space="preserve">
          <source>As a consequence, if the coercion is applied to self, as in the following example, the type of self is unified with the closed type c (a closed object type is an object type without ellipsis). This would constrain the type of self be closed and is thus rejected. Indeed, the type of self cannot be closed: this would prevent any further extension of the class. Therefore, a type error is generated when the unification of this type with another type would result in a closed object type.</source>
          <target state="translated">因此,如果胁迫应用于self,就像下面的例子一样,self的类型与封闭类型c统一(封闭的对象类型是没有省略号的对象类型)。这将约束self的类型是封闭的,因此被拒绝。事实上,self的类型不能是封闭的:这将阻止该类的任何进一步扩展。因此,当这个类型与另一个类型的统一会导致一个封闭的对象类型时,就会产生一个类型错误。</target>
        </trans-unit>
        <trans-unit id="236760b37470c1f5e34cd659fbad69bc911cec3c" translate="yes" xml:space="preserve">
          <source>As a convenience, caml/mlvalues.h defines the macros Val_unit, Val_false and Val_true to refer to (), false and true.</source>
          <target state="translated">为了方便起见,caml/mlvalues.h定义了宏Val_unit、Val_false和Val_true来引用()、false和true。</target>
        </trans-unit>
        <trans-unit id="d6708b84bc9659abee628ea692bfc6191fdb3835" translate="yes" xml:space="preserve">
          <source>As a shared library may have several clients simultaneously, it is made for convenience that caml_startup (and caml_startup_pooled) may be called multiple times, given that each such call is paired with a corresponding call to caml_shutdown (in a nested fashion). The runtime will be unloaded once there are no outstanding calls to caml_startup.</source>
          <target state="translated">由于一个共享库可能会同时拥有多个客户端,为了方便起见,caml_startup(和caml_startup_pooled)可以被多次调用,因为每次这样的调用都会与caml_shutdown的对应调用配对(以嵌套的方式)。一旦没有未完成的对caml_startup的调用,运行时将被卸载。</target>
        </trans-unit>
        <trans-unit id="84d9ea1b251e88997b679926917f2a4432728a0f" translate="yes" xml:space="preserve">
          <source>As a side-effect of this generativity, one is allowed to unpack first-class modules in the body of generative functors.</source>
          <target state="translated">作为这种生成性的副作用,人们被允许在生成性漏斗体中解包一级模块。</target>
        </trans-unit>
        <trans-unit id="f911d2f00f331336c981cf38aacf772c6fcf31a6" translate="yes" xml:space="preserve">
          <source>As a side-effect, these 3 keywords avoid the warnings &amp;zwj;7 (method override) and &amp;zwj;13 (instance variable override). Note that warning &amp;zwj;7 is disabled by default.</source>
          <target state="translated">作为副作用，这3个关键字避免了警告&amp;zwj;7（方法替代）和&amp;zwj;13（实例变量替代）。请注意，默认情况下禁用警告&amp;zwj;7。</target>
        </trans-unit>
        <trans-unit id="8c21716682d59482dd8cc66a86332eb9340c37df" translate="yes" xml:space="preserve">
          <source>As a side-effect, these 3 keywords avoid the warnings 7 (method override) and 13 (instance variable override). Note that warning 7 is disabled by default.</source>
          <target state="translated">作为一个副作用,这3个关键字避免了警告7(方法覆盖)和13(实例变量覆盖)。请注意,警告7在默认情况下是禁用的。</target>
        </trans-unit>
        <trans-unit id="a81290b5b966f9efcf2c6b0cb0f65e7caee04d82" translate="yes" xml:space="preserve">
          <source>As a special case, assert false is reduced to raise(Assert_failure ...), which gives it a polymorphic type. This means that it can be used in place of any expression (for example as a branch of any pattern-matching). It also means that the assert false &amp;ldquo;assertions&amp;rdquo; cannot be turned off by the -noassert option.</source>
          <target state="translated">作为一种特殊情况，assert false减少为raise（Assert_failure ...），从而为它提供了多态类型。这意味着它可以代替任何表达式使用（例如，作为任何模式匹配的分支）。这也意味着不能通过-noassert选项关闭断言为假的&amp;ldquo;断言&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="acf0e568489d8aa1699963c95f2533d75f92737b" translate="yes" xml:space="preserve">
          <source>As a special case, if id is all, it stands for all alerts.</source>
          <target state="translated">作为一种特殊情况,如果id是all,则代表所有警报。</target>
        </trans-unit>
        <trans-unit id="c52ed11f3bffe509a76486b6deece909f9053706" translate="yes" xml:space="preserve">
          <source>As a special case, if the function has a known arity, all the arguments are unlabeled, and their number matches the number of non-optional parameters, then labels are ignored and non-optional parameters are matched in their definition order. Optional arguments are defaulted.</source>
          <target state="translated">作为一种特殊情况,如果函数具有已知的arity,所有的参数都没有标签,并且它们的数量与非选项参数的数量相匹配,那么标签被忽略,非选项参数按其定义顺序匹配。可选参数是默认的。</target>
        </trans-unit>
        <trans-unit id="a938adb6f0aea5e4af4fb92f58e17c47a9825ed3" translate="yes" xml:space="preserve">
          <source>As an example, consider the following lexer that is parametrized over an arbitrary monad:</source>
          <target state="translated">举个例子,考虑下面这个在任意单体上进行参数化的词法器。</target>
        </trans-unit>
        <trans-unit id="f0d510e5dbaebaaf3fcb5f83b6a111b4d9ae064d" translate="yes" xml:space="preserve">
          <source>As an example, this code will return the integer 1:</source>
          <target state="translated">举个例子,这段代码将返回整数1。</target>
        </trans-unit>
        <trans-unit id="4f90f529d98bdc2a64de636cdc4ec8125e7bb221" translate="yes" xml:space="preserve">
          <source>As an example, we fuzz-test the following program, readline.ml:</source>
          <target state="translated">举个例子,我们对下面的程序readline.ml进行模糊测试。</target>
        </trans-unit>
        <trans-unit id="c2e17b3e7ef6d5d7fd46be15fe9cc1c0f4c1ec6b" translate="yes" xml:space="preserve">
          <source>As an exception to the above parameter matching rules, if an application is total (omitting all optional arguments), labels may be omitted. In practice, many applications are total, so that labels can often be omitted.</source>
          <target state="translated">作为上述参数匹配规则的一个例外,如果一个应用程序是总的(省略所有可选参数),标签可以被省略。在实践中,很多应用程序都是总计的,因此标签往往可以省略。</target>
        </trans-unit>
        <trans-unit id="e90091a05125db96622a5dd1550905e80e47ce30" translate="yes" xml:space="preserve">
          <source>As an optimization, records whose fields all have static type float are represented as arrays of floating-point numbers, with tag Double_array_tag. (See the section below on arrays.)</source>
          <target state="translated">作为一种优化,那些字段都具有静态类型float的记录被表示为浮点数字的数组,标签为Double_array_tag。参见下面关于数组的章节)。</target>
        </trans-unit>
        <trans-unit id="2132b6cde94d1364eb1755b1d0d913c9028161c7" translate="yes" xml:space="preserve">
          <source>As an optimization, unboxable concrete data types are represented specially; a concrete data type is unboxable if it has exactly one constructor and this constructor has exactly one argument. Unboxable concrete data types are represented in the same ways as unboxable record types: see the description in section &amp;zwj;&lt;a href=&quot;#ss%3Ac-tuples-and-records&quot;&gt;18.3.2&lt;/a&gt;.</source>
          <target state="translated">作为一种优化，特别表示了无法装箱的具体数据类型。如果一个具体的数据类型只有一个构造函数，并且此构造函数只有一个参数，则它是不可装箱的。Unboxable具体的数据类型则表示在相同的方式为unboxable记录类型：见描述部分&lt;a href=&quot;#ss%3Ac-tuples-and-records&quot;&gt;18.3.2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9b07ba0ea2f0d698023e6db84093874e3feaa2a" translate="yes" xml:space="preserve">
          <source>As an optimization, unboxable concrete data types are represented specially; a concrete data type is unboxable if it has exactly one constructor and this constructor has exactly one argument. Unboxable concrete data types are represented in the same ways as unboxable record types: see the description in section &lt;a href=&quot;#ss%3Ac-tuples-and-records&quot;&gt;20.3.2&lt;/a&gt;.</source>
          <target state="translated">作为一种优化，特别表示了无法装箱的具体数据类型。如果一个具体的数据类型只有一个构造函数，并且此构造函数只有一个参数，则它是不可装箱的。可取消装箱的具体数据类型的表示方式与可取消装箱的记录类型的表示方式相同：请参见第&lt;a href=&quot;#ss%3Ac-tuples-and-records&quot;&gt;20.3.2&lt;/a&gt;节中的描述。</target>
        </trans-unit>
        <trans-unit id="2e389f44aa5a062928a493d520912df25e67b105" translate="yes" xml:space="preserve">
          <source>As another optimization, unboxable record types are represented specially; unboxable record types are the immutable record types that have only one field. An unboxable type will be represented in one of two ways: boxed or unboxed. Boxed record types are represented as described above (by a block with tag 0 or Double_array_tag). An unboxed record type is represented directly by the value of its field (i.e. there is no block to represent the record itself).</source>
          <target state="translated">作为另一个优化,unboxable记录类型被特殊表示;unboxable记录类型是只有一个字段的不可改变的记录类型。一个不可装箱的记录类型将以两种方式之一来表示:装箱或不装箱。盒装记录类型的表示方式如上所述(由一个带有标签0或Double_array_tag的块表示)。未装箱的记录类型直接由其字段的值表示(即没有块来表示记录本身)。</target>
        </trans-unit>
        <trans-unit id="ab0914c80dac70311bbc335c79d02e0ca7dabf33" translate="yes" xml:space="preserve">
          <source>As can be expected, the type of window is recursive.</source>
          <target state="translated">可以预见,窗口的类型是递归的。</target>
        </trans-unit>
        <trans-unit id="36451f7154d544b297a165c4f3d0b643fc88da62" translate="yes" xml:space="preserve">
          <source>As checkpointing is quite expensive, it must not be done too often. On the other hand, backward execution is faster when checkpoints are taken more often. In particular, backward single-stepping is more responsive when many checkpoints have been taken just before the current time. To fine-tune the checkpointing strategy, the debugger does not take checkpoints at the same frequency for long displacements (e.g. run) and small ones (e.g. step). The two variables bigstep and smallstep contain the number of events between two checkpoints in each case.</source>
          <target state="translated">由于检查点是相当昂贵的,所以不能太频繁地进行检查点。另一方面,当检查点采取的次数较多时,后向执行的速度会更快。特别是在当前时间之前已经采取了许多检查点时,后向单步的响应速度更快。为了微调检查点策略,调试器对长位移(如run)和小位移(如step)的检查点取值频率不一样。两个变量bigstep和smallstep包含每种情况下两个检查点之间的事件数。</target>
        </trans-unit>
        <trans-unit id="0c2e49921371c9b9ceab2b2609b751d4d8a6ae6b" translate="yes" xml:space="preserve">
          <source>As described above, there are three parameters that restrict the search for inlining opportunities during speculation:</source>
          <target state="translated">如上所述,在炒股过程中,有三个参数限制了内线机会的寻找。</target>
        </trans-unit>
        <trans-unit id="04ce6fc5d3fc7d51652851a17e88a921906c733e" translate="yes" xml:space="preserve">
          <source>As in the PrioQueue example, it would be good style to hide the actual implementation of the type set, so that users of the structure will not rely on sets being lists, and we can switch later to another, more efficient representation of sets without breaking their code. This can be achieved by restricting Set by a suitable functor signature:</source>
          <target state="translated">和PrioQueue的例子一样,隐藏类型集的实际实现是一种很好的风格,这样结构的用户就不会依赖集是列表,我们可以在以后切换到另一种更有效的集表示方式而不破坏他们的代码。这可以通过用一个合适的漏子签名来限制Set来实现。</target>
        </trans-unit>
        <trans-unit id="d7636d82194e3efe6c5e09ed9156713f2d8407a4" translate="yes" xml:space="preserve">
          <source>As in the case of simple structures, an alternate syntax is provided for defining functors and restricting their result:</source>
          <target state="translated">与简单结构的情况一样,我们提供了一种替代的语法来定义漏斗和限制其结果。</target>
        </trans-unit>
        <trans-unit id="95375c7ef1a71d2bf1c6e19c4cf628da86c59bbb" translate="yes" xml:space="preserve">
          <source>As in the case of static linking, it is possible (and recommended) to record the names of C libraries in an OCaml .cma library archive. Consider again an OCaml library mylib.cma, built from the OCaml object files a.cmo and b.cmo, which reference C code in dllmylib.so. If the library is built as follows:</source>
          <target state="translated">与静态链接的情况一样,可以(也推荐)在OCaml .cma库存档中记录C库的名称。再考虑一个OCaml库mylib.cma,由OCaml对象文件a.cmo和b.cmo建立,这两个文件引用了dllmylib.so中的C代码。如果库的构建方式如下。</target>
        </trans-unit>
        <trans-unit id="5d584f24e6917e93c9448a575b3606f6a5980280" translate="yes" xml:space="preserve">
          <source>As mentioned above, a plain character in the format string is just matched with the next character of the input; however, two characters are special exceptions to this rule: the space character (&lt;code&gt;'&amp;nbsp;'&lt;/code&gt; or ASCII code 32) and the line feed character (&lt;code&gt;'\n'&lt;/code&gt; or ASCII code 10). A space does not match a single space character, but any amount of 'whitespace' in the input. More precisely, a space inside the format string matches &lt;em&gt;any number&lt;/em&gt; of tab, space, line feed and carriage return characters. Similarly, a line feed character in the format string matches either a single line feed or a carriage return followed by a line feed.</source>
          <target state="translated">如上所述，格式字符串中的普通字符仅与输入的下一个字符匹配；但是，此规则有两个特殊的例外：空格字符（ &lt;code&gt;'&amp;nbsp;'&lt;/code&gt; 或ASCII代码32）和换行符（ &lt;code&gt;'\n'&lt;/code&gt; 或ASCII代码10）。空格与单个空格字符不匹配，但输入中不包含任何数量的&amp;ldquo;空白&amp;rdquo;。更准确地说，格式字符串中的空格与&lt;em&gt;任意数量&lt;/em&gt;的制表符，空格，换行符和回车符匹配。同样，格式字符串中的换行符与单个换行符或回车符后跟换行符匹配。</target>
        </trans-unit>
        <trans-unit id="9bc7211404d7051f71f7c2a454c4181579989c21" translate="yes" xml:space="preserve">
          <source>As mentioned in chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;, the bytecode executable files produced by the ocamlc command are self-executable, and manage to launch the ocamlrun command on themselves automatically. That is, assuming a.out is a bytecode executable file,</source>
          <target state="translated">如第二章提到的&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;，由ocamlc命令生成字节码的可执行文件是自可执行文件，并设法对自己自动启动ocamlrun命令。也就是说，假设a.out是字节码可执行文件，</target>
        </trans-unit>
        <trans-unit id="910ea56dc6edf679b6fb9258db1d763027e94506" translate="yes" xml:space="preserve">
          <source>As mentioned in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;, the bytecode executable files produced by the ocamlc command are self-executable, and manage to launch the ocamlrun command on themselves automatically. That is, assuming a.out is a bytecode executable file,</source>
          <target state="translated">如第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章所述，由ocamlc命令生成的字节码可执行文件是可自行执行的，并设法自动在其自身上启动ocamlrun命令。也就是说，假设a.out是字节码可执行文件，</target>
        </trans-unit>
        <trans-unit id="299bd5bb4da212b06dc5e956686ae5d4002d4a7e" translate="yes" xml:space="preserve">
          <source>As mentioned in section &amp;zwj;&lt;a href=&quot;expr#sss%3Aexpr-localdef&quot;&gt;7.7.2&lt;/a&gt;, the letrec binding construct, in addition to the definition of recursive functions, also supports a certain class of recursive definitions of non-functional values, such as</source>
          <target state="translated">正如在节中提到&lt;a href=&quot;expr#sss%3Aexpr-localdef&quot;&gt;7.7.2&lt;/a&gt;，所述letrec结合构建体，除递归函数的定义，还支持某一类的非功能性值的递归定义，如</target>
        </trans-unit>
        <trans-unit id="4a210b9b840985d0d92278ed85640a6045dd1b85" translate="yes" xml:space="preserve">
          <source>As mentioned in section &lt;a href=&quot;expr#sss%3Aexpr-localdef&quot;&gt;7.7.2&lt;/a&gt;, the letrec binding construct, in addition to the definition of recursive functions, also supports a certain class of recursive definitions of non-functional values, such as</source>
          <target state="translated">如第&lt;a href=&quot;expr#sss%3Aexpr-localdef&quot;&gt;7.7.2&lt;/a&gt;节所述，letrec绑定构造除了递归函数的定义外，还支持某些类的非函数值的递归定义，例如</target>
        </trans-unit>
        <trans-unit id="0c627f19a423561ac14dfd8481d0392ee04dbc94" translate="yes" xml:space="preserve">
          <source>As of OCaml 4.07, the bigarray library has been integrated into OCaml&amp;rsquo;s standard library.</source>
          <target state="translated">从OCaml 4.07开始，bigarray库已集成到OCaml的标准库中。</target>
        </trans-unit>
        <trans-unit id="34bca80111a01f2e351f1111c7ac3f009fc572ff" translate="yes" xml:space="preserve">
          <source>As previously with polymorphic recursion, the problem stems from the fact that type variables are introduced only at the start of the let definitions. When we compute both f x and f y, the type of x and y are unified together. To avoid this unification, we need to indicate to the type checker that f is polymorphic in its first argument. In some sense, we would want average to have type</source>
          <target state="translated">与之前的多态递归一样,问题源于类型变量只在let定义的开头引入。当我们同时计算f x和f y时,x和y的类型被统一在一起。为了避免这种统一,我们需要向类型检查器表明f在其第一个参数中是多态的。在某种意义上,我们希望average有类型为</target>
        </trans-unit>
        <trans-unit id="2429872fc0410c40e6e3f24744bb0fefbd7305fd" translate="yes" xml:space="preserve">
          <source>As seen in section &amp;zwj;&lt;a href=&quot;objectexamples#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;, the solution is to use functional update instead. We need to create an instance variable containing the representation s of the string.</source>
          <target state="translated">如在截面中看到&lt;a href=&quot;objectexamples#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;，该解决方案是使用更新功能来代替。我们需要创建一个包含字符串表示形式的实例变量。</target>
        </trans-unit>
        <trans-unit id="0bc8c1d2e201eb9b8575e1d067fe0b0a35105b61" translate="yes" xml:space="preserve">
          <source>As seen in section &lt;a href=&quot;objectexamples#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;, the solution is to use functional update instead. We need to create an instance variable containing the representation s of the string.</source>
          <target state="translated">如&lt;a href=&quot;objectexamples#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;节所示，解决方案是改用功能更新。我们需要创建一个包含字符串表示形式的实例变量。</target>
        </trans-unit>
        <trans-unit id="146268ca5c35e116ecdc1071a5c5b8b50d37a961" translate="yes" xml:space="preserve">
          <source>As shown above, prefix and infix symbols as well as some keywords can be used as value names, provided they are written between parentheses. The capitalization rules are summarized in the table below.</source>
          <target state="translated">如上图所示,前缀和后缀符号以及一些关键字都可以用作值名,只要它们写在括号之间。下表总结了大写规则。</target>
        </trans-unit>
        <trans-unit id="34d83d9e79f521c6e091052dc06397df06c37842" translate="yes" xml:space="preserve">
          <source>As shown by the last item, the current behavior is imperfect and may be improved in future versions.</source>
          <target state="translated">由上一项可以看出,目前的行为还不完善,未来的版本可能会有所改进。</target>
        </trans-unit>
        <trans-unit id="5f52e265c35555d5dd6376d7c8518f28bfcf8591" translate="yes" xml:space="preserve">
          <source>As shown by the types of the values above, Bigarrays of kind &lt;code&gt;float32_elt&lt;/code&gt; and &lt;code&gt;float64_elt&lt;/code&gt; are accessed using the OCaml type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">如上述值的类型所示，使用OCaml类型 &lt;code&gt;float&lt;/code&gt; 来访问 &lt;code&gt;float32_elt&lt;/code&gt; 和 &lt;code&gt;float64_elt&lt;/code&gt; 类型的Bigarray。</target>
        </trans-unit>
        <trans-unit id="8476c185d0c89ce2f99fd45d0702217ddcf47f6c" translate="yes" xml:space="preserve">
          <source>As shown by the types of the values above, Bigarrays of kind &lt;code&gt;float32_elt&lt;/code&gt; and &lt;code&gt;float64_elt&lt;/code&gt; are accessed using the OCaml type &lt;code&gt;float&lt;/code&gt;. Bigarrays of complex kinds &lt;code&gt;complex32_elt&lt;/code&gt;, &lt;code&gt;complex64_elt&lt;/code&gt; are accessed with the OCaml type &lt;a href=&quot;complex#TYPEt&quot;&gt;&lt;code&gt;Complex.t&lt;/code&gt;&lt;/a&gt;. Bigarrays of integer kinds are accessed using the smallest OCaml integer type large enough to represent the array elements: &lt;code&gt;int&lt;/code&gt; for 8- and 16-bit integer Bigarrays, as well as OCaml-integer Bigarrays; &lt;code&gt;int32&lt;/code&gt; for 32-bit integer Bigarrays; &lt;code&gt;int64&lt;/code&gt; for 64-bit integer Bigarrays; and &lt;code&gt;nativeint&lt;/code&gt; for platform-native integer Bigarrays. Finally, Bigarrays of kind &lt;code&gt;int8_unsigned_elt&lt;/code&gt; can also be accessed as arrays of characters instead of arrays of small integers, by using the kind value &lt;code&gt;char&lt;/code&gt; instead of &lt;code&gt;int8_unsigned&lt;/code&gt;.</source>
          <target state="translated">如上述值的类型所示，使用OCaml类型 &lt;code&gt;float&lt;/code&gt; 来访问 &lt;code&gt;float32_elt&lt;/code&gt; 和 &lt;code&gt;float64_elt&lt;/code&gt; 类型的Bigarray。使用OCaml类型&lt;a href=&quot;complex#TYPEt&quot;&gt; &lt;code&gt;Complex.t&lt;/code&gt; &lt;/a&gt;访问复杂类型 &lt;code&gt;complex32_elt&lt;/code&gt; 和 &lt;code&gt;complex64_elt&lt;/code&gt; 的大数组。整数类型的Bigarray使用最小的OCaml整数类型访问，该类型足以表示数组元素： &lt;code&gt;int&lt;/code&gt; 表示8位和16位整数Bigarray，以及OCaml整数Bigarray；用于32位整数Bigarrays的 &lt;code&gt;int32&lt;/code&gt; ;用于64位整数Bigarrays的 &lt;code&gt;int64&lt;/code&gt; ;和 &lt;code&gt;nativeint&lt;/code&gt; 用于平台本地整数Bigarrays。最后，Bigarrays之类的 &lt;code&gt;int8_unsigned_elt&lt;/code&gt; 通过使用种类值 &lt;code&gt;char&lt;/code&gt; 而不是 &lt;code&gt;int8_unsigned&lt;/code&gt; ，也可以将int8_unsigned_elt作为字符数组而不是小整数数组进行访问。</target>
        </trans-unit>
        <trans-unit id="13a7da1695c3c5352050cfec39a769dbb674cfcd" translate="yes" xml:space="preserve">
          <source>As shown in the examples above, the internal representation (also called &lt;em&gt;abstract syntax&lt;/em&gt;) of expressions quickly becomes hard to read and write as the expressions get larger. We need a printer and a parser to go back and forth between the abstract syntax and the &lt;em&gt;concrete syntax&lt;/em&gt;, which in the case of expressions is the familiar algebraic notation (e.g. 2*x+1).</source>
          <target state="translated">如上面的示例所示，随着表达式的变大，表达式的内部表示（也称为&lt;em&gt;抽象语法&lt;/em&gt;）很快变得难以读写。我们需要一个打印机和一个解析器来在抽象语法和&lt;em&gt;具体语法&lt;/em&gt;之间来回切换，在表达式的情况下，这是熟悉的代数符号（例如2 * x + 1）。</target>
        </trans-unit>
        <trans-unit id="59652ec2d12ee8e1992d0d09b42d5fef7eaa31f9" translate="yes" xml:space="preserve">
          <source>As shown in the inferred type, the methods escaped and sub now return objects of the same type as the one of the class.</source>
          <target state="translated">如推断类型所示,现在方法escaped和sub返回的对象与类的类型相同。</target>
        </trans-unit>
        <trans-unit id="1677cf6090ca5f51486302f94edd1cbfae80aa0e" translate="yes" xml:space="preserve">
          <source>As such, n behaves as the &amp;ldquo;maximum depth of unrolling&amp;rdquo;.</source>
          <target state="translated">这样，n表现为&amp;ldquo;最大展开深度&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f163934b9085a82e3861515a2a64c2855047ac0e" translate="yes" xml:space="preserve">
          <source>As suggested above, the expression &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%d&quot;&amp;nbsp;f&lt;/code&gt; reads a decimal integer &lt;code&gt;n&lt;/code&gt; from the source of characters &lt;code&gt;ic&lt;/code&gt; and returns &lt;code&gt;f&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="translated">如上所述，表达式 &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%d&quot;&amp;nbsp;f&lt;/code&gt; 从字符 &lt;code&gt;ic&lt;/code&gt; 的源中读取一个十进制整数 &lt;code&gt;n&lt;/code&gt; 并返回 &lt;code&gt;f&amp;nbsp;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b63ec4df080300cfa9da6aea74b52a0e1970e4f4" translate="yes" xml:space="preserve">
          <source>As usual in format strings, &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters must be escaped using &lt;code&gt;%%&lt;/code&gt; and &lt;code&gt;%@&lt;/code&gt;; this rule still holds within range specifications and scanning indications. For instance, format &lt;code&gt;&quot;%s@%%&quot;&lt;/code&gt; reads a string up to the next &lt;code&gt;%&lt;/code&gt; character, and format &lt;code&gt;&quot;%s@%@&quot;&lt;/code&gt; reads a string up to the next &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">像通常在格式字符串中一样，必须使用 &lt;code&gt;%%&lt;/code&gt; 和 &lt;code&gt;%@&lt;/code&gt; 来对 &lt;code&gt;%&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt; 字符进行转义；该规则仍在范围规格和扫描指示之内。例如，格式 &lt;code&gt;&quot;%s@%%&quot;&lt;/code&gt; 读取一个字符串，直到下一个 &lt;code&gt;%&lt;/code&gt; 字符，格式 &lt;code&gt;&quot;%s@%@&quot;&lt;/code&gt; 读取一个字符串，直到下一个 &lt;code&gt;@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9513a3413b439631dd1d7bb4477ddee65ef66765" translate="yes" xml:space="preserve">
          <source>As with all other OCaml data structures, lists do not need to be explicitly allocated and deallocated from memory: all memory management is entirely automatic in OCaml. Similarly, there is no explicit handling of pointers: the OCaml compiler silently introduces pointers where necessary.</source>
          <target state="translated">与所有其他OCaml数据结构一样,列表不需要显式地从内存中分配和重新分配:在OCaml中,所有的内存管理都是完全自动的。同样,也不需要显式处理指针:OCaml编译器会在必要时默默地引入指针。</target>
        </trans-unit>
        <trans-unit id="faa7b814a8e7a19b930b22e13ead91aad6715db7" translate="yes" xml:space="preserve">
          <source>As with most OCaml data structures, inspecting and destructuring lists is performed by pattern-matching. List patterns have exactly the same form as list expressions, with identifiers representing unspecified parts of the list. As an example, here is insertion sort on a list:</source>
          <target state="translated">与大多数OCaml数据结构一样,检查和破坏列表是通过模式匹配进行的。列表模式的形式与列表表达式完全相同,标识符代表列表中未指定的部分。举个例子,这里是对列表的插入排序。</target>
        </trans-unit>
        <trans-unit id="a1eb0836959399cedd4347276c1b98d0ca3d0c82" translate="yes" xml:space="preserve">
          <source>As with records, the form {&amp;lt; x &amp;gt;} is an elided version of {&amp;lt; x = x &amp;gt;} which avoids the repetition of the instance variable name. Note that the type abbreviation functional_point is recursive, which can be seen in the class type of functional_point: the type of self is 'a and 'a appears inside the type of the method move.</source>
          <target state="translated">与记录一样，格式{&amp;lt;x&amp;gt;}是{&amp;lt;x = x&amp;gt;}的省略版本，它避免了实例变量名称的重复。请注意，缩写类型functional_point是递归的，可以在functional_point的类类型中看到：self的类型为'a，并且'a出现在方法move的类型内。</target>
        </trans-unit>
        <trans-unit id="17f13c41da6e3c55107056baa15f8a3dbb68f91b" translate="yes" xml:space="preserve">
          <source>As x is a subtype of xy, we can convert a value of type x to a value of type xy:</source>
          <target state="translated">由于x是xy的一个子类型,我们可以将类型x的值转换为类型xy的值。</target>
        </trans-unit>
        <trans-unit id="27d585775436817b8bbfb4935a528c62bb777faa" translate="yes" xml:space="preserve">
          <source>As you can see in the class type shown by the compiler, while polymorphic method types must be fully explicit in class definitions (appearing immediately after the method name), quantified type variables can be left implicit in class descriptions. Why require types to be explicit? The problem is that (int -&amp;gt; int -&amp;gt; int) -&amp;gt; int -&amp;gt; int would also be a valid type for fold, and it happens to be incompatible with the polymorphic type we gave (automatic instantiation only works for toplevel types variables, not for inner quantifiers, where it becomes an undecidable problem.) So the compiler cannot choose between those two types, and must be helped.</source>
          <target state="translated">在编译器显示的类类型中可以看到，虽然多态方法类型在类定义中必须是完全显式的（出现在方法名称之后），但量化的类型变量可以在类描述中保留为隐式。为什么要求类型是显式的？问题是（int-&amp;gt; int-&amp;gt; int）-&amp;gt; int-&amp;gt; int也是折叠的有效类型，并且恰好与我们给出的多态类型不兼容（自动实例化仅适用于顶级类型变量，而不是内部量词，在这里它变成了无法确定的问题。）因此，编译器无法在这两种类型之间进行选择，必须给予帮助。</target>
        </trans-unit>
        <trans-unit id="11d6e59058333963706b9356b3eee7ab6f10414a" translate="yes" xml:space="preserve">
          <source>As you move through the program, the debugger maintains an history of the successive times you stop at. The last command can be used to revisit these times: each last command moves one step back through the history. That is useful mainly to undo commands such as step and next.</source>
          <target state="translated">当你在程序中移动时,调试器会保存你停止的连续时间的历史。最后一条命令可以用来重温这些时间:每一条最后的命令都会在历史中向后移动一步。这主要是对撤消命令(如 step 和 next)有用。</target>
        </trans-unit>
        <trans-unit id="65354bb2656ea18d389b5fe5b411f5ee0d5e3d75" translate="yes" xml:space="preserve">
          <source>Assign an element of a generic Bigarray.</source>
          <target state="translated">分配一个通用Bigarray的元素。</target>
        </trans-unit>
        <trans-unit id="511e2f6557588ce6cb49fae5b91217ffb45c65de" translate="yes" xml:space="preserve">
          <source>Assign an element of a generic Bigarray. &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt; stores the value &lt;code&gt;v&lt;/code&gt; in the element of &lt;code&gt;a&lt;/code&gt; whose coordinates are &lt;code&gt;i1&lt;/code&gt; in the first dimension, &lt;code&gt;i2&lt;/code&gt; in the second dimension, ..., &lt;code&gt;iN&lt;/code&gt; in the &lt;code&gt;N&lt;/code&gt;-th dimension.</source>
          <target state="translated">分配通用Bigarray的元素。 &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt; 存储值 &lt;code&gt;v&lt;/code&gt; 中的元件 &lt;code&gt;a&lt;/code&gt; 坐标为 &lt;code&gt;i1&lt;/code&gt; 在第一维， &lt;code&gt;i2&lt;/code&gt; 在第二维，...， &lt;code&gt;iN&lt;/code&gt; 在 &lt;code&gt;N&lt;/code&gt; 个维度。</target>
        </trans-unit>
        <trans-unit id="8e4441e6b01109409d7db5b3985d7033187d4a2e" translate="yes" xml:space="preserve">
          <source>Assignment to non-mutable value.</source>
          <target state="translated">赋值为不可变值。</target>
        </trans-unit>
        <trans-unit id="693b1e8e0efde6572420480f71fd8ac02e79cc56" translate="yes" xml:space="preserve">
          <source>Associate precedences and associativities to the given symbols. All symbols on the same line are given the same precedence. They have higher precedence than symbols declared before in a &lt;code&gt;%left&lt;/code&gt;, &lt;code&gt;%right&lt;/code&gt; or &lt;code&gt;%nonassoc&lt;/code&gt; line. They have lower precedence than symbols declared after in a &lt;code&gt;%left&lt;/code&gt;, &lt;code&gt;%right&lt;/code&gt; or &lt;code&gt;%nonassoc&lt;/code&gt; line. The symbols are declared to associate to the left (&lt;code&gt;%left&lt;/code&gt;), to the right (&lt;code&gt;%right&lt;/code&gt;), or to be non-associative (&lt;code&gt;%nonassoc&lt;/code&gt;). The symbols are usually tokens. They can also be dummy nonterminals, for use with the &lt;code&gt;%prec&lt;/code&gt; directive inside the rules.</source>
          <target state="translated">将优先级和关联性与给定符号相关联。同一行上的所有符号都具有相同的优先级。它们的优先级高于 &lt;code&gt;%left&lt;/code&gt; ， &lt;code&gt;%right&lt;/code&gt; 或 &lt;code&gt;%nonassoc&lt;/code&gt; 行中之前声明的符号。它们的优先级比在 &lt;code&gt;%left&lt;/code&gt; ， &lt;code&gt;%right&lt;/code&gt; 或 &lt;code&gt;%nonassoc&lt;/code&gt; 行中声明的符号低。这些符号被声明为与左侧（ &lt;code&gt;%left&lt;/code&gt; ），右侧（ &lt;code&gt;%right&lt;/code&gt; ）关联，或者为非关联（ &lt;code&gt;%nonassoc&lt;/code&gt; ）。这些符号通常是标记。它们也可以是伪非终结符，与规则内的 &lt;code&gt;%prec&lt;/code&gt; 指令一起使用。</target>
        </trans-unit>
        <trans-unit id="afd5b4fd5a802d12133439bb6c727c5550f6bdba" translate="yes" xml:space="preserve">
          <source>Associate style number n to the given L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X sectioning command style, e.g. section or subsection. (L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X only.) This is useful when including the generated document in another L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document, at a given sectioning level. The default association is 1 for section, 2 for subsection, 3 for subsubsection, 4 for paragraph and 5 for subparagraph.</source>
          <target state="translated">将样式编号n与给定的L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X分区命令样式相关联，例如section或subsection。（L&lt;sup&gt;甲&lt;/sup&gt;Ť &lt;sub&gt;&amp;eacute;&lt;/sub&gt; X仅。），包括在另一L中生成的文档时，这是有用的&lt;sup&gt;甲&lt;/sup&gt;Ť &lt;sub&gt;&amp;eacute;&lt;/sub&gt; X文档，在给定的切片电平。默认关联是：节为1，小节为2，小节为3，段落为4，段落为5。</target>
        </trans-unit>
        <trans-unit id="c524fc36c86bd0a5d156287f9e272e9da389f023" translate="yes" xml:space="preserve">
          <source>Associate the given description (&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;) to the given parameter name id. This tag is used for functions, methods, classes and functors.</source>
          <target state="translated">将给定的描述（&lt;a href=&quot;#text&quot;&gt;文本&lt;/a&gt;）与给定的参数名称id相关联。该标签用于函数，方法，类和函子。</target>
        </trans-unit>
        <trans-unit id="9ec8233ec4293e18af80d1bdb5a2abfd01936116" translate="yes" xml:space="preserve">
          <source>Associate the given description (&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;) to the given version in order to document compatibility issues.</source>
          <target state="translated">将给定的描述（&lt;a href=&quot;#text&quot;&gt;文本&lt;/a&gt;）与给定的版本相关联，以记录兼容性问题。</target>
        </trans-unit>
        <trans-unit id="55db56ff500f9ca6b11e56023800331829b479b0" translate="yes" xml:space="preserve">
          <source>Association lists</source>
          <target state="translated">协会名单</target>
        </trans-unit>
        <trans-unit id="933443d0e9517ae1d7a08acaa81c31f178831777" translate="yes" xml:space="preserve">
          <source>Association tables over ordered types.</source>
          <target state="translated">在有序类型上的关联表。</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="2a1741771c0cc3890682eb4ba730ff53f9e9d5dd" translate="yes" xml:space="preserve">
          <source>Assume that module module is opened before parsing each of the following files.</source>
          <target state="translated">假设在解析以下各个文件之前,先打开模块模块。</target>
        </trans-unit>
        <trans-unit id="732d31f2e28996ce7c1526a4c29db2def23d8755" translate="yes" xml:space="preserve">
          <source>Assuming &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; denotes a signature, the expression &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;with&lt;a href=&quot;#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; { and&lt;a href=&quot;#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; } denotes the same signature where type equations have been added to some of the type specifications, as described by the constraints following the with keyword. The constraint type [&lt;a href=&quot;classes#type-parameters&quot;&gt;type-parameters&lt;/a&gt;] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; adds the type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; to the specification of the type component named &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; of the constrained signature. The constraint module&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;=&lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt; adds type equations to all type components of the sub-structure denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;, making them equivalent to the corresponding type components of the structure denoted by &lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;.</source>
          <target state="translated">假设&lt;a href=&quot;#module-type&quot;&gt;模块类型&lt;/a&gt;表示签名，带有&lt;a href=&quot;#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; {和&lt;a href=&quot;#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; }的表达式&lt;a href=&quot;#module-type&quot;&gt;模块类型&lt;/a&gt;表示相同的签名，其中类型方程式已添加到某些类型规范中，如with关键字后面的约束所描述。约束类型[ &lt;a href=&quot;classes#type-parameters&quot;&gt;type-parameters&lt;/a&gt; ] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;将类型方程= &lt;a href=&quot;types#typexpr&quot;&gt;typexpr添加&lt;/a&gt;到受约束签名的名为&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;的类型组件的规范中。约束模块的&lt;a href=&quot;names#module-path&quot;&gt;模块路径&lt;/a&gt;=&lt;a href=&quot;names#extended-module-path&quot;&gt;扩展的模块路径&lt;/a&gt;将类型方程式添加到&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;表示的子结构的所有类型组件中，使其等效于&lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;表示的结构的相应类型组件。</target>
        </trans-unit>
        <trans-unit id="4abe40bc093a635fe5f2393dd098c162da653457" translate="yes" xml:space="preserve">
          <source>Assuming unique ownership of strings that are not string literals, but are (partly) built from string literals, is also incorrect. For example, mutating &lt;code&gt;unsafe_of_string&amp;nbsp;(&quot;foo&quot;&amp;nbsp;^&amp;nbsp;s)&lt;/code&gt; could mutate the shared string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; -- assuming a rope-like representation of strings. More generally, functions operating on strings will assume shared ownership, they do not preserve unique ownership. It is thus incorrect to assume unique ownership of the result of &lt;code&gt;unsafe_of_string&lt;/code&gt;.</source>
          <target state="translated">假设不是字符串文字而是（部分）由字符串文字构建的字符串的唯一所有权也是不正确的。例如，对 &lt;code&gt;unsafe_of_string&amp;nbsp;(&quot;foo&quot;&amp;nbsp;^&amp;nbsp;s)&lt;/code&gt; 进行变异可以使共享字符串 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 变异-假定字符串的字符串类似表示形式。更一般而言，在字符串上运行的函数将承担共享所有权，但它们不保留唯一所有权。因此，假设 &lt;code&gt;unsafe_of_string&lt;/code&gt; 结果的唯一所有权是不正确的。</target>
        </trans-unit>
        <trans-unit id="0bf8057d6f5fa665b07dbede310cfe4a69c03150" translate="yes" xml:space="preserve">
          <source>Astute readers may have wondered what happens when two or more record fields or constructors share the same name</source>
          <target state="translated">敏锐的读者可能会想知道,当两个或多个记录字段或构造函数共享同一个名字时,会发生什么情况?</target>
        </trans-unit>
        <trans-unit id="9b1c0634cae4469e9d81ecf95e188f347608b54f" translate="yes" xml:space="preserve">
          <source>At any point, the parsing, compilation or evaluation of the current phrase can be interrupted by pressing ctrl-C (or, more precisely, by sending the INTR signal to the ocaml process). The toplevel then immediately returns to the # prompt.</source>
          <target state="translated">在任何时候,都可以通过按ctrl-C键(或者更准确地说,通过向ocaml进程发送INTR信号)来中断当前短语的解析、编译或评估。然后toplevel会立即返回到#提示。</target>
        </trans-unit>
        <trans-unit id="e0f954f80a0891f6d5cf340cf9dd1de0665d55eb" translate="yes" xml:space="preserve">
          <source>At any time, one of the stack frames is &amp;ldquo;selected&amp;rdquo; by the debugger; several debugger commands refer implicitly to the selected frame. In particular, whenever you ask the debugger for the value of a local variable, the value is found in the selected frame. The commands frame, up and down select whichever frame you are interested in.</source>
          <target state="translated">在任何时候，调试器都会&amp;ldquo;选择&amp;rdquo;其中一个堆栈帧。几个调试器命令隐式引用选定的帧。特别是，每当您向调试器询问局部变量的值时，都会在选定的帧中找到该值。在命令框架中，上下选择感兴趣的框架。</target>
        </trans-unit>
        <trans-unit id="0dc1f362156648d6f2461a3991beac3755f48ca1" translate="yes" xml:space="preserve">
          <source>At first look, we seem to have a polymorphic iterator, however this does not work in practice.</source>
          <target state="translated">乍一看,我们似乎有一个多态迭代器,然而这在实践中是行不通的。</target>
        </trans-unit>
        <trans-unit id="8b360f9d1eec9c2be338db85e91ea4dcbd8c92d8" translate="yes" xml:space="preserve">
          <source>At last, (**) is the empty documentation comment.</source>
          <target state="translated">最后,(**)是空的文档注释。</target>
        </trans-unit>
        <trans-unit id="75750c4cc5cbc3e0ac4fdd64ce772e90747028f1" translate="yes" xml:space="preserve">
          <source>At last, it is possible to update few fields of a record at once:</source>
          <target state="translated">最后,可以一次更新记录的几个字段。</target>
        </trans-unit>
        <trans-unit id="24a9bd7e79cc365e9058d6659c3e41e323547e2e" translate="yes" xml:space="preserve">
          <source>At present there may be a small penalty in terms of actual runtime performance when this transformation is enabled, although more stable performance may be obtained due to reduced allocation. It is recommended that developers experiment to determine whether the option is beneficial for their code. (It is expected that in the future it will be possible for the performance degradation to be removed.)</source>
          <target state="translated">目前,当启用这种转换时,实际运行时性能可能会受到一点惩罚,不过由于减少了分配,可能会获得更稳定的性能。建议开发人员进行实验,以确定该选项是否对其代码有利。(预计将来有可能消除性能下降的情况)。</target>
        </trans-unit>
        <trans-unit id="e33195f0c4c3cec6e9e12712f199a9503621c4f6" translate="yes" xml:space="preserve">
          <source>At run-time, the ocamlyacc-generated parser can be debugged by setting the p option in the OCAMLRUNPARAM environment variable (see section &amp;zwj;&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;). This causes the pushdown automaton executing the parser to print a trace of its action (tokens shifted, rules reduced, etc). The trace mentions rule numbers and state numbers that can be interpreted by looking at the file grammar.output generated by ocamlyacc -v.</source>
          <target state="translated">在运行时，所述ocamlyacc生成的解析器可以通过设置在OCAMLRUNPARAM环境变量中的p选项进行调试（见第&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;）。这将导致执行解析器的下推自动机打印其动作的痕迹（令牌移位，规则减少等）。跟踪中提到了规则编号和状态编号，这些编号可以通过查看ocamlyacc -v生成的文件grammar.output来解释。</target>
        </trans-unit>
        <trans-unit id="54dd7dd52291d1b6f1c195771e2d20eb9e881245" translate="yes" xml:space="preserve">
          <source>At run-time, the ocamlyacc-generated parser can be debugged by setting the p option in the OCAMLRUNPARAM environment variable (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;). This causes the pushdown automaton executing the parser to print a trace of its action (tokens shifted, rules reduced, etc). The trace mentions rule numbers and state numbers that can be interpreted by looking at the file grammar.output generated by ocamlyacc -v.</source>
          <target state="translated">在运行时，可以通过在OCAMLRUNPARAM环境变量中设置p选项来调试ocamlyacc生成的解析器（请参见&lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;节）。这将导致执行解析器的下推自动机打印其动作的痕迹（令牌移位，规则减少等）。跟踪中提到了规则编号和状态编号，这些编号可以通过查看ocamlyacc -v生成的文件grammar.output来解释。</target>
        </trans-unit>
        <trans-unit id="d2f00cca88cba919167a69aefb8aca0e72bd25ac" translate="yes" xml:space="preserve">
          <source>At runtime, &lt;code&gt;opaque_identity&lt;/code&gt; disappears altogether.</source>
          <target state="translated">在运行时， &lt;code&gt;opaque_identity&lt;/code&gt; 完全消失。</target>
        </trans-unit>
        <trans-unit id="a9dc01fd9b8fd2388a520e411cae0d934f399e38" translate="yes" xml:space="preserve">
          <source>At some point, the C code must call caml_main(argv) to initialize the OCaml code. The argv argument is a C array of strings (type char **), terminated with a NULL pointer, which represents the command-line arguments, as passed as second argument to main. The OCaml array Sys.argv will be initialized from this parameter. For the bytecode compiler, argv[0] and argv[1] are also consulted to find the file containing the bytecode.</source>
          <target state="translated">在某些时候,C代码必须调用caml_main(argv)来初始化OCaml代码。argv参数是一个由字符串组成的C数组(类型为char **),以一个NULL指针结束,代表命令行参数,作为第二个参数传递给main。OCaml数组Sys.argv将由这个参数初始化。对于字节码编译器来说,argv[0]和argv[1]也会被用来查找包含字节码的文件。</target>
        </trans-unit>
        <trans-unit id="6144d2f50b69132b6f0e43a3d8df29f0e099b424" translate="yes" xml:space="preserve">
          <source>At the beginning of each iteration of a loop:</source>
          <target state="translated">在每次循环迭代的开始。</target>
        </trans-unit>
        <trans-unit id="276d173e91530ea988de8831effc50db36e2cd99" translate="yes" xml:space="preserve">
          <source>At this point, the type checker rightfully complains that it is not possible to swap an integer and a function, and that an int should always be traded for another int. Furthermore, the type checker prevents us to change manually the type of the value stored by store:</source>
          <target state="translated">这时,类型检查器理所当然地抱怨说,不可能将一个整数和一个函数交换,一个int总是应该换成另一个int。此外,类型检查器还阻止我们手动改变store存储的值的类型。</target>
        </trans-unit>
        <trans-unit id="baefb49296d510841d2323ca6269711e7aab517d" translate="yes" xml:space="preserve">
          <source>Atom(t) returns an &amp;ldquo;atom&amp;rdquo; (zero-sized block) with tag t. Zero-sized blocks are preallocated outside of the heap. It is incorrect to try and allocate a zero-sized block using the functions below. For instance, Atom(0) represents the empty array.</source>
          <target state="translated">Atom（t）返回带有标签t的&amp;ldquo; atom&amp;rdquo;（零尺寸块）。零大小的块在堆之外预先分配。尝试使用以下功能分配大小为零的块是不正确的。例如，Atom（0）表示空数组。</target>
        </trans-unit>
        <trans-unit id="f3023cb8188912c321e51f84008e15af7ab75428" translate="yes" xml:space="preserve">
          <source>Atomic</source>
          <target state="translated">Atomic</target>
        </trans-unit>
        <trans-unit id="4596b982bdd8c86e98fef6030471fc19a2011ab4" translate="yes" xml:space="preserve">
          <source>Attached to a &lt;em&gt;declaration&lt;/em&gt; of a function or functor, these direct the inliner to either always or never inline, irrespective of the size/benefit calculation. (If the function is recursive then the body is substituted and no special action is taken for the recursive call site(s).) @@inline with no argument is equivalent to @@inline always.</source>
          <target state="translated">这些附加到函数或函子的&lt;em&gt;声明&lt;/em&gt;上，可将内联线始终或永远不内联，而与大小/收益计算无关。（如果函数是递归的，则将替换主体，并且不对递归调用站点执行任何特殊操作。）不带参数的@@ inline始终等同于@@ inline。</target>
        </trans-unit>
        <trans-unit id="802fa8cc9235819a2e3ca4b7e5ad5a55102ca722" translate="yes" xml:space="preserve">
          <source>Attached to a declaration of a function or functor, this directs the inliner to either always or never specialise the function so long as it has appropriate contextual knowledge, irrespective of the size/benefit calculation. @@specialise with no argument is equivalent to @@specialise always.</source>
          <target state="translated">附加在函数或漏斗的声明中,这指示inliner总是或从不特殊化函数,只要它有适当的上下文知识,无论大小/效益计算如何。没有参数的@@specialise相当于@@specialise always。</target>
        </trans-unit>
        <trans-unit id="e01f52df1214db8e3914c14829a8d5d286049aea" translate="yes" xml:space="preserve">
          <source>Attached to a function &lt;em&gt;application&lt;/em&gt;, these direct the inliner likewise. These attributes at call sites override any other attribute that may be present on the corresponding declaration. @inlined with no argument is equivalent to @inlined always. @@inlined hint is equivalent to @@inline always except that it will not trigger warning 55 if the function application cannot be inlined.</source>
          <target state="translated">附加到功能&lt;em&gt;应用程序上&lt;/em&gt;，这些同样指示衬板。呼叫站点上的这些属性将覆盖相应声明中可能存在的任何其他属性。不带参数的@inlined始终等于@inlined。@@ inlined提示始终等同于@@ inline，不同之处在于，如果无法内嵌函数应用程序，则不会触发警告55。</target>
        </trans-unit>
        <trans-unit id="577cc545cd56605f7a335573934c186d1c5c7a5e" translate="yes" xml:space="preserve">
          <source>Attached to a function application, this directs the inliner likewise. This attribute at a call site overrides any other attribute that may be present on the corresponding declaration. (Note that the function will still only be specialised if there exist one or more invariant parameters whose values are known.) @specialised with no argument is equivalent to @specialised always.</source>
          <target state="translated">附加到函数应用程序上,这同样会引导inliner。调用站点的这个属性会覆盖相应声明中可能存在的任何其他属性。(请注意,只有当存在一个或多个值是已知的不变参数时,函数才会被特殊化。)没有参数的@specialised等同于@specialised always。</target>
        </trans-unit>
        <trans-unit id="1728583c4e4935b573475fde344d9528bb9ac187" translate="yes" xml:space="preserve">
          <source>Attribute cannot appear in this context.</source>
          <target state="translated">在这种情况下不能出现属性。</target>
        </trans-unit>
        <trans-unit id="4070acc0b0373988065e52262412987a5bd978b2" translate="yes" xml:space="preserve">
          <source>Attribute used more than once on an expression.</source>
          <target state="translated">在一个表达式上使用过一次以上的属性。</target>
        </trans-unit>
        <trans-unit id="5990efd0ab5779ce4f416b7925179828c4ee7318" translate="yes" xml:space="preserve">
          <source>Attributes are &amp;ldquo;decorations&amp;rdquo; of the syntax tree which are mostly ignored by the type-checker but can be used by external tools. An attribute is made of an identifier and a payload, which can be a structure, a type expression (prefixed with :), a signature (prefixed with :) or a pattern (prefixed with ?) optionally followed by a when clause:</source>
          <target state="translated">属性是语法树的&amp;ldquo;装饰&amp;rdquo;，类型检查器通常会忽略它们，但外部工具可以使用它们。属性由标识符和有效载荷组成，可以是结构，类型表达式（以：前缀），签名（以：前缀）或模式（以？前缀）（可选），后跟when子句：</target>
        </trans-unit>
        <trans-unit id="1f1f8b09e882b8bdbac720d714a972f55a4914cb" translate="yes" xml:space="preserve">
          <source>August 19, 2020</source>
          <target state="translated">2020年8月19日</target>
        </trans-unit>
        <trans-unit id="681b5b5ae10b994e61d9fc53cf8a95498ff0df39" translate="yes" xml:space="preserve">
          <source>Availability</source>
          <target state="translated">Availability</target>
        </trans-unit>
        <trans-unit id="24aced72f5f433a578a6c9a6998684afc743e91e" translate="yes" xml:space="preserve">
          <source>Avoid the following construction:</source>
          <target state="translated">避免以下构造。</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="603bfbbca70684e9b081257d12079a348cfb4ae1" translate="yes" xml:space="preserve">
          <source>Backend type currently executing the OCaml program.</source>
          <target state="translated">当前执行OCaml程序的后台类型。</target>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="translated">地址错误</target>
        </trans-unit>
        <trans-unit id="c3d27fc57dc9d9f238fc65173552cc838eeef367" translate="yes" xml:space="preserve">
          <source>Bad argument to routine</source>
          <target state="translated">对例行公事有不好的议论</target>
        </trans-unit>
        <trans-unit id="100269e198b12a051ab659ff66bd324a08031278" translate="yes" xml:space="preserve">
          <source>Bad file descriptor</source>
          <target state="translated">文件描述符错误</target>
        </trans-unit>
        <trans-unit id="8951a0674378b9d01744b0df5ceff44c017f170d" translate="yes" xml:space="preserve">
          <source>Bad module name: the source file name is not a valid OCaml module name.</source>
          <target state="translated">坏的模块名:源文件名不是有效的OCaml模块名。</target>
        </trans-unit>
        <trans-unit id="4eb2f5b83ca06e2054445f5793507dccb214e76c" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm.</source>
          <target state="translated">基数10对数。</target>
        </trans-unit>
        <trans-unit id="16d2d5bc5f9c1c788a0de9d9941705860dc2b3ce" translate="yes" xml:space="preserve">
          <source>Basic file input/output</source>
          <target state="translated">基本文件输入/输出</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">基本功能</target>
        </trans-unit>
        <trans-unit id="7074f9544472955bb39bd2591371cef9276556d5" translate="yes" xml:space="preserve">
          <source>Basic input/output</source>
          <target state="translated">基本输入/输出</target>
        </trans-unit>
        <trans-unit id="e51905526a8ccdb787933df456dfe816843d0ee8" translate="yes" xml:space="preserve">
          <source>Be aware that subtyping and inheritance are not related. Inheritance is a syntactic relation between classes while subtyping is a semantic relation between types. For instance, the class of colored points could have been defined directly, without inheriting from the class of points; the type of colored points would remain unchanged and thus still be a subtype of points.</source>
          <target state="translated">要知道,子类型化和继承是没有关系的。继承是类之间的语法关系,而子类型化是类型之间的语义关系。例如,可以直接定义彩点类,而不继承彩点类,彩点类的类型不变,因此仍然是彩点类的子类型。</target>
        </trans-unit>
        <trans-unit id="bdc8260c792f0fd4d9bb961f3934f71b326ac1eb" translate="yes" xml:space="preserve">
          <source>Before 4.10, it was not fully implemented by the native-code compiler.</source>
          <target state="translated">在4.10之前,它并没有被本地代码编译器完全实现。</target>
        </trans-unit>
        <trans-unit id="b74f4732c6818d44f09006d1f07ce5f4af4c8740" translate="yes" xml:space="preserve">
          <source>Before 4.10, stack overflows, typically caused by excessively deep recursion, are not always turned into a Stack_overflow exception like with the bytecode compiler. The runtime system makes a best effort to trap stack overflows and raise the Stack_overflow exception, but sometimes it fails and a &amp;ldquo;segmentation fault&amp;rdquo; or another system fault occurs instead.</source>
          <target state="translated">在4.10之前，通常由过深的递归引起的堆栈溢出并不总是像字节码编译器一样变成Stack_overflow异常。运行时系统尽最大努力捕获堆栈溢出并引发Stack_overflow异常，但是有时它会失败，而发生&amp;ldquo;分段错误&amp;rdquo;或其他系统错误。</target>
        </trans-unit>
        <trans-unit id="cb21f986b61750e9afb09c606ad7c4cb297548ed" translate="yes" xml:space="preserve">
          <source>Before OCaml 4.08, there was support for a single kind of deprecation alert. It is now known as the deprecated alert, but legacy attributes to trigger it and the legacy ways to control it as warning 3 are still supported. For instance, passing -w +3 on the command-line is equivant to -alert +deprecated, and:</source>
          <target state="translated">在OCaml 4.08之前,支持一种单一的废弃警报。现在它被称为废弃警报,但仍然支持用于触发它的传统属性和控制它的传统方法,如警告3。例如,在命令行传递-w +3就相当于-alert +deprecated,而且。</target>
        </trans-unit>
        <trans-unit id="2de7f66ef195f2ee3a503b74c10b402e912c79ce" translate="yes" xml:space="preserve">
          <source>Before OCaml 4.09, this package simply ensures that the graphics library was installed by the compiler, and starting from OCaml 4.09 this package effectively provides the graphics library.</source>
          <target state="translated">在OCaml 4.09之前,这个包只是保证编译器安装了图形库,从OCaml 4.09开始,这个包有效地提供了图形库。</target>
        </trans-unit>
        <trans-unit id="74c16ae70bc6bcd030afe7f8bd853a9b539bab1c" translate="yes" xml:space="preserve">
          <source>Before including any of these files, you should define the CAML_NAME_SPACE macro. For instance,</source>
          <target state="translated">在包含这些文件之前,您应该定义CAML_NAME_SPACE宏。例如:</target>
        </trans-unit>
        <trans-unit id="e622083eb29748ddeeec3a04799aa00ee19ac13f" translate="yes" xml:space="preserve">
          <source>Before including any of these files, you should define the OCAML_NAME_SPACE macro. For instance,</source>
          <target state="translated">在包含这些文件之前,你应该定义OCAML_NAME_SPACE宏。例如:</target>
        </trans-unit>
        <trans-unit id="e4c77c58f74ae16545b5cc8be7261a9790aaed7e" translate="yes" xml:space="preserve">
          <source>Before profiling an execution, the program must be compiled in profiling mode, using the ocamlcp front-end to the ocamlc compiler (see chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;) or the ocamloptp front-end to the ocamlopt compiler (see chapter &amp;zwj;&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;). When compiling modules separately, ocamlcp or ocamloptp must be used when compiling the modules (production of .cmo or .cmx files), and can also be used (though this is not strictly necessary) when linking them together.</source>
          <target state="translated">仿形的执行之前，程序必须在分析模式使用ocamlcp前端到ocamlc编译器编译，（见章节&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;）或ocamloptp前端到ocamlopt编译器（见章节&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;）。当分别编译模块时，在编译模块（.cmo或.cmx文件的生成）时必须使用ocamlcp或ocamloptp，并且在将它们链接在一起时也可以使用ocamlcp或ocamloptp（尽管并非严格要求）。</target>
        </trans-unit>
        <trans-unit id="3e4184edb42a26ccfe7484a8b5fb01a18a764ebd" translate="yes" xml:space="preserve">
          <source>Before profiling an execution, the program must be compiled in profiling mode, using the ocamlcp front-end to the ocamlc compiler (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;) or the ocamloptp front-end to the ocamlopt compiler (see chapter &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;). When compiling modules separately, ocamlcp or ocamloptp must be used when compiling the modules (production of .cmo or .cmx files), and can also be used (though this is not strictly necessary) when linking them together.</source>
          <target state="translated">在对执行进行性能分析之前，必须使用ocamlc前端的ocamlcp前端（请参阅第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章）或ocamloptp编译器的ocamloptp前端（请参见第&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;章）以性能分析模式编译程序。当分别编译模块时，在编译模块（.cmo或.cmx文件的生成）时必须使用ocamlcp或ocamloptp，并且在将它们链接在一起时也可以使用ocamlcp或ocamloptp（尽管并非严格要求）。</target>
        </trans-unit>
        <trans-unit id="d51fe98572851ae3a2060aa9cce6148029d326e3" translate="yes" xml:space="preserve">
          <source>Before the debugger can be used, the program must be compiled and linked with the -g option: all .cmo and .cma files that are part of the program should have been created with ocamlc -g, and they must be linked together with ocamlc -g.</source>
          <target state="translated">在使用调试器之前,必须先编译程序,并使用-g选项进行链接:所有作为程序一部分的.cmo和.cma文件都应该是用ocamlc -g创建的,它们必须用ocamlc -g链接在一起。</target>
        </trans-unit>
        <trans-unit id="7224b7ef29ead465950bd04b8cbe2bc5541ba937" translate="yes" xml:space="preserve">
          <source>Behave as &lt;a href=&quot;threadunix#VALread&quot;&gt;&lt;code&gt;ThreadUnix.read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;threadunix#VALwrite&quot;&gt;&lt;code&gt;ThreadUnix.write&lt;/code&gt;&lt;/a&gt;, except that &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; is raised if no data is available for reading or ready for writing after &lt;code&gt;d&lt;/code&gt; seconds.</source>
          <target state="translated">表现为&lt;a href=&quot;threadunix#VALread&quot;&gt; &lt;code&gt;ThreadUnix.read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;threadunix#VALwrite&quot;&gt; &lt;code&gt;ThreadUnix.write&lt;/code&gt; &lt;/a&gt;，不同之处在于 &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; 如果在 &lt;code&gt;d&lt;/code&gt; 秒后没有可用的数据读取或准备写入，则会引发Unix_error（ETIMEDOUT，_，_）。</target>
        </trans-unit>
        <trans-unit id="c62be5fdf722fa0cb2c996d270b26e047fd26ba0" translate="yes" xml:space="preserve">
          <source>Behave as &lt;a href=&quot;threadunix#VALread&quot;&gt;&lt;code&gt;ThreadUnix.read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;threadunix#VALwrite&quot;&gt;&lt;code&gt;ThreadUnix.write&lt;/code&gt;&lt;/a&gt;, except that &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; is raised if no data is available for reading or ready for writing after &lt;code&gt;d&lt;/code&gt; seconds. The delay &lt;code&gt;d&lt;/code&gt; is given in the fifth argument, in seconds.</source>
          <target state="translated">表现为&lt;a href=&quot;threadunix#VALread&quot;&gt; &lt;code&gt;ThreadUnix.read&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;threadunix#VALwrite&quot;&gt; &lt;code&gt;ThreadUnix.write&lt;/code&gt; &lt;/a&gt;，不同之处在于 &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; 如果在 &lt;code&gt;d&lt;/code&gt; 秒后没有可用的数据读取或准备写入，则会引发Unix_error（ETIMEDOUT，_，_）。延迟 &lt;code&gt;d&lt;/code&gt; 在第五个参数中以秒为单位。</target>
        </trans-unit>
        <trans-unit id="3044d7453db8cbe2dec3a026dd466846b73be035" translate="yes" xml:space="preserve">
          <source>Being written directly into the output device of the formatter, semantic tag marker strings are not considered as part of the printing material that drives line splitting (in other words, the length of the strings corresponding to tag markers is considered as zero for line splitting).</source>
          <target state="translated">由于直接写入格式器的输出设备中,语义标签标记字符串不被视为驱动分行的打印材料的一部分(换句话说,标签标记对应的字符串长度在分行时被视为零)。</target>
        </trans-unit>
        <trans-unit id="69bf3db7f530d816adacc226db72ff8b952d7e77" translate="yes" xml:space="preserve">
          <source>Between subexpressions of a sequence:</source>
          <target state="translated">一个序列的子表达式之间。</target>
        </trans-unit>
        <trans-unit id="e01187252d64e42965e1df4b1a6807e200efab0e" translate="yes" xml:space="preserve">
          <source>Between the header and the entry points, one can give names to frequently-occurring regular expressions. This is written let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;. In regular expressions that follow this declaration, the identifier ident can be used as shorthand for regexp.</source>
          <target state="translated">在标题和入口点之间，可以为经常出现的正则表达式命名。这写成let &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;。在此声明之后的正则表达式中，标识符ident可用作regexp的简写。</target>
        </trans-unit>
        <trans-unit id="0762b857edb23abb186d37a5e2a1cf9b1db82d70" translate="yes" xml:space="preserve">
          <source>Beware also that some idioms make trivial errors very hard to find. For instance, the following code is probably wrong but the compiler has no way to see it.</source>
          <target state="translated">同时也要注意,有些成语会让一些琐碎的错误很难被发现。例如,下面的代码可能是错误的,但编译器却没有办法看到它。</target>
        </trans-unit>
        <trans-unit id="e96e5378f7f04072916e26ed0422a2ca7fee4ed6" translate="yes" xml:space="preserve">
          <source>Beware of the small syntactic difference between a type constraint on the last parameter</source>
          <target state="translated">要注意最后一个参数的类型约束和类型约束之间的微小语法差异。</target>
        </trans-unit>
        <trans-unit id="0863d7cb6a04fad42cda06f67cbcf747fb4740c8" translate="yes" xml:space="preserve">
          <source>Beware that channels are buffered so more characters may have been read from the file descriptor than those accessed using channel functions. Channels also keep a copy of the current position in the file.</source>
          <target state="translated">注意通道是有缓冲的,所以从文件描述符中读取的字符可能比使用通道函数访问的字符多。通道还保留了文件中当前位置的副本。</target>
        </trans-unit>
        <trans-unit id="9a7e376571acd2b703f175df9ba62834f1210318" translate="yes" xml:space="preserve">
          <source>Beware that channels are buffered so you may have to &lt;code&gt;flush&lt;/code&gt; them to ensure that all data has been sent to the file descriptor. Channels also keep a copy of the current position in the file.</source>
          <target state="translated">注意通道已缓冲，因此您可能必须 &lt;code&gt;flush&lt;/code&gt; 它们以确保所有数据都已发送到文件描述符。通道还会在文件中保留当前位置的副本。</target>
        </trans-unit>
        <trans-unit id="5020d42579c29f95a37a928f6ee296b1bfbd2ce0" translate="yes" xml:space="preserve">
          <source>Beware that the differentiation between the multi-index and single index operators is purely syntactic: multi-index operators are restricted to index expressions that contain one or more semicolons ;. For instance,</source>
          <target state="translated">要注意的是,多索引操作符和单索引操作符之间的区别纯粹是语法上的:多索引操作符仅限于包含一个或多个分号;的索引表达式。例如</target>
        </trans-unit>
        <trans-unit id="ecbdc1b64ef7dc2e9165f4238a760cb0019a726a" translate="yes" xml:space="preserve">
          <source>Beware that this extension is not available inside class definitions:</source>
          <target state="translated">请注意,这个扩展在类定义里面是不可用的。</target>
        </trans-unit>
        <trans-unit id="7c29307b11084a93c6603a32d5d737b8390831ae" translate="yes" xml:space="preserve">
          <source>Beware that this last resort disambiguation is local: once Ocaml has chosen a disambiguation, it sticks to this choice, even if it leads to an ulterior type error:</source>
          <target state="translated">要注意的是,这种最后的消除歧义是局部的:一旦Ocaml选择了一个消除歧义,它就会坚持这个选择,即使它导致了一个不可告人的类型错误。</target>
        </trans-unit>
        <trans-unit id="f7b2a8eecc3712331ab94305233f63d504f21583" translate="yes" xml:space="preserve">
          <source>Bigarray</source>
          <target state="translated">Bigarray</target>
        </trans-unit>
        <trans-unit id="7380a093245acf7191eec9ec92e09a46e18e884e" translate="yes" xml:space="preserve">
          <source>Bigarray.Array1.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;</source>
          <target state="translated">Bigarray.Array1.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4836645873279d91f4ef6d2469cebce7bf5a1513" translate="yes" xml:space="preserve">
          <source>Bigarray.Array1.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Bigarray.Array1.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="294760cd59cde90db4052169e314f7fd0306af03" translate="yes" xml:space="preserve">
          <source>Bigarray.Array2.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;</source>
          <target state="translated">Bigarray.Array2.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="1e8ad3137dd1b9a26a9779ee12d030fac6493896" translate="yes" xml:space="preserve">
          <source>Bigarray.Array2.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Bigarray.Array2.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99bb9e3898bd689c37ba94b52b1bc73b90a6f4ab" translate="yes" xml:space="preserve">
          <source>Bigarray.Array3.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;</source>
          <target state="translated">Bigarray.Array3.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="bf4b044934c55212e0d48ca2144367b12b0b6cdc" translate="yes" xml:space="preserve">
          <source>Bigarray.Array3.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Bigarray.Array3.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfde812cd151ad76b57b0ef94c12067805e1b7a8" translate="yes" xml:space="preserve">
          <source>Bigarray.Genarray.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]</source>
          <target state="translated">Bigarray.Genarray.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]</target>
        </trans-unit>
        <trans-unit id="e5eae93e4a3f09b82ba2713ee1b9fab39405ccae" translate="yes" xml:space="preserve">
          <source>Bigarray.Genarray.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Bigarray.Genarray.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="164b37e902bccec375adcec6ac207f8d8528851b" translate="yes" xml:space="preserve">
          <source>Bigarrays are multi-dimensional. Any number of dimensions between 0 and 16 is supported. In contrast, OCaml arrays are mono-dimensional and require encoding multi-dimensional arrays as arrays of arrays.</source>
          <target state="translated">Bigarrays是多维的。支持0到16之间的任意维数。而OCaml数组是单维的,需要将多维数组编码为数组的数组。</target>
        </trans-unit>
        <trans-unit id="6b10643bcaf2c18dffa1745f8ce67e9efe32a9b7" translate="yes" xml:space="preserve">
          <source>Bigarrays are not limited in size, unlike OCaml arrays. (Normal float arrays are limited to 2,097,151 elements on a 32-bit platform, and normal arrays of other types to 4,194,303 elements.)</source>
          <target state="translated">与OCaml数组不同,Bigarrays在大小上没有限制。(在32位平台上,普通浮动数组被限制为2,097,151个元素,其他类型的普通数组被限制为4,194,303个元素)。</target>
        </trans-unit>
        <trans-unit id="b3c068760255c39d7cfb8804626af3c6a04134aa" translate="yes" xml:space="preserve">
          <source>Bigarrays can contain elements of the following kinds:</source>
          <target state="translated">Bigarrays可以包含以下类型的元素:</target>
        </trans-unit>
        <trans-unit id="06bbb03d095ef0403ef39ce3bec731f64c4edc60" translate="yes" xml:space="preserve">
          <source>Bigarrays can only contain integers and floating-point numbers, while OCaml arrays can contain arbitrary OCaml data types.</source>
          <target state="translated">Bigarrays只能包含整数和浮点数,而OCaml数组可以包含任意的OCaml数据类型。</target>
        </trans-unit>
        <trans-unit id="dde73a8c5eb1bd7ebbe27f805e2f18a62417b5de" translate="yes" xml:space="preserve">
          <source>Bigarrays provide more space-efficient storage of integer and floating-point elements than normal OCaml arrays, in particular because they support 'small' types such as single-precision floats and 8 and 16-bit integers, in addition to the standard OCaml types of double-precision floats and 32 and 64-bit integers.</source>
          <target state="translated">比起普通的OCaml数组,Bigarrays提供了更节省空间的整数和浮点元素存储,特别是由于它们支持 &quot;小 &quot;类型,如单精度浮点和8位和16位整数,以及标准的OCaml类型双精度浮点和32位和64位整数。</target>
        </trans-unit>
        <trans-unit id="3b30eba7780f6a33ce03c9072c579c3a782adda9" translate="yes" xml:space="preserve">
          <source>Bigarrays returned by &lt;code&gt;Genarray.create&lt;/code&gt; are not initialized: the initial values of array elements is unspecified.</source>
          <target state="translated">Genarray.create返回的 &lt;code&gt;Genarray.create&lt;/code&gt; 不会初始化：数组元素的初始值未指定。</target>
        </trans-unit>
        <trans-unit id="062335b880b9c90adbbcca33a681878e4c2f925f" translate="yes" xml:space="preserve">
          <source>Bigarrays support all the OCaml ad-hoc polymorphic operations:</source>
          <target state="translated">Bigarrays支持所有OCaml特设多态操作。</target>
        </trans-unit>
        <trans-unit id="b78c464588eab46be79b11f66000060a0a82592e" translate="yes" xml:space="preserve">
          <source>Bigarrays support interesting high-level operations that normal arrays do not provide efficiently, such as extracting sub-arrays and 'slicing' a multi-dimensional array along certain dimensions, all without any copying.</source>
          <target state="translated">Bigarrays支持普通数组无法有效提供的有趣的高级操作,例如提取子数组和沿特定维度 &quot;切片 &quot;一个多维数组,所有这些操作都不需要任何复制。</target>
        </trans-unit>
        <trans-unit id="fc7ba9c56ac265afa1c83c3f5860425f6f8d05c6" translate="yes" xml:space="preserve">
          <source>Binary encoding of integers</source>
          <target state="translated">整数的二进制编码</target>
        </trans-unit>
        <trans-unit id="dbb694c389c0cdbf75c25a19ef2b17058523cf0a" translate="yes" xml:space="preserve">
          <source>Binary encoding/decoding of integers</source>
          <target state="translated">整数的二进制编码/解码。</target>
        </trans-unit>
        <trans-unit id="9c6c7ebe66c193cc69e8f187e150bb8eb2c2713a" translate="yes" xml:space="preserve">
          <source>Binary semaphores</source>
          <target state="translated">二元符号</target>
        </trans-unit>
        <trans-unit id="51f9ee60f439641ca9d8f01310d42d9ae7114a0b" translate="yes" xml:space="preserve">
          <source>Binary semaphores are a variant of counting semaphores where semaphores can only take two values, 0 and 1.</source>
          <target state="translated">二进制旗语是计数旗语的一种变体,旗语只能取两个值,0和1。</target>
        </trans-unit>
        <trans-unit id="c67c6977825a3171348c86b630d52532cd50075d" translate="yes" xml:space="preserve">
          <source>Bind a socket to an address.</source>
          <target state="translated">将一个套接字绑定到一个地址。</target>
        </trans-unit>
        <trans-unit id="d545537631f4daa805af6977069a1ae659ac89fa" translate="yes" xml:space="preserve">
          <source>Bind the substring matched by &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; to identifier &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;.</source>
          <target state="translated">将与&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;匹配的子字符串绑定到标识符&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98010387d59d504f717882ee0e29ce9561ef02f7" translate="yes" xml:space="preserve">
          <source>Bitwise arithmetic shift right on integers.</source>
          <target state="translated">整数上的位数算术右移。</target>
        </trans-unit>
        <trans-unit id="1ad662d09220d0d46d46b6bfecb1798cd38adcc0" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;and&amp;rdquo; on integers.</source>
          <target state="translated">整数的按位逻辑&amp;ldquo;与&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="49aac382b8e35200a9044197b1ea4c4df4708643" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;exclusive or&amp;rdquo; on integers.</source>
          <target state="translated">整数按位逻辑&amp;ldquo;异或&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="286b2e0f11888729ecb5275bfd01f89e609e86af" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;or&amp;rdquo; on integers.</source>
          <target state="translated">整数按位逻辑&amp;ldquo;或&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="38f47fa82a9e81696cb44cafa1b49f3b15a8d783" translate="yes" xml:space="preserve">
          <source>Bitwise logical and.</source>
          <target state="translated">位的逻辑和。</target>
        </trans-unit>
        <trans-unit id="f8120788c98e6228e8b9d7bcf0ec24a6003d5162" translate="yes" xml:space="preserve">
          <source>Bitwise logical and. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">按位逻辑与。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e12d57bf21bac825baf9ff63c9856f69ab644445" translate="yes" xml:space="preserve">
          <source>Bitwise logical exclusive or.</source>
          <target state="translated">位的逻辑独占或。</target>
        </trans-unit>
        <trans-unit id="d9b30b925799da28ec0ac76d3e01a3f81148da08" translate="yes" xml:space="preserve">
          <source>Bitwise logical exclusive or. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">按位逻辑异或。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e959911aefbddc80325181098fb38e48a8332ea" translate="yes" xml:space="preserve">
          <source>Bitwise logical negation.</source>
          <target state="translated">位的逻辑否定。</target>
        </trans-unit>
        <trans-unit id="a2b2038f4572ce60bed7fe655e3af57ae6849b39" translate="yes" xml:space="preserve">
          <source>Bitwise logical or.</source>
          <target state="translated">位逻辑或。</target>
        </trans-unit>
        <trans-unit id="40f0ebc0438d2a8b3f7d8ab17a47e2fc7e9a6733" translate="yes" xml:space="preserve">
          <source>Bitwise logical or. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">按位逻辑或。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51e629b6c338431a80d282be3b9738ea06d447a3" translate="yes" xml:space="preserve">
          <source>Bitwise logical shift left on integers.</source>
          <target state="translated">整数上的位逻辑左移。</target>
        </trans-unit>
        <trans-unit id="1c1d051215d4090b7e416aa0c5b96654c34c3df3" translate="yes" xml:space="preserve">
          <source>Bitwise logical shift right on integers.</source>
          <target state="translated">在整数上进行位逻辑移位右。</target>
        </trans-unit>
        <trans-unit id="67445a8812f7cd259e3b6e21272d2fddff30a9e2" translate="yes" xml:space="preserve">
          <source>Bitwise operations</source>
          <target state="translated">位面操作</target>
        </trans-unit>
        <trans-unit id="e2f8396020dfba14aa5dc6b1bd83f4647bd8ef67" translate="yes" xml:space="preserve">
          <source>Block device</source>
          <target state="translated">屏蔽设备</target>
        </trans-unit>
        <trans-unit id="f44f089c39b56e3f8dc6fad275cc2d75db99650b" translate="yes" xml:space="preserve">
          <source>Block with size = 2 and tag = 0; first field contains h, second field t.</source>
          <target state="translated">块的大小=2,标签=0;第一个字段包含h,第二个字段包含t。</target>
        </trans-unit>
        <trans-unit id="28d4367bfac6247903d75f1f870462ae73cd80c5" translate="yes" xml:space="preserve">
          <source>Blocks in the heap are garbage-collected, and therefore have strict structure constraints. Each block includes a header containing the size of the block (in words), and the tag of the block. The tag governs how the contents of the blocks are structured. A tag lower than No_scan_tag indicates a structured block, containing well-formed values, which is recursively traversed by the garbage collector. A tag greater than or equal to No_scan_tag indicates a raw block, whose contents are not scanned by the garbage collector. For the benefit of ad-hoc polymorphic primitives such as equality and structured input-output, structured and raw blocks are further classified according to their tags as follows:</source>
          <target state="translated">堆中的块是垃圾收集的,因此有严格的结构约束。每个块包括一个头,包含块的大小(以字为单位)和块的标签。标签规定了块的内容如何被结构化。一个小于No_scan_tag的标签表示一个结构化的块,包含了良好的值,它被垃圾收集器递归遍历。大于或等于No_scan_tag的标签表示一个原始块,其内容不被垃圾回收器扫描。为了方便特设多态基元,如平等和结构化输入输出,结构化块和原始块根据其标签进一步分类如下。</target>
        </trans-unit>
        <trans-unit id="d52377d4f36f405cfd1e7a45f168ae549d215d39" translate="yes" xml:space="preserve">
          <source>Blocks with tag Custom_tag contain both arbitrary user data and a pointer to a C struct, with type struct custom_operations, that associates user-provided finalization, comparison, hashing, serialization and deserialization functions to this block.</source>
          <target state="translated">带有标签的块Custom_tag既包含任意的用户数据,也包含一个指向C结构的指针,其类型为custom_operations结构,该结构将用户提供的最终化、比较、散列、序列化和反序列化函数关联到该块。</target>
        </trans-unit>
        <trans-unit id="f8c46ad79d1dd84b74158fed8d17c80696f45ae5" translate="yes" xml:space="preserve">
          <source>Blocks with tag Custom_tag.</source>
          <target state="translated">带有标签Custom_tag的区块。</target>
        </trans-unit>
        <trans-unit id="c12647fc73d7d1c9966497cc2c05ac43b902e3a4" translate="yes" xml:space="preserve">
          <source>Blocks with tag Double_tag.</source>
          <target state="translated">带有标签Double_tag的区块。</target>
        </trans-unit>
        <trans-unit id="7474968263988ef1fdd02a5d43ba5d0ef74d1f29" translate="yes" xml:space="preserve">
          <source>Blocks with tag String_tag.</source>
          <target state="translated">标记为String_tag的块。</target>
        </trans-unit>
        <trans-unit id="daf760a167a8047cee872015a8e80002f3b67442" translate="yes" xml:space="preserve">
          <source>Bool</source>
          <target state="translated">Bool</target>
        </trans-unit>
        <trans-unit id="72c318f119ab639d07f13e4bb5d9f5319d190b18" translate="yes" xml:space="preserve">
          <source>Bool_val(v) returns 0 if v is the OCaml boolean false, 1 if v is true.</source>
          <target state="translated">Bool_val(v)如果v是OCaml布尔值false,则返回0;如果v是true,则返回1。</target>
        </trans-unit>
        <trans-unit id="0ec6611901208bd78d162029849792816f5b2deb" translate="yes" xml:space="preserve">
          <source>Boolean conjunction.</source>
          <target state="translated">布尔型连词。</target>
        </trans-unit>
        <trans-unit id="edfcfb577d5e30b5e6899078780ad10f83147239" translate="yes" xml:space="preserve">
          <source>Boolean disjunction.</source>
          <target state="translated">布尔型离合。</target>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="translated">布尔运算</target>
        </trans-unit>
        <trans-unit id="e29add877007424818746892be55cde474c75bba" translate="yes" xml:space="preserve">
          <source>Boolean values.</source>
          <target state="translated">布尔值。</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="e117da47e3d7be3e9e0a3f82f9b8350253013973" translate="yes" xml:space="preserve">
          <source>Bound on floating garbage for out-of-heap memory held by custom values in the minor heap. A minor GC is triggered when this much memory is held by custom values located in the minor heap. Expressed as a percentage of minor heap size. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 100.</source>
          <target state="translated">绑定在浮动垃圾上，以存储次要堆中的自定义值保存的堆外内存。当位于次要堆中的自定义值保留了这么多内存时，将触发次要GC。表示为较小堆大小的百分比。注意：这仅适用于用 &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; 分配的值（例如bigarrays）。默认值：100。</target>
        </trans-unit>
        <trans-unit id="08b716c0794dbc0057215ee2f154e80bba251c2e" translate="yes" xml:space="preserve">
          <source>Break hints</source>
          <target state="translated">破解提示</target>
        </trans-unit>
        <trans-unit id="310549596be621bab70cac3b1e9df753e4f4a81d" translate="yes" xml:space="preserve">
          <source>Break hints are used to separate printing items and are mandatory to let the pretty-printer correctly split lines and indent items.</source>
          <target state="translated">分割提示是用来分隔打印项目的,是让漂亮打印机正确分线和缩进项目的必备条件。</target>
        </trans-unit>
        <trans-unit id="c82e2d18efe99fcf7dc512f1f1e8d815a8811ce1" translate="yes" xml:space="preserve">
          <source>Break hints in a horizontal box never split the line. (Line splitting may still occur inside boxes nested deeper).</source>
          <target state="translated">横框内的断线提示永远不要分线。(在嵌套较深的框内仍可能出现拆线现象)。</target>
        </trans-unit>
        <trans-unit id="c7dfd8323fd5e72ce649953eb9bbb100abdbf328" translate="yes" xml:space="preserve">
          <source>Broken pipe</source>
          <target state="translated">断裂的管道</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="a22edc1d8185e0421ca424eaf16cf9e2dafd3a13" translate="yes" xml:space="preserve">
          <source>Build a bytecode object file (.cmo file) and its associated compiled interface (.cmi) that combines the object files given on the command line, making them appear as sub-modules of the output .cmo file. The name of the output .cmo file must be given with the -o option. For instance,</source>
          <target state="translated">建立一个字节码对象文件(.cmo文件)及其相关的编译接口(.cmi),它结合了命令行给出的对象文件,使它们看起来像输出.cmo文件的子模块。输出.cmo文件的名称必须用-o选项给出。例如</target>
        </trans-unit>
        <trans-unit id="24d9722dac9658c6b23f48bb45b1da2eada712bd" translate="yes" xml:space="preserve">
          <source>Build a custom runtime system (in the file specified by option -o) incorporating the C object files and libraries given on the command line. This custom runtime system can be used later to execute bytecode executables produced with the ocamlc -use-runtimeruntime-name option. See section &amp;zwj;&lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;18.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">构建一个自定义的运行时系统（在选项-o指定的文件中），其中包含命令行中提供的C对象文件和库。此自定义的运行时系统可在以后用于执行使用ocamlc -use-runtimeruntime-name选项生成的字节码可执行文件。请参见&lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;18.1.6&lt;/a&gt;获取更多信息。</target>
        </trans-unit>
        <trans-unit id="8c491ef5b62f19f72f7c09ad96021606366a71f4" translate="yes" xml:space="preserve">
          <source>Build a custom runtime system (in the file specified by option -o) incorporating the C object files and libraries given on the command line. This custom runtime system can be used later to execute bytecode executables produced with the ocamlc -use-runtimeruntime-name option. See section &lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">构建一个自定义的运行时系统（在选项-o指定的文件中），其中包含命令行中提供的C对象文件和库。此自定义的运行时系统可在以后用于执行使用ocamlc -use-runtimeruntime-name选项生成的字节码可执行文件。有关更多信息，请参见第&lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="689a03030d28c2fe2318c8c8f9722c5b8054bdb7" translate="yes" xml:space="preserve">
          <source>Build a library(.cma file) with the object files ( .cmo files) given on the command line, instead of linking them into an executable file. The name of the library must be set with the -o option.</source>
          <target state="translated">用命令行给出的对象文件(.cmo文件)建立一个库(.cma文件),而不是将它们链接到一个可执行文件中。库的名称必须用-o选项设置。</target>
        </trans-unit>
        <trans-unit id="d3c6d896e003bfea1990e747dab4717403d4a43c" translate="yes" xml:space="preserve">
          <source>Build a library(.cmxa and .a/.lib files) with the object files (.cmx and .o/.obj files) given on the command line, instead of linking them into an executable file. The name of the library must be set with the -o option.</source>
          <target state="translated">用命令行给出的对象文件(.cmx和.o/.obj文件)建立一个库(.cmxa和.a/.lib文件),而不是将它们链接到一个可执行文件中。库的名称必须用-o选项来设置。</target>
        </trans-unit>
        <trans-unit id="a7fc2d180dacf6e6dc88e07dfb99b1916ef75f25" translate="yes" xml:space="preserve">
          <source>Build a map from the given bindings</source>
          <target state="translated">从给定的绑定中建立一个地图</target>
        </trans-unit>
        <trans-unit id="7291990c98b91f383cf392959b02f1108bd054ae" translate="yes" xml:space="preserve">
          <source>Build a one-dimensional Bigarray initialized from the given array.</source>
          <target state="translated">从给定的数组中初始化建立一个一维的Bigarray。</target>
        </trans-unit>
        <trans-unit id="18cd8e2d3ddf697fe8d31528763b8007962db336" translate="yes" xml:space="preserve">
          <source>Build a plugin (usually .cmxs) that can be dynamically loaded with the Dynlink module. The name of the plugin must be set with the -o option. A plugin can include a number of OCaml modules and libraries, and extra native objects (.o, .obj, .a, .lib files). Building native plugins is only supported for some operating system. Under some systems (currently, only Linux AMD 64), all the OCaml code linked in a plugin must have been compiled without the -nodynlink flag. Some constraints might also apply to the way the extra native objects have been compiled (under Linux AMD 64, they must contain only position-independent code).</source>
          <target state="translated">建立一个插件(通常是.cmxs),可以与Dynlink模块动态加载。插件的名称必须用-o选项来设置。一个插件可以包含一些OCaml模块和库,以及额外的本地对象(.o、.obj、.a、.lib文件)。构建本机插件只在某些操作系统中得到支持。在某些系统下(目前,只有Linux AMD 64),插件中链接的所有OCaml代码必须在没有使用-nodynlink标志的情况下进行编译。一些限制也可能适用于额外的本地对象的编译方式(在Linux AMD 64下,它们必须只包含与位置无关的代码)。</target>
        </trans-unit>
        <trans-unit id="069a1c0c668653aee76345e068c67b55843bbe6f" translate="yes" xml:space="preserve">
          <source>Build a self-contained executable by linking a C object file containing the bytecode program, the OCaml runtime system and any other static C code given to ocamlc. The resulting effect is similar to -custom, except that the bytecode is embedded in the C code so it is no longer accessible to tools such as ocamldebug. On the other hand, the resulting binary is resistant to strip.</source>
          <target state="translated">通过链接一个包含字节码程序、OCaml运行时系统和任何其他静态C代码的C对象文件来构建一个自足的可执行文件。所产生的效果与-custom类似,只是字节码被嵌入到C代码中,所以不再能被诸如ocamldebug等工具访问。另一方面,得到的二进制代码是抗剥离的。</target>
        </trans-unit>
        <trans-unit id="12091461d26b4a9178ef9b7fb79d4ea74a7322de" translate="yes" xml:space="preserve">
          <source>Build a sequence from a step function and an initial value.</source>
          <target state="translated">从一个步骤函数和一个初始值建立一个序列。</target>
        </trans-unit>
        <trans-unit id="89302c14cbe821b3cc65efb42319c0731273420e" translate="yes" xml:space="preserve">
          <source>Build a sequence from a step function and an initial value. &lt;code&gt;unfold&amp;nbsp;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;empty&lt;/code&gt; if &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, or &lt;code&gt;fun&amp;nbsp;()&amp;nbsp;-&amp;gt;&amp;nbsp;Cons&amp;nbsp;(x,&amp;nbsp;unfold&amp;nbsp;f&amp;nbsp;y)&lt;/code&gt; if &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;Some&amp;nbsp;(x,&amp;nbsp;y)&lt;/code&gt;.</source>
          <target state="translated">根据阶跃函数和初始值构建序列。 &lt;code&gt;unfold&amp;nbsp;f&amp;nbsp;u&lt;/code&gt; 返回 &lt;code&gt;empty&lt;/code&gt; ，如果 &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; 返回 &lt;code&gt;None&lt;/code&gt; ，或 &lt;code&gt;fun&amp;nbsp;()&amp;nbsp;-&amp;gt;&amp;nbsp;Cons&amp;nbsp;(x,&amp;nbsp;unfold&amp;nbsp;f&amp;nbsp;y)&lt;/code&gt; 如果 &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; 返回 &lt;code&gt;Some&amp;nbsp;(x,&amp;nbsp;y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40f99ba2c885b0621a0361f7903d103f89a1bcdc" translate="yes" xml:space="preserve">
          <source>Build a set from the given bindings</source>
          <target state="translated">从给定的绑定中建立一个集合</target>
        </trans-unit>
        <trans-unit id="7703cf54010e3d2a2a46e2aa34796e3417727340" translate="yes" xml:space="preserve">
          <source>Build a table from the given bindings.</source>
          <target state="translated">从给定的绑定中建立一个表格。</target>
        </trans-unit>
        <trans-unit id="bed507cdc786047af911f4641801d1284f48b787" translate="yes" xml:space="preserve">
          <source>Build a table from the given bindings. The bindings are added in the same order they appear in the sequence, using &lt;a href=&quot;hashtbl#VALreplace_seq&quot;&gt;&lt;code&gt;Hashtbl.replace_seq&lt;/code&gt;&lt;/a&gt;, which means that if two pairs have the same key, only the latest one will appear in the table.</source>
          <target state="translated">根据给定的绑定建立一个表。绑定使用&lt;a href=&quot;hashtbl#VALreplace_seq&quot;&gt; &lt;code&gt;Hashtbl.replace_seq&lt;/code&gt; &lt;/a&gt;按照在序列中出现的顺序添加，这意味着如果两对具有相同的键，则表中只会出现最新的键。</target>
        </trans-unit>
        <trans-unit id="6e85219c50d6a1d21950650a92863c4c3c52cdaa" translate="yes" xml:space="preserve">
          <source>Build a table from the given bindings. The bindings are added in the same order they appear in the sequence, using &lt;a href=&quot;morelabels.hashtbl#VALreplace_seq&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.replace_seq&lt;/code&gt;&lt;/a&gt;, which means that if two pairs have the same key, only the latest one will appear in the table.</source>
          <target state="translated">根据给定的绑定建立一个表。使用&lt;a href=&quot;morelabels.hashtbl#VALreplace_seq&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.replace_seq&lt;/code&gt; &lt;/a&gt;以相同的顺序添加绑定，这意味着如果两对具有相同的密钥，则表中只会出现最新的一对。</target>
        </trans-unit>
        <trans-unit id="ef17975a5143add151e0e399318d7995c25ed2ae" translate="yes" xml:space="preserve">
          <source>Build a three-dimensional Bigarray initialized from the given array of arrays of arrays.</source>
          <target state="translated">从给定的数组数组中初始化建立一个三维Bigarray。</target>
        </trans-unit>
        <trans-unit id="e21da3902ed80a10d9124a19e5502821d530b38d" translate="yes" xml:space="preserve">
          <source>Build a two-dimensional Bigarray initialized from the given array of arrays.</source>
          <target state="translated">从给定的数组中构建一个初始化的二维Bigarray。</target>
        </trans-unit>
        <trans-unit id="0baba8d3207ccbde756c21e219772188993d76ba" translate="yes" xml:space="preserve">
          <source>Build a zero-dimensional Bigarray initialized from the given value.</source>
          <target state="translated">从给定的值初始化建立一个零维的Bigarray。</target>
        </trans-unit>
        <trans-unit id="b1263e4d5769f672b1f15f28232e6f937c00bc59" translate="yes" xml:space="preserve">
          <source>Build an object file (.cmx and .o/.obj files) and its associated compiled interface (.cmi) that combines the .cmx object files given on the command line, making them appear as sub-modules of the output .cmx file. The name of the output .cmx file must be given with the -o option. For instance,</source>
          <target state="translated">建立一个对象文件(.cmx和.o/.obj文件)及其相关的编译接口(.cmi),结合命令行给出的.cmx对象文件,使它们成为输出.cmx文件的子模块。输出.cmx文件的名称必须用-o选项给出。例如</target>
        </trans-unit>
        <trans-unit id="f2635951b3208897985aea8ec1147e0e9b763177" translate="yes" xml:space="preserve">
          <source>Builtins to reduce code size</source>
          <target state="translated">内置减少代码大小的功能</target>
        </trans-unit>
        <trans-unit id="c6160c6225b900be02bb14ce176681dae0c8f8da" translate="yes" xml:space="preserve">
          <source>Bus error</source>
          <target state="translated">总线错误</target>
        </trans-unit>
        <trans-unit id="fe6c2475ca710215707c319b5b130842b36b44da" translate="yes" xml:space="preserve">
          <source>But beware that functions like ListLabels.fold_left whose result type is a type variable will never be considered as totally applied.</source>
          <target state="translated">但要注意,像ListLabels.fold_left这样的函数,其结果类型是类型变量的,永远不会被认为是完全应用。</target>
        </trans-unit>
        <trans-unit id="4d51ba5b49681459c1a354add2ac5d24ca30fd49" translate="yes" xml:space="preserve">
          <source>By applying the Set functor to a structure implementing an ordered type, we obtain set operations for this type:</source>
          <target state="translated">通过将Set漏子应用到一个实现有序类型的结构中,我们得到了这个类型的集合操作。</target>
        </trans-unit>
        <trans-unit id="0113e077a12f76985e5f478d2a05438d5de8f770" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;parse&lt;/code&gt; recognizes two unit options, &lt;code&gt;-help&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt;, which will print to standard output &lt;code&gt;usage_msg&lt;/code&gt; and the list of options, and exit the program. You can override this behaviour by specifying your own &lt;code&gt;-help&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt; options in &lt;code&gt;speclist&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;parse&lt;/code&gt; 识别两个单位选项 &lt;code&gt;-help&lt;/code&gt; 和 &lt;code&gt;--help&lt;/code&gt; ，这将打印到标准输出 &lt;code&gt;usage_msg&lt;/code&gt; 和选项列表，并退出程序。您可以通过在 &lt;code&gt;speclist&lt;/code&gt; 中指定自己的 &lt;code&gt;-help&lt;/code&gt; 和 &lt;code&gt;--help&lt;/code&gt; 选项来覆盖此行为。</target>
        </trans-unit>
        <trans-unit id="67b1de1205669f7876e1c1fd966de8ff32344e89" translate="yes" xml:space="preserve">
          <source>By default, when ocamllex reaches the end of its lexing buffer, it will silently call the refill_buff function of lexbuf structure and continue lexing. It is sometimes useful to be able to take control of refilling action; typically, if you use a library for asynchronous computation, you may want to wrap the refilling action in a delaying function to avoid blocking synchronous operations.</source>
          <target state="translated">默认情况下,当ocamllex到达其词法缓冲区的终点时,它会默默地调用lexbuf结构的refill_buff函数并继续词法。有时候,能够控制重新填充动作是很有用的;通常情况下,如果你使用一个库进行异步计算,你可能会希望将重新填充动作包裹在一个延迟函数中,以避免阻塞同步操作。</target>
        </trans-unit>
        <trans-unit id="1bd008e3d3a06d94fef9fb0520a149f7342a3b92" translate="yes" xml:space="preserve">
          <source>By default:</source>
          <target state="translated">默认情况下。</target>
        </trans-unit>
        <trans-unit id="571d97b05671e800889e1f8be66af8e1839c41a3" translate="yes" xml:space="preserve">
          <source>By inspecting instrumentation output, the fuzzer finds the crashing input quickly.</source>
          <target state="translated">通过检查仪表输出,模糊器可以快速找到崩溃的输入。</target>
        </trans-unit>
        <trans-unit id="fdb1ab62b1d1a61cd2bf6abb826d55b2452baa20" translate="yes" xml:space="preserve">
          <source>Bypass the standard routing algorithms</source>
          <target state="translated">绕过标准路由算法</target>
        </trans-unit>
        <trans-unit id="81a27c85cc78cf7082f8f4aa81367cc7aa73bbd6" translate="yes" xml:space="preserve">
          <source>Byte sequence operations.</source>
          <target state="translated">字节序列操作。</target>
        </trans-unit>
        <trans-unit id="1c3dcbe0c430e581c3ba7ac724f0f6e253c1162e" translate="yes" xml:space="preserve">
          <source>Byte sequences can be modified in place, for instance via the &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;blit&lt;/code&gt; functions described below. See also strings (module &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;), which are almost the same data structure, but cannot be modified in place.</source>
          <target state="translated">字节序列可以通过以下所述的 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;blit&lt;/code&gt; 函数进行修改。另请参见字符串（模块&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;），它们几乎是相同的数据结构，但不能就地修改。</target>
        </trans-unit>
        <trans-unit id="adb4a16c1c179874a37042f14ee4006ef6638ed6" translate="yes" xml:space="preserve">
          <source>Byte(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; byte of the string or byte sequence v, with type char. Bytes are numbered from 0 to string_length(v)&amp;minus;1.</source>
          <target state="translated">Byte（v，n）返回字符串或字节序列v的&lt;sup&gt;第&lt;/sup&gt;n&lt;sup&gt;个&lt;/sup&gt;字节，类型为char。字节从0到string_length（v）-1编号。</target>
        </trans-unit>
        <trans-unit id="e56c24ce60fe3442e00e45a21c6a40ce9981947b" translate="yes" xml:space="preserve">
          <source>Byte_u(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; byte of the string or byte sequence v, with type unsigned char. Bytes are numbered from 0 to string_length(v)&amp;minus;1.</source>
          <target state="translated">Byte_u（v，n）返回字符串或字节序列v的&lt;sup&gt;第&lt;/sup&gt;n&lt;sup&gt;个&lt;/sup&gt;字节，类型为unsigned char。字节从0到string_length（v）-1编号。</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="ee4b734d209787513981ac3c4587edcc9fd97576" translate="yes" xml:space="preserve">
          <source>Bytes are represented by the OCaml type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">字节由OCaml类型 &lt;code&gt;char&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="b7f1a4abc7d926b88b0ebb920ad333dc56ea8d84" translate="yes" xml:space="preserve">
          <source>BytesLabels</source>
          <target state="translated">BytesLabels</target>
        </trans-unit>
        <trans-unit id="f88d6f50d25613e6ba9716a6ec32d0fac19418c8" translate="yes" xml:space="preserve">
          <source>Bytes_val(v) returns a pointer to the first byte of the byte sequence v, with type unsigned char *.</source>
          <target state="translated">Bytes_val(v)返回指向字节序列 v 的第一个字节的指针,类型为 unsigned char *。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="5cdbd402c1d7266786e985245bde0656f198525c" translate="yes" xml:space="preserve">
          <source>C expression</source>
          <target state="translated">C表达</target>
        </trans-unit>
        <trans-unit id="c8e4b97f10fef4bff0c780402b8dd25cf8309940" translate="yes" xml:space="preserve">
          <source>C functions can apply OCaml function values (closures) to OCaml values. The following functions are provided to perform the applications:</source>
          <target state="translated">C函数可以将OCaml函数值(闭包)应用于OCaml值。提供以下函数来执行应用。</target>
        </trans-unit>
        <trans-unit id="bc5854e4455891ebb06ded2070bbca910df9ff80" translate="yes" xml:space="preserve">
          <source>C object files (.o, .a, respectively, .obj, .lib) comprising the C part of the library;</source>
          <target state="translated">C对象文件(.o,.a,分别为.obj,.lib)组成库的C部分。</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="translated">C型</target>
        </trans-unit>
        <trans-unit id="5c2691a3da47675d7786da9056ed654e4329e370" translate="yes" xml:space="preserve">
          <source>C-c &amp;gt;</source>
          <target state="translated">抄送&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d5895e3b6464a2f42c548ae3a42edfd0331e5913" translate="yes" xml:space="preserve">
          <source>C-c &amp;lt;</source>
          <target state="translated">抄送&amp;lt;</target>
        </trans-unit>
        <trans-unit id="63d94b505b28b164240bf9389a0b04f654a4efe7" translate="yes" xml:space="preserve">
          <source>C-c C-d</source>
          <target state="translated">C-c C-d</target>
        </trans-unit>
        <trans-unit id="7b336d22bd8ba7c961026c225d6dae53a99180fe" translate="yes" xml:space="preserve">
          <source>C-c C-f</source>
          <target state="translated">C-c C-f</target>
        </trans-unit>
        <trans-unit id="e157811222162c64e14516608ab7ec113770f6cc" translate="yes" xml:space="preserve">
          <source>C-c C-k</source>
          <target state="translated">C-c C-k</target>
        </trans-unit>
        <trans-unit id="35aab979b96b2084fb79f26513be2807d179fa9d" translate="yes" xml:space="preserve">
          <source>C-c C-l</source>
          <target state="translated">C-c C-l</target>
        </trans-unit>
        <trans-unit id="703476705fbc5c81f1fcd2e97899e90376b8bb77" translate="yes" xml:space="preserve">
          <source>C-c C-n</source>
          <target state="translated">C-c C-n</target>
        </trans-unit>
        <trans-unit id="b6b8a659d5ecf6f6de2e42c686ddf4655002e381" translate="yes" xml:space="preserve">
          <source>C-c C-p</source>
          <target state="translated">C-c C-p</target>
        </trans-unit>
        <trans-unit id="35a5eefc071272ad5677c99c4db64e5fe4dc5d2d" translate="yes" xml:space="preserve">
          <source>C-c C-r</source>
          <target state="translated">C-c C-r</target>
        </trans-unit>
        <trans-unit id="b1d45f9433ffa51171e234792f3e833fd92a28ea" translate="yes" xml:space="preserve">
          <source>C-c C-s</source>
          <target state="translated">C-c C-s</target>
        </trans-unit>
        <trans-unit id="5a7afd726a50bc021ba933c58863ceeb5085e993" translate="yes" xml:space="preserve">
          <source>C-c C-t</source>
          <target state="translated">C-c C-t</target>
        </trans-unit>
        <trans-unit id="51f8ced1b6f72805535bc35bcfb934e6a1af5d91" translate="yes" xml:space="preserve">
          <source>C-c C-v</source>
          <target state="translated">C-c C-v</target>
        </trans-unit>
        <trans-unit id="a7600b59263607e2e35bc0920247fd20391c74a2" translate="yes" xml:space="preserve">
          <source>C-x C-a C-b</source>
          <target state="translated">C-x C-a C-b</target>
        </trans-unit>
        <trans-unit id="bb5cfbe7597b16e6935dc781b66c74990211b37b" translate="yes" xml:space="preserve">
          <source>C-x C-a C-d</source>
          <target state="translated">C-x C-a C-d</target>
        </trans-unit>
        <trans-unit id="cb356c30fbc883e430534abb90e0f8ff779ffa95" translate="yes" xml:space="preserve">
          <source>C-x C-a C-p</source>
          <target state="translated">C-x C-a C-p</target>
        </trans-unit>
        <trans-unit id="0428d8d3b172e413bd41a84ee63c3aa76341d6f4" translate="yes" xml:space="preserve">
          <source>CAMLRUNPARAM</source>
          <target state="translated">CAMLRUNPARAM</target>
        </trans-unit>
        <trans-unit id="06ef60af17229bb84ed6cf51b34ad6a256455e79" translate="yes" xml:space="preserve">
          <source>CAML_BA_CAML_INT</source>
          <target state="translated">CAML_BA_CAML_INT</target>
        </trans-unit>
        <trans-unit id="29bf970ee1f3dcd0c4d491bf35cc1f3f5d511fb6" translate="yes" xml:space="preserve">
          <source>CAML_BA_FLOAT32</source>
          <target state="translated">CAML_BA_FLOAT32</target>
        </trans-unit>
        <trans-unit id="b0b45028fc165a76fdf7ef3c4b9544abf779f48e" translate="yes" xml:space="preserve">
          <source>CAML_BA_FLOAT64</source>
          <target state="translated">CAML_BA_FLOAT64</target>
        </trans-unit>
        <trans-unit id="c0a392f0c20d6938ed691222ff33a9ed03be26ee" translate="yes" xml:space="preserve">
          <source>CAML_BA_INT32</source>
          <target state="translated">CAML_BA_INT32</target>
        </trans-unit>
        <trans-unit id="28d3388f7484b35006ab4e33d099e8b1394d2ada" translate="yes" xml:space="preserve">
          <source>CAML_BA_INT64</source>
          <target state="translated">CAML_BA_INT64</target>
        </trans-unit>
        <trans-unit id="4ae0dcc3f1cb59220d53e50caf55af1eec638efe" translate="yes" xml:space="preserve">
          <source>CAML_BA_NATIVE_INT</source>
          <target state="translated">CAML_BA_NATIVE_INT</target>
        </trans-unit>
        <trans-unit id="12d8a9c4f45f9611251c206d7770c086b489bd77" translate="yes" xml:space="preserve">
          <source>CAML_BA_SINT16</source>
          <target state="translated">CAML_BA_SINT16</target>
        </trans-unit>
        <trans-unit id="4f8b28cf737d73c2546166e229b3ed6d00a4ec46" translate="yes" xml:space="preserve">
          <source>CAML_BA_SINT8</source>
          <target state="translated">CAML_BA_SINT8</target>
        </trans-unit>
        <trans-unit id="42c72be3c2d002cde18ad0cc888645508241b618" translate="yes" xml:space="preserve">
          <source>CAML_BA_UINT16</source>
          <target state="translated">CAML_BA_UINT16</target>
        </trans-unit>
        <trans-unit id="0b4fdfc80a15bdaea2467c74579a11c08063d303" translate="yes" xml:space="preserve">
          <source>CAML_BA_UINT8</source>
          <target state="translated">CAML_BA_UINT8</target>
        </trans-unit>
        <trans-unit id="862e38c8fdffac6697987f398fd840cb4757c5c6" translate="yes" xml:space="preserve">
          <source>CAML_LD_LIBRARY_PATH</source>
          <target state="translated">CAML_LD_LIBRARY_PATH</target>
        </trans-unit>
        <trans-unit id="1efcd7218656916b1a34ec7ace30f76879ccc769" translate="yes" xml:space="preserve">
          <source>Call site</source>
          <target state="translated">呼叫网站</target>
        </trans-unit>
        <trans-unit id="439ff774888e42456ac505657951f952d4018c9c" translate="yes" xml:space="preserve">
          <source>Call the function with a bool argument</source>
          <target state="translated">调用函数的bool参数</target>
        </trans-unit>
        <trans-unit id="b54d32e84799e629832cc3cf6d3d70a7415a5e3d" translate="yes" xml:space="preserve">
          <source>Call the function with a float argument</source>
          <target state="translated">用float参数调用函数</target>
        </trans-unit>
        <trans-unit id="1194b8c4e54a903611beb2fc6666d747a1e0e365" translate="yes" xml:space="preserve">
          <source>Call the function with a string argument</source>
          <target state="translated">用字符串参数调用函数</target>
        </trans-unit>
        <trans-unit id="1362db1cb4c46430a08897ce0bd10b0e6ea8a20d" translate="yes" xml:space="preserve">
          <source>Call the function with an int argument</source>
          <target state="translated">用int参数调用函数</target>
        </trans-unit>
        <trans-unit id="d5b1b5aaabaa5c8dc3fa786515c78609ee362d34" translate="yes" xml:space="preserve">
          <source>Call the function with unit argument</source>
          <target state="translated">调用带有单位参数的函数</target>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="5e3acd60f1a3a903622de6021e3383b98e3f2383" translate="yes" xml:space="preserve">
          <source>Callbacks from C to OCaml are possible only if the calling thread is known to the OCaml run-time system. Threads created from OCaml (through the Thread.create function of the system threads library) are automatically known to the run-time system. If the application creates additional threads from C and wishes to callback into OCaml code from these threads, it must first register them with the run-time system. The following functions are declared in the include file &amp;lt;caml/threads.h&amp;gt;.</source>
          <target state="translated">仅当OCaml运行时系统知道调用线程时，才可以从C回调到OCaml。从OCaml创建的线程（通过系统线程库的Thread.create函数）对于运行时系统是自动知道的。如果应用程序从C创建其他线程，并希望从这些线程回调到OCaml代码，则它必须首先在运行时系统中注册它们。在包含文件&amp;lt;caml / threads.h&amp;gt;中声明了以下功能。</target>
        </trans-unit>
        <trans-unit id="0e6bc26cd9de8a0ee5e063309082a78314bbdfd7" translate="yes" xml:space="preserve">
          <source>Callbacks from C to OCaml must be performed while holding the master lock to the OCaml run-time system. This is naturally the case if the callback is performed by a C primitive that did not release the run-time system. If the C primitive released the run-time system previously, or the callback is performed from other C code that was not invoked from OCaml (e.g. an event loop in a GUI application), the run-time system must be acquired before the callback and released after:</source>
          <target state="translated">从C到OCaml的回调必须在持有OCaml运行时系统的主锁时执行。如果回调是由没有释放运行时系统的C基元执行的,自然会出现这种情况。如果C基元之前释放了运行时系统,或者回调是由其他没有从OCaml调用的C代码执行的(例如GUI应用程序中的事件循环),则必须在回调之前获取运行时系统,并在回调之后释放。</target>
        </trans-unit>
        <trans-unit id="0f420b0e05a7d24397a2c4cbac41b11132d82dc0" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;Thread.exit&lt;/code&gt; in a callback is currently unsafe and can result in undefined behavior.</source>
          <target state="translated">&lt;code&gt;Thread.exit&lt;/code&gt; 在回调中调用Thread.exit是不安全的，并且可能导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="ee8b6fad857d73ca89a28b745d68e7d25285cbc2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;stop&lt;/code&gt; when a callback is running can lead to callbacks not being called even though some events happened.</source>
          <target state="translated">在运行回调时调用 &lt;code&gt;stop&lt;/code&gt; 可能导致即使发生了某些事件，也无法调用回调。</target>
        </trans-unit>
        <trans-unit id="88d0bd91811ae57feae3dc49557f93b46fb40091" translate="yes" xml:space="preserve">
          <source>Calling ocamlcp or ocamloptp without the -P option defaults to -P fm, meaning that only function calls and pattern matching are profiled.</source>
          <target state="translated">调用ocamlcp或ocamloptp而不使用-P选项时,默认为-P fm,这意味着只对函数调用和模式匹配进行分析。</target>
        </trans-unit>
        <trans-unit id="c76f4f235bcaa15b4e9e55e904d12a0353c6937f" translate="yes" xml:space="preserve">
          <source>Calling of finalization functions</source>
          <target state="translated">调用定型功能</target>
        </trans-unit>
        <trans-unit id="0a16634ad2d1d835f05f26e6db369cdfbe2de29c" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v) must always be dereferenced immediately and not stored anywhere, including local variables. It resolves to a derived pointer: it is not a valid OCaml value but points to a memory region managed by the GC. For this reason this value must not be stored in any memory location that could be live cross a GC.</source>
          <target state="translated">Caml_ba_array_val(v)必须总是立即被派生引用,而不是存储在任何地方,包括本地变量。它解析为一个派生指针:它不是一个有效的OCaml值,而是指向一个由GC管理的内存区域。出于这个原因,这个值不能存储在任何可能跨GC的内存位置。</target>
        </trans-unit>
        <trans-unit id="320ce4f3dd86e7b41979fa738908cf8ebc9f4093" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;dim[i]</source>
          <target state="translated">Caml_ba_array_val(v)-&amp;gt;dim[i]</target>
        </trans-unit>
        <trans-unit id="4965db9dfe36a2388ff16d79621b65a90fdc3268" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;flags &amp;amp; BIGARRAY_KIND_MASK</source>
          <target state="translated">Caml_ba_array_val（v）-&amp;gt;标志和BIGARRAY_KIND_MASK</target>
        </trans-unit>
        <trans-unit id="a8153f9a1f29a01a8d1e13a9a8facbe074e41d60" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;num_dims</source>
          <target state="translated">Caml_ba_array_val(v)-&amp;gt;num_dims</target>
        </trans-unit>
        <trans-unit id="31755d8a197ffc105d3a49a6cafb4948f97d69f7" translate="yes" xml:space="preserve">
          <source>CamlinternalAtomic</source>
          <target state="translated">CamlinternalAtomic</target>
        </trans-unit>
        <trans-unit id="b0826ae23f5c2aa6ec97d420d36156941be754c2" translate="yes" xml:space="preserve">
          <source>CamlinternalFormat</source>
          <target state="translated">CamlinternalFormat</target>
        </trans-unit>
        <trans-unit id="bb3e916c18c2e6c422542bf46f49c0d62f6e3c8f" translate="yes" xml:space="preserve">
          <source>CamlinternalFormatBasics</source>
          <target state="translated">CamlinternalFormatBasics</target>
        </trans-unit>
        <trans-unit id="481a5bc3eb5c42fe3b8d720d5e80798ff2509a6f" translate="yes" xml:space="preserve">
          <source>CamlinternalLazy</source>
          <target state="translated">CamlinternalLazy</target>
        </trans-unit>
        <trans-unit id="c3c09679073e3d5fb5469d0ee68e0dda2efb23c6" translate="yes" xml:space="preserve">
          <source>CamlinternalMod</source>
          <target state="translated">CamlinternalMod</target>
        </trans-unit>
        <trans-unit id="de3a6cdf4fe88074a43fdcad59d0f8af4cd7f6fd" translate="yes" xml:space="preserve">
          <source>CamlinternalOO</source>
          <target state="translated">CamlinternalOO</target>
        </trans-unit>
        <trans-unit id="d4281385821580139685e13cccf01eef5faad5fd" translate="yes" xml:space="preserve">
          <source>Can't assign requested address</source>
          <target state="translated">无法分配要求的地址</target>
        </trans-unit>
        <trans-unit id="7b11fa6f27d953791f239e466488fe3cc3dab71f" translate="yes" xml:space="preserve">
          <source>Can't send after socket shutdown</source>
          <target state="translated">插件关闭后无法发送</target>
        </trans-unit>
        <trans-unit id="fa179cda87a1dfd4a3c00c1a3a16ee3fa6ec361b" translate="yes" xml:space="preserve">
          <source>Cannot exec ocamlrun</source>
          <target state="translated">无法执行ocamlrun</target>
        </trans-unit>
        <trans-unit id="c76131d25b0f2f61dc3ec32dd51584863650417b" translate="yes" xml:space="preserve">
          <source>Cannot find file filename</source>
          <target state="translated">找不到文件名</target>
        </trans-unit>
        <trans-unit id="6e970cebe7ef506f91128a59d1bb09ee8b8b3c86" translate="yes" xml:space="preserve">
          <source>Cannot find the bytecode file</source>
          <target state="translated">找不到字节码文件</target>
        </trans-unit>
        <trans-unit id="20838d73bbc97dc3bb06bd228fc74b46a7848212" translate="yes" xml:space="preserve">
          <source>Canonical host name</source>
          <target state="translated">规范的主机名</target>
        </trans-unit>
        <trans-unit id="2176321ef1668ac2925aa2334216301b069265ea" translate="yes" xml:space="preserve">
          <source>Case of first letter</source>
          <target state="translated">第一个字母的情况</target>
        </trans-unit>
        <trans-unit id="152c573fc4d3829f2755ceb071de4e226c7a2b55" translate="yes" xml:space="preserve">
          <source>Cases with such a toplevel pattern are called &amp;ldquo;exception cases&amp;rdquo;, as opposed to regular &amp;ldquo;value cases&amp;rdquo;. Exception cases are applied when the evaluation of the matched expression raises an exception. The exception value is then matched against all the exception cases and re-raised if none of them accept the exception (as with a try...with block). Since the bodies of all exception and value cases are outside the scope of the exception handler, they are all considered to be in tail-position: if the match...with block itself is in tail position in the current function, any function call in tail position in one of the case bodies results in an actual tail call.</source>
          <target state="translated">与常规的&amp;ldquo;价值案例&amp;rdquo;相对，具有这种顶层模式的案例称为&amp;ldquo;例外案例&amp;rdquo;。当匹配表达式的求值引发异常时，将应用异常情况。然后，将异常值与所有异常情况进行匹配，如果它们均不接受该异常，则重新引发该异常值（例如使用try ... with块）。由于所有异常和值情况的主体都在异常处理程序的范围之外，因此它们都被视为处于尾部位置：如果match ... with块本身位于当前函数的尾部位置，则任何函数调用在其中一个表壳的尾部位置，将导致实际的尾声。</target>
        </trans-unit>
        <trans-unit id="a7bfa68b59ae09ff7937d27d80909654e0911df3" translate="yes" xml:space="preserve">
          <source>Catenate two lists.</source>
          <target state="translated">编制两个名单。</target>
        </trans-unit>
        <trans-unit id="bf6d1257bb5471d1a26f3650edf26a9b7ce4748e" translate="yes" xml:space="preserve">
          <source>Catenate two lists. Same function as the infix operator &lt;code&gt;@&lt;/code&gt;. Not tail-recursive (length of the first argument). The &lt;code&gt;@&lt;/code&gt; operator is not tail-recursive either.</source>
          <target state="translated">列出两个列表。与infix运算符 &lt;code&gt;@&lt;/code&gt; 的功能相同。不是尾递归的（第一个参数的长度）。该 &lt;code&gt;@&lt;/code&gt; 算不算尾递归无论是。</target>
        </trans-unit>
        <trans-unit id="3927eac7c0bbd9cb2a05b8b9b1bc048f32eed24a" translate="yes" xml:space="preserve">
          <source>Cause ocamldep to call the given command as a preprocessor for each source file.</source>
          <target state="translated">使ocamldep调用给定的命令作为每个源文件的预处理程序。</target>
        </trans-unit>
        <trans-unit id="66d65060239114c8da1c3ee5f06497c9c0388478" translate="yes" xml:space="preserve">
          <source>Cause the compiler to call the given command as a preprocessor for each source file. The output of command is redirected to an intermediate file, which is compiled. If there are no compilation errors, the intermediate file is deleted afterwards.</source>
          <target state="translated">使编译器调用给定的命令作为每个源文件的预处理程序。命令的输出被重定向到一个中间文件,并进行编译。如果没有编译错误,中间文件会在编译后被删除。</target>
        </trans-unit>
        <trans-unit id="a9ad0bc61108fd0f03730d7b8c62d48c4504661e" translate="yes" xml:space="preserve">
          <source>Cause the compiler to print all defined names (with their inferred types or their definitions) when compiling an implementation (.ml file). No compiled files (.cmo and .cmi files) are produced. This can be useful to check the types inferred by the compiler. Also, since the output follows the syntax of interfaces, it can help in writing an explicit interface (.mli file) for a file: just redirect the standard output of the compiler to a .mli file, and edit that file to remove all declarations of unexported names.</source>
          <target state="translated">在编译一个实现(.ml文件)时,使编译器打印所有定义的名称(及其推断的类型或其定义)。不产生编译文件(.cmo和.cmi文件)。这对于检查编译器推断的类型很有用。此外,由于输出遵循接口的语法,它可以帮助为文件编写一个显式接口(.mli文件):只需将编译器的标准输出重定向到一个.mli文件,并编辑该文件以删除所有未导出名称的声明。</target>
        </trans-unit>
        <trans-unit id="1e53b0d9b7bac60ff1de64afbb679accf404b1f2" translate="yes" xml:space="preserve">
          <source>Cause the linker to produce a C object file instead of a bytecode executable file. This is useful to wrap OCaml code as a C library, callable from any C program. See chapter &amp;zwj;&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;, section &amp;zwj;&lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;18.7.5&lt;/a&gt;. The name of the output object file must be set with the -o option. This option can also be used to produce a C source file (.c extension) or a compiled shared/dynamic library (.so extension, .dll under Windows).</source>
          <target state="translated">使链接器生成一个C对象文件，而不是字节码可执行文件。这对于将OCaml代码包装为可从任何C程序调用的C库很有用。见章&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;节&lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;18.7.5&lt;/a&gt;。必须使用-o选项设置输出目标文件的名称。此选项还可以用于生成C源文件（.c扩展名）或编译的共享/动态库（.so扩展名，在Windows下为.dll）。</target>
        </trans-unit>
        <trans-unit id="c6e7e3cc29834386322cdfd94e38c57364643191" translate="yes" xml:space="preserve">
          <source>Cause the linker to produce a C object file instead of a bytecode executable file. This is useful to wrap OCaml code as a C library, callable from any C program. See chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, section &lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt;. The name of the output object file must be set with the -o option. This option can also be used to produce a C source file (.c extension) or a compiled shared/dynamic library (.so extension, .dll under Windows).</source>
          <target state="translated">使链接器生成C对象文件，而不是字节码可执行文件。这对于将OCaml代码包装为可从任何C程序调用的C库很有用。参见第&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;章的&lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt;节。必须使用-o选项设置输出目标文件的名称。此选项还可以用于生成C源文件（.c扩展名）或已编译的共享/动态库（.so扩展名，在Windows下为.dll）。</target>
        </trans-unit>
        <trans-unit id="cb76c7d543cbdd9c24e8b245f7cea16405349ed4" translate="yes" xml:space="preserve">
          <source>Cause the linker to produce a C object file instead of an executable file. This is useful to wrap OCaml code as a C library, callable from any C program. See chapter &amp;zwj;&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;, section &amp;zwj;&lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;18.7.5&lt;/a&gt;. The name of the output object file must be set with the -o option. This option can also be used to produce a compiled shared/dynamic library (.so extension, .dll under Windows).</source>
          <target state="translated">使链接器生成C对象文件而不是可执行文件。这对于将OCaml代码包装为可从任何C程序调用的C库很有用。见章&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;节&lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;18.7.5&lt;/a&gt;。必须使用-o选项设置输出目标文件的名称。此选项还可以用于生成已编译的共享/动态库（.so扩展名，在Windows下为.dll）。</target>
        </trans-unit>
        <trans-unit id="2f2d52792e36f929afa45992d5b9371329947d44" translate="yes" xml:space="preserve">
          <source>Cause the linker to produce a C object file instead of an executable file. This is useful to wrap OCaml code as a C library, callable from any C program. See chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, section &lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt;. The name of the output object file must be set with the -o option. This option can also be used to produce a compiled shared/dynamic library (.so extension, .dll under Windows).</source>
          <target state="translated">使链接器生成C对象文件而不是可执行文件。这对于将OCaml代码包装为可从任何C程序调用的C库很有用。参见第&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;章的&lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt;节。必须使用-o选项设置输出目标文件的名称。此选项还可以用于生成已编译的共享/动态库（.so扩展名，在Windows下为.dll）。</target>
        </trans-unit>
        <trans-unit id="b850e3fb0d5b46820871c2935dfe3766bdbb938d" translate="yes" xml:space="preserve">
          <source>Change of GC parameters.</source>
          <target state="translated">改变气相色谱参数。</target>
        </trans-unit>
        <trans-unit id="85ddb2f3053e5e3a61aa51801cc581d3f377f0ca" translate="yes" xml:space="preserve">
          <source>Change the current working directory of the process.</source>
          <target state="translated">更改当前进程的工作目录。</target>
        </trans-unit>
        <trans-unit id="0a59a356a5fb89b1c7225a986140a24f071468d3" translate="yes" xml:space="preserve">
          <source>Change the current working directory.</source>
          <target state="translated">更改当前工作目录。</target>
        </trans-unit>
        <trans-unit id="1fc8ee486e678a2b93da90c36026c5c882c13c46" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of an opened file.</source>
          <target state="translated">更改已打开文件的所有者UID和所有者GID。</target>
        </trans-unit>
        <trans-unit id="7ff1b3a39f21500ee841c3b355ca9394dab29e7f" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of an opened file. On Windows: not implemented (make no sense on a DOS file system).</source>
          <target state="translated">更改打开文件的所有者uid和所有者gid。在Windows上:没有实现(在DOS文件系统上没有意义)。</target>
        </trans-unit>
        <trans-unit id="0c6826ef95971c6bcc713d9272d2f3957ce4e077" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of the named file.</source>
          <target state="translated">更改命名文件的所有者uid和所有者gid。</target>
        </trans-unit>
        <trans-unit id="eff00fe5b2a8e18dd9ab37b5013d51ebb074f663" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of the named file. On Windows: not implemented (make no sense on a DOS file system).</source>
          <target state="translated">更改命名文件的所有者 uid 和所有者 gid。在Windows上:没有实现(在DOS文件系统上没有意义)。</target>
        </trans-unit>
        <trans-unit id="bed0198ddea8ebff0f55e60936d9d3744ed76277" translate="yes" xml:space="preserve">
          <source>Change the permissions of an opened file.</source>
          <target state="translated">更改已打开文件的权限。</target>
        </trans-unit>
        <trans-unit id="be2f04cee52320988b31c4157241e0ae0e8b9395" translate="yes" xml:space="preserve">
          <source>Change the permissions of an opened file. On Windows: not implemented.</source>
          <target state="translated">更改已打开文件的权限。在Windows上:未执行。</target>
        </trans-unit>
        <trans-unit id="3dfd116dac46b84058c527a10dea8d7eb9d90f28" translate="yes" xml:space="preserve">
          <source>Change the permissions of the named file.</source>
          <target state="translated">更改命名文件的权限。</target>
        </trans-unit>
        <trans-unit id="059df7ed36823c0a5f15c733d667630994b09dfc" translate="yes" xml:space="preserve">
          <source>Change the process priority.</source>
          <target state="translated">改变流程优先级。</target>
        </trans-unit>
        <trans-unit id="4af895b8fed10993d46dc76e555515a59117c378" translate="yes" xml:space="preserve">
          <source>Change the process priority. The integer argument is added to the ``nice'' value. (Higher values of the ``nice'' value mean lower priorities.) Return the new nice value.</source>
          <target state="translated">改变进程优先级。整数参数加到 &quot;nice &quot;值上。(&quot;nice &quot;值越大,表示优先级越低。)返回新的nice值。</target>
        </trans-unit>
        <trans-unit id="525fb07cd9a161e6eede24edf36a6f523c0304e8" translate="yes" xml:space="preserve">
          <source>Change the process root directory.</source>
          <target state="translated">更改进程根目录。</target>
        </trans-unit>
        <trans-unit id="0b7679db58768be2f4e8b5dcad79023cb2410bef" translate="yes" xml:space="preserve">
          <source>Change the process root directory. On Windows: not implemented.</source>
          <target state="translated">更改进程根目录。在Windows上:不执行。</target>
        </trans-unit>
        <trans-unit id="c22f0bfd902da519c120d02a47bbc28f988fe88b" translate="yes" xml:space="preserve">
          <source>Change the process working directory.</source>
          <target state="translated">更改进程工作目录。</target>
        </trans-unit>
        <trans-unit id="f6247262a4ca64128524a7b46fe29e0adce2d3a4" translate="yes" xml:space="preserve">
          <source>Change the temporary directory returned by &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt;&lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt;&lt;/a&gt; and used by &lt;a href=&quot;filename#VALtemp_file&quot;&gt;&lt;code&gt;Filename.temp_file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;filename#VALopen_temp_file&quot;&gt;&lt;code&gt;Filename.open_temp_file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">更改返回的临时目录&lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt; &lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt; &lt;/a&gt;和使用&lt;a href=&quot;filename#VALtemp_file&quot;&gt; &lt;code&gt;Filename.temp_file&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;filename#VALopen_temp_file&quot;&gt; &lt;code&gt;Filename.open_temp_file&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d51cf8d48089b4f732ff5afde7638ab7ab4e09bc" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;1 The core language</source>
          <target state="translated">第1章核心语言</target>
        </trans-unit>
        <trans-unit id="6f0a5ed17a6b3bb44e410652b9d062eb7b8aba5e" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;10 The toplevel system or REPL (ocaml)</source>
          <target state="translated">第10章顶层系统或REPL（ocaml）</target>
        </trans-unit>
        <trans-unit id="8f70551bd0f931d63828815363f04ec50189aeeb" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;11 The runtime system (ocamlrun)</source>
          <target state="translated">第十一章运行时系统（ocamlrun）</target>
        </trans-unit>
        <trans-unit id="430d802ffa625631bf6da4528e7dbc4884a5222c" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;12 Native-code compilation (ocamlopt)</source>
          <target state="translated">第12章本机代码编译（ocamlopt）</target>
        </trans-unit>
        <trans-unit id="c5da18388d37ca3f536d602d851ff13ab20fbb8a" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;13 Lexer and parser generators (ocamllex, ocamlyacc)</source>
          <target state="translated">第13章Lexer和解析器生成器（ocamllex，ocamlyacc）</target>
        </trans-unit>
        <trans-unit id="60bdeefd23bb563504096dd3eb4364ef179897e0" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;14 Dependency generator (ocamldep)</source>
          <target state="translated">第14章依赖关系生成器（ocamldep）</target>
        </trans-unit>
        <trans-unit id="373611dccab75a9b7bf299b97be79e5f1694a012" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;15 The documentation generator (ocamldoc)</source>
          <target state="translated">第15章文档生成器（ocamldoc）</target>
        </trans-unit>
        <trans-unit id="97f0fcdf7b8d42f331651bfce2071ed7661fb33f" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;16 The debugger (ocamldebug)</source>
          <target state="translated">第16章调试器（ocamldebug）</target>
        </trans-unit>
        <trans-unit id="b9ba29da7edc2a124809e3e3f03c6e1fa25771f9" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;17 Profiling (ocamlprof)</source>
          <target state="translated">第17章分析（ocamlprof）</target>
        </trans-unit>
        <trans-unit id="ce4a0b6e07da018b0de05f8d54806a2b5a90f4da" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;18 Interfacing C with OCaml</source>
          <target state="translated">第18章C与OCaml的接口</target>
        </trans-unit>
        <trans-unit id="a1bfcf702965b24bcf17124239a6477f699f1559" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;19 Optimisation with Flambda</source>
          <target state="translated">第19章使用Flambda进行优化</target>
        </trans-unit>
        <trans-unit id="36b713585ca1e21ca084b2e0befe4cf545fe1721" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;2 The module system</source>
          <target state="translated">第2章模块系统</target>
        </trans-unit>
        <trans-unit id="cd4ff1ed01eadcea938ea91e2b735159ccc6f248" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;20 Fuzzing with afl-fuzz</source>
          <target state="translated">第20章使用afl-fuzz进行模糊测试</target>
        </trans-unit>
        <trans-unit id="cb4fb0fb8c0abf7ca6f308fe38671218f7833201" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;21 Runtime tracing with the instrumented runtime</source>
          <target state="translated">第21章使用已检测的运行时进行运行时跟踪</target>
        </trans-unit>
        <trans-unit id="2c91c259844c123c9a870402d78725e7bfe0b438" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;22 The core library</source>
          <target state="translated">第22章核心库</target>
        </trans-unit>
        <trans-unit id="87a45214ddc33551e26a7568cd6e9e2e81cf8534" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;23 The standard library</source>
          <target state="translated">第23章标准库</target>
        </trans-unit>
        <trans-unit id="8cbd57957cad6dd1e0904091003bf07216943da2" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;24 The compiler front-end</source>
          <target state="translated">第24章编译器前端</target>
        </trans-unit>
        <trans-unit id="28dc7f33eb5575e3c67445c28275e876b561440c" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;25 The unix library: Unix system calls</source>
          <target state="translated">第25章Unix库：Unix系统调用</target>
        </trans-unit>
        <trans-unit id="f5d44972c0145821fd67e44b29be427d9366f72a" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;26 The str library: regular expressions and string processing</source>
          <target state="translated">第26章str库：正则表达式和字符串处理</target>
        </trans-unit>
        <trans-unit id="dd514e07a075466085d4019111b25b67044fd23d" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;27 The threads library</source>
          <target state="translated">第27章线程库</target>
        </trans-unit>
        <trans-unit id="6ad869a9d50a2bbfdfff9537575a8739eb3e9163" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;28 The dynlink library: dynamic loading and linking of object files</source>
          <target state="translated">第28章dynlink库：动态加载和链接目标文件</target>
        </trans-unit>
        <trans-unit id="c2cdaf8bd223dbde9a0fd2a138b79464299c4871" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;29 Recently removed or moved libraries (Graphics, Bigarray, Num, LablTk)</source>
          <target state="translated">第29章最近删除或移动的库（Graphics，Bigarray，Num，LablTk）</target>
        </trans-unit>
        <trans-unit id="46e2d3218abd191043cf6f3536bb1a5a564ff50a" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;3 Objects in OCaml</source>
          <target state="translated">第3章OCaml中的对象</target>
        </trans-unit>
        <trans-unit id="bf383da684c39ebe1745727c280ef95145b2b01b" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;4 Labels and variants</source>
          <target state="translated">第四章标签和变体</target>
        </trans-unit>
        <trans-unit id="4c1c9eb16ff9d6689735b366a0ac946df19d46a5" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;5 Polymorphism and its limitations</source>
          <target state="translated">第五章多态性及其局限性</target>
        </trans-unit>
        <trans-unit id="a25ebc6ed1066e5d4700e34c00a988b9daad1e79" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;6 Advanced examples with classes and modules</source>
          <target state="translated">第6章具有类和模块的高级示例</target>
        </trans-unit>
        <trans-unit id="91dd9a4287f4eb9b916e6431bab563d01effe22c" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;7 The OCaml language</source>
          <target state="translated">第七章OCaml语言</target>
        </trans-unit>
        <trans-unit id="9d70d57247b86db02fe2f5ce1515cb552b8b50c4" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;8 Language extensions</source>
          <target state="translated">第8章语言扩展</target>
        </trans-unit>
        <trans-unit id="d0fdd1f3e7a910dcffa9147720151ebb633548f6" translate="yes" xml:space="preserve">
          <source>Chapter &amp;zwj;9 Batch compilation (ocamlc)</source>
          <target state="translated">第9章批处理编译（ocamlc）</target>
        </trans-unit>
        <trans-unit id="9ed43f5a28f32e3c670541a45ef01f44121648f3" translate="yes" xml:space="preserve">
          <source>Chapter 1 The core language</source>
          <target state="translated">第1章 核心语言</target>
        </trans-unit>
        <trans-unit id="f0b85dee7429fe72c76a05950f827ee16db3524d" translate="yes" xml:space="preserve">
          <source>Chapter 10 The toplevel system or REPL (ocaml)</source>
          <target state="translated">第10章 顶层系统或REPL(ocaml)</target>
        </trans-unit>
        <trans-unit id="001839bacc443f251cfd2c927f4f6758c410072e" translate="yes" xml:space="preserve">
          <source>Chapter 11 The runtime system (ocamlrun)</source>
          <target state="translated">第11章 运行时系统(ocamlrun)</target>
        </trans-unit>
        <trans-unit id="410707e0a197616d24db0cf28623150b0fd9bbf1" translate="yes" xml:space="preserve">
          <source>Chapter 12 Native-code compilation (ocamlopt)</source>
          <target state="translated">第12章 本地代码编译(ocamlopt)</target>
        </trans-unit>
        <trans-unit id="8a6c191b9a4d617a739da661e8ae774b6ea4bf3b" translate="yes" xml:space="preserve">
          <source>Chapter 13 Lexer and parser generators (ocamllex, ocamlyacc)</source>
          <target state="translated">第13章 Lexer和解析器生成器(ocamllex,ocamlyacc)</target>
        </trans-unit>
        <trans-unit id="43aac2b85afd5512793e5351074e2a49b841dd1f" translate="yes" xml:space="preserve">
          <source>Chapter 14 Dependency generator (ocamldep)</source>
          <target state="translated">第14章 依赖关系生成器(ocamldep)</target>
        </trans-unit>
        <trans-unit id="c3749109d031480d3bd81dbe0edd1a4e6240de1d" translate="yes" xml:space="preserve">
          <source>Chapter 15 The browser/editor (ocamlbrowser)</source>
          <target state="translated">第15章 浏览器/编辑器(ocamlbrowser)</target>
        </trans-unit>
        <trans-unit id="30a554141c94c8a595a0ef2d51b365bc92da3410" translate="yes" xml:space="preserve">
          <source>Chapter 16 The documentation generator (ocamldoc)</source>
          <target state="translated">第16章 文档生成器(ocamldoc)</target>
        </trans-unit>
        <trans-unit id="795917bcc2fe3d841a2020a62bda17476ffc5bab" translate="yes" xml:space="preserve">
          <source>Chapter 17 The debugger (ocamldebug)</source>
          <target state="translated">第17章 调试器(ocamldebug)</target>
        </trans-unit>
        <trans-unit id="9798fdf8ebfc25a72ac812bc7bebb20f7bb87cf3" translate="yes" xml:space="preserve">
          <source>Chapter 18 Profiling (ocamlprof)</source>
          <target state="translated">第18章 剖析(ocamlprof)</target>
        </trans-unit>
        <trans-unit id="f5bc6351790005d4d54dd018de1ed7222e66ff92" translate="yes" xml:space="preserve">
          <source>Chapter 19 The ocamlbuild compilation manager</source>
          <target state="translated">第19章 ocamlbuild编译管理器</target>
        </trans-unit>
        <trans-unit id="c269d97f2761aea9b7eaea373eec2819293a83aa" translate="yes" xml:space="preserve">
          <source>Chapter 2 The module system</source>
          <target state="translated">第2章 模块系统</target>
        </trans-unit>
        <trans-unit id="de06f01aba4e638c618d8a261f9859d128cb1e0d" translate="yes" xml:space="preserve">
          <source>Chapter 20 Interfacing C with OCaml</source>
          <target state="translated">第20章 C与OCaml的接口</target>
        </trans-unit>
        <trans-unit id="076a91db60f3e8f0cac45b804159393c0f3106d6" translate="yes" xml:space="preserve">
          <source>Chapter 21 Optimisation with Flambda</source>
          <target state="translated">第21章 利用Flambda进行优化</target>
        </trans-unit>
        <trans-unit id="d15de4a495e291c78283893fc4e762621d85a00d" translate="yes" xml:space="preserve">
          <source>Chapter 22 Memory profiling with Spacetime</source>
          <target state="translated">第22章 用Spacetime进行内存剖析</target>
        </trans-unit>
        <trans-unit id="f8cd41c063dcd4b4438b8dbdb483110eb38bd31d" translate="yes" xml:space="preserve">
          <source>Chapter 23 Fuzzing with afl-fuzz</source>
          <target state="translated">第23章 用 afl-fuzz 进行模糊处理</target>
        </trans-unit>
        <trans-unit id="a4a791f8f6f8c0d8a4ad00bed731a1667316e104" translate="yes" xml:space="preserve">
          <source>Chapter 24 Runtime tracing with the instrumented runtime</source>
          <target state="translated">第24章 使用工具化运行时的运行时跟踪</target>
        </trans-unit>
        <trans-unit id="dd5072f88a3e588aa13c91fd059d66f2d6f5ab85" translate="yes" xml:space="preserve">
          <source>Chapter 25 The core library</source>
          <target state="translated">第二十五章 核心库</target>
        </trans-unit>
        <trans-unit id="1d1e656bf488be3aeb94f939e1a3a6ce5c39307f" translate="yes" xml:space="preserve">
          <source>Chapter 26 The standard library</source>
          <target state="translated">第二十六章 标准库</target>
        </trans-unit>
        <trans-unit id="2b882a43356571b7b90c97eef6ad2c38753586fc" translate="yes" xml:space="preserve">
          <source>Chapter 27 The compiler front-end</source>
          <target state="translated">第27章 编译器前端</target>
        </trans-unit>
        <trans-unit id="4d9b946afe127a69a4a6fd1e867c3901de646cce" translate="yes" xml:space="preserve">
          <source>Chapter 28 The unix library: Unix system calls</source>
          <target state="translated">第28章 unix库。Unix系统调用</target>
        </trans-unit>
        <trans-unit id="43e77b1c65a3b715d2db33e651d357a448b28637" translate="yes" xml:space="preserve">
          <source>Chapter 29 The num library: arbitrary-precision rational arithmetic</source>
          <target state="translated">第29章 num库:任意精度的有理算术</target>
        </trans-unit>
        <trans-unit id="7e30811f338538f3c0d38f9d6d42248053bfbe1d" translate="yes" xml:space="preserve">
          <source>Chapter 3 Objects in OCaml</source>
          <target state="translated">第3章 OCaml中的对象</target>
        </trans-unit>
        <trans-unit id="b8a3a02a9cae42ecda284ccbe84e3c4056117fcd" translate="yes" xml:space="preserve">
          <source>Chapter 30 The str library: regular expressions and string processing</source>
          <target state="translated">第30章 str库:正则表达式与字符串处理</target>
        </trans-unit>
        <trans-unit id="fa16c195ce280b138dd01abe2b38e59c60633da6" translate="yes" xml:space="preserve">
          <source>Chapter 31 The threads library</source>
          <target state="translated">第三十一章 线程库</target>
        </trans-unit>
        <trans-unit id="4fa73c279162cd152d0c19a54753ed4b092a6f44" translate="yes" xml:space="preserve">
          <source>Chapter 32 The graphics library</source>
          <target state="translated">第三十二章 图形库</target>
        </trans-unit>
        <trans-unit id="7273034c7b0640dc1b3db6600c2ce523db39d3c4" translate="yes" xml:space="preserve">
          <source>Chapter 33 The dynlink library: dynamic loading and linking of object files</source>
          <target state="translated">第三十三章 dynlink库:对象文件的动态加载和链接</target>
        </trans-unit>
        <trans-unit id="c45f56f7818d55915c239211feb596da3ef30b64" translate="yes" xml:space="preserve">
          <source>Chapter 34 The bigarray library</source>
          <target state="translated">第三十四章 Bigarray库</target>
        </trans-unit>
        <trans-unit id="2d169dd1a467fd491bd155eb638e1ccdc56f2688" translate="yes" xml:space="preserve">
          <source>Chapter 4 Labels and variants</source>
          <target state="translated">第4章 标签和变体</target>
        </trans-unit>
        <trans-unit id="47acd2509ab08220cd88716a4d5adad74e851efa" translate="yes" xml:space="preserve">
          <source>Chapter 5 Polymorphism and its limitations</source>
          <target state="translated">第五章 多态性及其局限性</target>
        </trans-unit>
        <trans-unit id="ea957655c2d829d612062883bdcdc3375bb972f9" translate="yes" xml:space="preserve">
          <source>Chapter 6 Advanced examples with classes and modules</source>
          <target state="translated">第6章 使用类和模块的高级示例</target>
        </trans-unit>
        <trans-unit id="21be5d98e1e33b0bbdf4ea2e078c6d2b805d67b9" translate="yes" xml:space="preserve">
          <source>Chapter 7 The OCaml language</source>
          <target state="translated">第7章 OCaml语言</target>
        </trans-unit>
        <trans-unit id="46ab86a56b7497600bb8e714a88e9abef74c7fa3" translate="yes" xml:space="preserve">
          <source>Chapter 8 Language extensions</source>
          <target state="translated">第八章 语文扩展</target>
        </trans-unit>
        <trans-unit id="391b169f6153a4b9d3a6bcce4a613a60664189dd" translate="yes" xml:space="preserve">
          <source>Chapter 9 Batch compilation (ocamlc)</source>
          <target state="translated">第9章 批量编译(ocamlc)</target>
        </trans-unit>
        <trans-unit id="0f9ba953e35135a3f8ec268817cc92f2557202a9" translate="yes" xml:space="preserve">
          <source>Char</source>
          <target state="translated">Char</target>
        </trans-unit>
        <trans-unit id="b2f83f280f0ba4673ff9b860af0167edcb7dc5eb" translate="yes" xml:space="preserve">
          <source>Character denoted</source>
          <target state="translated">标识的字符</target>
        </trans-unit>
        <trans-unit id="c11b0e685f81f6a610a7012ef3b9b40a0b7893d9" translate="yes" xml:space="preserve">
          <source>Character device</source>
          <target state="translated">字符设备</target>
        </trans-unit>
        <trans-unit id="9cda61e490d068bb818a82546143deb1856eba54" translate="yes" xml:space="preserve">
          <source>Character literals are delimited by ' (single quote) characters. The two single quotes enclose either one character different from ' and \, or one of the escape sequences below:</source>
          <target state="translated">字符由'(单引号)字符分隔。两个单引号包含一个不同于'和/'的字符,或者是下面的转义序列之一。</target>
        </trans-unit>
        <trans-unit id="93d160e081a31096ac20a234dcd5857d1dd2c533" translate="yes" xml:space="preserve">
          <source>Character operations</source>
          <target state="translated">字符操作</target>
        </trans-unit>
        <trans-unit id="3ed87e23d6eb7a0d480742eab3f278ad3edc9072" translate="yes" xml:space="preserve">
          <source>Character operations.</source>
          <target state="translated">角色操作。</target>
        </trans-unit>
        <trans-unit id="7eb3c3d69869dc4d46c112661656a874dc159d9e" translate="yes" xml:space="preserve">
          <source>Character values are represented as 8-bit integers between 0 and 255. Character codes between 0 and 127 are interpreted following the ASCII standard. The current implementation interprets character codes between 128 and 255 following the ISO 8859-1 standard.</source>
          <target state="translated">字符值以0和255之间的8位整数表示。0和127之间的字符代码按照ASCII标准进行解释,目前实施的是按照ISO 8859-1标准解释128和255之间的字符代码。目前的实施方案按照ISO 8859-1标准解释128和255之间的字符代码。</target>
        </trans-unit>
        <trans-unit id="b5c6a1aad15eafbbc861ff217eae35aa29ad75f6" translate="yes" xml:space="preserve">
          <source>Check if the formatter geometry is valid: &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt;</source>
          <target state="translated">检查格式化程序的几何图形是否有效： &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cf0c2762d6bb5f500fd8d57ef70e961f0d11397" translate="yes" xml:space="preserve">
          <source>Check information path during type-checking, to make sure that all types are derived in a principal way. When using labelled arguments and/or polymorphic methods, this flag is required to ensure future versions of the compiler will be able to infer types correctly, even if internal algorithms change. All programs accepted in -principal mode are also accepted in the default mode with equivalent types, but different binary signatures, and this may slow down type checking; yet it is a good idea to use it once before publishing source code.</source>
          <target state="translated">在类型检查过程中检查信息路径,以确保所有类型都是以主要方式推导出来的。当使用有标签的参数和/或多态方法时,需要这个标志来确保未来版本的编译器能够正确推导类型,即使内部算法发生变化。所有在-principal模式下接受的程序在默认模式下也会接受等价类型,但二进制签名不同,这可能会减慢类型检查的速度;然而在发布源代码之前使用一次是个好主意。</target>
        </trans-unit>
        <trans-unit id="e981f123821139261d30477b7436fc5a55b64f1b" translate="yes" xml:space="preserve">
          <source>Check that the generated bytecode executable can run on 32-bit platforms and signal an error if it cannot. This is useful when compiling bytecode on a 64-bit machine.</source>
          <target state="translated">检查生成的字节码可执行文件是否能在32位平台上运行,如果不能,则发出错误信号。这在64位机器上编译字节码时很有用。</target>
        </trans-unit>
        <trans-unit id="605d9d3370c8fb91a9c430b3f8bc3429e0117aa7" translate="yes" xml:space="preserve">
          <source>Check that the process has the given permissions over the named file.</source>
          <target state="translated">检查进程是否对命名的文件有给定的权限。</target>
        </trans-unit>
        <trans-unit id="83dfb869c6a27841e790ad08cb50f233ca1f4045" translate="yes" xml:space="preserve">
          <source>Check that the process has the given permissions over the named file. Raise &lt;code&gt;Unix_error&lt;/code&gt; otherwise.</source>
          <target state="translated">检查进程是否对命名文件具有给定的权限。否则提高 &lt;code&gt;Unix_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6097bb19d940e5685334990aa89b56295b3b220" translate="yes" xml:space="preserve">
          <source>Child process terminated</source>
          <target state="translated">儿童程序终止</target>
        </trans-unit>
        <trans-unit id="ceda17985ac6b3f5a4c93ac5d7c217a8d28d7bcb" translate="yes" xml:space="preserve">
          <source>Class application is denoted by juxtaposition of (possibly labeled) expressions. It denotes the class whose constructor is the first expression applied to the given arguments. The arguments are evaluated as for expression application, but the constructor itself will only be evaluated when objects are created. In particular, side-effects caused by the application of the constructor will only occur at object creation time.</source>
          <target state="translated">类的应用是通过并列的(可能是标记的)表达式来表示的。它表示类的构造函数是应用于给定参数的第一个表达式。参数会像应用表达式一样被评估,但构造函数本身只有在创建对象时才会被评估。特别是,应用构造函数引起的副作用只会在对象创建时发生。</target>
        </trans-unit>
        <trans-unit id="8876b2e72d29d328da5ecb8760743ad996296c94" translate="yes" xml:space="preserve">
          <source>Class expressions are the class-level equivalent of value expressions: they evaluate to classes, thus providing implementations for the specifications expressed in class types.</source>
          <target state="translated">类表达式相当于类级的值表达式:它们评估到类,从而为类类型表达的规范提供了实现。</target>
        </trans-unit>
        <trans-unit id="108c4260793c1e17098c25078141189b9f80ad27" translate="yes" xml:space="preserve">
          <source>Class interfaces are inferred from class definitions. They may also be defined directly and used to restrict the type of a class. Like class declarations, they also define a new type abbreviation.</source>
          <target state="translated">类接口是从类定义中推导出来的。它们也可以直接定义,用于限制类的类型。像类声明一样,它们也定义了一个新的类型缩写。</target>
        </trans-unit>
        <trans-unit id="6fcdc33cca1230f6e629369b3712d206838762cc" translate="yes" xml:space="preserve">
          <source>Class specifications are described more precisely in section &amp;zwj;&lt;a href=&quot;classes#ss%3Aclass-spec&quot;&gt;7.9.4&lt;/a&gt;.</source>
          <target state="translated">类规范在部分更精确地描述&lt;a href=&quot;classes#ss%3Aclass-spec&quot;&gt;7.9.4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c857b3c0f35a1cf445f8db99a25973f3c3b2e890" translate="yes" xml:space="preserve">
          <source>Class specifications are described more precisely in section &lt;a href=&quot;classes#ss%3Aclass-spec&quot;&gt;7.9.4&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;classes#ss%3Aclass-spec&quot;&gt;7.9.4&lt;/a&gt;节中更加精确地描述了类规范。</target>
        </trans-unit>
        <trans-unit id="6cac64186cec5136028f17ddf4f650c957d03d5d" translate="yes" xml:space="preserve">
          <source>Class types are the class-level equivalent of type expressions: they specify the general shape and type properties of classes.</source>
          <target state="translated">类类型相当于类级的类型表达式:它们规定了类的一般形状和类型属性。</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="47bea575c5d9baad367210dd15b04c4c182dce19" translate="yes" xml:space="preserve">
          <source>Classes are defined using a small language, similar to the module language.</source>
          <target state="translated">类是用一种小语言定义的,类似于模块语言。</target>
        </trans-unit>
        <trans-unit id="8afd240a4acd3b80e8530e285fba9a2f238dc1dc" translate="yes" xml:space="preserve">
          <source>Classes window_observer and window_subject can still be extended by inheritance. For instance, one may enrich the subject with new behaviors and refine the behavior of the observer.</source>
          <target state="translated">window_observer 和 window_subject 类仍然可以通过继承来扩展。例如,我们可以用新的行为来丰富主体,完善观察者的行为。</target>
        </trans-unit>
        <trans-unit id="a01eb9463326201b62bd18afc119f471a20a46d3" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor.</source>
          <target state="translated">清除给定描述符上的 &quot;close-on-exec &quot;标志。</target>
        </trans-unit>
        <trans-unit id="4bc43d79488f3b27bccafdf17c420f0d747526c8" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">清除给定描述符上的``close-on-exec''标志。参见&lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a59376799f540da74c603bc50f48227a56704df" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor. See &lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt;&lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">清除给定描述符上的``close-on-exec''标志。参见&lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt; &lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0843662a0ae553306f085b13e4737ae2561db27" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor.</source>
          <target state="translated">清除指定描述符上的 &quot;非阻塞 &quot;标志。</target>
        </trans-unit>
        <trans-unit id="fd1c73dfdb7d3867700cd7ea86d4dd6c48d8ee02" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor. See &lt;a href=&quot;unix#VALset_nonblock&quot;&gt;&lt;code&gt;Unix.set_nonblock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">清除给定描述符上的``非阻塞''标志。参见&lt;a href=&quot;unix#VALset_nonblock&quot;&gt; &lt;code&gt;Unix.set_nonblock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23ed5871b75d708804ee3f41ea756675082150ec" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor. See &lt;a href=&quot;unixlabels#VALset_nonblock&quot;&gt;&lt;code&gt;UnixLabels.set_nonblock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">清除给定描述符上的``非阻塞''标志。参见&lt;a href=&quot;unixlabels#VALset_nonblock&quot;&gt; &lt;code&gt;UnixLabels.set_nonblock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb4c990b5652dae59a6be6a792769aef18fde455" translate="yes" xml:space="preserve">
          <source>Clear the close-on-exec flag. This is currently the default.</source>
          <target state="translated">清除执行时关闭标志。目前是默认值。</target>
        </trans-unit>
        <trans-unit id="bdb21a46e06b56087078be6b4aff4ce68b24daea" translate="yes" xml:space="preserve">
          <source>Cloning and override have a non empty intersection. They are interchangeable when used within an object and without overriding any field:</source>
          <target state="translated">克隆和覆盖有一个非空的交叉点。当在一个对象中使用时,它们是可以互换的,而且不覆盖任何字段。</target>
        </trans-unit>
        <trans-unit id="bfbe69f4a604ebda49f0c8e440a558ccd8966474" translate="yes" xml:space="preserve">
          <source>Cloning can also be used to provide facilities for saving and restoring the state of objects.</source>
          <target state="translated">克隆也可以用来提供保存和恢复对象状态的设施。</target>
        </trans-unit>
        <trans-unit id="241b9beb2f7204a7ae1316941e73e2b9fa4afd0c" translate="yes" xml:space="preserve">
          <source>Close a directory descriptor.</source>
          <target state="translated">关闭一个目录描述符。</target>
        </trans-unit>
        <trans-unit id="afd2c6b2e7b89772b6708c7aca8a6d5a888f5146" translate="yes" xml:space="preserve">
          <source>Close a file descriptor.</source>
          <target state="translated">关闭文件描述符。</target>
        </trans-unit>
        <trans-unit id="ab162827cb467aeef1cfdbabbced6f4ac7ae6731" translate="yes" xml:space="preserve">
          <source>Close both</source>
          <target state="translated">关闭两个</target>
        </trans-unit>
        <trans-unit id="ca279507e900048762edd58a735705649ef1441a" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process&quot;&gt;&lt;code&gt;Unix.open_process&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">关闭由&lt;a href=&quot;unix#VALopen_process&quot;&gt; &lt;code&gt;Unix.open_process&lt;/code&gt; &lt;/a&gt;打开的通道，等待相关命令终止，并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="aa4ea9d16cdeb07884420e45a9b4a955b46da461" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_full&quot;&gt;&lt;code&gt;Unix.open_process_full&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">关闭由&lt;a href=&quot;unix#VALopen_process_full&quot;&gt; &lt;code&gt;Unix.open_process_full&lt;/code&gt; &lt;/a&gt;打开的通道，等待相关命令终止，并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="fd5848e9973d58846ccebfcc487fe6068111200e" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">关闭由&lt;a href=&quot;unix#VALopen_process_in&quot;&gt; &lt;code&gt;Unix.open_process_in&lt;/code&gt; &lt;/a&gt;打开的通道，等待相关命令终止，并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="4a7c2328f3cb9873b3f974f2c82eac788b54581c" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_out&quot;&gt;&lt;code&gt;Unix.open_process_out&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">关闭由&lt;a href=&quot;unix#VALopen_process_out&quot;&gt; &lt;code&gt;Unix.open_process_out&lt;/code&gt; &lt;/a&gt;打开的通道，等待相关命令终止，并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="40dccb11bde36cc9d87578fff4b5574199a6f237" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process&quot;&gt;&lt;code&gt;UnixLabels.open_process&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">关闭由&lt;a href=&quot;unixlabels#VALopen_process&quot;&gt; &lt;code&gt;UnixLabels.open_process&lt;/code&gt; &lt;/a&gt;打开的通道，等待关联的命令终止，并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="104a97fe326dc92db83909431482619107f79d7f" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_full&quot;&gt;&lt;code&gt;UnixLabels.open_process_full&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">关闭由&lt;a href=&quot;unixlabels#VALopen_process_full&quot;&gt; &lt;code&gt;UnixLabels.open_process_full&lt;/code&gt; &lt;/a&gt;打开的通道，等待关联的命令终止，并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="dc2ac483e1e28bbc2dae7a1dcbdb428a53ea65db" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt;&lt;code&gt;UnixLabels.open_process_in&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">关闭由&lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt; &lt;code&gt;UnixLabels.open_process_in&lt;/code&gt; &lt;/a&gt;打开的通道，等待关联的命令终止，并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="987835cf216c09d3d3659c353042acf47eb82cb6" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt;&lt;code&gt;UnixLabels.open_process_out&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">关闭由&lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt; &lt;code&gt;UnixLabels.open_process_out&lt;/code&gt; &lt;/a&gt;打开的通道，等待关联的命令终止，并返回其终止状态。</target>
        </trans-unit>
        <trans-unit id="ea5708310a7ccde2ea99739644bf345de4466c25" translate="yes" xml:space="preserve">
          <source>Close for receiving</source>
          <target state="translated">关闭接收</target>
        </trans-unit>
        <trans-unit id="805fb7fdd53fdd68744184a36444efa2cf87c672" translate="yes" xml:space="preserve">
          <source>Close for sending</source>
          <target state="translated">关闭发送</target>
        </trans-unit>
        <trans-unit id="8b3f52183f139b54fa0f6f2fbb72a62dd79a1c1a" translate="yes" xml:space="preserve">
          <source>Close the given channel, flushing all buffered write operations.</source>
          <target state="translated">关闭给定通道,刷新所有缓冲写操作。</target>
        </trans-unit>
        <trans-unit id="41f5ceda25cbace756e58b1de142e130a58c7a95" translate="yes" xml:space="preserve">
          <source>Close the given channel, flushing all buffered write operations. Output functions raise a &lt;code&gt;Sys_error&lt;/code&gt; exception when they are applied to a closed output channel, except &lt;code&gt;close_out&lt;/code&gt; and &lt;code&gt;flush&lt;/code&gt;, which do nothing when applied to an already closed channel. Note that &lt;code&gt;close_out&lt;/code&gt; may raise &lt;code&gt;Sys_error&lt;/code&gt; if the operating system signals an error when flushing or closing.</source>
          <target state="translated">关闭给定通道，刷新所有缓冲的写操作。当将输出函数应用于关闭的输出通道时，它们会引发 &lt;code&gt;Sys_error&lt;/code&gt; 异常， &lt;code&gt;close_out&lt;/code&gt; 和 &lt;code&gt;flush&lt;/code&gt; 除外，当应用于已关闭的通道时它们不会执行任何操作。请注意，如果操作系统在刷新或关闭时发出错误信号，则 &lt;code&gt;close_out&lt;/code&gt; 可能会引发 &lt;code&gt;Sys_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5befc2f5b4184ff319029954a3ebf8773fc60aa3" translate="yes" xml:space="preserve">
          <source>Close the given channel.</source>
          <target state="translated">关闭指定通道。</target>
        </trans-unit>
        <trans-unit id="855dc6dc2be39d04f3f61cd8c3fd1df32f67ae63" translate="yes" xml:space="preserve">
          <source>Close the given channel. Input functions raise a &lt;code&gt;Sys_error&lt;/code&gt; exception when they are applied to a closed input channel, except &lt;code&gt;close_in&lt;/code&gt;, which does nothing when applied to an already closed channel.</source>
          <target state="translated">关闭给定的通道。当将输入函数应用于关闭的输入通道时，它们会引发 &lt;code&gt;Sys_error&lt;/code&gt; 异常，但 &lt;code&gt;close_in&lt;/code&gt; 除外，在应用于已关闭的通道时不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="9baa0ea016defeba1648df1c2d1bbcade0cfb062" translate="yes" xml:space="preserve">
          <source>Closed function</source>
          <target state="translated">封闭功能</target>
        </trans-unit>
        <trans-unit id="8e571180f5e0fe0a1fdd6d813d79acaf0ccfafa6" translate="yes" xml:space="preserve">
          <source>Closes the &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; associated with the given &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel.</source>
          <target state="translated">关闭&lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt;与给定的相关联&lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt;格式化的输入信道。</target>
        </trans-unit>
        <trans-unit id="92b5986b3d61e6de67170fcc909df02aeafde6d5" translate="yes" xml:space="preserve">
          <source>Closes the most recently open pretty-printing box.</source>
          <target state="translated">关闭最近打开的漂亮打印盒。</target>
        </trans-unit>
        <trans-unit id="ca307b38101cc962b95e89e6fb0f008aaea2cbd9" translate="yes" xml:space="preserve">
          <source>Closes the most recently opened tabulation box.</source>
          <target state="translated">关闭最近打开的表格框。</target>
        </trans-unit>
        <trans-unit id="68e5fec7b2f5ac26ce08ec9bc3f5ffc7a6bf53c7" translate="yes" xml:space="preserve">
          <source>Closing an account can be done with the following polymorphic function:</source>
          <target state="translated">关闭账户可以通过以下多态函数来完成。</target>
        </trans-unit>
        <trans-unit id="84e77ec95c5a92eb909c6ac217e1a65e9bf9d350" translate="yes" xml:space="preserve">
          <source>Closure</source>
          <target state="translated">Closure</target>
        </trans-unit>
        <trans-unit id="ab1d845e18aa99c6b3ee6f2e85015ce183551e94" translate="yes" xml:space="preserve">
          <source>Closure variable</source>
          <target state="translated">封闭变量</target>
        </trans-unit>
        <trans-unit id="1cd8c868a0be56feb09ac75a044fb7f0ae532487" translate="yes" xml:space="preserve">
          <source>Closure_tag</source>
          <target state="translated">Closure_tag</target>
        </trans-unit>
        <trans-unit id="1ebf4e3e7bbb419f530260ca7275b893d6cbb63a" translate="yes" xml:space="preserve">
          <source>Code_val(v) returns the code part of the closure v.</source>
          <target state="translated">Code_val(v)返回闭包v的代码部分。</target>
        </trans-unit>
        <trans-unit id="7fcd900e853fff06e8f7a1bd2e3f903467af8dcd" translate="yes" xml:space="preserve">
          <source>Coercions between generic Bigarrays and fixed-dimension Bigarrays</source>
          <target state="translated">通用Bigarrays和固定尺寸Bigarrays之间的胁迫。</target>
        </trans-unit>
        <trans-unit id="8d11cb9b589ffcbe8510661b59242a872e6798ab" translate="yes" xml:space="preserve">
          <source>Collected metrics include time spent executing the &lt;em&gt;garbage collector&lt;/em&gt;. The overall execution time of individual pauses are measured down to the time spent in specific parts of the garbage collection. Insight is also given on memory allocation and motion by recording the size of allocated memory blocks, as well as value promotions from the &lt;em&gt;minor heap&lt;/em&gt; to the &lt;em&gt;major heap&lt;/em&gt;.</source>
          <target state="translated">收集的指标包括执行&lt;em&gt;垃圾收集器所&lt;/em&gt;花费的时间。各个暂停的总执行时间将计算为在垃圾回收的特定部分所花费的时间。通过记录已分配内存块的大小以及从&lt;em&gt;次要堆&lt;/em&gt;到&lt;em&gt;主堆的&lt;/em&gt;价值提升，还可以对内存分配和运动进行深入了解。</target>
        </trans-unit>
        <trans-unit id="c87dcdd72a40f6bb0a5079a52dd8623dedfe7f0f" translate="yes" xml:space="preserve">
          <source>Colorize the OCaml code enclosed in [ ] and {[ ]}, using colors to emphasize keywords, etc. If the code fragments are not syntactically correct, no color is added.</source>
          <target state="translated">对[]和{[]}中包含的OCaml代码进行着色,使用颜色来强调关键字等。如果代码片段的语法不正确,则不加颜色。</target>
        </trans-unit>
        <trans-unit id="25e719594fe4392044efc80322d910ef4492ead1" translate="yes" xml:space="preserve">
          <source>Combinators</source>
          <target state="translated">Combinators</target>
        </trans-unit>
        <trans-unit id="6c17ee03a306b91971412221a882fcd419f9e636" translate="yes" xml:space="preserve">
          <source>Command-line flags that may apply per round, for example those with -cost in the name, accept arguments of the form:</source>
          <target state="translated">可能适用于每一轮的命令行标志,例如名称中带有-cost的标志,接受形式为参数。</target>
        </trans-unit>
        <trans-unit id="c25ddda331004e4397b9f28e2859119842f8dc5d" translate="yes" xml:space="preserve">
          <source>Commands for &lt;a href=&quot;unix#VALlockf&quot;&gt;&lt;code&gt;Unix.lockf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALlockf&quot;&gt; &lt;code&gt;Unix.lockf&lt;/code&gt; 的&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="8fe2bb252511c0dcd32f92897ba3957e1e2a7bb9" translate="yes" xml:space="preserve">
          <source>Commands for &lt;a href=&quot;unixlabels#VALlockf&quot;&gt;&lt;code&gt;UnixLabels.lockf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALlockf&quot;&gt; &lt;code&gt;UnixLabels.lockf&lt;/code&gt; 的&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="a3122e7df96ccf5ef3d6e6a21777fc3539282091" translate="yes" xml:space="preserve">
          <source>Comments are delimited by (* and *), as in OCaml. The parse keyword, can be replaced by the shortest keyword, with the semantic consequences explained below.</source>
          <target state="translated">注释用(*和*)来分隔,就像OCaml中一样。解析关键字,可以用最短关键字代替,语义后果解释如下。</target>
        </trans-unit>
        <trans-unit id="e0c1fef4daa2204e1362a69f73112badb4d24614" translate="yes" xml:space="preserve">
          <source>Comments are enclosed between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; (as in C) in the &amp;ldquo;declarations&amp;rdquo; and &amp;ldquo;rules&amp;rdquo; sections, and between &lt;code&gt;(*&lt;/code&gt; and &lt;code&gt;*)&lt;/code&gt; (as in OCaml) in the &amp;ldquo;header&amp;rdquo; and &amp;ldquo;trailer&amp;rdquo; sections.</source>
          <target state="translated">在&amp;ldquo;声明&amp;rdquo;和&amp;ldquo;规则&amp;rdquo;部分的 &lt;code&gt;/*&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; （如C）之间，以及在&amp;ldquo;标题&amp;rdquo;和&amp;ldquo;尾随&amp;rdquo;部分的 &lt;code&gt;(*&lt;/code&gt; 和 &lt;code&gt;*)&lt;/code&gt; 之间（在OCaml中）包含注释。</target>
        </trans-unit>
        <trans-unit id="ecc11b72dffe0da3e8d97afd6ad9a45f16491b95" translate="yes" xml:space="preserve">
          <source>Comments are introduced by the two characters (*, with no intervening blanks, and terminated by the characters *), with no intervening blanks. Comments are treated as blank characters. Comments do not occur inside string or character literals. Nested comments are handled correctly.</source>
          <target state="translated">注释由两个字符(*,中间没有空白)引入,由字符*结束,中间没有空白。注释被视为空白字符。注释不会出现在字符串或字符字元中。嵌套的注释会被正确处理。</target>
        </trans-unit>
        <trans-unit id="f75c107f6586a424d755198fc82176b1d5f1dff9" translate="yes" xml:space="preserve">
          <source>Comments containing documentation material are called &lt;em&gt;special comments&lt;/em&gt; and are written between (** and *). Special comments must start exactly with (**. Comments beginning with ( and more than two * are ignored.</source>
          <target state="translated">包含文档材料的&lt;em&gt;注释&lt;/em&gt;被称为&lt;em&gt;特殊注释&lt;/em&gt;，并写在（**和*）之间。特殊注释必须完全以（**。开头。注释以（开头，且超过两个*的注释将被忽略。</target>
        </trans-unit>
        <trans-unit id="03e0a1731c9889297d187cff3225ed905ba87b0e" translate="yes" xml:space="preserve">
          <source>Comments surrounded by blank lines that appear within structures, signatures, classes or class types are converted into &lt;a href=&quot;attributes#floating-attribute&quot;&gt;floating-attribute&lt;/a&gt;s. For example:</source>
          <target state="translated">出现在结构，签名，类或类类型内的空白行所包围的注释将转换为&lt;a href=&quot;attributes#floating-attribute&quot;&gt;float属性&lt;/a&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="d590b93e87bc1ca65038f4d51e929c8c079658f0" translate="yes" xml:space="preserve">
          <source>Comments which appear &lt;em&gt;immediately after&lt;/em&gt; a labelled argument, record field, variant constructor, object method or polymorphic variant constructor are are converted into &lt;a href=&quot;attributes#attribute&quot;&gt;attribute&lt;/a&gt;s. Immediately after means that there must be no blank lines or other documentation comments between them. For example:</source>
          <target state="translated">&lt;em&gt;在&lt;/em&gt;带标签的参数，记录字段，变量构造函数，对象方法或多态变量构造函数&lt;em&gt;之后立即&lt;/em&gt;出现的注释将转换为&lt;a href=&quot;attributes#attribute&quot;&gt;attribute&lt;/a&gt; s。紧随其后的意思是它们之间必须没有空白行或其他文档注释。例如：</target>
        </trans-unit>
        <trans-unit id="6b07191143ad093b41ed81db204e258405ef704d" translate="yes" xml:space="preserve">
          <source>Comments which appear &lt;em&gt;immediately before&lt;/em&gt; or &lt;em&gt;immediately after&lt;/em&gt; a structure item, signature item, class item or class type item are converted into &lt;a href=&quot;attributes#item-attribute&quot;&gt;item-attribute&lt;/a&gt;s. Immediately before or immediately after means that there must be no blank lines, ;;, or other documentation comments between them. For example:</source>
          <target state="translated">&lt;em&gt;在&lt;/em&gt;结构项，签名项，类项或类类型项&lt;em&gt;之前&lt;/em&gt;或&lt;em&gt;之后&lt;/em&gt;出现的注释将转换为&lt;a href=&quot;attributes#item-attribute&quot;&gt;item-attribute&lt;/a&gt;。紧接在此之前或之后的意思是，它们之间不得有任何空白行，;;或其他文档注释。例如：</target>
        </trans-unit>
        <trans-unit id="b4a9f0c7d9e6ed45794c74f1a8f2a1e8f36500ca" translate="yes" xml:space="preserve">
          <source>Comments which start with ** are also used by the ocamldoc documentation generator (see &lt;a href=&quot;ocamldoc#c%3Aocamldoc&quot;&gt;15&lt;/a&gt;). The three comment forms recognised by the compiler are a subset of the forms accepted by ocamldoc (see &lt;a href=&quot;ocamldoc#s%3Aocamldoc-comments&quot;&gt;15.2&lt;/a&gt;).</source>
          <target state="translated">ocamldoc文档生成器还会使用以**开头的注释（请参见&lt;a href=&quot;ocamldoc#c%3Aocamldoc&quot;&gt;15&lt;/a&gt;）。编译器可以识别的三种注释形式是ocamldoc接受的形式的子集（请参见&lt;a href=&quot;ocamldoc#s%3Aocamldoc-comments&quot;&gt;15.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b7e64151aaa26674586f987552e2a0ae124e42ca" translate="yes" xml:space="preserve">
          <source>Comments which start with ** are also used by the ocamldoc documentation generator (see &lt;a href=&quot;ocamldoc#c%3Aocamldoc&quot;&gt;16&lt;/a&gt;). The three comment forms recognised by the compiler are a subset of the forms accepted by ocamldoc (see &lt;a href=&quot;ocamldoc#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;).</source>
          <target state="translated">ocamldoc文档生成器还使用以**开头的注释（请参见&lt;a href=&quot;ocamldoc#c%3Aocamldoc&quot;&gt;16&lt;/a&gt;）。编译器可以识别的三种注释形式是ocamldoc接受的形式的子集（请参见&lt;a href=&quot;ocamldoc#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="547a2cc3c515433ea933b36b097f47f32287dbd8" translate="yes" xml:space="preserve">
          <source>Comments which start with ** are treated specially by the compiler. They are automatically converted during parsing into attributes (see &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;) to allow tools to process them as documentation.</source>
          <target state="translated">以**开头的注释将由编译器特别处理。它们在解析过程中会自动转换为属性（请参见&lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;），以允许工具将它们作为文档进行处理。</target>
        </trans-unit>
        <trans-unit id="d13ad45db1dc27f552c9c8e0654c622cd0ecc95b" translate="yes" xml:space="preserve">
          <source>Common usage of semantic tags is text decoration to get specific font or text size rendering for a display device, or marking delimitation of entities (e.g. HTML or TeX elements or terminal escape sequences). More sophisticated usage of semantic tags could handle dynamic modification of the pretty-printer behavior to properly print the material within some specific tags. For instance, we can define an RGB tag like so:</source>
          <target state="translated">语义标签的常见用法是文本装饰,以便为显示设备获得特定的字体或文本大小渲染,或标记实体的定界(如HTML或TeX元素或终端转义序列)。语义标签更复杂的用法可以处理动态修改pretty-printer行为,以正确打印某些特定标签内的材料。例如,我们可以这样定义一个RGB标签。</target>
        </trans-unit>
        <trans-unit id="97496bca65dfa73c8db0f1c633b8c699b9ca1bae" translate="yes" xml:space="preserve">
          <source>Commonly-used options:</source>
          <target state="translated">常用选项。</target>
        </trans-unit>
        <trans-unit id="69e3408c9830bff719edb4bd317094b20c392982" translate="yes" xml:space="preserve">
          <source>Compare the length of a list to an integer.</source>
          <target state="translated">将一个列表的长度与一个整数进行比较。</target>
        </trans-unit>
        <trans-unit id="ef5423e0ff1e624a91454907710145bf4ac0605c" translate="yes" xml:space="preserve">
          <source>Compare the length of a list to an integer. &lt;code&gt;compare_length_with&amp;nbsp;l&amp;nbsp;len&lt;/code&gt; is equivalent to &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l)&amp;nbsp;len&lt;/code&gt;, except that the computation stops after at most &lt;code&gt;len&lt;/code&gt; iterations on the list.</source>
          <target state="translated">将列表的长度与整数进行比较。 &lt;code&gt;compare_length_with&amp;nbsp;l&amp;nbsp;len&lt;/code&gt; 等效于 &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l)&amp;nbsp;len&lt;/code&gt; ，除了计算最多在列表上的 &lt;code&gt;len&lt;/code&gt; 迭代之后停止。</target>
        </trans-unit>
        <trans-unit id="160a38d938d09531dcc37101c8a48af67237c4f6" translate="yes" xml:space="preserve">
          <source>Compare the length of a list to an integer. &lt;code&gt;compare_length_with&amp;nbsp;l&amp;nbsp;n&lt;/code&gt; is equivalent to &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l)&amp;nbsp;n&lt;/code&gt;, except that the computation stops after at most &lt;code&gt;n&lt;/code&gt; iterations on the list.</source>
          <target state="translated">将列表的长度与整数进行比较。 &lt;code&gt;compare_length_with&amp;nbsp;l&amp;nbsp;n&lt;/code&gt; 等效于 &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l)&amp;nbsp;n&lt;/code&gt; ，除了计算最多在列表上进行 &lt;code&gt;n&lt;/code&gt; 次迭代后停止。</target>
        </trans-unit>
        <trans-unit id="b5b86b090c0daa980723dd4a0e6e2467eeba31e6" translate="yes" xml:space="preserve">
          <source>Compare the lengths of two lists.</source>
          <target state="translated">比较两个列表的长度。</target>
        </trans-unit>
        <trans-unit id="fbac14054ab6f68fcc3f6240710fbda158a49236" translate="yes" xml:space="preserve">
          <source>Compare the lengths of two lists. &lt;code&gt;compare_lengths&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; is equivalent to &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l1)&amp;nbsp;(length&amp;nbsp;l2)&lt;/code&gt;, except that the computation stops after itering on the shortest list.</source>
          <target state="translated">比较两个列表的长度。 &lt;code&gt;compare_lengths&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 等效于 &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l1)&amp;nbsp;(length&amp;nbsp;l2)&lt;/code&gt; ，除了在最短列表上迭代之后计算会停止。</target>
        </trans-unit>
        <trans-unit id="91f4c46890bc7f725d43aab1d105004a01e7075f" translate="yes" xml:space="preserve">
          <source>Compare the lengths of two lists. &lt;code&gt;compare_lengths&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; is equivalent to &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l1)&amp;nbsp;(length&amp;nbsp;l2)&lt;/code&gt;, except that the computation stops after reaching the end of the shortest list.</source>
          <target state="translated">比较两个列表的长度。 &lt;code&gt;compare_lengths&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 等效于 &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l1)&amp;nbsp;(length&amp;nbsp;l2)&lt;/code&gt; ，除了计算在到达最短列表的末尾之后停止。</target>
        </trans-unit>
        <trans-unit id="2dfcf898a3bd4e011123eee87384ecb67d0919d4" translate="yes" xml:space="preserve">
          <source>Comparison</source>
          <target state="translated">Comparison</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="5087a62fc321853c1ed733d0f0c235d307ad40e8" translate="yes" xml:space="preserve">
          <source>Compilation of modules that are able to be statically allocated (for example, the module corresponding to an entire compilation unit, as opposed to a first class module dependent on values computed at runtime) initially follows the strategy used for bytecode. A sequence of let-bindings, which may be interspersed with arbitrary effects, surrounds a record creation that becomes the module block. The Flambda-specific transformation follows: these bindings are lifted to toplevel symbols, as described above.</source>
          <target state="translated">能够被静态分配的模块(例如,对应于整个编译单元的模块,而不是依赖于运行时计算的值的第一类模块)的编译最初遵循用于字节码的策略。一个可以穿插任意效果的让绑定序列,围绕着一个成为模块块的记录创建。Flambda特有的转换如下:这些绑定被提升为toplevel符号,如上所述。</target>
        </trans-unit>
        <trans-unit id="338a814c20dd6bc624d9e88b7fc43588dd28cd6a" translate="yes" xml:space="preserve">
          <source>Compilation units bridge the module system and the separate compilation system. A compilation unit is composed of two parts: an interface and an implementation. The interface contains a sequence of specifications, just as the inside of a sig &amp;hellip; end signature expression. The implementation contains a sequence of definitions and expressions, just as the inside of a struct &amp;hellip; end module expression. A compilation unit also has a name unit-name, derived from the names of the files containing the interface and the implementation (see chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; for more details). A compilation unit behaves roughly as the module definition</source>
          <target state="translated">编译单元桥接模块系统和单独的编译系统。编译单元由两部分组成：接口和实现。该接口包含一系列规范，就像sig&amp;hellip;结束签名表达式的内部一样。该实现包含一系列定义和表达式，就像struct&amp;hellip;最终模块表达式的内部一样。编译单元还有一个名字单位名称，从包含接口和实现（见的文件的名称派生&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;了解详细信息）。编译单元的行为大致与模块定义相同</target>
        </trans-unit>
        <trans-unit id="89736122b4f9e6c854312216700fafb53d78c2c9" translate="yes" xml:space="preserve">
          <source>Compilation units bridge the module system and the separate compilation system. A compilation unit is composed of two parts: an interface and an implementation. The interface contains a sequence of specifications, just as the inside of a sig &amp;hellip; end signature expression. The implementation contains a sequence of definitions and expressions, just as the inside of a struct &amp;hellip; end module expression. A compilation unit also has a name unit-name, derived from the names of the files containing the interface and the implementation (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; for more details). A compilation unit behaves roughly as the module definition</source>
          <target state="translated">编译单元桥接模块系统和单独的编译系统。编译单元由两部分组成：接口和实现。该接口包含一系列规范，就像sig&amp;hellip;结束签名表达式的内部一样。该实现包含一系列定义和表达式，就像struct&amp;hellip;最终模块表达式的内部一样。编译单元还具有一个名称单元名称，该名称是从包含接口和实现的文件的名称派生的（有关更多详细信息，请参见第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章）。编译单元的行为大致与模块定义相同</target>
        </trans-unit>
        <trans-unit id="2fd716bd7c95ad22fcf1ff74d5dd9c3e2800de42" translate="yes" xml:space="preserve">
          <source>Compilation units that use the threads library must also be compiled with the -I +threads option (see chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">使用线程库编译单元也必须与-I +线程选项（参见章编译&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="76d0c7b86e662ef638a28a1ba63b2bf600c9a068" translate="yes" xml:space="preserve">
          <source>Compilation units that use the threads library must also be compiled with the -I +threads option (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">使用线程库的编译单元还必须使用-I + threads选项进行编译（请参见第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章）。</target>
        </trans-unit>
        <trans-unit id="5561032adf17bb14b32847302c46e8b6f2562175" translate="yes" xml:space="preserve">
          <source>Compile Mylib.ml using -no-alias-deps, and the other files using -no-alias-deps and -openMylib (the last one is equivalent to adding the line open!Mylib at the top of each file).</source>
          <target state="translated">使用-no-alias-deps编译Mylib.ml,使用-no-alias-deps和-openMylib编译其他文件(最后一个相当于在每个文件的顶部添加open!Mylib这一行)。</target>
        </trans-unit>
        <trans-unit id="0781426396e8d6e4ddff539e7a4bd1c018f11c8a" translate="yes" xml:space="preserve">
          <source>Compile a regular expression.</source>
          <target state="translated">编制一个正则表达式。</target>
        </trans-unit>
        <trans-unit id="379347737d11075d4adc510a0c49219cd575a386" translate="yes" xml:space="preserve">
          <source>Compile a regular expression. The following constructs are recognized:</source>
          <target state="translated">编译一个正则表达式。识别以下结构。</target>
        </trans-unit>
        <trans-unit id="9e82ad175e2f5dacb9db3b9f212ed757afd81633" translate="yes" xml:space="preserve">
          <source>Compile only. Suppress the linking phase of the compilation. Source code files are turned into compiled files, but no executable file is produced. This option is useful to compile modules separately.</source>
          <target state="translated">只编译。压制编译的链接阶段。源代码文件会变成编译后的文件,但不会产生可执行文件。这个选项对单独编译模块很有用。</target>
        </trans-unit>
        <trans-unit id="e75f188aa5bbb4470a9e0906d4ab6e6752a8b3a3" translate="yes" xml:space="preserve">
          <source>Compile the file filename as an implementation file, even if its extension is not .ml.</source>
          <target state="translated">将文件名编译为执行文件,即使其扩展名不是.ml。</target>
        </trans-unit>
        <trans-unit id="899b4c58ed78c400dbe712c3db1a649a9c6d6a72" translate="yes" xml:space="preserve">
          <source>Compile the file filename as an interface file, even if its extension is not .mli.</source>
          <target state="translated">将文件名编译为接口文件,即使其扩展名不是.mli。</target>
        </trans-unit>
        <trans-unit id="299b080c443dece1ea245d410a53d3e92be360bb" translate="yes" xml:space="preserve">
          <source>Compiled bytecode files (.cmo files), on the other hand, can be freely renamed once created. That&amp;rsquo;s because the linker never attempts to find by itself the .cmo file that implements a module with a given name: it relies instead on the user providing the list of .cmo files by hand.</source>
          <target state="translated">另一方面，编译后的字节码文件（.cmo文件）一旦创建便可以自由重命名。这是因为链接器从不尝试自行查找实现具有给定名称的模块的.cmo文件：而是依靠用户手动提供.cmo文件列表。</target>
        </trans-unit>
        <trans-unit id="c8d36c73ee25d65a59259585e736e00c1c87f0a3" translate="yes" xml:space="preserve">
          <source>Compiler options</source>
          <target state="translated">编译器选项</target>
        </trans-unit>
        <trans-unit id="17d018534cc6444c276f058ff3cb2e0e87d24e89" translate="yes" xml:space="preserve">
          <source>Compiling with -g entails no penalty on the running time of programs: object files and bytecode executable files are bigger and take longer to produce, but the executable files run at exactly the same speed as if they had been compiled without -g.</source>
          <target state="translated">使用-g编译不会对程序的运行时间造成任何影响:对象文件和字节码可执行文件的体积更大,制作时间更长,但可执行文件的运行速度与不使用-g编译的速度完全相同。</target>
        </trans-unit>
        <trans-unit id="10b26b96b1c573965f14a325ef88109f84be8e3b" translate="yes" xml:space="preserve">
          <source>Complex</source>
          <target state="translated">Complex</target>
        </trans-unit>
        <trans-unit id="7611b3d644720e341343c4b145fe3d01e8fd3e09" translate="yes" xml:space="preserve">
          <source>Complex numbers.</source>
          <target state="translated">复数。</target>
        </trans-unit>
        <trans-unit id="a41458c6695371dbb3a5a9986252d1ee23df137d" translate="yes" xml:space="preserve">
          <source>Composition operators</source>
          <target state="translated">组成运算符</target>
        </trans-unit>
        <trans-unit id="ae0f112d5883b3ed0b4cd635980e9b3e4954b4d1" translate="yes" xml:space="preserve">
          <source>Computation of compaction-triggering condition.</source>
          <target state="translated">压实触发条件的计算。</target>
        </trans-unit>
        <trans-unit id="d679feceea0c84fcb7b9d34d0e5bd48c86acaa87" translate="yes" xml:space="preserve">
          <source>Computation of major GC slice size.</source>
          <target state="translated">计算主要GC切片大小。</target>
        </trans-unit>
        <trans-unit id="1ead95ccbb832522b24581d6c389102a9d297f79" translate="yes" xml:space="preserve">
          <source>Compute dependencies, as the ocamldep command would do. The remaining arguments are interpreted as if they were given to the ocamldep command.</source>
          <target state="translated">计算依赖关系,就像ocamldep命令一样。其余的参数就像给ocamldep命令的参数一样被解释。</target>
        </trans-unit>
        <trans-unit id="3fd62d65b81816c32e4d92808204724e2d5c82fc" translate="yes" xml:space="preserve">
          <source>Computes the total size (in words, including the headers) of all heap blocks accessible from the argument.</source>
          <target state="translated">计算从参数中可以访问的所有堆块的总大小(字数,包括头)。</target>
        </trans-unit>
        <trans-unit id="5718bb8824710b28ce5338ee7ce5bfcd6f17e232" translate="yes" xml:space="preserve">
          <source>Computes the total size (in words, including the headers) of all heap blocks accessible from the argument. Statically allocated blocks are excluded, unless the runtime system was configured with &lt;code&gt;--disable-naked-pointers&lt;/code&gt;.</source>
          <target state="translated">计算可从参数访问的所有堆块的总大小（以字为单位，包括标头）。除非为运行时系统配置了 &lt;code&gt;--disable-naked-pointers&lt;/code&gt; ，否则将排除静态分配的块。</target>
        </trans-unit>
        <trans-unit id="518143af77e23baf0875a2af2ee9be3bba904a09" translate="yes" xml:space="preserve">
          <source>Computes the total size (in words, including the headers) of all heap blocks accessible from the argument. Statically allocated blocks are excluded.</source>
          <target state="translated">计算从参数访问的所有堆块的总大小(以字数计,包括头)。不包括静态分配的块。</target>
        </trans-unit>
        <trans-unit id="7e753af33c5e8b0b810748b18ff7f60b83d5a7d0" translate="yes" xml:space="preserve">
          <source>Concatenate a list of lists.</source>
          <target state="translated">连接一个列表。</target>
        </trans-unit>
        <trans-unit id="c4261005ac92aba9c70cd9071850bc5e978c5334" translate="yes" xml:space="preserve">
          <source>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</source>
          <target state="translated">连接一个列表。参数中的元素都被连接在一起(以相同的顺序),得到结果。不是递归尾数(参数长度+最长子列表的长度)。</target>
        </trans-unit>
        <trans-unit id="c21ae36c663b5598bb7f776455d5f7afa5edba88" translate="yes" xml:space="preserve">
          <source>Concatenate two lists.</source>
          <target state="translated">将两张清单连接起来。</target>
        </trans-unit>
        <trans-unit id="cf199bfa330ffd5961a47d9da430fec2620a9ae5" translate="yes" xml:space="preserve">
          <source>Concatenate two lists. Same as the infix operator &lt;code&gt;@&lt;/code&gt;. Not tail-recursive (length of the first argument).</source>
          <target state="translated">连接两个列表。与中缀运算符 &lt;code&gt;@&lt;/code&gt; 相同。不是尾递归的（第一个参数的长度）。</target>
        </trans-unit>
        <trans-unit id="faf25fef3241f98ca3648c022c1a11bb26299294" translate="yes" xml:space="preserve">
          <source>Concatenate two lists. Same function as the infix operator &lt;code&gt;@&lt;/code&gt;. Not tail-recursive (length of the first argument). The &lt;code&gt;@&lt;/code&gt; operator is not tail-recursive either.</source>
          <target state="translated">连接两个列表。与infix运算符 &lt;code&gt;@&lt;/code&gt; 的功能相同。不是尾递归的（第一个参数的长度）。该 &lt;code&gt;@&lt;/code&gt; 算不算尾递归无论是。</target>
        </trans-unit>
        <trans-unit id="f89ea4ef09331b71614569a09d9aca4399b964ed" translate="yes" xml:space="preserve">
          <source>Concatenating</source>
          <target state="translated">Concatenating</target>
        </trans-unit>
        <trans-unit id="1119e8da11a04af6ca0a753792995fcee08b2edc" translate="yes" xml:space="preserve">
          <source>Concatenating its elements using &lt;code&gt;sep&lt;/code&gt; as a separator returns a string equal to the input (&lt;code&gt;String.concat&amp;nbsp;(String.make&amp;nbsp;1&amp;nbsp;sep)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(String.split_on_char&amp;nbsp;sep&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt;).</source>
          <target state="translated">使用 &lt;code&gt;sep&lt;/code&gt; 作为分隔符连接其元素将返回一个等于输入的字符串（ &lt;code&gt;String.concat&amp;nbsp;(String.make&amp;nbsp;1&amp;nbsp;sep)&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(String.split_on_char&amp;nbsp;sep&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="88a1fbc05b9b989f35a41bfe1ac89bbcd068151f" translate="yes" xml:space="preserve">
          <source>Concatenating its elements using &lt;code&gt;sep&lt;/code&gt; as a separator returns a string equal to the input (&lt;code&gt;concat&amp;nbsp;(make&amp;nbsp;1&amp;nbsp;sep)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(split_on_char&amp;nbsp;sep&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt;).</source>
          <target state="translated">使用 &lt;code&gt;sep&lt;/code&gt; 作为分隔符连接其元素将返回一个等于输入的字符串（ &lt;code&gt;concat&amp;nbsp;(make&amp;nbsp;1&amp;nbsp;sep)&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(split_on_char&amp;nbsp;sep&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="61ff79974f16dba8d693a91da2e607160a4f439a" translate="yes" xml:space="preserve">
          <source>Concerning the precedences of operators, # has the highest precedence, followed by *, + and ?, then concatenation, then | (alternation), then as.</source>
          <target state="translated">关于运算符的优先级,#的优先级最高,其次是*、+和?,然后是连词,然后是|(交替),然后是as。</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="ae369e3bb89711211abac6ae92d6ff255dbe265e" translate="yes" xml:space="preserve">
          <source>Condition variables are used when one thread wants to wait until another thread has finished doing something: the former thread 'waits' on the condition variable, the latter thread 'signals' the condition when it is done. Condition variables should always be protected by a mutex. The typical use is (if &lt;code&gt;D&lt;/code&gt; is a shared data structure, &lt;code&gt;m&lt;/code&gt; its mutex, and &lt;code&gt;c&lt;/code&gt; is a condition variable):</source>
          <target state="translated">当一个线程想要等待另一线程完成某项操作时使用条件变量：前一个线程在条件变量上&amp;ldquo;等待&amp;rdquo;，而后一个线程在完成条件时&amp;ldquo;通知&amp;rdquo;条件。条件变量应始终由互斥体保护。典型用途是（如果 &lt;code&gt;D&lt;/code&gt; 是一个共享的数据结构， &lt;code&gt;m&lt;/code&gt; 其互斥，并且 &lt;code&gt;c&lt;/code&gt; 是一个条件变量）：</target>
        </trans-unit>
        <trans-unit id="3c9f5175bc76dab872dcca0a8f4945ab47e57882" translate="yes" xml:space="preserve">
          <source>Condition variables to synchronize between threads.</source>
          <target state="translated">线程间同步的条件变量。</target>
        </trans-unit>
        <trans-unit id="fee141f68e4704140703200ef223fa3472ef6c33" translate="yes" xml:space="preserve">
          <source>Conjugate: given the complex &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;x&amp;nbsp;-&amp;nbsp;i.y&lt;/code&gt;.</source>
          <target state="translated">共轭：给定复数 &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; ，返回 &lt;code&gt;x&amp;nbsp;-&amp;nbsp;i.y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8479889b89034bc022c57bd8893185ae0364f595" translate="yes" xml:space="preserve">
          <source>Connect a socket to an address.</source>
          <target state="translated">将一个插座连接到一个地址。</target>
        </trans-unit>
        <trans-unit id="b06164f137b6b54ef3d5592c316dbf54c71cfc6d" translate="yes" xml:space="preserve">
          <source>Connect to a server at the given address.</source>
          <target state="translated">连接到给定地址的服务器。</target>
        </trans-unit>
        <trans-unit id="80bf1adde48d120cd79946b31d85d02da38b97cb" translate="yes" xml:space="preserve">
          <source>Connect to a server at the given address. Return a pair of buffered channels connected to the server. Remember to call &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; on the output channel at the right times to ensure correct synchronization.</source>
          <target state="translated">连接到给定地址的服务器。返回连接到服务器的一对缓冲通道。请记住在正确的时间在输出通道上调用&lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;，以确保正确的同步。</target>
        </trans-unit>
        <trans-unit id="96f7e671b1e48da4a2700769f8225126847b97cf" translate="yes" xml:space="preserve">
          <source>Connection refused</source>
          <target state="translated">拒绝连接</target>
        </trans-unit>
        <trans-unit id="2986a51d253e6221052722aab2efbc181246b417" translate="yes" xml:space="preserve">
          <source>Connection reset by peer</source>
          <target state="translated">连接被对等体重置</target>
        </trans-unit>
        <trans-unit id="52c871ea22dada6554a1363ee61f9567c44efd80" translate="yes" xml:space="preserve">
          <source>Connection timed out</source>
          <target state="translated">连接超时</target>
        </trans-unit>
        <trans-unit id="8f72e1d193c8d460ed969566e06ff72f178f5e73" translate="yes" xml:space="preserve">
          <source>Consider an OCaml interface to the standard libz C library for reading and writing compressed files. Assume this library resides in /usr/local/zlib. This interface is composed of an OCaml part zip.cmo/zip.cmx and a C part zipstubs.o containing the stub code around the libz entry points. The following command builds the OCaml libraries zip.cma and zip.cmxa, as well as the companion C libraries dllzip.so and libzip.a:</source>
          <target state="translated">考虑为标准libz C库提供一个OCaml接口,用于读写压缩文件。假设这个库位于/usr/local/zlib中。这个接口由一个OCaml部分zip.cmo/zip.cmx和一个C部分zipstubs.o组成,其中包含libz入口点周围的存根代码。下面的命令构建了 OCaml 库 zip.cma 和 zip.cmxa,以及配套的 C 库 dllzip.so 和 libzip.a。</target>
        </trans-unit>
        <trans-unit id="f229a35ad8b444a6b385bd0bbc84911cc773a8ae" translate="yes" xml:space="preserve">
          <source>Consider the given extension (with leading dot) to be a synonym for .ml.</source>
          <target state="translated">将给定的扩展名(带前点)视为.ml的同义词。</target>
        </trans-unit>
        <trans-unit id="2f60faccd60355e261afc4acf9b9359997518724" translate="yes" xml:space="preserve">
          <source>Consider the given extension (with leading dot) to be a synonym for .mli.</source>
          <target state="translated">将给定的扩展名(带前导点)视为.mli的同义词。</target>
        </trans-unit>
        <trans-unit id="e850dfc5bd591d629fab1f8c55c2012ff29b5daf" translate="yes" xml:space="preserve">
          <source>Consider the service as UDP-based instead of the default TCP</source>
          <target state="translated">将服务视为基于UDP的服务,而不是默认的TCP。</target>
        </trans-unit>
        <trans-unit id="733fd2b4c4e1bca4c7d0e3c2e1c341bcd1d34269" translate="yes" xml:space="preserve">
          <source>Constant</source>
          <target state="translated">Constant</target>
        </trans-unit>
        <trans-unit id="adcae46226442190d49d512a839dba8c470eb3cd" translate="yes" xml:space="preserve">
          <source>Constant closure</source>
          <target state="translated">持续关闭</target>
        </trans-unit>
        <trans-unit id="5b2ef079e6ae98b281f8cdb764b9043d153c622f" translate="yes" xml:space="preserve">
          <source>Constant float arrays at the toplevel are mutable and never shared. (That is to say, for each such definition there is a distinct symbol in the data section of the object file pointing at the array.)</source>
          <target state="translated">顶层的恒定浮点数组是可变的,从不共享。也就是说,对于每一个这样的定义,在对象文件的数据部分都有一个指向数组的单独符号。</target>
        </trans-unit>
        <trans-unit id="091bc5369699349a2b7818b4093bfda40449b4e6" translate="yes" xml:space="preserve">
          <source>Constant float arrays not at toplevel are mutable and are created each time the expression is evaluated. This can be thought of as an operation that takes an immutable array (which in the source code has no associated name; let us call it the &lt;em&gt;initialising array&lt;/em&gt;) and duplicates it into a fresh mutable array.</source>
          <target state="translated">不在顶层的常量浮点数组是可变的，并且在每次对表达式求值时都会创建。可以认为这是一个采用不可变数组（在源代码中没有关联名称；让我们将其称为&lt;em&gt;Initializing array&lt;/em&gt;）并将其复制到新的可变数组中的操作。</target>
        </trans-unit>
        <trans-unit id="df73dfd589730df5a6d45da4297228a1572f788f" translate="yes" xml:space="preserve">
          <source>Constraints are added left to right. After each constraint has been applied, the resulting signature must be a subtype of the signature before the constraint was applied. Thus, the with operator can only add information on the type components of a signature, but never remove information.</source>
          <target state="translated">约束从左到右添加。在每个约束条件被应用后,所产生的签名必须是应用约束条件之前的签名的子类型。因此,with运算符只能添加签名的类型成分信息,但决不能删除信息。</target>
        </trans-unit>
        <trans-unit id="b1e8eac434f49462f355fa784ffa70e49747333e" translate="yes" xml:space="preserve">
          <source>Construct the lexer function.</source>
          <target state="translated">构造词条函数。</target>
        </trans-unit>
        <trans-unit id="a061bb0abb78e79e2f6fd7d764e9b588faff175a" translate="yes" xml:space="preserve">
          <source>Construct the lexer function. The first argument is the list of keywords. An identifier &lt;code&gt;s&lt;/code&gt; is returned as &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; belongs to this list, and as &lt;code&gt;Ident&amp;nbsp;s&lt;/code&gt; otherwise. A special character &lt;code&gt;s&lt;/code&gt; is returned as &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; belongs to this list, and cause a lexical error (exception &lt;a href=&quot;stream#EXCEPTIONError&quot;&gt;&lt;code&gt;Stream.Error&lt;/code&gt;&lt;/a&gt; with the offending lexeme as its parameter) otherwise. Blanks and newlines are skipped. Comments delimited by &lt;code&gt;(*&lt;/code&gt; and &lt;code&gt;*)&lt;/code&gt; are skipped as well, and can be nested. A &lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt;&lt;code&gt;Stream.Failure&lt;/code&gt;&lt;/a&gt; exception is raised if end of stream is unexpectedly reached.</source>
          <target state="translated">构造词法分析器功能。第一个参数是关键字列表。如果 &lt;code&gt;s&lt;/code&gt; 属于此列表，则返回标识符 &lt;code&gt;s&lt;/code&gt; 作为 &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; ，否则返回 &lt;code&gt;Ident&amp;nbsp;s&lt;/code&gt; 。如果 &lt;code&gt;s&lt;/code&gt; 属于此列表， &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 形式返回特殊字符s，否则会导致词法错误（异常&lt;a href=&quot;stream#EXCEPTIONError&quot;&gt; &lt;code&gt;Stream.Error&lt;/code&gt; &lt;/a&gt;，以令人讨厌的lexeme作为其参数）。空格和换行符将被跳过。以 &lt;code&gt;(*&lt;/code&gt; 和 &lt;code&gt;*)&lt;/code&gt; 分隔的注释也将被跳过，并且可以嵌套。一个&lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt; &lt;code&gt;Stream.Failure&lt;/code&gt; &lt;/a&gt;如果意外到达流的末尾异常。</target>
        </trans-unit>
        <trans-unit id="88ce4c1c12e94557da36c6eead56b4b8c0febfb9" translate="yes" xml:space="preserve">
          <source>Constructed term</source>
          <target state="translated">构造用语</target>
        </trans-unit>
        <trans-unit id="ecff4df31a7f2f32be511ceea60554afcb2a1798" translate="yes" xml:space="preserve">
          <source>Constructed terms are represented either by unboxed integers (for constant constructors) or by blocks whose tag encode the constructor (for non-constant constructors). The constant constructors and the non-constant constructors for a given concrete type are numbered separately, starting from 0, in the order in which they appear in the concrete type declaration. A constant constructor is represented by the unboxed integer equal to its constructor number. A non-constant constructor declared with n arguments is represented by a block of size n, tagged with the constructor number; the n fields contain its arguments. Example:</source>
          <target state="translated">构造项可以用未装箱的整数表示(对于常量构造项),也可以用标记编码构造项的块表示(对于非常量构造项)。给定具体类型的常量构造函数和非常量构造函数按照它们在具体类型声明中出现的顺序,从0开始分别编号。一个常量构造函数由等于其构造函数编号的未装箱整数表示。一个声明了n个参数的非常量构造函数用一个大小为n的块来表示,块上标有构造函数的编号;n个字段包含了它的参数。例子</target>
        </trans-unit>
        <trans-unit id="33c0fcb39098c99481dbabaef595556e1d6382af" translate="yes" xml:space="preserve">
          <source>Construction or operator</source>
          <target state="translated">建筑商或经营者</target>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="4dcc0e86f7ec49506f86ec0239fe32f8d5ecfc33" translate="yes" xml:space="preserve">
          <source>Constructor application, Tag application</source>
          <target state="translated">构造函数应用,标签应用</target>
        </trans-unit>
        <trans-unit id="a57a499db413be645296d9a22122e646866b53d6" translate="yes" xml:space="preserve">
          <source>Constructor or label name used out of scope.</source>
          <target state="translated">在范围外使用的构造函数或标签名称。</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="b1aff6232fa572c823b5ca4e0a0129e7ab716449" translate="yes" xml:space="preserve">
          <source>Consult the &lt;em&gt;Glossary&lt;/em&gt; at the end of this chapter for definitions of technical terms used below.</source>
          <target state="translated">有关以下使用的技术术语的定义，请参阅本章末尾的&lt;em&gt;术语表&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="4dfc2782cd72d273592670acab33392686fa763f" translate="yes" xml:space="preserve">
          <source>Contents of the block</source>
          <target state="translated">块的内容</target>
        </trans-unit>
        <trans-unit id="7ef50d03cf1626a58aa34b0e16915da06db0ad2e" translate="yes" xml:space="preserve">
          <source>Contextual control of command-line options</source>
          <target state="translated">命令行选项的上下文控制</target>
        </trans-unit>
        <trans-unit id="2e02623966f9391facf6eaefc8b079ed5b630bee" translate="yes" xml:space="preserve">
          <source>Continue</source>
          <target state="translated">Continue</target>
        </trans-unit>
        <trans-unit id="a5765b37016775dde6c6f0a25c6231ac5868c966" translate="yes" xml:space="preserve">
          <source>Contrarily, if we have a function that can handle values of type xy</source>
          <target state="translated">相反,如果我们有一个函数,可以处理类型为xy的值</target>
        </trans-unit>
        <trans-unit id="44e574919fb4b279c4aa016ee88a030406704659" translate="yes" xml:space="preserve">
          <source>Control debugging support for &lt;code&gt;ocamlyacc&lt;/code&gt;-generated parsers.</source>
          <target state="translated">控制对 &lt;code&gt;ocamlyacc&lt;/code&gt; 生成的解析器的调试支持。</target>
        </trans-unit>
        <trans-unit id="ea8016b69c5c63c94758b8d9afd091d63f269088" translate="yes" xml:space="preserve">
          <source>Control debugging support for &lt;code&gt;ocamlyacc&lt;/code&gt;-generated parsers. After &lt;code&gt;Parsing.set_trace&amp;nbsp;true&lt;/code&gt;, the pushdown automaton that executes the parsers prints a trace of its actions (reading a token, shifting a state, reducing by a rule) on standard output. &lt;code&gt;Parsing.set_trace&amp;nbsp;false&lt;/code&gt; turns this debugging trace off. The boolean returned is the previous state of the trace flag.</source>
          <target state="translated">控制对 &lt;code&gt;ocamlyacc&lt;/code&gt; 生成的解析器的调试支持。在 &lt;code&gt;Parsing.set_trace&amp;nbsp;true&lt;/code&gt; 之后，执行解析器的下推自动机会在标准输出上显示其动作的痕迹（读取令牌，转移状态，按规则减少）。 &lt;code&gt;Parsing.set_trace&amp;nbsp;false&lt;/code&gt; 将关闭此调试跟踪。返回的布尔值是跟踪标志的先前状态。</target>
        </trans-unit>
        <trans-unit id="a581af7c17aaf436ca9b9d0b8cc4b52024e23c6c" translate="yes" xml:space="preserve">
          <source>Control the Nagle algorithm for TCP sockets</source>
          <target state="translated">控制TCP套接字的Nagle算法</target>
        </trans-unit>
        <trans-unit id="01f6ce64b088c1d86a1cc628890b28def1724c57" translate="yes" xml:space="preserve">
          <source>Control the way error messages and warnings are printed. The following modes are supported:</source>
          <target state="translated">控制错误信息和警告的打印方式。支持以下模式:</target>
        </trans-unit>
        <trans-unit id="c54c927dcfd25ea6169be951e934da94f9e3db5c" translate="yes" xml:space="preserve">
          <source>Control whether the OCaml runtime system can emit warnings on stderr.</source>
          <target state="translated">控制 OCaml 运行时系统是否可以在 stderr 上发出警告。</target>
        </trans-unit>
        <trans-unit id="158cedb78544ff7bbffffff2c57e102bc5772791" translate="yes" xml:space="preserve">
          <source>Control whether the OCaml runtime system can emit warnings on stderr. Currently, the only supported warning is triggered when a channel created by &lt;code&gt;open_*&lt;/code&gt; functions is finalized without being closed. Runtime warnings are disabled by default.</source>
          <target state="translated">控制OCaml运行时系统是否可以在stderr上发出警告。当前，由 &lt;code&gt;open_*&lt;/code&gt; 函数创建的通道在未关闭的情况下完成时会触发唯一受支持的警告。默认情况下，运行时警告是禁用的。</target>
        </trans-unit>
        <trans-unit id="60df4ef37e363b7e927a63a861aa42ec8b55d7e9" translate="yes" xml:space="preserve">
          <source>Controlling which alerts are enabled and whether they are turned into fatal errors is done either through the compiler&amp;rsquo;s command-line option -alert &amp;lt;spec&amp;gt; or locally in the code through the alert or ocaml.alert attribute taking a single string payload &amp;lt;spec&amp;gt;. In both cases, the syntax for &amp;lt;spec&amp;gt; is a concatenation of items of the form:</source>
          <target state="translated">通过编译器的命令行选项-alert &amp;lt;spec&amp;gt;或通过使用单个字符串有效负载&amp;lt;spec&amp;gt;的alert或ocaml.alert属性在代码中本地控制启用了哪些警报以及是否将它们变成致命错误。在这两种情况下，&amp;lt;spec&amp;gt;的语法都是以下形式的项目的串联：</target>
        </trans-unit>
        <trans-unit id="a27bd30c8a3cfdf8bc8497766a3785c2b06c9875" translate="yes" xml:space="preserve">
          <source>Controls how the inliner assesses the runtime performance penalties associated with various operations. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;19.3.5&lt;/a&gt;.</source>
          <target state="translated">控制内联程序如何评估与各种操作关联的运行时性能损失。参见第&lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;19.3.5&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="933cc834a01ad3244115777194487cf144f0ecdd" translate="yes" xml:space="preserve">
          <source>Controls how the inliner assesses the runtime performance penalties associated with various operations. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="translated">控制内联程序如何评估与各种操作关联的运行时性能损失。参见第&lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="75aaa84728a9d0e45f295668f69d86480d912128" translate="yes" xml:space="preserve">
          <source>Controls how the inliner assesses whether a code path is likely to be hot or cold. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;19.3.5&lt;/a&gt;.</source>
          <target state="translated">控制内联程序如何评估代码路径可能是热还是冷。参见第&lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;19.3.5&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="b21ecd4fcc9a8d4ea30185fe486acd99672a553f" translate="yes" xml:space="preserve">
          <source>Controls how the inliner assesses whether a code path is likely to be hot or cold. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="translated">控制内联程序如何评估代码路径可能是热还是冷。参见第&lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="24a02efb8a5b050939ea8c3a78dbf3643f0a8826" translate="yes" xml:space="preserve">
          <source>Controls inlining of functors at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;19.3.5&lt;/a&gt;.</source>
          <target state="translated">在顶层控制函子的内联。参见第&lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;19.3.5&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="e9fa7a499f4a55d9e4e13932642f1433a08a09c0" translate="yes" xml:space="preserve">
          <source>Controls inlining of functors at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="translated">在顶层控制函子的内联。参见第&lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="293ff2efcde405fd53b38d3396adbe0390c9bd33" translate="yes" xml:space="preserve">
          <source>Convenience formatting functions.</source>
          <target state="translated">方便的格式化功能。</target>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="5cd6a9211102cdfa59a068840e929afa53f5eabc" translate="yes" xml:space="preserve">
          <source>Conversely, the module expression (val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) evaluates the core language expression &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; to a value, which must have type module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;, and extracts the module that was encapsulated in this value. Again &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; can be omitted if the type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is known. If the module expression is already parenthesized, like the arguments of functors are, no additional parens are needed: Map.Make(val key).</source>
          <target state="translated">相反，模块表达式（val &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）将核心语言表达式&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;评估为一个值，该值必须具有module &lt;a href=&quot;#package-type&quot;&gt;package-type类型&lt;/a&gt;，并提取封装在该值中的模块。同样，如果知道&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;的类型，可以省略&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;。如果模块表达式已经被括号括起来，就像函子的参数一样，则不需要额外的括号：Map.Make（val key）。</target>
        </trans-unit>
        <trans-unit id="c76f66df18ce8edc9efd1881966c3c39e47be201" translate="yes" xml:space="preserve">
          <source>Conversely, whitespace or special shell characters occurring in command names or in their arguments must be quoted or escaped so that the shell does not interpret them. The quoting rules vary between the POSIX shell and the Windows shell. The &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; performs the appropriate quoting given a command name, a list of arguments, and optional file redirections.</source>
          <target state="translated">相反，在命令名或其参数中出现的空格或特殊shell字符必须加引号或转义，以使shell不能解释它们。引用规则在POSIX Shell和Windows Shell之间有所不同。该&lt;a href=&quot;filename#VALquote_command&quot;&gt; &lt;code&gt;Filename.quote_command&lt;/code&gt; &lt;/a&gt;执行相应的引用给定的命令名称，参数列表，以及可选的文件重定向。</target>
        </trans-unit>
        <trans-unit id="6a64eefe7afd3acbb2a3fcb4bbbe7751fd9c8af3" translate="yes" xml:space="preserve">
          <source>Conversion from functions with default values to functions with patterns only works identically for class functions as for normal functions.</source>
          <target state="translated">从带有缺省值的函数转换到带有模式的函数,只有类函数和普通函数的转换效果相同。</target>
        </trans-unit>
        <trans-unit id="e91ad5abdc78b39b4ce92904e5396ec1f786248c" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation.</source>
          <target state="translated">将因特网地址的可打印表示转换为其内部表示。</target>
        </trans-unit>
        <trans-unit id="92b79bd86888a46b8955becf95db977c77d0ac25" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation. The argument string consists of 4 numbers separated by periods (&lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt;) for IPv4 addresses, and up to 8 numbers separated by colons for IPv6 addresses.</source>
          <target state="translated">从Internet地址的可打印表示形式到其内部表示形式的转换。对于IPv4地址，参数字符串包含4个数字，中间用句点（ &lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt; ）分隔，对于IPv6地址，该参数字符串最多包含8个数字，中间用冒号分隔。</target>
        </trans-unit>
        <trans-unit id="85ea1a5bd106d39445b87322996d86ec7c632630" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation. The argument string consists of 4 numbers separated by periods (&lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt;) for IPv4 addresses, and up to 8 numbers separated by colons for IPv6 addresses. Raise &lt;code&gt;Failure&lt;/code&gt; when given a string that does not match these formats.</source>
          <target state="translated">从Internet地址的可打印表示形式到其内部表示形式的转换。对于IPv4地址，参数字符串包含4个数字，中间用句点（ &lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt; ）分隔，对于IPv6地址，该参数字符串最多包含8个数字，中间用冒号分隔。 &lt;code&gt;Failure&lt;/code&gt; 给定的字符串与这些格式不匹配，则会引发失败。</target>
        </trans-unit>
        <trans-unit id="7d97210aeab0bd3ebce234df3ec8fe7e4a70ca7f" translate="yes" xml:space="preserve">
          <source>Conversion specifications consist in the &lt;code&gt;%&lt;/code&gt; character, followed by an optional flag, an optional field width, and followed by one or two conversion characters.</source>
          <target state="translated">转换规范包含 &lt;code&gt;%&lt;/code&gt; 字符，后跟一个可选标志，一个可选字段宽度，以及一个或两个转换字符。</target>
        </trans-unit>
        <trans-unit id="ab980193d03ab0985dd1b4bc77c12b22e232db45" translate="yes" xml:space="preserve">
          <source>Conversion specifications have the following form:</source>
          <target state="translated">转换规格有以下形式:</target>
        </trans-unit>
        <trans-unit id="8c06747952c1535df9eef8f493a0e2f59c85b975" translate="yes" xml:space="preserve">
          <source>Conversion specifications in format strings</source>
          <target state="translated">格式字符串的转换规格</target>
        </trans-unit>
        <trans-unit id="c1c32e11691d111083462c54b49004696a9a09d1" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;tm&lt;/code&gt; 参数指定的日期和时间转换为&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间。</target>
        </trans-unit>
        <trans-unit id="c792e891ce8ae61fdaebbd94276bd3662c41af32" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;tm_isdst&lt;/code&gt;, &lt;code&gt;tm_wday&lt;/code&gt; and &lt;code&gt;tm_yday&lt;/code&gt; fields of &lt;code&gt;tm&lt;/code&gt; are ignored. Also return a normalized copy of the given &lt;code&gt;tm&lt;/code&gt; record, with the &lt;code&gt;tm_wday&lt;/code&gt;, &lt;code&gt;tm_yday&lt;/code&gt;, and &lt;code&gt;tm_isdst&lt;/code&gt; fields recomputed from the other fields, and the other fields normalized (so that, e.g., 40 October is changed into 9 November). The &lt;code&gt;tm&lt;/code&gt; argument is interpreted in the local time zone.</source>
          <target state="translated">将 &lt;code&gt;tm&lt;/code&gt; 参数指定的日期和时间转换为&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间。 &lt;code&gt;tm&lt;/code&gt; 的 &lt;code&gt;tm_isdst&lt;/code&gt; ， &lt;code&gt;tm_wday&lt;/code&gt; 和 &lt;code&gt;tm_yday&lt;/code&gt; 字段将被忽略。还返回给定 &lt;code&gt;tm&lt;/code&gt; 记录的规范化副本，其中 &lt;code&gt;tm_wday&lt;/code&gt; ， &lt;code&gt;tm_yday&lt;/code&gt; 和 &lt;code&gt;tm_isdst&lt;/code&gt; 字段是从其他字段重新计算的，而其他字段则经过规范化（因此，例如10月40日更改为11月9日）。该 &lt;code&gt;tm&lt;/code&gt; 参数被解释在本地时区。</target>
        </trans-unit>
        <trans-unit id="166e14cf3638ad0b673e006de2b94c19860f26cb" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;tm&lt;/code&gt; 参数指定的日期和时间转换为&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间。</target>
        </trans-unit>
        <trans-unit id="7836de995e3285dfa0c8406853b5347a044422f1" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;tm_isdst&lt;/code&gt;, &lt;code&gt;tm_wday&lt;/code&gt; and &lt;code&gt;tm_yday&lt;/code&gt; fields of &lt;code&gt;tm&lt;/code&gt; are ignored. Also return a normalized copy of the given &lt;code&gt;tm&lt;/code&gt; record, with the &lt;code&gt;tm_wday&lt;/code&gt;, &lt;code&gt;tm_yday&lt;/code&gt;, and &lt;code&gt;tm_isdst&lt;/code&gt; fields recomputed from the other fields, and the other fields normalized (so that, e.g., 40 October is changed into 9 November). The &lt;code&gt;tm&lt;/code&gt; argument is interpreted in the local time zone.</source>
          <target state="translated">将 &lt;code&gt;tm&lt;/code&gt; 参数指定的日期和时间转换为&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间。 &lt;code&gt;tm&lt;/code&gt; 的 &lt;code&gt;tm_isdst&lt;/code&gt; ， &lt;code&gt;tm_wday&lt;/code&gt; 和 &lt;code&gt;tm_yday&lt;/code&gt; 字段将被忽略。还返回给定 &lt;code&gt;tm&lt;/code&gt; 记录的规范化副本，其中 &lt;code&gt;tm_wday&lt;/code&gt; ， &lt;code&gt;tm_yday&lt;/code&gt; 和 &lt;code&gt;tm_isdst&lt;/code&gt; 字段是从其他字段重新计算的，而其他字段则经过规范化（因此，例如10月40日更改为11月9日）。该 &lt;code&gt;tm&lt;/code&gt; 参数被解释在本地时区。</target>
        </trans-unit>
        <trans-unit id="b9ed34778c74b1876e28a09ef2bb4037d0b1602b" translate="yes" xml:space="preserve">
          <source>Convert a hexadecimal representation back into the corresponding digest.</source>
          <target state="translated">将十六进制表示法转换回相应的摘要。</target>
        </trans-unit>
        <trans-unit id="80ace682affc7ecae8d4105bd127d456bb9e4912" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time.</source>
          <target state="translated">将&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间转换为日期和时间。</target>
        </trans-unit>
        <trans-unit id="2edee9666a075f72e6c7a588f50ef593d07338fc" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT. To perform the inverse conversion, set the TZ environment variable to &quot;UTC&quot;, use &lt;a href=&quot;unix#VALmktime&quot;&gt;&lt;code&gt;Unix.mktime&lt;/code&gt;&lt;/a&gt;, and then restore the original value of TZ.</source>
          <target state="translated">将&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间转换为日期和时间。假定UTC（世界标准时间），也称为GMT。要执行逆转换，请将TZ环境变量设置为&amp;ldquo; UTC&amp;rdquo;，使用&lt;a href=&quot;unix#VALmktime&quot;&gt; &lt;code&gt;Unix.mktime&lt;/code&gt; &lt;/a&gt;，然后恢复TZ的原始值。</target>
        </trans-unit>
        <trans-unit id="f5a03657cb3a62a7760f59bceeacb0c77fd66446" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes the local time zone. The function performing the inverse conversion is &lt;a href=&quot;unix#VALmktime&quot;&gt;&lt;code&gt;Unix.mktime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间转换为日期和时间。假定本地时区。执行逆转换的函数是&lt;a href=&quot;unix#VALmktime&quot;&gt; &lt;code&gt;Unix.mktime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2bc9a0b90092a31e3fd77ab9bbe39a71117dbb38" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time.</source>
          <target state="translated">将&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间转换为日期和时间。</target>
        </trans-unit>
        <trans-unit id="aeb5627989cc9828b7f0b2b5062d617c78dd2e67" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT.</source>
          <target state="translated">将&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间转换为日期和时间。假定UTC（世界标准时间），也称为GMT。</target>
        </trans-unit>
        <trans-unit id="64970ff849dd9e285a5926eb98b0a4ea8054603f" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT. To perform the inverse conversion, set the TZ environment variable to &quot;UTC&quot;, use &lt;a href=&quot;unixlabels#VALmktime&quot;&gt;&lt;code&gt;UnixLabels.mktime&lt;/code&gt;&lt;/a&gt;, and then restore the original value of TZ.</source>
          <target state="translated">将&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间转换为日期和时间。假定UTC（世界标准时间），也称为GMT。要执行逆转换，请将TZ环境变量设置为&amp;ldquo; UTC&amp;rdquo;，使用&lt;a href=&quot;unixlabels#VALmktime&quot;&gt; &lt;code&gt;UnixLabels.mktime&lt;/code&gt; &lt;/a&gt;，然后恢复TZ的原始值。</target>
        </trans-unit>
        <trans-unit id="4e49f724bd9a1b75ab1bd5c379646f6a4ff69bc3" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes the local time zone.</source>
          <target state="translated">将&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间转换为日期和时间。假定本地时区。</target>
        </trans-unit>
        <trans-unit id="470addcc71929fcb5399d615ddd88b1fc1a3c6ea" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes the local time zone. The function performing the inverse conversion is &lt;a href=&quot;unixlabels#VALmktime&quot;&gt;&lt;code&gt;UnixLabels.mktime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt;返回的以秒为单位的时间转换为日期和时间。假定本地时区。执行逆转换的函数是&lt;a href=&quot;unixlabels#VALmktime&quot;&gt; &lt;code&gt;UnixLabels.mktime&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f93ecd2ce5ab11da436caae653e82540aed74786" translate="yes" xml:space="preserve">
          <source>Convert an error description to a printable message.</source>
          <target state="translated">将错误描述转换为可打印的信息。</target>
        </trans-unit>
        <trans-unit id="03cb0b9780f37bd211d882819f132343734c8465" translate="yes" xml:space="preserve">
          <source>Convert an integer to floating-point.</source>
          <target state="translated">将整数转换为浮点。</target>
        </trans-unit>
        <trans-unit id="f3cef616f14d50a47152db143f35cc307563ca92" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="translated">将给定的32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）转换为64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="411b3a0b25ac912caaa9c2f1d7ed837e3af70f3f" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to a native integer.</source>
          <target state="translated">将给定的32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）转换为本地整数。</target>
        </trans-unit>
        <trans-unit id="1be3acecc320ef8bb4b8ad656c48b398c14be616" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">将给定的32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）转换为整数（类型 &lt;code&gt;int&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="93f62b9cc8d76e35705b0ce4bdbf71d21a9df25e" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). On 32-bit platforms, the 32-bit integer is taken modulo 2&lt;sup&gt;31&lt;/sup&gt;, i.e. the high-order bit is lost during the conversion. On 64-bit platforms, the conversion is exact.</source>
          <target state="translated">将给定的32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）转换为整数（类型 &lt;code&gt;int&lt;/code&gt; ）。在32位平台上，将32位整数取模2 &lt;sup&gt;31&lt;/sup&gt;，即在转换过程中高阶位丢失。在64位平台上，转换是精确的。</target>
        </trans-unit>
        <trans-unit id="014bbb3bbf0643a138bb48038c7eaab32ae13c44" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer to a floating-point number.</source>
          <target state="translated">将给定的32位整数转换为浮点数。</target>
        </trans-unit>
        <trans-unit id="9f59aef95dedbe83b6777c4e724a128aced4162e" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="translated">将给定的64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）转换为32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2a8c52d49afae53eeb13c5e454150dfee5751bcf" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). The 64-bit integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;, i.e. the top 32 bits are lost during the conversion.</source>
          <target state="translated">将给定的64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）转换为32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）。64位整数被取模2 &lt;sup&gt;32&lt;/sup&gt;，即顶部的转换过程中的32位都将丢失。</target>
        </trans-unit>
        <trans-unit id="c54dd450fd275471e93b471cb0a1d306996989fe" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a native integer.</source>
          <target state="translated">将给定的64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）转换为本地整数。</target>
        </trans-unit>
        <trans-unit id="3cca923cfddf0036de4f3e2ea85fc94c1f82ef40" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a native integer. On 32-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;. On 64-bit platforms, the conversion is exact.</source>
          <target state="translated">将给定的64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）转换为本地整数。在32位的平台上，64位整数被取模2 &lt;sup&gt;32&lt;/sup&gt;。在64位平台上，转换是精确的。</target>
        </trans-unit>
        <trans-unit id="a8506d7c598044a6201c1a0f6c8f93251b1073a0" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">将给定的64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）转换为整数（类型 &lt;code&gt;int&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="95b8e9bc57fe5a67ea7ffcefe1594c337c38a927" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). On 64-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;63&lt;/sup&gt;, i.e. the high-order bit is lost during the conversion. On 32-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;31&lt;/sup&gt;, i.e. the top 33 bits are lost during the conversion.</source>
          <target state="translated">将给定的64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）转换为整数（类型 &lt;code&gt;int&lt;/code&gt; ）。在64位平台上，64位整数取2 &lt;sup&gt;63&lt;/sup&gt;为模，即在转换过程中高阶位丢失。在32位平台上，将64位整数取模2 &lt;sup&gt;31&lt;/sup&gt;，即，在转换期间会丢失前33位。</target>
        </trans-unit>
        <trans-unit id="9c6929450b6383bc9247464a59404dd3a1bdd763" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer to a floating-point number.</source>
          <target state="translated">将给定的64位整数转换为浮点数。</target>
        </trans-unit>
        <trans-unit id="b64aaae03809d3b5a65a5b282cb97472c52416af" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent lowercase character, using the ISO Latin-1 (8859-1) character set.</source>
          <target state="translated">使用ISO Latin-1 (8859-1)字符集,将给定字符转换为等效的小写字符。</target>
        </trans-unit>
        <trans-unit id="1cef781019641479d8714145b7af1e60404822ad" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent lowercase character, using the US-ASCII character set.</source>
          <target state="translated">使用US-ASCII字符集,将给定字符转换为等效的小写字符。</target>
        </trans-unit>
        <trans-unit id="10738094bd74009109a3d94ef91c5ed6b5c299bf" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent uppercase character, using the ISO Latin-1 (8859-1) character set.</source>
          <target state="translated">使用ISO Latin-1 (8859-1)字符集,将给定字符转换为等效的大写字符。</target>
        </trans-unit>
        <trans-unit id="dc257554c0317b3dd5566d489ad3fde9331403d9" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent uppercase character, using the US-ASCII character set.</source>
          <target state="translated">使用US-ASCII字符集,将给定字符转换为等效的大写字符。</target>
        </trans-unit>
        <trans-unit id="bf675d948a6aff1ee29c25ddcb8bee6dd88d8aec" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 32-bit integer, discarding the fractional part (truncate towards 0).</source>
          <target state="translated">将给定的浮点数转换为32位整数,丢弃小数部分(向0截断)。</target>
        </trans-unit>
        <trans-unit id="c2af0a4c1e0f6e2efe957e1a8efff3d2473b8403" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 32-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;int32#VALmin_int&quot;&gt;&lt;code&gt;Int32.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;int32#VALmax_int&quot;&gt;&lt;code&gt;Int32.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">将给定的浮点数转换为32位整数，丢弃小数部分（截断为0）。如果数字在截断后超出范围[ &lt;a href=&quot;int32#VALmin_int&quot;&gt; &lt;code&gt;Int32.min_int&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;int32#VALmax_int&quot;&gt; &lt;code&gt;Int32.max_int&lt;/code&gt; &lt;/a&gt; ] ，则转换结果不确定。</target>
        </trans-unit>
        <trans-unit id="5fcb051564865ed8de2eb491570af0a4f45f4edd" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 64-bit integer, discarding the fractional part (truncate towards 0).</source>
          <target state="translated">将给定的浮点数转换为64位整数,丢弃小数部分(向0截断)。</target>
        </trans-unit>
        <trans-unit id="580bb45852738cdd647d7446f484386b0a804244" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 64-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;int64#VALmin_int&quot;&gt;&lt;code&gt;Int64.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;int64#VALmax_int&quot;&gt;&lt;code&gt;Int64.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">将给定的浮点数转换为64位整数，丢弃小数部分（截断为0）。如果数字在截断后超出范围[ &lt;a href=&quot;int64#VALmin_int&quot;&gt; &lt;code&gt;Int64.min_int&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;int64#VALmax_int&quot;&gt; &lt;code&gt;Int64.max_int&lt;/code&gt; &lt;/a&gt; ] ，则转换结果不确定。</target>
        </trans-unit>
        <trans-unit id="5031b270a977528f20d0e7a11194d07248c96172" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a native integer, discarding the fractional part (truncate towards 0).</source>
          <target state="translated">将给定的浮点数转换为本地整数,丢弃小数部分(向0截断)。</target>
        </trans-unit>
        <trans-unit id="1725d3597c69c9439f05f46ee38743a2c137c782" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a native integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;nativeint#VALmin_int&quot;&gt;&lt;code&gt;Nativeint.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;nativeint#VALmax_int&quot;&gt;&lt;code&gt;Nativeint.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">将给定的浮点数转换为本机整数，丢弃小数部分（截断为0）。如果数字在截断后超出范围[ &lt;a href=&quot;nativeint#VALmin_int&quot;&gt; &lt;code&gt;Nativeint.min_int&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;nativeint#VALmax_int&quot;&gt; &lt;code&gt;Nativeint.max_int&lt;/code&gt; &lt;/a&gt; ] ，则转换结果不确定。</target>
        </trans-unit>
        <trans-unit id="6050cb5e0048524aee2d160ae0cce485161ded2d" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="translated">将给定的整数（类型 &lt;code&gt;int&lt;/code&gt; ）转换为32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c3887945b57ea121fcdf0f14b5a759fdbaad36e7" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). On 64-bit platforms, the argument is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;.</source>
          <target state="translated">将给定的整数（类型 &lt;code&gt;int&lt;/code&gt; ）转换为32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）。在64位平台上，自变量取模2 &lt;sup&gt;32&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="4debd3cb988d635b8f41534836b6a2b48d409ed0" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="translated">将给定的整数（类型 &lt;code&gt;int&lt;/code&gt; ）转换为64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4921b162e3c39cc7cd9396df60a318a087afa590" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a native integer (type &lt;code&gt;nativeint&lt;/code&gt;).</source>
          <target state="translated">将给定的整数（类型 &lt;code&gt;int&lt;/code&gt; ）转换为本地整数（类型 &lt;code&gt;nativeint&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dd3c57e865f3508e17aade52701128e682c09fd7" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="translated">将给定的本机整数（类型 &lt;code&gt;nativeint&lt;/code&gt; ）转换为64位整数（类型 &lt;code&gt;int64&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="63c44f46b0858567098c36f81e612d99fcc9adc8" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">将给定的本机整数（类型 &lt;code&gt;nativeint&lt;/code&gt; ）转换为整数（类型 &lt;code&gt;int&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="da94aa8d40c08299bdebdd7ca1f19bdf6f8a60cb" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). The high-order bit is lost during the conversion.</source>
          <target state="translated">将给定的本机整数（类型 &lt;code&gt;nativeint&lt;/code&gt; ）转换为整数（类型 &lt;code&gt;int&lt;/code&gt; ）。转换期间高位丢失。</target>
        </trans-unit>
        <trans-unit id="9cc4c17f687227c32c9382b73f0b0e3cba1ffd79" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="translated">将给定的本机整数转换为32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f14b0131a571b73ccad1485e208ed7eab1af27b0" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). On 64-bit platforms, the 64-bit native integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;, i.e. the top 32 bits are lost. On 32-bit platforms, the conversion is exact.</source>
          <target state="translated">将给定的本机整数转换为32位整数（类型 &lt;code&gt;int32&lt;/code&gt; ）。在64位的平台上，64位整数天然取模2 &lt;sup&gt;32&lt;/sup&gt;，即顶端32位被丢失。在32位平台上，转换是精确的。</target>
        </trans-unit>
        <trans-unit id="b84b8167237f0e84a7eba52f0611f41b25ced1e1" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a floating-point number.</source>
          <target state="translated">将给定的原生整数转换为浮点数。</target>
        </trans-unit>
        <trans-unit id="7c7d3886a056c01164226ca8f21d8885519399a9" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 32-bit integer.</source>
          <target state="translated">将给定的字符串转换为32位整数。</target>
        </trans-unit>
        <trans-unit id="f2799240478510b8655a29381484f108391a1adb" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 32-bit integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="translated">将给定的字符串转换为32位整数。如果字符串分别以 &lt;code&gt;0x&lt;/code&gt; ， &lt;code&gt;0o&lt;/code&gt; 或 &lt;code&gt;0b&lt;/code&gt; 开头，则以十进制（默认值，或者如果字符串以 &lt;code&gt;0u&lt;/code&gt; 开头）或十六进制，八进制或二进制形式读取字符串。</target>
        </trans-unit>
        <trans-unit id="c0d4202b90328e10c2df68813b3b1f8eb79b0f98" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 64-bit integer.</source>
          <target state="translated">将给定的字符串转换为64位整数。</target>
        </trans-unit>
        <trans-unit id="fd390af034ba87ea38383f34f7b32709bfd5568f" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 64-bit integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="translated">将给定的字符串转换为64位整数。如果字符串分别以 &lt;code&gt;0x&lt;/code&gt; ， &lt;code&gt;0o&lt;/code&gt; 或 &lt;code&gt;0b&lt;/code&gt; 开头，则以十进制（默认值，或者如果字符串以 &lt;code&gt;0u&lt;/code&gt; 开头）或十六进制，八进制或二进制形式读取字符串。</target>
        </trans-unit>
        <trans-unit id="046905d098af9c9b18df1bfb0e99207e44814271" translate="yes" xml:space="preserve">
          <source>Convert the given string to a boolean.</source>
          <target state="translated">将给定的字符串转换为布尔值。</target>
        </trans-unit>
        <trans-unit id="3cb27f7eac6e919033f75b4bb9b0ad927cf3a2cc" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float.</source>
          <target state="translated">将给定的字符串转换为浮点数。</target>
        </trans-unit>
        <trans-unit id="e405970d44a177d8f59d8de438813e89e623f942" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float. The string is read in decimal (by default) or in hexadecimal (marked by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="translated">将给定的字符串转换为浮点数。该字符串以十进制（默认）或十六进制（标记为 &lt;code&gt;0x&lt;/code&gt; 或 &lt;code&gt;0X&lt;/code&gt; ）读取。</target>
        </trans-unit>
        <trans-unit id="c724ac3d5dc6e9e705e1e17a5f0ea7c150159b6b" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float. The string is read in decimal (by default) or in hexadecimal (marked by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;). The format of decimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; stands for a decimal digit. The format of hexadecimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; stands for an hexadecimal digit and &lt;code&gt;d&lt;/code&gt; for a decimal digit. In both cases, at least one of the integer and fractional parts must be given; the exponent part is optional. The &lt;code&gt;_&lt;/code&gt; (underscore) character can appear anywhere in the string and is ignored. Depending on the execution platforms, other representations of floating-point numbers can be accepted, but should not be relied upon.</source>
          <target state="translated">将给定的字符串转换为浮点数。该字符串以十进制（默认）或十六进制（标记为 &lt;code&gt;0x&lt;/code&gt; 或 &lt;code&gt;0X&lt;/code&gt; ）读取。十进制浮点数的格式为 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; ，其中 &lt;code&gt;d&lt;/code&gt; 代表十进制数字。十六进制浮点数的格式为 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; ，其中 &lt;code&gt;h&lt;/code&gt; 代表十六进制数字， &lt;code&gt;d&lt;/code&gt; 代表十进制数字。在这两种情况下，都必须至少给出整数和小数部分之一；指数部分是可选的。该 &lt;code&gt;_&lt;/code&gt; （下划线）字符可以出现在字符串中的任何位置，并且将被忽略。根据执行平台的不同，可以接受其他浮点数表示形式，但不应依赖于这些表示形式。</target>
        </trans-unit>
        <trans-unit id="b9970fe070e5622757e45b32117233a0163be3ba" translate="yes" xml:space="preserve">
          <source>Convert the given string to a native integer.</source>
          <target state="translated">将给定的字符串转换为本地整数。</target>
        </trans-unit>
        <trans-unit id="a0a3df43f4c2b1e962a393e752d6bbadfbb2aff4" translate="yes" xml:space="preserve">
          <source>Convert the given string to a native integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="translated">将给定的字符串转换为本地整数。如果字符串分别以 &lt;code&gt;0x&lt;/code&gt; ， &lt;code&gt;0o&lt;/code&gt; 或 &lt;code&gt;0b&lt;/code&gt; 开头，则以十进制（默认值，或者如果字符串以 &lt;code&gt;0u&lt;/code&gt; 开头）或十六进制，八进制或二进制形式读取字符串。</target>
        </trans-unit>
        <trans-unit id="debd9a11f6bb577291b4caf3926d0227e1808f46" translate="yes" xml:space="preserve">
          <source>Convert the given string to an integer.</source>
          <target state="translated">将给定的字符串转换为整数。</target>
        </trans-unit>
        <trans-unit id="c7206df3c20e1d25190b72034c967fc58a3ca235" translate="yes" xml:space="preserve">
          <source>Convert the given string to an integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;), in hexadecimal (if it begins with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;), in octal (if it begins with &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or in binary (if it begins with &lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;).</source>
          <target state="translated">将给定的字符串转换为整数。字符串以十进制（默认情况下，或者如果字符串以 &lt;code&gt;0u&lt;/code&gt; 开头），十六进制（如果以 &lt;code&gt;0x&lt;/code&gt; 或 &lt;code&gt;0X&lt;/code&gt; 开头），八进制（如果以 &lt;code&gt;0o&lt;/code&gt; 或 &lt;code&gt;0O&lt;/code&gt; 开头）或二进制（如果以开头）读取与 &lt;code&gt;0b&lt;/code&gt; 或 &lt;code&gt;0B&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3bcef0a610e933857faac2e83c490abb8af3cab1" translate="yes" xml:space="preserve">
          <source>Converting</source>
          <target state="translated">Converting</target>
        </trans-unit>
        <trans-unit id="cbc0e232bf464340aba1214ff73887e6a343d877" translate="yes" xml:space="preserve">
          <source>Converting backtraces to &lt;code&gt;backtrace_slot&lt;/code&gt;s is slower than capturing the backtraces. If an application processes many backtraces, it can be useful to use &lt;code&gt;raw_backtrace&lt;/code&gt; to avoid or delay conversion.</source>
          <target state="translated">将backtrace转换为 &lt;code&gt;backtrace_slot&lt;/code&gt; s比捕获backtrace慢。如果应用程序处理许多回溯，则使用 &lt;code&gt;raw_backtrace&lt;/code&gt; 避免或延迟转换会很有用。</target>
        </trans-unit>
        <trans-unit id="796fed19f815a7871b9f55ad1bb6d03d63143aee" translate="yes" xml:space="preserve">
          <source>Converts a format string into a string.</source>
          <target state="translated">将格式字符串转换为字符串。</target>
        </trans-unit>
        <trans-unit id="714801eba41aa2625b2a713ececaf6f421fd187f" translate="yes" xml:space="preserve">
          <source>Copy all elements of a Bigarray in another Bigarray.</source>
          <target state="translated">将一个Bigarray的所有元素复制到另一个Bigarray中。</target>
        </trans-unit>
        <trans-unit id="f33c856c6fe179d2a83dff4070691e79ceca7dae" translate="yes" xml:space="preserve">
          <source>Copy all elements of a Bigarray in another Bigarray. &lt;code&gt;Genarray.blit&amp;nbsp;src&amp;nbsp;dst&lt;/code&gt; copies all elements of &lt;code&gt;src&lt;/code&gt; into &lt;code&gt;dst&lt;/code&gt;. Both arrays &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; must have the same number of dimensions and equal dimensions. Copying a sub-array of &lt;code&gt;src&lt;/code&gt; to a sub-array of &lt;code&gt;dst&lt;/code&gt; can be achieved by applying &lt;code&gt;Genarray.blit&lt;/code&gt; to sub-array or slices of &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">将一个Bigarray的所有元素复制到另一个Bigarray中。 &lt;code&gt;Genarray.blit&amp;nbsp;src&amp;nbsp;dst&lt;/code&gt; 将 &lt;code&gt;src&lt;/code&gt; 的所有元素复制到 &lt;code&gt;dst&lt;/code&gt; 中。数组 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dst&lt;/code&gt; 必须具有相同的维数和相等的维数。通过将 &lt;code&gt;Genarray.blit&lt;/code&gt; 应用于 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dst&lt;/code&gt; 的子数组或切片，可以将 &lt;code&gt;src&lt;/code&gt; 的子数组复制到 &lt;code&gt;dst&lt;/code&gt; 的子数组。</target>
        </trans-unit>
        <trans-unit id="2f98913bf026616eee1f70a64e0abe6968048030" translate="yes" xml:space="preserve">
          <source>Copy the first Bigarray to the second Bigarray.</source>
          <target state="translated">将第一个Bigarray复制到第二个Bigarray。</target>
        </trans-unit>
        <trans-unit id="4e63802c10caf95b9698af675ba70745b8440d3c" translate="yes" xml:space="preserve">
          <source>Copy the first Bigarray to the second Bigarray. See &lt;a href=&quot;bigarray.genarray#VALblit&quot;&gt;&lt;code&gt;Bigarray.Genarray.blit&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">将第一个Bigarray复制到第二个Bigarray。有关更多详细信息，请参见&lt;a href=&quot;bigarray.genarray#VALblit&quot;&gt; &lt;code&gt;Bigarray.Genarray.blit&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="749a2a1ff67c24e1aaefeb4893cf456a09300335" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2020 Institut National de Recherche en Informatique et en Automatique</source>
          <target state="translated">版权所有&amp;copy;2020年信息与自动化研究所</target>
        </trans-unit>
        <trans-unit id="bb6aaeb12b4c75558a5fcd526df17e6f1cddb21f" translate="yes" xml:space="preserve">
          <source>Correct use of exceptional return, in particular in the presence of garbage collection, is further detailed in Section &amp;zwj;&lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;18.7.1&lt;/a&gt;.</source>
          <target state="translated">正确使用的特殊回报，特别是在垃圾收集的情况下，进一步详细说明在第&lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;18.7.1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9f0ee0d8c723707d5631f23f004103955272851" translate="yes" xml:space="preserve">
          <source>Correct use of exceptional return, in particular in the presence of garbage collection, is further detailed in Section &lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt;.</source>
          <target state="translated">第&lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt;节中进一步详细说明了异常收益的正确使用，尤其是在存在垃圾回收的情况下。</target>
        </trans-unit>
        <trans-unit id="9221f888b1436de6082936ddd6d55309f806fb1b" translate="yes" xml:space="preserve">
          <source>Corrupted compiled interface filename</source>
          <target state="translated">编译后的接口文件名损坏</target>
        </trans-unit>
        <trans-unit id="7a82a6d806181e70fe9be0edf237bd49a8998364" translate="yes" xml:space="preserve">
          <source>Cosine.</source>
          <target state="translated">Cosine.</target>
        </trans-unit>
        <trans-unit id="3909ef6abac31cfe9a35b22ea080c9d194f203ef" translate="yes" xml:space="preserve">
          <source>Cosine. Argument is in radians.</source>
          <target state="translated">余弦。争论的单位是弧度。</target>
        </trans-unit>
        <trans-unit id="72cd010c4394bea276d4bdb151886625642b9b8b" translate="yes" xml:space="preserve">
          <source>Count the number of elements in the table.</source>
          <target state="translated">计算表格中的元素数量。</target>
        </trans-unit>
        <trans-unit id="e082d8bf67432c245dd736e9ca7132061f24ca80" translate="yes" xml:space="preserve">
          <source>Count the number of elements in the table. &lt;code&gt;count&amp;nbsp;t&lt;/code&gt; gives the same result as &lt;code&gt;fold&amp;nbsp;(fun&amp;nbsp;_&amp;nbsp;n&amp;nbsp;-&amp;gt;&amp;nbsp;n+1)&amp;nbsp;t&amp;nbsp;0&lt;/code&gt; but does not delay the deallocation of the dead elements.</source>
          <target state="translated">计算表中的元素数。 &lt;code&gt;count&amp;nbsp;t&lt;/code&gt; 给出与 &lt;code&gt;fold&amp;nbsp;(fun&amp;nbsp;_&amp;nbsp;n&amp;nbsp;-&amp;gt;&amp;nbsp;n+1)&amp;nbsp;t&amp;nbsp;0&lt;/code&gt; 相同的结果，但不会延迟死元素的重新分配。</target>
        </trans-unit>
        <trans-unit id="0ad30ec0a98552dd30130b7c329159ff45fa91d8" translate="yes" xml:space="preserve">
          <source>Counting semaphores</source>
          <target state="translated">语素的计数</target>
        </trans-unit>
        <trans-unit id="ec5cab66331e1f63a891d845b54e584c2f2ac037" translate="yes" xml:space="preserve">
          <source>Create a buffer from the generator</source>
          <target state="translated">从生成器中创建一个缓冲区</target>
        </trans-unit>
        <trans-unit id="19e34d2262662f5708968cd7624e835c13757358" translate="yes" xml:space="preserve">
          <source>Create a directory with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">创建具有给定权限的目录（请参见&lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="980fb320d636eb56f585e8815c4834fa44ebb83c" translate="yes" xml:space="preserve">
          <source>Create a directory with the given permissions (see &lt;a href=&quot;unixlabels#VALumask&quot;&gt;&lt;code&gt;UnixLabels.umask&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">创建具有给定权限的目录（请参见&lt;a href=&quot;unixlabels#VALumask&quot;&gt; &lt;code&gt;UnixLabels.umask&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="70d3168ae617afccee2b8028fe4d89dc16e329c7" translate="yes" xml:space="preserve">
          <source>Create a directory with the given permissions.</source>
          <target state="translated">用给定的权限创建一个目录。</target>
        </trans-unit>
        <trans-unit id="dc44996afbaa5cd1d76fa615bb2991b6a12175a4" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer on the given input channel.</source>
          <target state="translated">在给定的输入通道上创建一个lexer缓冲区。</target>
        </trans-unit>
        <trans-unit id="5143503b6006ea03b7e3bd6f9b08f1d8aa2fdea1" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer on the given input channel. &lt;code&gt;Lexing.from_channel&amp;nbsp;inchan&lt;/code&gt; returns a lexer buffer which reads from the input channel &lt;code&gt;inchan&lt;/code&gt;, at the current reading position.</source>
          <target state="translated">在给定的输入通道上创建一个词法分析器缓冲区。 &lt;code&gt;Lexing.from_channel&amp;nbsp;inchan&lt;/code&gt; 返回一个词法分析器缓冲区，该缓冲区在当前读取位置从输入通道 &lt;code&gt;inchan&lt;/code&gt; 读取。</target>
        </trans-unit>
        <trans-unit id="e81abb60f55d65a6d038b5d9a363404318029de3" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer which reads from the given string.</source>
          <target state="translated">创建一个从给定字符串中读取的词典缓冲区。</target>
        </trans-unit>
        <trans-unit id="6407d31fa51c4c55eb4598c03876535a93c6952f" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer which reads from the given string. Reading starts from the first character in the string. An end-of-input condition is generated when the end of the string is reached.</source>
          <target state="translated">创建一个lexer缓冲区,从给定的字符串中读取。从字符串中的第一个字符开始读取。当到达字符串的末端时,会产生一个输入结束的条件。</target>
        </trans-unit>
        <trans-unit id="190ca8ac4f2c64e047dbc76197c1ff595fa6b031" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer with the given function as its reading method.</source>
          <target state="translated">用给定的函数作为读取方法,创建一个lexer缓冲区。</target>
        </trans-unit>
        <trans-unit id="a8735b8a50290dcf794da46bfe74dd3527a8550a" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer with the given function as its reading method. When the scanner needs more characters, it will call the given function, giving it a byte sequence &lt;code&gt;s&lt;/code&gt; and a byte count &lt;code&gt;n&lt;/code&gt;. The function should put &lt;code&gt;n&lt;/code&gt; bytes or fewer in &lt;code&gt;s&lt;/code&gt;, starting at index 0, and return the number of bytes provided. A return value of 0 means end of input.</source>
          <target state="translated">使用给定的函数作为其读取方法创建一个词法分析器缓冲区。当扫描仪需要更多字符时，它将调用给定的函数，为其提供字节序列 &lt;code&gt;s&lt;/code&gt; 和字节数 &lt;code&gt;n&lt;/code&gt; 。该函数应在 &lt;code&gt;s&lt;/code&gt; 中放置 &lt;code&gt;n&lt;/code&gt; 个字节或更少的字节，从索引0开始，并返回提供的字节数。返回值0表示输入结束。</target>
        </trans-unit>
        <trans-unit id="30ba288a50ae1fece1cf0423426f78280eed622a" translate="yes" xml:space="preserve">
          <source>Create a list from the iterator</source>
          <target state="translated">从迭代器中创建一个列表</target>
        </trans-unit>
        <trans-unit id="9e01b81b620486ac9bbe38b7bfbca49778f2743f" translate="yes" xml:space="preserve">
          <source>Create a list from the iterator.</source>
          <target state="translated">从迭代器中创建一个列表。</target>
        </trans-unit>
        <trans-unit id="3456a1163b51311f839b8cf00cd30de750a651d3" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">创建具有给定权限的命名管道（请参见&lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a3d10d804380675a899416b24f92318eeb66d264" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;). On Windows: not implemented.</source>
          <target state="translated">创建具有给定权限的命名管道（请参见&lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; &lt;/a&gt;）。在Windows上：未实现。</target>
        </trans-unit>
        <trans-unit id="fafe0071b68e1e2c8343d9a91f6b671fb22a12e0" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions (see &lt;a href=&quot;unixlabels#VALumask&quot;&gt;&lt;code&gt;UnixLabels.umask&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">创建具有给定权限的命名管道（请参见&lt;a href=&quot;unixlabels#VALumask&quot;&gt; &lt;code&gt;UnixLabels.umask&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c2fdff70665a56d05f0ee5d27d9da24708eb1894" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions.</source>
          <target state="translated">用给定的权限创建一个命名的管道。</target>
        </trans-unit>
        <trans-unit id="aa1a16120ae466a832076e7d380310e5ff6301b8" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind.</source>
          <target state="translated">在给定的域中创建一个新的套接字,并使用给定的种类。</target>
        </trans-unit>
        <trans-unit id="093f73e0ca46114cb3907dbd3c6ba4b8e4823414" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets.</source>
          <target state="translated">在给定的域中用给定的类型创建一个新的套接字。第三个参数是协议类型,0选择该类型套接字的默认协议。</target>
        </trans-unit>
        <trans-unit id="3f3cf678cd161d0a98fd3f5d42b3cb008ce1a48a" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">在给定的域和给定的种类中创建一个新的套接字。第三个参数是协议类型；0选择该类型套接字的默认协议。见&lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt;有关文件 &lt;code&gt;cloexec&lt;/code&gt; 可选参数。</target>
        </trans-unit>
        <trans-unit id="3750c6ec5d325b294c2fca1e144b3f4fa1220beb" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets. See &lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt;&lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">在给定的域和给定的种类中创建一个新的套接字。第三个参数是协议类型；0选择该类型套接字的默认协议。见&lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt; &lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt; &lt;/a&gt;有关文件 &lt;code&gt;cloexec&lt;/code&gt; 可选参数。</target>
        </trans-unit>
        <trans-unit id="03a14162d305ff52f22126d9ba6cafa4d78574a8" translate="yes" xml:space="preserve">
          <source>Create a new state and initialize it with a system-dependent low-entropy seed.</source>
          <target state="translated">创建一个新的状态,并用一个依赖于系统的低熵种子来初始化它。</target>
        </trans-unit>
        <trans-unit id="9db61f76a5c74fd7a62aa832c9c1832527ee6e66" translate="yes" xml:space="preserve">
          <source>Create a new state and initialize it with the given seed.</source>
          <target state="translated">用给定的种子创建一个新的状态并初始化它。</target>
        </trans-unit>
        <trans-unit id="3b2f60955c649908da20c0760f6c08367ad20db1" translate="yes" xml:space="preserve">
          <source>Create a packing interface Mylib.ml, containing the following lines.</source>
          <target state="translated">创建一个打包接口Mylib.ml,包含以下几行。</target>
        </trans-unit>
        <trans-unit id="533abcfd8c9a401ae37bd05c83664abd41b3978f" translate="yes" xml:space="preserve">
          <source>Create a pair of unnamed sockets, connected together.</source>
          <target state="translated">创建一对未命名的插座,连接在一起。</target>
        </trans-unit>
        <trans-unit id="f3b413102c7a4e886a94cd1ccf3432e8ee8a268c" translate="yes" xml:space="preserve">
          <source>Create a pair of unnamed sockets, connected together. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">创建一对未命名的套接字，将其连接在一起。见&lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt;有关文件 &lt;code&gt;cloexec&lt;/code&gt; 可选参数。</target>
        </trans-unit>
        <trans-unit id="1585f1f21684fe678331027368e5e44665ede5a1" translate="yes" xml:space="preserve">
          <source>Create a pair of unnamed sockets, connected together. See &lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt;&lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">创建一对未命名的套接字，将其连接在一起。见&lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt; &lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt; &lt;/a&gt;有关文件 &lt;code&gt;cloexec&lt;/code&gt; 可选参数。</target>
        </trans-unit>
        <trans-unit id="4ecb3637f50b940e9ab5fbcaa7d0e3d9d8adca50" translate="yes" xml:space="preserve">
          <source>Create a pipe.</source>
          <target state="translated">创建一个管道。</target>
        </trans-unit>
        <trans-unit id="30af9bcb81b48bf202dd963116fe928f0c53fcfd" translate="yes" xml:space="preserve">
          <source>Create a pipe. The first component of the result is opened for reading, that's the exit to the pipe. The second component is opened for writing, that's the entrance to the pipe.</source>
          <target state="translated">创建一个管道。结果的第一个组件被打开读取,那就是管道的出口。第二个分量打开写,那就是管道的入口。</target>
        </trans-unit>
        <trans-unit id="cd252b1ca191e7bced4e2176974be7bd120d4a47" translate="yes" xml:space="preserve">
          <source>Create a pipe. The first component of the result is opened for reading, that's the exit to the pipe. The second component is opened for writing, that's the entrance to the pipe. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">创建一个管道。打开结果的第一部分以供读取，这是管道的出口。打开第二个组件以进行书写，这是管道的入口。见&lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt;有关文件 &lt;code&gt;cloexec&lt;/code&gt; 可选参数。</target>
        </trans-unit>
        <trans-unit id="923caa4f8ae72f7ab1ba46d83c7b5876cda12032" translate="yes" xml:space="preserve">
          <source>Create a pipe. The first component of the result is opened for reading, that's the exit to the pipe. The second component is opened for writing, that's the entrance to the pipe. See &lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt;&lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">创建一个管道。打开结果的第一部分以供读取，这是管道的出口。打开第二个组件以进行书写，这是管道的入口。见&lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt; &lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt; &lt;/a&gt;有关文件 &lt;code&gt;cloexec&lt;/code&gt; 可选参数。</target>
        </trans-unit>
        <trans-unit id="21dc9f570d12477a38ca2a08e98e4c0750a86675" translate="yes" xml:space="preserve">
          <source>Create a queue from the generator</source>
          <target state="translated">从生成器中创建一个队列</target>
        </trans-unit>
        <trans-unit id="a770574699ea3d33080750f7cc2703aad4c9a772" translate="yes" xml:space="preserve">
          <source>Create a stack from the iterator</source>
          <target state="translated">从迭代器中创建一个堆栈</target>
        </trans-unit>
        <trans-unit id="ee45c92ea429789a619f70851af380b2976438fe" translate="yes" xml:space="preserve">
          <source>Create a string from the generator</source>
          <target state="translated">从生成器中创建一个字符串</target>
        </trans-unit>
        <trans-unit id="4d42ea6eec79d2dc2d2ce4ff68459ef19908da18" translate="yes" xml:space="preserve">
          <source>Create an array from the generator</source>
          <target state="translated">从生成器中创建一个数组</target>
        </trans-unit>
        <trans-unit id="eaa3a15a2bb90fcfee2212ff47808afd2d02c456" translate="yes" xml:space="preserve">
          <source>Create an array from the generator.</source>
          <target state="translated">从生成器中创建一个数组。</target>
        </trans-unit>
        <trans-unit id="438b4343437f3d39aa2f6f57b9fe6b02e8768de6" translate="yes" xml:space="preserve">
          <source>Create an atomic reference.</source>
          <target state="translated">创建一个原子引用。</target>
        </trans-unit>
        <trans-unit id="47a23ab49072d38a59b186d4a3917b754a37143e" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor.</source>
          <target state="translated">从给定的描述符中创建一个输入通道读数。</target>
        </trans-unit>
        <trans-unit id="1be3c0896f6ff928d2c5d93f64972c34596328b6" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; if text mode is desired.</source>
          <target state="translated">创建一个从给定描述符读取的输入通道。通道最初处于二进制模式。如果需要文本模式，请使用 &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b4c5bfb3f135ee7e4bbeb7f01a5bc16dfacbdb0" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; if text mode is desired. Text mode is supported only if the descriptor refers to a file or pipe, but is not supported if it refers to a socket.</source>
          <target state="translated">创建一个从给定描述符读取的输入通道。通道最初处于二进制模式。如果需要文本模式，请使用 &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; 。仅当描述符引用文件或管道时才支持文本模式，但如果引用套接字则不支持文本模式。</target>
        </trans-unit>
        <trans-unit id="09b45b6f8c3f7cfba77d056c3802a69e5892dcce" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; if text mode is desired. Text mode is supported only if the descriptor refers to a file or pipe, but is not supported if it refers to a socket. On Windows, &lt;code&gt;set_binary_mode_in&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="translated">创建一个从给定描述符读取的输入通道。通道最初处于二进制模式。如果需要文本模式，请使用 &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; 。仅当描述符引用文件或管道时才支持文本模式，但如果引用套接字则不支持文本模式。在Windows上，使用此函数创建的通道上的 &lt;code&gt;set_binary_mode_in&lt;/code&gt; 总是失败。</target>
        </trans-unit>
        <trans-unit id="117259bf956aec536c5e186ca77e9ac5c916fcea" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor.</source>
          <target state="translated">在给定的描述符上创建一个输出通道写入。</target>
        </trans-unit>
        <trans-unit id="aef56a146856b79a283846092c16431e8f33cd0e" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; if text mode is desired.</source>
          <target state="translated">创建一个在给定描述符上写入的输出通道。通道最初处于二进制模式。如果需要文本模式，则使用 &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="373631338f6dea01101dbf491fcf2efb65b27d37" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; if text mode is desired. Text mode is supported only if the descriptor refers to a file or pipe, but is not supported if it refers to a socket.</source>
          <target state="translated">创建一个在给定描述符上写入的输出通道。通道最初处于二进制模式。如果需要文本模式，则使用 &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; 。仅当描述符引用文件或管道时才支持文本模式，但如果引用套接字则不支持文本模式。</target>
        </trans-unit>
        <trans-unit id="c3b9a3797ea26619d3139009eea19109e07b38e3" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; if text mode is desired. Text mode is supported only if the descriptor refers to a file or pipe, but is not supported if it refers to a socket. On Windows, &lt;code&gt;set_binary_mode_out&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="translated">创建一个在给定描述符上写入的输出通道。通道最初处于二进制模式。如果需要文本模式，则使用 &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; 。仅当描述符引用文件或管道时才支持文本模式，但如果引用套接字则不支持文本模式。在Windows上，使用此函数创建的通道上的 &lt;code&gt;set_binary_mode_out&lt;/code&gt; 总是失败。</target>
        </trans-unit>
        <trans-unit id="fe6800f26660081a63257b90928fee7fe0195a50" translate="yes" xml:space="preserve">
          <source>Create if nonexistent</source>
          <target state="translated">如果不存在,则创建</target>
        </trans-unit>
        <trans-unit id="6b2f57520b3f8b6769816f831656e126cef6ab78" translate="yes" xml:space="preserve">
          <source>Creating directly an object through the object&lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;end construct is operationally equivalent to defining locally a class&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;=object&lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;end &amp;mdash;see sections &lt;a href=&quot;classes#sss%3Aclass-body&quot;&gt;7.9.2&lt;/a&gt; and following for the syntax of &lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;&amp;mdash; and immediately creating a single object from it by new&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;.</source>
          <target state="translated">通过object &lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt; end构造直接创建一个对象在操作上等效于在本地定义一个class &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; = object &lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt; end-有关&lt;a href=&quot;classes#class-body&quot;&gt;类body&lt;/a&gt;的语法，请参见第&lt;a href=&quot;classes#sss%3Aclass-body&quot;&gt;7.9.2&lt;/a&gt;节和以下内容-并立即创建一个通过新的&lt;a href=&quot;names#class-name&quot;&gt;类名&lt;/a&gt;从其对象。</target>
        </trans-unit>
        <trans-unit id="601cb9beb4be7bd6b430fc5e8f28883c4379c1d3" translate="yes" xml:space="preserve">
          <source>Cross-references are fully qualified element names, as in the example {!Foo.Bar.t}. This is an ambiguous reference as it may designate a type name, a value name, a class name, etc. It is possible to make explicit the intended syntactic class, using {!type:Foo.Bar.t} to designate a type, and {!val:Foo.Bar.t} a value of the same name.</source>
          <target state="translated">交叉引用是完全限定的元素名,如例{!Foo.Bar.t}。这是一个模糊的引用,因为它可能指定一个类型名、一个值名、一个类名等。可以明确预期的语法类,用{!type:Foo.Bar.t}指定类型,用{!val:Foo.Bar.t}指定同名的值。</target>
        </trans-unit>
        <trans-unit id="37fe7fe65c32d93c2ca449d110fef079f2b333b8" translate="yes" xml:space="preserve">
          <source>Current call stack</source>
          <target state="translated">当前调用栈</target>
        </trans-unit>
        <trans-unit id="560d25076243183549a3366eeffb8ff8432d896d" translate="yes" xml:space="preserve">
          <source>Current size of the stack, in words.</source>
          <target state="translated">当前栈的大小,字数。</target>
        </trans-unit>
        <trans-unit id="2dfd3c4c638243840bd240275ac5f3fed807c54e" translate="yes" xml:space="preserve">
          <source>Current value of the timer</source>
          <target state="translated">定时器的当前值</target>
        </trans-unit>
        <trans-unit id="812249ab55025e47f0d8297bf9cf8f98c1593c35" translate="yes" xml:space="preserve">
          <source>Currently, the compiler requires that all dependency cycles between the recursively-defined module identifiers go through at least one &amp;ldquo;safe&amp;rdquo; module. A module is &amp;ldquo;safe&amp;rdquo; if all value definitions that it contains have function types &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. Evaluation of a recursive module definition proceeds by building initial values for the safe modules involved, binding all (functional) values to fun_-&amp;gt;raiseUndefined_recursive_module. The defining module expressions are then evaluated, and the initial values for the safe modules are replaced by the values thus computed. If a function component of a safe module is applied during this computation (which corresponds to an ill-founded recursive definition), the Undefined_recursive_module exception is raised at runtime:</source>
          <target state="translated">当前，编译器要求递归定义的模块标识符之间的所有依赖关系循环都至少经过一个&amp;ldquo;安全&amp;rdquo;模块。如果模块包含的所有值定义都具有函数类型&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;，则该模块是&amp;ldquo;安全的&amp;rdquo;&lt;sub&gt;&lt;/sub&gt;。递归模块定义的评估通过为所涉及的安全模块建立初始值，并将所有（功能）值绑定到fun _-&amp;gt; raiseUndefined_recursive_module来进行。然后评估定义的模块表达式，然后将安全模块的初始值替换为由此计算出的值。如果在此计算过程中应用了安全模块的功能组件（对应于基础不充分的递归定义），则会在运行时引发Undefined_recursive_module异常：</target>
        </trans-unit>
        <trans-unit id="38664408d8c3d30f0a6346765b3283aa12c40bf5" translate="yes" xml:space="preserve">
          <source>Currently, the official distribution only supports &lt;code&gt;Native&lt;/code&gt; and &lt;code&gt;Bytecode&lt;/code&gt;, but it can be other backends with alternative compilers, for example, javascript.</source>
          <target state="translated">当前，官方发行版仅支持 &lt;code&gt;Native&lt;/code&gt; 和 &lt;code&gt;Bytecode&lt;/code&gt; ，但也可以是其他后端以及其他编译器，例如javascript。</target>
        </trans-unit>
        <trans-unit id="c4bda26164af65ad302861503513ecff5571b51a" translate="yes" xml:space="preserve">
          <source>Custom blocks generalize the finalized blocks that were present in OCaml prior to version 3.00. For backward compatibility, the format of custom blocks is compatible with that of finalized blocks, and the alloc_final function is still available to allocate a custom block with a given finalization function, but default comparison, hashing and serialization functions. caml_alloc_final(n, f, used, max) returns a fresh custom block of size n+1 words, with finalization function f. The first word is reserved for storing the custom operations; the other n words are available for your data. The two parameters used and max are used to control the speed of garbage collection, as described for caml_alloc_custom.</source>
          <target state="translated">自定义块是对3.00版本之前OCaml中存在的最终化块的概括。为了向后兼容,自定义块的格式与最终化块的格式兼容,仍然可以使用 alloc_final 函数来分配一个给定最终化函数的自定义块,但默认比较、散列和序列化函数。 caml_alloc_final(n,f,used,max)返回一个大小为 n+1 个字的新鲜自定义块,最终化函数为 f,第一个字保留用于存储自定义操作,其他 n 个字可用于你的数据。used和max这两个参数用来控制垃圾回收的速度,具体操作方法如caml_alloc_custom所述。</target>
        </trans-unit>
        <trans-unit id="7d420f0c61810f3ee6a674eb6f4cdb6097699b24" translate="yes" xml:space="preserve">
          <source>Custom blocks must be allocated via caml_alloc_custom or caml_alloc_custom_mem:</source>
          <target state="translated">自定义块必须通过caml_alloc_custom或caml_alloc_custom_mem进行分配。</target>
        </trans-unit>
        <trans-unit id="0696943310470dcd9412c58452a376f47cd4d8e7" translate="yes" xml:space="preserve">
          <source>Custom_tag</source>
          <target state="translated">Custom_tag</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="876131551ef5b34a0ae26c45b8606a6d1e20f0ec" translate="yes" xml:space="preserve">
          <source>Damien Doligez, Alain Frisch, Jacques Garrigue, Didier R&amp;eacute;my and J&amp;eacute;r&amp;ocirc;me Vouillon</source>
          <target state="translated">达米安&amp;middot;多利格斯（Damien Doligez），阿兰&amp;middot;弗里施（Alain Frisch），雅克&amp;middot;加里格（Jacques Garrigue），迪迪埃&amp;middot;雷米（DidierR&amp;eacute;my）和杰罗姆&amp;middot;沃永（J&amp;eacute;r&amp;ocirc;meVouillon）</target>
        </trans-unit>
        <trans-unit id="9bb8e492ef8785784d3763a2dd035cbcb3a6f48d" translate="yes" xml:space="preserve">
          <source>Data_custom_val(v) returns a pointer to the data part of the custom block v. This pointer has type void * and must be cast to the type of the data contained in the custom block.</source>
          <target state="translated">Data_custom_val(v)返回一个指向自定义块v的数据部分的指针,这个指针的类型为void *,必须投向自定义块中包含的数据类型。</target>
        </trans-unit>
        <trans-unit id="6c61aac6c59c97a9391046663cc1f0a559430d2b" translate="yes" xml:space="preserve">
          <source>Datagram socket</source>
          <target state="translated">数据报插座</target>
        </trans-unit>
        <trans-unit id="ae5e1b484adfb0832aee424b80fdbf0749c94471" translate="yes" xml:space="preserve">
          <source>Day of month 1..31</source>
          <target state="translated">1.月31日</target>
        </trans-unit>
        <trans-unit id="a6b30c19d064061d359d4bd864a0a544b299c73f" translate="yes" xml:space="preserve">
          <source>Day of week (Sunday is 0)</source>
          <target state="translated">一周中的一天(周日为0</target>
        </trans-unit>
        <trans-unit id="b762515612697efddec23840f7a8446cf18c9759" translate="yes" xml:space="preserve">
          <source>Day of year 0..365</source>
          <target state="translated">0..365年的日子</target>
        </trans-unit>
        <trans-unit id="3b0dbb1420972511e036436a9980700df7df5ce2" translate="yes" xml:space="preserve">
          <source>Daylight time savings in effect</source>
          <target state="translated">实行夏令时</target>
        </trans-unit>
        <trans-unit id="2fadfd27832ae372bd710d8badba7a9b539b27e1" translate="yes" xml:space="preserve">
          <source>Deactivates the applicative behaviour of functors. With this option, each functor application generates new types in its result and applying the same functor twice to the same argument yields two incompatible structures.</source>
          <target state="translated">停用漏斗的应用行为。有了这个选项,每个漏斗应用都会在其结果中产生新的类型,而且同一个漏斗两次应用于同一个参数会产生两个不兼容的结构。</target>
        </trans-unit>
        <trans-unit id="751472bbc1120d8b191832a2b8fcc18014817d7f" translate="yes" xml:space="preserve">
          <source>Deactivates the constant propagation for floating-point operations. This option should be given if the program changes the float rounding mode during its execution.</source>
          <target state="translated">停用浮点运算的常量传播。如果程序在执行过程中改变了浮点进位模式,则应赋予该选项。</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="2678ad56aeb7875f3c2d5de90981064d8f642b7a" translate="yes" xml:space="preserve">
          <source>Declarations are given one per line. They all start with a &lt;code&gt;%&lt;/code&gt; sign.</source>
          <target state="translated">每行声明一次。它们都以 &lt;code&gt;%&lt;/code&gt; 符号开头。</target>
        </trans-unit>
        <trans-unit id="dea55cd40a5af4aaba5005b973e60323ff6e05fa" translate="yes" xml:space="preserve">
          <source>Declare the given symbols &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; as tokens (terminal symbols). These symbols are added as constant constructors for the token concrete type.</source>
          <target state="translated">将给定符号&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;声明为令牌（终端符号）。这些符号被添加为令牌具体类型的常量构造函数。</target>
        </trans-unit>
        <trans-unit id="71ce3434b9f14435902a3d78ef46a7ad71688c6e" translate="yes" xml:space="preserve">
          <source>Declare the given symbols &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; as tokens with an attached attribute of the given type. These symbols are added as constructors with arguments of the given type for the token concrete type. The &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part is an arbitrary OCaml type expression, except that all type constructor names must be fully qualified (e.g. Modname.typename) for all types except standard built-in types, even if the proper &lt;code&gt;open&lt;/code&gt; directives (e.g. &lt;code&gt;open Modname&lt;/code&gt;) were given in the header section. That&amp;rsquo;s because the header is copied only to the .ml output file, but not to the .mli output file, while the &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part of a &lt;code&gt;%token&lt;/code&gt; declaration is copied to both.</source>
          <target state="translated">将给定的符号&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip;&lt;a href=&quot;names#constr&quot;&gt;构造&lt;/a&gt;为具有给定类型的附加属性的标记。这些符号作为带有令牌具体类型的给定类型参数的构造函数添加。该&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;部分是任意的OCaml类型的表达式，除了所有类型的构造函数的名称必须是完全合格的（如Modname.typename）所有类型除了标准的内置类型，即使正确地 &lt;code&gt;open&lt;/code&gt; 指令（例如， &lt;code&gt;open Modname&lt;/code&gt; ）在给予标头部分。这是因为标头仅复制到.ml输出文件，而不复制到.mli输出文件，而 &lt;code&gt;%token&lt;/code&gt; 声明的&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;部分则复制到了两者。</target>
        </trans-unit>
        <trans-unit id="ae20b0b5091f27b6010031e7c755cac286e05951" translate="yes" xml:space="preserve">
          <source>Declare the given symbols as entry points for the grammar. For each entry point, a parsing function with the same name is defined in the output module. Non-terminals that are not declared as entry points have no such parsing function. Start symbols must be given a type with the &lt;code&gt;%type&lt;/code&gt; directive below.</source>
          <target state="translated">声明给定的符号作为语法的切入点。对于每个入口点，在输出模块中定义了具有相同名称的解析函数。未声明为入口点的非终端不具有此类解析功能。起始符号必须使用下面的 &lt;code&gt;%type&lt;/code&gt; 指令指定类型。</target>
        </trans-unit>
        <trans-unit id="e036180d7b4330c36ccc46169e89f1d9c0e3c6b6" translate="yes" xml:space="preserve">
          <source>Decrement the integer contained in the given reference.</source>
          <target state="translated">递减给定引用中的整数。</target>
        </trans-unit>
        <trans-unit id="47c2c2f15d575288567819a78318c5d8b38a36ce" translate="yes" xml:space="preserve">
          <source>Decrement the integer contained in the given reference. Equivalent to &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;pred&amp;nbsp;!r&lt;/code&gt;.</source>
          <target state="translated">减少给定引用中包含的整数。等效于 &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;pred&amp;nbsp;!r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c11b83f7c1a5251b3d34dbe51f9955f77470d6d" translate="yes" xml:space="preserve">
          <source>Default callbacks simply return &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">默认回调仅返回 &lt;code&gt;None&lt;/code&gt; 或 &lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80afbff2abe8c0d7fd33c9ccd7830a6e8695af59" translate="yes" xml:space="preserve">
          <source>Default directories searched by the system dynamic loader. Under Unix, these generally include /lib and /usr/lib, plus the directories listed in the file /etc/ld.so.conf and the environment variable LD_LIBRARY_PATH. Under Windows, these include the Windows system directories, plus the directories listed in the PATH environment variable.</source>
          <target state="translated">系统动态加载器搜索的默认目录。在Unix下,这些目录通常包括/lib和/usr/lib,加上文件/etc/ld.so.conf和环境变量LD_LIBRARY_PATH中列出的目录。在Windows下,这些目录包括Windows系统目录,加上PATH环境变量中列出的目录。</target>
        </trans-unit>
        <trans-unit id="7d3a0856d835d1235dff9d8788c3557c03ede792" translate="yes" xml:space="preserve">
          <source>Default tag-marking functions behave the HTML way: &lt;a href=&quot;format#TYPEtag&quot;&gt;string tags&lt;/a&gt; are enclosed in &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; while other tags are ignored; hence, opening marker for tag string &lt;code&gt;&quot;t&quot;&lt;/code&gt; is &lt;code&gt;&quot;&amp;lt;t&amp;gt;&quot;&lt;/code&gt; and closing marker is &lt;code&gt;&quot;&amp;lt;/t&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">默认的标记功能以HTML方式运行：&lt;a href=&quot;format#TYPEtag&quot;&gt;字符串标记&lt;/a&gt;括在&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;中，而其他标记则被忽略；因此，标记字符串 &lt;code&gt;&quot;t&quot;&lt;/code&gt; 开始标记是 &lt;code&gt;&quot;&amp;lt;t&amp;gt;&quot;&lt;/code&gt; ，结束标记是 &lt;code&gt;&quot;&amp;lt;/t&amp;gt;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a62a2e3e7ee2c9c2ee80559a4f3229d3577d48f" translate="yes" xml:space="preserve">
          <source>Default tag-printing functions just do nothing.</source>
          <target state="translated">默认的标签打印功能就是什么都不做。</target>
        </trans-unit>
        <trans-unit id="9eed4a181452e1959a48bc782bac0f8f566e7c0f" translate="yes" xml:space="preserve">
          <source>Default: 0.</source>
          <target state="translated">默认值:0。</target>
        </trans-unit>
        <trans-unit id="9082a1e7f923e7fce6486c509c1beb8c25f7fe15" translate="yes" xml:space="preserve">
          <source>Deferred computations.</source>
          <target state="translated">递延计算。</target>
        </trans-unit>
        <trans-unit id="bcf39e9d321a7d8c8984215b8972f37f40d07337" translate="yes" xml:space="preserve">
          <source>Define a hash table on generic containers which have a notion of &quot;death&quot; and aliveness. If a binding is dead the hash table can automatically remove it.</source>
          <target state="translated">在通用容器上定义一个哈希表,它有一个 &quot;死亡 &quot;和活力的概念。如果一个绑定是死的,哈希表可以自动将其删除。</target>
        </trans-unit>
        <trans-unit id="f21fc769210bfcaf86eb46d5f61d271368778b97" translate="yes" xml:space="preserve">
          <source>Defining expression</source>
          <target state="translated">定义表达方式</target>
        </trans-unit>
        <trans-unit id="7c4de55230924b0c3c5fc761cc7d4686a36f7dc3" translate="yes" xml:space="preserve">
          <source>Defining formatters</source>
          <target state="translated">定义格式化程序</target>
        </trans-unit>
        <trans-unit id="4911c404436a822d9f0fbfab26950a91ad559e29" translate="yes" xml:space="preserve">
          <source>Defining new formatters permits unrelated output of material in parallel on several output devices. All the parameters of a formatter are local to the formatter: right margin, maximum indentation limit, maximum number of pretty-printing boxes simultaneously open, ellipsis, and so on, are specific to each formatter and may be fixed independently.</source>
          <target state="translated">定义新的格式化程序允许在多个输出设备上并行输出不相关的材料。格式器的所有参数都是该格式器的局部参数:右边距、最大缩进限制、同时打开的漂亮打印框的最大数量、省略号等,都是每个格式器所特有的,可以独立固定。</target>
        </trans-unit>
        <trans-unit id="6e0b554ed773f7f64c570b11feb5887c9cc07fe5" translate="yes" xml:space="preserve">
          <source>Delete the specified breakpoints. Without argument, all breakpoints are deleted (after asking for confirmation).</source>
          <target state="translated">删除指定的断点。如果没有参数,所有的断点都会被删除(要求确认后)。</target>
        </trans-unit>
        <trans-unit id="f97978b86bb138adaba2fd837574900d5922d00e" translate="yes" xml:space="preserve">
          <source>Dependencies are generated both for compiling with the bytecode compiler ocamlc and with the native-code compiler ocamlopt.</source>
          <target state="translated">在使用字节码编译器ocamlc和本地码编译器ocamlopt编译时,都会产生依赖关系。</target>
        </trans-unit>
        <trans-unit id="b0d4c46a17ce0b5e730857044f9bf49c709590e2" translate="yes" xml:space="preserve">
          <source>Depending on the execution platforms, other representations of floating-point numbers can be accepted, but should not be relied upon.</source>
          <target state="translated">根据执行平台的不同,可以接受浮点数的其他表示方法,但不应该依赖这些方法。</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="11d3e633516ce1af098fe4ff7ebdf4e7f3c34f38" translate="yes" xml:space="preserve">
          <source>Deprecated functions</source>
          <target state="translated">废弃的功能</target>
        </trans-unit>
        <trans-unit id="74254f9d66f6a56051d0eaae6dea96f7d55c67a0" translate="yes" xml:space="preserve">
          <source>Deprecated since OCaml 4.11. Please use -bin-annot instead.</source>
          <target state="translated">自OCaml 4.11起已被废弃。请使用-bin-annot代替。</target>
        </trans-unit>
        <trans-unit id="ef0c6a5ddb045b6ece785229e78cf805f0b1a89d" translate="yes" xml:space="preserve">
          <source>Deprecated synonym for the &amp;rsquo;deprecated&amp;rsquo; alert.</source>
          <target state="translated">&amp;ldquo;已弃用&amp;rdquo;警报的已弃用同义词。</target>
        </trans-unit>
        <trans-unit id="8e967cec8e8fdbe014b3a9f6bbf388f62bb46fa7" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;a href=&quot;unix#VALgetsockopt_error&quot;&gt;&lt;code&gt;Unix.getsockopt_error&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">不推荐使用。请改用&lt;a href=&quot;unix#VALgetsockopt_error&quot;&gt; &lt;code&gt;Unix.getsockopt_error&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="835e8923117c78b0778f188959b87d1ff7511197" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;a href=&quot;unixlabels#VALgetsockopt_error&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_error&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">不推荐使用。请改用&lt;a href=&quot;unixlabels#VALgetsockopt_error&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_error&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2224f5d5269c5bc0b6728399953ed547eb0d09f0" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;a href=&quot;arraylabels#VALmake_float&quot;&gt;&lt;code&gt;ArrayLabels.make_float&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;arraylabels#VALcreate_float&quot;&gt;&lt;code&gt;ArrayLabels.create_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。&lt;a href=&quot;arraylabels#VALmake_float&quot;&gt; &lt;code&gt;ArrayLabels.make_float&lt;/code&gt; &lt;/a&gt;是一个别名&lt;a href=&quot;arraylabels#VALcreate_float&quot;&gt; &lt;code&gt;ArrayLabels.create_float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="778bc3674d64e797ac3bcdc24c0d0ca9cba0734e" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;a href=&quot;stdlib#VAL(&amp;amp;&amp;amp;)&quot;&gt;&lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt;&lt;/a&gt; should be used instead. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">不推荐使用。&lt;a href=&quot;stdlib#VAL(&amp;amp;&amp;amp;)&quot;&gt; &lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt; &lt;/a&gt;应该改为使用。右关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fca9f421cfdb9f0454d469cdb1dcaa8ace5429e" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;(||)&lt;/code&gt; should be used instead. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">不推荐使用。应该使用 &lt;code&gt;(||)&lt;/code&gt; 代替。右关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a150df40019aac9b002359089017a86258f19d9f" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.create&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;Array.create&lt;/code&gt; 是一个别名&lt;a href=&quot;array#VALmake&quot;&gt; &lt;code&gt;Array.make&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e89b4c51bb7679bf855f7c9eec368867486ddd1" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.create_matrix&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALmake_matrix&quot;&gt;&lt;code&gt;Array.make_matrix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;Array.create_matrix&lt;/code&gt; 是一个别名&lt;a href=&quot;array#VALmake_matrix&quot;&gt; &lt;code&gt;Array.make_matrix&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50bae5862dab3413cad88ccda1ead1a473864665" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.make_float&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALcreate_float&quot;&gt;&lt;code&gt;Array.create_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;Array.make_float&lt;/code&gt; 是一个别名&lt;a href=&quot;array#VALcreate_float&quot;&gt; &lt;code&gt;Array.create_float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea64d85c2e594370c18faa8e1d13550273cdb567" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Scanf.fscanf&lt;/code&gt; is error prone and deprecated since 4.03.0. This function violates the following invariant of the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: To preserve scanning semantics, all scanning functions defined in &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; must read from a user defined &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel. If you need to read from a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; input channel &lt;code&gt;ic&lt;/code&gt;, simply define a &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel as in &lt;code&gt;let&amp;nbsp;ib&amp;nbsp;=&amp;nbsp;Scanning.from_channel&amp;nbsp;ic&lt;/code&gt;, then use &lt;code&gt;Scanf.bscanf&amp;nbsp;ib&lt;/code&gt; as usual.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;Scanf.fscanf&lt;/code&gt; 很容易出错，因为4.03.0弃用。此函数违反以下不变&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;模块：为了保持扫描语义，在定义的所有扫描功能&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;必须从用户定义的读&lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt;格式化的输入信道。如果需要从&lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt;输入通道 &lt;code&gt;ic&lt;/code&gt; 中读取，只需如 &lt;code&gt;let&amp;nbsp;ib&amp;nbsp;=&amp;nbsp;Scanning.from_channel&amp;nbsp;ic&lt;/code&gt; 定义一个&lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt;格式的输入通道，然后照常使用 &lt;code&gt;Scanf.bscanf&amp;nbsp;ib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ce9cc4e47d57231b6a0bca0e76722fe4b7860a4" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Scanf.kfscanf&lt;/code&gt; is error prone and deprecated since 4.03.0.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;Scanf.kfscanf&lt;/code&gt; 很容易出错，因为4.03.0弃用。</target>
        </trans-unit>
        <trans-unit id="b2bd9888a0306c0294bfbf3f1f5de3501d713748" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;create&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;create&lt;/code&gt; 是&lt;a href=&quot;array#VALmake&quot;&gt; &lt;code&gt;Array.make&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="8f594cb170e0e9c8ecd301b0b815c721b26b065d" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;create&lt;/code&gt; is an alias for &lt;a href=&quot;arraylabels#VALmake&quot;&gt;&lt;code&gt;ArrayLabels.make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;create&lt;/code&gt; 是&lt;a href=&quot;arraylabels#VALmake&quot;&gt; &lt;code&gt;ArrayLabels.make&lt;/code&gt; &lt;/a&gt;的别名。</target>
        </trans-unit>
        <trans-unit id="01c6d72a37ce4e232b21c31fa0adcf70fa2b028e" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;create_matrix&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALmake_matrix&quot;&gt;&lt;code&gt;Array.make_matrix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;create_matrix&lt;/code&gt; 是一个别名&lt;a href=&quot;array#VALmake_matrix&quot;&gt; &lt;code&gt;Array.make_matrix&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ce71a4bfc97c24d6d8d5947007a2b7beb8109c0" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;create_matrix&lt;/code&gt; is an alias for &lt;a href=&quot;arraylabels#VALmake_matrix&quot;&gt;&lt;code&gt;ArrayLabels.make_matrix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;create_matrix&lt;/code&gt; 是一个别名&lt;a href=&quot;arraylabels#VALmake_matrix&quot;&gt; &lt;code&gt;ArrayLabels.make_matrix&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7a1f22ab597ffb34784adc0f369ab8d90a5cf4c" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;make_float&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALcreate_float&quot;&gt;&lt;code&gt;Array.create_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;make_float&lt;/code&gt; 是一个别名&lt;a href=&quot;array#VALcreate_float&quot;&gt; &lt;code&gt;Array.create_float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14f2feeac263a3b6b6ce234437eda12e31831568" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;make_float&lt;/code&gt; is an alias for &lt;a href=&quot;arraylabels#VALcreate_float&quot;&gt;&lt;code&gt;ArrayLabels.create_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。 &lt;code&gt;make_float&lt;/code&gt; 是一个别名&lt;a href=&quot;arraylabels#VALcreate_float&quot;&gt; &lt;code&gt;ArrayLabels.create_float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19939082fb7f2eee871d26aedbf72b901c3112f7" translate="yes" xml:space="preserve">
          <source>Deprecated.An alias for &lt;code&gt;ksprintf&lt;/code&gt;.</source>
          <target state="translated">不推荐使用 &lt;code&gt;ksprintf&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="e5109e0782a729eff640730e6ab1a3e754505085" translate="yes" xml:space="preserve">
          <source>Deprecated.Because strings are immutable, it doesn't make much sense to make identical copies of them.</source>
          <target state="translated">Deprecated.因为字符串是不可变的,所以制作相同的副本没有多大意义。</target>
        </trans-unit>
        <trans-unit id="750ec831f3c087b18622dc178ec61b7cb38e9e32" translate="yes" xml:space="preserve">
          <source>Deprecated.Functions operating on Latin-1 character set are deprecated.</source>
          <target state="translated">弃用.在Latin-1字符集上操作的函数已被弃用。</target>
        </trans-unit>
        <trans-unit id="ea75bf6e5b032cf8e893592df0f821c5e5f96d64" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#TYPEformatter_stag_functions&quot;&gt;&lt;code&gt;Format.formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，&lt;a href=&quot;format#TYPEformatter_stag_functions&quot;&gt; &lt;code&gt;Format.formatter_stag_functions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c97116701943fcfc6c2f740afe560b14ec3898d" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALclose_stag&quot;&gt;&lt;code&gt;Format.close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，包含在&lt;a href=&quot;format#VALclose_stag&quot;&gt; &lt;code&gt;Format.close_stag&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fca73c717756fa77071fb29946903b95deed41a6" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALget_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.get_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，&lt;a href=&quot;format#VALget_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.get_formatter_stag_functions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d93054ebdf71f3812384f734ddd0e2d1f78da6e2" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALopen_stag&quot;&gt;&lt;code&gt;Format.open_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，由&lt;a href=&quot;format#VALopen_stag&quot;&gt; &lt;code&gt;Format.open_stag&lt;/code&gt; 包含&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="281c574fe529db292e92addfbf152b24d9bdbbf3" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_close_stag&quot;&gt;&lt;code&gt;Format.pp_close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，包含在&lt;a href=&quot;format#VALpp_close_stag&quot;&gt; &lt;code&gt;Format.pp_close_stag&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="641c68cac8b19078637ee0e40e70a3a5d64a22f6" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_get_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.pp_get_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，由&lt;a href=&quot;format#VALpp_get_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.pp_get_formatter_stag_functions&lt;/code&gt; 包含&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ccb247c568c8d05554c40ee2105c8bf4f8476b4" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_open_stag&quot;&gt;&lt;code&gt;Format.pp_open_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，包含在&lt;a href=&quot;format#VALpp_open_stag&quot;&gt; &lt;code&gt;Format.pp_open_stag&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2602cd2b6f3d43929ce834f849335fcef5dae37" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_set_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.pp_set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，包含在&lt;a href=&quot;format#VALpp_set_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.pp_set_formatter_stag_functions&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afa368f3af7d6061271ddaa3583db9fd9dfb7bca" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用，由&lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt; 包含&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c33425025d507c5cd7b36ca43602379d421c4dc9" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;get_formatter_out_functions&lt;/code&gt;.</source>
          <target state="translated">已弃用。包含在 &lt;code&gt;get_formatter_out_functions&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="9b2a76881889cf4cb991a8f48ab00eec047820ff" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;pp_get_formatter_out_functions&lt;/code&gt;.</source>
          <target state="translated">不推荐使用，由 &lt;code&gt;pp_get_formatter_out_functions&lt;/code&gt; 包含。</target>
        </trans-unit>
        <trans-unit id="027d489c4ef0ad9d201d300c80987ca970dd611d" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;pp_set_formatter_out_functions&lt;/code&gt;.</source>
          <target state="translated">不推荐使用，由 &lt;code&gt;pp_set_formatter_out_functions&lt;/code&gt; 包含。</target>
        </trans-unit>
        <trans-unit id="ca3dcb5b6debc7e2c15801aa508b5d41a02ae9fc" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;set_formatter_out_functions&lt;/code&gt;.</source>
          <target state="translated">不推荐使用，由 &lt;code&gt;set_formatter_out_functions&lt;/code&gt; 包含。</target>
        </trans-unit>
        <trans-unit id="c0f8f5969e6b8a63fecae4c32ed1ceb9fde348db" translate="yes" xml:space="preserve">
          <source>Deprecated.The functionality of this module has been merged back into the &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module. Threaded programs can now call the functions from module &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; directly, and still get the correct behavior (block the calling thread, if required, but do not block all threads in the process).</source>
          <target state="translated">不推荐使用。此模块的功能已合并回&lt;a href=&quot;unix&quot;&gt; &lt;code&gt;Unix&lt;/code&gt; &lt;/a&gt;模块。现在，线程化程序可以直接从&lt;a href=&quot;unix&quot;&gt; &lt;code&gt;Unix&lt;/code&gt; &lt;/a&gt;模块中调用函数，并且仍然可以获得正确的行为（如果需要，可以阻塞调用线程，但不要阻塞进程中的所有线程）。</target>
        </trans-unit>
        <trans-unit id="3242d82a29f5555016d27f6fdf4642b2322aa5a3" translate="yes" xml:space="preserve">
          <source>Deprecated.This function is error prone. Do not use it. This function is neither compositional nor incremental, since it flushes the pretty-printer queue at each call. If you need to print to some buffer &lt;code&gt;b&lt;/code&gt;, you must first define a formatter writing to &lt;code&gt;b&lt;/code&gt;, using &lt;code&gt;let&amp;nbsp;to_b&amp;nbsp;=&amp;nbsp;formatter_of_buffer&amp;nbsp;b&lt;/code&gt;; then use regular calls to &lt;code&gt;Format.fprintf&lt;/code&gt; with formatter &lt;code&gt;to_b&lt;/code&gt;.</source>
          <target state="translated">不推荐使用。此功能容易出错。不要使用它。此函数既不是组合函数也不是增量函数，因为它在每次调用时都会刷新漂亮打印机队列。如果需要打印到某些缓冲区 &lt;code&gt;b&lt;/code&gt; ，则必须首先使用 &lt;code&gt;let&amp;nbsp;to_b&amp;nbsp;=&amp;nbsp;formatter_of_buffer&amp;nbsp;b&lt;/code&gt; 来定义写入 &lt;code&gt;b&lt;/code&gt; 的格式化程序；然后使用格式化程序 &lt;code&gt;to_b&lt;/code&gt; 对 &lt;code&gt;Format.fprintf&lt;/code&gt; 进行常规调用。</target>
        </trans-unit>
        <trans-unit id="d129f235645dc88a9f2ee69c1b366ec77d5e6af0" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;bytes#VALcreate&quot;&gt; &lt;code&gt;Bytes.create&lt;/code&gt; &lt;/a&gt;的不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="084f45be33efb669e78003db2459e911dc4792d9" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;byteslabels#VALcreate&quot;&gt;&lt;code&gt;BytesLabels.create&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;bytes#VALcreate&quot;&gt; &lt;code&gt;Bytes.create&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;byteslabels#VALcreate&quot;&gt; &lt;code&gt;BytesLabels.create&lt;/code&gt; &lt;/a&gt;的不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="ea0d72f83cc5b5f92d01d7c247da799f1cf025dd" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALfill&quot;&gt;&lt;code&gt;Bytes.fill&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;bytes#VALfill&quot;&gt; &lt;code&gt;Bytes.fill&lt;/code&gt; &lt;/a&gt;的不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="9b8803f09f0011f1e45f41895ff2af3c70059072" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALfill&quot;&gt;&lt;code&gt;Bytes.fill&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;byteslabels#VALfill&quot;&gt;&lt;code&gt;BytesLabels.fill&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;bytes#VALfill&quot;&gt; &lt;code&gt;Bytes.fill&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;byteslabels#VALfill&quot;&gt; &lt;code&gt;BytesLabels.fill&lt;/code&gt; &lt;/a&gt;的不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="5b1d7aec9a40e9b929be4e8acc4d6af5f1afb54e" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALset&quot;&gt;&lt;code&gt;Bytes.set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;bytes#VALset&quot;&gt; &lt;code&gt;Bytes.set&lt;/code&gt; &lt;/a&gt;不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="0777225adbbec28ad99a87a1edf7e9b1fa022533" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALset&quot;&gt;&lt;code&gt;Bytes.set&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;byteslabels#VALset&quot;&gt;&lt;code&gt;BytesLabels.set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;bytes#VALset&quot;&gt; &lt;code&gt;Bytes.set&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;byteslabels#VALset&quot;&gt; &lt;code&gt;BytesLabels.set&lt;/code&gt; &lt;/a&gt;不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="94967cc879b015aef449bb6fdb01c7b7b10b4307" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALcreate&quot;&gt;&lt;code&gt;BytesLabels.create&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;byteslabels#VALcreate&quot;&gt; &lt;code&gt;BytesLabels.create&lt;/code&gt; &lt;/a&gt;的不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="12aaa67606a221f7b76061f12289e38192d36dab" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALfill&quot;&gt;&lt;code&gt;BytesLabels.fill&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;byteslabels#VALfill&quot;&gt; &lt;code&gt;BytesLabels.fill&lt;/code&gt; &lt;/a&gt;的不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="b97555fc7a6d84d213dab655a6b7779fcd3941c9" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALset&quot;&gt;&lt;code&gt;BytesLabels.set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用。这是&lt;a href=&quot;byteslabels#VALset&quot;&gt; &lt;code&gt;BytesLabels.set&lt;/code&gt; &lt;/a&gt;不推荐使用的别名。</target>
        </trans-unit>
        <trans-unit id="8eb4d0a700ae5d08d5df97d7d36b72776b3f990e" translate="yes" xml:space="preserve">
          <source>Deprecated.You should use &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt;&lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">已弃用。您应该改用&lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt; &lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="288e17a817fd8dee0e659a5930d009274e344a1a" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;from_fun&lt;/code&gt;.</source>
          <target state="translated">不推荐使用 &lt;code&gt;from_fun&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="1fc633f74d2489b4a203e2ddf0b1d55195cf9e76" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;from_val&lt;/code&gt;.</source>
          <target state="translated">不推荐使用 &lt;code&gt;from_val&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="29f1d014a7b64bfd88ddaa57f0c63ab52af2c740" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;is_val&lt;/code&gt;.</source>
          <target state="translated">Deprecated.synonym为 &lt;code&gt;is_val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c61ae75bfda87e7eb880e442b4f35b49765a4e6" translate="yes" xml:space="preserve">
          <source>Deprecated: now part of warning 8.</source>
          <target state="translated">弃用:现在是警告的一部分 8.</target>
        </trans-unit>
        <trans-unit id="9c30d33385a5d3cd74cc6904ab3e2c26ba272b0c" translate="yes" xml:space="preserve">
          <source>Dereferencing (return the current contents of a reference).</source>
          <target state="translated">Dereferencing(返回当前引用的内容)。</target>
        </trans-unit>
        <trans-unit id="556c70c19023a2dd4cddc34ffa2fb962927700b6" translate="yes" xml:space="preserve">
          <source>Describe the currently selected stack frame.</source>
          <target state="translated">描述当前选择的堆栈框架。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
