<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="5ef10155ca428da06ee8b6867d58296ace73ef7f" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.08, it is possible to mark components (such as value or type declarations) in signatures with &amp;ldquo;alerts&amp;rdquo; that will be reported when those components are referenced. This generalizes the notion of &amp;ldquo;deprecated&amp;rdquo; components which were previously reported as warning 3. Those alerts can be used for instance to report usage of unsafe features, or of features which are only available on some platforms, etc.</source>
          <target state="translated">从OCaml 4.08开始，可以在签名中使用&amp;ldquo;警报&amp;rdquo;标记签名中的组件（例如值或类型声明），在引用这些组件时将报告这些组件。这概括了先前已报告为警告3的&amp;ldquo;已弃用&amp;rdquo;组件的概念。这些警报可用于例如报告不安全功能或仅在某些平台上可用的功能的使用情况，等等。</target>
        </trans-unit>
        <trans-unit id="7fb784bd027538e4265b84b801b820609e843b9e" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.09, the graphics library is distributed as an external package. Its new home is:</source>
          <target state="translated">从OCaml 4.09开始,图形库作为一个外部包发布。它的新家是:</target>
        </trans-unit>
        <trans-unit id="47910afc78d4869690c0ed5c357621b1abf65b2a" translate="yes" xml:space="preserve">
          <source>Since OCaml version 4.02, the OCamlBrowser tool and the Labltk library are distributed separately from the OCaml compiler. The project is now hosted at &lt;a href=&quot;https://forge.ocamlcore.org/projects/labltk/&quot;&gt;https://forge.ocamlcore.org/projects/labltk/&lt;/a&gt;.</source>
          <target state="translated">从OCaml版本4.02开始，OCamlBrowser工具和Labltk库与OCaml编译器分开分发。现在，该项目托管在&lt;a href=&quot;https://forge.ocamlcore.org/projects/labltk/&quot;&gt;https://forge.ocamlcore.org/projects/labltk/上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dd8aca1f9a01cb48e6026142ef6b38695861840" translate="yes" xml:space="preserve">
          <source>Since OCaml version 4.02, the OCamlBrowser tool and the Labltk library are distributed separately from the OCaml compiler. The project is now hosted at &lt;a href=&quot;https://github.com/garrigue/labltk&quot;&gt;https://github.com/garrigue/labltk&lt;/a&gt;.</source>
          <target state="translated">从OCaml版本4.02开始，OCamlBrowser工具和Labltk库与OCaml编译器分开分发。该项目现在托管在&lt;a href=&quot;https://github.com/garrigue/labltk&quot;&gt;https://github.com/garrigue/labltk&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85aeea25da4f851d04af97132f25d53038ece0d4" translate="yes" xml:space="preserve">
          <source>Since OCaml version 4.03, the ocamlbuild compilation manager is distributed separately from the OCaml compiler. The project is now hosted at &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;https://github.com/ocaml/ocamlbuild/&lt;/a&gt;.</source>
          <target state="translated">从OCaml版本4.03开始，ocamlbuild编译管理器与OCaml编译器分开分发。现在，该项目托管在&lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;https://github.com/ocaml/ocamlbuild/上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3c42e6e2c2dc841c6813ede2648ca45d6e38f24" translate="yes" xml:space="preserve">
          <source>Since Ocaml 3.12, the keywords inherit!, val! and method! have the same semantics as inherit, val and method, but they additionally require the definition they introduce to be overriding. Namely, method! requires &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; to be already defined in this class, val! requires &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; to be already defined in this class, and inherit! requires &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; to override some definitions. If no such overriding occurs, an error is signaled.</source>
          <target state="translated">从Ocaml 3.12开始，关键字herit !, val！和方法！具有与继承，val和方法相同的语义，但是它们还要求覆盖它们所引入的定义。即方法！要求在该类中已经定义了&lt;a href=&quot;names#method-name&quot;&gt;方法名&lt;/a&gt;val！要求已经在此类中定义了&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;并继承！需要&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;覆盖一些定义。如果没有发生此类覆盖，则将发出错误信号。</target>
        </trans-unit>
        <trans-unit id="b41b06211bb56a2cb0a28226137e946166598852" translate="yes" xml:space="preserve">
          <source>Since blocks are composed of several words, a block can potentially be sampled several times. If a block is sampled several times, then each of the callback is called once for each event of this block: the multiplicity is given in the &lt;code&gt;n_samples&lt;/code&gt; field of the &lt;code&gt;allocation&lt;/code&gt; structure.</source>
          <target state="translated">由于块是由几个单词组成的，因此一个块可能会被采样多次。如果一个块被采样了几次，那么对于该块的每个事件，每个回调都会被调用一次：多重性在 &lt;code&gt;allocation&lt;/code&gt; 结构的 &lt;code&gt;n_samples&lt;/code&gt; 字段中给出。</target>
        </trans-unit>
        <trans-unit id="879e48e0d81c1920490f9453989dbafc873931d1" translate="yes" xml:space="preserve">
          <source>Since the fields x and y can only appear simultaneously in the first record type, OCaml infers that the type of project_and_rotate is first_record -&amp;gt; first_record.</source>
          <target state="translated">由于字段x和y只能同时出现在第一种记录类型中，因此OCaml推断project_and_rotate的类型为first_record-&amp;gt; first_record。</target>
        </trans-unit>
        <trans-unit id="11b5947847de732bcf3a69fffb2afbb29de82849" translate="yes" xml:space="preserve">
          <source>Since the functions have sufficiently few arguments, more specialised arguments will be added. After some simplification one obtains:</source>
          <target state="translated">由于函数的参数足够少,所以将增加更多的专门参数。经过一些简化后,可以得到:</target>
        </trans-unit>
        <trans-unit id="607a6de4f0d6d6061a214efa4d56f36e0fd649f8" translate="yes" xml:space="preserve">
          <source>Since the type of None is 'a option and the function ref has type 'b -&amp;gt; 'b ref, a natural deduction for the type of store would be 'a option ref. However, the inferred type, '_weak1 option ref, is different. Type variables whose name starts with a _weak prefix like '_weak1 are weakly polymorphic type variables, sometimes shortened as weak type variables. A weak type variable is a placeholder for a single type that is currently unknown. Once the specific type t behind the placeholder type '_weak1 is known, all occurrences of '_weak1 will be replaced by t. For instance, we can define another option reference and store an int inside:</source>
          <target state="translated">由于None的类型是'a选项，而函数ref的类型是'b-&amp;gt;'b ref，因此自然地推导存储类型将是'a选项ref。但是，推断的类型'_weak1选项ref是不同的。名称以_weak前缀开头的类型变量（例如'_weak1）是弱多态类型变量，有时也简称为弱类型变量。弱类型变量是当前未知的单个类型的占位符。一旦知道占位符类型'_weak1后面的特定类型t，所有出现的'_weak1都将替换为t。例如，我们可以定义另一个选项引用并在其中存储一个int：</target>
        </trans-unit>
        <trans-unit id="f454df85c0505167cc193264f5f21518fa34f8d9" translate="yes" xml:space="preserve">
          <source>Since the use of a return type often eliminates the need to name type parameters in the left-hand side of a type definition, one can replace them with anonymous types _ in that case.</source>
          <target state="translated">由于使用返回类型往往不需要在类型定义的左侧命名类型参数,因此在这种情况下可以用匿名类型_代替。</target>
        </trans-unit>
        <trans-unit id="9ecba5078a243b75e15bfb04595710b711f37d53" translate="yes" xml:space="preserve">
          <source>Since there is only one case in this pattern matching, it is safe to expand directly the argument r in a record pattern:</source>
          <target state="translated">由于这种模式匹配中只有一种情况,所以直接展开记录模式中的参数r是安全的。</target>
        </trans-unit>
        <trans-unit id="6388c54547c979489e38f3575180f088b92eef41" translate="yes" xml:space="preserve">
          <source>Since version 3.10, redefinitions of a visible instance variable with the same name do not create a new variable, but are merged, using the last value for initialization. They must have identical types and mutability. However, if an instance variable is hidden by omitting it from an interface, it will be kept distinct from other instance variables with the same name.</source>
          <target state="translated">自3.10版本起,对同名可见实例变量的重新定义不会创建一个新的变量,而是合并,使用最后一个值进行初始化。它们必须具有相同的类型和可变性。然而,如果一个实例变量通过从接口中省略而被隐藏,它将与其他同名实例变量保持不同。</target>
        </trans-unit>
        <trans-unit id="cc7b7e27599e0ea9a03712ac291946d71c69a826" translate="yes" xml:space="preserve">
          <source>Sine.</source>
          <target state="translated">Sine.</target>
        </trans-unit>
        <trans-unit id="49bb3c5b34d4f790f63a5f9bea42c5d394baa7d3" translate="yes" xml:space="preserve">
          <source>Sine. Argument is in radians.</source>
          <target state="translated">正弦。论证的单位是弧度。</target>
        </trans-unit>
        <trans-unit id="850e57a1ee5fae18b0892f2cbd53b13443f4e553" translate="yes" xml:space="preserve">
          <source>Size (in words) of the largest block in the free list.</source>
          <target state="translated">自由列表中最大的块的大小(字数)。</target>
        </trans-unit>
        <trans-unit id="23aa6e811d60088ebfe23efb308861aa99dcc44c" translate="yes" xml:space="preserve">
          <source>Size in bytes</source>
          <target state="translated">字节大小</target>
        </trans-unit>
        <trans-unit id="45cf1f454a042183408948a20c84cf3be2a96f7b" translate="yes" xml:space="preserve">
          <source>Size of &lt;code&gt;int&lt;/code&gt;, in bits.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 的大小，以位为单位。</target>
        </trans-unit>
        <trans-unit id="8d1eb5965b0e8500bb02fadfe8d12ee828f16ead" translate="yes" xml:space="preserve">
          <source>Size of &lt;code&gt;int&lt;/code&gt;, in bits. It is 31 (resp. 63) when using OCaml on a 32-bit (resp. 64-bit) platform. It may differ for other implementations, e.g. it can be 32 bits when compiling to JavaScript.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 的大小，以位为单位。在32位（64位）平台上使用OCaml时，该值为31（63版）。其他实现可能会有所不同，例如，编译为JavaScript时可以为32位。</target>
        </trans-unit>
        <trans-unit id="811814293c14ee9d45359fd381dbd3619cdced86" translate="yes" xml:space="preserve">
          <source>Size of one word on the machine currently executing the OCaml program, in bits: 32 or 64.</source>
          <target state="translated">当前执行OCaml程序的机器上一个字的大小,以位为单位。32或64。</target>
        </trans-unit>
        <trans-unit id="8f670099c33bb6a9695a8b24391cc3ee7a94ec07" translate="yes" xml:space="preserve">
          <source>Size of received buffer</source>
          <target state="translated">接收缓冲区大小</target>
        </trans-unit>
        <trans-unit id="3a091b3f09d5cc7e72f0c3a89f2986c55176bed8" translate="yes" xml:space="preserve">
          <source>Size of send buffer</source>
          <target state="translated">发送缓冲区的大小</target>
        </trans-unit>
        <trans-unit id="fe888e70bfcbb275fa018e62ca6da8b998d3acd2" translate="yes" xml:space="preserve">
          <source>Slots are returned in the same order as &lt;code&gt;backtrace_slots&lt;/code&gt;: the slot at index &lt;code&gt;0&lt;/code&gt; is the most recent call, raise, or primitive, and subsequent slots represent callers.</source>
          <target state="translated">插槽以与 &lt;code&gt;backtrace_slots&lt;/code&gt; 相同的顺序返回：索引 &lt;code&gt;0&lt;/code&gt; 处的插槽是最近的调用，加注或原语，随后的插槽代表调用者。</target>
        </trans-unit>
        <trans-unit id="a5ba5bd7b7fe69d79153223545822822aa2cdcaf" translate="yes" xml:space="preserve">
          <source>So far, we have described how to call C functions from OCaml. In this section, we show how C functions can call OCaml functions, either as callbacks (OCaml calls C which calls OCaml), or with the main program written in C.</source>
          <target state="translated">到目前为止,我们已经介绍了如何从OCaml调用C函数。在这一节中,我们将展示C函数如何调用OCaml函数,无论是作为回调(OCaml调用C,而C调用OCaml),还是用C编写的主程序。</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="2cfd29f9858165eacbb559bf3f07fe2ff6c6692a" translate="yes" xml:space="preserve">
          <source>Socket domain</source>
          <target state="translated">套接字域</target>
        </trans-unit>
        <trans-unit id="2e98a4ed23c4c749f9fc8167cd3bde6181cd3ddb" translate="yes" xml:space="preserve">
          <source>Socket is already connected</source>
          <target state="translated">插座已经连接</target>
        </trans-unit>
        <trans-unit id="ff89f748bc36cfa9b24752455509275ea67d6018" translate="yes" xml:space="preserve">
          <source>Socket is not connected</source>
          <target state="translated">插座未连接</target>
        </trans-unit>
        <trans-unit id="ba3a2f86cdfbc4d51c8dd0104aa25dd69c9ae5eb" translate="yes" xml:space="preserve">
          <source>Socket operation on non-socket</source>
          <target state="translated">非插座上的插座操作</target>
        </trans-unit>
        <trans-unit id="3348447c0d2adbd99decc7a8738b6dea888ab6ca" translate="yes" xml:space="preserve">
          <source>Socket options</source>
          <target state="translated">插座选项</target>
        </trans-unit>
        <trans-unit id="c9ad407a2d95af30c4033ba9ae9c8dae9a728edf" translate="yes" xml:space="preserve">
          <source>Socket protocol number</source>
          <target state="translated">套接字协议号</target>
        </trans-unit>
        <trans-unit id="44977f379f1c02803857933034b64abf658f4fbb" translate="yes" xml:space="preserve">
          <source>Socket type</source>
          <target state="translated">插座类型</target>
        </trans-unit>
        <trans-unit id="1d0a063107fb2a5027e2f89664a6337ddcb70691" translate="yes" xml:space="preserve">
          <source>Socket type not supported</source>
          <target state="translated">不支持的插座类型</target>
        </trans-unit>
        <trans-unit id="508c36b3241ae34627fb1cadebb1f27b16e0f61a" translate="yes" xml:space="preserve">
          <source>Sockets</source>
          <target state="translated">Sockets</target>
        </trans-unit>
        <trans-unit id="da7e8a5db4d27cd8e808680b636e1905c8ab337a" translate="yes" xml:space="preserve">
          <source>Software caused connection abort</source>
          <target state="translated">软件导致连接中断</target>
        </trans-unit>
        <trans-unit id="ac38d3ac2b8f5582491bf72aa187e55579c2e9be" translate="yes" xml:space="preserve">
          <source>Some attributes are understood by the type-checker:</source>
          <target state="translated">有些属性是由类型检查员理解的。</target>
        </trans-unit>
        <trans-unit id="8cfecef4a7de8587a8731429a921ca7d4dfb4fd2" translate="yes" xml:space="preserve">
          <source>Some constructors, such as the exception constructors Failure and Invalid_argument, take as parameter a string value holding a text message intended for the user.</source>
          <target state="translated">一些构造函数,如异常构造函数Failure和Invalid_argument,将一个字符串值作为参数,这个字符串值是为用户准备的文本信息。</target>
        </trans-unit>
        <trans-unit id="65db1c59080316bcf74caa7e0683333457ad28c6" translate="yes" xml:space="preserve">
          <source>Some elements support only a subset of all @-tags. Tags that are not relevant to the documented element are simply ignored. For instance, all tags are ignored when documenting type constructors, record fields, and class inheritance clauses. Similarly, a @param tag on a class instance variable is ignored.</source>
          <target state="translated">有些元素只支持所有@标签的一个子集。与被记录元素无关的标签会被忽略。例如,当记录类型构造函数、记录字段和类继承子句时,所有标签都会被忽略。同样,类实例变量上的@param标签也会被忽略。</target>
        </trans-unit>
        <trans-unit id="f3e4e360257048c8ac9623c4484c27cbb25c848b" translate="yes" xml:space="preserve">
          <source>Some entity (typically an expression) the value of which is known by the compiler at compile time. Constantness may be explicit from the source code or inferred by the Flambda optimisers.</source>
          <target state="translated">一些实体(通常是一个表达式),其值在编译时由编译器知道。恒定性可以从源代码中明确表示,也可以由Flambda优化器推断。</target>
        </trans-unit>
        <trans-unit id="c4108bc1b80291fcd27aa85d3bc69508cd42011b" translate="yes" xml:space="preserve">
          <source>Some extension nodes are understood by the compiler itself:</source>
          <target state="translated">一些扩展节点由编译器自己理解。</target>
        </trans-unit>
        <trans-unit id="ac91f25bdfaca0fd0f24bc1c048bd2a822908634" translate="yes" xml:space="preserve">
          <source>Some functions are flagged as not tail-recursive. A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists. When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.</source>
          <target state="translated">有些函数被标记为非尾递归函数。尾递归函数使用恒定的堆栈空间,而非尾递归函数使用的堆栈空间与其列表参数的长度成正比,这对于非常长的列表来说可能是个问题。当函数接受多个列表参数时,括号中显示了一个近似的公式,给出了堆栈的使用量(以某个未指定的常量单位)。</target>
        </trans-unit>
        <trans-unit id="415760abd20f9a3ddcb87f0308d37d8d1a8acca5" translate="yes" xml:space="preserve">
          <source>Some of the Flambda flags may be subject to change in future releases.</source>
          <target state="translated">一些Flambda标志可能会在未来的版本中发生变化。</target>
        </trans-unit>
        <trans-unit id="a8faaa28b910e81e493d1ec8c3ff366be796ccb5" translate="yes" xml:space="preserve">
          <source>Some possible reasons for failing to return a location are as follow:</source>
          <target state="translated">未能返回位置的一些可能原因如下:</target>
        </trans-unit>
        <trans-unit id="352a26fd5c9966e34dc532660aeee492db89a4c8" translate="yes" xml:space="preserve">
          <source>Some possible reasons for returning &lt;code&gt;None&lt;/code&gt; are as follow:</source>
          <target state="translated">返回 &lt;code&gt;None&lt;/code&gt; 一些可能原因如下：</target>
        </trans-unit>
        <trans-unit id="a491a5b9ff21fc1c712012884a3f6d5255eb641d" translate="yes" xml:space="preserve">
          <source>Some special expressions are available in method bodies for manipulating instance variables and duplicating self:</source>
          <target state="translated">在方法体中可以使用一些特殊的表达式来操作实例变量和复制self。</target>
        </trans-unit>
        <trans-unit id="4dd7671731908ef2e0dae4c0fec50f5db2c9e9ac" translate="yes" xml:space="preserve">
          <source>Some syntactic constructions are accepted during parsing and rejected during type checking. These syntactic constructions can therefore not be used directly in vanilla OCaml. However, -ppx rewriters and other external tools can exploit this parser leniency to extend the language with these new syntactic constructions by rewriting them to vanilla constructions.</source>
          <target state="translated">一些语法结构在解析过程中被接受,在类型检查中被拒绝。因此,这些句法结构不能直接在vanilla OCaml中使用。然而,-ppx重写器和其他外部工具可以利用这种解析器的宽松性,通过将这些新的句法结构重写成vanilla结构来扩展语言。</target>
        </trans-unit>
        <trans-unit id="b04e037b0385d924ca5dee88bb5daf574bbfe126" translate="yes" xml:space="preserve">
          <source>Some_val(v) returns the argument \var{x} of a value v of the form Some(x).</source>
          <target state="translated">Some_val(v)返回值v的参数 \var{x},其形式为 Some(x)。</target>
        </trans-unit>
        <trans-unit id="fc75d8733433957f6ed3394f8f48aaaa13a230d6" translate="yes" xml:space="preserve">
          <source>Sort a floatarray in increasing order according to a comparison function.</source>
          <target state="translated">根据比较函数对浮动数组进行递增排序。</target>
        </trans-unit>
        <trans-unit id="12b9742f0225797751f8d045f36f092bce5f2a25" translate="yes" xml:space="preserve">
          <source>Sort a floatarray in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. After calling &lt;code&gt;sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="translated">根据比较函数以递增顺序对floatarray进行排序。如果比较函数的参数比较相等，则必须返回0；如果第一个较大，则返回正整数；如果第一个较小，则返回负整数（有关完整说明，请参见下文）。例如，&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;是合适的比较功能。调用 &lt;code&gt;sort&lt;/code&gt; 之后，将按升序对数组进行排序。可以保证 &lt;code&gt;sort&lt;/code&gt; 在恒定的堆空间和（最多）对数堆栈空间中运行。</target>
        </trans-unit>
        <trans-unit id="646c2222ce8e2809d04501367fe92adb8b901099" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function.</source>
          <target state="translated">根据比较功能对列表进行递增排序。</target>
        </trans-unit>
        <trans-unit id="07dab5a7b6f2fcf6a121a862ed23192a82b64444" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. The resulting list is sorted in increasing order. &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt; is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</source>
          <target state="translated">根据比较功能，以递增顺序对列表进行排序。如果比较函数的参数比较相等，则必须返回0；如果第一个较大，则返回正整数；如果第一个较小，则返回负整数（有关完整说明，请参见Array.sort）。例如，&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;是合适的比较功能。结果列表按升序排序。&lt;a href=&quot;list#VALsort&quot;&gt; &lt;code&gt;List.sort&lt;/code&gt; &lt;/a&gt;确保在恒定的堆空间（除了结果列表的大小之外）和对数堆栈空间中运行。</target>
        </trans-unit>
        <trans-unit id="44e135c27126ac813e3015ef39e796c759b36f4b" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. The resulting list is sorted in increasing order. &lt;a href=&quot;listlabels#VALsort&quot;&gt;&lt;code&gt;ListLabels.sort&lt;/code&gt;&lt;/a&gt; is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</source>
          <target state="translated">根据比较功能，以递增顺序对列表进行排序。如果比较函数的参数比较相等，则必须返回0；如果第一个较大，则返回正整数；如果第一个较小，则返回负整数（有关完整说明，请参见Array.sort）。例如，&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;是合适的比较功能。结果列表按升序排序。&lt;a href=&quot;listlabels#VALsort&quot;&gt; &lt;code&gt;ListLabels.sort&lt;/code&gt; &lt;/a&gt;确保在恒定的堆空间（除了结果列表的大小之外）和对数堆栈空间中运行。</target>
        </trans-unit>
        <trans-unit id="03d3137b9feb06bf6e9a2e8f8dca4845b6ea1be1" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. The resulting list is sorted in increasing order. &lt;code&gt;List.sort&lt;/code&gt; is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</source>
          <target state="translated">根据比较功能，以递增顺序对列表进行排序。如果比较函数的参数比较相等，则必须返回0；如果第一个较大，则返回正整数；如果第一个较小，则返回负整数（有关完整说明，请参见Array.sort）。例如，&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;是合适的比较功能。结果列表按升序排序。 &lt;code&gt;List.sort&lt;/code&gt; 确保在恒定的堆空间（除了结果列表的大小之外）和对数堆栈空间中运行。</target>
        </trans-unit>
        <trans-unit id="58d97caa0b4ab44fd3739d173807df802d224d9e" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function.</source>
          <target state="translated">根据比较函数对一个数组进行递增排序。</target>
        </trans-unit>
        <trans-unit id="f4bce5c3631201bcc5ecaef3a611067df24b6202" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function, provided there are no floating-point NaN values in the data. After calling &lt;code&gt;sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="translated">根据比较函数对数组进行升序排序。如果比较函数的参数比较相等，则必须返回0；如果第一个较大，则返回正整数；如果第一个较小，则返回负整数（有关完整说明，请参见下文）。例如，如果数据中没有浮点NaN值，则&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;是一个合适的比较函数。调用 &lt;code&gt;sort&lt;/code&gt; 之后，将按升序对数组进行排序。可以保证 &lt;code&gt;sort&lt;/code&gt; 在恒定的堆空间和（最多）对数堆栈空间中运行。</target>
        </trans-unit>
        <trans-unit id="b83d35f48bff1338b8ffef8c14c816e297c383b8" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. After calling &lt;code&gt;Array.sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;Array.sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="translated">根据比较函数对数组进行升序排序。如果比较函数的参数比较相等，则必须返回0；如果第一个较大，则返回正整数；如果第一个较小，则返回负整数（有关完整说明，请参见下文）。例如，&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;是合适的比较功能。调用 &lt;code&gt;Array.sort&lt;/code&gt; 之后，将按升序对数组进行排序。保证 &lt;code&gt;Array.sort&lt;/code&gt; 可以在恒定的堆空间和（最多）对数堆栈空间中运行。</target>
        </trans-unit>
        <trans-unit id="7bacc62ebcf0deeea3a374112083a2d9383b42ec" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. After calling &lt;code&gt;sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="translated">根据比较函数对数组进行升序排序。如果比较函数的参数比较相等，则必须返回0；如果第一个较大，则返回正整数；如果第一个较小，则返回负整数（有关完整说明，请参见下文）。例如，&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;是合适的比较功能。调用 &lt;code&gt;sort&lt;/code&gt; 之后，将按升序对数组进行排序。可以保证 &lt;code&gt;sort&lt;/code&gt; 在恒定的堆空间和（最多）对数堆栈空间中运行。</target>
        </trans-unit>
        <trans-unit id="01152a07b57f8764c6289151ce131fa414021b94" translate="yes" xml:space="preserve">
          <source>Sort files according to their dependencies.</source>
          <target state="translated">根据文件的依赖性进行排序。</target>
        </trans-unit>
        <trans-unit id="0a0c9ee78d00c49fdb36745d008f1df78dd6c77a" translate="yes" xml:space="preserve">
          <source>Sort the list of top-level modules before generating the documentation.</source>
          <target state="translated">在生成文档前,对顶层模块列表进行排序。</target>
        </trans-unit>
        <trans-unit id="378e9e163b7eecefadb4415cae533096e336c4ab" translate="yes" xml:space="preserve">
          <source>Sorting</source>
          <target state="translated">Sorting</target>
        </trans-unit>
        <trans-unit id="ae89003b504fabd08ec3be7403f79794ab72855c" translate="yes" xml:space="preserve">
          <source>Spacetime</source>
          <target state="translated">Spacetime</target>
        </trans-unit>
        <trans-unit id="1f8cf16b7ea8f93bf5c99c3fb2607d56d944da70" translate="yes" xml:space="preserve">
          <source>Spacetime is currently only available for x86-64 targets and has only been tested on Linux systems (although it is expected to work on most modern Unix-like systems and provision has been made for running under Windows). It is expected that the set of supported platforms will be extended in the future.</source>
          <target state="translated">Spacetime目前只适用于x86-64目标,并且只在Linux系统上进行了测试(尽管预计它可以在大多数现代Unix类系统上工作,并且已经为在Windows下运行做了准备)。预计今后将扩大支持的平台范围。</target>
        </trans-unit>
        <trans-unit id="ac584b81666b3bc3363ef560830c1cfe8b0e82d8" translate="yes" xml:space="preserve">
          <source>Spacetime is the name given to functionality within the OCaml compiler that provides for accurate profiling of the memory behaviour of a program. Using Spacetime it is possible to determine the source of memory leaks and excess memory allocation quickly and easily. Excess allocation slows programs down both by imposing a higher load on the garbage collector and reducing the cache locality of the program&amp;rsquo;s code. Spacetime provides full backtraces for every allocation that occurred on the OCaml heap during the lifetime of the program including those in C stubs.</source>
          <target state="translated">时空是OCaml编译器中功能的名称，该功能可对程序的内存行为进行准确的性能分析。使用Spacetime，可以快速，轻松地确定内存泄漏的来源和过多的内存分配。过多的分配会通过在垃圾收集器上施加更高的负载并降低程序代码的缓存局部性来减慢程序的运行速度。时空为程序生命周期中OCaml堆上发生的每个分配（包括C存根中的分配）提供完整的回溯。</target>
        </trans-unit>
        <trans-unit id="48a679b4fef93210c99c2867dca8b855aae9f079" translate="yes" xml:space="preserve">
          <source>Spacetime only analyses the memory behaviour of a program with respect to the OCaml heap allocators and garbage collector. It does not analyse allocation on the C heap. Spacetime does not affect the memory behaviour of a program being profiled with the exception of any change caused by the overhead of profiling (see section &lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3&lt;/a&gt;)&amp;mdash;for example the program running slower might cause it to allocate less memory in total.</source>
          <target state="translated">时空仅针对OCaml堆分配器和垃圾收集器分析程序的内存行为。它不分析C堆上的分配。时空不会影响正在分析的程序的内存行为，但由性能分析开销引起的任何更改（请参阅第&lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3&lt;/a&gt;节）除外-例如，程序运行速度较慢，可能会导致其分配的总内存更少。</target>
        </trans-unit>
        <trans-unit id="1bfc66fca52f849b22836f519ac13502d262a97d" translate="yes" xml:space="preserve">
          <source>Spacetime-configured compilers run slower and occupy more memory than their counterparts. It is hoped this will be fixed in the future as part of improved cross compilation support.</source>
          <target state="translated">空间配置的编译器比同类编译器运行速度慢,占用内存多。希望将来作为改进的交叉编译支持的一部分来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="0f3d7da024c878836fb44bec74f82a857945e099" translate="yes" xml:space="preserve">
          <source>Specialised argument</source>
          <target state="translated">专项论证</target>
        </trans-unit>
        <trans-unit id="36d1cca4de316b0f3ff4a4a7aea712ca5d0b8416" translate="yes" xml:space="preserve">
          <source>Specialised formatted input functions</source>
          <target state="translated">专门的格式化输入功能</target>
        </trans-unit>
        <trans-unit id="c7ee5cdce5b5adc99a16107f8a0cbad11ccbdc8e" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to one-dimensional arrays.</source>
          <target state="translated">&lt;a href=&quot;bigarray#VALreshape&quot;&gt; &lt;code&gt;Bigarray.reshape&lt;/code&gt; 的&lt;/a&gt;特殊版本，用于重整形为一维数组。</target>
        </trans-unit>
        <trans-unit id="9c8e450d4639c979ec29c285647dd2fe5e10040b" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to three-dimensional arrays.</source>
          <target state="translated">&lt;a href=&quot;bigarray#VALreshape&quot;&gt; &lt;code&gt;Bigarray.reshape&lt;/code&gt; 的&lt;/a&gt;特殊版本，用于重塑为三维数组。</target>
        </trans-unit>
        <trans-unit id="7be8395c98cd0223aab91f0599a991b4dc5afc58" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to two-dimensional arrays.</source>
          <target state="translated">&lt;a href=&quot;bigarray#VALreshape&quot;&gt; &lt;code&gt;Bigarray.reshape&lt;/code&gt; 的&lt;/a&gt;特殊版本，用于重塑为二维数组。</target>
        </trans-unit>
        <trans-unit id="43c35773327940730b665961e4752362a3b5e73d" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to zero-dimensional arrays.</source>
          <target state="translated">&lt;a href=&quot;bigarray#VALreshape&quot;&gt; &lt;code&gt;Bigarray.reshape&lt;/code&gt; 的&lt;/a&gt;特殊版本，用于重整形为零维数组。</target>
        </trans-unit>
        <trans-unit id="78b2052c026f21ce8899e084abfbef4c7c52450f" translate="yes" xml:space="preserve">
          <source>Specific annotations may be added in the format strings to give pretty-printing commands to the pretty-printing engine.</source>
          <target state="translated">可以在格式字符串中添加特定的注释,给漂亮打印引擎下达漂亮打印命令。</target>
        </trans-unit>
        <trans-unit id="f2c3dd0891ac4b24b95fb75f329dbcf06edc414d" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the array and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="translated">比较函数的规格：让 &lt;code&gt;a&lt;/code&gt; 为数组和 &lt;code&gt;cmp&lt;/code&gt; 比较函数。以下必须为所有真实 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; ， &lt;code&gt;z&lt;/code&gt; 在 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="264268d95295992703c12c188ef6048251a383d4" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the array and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all x, y, z in a :</source>
          <target state="translated">比较函数的规格：让 &lt;code&gt;a&lt;/code&gt; 为数组和 &lt;code&gt;cmp&lt;/code&gt; 比较函数。以下内容对于a中的所有x，y，z必须为真：</target>
        </trans-unit>
        <trans-unit id="4c87398d6e8515ee08416522a6df16c4bee30fa5" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the floatarray and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="translated">比较函数的规范：让 &lt;code&gt;a&lt;/code&gt; 为floatarray和 &lt;code&gt;cmp&lt;/code&gt; 比较函数。以下必须为所有真实 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; ， &lt;code&gt;z&lt;/code&gt; 在 &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d11d12414ac6591fc5217e352ba4806e18c81fbd" translate="yes" xml:space="preserve">
          <source>Specifies an additional string to be output with profiling information. By default, ocamlprof will annotate programs with comments of the form (* n *) where n is the counter value for a profiling point. With option -F s, the annotation will be (* sn *).</source>
          <target state="translated">指定一个额外的字符串,用于输出剖析信息。默认情况下,ocamlprof会以(*n *)的形式对程序进行注释,其中n是一个剖析点的计数器值。如果使用选项-F s,注释将是(*sn *)。</target>
        </trans-unit>
        <trans-unit id="b2ecbd64b6f63c8a41ad755311ef578f6fdd8a7a" translate="yes" xml:space="preserve">
          <source>Specifies an alternate dump file of profiling information to be read.</source>
          <target state="translated">指定要读取的剖析信息的备用转储文件。</target>
        </trans-unit>
        <trans-unit id="78189676774d8a03ffec36cdd021f56d4ff85ad2" translate="yes" xml:space="preserve">
          <source>Specify Info directory entry.</source>
          <target state="translated">指定Info目录条目。</target>
        </trans-unit>
        <trans-unit id="5f53615fd58fe78d52627fd5cf11f02e0382fab5" translate="yes" xml:space="preserve">
          <source>Specify merge options between interfaces and implementations. (see section &lt;a href=&quot;#ss%3Aocamldoc-merge&quot;&gt;15.1.2&lt;/a&gt; for details). flags can be one or several of the following characters:</source>
          <target state="translated">指定接口和实现之间的合并选项。（有关详细信息，请参见第&lt;a href=&quot;#ss%3Aocamldoc-merge&quot;&gt;15.1.2&lt;/a&gt;节）。标志可以是以下字符之一或几个：</target>
        </trans-unit>
        <trans-unit id="764c1c2ac8fdb8df6ca241276b753400dbadf23e" translate="yes" xml:space="preserve">
          <source>Specify merge options between interfaces and implementations. (see section &lt;a href=&quot;#ss%3Aocamldoc-merge&quot;&gt;16.1.2&lt;/a&gt; for details). flags can be one or several of the following characters:</source>
          <target state="translated">指定接口和实现之间的合并选项。（有关详细信息，请参见第&lt;a href=&quot;#ss%3Aocamldoc-merge&quot;&gt;16.1.2&lt;/a&gt;节）。标志可以是以下字符之一或几个：</target>
        </trans-unit>
        <trans-unit id="d9b2722d55e0ed667661be2e505491b3e2508aee" translate="yes" xml:space="preserve">
          <source>Specify odd parity instead of even.</source>
          <target state="translated">指定奇数奇偶校验,而不是偶数。</target>
        </trans-unit>
        <trans-unit id="b9eb61307c6397dc068c4836d5615b32db4f1bce" translate="yes" xml:space="preserve">
          <source>Specify section of Info directory.</source>
          <target state="translated">指定信息目录的部分。</target>
        </trans-unit>
        <trans-unit id="3cf69310aaf4ba0ff88c8c11acbb5d9e874ea7a9" translate="yes" xml:space="preserve">
          <source>Specify the colors to use in the generated dot code. When generating module dependencies, ocamldoc uses different colors for modules, depending on the directories in which they reside. When generating types dependencies, ocamldoc uses different colors for types, depending on the modules in which they are defined. colors is a list of color names separated by &amp;rsquo;,&amp;rsquo;, as in Red,Blue,Green. The available colors are the ones supported by the dot tool.</source>
          <target state="translated">指定在生成的点代码中使用的颜色。生成模块依赖项时，ocamldoc会根据模块所在的目录为模块使用不同的颜色。在生成类型依赖项时，ocamldoc根据定义它们的模块为类型使用不同的颜色。 colors是用&amp;ldquo;，&amp;rdquo;分隔的颜色名称的列表，如红色，蓝色，绿色。可用的颜色是点工具支持的颜色。</target>
        </trans-unit>
        <trans-unit id="d1a04c4094800d4a25e3996a323a80970407a756" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by ocamllex. The default is the input file name with its extension replaced by .ml.</source>
          <target state="translated">指定ocamllex产生的输出文件的名称。默认为输入文件名,扩展名用.ml代替。</target>
        </trans-unit>
        <trans-unit id="5bf2268a91aceafedecc7a037c499f825f2acf2f" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by the compiler. The default output name is a.out under Unix and camlprog.exe under Windows. If the -a option is given, specify the name of the library produced. If the -pack option is given, specify the name of the packed object file produced. If the -output-obj option is given, specify the name of the output file produced. If the -c option is given, specify the name of the object file produced for the &lt;em&gt;next&lt;/em&gt; source file that appears on the command line.</source>
          <target state="translated">指定编译器生成的输出文件的名称。默认输出名称是Unix下的a.out和Windows下的camlprog.exe。如果给出了-a选项，则指定产生的库的名称。如果提供了-pack选项，请指定生成的打包目标文件的名称。如果给出了-output-obj选项，则指定产生的输出文件的名称。如果指定了-c选项，则指定为命令行中显示的&lt;em&gt;下一个&lt;/em&gt;源文件生成的目标文件的名称。</target>
        </trans-unit>
        <trans-unit id="d328a3d88738a8d3eadb3b8aefcee241c2d7a300" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by the linker. The default output name is a.out under Unix and camlprog.exe under Windows. If the -a option is given, specify the name of the library produced. If the -pack option is given, specify the name of the packed object file produced. If the -output-obj option is given, specify the name of the output file produced. If the -shared option is given, specify the name of plugin file produced.</source>
          <target state="translated">指定由链接器产生的输出文件的名称,默认的输出名称是Unix下的a.out和Windows下的camlprog.exe。默认的输出文件名是Unix下的a.out和Windows下的camlprog.exe。如果给定了-a选项,则指定产生的库的名称。如果给出-pack选项,则指定产生的打包对象文件的名称。如果给定了-output-obj选项,则指定产生的输出文件的名称。如果给定了-shared选项,则指定生成的插件文件名。</target>
        </trans-unit>
        <trans-unit id="eac56ecb3edcec97524e457cb8e36bfda3addec2" translate="yes" xml:space="preserve">
          <source>Specify the name of the toplevel file produced by the linker. The default is a.out.</source>
          <target state="translated">指定链接器生成的toplevel文件的名称。默认为a.out。</target>
        </trans-unit>
        <trans-unit id="49fbb0a75dfa6081ddf8737f80eeb75c46445512" translate="yes" xml:space="preserve">
          <source>Specify the type of the semantic attributes for the given symbols. This is mandatory for start symbols only. Other nonterminal symbols need not be given types by hand: these types will be inferred when running the output files through the OCaml compiler (unless the &lt;code&gt;-s&lt;/code&gt; option is in effect). The &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part is an arbitrary OCaml type expression, except that all type constructor names must be fully qualified, as explained above for %token.</source>
          <target state="translated">指定给定符号的语义属性的类型。这仅对于开始符号是必需的。其他非终结符不需要手动指定类型：通过OCaml编译器运行输出文件时，将推断出这些类型（除非 &lt;code&gt;-s&lt;/code&gt; 选项有效）。所述&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;部分是一个任意的OCaml型表达，所不同的是所有类型构造名称必须是完全合格的，上面针对％令牌作为说明。</target>
        </trans-unit>
        <trans-unit id="dc0c554e640ae69ee83bf329f25eaa01f80aabef" translate="yes" xml:space="preserve">
          <source>Split a file name into directory name / base file name.</source>
          <target state="translated">将文件名拆成目录名/基础文件名。</target>
        </trans-unit>
        <trans-unit id="0ef2916d6063e59b7dc104bdabcd5daed75d687b" translate="yes" xml:space="preserve">
          <source>Split a file name into directory name / base file name. If &lt;code&gt;name&lt;/code&gt; is a valid file name, then &lt;code&gt;concat&amp;nbsp;(dirname&amp;nbsp;name)&amp;nbsp;(basename&amp;nbsp;name)&lt;/code&gt; returns a file name which is equivalent to &lt;code&gt;name&lt;/code&gt;. Moreover, after setting the current directory to &lt;code&gt;dirname&amp;nbsp;name&lt;/code&gt; (with &lt;a href=&quot;sys#VALchdir&quot;&gt;&lt;code&gt;Sys.chdir&lt;/code&gt;&lt;/a&gt;), references to &lt;code&gt;basename&amp;nbsp;name&lt;/code&gt; (which is a relative file name) designate the same file as &lt;code&gt;name&lt;/code&gt; before the call to &lt;a href=&quot;sys#VALchdir&quot;&gt;&lt;code&gt;Sys.chdir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将文件名拆分为目录名/基本文件名。如果 &lt;code&gt;name&lt;/code&gt; 是有效的文件名，则 &lt;code&gt;concat&amp;nbsp;(dirname&amp;nbsp;name)&amp;nbsp;(basename&amp;nbsp;name)&lt;/code&gt; 将返回与name等效的文件 &lt;code&gt;name&lt;/code&gt; 。此外，在将当前目录设置为 &lt;code&gt;dirname&amp;nbsp;name&lt;/code&gt; （使用&lt;a href=&quot;sys#VALchdir&quot;&gt; &lt;code&gt;Sys.chdir&lt;/code&gt; &lt;/a&gt;）之后，对 &lt;code&gt;basename&amp;nbsp;name&lt;/code&gt; 引用（这是一个相对文件名）在调用&lt;a href=&quot;sys#VALchdir&quot;&gt; &lt;code&gt;Sys.chdir&lt;/code&gt; &lt;/a&gt;之前指定与 &lt;code&gt;name&lt;/code&gt; 相同的文件。</target>
        </trans-unit>
        <trans-unit id="18a9705b01dc9c170d51771a987c403f46a25076" translate="yes" xml:space="preserve">
          <source>Splitting</source>
          <target state="translated">Splitting</target>
        </trans-unit>
        <trans-unit id="16df53085eea45d012180a01d9c65e4d69715793" translate="yes" xml:space="preserve">
          <source>Square root.</source>
          <target state="translated">方根。</target>
        </trans-unit>
        <trans-unit id="0d3138eae7ebb469e62a43de3996f397bab11b30" translate="yes" xml:space="preserve">
          <source>Square root. The result &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; is such that &lt;code&gt;x&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;x&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;y&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt;. This function has a discontinuity along the negative real axis.</source>
          <target state="translated">平方根。结果 &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; 使得 &lt;code&gt;x&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt; 或 &lt;code&gt;x&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; 且 &lt;code&gt;y&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; 。该函数沿负实轴具有不连续性。</target>
        </trans-unit>
        <trans-unit id="83e5a0d3d2ef19df258412a4d3ef3f9533b0c0c1" translate="yes" xml:space="preserve">
          <source>Stack</source>
          <target state="translated">Stack</target>
        </trans-unit>
        <trans-unit id="119f5ab8a4f65aecd72a4d4c15e7238c1dd30516" translate="yes" xml:space="preserve">
          <source>Standard labeled libraries.</source>
          <target state="translated">标准标签库。</target>
        </trans-unit>
        <trans-unit id="508cfdd242a4dbc44b800a23c67d10428e2c6d2c" translate="yes" xml:space="preserve">
          <source>Standard library modules</source>
          <target state="translated">标准库模块</target>
        </trans-unit>
        <trans-unit id="010b937250d8458f84df0333c058e6bbe6ee9a4c" translate="yes" xml:space="preserve">
          <source>Start and end of major GC cycle.</source>
          <target state="translated">主要气相色谱周期的开始和结束。</target>
        </trans-unit>
        <trans-unit id="e4da9a8e1b11d834d3eab1b30b53670f8388f8aa" translate="yes" xml:space="preserve">
          <source>Start character (usually ctrl-Q).</source>
          <target state="translated">起始字符(通常为ctrl-Q)。</target>
        </trans-unit>
        <trans-unit id="277ac8ecc15e2c9171fab8c17452880f42607be5" translate="yes" xml:space="preserve">
          <source>Start of major GC cycle.</source>
          <target state="translated">主要气相色谱周期的开始。</target>
        </trans-unit>
        <trans-unit id="90e0161012dde2267255594a35194c6fbd832e5d" translate="yes" xml:space="preserve">
          <source>Start the sampling with the given parameters.</source>
          <target state="translated">用给定的参数开始采样。</target>
        </trans-unit>
        <trans-unit id="19cc28c4f6b24df76b4178e0a8799f0454427c48" translate="yes" xml:space="preserve">
          <source>Start the sampling with the given parameters. Fails if sampling is already active.</source>
          <target state="translated">用给定的参数开始采样。如果采样已经开始,则失败。</target>
        </trans-unit>
        <trans-unit id="f830a13dce8adcb0cabc74755c312cfc51e5017b" translate="yes" xml:space="preserve">
          <source>Starting with Objective Caml 3.00, it is possible to record the -custom option as well as the names of C libraries in an OCaml library file .cma or .cmxa. For instance, consider an OCaml library mylib.cma, built from the OCaml object files a.cmo and b.cmo, which reference C code in libmylib.a. If the library is built as follows:</source>
          <target state="translated">从Objective Caml 3.00开始,可以在OCaml库文件.cma或.cmxa中记录-custom选项以及C库的名称。例如,考虑一个 OCaml 库 mylib.cma,由 OCaml 对象文件 a.cmo 和 b.cmo 建立,这两个文件引用了 libmylib.a 中的 C 代码,如果库的建立方式如下。</target>
        </trans-unit>
        <trans-unit id="b91eda3d5a614d7d82dcfba7938bafd9738269ae" translate="yes" xml:space="preserve">
          <source>Starting with Objective Caml 3.03, an alternative to static linking of C code using the -custom code is provided. In this mode, the OCaml linker generates a pure bytecode executable (no embedded custom runtime system) that simply records the names of dynamically-loaded libraries containing the C code. The standard OCaml runtime system ocamlrun then loads dynamically these libraries, and resolves references to the required primitives, before executing the bytecode.</source>
          <target state="translated">从Objective Caml 3.03开始,提供了一种使用-custom code静态链接C代码的替代方式。在这种模式下,OCaml链接器生成一个纯字节码可执行文件(没有嵌入自定义运行时系统),它只记录了包含C代码的动态加载库的名称。标准的 OCaml 运行时系统 ocamlrun 然后动态加载这些库,并在执行字节码之前解析对所需基元的引用。</target>
        </trans-unit>
        <trans-unit id="1f59cc0afb2e7a12e0dd36361604146e391913c8" translate="yes" xml:space="preserve">
          <source>Startup messages (loading the bytecode executable file, resolving shared libraries).</source>
          <target state="translated">启动信息(加载字节码可执行文件,解析共享库)。</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="29757350cc40a874924e4f8603f0be72611f1555" translate="yes" xml:space="preserve">
          <source>StdLabels</source>
          <target state="translated">StdLabels</target>
        </trans-unit>
        <trans-unit id="e4480faf0e810a556a7a3d6b1944ea9990b30303" translate="yes" xml:space="preserve">
          <source>Stdlib</source>
          <target state="translated">Stdlib</target>
        </trans-unit>
        <trans-unit id="9e253470c876ee6d5c720eb777aeb82d4c26e28f" translate="yes" xml:space="preserve">
          <source>Stop</source>
          <target state="translated">Stop</target>
        </trans-unit>
        <trans-unit id="cac94c65840b164f967c185720ce5d2d22fcd8fc" translate="yes" xml:space="preserve">
          <source>Stop character (usually ctrl-S).</source>
          <target state="translated">停止字符(通常为ctrl-S)。</target>
        </trans-unit>
        <trans-unit id="dd2d0badca0107bfe00c8bf707f6cbbc66e875ef" translate="yes" xml:space="preserve">
          <source>Stop compilation after the given compilation pass. The currently supported passes are: parsing, typing.</source>
          <target state="translated">在给定的编译通道后停止编译。目前支持的通证有:解析、打字。</target>
        </trans-unit>
        <trans-unit id="acb0dcfd6906c0d9e5e828dfe6db5b7a0e08dae4" translate="yes" xml:space="preserve">
          <source>Stop execution for the given number of seconds.</source>
          <target state="translated">停止执行指定的秒数。</target>
        </trans-unit>
        <trans-unit id="ba8848ffcb6b76a0d727951fcafac4b2adee910f" translate="yes" xml:space="preserve">
          <source>Stop execution for the given number of seconds. Like &lt;code&gt;sleep&lt;/code&gt;, but fractions of seconds are supported.</source>
          <target state="translated">在给定的秒数内停止执行。就像 &lt;code&gt;sleep&lt;/code&gt; 一样，但是只支持几分之一秒。</target>
        </trans-unit>
        <trans-unit id="e31551b253bad775da861aa7e781e955c0170316" translate="yes" xml:space="preserve">
          <source>Stop interpreting keywords and call the function with all remaining arguments</source>
          <target state="translated">停止解释关键字,并调用所有剩余参数的函数。</target>
        </trans-unit>
        <trans-unit id="9f39332271b648b33b9216188c148ca185ccff4c" translate="yes" xml:space="preserve">
          <source>Stop interpreting keywords and call the function with each remaining argument</source>
          <target state="translated">停止解释关键字,并调用每个剩余参数的函数。</target>
        </trans-unit>
        <trans-unit id="54caba6c5e005665e19c471a9869196aa5fe758e" translate="yes" xml:space="preserve">
          <source>Stop the sampling.</source>
          <target state="translated">停止取样。</target>
        </trans-unit>
        <trans-unit id="aa8698fd09970a6af5ef2746988e8701f18facae" translate="yes" xml:space="preserve">
          <source>Stop the sampling. Fails if sampling is not active.</source>
          <target state="translated">停止取样。如果取样不活动,则失败。</target>
        </trans-unit>
        <trans-unit id="31ef85d3886324ac0daa432598f7f28c17c3ca8f" translate="yes" xml:space="preserve">
          <source>Stop tracing all functions traced so far.</source>
          <target state="translated">停止追踪到目前为止的所有函数。</target>
        </trans-unit>
        <trans-unit id="2cef2a78b119882569894c0a7f505f95f3af25ea" translate="yes" xml:space="preserve">
          <source>Stop tracing the given function.</source>
          <target state="translated">停止跟踪给定函数。</target>
        </trans-unit>
        <trans-unit id="159480ac5536641c98c16dc1a2fc1666f43ed18c" translate="yes" xml:space="preserve">
          <source>Store_double_field(v, n, d) stores the double precision floating-point number d in the n&lt;sup&gt;th&lt;/sup&gt; element of the array of floating-point numbers v.</source>
          <target state="translated">Store_double_field（v，n，d）将双精度浮点数d存储在浮点数v的数组的&lt;sup&gt;第&lt;/sup&gt;n&lt;sup&gt;个&lt;/sup&gt;元素中。</target>
        </trans-unit>
        <trans-unit id="ba2305bf40cfd2ed7e52c98519e2076d13f1f2a8" translate="yes" xml:space="preserve">
          <source>Store_field (b, n, v) stores the value v in the field number n of value b, which must be a block (i.e. Is_block(b) must be true).</source>
          <target state="translated">Store_field (b,n,v)将值v存储在值b的字段号n中,该字段号必须是一个块(即Is_block(b)必须为真)。</target>
        </trans-unit>
        <trans-unit id="382e914de22199d46f8d0ef5c5b6a457fd5f5f88" translate="yes" xml:space="preserve">
          <source>Store_field(b, n, v) stores the value v in the field number n of value b, which must be a structured block.</source>
          <target state="translated">Store_field(b,n,v)将值v存储在值b的字段号n中,这个字段号必须是一个结构块。</target>
        </trans-unit>
        <trans-unit id="5dfe08d5f0fd501cb4cb5c9b5ab1306e28c9aaa5" translate="yes" xml:space="preserve">
          <source>Str</source>
          <target state="translated">Str</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="b48e1a50e3eb18053b14d5bfc02d99c1f824c681" translate="yes" xml:space="preserve">
          <source>Stream builders</source>
          <target state="translated">溪流建设者</target>
        </trans-unit>
        <trans-unit id="9712546075280428be043f28e86353de8b8e9c67" translate="yes" xml:space="preserve">
          <source>Stream iterator</source>
          <target state="translated">流迭代器</target>
        </trans-unit>
        <trans-unit id="c1df93dbb42814b12d5b273e5758a6fac66a2de5" translate="yes" xml:space="preserve">
          <source>Stream socket</source>
          <target state="translated">流插座</target>
        </trans-unit>
        <trans-unit id="fb2e7e5cdfa180129198e529d8ea2621c317804f" translate="yes" xml:space="preserve">
          <source>Streams and parsers.</source>
          <target state="translated">流和解析器。</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="bb36019440cc173d127c3aae1c10a96090c6c585" translate="yes" xml:space="preserve">
          <source>String concatenation.</source>
          <target state="translated">字符串串联。</target>
        </trans-unit>
        <trans-unit id="0d310b2b99cc668b17af0b02d5702685919572c5" translate="yes" xml:space="preserve">
          <source>String concatenation. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">字符串串联。右关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c14d9fcd0e402fa5d59a8deada34328c2183ab1" translate="yes" xml:space="preserve">
          <source>String conversion functions</source>
          <target state="translated">字符串转换功能</target>
        </trans-unit>
        <trans-unit id="e8c67bee324dda8862ee44968e54400194cc2d63" translate="yes" xml:space="preserve">
          <source>String literals are delimited by &quot; (double quote) characters. The two double quotes enclose a sequence of either characters different from &quot; and \, or escape sequences from the table given above for character literals, or a Unicode character escape sequence.</source>
          <target state="translated">字符串字符由&quot; &quot;(双引号)字符分隔。两个双引号包围着一个不同于&quot;&quot;和&quot;/&quot;的字符序列,或者是上面给定的字符字符转义序列,或者是Unicode字符转义序列。</target>
        </trans-unit>
        <trans-unit id="8c7906868ba95400fc8a6d36abebe6392b45e269" translate="yes" xml:space="preserve">
          <source>String matching and searching</source>
          <target state="translated">字符串匹配和搜索</target>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">字符串操作</target>
        </trans-unit>
        <trans-unit id="8d5d12fe85ff3629c70f06fe2ccba98f2ef750ad" translate="yes" xml:space="preserve">
          <source>String operations.</source>
          <target state="translated">字符串操作。</target>
        </trans-unit>
        <trans-unit id="6e7ccab3bf9ed59fa3897eaea798c56c7684cd59" translate="yes" xml:space="preserve">
          <source>String operations. This module is intended to be used through &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts</source>
          <target state="translated">字符串操作。该模块旨在通过&lt;a href=&quot;stdlabels&quot;&gt; &lt;code&gt;StdLabels&lt;/code&gt; &lt;/a&gt;使用，该模块将&lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;替换为其标记的对应对象</target>
        </trans-unit>
        <trans-unit id="0dd53d6d05f395fe64d03b9c25a5955171c3d33f" translate="yes" xml:space="preserve">
          <source>String tags</source>
          <target state="translated">字符串标签</target>
        </trans-unit>
        <trans-unit id="398d9ddb73ee4947a6d92a53a3b99ed8de605451" translate="yes" xml:space="preserve">
          <source>String values are finite sequences of characters. The current implementation supports strings containing up to 2&lt;sup&gt;24&lt;/sup&gt; &amp;minus; 5 characters (16777211 characters); on 64-bit platforms, the limit is 2&lt;sup&gt;57&lt;/sup&gt; &amp;minus; 9.</source>
          <target state="translated">字符串值是字符的有限序列。当前的实现支持最​​多包含2&lt;sup&gt;个&lt;/sup&gt;24-5个字符（16777211个字符）的字符串。在64位平台上，限制为2 &lt;sup&gt;57&lt;/sup&gt; &amp;minus; 9。</target>
        </trans-unit>
        <trans-unit id="34a998adbb8ec8935e29af4fede0169191c33176" translate="yes" xml:space="preserve">
          <source>StringLabels</source>
          <target state="translated">StringLabels</target>
        </trans-unit>
        <trans-unit id="f9ce9e410646789b1991a03fbd23ed1074dfa4df" translate="yes" xml:space="preserve">
          <source>String_tag</source>
          <target state="translated">String_tag</target>
        </trans-unit>
        <trans-unit id="2d498b782702d956bea922cd280afa2515d69410" translate="yes" xml:space="preserve">
          <source>String_val(v) returns a pointer to the first byte of the string v, with type char * or, when OCaml is configured with -force-safe-string, with type const char *. This pointer is a valid C string: there is a null byte after the last byte in the string. However, OCaml strings can contain embedded null bytes, which will confuse the usual C functions over strings.</source>
          <target state="translated">String_val(v)返回指向字符串 v 的第一个字节的指针,类型为 char *,或者当 OCaml 配置为 -force-safe-string 时,类型为 const char *。这个指针是一个有效的C字符串:在字符串的最后一个字节之后有一个空字节。然而,OCaml字符串可以包含内嵌的空字节,这将混淆通常的C函数对字符串的作用。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="4783a53435e04475242288debdaae1f5d02699bf" translate="yes" xml:space="preserve">
          <source>Strings.</source>
          <target state="translated">Strings.</target>
        </trans-unit>
        <trans-unit id="060ca5b23f65b0299c216dd4e8511069f47054f4" translate="yes" xml:space="preserve">
          <source>Strip 8th bit on input characters.</source>
          <target state="translated">剥离输入字符的第8位。</target>
        </trans-unit>
        <trans-unit id="7c0e13fdadda30bb92194b7ff31353209f1c6453" translate="yes" xml:space="preserve">
          <source>Structural equality test.</source>
          <target state="translated">结构性平等检验;</target>
        </trans-unit>
        <trans-unit id="1420a8bfe553843800a5e0eeda6eeea10bcce063" translate="yes" xml:space="preserve">
          <source>Structural inequality test.</source>
          <target state="translated">结构性不平等检验。</target>
        </trans-unit>
        <trans-unit id="964f4aa676065898b1577b34f94afc2774c1ff8d" translate="yes" xml:space="preserve">
          <source>Structural ordering functions.</source>
          <target state="translated">结构性排序功能;</target>
        </trans-unit>
        <trans-unit id="ba988a59552bfb50a703210d543593242c424d01" translate="yes" xml:space="preserve">
          <source>Structural ordering functions. These functions coincide with the usual orderings over integers, characters, strings, byte sequences and floating-point numbers, and extend them to a total ordering over all types. The ordering is compatible with &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt;. As in the case of &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt;, mutable structures are compared by contents. Comparison between functional values raises &lt;code&gt;Invalid_argument&lt;/code&gt;. Comparison between cyclic structures may not terminate. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">结构订购功能。这些函数与整数，字符，字符串，字节序列和浮点数的通常顺序一致，并将它们扩展为所有类型的总顺序。该顺序与 &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt; 兼容。与 &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt; 的情况一样，将可变结构按内容进行比较。函数值之间的比较会引发 &lt;code&gt;Invalid_argument&lt;/code&gt; 。循环结构之间的比较可能不会终止。左关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa1a6ce691e6d5ffdcd5ca0d0bf720c77435180e" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;groups&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;groups&lt;/code&gt; 数据库中条目的结构。</target>
        </trans-unit>
        <trans-unit id="598293f4d4d38fb64e25a27801c5bb777aed096f" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;hosts&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;hosts&lt;/code&gt; 数据库中条目的结构。</target>
        </trans-unit>
        <trans-unit id="d7118c10fc2f1d94d9826bee980fe8f7908c0e0c" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;passwd&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;passwd&lt;/code&gt; 数据库中条目的结构。</target>
        </trans-unit>
        <trans-unit id="abf82e0dcc97048077ad807e874664a09c91e309" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;protocols&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;protocols&lt;/code&gt; 数据库中条目的结构。</target>
        </trans-unit>
        <trans-unit id="a6c3d4928c346aafd5529fad82c13ccca99e8e53" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;services&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;services&lt;/code&gt; 数据库中条目的结构。</target>
        </trans-unit>
        <trans-unit id="d2e5835f238715991fb675b2b1d62d25b388199e" translate="yes" xml:space="preserve">
          <source>Structures struct &amp;hellip; end are collections of definitions for value names, type names, exceptions, module names and module type names. The definitions are evaluated in the order in which they appear in the structure. The scopes of the bindings performed by the definitions extend to the end of the structure. As a consequence, a definition may refer to names bound by earlier definitions in the same structure.</source>
          <target state="translated">结构struct&amp;hellip;end是值名称，类型名称，异常，模块名称和模块类型名称的定义的集合。定义按照它们在结构中出现的顺序进行评估。由定义执行的绑定的范围扩展到结构的末尾。结果，定义可以引用相同结构中较早的定义所绑定的名称。</target>
        </trans-unit>
        <trans-unit id="a5b58ce4dec6fe8562096a10da3109ac06c55815" translate="yes" xml:space="preserve">
          <source>Subtraction</source>
          <target state="translated">Subtraction</target>
        </trans-unit>
        <trans-unit id="85e16c85547da9b7ef56410541850d43ba4b72ba" translate="yes" xml:space="preserve">
          <source>Subtraction.</source>
          <target state="translated">Subtraction.</target>
        </trans-unit>
        <trans-unit id="f23d83765c27480ace90dc29b354fcb3af5074ca" translate="yes" xml:space="preserve">
          <source>Subtyping is never implicit. There are, however, two ways to perform subtyping. The most general construction is fully explicit: both the domain and the codomain of the type coercion must be given.</source>
          <target state="translated">子类型化从来不是隐性的。然而,有两种方法可以进行子类型化。最一般的构造是完全显式的:必须给出类型胁迫的域和同域。</target>
        </trans-unit>
        <trans-unit id="267236f12d087c344c732b17967129639c89c2dd" translate="yes" xml:space="preserve">
          <source>Successor.</source>
          <target state="translated">Successor.</target>
        </trans-unit>
        <trans-unit id="695eff1526e154751f93eceb9ecae7ae62843717" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Int32.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int32.add&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt;.</source>
          <target state="translated">接班人。 &lt;code&gt;Int32.succ&amp;nbsp;x&lt;/code&gt; 是 &lt;code&gt;Int32.add&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a88899200e53819e4fca75e68b1f2d7ef4f59f99" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Int64.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int64.add&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt;.</source>
          <target state="translated">接班人。 &lt;code&gt;Int64.succ&amp;nbsp;x&lt;/code&gt; 是 &lt;code&gt;Int64.add&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a33602394a98e9f181e6510ea20dbadc6f37f28" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Nativeint.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Nativeint.add&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt;.</source>
          <target state="translated">接班人。 &lt;code&gt;Nativeint.succ&amp;nbsp;x&lt;/code&gt; 是 &lt;code&gt;Nativeint.add&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b03e8df028a515393350967ae4387f5ffddb3921" translate="yes" xml:space="preserve">
          <source>Such abbreviations may be used alone,</source>
          <target state="translated">此类缩写可单独使用。</target>
        </trans-unit>
        <trans-unit id="a9a9a4018c6e87434fce0fcbcb6811297262044d" translate="yes" xml:space="preserve">
          <source>Such annotations of the form name: are called &lt;em&gt;labels&lt;/em&gt;. They are meant to document the code, allow more checking, and give more flexibility to function application. You can give such names to arguments in your programs, by prefixing them with a tilde ~.</source>
          <target state="translated">形式名称的此类注释：被称为&lt;em&gt;标签&lt;/em&gt;。它们旨在记录代码，允许更多检查，并为功能应用程序提供更大的灵活性。您可以在程序中为此类参数添加名称，只需在其前面加上波浪号〜即可。</target>
        </trans-unit>
        <trans-unit id="afe84014593353fc3502a2dfb59069e9aa563fb9" translate="yes" xml:space="preserve">
          <source>Such comments can take three forms: &lt;em&gt;floating comments&lt;/em&gt;, &lt;em&gt;item comments&lt;/em&gt; and &lt;em&gt;label comments&lt;/em&gt;. Any comment starting with ** which does not match one of these forms will cause the compiler to emit warning 50.</source>
          <target state="translated">这样的注释可以采用三种形式：&lt;em&gt;浮动注释&lt;/em&gt;，&lt;em&gt;项目注释&lt;/em&gt;和&lt;em&gt;标签注释&lt;/em&gt;。任何以**开头的注释与这些格式之一都不匹配，将导致编译器发出警告50。</target>
        </trans-unit>
        <trans-unit id="25da4ed1a780e343dd3f4f8e9110f06bf0afad4e" translate="yes" xml:space="preserve">
          <source>Such conjunctive constraints may be unsatisfiable. In such a case the corresponding tag may not be used in a value of this type. This does not mean that the whole type is not valid: one can still use other available tags. Conjunctive constraints are mainly intended as output from the type checker. When they are used in source programs, unsolvable constraints may cause early failures.</source>
          <target state="translated">这种共轭约束可能是不满足的。在这种情况下,相应的标签可能不会被用于此类型的值中。这并不意味着整个类型无效:人们仍然可以使用其他可用的标记。并联约束主要是作为类型检查器的输出。当它们被用于源程序中时,无法解决的约束可能会导致早期失败。</target>
        </trans-unit>
        <trans-unit id="608e778255c58bb721e1518cfabc05ef86956e7e" translate="yes" xml:space="preserve">
          <source>Such specifications are also inferred. Namely, when P is a path satisfying the above constraints,</source>
          <target state="translated">这样的规范也是推断出来的。即,当P是满足上述约束条件的路径时。</target>
        </trans-unit>
        <trans-unit id="20dbe04d5924d91567646631274eb2f545fc830d" translate="yes" xml:space="preserve">
          <source>Support libraries for the C part (-llib).</source>
          <target state="translated">支持C部分的库(-llib)。</target>
        </trans-unit>
        <trans-unit id="345aca003e713e405c83d4690e078d5d7eeef4ce" translate="yes" xml:space="preserve">
          <source>Supported layouts</source>
          <target state="translated">支持的布局</target>
        </trans-unit>
        <trans-unit id="e58a2db5e9aa8c332609520b8b74074728fd429c" translate="yes" xml:space="preserve">
          <source>Suppress header in generated documentation.</source>
          <target state="translated">在生成的文档中压制头部。</target>
        </trans-unit>
        <trans-unit id="de50b1b14218cb87a2945d6e8e68eda23b7643ee" translate="yes" xml:space="preserve">
          <source>Suppress trailer in generated documentation.</source>
          <target state="translated">在生成的文档中禁止使用拖车。</target>
        </trans-unit>
        <trans-unit id="7b699c4e85571d84428b248779bbe8ae1bbcbfbf" translate="yes" xml:space="preserve">
          <source>Suspend or restart reception or transmission of data on the given file descriptor, depending on the second argument: &lt;code&gt;TCOOFF&lt;/code&gt; suspends output, &lt;code&gt;TCOON&lt;/code&gt; restarts output, &lt;code&gt;TCIOFF&lt;/code&gt; transmits a STOP character to suspend input, and &lt;code&gt;TCION&lt;/code&gt; transmits a START character to restart input.</source>
          <target state="translated">挂起或重新启动给定文件描述符上的数据接收或传输，具体取决于第二个参数： &lt;code&gt;TCOOFF&lt;/code&gt; 挂起输出， &lt;code&gt;TCOON&lt;/code&gt; 重新启动输出， &lt;code&gt;TCIOFF&lt;/code&gt; 传送STOP字符以挂起输入， &lt;code&gt;TCION&lt;/code&gt; 传送START字符以重新开始输入。</target>
        </trans-unit>
        <trans-unit id="4f79bf2cca20cb87f53d54a2eae520b086d8ef01" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_write&lt;/code&gt;) on the given Unix file descriptor.</source>
          <target state="translated">暂停调用线程的执行，直到至少有一个字符或EOF可供读取（ &lt;code&gt;wait_read&lt;/code&gt; ）或可以在不阻塞给定Unix文件描述符的情况下写入一个字符而不会阻塞（ &lt;code&gt;wait_write&lt;/code&gt; ）为止。</target>
        </trans-unit>
        <trans-unit id="b9e7e7483847182bf81440a5b48041aad821bf57" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_write&lt;/code&gt;) on the given Unix file descriptor. Wait for at most the amount of time given as second argument (in seconds). Return &lt;code&gt;true&lt;/code&gt; if the file descriptor is ready for input/output and &lt;code&gt;false&lt;/code&gt; if the timeout expired.</source>
          <target state="translated">暂停调用线程的执行，直到至少有一个字符或EOF可供读取（ &lt;code&gt;wait_read&lt;/code&gt; ）或可以在不阻塞给定Unix文件描述符的情况下写入一个字符而不会阻塞（ &lt;code&gt;wait_write&lt;/code&gt; ）为止。等待最多第二个参数给出的时间（以秒为单位）。如果文件描述符可用于输入/输出，则返回 &lt;code&gt;true&lt;/code&gt; ;如果超时已过期，则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8346165cfb7a86989d05db06110a6d5d23ba4188" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_timed_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_timed_write&lt;/code&gt;) on the given Unix file descriptor.</source>
          <target state="translated">暂停调用线程的执行，直到至少一个字符或EOF可供读取（ &lt;code&gt;wait_timed_read&lt;/code&gt; ）或一个字符可以不受阻塞（写入 &lt;code&gt;wait_timed_write&lt;/code&gt; 在给定的Unix文件描述符）。</target>
        </trans-unit>
        <trans-unit id="90e544161b3e1ba0c206678d222617b4a3f53207" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_timed_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_timed_write&lt;/code&gt;) on the given Unix file descriptor. Wait for at most the amount of time given as second argument (in seconds). Return &lt;code&gt;true&lt;/code&gt; if the file descriptor is ready for input/output and &lt;code&gt;false&lt;/code&gt; if the timeout expired. The same functionality can be achieved with &lt;a href=&quot;unix#VALselect&quot;&gt;&lt;code&gt;Unix.select&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">暂停调用线程的执行，直到至少一个字符或EOF可供读取（ &lt;code&gt;wait_timed_read&lt;/code&gt; ）或一个字符可以不受阻塞（写入 &lt;code&gt;wait_timed_write&lt;/code&gt; 在给定的Unix文件描述符）。等待最多第二个参数给出的时间（以秒为单位）。如果文件描述符可用于输入/输出，则返回 &lt;code&gt;true&lt;/code&gt; ;如果超时已过期，则返回 &lt;code&gt;false&lt;/code&gt; 。使用&lt;a href=&quot;unix#VALselect&quot;&gt; &lt;code&gt;Unix.select&lt;/code&gt; &lt;/a&gt;可以实现相同的功能。</target>
        </trans-unit>
        <trans-unit id="dd698dfe06d0932557c1eb650583aff1c0a8f274" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until input/output becomes possible on the given Unix file descriptors.</source>
          <target state="translated">暂停调用线程的执行,直到可以在给定的Unix文件描述符上进行输入/输出。</target>
        </trans-unit>
        <trans-unit id="89b43cd2f521875a54a83bde786aa4892b785359" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until input/output becomes possible on the given Unix file descriptors. The arguments and results have the same meaning as for &lt;code&gt;Unix.select&lt;/code&gt;. This function is not implemented yet under Win32.</source>
          <target state="translated">暂停调用线程的执行，直到在给定的Unix文件描述符上可以进行输入/输出为止。参数和结果与 &lt;code&gt;Unix.select&lt;/code&gt; 的含义相同。在Win32下尚未实现此功能。</target>
        </trans-unit>
        <trans-unit id="c5ee688ede72fd80011cbf7bc6580d8f7239f6ae" translate="yes" xml:space="preserve">
          <source>Suspending threads</source>
          <target state="translated">暂停线程</target>
        </trans-unit>
        <trans-unit id="6174b4bb3312bb6b8d643916247f5c5c92a0cf44" translate="yes" xml:space="preserve">
          <source>Suspicious unused variable: unused variable that is bound with let or as, and doesn&amp;rsquo;t start with an underscore (_) character.</source>
          <target state="translated">可疑未使用变量：以let或as绑定且未以下划线（_）字符开头的未使用变量。</target>
        </trans-unit>
        <trans-unit id="11e58b2b3353eee96248693f8d563d3b5cd65b17" translate="yes" xml:space="preserve">
          <source>Suspicious-looking end-of-comment mark.</source>
          <target state="translated">长相可疑的注释末尾标记。</target>
        </trans-unit>
        <trans-unit id="ddf970710a96e309a4df7c47f666103b40de5ebd" translate="yes" xml:space="preserve">
          <source>Suspicious-looking start-of-comment mark.</source>
          <target state="translated">长得很可疑的评论开头的标记。</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="cb92d9d71dc582fcaac304377564d4e993a5d6c9" translate="yes" xml:space="preserve">
          <source>Symbol binding</source>
          <target state="translated">符号绑定</target>
        </trans-unit>
        <trans-unit id="8f08528b34287dbeb205e28df6f893eefe4bb6b5" translate="yes" xml:space="preserve">
          <source>Symbolic link</source>
          <target state="translated">符号链接</target>
        </trans-unit>
        <trans-unit id="1af7d6c34ea3d7825f1508a7baf71357f217a173" translate="yes" xml:space="preserve">
          <source>Symbolic links</source>
          <target state="translated">符号联系</target>
        </trans-unit>
        <trans-unit id="4bf49d12b0b857b45245352554b4248820e1c127" translate="yes" xml:space="preserve">
          <source>Symbolic pretty-printing</source>
          <target state="translated">符号化的漂亮印刷</target>
        </trans-unit>
        <trans-unit id="0fcc57bd9e40ddf977219a1819544a0cbcd1da68" translate="yes" xml:space="preserve">
          <source>Symbolic pretty-printing is pretty-printing using a symbolic formatter, i.e. a formatter that outputs symbolic pretty-printing items.</source>
          <target state="translated">符号漂亮打印是使用符号格式器进行漂亮打印,即输出符号漂亮打印项的格式器。</target>
        </trans-unit>
        <trans-unit id="c30177fee17f9de0bfd94e899114fd091110383c" translate="yes" xml:space="preserve">
          <source>Symbols from the class &lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;, as well as the keywords *, +, -, -., =, !=, &amp;lt;, &amp;gt;, or, ||, &amp;amp;, &amp;amp;&amp;amp;, :=, mod, land, lor, lxor, lsl, lsr, and asr can appear in infix position (between two expressions). Symbols from the class &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;, as well as the keywords - and -. can appear in prefix position (in front of an expression).</source>
          <target state="translated">来自&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;类的符号，以及关键字*，+，-，-。，=，！=，&amp;lt;，&amp;gt;或，||，＆，&amp;amp;&amp;amp;，：=，mod，land，lor，lxor ，lsl，lsr和asr可以出现在中缀位置（两个表达式之间）。类&lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol中的符号&lt;/a&gt;，以及关键字-和-。可以出现在前缀位置（在表达式前面）。</target>
        </trans-unit>
        <trans-unit id="4b8e8468d047790eb587f1fdac4b8b2c2a97f950" translate="yes" xml:space="preserve">
          <source>Syntactically, building or matching constructors with such an inline record argument is similar to working with a unary constructor whose unique argument is a declared record type. A pattern can bind the inline record as a pseudo-value, but the record cannot escape the scope of the binding and can only be used with the dot-notation to extract or modify fields or to build new constructor values.</source>
          <target state="translated">从语法上讲,用这样的内联记录参数构建或匹配构造函数,类似于使用单调构造函数,其唯一的参数是声明的记录类型。模式可以将内联记录作为一个伪值进行绑定,但该记录不能脱离绑定的范围,只能与点注一起用于提取或修改字段,或建立新的构造函数值。</target>
        </trans-unit>
        <trans-unit id="7242fc4d74104da137f0225f7f32f3f67b1f6f68" translate="yes" xml:space="preserve">
          <source>Syntax of command lines: A keyword is a character string starting with a &lt;code&gt;-&lt;/code&gt;. An option is a keyword alone or followed by an argument. The types of keywords are: &lt;code&gt;Unit&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Clear&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Set_string&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Set_int&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Set_float&lt;/code&gt;, &lt;code&gt;Tuple&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, &lt;code&gt;Rest&lt;/code&gt;, &lt;code&gt;Rest_all&lt;/code&gt; and &lt;code&gt;Expand&lt;/code&gt;.</source>
          <target state="translated">命令行的语法：关键字是一个以 &lt;code&gt;-&lt;/code&gt; 开头的字符串。选项是一个单独的关键字，或后跟一个参数。关键字的类型为： &lt;code&gt;Unit&lt;/code&gt; ， &lt;code&gt;Bool&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Clear&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Set_string&lt;/code&gt; ， &lt;code&gt;Int&lt;/code&gt; ， &lt;code&gt;Set_int&lt;/code&gt; ， &lt;code&gt;Float&lt;/code&gt; ， &lt;code&gt;Set_float&lt;/code&gt; ， &lt;code&gt;Tuple&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; ， &lt;code&gt;Rest&lt;/code&gt; ， &lt;code&gt;Rest_all&lt;/code&gt; 和 &lt;code&gt;Expand&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92a7a4f198e3ad53204452742e2bcd85c8b76c8e" translate="yes" xml:space="preserve">
          <source>Syntax of command lines: A keyword is a character string starting with a &lt;code&gt;-&lt;/code&gt;. An option is a keyword alone or followed by an argument. The types of keywords are: &lt;code&gt;Unit&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Clear&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Set_string&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Set_int&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Set_float&lt;/code&gt;, &lt;code&gt;Tuple&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, and &lt;code&gt;Rest&lt;/code&gt;. &lt;code&gt;Unit&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Clear&lt;/code&gt; keywords take no argument. A &lt;code&gt;Rest&lt;/code&gt; keyword takes the remaining of the command line as arguments. Every other keyword takes the following word on the command line as argument. For compatibility with GNU getopt_long, &lt;code&gt;keyword=arg&lt;/code&gt; is also allowed. Arguments not preceded by a keyword are called anonymous arguments.</source>
          <target state="translated">命令行的语法：关键字是一个以 &lt;code&gt;-&lt;/code&gt; 开头的字符串。选项是一个单独的关键字，或后跟一个参数。关键字的类型为： &lt;code&gt;Unit&lt;/code&gt; ， &lt;code&gt;Bool&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Clear&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Set_string&lt;/code&gt; ， &lt;code&gt;Int&lt;/code&gt; ， &lt;code&gt;Set_int&lt;/code&gt; ， &lt;code&gt;Float&lt;/code&gt; ， &lt;code&gt;Set_float&lt;/code&gt; ， &lt;code&gt;Tuple&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; 和 &lt;code&gt;Rest&lt;/code&gt; 。 &lt;code&gt;Unit&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Clear&lt;/code&gt; 关键字不带参数。一个 &lt;code&gt;Rest&lt;/code&gt; 关键字将命令行的其余部分作为参数。其他每个关键字都将命令行中的以下单词作为参数。为了与GNU getopt_long兼容，还允许使用 &lt;code&gt;keyword=arg&lt;/code&gt; 。不带关键字的参数称为匿名参数。</target>
        </trans-unit>
        <trans-unit id="eea5f6535cf1464538bf913c29432e06b44c8a00" translate="yes" xml:space="preserve">
          <source>Sys</source>
          <target state="translated">Sys</target>
        </trans-unit>
        <trans-unit id="8f7a8d4494a0d458d18524d29c3ede9485be05c9" translate="yes" xml:space="preserve">
          <source>Sys.argv is an array of strings containing the command-line parameters. Sys.argv.(1) is thus the first command-line parameter. The program above is compiled and executed with the following shell commands:</source>
          <target state="translated">Sys.argv是一个包含命令行参数的字符串数组。因此,Sys.argv.(1)是第一个命令行参数。上面的程序是用以下shell命令编译和执行的。</target>
        </trans-unit>
        <trans-unit id="77b1ff317375845ec33475f1b5fb67e6cbb973f9" translate="yes" xml:space="preserve">
          <source>System interface.</source>
          <target state="translated">系统接口。</target>
        </trans-unit>
        <trans-unit id="475b7fafddd719ea508a449badf45b0789ac88b8" translate="yes" xml:space="preserve">
          <source>System threads. This implementation builds on the OS-provided threads facilities: POSIX 1003.1c threads for Unix, and Win32 threads for Windows. When available, system threads support both bytecode and native-code programs.</source>
          <target state="translated">系统线程。这个实现是建立在操作系统提供的线程设施上的,Unix的POSIX 1003.1c线程,Windows的Win32线程。Unix的POSIX 1003.1c线程和Windows的Win32线程。在可用的情况下,系统线程同时支持字节码和本地代码程序。</target>
        </trans-unit>
        <trans-unit id="99901e02a798f32cd5219f56e51ca3215b2961b1" translate="yes" xml:space="preserve">
          <source>System time for the children processes</source>
          <target state="translated">儿童进程的系统时间</target>
        </trans-unit>
        <trans-unit id="34a877dc56d7b6f22f1f4507a6f98d13c327981d" translate="yes" xml:space="preserve">
          <source>System time for the process</source>
          <target state="translated">流程的系统时间</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="c068ca8b042bac0232c1a1485f2405cfa98b7a00" translate="yes" xml:space="preserve">
          <source>Table cache</source>
          <target state="translated">表格缓存</target>
        </trans-unit>
        <trans-unit id="88d5168e6958719b1f51075705e987c63433b18e" translate="yes" xml:space="preserve">
          <source>Tabulation boxes</source>
          <target state="translated">表格框</target>
        </trans-unit>
        <trans-unit id="982963c1c41cbed8cab073724749592fe35c532b" translate="yes" xml:space="preserve">
          <source>Tag</source>
          <target state="translated">Tag</target>
        </trans-unit>
        <trans-unit id="70ebce0319098abe29a21e0fc7bf392fb3792b10" translate="yes" xml:space="preserve">
          <source>Tag specific operations occur any time a tag is opened or closed, At each occurrence, two kinds of operations are performed &lt;em&gt;tag-marking&lt;/em&gt; and &lt;em&gt;tag-printing&lt;/em&gt;:</source>
          <target state="translated">标签特定的操作在标签打开或关闭时都会发生。在每种情况下，都会执行两种操作：&lt;em&gt;标签标记&lt;/em&gt;和&lt;em&gt;标签打印&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="21049d0d0e09867c94c7bfdcd7af965832440243" translate="yes" xml:space="preserve">
          <source>Tag-marking a semantic tag means calling the formatter specific function &lt;code&gt;mark_open_stag&lt;/code&gt; (resp. &lt;code&gt;mark_close_stag&lt;/code&gt;) with the name of the tag as argument: that tag-marking function can then return the 'tag-opening marker' (resp. `tag-closing marker') for direct output into the output device of the formatter.</source>
          <target state="translated">对语义标签进行标签标记是指使用标签名称作为参数来调用格式化程序特定的函数 &lt;code&gt;mark_open_stag&lt;/code&gt; （ &lt;code&gt;mark_close_stag&lt;/code&gt; ）：该标签标记函数随后可以返回&amp;ldquo;标签打开标记&amp;rdquo;（分别是&amp;ldquo;标签关闭标记&amp;rdquo;）。 '）直接输出到格式化程序的输出设备中。</target>
        </trans-unit>
        <trans-unit id="d0850e7bae659968c87fcd011c8098d48caf5ca1" translate="yes" xml:space="preserve">
          <source>Tag-marking and tag-printing functions are user definable and can be set by calling &lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">标签标记和标签打印功能是用户定义的，可以通过调用&lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt; &lt;/a&gt;进行设置。</target>
        </trans-unit>
        <trans-unit id="f087082b531d3d70af061b2f9983efc04fdab93a" translate="yes" xml:space="preserve">
          <source>Tag-printing a semantic tag means calling the formatter specific function &lt;code&gt;print_open_stag&lt;/code&gt; (resp. &lt;code&gt;print_close_stag&lt;/code&gt;) with the name of the tag as argument: that tag-printing function can then print any regular material to the formatter (so that this material is enqueued as usual in the formatter queue for further line splitting computation).</source>
          <target state="translated">对语义标签进行标签打印意味着以标签名称作为参数调用格式化程序特定的函数 &lt;code&gt;print_open_stag&lt;/code&gt; （ &lt;code&gt;print_close_stag&lt;/code&gt; ）：该标签打印功能随后可以将任何常规材料打印到格式化程序中（以便将该材料照常排入队列）在格式化程序队列中以进行进一步的行拆分计算）。</target>
        </trans-unit>
        <trans-unit id="3d968d48d29a395bb82a38da27ee9373279edc48" translate="yes" xml:space="preserve">
          <source>Tag_val(v) returns the tag of the block v.</source>
          <target state="translated">Tag_val(v)返回块 v 的标签。</target>
        </trans-unit>
        <trans-unit id="69680e9274247feaf41570c80b33d43c4f2d8bcd" translate="yes" xml:space="preserve">
          <source>Take one of the symbols as argument and call the function with the symbol</source>
          <target state="translated">取其中一个符号作为参数,并调用带有符号的函数。</target>
        </trans-unit>
        <trans-unit id="9d6b053ba3ae57bbab0f9ae23dd3906806ecb54b" translate="yes" xml:space="preserve">
          <source>Take several arguments according to the spec list</source>
          <target state="translated">根据规格列表取几个参数</target>
        </trans-unit>
        <trans-unit id="10762317d708b72b78e81e7071b82e94c42de1fc" translate="yes" xml:space="preserve">
          <source>Tangent.</source>
          <target state="translated">Tangent.</target>
        </trans-unit>
        <trans-unit id="780ae66c320e72eed30e1ed6d7739b9ecffb29da" translate="yes" xml:space="preserve">
          <source>Tangent. Argument is in radians.</source>
          <target state="translated">切线。论证的单位是弧度。</target>
        </trans-unit>
        <trans-unit id="8038dd5c0175f8f3d04e597ad2fbb9eac4f72a1c" translate="yes" xml:space="preserve">
          <source>Target ratio of floating garbage to major heap size for out-of-heap memory held by custom values located in the major heap. The GC speed is adjusted to try to use this much memory for dead values that are not yet collected. Expressed as a percentage of major heap size. The default value keeps the out-of-heap floating garbage about the same size as the in-heap overhead. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 44.</source>
          <target state="translated">对于位于主堆中的自定义值所持有的堆外内存，浮动垃圾与主堆大小的目标比率。已调整GC速度，以尝试将这么多的内存用于尚未收集的无效值。表示为主要堆大小的百分比。默认值使堆外浮动垃圾的大小与堆内开销的大小相同。注意：这仅适用于用 &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; 分配的值（例如bigarrays）。默认值：44</target>
        </trans-unit>
        <trans-unit id="cf716ff6c41584311aebda3a608e1a8001afd716" translate="yes" xml:space="preserve">
          <source>Tell the debugger it is executed under Emacs. (See section &amp;zwj;&lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;16.10&lt;/a&gt; for information on how to run the debugger under Emacs.)</source>
          <target state="translated">告诉调试器它在Emacs下执行。（详见&lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;16.10&lt;/a&gt;，了解如何运行的Emacs下的调试信息。）</target>
        </trans-unit>
        <trans-unit id="2fe258cc46692204a632aee373f4075f030d57a7" translate="yes" xml:space="preserve">
          <source>Tell the debugger it is executed under Emacs. (See section &lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;17.10&lt;/a&gt; for information on how to run the debugger under Emacs.)</source>
          <target state="translated">告诉调试器它在Emacs下执行。（有关如何在Emacs下运行调试器的信息，请参见第&lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;17.10&lt;/a&gt;节。）</target>
        </trans-unit>
        <trans-unit id="19b9145b33f4838c5f3973e7a6ea5d0f05c03b03" translate="yes" xml:space="preserve">
          <source>Tell whether the lexer buffer keeps track of position fields &lt;code&gt;lex_curr_p&lt;/code&gt; / &lt;code&gt;lex_start_p&lt;/code&gt;, as determined by the corresponding optional argument for functions that create lexer buffers (whose default value is &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">告诉lexer缓冲区是否跟踪位置字段 &lt;code&gt;lex_curr_p&lt;/code&gt; / &lt;code&gt;lex_start_p&lt;/code&gt; ，该位置字段由创建lexer缓冲区的函数（其默认值为 &lt;code&gt;true&lt;/code&gt; ）的相应可选参数确定。</target>
        </trans-unit>
        <trans-unit id="d7cd37004c27ae67bd613fe7aaf8dda4c2d384cf" translate="yes" xml:space="preserve">
          <source>Terminal interface</source>
          <target state="translated">终端接口</target>
        </trans-unit>
        <trans-unit id="df7e4a1d29e38609effa51863fd181383dbf7780" translate="yes" xml:space="preserve">
          <source>Terminal read from background process</source>
          <target state="translated">从后台进程读取终端</target>
        </trans-unit>
        <trans-unit id="69f382ea876bbdcbdd4d90e629da7780e4617313" translate="yes" xml:space="preserve">
          <source>Terminal write from background process</source>
          <target state="translated">终端从后台进程写入</target>
        </trans-unit>
        <trans-unit id="4813943164d0564fe70ad323f19653347b352115" translate="yes" xml:space="preserve">
          <source>Terminate prematurely the currently executing thread.</source>
          <target state="translated">提前终止当前正在执行的线程。</target>
        </trans-unit>
        <trans-unit id="56b1260afe50cb577a901efc314311be666089c4" translate="yes" xml:space="preserve">
          <source>Terminate prematurely the thread whose handle is given.</source>
          <target state="translated">过早地终止其句柄被赋予的线程。</target>
        </trans-unit>
        <trans-unit id="1edd80b3bab286216daf4e49c9f5cc789375f130" translate="yes" xml:space="preserve">
          <source>Terminate the calling process immediately, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure.</source>
          <target state="translated">立即终止调用进程,向操作系统返回给定的状态码:通常0表示没有错误,一个小正整数表示失败。</target>
        </trans-unit>
        <trans-unit id="dbcaba753b832dde4b1cb373e039bf131ee31f81" translate="yes" xml:space="preserve">
          <source>Terminate the calling process immediately, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure. Unlike &lt;a href=&quot;stdlib#VALexit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VAL_exit&quot;&gt;&lt;code&gt;Unix._exit&lt;/code&gt;&lt;/a&gt; performs no finalization whatsoever: functions registered with &lt;a href=&quot;stdlib#VALat_exit&quot;&gt;&lt;code&gt;at_exit&lt;/code&gt;&lt;/a&gt; are not called, input/output channels are not flushed, and the C run-time system is not finalized either.</source>
          <target state="translated">立即终止调用过程，将给定的状态码返回给操作系统：通常为0表示没有错误，而一个小的正整数表示失败。与&lt;a href=&quot;stdlib#VALexit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt;不同，&lt;a href=&quot;unix#VAL_exit&quot;&gt; &lt;code&gt;Unix._exit&lt;/code&gt; 不&lt;/a&gt;执行任何终结处理：不调用&lt;a href=&quot;stdlib#VALat_exit&quot;&gt; &lt;code&gt;at_exit&lt;/code&gt; &lt;/a&gt;注册的函数，不刷新输入/输出通道，也不对C运行时系统进行终结处理。</target>
        </trans-unit>
        <trans-unit id="26070bd7d4995159490297bd3d133957b3f011a9" translate="yes" xml:space="preserve">
          <source>Terminate the process, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure.</source>
          <target state="translated">终止进程,向操作系统返回给定的状态码:通常0表示没有错误,一个小正整数表示失败。</target>
        </trans-unit>
        <trans-unit id="0574c95a3a93d600e83a6f17eb926a568c0f9796" translate="yes" xml:space="preserve">
          <source>Terminate the process, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure. All open output channels are flushed with &lt;code&gt;flush_all&lt;/code&gt;. An implicit &lt;code&gt;exit&amp;nbsp;0&lt;/code&gt; is performed each time a program terminates normally. An implicit &lt;code&gt;exit&amp;nbsp;2&lt;/code&gt; is performed if the program terminates early because of an uncaught exception.</source>
          <target state="translated">终止该过程，将给定的状态码返回给操作系统：通常为0表示没有错误，而一个小的正整数表示失败。所有打开的输出通道都用 &lt;code&gt;flush_all&lt;/code&gt; 刷新。每次程序正常终止时，都会执行隐式 &lt;code&gt;exit&amp;nbsp;0&lt;/code&gt; 。如果程序由于未捕获的异常而提前终止，则执行隐式 &lt;code&gt;exit&amp;nbsp;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ee85218866a19e0d9f6c52c176e4eaf9d0877b2" translate="yes" xml:space="preserve">
          <source>Termination</source>
          <target state="translated">Termination</target>
        </trans-unit>
        <trans-unit id="158a94f8a2ff46fde496827d38e93851db51f5cc" translate="yes" xml:space="preserve">
          <source>Termination (cannot be ignored)</source>
          <target state="translated">终止(不能忽视)</target>
        </trans-unit>
        <trans-unit id="bb7a1f1e99b2c211113bd77cc5e7ef277a13ed74" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;greater than or equal&amp;rdquo;.</source>
          <target state="translated">测试&amp;ldquo;大于或等于&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cf55a085e33342b3081a9dd990d9070f808b5872" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;greater than&amp;rdquo;.</source>
          <target state="translated">测试&amp;ldquo;大于&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8c0f5c5dfaba7d5a348d0be90ebda99ec96925bd" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;less than or equal&amp;rdquo;.</source>
          <target state="translated">测试&amp;ldquo;小于或等于&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9023e669869c2a8e4df262bd37b076a1baa1f732" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;less than&amp;rdquo;.</source>
          <target state="translated">测试&amp;ldquo;小于&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4da88b01def945bdf24685deea788a8bc6d1da26" translate="yes" xml:space="preserve">
          <source>Test a region for other process locks</source>
          <target state="translated">测试一个区域的其他进程锁</target>
        </trans-unit>
        <trans-unit id="1787fedd7d2ced2ae48a3c3ae605449bb9a29103" translate="yes" xml:space="preserve">
          <source>Test if a file with the given name exists.</source>
          <target state="translated">测试给定名称的文件是否存在。</target>
        </trans-unit>
        <trans-unit id="b5d1af12b9f30270fd2ed2ad3dee29830b903b74" translate="yes" xml:space="preserve">
          <source>Test if two sets are disjoint.</source>
          <target state="translated">测试两个集合是否不相交。</target>
        </trans-unit>
        <trans-unit id="e1ac6c65bc9783f51306843b3f179afc02bc939b" translate="yes" xml:space="preserve">
          <source>Test whether a map is empty or not.</source>
          <target state="translated">测试地图是否为空。</target>
        </trans-unit>
        <trans-unit id="9521be20f61e3370ee61a403fa6f607a9a6420ea" translate="yes" xml:space="preserve">
          <source>Test whether a set is empty or not.</source>
          <target state="translated">测试一个集合是否为空。</target>
        </trans-unit>
        <trans-unit id="862bb20b2924b0e1bad9177d10a2c297215a311c" translate="yes" xml:space="preserve">
          <source>Tests if the maximum number of pretty-printing boxes allowed have already been opened.</source>
          <target state="translated">测试允许的最大数量的漂亮打印框是否已经被打开。</target>
        </trans-unit>
        <trans-unit id="d4721ae7197912536ec105c3ffe10fe5fe1d70fa" translate="yes" xml:space="preserve">
          <source>That is, the fun expression above evaluates to a curried function with n arguments: after applying this function n times to the values v&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; v&lt;sub&gt;n&lt;/sub&gt;, the values will be matched in parallel against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matching succeeds, the function returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; in an environment enriched by the bindings performed during the matchings. If the matching fails, the exception Match_failure is raised.</source>
          <target state="translated">就是说，上面的fun表达式对一个带有n个参数的咖喱函数求值：将这个函数对值v &lt;sub&gt;1&lt;/sub&gt; &amp;hellip;v &lt;sub&gt;n&lt;/sub&gt;应用n次后，这些值将与&lt;a href=&quot;patterns#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;并行匹配。如果匹配成功，则函数将在匹配过程中执行的绑定丰富的环境中返回&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的值。如果匹配失败，则会引发异常Match_failure。</target>
        </trans-unit>
        <trans-unit id="75556997ae93b7cf1b53d4c2255859edf696d5cd" translate="yes" xml:space="preserve">
          <source>That is, to define a new generator, one must implement a module with the expected signature, and with the given generator class, providing the generate method as entry point to make the generator generates documentation for a given list of modules &amp;zwj;:</source>
          <target state="translated">也就是说，要定义一个新的生成器，必须实现一个具有预期签名并具有给定生成器类的模块，并提供generate方法作为入口点，以使生成器为给定的模块列表生成文档&amp;zwj;：</target>
        </trans-unit>
        <trans-unit id="bb5dc7fe2f26372eda5226bac4a48e313d4e2b62" translate="yes" xml:space="preserve">
          <source>That is, to define a new generator, one must implement a module with the expected signature, and with the given generator class, providing the generate method as entry point to make the generator generates documentation for a given list of modules :</source>
          <target state="translated">也就是说,要定义一个新的生成器,必须实现一个具有预期签名的模块,并与给定的生成器类,提供生成方法作为切入点,使生成器生成给定模块列表的文档。</target>
        </trans-unit>
        <trans-unit id="cfe811707b86c6cce7b1af403f14e7f36cdc5d76" translate="yes" xml:space="preserve">
          <source>The &quot;release&quot; operation of a binary semaphore sets its value to 1, and &quot;acquire&quot; waits until the value is 1 and sets it to 0.</source>
          <target state="translated">二进制旗语的 &quot;释放 &quot;操作将其值设为1,&quot;获取 &quot;则等到值为1时再设为0。</target>
        </trans-unit>
        <trans-unit id="7ed38f27c94cab8c8d12304ae06126526d04b8bb" translate="yes" xml:space="preserve">
          <source>The (type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;) syntax construction by itself does not make polymorphic the type variable it introduces, but it can be combined with explicit polymorphic annotations where needed. The above rule is provided as syntactic sugar to make this easier:</source>
          <target state="translated">（type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;）语法构造本身不会使多态成为它引入的类型变量，但是可以在需要时将其与显式多态注释结合使用。上面的规则作为语法糖提供，以使其更容易：</target>
        </trans-unit>
        <trans-unit id="c4991a041e774dadbe4b581939be63f5a7cbe4ea" translate="yes" xml:space="preserve">
          <source>The -no-stop option to ocamldoc causes the Stop special comments to be ignored.</source>
          <target state="translated">ocamldoc的-no-stop选项会导致Stop特殊注释被忽略。</target>
        </trans-unit>
        <trans-unit id="3147fca5c37d9a1563cc013c628673b530b03e57" translate="yes" xml:space="preserve">
          <source>The -opaque option, available since 4.04, disables cross-module optimization information for the currently compiled unit. When compiling .mli interface, using -opaque marks the compiled .cmi interface so that subsequent compilations of modules that depend on it will not rely on the corresponding .cmx file, nor warn if it is absent. When the native compiler compiles a .ml implementation, using -opaque generates a .cmx that does not contain any cross-module optimization information.</source>
          <target state="translated">从4.04开始可用的-opaque选项会禁用当前编译单元的跨模块优化信息。当编译 .mli 接口时,使用 -opaque 标记编译后的 .cmi 接口,这样后续编译依赖它的模块时就不会依赖相应的 .cmx 文件,如果它不存在,也不会发出警告。当本地编译器编译.ml实现时,使用-opaque会生成一个不包含任何跨模块优化信息的.cmx。</target>
        </trans-unit>
        <trans-unit id="564904d19df6fc8011ad3d2bee2ea1a4e77ad2e7" translate="yes" xml:space="preserve">
          <source>The -output-obj option can also be used to obtain the C source file. More interestingly, the same option can also produce directly a shared library (.so file, .dll under Windows) that contains the OCaml code, the OCaml runtime system and any other static C code given to ocamlc (.o, .a, respectively, .obj, .lib). This use of -output-obj is very similar to a normal linking step, but instead of producing a main program that automatically runs the OCaml code, it produces a shared library that can run the OCaml code on demand. The three possible behaviors of -output-obj are selected according to the extension of the resulting file (given with -o).</source>
          <target state="translated">也可以用-output-obj选项来获取C源文件。更有趣的是,同一个选项还可以直接生成一个共享库(.so文件,Windows下为.dll),其中包含了OCaml代码、OCaml运行时系统和任何其他给ocamlc的静态C代码(.o、.a,分别为.obj、.lib)。这种使用-output-obj的方式与普通的链接步骤非常相似,但它不是产生一个自动运行OCaml代码的主程序,而是产生一个可以按需运行OCaml代码的共享库。根据生成文件的扩展名(用-o给出)选择-output-obj的三种可能行为。</target>
        </trans-unit>
        <trans-unit id="3b36f21e3b344b1468a19dcfe1a7ba5421f00dae" translate="yes" xml:space="preserve">
          <source>The -unbox-closures-factor command line flag, which takes an integer, may be used to adjust the point at which a function is deemed large enough to be ineligible for duplication. The benefit of duplication is scaled by the integer before being evaluated against the size.</source>
          <target state="translated">命令行标志-unbox-closures-factor,取一个整数,可以用来调整一个函数被认为足够大,不符合复制条件的点。复制的好处在对大小进行评估之前,会先按整数进行缩放。</target>
        </trans-unit>
        <trans-unit id="a2209f3894b8163766592d29f0ebe68de13e2bfb" translate="yes" xml:space="preserve">
          <source>The .cmi and .cmo files produced by the compiler have the same base name as the source file. Hence, the compiled files always have their base name equal (modulo capitalization of the first letter) to the name of the module they describe (for .cmi files) or implement (for .cmo files).</source>
          <target state="translated">编译器生成的.cmi和.cmo文件的基本名称与源文件相同。因此,编译后的文件的基本名称总是与它们所描述的模块名称(对于.cmi文件)或执行的模块名称(对于.cmo文件)相等(第一个字母大写)。</target>
        </trans-unit>
        <trans-unit id="b721260b32a59d156249128e83aba8efd5e1aba3" translate="yes" xml:space="preserve">
          <source>The .cmx object files being combined must have been compiled with the appropriate -for-pack option. In the example above, A.cmx, B.cmx and C.cmx must have been compiled with ocamlopt -for-pack P.</source>
          <target state="translated">被合并的.cmx对象文件必须已经用适当的-for-pack选项编译过。在上面的例子中,A.cmx、B.cmx 和 C.cmx 必须用 ocamlopt -for-pack P 编译。</target>
        </trans-unit>
        <trans-unit id="f8d1d5867cdb0bfd731826d0c29b478c2ae3ed20" translate="yes" xml:space="preserve">
          <source>The 32-bit code generator for Intel/AMD x86 processors (i386 architecture) supports the following additional option:</source>
          <target state="translated">英特尔/AMD x86处理器(i386架构)的32位代码生成器支持以下附加选项。</target>
        </trans-unit>
        <trans-unit id="19cf8b2f632836f4f34c4d1b723f6f2c4408241e" translate="yes" xml:space="preserve">
          <source>The 32-bit integer -1.</source>
          <target state="translated">32位整数-1。</target>
        </trans-unit>
        <trans-unit id="25bfbe3425f7612c84c4a60433757b0cd2caa725" translate="yes" xml:space="preserve">
          <source>The 32-bit integer 0.</source>
          <target state="translated">32位整数0。</target>
        </trans-unit>
        <trans-unit id="adf5ef41fc3f6cfaf4d8f1db7abf1ec88c03da49" translate="yes" xml:space="preserve">
          <source>The 32-bit integer 1.</source>
          <target state="translated">32位整数1。</target>
        </trans-unit>
        <trans-unit id="77b20c5219874b842e364037b79509517abba8bd" translate="yes" xml:space="preserve">
          <source>The 64-bit code generator for Intel/AMD x86 processors (amd64 architecture) supports the following additional options:</source>
          <target state="translated">英特尔/AMD x86处理器(amd64架构)的64位代码生成器支持以下附加选项。</target>
        </trans-unit>
        <trans-unit id="006eed8987b86bde9c7f054166d4c4843fab6c03" translate="yes" xml:space="preserve">
          <source>The 64-bit integer -1.</source>
          <target state="translated">64位整数-1。</target>
        </trans-unit>
        <trans-unit id="157479d5f01ffa68d3fe29e3a78c6d437b79bcf0" translate="yes" xml:space="preserve">
          <source>The 64-bit integer 0.</source>
          <target state="translated">64位整数0。</target>
        </trans-unit>
        <trans-unit id="629c9977446445c9cf7c1aa59f2924bbe702fd82" translate="yes" xml:space="preserve">
          <source>The 64-bit integer 1.</source>
          <target state="translated">64位整数1。</target>
        </trans-unit>
        <trans-unit id="6b95251b3f2b1a3e28a4b746eb2d6fd549aedfc0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; syntactic class appearing in the (module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) type expression and in the annotated forms represents a subset of module types. This subset consists of named module types with optional constraints of a limited form: only non-parametrized types can be specified.</source>
          <target state="translated">出现在（模块&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）类型表达式中并以注释形式出现的&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;句法类表示模块类型的子集。该子集由命名模块类型组成，并具有有限形式的可选约束：只能指定非参数化类型。</target>
        </trans-unit>
        <trans-unit id="6682753740053ec4013bd76f06934bf2221ce480" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; should describe when the element was deprecated, what to use as a replacement, and possibly the reason for deprecation.</source>
          <target state="translated">该&lt;a href=&quot;#text&quot;&gt;文本&lt;/a&gt;应描述当元素已被废弃，以什么作为替代，可能弃用的原因使用。</target>
        </trans-unit>
        <trans-unit id="8fcbebcee75dae7d24519bf68c433e5e177f48a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;morelabels.set.make&quot;&gt;&lt;code&gt;MoreLabels.Set.Make&lt;/code&gt;&lt;/a&gt; functor constructs implementations for any type, given a &lt;code&gt;compare&lt;/code&gt; function. For instance:</source>
          <target state="translated">该&lt;a href=&quot;morelabels.set.make&quot;&gt; &lt;code&gt;MoreLabels.Set.Make&lt;/code&gt; &lt;/a&gt;仿函数构造实现任何类型，给出一个 &lt;code&gt;compare&lt;/code&gt; 功能。例如：</target>
        </trans-unit>
        <trans-unit id="cde17ed2d9a66d67e67d6fe2b53d455fb37fc839" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; functor constructs implementations for any type, given a &lt;code&gt;compare&lt;/code&gt; function. For instance:</source>
          <target state="translated">该&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;仿函数构造实现任何类型，给出一个 &lt;code&gt;compare&lt;/code&gt; 功能。例如：</target>
        </trans-unit>
        <trans-unit id="a4ed2561f30b1f4e9552cc537f7755aeeba34c0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Int32.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;int32#VALmax_int&quot;&gt;&lt;code&gt;Int32.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int32.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int32.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;0u&lt;/code&gt; 前缀读取输入作为在范围内的无符号的整数 &lt;code&gt;[0,&amp;nbsp;2*Int32.max_int+1]&lt;/code&gt; 。如果输入超过&lt;a href=&quot;int32#VALmax_int&quot;&gt; &lt;code&gt;Int32.max_int&lt;/code&gt; ,则将&lt;/a&gt;其转换为有符号整数 &lt;code&gt;Int32.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int32.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23dffe6eb51ba2abaa4cfa566ea1b02078814e57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Int64.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;int64#VALmax_int&quot;&gt;&lt;code&gt;Int64.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int64.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;0u&lt;/code&gt; 前缀读取输入作为在范围内的无符号的整数 &lt;code&gt;[0,&amp;nbsp;2*Int64.max_int+1]&lt;/code&gt; 。如果输入超过&lt;a href=&quot;int64#VALmax_int&quot;&gt; &lt;code&gt;Int64.max_int&lt;/code&gt; ,则将&lt;/a&gt;其转换为有符号整数 &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int64.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bdf559646ed66e4c76c9311859fb36ebd722036" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Nativeint.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;nativeint#VALmax_int&quot;&gt;&lt;code&gt;Nativeint.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Nativeint.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;0u&lt;/code&gt; 前缀读取输入作为在范围内的无符号的整数 &lt;code&gt;[0,&amp;nbsp;2*Nativeint.max_int+1]&lt;/code&gt; 。如果输入超过&lt;a href=&quot;nativeint#VALmax_int&quot;&gt; &lt;code&gt;Nativeint.max_int&lt;/code&gt; ,则将&lt;/a&gt;其转换为有符号整数 &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Nativeint.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d37cd54b36382c9e5496e2092f5aaa8dc45ad01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;stdlib#VALmax_int&quot;&gt;&lt;code&gt;max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;0u&lt;/code&gt; 前缀读取输入作为在范围内的无符号的整数 &lt;code&gt;[0,&amp;nbsp;2*max_int+1]&lt;/code&gt; 。如果输入超过&lt;a href=&quot;stdlib#VALmax_int&quot;&gt; &lt;code&gt;max_int&lt;/code&gt; ,&lt;/a&gt;它将转换为有符号整数 &lt;code&gt;min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61b166f6086faf0c742754df16fab62941896c59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Exit&lt;/code&gt; exception is not raised by any library function.</source>
          <target state="translated">在 &lt;code&gt;Exit&lt;/code&gt; 异常没有被任何库函数提高。</target>
        </trans-unit>
        <trans-unit id="618dcafc239b4a1cd930e5a52c4ba8ab644cc7e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Exit&lt;/code&gt; exception is not raised by any library function. It is provided for use in your programs.</source>
          <target state="translated">在 &lt;code&gt;Exit&lt;/code&gt; 异常没有被任何库函数提高。提供它供您在程序中使用。</target>
        </trans-unit>
        <trans-unit id="54bcc8ec2f507902da16600415bbcb8e20ed4f95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F_LOCK&lt;/code&gt; and &lt;code&gt;F_TLOCK&lt;/code&gt; commands attempts to put a write lock on the specified region. The &lt;code&gt;F_RLOCK&lt;/code&gt; and &lt;code&gt;F_TRLOCK&lt;/code&gt; commands attempts to put a read lock on the specified region. If one or several locks put by another process prevent the current process from acquiring the lock, &lt;code&gt;F_LOCK&lt;/code&gt; and &lt;code&gt;F_RLOCK&lt;/code&gt; block until these locks are removed, while &lt;code&gt;F_TLOCK&lt;/code&gt; and &lt;code&gt;F_TRLOCK&lt;/code&gt; fail immediately with an exception. The &lt;code&gt;F_ULOCK&lt;/code&gt; removes whatever locks the current process has on the specified region. Finally, the &lt;code&gt;F_TEST&lt;/code&gt; command tests whether a write lock can be acquired on the specified region, without actually putting a lock. It returns immediately if successful, or fails otherwise.</source>
          <target state="translated">该 &lt;code&gt;F_LOCK&lt;/code&gt; 和 &lt;code&gt;F_TLOCK&lt;/code&gt; 命令试图将一个写锁在指定区域。该 &lt;code&gt;F_RLOCK&lt;/code&gt; 和 &lt;code&gt;F_TRLOCK&lt;/code&gt; 命令试图把一个读锁定在指定的区域。如果另一个进程放置的一个或几个锁阻止当前进程获取该锁，则 &lt;code&gt;F_LOCK&lt;/code&gt; 和 &lt;code&gt;F_RLOCK&lt;/code&gt; 会阻塞，直到这些锁被删除为止，而 &lt;code&gt;F_TLOCK&lt;/code&gt; 和 &lt;code&gt;F_TRLOCK&lt;/code&gt; 会立即异常失败。该 &lt;code&gt;F_ULOCK&lt;/code&gt; 无论锁定当前过程中除去对指定区域。最后， &lt;code&gt;F_TEST&lt;/code&gt; 命令测试是否可以在不实际放置锁的情况下在指定区域上获取写锁。如果成功，它将立即返回，否则将失败。</target>
        </trans-unit>
        <trans-unit id="38136ee726cf908eb5522e7345bd976551936ebd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Format&lt;/code&gt; module is versatile enough to let you completely redefine the meaning of pretty-printing output: you may provide your own functions to define how to handle indentation, line splitting, and even printing of all the characters that have to be printed!</source>
          <target state="translated">该 &lt;code&gt;Format&lt;/code&gt; 模块是通用的，足以让你彻底重新定义的格式打印输出的含义是：你可以提供自己的函数定义如何处理缩进，行分裂，甚至在打印所有必须打印的字符！</target>
        </trans-unit>
        <trans-unit id="68315cad3ec5fa750806e2fcfa1b99271143dfe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; (underscore) character can appear anywhere in the string and is ignored.</source>
          <target state="translated">该 &lt;code&gt;_&lt;/code&gt; （下划线）字符的字符串中的任何地方出现，将被忽略。</target>
        </trans-unit>
        <trans-unit id="0dcf95ffbbacb39e9db9049899df2d9baf6d087f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cloexec&lt;/code&gt; optional arguments and the &lt;code&gt;O_KEEPEXEC&lt;/code&gt; flag were introduced in OCaml 4.05. Earlier, the common practice was to create file descriptors in the default, ``keep-on-exec'' mode, then call &lt;code&gt;set_close_on_exec&lt;/code&gt; on those freshly-created file descriptors. This is not as safe as creating the file descriptor in ``close-on-exec'' mode because, in multithreaded programs, a window of vulnerability exists between the time when the file descriptor is created and the time &lt;code&gt;set_close_on_exec&lt;/code&gt; completes. If another thread spawns another program during this window, the descriptor will leak, as it is still in the ``keep-on-exec'' mode.</source>
          <target state="translated">该 &lt;code&gt;cloexec&lt;/code&gt; 可选参数和 &lt;code&gt;O_KEEPEXEC&lt;/code&gt; 标志OCaml中4.05进行了介绍。早些时候，通常的做法是在默认的``keep-on-exec''模式下创建文件描述符，然后对这些新创建的文件描述符调用 &lt;code&gt;set_close_on_exec&lt;/code&gt; 。这不像在``close-on-exec''模式下创建文件描述符那样安全，因为在多线程程序中，在创建文件描述符的时间与 &lt;code&gt;set_close_on_exec&lt;/code&gt; 完成的时间之间存在一个漏洞窗口。如果另一个线程在此窗口中生成另一个程序，则描述符将泄漏，因为它仍处于``keep-on-exec''模式。</target>
        </trans-unit>
        <trans-unit id="1eb7c114770073f6910d08925899aa9381142883" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compare&lt;/code&gt; function can be used as the comparison function required by the &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt; functors, as well as the &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">的 &lt;code&gt;compare&lt;/code&gt; 功能可以作为由所需的比较函数&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt;函子，以及所述&lt;a href=&quot;list#VALsort&quot;&gt; &lt;code&gt;List.sort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;array#VALsort&quot;&gt; &lt;code&gt;Array.sort&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="9e2d6e8ecc1f534250d3b0fe9ad0f7fcb8f3fbb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal&lt;/code&gt; relation must be able to work on a shallow copy of the values and give the same result as with the values themselves.</source>
          <target state="translated">在 &lt;code&gt;equal&lt;/code&gt; 的关系必须能够对值的浅拷贝工作，并给予同样的结果与这些值本身。</target>
        </trans-unit>
        <trans-unit id="42475c29a84bb6547470710fd8e643615f2c721d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;f&lt;/code&gt; function can use all features of OCaml, including assignments that make the value reachable again. It can also loop forever (in this case, the other finalisation functions will not be called during the execution of f, unless it calls &lt;code&gt;finalise_release&lt;/code&gt;). It can call &lt;code&gt;finalise&lt;/code&gt; on &lt;code&gt;v&lt;/code&gt; or other values to register other functions or even itself. It can raise an exception; in this case the exception will interrupt whatever the program was doing when the function was called.</source>
          <target state="translated">该 &lt;code&gt;f&lt;/code&gt; 功能可以使用OCaml的所有功能，包括任务，从而再次进行值可达。它也可以永远循环（在这种情况下，除非执行 &lt;code&gt;finalise_release&lt;/code&gt; ，否则其他终结函数不会在f执行期间被调用）。它可以在 &lt;code&gt;v&lt;/code&gt; 或其他值上调用 &lt;code&gt;finalise&lt;/code&gt; 以注册其他函数，甚至注册自身。它可能会引发异常；在这种情况下，异常将中断调用该函数时程序正在执行的操作。</target>
        </trans-unit>
        <trans-unit id="b556f0336e223bedcd6066a8e647fbdbfaf3934e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush&lt;/code&gt; function is called whenever the pretty-printer is flushed (via conversion &lt;code&gt;%!&lt;/code&gt;, or pretty-printing indications &lt;code&gt;@?&lt;/code&gt; or &lt;code&gt;@.&lt;/code&gt;, or using low level functions &lt;code&gt;print_flush&lt;/code&gt; or &lt;code&gt;print_newline&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;flush&lt;/code&gt; 每当美化打印机刷新函数被调用（通过转换 &lt;code&gt;%!&lt;/code&gt; ，还是蛮印刷迹象 &lt;code&gt;@?&lt;/code&gt; 或 &lt;code&gt;@.&lt;/code&gt; ，或使用低级别的功能 &lt;code&gt;print_flush&lt;/code&gt; 或 &lt;code&gt;print_newline&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="27ca5eda4c43f08d46a2c695faa646d521db2882" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;out&lt;/code&gt; function performs all the pretty-printer string output. It is called with a string &lt;code&gt;s&lt;/code&gt;, a start position &lt;code&gt;p&lt;/code&gt;, and a number of characters &lt;code&gt;n&lt;/code&gt;; it is supposed to output characters &lt;code&gt;p&lt;/code&gt; to &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;out&lt;/code&gt; 函数执行所有漂亮的打印机输出字符串。它由字符串 &lt;code&gt;s&lt;/code&gt; ，起始位置 &lt;code&gt;p&lt;/code&gt; 和许多字符 &lt;code&gt;n&lt;/code&gt; 来调用。它应该输出字符 &lt;code&gt;p&lt;/code&gt; 到 &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75d43060306ebfa6fa32ab493326575601269afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print_&lt;/code&gt; field of the record contains the tag-printing functions that are called at tag opening and tag closing time, to output regular material in the pretty-printer queue.</source>
          <target state="translated">记录的 &lt;code&gt;print_&lt;/code&gt; 字段包含在标签打开和标签关闭时调用的标签打印功能，以在漂亮打印机队列中输出常规材料。</target>
        </trans-unit>
        <trans-unit id="056af88ed3bcf5589ed5c7b7003c98a7067f4a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print_open_stag&lt;/code&gt; tag-printing function of the formatter is called with &lt;code&gt;t&lt;/code&gt; as argument; then the opening tag marker for &lt;code&gt;t&lt;/code&gt;, as given by &lt;code&gt;mark_open_stag&amp;nbsp;t&lt;/code&gt;, is written into the output device of the formatter.</source>
          <target state="translated">使用 &lt;code&gt;t&lt;/code&gt; 作为参数调用格式化程序的 &lt;code&gt;print_open_stag&lt;/code&gt; 标记打印功能；然后开始标记标记 &lt;code&gt;t&lt;/code&gt; ，如下式给出 &lt;code&gt;mark_open_stag&amp;nbsp;t&lt;/code&gt; ，被写入到格式化器的输出装置。</target>
        </trans-unit>
        <trans-unit id="e08dda4298e3191068d142ddd263ae997f8088ec" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;eventlog_metadata&lt;/em&gt; file can be found at this path and copied in the same directory as the generated trace file. However, &lt;em&gt;babeltrace&lt;/em&gt; expects the file to be named metadata in order to process the trace. Thus, it will need to be renamed when copied to the trace&amp;rsquo;s directory.</source>
          <target state="translated">该&lt;em&gt;eventlog_metadata&lt;/em&gt;文件可以在这个路径中找到，并在同一目录下生成的跟踪文件复制。但是，&lt;em&gt;babeltrace&lt;/em&gt;希望将文件命名为元数据以便处理跟踪。因此，将其复制到跟踪的目录时将需要重命名。</target>
        </trans-unit>
        <trans-unit id="f53775be5e375c4dc7ef58b639a6d408285df99f" translate="yes" xml:space="preserve">
          <source>The AMD64 code generator (64-bit versions of Intel Pentium and AMD Athlon) supports the following additional options:</source>
          <target state="translated">AMD64代码生成器(Intel Pentium和AMD Athlon的64位版本)支持以下附加选项。</target>
        </trans-unit>
        <trans-unit id="65568e29c592dc9019c9f674c81a29c684908ec4" translate="yes" xml:space="preserve">
          <source>The C code can then invoke OCaml functions using the callback mechanism (see section &amp;zwj;&lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;18.7.1&lt;/a&gt;).</source>
          <target state="translated">C代码然后可以调用使用回调机制OCaml的功能（见&lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;18.7.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fb87a73c92ae01d9c7c4db3849eb48ff0818dc23" translate="yes" xml:space="preserve">
          <source>The C code can then invoke OCaml functions using the callback mechanism (see section &lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt;).</source>
          <target state="translated">然后，C代码可以使用回调机制调用OCaml函数（请参见&lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt;节）。</target>
        </trans-unit>
        <trans-unit id="876e3c62a7b0d3bf41a4b52452f9a2cbc0c89632" translate="yes" xml:space="preserve">
          <source>The C code can then recover the exception identifier using caml_named_value and pass it as first argument to the functions raise_constant, raise_with_arg, and raise_with_string (described in section &amp;zwj;&lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;18.4.5&lt;/a&gt;) to actually raise the exception. For example, here is a C function that raises the Error exception with the given argument:</source>
          <target state="translated">然后将C代码可以使用caml_named_value恢复异常标识，并将其传递作为第一个参数的功能raise_constant，raise_with_arg和raise_with_string（在部分中描述&lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;18.4.5&lt;/a&gt;）来实际提高异常。例如，下面是一个C函数，该函数使用给定的参数引发Error异常：</target>
        </trans-unit>
        <trans-unit id="8e464c9797631ebce99ef6cccb7cb68c06035632" translate="yes" xml:space="preserve">
          <source>The C code can then recover the exception identifier using caml_named_value and pass it as first argument to the functions raise_constant, raise_with_arg, and raise_with_string (described in section &lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;20.4.5&lt;/a&gt;) to actually raise the exception. For example, here is a C function that raises the Error exception with the given argument:</source>
          <target state="translated">然后，C代码可以使用caml_named_value恢复异常标识符，并将其作为第一个参数传递给函数raise_constant，raise_with_arg和raise_with_string（在&lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;20.4.5&lt;/a&gt;节中进行了介绍），以实际引发异常。例如，下面是一个C函数，该函数使用给定的参数引发Error异常：</target>
        </trans-unit>
        <trans-unit id="aa93c2abc45968f3784b93eb9dcd8bd6529c1ecd" translate="yes" xml:space="preserve">
          <source>The C part of the program must provide a main function, which will override the default main function provided by the OCaml runtime system. Execution will start in the user-defined main function just like for a regular C program.</source>
          <target state="translated">程序的C部分必须提供一个主函数,它将覆盖OCaml运行时系统提供的默认主函数。执行将在用户定义的主函数中开始,就像普通C程序一样。</target>
        </trans-unit>
        <trans-unit id="50e4f4eda019d6551e91347a8e71357c4a87e23b" translate="yes" xml:space="preserve">
          <source>The CAML macros use identifiers (local variables, type identifiers, structure tags) that start with caml__. Do not use any identifier starting with caml__ in your programs.</source>
          <target state="translated">CAML 宏使用以 caml__开头的标识符(局部变量、类型标识符、结构标签)。在你的程序中不要使用任何以caml__开头的标识符。</target>
        </trans-unit>
        <trans-unit id="947f7ca3d56e80606a767e9b12f1a9e600046008" translate="yes" xml:space="preserve">
          <source>The Flambda inlining heuristics, used whenever the compiler is configured for Flambda and -Oclassic was not specified, make inlining decisions at call sites. This helps in situations where the context is important. For example:</source>
          <target state="translated">Flambda内联启发式方法,在编译器配置为Flambda且未指定-Oclassic时使用,在调用站点做出内联决定。这在上下文很重要的情况下很有帮助。例如</target>
        </trans-unit>
        <trans-unit id="3d5b0d2b11b3ee57c6f9a2ae20c6f1a2b2492c1f" translate="yes" xml:space="preserve">
          <source>The Flambda mode is described in the next section.</source>
          <target state="translated">Flambda模式将在下一节介绍。</target>
        </trans-unit>
        <trans-unit id="1a8cbe3e5a223fda241e040fe66da36a6dedfca0" translate="yes" xml:space="preserve">
          <source>The Flambda optimisers classify expressions in order to determine whether an expression:</source>
          <target state="translated">Flambda优化器对表达式进行分类,以确定一个表达式是否。</target>
        </trans-unit>
        <trans-unit id="4a55df8086c936ee6955c4d5f1e4e9c60c3a3b17" translate="yes" xml:space="preserve">
          <source>The Flambda optimisers provide a variety of command-line flags that may be used to control their behaviour. Detailed descriptions of each flag are given in the referenced sections. Those sections also describe any arguments which the particular flags take.</source>
          <target state="translated">Flambda优化器提供了多种命令行标志,可以用来控制它们的行为。每个标志的详细描述在参考章节中给出。这些章节还描述了特定标志所使用的任何参数。</target>
        </trans-unit>
        <trans-unit id="1f41ece3d458792a5a112edf6fe3a0fc355449cf" translate="yes" xml:space="preserve">
          <source>The GADT type &lt;code&gt;'a&amp;nbsp;layout&lt;/code&gt; represents one of the two supported memory layouts: C-style or Fortran-style. Its constructors are re-exported as values below for backward-compatibility reasons.</source>
          <target state="translated">GADT类型 &lt;code&gt;'a&amp;nbsp;layout&lt;/code&gt; 代表两种受支持的内存布局之一：C样式或Fortran样式。由于向后兼容的原因，其构造函数重新导出为以下值。</target>
        </trans-unit>
        <trans-unit id="9592e7237389ee2174122cfd60652798cead6941" translate="yes" xml:space="preserve">
          <source>The GADT type &lt;code&gt;('a,&amp;nbsp;'b)&amp;nbsp;kind&lt;/code&gt; captures this association of an OCaml type &lt;code&gt;'a&lt;/code&gt; for values read or written in the Bigarray, and of an element kind &lt;code&gt;'b&lt;/code&gt; which represents the actual contents of the Bigarray. Its constructors list all possible associations of OCaml types with element kinds, and are re-exported below for backward-compatibility reasons.</source>
          <target state="translated">GADT类型 &lt;code&gt;('a,&amp;nbsp;'b)&amp;nbsp;kind&lt;/code&gt; 捕获了在Bigarray中读取或写入的值的OCaml类型 &lt;code&gt;'a&lt;/code&gt; 与表示Bigarray实际内容的元素类型 &lt;code&gt;'b&lt;/code&gt; 的这种关联。它的构造函数列出了OCaml类型与元素类型的所有可能关联，并出于向后兼容的原因在下面重新导出。</target>
        </trans-unit>
        <trans-unit id="dd7b721d0850765e0f33c133f4e389240cfc627b" translate="yes" xml:space="preserve">
          <source>The GC parameters are given as a &lt;code&gt;control&lt;/code&gt; record.</source>
          <target state="translated">GC参数作为 &lt;code&gt;control&lt;/code&gt; 记录给出。</target>
        </trans-unit>
        <trans-unit id="95efad48009e26c2e773fa9f3a23237febe8ef7a" translate="yes" xml:space="preserve">
          <source>The GC parameters are given as a &lt;code&gt;control&lt;/code&gt; record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of &lt;code&gt;ocamlrun&lt;/code&gt;.</source>
          <target state="translated">GC参数作为 &lt;code&gt;control&lt;/code&gt; 记录给出。请注意，也可以通过设置OCAMLRUNPARAM环境变量来初始化这些参数。请参阅 &lt;code&gt;ocamlrun&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="c85d7c1fb9f174f09ac7febf2cc5071806120427" translate="yes" xml:space="preserve">
          <source>The GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to &lt;code&gt;finalise&lt;/code&gt;. If &lt;code&gt;finalise&lt;/code&gt; is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.</source>
          <target state="translated">GC将按取消分配的顺序调用终结函数。当多个值在同一时间（即，在同一GC周期内）变得不可访问时，将以与相应的 &lt;code&gt;finalise&lt;/code&gt; 调用相反的顺序调用finalization函数。如果按与分配值相同的顺序调用 &lt;code&gt;finalise&lt;/code&gt; 则意味着每个值都在其依赖的值之前完成。当然，如果分配引入了其他依赖关系，则这将成为错误。</target>
        </trans-unit>
        <trans-unit id="7795741ff8b943ea1be2628f77110237f9e449f7" translate="yes" xml:space="preserve">
          <source>The HTML tags &amp;lt;b&amp;gt;..&amp;lt;/b&amp;gt;, &amp;lt;code&amp;gt;..&amp;lt;/code&amp;gt;, &amp;lt;i&amp;gt;..&amp;lt;/i&amp;gt;, &amp;lt;ul&amp;gt;..&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;..&amp;lt;/ol&amp;gt;, &amp;lt;li&amp;gt;..&amp;lt;/li&amp;gt;, &amp;lt;center&amp;gt;..&amp;lt;/center&amp;gt; and &amp;lt;h[0-9]&amp;gt;..&amp;lt;/h[0-9]&amp;gt; can be used instead of, respectively, {b ..} , [..] , {i ..} , {ul ..} , {ol ..} , {li ..} , {C ..} and {[0-9] ..}.</source>
          <target state="translated">HTML标签&amp;lt;b&amp;gt; .. &amp;lt;/ b&amp;gt;，&amp;lt;code&amp;gt; .. &amp;lt;/ code&amp;gt;，&amp;lt;i&amp;gt;。&amp;lt;/ i&amp;gt;，&amp;lt;ul&amp;gt;。&amp;lt;/ ul&amp;gt;，&amp;lt;ol&amp;gt;。&amp;lt;/可以分别使用ol&amp;gt;，&amp;lt;li&amp;gt; .. &amp;lt;/ li&amp;gt;，&amp;lt;center&amp;gt; .. &amp;lt;/ center&amp;gt;和&amp;lt;h [0-9]&amp;gt; .. &amp;lt;/ h [0-9]&amp;gt;代替{b ..}，[..]，{i ..}，{ul ..}，{ol ..}，{li ..}，{C ..}和{[0-9] ..} 。</target>
        </trans-unit>
        <trans-unit id="e0385ec9d501a25d53c3aad498dad447e84092fe" translate="yes" xml:space="preserve">
          <source>The IA32 code generator (Intel Pentium, AMD Athlon) supports the following additional option:</source>
          <target state="translated">IA32代码生成器(Intel Pentium、AMD Athlon)支持以下附加选项。</target>
        </trans-unit>
        <trans-unit id="d32d0bbbe468bebfac2e7c376f0e2c87a1ae0cea" translate="yes" xml:space="preserve">
          <source>The MD5 hash function is not cryptographically secure. Hence, this module should not be used for security-sensitive applications. More recent, stronger cryptographic primitives should be used instead.</source>
          <target state="translated">MD5哈希函数在密码学上不安全。因此,这个模块不应该用于安全敏感的应用。应使用较新的、较强的加密基元。</target>
        </trans-unit>
        <trans-unit id="f406da7037c42f4a4f464bf9db0658f383ecf08c" translate="yes" xml:space="preserve">
          <source>The OCaml Standard library.</source>
          <target state="translated">OCaml标准库。</target>
        </trans-unit>
        <trans-unit id="3cd9888d4cc0302f8bc1d09fa4ef39df6a3ff2b8" translate="yes" xml:space="preserve">
          <source>The OCaml debugger has a simple on-line help system, which gives a brief description of each command and variable.</source>
          <target state="translated">OCaml调试器有一个简单的在线帮助系统,它给出了每个命令和变量的简要说明。</target>
        </trans-unit>
        <trans-unit id="75b7f273467919c29f03470504af44cab3766154" translate="yes" xml:space="preserve">
          <source>The OCaml debugger is invoked by running the program ocamldebug with the name of the bytecode executable file as first argument:</source>
          <target state="translated">OCaml调试器是通过运行程序ocamldebug调用的,第一个参数是字节码可执行文件的名称。</target>
        </trans-unit>
        <trans-unit id="13488dcd67078760c0511e807304bd3a788513ec" translate="yes" xml:space="preserve">
          <source>The OCaml debugger is started under Emacs by the command M-x camldebug, with argument the name of the executable file progname to debug. Communication with the debugger takes place in an Emacs buffer named *camldebug-progname*. The editing and history facilities of Shell mode are available for interacting with the debugger.</source>
          <target state="translated">OCaml 调试器在 Emacs 下由 M-x camldebug 命令启动,参数是要调试的可执行文件 progname 的名称。与调试器的通信发生在一个名为*camldebug-progname*的Emacs缓冲区中。Shell模式的编辑和历史记录功能可以用于与调试器交互。</target>
        </trans-unit>
        <trans-unit id="0701bb96dd9335c1a8b9cd5991613a9554bc96eb" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user&amp;rsquo;s manual is copyright &amp;copy; 2020 Institut National de Recherche en Informatique et en Automatique (INRIA).</source>
          <target state="translated">OCaml文档和用户手册的版权归&amp;copy;2020年信息安全和自动化研究所（INRIA）所有。</target>
        </trans-unit>
        <trans-unit id="063309f868ad72cc8f639e2db6e77b695df7e9cb" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user&amp;rsquo;s manual is copyright &amp;copy; 2021 Institut National de Recherche en Informatique et en Automatique (INRIA).</source>
          <target state="translated">OCaml文档和用户手册的版权归&amp;copy;2021国家信息安全和自动化研究所（INRIA）所有。</target>
        </trans-unit>
        <trans-unit id="1af4680eb3a182fd7749d661362740023609c59f" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user's manual is licensed under a &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.</source>
          <target state="translated">OCaml文档和用户手册已根据&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License获得许可&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf8bacefcbad184b18e85f7294594e9bb4eeae34" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user's manual is licensed under a &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.</source>
          <target state="translated">OCaml文档和用户手册已根据&lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License获得许可&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a12bf6d10452a673a4059a176328235b4073891" translate="yes" xml:space="preserve">
          <source>The OCaml notation for the type of a function with multiple arguments is</source>
          <target state="translated">有多个参数的函数类型的OCaml符号是</target>
        </trans-unit>
        <trans-unit id="3b300bbe66442808bbe9b55b3a38db2ca2b4dfb4" translate="yes" xml:space="preserve">
          <source>The OCaml run-time system is not reentrant: at any time, at most one thread can be executing OCaml code or C code that uses the OCaml run-time system. Technically, this is enforced by a &amp;ldquo;master lock&amp;rdquo; that any thread must hold while executing such code.</source>
          <target state="translated">OCaml运行时系统不是可重入的：在任何时候，最多一个线程可以执行使用OCaml运行时系统的OCaml代码或C代码。从技术上讲，这是由&amp;ldquo;主锁&amp;rdquo;强制执行的，任何线程在执行此类代码时都必须持有该主锁。</target>
        </trans-unit>
        <trans-unit id="e888d1165d4d21dea5f4e7b7872ca6fbab7bdab8" translate="yes" xml:space="preserve">
          <source>The OCaml runtime system comprises three main parts: the bytecode interpreter, the memory manager, and a set of C functions that implement the primitive operations. Some bytecode instructions are provided to call these C functions, designated by their offset in a table of functions (the table of primitives).</source>
          <target state="translated">OCaml运行时系统主要由三部分组成:字节码解释器、内存管理器和一组实现基元操作的C函数。提供了一些字节码指令来调用这些C函数,由它们在函数表中的偏移量指定(基元表)。</target>
        </trans-unit>
        <trans-unit id="0a9ec24fe8572105b571386cc4dee94c3a1b7683" translate="yes" xml:space="preserve">
          <source>The OCaml scanning facility is reminiscent of the corresponding C feature. However, it is also largely different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and the parameter passing mechanism is just the regular function application not the variable assignment based mechanism which is typical for formatted input in imperative languages; the OCaml format strings also feature useful additions to easily define complex tokens; as expected within a functional programming language, the formatted input functions also support polymorphism, in particular arbitrary interaction with polymorphic user-defined scanners. Furthermore, the OCaml formatted input facility is fully type-checked at compile time.</source>
          <target state="translated">OCaml的扫描设施让人联想到相应的C语言功能。但是,它也有很大的不同,更简单,却更强大:格式化输入函数是高阶函数,参数传递机制只是常规函数的应用,而不是基于变量赋值的机制,这是典型的命令式语言中格式化输入的机制;OCaml格式字符串还具有有用的附加功能,可以方便地定义复杂的标记;正如在函数式编程语言中所期望的那样,格式化输入函数还支持多态性,特别是与多态性用户定义扫描器的任意交互。此外,OCaml格式化输入设施在编译时完全进行了类型检查。</target>
        </trans-unit>
        <trans-unit id="abc31968fdf618dcf3aa38d81db7bcb91f6bbaf6" translate="yes" xml:space="preserve">
          <source>The OCaml system</source>
          <target state="translated">OCaml系统</target>
        </trans-unit>
        <trans-unit id="c00ea3211d757c3befa9662576a06b2a3d185969" translate="yes" xml:space="preserve">
          <source>The OCaml system computes both the value and the type for each phrase. Even function parameters need no explicit type declaration: the system infers their types from their usage in the function. Notice also that integers and floating-point numbers are distinct types, with distinct operators: + and * operate on integers, but +. and *. operate on floats.</source>
          <target state="translated">OCaml系统会计算每个短语的值和类型。即使是函数参数也不需要明确的类型声明:系统会根据它们在函数中的用法推断它们的类型。还请注意,整数和浮点数是不同的类型,有不同的操作符。+和*对整数进行操作,但+.和*.对浮点数进行操作。</target>
        </trans-unit>
        <trans-unit id="108a7dca000ccd9968ece57a159ab22379aec497" translate="yes" xml:space="preserve">
          <source>The OCaml system is copyright &amp;copy; 1996&amp;ndash;2020 Institut National de Recherche en Informatique et en Automatique (INRIA). INRIA holds all ownership rights to the OCaml system.</source>
          <target state="translated">OCaml系统的版权&amp;copy;1996&amp;ndash;2020信息技术与自动化研究所（INRIA）。INRIA拥有OCaml系统的所有所有权。</target>
        </trans-unit>
        <trans-unit id="be8f0d00e054bffe0a529a091f45121dddd7f60f" translate="yes" xml:space="preserve">
          <source>The OCaml system is copyright &amp;copy; 1996&amp;ndash;2021 Institut National de Recherche en Informatique et en Automatique (INRIA). INRIA holds all ownership rights to the OCaml system.</source>
          <target state="translated">OCaml系统的版权归&amp;copy;1996-2021国立信息安全与自动化研究所（INRIA）所有。INRIA拥有OCaml系统的所有所有权。</target>
        </trans-unit>
        <trans-unit id="1e41ebd883056d903f296e46ca32d4e99959d066" translate="yes" xml:space="preserve">
          <source>The OCaml system is open source and can be freely redistributed. See the file LICENSE in the distribution for licensing information.</source>
          <target state="translated">OCaml系统是开源的,可以自由地重新分配。请参阅发行版中的LICENSE文件,了解授权信息。</target>
        </trans-unit>
        <trans-unit id="6a6d62f8ada2e0a3471af00a4f2d72e08bf53548" translate="yes" xml:space="preserve">
          <source>The OCaml system under Windows can be configured at build time in one of two modes:</source>
          <target state="translated">Windows下的OCaml系统可以在构建时以两种模式之一进行配置。</target>
        </trans-unit>
        <trans-unit id="46e485e11802130ef8432b55f6c33406ef03529e" translate="yes" xml:space="preserve">
          <source>The OCaml type system checks that the type of the arguments and the specifiers are compatible. If you pass it an argument of a type that does not correspond to the format specifier, the compiler will display an error message:</source>
          <target state="translated">OCaml类型系统会检查参数和指定符的类型是否兼容。如果你传给它一个类型与格式指定符不一致的参数,编译器将显示一个错误信息。</target>
        </trans-unit>
        <trans-unit id="b075ff3a2ce27b8853b8203828c331ee0dc266ff" translate="yes" xml:space="preserve">
          <source>The PowerPC code generator supports the following additional options:</source>
          <target state="translated">PowerPC代码生成器支持以下附加选项。</target>
        </trans-unit>
        <trans-unit id="595a52e6177f37e25c12ad26af16912ffc174450" translate="yes" xml:space="preserve">
          <source>The Windows API uses the UTF-16 encoding to support Unicode. The runtime system performs the necessary conversions so that the OCaml programmer only needs to deal with the OCaml encoding. C stubs that call Windows Unicode APIs need to use specific runtime functions to perform the necessary conversions in a compatible way.</source>
          <target state="translated">Windows API使用UTF-16编码来支持Unicode。运行时系统会执行必要的转换,因此OCaml程序员只需要处理OCaml编码。调用Windows Unicode API的C存根需要使用特定的运行时函数,以兼容的方式执行必要的转换。</target>
        </trans-unit>
        <trans-unit id="5e58e4ef240f0b79192b60989a00c3560ae96550" translate="yes" xml:space="preserve">
          <source>The above class money reveals a problem that often occurs with binary methods. In order to interact with other objects of the same class, the representation of money objects must be revealed, using a method such as value. If we remove all binary methods (here plus and leq), the representation can easily be hidden inside objects by removing the method value as well. However, this is not possible as soon as some binary method requires access to the representation of objects of the same class (other than self).</source>
          <target state="translated">上面的类money揭示了二进制方法经常出现的一个问题。为了与同类的其他对象进行交互,必须揭示金钱对象的表示,使用value这样的方法。如果我们去掉所有的二进制方法(这里是加和leq),那么通过把方法值也去掉,就可以很容易地把表示隐藏在对象内部。但是,只要有一些二进制方法需要访问同一类对象(除self之外)的表示,这就不可能了。</target>
        </trans-unit>
        <trans-unit id="0c2b2bc28098b3a5ed96c8509e9d54181688aacc" translate="yes" xml:space="preserve">
          <source>The above considerations can usually be ignored if your lists are not longer than about 10000 elements.</source>
          <target state="translated">如果你的列表长度不超过10000个元素左右,通常可以忽略上述考虑。</target>
        </trans-unit>
        <trans-unit id="1275e5b0fd632a0adb161ae45fd343dd0a7ed674" translate="yes" xml:space="preserve">
          <source>The above definition of functional_point is not equivalent to the following:</source>
          <target state="translated">上述functional_point的定义不等于下面的定义。</target>
        </trans-unit>
        <trans-unit id="ca1370db07df54b9210798f4a752f3703b356815" translate="yes" xml:space="preserve">
          <source>The above definition will only backup one level. The backup facility can be added to any class by using multiple inheritance.</source>
          <target state="translated">以上定义只能备份一个级别。可以通过使用多重继承的方式将备份设施添加到任何类中。</target>
        </trans-unit>
        <trans-unit id="044810ffbb768ce3b2056b4a6f6c69fc26ffde37" translate="yes" xml:space="preserve">
          <source>The above specification, inside a signature, only matches a module definition equal to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;. Conversely, a type-level module alias can be matched by itself, or by any supertype of the type of the module it references.</source>
          <target state="translated">签名中的以上规范仅匹配等于&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;的模块定义。相反，类型级别的模块别名可以自己匹配，也可以通过其引用的模块类型的任何超类型进行匹配。</target>
        </trans-unit>
        <trans-unit id="6a4efe688ae0c8753fcbb050f0706980508ba0af" translate="yes" xml:space="preserve">
          <source>The above variant types were polymorphic, allowing further refinement. When writing type annotations, one will most often describe fixed variant types, that is types that cannot be refined. This is also the case for type abbreviations. Such types do not contain &amp;lt; or &amp;gt;, but just an enumeration of the tags and their associated types, just like in a normal datatype definition.</source>
          <target state="translated">上面的变体类型是多态的，允许进一步完善。编写类型注释时，通常会描述固定的变体类型，即无法优化的类型。类型缩写也是如此。此类类型不包含&amp;lt;或&amp;gt;，而只是标签及其关联类型的枚举，就像在普通数据类型定义中一样。</target>
        </trans-unit>
        <trans-unit id="4ef217485c89f7960da6716b91dd0fabc645656e" translate="yes" xml:space="preserve">
          <source>The abstract type &lt;code&gt;backtrace_slot&lt;/code&gt; represents a single slot of a backtrace.</source>
          <target state="translated">抽象类型 &lt;code&gt;backtrace_slot&lt;/code&gt; 表示回溯的单个插槽。</target>
        </trans-unit>
        <trans-unit id="739286bc505e97139a598fe8147fb7a3765c2deb" translate="yes" xml:space="preserve">
          <source>The abstract type &lt;code&gt;raw_backtrace&lt;/code&gt; stores a backtrace in a low-level format, instead of directly exposing them as string as the &lt;code&gt;get_backtrace()&lt;/code&gt; function does.</source>
          <target state="translated">抽象类型 &lt;code&gt;raw_backtrace&lt;/code&gt; 以低级格式存储回溯，而不是像 &lt;code&gt;get_backtrace()&lt;/code&gt; 函数那样将其直接显示为字符串。</target>
        </trans-unit>
        <trans-unit id="af764d88af01f9903675386eab28fc1408ce8155" translate="yes" xml:space="preserve">
          <source>The abstract type of Internet addresses.</source>
          <target state="translated">互联网地址的抽象类型。</target>
        </trans-unit>
        <trans-unit id="481d24b8ea9ec5881b68246c8998a8f47be76742" translate="yes" xml:space="preserve">
          <source>The abstract type of buffers.</source>
          <target state="translated">缓冲器的抽象类型。</target>
        </trans-unit>
        <trans-unit id="4026004092ed45c6dd9c41b6b253ecdb6f12e44c" translate="yes" xml:space="preserve">
          <source>The abstract type of file descriptors.</source>
          <target state="translated">文件描述符的抽象类型。</target>
        </trans-unit>
        <trans-unit id="012fb3dc8bc487525d0af4de37a9ed3cffd39a71" translate="yes" xml:space="preserve">
          <source>The actions are arbitrary OCaml expressions. They are evaluated in a context where the identifiers defined by using the as construct are bound to subparts of the matched string. Additionally, lexbuf is bound to the current lexer buffer. Some typical uses for lexbuf, in conjunction with the operations on lexer buffers provided by the Lexing standard library module, are listed below.</source>
          <target state="translated">动作是任意的 OCaml 表达式。它们在上下文中被评估,在上下文中,通过使用as结构定义的标识符被绑定到匹配字符串的子部分。此外,lexbuf被绑定到当前的lexer缓冲区。下面列出了lexbuf的一些典型用途,结合Lexing标准库模块提供的对lexer缓冲区的操作。</target>
        </trans-unit>
        <trans-unit id="f24608a60c588712f36527d1438e6185c4caa81b" translate="yes" xml:space="preserve">
          <source>The advantage of those printers based on the %a specifier is that they can be composed together to create more complex printers step by step. We can define a combinator that can turn a printer for 'a type into a printer for 'a optional:</source>
          <target state="translated">这些基于%a指定符的打印机的优点是可以将它们组合在一起,逐步创建更复杂的打印机。我们可以定义一个组合器,将'a类型的打印机变成'a可选的打印机。</target>
        </trans-unit>
        <trans-unit id="08b7a0d96acbf6b2533907cd2c43896611cce1c8" translate="yes" xml:space="preserve">
          <source>The aims of inlining are:</source>
          <target state="translated">内联的目的是:</target>
        </trans-unit>
        <trans-unit id="4e4b4f885867a255a22ab6931eddd051e8225ed9" translate="yes" xml:space="preserve">
          <source>The all-time favorite: a desk calculator. This program reads arithmetic expressions on standard input, one per line, and prints their values. Here is the grammar definition:</source>
          <target state="translated">一直以来的最爱:桌面计算器。这个程序读取标准输入的算术表达式,每行一个,并打印它们的值。下面是语法定义。</target>
        </trans-unit>
        <trans-unit id="ac2c39dacdc6a9be5743e68f1dd99fbde2e43c29" translate="yes" xml:space="preserve">
          <source>The allocation of the pair has been eliminated.</source>
          <target state="translated">对的分配已被淘汰。</target>
        </trans-unit>
        <trans-unit id="3bdf6e627c88ed40af03f752c75a521013dd60d7" translate="yes" xml:space="preserve">
          <source>The allocation of the pair within f has been removed. (Since the two closures for loop&amp;rsquo; and loop2&amp;rsquo; are constant they will also be lifted to toplevel with no runtime allocation penalty. This would also happen without having run the transformation to unbox specialise arguments.)</source>
          <target state="translated">f中的线对分配已被删除。（由于loop'和loop2'的两个闭包是恒定的，因此它们也将被提升到顶级，而不会造成运行时分配损失。这也将发生，而无需运行转换以取消装箱specialize参数。）</target>
        </trans-unit>
        <trans-unit id="f2de0b011f578d5d6e9c61968919404fdcc2ece6" translate="yes" xml:space="preserve">
          <source>The alternative is of course to build the library without extra options:</source>
          <target state="translated">当然,另一种选择是在没有额外选项的情况下建库。</target>
        </trans-unit>
        <trans-unit id="0e2dd4f451a8dcf054a1812b560aca93e651aa0b" translate="yes" xml:space="preserve">
          <source>The amount of profiling information can be controlled through the -P option to ocamlcp or ocamloptp, followed by one or several letters indicating which parts of the program should be profiled:</source>
          <target state="translated">剖析信息的数量可以通过ocamlcp或ocamloptp的-P选项来控制,后面是一个或几个字母,表示程序的哪些部分应该被剖析。</target>
        </trans-unit>
        <trans-unit id="8ab3f2331e8b1749d459c0080607551039b5ae36" translate="yes" xml:space="preserve">
          <source>The annotation virtual here is only used to mention a method without providing its definition. Since we didn&amp;rsquo;t add the private annotation, this makes the method public, keeping the original definition.</source>
          <target state="translated">这里的虚拟注解仅用于提及一种方法，而没有提供其定义。由于我们未添加私有批注，因此这将使方法公开，并保留原始定义。</target>
        </trans-unit>
        <trans-unit id="f58bb108f6951aa34759425d8ee753adc0f3924e" translate="yes" xml:space="preserve">
          <source>The answer is that when confronted with multiple options, OCaml tries to use locally available information to disambiguate between the various fields and constructors. First, if the type of the record or variant is known, OCaml can pick unambiguously the corresponding field or constructor. For instance:</source>
          <target state="translated">答案是,当面对多个选项时,OCaml会尝试使用本地可用的信息来区分不同的字段和构造函数。首先,如果知道记录或变体的类型,OCaml可以毫不含糊地挑选出相应的字段或构造函数。例如</target>
        </trans-unit>
        <trans-unit id="611a6a75c3c1ff11eb7d3c599a9f649411be363a" translate="yes" xml:space="preserve">
          <source>The answer is twofold. One first aspect is that while being pretty efficient, the lack of static type information allows for less optimizations, and makes polymorphic variants slightly heavier than core language ones. However noticeable differences would only appear on huge data structures.</source>
          <target state="translated">答案是两个方面。第一个方面是,虽然效率相当高,但由于缺乏静态类型信息,使得优化程度较低,使得多态变体比核心语言变体略重。然而明显的差异只会出现在巨大的数据结构上。</target>
        </trans-unit>
        <trans-unit id="2e0ae228161936f806d34344dc59d7232112d71f" translate="yes" xml:space="preserve">
          <source>The argument f to iter is invariant so the function may be specialised:</source>
          <target state="translated">iter的参数f是不变的,所以函数可能会被专门化。</target>
        </trans-unit>
        <trans-unit id="f3e5632dfa7a2b83bf829cdc816e3c1a87c98674" translate="yes" xml:space="preserve">
          <source>The argument of &lt;a href=&quot;sys#VALcommand&quot;&gt;&lt;code&gt;Sys.command&lt;/code&gt;&lt;/a&gt; is generally the name of a command followed by zero, one or several arguments, separated by whitespace. The given argument is interpreted by a shell: either the Windows shell &lt;code&gt;cmd.exe&lt;/code&gt; for the Win32 ports of OCaml, or the POSIX shell &lt;code&gt;sh&lt;/code&gt; for other ports. It can contain shell builtin commands such as &lt;code&gt;echo&lt;/code&gt;, and also special characters such as file redirections &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;, which will be honored by the shell.</source>
          <target state="translated">&lt;a href=&quot;sys#VALcommand&quot;&gt; &lt;code&gt;Sys.command&lt;/code&gt; &lt;/a&gt;的自变量通常是命令的名称，后跟零个，一个或多个自变量，并用空格分隔。给定的参数由Shell解释：Windows外壳 &lt;code&gt;cmd.exe&lt;/code&gt; (用于OCaml的Win32端口），或POSIX shell &lt;code&gt;sh&lt;/code&gt; (用于其他端口）。它可以包含shell内置命令（例如 &lt;code&gt;echo&lt;/code&gt; ）以及特殊字符（例如文件重定向 &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; )，这些字符将被shell接受。</target>
        </trans-unit>
        <trans-unit id="7c32b048d109d34646b19b7212d9e49b0e7c2fe1" translate="yes" xml:space="preserve">
          <source>The arguments following program are optional, and are passed as command-line arguments to the program being debugged. (See also the set arguments command.)</source>
          <target state="translated">程序后面的参数是可选的,作为命令行参数传递给被调试的程序。参见设置参数命令。</target>
        </trans-unit>
        <trans-unit id="adbf5b37a6462b0983b5bf9cd33bf85f4db819aa" translate="yes" xml:space="preserve">
          <source>The arguments of sum-type constructors can now be defined using the same syntax as records. Mutable and polymorphic fields are allowed. GADT syntax is supported. Attributes can be specified on individual fields.</source>
          <target state="translated">现在可以使用与记录相同的语法来定义和型构造函数的参数。允许使用可变和多态字段。支持GADT语法。可以在单个字段上指定属性。</target>
        </trans-unit>
        <trans-unit id="82ce2f746abf0188689410ed58dc502e67dced4e" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) of a primitive is automatically determined from its OCaml type in the external declaration, by counting the number of function arrows in the type. For instance, input above has arity 4, and the input C function is called with four arguments. Similarly,</source>
          <target state="translated">一个基元的arity(参数数)是由其外部声明中的OCaml类型自动确定的,通过计算该类型中的函数箭头数来确定。例如,上面的input的arity为4,调用input的C函数就有4个参数。同理。</target>
        </trans-unit>
        <trans-unit id="e00a28237987af7a41897bd91d033f1bf8d96517" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) of a primitive is automatically determined from its OCaml type in the external declaration, by counting the number of function arrows in the type. For instance, seek_in above has arity 2, and the caml_ml_seek_in C function is called with two arguments. Similarly,</source>
          <target state="translated">一个基元的arity(参数数)是根据其外部声明中的OCaml类型,通过计算该类型中的函数箭头数自动确定的。例如,上面的seek_in的arity为2,调用caml_ml_seek_in C函数时有两个参数。同理。</target>
        </trans-unit>
        <trans-unit id="2ab01eca841b7f4d65b6116a30c2bd33e79dbb17" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;a&lt;/code&gt; must have exactly &lt;code&gt;N&lt;/code&gt; dimensions, and all coordinates must lie inside the array bounds, as described for &lt;code&gt;Genarray.get&lt;/code&gt;; otherwise, &lt;code&gt;Invalid_argument&lt;/code&gt; is raised.</source>
          <target state="translated">数组 &lt;code&gt;a&lt;/code&gt; 必须恰好具有 &lt;code&gt;N&lt;/code&gt; 个维度，并且所有坐标都必须位于数组范围内，如 &lt;code&gt;Genarray.get&lt;/code&gt; 所述。否则，将引发 &lt;code&gt;Invalid_argument&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="868ea2ab054abe050c8bc298a300a68a34cb7e0b" translate="yes" xml:space="preserve">
          <source>The as construct is similar to &amp;ldquo;&lt;em&gt;groups&lt;/em&gt;&amp;rdquo; as provided by numerous regular expression packages. The type of these variables can be string, char, string option or char option.</source>
          <target state="translated">as构造类似于由许多正则表达式包提供的&amp;ldquo; &lt;em&gt;groups&lt;/em&gt; &amp;rdquo;。这些变量的类型可以是字符串，字符，字符串选项或字符选项。</target>
        </trans-unit>
        <trans-unit id="73177bb5797d8e28b73870b15973e78612bd93d2" translate="yes" xml:space="preserve">
          <source>The associated parser would be a function from &lt;code&gt;token&amp;nbsp;stream&lt;/code&gt; to, for instance, &lt;code&gt;int&lt;/code&gt;, and would have rules such as:</source>
          <target state="translated">相关的解析器会从一个函数 &lt;code&gt;token&amp;nbsp;stream&lt;/code&gt; 来，例如， &lt;code&gt;int&lt;/code&gt; ，而且会对规则，如：</target>
        </trans-unit>
        <trans-unit id="2420f95fc8ad57ab7c1da6f7e6377e30752e6e0e" translate="yes" xml:space="preserve">
          <source>The author of the element. One author per @author tag. There may be several @author tags for the same element.</source>
          <target state="translated">该元素的作者。每个@author标签只能有一个作者。同一元素可以有多个@author标签。</target>
        </trans-unit>
        <trans-unit id="7c7873377d2e12a00df000be90fb6b4a6087455b" translate="yes" xml:space="preserve">
          <source>The basic form for defining a module component is module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, which evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; and binds the result to the name &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;.</source>
          <target state="translated">定义模块组件的基本形式是module &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; = &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;，它评估&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;并将结果绑定到名称&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="842164f73b83f27f15ffe93e1ec98838de6e836b" translate="yes" xml:space="preserve">
          <source>The behavior is not defined if the hash table is modified by &lt;code&gt;f&lt;/code&gt; during the iteration.</source>
          <target state="translated">如果哈希表在迭代过程中被 &lt;code&gt;f&lt;/code&gt; 修改，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="c7911b90c87825476ae85d935bdfc9f902a9f2ea" translate="yes" xml:space="preserve">
          <source>The behavior is not defined if the hash table is modified during the iteration.</source>
          <target state="translated">如果在迭代过程中修改了哈希表,则不定义该行为。</target>
        </trans-unit>
        <trans-unit id="c2864aadac566232a3bcdc4cb624a8b2acaaa672" translate="yes" xml:space="preserve">
          <source>The behavior of other forms of letrec definitions is implementation-dependent. The current implementation also supports a certain class of recursive definitions of non-functional values, as explained in section &amp;zwj;&lt;a href=&quot;letrecvalues#s%3Aletrecvalues&quot;&gt;8.1&lt;/a&gt;.</source>
          <target state="translated">letrec定义的其他形式的行为取决于实现。当前的实现还支持某些类的非功能性值的递归定义，如在部分说明&lt;a href=&quot;letrecvalues#s%3Aletrecvalues&quot;&gt;8.1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d6058839cd5d6f864ed769e103e1c4571b14c4b" translate="yes" xml:space="preserve">
          <source>The behavior of other forms of letrec definitions is implementation-dependent. The current implementation also supports a certain class of recursive definitions of non-functional values, as explained in section &lt;a href=&quot;letrecvalues#s%3Aletrecvalues&quot;&gt;8.1&lt;/a&gt;.</source>
          <target state="translated">letrec定义的其他形式的行为取决于实现。当前的实现还支持非功能值的特定类别的递归定义，如第&lt;a href=&quot;letrecvalues#s%3Aletrecvalues&quot;&gt;8.1&lt;/a&gt;节所述。</target>
        </trans-unit>
        <trans-unit id="1ff67900c42b4aee958325c5f4f3657cfb01e905" translate="yes" xml:space="preserve">
          <source>The behavior of pretty-printing commands is unspecified if there is no open pretty-printing box. Each box opened by one of the &lt;code&gt;open_&lt;/code&gt; functions below must be closed using &lt;code&gt;close_box&lt;/code&gt; for proper formatting. Otherwise, some of the material printed in the boxes may not be output, or may be formatted incorrectly.</source>
          <target state="translated">如果没有打开的漂亮打印框，则未指定漂亮打印命令的行为。由以下 &lt;code&gt;open_&lt;/code&gt; 函数之一打开的每个框都必须使用 &lt;code&gt;close_box&lt;/code&gt; 进行关闭才能正确格式化。否则，可能无法输出包装在框中的某些材料，或格式不正确。</target>
        </trans-unit>
        <trans-unit id="294b4ce3a6ec7d9526f89437cbfa0a62dbc20037" translate="yes" xml:space="preserve">
          <source>The behaviour depends on whether -Oclassic is used.</source>
          <target state="translated">其行为取决于是否使用-Oclassic。</target>
        </trans-unit>
        <trans-unit id="37716c4181d6f75c920bfc58fd4811b40988028e" translate="yes" xml:space="preserve">
          <source>The behaviour of the Flambda simplification pass means that certain unsafe operations, which may without Flambda or when using previous versions of the compiler be safe, must not be used. This specifically refers to functions found in the Obj module.</source>
          <target state="translated">Flambda简化通证的行为意味着某些不安全的操作,如果没有Flambda或使用以前版本的编译器时可能是安全的,但不能使用。这具体指的是Obj模块中的函数。</target>
        </trans-unit>
        <trans-unit id="eee0f3f481dbee307882214b9d43efeec2d8af62" translate="yes" xml:space="preserve">
          <source>The benefit of specialisation is assessed in a similar way as for inlining. Specialised argument information may mean that the body of the function being specialised can be simplified: the removed operations are accumulated into a benefit. This, together with the size of the duplicated (specialised) function declaration, is then assessed against the size of the call to the original function.</source>
          <target state="translated">专门化的好处的评估方式与内联类似。专门化的参数信息可能意味着被专门化的函数的主体可以被简化:被删除的操作被累积成一个效益。这一点,连同重复的(专门化)函数声明的大小,然后与原始函数的调用大小进行评估。</target>
        </trans-unit>
        <trans-unit id="0b2c4a9ea1966c2159ce87a9dbf7fed0e3ab528e" translate="yes" xml:space="preserve">
          <source>The best way to set a file descriptor ``close-on-exec'' is to create it in this state. To this end, the &lt;code&gt;openfile&lt;/code&gt; function has &lt;code&gt;O_CLOEXEC&lt;/code&gt; and &lt;code&gt;O_KEEPEXEC&lt;/code&gt; flags to enforce ``close-on-exec'' mode or ``keep-on-exec'' mode, respectively. All other operations in the Unix module that create file descriptors have an optional argument &lt;code&gt;?cloexec:bool&lt;/code&gt; to indicate whether the file descriptor should be created in ``close-on-exec'' mode (by writing &lt;code&gt;~cloexec:true&lt;/code&gt;) or in ``keep-on-exec'' mode (by writing &lt;code&gt;~cloexec:false&lt;/code&gt;). For historical reasons, the default file descriptor creation mode is ``keep-on-exec'', if no &lt;code&gt;cloexec&lt;/code&gt; optional argument is given. This is not a safe default, hence it is highly recommended to pass explicit &lt;code&gt;cloexec&lt;/code&gt; arguments to operations that create file descriptors.</source>
          <target state="translated">设置文件描述符``close-on-exec''的最佳方法是在此状态下创建它。为此， &lt;code&gt;openfile&lt;/code&gt; 函数具有 &lt;code&gt;O_CLOEXEC&lt;/code&gt; 和 &lt;code&gt;O_KEEPEXEC&lt;/code&gt; 标志以分别强制执行``执行时关闭''模式或``执行时保持''模式。 Unix模块中用于创建文件描述符的所有其他操作都有一个可选参数 &lt;code&gt;?cloexec:bool&lt;/code&gt; ,用于指示应以&amp;ldquo;执行时关闭&amp;rdquo;模式（通过编写 &lt;code&gt;~cloexec:true&lt;/code&gt; ）还是在``` exec-close-exec&amp;rdquo;模式下创建文件描述符。 `keep-on-exec'模式（通过写 &lt;code&gt;~cloexec:false&lt;/code&gt; ）。出于历史原因，如果没有 &lt;code&gt;cloexec&lt;/code&gt; ，默认的文件描述符创建模式为``keep-on-exec''给出了可选参数。这不是一个安全的默认值，因此强烈建议将显式的 &lt;code&gt;cloexec&lt;/code&gt; 参数传递给创建文件描述符的操作。</target>
        </trans-unit>
        <trans-unit id="86498a92f17f772fbb61c7717d965395dedb151e" translate="yes" xml:space="preserve">
          <source>The bigarray functionality may now be found in the standard library &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray module&lt;/a&gt;, except for the map_file function which is now part of the &lt;a href=&quot;libunix#c%3Aunix&quot;&gt;Unix library&lt;/a&gt;. The documentation has been integrated into the documentation for the standard library.</source>
          <target state="translated">现在，可以在标准库&lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray模块中&lt;/a&gt;找到bigarray功能，但map_file函数现在已成为&lt;a href=&quot;libunix#c%3Aunix&quot;&gt;Unix库的&lt;/a&gt;一部分。该文档已集成到标准库的文档中。</target>
        </trans-unit>
        <trans-unit id="c17f0e116811b46fb1a7e57d12263409833bc755" translate="yes" xml:space="preserve">
          <source>The bigarray library has now been integrated into OCaml&amp;rsquo;s standard library.</source>
          <target state="translated">现在，bigarray库已集成到OCaml的标准库中。</target>
        </trans-unit>
        <trans-unit id="f6a6099570dff5141c480a3752e67d9450054231" translate="yes" xml:space="preserve">
          <source>The boolean 'and'.</source>
          <target state="translated">布林 &quot;和&quot;。</target>
        </trans-unit>
        <trans-unit id="353c4c988751affe11b91a3216ece019b7e4c283" translate="yes" xml:space="preserve">
          <source>The boolean 'and'. Evaluation is sequential, left-to-right: in &lt;code&gt;e1&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;e2&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt; is evaluated first, and if it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;e2&lt;/code&gt; is not evaluated at all. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">布尔&amp;ldquo;和&amp;rdquo;。评估是从左到右的顺序操作：在 &lt;code&gt;e1&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;e2&lt;/code&gt; ，首先评估 &lt;code&gt;e1&lt;/code&gt; ，如果返回 &lt;code&gt;false&lt;/code&gt; ，则根本不评估 &lt;code&gt;e2&lt;/code&gt; 。右关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c5b81b1af0be4a909b4ff180ecd97e7f3ba74ce" translate="yes" xml:space="preserve">
          <source>The boolean 'or'.</source>
          <target state="translated">布林 &quot;或&quot;。</target>
        </trans-unit>
        <trans-unit id="a7978a7e64fa2a3b90ad7ad3cd09291d62fe4c55" translate="yes" xml:space="preserve">
          <source>The boolean 'or'. Evaluation is sequential, left-to-right: in &lt;code&gt;e1&amp;nbsp;||&amp;nbsp;e2&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt; is evaluated first, and if it returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;e2&lt;/code&gt; is not evaluated at all. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">布尔值&amp;ldquo;或&amp;rdquo;。评估是顺序的，从左到右：在 &lt;code&gt;e1&amp;nbsp;||&amp;nbsp;e2&lt;/code&gt; ，首先评估 &lt;code&gt;e1&lt;/code&gt; ，如果它返回 &lt;code&gt;true&lt;/code&gt; ，则根本不评估 &lt;code&gt;e2&lt;/code&gt; 。右关联运算符，有关更多信息，请参见&lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57f592a468f9e49822816c7b0706ff6890f3319b" translate="yes" xml:space="preserve">
          <source>The boolean negation.</source>
          <target state="translated">布尔运算的否定。</target>
        </trans-unit>
        <trans-unit id="e3356fbfc82845f932c40854238e79297422bf18" translate="yes" xml:space="preserve">
          <source>The boolean operators &amp;amp; and or are deprecated synonyms for (respectively) &amp;amp;&amp;amp; and ||.</source>
          <target state="translated">布尔运算符＆和or分别是&amp;amp;&amp;amp;和||的不赞成使用的同义词。</target>
        </trans-unit>
        <trans-unit id="a5f2def0fcadebd404f0b3e288cd99d54193864d" translate="yes" xml:space="preserve">
          <source>The bytecode compiler in custom runtime mode (ocamlc -custom) normally appends the bytecode to the executable file containing the custom runtime. This has two consequences. First, the final linking step must be performed by ocamlc. Second, the OCaml runtime library must be able to find the name of the executable file from the command-line arguments. When using caml_main(argv) as in section &amp;zwj;&lt;a href=&quot;#ss%3Amain-c&quot;&gt;18.7.4&lt;/a&gt;, this means that argv[0] or argv[1] must contain the executable file name.</source>
          <target state="translated">定制运行时模式下的字节码编译器（ocamlc -custom）通常将字节码附加到包含定制运行时的可执行文件中。这有两个后果。首先，最后的链接步骤必须由ocamlc执行。其次，OCaml运行时库必须能够从命令行参数中找到可执行文件的名称。当使用caml_main（argv的）如在章节&lt;a href=&quot;#ss%3Amain-c&quot;&gt;18.7.4&lt;/a&gt;，这意味着的argv [0]或的argv [1]必须包含可执行文件的名称。</target>
        </trans-unit>
        <trans-unit id="4b049f36521b991b87ac5a40eab10383da5bcce8" translate="yes" xml:space="preserve">
          <source>The bytecode compiler in custom runtime mode (ocamlc -custom) normally appends the bytecode to the executable file containing the custom runtime. This has two consequences. First, the final linking step must be performed by ocamlc. Second, the OCaml runtime library must be able to find the name of the executable file from the command-line arguments. When using caml_main(argv) as in section &lt;a href=&quot;#ss%3Amain-c&quot;&gt;20.7.4&lt;/a&gt;, this means that argv[0] or argv[1] must contain the executable file name.</source>
          <target state="translated">定制运行时模式下的字节码编译器（ocamlc -custom）通常将字节码附加到包含定制运行时的可执行文件中。这有两个后果。首先，最后的链接步骤必须由ocamlc执行。其次，OCaml运行时库必须能够从命令行参数中找到可执行文件的名称。如第&lt;a href=&quot;#ss%3Amain-c&quot;&gt;20.7.4&lt;/a&gt;节中所述，使用caml_main（argv）时，这意味着argv [0]或argv [1]必须包含可执行文件名。</target>
        </trans-unit>
        <trans-unit id="ae71aa32bd811f5994a5593dcd1cb87c5ea5d8e1" translate="yes" xml:space="preserve">
          <source>The bytecode executable myprog can then be launched as usual: myprogargs or /home/me/ocamlunixrun myprogargs.</source>
          <target state="translated">然后可以像往常一样启动字节码可执行文件 myprogargs 或 /home/me/ocamlunixrun myprogargs。</target>
        </trans-unit>
        <trans-unit id="31c8711898f71d43a2b4ca33e6558e5b43e7cda7" translate="yes" xml:space="preserve">
          <source>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header.</source>
          <target state="translated">代表Marshaled值的字节由固定大小的头和可变大小的数据部分组成,数据部分的大小可以由头决定。</target>
        </trans-unit>
        <trans-unit id="d6cf8ac9f4453cd731df08caa3e42856639d786a" translate="yes" xml:space="preserve">
          <source>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header. &lt;a href=&quot;marshal#VALheader_size&quot;&gt;&lt;code&gt;Marshal.header_size&lt;/code&gt;&lt;/a&gt; is the size, in bytes, of the header. &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;nbsp;buff&amp;nbsp;ofs&lt;/code&gt; is the size, in bytes, of the data part, assuming a valid header is stored in &lt;code&gt;buff&lt;/code&gt; starting at position &lt;code&gt;ofs&lt;/code&gt;. Finally, &lt;a href=&quot;marshal#VALtotal_size&quot;&gt;&lt;code&gt;Marshal.total_size&lt;/code&gt;&lt;/a&gt;&lt;code&gt;buff&amp;nbsp;ofs&lt;/code&gt; is the total size, in bytes, of the marshaled value. Both &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;marshal#VALtotal_size&quot;&gt;&lt;code&gt;Marshal.total_size&lt;/code&gt;&lt;/a&gt; raise &lt;code&gt;Failure&lt;/code&gt; if &lt;code&gt;buff&lt;/code&gt;, &lt;code&gt;ofs&lt;/code&gt; does not contain a valid header.</source>
          <target state="translated">表示封送值的字节由固定大小的标头和可变大小的数据部分组成，数据部分的大小可以从标头中确定。&lt;a href=&quot;marshal#VALheader_size&quot;&gt; &lt;code&gt;Marshal.header_size&lt;/code&gt; &lt;/a&gt;是标头的大小（以字节为单位）。&lt;a href=&quot;marshal#VALdata_size&quot;&gt; &lt;code&gt;Marshal.data_size&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;nbsp;buff&amp;nbsp;ofs&lt;/code&gt; 是数据部分的大小，以字节为单位，假设有效的标头存储在 &lt;code&gt;buff&lt;/code&gt; 中，位置为 &lt;code&gt;ofs&lt;/code&gt; 。最后，&lt;a href=&quot;marshal#VALtotal_size&quot;&gt; &lt;code&gt;Marshal.total_size&lt;/code&gt; &lt;/a&gt; &lt;code&gt;buff&amp;nbsp;ofs&lt;/code&gt; 是封送值的总大小（以字节为单位）。无论&lt;a href=&quot;marshal#VALdata_size&quot;&gt; &lt;code&gt;Marshal.data_size&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;marshal#VALtotal_size&quot;&gt; &lt;code&gt;Marshal.total_size&lt;/code&gt; &lt;/a&gt;加薪 &lt;code&gt;Failure&lt;/code&gt; 如果 &lt;code&gt;buff&lt;/code&gt; ， &lt;code&gt;ofs&lt;/code&gt; 不包含一个有效的头。</target>
        </trans-unit>
        <trans-unit id="1d1103a29f51d40271f1f9e57f4afef462874497" translate="yes" xml:space="preserve">
          <source>The call to caml_main initializes the OCaml runtime system, loads the bytecode (in the case of the bytecode compiler), and executes the initialization code of the OCaml program. Typically, this initialization code registers callback functions using Callback.register. Once the OCaml initialization code is complete, control returns to the C code that called caml_main.</source>
          <target state="translated">调用caml_main初始化OCaml运行时系统,加载字节码(在字节码编译器的情况下),并执行OCaml程序的初始化代码。通常,这个初始化代码使用Callback.register注册回调函数。一旦OCaml初始化代码完成,控制权就返回到调用caml_main的C代码。</target>
        </trans-unit>
        <trans-unit id="9a133408bb95ba502b3a3f1d4a608ee2cbee5abd" translate="yes" xml:space="preserve">
          <source>The call to print_int can indeed be inlined:</source>
          <target state="translated">对print_int的调用确实可以内联。</target>
        </trans-unit>
        <trans-unit id="94ba4fe5d5732c256fe3a8bfe75e3f359200cfb9" translate="yes" xml:space="preserve">
          <source>The caller may not mutate &lt;code&gt;s&lt;/code&gt; while the string is borrowed (it has temporarily given up ownership). This affects concurrent programs, but also higher-order functions: if &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; returned a closure to be called later, &lt;code&gt;s&lt;/code&gt; should not be mutated until this closure is fully applied and returns ownership.</source>
          <target state="translated">借用字符串时，调用者可能不会使 &lt;code&gt;s&lt;/code&gt; 突变（它已暂时放弃所有权）。这会影响并发程序，还会影响高阶函数：如果&lt;a href=&quot;string#VALlength&quot;&gt; &lt;code&gt;String.length&lt;/code&gt; &lt;/a&gt;返回了一个闭包供以后调用，则在完全应用此闭包并返回所有权之前，不应更改 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0f9579a2db02b7e2d6ea5033fac1d3e370d16d1" translate="yes" xml:space="preserve">
          <source>The callstack for the allocation.</source>
          <target state="translated">分配的调用栈。</target>
        </trans-unit>
        <trans-unit id="622bd19b67cd4c019f61e03bb878afac5759460b" translate="yes" xml:space="preserve">
          <source>The caml_startup function calls the uncaught exception handler (or enters the debugger, if running under ocamldebug) if an exception escapes from a top-level module initialiser. Such exceptions may be caught in the C code by instead using the caml_startup_exn function and testing the result using Is_exception_result (followed by Extract_exception if appropriate).</source>
          <target state="translated">如果一个异常从顶层模块初始化器中逃逸出来,caml_startup函数就会调用未捕获的异常处理程序(如果在ocamldebug下运行,则进入调试器)。这种异常可以在C代码中通过使用caml_startup_exn函数来捕获,并使用Is_exception_result来测试结果(如果合适的话,使用Extract_exception)。</target>
        </trans-unit>
        <trans-unit id="264cb221ad2c5021cb06f4e90ab892974f6027b4" translate="yes" xml:space="preserve">
          <source>The caml_startup function must be called from the main C program in order to initialize the OCaml runtime and execute the OCaml initialization code. Just like caml_main, it takes one argv parameter containing the command-line parameters. Unlike caml_main, this argv parameter is used only to initialize Sys.argv, but not for finding the name of the executable file.</source>
          <target state="translated">为了初始化OCaml运行时和执行OCaml初始化代码,必须从主C程序中调用caml_startup函数。就像caml_main一样,它需要一个包含命令行参数的argv参数。与caml_main不同的是,这个argv参数只用来初始化Sys.argv,而不是用来查找可执行文件的名称。</target>
        </trans-unit>
        <trans-unit id="2affb46e2f6bba633bb7602b97c665a41396ccad" translate="yes" xml:space="preserve">
          <source>The cases of a pattern matching (in the function, match and try constructs) can include guard expressions, which are arbitrary boolean expressions that must evaluate to true for the match case to be selected. Guards occur just before the -&amp;gt; token and are introduced by the when keyword:</source>
          <target state="translated">模式匹配的情况（在函数中，match和try构造中）可以包括保护表达式，该表达式是任意布尔表达式，对于要选择的匹配情况，其值必须为true。保护发生在-&amp;gt;标记之前，并由when关键字引入：</target>
        </trans-unit>
        <trans-unit id="c57a5996cc3de19dcd4e1eed39d89bc12a76cdf5" translate="yes" xml:space="preserve">
          <source>The change in code size is also estimated: morally speaking it should be the change in machine code size, but since that is not available to the inliner, an approximation is used.</source>
          <target state="translated">代码大小的变化也是估计出来的:从道义上讲,应该是机器代码大小的变化,但由于内联机无法获得,所以采用了近似值。</target>
        </trans-unit>
        <trans-unit id="ca1b550469abfe316a8551222d7494a0d41f29ab" translate="yes" xml:space="preserve">
          <source>The class Odoc_html.Generator.html inherits from the class Odoc_html.info, containing a field tag_functions which is a list pairs composed of a custom tag (e.g. &quot;foo&quot;) and a function taking a text and returning HTML code (of type string). To handle a new tag bar, extend the current HTML generator and complete the tag_functions field:</source>
          <target state="translated">类Odoc_html.Generator.html继承自类Odoc_html.info,包含一个字段tag_functions,它是由一个自定义标签(如 &quot;foo&quot;)和一个取一个文本并返回HTML代码(类型为string)的函数组成的列表对。要处理一个新的标签栏,请扩展当前的HTML生成器并完成tag_functions字段。</target>
        </trans-unit>
        <trans-unit id="926c19980b2db5430ad107b75fe1458a4f3fbdcc" translate="yes" xml:space="preserve">
          <source>The class bank is the &lt;em&gt;real&lt;/em&gt; implementation of the bank account (it could have been inlined). This is the one that will be used for further extensions, refinements, etc. Conversely, the client will only be given the client view.</source>
          <target state="translated">类别银行是银行帐户的&lt;em&gt;真实&lt;/em&gt;实现（可以内联）。这是将用于进一步扩展，改进等的内容。相反，将仅向客户端提供客户端视图。</target>
        </trans-unit>
        <trans-unit id="e75252ec56a2bb1491e257e9361045a0dd0b5821" translate="yes" xml:space="preserve">
          <source>The class colored_circle is a specialized version of class circle that requires the type of the center to unify with #colored_point, and adds a method color. Note that when specializing a parameterized class, the instance of type parameter must always be explicitly given. It is again written between [ and ].</source>
          <target state="translated">类colored_circle是类circle的专门化版本,它要求中心的类型与#colored_point统一,并增加了一个方法颜色。需要注意的是,在对参数化类进行特殊化时,必须始终明确给出类型参数的实例。同样是写在【和】之间。</target>
        </trans-unit>
        <trans-unit id="79b45dbbed1c7c5a93e33df7a349eb52d30c016c" translate="yes" xml:space="preserve">
          <source>The class money could naturally carry another binary method. Here is a direct definition:</source>
          <target state="translated">类钱自然可以进行另一种二元法。这里直接定义一下。</target>
        </trans-unit>
        <trans-unit id="8da53bfa481f42c4800f57d82c95a21c851133c0" translate="yes" xml:space="preserve">
          <source>The class observer has a distinguished method notify that requires two arguments, a subject and an event to execute an action.</source>
          <target state="translated">类观察者有一个区分的方法notify,需要两个参数,一个主体和一个事件来执行一个动作。</target>
        </trans-unit>
        <trans-unit id="df3bd4e2828bcd091f80465c81ab6f432a8b0a11" translate="yes" xml:space="preserve">
          <source>The class point below defines one instance variable x and two methods get_x and move. The initial value of the instance variable is 0. The variable x is declared mutable, so the method move can change its value.</source>
          <target state="translated">下面这个类点定义了一个实例变量x和两个方法get_x和move。实例变量的初始值为0,变量x被声明为可突变的,所以方法move可以改变其值。</target>
        </trans-unit>
        <trans-unit id="4593d18e4f9e303d386e01a8341f25ec6716bf22" translate="yes" xml:space="preserve">
          <source>The class point can also be abstracted over the initial values of the x coordinate.</source>
          <target state="translated">类点也可以抽象出x坐标的初始值。</target>
        </trans-unit>
        <trans-unit id="d631271177c3626e572631b72bb8a711d8d83fe5" translate="yes" xml:space="preserve">
          <source>The class subject remembers a list of observers in an instance variable, and has a distinguished method notify_observers to broadcast the message notify to all observers with a particular event e.</source>
          <target state="translated">类主体在一个实例变量中记住了一个观察者列表,并有一个区分方法notify_observers来向所有有特定事件e的观察者广播消息通知。</target>
        </trans-unit>
        <trans-unit id="4100d907acfdcabf2433a494dd1a3e4d594e0d96" translate="yes" xml:space="preserve">
          <source>The class type expression &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; is the type of class functions (functions from values to classes) that take as argument a value of type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; and return as result a class of type &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;.</source>
          <target state="translated">类类型表达式&lt;a href=&quot;types#typexpr&quot;&gt;typexpr-&lt;/a&gt; &amp;gt; &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;是类函数（从值到类的函数）的类型，这些函数将&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;类型的值作为参数并返回结果为&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;类型的类。</target>
        </trans-unit>
        <trans-unit id="ccb1b7cb0b9bf09c44c246b3d8b635b8df171c1b" translate="yes" xml:space="preserve">
          <source>The class type expression object [(&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;)] {&lt;a href=&quot;#class-field-spec&quot;&gt;class-field-spec&lt;/a&gt;} end is the type of a class body. It specifies its instance variables and methods. In this type, &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; is matched against the self type, therefore providing a name for the self type.</source>
          <target state="translated">类类型表达式对象[（&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）] { &lt;a href=&quot;#class-field-spec&quot;&gt;class-field-spec&lt;/a&gt; } end是类主体的类型。它指定其实例变量和方法。在此类型中，&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;与自身类型匹配，因此提供了自身类型的名称。</target>
        </trans-unit>
        <trans-unit id="54e83d883d9c89940ee922a012fe9586b0e83667" translate="yes" xml:space="preserve">
          <source>The class type parameters correspond to the ones of the class type and of the two type abbreviations defined by the class binding. They must be bound to actual types in the class definition using type constraints. So that the abbreviations are well-formed, type variables of the inferred type of the class must either be type parameters or be bound in the constraint clause.</source>
          <target state="translated">类类型参数对应于类绑定所定义的类类型和两个类型缩写的参数。它们必须使用类型约束与类定义中的实际类型进行绑定。为了使缩写形式良好,类的推断类型的类型变量必须作为类型参数或在约束子句中绑定。</target>
        </trans-unit>
        <trans-unit id="a5fa7a046792c2877d81d775912d2e5ba688e9f6" translate="yes" xml:space="preserve">
          <source>The closing tag marker, as given by &lt;code&gt;mark_close_stag&amp;nbsp;t&lt;/code&gt;, is written into the output device of the formatter; then the &lt;code&gt;print_close_stag&lt;/code&gt; tag-printing function of the formatter is called with &lt;code&gt;t&lt;/code&gt; as argument.</source>
          <target state="translated">&lt;code&gt;mark_close_stag&amp;nbsp;t&lt;/code&gt; 给出的结束标记标记被写入格式化程序的输出设备；然后使用 &lt;code&gt;t&lt;/code&gt; 作为参数调用格式化程序的 &lt;code&gt;print_close_stag&lt;/code&gt; 标签打印功能。</target>
        </trans-unit>
        <trans-unit id="4f5a0cc5c3693ff9428c3a313f5f025808cf9ecb" translate="yes" xml:space="preserve">
          <source>The code resulting from applying -O3 -unbox-closures to this code passes the free variables via function arguments in order to eliminate all closure allocation in this example (aside from any that might be performed inside printf).</source>
          <target state="translated">在这段代码中应用-O3 -unbox-closures所产生的代码通过函数参数传递自由变量,以消除本例中的所有闭包分配(除了可能在printf内部执行的任何闭包)。</target>
        </trans-unit>
        <trans-unit id="a56e3d3e4c999f25e3f562df13ab73e9511528d5" translate="yes" xml:space="preserve">
          <source>The command line analysis is performed after loading the module containing the documentation generator, thus allowing command line options to be added to the list of existing ones. Adding an option can be done with the function</source>
          <target state="translated">命令行分析是在加载包含文档生成器的模块后进行的,因此允许将命令行选项添加到现有选项列表中。添加一个选项可以通过函数</target>
        </trans-unit>
        <trans-unit id="713e03c7df6783cbf595d790dada27c89d701a1d" translate="yes" xml:space="preserve">
          <source>The command line arguments given to the process.</source>
          <target state="translated">给予进程的命令行参数。</target>
        </trans-unit>
        <trans-unit id="7aeece9eee37cad413bcf22ebfdfa0c87857f155" translate="yes" xml:space="preserve">
          <source>The command line arguments given to the process. The first element is the command name used to invoke the program. The following elements are the command-line arguments given to the program.</source>
          <target state="translated">给予程序的命令行参数。第一个元素是用于调用程序的命令名。下面的元素是给程序的命令行参数。</target>
        </trans-unit>
        <trans-unit id="351afc02e66d69b38e7fb7bbf282c52d820d0b73" translate="yes" xml:space="preserve">
          <source>The command quit exits the debugger. You can also exit the debugger by typing an end-of-file character (usually ctrl-D).</source>
          <target state="translated">命令quit可以退出调试器,也可以通过输入文件结束符(通常是ctrl-D)退出调试器。你也可以通过输入文件结束符(通常是ctrl-D)来退出调试器。</target>
        </trans-unit>
        <trans-unit id="e23e32f6685f8bb7b921c0aa6a10415254fe4726" translate="yes" xml:space="preserve">
          <source>The compare field can be set to custom_compare_default; this default comparison function simply raises Failure.</source>
          <target state="translated">比较字段可以设置为custom_compare_default,这个默认比较函数只是引发Failure。</target>
        </trans-unit>
        <trans-unit id="400936dd851589bd58319e0915e19ac225ad000b" translate="yes" xml:space="preserve">
          <source>The compare field contains a pointer to a C function that is called whenever two custom blocks are compared using OCaml&amp;rsquo;s generic comparison operators (=, &amp;lt;&amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;, &amp;gt; and compare). The C function should return 0 if the data contained in the two blocks are structurally equal, a negative integer if the data from the first block is less than the data from the second block, and a positive integer if the data from the first block is greater than the data from the second block.</source>
          <target state="translated">比较字段包含一个指向C函数的指针，每当使用OCaml的通用比较运算符（=，&amp;lt;&amp;gt;，&amp;lt;=，&amp;gt; =，&amp;lt;，&amp;gt;和compare）比较两个自定义块时，就会调用该C函数。如果两个块中包含的数据在结构上相等，则C函数应返回0；如果第一个块中的数据小于第二个块中的数据，则C函数应返回负整数；如果第一个块中的数据为以下值，则C函数应返回正整数。大于第二个块中的数据。</target>
        </trans-unit>
        <trans-unit id="fc7b967b6bfa6059a95a5177a3d4d949e36cefb7" translate="yes" xml:space="preserve">
          <source>The compare_ext field can be set to custom_compare_ext_default; this default comparison function simply raises Failure.</source>
          <target state="translated">compare_ext字段可以设置为custom_compare_ext_default,这个默认的比较函数只是引发Failure。</target>
        </trans-unit>
        <trans-unit id="2e507c128d533ecafbf0707e3311fd3954593733" translate="yes" xml:space="preserve">
          <source>The comparison function for 16-character digest, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; and the implementation shared with &lt;a href=&quot;string#VALcompare&quot;&gt;&lt;code&gt;String.compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">16个字符的摘要的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规范，并且与&lt;a href=&quot;string#VALcompare&quot;&gt; &lt;code&gt;String.compare&lt;/code&gt; &lt;/a&gt;共享实现。</target>
        </trans-unit>
        <trans-unit id="2d93ed75e8c4197749446b6127b8c28c77f22cc5" translate="yes" xml:space="preserve">
          <source>The comparison function for 16-character digest, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; and the implementation shared with &lt;a href=&quot;string#VALcompare&quot;&gt;&lt;code&gt;String.compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Digest&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">16个字符的摘要的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规范，并且与&lt;a href=&quot;string#VALcompare&quot;&gt; &lt;code&gt;String.compare&lt;/code&gt; &lt;/a&gt;共享实现。与类型 &lt;code&gt;t&lt;/code&gt; 一起，此函数 &lt;code&gt;compare&lt;/code&gt; 允许将 &lt;code&gt;Digest&lt;/code&gt; 模块作为参数传递给函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9f9a53259e71203663f8e69d67e5c99f6aeaf69" translate="yes" xml:space="preserve">
          <source>The comparison function for 32-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">32位整数的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。</target>
        </trans-unit>
        <trans-unit id="52c057344f74f3ec299881602b4bac70c2781e4d" translate="yes" xml:space="preserve">
          <source>The comparison function for 32-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Int32&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">32位整数的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。与类型 &lt;code&gt;t&lt;/code&gt; 一起，此函数 &lt;code&gt;compare&lt;/code&gt; 允许将 &lt;code&gt;Int32&lt;/code&gt; 模块作为参数传递给函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32ed748cfcec44e96e26180791258594924fa2f5" translate="yes" xml:space="preserve">
          <source>The comparison function for 64-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">64位整数的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。</target>
        </trans-unit>
        <trans-unit id="5d3cd3ac1cd893b13ee278ef969766aaeeb6d9d9" translate="yes" xml:space="preserve">
          <source>The comparison function for 64-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Int64&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">64位整数的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。与类型 &lt;code&gt;t&lt;/code&gt; 一起，此函数 &lt;code&gt;compare&lt;/code&gt; 允许将 &lt;code&gt;Int64&lt;/code&gt; 模块作为参数传递给函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bea1fb4f967f6e930a0a3f1b6dd8b3d9440baccf" translate="yes" xml:space="preserve">
          <source>The comparison function for byte sequences, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字节序列的比较功能，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。</target>
        </trans-unit>
        <trans-unit id="c0c8f9bc7e72b4041efc638ebe36bb3de869d339" translate="yes" xml:space="preserve">
          <source>The comparison function for byte sequences, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Bytes&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字节序列的比较功能，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。与类型 &lt;code&gt;t&lt;/code&gt; 一起，此函数 &lt;code&gt;compare&lt;/code&gt; 允许将模块 &lt;code&gt;Bytes&lt;/code&gt; 作为参数传递给函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4248cb5972f6600877776ee5b7caa863058e709e" translate="yes" xml:space="preserve">
          <source>The comparison function for characters, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符的比较功能，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。</target>
        </trans-unit>
        <trans-unit id="7f1c4568057988fd6052ab54ff61953ad29435a0" translate="yes" xml:space="preserve">
          <source>The comparison function for characters, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Char&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符的比较功能，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。与类型 &lt;code&gt;t&lt;/code&gt; 一起，此函数 &lt;code&gt;compare&lt;/code&gt; 允许将模块 &lt;code&gt;Char&lt;/code&gt; 作为参数传递给函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c2863b10b77fa26a22a5fb611bbcda7b42b0bce" translate="yes" xml:space="preserve">
          <source>The comparison function for native integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本地整数的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。</target>
        </trans-unit>
        <trans-unit id="13b4368747939c68aea788a4bc151e1321dcb60a" translate="yes" xml:space="preserve">
          <source>The comparison function for native integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Nativeint&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本地整数的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。与类型 &lt;code&gt;t&lt;/code&gt; 一起，此函数 &lt;code&gt;compare&lt;/code&gt; 允许将 &lt;code&gt;Nativeint&lt;/code&gt; 模块作为参数传递给函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6d081b56d1fdbb9331b6bc0b8263048c0154295" translate="yes" xml:space="preserve">
          <source>The comparison function for strings, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。</target>
        </trans-unit>
        <trans-unit id="73fb41656984243b49dbd382d60fab144a75f5a1" translate="yes" xml:space="preserve">
          <source>The comparison function for strings, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;String&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串的比较函数，具有与&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt;相同的规格。与类型 &lt;code&gt;t&lt;/code&gt; 一起，此函数 &lt;code&gt;compare&lt;/code&gt; 允许将 &lt;code&gt;String&lt;/code&gt; 模块作为参数传递给函子&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf96782a960b80262c43276b69181745eee6a160" translate="yes" xml:space="preserve">
          <source>The compilation units loaded by this function are added to the &quot;allowed units&quot; list (see &lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt;&lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此函数加载的编译单元将添加到&amp;ldquo;允许的单元&amp;rdquo;列表中（请参阅&lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt; &lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2f8562bc429c53a9ee1fb8567862cc87267a563b" translate="yes" xml:space="preserve">
          <source>The compilation units loaded by this function are not added to the &quot;allowed units&quot; list (see &lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt;&lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt;&lt;/a&gt;) since they cannot be referenced from other compilation units.</source>
          <target state="translated">此函数加载的编译单元不会添加到&amp;ldquo;允许的单元&amp;rdquo;列表中（请参见&lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt; &lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt; &lt;/a&gt;），因为它们不能从其他编译单元中引用。</target>
        </trans-unit>
        <trans-unit id="707933d508f6c3a7f70392088950a49fbd52b59f" translate="yes" xml:space="preserve">
          <source>The compiler aims to share constants lifted to toplevel such that there are no duplicate definitions. However if .cmx files are hidden from the compiler then maximal sharing may not be possible.</source>
          <target state="translated">编译器的目标是共享提升到toplevel的常量,这样就不会有重复的定义。然而,如果.cmx文件被编译器隐藏,那么最大限度的共享可能是不可能的。</target>
        </trans-unit>
        <trans-unit id="c5839a1745e82e6942b420724963de7198ab2be1" translate="yes" xml:space="preserve">
          <source>The compiler always derives the module name by taking the capitalized base name of the source file (.ml or .mli file). That is, it strips the leading directory name, if any, as well as the .ml or .mli suffix; then, it set the first letter to uppercase, in order to comply with the requirement that module names must be capitalized. For instance, compiling the file mylib/misc.ml provides an implementation for the module named Misc. Other compilation units may refer to components defined in mylib/misc.ml under the names Misc.name; they can also do open Misc, then use unqualified names name.</source>
          <target state="translated">编译器总是以源文件(.ml或.mli文件)的大写基名来推导模块名。也就是说,如果有的话,它会去掉前面的目录名,以及.ml或.mli后缀;然后,它会将第一个字母设置为大写,以符合模块名必须大写的要求。例如,编译文件mylib/misc.ml提供了一个名为Misc.ml的模块的实现。其他编译单位可以将mylib/misc.ml中定义的组件引用到Misc.name的名称下;它们也可以做打开Misc,然后使用不限定的名称name。</target>
        </trans-unit>
        <trans-unit id="12a0d3bf4431d29fd5d6cebb56459fe2a6246977" translate="yes" xml:space="preserve">
          <source>The compiler can prove invariance of function arguments across multiple functions within a recursive group (although this has some limitations, as shown by the example below).</source>
          <target state="translated">编译器可以在一个递归组内的多个函数中证明函数参数的不变性(尽管这有一些限制,如下例所示)。</target>
        </trans-unit>
        <trans-unit id="c3a13caf32a0850458a50504a9f9b67fbe141403" translate="yes" xml:space="preserve">
          <source>The compiler cannot currently detect invariance in cases such as the following.</source>
          <target state="translated">编译器目前无法检测到以下情况下的不变性。</target>
        </trans-unit>
        <trans-unit id="6c5469d71b4fc3737466081b4134fc0bcc32f1c5" translate="yes" xml:space="preserve">
          <source>The compiler command line can be modified &amp;ldquo;from the outside&amp;rdquo; with the following mechanisms. These are experimental and subject to change. They should be used only for experimental and development work, not in released packages.</source>
          <target state="translated">可以使用以下机制&amp;ldquo;从外部&amp;rdquo;修改编译器命令行。这些是实验性的，随时可能更改。它们仅应用于实验和开发工作，而不应用于已发布的软件包中。</target>
        </trans-unit>
        <trans-unit id="9b6fd616c3d14b8722315aee0f9e2a79310b0ab4" translate="yes" xml:space="preserve">
          <source>The compiler distribution does not itself provide the facility for analysing Spacetime output files; this is left to external tools. The first such tool will appear in OPAM as a package called prof_spacetime. That tool will provide interactive graphical and terminal-based visualisation of the results of profiling.</source>
          <target state="translated">编译器发行版本身并不提供分析Spacetime输出文件的工具;这要靠外部工具来完成。第一个这样的工具将作为名为prof_spacetime的软件包出现在OPAM中。该工具将提供交互式图形和基于终端的可视化剖析结果。</target>
        </trans-unit>
        <trans-unit id="431b5a10ae44ff4efacaa2847555e5ec57afda8d" translate="yes" xml:space="preserve">
          <source>The compiler distribution provides an &amp;ldquo;otherlibs&amp;rdquo; library called raw_spacetime_lib for decoding Spacetime files. This library provides facilities to read not only memory profiling information but also the full dynamic call graph of the profiled program which is written into Spacetime output files.</source>
          <target state="translated">编译器发行版提供了一个名为raw_spacetime_lib的&amp;ldquo; otherlibs&amp;rdquo;库，用于解码时空文件。该库提供的功能不仅可以读取内存配置文件信息，还可以读取配置文件的程序的完整动态调用图，该图被写入到Spacetime输出文件中。</target>
        </trans-unit>
        <trans-unit id="36caea4a11df67f29a0533e03c9c03a280e97c4b" translate="yes" xml:space="preserve">
          <source>The compiler does not include the runtime system (nor a reference to it) in the generated program; it must be supplied separately.</source>
          <target state="translated">编译器不在生成的程序中包含运行时系统(也不包含对它的引用),它必须单独提供。</target>
        </trans-unit>
        <trans-unit id="9fb9134b61ba76fc9c4316c0291fbc13063e70af" translate="yes" xml:space="preserve">
          <source>The compiler is able to emit some information on its internal stages. It can output .cmt files for the implementation of the compilation unit and .cmti for signatures if the option -bin-annot is passed to it (see the description of -bin-annot below). Each such file contains a typed abstract syntax tree (AST), that is produced during the type checking procedure. This tree contains all available information about the location and the specific type of each term in the source file. The AST is partial if type checking was unsuccessful.</source>
          <target state="translated">编译器能够发出一些关于其内部阶段的信息。它可以输出.cmt文件用于编译单元的实现,如果向它传递了选项-bin-annot,则可以输出.cmti用于签名(见下面对-bin-annot的描述)。每个这样的文件都包含一个类型化的抽象语法树(AST),它是在类型检查过程中产生的。这个树包含了所有关于源文件中每个术语的位置和具体类型的可用信息。如果类型检查不成功,AST是部分的。</target>
        </trans-unit>
        <trans-unit id="48ebb88864057cd3c0c7e6531c5d37c29d605813" translate="yes" xml:space="preserve">
          <source>The compiler notes down that for the function iter&amp;rsquo;, the argument f is specialised to the constant closure print_int. This means that the body of iter&amp;rsquo; may be simplified:</source>
          <target state="translated">编译器记录下来，对于函数iter'，参数f专用于常量闭包print_int。这意味着iter'的主体可以简化：</target>
        </trans-unit>
        <trans-unit id="65c5761f18846d3de8e8d4bc7344497dc351852c" translate="yes" xml:space="preserve">
          <source>The compiler produces this error when it tries to read a compiled interface file (.cmi file) that has the wrong structure. This means something went wrong when this .cmi file was written: the disk was full, the compiler was interrupted in the middle of the file creation, and so on. This error can also appear if a .cmi file is modified after its creation by the compiler. Fix: remove the corrupted .cmi file, and rebuild it.</source>
          <target state="translated">当编译器试图读取一个结构错误的编译接口文件(.cmi文件)时,会产生这个错误。这意味着在写入这个.cmi文件时出了问题:磁盘满了,编译器在创建文件的过程中被打断了,等等。如果.cmi文件在编译器创建后被修改,也会出现这个错误。修复方法:删除损坏的.cmi文件,然后重建。</target>
        </trans-unit>
        <trans-unit id="20b2d8ee46fbd0ec43648349d2f501735b50eb59" translate="yes" xml:space="preserve">
          <source>The complete OCaml distribution can be accessed via the &lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org website&lt;/a&gt;. This site contains a lot of additional information on OCaml.</source>
          <target state="translated">完整的OCaml发行版可以通过&lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org网站&lt;/a&gt;进行访问。该站点包含有关OCaml的许多其他信息。</target>
        </trans-unit>
        <trans-unit id="581d160324d6b1dcf6f5966e788655a0b8d7c61c" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">复数 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a94f375eaa7012dabdc57ca285225234540e0a33" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">复数 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b43370e6d1b0c376b1980b552194da8b6181987d" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">复数 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ad39316a87edf772e43a6c5b64a3e41e9c0e181" translate="yes" xml:space="preserve">
          <source>The concrete type describing the behavior associated with a keyword.</source>
          <target state="translated">描述与关键字相关行为的具体类型。</target>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="translated">常数∏。</target>
        </trans-unit>
        <trans-unit id="8ad8c44fad65df83c02fac0ee5f9d77f6672d992" translate="yes" xml:space="preserve">
          <source>The constraint on self&amp;rsquo;s type is requiring a public move method, and this is sufficient to override private.</source>
          <target state="translated">对自身类型的约束要求使用public move方法，这足以覆盖private。</target>
        </trans-unit>
        <trans-unit id="a279814e737c452af822699c5733e5455892c221" translate="yes" xml:space="preserve">
          <source>The constraints associated to each constructor can be recovered through pattern-matching. Namely, if the type of the scrutinee of a pattern-matching contains a locally abstract type, this type can be refined according to the constructor used. These extra constraints are only valid inside the corresponding branch of the pattern-matching. If a constructor has some existential variables, fresh locally abstract types are generated, and they must not escape the scope of this branch.</source>
          <target state="translated">与每个构造函数相关的约束可以通过模式匹配来恢复。也就是说,如果模式匹配的审视者的类型包含一个局部抽象类型,这个类型可以根据所使用的构造函数进行细化。这些额外的约束只在模式匹配的相应分支内有效。如果一个构造函数有一些存在性变量,就会生成新的局部抽象类型,它们不能逃出这个分支的范围。</target>
        </trans-unit>
        <trans-unit id="72a6619fc6d35a54f266cbb1b53bb99ad5b03227" translate="yes" xml:space="preserve">
          <source>The construct constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; allows the specification of type parameters. Any actual type argument corresponding to the type parameter &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; has to be an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; (more precisely, &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; are unified). Type variables of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; can appear in the type equation and the type declaration.</source>
          <target state="translated">构造约束的&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;允许指定类型参数。对应于类型参数&lt;a href=&quot;lex#ident&quot;&gt;ident的&lt;/a&gt;任何实际类型参数必须是&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;的实例（更确切地说，&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;是统一的）。&lt;a href=&quot;types#typexpr&quot;&gt;typexpr的&lt;/a&gt;类型变量可以出现在类型方程式和类型声明中。</target>
        </trans-unit>
        <trans-unit id="a6dcf637d8dc6131f0b0eb619e7d7999e61b6d1b" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equal. This is typically used to specify type parameters: in this way, they can be bound to specific type expressions.</source>
          <target state="translated">构造约束&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;强制两个类型表达式相等。这通常用于指定类型参数：通过这种方式，可以将它们绑定到特定的类型表达式。</target>
        </trans-unit>
        <trans-unit id="e91937a9ebb9b2f875d8df7aec3ae920407278b6" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equals. This is typically used to specify type parameters: in that way they can be bound to specific type expressions.</source>
          <target state="translated">构造约束&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;强制两个类型表达式相等。这通常用于指定类型参数：通过这种方式，可以将它们绑定到特定的类型表达式。</target>
        </trans-unit>
        <trans-unit id="4111af28e88c74529d924590f2259579d7eddcd6" translate="yes" xml:space="preserve">
          <source>The construction moduletypeof&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; expands to the module type (signature or functor type) inferred for the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;. To make this module type reusable in many situations, it is intentionally not strengthened: abstract types and datatypes are not explicitly related with the types of the original module. For the same reason, module aliases in the inferred type are expanded.</source>
          <target state="translated">&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;的construction moduletype扩展为针对模块表达式&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;推断的模块类型（签名或函子类型）。为了使此模块类型在许多情况下都可重用，有意不对其进行增强：抽象类型和数据类型与原始模块的类型没有明确关联。出于相同的原因，推断类型的模块别名也会被扩展。</target>
        </trans-unit>
        <trans-unit id="760fdc00af3cbc0e13df9af8553cc7a286bca119" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;()&lt;/code&gt; is included here so that it has a path, but it is not intended to be used in user-defined data types.</source>
          <target state="translated">此处包含了构造函数 &lt;code&gt;()&lt;/code&gt; ，因此它具有路径，但不适用于用户定义的数据类型。</target>
        </trans-unit>
        <trans-unit id="a3003c0bbe668e94ab79defd3f710132d87092a6" translate="yes" xml:space="preserve">
          <source>The constructors &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; are included here so that they have paths, but they are not intended to be used in user-defined data types.</source>
          <target state="translated">此处包含构造函数 &lt;code&gt;false&lt;/code&gt; 和 &lt;code&gt;true&lt;/code&gt; ，以便它们具有路径，但不能在用户定义的数据类型中使用它们。</target>
        </trans-unit>
        <trans-unit id="16640eb9daf1519aa608d0b29675645a8a35f3cb" translate="yes" xml:space="preserve">
          <source>The content inside {%foo: ... %} is target-specific and will only be interpreted by the backend foo, and ignored by the others. The backends of the distribution are latex, html, texi and man. If no target is specified (syntax {% ... %}), latex is chosen by default. Custom generators may support their own target prefix.</source>
          <target state="translated">{%foo:......%}里面的内容是针对特定目标的,只由后端foo解释,其他的忽略。分发的后端是latex、html、texi和man。如果没有指定目标(语法{% ...%}),默认选择latex。自定义生成器可以支持自己的目标前缀。</target>
        </trans-unit>
        <trans-unit id="1c5c2fffb0418b713216d4c77f75ee03f3710a80" translate="yes" xml:space="preserve">
          <source>The contents of custom blocks are not scanned by the garbage collector, and must therefore not contain any pointer inside the OCaml heap. In other terms, never store an OCaml value in a custom block, and do not use Field, Store_field nor caml_modify to access the data part of a custom block. Conversely, any C data structure (not containing heap pointers) can be stored in a custom block.</source>
          <target state="translated">自定义块的内容不会被垃圾收集器扫描,因此不能包含任何OCaml堆内的指针。换句话说,永远不要在自定义块中存储一个OCaml值,也不要使用Field、Store_field或caml_modify来访问自定义块的数据部分。相反,任何C数据结构(不包含堆指针)都可以存储在自定义块中。</target>
        </trans-unit>
        <trans-unit id="785642c4a4c006be73a07a4f7ec8afa9d91aa1ff" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g.</source>
          <target state="translated">当前目录的常规名称(如</target>
        </trans-unit>
        <trans-unit id="ab0089cb61bfc166d7c15a2b68e795215831943d" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g. &lt;code&gt;.&lt;/code&gt; in Unix).</source>
          <target state="translated">传统名称为当前目录（例如 &lt;code&gt;.&lt;/code&gt; 在UNIX中）。</target>
        </trans-unit>
        <trans-unit id="545670a3a8b2e0fff49a5ac43c08636390916185" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g.</source>
          <target state="translated">当前目录的父目录的常规名称(如</target>
        </trans-unit>
        <trans-unit id="9b950ea81536e7df7421680a6cf3781982072c75" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g. &lt;code&gt;..&lt;/code&gt; in Unix).</source>
          <target state="translated">当前目录的父级的常规名称（例如，Unix中的 &lt;code&gt;..&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="33e422b54f028d0f9f99ad979df276c42ced7356" translate="yes" xml:space="preserve">
          <source>The conversion characters and their meanings are:</source>
          <target state="translated">转换字符及其含义是:</target>
        </trans-unit>
        <trans-unit id="8cb23e02c094574c60663d78adfeb6ade600463a" translate="yes" xml:space="preserve">
          <source>The corresponding C type must be intnat.</source>
          <target state="translated">对应的C型必须是intnat。</target>
        </trans-unit>
        <trans-unit id="31b0b9138835461b550a52acf6e1102fcf625f54" translate="yes" xml:space="preserve">
          <source>The cost of a &lt;em&gt;primitive&lt;/em&gt;. Primitives encompass operations including arithmetic and memory access.</source>
          <target state="translated">&lt;em&gt;原始&lt;/em&gt;成本。基元包括操作，包括算术和内存访问。</target>
        </trans-unit>
        <trans-unit id="2821dc95f75734aab94e295a923c218e0df1c9bf" translate="yes" xml:space="preserve">
          <source>The cost of a branch.</source>
          <target state="translated">一家分公司的成本。</target>
        </trans-unit>
        <trans-unit id="c804487a1287d7acc06a19d856642958b1444628" translate="yes" xml:space="preserve">
          <source>The cost of a direct function call.</source>
          <target state="translated">直接调用函数的成本。</target>
        </trans-unit>
        <trans-unit id="534cefa77673c331e56e7d9f6dd6b1f2ed24344c" translate="yes" xml:space="preserve">
          <source>The cost of an allocation.</source>
          <target state="translated">分配的费用。</target>
        </trans-unit>
        <trans-unit id="9c86a389e7f94b0cbdc2d7b61509a2068780aa63" translate="yes" xml:space="preserve">
          <source>The cost of an indirect function call.</source>
          <target state="translated">间接函数调用的成本。</target>
        </trans-unit>
        <trans-unit id="3ad4c2d03309e92f9ae01be1d5e41f51136f454b" translate="yes" xml:space="preserve">
          <source>The current default is next-fit, as the best-fit policy is new and not yet widely tested. We expect best-fit to become the default in the future.</source>
          <target state="translated">目前的默认值是next-fit,因为最佳匹配政策是新的政策,尚未广泛测试。我们预计,今后将采用最适合的政策。</target>
        </trans-unit>
        <trans-unit id="3b8c08752945457971d1f3f4ac09df0af940d32a" translate="yes" xml:space="preserve">
          <source>The current implementation limits each variant type to have at most 246 non-constant constructors and 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1 constant constructors.</source>
          <target state="translated">当前的实现方式将每个变量类型限制为最多具有246个非常量构造函数和2 &lt;sup&gt;30&lt;/sup&gt; -1个常量构造函数。</target>
        </trans-unit>
        <trans-unit id="f9a96ae8d528ab0d30d73879bd55f0ed974647fc" translate="yes" xml:space="preserve">
          <source>The current implementation places practically no restrictions on the length of string literals.</source>
          <target state="translated">目前的实现对字符串的长度几乎没有限制。</target>
        </trans-unit>
        <trans-unit id="8888fe7c320796681a86d9fc38d5331494f11ea4" translate="yes" xml:space="preserve">
          <source>The current implementation uses Heap Sort. It runs in constant stack space.</source>
          <target state="translated">目前的实现使用堆排序。它在恒定的栈空间中运行。</target>
        </trans-unit>
        <trans-unit id="aa3296295a4df646c086eb4650f57f70f9f85c18" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</source>
          <target state="translated">目前的实现使用合并排序。它运行在恒定的堆空间和对数堆空间。</target>
        </trans-unit>
        <trans-unit id="b5d51df06a97d47df008e45a13c0928311228904" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses &lt;code&gt;n/2&lt;/code&gt; words of heap space, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前实现使用合并排序。它使用 &lt;code&gt;n/2&lt;/code&gt; 个堆空间字，其中 &lt;code&gt;n&lt;/code&gt; 是数组的长度。它通常比&lt;a href=&quot;arraylabels#VALsort&quot;&gt; &lt;code&gt;ArrayLabels.sort&lt;/code&gt; &lt;/a&gt;的当前实现更快。</target>
        </trans-unit>
        <trans-unit id="d71af0bf722f0a317f82d7cfc36b49481534370f" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary array of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前实现使用合并排序。它使用长度为 &lt;code&gt;n/2&lt;/code&gt; 的临时数组，其中 &lt;code&gt;n&lt;/code&gt; 是数组的长度。它通常比&lt;a href=&quot;array#VALsort&quot;&gt; &lt;code&gt;Array.sort&lt;/code&gt; &lt;/a&gt;的当前实现更快。</target>
        </trans-unit>
        <trans-unit id="d6a650f05571190722115be821ddb0eec6d9c2b0" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary array of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前实现使用合并排序。它使用长度为 &lt;code&gt;n/2&lt;/code&gt; 的临时数组，其中 &lt;code&gt;n&lt;/code&gt; 是数组的长度。它通常比&lt;a href=&quot;arraylabels#VALsort&quot;&gt; &lt;code&gt;ArrayLabels.sort&lt;/code&gt; &lt;/a&gt;的当前实现更快。</target>
        </trans-unit>
        <trans-unit id="bdff8609298ac6203743f842126dd2f7ca872714" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary floatarray of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray. It is usually faster than the current implementation of &lt;a href=&quot;float.array#VALsort&quot;&gt;&lt;code&gt;Float.Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前实现使用合并排序。它使用长度为 &lt;code&gt;n/2&lt;/code&gt; 的临时floatarray ，其中 &lt;code&gt;n&lt;/code&gt; 是floatarray的长度。它通常比&lt;a href=&quot;float.array#VALsort&quot;&gt; &lt;code&gt;Float.Array.sort&lt;/code&gt; &lt;/a&gt;的当前实现更快。</target>
        </trans-unit>
        <trans-unit id="43edd4f7fc431695c3b52aadd6a0a76eca47b353" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary floatarray of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray. It is usually faster than the current implementation of &lt;a href=&quot;float.arraylabels#VALsort&quot;&gt;&lt;code&gt;Float.ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前实现使用合并排序。它使用长度为 &lt;code&gt;n/2&lt;/code&gt; 的临时floatarray ，其中 &lt;code&gt;n&lt;/code&gt; 是floatarray的长度。它通常比&lt;a href=&quot;float.arraylabels#VALsort&quot;&gt; &lt;code&gt;Float.ArrayLabels.sort&lt;/code&gt; &lt;/a&gt;的当前实现更快。</target>
        </trans-unit>
        <trans-unit id="b20647dbf18c92523a7fd6b83c3b58c9724e3e7a" translate="yes" xml:space="preserve">
          <source>The custom break is useful if you want to change which visible (non-whitespace) characters are printed in case of break or no break. For example, when printing a list</source>
          <target state="translated">如果你想改变在有断点或无断点的情况下打印哪些可见的(非空格)字符,那么自定义断点就很有用。例如,当打印一个列表时</target>
        </trans-unit>
        <trans-unit id="8b24549afabe1745d997e15b64b4d2aae161436a" translate="yes" xml:space="preserve">
          <source>The data is considered by the garbage collector alive if all the full keys are alive and if the ephemeron is alive. When one of the keys is not considered alive anymore by the GC, the data is emptied from the ephemeron. The data could be alive for another reason and in that case the GC will not free it, but the ephemeron will not hold the data anymore.</source>
          <target state="translated">如果所有的键都是活的,并且表象是活的,那么数据就被垃圾回收器认为是活的。当其中一个键不再被GC认为是活着的时候,数据就会被从星历中清空。数据可能因为其他原因而存活,在这种情况下,GC不会释放它,但星历子将不再保存数据。</target>
        </trans-unit>
        <trans-unit id="ac0854565c0cabc94cf88db7d79f91eea95e9a7c" translate="yes" xml:space="preserve">
          <source>The data part of a custom block v can be accessed via the pointer Data_custom_val(v). This pointer has type void * and should be cast to the actual type of the data stored in the custom block.</source>
          <target state="translated">自定义块v的数据部分可以通过指针Data_custom_val(v)来访问。这个指针的类型为void *,应该投向自定义块中存储的数据的实际类型。</target>
        </trans-unit>
        <trans-unit id="e8e6e6b562a36d00a364c6de4dc0a4ef30f6a91f" translate="yes" xml:space="preserve">
          <source>The debugger can print the current value of simple expressions. The expressions can involve program variables: all the identifiers that are in scope at the selected program point can be accessed.</source>
          <target state="translated">调试器可以打印简单表达式的当前值。表达式可以涉及程序变量:可以访问所有在选定程序点范围内的标识符。</target>
        </trans-unit>
        <trans-unit id="f8c3dc260564ad64dea40270472823def2648071" translate="yes" xml:space="preserve">
          <source>The debugger communicate with the program being debugged through a Unix socket. You may need to change the socket name, for example if you need to run the debugger on a machine and your program on another.</source>
          <target state="translated">调试器通过Unix套接字与被调试的程序进行通信。你可能需要改变套接字的名称,例如,如果你需要在一台机器上运行调试器,而你的程序在另一台机器上运行。</target>
        </trans-unit>
        <trans-unit id="89cf1e71a9b9ce7771fbb1158aff4c5ec71b350f" translate="yes" xml:space="preserve">
          <source>The debugger execute the OCaml runtime ocamlrun on the program. Rarely useful; moreover it prevents the debugging of programs compiled in &amp;ldquo;custom runtime&amp;rdquo; mode.</source>
          <target state="translated">调试器在程序上执行OCaml运行时ocamlrun。很少有用；此外，它还防止调试在&amp;ldquo;自定义运行时&amp;rdquo;模式下编译的程序。</target>
        </trans-unit>
        <trans-unit id="d8a4e05ea8e12b749680b25bf9ad4fb77bd551fb" translate="yes" xml:space="preserve">
          <source>The debugger is compatible with the Dynlink module. However, when an external module is not yet loaded, it is impossible to set a breakpoint in its code. In order to facilitate setting breakpoints in dynamically loaded code, the debugger stops the program each time new modules are loaded. This behavior can be disabled using the break_on_load variable:</source>
          <target state="translated">调试器与Dynlink模块兼容,但当外部模块尚未加载时,无法在其代码中设置断点。但是,当外部模块尚未加载时,无法在其代码中设置断点。为了方便在动态加载的代码中设置断点,每次加载新模块时,调试器都会停止程序。这种行为可以使用break_on_load变量来禁止。</target>
        </trans-unit>
        <trans-unit id="67085f47487648631c3de0d3b7f5a54b54f116e7" translate="yes" xml:space="preserve">
          <source>The debugger searches for source files and compiled interface files in a list of directories, the search path. The search path initially contains the current directory . and the standard library directory. The directory command adds directories to the path.</source>
          <target state="translated">调试器在一个目录列表中搜索源文件和编译后的接口文件,即搜索路径。搜索路径最初包含当前目录.和标准库目录。目录命令将目录添加到路径中。</target>
        </trans-unit>
        <trans-unit id="d81bce2c8314b77a05e6061c8832d983f35d9089" translate="yes" xml:space="preserve">
          <source>The debugger starts executing the debugged program only when needed. This allows setting breakpoints or assigning debugger variables before execution starts. There are several ways to start execution:</source>
          <target state="translated">调试器只在需要时才开始执行被调试程序。这样可以在执行开始前设置断点或分配调试器变量。有几种方法可以开始执行。</target>
        </trans-unit>
        <trans-unit id="6c85faabbbf8e1f661bc7a77c9db172d2189ae3c" translate="yes" xml:space="preserve">
          <source>The declaration of a variant type lists all possible forms for values of that type. Each case is identified by a name, called a constructor, which serves both for constructing values of the variant type and inspecting them by pattern-matching. Constructor names are capitalized to distinguish them from variable names (which must start with a lowercase letter). For instance, here is a variant type for doing mixed arithmetic (integers and floats):</source>
          <target state="translated">变体类型的声明列出了该类型值的所有可能形式。每种情况都有一个名称,称为构造函数,它既可以用来构造变体类型的值,也可以通过模式匹配检查它们。构造函数的名称是大写的,以区别于变量名(变量名必须以小写字母开头)。例如,这里是一个用于进行混合运算(整数和浮点数)的变体类型。</target>
        </trans-unit>
        <trans-unit id="6dc771c421fb48e91d66c641d430796a079c9f9c" translate="yes" xml:space="preserve">
          <source>The declarations of the built-in types and the components of module Stdlib are printed one by one in typewriter font, followed by a short comment. All library modules and the components they provide are indexed at the end of this report.</source>
          <target state="translated">内置类型的声明和模块Stdlib的组件以打字机字体逐一打印出来,后面有简短的注释。所有的库模块和它们所提供的组件都在本报告的最后做了索引。</target>
        </trans-unit>
        <trans-unit id="2765fb82c88da6a8123fcc1afb411e9f247fbfa9" translate="yes" xml:space="preserve">
          <source>The default representation. In the present version of OCaml, the default is the boxed representation.</source>
          <target state="translated">默认的表示方式。在目前的OCaml版本中,默认为盒式表示法。</target>
        </trans-unit>
        <trans-unit id="74b33452fd1e9690245e62c43fa2151918346419" translate="yes" xml:space="preserve">
          <source>The default setting is &amp;rsquo;auto&amp;rsquo;, and the current heuristic checks that the TERM environment variable exists and is not empty or dumb, and that &amp;rsquo;isatty(stderr)&amp;rsquo; holds.</source>
          <target state="translated">默认设置为'auto'，当前的启发式检查将检查TERM环境变量是否存在且不为空或哑，并且'isatty（stderr）'成立。</target>
        </trans-unit>
        <trans-unit id="08126df5b12a33c60b2609d1299988ea98c261cf" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by  -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">默认设置为-w +a-4-6-7-9-27-29-32...42-44-45-48-50-60。它由-help显示。注意,警告5和10并不总是被触发,这取决于类型检查器的内部结构。</target>
        </trans-unit>
        <trans-unit id="ed097a6c98a3e8cb9832ea96755d5d9244c148bd" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlc -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">默认设置是-w +a-4-6-7-9-27-29-32...42-44-45-48-50-60。它由ocamlc -help显示。注意,警告5和10并不总是被触发,这取决于类型检查器的内部结构。</target>
        </trans-unit>
        <trans-unit id="7ab6f8a18cb9ae711fa680c3d32f93edfefbee98" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlopt -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">默认设置是-w +a-4-6-7-9-27-29-32...42-44-45-48-50-60。它可以通过 ocamlopt -help 显示。注意,警告5和10并不总是被触发,这取决于类型检查器的内部结构。</target>
        </trans-unit>
        <trans-unit id="3eff228cd3aa401186be612172c09c21427569b2" translate="yes" xml:space="preserve">
          <source>The default setting is -warn-error -a+31 (only warning 31 is fatal).</source>
          <target state="translated">默认设置是-warn-error -a+31(只有警告31是致命的)。</target>
        </trans-unit>
        <trans-unit id="d8b548e294caad0232bcef920b432423c497646b" translate="yes" xml:space="preserve">
          <source>The default setting is contextual.</source>
          <target state="translated">默认设置为上下文。</target>
        </trans-unit>
        <trans-unit id="4549da8d617844ebcd908e7e44273e838886bca2" translate="yes" xml:space="preserve">
          <source>The default settings (when not using -Oclassic) are for one round of optimisation using the following parameters.</source>
          <target state="translated">默认设置(不使用-Oclassic时)是使用以下参数进行一轮优化。</target>
        </trans-unit>
        <trans-unit id="5f4796a7bec8a2fd44bd0c64ad6daa008bf2c968" translate="yes" xml:space="preserve">
          <source>The default trace filename is caml-{PID}.eventlog, where {PID} is the process identifier of the traced program.</source>
          <target state="translated">默认的跟踪文件名是caml-{PID}.eventlog,其中{PID}是被跟踪程序的进程标识符。</target>
        </trans-unit>
        <trans-unit id="56ba28d4eda458e2debd6c11d3035373c9678204" translate="yes" xml:space="preserve">
          <source>The definition val [mutable] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; adds an instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; whose initial value is the value of expression &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. The flag mutable allows physical modification of this variable by methods.</source>
          <target state="translated">定义val [mutable] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;添加了一个实例变量&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name，&lt;/a&gt;其初始值为表达式&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;的值。可变的标志允许通过方法对该变量进行物理修改。</target>
        </trans-unit>
        <trans-unit id="a51442850ae9805c91c304fd05e9989dc50518ce" translate="yes" xml:space="preserve">
          <source>The deserialize field can be set to custom_deserialize_default to indicate that deserialization is not supported. In this case, do not register the struct custom_operations with the deserializer using register_custom_operations (see below).</source>
          <target state="translated">可以将deserialize字段设置为custom_deserialize_default来表示不支持反序列化。在这种情况下,不要使用 register_custom_operations 向反序列化器注册 custom_operations 结构(见下文)。</target>
        </trans-unit>
        <trans-unit id="7d06ebe0f4fedec527437bd502a65f8f670ba5db" translate="yes" xml:space="preserve">
          <source>The deserialize field contains a pointer to a C function that is called whenever a custom block with identifier identifier needs to be deserialized (un-marshaled) using the OCaml functions input_value or Marshal.from_.... This user-provided function is responsible for reading back the data written by the serialize operation, using the deserialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. It must then rebuild the data part of the custom block and store it at the pointer given as the dst argument. Finally, it returns the size in bytes of the data part of the custom block. This size must be identical to the wsize_32 result of the serialize operation if the architecture is 32 bits, or wsize_64 if the architecture is 64 bits.</source>
          <target state="translated">反序列化字段包含一个指向C函数的指针，每当需要使用OCaml函数input_value或Marshal.from _...对具有标识符标识符的自定义块进行反序列化（未编组）时，就会调用此函数。此用户提供的函数负责使用在&amp;lt;caml / intext.h&amp;gt;中定义并在下面列出的deserialize _...函数，读回由序列化操作写入的数据。然后，它必须重建自定义块的数据部分，并将其存储在作为dst参数给出的指针处。最后，它返回自定义块数据部分的大小（以字节为单位）。如果体系结构为32位，则此大小必须与序列化操作的wsize_32结果相同；如果体系结构为64位，则此大小必须与wsize_64相同。</target>
        </trans-unit>
        <trans-unit id="e12a3fa498a55d5d0c412779070a2ed53e0f6b56" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex are limited to at most 32767 transitions. The message above indicates that your lexer definition is too complex and overflows this limit. This is commonly caused by lexer definitions that have separate rules for each of the alphabetic keywords of the language, as in the following example.</source>
          <target state="translated">ocamllex生成的确定性自动机最多只能有32767个转换。上面的消息表明,你的词库定义太复杂,超出了这个限制。这通常是由词典定义引起的,这些定义对语言的每个字母关键词都有单独的规则,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="f264a27cdcd5df325cf7076559a44cc284c906a3" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex maintain a table of positions inside the scanned lexer buffer. The size of this table is limited to at most 255 cells. This error should not show up in normal situations.</source>
          <target state="translated">ocamllex生成的确定性自动机在扫描的词库缓冲区内维护一个位置表。这个表的大小最多限制为255个单元。这个错误在正常情况下不应该出现。</target>
        </trans-unit>
        <trans-unit id="3158707a3751ac6c5252dbe261969b8247c51cac" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;1.0&lt;/code&gt; and the smallest exactly representable floating-point number greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1.0&lt;/code&gt; 与最小可精确表示的浮点数之间的差大于 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2adcbc0a31dc0085a55ca93ed2f074bdee4bf581" translate="yes" xml:space="preserve">
          <source>The difference between open and include is that open simply provides short names for the components of the opened structure, without defining any components of the current structure, while include also adds definitions for the components of the included structure.</source>
          <target state="translated">open和include的区别在于,open只是为被打开的结构的组件提供了简短的名称,而没有定义当前结构的任何组件,而include也为include结构的组件添加了定义。</target>
        </trans-unit>
        <trans-unit id="9aa0efd021b346152ef35413cf1dcb66bfc3d8c0" translate="yes" xml:space="preserve">
          <source>The difficulty usually lies in defining instances of the pattern above by inheritance. This can be done in a natural and obvious manner in OCaml, as shown on the following example manipulating windows.</source>
          <target state="translated">困难通常在于通过继承来定义上述模式的实例。这在OCaml中可以用自然而明显的方式来完成,如下图所示,在操作窗口的例子上。</target>
        </trans-unit>
        <trans-unit id="5d9b6c0e1a7cefc1807aceddd0b3961bcb021ba5" translate="yes" xml:space="preserve">
          <source>The directory containing the OCaml standard library. (If OCAMLLIB is not set, CAMLLIB will be used instead.) Used to locate the ld.conf configuration file for dynamic loading (see section &amp;zwj;&lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). If not set, default to the library directory specified when compiling OCaml.</source>
          <target state="translated">包含OCaml标准库的目录。用于定位为动态加载的ld.conf配置文件（如果没有设置OCAMLLIB，CAMLLIB将被用来代替。）（见第&lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;）。如果未设置，则默认为编译OCaml时指定的库目录。</target>
        </trans-unit>
        <trans-unit id="7c440f9c47d69da4fc51fae25d28e485866ceeae" translate="yes" xml:space="preserve">
          <source>The directory containing the OCaml standard library. (If OCAMLLIB is not set, CAMLLIB will be used instead.) Used to locate the ld.conf configuration file for dynamic loading (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). If not set, default to the library directory specified when compiling OCaml.</source>
          <target state="translated">包含OCaml标准库的目录。（如果未设置OCAMLLIB，则将改用CAMLLIB。）用于查找ld.conf配置文件以进行动态加载（请参见&lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;节）。如果未设置，则默认为编译OCaml时指定的库目录。</target>
        </trans-unit>
        <trans-unit id="84d3f5e5913ebfecb51ac69e325978cd0b7f44c0" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g.</source>
          <target state="translated">目录分隔符(如</target>
        </trans-unit>
        <trans-unit id="6ff406baa499fe8d2e26970180e41618d3f08eae" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g. &lt;code&gt;/&lt;/code&gt; in Unix).</source>
          <target state="translated">目录分隔符（例如 &lt;code&gt;/&lt;/code&gt; 在Unix中）。</target>
        </trans-unit>
        <trans-unit id="cabc8641d53a500b754d86780ff17e145160ba34" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; was introduced in OCaml 4.02, and the &quot;unsafe-string&quot; compatibility mode was the default until OCaml 4.05. Starting with 4.06, the compatibility mode is opt-in; we intend to remove the option in the future.</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 之间的区别是在OCaml 4.02中引入的，在直到OCaml 4.05之前，&amp;ldquo; unsafe-string&amp;rdquo;兼容模式是默认的。从4.06开始，兼容模式为选择加入；我们打算在将来删除该选项。</target>
        </trans-unit>
        <trans-unit id="8186633942c846dfc9406083eb5c8a8657d3ebba" translate="yes" xml:space="preserve">
          <source>The domain of a coercion can often be omitted. For instance, one can define:</source>
          <target state="translated">强制的领域往往可以省略。例如,人们可以定义:</target>
        </trans-unit>
        <trans-unit id="8f7c83c21065a6dbadc8d2a47e55b23520a044b2" translate="yes" xml:space="preserve">
          <source>The dump file is written only if the program terminates normally (by calling exit or by falling through). It is not written if the program terminates with an uncaught exception.</source>
          <target state="translated">转储文件只在程序正常终止(调用exit或落空)的情况下写入。如果程序以未捕获的异常终止,则不写入转储文件。</target>
        </trans-unit>
        <trans-unit id="73f7bba6640e6313fca9805d26493bd64599c1bc" translate="yes" xml:space="preserve">
          <source>The dynlink library supports type-safe dynamic loading and linking of bytecode object files (.cmo and .cma files) in a running bytecode program, or of native plugins (usually .cmxs files) in a running native program. Type safety is ensured by limiting the set of modules from the running program that the loaded object file can access, and checking that the running program and the loaded object file have been compiled against the same interfaces for these modules. In native code, there are also some compatibility checks on the implementations (to avoid errors with cross-module optimizations); it might be useful to hide .cmx files when building native plugins so that they remain independent of the implementation of modules in the main program.</source>
          <target state="translated">dynlink库支持类型安全的动态加载和链接正在运行的字节码程序中的字节码对象文件(.cmo和.cma文件),或者正在运行的本地程序中的本地插件(通常是.cmxs文件)。类型安全是通过限制加载的对象文件可以访问的运行程序中的模块集,并检查运行程序和加载的对象文件是否已经针对这些模块的相同接口进行了编译来保证的。在原生代码中,还对实现进行了一些兼容性检查(以避免跨模块优化的错误);在构建原生插件时,隐藏.cmx文件可能是有用的,这样它们就可以保持独立于主程序中模块的实现。</target>
        </trans-unit>
        <trans-unit id="a8d149e1bbd9086296a3979238c337a08c4d4c93" translate="yes" xml:space="preserve">
          <source>The easiest way to define a custom generator is the following this example, here extending the current HTML generator. We don&amp;rsquo;t have to know if this is the original HTML generator defined in ocamldoc or if it has been extended already by a previously loaded custom generator &amp;zwj;:</source>
          <target state="translated">定义自定义生成器的最简单方法是此示例，此处扩展了当前的HTML生成器。我们不必知道这是ocamldoc中定义的原始HTML生成器，还是先前已加载的自定义生成器已经对其进行了扩展：</target>
        </trans-unit>
        <trans-unit id="bfccb11647d7c3a22dd1b9fca91bf4419d42d590" translate="yes" xml:space="preserve">
          <source>The easiest way to define a custom generator is the following this example, here extending the current HTML generator. We don&amp;rsquo;t have to know if this is the original HTML generator defined in ocamldoc or if it has been extended already by a previously loaded custom generator :</source>
          <target state="translated">定义自定义生成器的最简单方法是此示例，此处扩展了当前的HTML生成器。我们不必知道这是ocamldoc中定义的原始HTML生成器，还是先前已加载的自定义生成器已经对其进行了扩展：</target>
        </trans-unit>
        <trans-unit id="58f055689b02c7748240c0805950d6c0e3a0e111" translate="yes" xml:space="preserve">
          <source>The elements are passed to &lt;code&gt;f&lt;/code&gt; in increasing order with respect to the ordering over the type of the elements.</source>
          <target state="translated">相对于元素类型的顺序，这些元素以递增的顺序传递给 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6710aa8b225c8ca5f7b41012a718cf1001e66889" translate="yes" xml:space="preserve">
          <source>The else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; part can be omitted, in which case it defaults to else().</source>
          <target state="translated">可以省略else &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;部分，在这种情况下，它默认为else（）。</target>
        </trans-unit>
        <trans-unit id="9282996444b9faf1c947138395efb723dd3e6881" translate="yes" xml:space="preserve">
          <source>The empty map.</source>
          <target state="translated">空地图。</target>
        </trans-unit>
        <trans-unit id="8e51b0d5d7e271c88e867edd7cf3a56d6061ba51" translate="yes" xml:space="preserve">
          <source>The empty sequence, containing no elements.</source>
          <target state="translated">空序列,不含任何元素。</target>
        </trans-unit>
        <trans-unit id="0ac903ee0be4b8d03c2629dea67dc51a5e1dc555" translate="yes" xml:space="preserve">
          <source>The empty set.</source>
          <target state="translated">的空集。</target>
        </trans-unit>
        <trans-unit id="bcc5ac53238f78e7ccd13efd320b3aba2a2a43c4" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_COLOR is considered if -color is not provided. Its values are auto/always/never as above.</source>
          <target state="translated">如果没有提供-color,则会考虑环境变量OCML_COLOR。它的值是自动/总是/从不,如上所述。</target>
        </trans-unit>
        <trans-unit id="bc5a16c0802c0d6eab8dd39659b932cb9d3eeec2" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_ERROR_STYLE is considered if -error-style is not provided. Its values are short/contextual as above.</source>
          <target state="translated">如果没有提供-error-style,则考虑环境变量OCML_ERROR_STYLE。它的值是短的/上下文的,如上所述。</target>
        </trans-unit>
        <trans-unit id="d7f093c02c802f297eef039f1f8ed6be219bfe78" translate="yes" xml:space="preserve">
          <source>The ephemerons complicate the notion of liveness of values, because it is not anymore an equivalence with the reachability from root value by usual pointers (not weak and not ephemerons). With ephemerons the notion of liveness is constructed by the least fixpoint of: A value is alive if:</source>
          <target state="translated">瞤息子使值的有效性概念复杂化了,因为它不再是一个等价的概念,而是通过通常的指针(不是弱指针,也不是瞤息子)从根值出发的可达性。对于外延子,活泼性的概念是由最小的fixpoint of构建的。一个值是活的,如果:</target>
        </trans-unit>
        <trans-unit id="f38c615e4885039a9f6a96adebc7d8b6a2703f76" translate="yes" xml:space="preserve">
          <source>The equal function for 16-character digest.</source>
          <target state="translated">16字符文摘的等价函数。</target>
        </trans-unit>
        <trans-unit id="4745822a26883aa3e079c90a04c121006a19e95e" translate="yes" xml:space="preserve">
          <source>The equal function for chars.</source>
          <target state="translated">chars的等价函数。</target>
        </trans-unit>
        <trans-unit id="975faf8015348dfd4f8f27ef557f89666b74bd4f" translate="yes" xml:space="preserve">
          <source>The equal function for floating-point numbers, compared using &lt;a href=&quot;float#VALcompare&quot;&gt;&lt;code&gt;Float.compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;float#VALcompare&quot;&gt; &lt;code&gt;Float.compare&lt;/code&gt; &lt;/a&gt;进行比较的浮点数相等函数。</target>
        </trans-unit>
        <trans-unit id="9f25af14cf81fd197468c0aef6ee60036c040bc5" translate="yes" xml:space="preserve">
          <source>The equal function for int32s.</source>
          <target state="translated">int32s的等价函数。</target>
        </trans-unit>
        <trans-unit id="43353326c31a51a2e1e40be3cfbc055a576f0c46" translate="yes" xml:space="preserve">
          <source>The equal function for int64s.</source>
          <target state="translated">int64s的等价函数。</target>
        </trans-unit>
        <trans-unit id="9acc244879540dd60658943a5fc7d40212cd5702" translate="yes" xml:space="preserve">
          <source>The equal function for native ints.</source>
          <target state="translated">原生英特的等价函数。</target>
        </trans-unit>
        <trans-unit id="287fd038b43c08ac15387236db89c8b9dfd89564" translate="yes" xml:space="preserve">
          <source>The equal function for strings.</source>
          <target state="translated">字符串的等价函数。</target>
        </trans-unit>
        <trans-unit id="4a7926a9ee2ed830da3e6706d16691abddc39c2a" translate="yes" xml:space="preserve">
          <source>The equality function for byte sequences.</source>
          <target state="translated">字节序列的平等函数。</target>
        </trans-unit>
        <trans-unit id="af06b8ab4789de98e0de35bd84609d867593cd6b" translate="yes" xml:space="preserve">
          <source>The equality predicate used to compare keys.</source>
          <target state="translated">用于比较键的平等谓词。</target>
        </trans-unit>
        <trans-unit id="b5b330b7afa938d8255dff04d36ee3805387cec6" translate="yes" xml:space="preserve">
          <source>The equivalent of -inline but used when speculative inlining starts at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;. Not used in -Oclassic mode.</source>
          <target state="translated">等效于-inline，但在推测性内联从顶级开始时使用。参见第&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;节。在-Oclassic模式下不使用。</target>
        </trans-unit>
        <trans-unit id="83858c6c1566ad5f65edb208e38dd2558053de52" translate="yes" xml:space="preserve">
          <source>The equivalent of -inline but used when speculative inlining starts at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;. Not used in -Oclassic mode.</source>
          <target state="translated">等效于-inline，但在推测性内联从顶级开始时使用。参见第&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;节。在-Oclassic模式下不使用。</target>
        </trans-unit>
        <trans-unit id="39ebc7f9bdd19cdd7a118ed9f1944b74ed8a6585" translate="yes" xml:space="preserve">
          <source>The error messages are almost identical to those of ocamlc. See section &amp;zwj;&lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;.</source>
          <target state="translated">错误消息与ocamlc几乎相同。见&lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94cdb8a214ed46b885c25876cd3600fef2503877" translate="yes" xml:space="preserve">
          <source>The error messages are almost identical to those of ocamlc. See section &lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;.</source>
          <target state="translated">错误消息与ocamlc几乎相同。参见第&lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="7f378c773556e60ceb5a7a9d15fb2d1a81df83d7" translate="yes" xml:space="preserve">
          <source>The evaluation of the body of a class only takes place at object creation time. Therefore, in the following example, the instance variable x is initialized to different values for two different objects.</source>
          <target state="translated">类的主体的评估只发生在对象创建时。因此,在下面的例子中,实例变量x被初始化为两个不同对象的不同值。</target>
        </trans-unit>
        <trans-unit id="823e43ea0dd60b51d8777275d399ee78c608b08d" translate="yes" xml:space="preserve">
          <source>The exact definition of which free variables are captured in a closure is not specified and can vary between bytecode and native code (and according to optimization flags). In particular, a function value accessing a global reference may or may not include the reference in its closure. If it does, unmarshaling the corresponding closure will create a new reference, different from the global one.</source>
          <target state="translated">闭包中捕获哪些自由变量的确切定义没有指定,在字节码和本地代码之间可能会有所不同(并根据优化标志)。特别是,访问全局引用的函数值可能包括也可能不包括在其闭包中的引用。如果包含了,解开相应的闭包将创建一个新的引用,与全局引用不同。</target>
        </trans-unit>
        <trans-unit id="367c1c92926004568a37375dcb37462e755ae202" translate="yes" xml:space="preserve">
          <source>The execution of a program is affected by certain information it receives when the debugger starts it, such as the command-line arguments to the program and its working directory. The debugger provides commands to specify this information (set arguments and cd). These commands must be used before program execution starts. If you try to change the arguments or the working directory after starting your program, the debugger will kill the program (after asking for confirmation).</source>
          <target state="translated">程序的执行会受到调试器启动程序时接收到的某些信息的影响,比如程序的命令行参数和工作目录。调试器提供了指定这些信息的命令(设置参数和cd)。这些命令必须在程序执行开始前使用。如果你在启动程序后试图改变参数或工作目录,调试器将杀死程序(在要求确认后)。</target>
        </trans-unit>
        <trans-unit id="891519fb02f7659ffef41323f18ea6f26295ee67" translate="yes" xml:space="preserve">
          <source>The execution times (CPU times) of a process.</source>
          <target state="translated">进程的执行时间(CPU时间)。</target>
        </trans-unit>
        <trans-unit id="ea3566383d4d77e6af67a2d9e1c982e58d1aacae" translate="yes" xml:space="preserve">
          <source>The exhaustiveness check is aware of GADT constraints, and can automatically infer that some cases cannot happen. For instance, the following pattern matching is correctly seen as exhaustive (the Add case cannot happen).</source>
          <target state="translated">穷尽性检查意识到了GADT约束,可以自动推断出一些情况不能发生。例如,下面的模式匹配被正确地看成是穷尽性的(Add case不能发生)。</target>
        </trans-unit>
        <trans-unit id="682f2afe18d27a6b2d5109af77f4241c373f09ce" translate="yes" xml:space="preserve">
          <source>The expression</source>
          <target state="translated">表达式</target>
        </trans-unit>
        <trans-unit id="48d5ec0634b8a1782837ee8b1ca9761b0c8a2b02" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;.</source>
          <target state="translated">表达式（&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;）的计算结果与&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="fc9adc4308aa68c065cc84caf08fbc1ea795d7aa" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;) checks that &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; matches the type of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; (that is, that the implementation &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;). The whole expression evaluates to the same class as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="translated">表达式（&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;：&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;）检查&lt;a href=&quot;#class-type&quot;&gt;class-type是否&lt;/a&gt;与&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;的类型匹配（即，实现&lt;a href=&quot;#class-expr&quot;&gt;class-expr是否&lt;/a&gt;满足类型规范&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;）。整个表达式的计算结果与&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;属于同一类，除了未在&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;中指定的所有组件被隐藏并且无法再访问之外。</target>
        </trans-unit>
        <trans-unit id="8f1374da867ccabac7aad3663177813cdc0a9fa8" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;.</source>
          <target state="translated">表达式（&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;）的计算结果与&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="1fd1fd31681b7a2cf0269cba7eed69aec7e48ffe" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) checks that the type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; is a subtype of &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;, that is, that all components specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are implemented in &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, and their implementation meets the requirements given in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. In other terms, it checks that the implementation &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. The whole expression evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="translated">表达式（&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;：&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;）检查&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;的类型是否是&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;的子类型，即，在&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;中指定的所有组件都在&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;中实现，并且它们的实现是否满足在&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type中&lt;/a&gt;给出的要求。换句话说，它检查实现&lt;a href=&quot;#module-expr&quot;&gt;module-expr是否&lt;/a&gt;满足类型规范&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;。整个表达式的计算结果与&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;属于同一模块，除了未在&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;中指定的所有组件被隐藏并且无法再访问之外。</target>
        </trans-unit>
        <trans-unit id="bef2d23b52ee970fade1b06935e7b9ced9f528d5" translate="yes" xml:space="preserve">
          <source>The expression (module&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) converts the module (structure or functor) denoted by module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to a value of the core language that encapsulates this module. The type of this core language value is (module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;). The &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; annotation can be omitted if it can be inferred from the context.</source>
          <target state="translated">表达式（module &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）将由模块表达式&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;表示的模块（结构或函子）转换为封装该模块的核心语言的值。此核心语言值&lt;a href=&quot;#package-type&quot;&gt;的类型&lt;/a&gt;为（模块package-type）。的&lt;a href=&quot;#package-type&quot;&gt;包型&lt;/a&gt;，如果它可以从上下文中推断注释可以省略。</target>
        </trans-unit>
        <trans-unit id="c3d05c07c0894d4fd053f92bb2e5d69fce8d15a3" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; invokes the method &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; of the object denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;＃&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;调用由&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;表示的对象的方法&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5fe9ec8f9aa27454f205256c37ed9a50e6170e6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if both &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluate to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to false. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="translated">如果&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;都等于true，则表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;amp;&amp;amp; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;等于true；否则，表达式expr &lt;sub&gt;1&lt;/sub&gt; &amp;amp;&amp;amp; expr &lt;sub&gt;2&lt;/sub&gt;等于true。否则，它的计算结果为false。首先评估第一个组件&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。如果第一个组件的评估结果为false，则不评估第二个组件&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。因此，表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;amp;&amp;amp; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2的&lt;/sub&gt;行为与&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="67be0419a621a610a2e5884430cdee8308e61e8d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; evaluates to the n-tuple of the values of expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The evaluation order of the subexpressions is not specified.</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;等于表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;到&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;的值的n元组。未指定子表达式的求值顺序。</target>
        </trans-unit>
        <trans-unit id="f82e349965c8472e346c4996f8f13cfaa04ee8f5" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) returns the value of element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first element has number 0; the last element has number n&amp;minus;1, where n is the size of the array. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1。&lt;/sub&gt;（&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）返回由&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;表示的数组中元素编号&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;的值。第一个元素的编号为0；第二个元素的编号为0。最后一个元素的编号为n-1，其中n是数组的大小。如果访问超出范围，则会引发Invalid_argument异常。&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="b86cf48755f90d38c3703b093a559d201d41505d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;)&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1。&lt;/sub&gt;（&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）&amp;lt;- &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;修改就位的&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;表示的数组，用&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;的值替换元素编号&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。如果访问超出范围，则会引发Invalid_argument异常。整个表达式的值为（）。&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="82e23d1a40c45b5cca334a602a3b8464c8cb5ac6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, and returns the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record value.</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。&lt;a href=&quot;names#field&quot;&gt;字段将&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;评估为记录值，并返回与此记录值中的&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;关联的值。</target>
        </trans-unit>
        <trans-unit id="fac0b26bb16a9c0e18d3fa3496db97765aa8519f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, which is then modified in-place by replacing the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This operation is permitted only if &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; has been declared mutable in the definition of the record type. The whole expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to the unit value ().</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr &lt;/a&gt;&lt;sub&gt;2将&lt;/sub&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;评估为记录值，然后通过用&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;的值替换与该记录中的&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;相关的值来对其进行就地修改。仅当在记录类型的定义中将&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;声明为可变字段时，才允许执行此操作。整个表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;计算为单位值（）。&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7cd6fc3dc672a6d7077ed6957a582e1952b94590" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;] returns the value of character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first character has number 0; the last character has number n&amp;minus;1, where n is the length of the string. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1。&lt;/sub&gt; [ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ]返回由&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;表示的字符串中字符编号&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;的值。第一个字符的编号为0；最后一个字符的编号为n-1，其中n是字符串的长度。如果访问超出范围，则会引发Invalid_argument异常。&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="19a3eefaad7e437247b3bc6db656e1c074dfe4b0" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;]&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1。&lt;/sub&gt; [ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ] &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;修改就位的&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;表示的字符串，用&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;的值替换字符数&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。如果访问超出范围，则会引发Invalid_argument异常。整个表达式的值为（）。&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="54bc0bbda0902a87059f4ab52fd17c9a2c5cb0cd" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; first, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, and returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;首先对&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;求值，然后对&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;求值，并返回&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;的值。</target>
        </trans-unit>
        <trans-unit id="c3309f1c657c39dcf14b482d1d2b52b485c6e1c1" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if one of the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to true. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="translated">表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; || &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2个&lt;/sub&gt;评估为真，如果表达式之一&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;个&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;评估为真;否则，它的计算结果为false。首先评估第一个组件&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。如果第一个组件的值为true，则不评估第二个组件的&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。因此，表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; || &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2的&lt;/sub&gt;行为与</target>
        </trans-unit>
        <trans-unit id="465cc162397700c3a7233e4d6be2e63f71fde0fe" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a functor and &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; to a module, and applies the former to the latter. The type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must match the type expected for the arguments of the functor &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;#module-expr&quot;&gt;module-expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;（&lt;a href=&quot;#module-expr&quot;&gt;module-expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;）将&lt;a href=&quot;#module-expr&quot;&gt;模块expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;评估为函子，将&lt;a href=&quot;#module-expr&quot;&gt;module-expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;评估为模块，并将前者应用于后者。所述类型的&lt;a href=&quot;#module-expr&quot;&gt;模块EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;必须预期的函子的参数的类型匹配&lt;a href=&quot;#module-expr&quot;&gt;模块EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="1e4e8d9bdc0d328e50497d061e05aaaa6759bfe6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the parametric class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;, in which type parameters have been instantiated respectively to &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;names#class-path&quot;&gt;class-path的&lt;/a&gt;计算结果是绑定到名称&lt;a href=&quot;names#class-path&quot;&gt;class-path的类&lt;/a&gt;。类似地，表达式[ &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt; ]&lt;a href=&quot;names#class-path&quot;&gt;类路径&lt;/a&gt;的计算结果为绑定到名称参数类&lt;a href=&quot;names#class-path&quot;&gt;类路径&lt;/a&gt;，其中类型参数已被实例化以分别&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="88f78fb35dd0d933beef57fab438013880471ef8" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the parametric class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;, in which type parameters have been instantiated to respectively &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;等效于绑定到名称&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;的类类型。类似地，表达式[ &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt; ] &lt;a href=&quot;names#classtype-path&quot;&gt;CLASSTYPE路径&lt;/a&gt;相当于绑定到名称参数类型&lt;a href=&quot;names#classtype-path&quot;&gt;CLASSTYPE路径&lt;/a&gt;，其中类型参数已被实例化以分别&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，... &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="9bdccee9cf7f9a846ebb0d6ce9a9a4d063b0d4f4" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;（&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）的计算结果为变量值，其构造函数为&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;，其参数为&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;的值。</target>
        </trans-unit>
        <trans-unit id="fd2b0c9502549e5b50e4ab2002a089216e807b74" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the unary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Similarly, the expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the n-ary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;names#constr&quot;&gt;constr &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr的&lt;/a&gt;计算结果为一元变量值，该变量的构造函数为&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;，其参数为&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的值。类似地，表达式&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;（&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）求值为构造函数为&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;且其参数为&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;的值的n元变量值。</target>
        </trans-unit>
        <trans-unit id="86658bc3c80f7feb554c6583c0fa9ad438f2d77f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; modifies in-place the current object by replacing the value associated to &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; by the value of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Of course, this instance variable must have been declared mutable.</source>
          <target state="translated">表达&lt;a href=&quot;names#inst-var-name&quot;&gt;INST-VAR-名&lt;/a&gt;&amp;lt; - &lt;a href=&quot;expr#expr&quot;&gt;EXPR&lt;/a&gt;就地修改当前对象通过更换相关联的值&lt;a href=&quot;names#inst-var-name&quot;&gt;INST-VAR-名&lt;/a&gt;由的值&lt;a href=&quot;expr#expr&quot;&gt;EXPR&lt;/a&gt;。当然，此实例变量必须已声明为可变的。</target>
        </trans-unit>
        <trans-unit id="7ac13a35707432acbcfeb9a3119c7ad181cc342a" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt; is equivalent to the module type bound to the name &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt;. The expression (&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt;等效于绑定到名称&lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt;的模块类型。表达式（&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;）表示与&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;相同的类型。</target>
        </trans-unit>
        <trans-unit id="63b697cf7e46dafd21affd4bfc9ae60ca539fafc" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; evaluates to the module bound to the name &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.</source>
          <target state="translated">表达式&lt;a href=&quot;names#module-path&quot;&gt;module-path的&lt;/a&gt;计算结果是绑定到名称&lt;a href=&quot;names#module-path&quot;&gt;module-path的模块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="374fd1d5eec03fb1c40077ef206acff290b1b338" translate="yes" xml:space="preserve">
          <source>The expression [|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] evaluates to a n-element array, whose elements are initialized with the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively. The order in which these expressions are evaluated is unspecified.</source>
          <target state="translated">表达式[| &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;；&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; |]计算一个n元素数组，其元素分别用&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;到&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;的值初始化。这些表达式的求值顺序不确定。</target>
        </trans-unit>
        <trans-unit id="e45182f3efd80314e85a55d033c068a05794bdeb" translate="yes" xml:space="preserve">
          <source>The expression `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the polymorphic variant value whose tag is &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">表达式` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;计算得出的多态变量值，其标签为&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;，其参数为&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="c7801f0a175513fedc9db3b2ea095ee870659f32" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world save for possibly affecting the state of the garbage collector by performing an allocation. Expressions that only have generative effects and whose results are unused may be eliminated by the compiler. However, unlike expressions with &amp;ldquo;no effects&amp;rdquo;, such expressions will never be eligible for duplication.</source>
          <target state="translated">该表达式不会更改世界的可观察状态，除非可能通过执行分配影响垃圾回收器的状态。编译器可能会删除仅具有生成效果且未使用结果的表达式。但是，与具有&amp;ldquo;没有效果&amp;rdquo;的表达式不同，此类表达式将永远无法进行复制。</target>
        </trans-unit>
        <trans-unit id="06268c11c08cbf54ec4d6dfccb9fea053ea40756" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world. For example, it must not write to any mutable storage, call arbitrary external functions or change control flow (e.g. by raising an exception). Note that allocation is &lt;em&gt;not&lt;/em&gt; classed as having &amp;ldquo;no effects&amp;rdquo; (see below).</source>
          <target state="translated">该表达方式不会改变世界的可观察状态。例如，它不得写入任何可变存储器，调用任意外部函数或更改控制流（例如，通过引发异常）。请注意，分配&lt;em&gt;不&lt;/em&gt;归类为具有&amp;ldquo;无效果&amp;rdquo;（见下文）。</target>
        </trans-unit>
        <trans-unit id="54674c43e48502affde9ef34390ab16ef7402518" translate="yes" xml:space="preserve">
          <source>The expression does not observe the effects (in the sense described above) of other expressions. For example, it must not read from any mutable storage or call arbitrary external functions.</source>
          <target state="translated">该表达式不观察其他表达式的效果(在上述意义上)。例如,它不得从任何可改变的存储器中读取或调用任意的外部函数。</target>
        </trans-unit>
        <trans-unit id="66513182b7246bbaa2fec620bc98c1dc1505d3a1" translate="yes" xml:space="preserve">
          <source>The expression e in let x = e in e&amp;rsquo;.</source>
          <target state="translated">表达式e in让x = e in e'。</target>
        </trans-unit>
        <trans-unit id="fafa3e808d29aa326f8219b2a729faf94bb92f2f" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;downto&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done evaluates similarly, except that name is successively bound to the values n, n&amp;minus;1, &amp;hellip;, p+1, p. The loop body is never evaluated if n &amp;lt; p.</source>
          <target state="translated">表达的forName = &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; DOWNTO &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;做&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;3个&lt;/sub&gt;做过类似地求值，不同之处在于名称被依次结合到n的值，n-1个，...，P + 1，P。如果n &amp;lt;p，则永远不会评估循环体。</target>
        </trans-unit>
        <trans-unit id="9d57f96f2e7c598ac2e5a92cdba5ecd224f400d7" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;to&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done first evaluates the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; (the boundaries) into integer values n and p. Then, the loop body &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; is repeatedly evaluated in an environment where name is successively bound to the values n, n+1, &amp;hellip;, p&amp;minus;1, p. The loop body is never evaluated if n &amp;gt; p.</source>
          <target state="translated">首先完成表达式forname = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;至&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; do &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3，&lt;/sub&gt;将表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;（边界）求值为整数n和p。然后，在名称被连续绑定到值n，n + 1，&amp;hellip;，p-1，p的环境中，反复评估循环体&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;。如果n&amp;gt; p，则永远不会评估循环体。</target>
        </trans-unit>
        <trans-unit id="13ea45faff3269f614a52ad4b80de5d2a8ebf30f" translate="yes" xml:space="preserve">
          <source>The expression fun [[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; evaluates to a function from values to classes. When this function is applied to a value v, this value is matched against the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; and the result is the result of the evaluation of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; in the extended environment.</source>
          <target state="translated">表达式fun [[？] &lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;：] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern-&lt;/a&gt; &amp;gt; &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;计算得出一个从值到类的函数。当将此函数应用于值v时，该值将与模式&lt;a href=&quot;patterns#pattern&quot;&gt;模式&lt;/a&gt;匹配，并且结果是扩展环境中&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;的评估结果。</target>
        </trans-unit>
        <trans-unit id="5a2641611d76e3a4d8e4ffbce3daf0019fe517c9" translate="yes" xml:space="preserve">
          <source>The expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; introduces a type constructor named &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; which is considered abstract in the scope of the sub-expression, but then replaced by a fresh type variable. Note that contrary to what the syntax could suggest, the expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; itself does not suspend the evaluation of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; as a regular abstraction would. The syntax has been chosen to fit nicely in the context of function declarations, where it is generally used. It is possible to freely mix regular function parameters with pseudo type parameters, as in:</source>
          <target state="translated">表达式fun（type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;）-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;引入了一个名为&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;的类型构造函数，该构造函数在子表达式的范围内被认为是抽象的，但随后被一个新鲜的type变量替换。请注意，与语法建议的相反，表达式fun（type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;）-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;本身不会像常规抽象那样暂停对&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;的求值。选择该语法以使其很好地适合通常在函数声明的上下文中使用的语法。可以将常规函数参数与伪类型参数自由混合，如下所示：</target>
        </trans-unit>
        <trans-unit id="dc2f0b7a211a145ce7e8a7301a70f0d4c7d342fe" translate="yes" xml:space="preserve">
          <source>The expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; evaluates to a functor that takes as argument modules of the type &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, binds &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to these modules, evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in the extended environment, and returns the resulting modules as results. No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="translated">表达式functor（&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;：&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;）-&amp;gt; &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;评估为一个仿函数，该仿函数将类型为&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;1的&lt;/sub&gt;模块作为参数，将&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;绑定到这些模块，并在扩展环境中评估&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;，并返回结果模块作为结果。对functor参数的类型没有任何限制。特别是，一个函子可以将另一个函子作为参数（&amp;ldquo;高阶&amp;rdquo;函子）。</target>
        </trans-unit>
        <trans-unit id="39045ca493f5041229a426581d36cb35d6454361" translate="yes" xml:space="preserve">
          <source>The expression if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; evaluates to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean true, and to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean false.</source>
          <target state="translated">表达如果&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;然后&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;别的&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;3个&lt;/sub&gt;评估为的值&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;如果&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1个&lt;/sub&gt;评估为布尔真，并且它的值&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;如果&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;计算结果为布尔假。</target>
        </trans-unit>
        <trans-unit id="4cee2fb74666dafe45945b12c3589890b3ad2f7a" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in a structure re-exports in the current structure all definitions of the structure denoted by &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;. For instance, if you define a module S as below</source>
          <target state="translated">该表达式包括结构中的&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;在当前结构中重新导出由&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;表示的结构的所有定义。例如，如果您如下定义模块S</target>
        </trans-unit>
        <trans-unit id="5348485cb90b4b3e0999ac25862d4723d8c8e9d9" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; in a signature performs textual inclusion of the components of the signature denoted by &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;. It behaves as if the components of the included signature were copied at the location of the include. The &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; argument must refer to a module type that is a signature, not a functor type.</source>
          <target state="translated">签名中的包括&lt;a href=&quot;#module-type&quot;&gt;模块类型&lt;/a&gt;的表达对由&lt;a href=&quot;#module-type&quot;&gt;模块类型&lt;/a&gt;表示的签名的组件进行文本包含。它的行为就像是将包含的签名的组件复制到包含位置中。该&lt;a href=&quot;#module-type&quot;&gt;模块类型&lt;/a&gt;参数必须指的是签名，而不是一个仿函数类型的模块类型。</target>
        </trans-unit>
        <trans-unit id="b2aa219207ffe702cd009fe575887afe0cfda1d7" translate="yes" xml:space="preserve">
          <source>The expression is not evaluated this time; notice that &amp;ldquo;lazy_two evaluation&amp;rdquo; is not printed. The result of the initial computation is simply returned.</source>
          <target state="translated">这次不对表达式求值；请注意，未打印&amp;ldquo; lazy_two评估&amp;rdquo;。仅返回初始计算的结果。</target>
        </trans-unit>
        <trans-unit id="3d11d633400d5e62d612a20b195ade3fd7ebb41b" translate="yes" xml:space="preserve">
          <source>The expression lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; returns a value v of type Lazy.t that encapsulates the computation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The argument &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at this point in the program. Instead, its evaluation will be performed the first time the function Lazy.force is applied to the value v, returning the actual value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Subsequent applications of Lazy.force to v do not evaluate &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; again. Applications of Lazy.force may be implicit through pattern matching (see &amp;zwj;&lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;).</source>
          <target state="translated">表达式lazy &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;返回一个Lazy.t类型的值v，该值封装了&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的计算。在程序中，此时不对参数&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;求值。相反，将在函数Lazy.force第一次应用于值v时返回其实际值&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;，进行评估。 Lazy.force在v上的后续应用不会再次评估&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;。 Lazy.force的应用可以是通过图案匹配隐式的（见&lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8bad5791aee2947a352057622227636c6db71ed9" translate="yes" xml:space="preserve">
          <source>The expression lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; returns a value v of type Lazy.t that encapsulates the computation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The argument &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at this point in the program. Instead, its evaluation will be performed the first time the function Lazy.force is applied to the value v, returning the actual value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Subsequent applications of Lazy.force to v do not evaluate &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; again. Applications of Lazy.force may be implicit through pattern matching (see &lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;).</source>
          <target state="translated">表达式lazy &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;返回一个Lazy.t类型的值v，该值封装了&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的计算。在程序中，此时不对参数&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;求值。相反，将在函数Lazy.force第一次应用于值v时返回其实际值&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;，进行评估。 Lazy.force在v上的后续应用不会再次评估&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;。 Lazy.force的应用程序可能会通过模式匹配而隐含（请参见&lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d836be1d196aa1c9fd598fef8e21c88679d68ac4" translate="yes" xml:space="preserve">
          <source>The expression letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; locally binds the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to the identifier &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; during the evaluation of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. It then returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. For example:</source>
          <target state="translated">表达letmodule&lt;a href=&quot;names#module-name&quot;&gt;模块名&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;模块EXPR&lt;/a&gt;在&lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;局部结合模块表达&lt;a href=&quot;modules#module-expr&quot;&gt;模块EXPR&lt;/a&gt;于所述标识符&lt;a href=&quot;names#module-name&quot;&gt;的模块名称&lt;/a&gt;的表达式的求值期间&lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;。然后，它返回&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的值。例如：</target>
        </trans-unit>
        <trans-unit id="f314e61bf1988c22719a609f5831e22bbdc7dc32" translate="yes" xml:space="preserve">
          <source>The expression object&lt;a href=&quot;#class-body&quot;&gt;class-body&lt;/a&gt;end denotes a class body. This is the prototype for an object : it lists the instance variables and methods of an object of this class.</source>
          <target state="translated">表达式对象&lt;a href=&quot;#class-body&quot;&gt;class-body&lt;/a&gt; end表示类主体。这是对象的原型：它列出了此类的对象的实例变量和方法。</target>
        </trans-unit>
        <trans-unit id="6d92cd34881d32ef8ac6eb5fb33636280b1183b9" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a signature does not specify any components. It simply affects the parsing of the following items of the signature, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the signature expression.</source>
          <target state="translated">签名中的表达式open &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;没有指定任何组件。它仅影响签名的以下各项的解析，从而允许以&lt;a href=&quot;names#module-path&quot;&gt;模块路径&lt;/a&gt;表示的模块组件用其简单名称name而不是路径访问&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; .name来引用。打开的范围在签名表达式的末尾停止。</target>
        </trans-unit>
        <trans-unit id="3374b1493b2b2832203e28fc7202ca2b6bc44cc6" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a structure does not define any components nor perform any bindings. It simply affects the parsing of the following items of the structure, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the structure expression.</source>
          <target state="translated">结构中的表达式open &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;不会定义任何组件，也不会执行任何绑定。它仅影响结构的以下各项的解析，允许以&lt;a href=&quot;names#module-path&quot;&gt;模块路径&lt;/a&gt;表示的模块组件用其简单名称name而不是路径访问&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; .name来引用。打开的范围在结构表达式的末尾停止。</target>
        </trans-unit>
        <trans-unit id="d045a7e48acb78229180ba1f49811e331b9b826a" translate="yes" xml:space="preserve">
          <source>The expression while&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;done repeatedly evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; while &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to true. The loop condition &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is evaluated and tested at the beginning of each iteration. The whole while &amp;hellip; done expression evaluates to the unit value ().</source>
          <target state="translated">表达而&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;做&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2个&lt;/sub&gt;反复做评估板&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;而&lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;计算为TRUE。在每次迭代的开始对循环条件&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;进行评估和测试。整个while ... done表达式的计算结果为单位值（）。</target>
        </trans-unit>
        <trans-unit id="e7999e39ad27377cd7dc800aeafcf6be489d1e7a" translate="yes" xml:space="preserve">
          <source>The expression {&amp;lt;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;&amp;gt;} evaluates to a copy of the current object in which the values of instance variables &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; have been replaced by the values of the corresponding expressions &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">表达式{&amp;lt; &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;；&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; &amp;gt;}计算为当前对象的副本，其中实例变量&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;的值已替换为相应对象的值表达式&lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="a02ea084f763d805328a3e7ce4d219962ddcb521" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } builds a fresh record with fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; equal to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and all other fields having the same value as in the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. In other terms, it returns a shallow copy of the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, except for the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, which are initialized to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. As previously, single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; and it is possible to add an optional type constraint on each field being updated with {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;}.</source>
          <target state="translated">表达式{ &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; with &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]； &amp;hellip;；&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]}将创建一个新记录，其中字段&lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;等于&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;，而所有其他字段的值与记录&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;中的值相同。换句话说，它返回记录&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的浅表副本，但字段&lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;n的&lt;/sub&gt;字段已初始化为&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;除外。&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;。如前所述，单个标识符&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;代表&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;，即合格的标识符&lt;a href=&quot;names#module-path&quot;&gt;模块路径&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;代表&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;，并且可以在每个要用{ &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; with &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ;更新的字段上添加可选的类型约束。&amp;hellip;；&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; }。</target>
        </trans-unit>
        <trans-unit id="81df39f38d8523b1217ede44454dadcb59a82246" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]} evaluates to the record value { field&lt;sub&gt;1&lt;/sub&gt; = v&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip;; field&lt;sub&gt;n&lt;/sub&gt; = v&lt;sub&gt;n&lt;/sub&gt; } where v&lt;sub&gt;i&lt;/sub&gt; is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, and a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;. The fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; must all belong to the same record type; each field of this record type must appear exactly once in the record expression, though they can appear in any order. The order in which &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified. Optional type constraints can be added after each field {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="translated">表达式{ &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]； &amp;hellip;；&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]}的计算结果为记录值{字段&lt;sub&gt;1&lt;/sub&gt; = v &lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;；字段&lt;sub&gt;n&lt;/sub&gt; = v &lt;sub&gt;n&lt;/sub&gt; }其中v &lt;sub&gt;i&lt;/sub&gt;是i = 1，&amp;hellip;，n的&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;的值。单个标识符&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;代表&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;，一个合格的标识符&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;代表&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;场地&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;。该场&lt;a href=&quot;names#field&quot;&gt;场&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;到&lt;a href=&quot;names#field&quot;&gt;外地&lt;/a&gt;&lt;sub&gt;ň&lt;/sub&gt;必须全部属于同一记录类型;尽管该记录类型的每个字段可以按任何顺序出现，但它们必须在记录表达式中仅出现一次。没有指定评估&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;到&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;的顺序。可以在每个字段之后添加可选的类型约束{ &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ;&amp;hellip;;&lt;a href=&quot;names#field&quot;&gt;域&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; }强制类型为&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;与&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;兼容。</target>
        </trans-unit>
        <trans-unit id="770439db3ff36f7c9028cd337c7098117fa187ed" translate="yes" xml:space="preserve">
          <source>The expressions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) and begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end have the same value as &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The two constructs are semantically equivalent, but it is good style to use begin &amp;hellip; end inside control structures:</source>
          <target state="translated">表达式（&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;）和begin &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; end具有与&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;相同的值。这两个构造在语义上是等效的，但是在控件结构中使用begin&amp;hellip;end是一种很好的样式：</target>
        </trans-unit>
        <trans-unit id="c9bf76fd4e9d4e7583a34999f67c07a62a02f933" translate="yes" xml:space="preserve">
          <source>The expressions Field(v, n), Byte(v, n) and Byte_u(v, n) are valid l-values. Hence, they can be assigned to, resulting in an in-place modification of value v. Assigning directly to Field(v, n) must be done with care to avoid confusing the garbage collector (see below).</source>
          <target state="translated">表达式Field(v,n)、Byte(v,n)和Byte_u(v,n)是有效的l值。因此,它们可以被赋值,导致值v的原地修改。直接赋值给Field(v,n)必须小心,以避免混淆垃圾收集器(见下文)。</target>
        </trans-unit>
        <trans-unit id="d39a1aaa7be45538447c135e96180858a54150e6" translate="yes" xml:space="preserve">
          <source>The expressions letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) are strictly equivalent. These constructions locally open the module referred to by the module path &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in the respective scope of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">letopen表达&lt;a href=&quot;names#module-path&quot;&gt;模块路径&lt;/a&gt;在&lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;和&lt;a href=&quot;names#module-path&quot;&gt;模块路径&lt;/a&gt;。（&lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;）是严格相等。这些构造在表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的相应范围内局部打开由模块路径&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;引用的模块。</target>
        </trans-unit>
        <trans-unit id="e1d5d2150f39dd154ec68fa36cfff5333db652cf" translate="yes" xml:space="preserve">
          <source>The external function f is not available</source>
          <target state="translated">外部函数f不可用</target>
        </trans-unit>
        <trans-unit id="e5f529de453636246288677488101d22e2108e01" translate="yes" xml:space="preserve">
          <source>The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, &lt;code&gt;%6d&lt;/code&gt; reads an integer, having at most 6 decimal digits; &lt;code&gt;%4f&lt;/code&gt; reads a float with at most 4 characters; and &lt;code&gt;%8[\000-\255]&lt;/code&gt; returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).</source>
          <target state="translated">字段宽度由可选的整数文字组成，指示要读取的令牌的最大宽度。例如， &lt;code&gt;%6d&lt;/code&gt; 读取一个整数，该整数最多具有6个十进制数字。 &lt;code&gt;%4f&lt;/code&gt; 读取一个浮点数，该浮点数最多包含4个字符；和 &lt;code&gt;%8[\000-\255]&lt;/code&gt; 返回后8个字符（如果输入中少于8个字符，则所有字符仍然可用）。</target>
        </trans-unit>
        <trans-unit id="ae52f5d3cbe515efd2a7aaa53a21566c409e073d" translate="yes" xml:space="preserve">
          <source>The file curses_stubs.c can be compiled with:</source>
          <target state="translated">文件curses_stubs.c可以用编译。</target>
        </trans-unit>
        <trans-unit id="725c49463cca5a3ec4ded63dc37357ba481599db" translate="yes" xml:space="preserve">
          <source>The file custom.cmo is created and can be used this way &amp;zwj;:</source>
          <target state="translated">创建文件custom.cmo并可以通过以下方式使用它：</target>
        </trans-unit>
        <trans-unit id="c9cf1595a49bfb32957e71e1d6050587722d1094" translate="yes" xml:space="preserve">
          <source>The file custom.cmo is created and can be used this way :</source>
          <target state="translated">创建文件custom.cmo,可以这样使用。</target>
        </trans-unit>
        <trans-unit id="139f2d48257c0343c4b071f4794d59ad6e533fc9" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute (e.g. the file given as first non-option argument to ocamlrun) either does not exist, or is not a valid executable bytecode file.</source>
          <target state="translated">ocamlrun试图执行的文件(例如作为ocamlrun第一个非选项参数的文件)要么不存在,要么不是一个有效的可执行字节码文件。</target>
        </trans-unit>
        <trans-unit id="9df79524971faf6930542e99bcb97fb7e6ed0d2f" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute is not a valid executable bytecode file. Probably it has been truncated or mangled since created. Erase and rebuild it.</source>
          <target state="translated">ocamlrun试图执行的文件不是一个有效的可执行字节码文件。可能它在创建后被截断或损坏了。擦除并重建它。</target>
        </trans-unit>
        <trans-unit id="1479d9789eb939b776377dc8d01919fe50c91085" translate="yes" xml:space="preserve">
          <source>The files that define the compilation units can be compiled separately using the ocamlc -c command (the -c option means &amp;ldquo;compile only, do not try to link&amp;rdquo;); this produces compiled interface files (with extension .cmi) and compiled object code files (with extension .cmo). When all units have been compiled, their .cmo files are linked together using the ocamlc command. For instance, the following commands compile and link a program composed of two compilation units Aux and Main:</source>
          <target state="translated">可以使用ocamlc -c命令分别编译定义编译单元的文件（-c选项表示&amp;ldquo;仅编译，不要尝试链接&amp;rdquo;）；这将生成已编译的接口文件（扩展名为.cmi）和已编译的目标代码文件（扩展名为.cmo）。编译完所有单元后，将使用ocamlc命令将它们的.cmo文件链接在一起。例如，以下命令编译并链接一个由两个编译单元Aux和Main组成的程序：</target>
        </trans-unit>
        <trans-unit id="218142a8cd84298a616575dd3b1a7d204717b40e" translate="yes" xml:space="preserve">
          <source>The files you can use to define custom generators are installed in the ocamldoc sub-directory of the OCaml standard library.</source>
          <target state="translated">你可以用来定义自定义生成器的文件安装在 OCaml 标准库的 ocamldoc 子目录下。</target>
        </trans-unit>
        <trans-unit id="59dbb07f3aaa12eeacf11b0514d46f8f8f33f5ee" translate="yes" xml:space="preserve">
          <source>The finalize field contains a pointer to a C function that is called when the block becomes unreachable and is about to be reclaimed. The block is passed as first argument to the function. The finalize field can also be custom_finalize_default to indicate that no finalization function is associated with the block.</source>
          <target state="translated">finalize字段包含了一个指向C函数的指针,该函数在块无法到达并即将被回收时被调用。该块被作为函数的第一个参数传递。finalize字段也可以是custom_finalize_default来表示没有与块相关联的最终化函数。</target>
        </trans-unit>
        <trans-unit id="db242e09b65549d74785bc5f6a999727dbb33d18" translate="yes" xml:space="preserve">
          <source>The first argument of Store_field and Store_double_field must be a variable declared by CAMLparam* or a parameter declared by CAMLlocal* to ensure that a garbage collection triggered by the evaluation of the other arguments will not invalidate the first argument after it is computed.</source>
          <target state="translated">Store_field和Store_double_field的第一个参数必须是CAMLparam*声明的变量或CAMLlocal*声明的参数,以保证由其他参数的评估触发的垃圾收集不会使第一个参数在计算后失效。</target>
        </trans-unit>
        <trans-unit id="483025a84206923192f7c9762bbef7fe0c59cbd8" translate="yes" xml:space="preserve">
          <source>The first case is an exact variant type: all possible tags are known, with their associated types, and they can all be present. Its structure is fully known.</source>
          <target state="translated">第一种情况是一个精确的变体类型:所有可能的标签都是已知的,还有它们的相关类型,而且它们都可以存在。其结构是完全已知的。</target>
        </trans-unit>
        <trans-unit id="26e2eb8f32164f7d7049d034e263952e663d7410" translate="yes" xml:space="preserve">
          <source>The first case is simple: g is passed ~y and then ~x, but f expects ~x and then ~y. This is correctly handled if we know the type of g to be x:int -&amp;gt; y:int -&amp;gt; int in advance, but otherwise this causes the above type clash. The simplest workaround is to apply formal parameters in a standard order.</source>
          <target state="translated">第一种情况很简单：将g传递给〜y，然后传递给〜x，但是f期望传递〜x，然后传递〜y。如果我们事先知道g的类型为x：int-&amp;gt; y：int-&amp;gt; int，则可以正确处理此问题，否则会导致上述类型冲突。最简单的解决方法是按标准顺序应用形式参数。</target>
        </trans-unit>
        <trans-unit id="7ddf571ff45a432684168e808086b6b09e060a7b" translate="yes" xml:space="preserve">
          <source>The first declaration is incorrect, because the string literal &lt;code&gt;&quot;hello&quot;&lt;/code&gt; could be shared by the compiler with other parts of the program, and mutating &lt;code&gt;incorrect&lt;/code&gt; is a bug. You must always use the second version, which performs a copy and is thus correct.</source>
          <target state="translated">第一个声明是不正确的，因为字符串文字 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 可能会被编译器与程序的其他部分共享，并且 &lt;code&gt;incorrect&lt;/code&gt; 更改是一个错误。您必须始终使用第二个版本，该版本将执行复制并因此是正确的。</target>
        </trans-unit>
        <trans-unit id="7a8e55f0808e48aad9f2858718bff1a1afbe6952" translate="yes" xml:space="preserve">
          <source>The first form of attributes is attached with a postfix notation on &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="translated">属性的第一种形式附有&amp;ldquo;代数&amp;rdquo;类别的后缀符号：</target>
        </trans-unit>
        <trans-unit id="c20d4143c725e414a8fe296ef743e273f408fd33" translate="yes" xml:space="preserve">
          <source>The first form of extension node is used for &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="translated">扩展节点的第一种形式用于&amp;ldquo;代数&amp;rdquo;类别：</target>
        </trans-unit>
        <trans-unit id="9e06920ecf0cdfc759a972552119b98dac760381" translate="yes" xml:space="preserve">
          <source>The first non-option argument is taken to be the name of the file containing the executable bytecode. (That file is searched in the executable path as well as in the current directory.) The remaining arguments are passed to the OCaml program, in the string array Sys.argv. Element 0 of this array is the name of the bytecode executable file; elements 1 to n are the remaining arguments arg&lt;sub&gt;1&lt;/sub&gt; to arg&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">第一个非选项参数被视为包含可执行字节码的文件的名称。 （在可执行文件路径和当前目录中搜索该文件。）剩余的参数以字符串数组Sys.argv的形式传递给OCaml程序。该数组的元素0是字节码可执行文件的名称；元素1到n是其余的参数arg &lt;sub&gt;1&lt;/sub&gt;到arg &lt;sub&gt;n&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="4b219d7a443ce004c101ae67774c3ff8d7838f69" translate="yes" xml:space="preserve">
          <source>The first two cases refer to a value identifier, either unqualified or qualified by the path to the structure that define it. * refers to the result just computed (typically, the value of a function application), and is valid only if the selected event is an &amp;ldquo;after&amp;rdquo; event (typically, a function application). $integer refer to a previously printed value. The remaining four forms select part of an expression: respectively, a record field, an array element, a string element, and the current contents of a reference.</source>
          <target state="translated">前两种情况是指值标识符，该标识符要么是未限定的，要么是通过定义它的结构的路径限定的。*表示刚计算出的结果（通常是函数应用程序的值），并且仅在所选事件是&amp;ldquo;后&amp;rdquo;事件（通常是函数应用程序）时才有效。$ integer是指先前打印的值。其余四种形式选择表达式的一部分：分别是记录字段，数组元素，字符串元素和引用的当前内容。</target>
        </trans-unit>
        <trans-unit id="2239d147af301ebf1848d9c3aed42b025297f0fd" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;float#VALclassify_float&quot;&gt;&lt;code&gt;Float.classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">由&lt;a href=&quot;float#VALclassify_float&quot;&gt; &lt;code&gt;Float.classify_float&lt;/code&gt; &lt;/a&gt;函数确定的五类浮点数。</target>
        </trans-unit>
        <trans-unit id="e5f4b14dbb83404562f202cb46321bbf598f23f0" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;stdlib#VALclassify_float&quot;&gt;&lt;code&gt;classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">由&lt;a href=&quot;stdlib#VALclassify_float&quot;&gt; &lt;code&gt;classify_float&lt;/code&gt; &lt;/a&gt;函数确定的五类浮点数。</target>
        </trans-unit>
        <trans-unit id="681b526c61bdcee2f004dd7b0da14d09277654dc" translate="yes" xml:space="preserve">
          <source>The flags -Oclassic, -O2 and -O3 are applied before all other flags, meaning that certain parameters may be overridden without having to specify every parameter usually invoked by the given optimisation level.</source>
          <target state="translated">标志-Oclassic、-O2和-O3应用在所有其他标志之前,这意味着某些参数可以被覆盖,而不必指定通常由给定优化级别调用的每个参数。</target>
        </trans-unit>
        <trans-unit id="41e4ad6689358b23fa1eb693a69c5cf4c073612a" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unix#VALrecv&quot;&gt;&lt;code&gt;Unix.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALrecvfrom&quot;&gt;&lt;code&gt;Unix.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALsend&quot;&gt;&lt;code&gt;Unix.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALsendto&quot;&gt;&lt;code&gt;Unix.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于标志&lt;a href=&quot;unix#VALrecv&quot;&gt; &lt;code&gt;Unix.recv&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;unix#VALrecvfrom&quot;&gt; &lt;code&gt;Unix.recvfrom&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;unix#VALsend&quot;&gt; &lt;code&gt;Unix.send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unix#VALsendto&quot;&gt; &lt;code&gt;Unix.sendto&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fd4283b647a522a0c9037980c206ad3a14cfba5" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unixlabels#VALrecv&quot;&gt;&lt;code&gt;UnixLabels.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALrecvfrom&quot;&gt;&lt;code&gt;UnixLabels.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALsend&quot;&gt;&lt;code&gt;UnixLabels.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALsendto&quot;&gt;&lt;code&gt;UnixLabels.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于标志&lt;a href=&quot;unixlabels#VALrecv&quot;&gt; &lt;code&gt;UnixLabels.recv&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;unixlabels#VALrecvfrom&quot;&gt; &lt;code&gt;UnixLabels.recvfrom&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;unixlabels#VALsend&quot;&gt; &lt;code&gt;UnixLabels.send&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;unixlabels#VALsendto&quot;&gt; &lt;code&gt;UnixLabels.sendto&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e26b9a410e534dd152b1e84e847e91afe66a6921" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unix#VALopenfile&quot;&gt;&lt;code&gt;Unix.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopenfile&quot;&gt; &lt;code&gt;Unix.openfile&lt;/code&gt; &lt;/a&gt;的标志。</target>
        </trans-unit>
        <trans-unit id="92926c8ba910a78b19eb9560e04391f617314f85" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unixlabels#VALopenfile&quot;&gt;&lt;code&gt;UnixLabels.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopenfile&quot;&gt; &lt;code&gt;UnixLabels.openfile&lt;/code&gt; &lt;/a&gt;的标志。</target>
        </trans-unit>
        <trans-unit id="da416c9b0c9ec887e3c9fed14c90d2a6cfe00274" translate="yes" xml:space="preserve">
          <source>The flags to the &lt;code&gt;Marshal.to_*&lt;/code&gt; functions below.</source>
          <target state="translated">以下是 &lt;code&gt;Marshal.to_*&lt;/code&gt; 的标志。</target>
        </trans-unit>
        <trans-unit id="e8910a8a70e1456ec6a90eb77007ffc0da7c2187" translate="yes" xml:space="preserve">
          <source>The floating point 0.</source>
          <target state="translated">浮点数0。</target>
        </trans-unit>
        <trans-unit id="4ab9429d7283ec75f0e02bc07dcd3134a72594e2" translate="yes" xml:space="preserve">
          <source>The floating-point -1.</source>
          <target state="translated">浮点数-1。</target>
        </trans-unit>
        <trans-unit id="2f12a48f02e6b8cb1bc97e090aa405bfffaff9d2" translate="yes" xml:space="preserve">
          <source>The floating-point 1.</source>
          <target state="translated">浮点数1。</target>
        </trans-unit>
        <trans-unit id="0cf650e7443d1e286b4973d2572d41f2dd1c5a71" translate="yes" xml:space="preserve">
          <source>The following bindings for the most common debugger commands are available in the *camldebug-progname* buffer:</source>
          <target state="translated">以下是*camldebug-progname*缓冲区中最常见的调试器命令的绑定。</target>
        </trans-unit>
        <trans-unit id="fa8fb8f6579c8a754f8160f2c545902f2c3649f3" translate="yes" xml:space="preserve">
          <source>The following built-in types and predefined exceptions are always defined in the compilation environment, but are not part of any module. As a consequence, they can only be referred by their short names.</source>
          <target state="translated">以下内置类型和预定义的异常总是在编译环境中定义的,但不是任何模块的一部分。因此,它们只能用它们的简称来表示。</target>
        </trans-unit>
        <trans-unit id="741949c165a3e82c7b1f8762527481edfe04447a" translate="yes" xml:space="preserve">
          <source>The following character sequences are also keywords:</source>
          <target state="translated">以下字符序列也是关键词。</target>
        </trans-unit>
        <trans-unit id="34ab75b655a01e99e773cf2e772887f93cd01533" translate="yes" xml:space="preserve">
          <source>The following characters are considered as blanks: space, horizontal tabulation, carriage return, line feed and form feed. Blanks are ignored, but they separate adjacent identifiers, literals and keywords that would otherwise be confused as one single identifier, literal or keyword.</source>
          <target state="translated">以下字符被视为空白:空格、水平制表、回车、换行和换页。空白被忽略,但它们将相邻的标识符、文字和关键字分开,否则会被混淆为一个单一的标识符、文字或关键字。</target>
        </trans-unit>
        <trans-unit id="bfd936c99ec75ec8467efb2fa73208d1cfd7da18" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlc. The options -pack, -a, -c and -output-obj are mutually exclusive.</source>
          <target state="translated">ocamlc可以识别以下命令行选项。选项-pack、-a、-c和-output-obj是相互排斥的。</target>
        </trans-unit>
        <trans-unit id="8fe55eff2fce3bd36f31017706fd97b0e53f6496" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamldep.</source>
          <target state="translated">ocamldep可以识别以下命令行选项。</target>
        </trans-unit>
        <trans-unit id="885f4ff9e5ff4ddb2e7d9854020f77ada3553ef5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamllex.</source>
          <target state="translated">ocamllex可以识别以下命令行选项。</target>
        </trans-unit>
        <trans-unit id="ba3896a823e9e144bf0d4b7e1f61010aad966b5f" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlmktop.</source>
          <target state="translated">ocamlmktop可以识别以下命令行选项。</target>
        </trans-unit>
        <trans-unit id="1edcf650050ceecdfe0b7ab459ca56279ebf0aae" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlopt. The options -pack, -a, -shared, -c and -output-obj are mutually exclusive.</source>
          <target state="translated">ocamlopt可以识别以下命令行选项。选项-pack、-a、-shared、-c和-output-obj是相互排斥的。</target>
        </trans-unit>
        <trans-unit id="f01e63f748272442f586e0dcde7deabec94a1be5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlrun.</source>
          <target state="translated">ocamlrun可以识别以下命令行选项。</target>
        </trans-unit>
        <trans-unit id="df87076d9fe00726ba61eaa8293d8eef997abd39" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by the ocaml command.</source>
          <target state="translated">ocaml命令可以识别以下命令行选项。</target>
        </trans-unit>
        <trans-unit id="d8652df34978643d1ab214e3a8b1d14afa637e47" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized:</source>
          <target state="translated">识别以下命令行选项。</target>
        </trans-unit>
        <trans-unit id="f87b7161534c08e8f8b2934a7a39ac4e75fe02aa" translate="yes" xml:space="preserve">
          <source>The following commands create the custom.cma file from files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i] &amp;zwj;:</source>
          <target state="translated">以下命令从文件&lt;sub&gt;1&lt;/sub&gt; .ml [i]，...，文件&lt;sub&gt;n&lt;/sub&gt; .ml [i] &amp;zwj;创建custom.cma文件：</target>
        </trans-unit>
        <trans-unit id="ea03de4698c2ebdfac27067880c0104b3ab3bd1f" translate="yes" xml:space="preserve">
          <source>The following commands create the custom.cma file from files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i] :</source>
          <target state="translated">以下命令从文件&lt;sub&gt;1&lt;/sub&gt; .ml [i]，...，文件&lt;sub&gt;n&lt;/sub&gt; .ml [i]创建custom.cma文件：</target>
        </trans-unit>
        <trans-unit id="2ef4512268a1e60220a903be3d8066db5cafc567" translate="yes" xml:space="preserve">
          <source>The following commands display information on checkpoints and events:</source>
          <target state="translated">以下命令将显示检查点和事件的信息。</target>
        </trans-unit>
        <trans-unit id="d56705239611e41383cc5a0fc4c62ec9ece9f729" translate="yes" xml:space="preserve">
          <source>The following commands execute the program forward or backward, starting at the current time. The execution will stop either when specified by the command or when a breakpoint is encountered.</source>
          <target state="translated">以下命令从当前时间开始向前或向后执行程序。当命令指定或遇到断点时,程序将停止执行。</target>
        </trans-unit>
        <trans-unit id="aa8b474e507be285882f655940a333fef3ed7e16" translate="yes" xml:space="preserve">
          <source>The following constants are treated like built-in constant constructors:</source>
          <target state="translated">以下常量被视为内置常量构造函数。</target>
        </trans-unit>
        <trans-unit id="f046204697990bb2d0f4cd47a0f626a4abb10376" translate="yes" xml:space="preserve">
          <source>The following directives control the toplevel behavior, load files in memory, and trace program execution.</source>
          <target state="translated">以下指令控制toplevel的行为,加载内存中的文件,并跟踪程序的执行。</target>
        </trans-unit>
        <trans-unit id="0e3f41e76fac899ccc6e7dc6bb71eadc7f7839bf" translate="yes" xml:space="preserve">
          <source>The following environment variables are also consulted:</source>
          <target state="translated">还会参考以下环境变量。</target>
        </trans-unit>
        <trans-unit id="86dc8be3269b92b9232bc979a84ec53ac86636df" translate="yes" xml:space="preserve">
          <source>The following example illustrates how statically-allocated C and Fortran arrays can be made available to OCaml.</source>
          <target state="translated">下面的例子说明了如何将静态分配的C和Fortran数组提供给OCaml。</target>
        </trans-unit>
        <trans-unit id="7b95c269aef6e820286357345f289155493b43dd" translate="yes" xml:space="preserve">
          <source>The following example illustrates the assignment of integers and block tags to constructors:</source>
          <target state="translated">下面的例子说明了整数和块标签对构造函数的分配。</target>
        </trans-unit>
        <trans-unit id="bb54e0eb9f74bd676ad11ff69ff7bddb5206be2e" translate="yes" xml:space="preserve">
          <source>The following example of file toto.ml shows where to place comments in a .ml file.</source>
          <target state="translated">下面的文件toto.ml的例子显示了在.ml文件中注释的位置。</target>
        </trans-unit>
        <trans-unit id="fb214a3cbe4113b36d77da33d2aad1393c44f7c9" translate="yes" xml:space="preserve">
          <source>The following example shows the passing of a two-dimensional Bigarray to a C function and a Fortran function.</source>
          <target state="translated">下面的例子显示了将一个二维Bigarray传递给一个C函数和一个Fortran函数。</target>
        </trans-unit>
        <trans-unit id="28d8c0cb68d2ae92275d2ecc53225fa520b47419" translate="yes" xml:space="preserve">
          <source>The following example uses a private type abbreviation to define a module of nonnegative integers:</source>
          <target state="translated">下面的例子使用私有类型缩写来定义一个非负整数模块。</target>
        </trans-unit>
        <trans-unit id="d3ae00605da64b105662093b0c38586124245f33" translate="yes" xml:space="preserve">
          <source>The following example, known as the subject/observer pattern, is often presented in the literature as a difficult inheritance problem with inter-connected classes. The general pattern amounts to the definition a pair of two classes that recursively interact with one another.</source>
          <target state="translated">下面的例子,被称为主体/观察者模式,在文献中经常作为一个难以解决的继承问题与相互连接的类一起出现。一般模式相当于定义了一对相互递归交互的两个类。</target>
        </trans-unit>
        <trans-unit id="fe79f151ba4780648aa79dae8b08c42dcb70ffa0" translate="yes" xml:space="preserve">
          <source>The following functions are exposed to help write compatible C stubs. To use them, you need to include both &amp;lt;caml/misc.h&amp;gt; and &amp;lt;caml/osdeps.h&amp;gt;.</source>
          <target state="translated">公开了以下功能以帮助编写兼容的C存根。要使用它们，您需要同时包含&amp;lt;caml / misc.h&amp;gt;和&amp;lt;caml / osdeps.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="832fc1be181c5700f255f7f5cd917c79991599e3" translate="yes" xml:space="preserve">
          <source>The following functions are slightly more efficient than caml_alloc, but also much more difficult to use.</source>
          <target state="translated">以下函数的效率比caml_alloc略高,但也比caml_alloc难用得多。</target>
        </trans-unit>
        <trans-unit id="e63d19b6970bf278c78ca3c011faa62ed74f62ae" translate="yes" xml:space="preserve">
          <source>The following functions can be called from the semantic actions of lexer definitions (the ML code enclosed in braces that computes the value returned by lexing functions). They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument &lt;code&gt;lexbuf&lt;/code&gt;, which, in the code generated by &lt;code&gt;ocamllex&lt;/code&gt;, is bound to the lexer buffer passed to the parsing function.</source>
          <target state="translated">可以从词法分析器定义的语义动作（括在括号中的ML代码计算词法化函数返回的值）中调用以下函数。它们允许访问与语义动作相关联的正则表达式匹配的字符串。必须将这些函数应用于参数 &lt;code&gt;lexbuf&lt;/code&gt; ，其在所产生的代码 &lt;code&gt;ocamllex&lt;/code&gt; ，势必传递给解析函数词法分析器缓冲器。</target>
        </trans-unit>
        <trans-unit id="45f2a5408f593c266bc5b945e256185ab7faa225" translate="yes" xml:space="preserve">
          <source>The following functions implement the POSIX standard terminal interface. They provide control over asynchronous communication ports and pseudo-terminals. Refer to the &lt;code&gt;termios&lt;/code&gt; man page for a complete description.</source>
          <target state="translated">以下功能实现POSIX标准终端接口。它们提供对异步通信端口和伪终端的控制。有关完整说明，请参见 &lt;code&gt;termios&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="04b159ad2babd8305b93430182e2074b26259f77" translate="yes" xml:space="preserve">
          <source>The following functions, defined in &amp;lt;caml/intext.h&amp;gt;, are provided to write and read back the contents of custom blocks in a portable way. Those functions handle endianness conversions when e.g. data is written on a little-endian machine and read back on a big-endian machine.</source>
          <target state="translated">提供了以下在&amp;lt;caml / intext.h&amp;gt;中定义的功能，以可移植的方式写入和读取自定义块的内容。当例如在小字节序的机器上写入数据并在大字节序的机器上读回数据时，这些函数处理字节序转换。</target>
        </trans-unit>
        <trans-unit id="d4d76bd017aaace084c2fe4ba75e854a770052fa" translate="yes" xml:space="preserve">
          <source>The following idiom separates description and definition.</source>
          <target state="translated">以下成语将描述和定义分开。</target>
        </trans-unit>
        <trans-unit id="abdd18dbed9ebbfffd9a3d53fecf519fa1b39456" translate="yes" xml:space="preserve">
          <source>The following invariant holds for any file name &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">以下不变量适用于任何文件名 &lt;code&gt;s&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da4c18672e8270bfb1a76f87b23a373991175930" translate="yes" xml:space="preserve">
          <source>The following language semantics apply specifically to constant float arrays. (By &amp;ldquo;constant float array&amp;rdquo; is meant an array consisting entirely of floating point numbers that are known at compile time. A common case is a literal such as [| 42.0; 43.0; |].</source>
          <target state="translated">以下语言语义专门适用于常量浮点数组。（&amp;ldquo;常量浮点数组&amp;rdquo;是指完全由编译时已知的浮点数组成的数组。常见的情况是文字，例如[| 42.0; 43.0; |]。</target>
        </trans-unit>
        <trans-unit id="2f8a143ee55050d3e9f8c912fc4c49000ef1b06a" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -dot option:</source>
          <target state="translated">以下选项与-dot选项一起适用。</target>
        </trans-unit>
        <trans-unit id="166817d7c28936e2b423cdda7a6aa67512725a8e" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -html option:</source>
          <target state="translated">以下选项与-html选项一起使用。</target>
        </trans-unit>
        <trans-unit id="4ecf6b7625e3e537050eaf9dc3a7fa22f048e25b" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -latex option:</source>
          <target state="translated">以下选项与-latex选项一起适用。</target>
        </trans-unit>
        <trans-unit id="cbc2ec126f36a5f0afa27f31d58d5bda45d9c06d" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -man option:</source>
          <target state="translated">以下选项与-man选项一起使用。</target>
        </trans-unit>
        <trans-unit id="051fe64a5d38a370f62ad07eadfb825faac6621f" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -texi option:</source>
          <target state="translated">以下选项与-texi选项一起使用。</target>
        </trans-unit>
        <trans-unit id="3d4dbac485d984712c71b7a64c65bc9a132b2436" translate="yes" xml:space="preserve">
          <source>The following options are recognized by ocamlprof:</source>
          <target state="translated">ocamlprof识别以下选项。</target>
        </trans-unit>
        <trans-unit id="6a846492c1f0c6319e8b3788beab792307a98121" translate="yes" xml:space="preserve">
          <source>The following options determine the format for the generated documentation.</source>
          <target state="translated">以下选项决定了生成文档的格式。</target>
        </trans-unit>
        <trans-unit id="8c2e53d36ec19399f7c32f9aac23861dbfe9cf9f" translate="yes" xml:space="preserve">
          <source>The following rules must be respected in order to avoid name clashes resulting in cross-reference errors:</source>
          <target state="translated">为了避免名称冲突导致交叉引用错误,必须遵守以下规则。</target>
        </trans-unit>
        <trans-unit id="097e045769a0dca8fade64c26d195db8b9414337" translate="yes" xml:space="preserve">
          <source>The following sample interface file foo.mli illustrates the placement rules for comments in .mli files.</source>
          <target state="translated">下面的界面示例文件foo.mli说明了.mli文件中注释的放置规则。</target>
        </trans-unit>
        <trans-unit id="ebfe702602d2495e52da52309ab1711b73354bb5" translate="yes" xml:space="preserve">
          <source>The following table gives the list of predefined @-tags, with their syntax and meaning.</source>
          <target state="translated">下表给出了预定义@标签的列表,以及它们的语法和含义。</target>
        </trans-unit>
        <trans-unit id="dd8a8320baafd30cfa4602768ee2151691b2708f" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence level of all operator classes from the highest to the lowest precedence. A few other syntactic constructions are also listed as references.</source>
          <target state="translated">下表列出了所有运算符类的优先级,从最高级到最低级。还列出了其他一些语法结构作为参考。</target>
        </trans-unit>
        <trans-unit id="9e256f5eaf5d8b81e4043192160908c1bd8faea3" translate="yes" xml:space="preserve">
          <source>The following table summarize what OCaml types can be unboxed, and what C types should be used in correspondence:</source>
          <target state="translated">下表总结了哪些OCaml类型可以开箱,对应的应该使用哪些C类型。</target>
        </trans-unit>
        <trans-unit id="ef06aa8040c0f03b521f5cef891b934434387cc7" translate="yes" xml:space="preserve">
          <source>The following terminology is used in this chapter of the manual.</source>
          <target state="translated">手册本章使用了以下术语:</target>
        </trans-unit>
        <trans-unit id="1699520402e7ac3828d5b8bcc342d6a427931baa" translate="yes" xml:space="preserve">
          <source>The following two functions are deprecated. Use module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">不推荐使用以下两个功能。请改用&lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="b87aaa89310b1024b8a1a7a3d739748757473aea" translate="yes" xml:space="preserve">
          <source>The form exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; generates a new exception, distinct from all other exceptions in the system. The form exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; gives an alternate name to an existing exception.</source>
          <target state="translated">形式异常&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;生成一个新的异常，该异常不同于系统中的所有其他异常。形式异常&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; = &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;为现有异常提供了备用名称。</target>
        </trans-unit>
        <trans-unit id="098fb8ce1b660c1d46d3db836e055890e6290a74" translate="yes" xml:space="preserve">
          <source>The form external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; is similar, except that it requires in addition the name to be implemented as the external function specified in &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; (see chapter &amp;zwj;&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;).</source>
          <target state="translated">形式的外部&lt;a href=&quot;names#value-name&quot;&gt;值名&lt;/a&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; =&lt;a href=&quot;intfc#external-declaration&quot;&gt;外部声明&lt;/a&gt;是类似的，不同之处在于它除了要求被实现为在指定的外部函数的名称&lt;a href=&quot;intfc#external-declaration&quot;&gt;外部声明&lt;/a&gt;（见章节&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b37d1605c59154ddd022186be0bfed3eb3e2b35d" translate="yes" xml:space="preserve">
          <source>The form external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; is similar, except that it requires in addition the name to be implemented as the external function specified in &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; (see chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;).</source>
          <target state="translated">外部&lt;a href=&quot;names#value-name&quot;&gt;值名称&lt;/a&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; = &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration的&lt;/a&gt;形式类似，不同之处在于它另外需要将名称实现为&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration中&lt;/a&gt;指定的外部函数（请参见第&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;章）。</target>
        </trans-unit>
        <trans-unit id="3184fd8520491af729727e8e58dedc4128114b17" translate="yes" xml:space="preserve">
          <source>The format of decimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; stands for a decimal digit.</source>
          <target state="translated">十进制浮点数的格式为 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; ，其中 &lt;code&gt;d&lt;/code&gt; 代表十进制数字。</target>
        </trans-unit>
        <trans-unit id="7828f8d5d5c611bdddc6c78b6ef04afbcd5d417e" translate="yes" xml:space="preserve">
          <source>The format of hexadecimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; stands for an hexadecimal digit and &lt;code&gt;d&lt;/code&gt; for a decimal digit.</source>
          <target state="translated">十六进制浮点数的格式为 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; ，其中 &lt;code&gt;h&lt;/code&gt; 代表十六进制数字， &lt;code&gt;d&lt;/code&gt; 代表十进制数字。</target>
        </trans-unit>
        <trans-unit id="812ca11444f87b91a5c1a4d58c74d93fafa141dc" translate="yes" xml:space="preserve">
          <source>The format of lexer definitions is as follows:</source>
          <target state="translated">词典定义的格式如下:</target>
        </trans-unit>
        <trans-unit id="127323cd14f10ff976ce82741602642432da7e75" translate="yes" xml:space="preserve">
          <source>The format string &lt;code&gt;fmt&lt;/code&gt; is a character string which contains three types of objects: plain characters and conversion specifications as specified in the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module, and pretty-printing indications specific to the &lt;code&gt;Format&lt;/code&gt; module.</source>
          <target state="translated">格式字符串 &lt;code&gt;fmt&lt;/code&gt; 是一个字符串，其中包含三种类型的对象：在&lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt;模块中指定的纯字符和转换规范，以及特定于 &lt;code&gt;Format&lt;/code&gt; 模块的漂亮打印指示。</target>
        </trans-unit>
        <trans-unit id="98fb30c95542494775f06815271fe47f1e740e5d" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains three types of objects:</source>
          <target state="translated">格式字符串是一个字符字符串,包含三种类型的对象。</target>
        </trans-unit>
        <trans-unit id="66553eccbf80219caa1c3c646bc08b8b25b163d4" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments.</source>
          <target state="translated">格式字符串是一个字符字符串,它包含两种类型的对象:明文字符和转换规范,明文字符只是被复制到输出通道,而转换规范则分别引起转换和打印参数。</target>
        </trans-unit>
        <trans-unit id="9fd14a172518628e19f32be0e91f3d86d102d1cd" translate="yes" xml:space="preserve">
          <source>The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a &lt;em&gt;formatted input channel&lt;/em&gt; (or &lt;em&gt; scanning buffer&lt;/em&gt;) and has type &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt;. The more general formatted input function reads from any scanning buffer and is named &lt;code&gt;bscanf&lt;/code&gt;.</source>
          <target state="translated">格式化的输入函数可以从任何类型的输入中读取，包括字符串，文件或可以返回字符的任何内容。更通用的字符来源被命名为&lt;em&gt;格式化输入通道&lt;/em&gt;（或&lt;em&gt;扫描缓冲区&lt;/em&gt;），类型为&lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt;。更为通用的格式化输入函数可以从任何扫描缓冲区读取数据，并将其命名为 &lt;code&gt;bscanf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e23bc34a1d5333a784d920ce0ee827fd82d18c4c" translate="yes" xml:space="preserve">
          <source>The former alternative is more convenient for the final users of the library, however.</source>
          <target state="translated">不过,对于图书馆的最终用户来说,前一种选择更方便。</target>
        </trans-unit>
        <trans-unit id="cf9a1462b05ebbf56fca1e287e7b7e2870abd6cd" translate="yes" xml:space="preserve">
          <source>The former operator will sometimes fail to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; even if type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;: in the current implementation it only expands two levels of type abbreviations containing objects and/or polymorphic variants, keeping only recursion when it is explicit in the class type (for objects). As an exception to the above algorithm, if both the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; are ground (&lt;em&gt;i.e.&lt;/em&gt; do not contain type variables), the former operator behaves as the latter one, taking the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. In case of failure with the former operator, the latter one should be used.</source>
          <target state="translated">前一个运算符有时将无法将表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;从类型&lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;强制为类型&lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;2，&lt;/sub&gt;即使类型&lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;是类型&lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;的子类型：在当前实现中，它仅扩展两个级别的类型缩写，其中包含对象和/或多态变体，仅当递归在类类型中（对于对象）时才保留递归。作为上述算法的一个例外，如果&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;和&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;的推断类型都为基（&lt;em&gt;即&lt;/em&gt;不包含类型变量），则前一个运算符的行为与后者相同，采用&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;的推断类型作为&lt;a href=&quot;types#typexpr&quot;&gt;典型&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。如果前者失败，则应使用后者。</target>
        </trans-unit>
        <trans-unit id="e62ce70c70537475c1b181d579e82b479775978d" translate="yes" xml:space="preserve">
          <source>The fprintf function is like printf except that it takes an output channel as the first argument. The %a specifier can be useful to define custom printer (for custom types). For instance, we can create a printing template that converts an integer argument to signed decimal:</source>
          <target state="translated">fprintf函数和printf函数一样,只是它以一个输出通道作为第一个参数。%a指定符可以用来定义自定义打印机(对于自定义类型)。例如,我们可以创建一个打印模板,将一个整数参数转换为有符号的十进制。</target>
        </trans-unit>
        <trans-unit id="d13a291c5fa3db94f06d27016206ff693957ed08" translate="yes" xml:space="preserve">
          <source>The front-end is a part of compiler-libs library. Programs that use the compiler-libs library should be built as follows:</source>
          <target state="translated">前端是编译器-libs库的一部分。使用编译器-libs库的程序应按以下方式构建。</target>
        </trans-unit>
        <trans-unit id="0136f8eadbf8d006e647f8e6e794a54dea870bab" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;scanf#VALunescaped&quot;&gt;&lt;code&gt;Scanf.unescaped&lt;/code&gt;&lt;/a&gt; is a left inverse of &lt;code&gt;escaped&lt;/code&gt;, i.e. &lt;code&gt;Scanf.unescaped&amp;nbsp;(escaped&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt; for any string &lt;code&gt;s&lt;/code&gt; (unless &lt;code&gt;escaped&amp;nbsp;s&lt;/code&gt; fails).</source>
          <target state="translated">功能&lt;a href=&quot;scanf#VALunescaped&quot;&gt; &lt;code&gt;Scanf.unescaped&lt;/code&gt; &lt;/a&gt;是的左逆 &lt;code&gt;escaped&lt;/code&gt; ，即 &lt;code&gt;Scanf.unescaped&amp;nbsp;(escaped&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt; 对任意字符串 &lt;code&gt;s&lt;/code&gt; （除非 &lt;code&gt;escaped&amp;nbsp;s&lt;/code&gt; 失败）。</target>
        </trans-unit>
        <trans-unit id="4658f7d95c6ccb485b665c4a8fd77d14df445b99" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;caml_process_pending_actions&lt;/code&gt; from &amp;lt;caml/signals.h&amp;gt; executes any pending signal handlers and finalisers, Memprof callbacks, and requested minor and major garbage collections. In particular, it can raise asynchronous exceptions. It is recommended to call it regularly at safe points inside long-running non-blocking C code.</source>
          <target state="translated">&amp;lt;caml / &lt;code&gt;caml_process_pending_actions&lt;/code&gt; &amp;gt;中的caml_process_pending_actions函数执行所有挂起的信号处理程序和终结器，Memprof回调以及请求的次要和主要垃圾回收。特别是，它可以引发异步异常。建议在长时间运行的非阻塞C代码中的安全点定期调用它。</target>
        </trans-unit>
        <trans-unit id="0830c833940b33a13600b2fc8f3c6ec9ed72ba39" translate="yes" xml:space="preserve">
          <source>The function's output is specified by the following invariants:</source>
          <target state="translated">该函数的输出由以下不变量指定。</target>
        </trans-unit>
        <trans-unit id="2cc5f117527b2b6ccf3cd9af7823b5af5628418b" translate="yes" xml:space="preserve">
          <source>The function's result is specified by the following invariants:</source>
          <target state="translated">函数的结果由以下不变量指定。</target>
        </trans-unit>
        <trans-unit id="3e123b1399cb46194a1cbce9625fdeb27b778403" translate="yes" xml:space="preserve">
          <source>The functions below are leftovers from an earlier, VM-based threading system. The &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module provides equivalent functionality, in a more general and more standard-conformant manner. It is recommended to use &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; functions directly.</source>
          <target state="translated">以下功能是早期基于VM的线程系统的剩余功能。在&lt;a href=&quot;unix&quot;&gt; &lt;code&gt;Unix&lt;/code&gt; 的&lt;/a&gt;模块提供等效的功能，在更一般的和更符合标准的方式。建议直接使用&lt;a href=&quot;unix&quot;&gt; &lt;code&gt;Unix&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="b16f05a4538c91ac60ba6969c4d9b5e686f1d91a" translate="yes" xml:space="preserve">
          <source>The functions from module &lt;a href=&quot;random.state&quot;&gt;&lt;code&gt;Random.State&lt;/code&gt;&lt;/a&gt; manipulate the current state of the random generator explicitly. This allows using one or several deterministic PRNGs, even in a multi-threaded program, without interference from other parts of the program.</source>
          <target state="translated">来自模块&lt;a href=&quot;random.state&quot;&gt; &lt;code&gt;Random.State&lt;/code&gt; &lt;/a&gt;的函数显式地操纵随机生成器的当前状态。这样，即使在多线程程序中，也可以使用一个或多个确定性PRNG，而不会受到程序其他部分的干扰。</target>
        </trans-unit>
        <trans-unit id="cbce52b776ac08f2366078197c98e1659ba43ad5" translate="yes" xml:space="preserve">
          <source>The functions in this module are thread safe.</source>
          <target state="translated">本模块中的功能是线程安全的。</target>
        </trans-unit>
        <trans-unit id="511113955645abe47f0e74cfd8701cd531b7acf8" translate="yes" xml:space="preserve">
          <source>The functions in this section append binary encodings of integers to buffers.</source>
          <target state="translated">本节的函数将整数的二进制编码附加到缓冲区。</target>
        </trans-unit>
        <trans-unit id="735840deef678499261950948d63f843f78e8b4b" translate="yes" xml:space="preserve">
          <source>The functions in this section binary encode and decode integers to and from byte sequences.</source>
          <target state="translated">本节中的函数对整数进行二进制编码和解码,并对字节序列进行解码。</target>
        </trans-unit>
        <trans-unit id="692df968d9b76de8295f62a1cc39eca74e7c54e9" translate="yes" xml:space="preserve">
          <source>The functor Client may also be redefined when some new features of the account can be given to the client.</source>
          <target state="translated">当账户的一些新功能可以被赋予客户端时,也可以重新定义漏斗Client。</target>
        </trans-unit>
        <trans-unit id="23eb5fdacb362f1e019b7a5da5dbe8a3fbb9da5e" translate="yes" xml:space="preserve">
          <source>The functorial interface allows the use of specific comparison and hash functions, either for performance/security concerns, or because keys are not hashable/comparable with the polymorphic builtins.</source>
          <target state="translated">漏斗接口允许使用特定的比较和散列函数,无论是出于性能/安全考虑,还是因为键不能与多态内建进行散列/比较。</target>
        </trans-unit>
        <trans-unit id="9842cecf834f807f4e52659d4bb05e758d2b67ff" translate="yes" xml:space="preserve">
          <source>The general formatted input function</source>
          <target state="translated">一般格式化输入功能</target>
        </trans-unit>
        <trans-unit id="39ea5439ffc8a37ae7dfd624fd6123810662e231" translate="yes" xml:space="preserve">
          <source>The generated module defines one parsing function per entry point in the grammar. These functions have the same names as the entry points. Parsing functions take as arguments a lexical analyzer (a function from lexer buffers to tokens) and a lexer buffer, and return the semantic attribute of the corresponding entry point. Lexical analyzer functions are usually generated from a lexer specification by the ocamllex program. Lexer buffers are an abstract data type implemented in the standard library module Lexing. Tokens are values from the concrete type token, defined in the interface file grammar.mli produced by ocamlyacc.</source>
          <target state="translated">生成的模块为语法中的每个入口点定义了一个解析函数。这些函数的名称与入口点相同。解析函数将一个词法分析器(从词法缓冲区到标记的函数)和一个词法缓冲区作为参数,并返回相应入口点的语义属性。词法分析器函数通常由ocamllex程序从词法规范中生成。词符缓冲区是标准库模块Lexing中实现的一种抽象数据类型。令牌是来自具体类型令牌的值,由ocamlyacc产生的接口文件grammar.mli中定义。</target>
        </trans-unit>
        <trans-unit id="a2263e6287694d2f2d32e4219ff36b6fad805902" translate="yes" xml:space="preserve">
          <source>The generated trace files are stored using the &lt;em&gt;Common Trace Format&lt;/em&gt;, which is a general purpose binary tracing format. A complete trace consists of:</source>
          <target state="translated">生成的跟踪文件使用&amp;ldquo;&lt;em&gt;通用跟踪格式&amp;rdquo;&lt;/em&gt;（通用跟踪格式）存储。完整的跟踪包括：</target>
        </trans-unit>
        <trans-unit id="05828d489f6ac2387f6a65167157fb9f23021c22" translate="yes" xml:space="preserve">
          <source>The greatest representable 32-bit integer, 2&lt;sup&gt;31&lt;/sup&gt; - 1.</source>
          <target state="translated">可表示的最大32位整数2 &lt;sup&gt;31-1&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="a404ad0913817fcb80ea923a9800ed75493e4170" translate="yes" xml:space="preserve">
          <source>The greatest representable 64-bit integer, 2&lt;sup&gt;63&lt;/sup&gt; - 1.</source>
          <target state="translated">可表示的最大64位整数2 &lt;sup&gt;63-1&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="4f471d57c7b55d66ee6fb3224ba15693e2e1e916" translate="yes" xml:space="preserve">
          <source>The greatest representable integer.</source>
          <target state="translated">最大的可代表整数。</target>
        </trans-unit>
        <trans-unit id="83953d60191eeb31cc3f9a4dc8dba81bf1560d9f" translate="yes" xml:space="preserve">
          <source>The greatest representable native integer, either 2&lt;sup&gt;31&lt;/sup&gt; - 1 on a 32-bit platform, or 2&lt;sup&gt;63&lt;/sup&gt; - 1 on a 64-bit platform.</source>
          <target state="translated">的最大可表示天然整数，无论是2 &lt;sup&gt;31&lt;/sup&gt; - 1 32位的平台上，或2 &lt;sup&gt;63&lt;/sup&gt; - 1 64位的平台上。</target>
        </trans-unit>
        <trans-unit id="e04fd04f5b90806f4bde8e56f9e1f7c424d03265" translate="yes" xml:space="preserve">
          <source>The hash field can be set to custom_hash_default, in which case the custom block is ignored during hash computation.</source>
          <target state="translated">哈希字段可以设置为custom_hash_default,在这种情况下,自定义块在哈希计算过程中会被忽略。</target>
        </trans-unit>
        <trans-unit id="d1bdc212a7c36c7cbf75250ae2e9cd081ccee7eb" translate="yes" xml:space="preserve">
          <source>The hash field contains a pointer to a C function that is called whenever OCaml&amp;rsquo;s generic hash operator (see module &lt;a href=&quot;libref/hashtbl&quot;&gt;Hashtbl&lt;/a&gt;) is applied to a custom block. The C function can return an arbitrary integer representing the hash value of the data contained in the given custom block. The hash value must be compatible with the compare function, in the sense that two structurally equal data (that is, two custom blocks for which compare returns 0) must have the same hash value.</source>
          <target state="translated">哈希字段包含一个指向C函数的指针，每当OCaml的通用哈希运算符（请参见模块&lt;a href=&quot;libref/hashtbl&quot;&gt;Hashtbl&lt;/a&gt;）应用于自定义块时，该函数就会被调用。C函数可以返回一个任意整数，该整数表示给定定制块中包含的数据的哈希值。在两个结构上相等的数据（即，两个比较块返回0的自定义块）必须具有相同的哈希值的意义上，哈希值必须与compare函数兼容。</target>
        </trans-unit>
        <trans-unit id="3784686c2bcba80c99df973ccfa187b6dc78d6d0" translate="yes" xml:space="preserve">
          <source>The hash function for floating-point numbers.</source>
          <target state="translated">浮点数的哈希函数。</target>
        </trans-unit>
        <trans-unit id="afd0450a8b37538d5ad7af752cb7dc24545ce1f7" translate="yes" xml:space="preserve">
          <source>The header and the trailer sections are OCaml code that is copied as is into file grammar.ml. Both sections are optional. The header goes at the beginning of the output file; it usually contains open directives and auxiliary functions required by the semantic actions of the rules. The trailer goes at the end of the output file.</source>
          <target state="translated">头部和预告片部分是 OCaml 代码,原样复制到文件 grammar.ml 中。这两个部分都是可选的。头部位于输出文件的开头;它通常包含规则的语义操作所需的开放指令和辅助函数。预告片放在输出文件的最后。</target>
        </trans-unit>
        <trans-unit id="7a49035078d6028cf4719edc4791d70f6385a46e" translate="yes" xml:space="preserve">
          <source>The header and trailer sections are arbitrary OCaml text enclosed in curly braces. Either or both can be omitted. If present, the header text is copied as is at the beginning of the output file and the trailer text at the end. Typically, the header section contains the open directives required by the actions, and possibly some auxiliary functions used in the actions.</source>
          <target state="translated">标题和预告片部分是用大括号括起来的任意OCaml文本。可以省略其中一个或两个。如果存在的话,头文字会被原样复制在输出文件的开头,而拖车文字则会被复制在最后。通常情况下,头部分包含了动作所需的打开指令,可能还有动作中使用的一些辅助函数。</target>
        </trans-unit>
        <trans-unit id="65fb09bbdabd2dfcd32a5c38a54fcbcdf3587281" translate="yes" xml:space="preserve">
          <source>The identifiers below are reserved as keywords, and cannot be employed otherwise:</source>
          <target state="translated">下面的标识符是作为关键词保留的,不能采用其他方式。</target>
        </trans-unit>
        <trans-unit id="a3cdbac9abe023e77c0d5c1367f0671359c68a73" translate="yes" xml:space="preserve">
          <source>The implementation allows efficient sharing of large numerical arrays between OCaml code and C or Fortran numerical libraries.</source>
          <target state="translated">该实现允许在OCaml代码和C或Fortran数值库之间高效共享大型数值数组。</target>
        </trans-unit>
        <trans-unit id="43b6a822ebb15a95c06ae979273df36acec6ea3c" translate="yes" xml:space="preserve">
          <source>The implementation is checked against the interface file x.mli (if it exists) as described in the manual for ocamlc (chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">的实现是靠在接口文件x.mli检查（如果它存在），作为ocamlc（章节的手册中所描述&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="37db43ed15e53d861a8a0109f7b167f500eef59c" translate="yes" xml:space="preserve">
          <source>The implementation is checked against the interface file x.mli (if it exists) as described in the manual for ocamlc (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">按照接口文件x.mli（如果存在）检查实现，如ocamlc手册中所述（第&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;章）。</target>
        </trans-unit>
        <trans-unit id="f0e6ef3c775c3e80317b4caf9ce4c73cd303a6bf" translate="yes" xml:space="preserve">
          <source>The include file &amp;lt;caml/bigarray.h&amp;gt; must be included in the C stub file. It declares the functions, constants and macros discussed below.</source>
          <target state="translated">包含文件&amp;lt;caml / bigarray.h&amp;gt;必须包含在C存根文件中。它声明了下面讨论的函数，常量和宏。</target>
        </trans-unit>
        <trans-unit id="535f73d31ed740bfcbb9fa46992a794cf0b8e833" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">&lt;a href=&quot;unix#VALstat&quot;&gt; &lt;code&gt;Unix.stat&lt;/code&gt; &lt;/a&gt;调用返回的信息。</target>
        </trans-unit>
        <trans-unit id="0dab77f7c802e91039a17f7a96119c9dc7d99b16" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALstat&quot;&gt; &lt;code&gt;UnixLabels.stat&lt;/code&gt; &lt;/a&gt;调用返回的信息。</target>
        </trans-unit>
        <trans-unit id="432250b262611d097e3c2e7a360d5606d16533ba" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; provides for inclusion of methods and instance variables from other class types. The instance variable and method types from &lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; are added into the current class type.</source>
          <target state="translated">继承构造继承&lt;a href=&quot;#class-body-type&quot;&gt;类主体类型&lt;/a&gt;提供了其他类类型的方法和实例变量的包含。来自&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;的实例变量和方法类型被添加到当前的类类型中。</target>
        </trans-unit>
        <trans-unit id="0a6f2342a82527fef9c1f1e57a822b49fe405407" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; allows reusing methods and instance variables from other classes. The class expression &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; must evaluate to a class body. The instance variables, methods and initializers from this class body are added into the current class. The addition of a method will override any previously defined method of the same name.</source>
          <target state="translated">继承构造继承&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;允许重用其他类的方法和实例变量。类表达式&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;必须计算为类主体。来自该类主体的实例变量，方法和初始化器将添加到当前类中。方法的添加将覆盖任何先前定义的相同名称的方法。</target>
        </trans-unit>
        <trans-unit id="e6a4c6ce7609b4fdb581947deed89b2c406dd7c0" translate="yes" xml:space="preserve">
          <source>The initial benefit value is then scaled by a factor that attempts to compensate for the fact that the current point in the code, if under some number of conditional branches, may be cold. (Flambda does not currently compute hot and cold paths.) The factor&amp;mdash;the estimated probability that the inliner really is on a &lt;em&gt;hot&lt;/em&gt; path&amp;mdash;is calculated as 1/(1 + f)&lt;sup&gt;d&lt;/sup&gt;, where f is set by -inline-branch-factor and d is the nesting depth of branches at the current point. As the inliner descends into more deeply-nested branches, the benefit of inlining thus lessens.</source>
          <target state="translated">然后，将初始收益值缩放一个因子，该因子试图补偿以下事实：如果在一定数量的条件分支下，代码中的当前点可能很冷。 （弗拉姆达（Flambda）当前不计算冷热路径。）该因子（内衬确实在&lt;em&gt;热&lt;/em&gt;路径上的估计概率）计算为1 /（1 + f）&lt;sup&gt;d&lt;/sup&gt;，其中f由-inline-branch-系数d是当前点处的嵌套深度。当内衬下降到更深的嵌套分支时，内联的好处因此会减少。</target>
        </trans-unit>
        <trans-unit id="605d70d1e078307745dd48e9410e6df59a2d38ed" translate="yes" xml:space="preserve">
          <source>The initial size of the major heap (in words).</source>
          <target state="translated">主要堆的初始大小(单位:字)。</target>
        </trans-unit>
        <trans-unit id="d19155151a59efc551f6b49f7c9952f00e4278ab" translate="yes" xml:space="preserve">
          <source>The inliner is directed using attributes. For non-recursive functions (and one-step unrolling of recursive functions, although @unroll is more clear for this purpose) the following are supported:</source>
          <target state="translated">inliner是使用属性定向的。对于非递归函数(以及递归函数的单步展开,虽然@unroll的目的更明确),支持以下内容。</target>
        </trans-unit>
        <trans-unit id="ec62c15f868750119abec49b24817b3f70272bf1" translate="yes" xml:space="preserve">
          <source>The inliner may discover a call site to a recursive function where something is known about the arguments: for example, they may be equal to some other variables currently in scope. In this situation it may be beneficial to &lt;em&gt;specialise&lt;/em&gt; the function to those arguments. This is done by copying the declaration of the function (and any others involved in any same mutually-recursive declaration) and noting the extra information about the arguments. The arguments augmented by this information are known as &lt;em&gt;specialised arguments&lt;/em&gt;. In order to try to ensure that specialisation is not performed uselessly, arguments are only specialised if it can be shown that they are &lt;em&gt;invariant&lt;/em&gt;: in other words, during the execution of the recursive function(s) themselves, the arguments never change.</source>
          <target state="translated">内联函数可能会发现递归函数的调用站点，在该函数中，有关参数的信息已为您所知：例如，它们可能等于当前作用域中的其他一些变量。在这种情况下，将功能&lt;em&gt;专门&lt;/em&gt;用于那些参数可能会有所帮助。这是通过复制函数的声明（以及任何其他相互递归声明中涉及的其他声明）并注意有关参数的额外信息来完成的。通过此信息补充的论点称为&lt;em&gt;专用论点&lt;/em&gt;。为了尝试确保不会无用地执行专门化，只有在可以证明参数&lt;em&gt;不变的情况下，才对&lt;/em&gt;它们进行专门化&lt;em&gt;&lt;/em&gt;：换句话说，在执行递归函数本身的过程中，参数永远不会改变。</target>
        </trans-unit>
        <trans-unit id="0c51b8b56bbf10eb40d95b1f8d06cf0bb2a8da17" translate="yes" xml:space="preserve">
          <source>The inliner will be able to consider inlining a call to a function in a first class module if it knows which particular function is going to be called. The presence of the first-class module record that wraps the set of functions in the module does not per se inhibit inlining.</source>
          <target state="translated">如果内联器知道要调用哪个特定的函数,它就可以考虑内联一个一级模块中的函数。包裹模块中函数集的一级模块记录的存在本身并不妨碍内联。</target>
        </trans-unit>
        <trans-unit id="f97af2287565035553d926928c75a2ecba69b6f2" translate="yes" xml:space="preserve">
          <source>The inlining depth starts at zero and is increased by one every time the inliner descends into another function. It is then decreased by one every time the inliner leaves such function. If the depth exceeds the value set by -inline-max-depth then speculation stops. This parameter is intended as a general backstop for situations where the inlining threshold does not control the search sufficiently.</source>
          <target state="translated">内嵌深度从零开始,每当内嵌程序进入另一个函数时,内嵌深度增加一。然后,每当内联程序离开这个函数时,内联深度就会减少1。如果深度超过-inline-max-depth设置的值,那么投机就会停止。这个参数的目的是为了在内联阈值不能充分控制搜索的情况下作为一般的后备措施。</target>
        </trans-unit>
        <trans-unit id="1fef85946e0fcf5a71d076de458a459e1642b8d5" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hashtbl.make&quot;&gt; &lt;code&gt;Hashtbl.Make&lt;/code&gt; &lt;/a&gt;函数Hashtbl.Make的输入签名。</target>
        </trans-unit>
        <trans-unit id="06d18381a5748615e440710ac855b1a56b9c2889" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hashtbl.makeseeded&quot;&gt; &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt;函数Hashtbl.MakeSeeded的输入签名。</target>
        </trans-unit>
        <trans-unit id="da597a43f328dc2efe7fbdb2804af861660747d2" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;morelabels.hashtbl.make&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;morelabels.hashtbl.make&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.Make&lt;/code&gt; &lt;/a&gt;的输入签名。</target>
        </trans-unit>
        <trans-unit id="370d3ad23a4b2f90badc6bea26dfa703f32c6590" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;morelabels.hashtbl.makeseeded&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;morelabels.hashtbl.makeseeded&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt;的输入签名。</target>
        </trans-unit>
        <trans-unit id="95c572128ac8d5e1df8128cf0a673f5f91f32169" translate="yes" xml:space="preserve">
          <source>The inside of documentation comments (**&amp;hellip;*) consists of free-form text with optional formatting annotations, followed by optional &lt;em&gt;tags&lt;/em&gt; giving more specific information about parameters, version, authors, &amp;hellip; The tags are distinguished by a leading @ character. Thus, a documentation comment has the following shape:</source>
          <target state="translated">文档注释（** ... *）的内部包含带有可选格式注释的自由格式文本，其后是可选&lt;em&gt;标签&lt;/em&gt;，这些&lt;em&gt;标签&lt;/em&gt;提供了有关参数，版本，作者等的更多特定信息。这些标签以@开头。因此，文档注释具有以下形状：</target>
        </trans-unit>
        <trans-unit id="148efbe2c3192ef6b3c2f5ce513345372f5ff8d7" translate="yes" xml:space="preserve">
          <source>The instance variables of a class are visible only in the body of the methods defined in the same class or a class that inherits from the class defining the instance variables. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; evaluates to the value of the given instance variable. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; assigns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to the instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;, which must be mutable. The whole expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to ().</source>
          <target state="translated">一个类的实例变量仅在同一类或从定义该实例变量的类继承的类的方法的主体中可见。表达式&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;的值等于给定实例变量的值。表达&lt;a href=&quot;names#inst-var-name&quot;&gt;INST-VAR-名&lt;/a&gt;&amp;lt; - &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;受让人的值&lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;实例变量&lt;a href=&quot;names#inst-var-name&quot;&gt;INST-VAR-名称&lt;/a&gt;，它必须是可变的。整个表达式&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr的&lt;/a&gt;计算结果为（）。</target>
        </trans-unit>
        <trans-unit id="1983ba3b3cbd666c6b286b10b7424eaa8d46d8e4" translate="yes" xml:space="preserve">
          <source>The instrumentation that afl-fuzz requires is not generated by default, and must be explicitly enabled, by passing the -afl-instrument option to ocamlopt.</source>
          <target state="translated">afl-fuzz 所需的仪器默认不生成,必须通过向 ocamlopt 传递 -afl-instrument 选项来明确启用。</target>
        </trans-unit>
        <trans-unit id="9c38a45a391c534fde7023ac64ba050bd0bfc352" translate="yes" xml:space="preserve">
          <source>The instrumented runtime aims to provide insight into the runtime&amp;rsquo;s execution while maintaining a low overhead. However, this overhead may become more noticeable depending on how a program executes. The instrumented runtime currently puts a strong emphasis on tracing &lt;em&gt;garbage collection&lt;/em&gt; events. This means that programs with heavy garbage collection activity may be more susceptible to tracing induced performance penalties.</source>
          <target state="translated">仪器化的运行时旨在提供对运行时执行的洞察力，同时保持较低的开销。但是，根据程序的执行方式，此开销可能会变得更加明显。目前，已检测的运行时非常重视跟踪&lt;em&gt;垃圾回收&lt;/em&gt;事件。这意味着具有大量垃圾回收活动的程序可能更容易跟踪引起的性能损失。</target>
        </trans-unit>
        <trans-unit id="c752c8999051d42387c90e33a51fa248e92151ee" translate="yes" xml:space="preserve">
          <source>The instrumented runtime can also be used with the OCaml bytecode interpreter. This can be done by either using the -runtime-variant=i flag when linking the program with ocamlc, or by running the generated bytecode through ocamlruni:</source>
          <target state="translated">工具化的运行时也可以和 OCaml 字节码解释器一起使用,可以通过使用 -runtime-variant=i 标志来实现。当程序与 ocamlc 链接时,可以使用 -runtime-variant=i 标志,或者通过 ocamlruni 运行生成的字节码。</target>
        </trans-unit>
        <trans-unit id="bdd8c2054ca56fa61b478da767e7a87b2d4b4462" translate="yes" xml:space="preserve">
          <source>The instrumented runtime does not support the fork system call. A child process forked from an instrumented program will not be traced.</source>
          <target state="translated">工具化的运行时不支持fork系统调用。从工具化程序中分叉出来的子进程将不会被跟踪。</target>
        </trans-unit>
        <trans-unit id="83cc8fe30284169270dc9bfd2599a1edfd3403c6" translate="yes" xml:space="preserve">
          <source>The integer in a &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt; can also be specified as &lt;code&gt;*&lt;/code&gt;, in which case an extra integer argument is taken to specify the corresponding &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt;. This integer argument precedes immediately the argument to print. For instance, &lt;code&gt;%.*f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with as many fractional digits as the value of the argument given before the float.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 或 &lt;code&gt;precision&lt;/code&gt; 的整数也可以指定为 &lt;code&gt;*&lt;/code&gt; ，在这种情况下，将使用额外的整数参数来指定相应的 &lt;code&gt;width&lt;/code&gt; 或 &lt;code&gt;precision&lt;/code&gt; 。该整数参数紧随要打印的参数之前。例如， &lt;code&gt;%.*f&lt;/code&gt; 打印一个 &lt;code&gt;float&lt;/code&gt; ，该浮点数与浮点数之前给出的参数值一样多。</target>
        </trans-unit>
        <trans-unit id="0b15dd3f5ba2129587d0969abe183388bad06fc4" translate="yes" xml:space="preserve">
          <source>The interface of a class can also be specified in a module signature, and used to restrict the inferred signature of a module.</source>
          <target state="translated">类的接口也可以在模块签名中指定,并用于限制模块的推断签名。</target>
        </trans-unit>
        <trans-unit id="105395de5f7d644b47550655e63b2ed02fcd3fdf" translate="yes" xml:space="preserve">
          <source>The keys and data of an ephemeron are said to be full if they point to a value, or empty if the value has never been set, has been unset, or was erased by the GC. In the function that accesses the keys or data these two states are represented by the &lt;code&gt;option&lt;/code&gt; type.</source>
          <target state="translated">如果一个星历表的键和数据指向某个值，则称其为已满；如果该值从未设置，尚未设置或已被GC擦除，则称其为空。在访问键或数据的功能中，这两种状态由 &lt;code&gt;option&lt;/code&gt; 类型表示。</target>
        </trans-unit>
        <trans-unit id="6634b8f0a482d759792ec8ca2ac4ce6773a03e6f" translate="yes" xml:space="preserve">
          <source>The keyword as in that type binds the type variable 'a to the object type &amp;lt; .. &amp;gt;. Therefore, Oo.copy takes an object with any methods (represented by the ellipsis), and returns an object of the same type. The type of Oo.copy is different from type &amp;lt; .. &amp;gt; -&amp;gt; &amp;lt; .. &amp;gt; as each ellipsis represents a different set of methods. Ellipsis actually behaves as a type variable.</source>
          <target state="translated">如该类型的关键字将类型变量'a绑定到对象类型&amp;lt;..&amp;gt;。因此，Oo.copy可以使用任何方法获取对象（用省略号表示），并返回相同类型的对象。 Oo.copy的类型与&amp;lt;..&amp;gt;-&amp;gt; &amp;lt;..&amp;gt;类型不同，因为每个省略号表示一组不同的方法。省略号实际上表现为类型变量。</target>
        </trans-unit>
        <trans-unit id="26d04af0b9de3d4d2a72eb74f835f5f6f6e937e3" translate="yes" xml:space="preserve">
          <source>The keywords - and -. can appear both as infix and prefix operators. When they appear as prefix operators, they are interpreted respectively as the functions (~-) and (~-.).</source>
          <target state="translated">关键词-和-.既可以作为后缀运算符,也可以作为前缀运算符。当它们作为前缀运算符出现时,它们分别被解释为函数(~-)和(~-.)。</target>
        </trans-unit>
        <trans-unit id="63ad31bd653530cc49e2890ef110e7033521237a" translate="yes" xml:space="preserve">
          <source>The kind of array elements is one of the following constants:</source>
          <target state="translated">数组元素的种类是以下常数之一。</target>
        </trans-unit>
        <trans-unit id="5a967e2a530696f236a7ac2ee23ef626eeebebbd" translate="yes" xml:space="preserve">
          <source>The labeled version of this module can be used as described in the &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">可以按照&lt;a href=&quot;stdlabels&quot;&gt; &lt;code&gt;StdLabels&lt;/code&gt; &lt;/a&gt;模块中的说明使用此模块的标记版本。</target>
        </trans-unit>
        <trans-unit id="ad467b38d8db4456aa825c50933b9ea245ee8d05" translate="yes" xml:space="preserve">
          <source>The language accepts external declarations with one or two flag strings in addition to the C function&amp;rsquo;s name. These flags are reserved for the implementation of the standard library.</source>
          <target state="translated">该语言除了使用C函数的名称外，还接受带有一或两个标志字符串的外部声明。这些标志保留用于标准库的实现。</target>
        </trans-unit>
        <trans-unit id="b8cdc3190f510239fa37ad383f7499bbcfcecc73" translate="yes" xml:space="preserve">
          <source>The largest positive finite value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 类型的最大正有限值。</target>
        </trans-unit>
        <trans-unit id="9b02fd4b3ae9e22d2aa52705a920bd39b960133e" translate="yes" xml:space="preserve">
          <source>The last two entries are valid for any n &amp;gt; 3.</source>
          <target state="translated">对于任何n&amp;gt; 3，最后两个条目均有效。</target>
        </trans-unit>
        <trans-unit id="411f2ed0253bd263770b7a506015d3b73acb28b7" translate="yes" xml:space="preserve">
          <source>The latter is slightly more efficient, as it allows clients of the module to call directly the C function instead of going through the corresponding OCaml function. On the other hand, it should not be used in library modules if they have side-effects at toplevel, as this direct call interferes with the linker&amp;rsquo;s algorithm for removing unused modules from libraries at link-time.</source>
          <target state="translated">后者的效率稍高一些，因为它允许模块的客户端直接调用C函数，而不用通过相应的OCaml函数。另一方面，如果库模块在顶级有副作用，则不应在库模块中使用它，因为此直接调用会干扰链接器在链接时从库中删除未使用的模块的算法。</target>
        </trans-unit>
        <trans-unit id="e0d5230f60bcbec268122dc0a17e6710399bb6df" translate="yes" xml:space="preserve">
          <source>The lazy expression lazy_expr is forced only if the lazy_guard value yields true once computed. Indeed, a simple wildcard pattern (not lazy) never forces the lazy expression&amp;rsquo;s evaluation. However, a pattern with keyword lazy, even if it is wildcard, always forces the evaluation of the deferred computation.</source>
          <target state="translated">仅当一次计算后lazy_guard值产生true时，才强制执行惰性表达式lazy_expr。确实，简单的通配符模式（不是惰性的）永远不会强迫惰性表达式的求值。但是，带有关键字lazy的模式，即使它是通配符，也始终会强制评估延迟的计算。</target>
        </trans-unit>
        <trans-unit id="cfa4f4b740be36ff7f795509d500d37f7af78f8b" translate="yes" xml:space="preserve">
          <source>The legacy bigarray library bundled with the compiler is a compatibility library with exactly the same interface as before, i.e. with map_file included.</source>
          <target state="translated">编译器中捆绑的legacy bigarray库是一个兼容性库,其接口与之前完全相同,即包含map_file。</target>
        </trans-unit>
        <trans-unit id="3c3cccf18cbaa6ce05baa77a874dea7a1d1ade41" translate="yes" xml:space="preserve">
          <source>The let and let rec constructs bind value names locally, as for the core language expressions.</source>
          <target state="translated">let和let rec构造体与核心语言表达式一样,将值名绑定在本地。</target>
        </trans-unit>
        <trans-unit id="a230275b7985703b310f49dd04772a11ba7b81ae" translate="yes" xml:space="preserve">
          <source>The let and letrec constructs bind value names locally. The construct</source>
          <target state="translated">let和letrec构造体将值名绑定在本地。构造</target>
        </trans-unit>
        <trans-unit id="4a7c897adf765ad531b54431abd748cbea11f170" translate="yes" xml:space="preserve">
          <source>The list is not empty.</source>
          <target state="translated">列表不是空的。</target>
        </trans-unit>
        <trans-unit id="e80da8bc0045d539fc55b1771c12707e1366c643" translate="yes" xml:space="preserve">
          <source>The list of options, each followed by the corresponding &lt;code&gt;doc&lt;/code&gt; string. Beware: options that have an empty &lt;code&gt;doc&lt;/code&gt; string will not be included in the list.</source>
          <target state="translated">选项列表，每个选项后跟相应的 &lt;code&gt;doc&lt;/code&gt; 字符串。当心：具有空 &lt;code&gt;doc&lt;/code&gt; 字符串的选项将不包括在列表中。</target>
        </trans-unit>
        <trans-unit id="37a09eb76bbb9dc4b8871dbc8586b6f3b99c21f6" translate="yes" xml:space="preserve">
          <source>The list of possible syntactic class is as follows:</source>
          <target state="translated">可能的语法类列表如下:</target>
        </trans-unit>
        <trans-unit id="7119efad1f349c18d670dab6d20261e060049541" translate="yes" xml:space="preserve">
          <source>The loadingmode variable controls how the program is executed.</source>
          <target state="translated">loadingmode变量控制程序的执行方式。</target>
        </trans-unit>
        <trans-unit id="15f3b2280a23c9730e0ae9df7fd26ba354827556" translate="yes" xml:space="preserve">
          <source>The macros CAMLlocal1 to CAMLlocal5 declare and initialize one to five local variables of type value. The variable names are given as arguments to the macros. CAMLlocalN(x, n) declares and initializes a local variable of type value [n]. You can use several calls to these macros if you have more than 5 local variables.</source>
          <target state="translated">宏CAMLlocal1至CAMLlocal5声明并初始化一到五个类型为value的局部变量。变量名称作为宏的参数。CAMLlocalN(x,n)声明并初始化一个类型为值[n]的局部变量。如果您有超过5个局部变量,您可以多次调用这些宏。</target>
        </trans-unit>
        <trans-unit id="1aaef768b1af4841714c0865edff6a7e10553a66" translate="yes" xml:space="preserve">
          <source>The macros CAMLreturn, CAMLreturn0, and CAMLreturnT are used to replace the C keyword return. Every occurrence of return x must be replaced by CAMLreturn (x) if x has type value, or CAMLreturnT (t, x) (where t is the type of x); every occurrence of return without argument must be replaced by CAMLreturn0. If your C function is a procedure (i.e. if it returns void), you must insert CAMLreturn0 at the end (to replace C&amp;rsquo;s implicit return).</source>
          <target state="translated">宏CAMLreturn，CAMLreturn0和CAMLreturnT用于替换C关键字return。如果x具有类型值，则每次出现的return x都必须用CAMLreturn（x）替换，或者用CAMLreturnT（t，x）（其中t是x的类型）替换；每次不带参数的return都必须替换为CAMLreturn0。如果您的C函数是一个过程（即，如果它返回void），则必须在末尾插入CAMLreturn0（以替换C的隐式返回）。</target>
        </trans-unit>
        <trans-unit id="885b3218ec0a809028025c650e9f6b490326927a" translate="yes" xml:space="preserve">
          <source>The main advantage of dynamic linking is that it preserves the platform-independence of bytecode executables. That is, the bytecode executable contains no machine code, and can therefore be compiled on platform A and executed on other platforms B, C, &amp;hellip;, as long as the required shared libraries are available on all these platforms. In contrast, executables generated by ocamlc -custom run only on the platform on which they were created, because they embark a custom-tailored runtime system specific to that platform. In addition, dynamic linking results in smaller executables.</source>
          <target state="translated">动态链接的主要优点是它保留了字节码可执行文件的平台无关性。也就是说，字节码可执行文件不包含任何机器代码，因此只要在所有这些平台上都可以使用所需的共享库，就可以在平台A上进行编译并在其他平台B，C ...上执行。相反，由ocamlc -custom生成的可执行文件仅在创建它们的平台上运行，因为它们启动了特定于该平台的定制化运行时系统。此外，动态链接会生成较小的可执行文件。</target>
        </trans-unit>
        <trans-unit id="31c9f9893f98dd3b2cb21409e3d29c4b1dc69b68" translate="yes" xml:space="preserve">
          <source>The main differences between 'Bigarrays' and standard OCaml arrays are as follows:</source>
          <target state="translated">Bigarrays &quot;与标准OCaml数组的主要区别如下。</target>
        </trans-unit>
        <trans-unit id="6fcf71e83dbbe5bf7b82af138897c5021410d4ef" translate="yes" xml:space="preserve">
          <source>The major GC speed is computed from this parameter. This is the memory that will be &quot;wasted&quot; because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if &lt;code&gt;space_overhead&lt;/code&gt; is smaller. Default: 80.</source>
          <target state="translated">主GC速度是从该参数计算得出的。这是将被&amp;ldquo;浪费&amp;rdquo;的内存，因为GC不会立即收集无法访问的块。它表示为用于实时数据的内存的百分比。如果 &lt;code&gt;space_overhead&lt;/code&gt; 较小，则GC将工作更多（使用更多的CPU时间并更热切地收集块）。默认值：80。</target>
        </trans-unit>
        <trans-unit id="0ac087e4dec98a5d96dc10610c38149e487d9d82" translate="yes" xml:space="preserve">
          <source>The maximum depth of any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;.</source>
          <target state="translated">任何推测性内联搜索的最大深度。参见第&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="30da6783cb2d914f60ad876ac28283601a269030" translate="yes" xml:space="preserve">
          <source>The maximum depth of any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="translated">任何推测性内联搜索的最大深度。参见第&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="52589afb28fd3716e0f6369cc78e02af38779e60" translate="yes" xml:space="preserve">
          <source>The maximum depth of any unrolling of recursive functions during any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;.</source>
          <target state="translated">在任何推测性内联搜索过程中展开任何递归函数的最大深度。参见第&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="14b6f2abfdc332a11cef59acff883ca20f69b025" translate="yes" xml:space="preserve">
          <source>The maximum depth of any unrolling of recursive functions during any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="translated">在任何推测性内联搜索过程中展开任何递归函数的最大深度。参见第&lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;节。</target>
        </trans-unit>
        <trans-unit id="6537d7fb4312afbfc14faa7b11bce9479277bccc" translate="yes" xml:space="preserve">
          <source>The maximum formatting depth is the maximum number of pretty-printing boxes simultaneously open.</source>
          <target state="translated">最大格式化深度是指同时打开的漂亮打印框的最大数量。</target>
        </trans-unit>
        <trans-unit id="fa16112992d556366d6be6ead64cb5e2ddc5d021" translate="yes" xml:space="preserve">
          <source>The maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.</source>
          <target state="translated">栈的最大尺寸(字数)。这只与字节码运行时有关,因为本地代码运行时使用操作系统的栈。默认值:1024k。</target>
        </trans-unit>
        <trans-unit id="3dcda863ccacea505bd2a294ce1ed4f2df1932a4" translate="yes" xml:space="preserve">
          <source>The meaning of format string type parameters is as follows:</source>
          <target state="translated">格式字符串类型参数的含义如下。</target>
        </trans-unit>
        <trans-unit id="290889214c915b5911f3b92719bce41512c0c609" translate="yes" xml:space="preserve">
          <source>The memory layout of Bigarrays is entirely compatible with that of arrays in C and Fortran, allowing large arrays to be passed back and forth between OCaml code and C / Fortran code with no data copying at all.</source>
          <target state="translated">Bigarrays的内存布局与C和Fortran中的数组完全兼容,允许大型数组在OCaml代码和C/Fortran代码之间来回传递,完全不需要复制数据。</target>
        </trans-unit>
        <trans-unit id="db529abafebd1568315a8328ddaf314170689aa7" translate="yes" xml:space="preserve">
          <source>The memory management counters are returned in a &lt;code&gt;stat&lt;/code&gt; record.</source>
          <target state="translated">内存管理计数器在 &lt;code&gt;stat&lt;/code&gt; 记录中返回。</target>
        </trans-unit>
        <trans-unit id="c4a3b03ef777eb26c6ae028dd5d106d607d702a8" translate="yes" xml:space="preserve">
          <source>The metadata file is available in the OCaml installation. Its location can be obtained using the following command:</source>
          <target state="translated">元数据文件在OCaml安装中是可用的。它的位置可以通过以下命令获得。</target>
        </trans-unit>
        <trans-unit id="e072a2bbaafe77d3313822b37614800d154b59ef" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; provides formatted input functions or &lt;em&gt;scanners&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;模块提供格式化的输入功能或&lt;em&gt;扫描仪&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="98dc8a81338816e727b183ae8835ac70814be748" translate="yes" xml:space="preserve">
          <source>The module type expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is the type of functors (functions from modules to modules) that take as argument a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and return as result a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The module type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; can use the name &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to refer to type components of the actual argument of the functor. If the type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; does not depend on type components of &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;, the module type expression can be simplified with the alternative short syntax &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="translated">模块类型表达式functor（&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;：&lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;）-&amp;gt; &lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;是函子的类型（从模块到模块的函数），其类型为&lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;的模块作为参数并返回a模块类型&lt;a href=&quot;#module-type&quot;&gt;模块类型&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。模块类型&lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;可以使用名称&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;来引用函子的实际参数的类型组件。如果类型&lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;不依赖于&lt;a href=&quot;names#module-name&quot;&gt;module-name的&lt;/a&gt;类型组成部分，则可以使用可选的简短语法来简化模块类型表达式&lt;a href=&quot;#module-type&quot;&gt;模块类型&lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt;&lt;a href=&quot;#module-type&quot;&gt;模块类型&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。对functor参数的类型没有任何限制。特别是，一个仿函数可以将另一个仿函数作为参数（&amp;ldquo;高阶&amp;rdquo;仿函数）。</target>
        </trans-unit>
        <trans-unit id="19e87897038acb2ea0b22d40eb32fcf01d0bb4bf" translate="yes" xml:space="preserve">
          <source>The most common usage of variant types is to describe recursive data structures. Consider for example the type of binary trees:</source>
          <target state="translated">变体类型最常见的用法是描述递归数据结构。例如考虑二进制树的类型。</target>
        </trans-unit>
        <trans-unit id="0c5e4a5c67b4d7db566f82e81b3b0733b0a71933" translate="yes" xml:space="preserve">
          <source>The most user-friendly way to use the debugger is to run it under Emacs with the OCaml mode available through MELPA and also at &lt;a href=&quot;https://github.com/ocaml/caml-mode&quot;&gt;https://github.com/ocaml/caml-mode&lt;/a&gt;.</source>
          <target state="translated">使用调试器的最方便用户的方法是在MELPA可用的OCaml模式下在Emacs下运行它，也可以在&lt;a href=&quot;https://github.com/ocaml/caml-mode&quot;&gt;https://github.com/ocaml/caml-mode&lt;/a&gt;下运行它。</target>
        </trans-unit>
        <trans-unit id="969c39463cdd83094435d7ff5442eba358f5bbab" translate="yes" xml:space="preserve">
          <source>The most user-friendly way to use the debugger is to run it under Emacs. See the file emacs/README in the distribution for information on how to load the Emacs Lisp files for OCaml support.</source>
          <target state="translated">使用调试器最方便的方法是在Emacs下运行它。请参阅发行版中的 emacs/README 文件,了解如何加载 Emacs Lisp 文件以支持 OCaml。</target>
        </trans-unit>
        <trans-unit id="78aad986fb7a4eb2c56f1239f1a0ea9f7c757987" translate="yes" xml:space="preserve">
          <source>The motivation is that, by letting &amp;lsquo;ocamlopt&amp;lsquo; deal with boxing, it can often decide to suppress it entirely.</source>
          <target state="translated">其动机是，通过让&amp;ldquo; ocamlopt&amp;rdquo;处理拳击，它通常可以决定完全压制它。</target>
        </trans-unit>
        <trans-unit id="e080b5bf8fc37b589b95288dd439c400c34b427b" translate="yes" xml:space="preserve">
          <source>The multiplier is k, M, or G, for multiplication by 2&lt;sup&gt;10&lt;/sup&gt;, 2&lt;sup&gt;20&lt;/sup&gt;, and 2&lt;sup&gt;30&lt;/sup&gt; respectively.</source>
          <target state="translated">乘法器为k，M或G，用于乘以2 &lt;sup&gt;10&lt;/sup&gt;，2 &lt;sup&gt;20&lt;/sup&gt;，2 &lt;sup&gt;30&lt;/sup&gt;分别。</target>
        </trans-unit>
        <trans-unit id="e5001d83b2b93aa689b354ed2086458f2935a047" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running.</source>
          <target state="translated">包含当前运行的可执行文件的文件名。</target>
        </trans-unit>
        <trans-unit id="59eca0c39d17cb0f2108d6d77b193b119b04559b" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running. This name may be absolute or relative to the current directory, depending on the platform and whether the program was compiled to bytecode or a native executable.</source>
          <target state="translated">包含当前运行的可执行文件的文件名。这个名字可能是绝对的,也可能是相对于当前目录的,这取决于平台和程序是否被编译成字节码或本地可执行文件。</target>
        </trans-unit>
        <trans-unit id="cf0030b90670a18e3de17304172d5e4c928be425" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="translated">初始临时目录的名称：在Unix下， &lt;code&gt;TMPDIR&lt;/code&gt; 环境变量的值；如果未设置该变量，则为&amp;ldquo; / tmp&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7c8b8d9700396ab187abf8b0e62dcd1c6f319473" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set.</source>
          <target state="translated">初始临时目录的名称：在Unix下， &lt;code&gt;TMPDIR&lt;/code&gt; 环境变量的值；如果未设置该变量，则为&amp;ldquo; / tmp&amp;rdquo;。在Windows下， &lt;code&gt;TEMP&lt;/code&gt; 环境变量的值或&amp;ldquo;。&amp;rdquo;。如果未设置变量。</target>
        </trans-unit>
        <trans-unit id="3c9a52823f32936b8fa5faaa814adee980e5c3ce" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="translated">临时目录的名称：在Unix下， &lt;code&gt;TMPDIR&lt;/code&gt; 环境变量的值；如果未设置该变量，则为&amp;ldquo; / tmp&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="bd4c9b92bb5cafc665608d7e7c71ee74b72bd3e4" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set. The temporary directory can be changed with &lt;a href=&quot;filename#VALset_temp_dir_name&quot;&gt;&lt;code&gt;Filename.set_temp_dir_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">临时目录的名称：在Unix下， &lt;code&gt;TMPDIR&lt;/code&gt; 环境变量的值；如果未设置该变量，则为&amp;ldquo; / tmp&amp;rdquo;。在Windows下， &lt;code&gt;TEMP&lt;/code&gt; 环境变量的值或&amp;ldquo;。&amp;rdquo;。如果未设置变量。可以使用&lt;a href=&quot;filename#VALset_temp_dir_name&quot;&gt; &lt;code&gt;Filename.set_temp_dir_name&lt;/code&gt; &lt;/a&gt;更改临时目录。</target>
        </trans-unit>
        <trans-unit id="80a92c6fec8ac40ba4e0c4025b59dde0b751953a" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path.</source>
          <target state="translated">在当前目录和搜索路径的目录中都找不到命名的文件。</target>
        </trans-unit>
        <trans-unit id="952b3090c265f73e61fb891aab443a8262a5704d" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path. The filename is either a compiled interface file (.cmi file), or a compiled bytecode file (.cmo file). If filename has the format mod.cmi, this means you are trying to compile a file that references identifiers from module mod, but you have not yet compiled an interface for module mod. Fix: compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.</source>
          <target state="translated">在当前目录下和搜索路径的目录下都找不到命名的文件。文件名要么是一个编译过的接口文件(.cmi文件),要么是一个编译过的字节码文件(.cmo文件)。如果文件名的格式为mod.cmi,这意味着你正试图编译一个引用mod模块标识符的文件,但你还没有编译mod模块的接口。修正:先编译mod.mli或mod.ml,以创建编译后的接口mod.cmi。</target>
        </trans-unit>
        <trans-unit id="a2f02d60d1e116f8243f8229b3fd568a95c8a809" translate="yes" xml:space="preserve">
          <source>The names of the entry points must be valid identifiers for OCaml values (starting with a lowercase letter). Similarly, the arguments arg&lt;sub&gt;1&lt;/sub&gt;&amp;hellip; arg&lt;sub&gt;n&lt;/sub&gt; must be valid identifiers for OCaml. Each entry point becomes an OCaml function that takes n+1 arguments, the extra implicit last argument being of type Lexing.lexbuf. Characters are read from the Lexing.lexbuf argument and matched against the regular expressions provided in the rule, until a prefix of the input matches one of the rule. The corresponding action is then evaluated and returned as the result of the function.</source>
          <target state="translated">入口点的名称必须是OCaml值的有效标识符（以小写字母开头）。同样，参数arg &lt;sub&gt;1&lt;/sub&gt; &amp;hellip;arg &lt;sub&gt;n&lt;/sub&gt;必须是OCaml的有效标识符。每个入口点都变成一个OCaml函数，该函数接受n + 1个参数，额外的隐式最后一个参数的类型为Lexing.lexbuf。从Lexing.lexbuf参数读取字符，并与规则中提供的正则表达式进行匹配，直到输入的前缀与规则之一匹配为止。然后评估相应的动作并作为函数的结果返回。</target>
        </trans-unit>
        <trans-unit id="a5ca4780e331ea88692f3bab8f908b1e857d3545" translate="yes" xml:space="preserve">
          <source>The names of the two C functions must be given in the primitive declaration, as follows:</source>
          <target state="translated">两个C函数的名称必须在基元声明中给出,如下。</target>
        </trans-unit>
        <trans-unit id="2af38c50738eb4e1ac67f27fb83521c12f9da713" translate="yes" xml:space="preserve">
          <source>The native C character type under Windows is WCHAR, two bytes wide, while under Unix it is char, one byte wide. A type char_os is defined in &amp;lt;caml/misc.h&amp;gt; that stands for the concrete C character type of each platform. Strings in the platform encoding are of type char_os *.</source>
          <target state="translated">在Windows下，本机C字符类型是WCHAR，两个字节宽，而在Unix下，它是char，一个字节宽。在&amp;lt;caml / misc.h&amp;gt;中定义了一种char_os类型，代表每个平台的具体C字符类型。平台编码中的字符串类型为char_os *。</target>
        </trans-unit>
        <trans-unit id="376053bbccd9cdcd8890b3fbdf88ead49637bae1" translate="yes" xml:space="preserve">
          <source>The native integer -1.</source>
          <target state="translated">原生整数-1。</target>
        </trans-unit>
        <trans-unit id="9ee1fc5518ff6fbf2992ed7e1ec40186e53f6653" translate="yes" xml:space="preserve">
          <source>The native integer 0.</source>
          <target state="translated">原生整数0。</target>
        </trans-unit>
        <trans-unit id="4bcc40875771e327d2f0e7c0fa203d846f93e6b4" translate="yes" xml:space="preserve">
          <source>The native integer 1.</source>
          <target state="translated">原生整数1。</target>
        </trans-unit>
        <trans-unit id="5c20da3e1fe2cd472edcbc03735391872edbfb80" translate="yes" xml:space="preserve">
          <source>The native-code compiler is only available on certain platforms. It produces code that runs faster than the bytecode produced by ocamlc, at the cost of increased compilation time and executable code size. Compatibility with the bytecode compiler is extremely high: the same source code should run identically when compiled with ocamlc and ocamlopt.</source>
          <target state="translated">本机代码编译器只在某些平台上使用。它产生的代码比ocamlc产生的字节码运行得更快,但代价是增加了编译时间和可执行代码的大小。与字节码编译器的兼容性非常高:同样的源代码在用ocamlc和ocamlopt编译时应该运行得完全一样。</target>
        </trans-unit>
        <trans-unit id="5e5e7155dfdf15208a1cbe9f526ab06c992a1a3c" translate="yes" xml:space="preserve">
          <source>The native-code compiler ocamlopt also supports the -output-obj option, causing it to output a C object file or a shared library containing the native code for all OCaml modules on the command-line, as well as the OCaml startup code. Initialization is performed by calling caml_startup (or caml_startup_exn) as in the case of the bytecode compiler.</source>
          <target state="translated">本机代码编译器ocamlopt也支持-output-obj选项,使其输出一个C对象文件或共享库,其中包含命令行上所有OCaml模块的本机代码,以及OCaml启动代码。初始化是通过调用caml_startup(或caml_startup_exn)来完成的,就像字节码编译器一样。</target>
        </trans-unit>
        <trans-unit id="36be14bc239e78c132c193d0ff0e16beb22b0661" translate="yes" xml:space="preserve">
          <source>The native-code compiler performs a number of optimizations that the bytecode compiler does not perform, especially when the Flambda optimizer is active. In particular, the native-code compiler identifies and eliminates &amp;ldquo;dead code&amp;rdquo;, i.e. computations that do not contribute to the results of the program. For example,</source>
          <target state="translated">本机代码编译器执行许多字节码编译器不执行的优化，尤其是在Flambda优化器处于活动状态时。特别地，本机代码编译器识别并消除&amp;ldquo;死代码&amp;rdquo;，即对程序结果无贡献的计算。例如，</target>
        </trans-unit>
        <trans-unit id="f90676a471e21697a3a109feb2073705f4c086a3" translate="yes" xml:space="preserve">
          <source>The next allocation can trigger a garbage collection. The garbage collector assumes that all structured blocks contain well-formed values. Newly created blocks contain random data, which generally do not represent well-formed values.</source>
          <target state="translated">下一次分配会触发垃圾收集器。垃圾收集器假设所有结构化的块都包含了良好形式的值。新创建的块包含随机数据,一般不代表格式良好的值。</target>
        </trans-unit>
        <trans-unit id="33f94342d426b6ca7b5a6cd5848192a5418df90c" translate="yes" xml:space="preserve">
          <source>The next step is to compile and link the program with the instrumented runtime. This can be done by using the -runtime-variant flag:</source>
          <target state="translated">下一步是编译程序并将其与工具化的运行时相连接,这可以通过使用-runtime-variant标志来完成。这可以通过使用 -runtime-variant 标志来完成。</target>
        </trans-unit>
        <trans-unit id="bbe1c650255dd39febc517d8d6e9ecf4a27a4e50" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;模块的输入通道的概念：这些通道提供了从任何字符源读取所需的所有设备，包括&lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt;值。</target>
        </trans-unit>
        <trans-unit id="16542651eb8af79575740dab6d97e5baeedd8889" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value. A Scanf.Scanning.in_channel value is also called a</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;模块的输入通道的概念：这些通道提供了从任何字符源读取所需的所有设备，包括&lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt;值。Scanf.Scanning.in_channel值也称为</target>
        </trans-unit>
        <trans-unit id="dc0369bec5d64b7e5ca44539b36eca9c14402a44" translate="yes" xml:space="preserve">
          <source>The num library implements integer arithmetic and rational arithmetic in arbitrary precision. It was split off the core OCaml distribution starting with the 4.06.0 release, and can now be found at &lt;a href=&quot;https://github.com/ocaml/num&quot;&gt;https://github.com/ocaml/num&lt;/a&gt;.</source>
          <target state="translated">num库以任意精度实现整数算术和有理算术。从4.06.0发行版开始，它已从核心OCaml发行版中分离出来，现在可以在&lt;a href=&quot;https://github.com/ocaml/num&quot;&gt;https://github.com/ocaml/num&lt;/a&gt;上找到。</target>
        </trans-unit>
        <trans-unit id="0976e8b95aee4f6b6b94a903578443416a16fd1d" translate="yes" xml:space="preserve">
          <source>The number of samples in this block (&amp;gt;= 1).</source>
          <target state="translated">此块中的样本数（&amp;gt; = 1）。</target>
        </trans-unit>
        <trans-unit id="80c5921664757a5de49c34516dd5a9044bf527fa" translate="yes" xml:space="preserve">
          <source>The object type c0 is an abbreviation for &amp;lt;m : 'a; n : int&amp;gt; as 'a. Consider now the type declaration:</source>
          <target state="translated">对象类型c0是&amp;lt;m：'a;的缩写。n：int&amp;gt;为'a。现在考虑类型声明：</target>
        </trans-unit>
        <trans-unit id="c4798644a1b3b83b3464a016d6b7ad72bf5f4632" translate="yes" xml:space="preserve">
          <source>The object type c1 is an abbreviation for the type &amp;lt;m : 'a&amp;gt; as 'a. The coercion from an object of type c0 to an object of type c1 is correct:</source>
          <target state="translated">对象类型c1是类型&amp;lt;m：'a&amp;gt;作为'a的缩写。从c0类型的对象到c1类型的对象的强制是正确的：</target>
        </trans-unit>
        <trans-unit id="4e56b5bcc7c0be28d1a5ad641e4581f9a06b6925" translate="yes" xml:space="preserve">
          <source>The ocaml.alert or alert attribute serves two purposes: (i) to mark component with an alert to be triggered when the component is referenced, and (ii) to control which alert names are enabled. In the first form, the attribute takes an identifier possibly followed by a message. Here is an example of a value declaration marked with an alert:</source>
          <target state="translated">ocaml.alert或alert属性有两个目的。(一)在组件被引用时用警报标记该组件,(二)控制启用哪些警报名称。在第一种形式中,该属性使用一个标识符,后面可能跟一个消息。下面是一个用警报标记的值声明的例子。</target>
        </trans-unit>
        <trans-unit id="663c4b2feb0ff61316e473a7d7058b8a8ac77602" translate="yes" xml:space="preserve">
          <source>The ocamlc command has a command-line interface similar to the one of most C compilers. It accepts several types of arguments and processes them sequentially, after all options have been processed:</source>
          <target state="translated">ocamlc命令有一个类似于大多数C编译器的命令行界面。它接受多种类型的参数,并在处理完所有选项后按顺序进行处理。</target>
        </trans-unit>
        <trans-unit id="8ccd15521b1aa9660fdf126df14cf7897ed7444c" translate="yes" xml:space="preserve">
          <source>The ocamlcp and ocamloptp commands also accept all the options of the corresponding ocamlc or ocamlopt compiler, except the -pp (preprocessing) option.</source>
          <target state="translated">ocamlcp和ocamloptp命令也接受相应的ocamlc或ocamlopt编译器的所有选项,除了-pp(预处理)选项。</target>
        </trans-unit>
        <trans-unit id="fa91a0c172cde52b6822b93be7514538cd75d072" translate="yes" xml:space="preserve">
          <source>The ocamldep command scans a set of OCaml source files (.ml and .mli files) for references to external compilation units, and outputs dependency lines in a format suitable for the make utility. This ensures that make will compile the source files in the correct order, and recompile those files that need to when a source file is modified.</source>
          <target state="translated">ocamldep命令扫描一组OCaml源文件(.ml和.mli文件),以查找对外部编译单元的引用,并以适合make工具的格式输出依赖行。这确保了make将以正确的顺序编译源文件,并在源文件被修改时重新编译那些需要的文件。</target>
        </trans-unit>
        <trans-unit id="5bc0cf38a6832c2cb08c4085b324377b241b03c6" translate="yes" xml:space="preserve">
          <source>The ocamllex command produces a lexical analyzer from a set of regular expressions with attached semantic actions, in the style of lex. Assuming the input file is lexer.mll, executing</source>
          <target state="translated">ocamllex 命令以 lex 的风格,从一组带有附加语义操作的正则表达式中生成一个词法分析器。假设输入文件是 lexer.mll,那么执行</target>
        </trans-unit>
        <trans-unit id="785a09dfb0b7bb6413c4e50f2cabd1b69c63c6b4" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command facilitates the construction of libraries containing both OCaml code and C code, and usable both in static linking and dynamic linking modes. This command is available under Windows since Objective Caml 3.11 and under other operating systems since Objective Caml 3.03.</source>
          <target state="translated">ocamlmklib命令有助于构建包含OCaml代码和C代码的库,并且在静态链接和动态链接模式下都可以使用。这个命令从Objective Caml 3.11开始在Windows下可用,从Objective Caml 3.03开始在其他操作系统下可用。</target>
        </trans-unit>
        <trans-unit id="37782ee3b2232fe93bbe77ca370d4160e2021dd2" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command takes three kinds of arguments:</source>
          <target state="translated">ocamlmklib命令需要三种参数。</target>
        </trans-unit>
        <trans-unit id="68dd5d1772fdc70b18042e2faf73bb6d263b83ef" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command builds OCaml toplevels that contain user code preloaded at start-up.</source>
          <target state="translated">ocamlmktop命令可以构建包含在启动时预装的用户代码的OCaml toplevels。</target>
        </trans-unit>
        <trans-unit id="6831997e14580584458639904bb3e8b4303221cf" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command takes as argument a set of .cmo and .cma files, and links them with the object files that implement the OCaml toplevel. The typical use is:</source>
          <target state="translated">ocamlmktop命令将一组.cmo和.cma文件作为参数,并将它们与实现OCaml toplevel的对象文件链接起来。典型的用法是。</target>
        </trans-unit>
        <trans-unit id="ab3cce8e0848dae6978b901dc63aa4ea6c79e945" translate="yes" xml:space="preserve">
          <source>The ocamlopt command has a command-line interface very close to that of ocamlc. It accepts the same types of arguments, and processes them sequentially, after all options have been processed:</source>
          <target state="translated">ocamlopt 命令的命令行界面与 ocamlc 非常接近。它接受相同类型的参数,并在处理完所有选项后依次处理。</target>
        </trans-unit>
        <trans-unit id="9f43adb44cad300b255a2ab339a13959b026d322" translate="yes" xml:space="preserve">
          <source>The ocamlprof command produces a source listing of the program modules where execution counts have been inserted as comments. For instance,</source>
          <target state="translated">ocamlprof命令产生一个程序模块的源码列表,在这个列表中,执行次数被作为注释插入。例如</target>
        </trans-unit>
        <trans-unit id="b7ea8af81e418a1edb4e459f8a9a2eab6da15605" translate="yes" xml:space="preserve">
          <source>The ocamlrun command comprises three main parts: the bytecode interpreter, that actually executes bytecode files; the memory allocator and garbage collector; and a set of C functions that implement primitive operations such as input/output.</source>
          <target state="translated">ocamlrun命令由三大部分组成:字节码解释器,实际执行字节码文件;内存分配器和垃圾收集器;以及一组实现输入/输出等基本操作的C函数。</target>
        </trans-unit>
        <trans-unit id="ba3256951b99c851dcb6d71a9ee49e018d24d2bb" translate="yes" xml:space="preserve">
          <source>The ocamlrun command executes bytecode files produced by the linking phase of the ocamlc command.</source>
          <target state="translated">ocamlrun命令执行由ocamlc命令的链接阶段产生的字节码文件。</target>
        </trans-unit>
        <trans-unit id="9e1235caedb5ccfed4248d72a0e38e7bda7a4c82" translate="yes" xml:space="preserve">
          <source>The ocamlrun command searches shared libraries in the following directories, in the order indicated:</source>
          <target state="translated">ocamlrun命令按照指定的顺序在以下目录中搜索共享库。</target>
        </trans-unit>
        <trans-unit id="45cf460ec88bc5d152326aaf5ae83eb8df678857" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command produces a parser from a context-free grammar specification with attached semantic actions, in the style of yacc. Assuming the input file is grammar.mly, executing</source>
          <target state="translated">ocamlyacc命令从一个无上下文的语法规范中产生一个解析器,该语法规范带有附加的语义操作,其风格与yacc相似。假设输入文件是 grammar.mly,执行</target>
        </trans-unit>
        <trans-unit id="028fe9d310df119de0ec84424c8896799e9e2f82" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command recognizes the following options:</source>
          <target state="translated">ocamlyacc命令可以识别以下选项。</target>
        </trans-unit>
        <trans-unit id="2c12a611ec5444a4dcbe094626c7878666edcceb" translate="yes" xml:space="preserve">
          <source>The only case we have reasonable confidence is safe is if the produced &lt;code&gt;bytes&lt;/code&gt; is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt;) and previously used the &lt;code&gt;string&lt;/code&gt; type for this purpose.</source>
          <target state="translated">我们唯一有合理把握的情况是安全的，即如果产生的 &lt;code&gt;bytes&lt;/code&gt; 是共享的-用作不可变字节序列，则是安全的。这对于处理不可变的字节序列（例如&lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt; &lt;code&gt;Marshal.from_bytes&lt;/code&gt; &lt;/a&gt;）并且先前为此目的使用 &lt;code&gt;string&lt;/code&gt; 类型的低级程序的增量迁移很有用。</target>
        </trans-unit>
        <trans-unit id="9599505a809ca09e4fab73b6902744c16bc81fdd" translate="yes" xml:space="preserve">
          <source>The only case where that transformation is not possible is if a given function call may raise distinct exceptions with the same constructor but different string values. In this case, you will have to check for specific string values. This is dangerous API design and it should be discouraged: it&amp;rsquo;s better to define more precise exception constructors than store useful information in strings.</source>
          <target state="translated">唯一不可能进行这种转换的情况是，给定的函数调用可能会在相同的构造函数但字符串值不同的情况下引发不同的异常。在这种情况下，您将必须检查特定的字符串值。这是危险的API设计，应劝阻：最好定义更精确的异常构造函数，而不是将有用的信息存储在字符串中。</target>
        </trans-unit>
        <trans-unit id="2cedfa4c8d920a307290831222d9cbd51790caf6" translate="yes" xml:space="preserve">
          <source>The only difference with the let construct described above is that the bindings of names to values performed by the pattern-matching are considered already performed when the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated. That is, the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; can reference identifiers that are bound by one of the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and expect them to have the same value as in &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the body of the letrec construct.</source>
          <target state="translated">与上述let构造的唯一区别在于，当对表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;到&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;求值时，就认为名称与通过模式匹配执行的值的绑定已经执行。也就是说，表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;至&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;可以引用由模式&lt;a href=&quot;patterns#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，...，&lt;a href=&quot;patterns#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;之一绑定的标识符，并希望它们具有与letrec构造体&lt;a href=&quot;#expr&quot;&gt;expr中的&lt;/a&gt;值相同的值。</target>
        </trans-unit>
        <trans-unit id="774d89b5de623ddb891076997b98ef614701dff8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flags&lt;/code&gt; are:</source>
          <target state="translated">可选 &lt;code&gt;flags&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="8e89406e3e1bdda8e82d077bce710e73570e29fe" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;precision&lt;/code&gt; is a dot &lt;code&gt;.&lt;/code&gt; followed by an integer indicating how many digits follow the decimal point in the &lt;code&gt;%f&lt;/code&gt;, &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%h&lt;/code&gt;, and &lt;code&gt;%H&lt;/code&gt; conversions or the maximum number of significant digits to appear for the &lt;code&gt;%F&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; conversions. For instance, &lt;code&gt;%.4f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with 4 fractional digits.</source>
          <target state="translated">可选的 &lt;code&gt;precision&lt;/code&gt; 是点 &lt;code&gt;.&lt;/code&gt; 后跟一个整数，该整数指示 &lt;code&gt;%f&lt;/code&gt; ， &lt;code&gt;%e&lt;/code&gt; ， &lt;code&gt;%E&lt;/code&gt; ， &lt;code&gt;%h&lt;/code&gt; 和 &lt;code&gt;%H&lt;/code&gt; 转换中的小数点后有多少位数，或 &lt;code&gt;%F&lt;/code&gt; ， &lt;code&gt;%g&lt;/code&gt; 和 &lt;code&gt;%G&lt;/code&gt; 转换中出现的最大有效位数。例如， &lt;code&gt;%.4f&lt;/code&gt; 打印带有4个小数位的 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5468298bc781912cae47e80a93f5f848cf36f0ca" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;random&lt;/code&gt; parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of &lt;code&gt;Hashtbl.create&lt;/code&gt; or deterministic over all executions.</source>
          <target state="translated">可选的 &lt;code&gt;random&lt;/code&gt; 参数（布尔值）控制哈希表的内部组织是在 &lt;code&gt;Hashtbl.create&lt;/code&gt; 的每次执行时是随机的，还是在所有执行中是确定性的。</target>
        </trans-unit>
        <trans-unit id="af162af26700a86b364c7a2731480ce8c43ff2a7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;width&lt;/code&gt; is an integer indicating the minimal width of the result. For instance, &lt;code&gt;%6d&lt;/code&gt; prints an integer, prefixing it with spaces to fill at least 6 characters.</source>
          <target state="translated">可选 &lt;code&gt;width&lt;/code&gt; 是一个整数，指示结果的最小宽度。例如， &lt;code&gt;%6d&lt;/code&gt; 打印一个整数，并在其前面加上空格以填充至少6个字符。</target>
        </trans-unit>
        <trans-unit id="18011c2fab12a66b7e7060c98020473e137bdb60" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;~&lt;/code&gt;&lt;code&gt;random&lt;/code&gt; parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of &lt;code&gt;Hashtbl.create&lt;/code&gt; or deterministic over all executions.</source>
          <target state="translated">可选 &lt;code&gt;~&lt;/code&gt; &lt;code&gt;random&lt;/code&gt; 参数（布尔型）对照散列表中的内部组织是否是在每次执行随机 &lt;code&gt;Hashtbl.create&lt;/code&gt; 或确定性在所有的执行。</target>
        </trans-unit>
        <trans-unit id="a984b2d5c22765574cbc75b87562636eb520c87c" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;?stdin&lt;/code&gt; and &lt;code&gt;?stdout&lt;/code&gt; and &lt;code&gt;?stderr&lt;/code&gt; are file names used to redirect the standard input, the standard output, or the standard error of the command. If &lt;code&gt;~stdin:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;lt;&amp;nbsp;f&lt;/code&gt; is performed and the standard input of the command reads from file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stdout:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard output of the command is written to file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stderr:f&lt;/code&gt; is given, a redirection &lt;code&gt;2&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard error of the command is written to file &lt;code&gt;f&lt;/code&gt;. If both &lt;code&gt;~stdout:f&lt;/code&gt; and &lt;code&gt;~stderr:f&lt;/code&gt; are given, with the exact same file name &lt;code&gt;f&lt;/code&gt;, a &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; redirection is performed so that the standard output and the standard error of the command are interleaved and redirected to the same file &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">可选参数 &lt;code&gt;?stdin&lt;/code&gt; 和 &lt;code&gt;?stdout&lt;/code&gt; 和 &lt;code&gt;?stderr&lt;/code&gt; 是用于重定向命令的标准输入，标准输出或标准错误的文件名。如果给定 &lt;code&gt;~stdin:f&lt;/code&gt; ，则执行重定向 &lt;code&gt;&amp;lt;&amp;nbsp;f&lt;/code&gt; ，并且命令的标准输入从文件 &lt;code&gt;f&lt;/code&gt; 中读取。如果给定 &lt;code&gt;~stdout:f&lt;/code&gt; ，则执行重定向 &lt;code&gt;&amp;gt;&amp;nbsp;f&lt;/code&gt; ，并将命令的标准输出写入文件 &lt;code&gt;f&lt;/code&gt; 。如果给定 &lt;code&gt;~stderr:f&lt;/code&gt; ，则执行重定向 &lt;code&gt;2&amp;gt;&amp;nbsp;f&lt;/code&gt; ，并将命令的标准错误写入文件 &lt;code&gt;f&lt;/code&gt; 。如果都 &lt;code&gt;~stdout:f&lt;/code&gt; 给出了和 &lt;code&gt;~stderr:f&lt;/code&gt; ，具有完全相同的文件名 &lt;code&gt;f&lt;/code&gt; ，执行 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 重定向，以便将标准输出和命令的标准错误插入并重定向到同一文件 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e256823745bc0b0bb3e5fba44ec11d079e0f250" translate="yes" xml:space="preserve">
          <source>The optional type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; makes the defined type equivalent to the type expression &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;: one can be substituted for the other during typing. If no type equation is given, a new type is generated: the defined type is incompatible with any other type.</source>
          <target state="translated">可选的类型方程式= &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;使定义的类型等效于类型表达式&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;：在键入过程中，一个可以替代另一个。如果没有给出类型方程式，则生成新的类型：定义的类型与任何其他类型都不兼容。</target>
        </trans-unit>
        <trans-unit id="b981238dc55cab7ff8d05b1c6297d9f1f74dde9a" translate="yes" xml:space="preserve">
          <source>The optional type parameters are either one type variable '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, for type constructors with one parameter, or a list of type variables ('&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;), for type constructors with several parameters. Each type parameter may be prefixed by a variance constraint + (resp. -) indicating that the parameter is covariant (resp. contravariant), and an injectivity annotation ! indicating that the parameter can be deduced from the whole type. These type parameters can appear in the type expressions of the right-hand side of the definition, optionally restricted by a variance constraint ; &lt;em&gt;i.e.&lt;/em&gt; a covariant parameter may only appear on the right side of a functional arrow (more precisely, follow the left branch of an even number of arrows), and a contravariant parameter only the left side (left branch of an odd number of arrows). If the type has a representation or an equation, and the parameter is free (&lt;em&gt;i.e.&lt;/em&gt; not bound via a type constraint to a constructed type), its variance constraint is checked but subtyping &lt;em&gt;etc.&lt;/em&gt; will use the inferred variance of the parameter, which may be less restrictive; otherwise (&lt;em&gt;i.e.&lt;/em&gt; for abstract types or non-free parameters), the variance must be given explicitly, and the parameter is invariant if no variance is given.</source>
          <target state="translated">对于具有一个参数的类型构造函数，可选的类型参数可以是一个类型变量' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;，对于具有多个参数的类型构造函数，可以是类型变量列表（' &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，' &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）。每个类型参数的前缀可以是方差约束+（表示-），表示该参数是协变的（表示反变量），并且带有注解！指示可以从整个类型推导该参数。这些类型参数可以出现在定义右侧的类型表达式中，可以选择受方差约束的约束；&lt;em&gt;IE&lt;/em&gt;协变参数只能出现在功能箭头的右侧（更精确地，遵循偶数个箭头的左侧分支），而协变参数只能出现在左侧（奇数个箭头的左侧分支）。如果类型具有表示形式或等式，并且参数是自由的（&lt;em&gt;即&lt;/em&gt;未通过类型约束绑定到构造的类型），则检查其方差约束，但子类型化&lt;em&gt;等&lt;/em&gt;将使用参数的推断方差，这可能是限制较少；否则（&lt;em&gt;即&lt;/em&gt;对于抽象类型或非自由参数），必须显式给出方差，如果未给出方差，则参数是不变的。</target>
        </trans-unit>
        <trans-unit id="4236d000dcf5d91e24113385c5dda11fb81d860b" translate="yes" xml:space="preserve">
          <source>The optional type parameters are either one type variable '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, for type constructors with one parameter, or a list of type variables ('&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;), for type constructors with several parameters. Each type parameter may be prefixed by a variance constraint + (resp. -) indicating that the parameter is covariant (resp. contravariant). These type parameters can appear in the type expressions of the right-hand side of the definition, optionally restricted by a variance constraint ; &lt;em&gt;i.e.&lt;/em&gt; a covariant parameter may only appear on the right side of a functional arrow (more precisely, follow the left branch of an even number of arrows), and a contravariant parameter only the left side (left branch of an odd number of arrows). If the type has a representation or an equation, and the parameter is free (&lt;em&gt;i.e.&lt;/em&gt; not bound via a type constraint to a constructed type), its variance constraint is checked but subtyping &lt;em&gt;etc.&lt;/em&gt; will use the inferred variance of the parameter, which may be less restrictive; otherwise (&lt;em&gt;i.e.&lt;/em&gt; for abstract types or non-free parameters), the variance must be given explicitly, and the parameter is invariant if no variance is given.</source>
          <target state="translated">对于具有一个参数的类型构造函数，可选的类型参数可以是一个类型变量' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;，对于具有多个参数的类型构造函数，可以是类型变量列表（' &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，' &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）。每个类型参数都可以加上方差约束+（分别为-）作为前缀，指示该参数是协方差（分别为对数）。这些类型参数可以出现在定义右侧的类型表达式中，可以选择受方差约束的约束；&lt;em&gt;IE&lt;/em&gt;协变参数只能出现在功能箭头的右侧（更精确地，遵循偶数个箭头的左侧分支），而协变参数只能出现在左侧（奇数个箭头的左侧分支）。如果类型具有表示形式或等式，并且参数是自由的（&lt;em&gt;即&lt;/em&gt;未通过类型约束绑定到构造的类型），则检查其方差约束，但子类型化&lt;em&gt;等&lt;/em&gt;将使用参数的推断方差，这可能是限制较少；否则（&lt;em&gt;即&lt;/em&gt;对于抽象类型或非自由参数），必须显式给出方差，如果未给出方差，则参数是不变的。</target>
        </trans-unit>
        <trans-unit id="dca346bd513d4a4a22688d0f639db0a9deec76c9" translate="yes" xml:space="preserve">
          <source>The optional type representation describes the data structure representing the defined type, by giving the list of associated constructors (if it is a variant type) or associated fields (if it is a record type). If no type representation is given, nothing is assumed on the structure of the type besides what is stated in the optional type equation.</source>
          <target state="translated">可选类型表示通过给出相关构造器(如果是变体类型)或相关字段(如果是记录类型)的列表来描述代表定义类型的数据结构。如果没有给出类型表示,除了在可选类型等式中说明的内容外,对类型结构不做任何假设。</target>
        </trans-unit>
        <trans-unit id="c913082fd743d89983385840500d287f715d0b40" translate="yes" xml:space="preserve">
          <source>The order in which the .cmo files are given to ocamlc during the linking phase determines the order in which the module definitions occur. Hence, in the example above, Aux appears first and Main can refer to it, but Aux cannot refer to Main.</source>
          <target state="translated">在链接阶段,将.cmo文件交给ocamlc的顺序决定了模块定义出现的顺序。因此,在上面的例子中,Aux先出现,Main可以引用它,但Aux不能引用Main。</target>
        </trans-unit>
        <trans-unit id="9875c6ba3859a4c01a0b128c6fb6274d60da0369" translate="yes" xml:space="preserve">
          <source>The order in which the bindings are passed to &lt;code&gt;f&lt;/code&gt; is unspecified. However, if the table contains several bindings for the same key, they are passed to &lt;code&gt;f&lt;/code&gt; in reverse order of introduction, that is, the most recent binding is passed first.</source>
          <target state="translated">绑定传递给 &lt;code&gt;f&lt;/code&gt; 的顺序未指定。但是，如果表包含同一键的多个绑定，则会以相反的顺序将它们传递给 &lt;code&gt;f&lt;/code&gt; ，即，最新的绑定会首先传递。</target>
        </trans-unit>
        <trans-unit id="0038d1e71d2d22bcc5fc3fc7481009a2bb18e7e5" translate="yes" xml:space="preserve">
          <source>The order in which the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified.</source>
          <target state="translated">未指定表达式&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;，&lt;a href=&quot;#argument&quot;&gt;参数&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;#argument&quot;&gt;参数&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;的计算顺序。</target>
        </trans-unit>
        <trans-unit id="63c6c1451d4aeaf3a047e06c6ffd102113e24f2b" translate="yes" xml:space="preserve">
          <source>The other caveat is that by default symbolic links are a privileged operation. Administrators will always need to be running elevated (or with UAC disabled) and by default normal user accounts need to be granted the SeCreateSymbolicLinkPrivilege via Local Security Policy (secpol.msc) or via Active Directory.</source>
          <target state="translated">另一个需要注意的是,默认情况下,符号链接是一个特权操作。管理员总是需要在高位运行(或禁用UAC),默认情况下,普通用户账户需要通过本地安全策略(secpol.msc)或活动目录授予SeCreateSymbolicLinkPrivilege。</target>
        </trans-unit>
        <trans-unit id="69042c37de15f706ea13e0d0d27fbaa418b8568a" translate="yes" xml:space="preserve">
          <source>The other form of function definition is introduced by the keyword fun:</source>
          <target state="translated">函数定义的另一种形式是由关键字fun引入的。</target>
        </trans-unit>
        <trans-unit id="9ef7b523167e57b31abccd875bb07306286ad08a" translate="yes" xml:space="preserve">
          <source>The output buffer of a symbolic pretty-printer.</source>
          <target state="translated">符号漂亮打印机的输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="64e2b5efa720054b9f0ac49507c8989cfb0711a0" translate="yes" xml:space="preserve">
          <source>The output elements are included in &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; in the same relative order as the corresponding input elements in &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">输出元件包括在 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 以相同的相对次序在相应的输入元件 &lt;code&gt;l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="197edf84eebbfd7ce0d59bc84a2b213982ad8e53" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a file containing compiled bytecode that can be executed by the OCaml bytecode interpreter: the command named ocamlrun. If a.out is the name of the file produced by the linking phase, the command</source>
          <target state="translated">链接阶段的输出是一个包含编译字节码的文件,可以由OCaml字节码解释器执行:命令名为ocamlrun。如果a.out是链接阶段产生的文件名,那么命令是</target>
        </trans-unit>
        <trans-unit id="f86bd69d544011aefe916eee4af7cd635e073e0c" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a regular Unix or Windows executable file. It does not need ocamlrun to run.</source>
          <target state="translated">链接阶段的输出是一个普通的Unix或Windows可执行文件。它不需要ocamlrun来运行。</target>
        </trans-unit>
        <trans-unit id="3ce0fa21bd7ce51645890738324e05068fce2adc" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1.make&quot;&gt; &lt;code&gt;Ephemeron.K1.Make&lt;/code&gt; &lt;/a&gt;函数Ephemeron.K1.Make和&lt;a href=&quot;ephemeron.k2.make&quot;&gt; &lt;code&gt;Ephemeron.K2.Make&lt;/code&gt; &lt;/a&gt;的输出签名。</target>
        </trans-unit>
        <trans-unit id="5b888b9c1ae97afb61ed88f6dcc91b6356987780" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;. These hash tables are weak in the keys. If all the keys of a binding are alive the binding is kept, but if one of the keys of the binding is dead then the binding is removed.</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1.make&quot;&gt; &lt;code&gt;Ephemeron.K1.Make&lt;/code&gt; &lt;/a&gt;函数Ephemeron.K1.Make和&lt;a href=&quot;ephemeron.k2.make&quot;&gt; &lt;code&gt;Ephemeron.K2.Make&lt;/code&gt; &lt;/a&gt;的输出签名。这些哈希表的键很弱。如果绑定的所有键均处于活动状态，则保留该绑定，但是如果绑定的键之一已失效，则将删除绑定。</target>
        </trans-unit>
        <trans-unit id="6df4d9df08fab00830fd043eb96f7af5ace9c32e" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K1.MakeSeeded&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K2.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1.makeseeded&quot;&gt; &lt;code&gt;Ephemeron.K1.MakeSeeded&lt;/code&gt; &lt;/a&gt;函数Ephemeron.K1.MakeSeeded和&lt;a href=&quot;ephemeron.k2.makeseeded&quot;&gt; &lt;code&gt;Ephemeron.K2.MakeSeeded&lt;/code&gt; &lt;/a&gt;的输出签名。</target>
        </trans-unit>
        <trans-unit id="ebc4f49be3b37069506238985b68b76a704e8a12" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hashtbl.make&quot;&gt; &lt;code&gt;Hashtbl.Make&lt;/code&gt; &lt;/a&gt;函数Hashtbl.Make的输出签名。</target>
        </trans-unit>
        <trans-unit id="acd77c5116baf2558a8ee6e7372f7c8f987c6831" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hashtbl.makeseeded&quot;&gt; &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt;函数Hashtbl.MakeSeeded的输出签名。</target>
        </trans-unit>
        <trans-unit id="4ca70fc1f40276a7d1472b43e23f9229ebf89348" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;morelabels.hashtbl.make&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;morelabels.hashtbl.make&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.Make&lt;/code&gt; &lt;/a&gt;的输出签名。</target>
        </trans-unit>
        <trans-unit id="f416a370c920a779662bea36d75e75022525b518" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;morelabels.hashtbl.makeseeded&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函子&lt;a href=&quot;morelabels.hashtbl.makeseeded&quot;&gt; &lt;code&gt;MoreLabels.Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt;的输出签名。</target>
        </trans-unit>
        <trans-unit id="ffa1e6deb7c02cb5fb60673b1d37d74545f296d4" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;weak.make&quot;&gt;&lt;code&gt;Weak.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;weak.make&quot;&gt; &lt;code&gt;Weak.Make&lt;/code&gt; &lt;/a&gt;函数Weak.Make的输出签名。</target>
        </trans-unit>
        <trans-unit id="235dcfaccc10009cd349c37e2f6b3ea0f93a7b42" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;callstack_size&lt;/code&gt; is the length of the callstack recorded at every sample. Its default is &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;callstack_size&lt;/code&gt; 是每个样本处记录的调用堆栈的长度。其默认值为 &lt;code&gt;max_int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e070830e786df33101debf41e042d4603dc7e8c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;sampling_rate&lt;/code&gt; is the sampling rate in samples per word (including headers). Usually, with cheap callbacks, a rate of 1e-4 has no visible effect on performance, and 1e-3 causes the program to run a few percent slower</source>
          <target state="translated">参数 &lt;code&gt;sampling_rate&lt;/code&gt; 是每个单词（包括标题）中以样本为单位的采样率。通常，在便宜的回调中，速率1e-4对性能没有明显影响，而1e-3会使程序运行慢百分之几</target>
        </trans-unit>
        <trans-unit id="49970203f15065fd920f5133460488f7c2c20b5b" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;tracker&lt;/code&gt; determines how to track sampled blocks over their lifetime in the minor and major heap.</source>
          <target state="translated">参数 &lt;code&gt;tracker&lt;/code&gt; 确定如何在次堆和主堆中跟踪采样块的整个生命周期。</target>
        </trans-unit>
        <trans-unit id="09fbb96897f07cf55eb54e9bcb8824b504ac0830" translate="yes" xml:space="preserve">
          <source>The parameter patterns ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]) are shorthands for respectively ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]), and similarly for their optional counterparts.</source>
          <target state="translated">该参数模式〜&lt;a href=&quot;lex#label-name&quot;&gt;实验室&lt;/a&gt;和〜（&lt;a href=&quot;lex#label-name&quot;&gt;实验室&lt;/a&gt;[：&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;]）分别是用于速记〜&lt;a href=&quot;lex#label-name&quot;&gt;实验室&lt;/a&gt;：&lt;a href=&quot;lex#label-name&quot;&gt;实验室&lt;/a&gt;和〜&lt;a href=&quot;lex#label-name&quot;&gt;实验室&lt;/a&gt;:(&lt;a href=&quot;lex#label-name&quot;&gt;实验室&lt;/a&gt;[：&lt;a href=&quot;types#typexpr&quot;&gt;典型值&lt;/a&gt;]），并且类似地为他们的任选的对应物。</target>
        </trans-unit>
        <trans-unit id="1e5974a12a7d51f44c9175604dd69a6dc4db175f" translate="yes" xml:space="preserve">
          <source>The parameter x_init is, of course, visible in the whole body of the definition, including methods. For instance, the method get_offset in the class below returns the position of the object relative to its initial position.</source>
          <target state="translated">当然,x_init这个参数在整个定义的主体中是可见的,包括方法。例如,下面类中的方法get_offset返回对象相对于其初始位置的位置。</target>
        </trans-unit>
        <trans-unit id="e95fd7cf7f4ba7d41d47acfb96f75946ad23cd79" translate="yes" xml:space="preserve">
          <source>The parser also enters error recovery mode if one of the grammar actions raises the Parsing.Parse_error exception.</source>
          <target state="translated">如果其中一个语法动作引发了Parsing.Parsse_error异常,解析器也会进入错误恢复模式。</target>
        </trans-unit>
        <trans-unit id="34d65af266245e845378220e5a545186f7764e3e" translate="yes" xml:space="preserve">
          <source>The pass analyses functions to determine which arguments are unused. Removal is effected by creating a wrapper function, which will be inlined at every direct call site, that accepts the original arguments and then discards the unused ones before calling the original function. As a consequence, this transformation may be detrimental if the original function is usually indirectly called, since such calls will now bounce through the wrapper. (The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used to reduce this penalty during unboxing of closure variables (see above) does not yet apply to the pass that removes unused arguments.)</source>
          <target state="translated">通过分析功能以确定未使用哪些参数。删除是通过创建包装函数来实现的，该包装函数将在每个直接调用站点处内联，该包装函数接受原始参数，然后在调用原始函数之前丢弃未使用的参数。结果，如果通常间接调用原始函数，则这种转换可能是有害的，因为这样的调用现在将通过包装器反弹。 （用于取消闭合变量装箱（参见上文）期间用于减少此代价的&lt;em&gt;直接调用代理&lt;/em&gt;技术尚未应用于删除未使用的参数的传递。）</target>
        </trans-unit>
        <trans-unit id="ddb1f22a5bac6d00f359ad560b86fb3d4abcbdd7" translate="yes" xml:space="preserve">
          <source>The pattern 'c'..'d' is a shorthand for the pattern</source>
          <target state="translated">'c'...'d'模式是模式的速记。</target>
        </trans-unit>
        <trans-unit id="78a9eb434825f2c323017a519a3d60fa9f698c76" translate="yes" xml:space="preserve">
          <source>The pattern (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. A type constraint can appear in a parenthesized pattern, as in (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">的图案（&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;）相同的值相匹配的&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。类型约束可以出现在带括号的模式中，如（&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;）。该约束迫使&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;的类型与&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;兼容。</target>
        </trans-unit>
        <trans-unit id="16ae7f98de1b36c58b45270ed0fb02b7e9c6764a" translate="yes" xml:space="preserve">
          <source>The pattern (module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) matches a package with type &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; and binds it to &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;. It is not allowed in toplevel let bindings. Again &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; can be omitted if it can be inferred from the enclosing pattern.</source>
          <target state="translated">模式（模块&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;：&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;）将类型为&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;的包与之匹配，并将其绑定到&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;。顶级let绑定中不允许这样做。同样，如果可以从封装模式中推断出&lt;a href=&quot;#package-type&quot;&gt;package-type，则&lt;/a&gt;可以将其省略。</target>
        </trans-unit>
        <trans-unit id="f60d5e8c331afa9fe8e1e6db86c21aacdc85acef" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; matches n-tuples whose components match the patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. That is, the pattern matches the tuple values (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, v&lt;sub&gt;n&lt;/sub&gt;) such that &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches v&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n.</source>
          <target state="translated">模式&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;匹配n个元组，其元组与模式&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;到&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;相匹配。也就是说，模式与元组值（v &lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，v &lt;sub&gt;n&lt;/sub&gt;）相匹配，使得&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;与i = 1，&amp;hellip;，n的vi &lt;sub&gt;i&lt;/sub&gt;相匹配。</target>
        </trans-unit>
        <trans-unit id="f6da6c23d8212831014d6c0f7d9fd644913b7199" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; matches non-empty lists whose heads match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, and whose tails match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">模式&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ::&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;匹配其头部与&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;匹配且其尾部与&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;匹配的非空列表。</target>
        </trans-unit>
        <trans-unit id="41348db0bf142801b4dc26e958764633a28f85d6" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;as&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. If the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is successful, the name &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; is bound to the matched value, in addition to the bindings performed by the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">图案&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;作为&lt;a href=&quot;names#value-name&quot;&gt;值名称&lt;/a&gt;相同的值相匹配的&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;。如果对&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;的匹配成功，则除了对&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;的匹配执行的绑定之外，还将名称&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;绑定到匹配的值。&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="cdceda5e76dc99dff62cfbffd34932860bd8932c" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; represents the logical &amp;ldquo;or&amp;rdquo; of the two patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. A value matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if it matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; or &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The two sub-patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must bind exactly the same identifiers to values having the same types. Matching is performed from left to right. More precisely, in case some value &amp;zwj;v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, the bindings performed are those of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; when v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. Otherwise, value &amp;zwj;v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; whose bindings are performed.</source>
          <target state="translated">图案&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; |&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;表示逻辑&amp;ldquo;或&amp;rdquo;的两个图案的&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。值匹配&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; |&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2（&lt;/sub&gt;如果它与&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;或&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;相匹配）。两个子模式&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;必须将完全相同的标识符绑定到具有相同类型的值。匹配从左到右执行。更确切地说，如果某些值&amp;zwj;v匹配&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; |&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;，当v匹配&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;时，执行的绑定是&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;的绑定。否则，值&amp;zwj;v与执行绑定的&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;匹配。&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9299c9cb5135cc2b4bedfa03f575390c8ead0e50" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; represents the logical &amp;ldquo;or&amp;rdquo; of the two patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. A value matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if it matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; or &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The two sub-patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must bind exactly the same identifiers to values having the same types. Matching is performed from left to right. More precisely, in case some value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, the bindings performed are those of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; when v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. Otherwise, value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; whose bindings are performed.</source>
          <target state="translated">图案&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; |&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;表示逻辑&amp;ldquo;或&amp;rdquo;的两个图案的&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。值匹配&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; |&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2（&lt;/sub&gt;如果它与&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;或&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;相匹配）。两个子模式&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;和&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;必须将完全相同的标识符绑定到具有相同类型的值。匹配从左到右执行。更准确地说，如果某个值v匹配&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; |&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;，当v匹配&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;时，执行的绑定是&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;的绑定。否则，值v匹配执行绑定的&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;。&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="00b0db5a51b1f1d5c7c59b426eaf70572b94fa7f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) matches all variants whose constructor is equal to &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. It is a type error if n is not the number of arguments expected by the constructor.</source>
          <target state="translated">模式&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;（&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;，&amp;hellip;，&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;）匹配其构造函数等于&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;且其参数匹配&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;n的&lt;/sub&gt;所有变量。如果n不是构造函数期望的参数数量，则是类型错误。</target>
        </trans-unit>
        <trans-unit id="d790d4519563bbe23e283cddeb381557179c1ed8" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;_ matches all variants whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;.</source>
          <target state="translated">模式&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; _匹配其构造函数为&lt;a href=&quot;names#constr&quot;&gt;constr的&lt;/a&gt;所有变体。</target>
        </trans-unit>
        <trans-unit id="3c4b162c77607f7f0c96e87989be66403257ce86" translate="yes" xml:space="preserve">
          <source>The pattern [&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] matches lists of length n whose elements match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, respectively. This pattern behaves like &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:: &amp;hellip; ::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;::[].</source>
          <target state="translated">模式[&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;；&lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]匹配长度为n的列表，其元素分别与&lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;相匹配。此模式的行为类似于&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ::&amp;hellip;::&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; :: []。</target>
        </trans-unit>
        <trans-unit id="5be2296eeedc0ad28df110fb34fef15f60597b6f" translate="yes" xml:space="preserve">
          <source>The pattern [|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] matches arrays of length n such that the i-th array element matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n.</source>
          <target state="translated">模式[| &lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;；&lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; |]匹配长度为n的数组，使得第i个数组元素与pattern &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;匹配，对于i = 1，&amp;hellip;，n。</target>
        </trans-unit>
        <trans-unit id="1788df79d59202a4d26aad006675bcfb219b3e5f" translate="yes" xml:space="preserve">
          <source>The pattern `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; matches all polymorphic variants whose tag is equal to &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">模式` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;匹配其tag等于&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;且其参数匹配&lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1的&lt;/sub&gt;所有多态变体。</target>
        </trans-unit>
        <trans-unit id="d78189bca7a2a4a7c7d4b24d2ca0b9ace362515e" translate="yes" xml:space="preserve">
          <source>The pattern lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches a value v of type Lazy.t, provided &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches the result of forcing v with Lazy.force. A successful match of a pattern containing lazy sub-patterns forces the corresponding parts of the value being matched, even those that imply no test such as lazy&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; or lazy_. Matching a value with a &lt;a href=&quot;expr#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt; where some patterns contain lazy sub-patterns may imply forcing parts of the value, even when the pattern selected in the end has no lazy sub-pattern.</source>
          <target state="translated">模式惰性&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;与Lazy.t类型的值v匹配，前提是&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;与对Lazy.force强制v的结果匹配。包含惰性子模式的模式的成功匹配将强制匹配值的相应部分，即使是那些没有测试的内容，例如惰性&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;或lazy_。将值与某些模式包含惰性子模式的&lt;a href=&quot;expr#pattern-matching&quot;&gt;模式匹配进行匹配&lt;/a&gt;可能意味着强制值的一部分，即使最后选择的模式没有惰性子模式也是如此。</target>
        </trans-unit>
        <trans-unit id="16f7adce7fddea3b9b8f86106681f2bc5fc82ba6" translate="yes" xml:space="preserve">
          <source>The pattern {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } matches records that define at least the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and such that the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; , and a single qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; . The record value can define more fields than &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;; the values associated to these extra fields are not taken into account for matching. Optionally, a record pattern can be terminated by ;_ to convey the fact that not all fields of the record type are listed in the record pattern and that it is intentional. Optional type constraints can be added field by field with {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="translated">模式{&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]； &amp;hellip;；&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt; ]}匹配至少定义字段的记录&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;通过&lt;a href=&quot;names#field&quot;&gt;场&lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt;，并且使得相关联的值来&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;我&lt;/sub&gt;的模式匹配，&lt;a href=&quot;#pattern&quot;&gt;图案&lt;/a&gt;&lt;sub&gt;我&lt;/sub&gt;，对于i = 1，...，N。单个标识符&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;代表&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;，而单个合格标识符&lt;a href=&quot;names#module-path&quot;&gt;模块path&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;代表&lt;a href=&quot;names#module-path&quot;&gt;模块路径&lt;/a&gt;。&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; =&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;。记录值可以定义的字段比&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;n多&lt;/sub&gt;；与这些额外字段相​​关联的值不考虑匹配。可选地，记录模式可以用; _终止，以传达以下事实：并非所有记录类型的字段都在记录模式中列出，并且这是有意的。可以通过{&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; =&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ;&amp;hellip;;来逐字段添加可选的类型约束。&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;：&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; =&lt;a href=&quot;#pattern&quot;&gt;模式&lt;/a&gt;&lt;sub&gt;&amp;Ntilde;&lt;/sub&gt; }强制的类型&lt;a href=&quot;names#field&quot;&gt;字段&lt;/a&gt;&lt;sub&gt;ķ&lt;/sub&gt;为与兼容&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;ķ&lt;/sub&gt;。</target>
        </trans-unit>
        <trans-unit id="28c11f2884ea2e751e90db06b713059bf8743ce8" translate="yes" xml:space="preserve">
          <source>The pointer returned by caml_named_value is constant and can safely be cached in a C variable to avoid repeated name lookups. The value pointed to cannot be changed from C. However, it might change during garbage collection, so must always be recomputed at the point of use. Here is a more efficient variant of call_caml_f above that calls caml_named_value only once:</source>
          <target state="translated">caml_named_value返回的指针是常数,可以安全地缓存在C变量中,以避免重复查找名称。然而,在垃圾回收过程中,它可能会改变,所以必须在使用时重新计算。这里是上面call_caml_f的一个更有效的变体,它只调用caml_named_value一次。</target>
        </trans-unit>
        <trans-unit id="32e4ea607d04ac6fcfc5da2a4f99be29eb749147" translate="yes" xml:space="preserve">
          <source>The policy used for allocating in the major heap. Possible values are 0, 1 and 2.</source>
          <target state="translated">用于在主堆中分配的策略。可能的值是0、1和2。</target>
        </trans-unit>
        <trans-unit id="a0575e3a19290f6df5fdcaa47a106f8449112455" translate="yes" xml:space="preserve">
          <source>The polymorphic hash functions</source>
          <target state="translated">多态哈希函数</target>
        </trans-unit>
        <trans-unit id="10931e6e8e695da4d6f07c1443d2547e5cf128cc" translate="yes" xml:space="preserve">
          <source>The polymorphism may be left implicit in public method specifications: any type variable which is not bound to a class parameter and does not appear elsewhere inside the class specification will be assumed to be universal, and made polymorphic in the resulting method type. Writing an explicit polymorphic type will disable this behaviour.</source>
          <target state="translated">多态性可以隐含在公共方法规范中:任何没有绑定到类参数的类型变量以及没有出现在类规范中的其他地方的类型变量都将被假定为是通用的,并在产生的方法类型中成为多态的。编写一个显式的多态类型将使这种行为失效。</target>
        </trans-unit>
        <trans-unit id="46f55cdbce1c396ddb68caad025838e2c114c305" translate="yes" xml:space="preserve">
          <source>The precedence declarations are used in the following way to resolve reduce/reduce and shift/reduce conflicts:</source>
          <target state="translated">优先级声明的使用方法如下,以解决reduce/reduce和shift/reduce冲突。</target>
        </trans-unit>
        <trans-unit id="1442484d01949a40882f7fd1198334b88701ef0b" translate="yes" xml:space="preserve">
          <source>The pretty-printer must split the line at this point,</source>
          <target state="translated">此时,漂亮的打印机必须分线。</target>
        </trans-unit>
        <trans-unit id="e659673f1b18fb1d82b63a1c55173f87e4ba3218" translate="yes" xml:space="preserve">
          <source>The pretty-printing engine uses the concepts of pretty-printing box and break hint to drive indentation and line splitting behavior of the pretty-printer.</source>
          <target state="translated">漂亮打印引擎使用漂亮打印框和断点提示的概念来驱动漂亮打印机的缩进和分线行为。</target>
        </trans-unit>
        <trans-unit id="a53dbcb487f74a0958c713e69a144733631dbfe2" translate="yes" xml:space="preserve">
          <source>The pretty-printing functions output material that is delayed in the pretty-printer queue and stacks in order to compute proper line splitting. In contrast, basic I/O output functions write directly in their output device. As a consequence, the output of a basic I/O function may appear before the output of a pretty-printing function that has been called before. For instance, &lt;code&gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;lt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;PRETTY&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;gt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;TEXT&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt; leads to output &lt;code&gt;&amp;lt;&amp;gt;PRETTYTEXT&lt;/code&gt;.</source>
          <target state="translated">漂亮打印功能输出在漂亮打印机队列中延迟并堆叠的材料，以便计算适当的行拆分。相反，基本的I / O输出功能直接在其输出设备中写入。结果，基本I / O功能的输出可能出现在之前已调用的漂亮打印功能的输出之前。例如， &lt;code&gt;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;lt;&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;PRETTY&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;gt;&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;TEXT&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt; 导致输出 &lt;code&gt;&amp;lt;&amp;gt;PRETTYTEXT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f51978ff177538bd6acc10bb07871f9792c046ef" translate="yes" xml:space="preserve">
          <source>The pretty-printing indication characters are introduced by a &lt;code&gt;@&lt;/code&gt; character, and their meanings are:</source>
          <target state="translated">印刷精美的指示字符由 &lt;code&gt;@&lt;/code&gt; 字符引入，它们的含义是：</target>
        </trans-unit>
        <trans-unit id="433dda59f28a1c16b7f6ad751b61d21f14015c15" translate="yes" xml:space="preserve">
          <source>The previous coercion problem can often be avoided by first defining the abbreviation, using a class type:</source>
          <target state="translated">通常可以通过先定义缩写,使用类类型来避免前面的胁迫问题。</target>
        </trans-unit>
        <trans-unit id="cb0dbd05eb51d23e1a522b80e905369b8eb83ac6" translate="yes" xml:space="preserve">
          <source>The printing function printer-name should have type Format.formatter-&amp;gt;t-&amp;gt;unit, where t is the type for the values to be printed, and should output its textual representation for the value of type t on the given formatter, using the functions provided by the Format library. For backward compatibility, printer-name can also have type t-&amp;gt;unit and should then output on the standard formatter, but this usage is deprecated.</source>
          <target state="translated">打印功能printer-name的类型应为Format.formatter-&amp;gt; t-&amp;gt; unit，其中t是要打印的值的类型，并应使用给定格式器在类型为t的值上输出其文本表示形式。格式库提供的功能。为了向后兼容，打印机名称也可以具有类型t-&amp;gt; unit，然后应在标准格式器上输出，但不建议使用此用法。</target>
        </trans-unit>
        <trans-unit id="8883bf4f143303eb37a391cfe05fa314bafceca6" translate="yes" xml:space="preserve">
          <source>The problem here is that SET specifies the type element abstractly, so that the type equality between element in the result of the functor and t in its argument is forgotten. Consequently, WrongStringSet.element is not the same type as string, and the operations of WrongStringSet cannot be applied to strings. As demonstrated above, it is important that the type element in the signature SET be declared equal to Elt.t; unfortunately, this is impossible above since SET is defined in a context where Elt does not exist. To overcome this difficulty, OCaml provides a with type construct over signatures that allows enriching a signature with extra type equalities:</source>
          <target state="translated">这里的问题是,SET抽象地指定了元素的类型,因此忘记了漏子结果中的元素和其参数中的t之间的类型平等。因此,WrongStringSet.element与字符串的类型不一样,WrongStringSet的操作不能应用于字符串。如上所示,重要的是签名SET中的类型元素被声明等于Elt.t;不幸的是,这在上面是不可能的,因为SET是在Elt不存在的上下文中定义的。为了克服这个困难,OCaml在签名上提供了一个with类型构造,允许用额外的类型等价来丰富签名。</target>
        </trans-unit>
        <trans-unit id="79d5207edef86d719b23b481fee7c2e0aa2b94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that quantification was wrongly located: it is not the class we want to be polymorphic, but the fold method. This can be achieved by giving an explicitly polymorphic type in the method definition.</source>
          <target state="translated">这里的问题是量化的定位错误:我们要多态的不是类,而是折叠方法。这可以通过在方法定义中给出一个明确的多态类型来实现。</target>
        </trans-unit>
        <trans-unit id="d28eba679c98023f0747aaf9581f0f01fc941cfe" translate="yes" xml:space="preserve">
          <source>The process terminated normally by &lt;code&gt;exit&lt;/code&gt;; the argument is the return code.</source>
          <target state="translated">该过程通常通过 &lt;code&gt;exit&lt;/code&gt; 而终止；参数是返回码。</target>
        </trans-unit>
        <trans-unit id="168ecaee8748c10e62b8f47e3dcea6c8cbd65579" translate="yes" xml:space="preserve">
          <source>The process was killed by a signal; the argument is the signal number.</source>
          <target state="translated">进程被信号杀死,参数为信号号。</target>
        </trans-unit>
        <trans-unit id="34eaa6addd6d491cf217fc8965c116ada2b0beed" translate="yes" xml:space="preserve">
          <source>The process was stopped by a signal; the argument is the signal number.</source>
          <target state="translated">进程被一个信号停止,参数是信号号。</target>
        </trans-unit>
        <trans-unit id="c048c9cffeb4593d3904a5383fdb63616e02e942" translate="yes" xml:space="preserve">
          <source>The produced file has the executable bit set, and it manages to launch the bytecode interpreter by itself.</source>
          <target state="translated">生成的文件有可执行位设置,它能自己启动字节码解释器。</target>
        </trans-unit>
        <trans-unit id="5147f68b7fbbbd5f93868579353c15f80510e07f" translate="yes" xml:space="preserve">
          <source>The program behaves exactly as if the following phrases were entered at top-level:</source>
          <target state="translated">该程序的行为与在顶层输入以下短语的情况完全相同。</target>
        </trans-unit>
        <trans-unit id="7f6811b8d125d2cdaaeacc0a56ba7fbf8a7e5194" translate="yes" xml:space="preserve">
          <source>The program being executed contains a &amp;ldquo;stray&amp;rdquo; exception. That is, it raises an exception at some point, and this exception is never caught. This causes immediate termination of the program. The name of the exception is printed, along with its string, byte sequence, and integer arguments (arguments of more complex types are not correctly printed). To locate the context of the uncaught exception, compile the program with the -g option and either run it again under the ocamldebug debugger (see chapter &amp;zwj;&lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;16&lt;/a&gt;), or run it with ocamlrun -b or with the OCAMLRUNPARAM environment variable set to b=1.</source>
          <target state="translated">正在执行的程序包含&amp;ldquo;杂散&amp;rdquo;异常。也就是说，它在某个时刻引发了异常，并且从未捕获到该异常。这将导致程序立即终止。将打印异常的名称以及其字符串，字节序列和整数参数（无法正确打印更复杂类型的参数）。要找到未捕获的异常的情况下，编译程序用-g选项并且或者ocamldebug调试器下再次运行（见章节&lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;16&lt;/a&gt;），或与运行它ocamlrun -b或与OCAMLRUNPARAM环境变量设置为B = 1。</target>
        </trans-unit>
        <trans-unit id="f484a5296a71c426225e4ed54accc59929e24d8b" translate="yes" xml:space="preserve">
          <source>The program being executed contains a &amp;ldquo;stray&amp;rdquo; exception. That is, it raises an exception at some point, and this exception is never caught. This causes immediate termination of the program. The name of the exception is printed, along with its string, byte sequence, and integer arguments (arguments of more complex types are not correctly printed). To locate the context of the uncaught exception, compile the program with the -g option and either run it again under the ocamldebug debugger (see chapter &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;), or run it with ocamlrun -b or with the OCAMLRUNPARAM environment variable set to b=1.</source>
          <target state="translated">正在执行的程序包含&amp;ldquo;杂散&amp;rdquo;异常。也就是说，它在某个时刻引发了异常，并且从未捕获到该异常。这将导致程序立即终止。将打印异常的名称以及其字符串，字节序列和整数参数（无法正确打印更复杂类型的参数）。要找到未捕获异常的上下文，请使用-g选项编译程序，然后在ocamldebug调试器（请参见第&lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;章）下再次运行该程序，或者使用ocamlrun -b或将OCAMLRUNPARAM环境变量设置为b = 1来运行该程序。 。</target>
        </trans-unit>
        <trans-unit id="b266af3c49a1ad66480fec482895593ef57dff7e" translate="yes" xml:space="preserve">
          <source>The program being executed requires more memory than available. Either the program builds excessively large data structures; or the program contains too many nested function calls, and the stack overflows. In some cases, your program is perfectly correct, it just requires more memory than your machine provides. In other cases, the &amp;ldquo;out of memory&amp;rdquo; message reveals an error in your program: non-terminating recursive function, allocation of an excessively large array, string or byte sequence, attempts to build an infinite list or other data structure, &amp;hellip;</source>
          <target state="translated">正在执行的程序需要更多的内存。该程序将构建过大的数据结构。或程序包含太多的嵌套函数调用，并且堆栈溢出。在某些情况下，您的程序是完全正确的，只需要比计算机提供的内存更多的内存即可。在其他情况下，&amp;ldquo;内存不足&amp;rdquo;消息表明您的程序中存在错误：非终止递归函数，分配了太大的数组，字符串或字节序列，试图建立无限列表或其他数据结构，&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a503f7e4a9e093239bc1734598a0ac0302624fc9" translate="yes" xml:space="preserve">
          <source>The program being profiled must exit normally or be caused to exit using the SIGINT signal (e.g. by pressing Ctrl+C). When the program exits files will be written in the directory that was the working directory when the program was started. One Spacetime file will be written for each process that was involved, indexed by process ID; there will normally only be one such. The Spacetime files may be substantial. The directory to which they are written may be overridden by setting the OCAML_SPACETIME_SNAPSHOT_DIR environment variable before the program is started.</source>
          <target state="translated">被剖析的程序必须正常退出或使用SIGINT信号(如按Ctrl+C)使其退出。当程序退出时,文件将被写入程序启动时的工作目录中。每个参与的进程都会被写入一个Spacetime文件,以进程ID为索引;通常只有一个这样的文件。Spacetime文件可能很大。在程序启动前,可以通过设置OCML_SPACETIME_SNAPSHOT_DIR环境变量来覆盖写入的目录。</target>
        </trans-unit>
        <trans-unit id="3cc4a8046bc314aed242125f697f2a900a2c88e8" translate="yes" xml:space="preserve">
          <source>The program is run directly by the debugger. This is the default mode.</source>
          <target state="translated">程序直接由调试器运行。这是默认模式。</target>
        </trans-unit>
        <trans-unit id="869eb5aeb2fdd87b2a28ba89f60a8c2af784a6d6" translate="yes" xml:space="preserve">
          <source>The program will have to start event collection explicitly. Starting and stopping event collection programmatically can be done by calling Gc.eventlog_resume and Gc.eventlog_pause) from within the program. Refer to the &lt;a href=&quot;libref/gc&quot;&gt;Gc&lt;/a&gt; module documentation for more information.</source>
          <target state="translated">该程序将必须显式启动事件收集。可以通过在程序中调用Gc.eventlog_resume和Gc.eventlog_pause来以编程方式启动和停止事件收集。有关更多信息，请参考&lt;a href=&quot;libref/gc&quot;&gt;Gc&lt;/a&gt;模块文档。</target>
        </trans-unit>
        <trans-unit id="07c2399b10db28be424b9d95192597cf13943884" translate="yes" xml:space="preserve">
          <source>The projections from p may be replaced by uses of the variables x and y, potentially meaning that p becomes unused.</source>
          <target state="translated">从p出发的投影可能会被变量x和y的使用所取代,这可能意味着p成为未使用的变量。</target>
        </trans-unit>
        <trans-unit id="0e07f245bb0c49e7a50bc84525e1cacf4689e631" translate="yes" xml:space="preserve">
          <source>The propagation can help to eliminate allocations in cases such as:</source>
          <target state="translated">传播可以帮助消除分配的情况,如。</target>
        </trans-unit>
        <trans-unit id="f79e766e028d6e095da9d529d5a9dfbe0498d920" translate="yes" xml:space="preserve">
          <source>The propagation performed by the simplification pass is also important for discovering which functions flow to indirect call sites. This can enable the transformation of such call sites into direct call sites, which makes them eligible for an inlining transformation.</source>
          <target state="translated">简化传递所进行的传播对于发现哪些函数流向间接调用站点也很重要。这可以使这些调用站点转化为直接调用站点,从而使它们有资格进行内联转化。</target>
        </trans-unit>
        <trans-unit id="94c9da3eb2e38629000eda75e07fe34fd5562fd6" translate="yes" xml:space="preserve">
          <source>The reason for the error: unknown option, invalid or missing argument, etc.</source>
          <target state="translated">错误原因:未知选项、无效或缺少参数等。</target>
        </trans-unit>
        <trans-unit id="a43dbd7b9edc2247945720db7869546aded72b86" translate="yes" xml:space="preserve">
          <source>The reason is that at least one of the methods has a polymorphic type (here, the type of the value stored in the reference cell), thus either the class should be parametric, or the method type should be constrained to a monomorphic type. A monomorphic instance of the class could be defined by:</source>
          <target state="translated">原因是,至少有一个方法具有多态类型(这里是指存储在引用单元格中的值的类型),因此,要么这个类应该是参数化的,要么方法类型应该被约束为单态类型。类的单态实例可以通过以下方式来定义。</target>
        </trans-unit>
        <trans-unit id="072461fde3d0d8b6efbc5a6868695ccf66c6f021" translate="yes" xml:space="preserve">
          <source>The reason this is unsafe is because the simplification pass believes that fst a holds the value 42; and indeed it must, unless type soundness has been broken via unsafe operations.</source>
          <target state="translated">这是不安全的,因为简化通证认为fst a持有42的值;事实上它必须持有,除非通过不安全的操作破坏了类型健全性。</target>
        </trans-unit>
        <trans-unit id="c67a48b57781f36d335583c6c3fd5c675bbebd44" translate="yes" xml:space="preserve">
          <source>The recursive definition is guaranteed to behave as described above if the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are function definitions (fun &amp;hellip; or function &amp;hellip;), and the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are just value names, as in:</source>
          <target state="translated">如果表达式&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;至&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;是函数定义（fun&amp;hellip;或function&amp;hellip;），而模式&lt;a href=&quot;patterns#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;只是值名称，则保证递归定义的行为如上所述，例如：</target>
        </trans-unit>
        <trans-unit id="21a0eac9c2ffe7244b1f04ef0b56b0358674bc2b" translate="yes" xml:space="preserve">
          <source>The registration causes the contents of the variable or memory location to be updated by the garbage collector whenever the value in such variable or location is moved within the OCaml heap. In the presence of threads care must be taken to ensure appropriate synchronisation with the OCaml runtime to avoid a race condition against the garbage collector when reading or writing the value. (See section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;18.12.2&lt;/a&gt;.)</source>
          <target state="translated">每当在OCaml堆中移动变量或内存位置中的值时，注册都会使垃圾回收器更新变量或内存位置的内容。在存在线程的情况下，必须注意确保与OCaml运行时的适当同步，以避免在读取或写入值时与垃圾回收器发生竞争。（请参阅第&lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;18.12.2&lt;/a&gt;节。）</target>
        </trans-unit>
        <trans-unit id="be50e5ba6751e078d213ea17d81f37abaeae3a78" translate="yes" xml:space="preserve">
          <source>The registration causes the contents of the variable or memory location to be updated by the garbage collector whenever the value in such variable or location is moved within the OCaml heap. In the presence of threads care must be taken to ensure appropriate synchronisation with the OCaml runtime to avoid a race condition against the garbage collector when reading or writing the value. (See section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;.)</source>
          <target state="translated">每当在OCaml堆中移动变量或内存位置中的值时，注册都会使垃圾回收器更新变量或内存位置的内容。在存在线程的情况下，必须注意确保与OCaml运行时进行适当的同步，以避免在读取或写入值时与垃圾回收器发生竞争。 （请参见&lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;节。）</target>
        </trans-unit>
        <trans-unit id="e498792eb5a8e5a1f7711c5d76148d563e2627fe" translate="yes" xml:space="preserve">
          <source>The registration mechanism described above can also be used to communicate exception identifiers from OCaml to C. The OCaml code registers the exception by evaluating Callback.register_exceptionn exn, where n is an arbitrary name and exn is an exception value of the exception to register. For example:</source>
          <target state="translated">上面描述的注册机制也可以用来将异常标识符从OCaml传达给C,OCaml代码通过评估Callback.register_exceptionn exn来注册异常,其中n是一个任意的名称,exn是要注册的异常值。例如</target>
        </trans-unit>
        <trans-unit id="7e412ad57efe185f94f3f66dee663594387b73ec" translate="yes" xml:space="preserve">
          <source>The regular expressions are in the style of lex, with a more OCaml-like syntax.</source>
          <target state="translated">正则表达式采用lex的风格,语法更像OCaml。</target>
        </trans-unit>
        <trans-unit id="ca763eb3bdb448bf22bb32fc59cd71ec5db35a9f" translate="yes" xml:space="preserve">
          <source>The representation is chosen according to the following, in decreasing order of priority:</source>
          <target state="translated">按以下优先顺序选择代表:</target>
        </trans-unit>
        <trans-unit id="6cb9b87429c5694aec26392deb0ded32f7bf6b82" translate="yes" xml:space="preserve">
          <source>The representation of marshaled values is not human-readable, and uses bytes that are not printable characters. Therefore, input and output channels used in conjunction with &lt;code&gt;Marshal.to_channel&lt;/code&gt; and &lt;code&gt;Marshal.from_channel&lt;/code&gt; must be opened in binary mode, using e.g. &lt;code&gt;open_out_bin&lt;/code&gt; or &lt;code&gt;open_in_bin&lt;/code&gt;; channels opened in text mode will cause unmarshaling errors on platforms where text channels behave differently than binary channels, e.g. Windows.</source>
          <target state="translated">封送值的表示方式不是人类可读的，并且使用了不可打印字符的字节。因此，与 &lt;code&gt;Marshal.to_channel&lt;/code&gt; 和 &lt;code&gt;Marshal.from_channel&lt;/code&gt; 结合使用的输入和输出通道必须以二进制模式打开，例如使用 &lt;code&gt;open_out_bin&lt;/code&gt; 或 &lt;code&gt;open_in_bin&lt;/code&gt; ; 在文本通道的行为与二进制通道不同的平台（例如Windows）上，以文本模式打开的通道会导致编组错误。</target>
        </trans-unit>
        <trans-unit id="b30fdf8a2c0fb75299c4dafd61caaf7a19cc1857" translate="yes" xml:space="preserve">
          <source>The rest of the binding is the same for both platforms:</source>
          <target state="translated">其余的绑定在两个平台上是一样的。</target>
        </trans-unit>
        <trans-unit id="44c9e601546b4f760808bdd19852d33ad5355c07" translate="yes" xml:space="preserve">
          <source>The restriction can also be performed during the definition of the structure, as in</source>
          <target state="translated">限制也可以在定义结构时进行,如</target>
        </trans-unit>
        <trans-unit id="dc0357393d60a0f1fa7baa5274ba71a46d90f408" translate="yes" xml:space="preserve">
          <source>The resulting P.cmx object file has sub-modules P.Q, P.Q.A and P.B.</source>
          <target state="translated">生成的P.cmx对象文件有子模块P.Q、P.Q.A和P.B。</target>
        </trans-unit>
        <trans-unit id="540f70e6d81a40f7974a7c5702a14ef36eff5dc8" translate="yes" xml:space="preserve">
          <source>The resulting benefit value is known as the &lt;em&gt;estimated benefit&lt;/em&gt;.</source>
          <target state="translated">产生的收益值称为&lt;em&gt;估计收益&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f24d01c073b212c7b11b8ff5380c3e1f163e921d" translate="yes" xml:space="preserve">
          <source>The resulting program can then be traced by running it with the environment variable OCAML_EVENTLOG_ENABLED:</source>
          <target state="translated">然后可以通过运行环境变量OCML_EVENTLOG_ENABLED来跟踪生成的程序。</target>
        </trans-unit>
        <trans-unit id="0936bfa6fa4fa6c80130298ea1d5af175d858507" translate="yes" xml:space="preserve">
          <source>The resulting trace contains only one event payload, namely a &lt;em&gt;flush&lt;/em&gt; event, indicating how much time was spent flushing the trace file to disk.</source>
          <target state="translated">生成的跟踪仅包含一个事件有效负载，即&lt;em&gt;刷新&lt;/em&gt;事件，指示花了多少时间将跟踪文件刷新到磁盘。</target>
        </trans-unit>
        <trans-unit id="5ed3a555a7ebebf96c3208ad39f845704f68067a" translate="yes" xml:space="preserve">
          <source>The resulting trace will contain all events encountered during the program&amp;rsquo;s execution:</source>
          <target state="translated">结果跟踪将包含程序执行期间遇到的所有事件：</target>
        </trans-unit>
        <trans-unit id="76a2e5fedee04aeb14150359846ceeb930560151" translate="yes" xml:space="preserve">
          <source>The results of calling &lt;a href=&quot;string#VALmake&quot;&gt;&lt;code&gt;String.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALmake&quot;&gt;&lt;code&gt;Bytes.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;stdlib#VALref&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; are guaranteed to be heap-allocated and non-constant except when the length argument is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;bytes#VALmake&quot;&gt; &lt;code&gt;Bytes.make&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&quot;string#VALmake&quot;&gt; &lt;code&gt;String.make&lt;/code&gt; &lt;/a&gt;，Bytes.make，&lt;a href=&quot;bytes#VALcreate&quot;&gt; &lt;code&gt;Bytes.create&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;array#VALmake&quot;&gt; &lt;code&gt;Array.make&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;stdlib#VALref&quot;&gt; &lt;code&gt;ref&lt;/code&gt; 的&lt;/a&gt;结果是堆分配的，并且非恒定的，除非length参数为 &lt;code&gt;0&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="dab88c1cb3eef6aab0ce452f5d3a24ee29766571" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem for optional parameters is to add a type annotation to the argument bump.</source>
          <target state="translated">对于可选参数来说,解决这个问题的正确方法是在参数凹凸处加一个类型注释。</target>
        </trans-unit>
        <trans-unit id="021484aa4f766fbe935de88999e6cb6d7bb47d1e" translate="yes" xml:space="preserve">
          <source>The rules may contain the special symbol error to indicate resynchronization points, as in yacc.</source>
          <target state="translated">规则中可以包含特殊符号错误来表示重新同步点,如yacc。</target>
        </trans-unit>
        <trans-unit id="b2425e4fb8fd4780c2506baebfe7345c64646daa" translate="yes" xml:space="preserve">
          <source>The run-time library for lexers generated by &lt;code&gt;ocamllex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ocamllex&lt;/code&gt; 生成的词法分析器的运行时库。</target>
        </trans-unit>
        <trans-unit id="2d4e630606c50faf5f2e5b24a4b0bf1a04b6c5db" translate="yes" xml:space="preserve">
          <source>The run-time library for parsers generated by &lt;code&gt;ocamlyacc&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;ocamlyacc&lt;/code&gt; 生成的解析器的运行时库。</target>
        </trans-unit>
        <trans-unit id="b06b765c6160900806a7c7c50af837787bf9890a" translate="yes" xml:space="preserve">
          <source>The runtime overhead imposed by Spacetime varies considerably depending on the particular program being profiled. The overhead may be as low as ten percent&amp;mdash;but more usually programs should be expected to run at perhaps a third or quarter of their normal speed. It is expected that this overhead will be reduced in future versions of the compiler.</source>
          <target state="translated">时空所施加的运行时开销根据要分析的特定程序而有很大不同。开销可能低至百分之十-但通常应期望程序以正常速度的三分之一或四分之一运行。预期在以后的编译器版本中将减少此开销。</target>
        </trans-unit>
        <trans-unit id="7ef99f2b64955164c9593d8e632198f04c1ea43d" translate="yes" xml:space="preserve">
          <source>The runtime representation of a function. This includes pointers to the code of the function together with the values of any variables that are used in the body of the function but actually defined outside of the function, in the enclosing scope. The values of such variables, collectively known as the &lt;em&gt;environment&lt;/em&gt;, are required because the function may be invoked from a place where the original bindings of such variables are no longer in scope. A group of possibly mutually-recursive functions defined using &lt;em&gt;let rec&lt;/em&gt; all share a single closure. (Note to developers: in the Flambda source code a &lt;em&gt;closure&lt;/em&gt; always corresponds to a single function; a &lt;em&gt;set of closures&lt;/em&gt; refers to a group of such.)</source>
          <target state="translated">函数的运行时表示形式。这包括指向函数代码的指针，以及在函数范围内使用的，但实际上在函数外部定义的任何变量的值。需要这样的变量的值（统称为&lt;em&gt;环境）&lt;/em&gt;，因为可以从这样的变量的原始绑定不在范围内的地方调用该函数。使用&lt;em&gt;let rec&lt;/em&gt;定义的一组可能相互递归的函数都共享一个闭包。 （开发人员注意：在Flambda源代码中，&lt;em&gt;闭包&lt;/em&gt;始终对应于一个函数；一&lt;em&gt;组闭包&lt;/em&gt;指的是一组这样的函数。）</target>
        </trans-unit>
        <trans-unit id="09e0b17c8f9005f5c598030be2554c687ccaa24d" translate="yes" xml:space="preserve">
          <source>The same feature is provided for method definitions.</source>
          <target state="translated">同样的功能也提供给方法定义。</target>
        </trans-unit>
        <trans-unit id="f69459bd2efc915e393510bd7d020112db264859" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;code&gt;set_double_field&lt;/code&gt; and &lt;code&gt;set_tag&lt;/code&gt;. However, for &lt;code&gt;set_tag&lt;/code&gt;, in the case of immutable blocks where the middle-end optimizers never see code that discriminates on their tag (for example records), the operation should be safe. Such uses are nonetheless discouraged.</source>
          <target state="translated">这同样适用于 &lt;code&gt;set_double_field&lt;/code&gt; 和 &lt;code&gt;set_tag&lt;/code&gt; 。但是，对于 &lt;code&gt;set_tag&lt;/code&gt; ，在不可变块的情况下，中端优化器永远不会看到区分其标签的代码（例如记录），则该操作应该是安全的。尽管如此，不鼓励此类使用。</target>
        </trans-unit>
        <trans-unit id="c251a3b5f6c58244053faab7ecc98ddabddcb4f0" translate="yes" xml:space="preserve">
          <source>The same ownership discipline that makes &lt;code&gt;unsafe_to_string&lt;/code&gt; correct applies to &lt;code&gt;unsafe_of_string&lt;/code&gt;: you may use it if you were the owner of the &lt;code&gt;string&lt;/code&gt; value, and you will own the return &lt;code&gt;bytes&lt;/code&gt; in the same mode.</source>
          <target state="translated">使 &lt;code&gt;unsafe_to_string&lt;/code&gt; 正确的相同所有权准则也适用于 &lt;code&gt;unsafe_of_string&lt;/code&gt; ：如果您是 &lt;code&gt;string&lt;/code&gt; 值的所有者，则可以使用它，并且您将以相同的方式拥有返回 &lt;code&gt;bytes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ac338637d2a5fce3a9f3793f3f8813dc5e79b82" translate="yes" xml:space="preserve">
          <source>The same shortcut is available for enumerated lists, using &amp;rsquo;+&amp;rsquo; instead of &amp;rsquo;-&amp;rsquo;. Note that only one list can be defined by this shortcut in nested lists.</source>
          <target state="translated">对于枚举列表，可以使用相同的快捷方式，使用&amp;ldquo; +&amp;rdquo;代替&amp;ldquo;-&amp;rdquo;。请注意，此快捷方式只能在嵌套列表中定义一个列表。</target>
        </trans-unit>
        <trans-unit id="a96000f19b19300268f15d1d76e944ef3a1ebf04" translate="yes" xml:space="preserve">
          <source>The same syntactic form is also used to attach attributes to labels and constructors in type declarations:</source>
          <target state="translated">同样的语法形式也用于在类型声明中为标签和构造函数附加属性。</target>
        </trans-unit>
        <trans-unit id="c56f9cdc02f4eaf0671121f748c04b2b039e6299" translate="yes" xml:space="preserve">
          <source>The scanning indications introduce slight differences in the syntax of &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; format strings, compared to those used for the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module. However, the scanning indications are similar to those used in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module; hence, when producing formatted text to be scanned by &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt;, it is wise to use printing functions from the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module (or, if you need to use functions from &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt;, banish or carefully double check the format strings that contain &lt;code&gt;'@'&lt;/code&gt; characters).</source>
          <target state="translated">与用于&lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt;模块的扫描指示相比，扫描指示在&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;格式字符串的语法上引入了些微差异。但是，扫描指示与&amp;ldquo;&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;模块中使用的扫描指示相似。因此，在生成要由&lt;a href=&quot;scanf#VALbscanf&quot;&gt; &lt;code&gt;Scanf.bscanf&lt;/code&gt; &lt;/a&gt;扫描的格式化文本时，明智的做法是使用&amp;ldquo;&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt;模块中的打印功能（或者，如果您需要使用&lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; 中的&lt;/a&gt;功能，请放逐或仔细检查包含 &lt;code&gt;'@'&lt;/code&gt; 的格式字符串人物）。</target>
        </trans-unit>
        <trans-unit id="d497c2d6e07b975e5682bc991cd842d916c5c070" translate="yes" xml:space="preserve">
          <source>The second case is an open variant type, describing a polymorphic variant value: it gives the list of all tags the value could take, with their associated types. This type is still compatible with a variant type containing more tags. A special case is the unknown type, which does not define any tag, and is compatible with any variant type.</source>
          <target state="translated">第二种情况是一个开放的变体类型,描述了一个多态的变体值:它给出了该值可以采用的所有标记的列表,以及它们相关的类型。这种类型仍然与包含更多标签的变体类型兼容。一种特殊情况是未知类型,它没有定义任何标记,与任何变体类型兼容。</target>
        </trans-unit>
        <trans-unit id="206f431b57884a92787316f42c56f48556e1bebc" translate="yes" xml:space="preserve">
          <source>The second drawback of dynamic linking is that it complicates the construction of the library. The C compiler and linker flags to compile to position-independent code and build a shared library vary wildly between different Unix systems. Also, dynamic linking is not supported on all Unix systems, requiring a fall-back case to static linking in the Makefile for the library. The ocamlmklib command (see section &amp;zwj;&lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;18.14&lt;/a&gt;) tries to hide some of these system dependencies.</source>
          <target state="translated">动态链接的第二个缺点是它使库的构造复杂化。在不同的Unix系统之间，用于编译为与位置无关的代码并构建共享库的C编译器和链接器标志差异很大。而且，并非所有的Unix系统都支持动态链接，因此需要在Makefile中进行静态链接的后备情况。的ocamlmklib命令（参见&lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;18.14&lt;/a&gt;）试图隐藏一些这些系统依赖。</target>
        </trans-unit>
        <trans-unit id="f4cd062edd42fc49d3c066f95872cdcd6b75a514" translate="yes" xml:space="preserve">
          <source>The second drawback of dynamic linking is that it complicates the construction of the library. The C compiler and linker flags to compile to position-independent code and build a shared library vary wildly between different Unix systems. Also, dynamic linking is not supported on all Unix systems, requiring a fall-back case to static linking in the Makefile for the library. The ocamlmklib command (see section &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;) tries to hide some of these system dependencies.</source>
          <target state="translated">动态链接的第二个缺点是它使库的构造复杂化。在不同的Unix系统之间，用于编译为与位置无关的代码并构建共享库的C编译器和链接器标志差异很大。而且，并非所有的Unix系统都支持动态链接，因此需要在Makefile中进行静态链接的后备情况。ocamlmklib命令（请参见第&lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;节）尝试隐藏其中的某些系统依赖项。</target>
        </trans-unit>
        <trans-unit id="f1cce543693960e06654a40bc08d8813b14f9075" translate="yes" xml:space="preserve">
          <source>The second example is more subtle: while we intended the argument bump to be of type ?step:int -&amp;gt; int -&amp;gt; int, it is inferred as step:int -&amp;gt; int -&amp;gt; 'a. These two types being incompatible (internally normal and optional arguments are different), a type error occurs when applying bump_it to the real bump.</source>
          <target state="translated">第二个示例更加微妙：尽管我们希望参数凹凸的类型为？step：int-&amp;gt; int-&amp;gt; int，但可以将其推断为step：int-&amp;gt; int-&amp;gt;'a。这两种类型不兼容（内部常规参数和可选参数不同），将bump_it应用于实际凹凸时会发生类型错误。</target>
        </trans-unit>
        <trans-unit id="9d4ee921aaa1ec3723cdbada30294d66c801a5b5" translate="yes" xml:space="preserve">
          <source>The second form of attributes are attached to &amp;ldquo;blocks&amp;rdquo; such as type declarations, class fields, etc:</source>
          <target state="translated">属性的第二种形式附加到&amp;ldquo;块&amp;rdquo;，例如类型声明，类字段等：</target>
        </trans-unit>
        <trans-unit id="4bcf7cdc991e4c97ac21aa1c7ae7ff5801e85d37" translate="yes" xml:space="preserve">
          <source>The second major class of non-genericity is directly related to the problem of type inference for polymorphic functions. In some circumstances, the type inferred by OCaml might be not general enough to allow the definition of some recursive functions, in particular for recursive function acting on non-regular algebraic data type.</source>
          <target state="translated">第二大类非通用性与多态函数的类型推断问题直接相关。在某些情况下,OCaml推断的类型可能不够通用,无法定义某些递归函数,特别是对作用于非规则代数数据类型的递归函数。</target>
        </trans-unit>
        <trans-unit id="ddae56c7d78a1170cc9452541524e5c04728b654" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter.</source>
          <target state="translated">格式化程序特有的语义标签处理功能： &lt;code&gt;mark&lt;/code&gt; 版本是&amp;ldquo;标记标记&amp;rdquo;功能，可将字符串标记与标记关联，以便漂亮打印引擎将这些标记作为长度为0的标记写在标记的输出设备中。格式化程序。</target>
        </trans-unit>
        <trans-unit id="bff7da471def393c1b371feaa59a0379272afe47" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter. &lt;code&gt;print&lt;/code&gt; versions are the 'tag-printing' functions that can perform regular printing when a tag is closed or opened.</source>
          <target state="translated">格式化程序特有的语义标签处理功能： &lt;code&gt;mark&lt;/code&gt; 版本是&amp;ldquo;标记标记&amp;rdquo;功能，可将字符串标记与标记关联，以便漂亮打印引擎将这些标记作为长度为0的标记写在标记的输出设备中。格式化程序。 &lt;code&gt;print&lt;/code&gt; 版本是&amp;ldquo;标签打印&amp;rdquo;功能，可以在关闭或打开标签时执行常规打印。</target>
        </trans-unit>
        <trans-unit id="7b2c1fa893284068e8e146efa02bbd7bcc29fab2" translate="yes" xml:space="preserve">
          <source>The semantics is clear: match the scrutinee against the pattern, if it matches, test the guard, and if the guard passes, take the branch. In particular, consider the input (Const &amp;zwj;a, Const &amp;zwj;b), where a fails the test is_neutral &amp;zwj;a, while b passes the test is_neutral &amp;zwj;b. With the left-to-right semantics, the clause above is &lt;em&gt;not&lt;/em&gt; taken by its input: matching (Const &amp;zwj;a, Const &amp;zwj;b) against the or-pattern succeeds in the left branch, it returns the environment x &amp;zwj;-&amp;gt; &amp;zwj;a, and then the guard is_neutral &amp;zwj;a is tested and fails, the branch is not taken.</source>
          <target state="translated">语义很清楚：将模式与模式匹配，如果匹配，则测试防护，如果防护通过，则采取分支。特别要考虑输入（Const A，Const B），其中a通过测试is_neutral &amp;zwj; a失败，而b通过测试is_neutral &amp;zwj;b。使用从左到右的语义，上面的子句&lt;em&gt;不会&lt;/em&gt;被其输入接受：在左分支中，与or-pattern匹配（Const &amp;zwj;a，Const &amp;zwj;b）成功，它返回了环境x &amp;zwj;-&amp;gt; a，然后保护is_neutral &amp;zwj;a已测试并且失败，不采用分支。</target>
        </trans-unit>
        <trans-unit id="2bcc6c39a05b6e4644ddb92b4ebfbec3f0bd5823" translate="yes" xml:space="preserve">
          <source>The semantics is clear: match the scrutinee against the pattern, if it matches, test the guard, and if the guard passes, take the branch. In particular, consider the input (Consta, Constb), where a fails the test is_neutrala, while b passes the test is_neutralb. With the left-to-right semantics, the clause above is &lt;em&gt;not&lt;/em&gt; taken by its input: matching (Consta, Constb) against the or-pattern succeeds in the left branch, it returns the environment x-&amp;gt;a, and then the guard is_neutrala is tested and fails, the branch is not taken.</source>
          <target state="translated">语义很清楚：将模式与模式匹配，如果匹配，则测试防护，如果防护通过，则采取分支。特别是，考虑输入（Consta，Constb），其中a通过测试is_neutrala失败，而b通过测试is_neutralb。使用从左到右的语义，上面的子句&lt;em&gt;不会&lt;/em&gt;被其输入接受：在左分支中，与or模式的匹配（Consta，Constb）成功，它返回环境x-&amp;gt; a，然后保护is_neutrala经过测试并失败，则不采用该分支。</target>
        </trans-unit>
        <trans-unit id="7a1ca7a03baad7716212210f3fc88fe09e15dd50" translate="yes" xml:space="preserve">
          <source>The semantics of or-patterns in OCaml is specified with a left-to-right bias: a value v matches the pattern p|q if it matches p or q, but if it matches both, the environment captured by the match is the environment captured by p, never the one captured by q.</source>
          <target state="translated">在OCaml中,or-patterns的语义是以从左到右的偏向来指定的:一个值v如果与p|q模式相匹配,那么它就与p或q相匹配,但如果两者都相匹配,那么匹配所捕获的环境就是p所捕获的环境,绝不是q所捕获的环境。</target>
        </trans-unit>
        <trans-unit id="c1583a4f3236a4e29dfa43d51de455715358c04c" translate="yes" xml:space="preserve">
          <source>The semantics of string functions is defined in terms of indices and positions. These are depicted and described as follows.</source>
          <target state="translated">字符串函数的语义是用索引和位置来定义的。以下是对它们的描述和说明。</target>
        </trans-unit>
        <trans-unit id="33bae5ab3c39edb36e6026c0e18053f2831c7697" translate="yes" xml:space="preserve">
          <source>The serialize field can be set to custom_serialize_default, in which case the Failure exception is raised when attempting to serialize the custom block.</source>
          <target state="translated">序列化字段可以设置为custom_serialize_default,在这种情况下,当试图序列化自定义块时,会引发Failure异常。</target>
        </trans-unit>
        <trans-unit id="d40ce64ff61f966dff5d5f82bc2dc3bb7256bb8b" translate="yes" xml:space="preserve">
          <source>The serialize field contains a pointer to a C function that is called whenever the custom block needs to be serialized (marshaled) using the OCaml functions output_value or Marshal.to_.... For a custom block, those functions first write the identifier of the block (as given by the identifier field) to the output stream, then call the user-provided serialize function. That function is responsible for writing the data contained in the custom block, using the serialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. The user-provided serialize function must then store in its bsize_32 and bsize_64 parameters the sizes in bytes of the data part of the custom block on a 32-bit architecture and on a 64-bit architecture, respectively.</source>
          <target state="translated">serialize字段包含一个指向C函数的指针，每当需要使用OCaml函数output_value或Marshal.to _...对自定义块进行序列化（编组）时，就会调用该C函数。块（由标识符字段指定）到输出流，然后调用用户提供的序列化函数。该函数负责使用&amp;lt;caml / intext.h&amp;gt;中定义的并在下面列出的serialize _...函数来写入包含在自定义块中的数据。然后，用户提供的串行化函数必须在其bsize_32和bsize_64参数中分别存储32位体系结构和64位体系结构中自定义块的数据部分的字节大小。</target>
        </trans-unit>
        <trans-unit id="d2942136b250ae1097e80c746ad490f52ed3542e" translate="yes" xml:space="preserve">
          <source>The set of command line flags relating to optimisation should typically be specified to be the same across an entire project. Flambda does not currently record the requested flags in the .cmx files. As such, inlining of functions from previously-compiled units will subject their code to the optimisation parameters of the unit currently being compiled, rather than those specified when they were previously compiled. It is hoped to rectify this deficiency in the future.</source>
          <target state="translated">与优化有关的命令行标志集通常应该在整个项目中被指定为相同的。Flambda目前没有在.cmx文件中记录所要求的标志。因此,内联以前编译过的单元中的函数,其代码将受制于当前正在编译的单元的优化参数,而不是以前编译时指定的参数。希望将来能纠正这个缺陷。</target>
        </trans-unit>
        <trans-unit id="75f7516c7000daca4e41898b962a62fb90ba554f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter:</source>
          <target state="translated">特定于格式器的输出函数集。</target>
        </trans-unit>
        <trans-unit id="58f5c99c8953630f7d0eb9e43e64f07f7389a46f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter: the &lt;code&gt;out_string&lt;/code&gt; function performs all the pretty-printer string output. It is called with a string &lt;code&gt;s&lt;/code&gt;, a start position &lt;code&gt;p&lt;/code&gt;, and a number of characters &lt;code&gt;n&lt;/code&gt;; it is supposed to output characters &lt;code&gt;p&lt;/code&gt; to &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;., the &lt;code&gt;out_flush&lt;/code&gt; function flushes the pretty-printer output device., &lt;code&gt;out_newline&lt;/code&gt; is called to open a new line when the pretty-printer splits the line., the &lt;code&gt;out_spaces&lt;/code&gt; function outputs spaces when a break hint leads to spaces instead of a line split. It is called with the number of spaces to output., the &lt;code&gt;out_indent&lt;/code&gt; function performs new line indentation when the pretty-printer splits the line. It is called with the indentation value of the new line. By default: fields &lt;code&gt;out_string&lt;/code&gt; and &lt;code&gt;out_flush&lt;/code&gt; are output device specific; (e.g. &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt;&lt;code&gt;output_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; device, or &lt;code&gt;Buffer.add_substring&lt;/code&gt; and &lt;a href=&quot;stdlib#VALignore&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; for a &lt;code&gt;Buffer.t&lt;/code&gt; output device),, field &lt;code&gt;out_newline&lt;/code&gt; is equivalent to &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;;, fields &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_indent&lt;/code&gt; are equivalent to &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="translated">格式化程序特有的一组输出函数： &lt;code&gt;out_string&lt;/code&gt; 函数执行所有漂亮打印机字符串输出。它由字符串 &lt;code&gt;s&lt;/code&gt; ，起始位置 &lt;code&gt;p&lt;/code&gt; 和许多字符 &lt;code&gt;n&lt;/code&gt; 来调用。它应该输出字符 &lt;code&gt;p&lt;/code&gt; 到 &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 中， &lt;code&gt;out_flush&lt;/code&gt; 功能刷新漂亮打印机输出装置。 &lt;code&gt;out_newline&lt;/code&gt; 被调用当漂亮打印机分割线打开一个新的线，所述。 &lt;code&gt;out_spaces&lt;/code&gt; 功能当中断提示导致空格而不是行拆分时，输出空格。用要输出的空格数调用它 &lt;code&gt;out_indent&lt;/code&gt; 当漂亮打印机分割行时，该函数将执行新的行缩进。用新行的缩进值调用它。默认情况下： &lt;code&gt;out_string&lt;/code&gt; 和 &lt;code&gt;out_flush&lt;/code&gt; 字段是特定于输出设备的； （例如，对于&lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt; &lt;code&gt;out_channel&lt;/code&gt; &lt;/a&gt;设备为&lt;a href=&quot;stdlib#VALoutput_string&quot;&gt; &lt;code&gt;output_string&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;，对于 &lt;code&gt;Buffer.t&lt;/code&gt; 输出设备为 &lt;code&gt;Buffer.add_substring&lt;/code&gt; 并&lt;a href=&quot;stdlib#VALignore&quot;&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/a&gt;），字段 &lt;code&gt;out_newline&lt;/code&gt; 等效于 &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt; ；字段 &lt;code&gt;out_spaces&lt;/code&gt; 和 &lt;code&gt;out_indent&lt;/code&gt; 等效于 &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fe430d7f65b9a4115dd36213fde72e2766eb905" translate="yes" xml:space="preserve">
          <source>The short expressions are translated into calls to functions of the Bigarray module as described in the following table.</source>
          <target state="translated">简短的表达式被翻译成对Bigarray模块函数的调用,如下表所示。</target>
        </trans-unit>
        <trans-unit id="3ec3650bd7c2cf484db50a370f6c089d2295064a" translate="yes" xml:space="preserve">
          <source>The signature MYHASH then contains all the fields of the signature of the module Hashtbl (with strengthened type definitions), plus the new field replace. An implementation of this signature can be obtained easily by using the include construct again, but this time at the structure level:</source>
          <target state="translated">然后,签名 MYHASH 包含了 Hashtbl 模块签名的所有字段 (加强了类型定义),加上新的字段 replace。这个签名的实现可以通过再次使用include构造轻松获得,但这次是在结构层。</target>
        </trans-unit>
        <trans-unit id="70846c98b1e5f76d1a8eeae9357dba832f61e830" translate="yes" xml:space="preserve">
          <source>The simplification pass removes unused let bindings so long as their corresponding defining expressions have &amp;ldquo;no effects&amp;rdquo;. See the section &amp;ldquo;Treatment of effects&amp;rdquo; below for the precise definition of this term.</source>
          <target state="translated">简化过程将删除未使用的let绑定，只要它们对应的定义表达式没有任何效果即可。有关此术语的确切定义，请参见下面的&amp;ldquo;影响的处理&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0fef5e19c04ebce13dc54db7219bcb47397db9b0" translate="yes" xml:space="preserve">
          <source>The singleton sequence containing only the given element.</source>
          <target state="translated">只包含给定元素的单子序列。</target>
        </trans-unit>
        <trans-unit id="c4bcd7d574236ad63f44f94fc9e518268676361d" translate="yes" xml:space="preserve">
          <source>The size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.</source>
          <target state="translated">次要堆的大小(字数)。改变这个参数将触发一个次要集合。默认值:256k。</target>
        </trans-unit>
        <trans-unit id="a7507f679adbb7afe1b145bc75e44b72811c4382" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer.</source>
          <target state="translated">本机整数的位数。</target>
        </trans-unit>
        <trans-unit id="85cc984ceaff2d2d3db71a0f154333bd58e0401c" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer. This is equal to &lt;code&gt;32&lt;/code&gt; on a 32-bit platform and to &lt;code&gt;64&lt;/code&gt; on a 64-bit platform.</source>
          <target state="translated">本地整数的大小（以位为单位）。在32位平台上等于 &lt;code&gt;32&lt;/code&gt; ,在 &lt;code&gt;64&lt;/code&gt; 位平台上等于64。</target>
        </trans-unit>
        <trans-unit id="64bd44d9e49c2e76cdcec87737e9935d12ee6bdc" translate="yes" xml:space="preserve">
          <source>The size of the block, in words, excluding the header.</source>
          <target state="translated">块的大小,以字为单位,不包括头部。</target>
        </trans-unit>
        <trans-unit id="e6050e441d76daaaf25b47ad3fafeab9c8db6155" translate="yes" xml:space="preserve">
          <source>The size of the window used by the major GC for smoothing out variations in its workload. This is an integer between 1 and 50. Default: 1.</source>
          <target state="translated">主要GC用于平滑其工作量变化的窗口大小。这是一个介于1和50之间的整数。默认值:1。</target>
        </trans-unit>
        <trans-unit id="e707fef1fa0d611c38a23a134e978234bf5dd431" translate="yes" xml:space="preserve">
          <source>The smallest positive, non-zero, non-denormalized value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 类型的最小的正，非零，未归一化的值。</target>
        </trans-unit>
        <trans-unit id="a3b9782a5db6a027afd3f2671f6d34f2dca120c7" translate="yes" xml:space="preserve">
          <source>The smallest representable 32-bit integer, -2&lt;sup&gt;31&lt;/sup&gt;.</source>
          <target state="translated">可表示的最小32位整数-2 &lt;sup&gt;31&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="1bcd225542d9f92f6251d4bb2d635ef483db75e2" translate="yes" xml:space="preserve">
          <source>The smallest representable 64-bit integer, -2&lt;sup&gt;63&lt;/sup&gt;.</source>
          <target state="translated">最小的可表示64位整数-2 &lt;sup&gt;63&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="e75cf5a86c7fa5d080ac26a1f47b98cef3adf163" translate="yes" xml:space="preserve">
          <source>The smallest representable integer.</source>
          <target state="translated">最小的可表示整数。</target>
        </trans-unit>
        <trans-unit id="b7ad80500b883d3470a8546d7763368d6a139abd" translate="yes" xml:space="preserve">
          <source>The smallest representable native integer, either -2&lt;sup&gt;31&lt;/sup&gt; on a 32-bit platform, or -2&lt;sup&gt;63&lt;/sup&gt; on a 64-bit platform.</source>
          <target state="translated">最小的可表示本机整数，在32位平台上为-2 &lt;sup&gt;31&lt;/sup&gt;，在64位平台上为-2 &lt;sup&gt;63&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="16618ca96c698ad7bfc1856d7b38af8d4e0524d6" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67e810815e754c36f51190792dabe6b7f6d39fc1" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt;。这些选项具有布尔值（ &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6598491cb35302bb16af6b6c7a9e151f8e63d9b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt; &lt;code&gt;Unix.getsockopt_float&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt; &lt;code&gt;Unix.setsockopt_float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2019ae655a591c32fb8f40c0b2ba647816b414ae" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt; &lt;code&gt;Unix.getsockopt_float&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt; &lt;code&gt;Unix.setsockopt_float&lt;/code&gt; &lt;/a&gt;。这些选项的浮点值表示以秒为单位的时间。值0表示无限超时。</target>
        </trans-unit>
        <trans-unit id="2e1595d080e9d78ca9f7ddffc0fd77da50d67b0c" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt; &lt;code&gt;Unix.getsockopt_int&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt; &lt;code&gt;Unix.setsockopt_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6570006f88037fbe57d746e9ffa8ebe2113c3daa" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt; &lt;code&gt;Unix.getsockopt_int&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt; &lt;code&gt;Unix.setsockopt_int&lt;/code&gt; &lt;/a&gt;。这些选项具有整数值。</target>
        </trans-unit>
        <trans-unit id="67cb053530374f0ae91755129be399861c2e62b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt; &lt;code&gt;Unix.getsockopt_optint&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt; &lt;code&gt;Unix.setsockopt_optint&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b02d9606ae3049641c3c0b7a49b93173582ba252" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;. These options have a value of type &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;, with &lt;code&gt;None&lt;/code&gt; meaning ``disabled''.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt; &lt;code&gt;Unix.getsockopt_optint&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt; &lt;code&gt;Unix.setsockopt_optint&lt;/code&gt; &lt;/a&gt;。这些选项的值类型为 &lt;code&gt;int&amp;nbsp;option&lt;/code&gt; ， &lt;code&gt;None&lt;/code&gt; 表示``disabled''。</target>
        </trans-unit>
        <trans-unit id="773642dab704b446e24c880397ae53bf6b4f36e8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt; &lt;code&gt;UnixLabels.getsockopt&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt; &lt;code&gt;UnixLabels.setsockopt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="127c95d87113564ad21001801dba75443274ac20" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt; &lt;code&gt;UnixLabels.getsockopt&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt; &lt;code&gt;UnixLabels.setsockopt&lt;/code&gt; &lt;/a&gt;。这些选项具有布尔值（ &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5d121887ffb4d5fad74076fcd7a6ddb33c6b3f62" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03fad790fcf2b775879fa18d8ded24985ac1495f" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt; &lt;/a&gt;。这些选项的浮点值表示以秒为单位的时间。值0表示无限超时。</target>
        </trans-unit>
        <trans-unit id="4cd8b0a441c72f8156f95e88c710953c3fa2ced0" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af5931adebaf9a357ecb0df8a73e7c072f718e8d" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt; &lt;/a&gt;。这些选项具有整数值。</target>
        </trans-unit>
        <trans-unit id="021f8090168584ea506e1a7f1144ad38a2016940" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_optint&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_optint&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_optint&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unixlabels#VALgetsockopt_optint&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_optint&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unixlabels#VALsetsockopt_optint&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_optint&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56353b8785e40bfc0f8aeaadd9ecd6af851b7561" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_optint&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_optint&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_optint&lt;/code&gt;&lt;/a&gt;. These options have a value of type &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;, with &lt;code&gt;None&lt;/code&gt; meaning ``disabled''.</source>
          <target state="translated">可与被咨询的套接字选项&lt;a href=&quot;unixlabels#VALgetsockopt_optint&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_optint&lt;/code&gt; &lt;/a&gt;和改良&lt;a href=&quot;unixlabels#VALsetsockopt_optint&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_optint&lt;/code&gt; &lt;/a&gt;。这些选项的值类型为 &lt;code&gt;int&amp;nbsp;option&lt;/code&gt; ， &lt;code&gt;None&lt;/code&gt; 表示``disabled''。</target>
        </trans-unit>
        <trans-unit id="55d3d9fad514eda7c3e614c6496c099599e1e6e6" translate="yes" xml:space="preserve">
          <source>The solution of this conundrum is to use an explicitly polymorphic type annotation for the type 'a:</source>
          <target state="translated">这个难题的解决方法是为'a'类型使用显式多态类型注解。</target>
        </trans-unit>
        <trans-unit id="ca3eb9c8c5023c43f9da6f2e55f310ac29817523" translate="yes" xml:space="preserve">
          <source>The sort function above does not modify its input list: it builds and returns a new list containing the same elements as the input list, in ascending order. There is actually no way in OCaml to modify a list in-place once it is built: we say that lists are &lt;em&gt;immutable&lt;/em&gt; data structures. Most OCaml data structures are immutable, but a few (most notably arrays) are &lt;em&gt;mutable&lt;/em&gt;, meaning that they can be modified in-place at any time.</source>
          <target state="translated">上面的sort函数不会修改其输入列表：它会生成并返回一个新列表，该列表包含与输入列表相同的元素（按升序排列）。实际上，OCaml在建立列表后实际上就无法修改它：我们说列表是&lt;em&gt;不可变的&lt;/em&gt;数据结构。大多数OCaml数据结构都是不可变的，但是有一些（最著名的是数组）是&lt;em&gt;可变的&lt;/em&gt;，这意味着它们可以随时进行修改。</target>
        </trans-unit>
        <trans-unit id="3aef2817764bb52ac263b2fae2a148fec94730b6" translate="yes" xml:space="preserve">
          <source>The space character in format strings</source>
          <target state="translated">格式字符串中的空格字符</target>
        </trans-unit>
        <trans-unit id="c0c0e1ff4d5efd916e94aa7b9b072f20bb6cc011" translate="yes" xml:space="preserve">
          <source>The special comment (**/**) tells OCamldoc to discard elements placed after this comment, up to the end of the current class, class type, module or module type, or up to the next stop comment. For instance:</source>
          <target state="translated">特殊注释(**/**)告诉OCamldoc丢弃放在这个注释之后的元素,直到当前类、类类型、模块或模块类型的末尾,或者直到下一个停止注释。例如</target>
        </trans-unit>
        <trans-unit id="cebcc58b51afa7136699d267676f15d0e280a3f4" translate="yes" xml:space="preserve">
          <source>The special comment is not already associated to the previous element.</source>
          <target state="translated">特别评论没有与前一个元素相关联。</target>
        </trans-unit>
        <trans-unit id="5435aaea40f8385771bfff6ba0d166cd3c0eeccb" translate="yes" xml:space="preserve">
          <source>The special comment is not the first one of a toplevel module.</source>
          <target state="translated">特别评论不是toplevel模块的第一条。</target>
        </trans-unit>
        <trans-unit id="06de91b2368326e2f06fbc6d38cdade544c2bc74" translate="yes" xml:space="preserve">
          <source>The specification exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; in a signature requires the matching structure to provide an exception with the name and arguments specified in the definition, and makes the exception available to all users of the structure.</source>
          <target state="translated">签名中的规范异常&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;要求匹配的结构提供具有定义中指定的名称和参数的异常，并使该异常可用于该结构的所有用户。</target>
        </trans-unit>
        <trans-unit id="fc96b351853386bb44b989f2d36255658c8e97cf" translate="yes" xml:space="preserve">
          <source>The specification of a method is written method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;, where &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is the name of the method and &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; its expected type, possibly polymorphic. The flag private indicates that the method cannot be accessed from outside the object.</source>
          <target state="translated">方法的规范写为method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;：&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;，其中&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;是方法的名称，而&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr是&lt;/a&gt;其预期的类型，可能是多态的。标志private表示无法从对象外部访问该方法。</target>
        </trans-unit>
        <trans-unit id="816c127c5b84f64b52fb9fd685c1cb4ac8a4ea85" translate="yes" xml:space="preserve">
          <source>The standard error output for the process.</source>
          <target state="translated">过程的标准误差输出。</target>
        </trans-unit>
        <trans-unit id="db78c9295b1256ee8e8a6b6086c5f3651f2fa1cd" translate="yes" xml:space="preserve">
          <source>The standard formatter to write to standard output.</source>
          <target state="translated">标准格式化,以写入标准输出。</target>
        </trans-unit>
        <trans-unit id="ba48c9ea4ac16d1bd2010fb99db24330d34c33b1" translate="yes" xml:space="preserve">
          <source>The standard input for the process.</source>
          <target state="translated">流程的标准输入。</target>
        </trans-unit>
        <trans-unit id="375db9af8a0d4dc3c0ba86650eeff121048506df" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;模块的标准输入概念。</target>
        </trans-unit>
        <trans-unit id="464e4c58fe500861730075b12f1fb6435b04534f" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module. &lt;code&gt;Scanning.stdin&lt;/code&gt; is the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel attached to &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt;模块的标准输入概念。 &lt;code&gt;Scanning.stdin&lt;/code&gt; 是附加到&lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt;格式的输入通道。</target>
        </trans-unit>
        <trans-unit id="aecb465e5714800c091e84c331cee9577b92a018" translate="yes" xml:space="preserve">
          <source>The standard library directory.</source>
          <target state="translated">标准库目录。</target>
        </trans-unit>
        <trans-unit id="defad1b44801f55e161dc009fb41cef1fe3ba956" translate="yes" xml:space="preserve">
          <source>The standard output for the process.</source>
          <target state="translated">流程的标准输出。</target>
        </trans-unit>
        <trans-unit id="f1326096be35fcaff4666a9f746f76c98f98925e" translate="yes" xml:space="preserve">
          <source>The str library provides high-level string processing functions, some based on regular expressions. It is intended to support the kind of file processing that is usually performed with scripting languages such as awk, perl or sed.</source>
          <target state="translated">str库提供了高级字符串处理函数,其中一些是基于正则表达式的。它的目的是支持那种通常用awk、perl或sed等脚本语言进行的文件处理。</target>
        </trans-unit>
        <trans-unit id="6d5110986ab904812febd54df3e70e3cfe974039" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;cmd&lt;/code&gt; is the command to call. The list &lt;code&gt;args&lt;/code&gt; is the list of arguments to pass to this command. It can be empty.</source>
          <target state="translated">字符串 &lt;code&gt;cmd&lt;/code&gt; 是要调用的命令。列表 &lt;code&gt;args&lt;/code&gt; 是要传递给此命令的参数列表。它可以是空的。</target>
        </trans-unit>
        <trans-unit id="4ea036aba8bc423b44bed368aa0538f1848ee618" translate="yes" xml:space="preserve">
          <source>The string buffer in which &lt;code&gt;str_formatter&lt;/code&gt; writes.</source>
          <target state="translated">&lt;code&gt;str_formatter&lt;/code&gt; 写入的字符串缓冲区。</target>
        </trans-unit>
        <trans-unit id="7a78fd29209652bbda7cca4022b56527d5c814fe" translate="yes" xml:space="preserve">
          <source>The struct custom_operations is defined in &amp;lt;caml/custom.h&amp;gt; and contains the following fields:</source>
          <target state="translated">struct custom_operations在&amp;lt;caml / custom.h&amp;gt;中定义，并包含以下字段：</target>
        </trans-unit>
        <trans-unit id="a298a05448f3ad20cfa9581c95c5d1288fc8e676" translate="yes" xml:space="preserve">
          <source>The syntactic class of constants comprises literals from the four base types (integers, floating-point numbers, characters, character strings), the integer variants, and constant constructors from both normal and polymorphic variants, as well as the special constants false, true, (), [], and [||], which behave like constant constructors, and beginend, which is equivalent to ().</source>
          <target state="translated">常量的语法类包括四个基本类型(整数、浮点数、字符、字符串)的字元、整数变体、正常变体和多态变体的常量构造函数,以及特殊常量false、true、()、[]和[||],它们的行为类似于常量构造函数,还有相当于()的beginend。</target>
        </trans-unit>
        <trans-unit id="a830f98dedde0a3c31b9928e1164ca27920971ea" translate="yes" xml:space="preserve">
          <source>The syntax for rules is as usual:</source>
          <target state="translated">规则的语法和往常一样。</target>
        </trans-unit>
        <trans-unit id="11b8e75b70b6bcdf9c144d7d28884193fb2da070" translate="yes" xml:space="preserve">
          <source>The syntax is exactly the same as for class expressions, but the result is a single object rather than a class. All the constructs described in the rest of this section also apply to immediate objects.</source>
          <target state="translated">语法与类表达式完全相同,但结果是一个单一的对象而不是一个类。本节其余部分描述的所有构造也适用于直接对象。</target>
        </trans-unit>
        <trans-unit id="f75ce09e5843f380505e811b0272a865314bf4e9" translate="yes" xml:space="preserve">
          <source>The syntax of the language is given in BNF-like notation. Terminal symbols are set in typewriter font (likethis). Non-terminal symbols are set in italic font (likethat). Square brackets [&amp;hellip;] denote optional components. Curly brackets {&amp;hellip;} denotes zero, one or several repetitions of the enclosed components. Curly brackets with a trailing plus sign {&amp;hellip;}&lt;sup&gt;+&lt;/sup&gt; denote one or several repetitions of the enclosed components. Parentheses (&amp;hellip;) denote grouping.</source>
          <target state="translated">该语言的语法以类似于BNF的表示法给出。终端符号以打字机字体设置（例如this）。非终端符号以斜体字体（likethat）设置。方括号[&amp;hellip;]表示可选组件。圆括号{&amp;hellip;}表示零，一或几个重复的封闭组成部分。带尾随加号{&amp;hellip;} &lt;sup&gt;+的&lt;/sup&gt;花括号表示所包含组件的一个或多个重复。括号（&amp;hellip;）表示分组。</target>
        </trans-unit>
        <trans-unit id="65737a98101a7097f4f09e81329b8761dd1cfb2a" translate="yes" xml:space="preserve">
          <source>The table below lists the symbols defined in the initial environment and their initial meaning. (See the description of the core library module Stdlib in chapter &amp;zwj;&lt;a href=&quot;core#c%3Acorelib&quot;&gt;22&lt;/a&gt; for more details). Their meaning may be changed at any time using let(&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;)name&lt;sub&gt;1&lt;/sub&gt;name&lt;sub&gt;2&lt;/sub&gt;= &amp;hellip;</source>
          <target state="translated">下表列出了初始环境中定义的符号及其初始含义。（参见核心库模块STDLIB的章节中的描述&lt;a href=&quot;core#c%3Acorelib&quot;&gt;22&lt;/a&gt;的更多的细节）。使用let（&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;）name &lt;sub&gt;1&lt;/sub&gt; name &lt;sub&gt;2&lt;/sub&gt; =&amp;hellip;可以随时更改其含义。</target>
        </trans-unit>
        <trans-unit id="aa08323f8802e6d50ccec78b682ef7b93d7f7d1e" translate="yes" xml:space="preserve">
          <source>The table below lists the symbols defined in the initial environment and their initial meaning. (See the description of the core library module Stdlib in chapter &lt;a href=&quot;core#c%3Acorelib&quot;&gt;25&lt;/a&gt; for more details). Their meaning may be changed at any time using let(&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;)name&lt;sub&gt;1&lt;/sub&gt;name&lt;sub&gt;2&lt;/sub&gt;= &amp;hellip;</source>
          <target state="translated">下表列出了初始环境中定义的符号及其初始含义。（有关更多详细信息，请参见第&lt;a href=&quot;core#c%3Acorelib&quot;&gt;25&lt;/a&gt;章中对核心库模块Stdlib的描述）。使用let（&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;）name &lt;sub&gt;1&lt;/sub&gt; name &lt;sub&gt;2&lt;/sub&gt; =&amp;hellip;可以随时更改其含义。</target>
        </trans-unit>
        <trans-unit id="4265c38e98429479cc2782e5d12f7b2b292f3497" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed constructions. The constructions with higher precedence come first. For infix and prefix symbols, we write &amp;ldquo;*&amp;hellip;&amp;rdquo; to mean &amp;ldquo;any symbol starting with *&amp;rdquo;.</source>
          <target state="translated">下表显示了运算符和非封闭构造的相对优先级和关联性。具有较高优先级的结构排在第一位。对于中缀和前缀符号，我们写&amp;ldquo; *&amp;hellip;&amp;rdquo;表示&amp;ldquo;以*开头的任何符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1ca02ca74768b06f8e3e1c2b6d1dd2805e4d9dc1" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed pattern constructions. The constructions with higher precedences come first.</source>
          <target state="translated">下表显示了运算符和非封闭模式结构的相对优先性和关联性。优先级较高的结构优先。</target>
        </trans-unit>
        <trans-unit id="2aaedd4906bf37d963daebc10f3ce2cae137d335" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed type constructions. The constructions with higher precedences come first.</source>
          <target state="translated">下表显示了运算符和非封闭类型结构的相对优先性和关联性。优先级较高的结构优先。</target>
        </trans-unit>
        <trans-unit id="873780c573d904e6823105d70079b69ff6aa2a60" translate="yes" xml:space="preserve">
          <source>The tag-marking operation is the simpler tag specific operation: it simply writes a tag specific string into the output device of the formatter. Tag-marking does not interfere with line-splitting computation.</source>
          <target state="translated">标签标记操作是较简单的标签特定操作:它只是将一个标签特定的字符串写入格式化器的输出设备中。标签标记不会干扰分行计算。</target>
        </trans-unit>
        <trans-unit id="3e9b336647566103c9dc222eca78097e8e36a10d" translate="yes" xml:space="preserve">
          <source>The tag-printing operation is the more involved tag specific operation: it can print arbitrary material to the formatter. Tag-printing is tightly linked to the current pretty-printer operations.</source>
          <target state="translated">标签打印操作是涉及较多的标签专用操作:它可以将任意材料打印到格式器上。标签打印与当前的漂亮打印机操作紧密相连。</target>
        </trans-unit>
        <trans-unit id="bc0467c82797c179e1082f88331fe596f582254d" translate="yes" xml:space="preserve">
          <source>The term type we have defined above is an &lt;em&gt;indexed&lt;/em&gt; type, where a type parameter reflects a property of the value contents. Another use of GADTs is &lt;em&gt;singleton&lt;/em&gt; types, where a GADT value represents exactly one type. This value can be used as runtime representation for this type, and a function receiving it can have a polytypic behavior.</source>
          <target state="translated">我们上面定义的术语类型是&lt;em&gt;索引&lt;/em&gt;类型，其中类型参数反映了值内容的属性。GADT的另一种用途是&lt;em&gt;单例&lt;/em&gt;类型，其中GADT值恰好代表一种类型。此值可以用作此类型的运行时表示，并且接收该值的函数可以具有多型行为。</target>
        </trans-unit>
        <trans-unit id="bff74d740aa663829cf4f77edbb8806d1bc466d0" translate="yes" xml:space="preserve">
          <source>The termination status of a process.</source>
          <target state="translated">流程的终止状态。</target>
        </trans-unit>
        <trans-unit id="e0c71035b432f40f8ce6567e0659d0f94303a4bb" translate="yes" xml:space="preserve">
          <source>The termination status of a process. See module &lt;a href=&quot;sys&quot;&gt;&lt;code&gt;Sys&lt;/code&gt;&lt;/a&gt; for the definitions of the standard signal numbers. Note that they are not the numbers used by the OS.</source>
          <target state="translated">进程的终止状态。有关标准信号号的定义，请参见模块&lt;a href=&quot;sys&quot;&gt; &lt;code&gt;Sys&lt;/code&gt; &lt;/a&gt;。请注意，它们不是操作系统使用的数字。</target>
        </trans-unit>
        <trans-unit id="b998179643d8f25a6de4e2f828c6ab63197c25fd" translate="yes" xml:space="preserve">
          <source>The third case is a closed variant type. It gives information about all the possible tags and their associated types, and which tags are known to potentially appear in values. The exact variant type (first case) is just an abbreviation for a closed variant type where all possible tags are also potentially present.</source>
          <target state="translated">第三种情况是封闭的变体类型。它给出了所有可能的标记及其相关类型的信息,以及已知哪些标记可能出现在值中。确切的变体类型(第一种情况)只是封闭的变体类型的缩写,在这种类型中,所有可能的标记也都有可能出现。</target>
        </trans-unit>
        <trans-unit id="72c73fe652e0c0e0cf068757abf72958b2266b30" translate="yes" xml:space="preserve">
          <source>The threads library allows concurrent programming in OCaml. It provides multiple threads of control (also called lightweight processes) that execute concurrently in the same memory space. Threads communicate by in-place modification of shared data structures, or by sending and receiving data on communication channels.</source>
          <target state="translated">线程库允许在OCaml中进行并发编程。它提供了多个控制线程(也称为轻量级进程),这些线程在同一个内存空间中并发执行。线程通过就地修改共享数据结构,或通过在通信通道上发送和接收数据进行通信。</target>
        </trans-unit>
        <trans-unit id="ee8a007db9b67f061741b11b1f8ef10fd7dfa6a8" translate="yes" xml:space="preserve">
          <source>The threads library is implemented by time-sharing on a single processor. It will not take advantage of multi-processor machines. Using this library will therefore never make programs run faster. However, many programs are easier to write when structured as several communicating processes.</source>
          <target state="translated">线程库是通过在单处理器上分时实现的。它不会利用多处理器机器的优势。因此,使用这个库绝不会使程序运行得更快。然而,许多程序在结构为多个通信进程时更容易编写。</target>
        </trans-unit>
        <trans-unit id="27bdd6f835a65a4ddc9fd64736364ffb4476e344" translate="yes" xml:space="preserve">
          <source>The threads library is implemented on top of the threading facilities provided by the operating system: POSIX 1003.1c threads for Linux, MacOS, and other Unix-like systems; Win32 threads for Windows. Only one thread at a time is allowed to run OCaml code, hence opportunities for parallelism are limited to the parts of the program that run system or C library code. However, threads provide concurrency and can be used to structure programs as several communicating processes. Threads also efficiently support concurrent, overlapping I/O operations.</source>
          <target state="translated">线程库是在操作系统提供的线程设施之上实现的。POSIX 1003.1c线程适用于Linux、MacOS和其他类似Unix系统;Win32线程适用于Windows。一次只允许一个线程运行OCaml代码,因此并行的机会仅限于程序中运行系统或C库代码的部分。然而,线程提供了并发性,并可用于将程序结构为多个通信进程。线程还能有效地支持并发的、重叠的I/O操作。</target>
        </trans-unit>
        <trans-unit id="d5a20efffaf644d1427994b098f56c7f31e6be5e" translate="yes" xml:space="preserve">
          <source>The three kinds of interval timers.</source>
          <target state="translated">三种间隔定时器。</target>
        </trans-unit>
        <trans-unit id="4b1f416d7e4aa2468aa653df39f4953c40bbd756" translate="yes" xml:space="preserve">
          <source>The three type parameters to &lt;code&gt;Genarray.t&lt;/code&gt; identify the array element kind and layout, as follows:</source>
          <target state="translated">&lt;code&gt;Genarray.t&lt;/code&gt; 的三个类型参数标识数组元素的种类和布局，如下所示：</target>
        </trans-unit>
        <trans-unit id="27a8084722c0c59b716ab80edd05f2b005dea978" translate="yes" xml:space="preserve">
          <source>The toplevel system does not perform line editing, but it can easily be used in conjunction with an external line editor such as ledit, or rlwrap. An improved toplevel, utop, is also available. Another option is to use ocaml under Gnu Emacs, which gives the full editing power of Emacs (command run-caml from library inf-caml).</source>
          <target state="translated">toplevel系统不进行行编辑,但它可以很容易地与外部行编辑器(如ledit或rlwrap)结合使用。还有一个改进的toplevel,utop,也可以使用。另一个选择是在Gnu Emacs下使用ocaml,它提供了Emacs的全部编辑功能(命令从库inf-caml运行-caml)。</target>
        </trans-unit>
        <trans-unit id="0efc25c223657f44333e6ed3dee74d2f834fa753" translate="yes" xml:space="preserve">
          <source>The total amount of memory allocated by the program since it was started is (in words) &lt;code&gt;minor_words&amp;nbsp;+&amp;nbsp;major_words&amp;nbsp;-&amp;nbsp;promoted_words&lt;/code&gt;. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</source>
          <target state="translated">自从程序启动以来，程序分配的内存总量（以字为单位） &lt;code&gt;minor_words&amp;nbsp;+&amp;nbsp;major_words&amp;nbsp;-&amp;nbsp;promoted_words&lt;/code&gt; 。乘以字长（在32位计算机上为4，在64位计算机上为8）得到字节数。</target>
        </trans-unit>
        <trans-unit id="f4eb40ef4dc24c3e0ad0bdb73cac37d303dc7aee" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by adding a new wrapper function in the manner of that used when unboxing specialised arguments. The closure variables are still free in the wrapper, but the intention is that when the wrapper is inlined at direct call sites, the relevant values are passed directly to the main function via the new specialised arguments.</source>
          <target state="translated">这种转换是通过添加一个新的包装函数来实现的,其方式与拆箱专用参数时使用的方式相同。封闭变量在包装器中仍然是空闲的,但目的是当包装器在直接调用处内联时,相关的值会通过新的专用参数直接传递给主函数。</target>
        </trans-unit>
        <trans-unit id="2e984d305346aebd0ab69a424dfacb7e6aa1b981" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by creating a wrapper function that accepts the original arguments. Meanwhile, the original function is renamed and extra arguments are added corresponding to the unboxed specialised arguments; this new function is called from the wrapper. The wrapper will then be inlined at direct call sites. Indeed, all call sites will be direct unless -unbox-closures is being used, since they will have been generated by the compiler when originally specialising the function. (In the case of -unbox-closures other functions may appear with specialised arguments; in this case there may be indirect calls and these will incur a small penalty owing to having to bounce through the wrapper. The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used for -unbox-closures is not used by the transformation to unbox specialised arguments.)</source>
          <target state="translated">通过创建一个接受原始参数的包装器函数来实现该转换。同时，重命名了原始函数，并添加了对应于未装箱的专用参数的额外参数；从包装器中调用此新函数。然后，将在直接调用站点内联包装器。实际上，除非使用-unbox-closures，否则所有调用站点都是直接的，因为它们最初是由编译器在最初专用于该函数时生成的。 （在-unbox-closures的情况下，其他函数可能会带有专门的参数；在这种情况下，可能会有间接调用，并且由于必须通过包装程序反弹，因此这些间接调用会产生较小的代价。&lt;em&gt;直接调用代理&lt;/em&gt;的技术&lt;em&gt;&lt;/em&gt; 用于-unbox-closures的转换未用于取消装箱专用参数的转换。）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
