<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="9839a314b20b78f9253b406fd33020bc5eeae4df" translate="yes" xml:space="preserve">
          <source>The smallest reasonable width/height of the component or component group, in pixels.</source>
          <target state="translated">The smallest reasonable width/height of the component or component group, in pixels.</target>
        </trans-unit>
        <trans-unit id="d29505ba6327a428e6ada6e998db00c29198a04c" translate="yes" xml:space="preserve">
          <source>The smallest valid index for reading, initially 0.</source>
          <target state="translated">The smallest valid index for reading, initially 0.</target>
        </trans-unit>
        <trans-unit id="cc3e306f7c43f12a0cd31a1e11f56ee1c06bddfe" translate="yes" xml:space="preserve">
          <source>The smallest valid index for reading, initially 0. When &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, various methods may throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; on an attempt to access data associate with an image having a lower index.</source>
          <target state="translated">판독 할 때의 최소 유효 인덱스는 초기에 0 &lt;code&gt;seekForwardOnly&lt;/code&gt; 가 있다 &lt;code&gt;true&lt;/code&gt; , 다양한 방법은 던질 수 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 화상 낮은 인덱스를 갖는 데이터 액세스 연관시킬 시도.</target>
        </trans-unit>
        <trans-unit id="47262b7bead58cc0b762a05c504fc361f30be635" translate="yes" xml:space="preserve">
          <source>The snippet has a valid signature and it is visible to other snippets (&lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined() == true&lt;/code&gt;&lt;/a&gt;) and thus can be referenced in existing or new snippets but the snippet cannot be executed. An &lt;a href=&quot;unresolvedreferenceexception&quot;&gt;&lt;code&gt;UnresolvedReferenceException&lt;/code&gt;&lt;/a&gt; will be thrown on an attempt to execute it.</source>
          <target state="translated">스 니펫에는 유효한 서명이 있으며 다른 스 니펫 ( &lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined() == true&lt;/code&gt; &lt;/a&gt; )에 표시되므로 기존 또는 새 스 니펫에서 참조 할 수 있지만 스 니펫은 실행할 수 없습니다. &lt;a href=&quot;unresolvedreferenceexception&quot;&gt; &lt;code&gt;UnresolvedReferenceException&lt;/code&gt; 은&lt;/a&gt; 그것을 실행하기위한 시도에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0d997d545268301277a9bcb7f89af28ce8cd435a" translate="yes" xml:space="preserve">
          <source>The snippet has an invalid signature or the implementation is otherwise unable to define it. The snippet it is not visible to other snippets (&lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined() == false&lt;/code&gt;&lt;/a&gt;) and thus cannot be referenced or executed.</source>
          <target state="translated">스 니펫에 유효하지 않은 서명이 있거나 구현시이를 정의 할 수 없습니다. 스 니펫은 다른 스 니펫 ( &lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined() == false&lt;/code&gt; &lt;/a&gt; )에 표시되지 않으므로 참조하거나 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa27fca3d9b651ed6796e1124fea3ceb65daeaff" translate="yes" xml:space="preserve">
          <source>The snippet is a declaration snippet with potentially recoverable unresolved references or other issues (in the context of current &lt;code&gt;JShell&lt;/code&gt; state).</source>
          <target state="translated">스 니펫은 잠재적으로 복구 가능한 미해결 참조 또는 기타 문제 (현재 &lt;code&gt;JShell&lt;/code&gt; 상태 의 컨텍스트에서)가 포함 된 선언 스 니펫입니다 .</target>
        </trans-unit>
        <trans-unit id="1703051353b6fbbbe0a98a60b44b9f8c07d2cba0" translate="yes" xml:space="preserve">
          <source>The snippet is a declaration snippet with potentially recoverable unresolved references or other issues (in the context of current &lt;code&gt;JShell&lt;/code&gt; state). Only a &lt;a href=&quot;declarationsnippet&quot;&gt;&lt;code&gt;DeclarationSnippet&lt;/code&gt;&lt;/a&gt; can have this &lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">스 니펫은 잠재적으로 복구 가능한 미해결 참조 또는 기타 문제 (현재 &lt;code&gt;JShell&lt;/code&gt; 상태 의 컨텍스트에서)가 포함 된 선언 스 니펫입니다 . &lt;a href=&quot;declarationsnippet&quot;&gt; &lt;code&gt;DeclarationSnippet&lt;/code&gt; &lt;/a&gt; 만이 &lt;code&gt;Status&lt;/code&gt; 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="534843ccba930540dd96d6a2040f6b9b01ffc247" translate="yes" xml:space="preserve">
          <source>The snippet is a declaration snippet with potentially recoverable unresolved references or other issues in its body (in the context of current &lt;code&gt;JShell&lt;/code&gt; state).</source>
          <target state="translated">스 니펫은 잠재적으로 복구 가능한 미해결 참조 또는 본문에 기타 문제가있는 선언 스 니펫입니다 (현재 &lt;code&gt;JShell&lt;/code&gt; 상태 의 컨텍스트에서 ).</target>
        </trans-unit>
        <trans-unit id="36fb7e093d326a223b05fe5aa66add48a7b56c11" translate="yes" xml:space="preserve">
          <source>The snippet is a declaration snippet with potentially recoverable unresolved references or other issues in its body (in the context of current &lt;code&gt;JShell&lt;/code&gt; state). Only a &lt;a href=&quot;declarationsnippet&quot;&gt;&lt;code&gt;DeclarationSnippet&lt;/code&gt;&lt;/a&gt; can have this &lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">스 니펫은 잠재적으로 복구 가능한 미해결 참조 또는 본문에 기타 문제가있는 선언 스 니펫입니다 (현재 &lt;code&gt;JShell&lt;/code&gt; 상태 의 컨텍스트에서 ). &lt;a href=&quot;declarationsnippet&quot;&gt; &lt;code&gt;DeclarationSnippet&lt;/code&gt; &lt;/a&gt; 만이 &lt;code&gt;Status&lt;/code&gt; 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c076e442c29974123067f6dd99c7c848ad814370" translate="yes" xml:space="preserve">
          <source>The snippet is a valid snippet (in the context of current &lt;code&gt;JShell&lt;/code&gt; state).</source>
          <target state="translated">스 니펫은 유효한 스 니펫 (현재 &lt;code&gt;JShell&lt;/code&gt; 상태 의 컨텍스트에서 )입니다.</target>
        </trans-unit>
        <trans-unit id="01367707922b92652ec5a4fa560e56793668f4c1" translate="yes" xml:space="preserve">
          <source>The snippet is a valid snippet (in the context of current &lt;code&gt;JShell&lt;/code&gt; state). Only snippets with &lt;code&gt;VALID&lt;/code&gt;&lt;code&gt;Status&lt;/code&gt; can be executed (though not all &lt;code&gt;VALID&lt;/code&gt; snippets have executable code).</source>
          <target state="translated">스 니펫은 유효한 스 니펫 (현재 &lt;code&gt;JShell&lt;/code&gt; 상태 의 컨텍스트에서 )입니다. &lt;code&gt;VALID&lt;/code&gt; &lt;code&gt;Status&lt;/code&gt; 스 니펫 만 실행할 수 있습니다 (모든 &lt;code&gt;VALID&lt;/code&gt; 스 니펫에 실행 코드가있는 것은 아님 ).</target>
        </trans-unit>
        <trans-unit id="86ed097e60ce8d08b4843b18da7a9b776540867e" translate="yes" xml:space="preserve">
          <source>The snippet is defined (&lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined() == true&lt;/code&gt;&lt;/a&gt;). If the snippet is a declaration or import (&lt;a href=&quot;snippet.kind#isPersistent()&quot;&gt;&lt;code&gt;Snippet.Kind.isPersistent()&lt;/code&gt;&lt;/a&gt;), it is visible to other snippets</source>
          <target state="translated">스 니펫이 정의되었습니다 ( &lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined() == true&lt;/code&gt; &lt;/a&gt; ). 스 니펫이 선언 또는 가져 오기 ( &lt;a href=&quot;snippet.kind#isPersistent()&quot;&gt; &lt;code&gt;Snippet.Kind.isPersistent()&lt;/code&gt; &lt;/a&gt; )이면 다른 스 니펫에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cd5904cbd3573e566ff1f2085feb79f7f3379232" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it does not yet exist.</source>
          <target state="translated">스 니펫이 아직 존재하지 않기 때문에 비활성 상태입니다.</target>
        </trans-unit>
        <trans-unit id="9a62709f6052670bec0af74609b5b12c267407e4" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it does not yet exist. Used only in &lt;code&gt;SnippetEvent.previousStatus&lt;/code&gt; for new snippets. &lt;a href=&quot;jshell#status(jdk.jshell.Snippet)&quot;&gt;&lt;code&gt;JShell.status(Snippet)&lt;/code&gt;&lt;/a&gt; will never return this &lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">스 니펫이 아직 존재하지 않기 때문에 비활성 상태입니다. 새 스 니펫의 &lt;code&gt;SnippetEvent.previousStatus&lt;/code&gt; 에서만 사용됩니다 . &lt;a href=&quot;jshell#status(jdk.jshell.Snippet)&quot;&gt; &lt;code&gt;JShell.status(Snippet)&lt;/code&gt; &lt;/a&gt; 는이 &lt;code&gt;Status&lt;/code&gt; 를 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="46041cbcdec9e126fee187edfd581d626cd40425" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it failed compilation on initial evaluation and it is not capable of becoming valid with further changes to the JShell state.</source>
          <target state="translated">스 니펫은 초기 평가에서 컴파일에 실패하고 JShell 상태를 추가로 변경해도 유효하지 않기 때문에 비활성 상태입니다.</target>
        </trans-unit>
        <trans-unit id="ff59f9e01cd5b521bc7b8652604d7c50cd0bb4a8" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it has been replaced by a new snippet.</source>
          <target state="translated">스 니펫이 새 스 니펫으로 대체 되었기 때문에 비활성 상태입니다.</target>
        </trans-unit>
        <trans-unit id="7b34acaafe0b4b06404d2342a73ac1d09caae77c" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because it has been replaced by a new snippet. This occurs when the new snippet added with &lt;a href=&quot;jshell#eval(java.lang.String)&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; matches a previous snippet. A &lt;code&gt;TypeDeclSnippet&lt;/code&gt; will match another &lt;code&gt;TypeDeclSnippet&lt;/code&gt; if the names match. For example &lt;code&gt;class X { }&lt;/code&gt; will overwrite &lt;code&gt;class X { int ii; }&lt;/code&gt; or &lt;code&gt;interface X { }&lt;/code&gt;. A &lt;code&gt;MethodSnippet&lt;/code&gt; will match another &lt;code&gt;MethodSnippet&lt;/code&gt; if the names and parameter types match. For example &lt;code&gt;void m(int a) { }&lt;/code&gt; will overwrite &lt;code&gt;int m(int a) { return a+a; }&lt;/code&gt;. A &lt;code&gt;VarSnippet&lt;/code&gt; will match another &lt;code&gt;VarSnippet&lt;/code&gt; if the names match. For example &lt;code&gt;double z;&lt;/code&gt; will overwrite &lt;code&gt;long z = 2L;&lt;/code&gt;. Only a &lt;a href=&quot;persistentsnippet&quot;&gt;&lt;code&gt;PersistentSnippet&lt;/code&gt;&lt;/a&gt; can have this &lt;code&gt;Status&lt;/code&gt;.</source>
          <target state="translated">스 니펫이 새 스 니펫으로 대체 되었기 때문에 비활성 상태입니다. 이는 &lt;a href=&quot;jshell#eval(java.lang.String)&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 과 함께 추가 된 새 스 니펫 이 이전 스 니펫과 일치 할 때 발생합니다 . &lt;code&gt;TypeDeclSnippet&lt;/code&gt; 는 다른 일치 &lt;code&gt;TypeDeclSnippet&lt;/code&gt; 을 이름이 일치합니다. 예를 들어, &lt;code&gt;class X { }&lt;/code&gt; 는 &lt;code&gt;class X { int ii; }&lt;/code&gt; 덮어 씁니다 . } 또는 &lt;code&gt;interface X { }&lt;/code&gt; . &lt;code&gt;MethodSnippet&lt;/code&gt; 는 다른 일치 &lt;code&gt;MethodSnippet&lt;/code&gt; 을 이름과 매개 변수 형식이 일치합니다. 예를 들어 &lt;code&gt;void m(int a) { }&lt;/code&gt; 는 &lt;code&gt;int m(int a) { return a+a; }&lt;/code&gt; . &lt;code&gt;VarSnippet&lt;/code&gt; 는 다른 일치 &lt;code&gt;VarSnippet&lt;/code&gt; 을이름이 일치하면. 예를 들어 &lt;code&gt;double z;&lt;/code&gt; &lt;code&gt;long z = 2L;&lt;/code&gt; 을 덮어 씁니다 . . &lt;a href=&quot;persistentsnippet&quot;&gt; &lt;code&gt;PersistentSnippet&lt;/code&gt; &lt;/a&gt; 만이 &lt;code&gt;Status&lt;/code&gt; 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be7fc269089662edb796c5aac76419901a949bde" translate="yes" xml:space="preserve">
          <source>The snippet is inactive because of an explicit call to the &lt;a href=&quot;jshell#drop(jdk.jshell.Snippet)&quot;&gt;&lt;code&gt;JShell.drop(Snippet)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코드 조각은 &lt;a href=&quot;jshell#drop(jdk.jshell.Snippet)&quot;&gt; &lt;code&gt;JShell.drop(Snippet)&lt;/code&gt; &lt;/a&gt; 에 대한 명시적인 호출로 인해 비활성 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="88904de386c079fccf3f30e7b543e31de3c3761f" translate="yes" xml:space="preserve">
          <source>The snippet is not visible to other snippets (&lt;a href=&quot;#isDefined()&quot;&gt;&lt;code&gt;isDefined() == false&lt;/code&gt;&lt;/a&gt;) and thus cannot be referenced or executed.</source>
          <target state="translated">스 니펫은 다른 스 니펫 ( &lt;a href=&quot;#isDefined()&quot;&gt; &lt;code&gt;isDefined() == false&lt;/code&gt; &lt;/a&gt; )에 표시되지 않으므로 참조하거나 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd303338297041406f7184b465492cfc79af727e" translate="yes" xml:space="preserve">
          <source>The snippet will not update as dependents change (&lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive() == false&lt;/code&gt;&lt;/a&gt;), its &lt;code&gt;Status&lt;/code&gt; will never change again.</source>
          <target state="translated">스 니펫은 종속 항목이 변경 될 때 업데이트되지 않으며 ( &lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive() == false&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;Status&lt;/code&gt; 가 다시 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b1f33d6505253b243833ef1169501d91d39c62e" translate="yes" xml:space="preserve">
          <source>The snippet will update as dependents change (&lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive() == true&lt;/code&gt;&lt;/a&gt;), its status could become &lt;code&gt;RECOVERABLE_DEFINED&lt;/code&gt;, &lt;code&gt;RECOVERABLE_NOT_DEFINED&lt;/code&gt;, &lt;code&gt;DROPPED&lt;/code&gt;, or &lt;code&gt;OVERWRITTEN&lt;/code&gt;.</source>
          <target state="translated">스 니펫은 종속 항목이 변경되면 ( &lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive() == true&lt;/code&gt; &lt;/a&gt; ) 업데이트되며 상태는 &lt;code&gt;RECOVERABLE_DEFINED&lt;/code&gt; , &lt;code&gt;RECOVERABLE_NOT_DEFINED&lt;/code&gt; , &lt;code&gt;DROPPED&lt;/code&gt; 또는 &lt;code&gt;OVERWRITTEN&lt;/code&gt; 이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b1eec2fab48735c90d5772f07bce5da4abb91fe" translate="yes" xml:space="preserve">
          <source>The snippet will update as dependents change (&lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive() == true&lt;/code&gt;&lt;/a&gt;), its status could become &lt;code&gt;VALID&lt;/code&gt;, &lt;code&gt;RECOVERABLE_DEFINED&lt;/code&gt;, &lt;code&gt;DROPPED&lt;/code&gt;, or &lt;code&gt;OVERWRITTEN&lt;/code&gt;.</source>
          <target state="translated">스 니펫은 종속 항목이 변경되면 ( &lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive() == true&lt;/code&gt; &lt;/a&gt; ) 업데이트되며 상태는 &lt;code&gt;VALID&lt;/code&gt; , &lt;code&gt;RECOVERABLE_DEFINED&lt;/code&gt; , &lt;code&gt;DROPPED&lt;/code&gt; 또는 &lt;code&gt;OVERWRITTEN&lt;/code&gt; 이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752e212aff543f906f63d7b8eebdaaa65a70207e" translate="yes" xml:space="preserve">
          <source>The snippet will update as dependents change (&lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;isActive() == true&lt;/code&gt;&lt;/a&gt;), its status could become &lt;code&gt;VALID&lt;/code&gt;, &lt;code&gt;RECOVERABLE_NOT_DEFINED&lt;/code&gt;, &lt;code&gt;DROPPED&lt;/code&gt;, or &lt;code&gt;OVERWRITTEN&lt;/code&gt;.</source>
          <target state="translated">스 니펫은 종속 항목이 변경되면 ( &lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;isActive() == true&lt;/code&gt; &lt;/a&gt; ) 업데이트되며 상태는 &lt;code&gt;VALID&lt;/code&gt; , &lt;code&gt;RECOVERABLE_NOT_DEFINED&lt;/code&gt; , &lt;code&gt;DROPPED&lt;/code&gt; 또는 &lt;code&gt;OVERWRITTEN&lt;/code&gt; 이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34a10ed96641b907e1eb213e81431652411700a" translate="yes" xml:space="preserve">
          <source>The socket address that the socket is bound to, or &lt;code&gt;null&lt;/code&gt; if the channel's socket is not bound</source>
          <target state="translated">소켓이 바인드 된 소켓 주소 또는 채널의 소켓이 바인드되지 않은 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="450eed1463cf271b1ec0cb13231cb29de59dc30a" translate="yes" xml:space="preserve">
          <source>The socket address, or &lt;code&gt;null&lt;/code&gt; if this instance is to be used for sending a message and has been construced without specifying a preferred destination address</source>
          <target state="translated">소켓 주소. 이 인스턴스가 메시지를 보내는 데 사용되며 선호하는 대상 주소를 지정하지 않고 해석 된 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004c4bf3ac859ce08e79a8b3e914c8cf5426cb22" translate="yes" xml:space="preserve">
          <source>The socket channel for the new connection, or &lt;code&gt;null&lt;/code&gt; if this channel is in non-blocking mode and no connection is available to be accepted</source>
          <target state="translated">새로운 접속의 소켓 채널. 이 채널이 비 블로킹 모드에있어 접속 가능한 접속이없는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72330096ca60d13bfb3300d243f2b2b77e32b537" translate="yes" xml:space="preserve">
          <source>The socket channel returned by this method, if any, will be in blocking mode regardless of the blocking mode of this channel.</source>
          <target state="translated">이 메소드에 의해 돌려 주어진 소켓 채널은,이 채널의 블록킹 모드에 관계없이 차단 모드에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="0916495727f93025eff6a66cbf7b722521e11aa1" translate="yes" xml:space="preserve">
          <source>The socket factories are used when creating sockets for secure https URL connections.</source>
          <target state="translated">소켓 팩토리는 안전한 https URL 연결을위한 소켓을 만들 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad5881f1dd9699e6809bd7cb33d457d13c6558c9" translate="yes" xml:space="preserve">
          <source>The socket option is read-only and an attempt to set the socket option will throw &lt;code&gt;SocketException&lt;/code&gt;.</source>
          <target state="translated">소켓 옵션은 읽기 전용이며 소켓 옵션을 설정하려고하면 &lt;code&gt;SocketException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b9b1dacea19873875bd394d1604a0e5a5d30890d" translate="yes" xml:space="preserve">
          <source>The sockets returned to the application can be subclasses of java.net.Socket, so that they can directly expose new APIs for features such as compression, security, record marking, statistics collection, or firewall tunneling.</source>
          <target state="translated">애플리케이션에 리턴 된 소켓은 java.net.Socket의 서브 클래스 일 수 있으므로 압축, 보안, 레코드 표시, 통계 콜렉션 또는 방화벽 터널링과 같은 기능에 대한 새 API를 직접 노출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e877bbc8bfc38843765b0308b8332044317fbf2a" translate="yes" xml:space="preserve">
          <source>The sole constructor.</source>
          <target state="translated">유일한 생성자.</target>
        </trans-unit>
        <trans-unit id="d5d133be61491e0ac1417ab0eba748b3aa345615" translate="yes" xml:space="preserve">
          <source>The sole purpose of these additions is to allow the specification of tables for use in decoding abbreviated streams. The built-in JPEG reader will also accept an ordinary &lt;code&gt;ImageReadParam&lt;/code&gt;, which is sufficient for decoding non-abbreviated streams.</source>
          <target state="translated">이러한 추가의 유일한 목적은 축약 된 스트림을 디코딩하는 데 사용하기위한 테이블 지정을 허용하는 것입니다. 내장 JPEG 리더는 일반 &lt;code&gt;ImageReadParam&lt;/code&gt; 을 수용하므로 단축되지 않은 스트림을 디코딩하는 데 충분합니다.</target>
        </trans-unit>
        <trans-unit id="a6c3a336ac8595f00b634d72ee534ceffed81b71" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations.</source>
          <target state="translated">정렬 알고리즘은 Vladimir Yaroslavskiy, Jon Bentley 및 Josh Bloch의 Dual-Pivot Quicksort입니다. 이 알고리즘은 모든 데이터 세트에서 O (n log (n)) 성능을 제공하며 일반적으로 기존 (1 피벗) Quicksort 구현보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="0f89eabf4c727d37647595fc5e3c16a6a2f03dd3" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on all data sets, and is typically faster than traditional (one-pivot) Quicksort implementations.</source>
          <target state="translated">정렬 알고리즘은 Vladimir Yaroslavskiy, Jon Bentley 및 Joshua Bloch의 Dual-Pivot Quicksort입니다. 이 알고리즘은 모든 데이터 세트에서 O (n log (n)) 성능을 제공하며 일반적으로 기존 (1 피벗) Quicksort 구현보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="89b93c3df541630653c18e1886ceb597afae62a2" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="784cdcae362dc5581521030a458ea9926ba3223b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(byte%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="7ff5d937d432a11ea2a201ecc58034dd5441a852" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="2e5b7af711e48ed5dc89614218be16edbd43e49c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(char%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="2fddd1310d77bbe7f9dfe3d3aa01ae962a906b1b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="02eeb024eac83701cb3dab1984790a4264154db6" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(double%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="4f90425a9cfcd671163aa3ba4f42ed3b9d2bc3a4" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="275540cfb6a8e26c5b313f0e391cacb2ad9d0076" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(float%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="94b575be4e8e24c03f457815c4ac16e5b75c882e" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="6ee0d5b8c7e0d8151809c5f26bb13f06d5c6f2a1" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(int%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="5e68b55659f65572149d90497e01649faf00e021" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="be292033b578af0efd8258008b00c522a942cd0c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="4939742092d60ecdc9f5ff5d5d17f5c9210da4ff" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="311db9e136afe682fa40514c417dc4d15f8e69c5" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(long%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="1fde7bfb5ab47c4ddc5c959bc79b4e7eb9f4030c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="c9a68b6c5882885166c6b5b6d4f8f9f68a7f939b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;#sort(short%5B%5D)&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool()&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; is used to execute any parallel tasks.</target>
        </trans-unit>
        <trans-unit id="38844e94f41cc1969fb62e4894696634a14fe20b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="75b2a84749a330a1c0b895e2bdf2312622f71cb8" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-byte:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="20a31ccdaba6cb746cb91c886a84a8c2d7c538b7" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="48b9a8628a4883f257650b1adf775491c8f08839" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-char:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-char:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="d3cac5983cf37dcfe292291f746e0459fd7e8669" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="08eda0222f2f9308c70c208bbdafe98a9e736807" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-double:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-double:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="1b5efb4aa3ea50144cc0394f060b745aadbd838e" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="b9ac2ce61dcea76b147223bff87472496593df2a" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-float:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 하위 배열은 적절한&lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-float:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="ff09cbb5362e1360ac15f00a55f46a71d4e41ca1" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 서브 어레이 길이가 최소 입도에 도달하면, 서브 어레이를 사용하여 적절한 정렬 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="edc68fa2b5db74746879cf023d506ffd46c30425" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-int:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 서브 어레이 길이가 최소 입도에 도달하면, 서브 어레이를 사용하여 적절한 정렬 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-int:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="839592e0ded3d9de75771fbf4886b637ea10acea" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="614e7b8df8741ffaa018e919714cf7473694c642" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-java.lang.Object:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="648b93b50bbd09b1605688594b8660ecbbb90d1b" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작은 경우 적절한 배열을 사용하여 정렬됩니다&lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="0247ed33cde4f71d592e6d7daa37c7760b936d47" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-long:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 작은 최소 단위보다 긴 경우, 그것은 적절한하여 정렬 &lt;a href=&quot;arrays#sort-long:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; 에를&lt;/a&gt; 메서드를 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="777d40468912737a83340f22bc67c6f77af71aaf" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 알고리즘에는 원래 배열의 크기보다 크지 않은 작업 공간이 필요합니다. &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="e41f68150d548775a312ef7c6bad1b753c9c647c" translate="yes" xml:space="preserve">
          <source>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate &lt;a href=&quot;arrays#sort-short:A-&quot;&gt;&lt;code&gt;Arrays.sort&lt;/code&gt;&lt;/a&gt; method. The algorithm requires a working space no greater than the size of the specified range of the original array. The &lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt;&lt;code&gt;ForkJoin common pool&lt;/code&gt;&lt;/a&gt; is used to execute any parallel tasks.</source>
          <target state="translated">정렬 알고리즘은 병렬 정렬 병합으로, 배열을 자체적으로 정렬 한 다음 병합하는 하위 배열로 나눕니다. 하위 배열 길이가 최소 입도에 도달하면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 하위 배열이 정렬됩니다 . 지정된 배열의 길이가 최소 입도보다 작 으면 적절한 &lt;a href=&quot;arrays#sort-short:A-&quot;&gt; &lt;code&gt;Arrays.sort&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 정렬됩니다 . 이 알고리즘에는 원래 배열의 지정된 범위 크기보다 크지 않은 작업 공간이 필요합니다. 그만큼&lt;a href=&quot;concurrent/forkjoinpool#commonPool--&quot;&gt; &lt;code&gt;ForkJoin common pool&lt;/code&gt; &lt;/a&gt; 임의의 병렬 작업을 실행하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="b4ca5b611518435cd08b1d3ce800c9c8f468a67f" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;DocumentView&lt;/code&gt; of which this is an &lt;code&gt;AbstractView&lt;/code&gt;.</source>
          <target state="translated">The source &lt;code&gt;DocumentView&lt;/code&gt; of which this is an &lt;code&gt;AbstractView&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55944b789daff6ef5841d9434f11985f49ff23c4" translate="yes" xml:space="preserve">
          <source>The source actions represent the set of actions supported by the source of this transfer, and are represented as some bitwise-OR combination of &lt;code&gt;COPY&lt;/code&gt;, &lt;code&gt;MOVE&lt;/code&gt; and &lt;code&gt;LINK&lt;/code&gt;. You may wish to query this in &lt;code&gt;TransferHandler&lt;/code&gt;'s &lt;code&gt;canImport&lt;/code&gt; method when determining the suitability of a drop or when deciding on a drop action to explicitly choose. To determine if a particular action is supported by the source, bitwise-AND the action with the source drop actions, and then compare the result against the original action. For example:</source>
          <target state="translated">The source actions represent the set of actions supported by the source of this transfer, and are represented as some bitwise-OR combination of &lt;code&gt;COPY&lt;/code&gt; , &lt;code&gt;MOVE&lt;/code&gt; and &lt;code&gt;LINK&lt;/code&gt; . You may wish to query this in &lt;code&gt;TransferHandler&lt;/code&gt; 's &lt;code&gt;canImport&lt;/code&gt; method when determining the suitability of a drop or when deciding on a drop action to explicitly choose. To determine if a particular action is supported by the source, bitwise-AND the action with the source drop actions, and then compare the result against the original action. For example:</target>
        </trans-unit>
        <trans-unit id="368f0e5364e526b1a62ff1d9e84b032a4799d112" translate="yes" xml:space="preserve">
          <source>The source address if this membership key is source-specific, otherwise &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">이 멤버쉽 키가 소스 별 인 경우 소스 주소 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49ef1bc740369619f8b5584da49f9c3ff9ac10f5" translate="yes" xml:space="preserve">
          <source>The source and destination must be different.</source>
          <target state="translated">The source and destination must be different.</target>
        </trans-unit>
        <trans-unit id="1c54b79003a5eb4cba89a06459605f65bd7f13fd" translate="yes" xml:space="preserve">
          <source>The source bean is used as the source of events for the property changes. This source should be used for information purposes only and should not be modified by the PropertyEditor.</source>
          <target state="translated">소스 Bean은 특성 변경에 대한 이벤트 소스로 사용됩니다. 이 소스는 정보 용으로 만 사용해야하며 PropertyEditor에서 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d614f9d4f31f56431b30829db0ada88a1526496a" translate="yes" xml:space="preserve">
          <source>The source cannot be structurally interfered with.</source>
          <target state="translated">소스는 구조적으로 방해 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61689ca13fa0754b0dac1fef1851f1593b2946cb" translate="yes" xml:space="preserve">
          <source>The source format represents the format of the incoming audio data, which will be converted.</source>
          <target state="translated">소스 형식은 들어오는 오디오 데이터의 형식을 나타내며 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="46df136cd9cc4668c308b326cb05d7ed6808c192" translate="yes" xml:space="preserve">
          <source>The source increases the likelihood of throwing &lt;code&gt;ConcurrentModificationException&lt;/code&gt; since the window of potential interference is larger.</source>
          <target state="translated">잠재적 인 간섭의 창이 더 크기 때문에 소스는 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 던질 가능성을 높입니다 .</target>
        </trans-unit>
        <trans-unit id="c1f61cf74a08642c4ff7ee4b8bc3cda7829bff8b" translate="yes" xml:space="preserve">
          <source>The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction.</source>
          <target state="translated">소스는 구성 후에 감지되지 않은 간섭이 발생할 수 있으므로 임의의 비 결정적 동작의 위험을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="03565c55ce32575c338f8855e376da1747bff628" translate="yes" xml:space="preserve">
          <source>The source information for a Location is dependent on the</source>
          <target state="translated">위치에 대한 소스 정보는</target>
        </trans-unit>
        <trans-unit id="03d33500fcd4a667ea73efed98252841199edc27" translate="yes" xml:space="preserve">
          <source>The source is composited over the destination (Porter-Duff Source Over Destination rule).</source>
          <target state="translated">The source is composited over the destination (Porter-Duff Source Over Destination rule).</target>
        </trans-unit>
        <trans-unit id="dfdd906a9cfc82513a491834d2af899dcb03b222" translate="yes" xml:space="preserve">
          <source>The source is copied to the destination (Porter-Duff Source rule).</source>
          <target state="translated">The source is copied to the destination (Porter-Duff Source rule).</target>
        </trans-unit>
        <trans-unit id="29c343852025e2139effd2803766c6065e489fe6" translate="yes" xml:space="preserve">
          <source>The source is copied to the destination (Porter-Duff Source rule). The destination is not used as input.</source>
          <target state="translated">The source is copied to the destination (Porter-Duff Source rule). The destination is not used as input.</target>
        </trans-unit>
        <trans-unit id="7f5e35322fb74527344b994cfeb8d4a21c655439" translate="yes" xml:space="preserve">
          <source>The source manages concurrent modifications.</source>
          <target state="translated">소스는 동시 수정을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="cc3c2e9f00eb13dba6597fe19ebf6cc799eb8981" translate="yes" xml:space="preserve">
          <source>The source may be divided and mapped to different locations within the wrapped source.</source>
          <target state="translated">소스는 분할되어 래핑 된 소스 내의 다른 위치에 매핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a5d1008eaa1af299fb1410c7693c63aa92311bc" translate="yes" xml:space="preserve">
          <source>The source object is the Relation Service itself.</source>
          <target state="translated">소스 오브젝트는 관계 서비스 자체입니다.</target>
        </trans-unit>
        <trans-unit id="cc9b426ca5912c0c22947a2cdc8350ca098c22e1" translate="yes" xml:space="preserve">
          <source>The source object needing translating.</source>
          <target state="translated">번역이 필요한 원본 개체입니다.</target>
        </trans-unit>
        <trans-unit id="aa58c7b11a77f180bde4263ee0c9af48ad826837" translate="yes" xml:space="preserve">
          <source>The source of the event can be retrieved with the method &lt;code&gt;event.getSource&lt;/code&gt;.</source>
          <target state="translated">The source of the event can be retrieved with the method &lt;code&gt;event.getSource&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b758d7983ddc60e8668a83198491ca7fd663319" translate="yes" xml:space="preserve">
          <source>The source of the event can be retrieved with the method event.getSource.</source>
          <target state="translated">The source of the event can be retrieved with the method event.getSource.</target>
        </trans-unit>
        <trans-unit id="ba472d8058ce42e7759745b4cd537b6da4c0628f" translate="yes" xml:space="preserve">
          <source>The source of this event is the SSLSocket on which handshaking just completed.</source>
          <target state="translated">이 이벤트의 소스는 핸드 쉐이킹이 완료된 SSLSocket입니다.</target>
        </trans-unit>
        <trans-unit id="34b28226ae9b0c9b05be3b2b72d0f78f8a72db57" translate="yes" xml:space="preserve">
          <source>The source of this pattern</source>
          <target state="translated">이 패턴의 근원</target>
        </trans-unit>
        <trans-unit id="9d040b79148889dda3be3cace827402195b26754" translate="yes" xml:space="preserve">
          <source>The source region of interest specified by this method will be clipped as needed to fit within the source bounds, as well as the destination offsets, width, and height at the time of actual I/O.</source>
          <target state="translated">이 방법으로 지정된 소스 관심 영역은 실제 I / O시 대상 오프셋, 너비 및 높이뿐만 아니라 소스 경계 내에 맞추기 위해 필요에 따라 잘립니다.</target>
        </trans-unit>
        <trans-unit id="6c425edd2b72c5bd49ce0000e1e9c0d010d1b680" translate="yes" xml:space="preserve">
          <source>The source region, on &lt;code&gt;null&lt;/code&gt; if none is set.</source>
          <target state="translated">소스 영역 . 설정되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79992770a23d8083e338e39d04240948297bfa86" translate="yes" xml:space="preserve">
          <source>The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected.</source>
          <target state="translated">간섭이 감지되지 않기 때문에 통과가 시작된 후 소스는 임의의 비 결정적 동작의 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d10c68f89f90c7178d019f1f4c1c12f009d6876" translate="yes" xml:space="preserve">
          <source>The south layout constraint (bottom of container).</source>
          <target state="translated">The south layout constraint (bottom of container).</target>
        </trans-unit>
        <trans-unit id="e68ddcb7c0e62435f6fe1696214e8145cd3b4f3c" translate="yes" xml:space="preserve">
          <source>The south-east-resize cursor type.</source>
          <target state="translated">The south-east-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="73fec64518a4d7b3dec25260b8298e0b9bed5f17" translate="yes" xml:space="preserve">
          <source>The south-resize cursor type.</source>
          <target state="translated">The south-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="3b088fa20b66361bda186416ad335eb99b17d70b" translate="yes" xml:space="preserve">
          <source>The south-west-resize cursor type.</source>
          <target state="translated">The south-west-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="b1f69a5894aacc09dd4212a4b7863d5992a5dd30" translate="yes" xml:space="preserve">
          <source>The space between strings.</source>
          <target state="translated">The space between strings.</target>
        </trans-unit>
        <trans-unit id="7900bed2b0d5a0428294adba3589eaef49b81ef4" translate="yes" xml:space="preserve">
          <source>The space character &quot; &quot; is converted into a plus sign &quot;&lt;code&gt;+&lt;/code&gt;&quot;.</source>
          <target state="translated">공백 문자 &quot;&quot;는 더하기 부호 &quot; &lt;code&gt;+&lt;/code&gt; &quot; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="507149f00d63c959176bee1f4d30e062fc83fdd7" translate="yes" xml:space="preserve">
          <source>The special characters &quot;&lt;code&gt;.&lt;/code&gt;&quot;, &quot;&lt;code&gt;-&lt;/code&gt;&quot;, &quot;&lt;code&gt;*&lt;/code&gt;&quot;, and &quot;&lt;code&gt;_&lt;/code&gt;&quot; remain the same.</source>
          <target state="translated">특수 문자 &quot; &lt;code&gt;.&lt;/code&gt; &quot;, &quot; &lt;code&gt;-&lt;/code&gt; &quot;, &quot; &lt;code&gt;*&lt;/code&gt; &quot;및 &quot; &lt;code&gt;_&lt;/code&gt; &quot;는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="554ae3414c670a7436c25a4064ec6ae6a231747b" translate="yes" xml:space="preserve">
          <source>The special method &lt;a href=&quot;#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt;&lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</source>
          <target state="translated">The special method &lt;a href=&quot;#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt; &lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</target>
        </trans-unit>
        <trans-unit id="a9d1df01fb5b8d33027995ef22465c9c621f1abe" translate="yes" xml:space="preserve">
          <source>The special method &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt;&lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt;&lt;/a&gt; determines whether an access request indicated by a specified permission should be granted or denied. The default implementation calls</source>
          <target state="translated">특수 메소드 &lt;a href=&quot;securitymanager#checkPermission-java.security.Permission-&quot;&gt; &lt;code&gt;checkPermission(java.security.Permission)&lt;/code&gt; &lt;/a&gt; 은 지정된 권한으로 표시된 액세스 요청을 승인할지 거부 할지를 결정합니다. 기본 구현 호출</target>
        </trans-unit>
        <trans-unit id="0f63e638f0c9b18504ea41e24439a23387628a9a" translate="yes" xml:space="preserve">
          <source>The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;#UNKNOWN_ATTRIBUTE&quot;&gt;&lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</source>
          <target state="translated">The special strings &lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;#UNKNOWN_ATTRIBUTE&quot;&gt; &lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt; &lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</target>
        </trans-unit>
        <trans-unit id="32010eba7b4259d4453391d1922bfa0e43808b88" translate="yes" xml:space="preserve">
          <source>The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed, with the same meaning as &lt;a href=&quot;pack200.packer#UNKNOWN_ATTRIBUTE&quot;&gt;&lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt;&lt;/a&gt;. This provides a way for users to request that specific attributes be refused, stripped, or passed bitwise (with no class compression).</source>
          <target state="translated">&lt;a href=&quot;pack200.packer#UNKNOWN_ATTRIBUTE&quot;&gt; &lt;code&gt;UNKNOWN_ATTRIBUTE&lt;/code&gt; &lt;/a&gt; 와 같은 의미로 특수 문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다 . 이를 통해 사용자는 클래스 압축없이 특정 속성을 거부, 제거 또는 비트 단위로 전달하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a13bd69809d0a0a05735ac36655ba584ce36412" translate="yes" xml:space="preserve">
          <source>The special value 0 instructs the packer to copy through the original JAR file directly, with no compression. The JSR 200 standard requires any unpacker to understand this special case as a pass-through of the entire archive.</source>
          <target state="translated">특수 값 0은 압축하지 않고 패커가 원본 JAR 파일을 직접 복사하도록 지시합니다. JSR 200 표준은 압축 풀기 사용자가이 특수 사례를 전체 아카이브의 통과로 이해하도록 요구합니다.</target>
        </trans-unit>
        <trans-unit id="d43aa293b92f885948dfdec9b93e9f6263ba164c" translate="yes" xml:space="preserve">
          <source>The specialized subtype default implementations of &lt;a href=&quot;iterator#next()&quot;&gt;&lt;code&gt;Iterator.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining(java.util.function.Consumer)&quot;&gt;&lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt()&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.IntConsumer)&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next()&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.Consumer)&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The specialized subtype default implementations of &lt;a href=&quot;iterator#next()&quot;&gt; &lt;code&gt;Iterator.next()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining(java.util.function.Consumer)&quot;&gt; &lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt()&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.IntConsumer)&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next()&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining(java.util.function.Consumer)&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bb3de17aa29974030176e4818ff90fa588d4cccd" translate="yes" xml:space="preserve">
          <source>The specialized subtype default implementations of &lt;a href=&quot;iterator#next--&quot;&gt;&lt;code&gt;Iterator.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt; box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt;&lt;/a&gt; should be used in preference to &lt;a href=&quot;primitiveiterator.ofint#next--&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.Consumer-&quot;&gt;&lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iterator#next--&quot;&gt; &lt;code&gt;Iterator.next()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;iterator#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;Iterator.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt; 상자 기본 값 의 특수 하위 유형 기본 구현은 해당 랩퍼 클래스의 인스턴스에 적용됩니다. 이러한 복싱은 원시 전문화를 사용할 때 얻는 모든 이점을 상쇄 할 수 있습니다. 복싱을 피하려면 해당하는 기본 기반 방법을 사용해야합니다. 예를 들어 &lt;a href=&quot;primitiveiterator.ofint#nextInt--&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.nextInt()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.IntConsumer-&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.IntConsumer)&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;primitiveiterator.ofint#next--&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.next()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;primitiveiterator.ofint#forEachRemaining-java.util.function.Consumer-&quot;&gt; &lt;code&gt;PrimitiveIterator.OfInt.forEachRemaining(java.util.function.Consumer)&lt;/code&gt; &lt;/a&gt;) 보다 우선적으로 사용해야합니다. 소비자) .</target>
        </trans-unit>
        <trans-unit id="50f407aa7fac51cbfd7197c06936b8340a15f9e5" translate="yes" xml:space="preserve">
          <source>The specification and implementation titles, versions, and vendors are unspecified.</source>
          <target state="translated">The specification and implementation titles, versions, and vendors are unspecified.</target>
        </trans-unit>
        <trans-unit id="d6f9034bc2b0e9e47c35477b9b0c1050884a6e58" translate="yes" xml:space="preserve">
          <source>The specification of &lt;a href=&quot;#floatDWidth&quot;&gt;width&lt;/a&gt; and &lt;a href=&quot;#floatDPrec&quot;&gt;precision&lt;/a&gt; is the same as defined for Float and Double.</source>
          <target state="translated">&lt;a href=&quot;#floatDWidth&quot;&gt;너비&lt;/a&gt; 와 &lt;a href=&quot;#floatDPrec&quot;&gt;정밀도&lt;/a&gt; 의 지정은 Float 및 Double에 정의 된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fa9ee937f65b438b3e28d90ed076c5fb130b0ebe" translate="yes" xml:space="preserve">
          <source>The specification of &lt;a href=&quot;#intWidth&quot;&gt;width&lt;/a&gt; is the same as defined for Byte, Short, Integer, and Long.</source>
          <target state="translated">의 사양 &lt;a href=&quot;#intWidth&quot;&gt;폭은&lt;/a&gt; Byte, Short, Integer, 및 Long로 정의 된 사양과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a10ca3cba79e422f1740bb3e0934c522a4f1925b" translate="yes" xml:space="preserve">
          <source>The specification of the &lt;a href=&quot;../nio/charset/charset&quot;&gt;&lt;code&gt;java.nio.charset.Charset&lt;/code&gt;&lt;/a&gt; class describes the naming conventions for character encodings as well as the set of standard encodings that must be supported by every implementation of the Java platform.</source>
          <target state="translated">&lt;a href=&quot;../nio/charset/charset&quot;&gt; &lt;code&gt;java.nio.charset.Charset&lt;/code&gt; &lt;/a&gt; 클래스 의 스펙은 문자 인코딩의 이름 지정 규칙과 Java 플랫폼의 모든 구현에서 지원해야하는 표준 인코딩 세트를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5bc479f4b94e6ed3adb52c78855a8eaf971be4f5" translate="yes" xml:space="preserve">
          <source>The specifications of these methods enable implementations to employ efficient machine-level atomic instructions that are available on contemporary processors. However on some platforms, support may entail some form of internal locking. Thus the methods are not strictly guaranteed to be non-blocking -- a thread may block transiently before performing the operation.</source>
          <target state="translated">이러한 방법의 사양을 통해 구현시 최신 프로세서에서 사용할 수있는 효율적인 기계 수준의 원자 명령어를 사용할 수 있습니다. 그러나 일부 플랫폼에서는 일부 형태의 내부 잠금이 지원 될 수 있습니다. 따라서이 방법은 비 차단임을 반드시 보장하지는 않습니다. 작업을 수행하기 전에 스레드가 일시적으로 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">지정된</target>
        </trans-unit>
        <trans-unit id="6ef62c35d30b6f6e7b7d2f2944ffd8af1accdeb5" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;CompositeData&lt;/code&gt; must have the following item names and item types to be valid.</source>
          <target state="translated">지정된 &lt;code&gt;CompositeData&lt;/code&gt; 가 유효하려면 다음 항목 이름 및 항목 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="62478b55800b13e9edc844048f06d81a5395c823" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;attributes&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;SecretKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;SecretKeyEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce6192f33f7b86e9ead09fddf2eb53ecad7d96e2" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;attributes&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;TrustedCertificateEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="d471977883e3ea29098c508c72fa94025049aa80" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;chain&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; are cloned before they are stored in the new &lt;code&gt;PrivateKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;chain&lt;/code&gt; 과 &lt;code&gt;attributes&lt;/code&gt; 은 새 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 개체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="feecfb1f75d3f2369d375a91acbc68cab6f7dc08" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;chain&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PrivateKeyEntry&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;chain&lt;/code&gt; 은 새로운 &lt;code&gt;PrivateKeyEntry&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="91787ab6a545bac8438e8b3009f062a3b8a33372" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;name&lt;/code&gt; cannot begin with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, since all classes in the &quot;&lt;code&gt;java.*&lt;/code&gt; packages can only be defined by the bootstrap class loader. If &lt;code&gt;name&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be equal to the &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class specified by the byte array &quot;&lt;code&gt;b&lt;/code&gt;&quot;, otherwise a &lt;a href=&quot;noclassdeffounderror&quot;&gt;&lt;code&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">&quot; &lt;code&gt;java.*&lt;/code&gt; 패키지 의 모든 클래스 는 부트 스트랩 클래스 로더로만 정의 할 수 있으므로 지정된 &lt;code&gt;name&lt;/code&gt; 은&quot; &lt;code&gt;java.&lt;/code&gt; &quot;로 시작할 수 없습니다 . &lt;code&gt;name&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 , 지정된 클래스 의 &lt;a href=&quot;#name&quot;&gt;이진 이름&lt;/a&gt; 과 같아야합니다. 바이트 배열 &quot; &lt;code&gt;b&lt;/code&gt; &quot;, 그렇지 않으면 &lt;a href=&quot;noclassdeffounderror&quot;&gt; &lt;code&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eaef74f38f0fefbf6b797c4d769b36b62a96e610" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;password&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PasswordProtection&lt;/code&gt; object.</source>
          <target state="translated">지정된 &lt;code&gt;password&lt;/code&gt; 는 새 &lt;code&gt;PasswordProtection&lt;/code&gt; 객체에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="c18dc4bf1e553fd51a6ef779b53c94ede909086a" translate="yes" xml:space="preserve">
          <source>The specified MBean does not exist in the repository.</source>
          <target state="translated">지정된 MBean이 저장소에 없습니다.</target>
        </trans-unit>
        <trans-unit id="1da5f575f6552b129ebced03a3fcca62b2e49042" translate="yes" xml:space="preserve">
          <source>The specified MBean listener does not exist in the repository.</source>
          <target state="translated">지정된 MBean 리스너가 저장소에 없습니다.</target>
        </trans-unit>
        <trans-unit id="af5fc804aa4841cb6f3309cca620e06c665f28ff" translate="yes" xml:space="preserve">
          <source>The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt;. Other types are interpreted using &lt;a href=&quot;#from(java.time.temporal.TemporalAmount)&quot;&gt;&lt;code&gt;from(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt; . Other types are interpreted using &lt;a href=&quot;#from(java.time.temporal.TemporalAmount)&quot;&gt; &lt;code&gt;from(TemporalAmount)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="190c4561e923b6d02247206d09c8f34b9f935a7d" translate="yes" xml:space="preserve">
          <source>The specified amount is typically an instance of &lt;code&gt;Period&lt;/code&gt;. Other types are interpreted using &lt;a href=&quot;period#from-java.time.temporal.TemporalAmount-&quot;&gt;&lt;code&gt;from(TemporalAmount)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 금액은 일반적으로 &lt;code&gt;Period&lt;/code&gt; 인스턴스입니다 . 다른 유형은 &lt;a href=&quot;period#from-java.time.temporal.TemporalAmount-&quot;&gt; &lt;code&gt;from(TemporalAmount)&lt;/code&gt; &lt;/a&gt; 사용하여 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f3bf406b8fb479bb6ba897f4dfcf1ddc3eae351" translate="yes" xml:space="preserve">
          <source>The specified amount of real time has elapsed, more or less. If &lt;code&gt;timeout&lt;/code&gt; is zero, however, then real time is not taken into consideration and the thread simply waits until notified.</source>
          <target state="translated">지정된 실시간 시간이 다소 경과했습니다. 그러나 &lt;code&gt;timeout&lt;/code&gt; 가 0이면 실시간이 고려되지 않고 스레드가 통지 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="00452a58dccb117675d49a429b178f798add4786" translate="yes" xml:space="preserve">
          <source>The specified amount of real time has elapsed, more or less. The amount of real time, in nanoseconds, is given by the expression &lt;code&gt;1000000 * timeoutMillis + nanos&lt;/code&gt;. If &lt;code&gt;timeoutMillis&lt;/code&gt; and &lt;code&gt;nanos&lt;/code&gt; are both zero, then real time is not taken into consideration and the thread waits until awakened by one of the other causes.</source>
          <target state="translated">The specified amount of real time has elapsed, more or less. The amount of real time, in nanoseconds, is given by the expression &lt;code&gt;1000000 * timeoutMillis + nanos&lt;/code&gt; . If &lt;code&gt;timeoutMillis&lt;/code&gt; and &lt;code&gt;nanos&lt;/code&gt; are both zero, then real time is not taken into consideration and the thread waits until awakened by one of the other causes.</target>
        </trans-unit>
        <trans-unit id="2fb0d14ec3b91bd96d9fc6ab5161cd7aea17ba63" translate="yes" xml:space="preserve">
          <source>The specified attribute does not exist or cannot be retrieved.</source>
          <target state="translated">지정된 속성이 존재하지 않거나 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c4052d464c8f6871afa7336bc62a9e77ae7434b" translate="yes" xml:space="preserve">
          <source>The specified comparator is used to determine if two array elements from the each array are not equal.</source>
          <target state="translated">The specified comparator is used to determine if two array elements from the each array are not equal.</target>
        </trans-unit>
        <trans-unit id="2c8613acf6749ef0ed389aa41eb552a29cdf6d0d" translate="yes" xml:space="preserve">
          <source>The specified constructor is invoked with the arguments in the specified argument list. The invocation is synchronous; this method does not return until the constructor returns in the target VM. If the invoked method throws an exception, this method will throw an &lt;a href=&quot;invocationexception&quot;&gt;&lt;code&gt;InvocationException&lt;/code&gt;&lt;/a&gt; which contains a mirror to the exception object thrown.</source>
          <target state="translated">지정된 생성자는 지정된 인수 목록의 인수를 사용하여 호출됩니다. 호출은 동기식입니다. 이 메서드는 생성자가 대상 VM에서 반환 될 때까지 반환되지 않습니다. 호출 된 메서드가 예외를 throw하면이 메서드는 throw 된 예외 개체에 대한 미러를 포함 하는 &lt;a href=&quot;invocationexception&quot;&gt; &lt;code&gt;InvocationException&lt;/code&gt; &lt;/a&gt; 을 throw합니다.</target>
        </trans-unit>
        <trans-unit id="7b8d3e0653b6d1561f69a4fc51247490be2c9fff" translate="yes" xml:space="preserve">
          <source>The specified deadline elapses; or</source>
          <target state="translated">지정된 마감 시간이 경과합니다. 또는</target>
        </trans-unit>
        <trans-unit id="dfc1facec1624a9e49107544937a16179ab58cc9" translate="yes" xml:space="preserve">
          <source>The specified deadline passes; or</source>
          <target state="translated">지정된 마감일이 지났습니다. 또는</target>
        </trans-unit>
        <trans-unit id="5247131e5691f2b17d264ef1c3dfc670058c9a69" translate="yes" xml:space="preserve">
          <source>The specified default value.</source>
          <target state="translated">지정된 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5b4866a14164fbbb9168f172b4e6e8d7dc395270" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances.</source>
          <target state="translated">The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances.</target>
        </trans-unit>
        <trans-unit id="f68d5b41f2fafda46b89738c8f86f8e066852d0c" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances. If there is no exact match, the closest match is used.</source>
          <target state="translated">The specified dimensions are used to locate a matching &lt;code&gt;MediaSize&lt;/code&gt; instance from amongst all the standard &lt;code&gt;MediaSize&lt;/code&gt; instances. If there is no exact match, the closest match is used.</target>
        </trans-unit>
        <trans-unit id="310ae4a82260e2743fd9957091b33702914d499e" translate="yes" xml:space="preserve">
          <source>The specified dimensions are used to locate a matching MediaSize instance from amongst all the standard MediaSize instances. If there is no exact match, the closest match is used.</source>
          <target state="translated">지정된 차원은 모든 표준 MediaSize 인스턴스에서 일치하는 MediaSize 인스턴스를 찾는 데 사용됩니다. 정확히 일치하는 것이 없으면 가장 가까운 일치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="104dce0f8cf047aa941594c95f88524f18e28ce2" translate="yes" xml:space="preserve">
          <source>The specified list must be modifiable, but need not be resizable.</source>
          <target state="translated">지정된 목록은 수정 가능해야하지만 크기를 조정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f09ffd7e81a93fd6948e5a765fff32edb59db61" translate="yes" xml:space="preserve">
          <source>The specified map contains the current state of the parse. The map is mutable and must be mutated to resolve the field and any related fields. This method will only be invoked during parsing if the map contains this field, and implementations should therefore assume this field is present.</source>
          <target state="translated">지정된 맵에는 구문 분석의 현재 상태가 포함됩니다. 맵은 변경 가능하며 필드 및 관련 필드를 해결하려면 변경해야합니다. 이 메소드는 맵에이 필드가 포함 된 경우 구문 분석 중에 만 호출되므로 구현시이 필드가 있다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="493032b220120145406a2c95c31eb22182fdc14e" translate="yes" xml:space="preserve">
          <source>The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:</source>
          <target state="translated">지정된 맵은이 메소드가 호출 될 때 비어 있어야하며이 메소드가 리턴 된 후 직접 액세스해서는 안됩니다. 다음 코드 조각에 표시된대로 맵이 비어 있고이 메소드에 직접 전달되고 맵에 대한 참조가 유지되지 않으면 이러한 조건이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5458edf560d4ce470bc3f0200d198b4f628d8da9" translate="yes" xml:space="preserve">
          <source>The specified method is invoked with the arguments in the specified argument list. The method invocation is synchronous; this method does not return until the invoked method returns in the target VM. If the invoked method throws an exception, this method will throw an &lt;a href=&quot;invocationexception&quot;&gt;&lt;code&gt;InvocationException&lt;/code&gt;&lt;/a&gt; which contains a mirror to the exception object thrown.</source>
          <target state="translated">지정된 메소드는 지정된 인수 목록의 인수와 함께 호출됩니다. 메소드 호출은 동기식입니다. 이 메서드는 호출 된 메서드가 대상 VM에서 반환 될 때까지 반환되지 않습니다. 호출 된 메서드가 예외를 throw하면이 메서드는 throw 된 예외 개체에 대한 미러를 포함 하는 &lt;a href=&quot;invocationexception&quot;&gt; &lt;code&gt;InvocationException&lt;/code&gt; &lt;/a&gt; 을 throw합니다.</target>
        </trans-unit>
        <trans-unit id="e8d2949ab1852b4adf83258648df2f3d3aea9bdc" translate="yes" xml:space="preserve">
          <source>The specified number of bytes have been read,</source>
          <target state="translated">지정된 바이트 수를 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="04268be0844ec6f86b3371c45be5d6b167be71f6" translate="yes" xml:space="preserve">
          <source>The specified number of characters have been read,</source>
          <target state="translated">지정된 수의 문자를 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="9c75e9930b115a843435f6e70515c2fbf02a4ce1" translate="yes" xml:space="preserve">
          <source>The specified path is added to the end of the classpath used in eval().</source>
          <target state="translated">지정된 경로는 eval ()에서 사용되는 클래스 경로의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2c0a2d50122bd703c21aacfe280b277010cfa080" translate="yes" xml:space="preserve">
          <source>The specified path is added to the end of the classpath used in eval(). Note that the unnamed package is not accessible from the package in which &lt;a href=&quot;#eval(java.lang.String)&quot;&gt;&lt;code&gt;eval(String)&lt;/code&gt;&lt;/a&gt; code is placed.</source>
          <target state="translated">지정된 경로는 eval ()에서 사용되는 클래스 경로의 끝에 추가됩니다. 이름이 지정되지 않은 패키지는 &lt;a href=&quot;#eval(java.lang.String)&quot;&gt; &lt;code&gt;eval(String)&lt;/code&gt; &lt;/a&gt; 코드가 있는 패키지에서 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8b6cc3dc228a55bbb5be0ad0c4aa456b38c93c73" translate="yes" xml:space="preserve">
          <source>The specified stream is closed after this method returns.</source>
          <target state="translated">이 메소드가 반환 된 후 지정된 스트림이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="51786fb87bcf180e4b0079696fd451f32baf2367" translate="yes" xml:space="preserve">
          <source>The specified stream remains open after this method returns.</source>
          <target state="translated">지정된 스트림은이 메서드가 반환 된 후에도 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="7526737a0fdb5c1ec28cb0f7e645a738da9f21ee" translate="yes" xml:space="preserve">
          <source>The specified string</source>
          <target state="translated">지정된 문자열</target>
        </trans-unit>
        <trans-unit id="020eb4b0a71ae7c3e458a5afa3348d57de83d3bc" translate="yes" xml:space="preserve">
          <source>The specified substring. If the sum of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; exceeds the &lt;code&gt;length&lt;/code&gt;, then all 16-bit units to the end of the data are returned.</source>
          <target state="translated">The specified substring. If the sum of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; exceeds the &lt;code&gt;length&lt;/code&gt; , then all 16-bit units to the end of the data are returned.</target>
        </trans-unit>
        <trans-unit id="2615e62cfbfda5abfd51b12dbda35048bb40079b" translate="yes" xml:space="preserve">
          <source>The specified temporal must have the same chronology as this period. This returns a temporal with the non-zero supported units added.</source>
          <target state="translated">지정된 시간은이 기간과 동일한 연대기를 가져야합니다. 0이 아닌 지원 단위가 추가 된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="157250d9b4b02aeb6925cbf93c8ae0c1bd6e00ac" translate="yes" xml:space="preserve">
          <source>The specified temporal must have the same chronology as this period. This returns a temporal with the non-zero supported units subtracted.</source>
          <target state="translated">지정된 시간은이 기간과 동일한 연대기를 가져야합니다. 0이 아닌 지원 단위를 뺀 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc9a505a8f5c31216ff0ecff5662a313bc10a9ec" translate="yes" xml:space="preserve">
          <source>The specified temporal objects must support the &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt;&lt;code&gt;SECONDS&lt;/code&gt;&lt;/a&gt; unit. For full accuracy, either the &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt;&lt;code&gt;NANOS&lt;/code&gt;&lt;/a&gt; unit or the &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; field should be supported.</source>
          <target state="translated">지정된 임시 오브젝트는 &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt; &lt;code&gt;SECONDS&lt;/code&gt; &lt;/a&gt; 단위를 지원해야합니다 . 정확성을 &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt; &lt;code&gt;NANOS&lt;/code&gt; &lt;/a&gt; 려면 NANOS 장치 또는 &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 필드가 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="48aa14ed6ed221e27d9f2cd6ffaee94b553e7c4d" translate="yes" xml:space="preserve">
          <source>The specified thread must be suspended.</source>
          <target state="translated">지정된 스레드가 일시 중단되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9126ea58e2571bc036db8beb3f6e7cb81714d752" translate="yes" xml:space="preserve">
          <source>The specified timeout elapses; or</source>
          <target state="translated">지정된 시간이 초과되었습니다. 또는</target>
        </trans-unit>
        <trans-unit id="6c00c0e0136e5f97f317610379bde9404184da35" translate="yes" xml:space="preserve">
          <source>The specified title as a string.</source>
          <target state="translated">문자열로 지정된 제목입니다.</target>
        </trans-unit>
        <trans-unit id="77816529a97b17e719694d443a16cc6eb0b2358f" translate="yes" xml:space="preserve">
          <source>The specified value is used for components that do not have an explicit visibility specified.</source>
          <target state="translated">The specified value is used for components that do not have an explicit visibility specified.</target>
        </trans-unit>
        <trans-unit id="b837498e4f5bfb7ecf362b5a40901bb42bb72876" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses</source>
          <target state="translated">지정된 대기 시간이 경과합니다</target>
        </trans-unit>
        <trans-unit id="2e16f4e41d2bec157ff32585a40c8df18c39455f" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses.</source>
          <target state="translated">지정된 대기 시간이 경과합니다.</target>
        </trans-unit>
        <trans-unit id="f6172c989e04cb91e71e97089eeadbcfd41054bf" translate="yes" xml:space="preserve">
          <source>The specified waiting time elapses; or</source>
          <target state="translated">지정된 대기 시간이 경과합니다. 또는</target>
        </trans-unit>
        <trans-unit id="bcb09cd9d5c1d9cff3d8db3594d6e42aab3b0b8d" translate="yes" xml:space="preserve">
          <source>The spinner that we're a UI delegate for.</source>
          <target state="translated">The spinner that we're a UI delegate for.</target>
        </trans-unit>
        <trans-unit id="97f64657e5f059399930d54a08e9b83baa27ae28" translate="yes" xml:space="preserve">
          <source>The spinner that we're a UI delegate for. Initialized by the &lt;code&gt;installUI&lt;/code&gt; method, and reset to null by &lt;code&gt;uninstallUI&lt;/code&gt;.</source>
          <target state="translated">The spinner that we're a UI delegate for. Initialized by the &lt;code&gt;installUI&lt;/code&gt; method, and reset to null by &lt;code&gt;uninstallUI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d585405edcff8efbfeceb28b75b5f670d57bbe62" translate="yes" xml:space="preserve">
          <source>The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts.</source>
          <target state="translated">The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts.</target>
        </trans-unit>
        <trans-unit id="799c8129c9adc3cde63003661b566735c720a9dc" translate="yes" xml:space="preserve">
          <source>The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts. The splash screen is displayed as an undecorated window containing an image. You can use GIF, JPEG, or PNG files for the image. Animation is supported for the GIF format, while transparency is supported both for GIF and PNG. The window is positioned at the center of the screen. The position on multi-monitor systems is not specified. It is platform and implementation dependent. The splash screen window is closed automatically as soon as the first window is displayed by Swing/AWT (may be also closed manually using the Java API, see below).</source>
          <target state="translated">The splash screen can be displayed at application startup, before the Java Virtual Machine (JVM) starts. The splash screen is displayed as an undecorated window containing an image. You can use GIF, JPEG, or PNG files for the image. Animation is supported for the GIF format, while transparency is supported both for GIF and PNG. The window is positioned at the center of the screen. The position on multi-monitor systems is not specified. It is platform and implementation dependent. The splash screen window is closed automatically as soon as the first window is displayed by Swing/AWT (may be also closed manually using the Java API, see below).</target>
        </trans-unit>
        <trans-unit id="b1c8f20ff40da3f5e74a84ba6b16f559f12b32df" translate="yes" xml:space="preserve">
          <source>The splash screen will be displayed as faithfully as possible to present the whole splash screen image given the limitations of the target platform and display.</source>
          <target state="translated">The splash screen will be displayed as faithfully as possible to present the whole splash screen image given the limitations of the target platform and display.</target>
        </trans-unit>
        <trans-unit id="358fe8f4c03c65db9f92645925be98830ef03da4" translate="yes" xml:space="preserve">
          <source>The spliterator is &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the collection's iterator, and implements &lt;code&gt;trySplit&lt;/code&gt; to permit limited parallelism.</source>
          <target state="translated">spliterator는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;늦게 바인딩&lt;/a&gt;&lt;/em&gt; 되고 컬렉션 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 속성을 상속하며 제한된 병렬 처리를 허용하도록 &lt;code&gt;trySplit&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="5c3d939c98fbccf6b0709b1993b6b3ad3fbfd412" translate="yes" xml:space="preserve">
          <source>The spliterator is not &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, inherits the &lt;em&gt;fail-fast&lt;/em&gt; properties of the iterator, and implements &lt;code&gt;trySplit&lt;/code&gt; to permit limited parallelism.</source>
          <target state="translated">spliterator는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;늦게 바인딩&lt;/a&gt;&lt;/em&gt; 되지 않고 반복자 의 &lt;em&gt;fail-fast&lt;/em&gt; 속성을 상속하며 제한된 병렬 처리를 허용하기 위해 &lt;code&gt;trySplit&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="c89136b191a7ef1fb716259822efc70d2b8982ba" translate="yes" xml:space="preserve">
          <source>The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences.</source>
          <target state="translated">스플리터는 스트림 파이프 라인의 터미널 작업이 시작된 후 예상 크기에 대해서만 순회, 스플릿 또는 쿼리됩니다.</target>
        </trans-unit>
        <trans-unit id="2e796cc75190234b6abcae4603bbe835004bc5ff" translate="yes" xml:space="preserve">
          <source>The spliterator provides a snapshot of the state of the list when the spliterator was constructed. No synchronization is needed while operating on the spliterator.</source>
          <target state="translated">스플리터는 스플리터가 구성 될 때 목록 상태의 스냅 샷을 제공합니다. 스플리터에서 작동하는 동안 동기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb6fc47357accd5ef236f3f5c242ba1b0d8c1cb4" translate="yes" xml:space="preserve">
          <source>The spliterator provides a snapshot of the state of the set when the spliterator was constructed. No synchronization is needed while operating on the spliterator.</source>
          <target state="translated">스플리터는 스플리터가 구성 될 때 세트 상태의 스냅 샷을 제공합니다. 스플리터에서 작동하는 동안 동기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c63ef1d32be1189c32d967974dfe2fc9a2f274a" translate="yes" xml:space="preserve">
          <source>The spliterator reports &lt;a href=&quot;spliterator#SIZED&quot;&gt;&lt;code&gt;Spliterator.SIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt;&lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt;&lt;code&gt;Spliterator.IMMUTABLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스플리터는 &lt;a href=&quot;spliterator#SIZED&quot;&gt; &lt;code&gt;Spliterator.SIZED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#SUBSIZED&quot;&gt; &lt;code&gt;Spliterator.SUBSIZED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;spliterator#IMMUTABLE&quot;&gt; &lt;code&gt;Spliterator.IMMUTABLE&lt;/code&gt; 을보고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c0e1fd6ad7e570320cb5c4dec58534b0c8203896" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;../spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the set's comparator (see &lt;a href=&quot;concurrentskiplistset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the set's comparator.</source>
          <target state="translated">세트의 비교 자 ( &lt;a href=&quot;concurrentskiplistset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;../spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면, 스플리터의 비교기는 세트의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="fe057f9948defb315751a3ca1f88f4994c9e14dd" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;sortedset#comparator()&quot;&gt;&lt;code&gt;SortedSet.comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</source>
          <target state="translated">The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;sortedset#comparator()&quot;&gt; &lt;code&gt;SortedSet.comparator()&lt;/code&gt; &lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; . Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</target>
        </trans-unit>
        <trans-unit id="f6b692dffef505c29f727633715bcaa25d9f58af" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator()&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) must be &lt;code&gt;null&lt;/code&gt; if the sorted set's comparator (see &lt;a href=&quot;#comparator()&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.</source>
          <target state="translated">정렬 된 세트의 비교기 ( &lt;a href=&quot;#comparator()&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우 분할기의 비교기 ( &lt;a href=&quot;spliterator#getComparator()&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 이어야합니다 . 그렇지 않으면 분할기의 비교기는 정렬 된 세트의 비교기와 동일하거나 동일한 총 순서를 부과해야합니다.</target>
        </trans-unit>
        <trans-unit id="48dde829f5e209bbf80a37d8886c87c609c3d85b" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt; if the tree set's comparator (see &lt;a href=&quot;treeset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.</source>
          <target state="translated">트리 세트의 비교 자 ( &lt;a href=&quot;treeset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, spliterator의 비교 자 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 입니다. 그렇지 않으면 스플리터의 비교기는 트리 세트의 비교기와 동일하거나 동일한 총 순서를 부과합니다.</target>
        </trans-unit>
        <trans-unit id="5d0a078e5e6eab06b16fc00059f9764476f503fd" translate="yes" xml:space="preserve">
          <source>The spliterator's comparator (see &lt;a href=&quot;spliterator#getComparator--&quot;&gt;&lt;code&gt;Spliterator.getComparator()&lt;/code&gt;&lt;/a&gt;) must be &lt;code&gt;null&lt;/code&gt; if the sorted set's comparator (see &lt;a href=&quot;sortedset#comparator--&quot;&gt;&lt;code&gt;comparator()&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;null&lt;/code&gt;. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.</source>
          <target state="translated">정렬 된 세트의 비교기 ( &lt;a href=&quot;sortedset#comparator--&quot;&gt; &lt;code&gt;comparator()&lt;/code&gt; &lt;/a&gt; 참조 )가 &lt;code&gt;null&lt;/code&gt; 인 경우, 분할기의 비교기 ( &lt;a href=&quot;spliterator#getComparator--&quot;&gt; &lt;code&gt;Spliterator.getComparator()&lt;/code&gt; &lt;/a&gt; 참조 )는 &lt;code&gt;null&lt;/code&gt; 이어야합니다 . 그렇지 않으면 스플리터의 비교기가 정렬 된 세트의 비교기와 동일하거나 동일한 총 순서를 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="81c6f54339613405ef47fa4cf7fd2cfc6963fe4e" translate="yes" xml:space="preserve">
          <source>The spliterators for &lt;code&gt;Collection&lt;/code&gt; classes in the JDK that implement &lt;a href=&quot;navigableset&quot;&gt;&lt;code&gt;NavigableSet&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sortedset&quot;&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; report &lt;code&gt;SORTED&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;navigableset&quot;&gt; &lt;code&gt;NavigableSet&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sortedset&quot;&gt; &lt;code&gt;SortedSet&lt;/code&gt; &lt;/a&gt; 보고서 를 구현하는 JDK의 &lt;code&gt;Collection&lt;/code&gt; 클래스에 대한 스플리터는 &lt;code&gt;SORTED&lt;/code&gt; 를 보고 합니다 .</target>
        </trans-unit>
        <trans-unit id="cd697bf3371b30cc43133d20204f9b133ffb8c0e" translate="yes" xml:space="preserve">
          <source>The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt;, and additionally report &lt;a href=&quot;spliterator#ORDERED&quot;&gt;&lt;code&gt;Spliterator.ORDERED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스의 모든 콜렉션 뷰 메소드에 의해 리턴 된 콜렉션의 spliterator 메소드에 의해 리턴 된 스플리터는 &lt;em&gt;&lt;a href=&quot;spliterator#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; , &lt;em&gt;fail-fast&lt;/em&gt; 및 추가로 &lt;a href=&quot;spliterator#ORDERED&quot;&gt; &lt;code&gt;Spliterator.ORDERED&lt;/code&gt; 를&lt;/a&gt; 보고 합니다 .</target>
        </trans-unit>
        <trans-unit id="3f5421d4c1a6fd2ddf5564c1dd18506c0df41358" translate="yes" xml:space="preserve">
          <source>The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are created from the iterators of the corresponding collections.</source>
          <target state="translated">이 클래스의 모든 콜렉션 뷰 메소드에 의해 리턴 된 콜렉션의 spliterator 메소드에 의해 리턴 된 스플리터는 대응하는 콜렉션의 반복자로부터 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9f0eea49dd34a9dc6611340a54bee1813909e27a" translate="yes" xml:space="preserve">
          <source>The square root of a number numerically equal to &lt;code&gt;
 ZERO&lt;/code&gt; is numerically equal to &lt;code&gt;ZERO&lt;/code&gt; with a preferred scale according to the general rule above. In particular, for &lt;code&gt;ZERO&lt;/code&gt;, &lt;code&gt;ZERO.sqrt(mc).equals(ZERO)&lt;/code&gt; is true with any &lt;code&gt;MathContext&lt;/code&gt; as an argument.</source>
          <target state="translated">숫자와 동일한 숫자의 제곱근 &lt;code&gt; ZERO&lt;/code&gt; 는 같은 수치 &lt;code&gt;ZERO&lt;/code&gt; 위의 일반 규칙에 따라 바람직한 스케일. 특히 &lt;code&gt;ZERO&lt;/code&gt; 의 경우 &lt;code&gt;ZERO.sqrt(mc).equals(ZERO)&lt;/code&gt; 는 &lt;code&gt;MathContext&lt;/code&gt; 를 인수로 사용하여 true입니다 .</target>
        </trans-unit>
        <trans-unit id="78e9aaccc7e1f2b7c96d28e2bb5525d00bd5e897" translate="yes" xml:space="preserve">
          <source>The stack can be queried by methods on &lt;code&gt;Exception&lt;/code&gt;. Note that in stack trace frames representing JShell Snippets, &lt;code&gt;StackTraceElement.getFileName()&lt;/code&gt; will return &quot;#&quot; followed by the Snippet id and for snippets without a method name (for example an expression) &lt;code&gt;StackTraceElement.getName()&lt;/code&gt; will be the empty string.</source>
          <target state="translated">스택은 &lt;code&gt;Exception&lt;/code&gt; 에 대한 메서드로 쿼리 할 수 ​​있습니다 . JShell 스 니펫을 나타내는 스택 추적 프레임에서 &lt;code&gt;StackTraceElement.getFileName()&lt;/code&gt; 은 &quot;#&quot;뒤에 스 니펫 ID를 반환하고 메소드 이름 (예 : 표현식)이없는 스 니펫의 경우 &lt;code&gt;StackTraceElement.getName()&lt;/code&gt; 은 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="97a32597a130645adffb584e7165020d15f080bc" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; values are:</source>
          <target state="translated">표준 &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec658a969bcb92aa1baad080b6a1974cf0ea66e2" translate="yes" xml:space="preserve">
          <source>The standard AC chrominance Huffman table.</source>
          <target state="translated">표준 AC 색차 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="de7f2a4797f9371ba730de4782f10f7289878bf4" translate="yes" xml:space="preserve">
          <source>The standard AC luminance Huffman table.</source>
          <target state="translated">표준 AC 휘도 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="c018ce1af2d766ca3e1a4abc0ceaf42164f207ce" translate="yes" xml:space="preserve">
          <source>The standard DC chrominance Huffman table.</source>
          <target state="translated">표준 DC 색차 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="a329f8b4144b879c7b6f5ae550949bccdbf73f49" translate="yes" xml:space="preserve">
          <source>The standard DC luminance Huffman table.</source>
          <target state="translated">표준 DC 휘도 허프만 테이블.</target>
        </trans-unit>
        <trans-unit id="db8c6341d94f5edfcecbdce8b46d6840a2f9998a" translate="yes" xml:space="preserve">
          <source>The standard MultipleDocumentHandling values are:</source>
          <target state="translated">표준 MultipleDocumentHandling 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cea92758ea1f357e469fa3131a98d496ed04fb3d" translate="yes" xml:space="preserve">
          <source>The standard WebRowSet XML Schema definition is available at the following URI:</source>
          <target state="translated">표준 WebRowSet XML 스키마 정의는 다음 URI에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92cab317859f368c1aae7d7671cb740196644a9d" translate="yes" xml:space="preserve">
          <source>The standard astronomical definition uses a fraction to indicate the time-of-day, thus 3.25 would represent the time 18:00, since days start at midday. This implementation uses an integer and days starting at midnight. The integer value for the Julian Day Number is the astronomical Julian Day value at midday of the date in question. This amounts to the astronomical Julian Day, rounded to an integer &lt;code&gt;JDN = floor(JD + 0.5)&lt;/code&gt;.</source>
          <target state="translated">표준 천문학적 정의는 분수를 사용하여 하루 중 시간을 나타내므로 하루가 정오에 시작하므로 3.25는 18:00 시간을 나타냅니다. 이 구현은 자정에 시작하는 정수와 요일을 사용합니다. Julian Day Number의 정수 값은 해당 날짜의 정오에 천문학적 Julian Day 값입니다. 이것은 천문학적 줄리안 데이에 해당하며 정수 &lt;code&gt;JDN = floor(JD + 0.5)&lt;/code&gt; 반올림됩니다 .</target>
        </trans-unit>
        <trans-unit id="880ecebc89a3bd9ce7264ab7dfc0e29562f0f35f" translate="yes" xml:space="preserve">
          <source>The standard astronomical definition uses a fraction to indicate the time-of-day, where each day is counted from midday to midday. For example, a fraction of 0 represents midday, a fraction of 0.25 represents 18:00, a fraction of 0.5 represents midnight and a fraction of 0.75 represents 06:00.</source>
          <target state="translated">표준 천문학적 정의는 분수를 사용하여 하루 중 시간을 나타내며 매일 정오부터 정오까지 계산됩니다. 예를 들어, 분수 0은 정오를 나타내고 0.25는 18:00를, 0.5는 자정을, 0.75는 06:00을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13ecff8dc7f4fb8e1c0a2ecc7b63b91ab8bf3498" translate="yes" xml:space="preserve">
          <source>The standard bold weight.</source>
          <target state="translated">표준 굵은 무게.</target>
        </trans-unit>
        <trans-unit id="87015164736bf1cd9c8bbb4ea24b900496c33f69" translate="yes" xml:space="preserve">
          <source>The standard class for rendering (displaying) individual cells in a &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JTable&lt;/code&gt; 에서 개별 셀을 렌더링 (표시)하기위한 표준 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="42ca28b6f9992a10a95b6a95ebf901f9b15239be" translate="yes" xml:space="preserve">
          <source>The standard classes and interfaces that a third party vendor has to use in its implementation of a synchronization provider.</source>
          <target state="translated">타사 공급 업체가 동기화 공급자 구현에 사용해야하는 표준 클래스 및 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f20e3d89b127e95d58c2061d7d4c9dd74ba0ee75" translate="yes" xml:space="preserve">
          <source>The standard classes and interfaces that a third party vendor has to use in its implementation of a synchronization provider. These classes and interfaces are referred to as the Service Provider Interface (SPI). To make it possible for a &lt;code&gt;RowSet&lt;/code&gt; object to use an implementation, the vendor must register it with the &lt;code&gt;SyncFactory&lt;/code&gt; singleton. (See the class comment for &lt;code&gt;SyncProvider&lt;/code&gt; for a full explanation of the registration process and the naming convention to be used.)</source>
          <target state="translated">타사 공급 업체가 동기화 공급자 구현에 사용해야하는 표준 클래스 및 인터페이스입니다. 이러한 클래스와 인터페이스를 SPI (서비스 공급자 인터페이스)라고합니다. &lt;code&gt;RowSet&lt;/code&gt; 객체가 구현을 사용할 수 있도록하려면 공급 업체가이를 &lt;code&gt;SyncFactory&lt;/code&gt; 싱글 톤에 등록해야합니다 . ( 등록 프로세스 및 사용할 명명 규칙에 대한 전체 설명은 &lt;code&gt;SyncProvider&lt;/code&gt; 에 대한 클래스 주석을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b131b8a4797ef2827907440045a418e64b3fbf06" translate="yes" xml:space="preserve">
          <source>The standard column-handler for a &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JTable&lt;/code&gt; 의 표준 열 처리기입니다 .</target>
        </trans-unit>
        <trans-unit id="ebd97f6234307a116f96853fd3903e56b9d40331" translate="yes" xml:space="preserve">
          <source>The standard default domain name is &lt;code&gt;DefaultDomain&lt;/code&gt;.</source>
          <target state="translated">표준 기본 도메인 이름은 &lt;code&gt;DefaultDomain&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eba1c345bcad3128d67e184f5948f0c758533831" translate="yes" xml:space="preserve">
          <source>The standard doclet supports user-defined &lt;a href=&quot;taglet&quot;&gt;&lt;code&gt;taglets&lt;/code&gt;&lt;/a&gt;, which can be used to generate customized output for user-defined tags in documentation comments. Taglets invoked by the standard doclet must return strings from &lt;a href=&quot;taglet#toString(java.util.List,javax.lang.model.element.Element)&quot;&gt;&lt;code&gt;Taglet.toString&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">표준 doclet은 문서 주석에서 사용자 정의 태그에 대한 사용자 정의 출력을 생성하는 데 사용할 수있는 사용자 정의 &lt;a href=&quot;taglet&quot;&gt; &lt;code&gt;taglets&lt;/code&gt; &lt;/a&gt; 지원합니다 . 표준 doclet에 의해 호출 된 태그 렛은 다음과 같이 &lt;a href=&quot;taglet#toString(java.util.List,javax.lang.model.element.Element)&quot;&gt; &lt;code&gt;Taglet.toString&lt;/code&gt; &lt;/a&gt; 에서 문자열을 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ef55295fde5154a258f26679975fa232098fcdbf" translate="yes" xml:space="preserve">
          <source>The standard file manager serves two purposes:</source>
          <target state="translated">표준 파일 관리자는 두 가지 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7ea3f0338f77cf538431691011f031baff3b34" translate="yes" xml:space="preserve">
          <source>The standard file manager will be automatically reopened if it is accessed after calls to &lt;code&gt;flush&lt;/code&gt; or &lt;code&gt;close&lt;/code&gt;. The standard file manager must be usable with other tools.</source>
          <target state="translated">표준 파일 관리자는 &lt;code&gt;flush&lt;/code&gt; 또는 &lt;code&gt;close&lt;/code&gt; 호출 후 액세스되면 자동으로 다시 열립니다 . 표준 파일 관리자는 다른 도구와 함께 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d899fd7b1f2ffca29d5ec4be5ab688999a5e0e42" translate="yes" xml:space="preserve">
          <source>The standard interface that all implementations of a &lt;code&gt;WebRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;WebRowSet&lt;/code&gt; 의 모든 구현이 구현해야하는 표준 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="68aac4cc5c3cf5132e5aff63b1695213f60c720d" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;FilteredRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;FilteredRowSet&lt;/code&gt; 의 모든 표준 구현이 구현해야하는 표준 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="247ee5b52f4343f5290a6af4a99cb5a09ea9f68c" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;FilteredRowSet&lt;/code&gt; must implement. The &lt;code&gt;FilteredRowSetImpl&lt;/code&gt; class provides the reference implementation which may be extended if required. Alternatively, a vendor is free to implement its own version by implementing this interface.</source>
          <target state="translated">&lt;code&gt;FilteredRowSet&lt;/code&gt; 의 모든 표준 구현이 구현해야하는 표준 인터페이스입니다 . &lt;code&gt;FilteredRowSetImpl&lt;/code&gt; 의 클래스는 필요하다면 연장 될 수도 참조 구현을 제공한다. 또는 공급 업체는이 인터페이스를 구현하여 자체 버전을 자유롭게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4179729038e158c2938276999d2a0f8a9a828d40" translate="yes" xml:space="preserve">
          <source>The standard interface that all standard implementations of &lt;code&gt;JdbcRowSet&lt;/code&gt; must implement.</source>
          <target state="translated">&lt;code&gt;JdbcRowSet&lt;/code&gt; 의 모든 표준 구현이 구현해야하는 표준 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="bbf8d9d8dbd72ecf1f4215ba8e97cd7badb383b6" translate="yes" xml:space="preserve">
          <source>The standard interface that provides the framework for all &lt;code&gt;FilteredRowSet&lt;/code&gt; objects to describe their filters.</source>
          <target state="translated">필터를 설명하는 모든 &lt;code&gt;FilteredRowSet&lt;/code&gt; 개체에 대한 프레임 워크를 제공하는 표준 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="f8f169d2bb832c35eba59bc410c0b85f0003b6f8" translate="yes" xml:space="preserve">
          <source>The standard interface to a DSA private key.</source>
          <target state="translated">DSA 개인 키에 대한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="be4242d6a22a82129b32c761e9b997ab8bdb7b76" translate="yes" xml:space="preserve">
          <source>The standard interface to a DSA private key. DSA (Digital Signature Algorithm) is defined in NIST's FIPS-186.</source>
          <target state="translated">DSA 개인 키에 대한 표준 인터페이스입니다. DSA (Digital Signature Algorithm)는 NIST의 FIPS-186에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aee232c28f9de3b58df1a19a8e2a72c95efd9f7" translate="yes" xml:space="preserve">
          <source>The standard italic posture.</source>
          <target state="translated">표준 이탤릭체 자세.</target>
        </trans-unit>
        <trans-unit id="265e9fc158c49896c41933585c842cef5b8e987f" translate="yes" xml:space="preserve">
          <source>The standard layer, where most components go. This the bottommost layer.</source>
          <target state="translated">대부분의 구성 요소가 들어가는 표준 레이어입니다. 이것은 맨 아래 레이어입니다.</target>
        </trans-unit>
        <trans-unit id="7b2b71d5aa7e1b0b260acaadc43d3221dce05731" translate="yes" xml:space="preserve">
          <source>The standard light weight.</source>
          <target state="translated">표준 경량입니다.</target>
        </trans-unit>
        <trans-unit id="a8d8726b4a5a07328b176cca7d74f5e2a761a964" translate="yes" xml:space="preserve">
          <source>The standard mapping in the Java programming language for an SQL structured type.</source>
          <target state="translated">SQL 구조화 유형에 대한 Java 프로그래밍 언어의 표준 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="c2eeb32dafb015f6f93305e7066122591f181fc8" translate="yes" xml:space="preserve">
          <source>The standard mapping in the Java programming language for an SQL structured type. A &lt;code&gt;Struct&lt;/code&gt; object contains a value for each attribute of the SQL structured type that it represents. By default, an instance of&lt;code&gt;Struct&lt;/code&gt; is valid as long as the application has a reference to it.</source>
          <target state="translated">SQL 구조화 유형에 대한 Java 프로그래밍 언어의 표준 매핑입니다. &lt;code&gt;Struct&lt;/code&gt; 객체가 나타내는 SQL 구조형의 각 속성에 대한 값을 포함한다. 기본적으로 &lt;code&gt;Struct&lt;/code&gt; 의 인스턴스 는 응용 프로그램에 참조가있는 한 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c927c0ada9cba1ad53c2c1bf1aa34f20c5ec2c56" translate="yes" xml:space="preserve">
          <source>The standard mental model for a date is based on three concepts - year, month and day. These map onto the &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Note that there is no reference to eras. The full model for a date requires four concepts - era, year, month and day. These map onto the &lt;code&gt;ERA&lt;/code&gt;, &lt;code&gt;YEAR_OF_ERA&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Whether this field or &lt;code&gt;YEAR&lt;/code&gt; is used depends on which mental model is being used. See &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; for more discussion on this topic.</source>
          <target state="translated">날짜의 표준 정신 모델은 세 가지 개념-년, 월 및 일을 기반으로합니다. 이들은 &lt;code&gt;YEAR&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 시대에 대한 언급은 없습니다. 날짜의 전체 모델에는 시대, 연도, 월, 일의 네 가지 개념이 필요합니다. 이들은 &lt;code&gt;ERA&lt;/code&gt; , &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 이 필드 또는 &lt;code&gt;YEAR&lt;/code&gt; 사용 여부는 사용중인 정신 모델에 따라 다릅니다. 이 주제에 대한 자세한 내용은 &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="552969cac10043f5eb1e8db38405b389d7505393" translate="yes" xml:space="preserve">
          <source>The standard mental model for a date is based on three concepts - year, month and day. These map onto the &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Note that there is no reference to eras. The full model for a date requires four concepts - era, year, month and day. These map onto the &lt;code&gt;ERA&lt;/code&gt;, &lt;code&gt;YEAR_OF_ERA&lt;/code&gt;, &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields. Whether this field or &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; is used depends on which mental model is being used. See &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt;&lt;code&gt;ChronoLocalDate&lt;/code&gt;&lt;/a&gt; for more discussion on this topic.</source>
          <target state="translated">날짜의 표준 정신 모델은 세 가지 개념-년, 월 및 일을 기반으로합니다. 이지도는 &lt;code&gt;YEAR&lt;/code&gt; 에 &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 됩니다. 시대에 대한 언급은 없습니다. 날짜의 전체 모델에는 시대, 연도, 월, 일의 네 가지 개념이 필요합니다. 이들은 &lt;code&gt;ERA&lt;/code&gt; , &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; , &lt;code&gt;MONTH_OF_YEAR&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드에 매핑 됩니다. 이 필드 또는 &lt;code&gt;YEAR_OF_ERA&lt;/code&gt; 사용 여부는 사용중인 정신 모델에 따라 다릅니다. 이 주제에 대한 자세한 내용은 &lt;a href=&quot;../chrono/chronolocaldate&quot;&gt; &lt;code&gt;ChronoLocalDate&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3661c18690ae34088219c95d1f642f9094ca6650" translate="yes" xml:space="preserve">
          <source>The standard posture, upright.</source>
          <target state="translated">표준 자세, 똑바로.</target>
        </trans-unit>
        <trans-unit id="bcac68430abf1f9b59c3fc0c0ced10c89898d656" translate="yes" xml:space="preserve">
          <source>The standard posture, upright. This is the default value for &lt;code&gt;POSTURE&lt;/code&gt;.</source>
          <target state="translated">표준 자세, 똑바로. 이것은 &lt;code&gt;POSTURE&lt;/code&gt; 의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="4204acbf3d5f3f85ee9f30f3059d6be897c6a196" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation name.</source>
          <target state="translated">동기화 공급자 구현 이름에 대한 표준 속성 ID입니다.</target>
        </trans-unit>
        <trans-unit id="80bb8e7243eb06e9dd0a04e994954134803a7ab1" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation vendor name.</source>
          <target state="translated">동기화 공급자 구현 공급 업체 이름의 표준 속성 ID입니다.</target>
        </trans-unit>
        <trans-unit id="f3300fc7bb9dd6b49894aeba609ac649a7e0edb1" translate="yes" xml:space="preserve">
          <source>The standard property-id for a synchronization provider implementation version tag.</source>
          <target state="translated">동기화 공급자 구현 버전 태그의 표준 속성 ID입니다.</target>
        </trans-unit>
        <trans-unit id="f924447dc30c0a207a7a8dd003998719d641a65d" translate="yes" xml:space="preserve">
          <source>The standard reference implementation for the &lt;code&gt;CachedRowSet&lt;/code&gt; interface uses a &lt;code&gt;TreeMap&lt;/code&gt; object for the rowset, with the values in each row being contained in &lt;code&gt;Vector&lt;/code&gt; objects. It is expected that most implementations will do the same.</source>
          <target state="translated">&lt;code&gt;CachedRowSet&lt;/code&gt; 인터페이스에 대한 표준 참조 구현 은 행 집합에 대해 &lt;code&gt;TreeMap&lt;/code&gt; 개체를 사용하며 각 행의 값은 &lt;code&gt;Vector&lt;/code&gt; 개체 에 포함 됩니다. 대부분의 구현에서 동일한 작업을 수행 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="44003f488ebc1e70329a9b7e5361903f72e0de08" translate="yes" xml:space="preserve">
          <source>The standard reference implementation uses a &lt;code&gt;Vector&lt;/code&gt; object to contain the column values, and it is expected that most implementations will do the same. If a &lt;code&gt;Vector&lt;/code&gt; object is used, it size must be exactly equal to the number of rows in this &lt;code&gt;CachedRowSet&lt;/code&gt; object.</source>
          <target state="translated">표준 참조 구현은 &lt;code&gt;Vector&lt;/code&gt; 객체를 사용 하여 열 값을 포함하며 대부분의 구현에서 동일한 작업을 수행 할 것으로 예상됩니다. 경우 &lt;code&gt;Vector&lt;/code&gt; 객체가 사용되며, 그 크기는이 행의 수와 정확히 일치해야합니다 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5a269f562c7ddcb5223b4c729ca3aacff15045f7" translate="yes" xml:space="preserve">
          <source>The standard set of non-localized decimal style symbols.</source>
          <target state="translated">현지화되지 않은 10 진수 스타일 기호의 표준 세트입니다.</target>
        </trans-unit>
        <trans-unit id="2aa618fb16592d9504ead37dd1498e07dc1eb2fd" translate="yes" xml:space="preserve">
          <source>The standard target names for an Authentication Permission are:</source>
          <target state="translated">인증 권한의 표준 대상 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="085376bdd00c3589b2477d9a9b7e25e5aa764bdf" translate="yes" xml:space="preserve">
          <source>The standard text outputting methods use the localized text in the JDK. This method allows that text to be specified directly. The supplied map is not validated by the builder to ensure that formatting or parsing is possible, thus an invalid map may throw an error during later use.</source>
          <target state="translated">표준 텍스트 출력 방법은 JDK에서 지역화 된 텍스트를 사용합니다. 이 방법을 사용하면 해당 텍스트를 직접 지정할 수 있습니다. 제공된 맵은 형식화 또는 구문 분석이 가능한지 확인하기 위해 빌더에 의해 유효성 검증되지 않으므로 유효하지 않은 맵은 나중에 사용하는 동안 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace8ff3c243593fda8f90cc8a3f288d71a11483d" translate="yes" xml:space="preserve">
          <source>The standard value of the propertyName as fired from a BeanContext or other source of PropertyChangeEvents.</source>
          <target state="translated">BeanContext 또는 다른 PropertyChangeEvents 소스로부터 시작된 propertyName의 표준치입니다.</target>
        </trans-unit>
        <trans-unit id="49ec7e4579c545f03b2dbae2595c4136e74f5f2a" translate="yes" xml:space="preserve">
          <source>The standard weight.</source>
          <target state="translated">표준 무게입니다.</target>
        </trans-unit>
        <trans-unit id="062b0e97b7470f28f4677451830d828c09857342" translate="yes" xml:space="preserve">
          <source>The standard weight. This is the default value for &lt;code&gt;WEIGHT&lt;/code&gt;.</source>
          <target state="translated">표준 무게입니다. &lt;code&gt;WEIGHT&lt;/code&gt; 의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="5fa2e7b7afa217d5160022594a1240084ec90835" translate="yes" xml:space="preserve">
          <source>The standard width.</source>
          <target state="translated">표준 너비입니다.</target>
        </trans-unit>
        <trans-unit id="1ec1dd1d6de288f3d7a0a8ac09f8cd6fa6f29d04" translate="yes" xml:space="preserve">
          <source>The standard width. This is the default value for &lt;code&gt;WIDTH&lt;/code&gt;.</source>
          <target state="translated">표준 너비입니다. 이것은 &lt;code&gt;WIDTH&lt;/code&gt; 의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="f3bed9164e92a7973b9cbcd9ad79594c005f0947" translate="yes" xml:space="preserve">
          <source>The start and end points are &lt;code&gt;this&lt;/code&gt; and the specified date. The result will be negative if the end is before the start. The negative sign will be the same in each of year, month and day.</source>
          <target state="translated">시작 및 종료 지점은 &lt;code&gt;this&lt;/code&gt; 날짜이며 지정된 날짜입니다. 끝이 시작하기 전에 결과는 음수입니다. 음수 부호는 매년, 월, 일마다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3c2d246e90e00803aeb29283b1b8bc16d249d5bc" translate="yes" xml:space="preserve">
          <source>The start argument must be nonnegative, and not greater than &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">start 인수는 음이 아니어야하고 &lt;code&gt;end&lt;/code&gt; 보다 크지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="a4ddf7bb81f0c34d9260c89803dda3e7e413e128" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated by removing complete months, then calculating the remaining number of days, adjusting to ensure that both have the same sign. The number of months is then normalized into years and months based on a 12 month year. A month is considered to be complete if the end day-of-month is greater than or equal to the start day-of-month. For example, from &lt;code&gt;2010-01-15&lt;/code&gt; to &lt;code&gt;2011-03-18&lt;/code&gt; is &quot;1 year, 2 months and 3 days&quot;.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 완전한 월을 제거한 다음 남은 일 수를 계산하여 둘 다 동일한 부호를 갖도록 조정하여 계산됩니다. 그런 다음 월 수는 12 개월 연도를 기준으로 연도 및 월로 정규화됩니다. 월말이 시작일보다 크거나 같으면 한 달이 완료된 것으로 간주됩니다. 예를 들어 &lt;code&gt;2010-01-15&lt;/code&gt; 에서 &lt;code&gt;2011-03-18&lt;/code&gt; 은 &quot;1 년, 2 개월 및 3 일&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6620cb9be5fc56436fc3a7c1b18ff6874dd29e0c" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated by removing complete months, then calculating the remaining number of days, adjusting to ensure that both have the same sign. The number of months is then split into years and months based on a 12 month year. A month is considered if the end day-of-month is greater than or equal to the start day-of-month. For example, from &lt;code&gt;2010-01-15&lt;/code&gt; to &lt;code&gt;2011-03-18&lt;/code&gt; is one year, two months and three days.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 전체 월을 제거한 다음 남은 일 수를 계산하여 둘 다 동일한 부호를 갖도록 조정하여 계산됩니다. 그런 다음 월 수는 12 개월 연도를 기준으로 년과 월로 분할됩니다. 월말이 시작일보다 크거나 같은 경우 한 달로 간주됩니다. 예를 들어 &lt;code&gt;2010-01-15&lt;/code&gt; 에서 &lt;code&gt;2011-03-18&lt;/code&gt; 은 1 년, 2 개월 3 일입니다.</target>
        </trans-unit>
        <trans-unit id="7220f597737d970989890a2427aecffcbf28c9bf" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated using &lt;a href=&quot;chronolocaldate#until(java.time.chrono.ChronoLocalDate)&quot;&gt;&lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;. As such, the calculation is chronology specific.</source>
          <target state="translated">시작일은 포함되지만 종료일은 포함되지 않습니다. 기간은 &lt;a href=&quot;chronolocaldate#until(java.time.chrono.ChronoLocalDate)&quot;&gt; &lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 사용하여 계산됩니다 . 따라서 계산은 연대기별로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9238c2af9e0839f3491092fc2fe2b2c12cadecf1" translate="yes" xml:space="preserve">
          <source>The start date is included, but the end date is not. The period is calculated using &lt;a href=&quot;chronolocaldate#until-java.time.chrono.ChronoLocalDate-&quot;&gt;&lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt;&lt;/a&gt;. As such, the calculation is chronology specific.</source>
          <target state="translated">시작 날짜는 포함되지만 종료 날짜는 포함되지 않습니다. 기간은 &lt;a href=&quot;chronolocaldate#until-java.time.chrono.ChronoLocalDate-&quot;&gt; &lt;code&gt;ChronoLocalDate.until(ChronoLocalDate)&lt;/code&gt; &lt;/a&gt; 사용하여 계산됩니다 . 따라서 계산은 시간순으로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="4616505c5d1d5433c8afbd259a8f16eac5343c68" translate="yes" xml:space="preserve">
          <source>The start index of the text sequence.</source>
          <target state="translated">텍스트 시퀀스의 시작 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="2da02a77743138ef2df4ac8502302bd010532bde" translate="yes" xml:space="preserve">
          <source>The start time must be set before starting the stream</source>
          <target state="translated">스트림을 시작하기 전에 시작 시간을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6becf8d53264f434379756115b0b786e11e4f8c2" translate="yes" xml:space="preserve">
          <source>The startDrag() method invokes the createDragSourceContext() method to instantiate an appropriate &lt;code&gt;DragSourceContext&lt;/code&gt; and associate the &lt;code&gt;DragSourceContextPeer&lt;/code&gt; with that.</source>
          <target state="translated">startDrag () 메소드는 적절한 인스턴스로 createDragSourceContext () 메소드 호출 &lt;code&gt;DragSourceContext&lt;/code&gt; 상기 연결 &lt;code&gt;DragSourceContextPeer&lt;/code&gt; 를을 그와 함께한다.</target>
        </trans-unit>
        <trans-unit id="82e2ccda6d83bc11eba880fd5d75e0aa357c29cd" translate="yes" xml:space="preserve">
          <source>The starting angle of the arc in degrees.</source>
          <target state="translated">호의 시작 각도 (도)입니다.</target>
        </trans-unit>
        <trans-unit id="2264eaa8f12a8a3d18c204a6414263d50eec329f" translate="yes" xml:space="preserve">
          <source>The starting point of this matcher's region</source>
          <target state="translated">이 매처 지역의 시작점</target>
        </trans-unit>
        <trans-unit id="711145c27ccf3166aa36ebb810ced05b44da407a" translate="yes" xml:space="preserve">
          <source>The state factories tried must each implement either &lt;code&gt;StateFactory&lt;/code&gt; or &lt;code&gt;DirStateFactory&lt;/code&gt;. If it implements &lt;code&gt;DirStateFactory&lt;/code&gt;, then &lt;code&gt;DirStateFactory.getStateToBind()&lt;/code&gt; is called; otherwise, &lt;code&gt;StateFactory.getStateToBind()&lt;/code&gt; is called.</source>
          <target state="translated">시도한 상태 팩토리는 각각 &lt;code&gt;StateFactory&lt;/code&gt; 또는 &lt;code&gt;DirStateFactory&lt;/code&gt; 를 구현해야합니다 . 그것을 구현하는 경우 &lt;code&gt;DirStateFactory&lt;/code&gt; 다음을, &lt;code&gt;DirStateFactory.getStateToBind()&lt;/code&gt; 라고합니다; 그렇지 않으면 &lt;code&gt;StateFactory.getStateToBind()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="069364d5e2bc01251c39eefbdac8ec561989f08f" translate="yes" xml:space="preserve">
          <source>The state information after the edit</source>
          <target state="translated">편집 후 상태 정보</target>
        </trans-unit>
        <trans-unit id="78b85e5c07d69b00d4a00829691f1844f46ca899" translate="yes" xml:space="preserve">
          <source>The state information prior to the edit</source>
          <target state="translated">편집 전 상태 정보</target>
        </trans-unit>
        <trans-unit id="b4b4593a62342b2b46d5d7ee91609ae7dd334526" translate="yes" xml:space="preserve">
          <source>The state maintained by an instance of &lt;code&gt;ImageReadParam&lt;/code&gt; is independent of any particular image being decoded. When actual decoding takes place, the values set in the read param are combined with the actual properties of the image being decoded from the stream and the destination &lt;code&gt;BufferedImage&lt;/code&gt; that will receive the decoded pixel data. For example, the source region set using &lt;code&gt;setSourceRegion&lt;/code&gt; will first be intersected with the actual valid source area. The result will be translated by the value returned by &lt;code&gt;getDestinationOffset&lt;/code&gt;, and the resulting rectangle intersected with the actual valid destination area to yield the destination area that will be written.</source>
          <target state="translated">&lt;code&gt;ImageReadParam&lt;/code&gt; 의 인스턴스에 의해 유지되는 상태 는 디코딩되는 특정 이미지와 무관합니다. 실제 디코딩이 수행 될 때, 판독 파라미터에 설정된 값은 스트림으로부터 디코딩되는 이미지의 실제 속성 및 디코딩 된 픽셀 데이터를 수신 할 목적지 &lt;code&gt;BufferedImage&lt;/code&gt; 와 결합된다 . 예를 들어, &lt;code&gt;setSourceRegion&lt;/code&gt; 을 사용하여 설정된 소스 영역 을 은 먼저 실제 유효한 소스 영역과 교차합니다. 결과는 &lt;code&gt;getDestinationOffset&lt;/code&gt; 에서 반환 한 값으로 변환되고 결과 사각형은 실제 유효한 대상 영역과 교차하여 작성 될 대상 영역을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3a932e6e75d4e4ee973a0e76a7f43125497f0c01" translate="yes" xml:space="preserve">
          <source>The state moves from readable to not readable once free() or any of the reading APIs are called: getBinaryStream(), getCharacterStream(), getSource(), and getString(). Implementations may also change the state to not writable when this occurs.</source>
          <target state="translated">free () 또는 읽기 API (getBinaryStream (), getCharacterStream (), getSource () 및 getString ())가 호출되면 상태가 읽기에서 읽을 수 없음으로 이동합니다. 구현시 이러한 상황이 발생하면 상태를 쓰기 불가능으로 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6f7bffc98d1e8352d937b1d9d3e6a929292204" translate="yes" xml:space="preserve">
          <source>The state moves from writable to not writable once free() or any of the writing APIs are called: setBinaryStream(), setCharacterStream(), setResult(), and setString(). Implementations may also change the state to not readable when this occurs.</source>
          <target state="translated">free () 또는 쓰기 API (setBinaryStream (), setCharacterStream (), setResult () 및 setString ())가 호출되면 상태가 쓰기 가능에서 쓰기 불가능으로 이동합니다. 구현시 상태를 읽을 수 없음으로 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f123d14f73abf8b927161bc953361f29bebc2d2" translate="yes" xml:space="preserve">
          <source>The state of each match result passed to the replacer function is guaranteed to be constant only for the duration of the replacer function call and only if the replacer function does not modify this matcher's state.</source>
          <target state="translated">replacer 함수에 전달 된 각 일치 결과의 상태는 replacer 함수 호출 기간 동안과 replacer 함수가이 일치 자의 상태를 수정하지 않는 경우에만 일정하게 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="861a0f2ac6e69c9f80d5a917a538314fa0c92b1d" translate="yes" xml:space="preserve">
          <source>The state of one method invocation on a thread's call stack.</source>
          <target state="translated">스레드의 호출 스택에 대한 하나의 메서드 호출 상태입니다.</target>
        </trans-unit>
        <trans-unit id="cf0481dbb6b7adfb17cade428ef1369a516f361a" translate="yes" xml:space="preserve">
          <source>The state of one method invocation on a thread's call stack. As a thread executes, stack frames are pushed and popped from its call stack as methods are invoked and then return. A StackFrame mirrors one such frame from a target VM at some point in its thread's execution. The call stack is, then, simply a List of StackFrame objects. The call stack can be obtained any time a thread is suspended through a call to &lt;a href=&quot;threadreference#frames()&quot;&gt;&lt;code&gt;ThreadReference.frames()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">스레드의 호출 스택에 대한 하나의 메서드 호출 상태입니다. 스레드가 실행되면 메서드가 호출 된 다음 반환 될 때 스택 프레임이 호출 스택에서 푸시되고 팝됩니다. StackFrame은 스레드 실행의 특정 지점에서 대상 VM에서 이러한 프레임 하나를 미러링합니다. 그러면 호출 스택은 단순히 StackFrame 개체의 목록입니다. 호출 스택은 &lt;a href=&quot;threadreference#frames()&quot;&gt; &lt;code&gt;ThreadReference.frames()&lt;/code&gt; &lt;/a&gt; 호출을 통해 스레드가 일시 중단 될 때마다 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f87189b7cffe5c4bdbf9a74576a5752597c030" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream &lt;a href=&quot;../../io/closeable#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;. The file is not required to exist at the time that the file attribute view is created but methods to read or update attributes of the file will fail when invoked and the file does not exist.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결됩니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메서드에서 &lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. 파일 속성보기가 작성 될 때 파일이 존재하지 않아도되지만 파일 속성을 읽거나 업데이트하는 메소드가 호출 될 때 실패하고 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31371db7bcedb5e6ef0fa2a822080261021c1cbf" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream &lt;a href=&quot;../../io/closeable#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;. The file is not required to exist at the time that the file attribute view is created but methods to read or update attributes of the file will fail when invoked and the file does not exist.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결되어 있습니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메소드가 발생합니다.&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; . 파일 속성보기가 작성 될 때 파일이 존재하지 않아도되지만 호출 될 때 파일의 속성을 읽거나 업데이트하는 메소드가 실패하고 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5387502d22d451f2fcf83887e20653a2840e5163" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream is &lt;a href=&quot;../../io/closeable#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결됩니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메서드에서 &lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6e75ea05d69038d832d8131b3848e4927b08478a" translate="yes" xml:space="preserve">
          <source>The state of resulting file attribute view is intimately connected to this directory stream. Once the directory stream is &lt;a href=&quot;../../io/closeable#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then all methods to read or update attributes will throw &lt;a href=&quot;closeddirectorystreamexception&quot;&gt;&lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 파일 속성보기의 상태는이 디렉토리 스트림에 밀접하게 연결되어 있습니다. 디렉토리 스트림이 &lt;a href=&quot;../../io/closeable#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 속성을 읽거나 업데이트하는 모든 메소드가 발생합니다.&lt;a href=&quot;closeddirectorystreamexception&quot;&gt; &lt;code&gt;ClosedDirectoryStreamException&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cfab20243a8ae6cc96b634df30cc6e006330263" translate="yes" xml:space="preserve">
          <source>The state of the horizontal and vertical scrollbars is represented by two &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; objects (one for each dimension) which implement the &lt;code&gt;Adjustable&lt;/code&gt; interface. The API provides methods to access those objects such that the attributes on the Adjustable object (such as unitIncrement, value, etc.) can be manipulated.</source>
          <target state="translated">가로 및 세로 스크롤 막대의 상태 는 &lt;code&gt;Adjustable&lt;/code&gt; 인터페이스 를 구현하는 두 개의 &lt;code&gt;ScrollPaneAdjustable&lt;/code&gt; 개체 (각 차원에 대해 하나씩)로 표시 됩니다. API는 해당 개체에 액세스하는 메서드를 제공하여 조정 가능한 개체의 속성 (예 : unitIncrement, 값 등)을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996e9184ffea209eb07129d46d0cbe21a541d384" translate="yes" xml:space="preserve">
          <source>The state of the match result passed to the replacer function is guaranteed to be constant only for the duration of the replacer function call and only if the replacer function does not modify this matcher's state.</source>
          <target state="translated">replacer 함수에 전달 된 일치 결과의 상태는 replacer 함수 호출 기간 동안과 replacer 함수가이 일치 자의 상태를 수정하지 않는 경우에만 일정하게 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5df4fed0eb737b7e2f38a8fe3aee9d1a9f382989" translate="yes" xml:space="preserve">
          <source>The state of the modifier keys.</source>
          <target state="translated">수정 자 키의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="98da643dc29593f616d4b328dffe394f8b15ab99" translate="yes" xml:space="preserve">
          <source>The state of the modifier keys. This is replaced with InputEvent.getModifiers() In java 1.1 MouseEvent and KeyEvent are subclasses of InputEvent.</source>
          <target state="translated">수정 자 키의 상태입니다. 이것은 InputEvent.getModifiers ()로 대체되었습니다. java 1.1에서 MouseEvent와 KeyEvent는 InputEvent의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e2b4f9494871b832aa6cdc89d8afd5085d887c4d" translate="yes" xml:space="preserve">
          <source>The state of the tree selection is characterized by a set of TreePaths, and optionally a set of integers. The mapping from TreePath to integer is done by way of an instance of RowMapper. It is not necessary for a TreeSelectionModel to have a RowMapper to correctly operate, but without a RowMapper &lt;code&gt;getSelectionRows&lt;/code&gt; will return null.</source>
          <target state="translated">트리 선택의 상태는 TreePath 세트와 선택적으로 정수 세트로 특성화됩니다. TreePath에서 정수로의 매핑은 RowMapper의 인스턴스를 통해 수행됩니다. TreeSelectionModel이 올바르게 작동하기 위해 RowMapper를 가질 필요는 없지만 RowMapper가 없으면 &lt;code&gt;getSelectionRows&lt;/code&gt; 는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1dd113847fce5d615aef061976b5b5490ed246b1" translate="yes" xml:space="preserve">
          <source>The static methods of this class are also guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.</source>
          <target state="translated">이 클래스의 정적 메소드는 스레드로부터 안전합니다. 여러 스레드가 동시에이 클래스에 정의 된 정적 메서드를 아무런 영향없이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd0f94f9998daea410fa7e45671e8cee561746d9" translate="yes" xml:space="preserve">
          <source>The static methods of this class are guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.</source>
          <target state="translated">이 클래스의 정적 메소드는 스레드로부터 안전합니다. 여러 스레드가 동시에이 클래스에 정의 된 정적 메서드를 아무런 영향없이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f29a8577aa7fa5da666083e0fd1a58f4e6d820" translate="yes" xml:space="preserve">
          <source>The status before the transition.</source>
          <target state="translated">전환 전 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e02a1b12a0469601ec44897d75008b5d8295adbb" translate="yes" xml:space="preserve">
          <source>The status before the transition. If this event describes a Snippet creation return &lt;a href=&quot;snippet.status#NONEXISTENT&quot;&gt;&lt;code&gt;NONEXISTENT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전환 전 상태입니다. 이 이벤트가 Snippet 생성을 설명하는 경우 &lt;a href=&quot;snippet.status#NONEXISTENT&quot;&gt; &lt;code&gt;NONEXISTENT&lt;/code&gt; 를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="453f0a5aaaeaa1b3ec705217a056ecbeb4f2af9e" translate="yes" xml:space="preserve">
          <source>The status is allowed.</source>
          <target state="translated">상태가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b19b7fa28bfd0ac50416748ffc0c43c6c19d76ee" translate="yes" xml:space="preserve">
          <source>The status is rejected.</source>
          <target state="translated">상태가 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="43acb129e0f044bbc46043461b48630e54dab85d" translate="yes" xml:space="preserve">
          <source>The status is undecided, not allowed and not rejected.</source>
          <target state="translated">상태는 미결정, 허용되지 않음 및 거부되지 않음입니다.</target>
        </trans-unit>
        <trans-unit id="c8c42310ccefa275fea074e407b370d922b16a8c" translate="yes" xml:space="preserve">
          <source>The status of a check on the class, array length, number of references, depth, and stream size.</source>
          <target state="translated">클래스, 배열 길이, 참조 수, 깊이 및 스트림 크기에 대한 검사 상태입니다.</target>
        </trans-unit>
        <trans-unit id="0914f7bca27a68099a07b4e6076d13b547cbe3fd" translate="yes" xml:space="preserve">
          <source>The stax.properties file is read only once by the implementation and its values are then cached for future use. If the file does not exist when the first attempt is made to read from it, no further attempts are made to check for its existence. It is not possible to change the value of any property in stax.properties after it has been read for the first time.</source>
          <target state="translated">stax.properties 파일은 구현에 의해 한 번만 읽히고 그 값은 나중에 사용하기 위해 캐시됩니다. 파일을 처음 읽으려고 할 때 파일이 존재하지 않으면 그 존재를 확인하기 위해 더 이상 시도하지 않습니다. stax.properties의 속성 값을 처음 읽은 후에는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b80b91b73f97f322ab33c92b0bd0b2d998475afe" translate="yes" xml:space="preserve">
          <source>The step and pred functions are then executed, in clause order (step before pred), until a pred function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">그런 다음 pred 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때까지 step 및 pred 함수가 절 순서 (pred 전 단계)에 따라 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="894a59007f0696d713a79c9ba3e2b5d5cb14c470" translate="yes" xml:space="preserve">
          <source>The steps in the rendering process are:</source>
          <target state="translated">렌더링 프로세스의 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c14f9f8f60727625d22b3850782fe64ea87452ab" translate="yes" xml:space="preserve">
          <source>The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including &lt;code&gt;null&lt;/code&gt;, and throw an exception, as described in the specification for &lt;a href=&quot;collection#add(E)&quot;&gt;&lt;code&gt;Collection.add&lt;/code&gt;&lt;/a&gt;. Individual set implementations should clearly document any restrictions on the elements that they may contain.</source>
          <target state="translated">위의 규정은 집합이 모든 요소를 ​​수용해야 함을 의미하지 않습니다. 집합은 &lt;a href=&quot;collection#add(E)&quot;&gt; &lt;code&gt;Collection.add&lt;/code&gt; &lt;/a&gt; 사양에 설명 된대로 &lt;code&gt;null&lt;/code&gt; 을 포함한 특정 요소 추가를 거부 하고 예외를 throw 할 수 있습니다. 개별 집합 구현은 포함 할 수있는 요소에 대한 제한 사항을 명확하게 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="8af2436810c570bd5737c0e2bb02a5d795441443" translate="yes" xml:space="preserve">
          <source>The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including &lt;code&gt;null&lt;/code&gt;, and throw an exception, as described in the specification for &lt;a href=&quot;collection#add-E-&quot;&gt;&lt;code&gt;Collection.add&lt;/code&gt;&lt;/a&gt;. Individual set implementations should clearly document any restrictions on the elements that they may contain.</source>
          <target state="translated">위의 규정은 세트가 모든 요소를 ​​수용해야 함을 의미하지는 않습니다. set은 &lt;a href=&quot;collection#add-E-&quot;&gt; &lt;code&gt;Collection.add&lt;/code&gt; &lt;/a&gt; 사양에 설명 된대로 &lt;code&gt;null&lt;/code&gt; 을 포함한 특정 요소 추가를 거부 하고 예외를 throw 할 수 있습니다. 개별 집합 구현에는 포함될 수있는 요소에 대한 제한 사항이 명확하게 문서화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="18eb68b1ed315d63fa4df9e04e256a50303f9665" translate="yes" xml:space="preserve">
          <source>The stored chain is cloned before being returned.</source>
          <target state="translated">저장된 체인은 반환되기 전에 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="34211847f3a2164208058d0523645bdef1169daa" translate="yes" xml:space="preserve">
          <source>The stored derived color</source>
          <target state="translated">저장된 파생 색상</target>
        </trans-unit>
        <trans-unit id="59fa77a75631a5fd04013364bcf5c35eed6bf5bc" translate="yes" xml:space="preserve">
          <source>The strategy used to shut down the application, if Sudden Termination is not enabled.</source>
          <target state="translated">갑자기 종료가 활성화되지 않은 경우 응용 프로그램을 종료하는 데 사용되는 전략입니다.</target>
        </trans-unit>
        <trans-unit id="6a20537f8d5d92c9cff89f8fb6c2858031b1dd68" translate="yes" xml:space="preserve">
          <source>The stream binds to this bit set when the terminal stream operation commences (specifically, the spliterator for the stream is &lt;a href=&quot;spliterator#binding&quot;&gt;&lt;em&gt;late-binding&lt;/em&gt;&lt;/a&gt;). If the bit set is modified during that operation then the result is undefined.</source>
          <target state="translated">스트림은 터미널 스트림 작업이 시작될 때이 비트 세트에 바인딩됩니다 (특히 스트림의 분할자는 &lt;a href=&quot;spliterator#binding&quot;&gt;&lt;em&gt;후기 바인딩&lt;/em&gt;&lt;/a&gt; 임). 해당 작업 중에 비트 세트가 수정되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b503c50c6ec2a853d246bef99b17e237b1f62fe3" translate="yes" xml:space="preserve">
          <source>The stream binds to this sequence when the terminal stream operation commences (specifically, for mutable sequences the spliterator for the stream is &lt;a href=&quot;../util/spliterator#binding&quot;&gt;&lt;em&gt;late-binding&lt;/em&gt;&lt;/a&gt;). If the sequence is modified during that operation then the result is undefined.</source>
          <target state="translated">스트림은 터미널 스트림 작업이 시작될 때이 시퀀스에 바인딩됩니다 (특히, 변경 가능한 시퀀스의 경우 스트림에 대한 분할자는 &lt;a href=&quot;../util/spliterator#binding&quot;&gt;&lt;em&gt;후기 바인딩&lt;/em&gt;&lt;/a&gt; ). 해당 작업 중에 시퀀스가 ​​수정되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="284a200aa5c754806caf07fbf13e99a88b0c7015" translate="yes" xml:space="preserve">
          <source>The stream is</source>
          <target state="translated">스트림은</target>
        </trans-unit>
        <trans-unit id="0f4127d1899727942c90922302e4fcbdc49bed7d" translate="yes" xml:space="preserve">
          <source>The stream is parallel;</source>
          <target state="translated">스트림은 평행하다.</target>
        </trans-unit>
        <trans-unit id="18c2dad420890c0c93e56bc71847c1ffc91d517a" translate="yes" xml:space="preserve">
          <source>The stream is written using the ISO 8859-1 character encoding.</source>
          <target state="translated">스트림은 ISO 8859-1 문자 인코딩을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="cf2f279f616bcf76e47ab21d81f5d9638809710c" translate="yes" xml:space="preserve">
          <source>The stream may contain some data outside the specified range.</source>
          <target state="translated">스트림에 지정된 범위를 벗어난 일부 데이터가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8981351805e6fb1fc8a0c57d5496e2d24e17c129" translate="yes" xml:space="preserve">
          <source>The stream number</source>
          <target state="translated">스트림 번호</target>
        </trans-unit>
        <trans-unit id="40953f480e1f2608bd2829d4c5ca6a88b49f29cb" translate="yes" xml:space="preserve">
          <source>The stream of strings computed by splitting the input around matches of this pattern</source>
          <target state="translated">이 패턴의 일치 항목 주위에 입력을 분할하여 계산 된 문자열 스트림</target>
        </trans-unit>
        <trans-unit id="0278f0c3b2832857f3b5d471e56fa1f750974135" translate="yes" xml:space="preserve">
          <source>The stream position is left at its prior position upon exit from this method.</source>
          <target state="translated">이 방법에서 나갈 때 스트림 위치는 이전 위치에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c88da049e966b7fa1b0336d227d0469c10d044c" translate="yes" xml:space="preserve">
          <source>The stream returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the stream are in the order in which they occur in the input. Trailing empty strings will be discarded and not encountered in the stream.</source>
          <target state="translated">이 메소드에 의해 리턴 된 스트림은이 패턴과 일치하는 다른 서브 시퀀스에 의해 종료되거나 입력 시퀀스의 끝에 의해 종료되는 입력 시퀀스의 각 서브 스트링을 포함합니다. 스트림의 하위 문자열은 입력에서 발생하는 순서입니다. 후행 빈 문자열은 버리고 스트림에서 발견되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6f6114953487ace92dd1c168418f7e9f095d3d0" translate="yes" xml:space="preserve">
          <source>The stream returned by this method contains the lines from this string in the order in which they occur.</source>
          <target state="translated">이 메서드가 반환하는 스트림에는이 문자열의 행이 발생하는 순서대로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cc5a36b07837d8684881fc09793cf7774af9e41a" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메서드를 지원하지 않습니다 . 스트림은 여러 동시 스레드에 의한 액세스에 안전합니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="8035d3c148eb320bea2a1229c6025747c0adc1f8" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메소드를 지원하지 않습니다 . 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="bc7063010775a8a4dfbf6ea7c3f4fd8168851da4" translate="yes" xml:space="preserve">
          <source>The stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">스트림은 버퍼링되지 않습니다. 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="635eea582878c3cee66666dcef47dae09ac40dc8" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e0b7738c3889e14f5b400112462983b88473f42" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;acceptSecContext(byte[], int, int)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;acceptSecContext(byte[], int, int)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fdd1e4fc8cc236e807967eab1defe58a2d7fb81c" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;getMIC(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;getMIC(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="75a1f54ce108d9e7d4e20f8e2e55c349191efa71" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;initSecContext(byte[], int, int)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;initSecContext(byte[], int, int)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="837beaf6b0fd108bd6761b7a930f749f93c98a2f" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;unwrap(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;unwrap(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20e163f975ddc90067dad425a1a8436ac6312c00" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;verifyMIC(byte[], int, int, byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다. 대신 &lt;a href=&quot;#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;verifyMIC(byte[], int, int, byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3311a132a16f8c1f01912c04e4d437b623872dab" translate="yes" xml:space="preserve">
          <source>The stream-based methods have been removed from RFC 8353. Use &lt;a href=&quot;#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap(byte[], int, int, MessageProp)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스트림 기반 메서드는 RFC 8353에서 제거되었습니다 . 대신 &lt;a href=&quot;#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap(byte[], int, int, MessageProp)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6e7c1e2a83cde4b74baace6a01266e9922cbc527" translate="yes" xml:space="preserve">
          <source>The stream-based methods of &lt;code&gt;GSSContext&lt;/code&gt; have been deprecated in Java SE 11. These methods have also been removed from &lt;a href=&quot;http://tools.ietf.org/html/rfc8353&quot;&gt; RFC 8353: Generic Security Service API Version 2: Java Bindings Update&lt;/a&gt; for the following reasons (see section 11): &quot;The overloaded methods of GSSContext that use input and output streams as the means to convey authentication and per-message GSS-API tokens as described in Section 5.15 of RFC 5653 are removed in this update as the wire protocol should be defined by an application and not a library. It's also impossible to implement these methods correctly when the token has no self-framing (where the end cannot be determined), or the library has no knowledge of the token format (for example, as a bridge talking to another GSS library)&quot;. These methods include &lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GSSContext&lt;/code&gt; 의 스트림 기반 메소드는 Java SE 11에서 더 이상 사용되지 않습니다. 이러한 메소드는 다음과 같은 이유로 &lt;a href=&quot;http://tools.ietf.org/html/rfc8353&quot;&gt;RFC 8353&lt;/a&gt; 에서 제거되었습니다 . 일반 보안 서비스 API 버전 2 : Java 바인딩 업데이트 (11 절 참조) : &quot; RFC 5653의 섹션 5.15에 설명 된대로 인증 및 메시지 당 GSS-API 토큰을 전달하는 수단으로 입력 및 출력 스트림을 사용하는 GSSContext는 유선 프로토콜이 라이브러리가 아닌 응용 프로그램에 의해 정의되어야하므로 이번 업데이트에서 제거되었습니다. 또한 토큰에 자체 프레이밍이 없거나 (끝을 확인할 수없는 경우) 라이브러리가 토큰 형식을 알지 못하는 경우 (예 : 다른 GSS 라이브러리와 통신하는 브리지) 이러한 메서드를 올바르게 구현할 수 없습니다. &quot; 이러한 방법에는 다음이 포함됩니다.&lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93d3cf16abf302a5134c3443f01b2257c53b0385" translate="yes" xml:space="preserve">
          <source>The stream-based methods of &lt;code&gt;GSSContext&lt;/code&gt; have been deprecated in Java SE 11. These methods have also been removed from &lt;a href=&quot;https://tools.ietf.org/html/rfc8353&quot;&gt; RFC 8353: Generic Security Service API Version 2: Java Bindings Update&lt;/a&gt; for the following reasons (see section 11): &quot;The overloaded methods of GSSContext that use input and output streams as the means to convey authentication and per-message GSS-API tokens as described in Section 5.15 of RFC 5653 are removed in this update as the wire protocol should be defined by an application and not a library. It's also impossible to implement these methods correctly when the token has no self-framing (where the end cannot be determined), or the library has no knowledge of the token format (for example, as a bridge talking to another GSS library)&quot;. These methods include &lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt;&lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt;&lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GSSContext&lt;/code&gt; 의 스트림 기반 메소드는 Java SE 11에서 더 이상 사용되지 않습니다. 이러한 메소드는 다음과 같은 이유로 &lt;a href=&quot;https://tools.ietf.org/html/rfc8353&quot;&gt;RFC 8353&lt;/a&gt; 에서도 제거되었습니다 . 일반 보안 서비스 API 버전 2 : Java 바인딩 업데이트 (섹션 11 참조) : RFC 5653의 섹션 5.15에 설명 된대로 인증 및 메시지 당 GSS-API 토큰을 전달하는 수단으로 입력 및 출력 스트림을 사용하는 GSSContext는 유선 프로토콜이 라이브러리가 아닌 애플리케이션에 의해 정의되어야하므로 이번 업데이트에서 제거되었습니다. 또한 토큰에 자체 프레이밍이 없거나 (끝을 결정할 수없는 경우) 라이브러리가 토큰 형식을 알지 못하는 경우 (예 : 다른 GSS 라이브러리와 통신하는 브리지) 이러한 메서드를 올바르게 구현할 수 없습니다. &quot; 이러한 방법에는 다음이 포함됩니다.&lt;a href=&quot;#initSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;initSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#acceptSecContext(java.io.InputStream,java.io.OutputStream)&quot;&gt; &lt;code&gt;acceptSecContext(InputStream, OutputStream)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;wrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;unwrap(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;getMIC(InputStream, OutputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)&quot;&gt; &lt;code&gt;verifyMIC(InputStream, InputStream, MessageProp)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3196486e12ee1ceae179dd2a0073d0d87998aba" translate="yes" xml:space="preserve">
          <source>The strict sequential order of invocations from &lt;code&gt;WebSocket&lt;/code&gt; to &lt;code&gt;Listener&lt;/code&gt; means, in particular, that the &lt;code&gt;Listener&lt;/code&gt;'s methods are treated as non-reentrant. This means that &lt;code&gt;Listener&lt;/code&gt; implementations do not need to be concerned with possible recursion or the order in which they invoke &lt;code&gt;WebSocket.request&lt;/code&gt; in relation to their processing logic.</source>
          <target state="translated">&lt;code&gt;WebSocket&lt;/code&gt; 에서 &lt;code&gt;Listener&lt;/code&gt; 로의 엄격한 순차적 호출 순서는 특히 &lt;code&gt;Listener&lt;/code&gt; 의 메서드가 재진입이 아닌 것으로 처리 된다는 것을 의미 합니다. 이는 &lt;code&gt;Listener&lt;/code&gt; 구현이 가능한 재귀 또는 처리 로직과 관련하여 &lt;code&gt;WebSocket.request&lt;/code&gt; 를 호출하는 순서에 관심을 가질 필요가 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="677e924344268647b9f4c33bebdbd774bffeedb1" translate="yes" xml:space="preserve">
          <source>The strikethrough affects both the visual bounds and the outline of the text.</source>
          <target state="translated">취소 선은 텍스트의 시각적 경계와 윤곽 모두에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="08ace5725b5a326d5041f65d175699034a1c1db6" translate="yes" xml:space="preserve">
          <source>The string &quot;error&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;error&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="bfc3fe82f3ff5835f163f82fa9c6c4dba766b9ab" translate="yes" xml:space="preserve">
          <source>The string &quot;false&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;false&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="e30c0643390c5dc7ebd25358b9755769e7551051" translate="yes" xml:space="preserve">
          <source>The string &quot;keep&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;keep&quot;은 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="1f0cf467ff107c2e23c66f6d76abd1c756e88c98" translate="yes" xml:space="preserve">
          <source>The string &quot;latest&quot;, a possible value for certain properties.</source>
          <target state="translated">특정 속성에 가능한 값인 &quot;latest&quot;문자열</target>
        </trans-unit>
        <trans-unit id="108f1155e473064ee5869a10046f49c5f28678dc" translate="yes" xml:space="preserve">
          <source>The string &quot;pass&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;pass&quot;는 특정 속성에 가능한 값입니다.</target>
        </trans-unit>
        <trans-unit id="558ef0c8eaf4af89eed40f1773ec89e05db3ff2d" translate="yes" xml:space="preserve">
          <source>The string &quot;strip&quot;, a possible value for certain properties.</source>
          <target state="translated">문자열 &quot;strip&quot;, 특정 속성에 가능한 값.</target>
        </trans-unit>
        <trans-unit id="465f99ea7628c0edb2cf953567db0aafbc5f0067" translate="yes" xml:space="preserve">
          <source>The string &quot;true&quot;, a possible value for certain properties.</source>
          <target state="translated">특정 속성에 가능한 값인 &quot;true&quot;문자열</target>
        </trans-unit>
        <trans-unit id="22c0cd468531813dfe7dcaa04b8b2d76bff20d6f" translate="yes" xml:space="preserve">
          <source>The string &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt; means that the pack operation as a whole will fail, with an exception of type &lt;code&gt;IOException&lt;/code&gt;. The string &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt; means that the attribute will be dropped. The string &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; means that the whole class-file will be passed through (as if it were a resource file) without compression, with a suitable warning. This is the default value for this property.</source>
          <target state="translated">&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; 문자열 은 &lt;code&gt;IOException&lt;/code&gt; 유형의 예외를 제외하고 전체적으로 압축 작업이 실패 함을 의미합니다 . &lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 문자열 은 속성이 삭제됨을 의미합니다. &lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 문자열 은 전체 클래스 파일이 압축없이 (리소스 파일 인 것처럼) 적절한 경고와 함께 전달됨을 의미합니다. 이 속성의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b7d2fbb70acb3059d5c5bbd79c4294963cdbf352" translate="yes" xml:space="preserve">
          <source>The string &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt; means that the pack operation as a whole will fail, with an exception of type &lt;code&gt;IOException&lt;/code&gt;. The string &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt; means that the attribute will be dropped. The string &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; means that the whole class-file will be passed through (as if it were a resource file) without compression, with a suitable warning. This is the default value for this property.</source>
          <target state="translated">문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;IOException&lt;/code&gt; 유형을 제외하고 전체 팩 조작이 실패 함을 의미합니다 . 문자열 &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 는 속성이 삭제됨을 의미합니다. 문자열 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 는 적절한 경고와 함께 전체 클래스 파일이 압축없이 (리소스 파일 인 것처럼) 전달됨을 의미합니다. 이것이이 속성의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ad02c3d243be4e9c61737e03ba9c0bf8b38dbb60" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these expressions:</source>
          <target state="translated">예를 들어, 문자열 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 는 다음 표현식으로 다음 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0a75a6f894f0ae1c44cee0d9fcd6514b9f78e1dd" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt;, for example, yields the following results with these parameters:</source>
          <target state="translated">예를 들어, 문자열 &lt;code&gt;&quot;boo:and:foo&quot;&lt;/code&gt; 는 다음 매개 변수를 사용하여 다음 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1565ac3867c9c20773f4cb4feb587c3d597a0245" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;precision=&quot;&lt;/code&gt;, immediately followed by the value of the precision setting as a numeric string as if generated by the &lt;a href=&quot;../lang/integer#toString(int)&quot;&gt;&lt;code&gt;Integer.toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;precision=&quot;&lt;/code&gt; . &lt;a href=&quot;../lang/integer#toString(int)&quot;&gt; &lt;code&gt;Integer.toString&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성 된 것처럼 숫자 문자열로 정밀도 설정 값이 바로 뒤에옵니다 .</target>
        </trans-unit>
        <trans-unit id="6550e9f9888c201023a4fc7c4d06f985451147bf" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;precision=&quot;&lt;/code&gt;, immediately followed by the value of the precision setting as a numeric string as if generated by the &lt;a href=&quot;../lang/integer#toString-int-&quot;&gt;&lt;code&gt;Integer.toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;precision=&quot;&lt;/code&gt; , 바로 뒤에 &lt;a href=&quot;../lang/integer#toString-int-&quot;&gt; &lt;code&gt;Integer.toString&lt;/code&gt; &lt;/a&gt; 메서드에서 생성 된 것처럼 정밀도 설정 값이 숫자 문자열로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="62905723a8ac431fa9dccaf628bb9c07af02e5dd" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;roundingMode=&quot;&lt;/code&gt;, immediately followed by the value of the &lt;code&gt;roundingMode&lt;/code&gt; setting as a word. This word will be the same as the name of the corresponding public constant in the &lt;a href=&quot;roundingmode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;roundingMode=&quot;&lt;/code&gt; , 바로 뒤에 &lt;code&gt;roundingMode&lt;/code&gt; 설정 값이 단어로 표시됩니다. 이 단어는 &lt;a href=&quot;roundingmode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt; 열거 형 의 해당 공용 상수 이름과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a056f3c02b144a1272485d342c4c2a38f8a60c41" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this MBean is an &lt;a href=&quot;mxbean&quot;&gt;&lt;code&gt;MXBean&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly with the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">이 MBean에 따른 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 는 &lt;a href=&quot;mxbean&quot;&gt; &lt;code&gt;MXBean&lt;/code&gt; &lt;/a&gt; 입니다. MBean Server에 직접 등록되거나 &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 작성된 표준 MBean 또는 MXBean 은이 필드를 MBeanInfo 디스크립터에 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fa3bdb340e93ffe54892a6e3894a1d8cb94a703a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this MBean's MBeanInfo is &lt;em&gt;immutable&lt;/em&gt;. When this field is true, the MBeanInfo for the given MBean is guaranteed not to change over the lifetime of the MBean. Hence, a client can read it once and cache the read value. When this field is false or absent, there is no such guarantee, although that does not mean that the MBeanInfo will necessarily change. See also the &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt;&lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; notification.</source>
          <target state="translated">이 MBean MBeanInfo로서의 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 캐릭터 라인 은 &lt;em&gt;불변&lt;/em&gt; 입니다. 이 필드가 true 인 경우, 지정된 MBean의 MBeanInfo는 MBean의 수명 동안 변경되지 않도록 보장됩니다. 따라서 클라이언트는 한 번 읽고 읽은 값을 캐시 할 수 있습니다. 이 필드가 false 또는없는 경우, MBeanInfo가 반드시 변경되는 것은 아닙니다만, 그러한 보증은 없습니다. &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt; 알림 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58cf603470519c5b5e195c25d45c63e85fd34cc0" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; according as this item is enabled. When an attribute or operation is not enabled, it exists but cannot currently be accessed. A user interface might present it as a greyed-out item. For example, an attribute might only be meaningful after the &lt;code&gt;start()&lt;/code&gt; method of an MBean has been called, and is otherwise disabled. Likewise, a notification might be disabled if it cannot currently be emitted but could be in other circumstances.</source>
          <target state="translated">이 항목에 따라 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 가 활성화됩니다. 속성 또는 조작이 사용 가능하지 않으면 존재하지만 현재 액세스 할 수 없습니다. 사용자 인터페이스는이를 회색으로 표시 할 수 있습니다. 예를 들어, 속성은 MBean 의 &lt;code&gt;start()&lt;/code&gt; 메소드가 호출 된 후에 만 의미 가 있으며, 그렇지 않으면 비활성화됩니다. 마찬가지로 현재 알림을 생성 할 수 없지만 다른 상황에있을 수있는 경우 알림이 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="631ed054c3067658cc3a118e7936d64f51bfad09" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;unchecked&quot;&lt;/code&gt; is used to suppress unchecked warnings. Compiler vendors should document the additional warning names they support in conjunction with this annotation type. They are encouraged to cooperate to ensure that the same names work across multiple compilers.</source>
          <target state="translated">&lt;code&gt;&quot;unchecked&quot;&lt;/code&gt; 문자열 은 확인되지 않은 경고를 억제하는 데 사용됩니다. 컴파일러 공급 업체는이 주석 유형과 함께 지원하는 추가 경고 이름을 문서화해야합니다. 동일한 이름이 여러 컴파일러에서 작동하도록 협력하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="69491b7b47334ee084c1c31f631a979ba7599e82" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s&lt;/code&gt; is processed from left to right, looking for data of interest. Any material in &lt;code&gt;s&lt;/code&gt; that is within the ASCII parenthesis characters &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; is ignored. Parentheses may be nested. Otherwise, the only characters permitted within &lt;code&gt;s&lt;/code&gt; are these ASCII characters:</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 는 왼쪽에서 오른쪽으로 처리되어 관심있는 데이터를 찾습니다. ASCII 괄호 문자 &lt;code&gt;(&lt;/code&gt; 및 &lt;code&gt;)&lt;/code&gt; 내에있는 &lt;code&gt;s&lt;/code&gt; 의 모든 자료 는 무시됩니다. 괄호는 중첩 될 수 있습니다. 그렇지 않으면 &lt;code&gt;s&lt;/code&gt; 내에 허용되는 유일한 문자 는 다음 ASCII 문자입니다.</target>
        </trans-unit>
        <trans-unit id="fa07a44e85f7b0960fe0afe9cd1bc3596bb25ceb" translate="yes" xml:space="preserve">
          <source>The string NULL (not enclosed in quotes) - if NULL was specified as the default value</source>
          <target state="translated">문자열 NULL (따옴표로 묶지 않음)-NULL이 기본값으로 지정된 경우</target>
        </trans-unit>
        <trans-unit id="919c5615e88a8576efe725aa5581160688478bfe" translate="yes" xml:space="preserve">
          <source>The string attribute values are not interpreted as &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; formatted RDN strings. That is, the values are used literally (not parsed) and assumed to be unescaped.</source>
          <target state="translated">문자열 속성 값은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; 형식의 RDN 문자열 로 해석되지 않습니다 . 즉, 값은 문자 그대로 (구문 분석되지 않음) 사용되며 이스케이프 처리되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="281a06519e314093dc16bc940319b122ec1fafd2" translate="yes" xml:space="preserve">
          <source>The string attribute values are not interpreted as &lt;a href=&quot;https://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; formatted RDN strings. That is, the values are used literally (not parsed) and assumed to be unescaped.</source>
          <target state="translated">문자열 속성 값은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; 형식의 RDN 문자열 로 해석되지 않습니다 . 즉, 값은 문자 그대로 (파싱되지 않음) 사용되며 이스케이프되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fad0ec093c3f0998c8bdd918a0718e5eab967d10" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing each matching subsequence by the replacement string, substituting captured subsequences as needed</source>
          <target state="translated">일치하는 각 서브 시퀀스를 교체 스트링으로 교체하고 필요에 따라 캡처 된 서브 시퀀스를 대체하여 구성된 스트링</target>
        </trans-unit>
        <trans-unit id="afda6d3703500c7f92e7b1f7f59b56df33958ed8" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing each matching subsequence with the result of applying the replacer function to that matched subsequence, substituting captured subsequences as needed.</source>
          <target state="translated">각 일치하는 하위 시퀀스를 일치하는 하위 시퀀스에 대체 함수를 적용한 결과로 대체하여 생성 된 문자열입니다. 필요에 따라 캡처 된 하위 시퀀스를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c64ffe780cf31db4996cccb5e0b7a94f8f71ac12" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing the first matching subsequence by the replacement string, substituting captured subsequences as needed</source>
          <target state="translated">첫 번째로 일치하는 하위 시퀀스를 대체 문자열로 바꾸고 캡처 된 하위 시퀀스를 필요에 따라 대체하여 구성된 문자열</target>
        </trans-unit>
        <trans-unit id="e0bec6f730c0449ee38f585e3dde0d82f697b3cb" translate="yes" xml:space="preserve">
          <source>The string constructed by replacing the first matching subsequence with the result of applying the replacer function to the matched subsequence, substituting captured subsequences as needed.</source>
          <target state="translated">첫 번째 일치하는 하위 시퀀스를 일치 된 하위 시퀀스에 대체 함수를 적용한 결과로 바꾸고 필요에 따라 캡처 된 하위 시퀀스를 대체하여 구성된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="57510220bfaf470419bb00af78884a6462f36070" translate="yes" xml:space="preserve">
          <source>The string containing the version of the module if recorded at compile-time, or an empty &lt;code&gt;Optional&lt;/code&gt; if no version was recorded</source>
          <target state="translated">컴파일 타임에 기록 된 경우 모듈의 버전을 포함하는 문자열 또는 기록 된 버전이 없으면 빈 &lt;code&gt;Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a584ad3952c728ec28d3c26b8f0d57ad4cd86d7a" translate="yes" xml:space="preserve">
          <source>The string containing the version of the module or an empty &lt;code&gt;Optional&lt;/code&gt; if the module does not have a version</source>
          <target state="translated">모듈의 버전을 포함하는 문자열 또는 모듈에 버전이없는 경우 빈 &lt;code&gt;Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c31beff83674da5e332dc00712cbbbdd5562206f" translate="yes" xml:space="preserve">
          <source>The string form of the compound name follows the syntax described above. When the components of the compound name are turned into their string representation, the reserved syntax rules described above are applied (e.g. embedded separators are escaped or quoted) so that when the same string is parsed, it will yield the same components of the original compound name.</source>
          <target state="translated">복합 이름의 문자열 형식은 위에서 설명한 구문을 따릅니다. 복합 이름의 구성 요소가 문자열 표시로 바뀌면, 위에서 설명한 예약 구문 규칙이 적용되어 (예 : 내장 분리자가 이스케이프 또는 인용) 동일한 문자열이 구문 분석 될 때 원래 복합의 동일한 구성 요소가 생성됩니다 이름.</target>
        </trans-unit>
        <trans-unit id="f10938b9c9c0c8797b9503b58353064a7df27786" translate="yes" xml:space="preserve">
          <source>The string form of this URI</source>
          <target state="translated">이 URI의 문자열 형식</target>
        </trans-unit>
        <trans-unit id="2fdc4bee66cbffe9f8926f8d8bb6b3ff409dbcc9" translate="yes" xml:space="preserve">
          <source>The string form of this URI, encoded as needed so that it only contains characters in the US-ASCII charset</source>
          <target state="translated">이 URI의 문자열 형식으로 US-ASCII 문자 집합의 문자 만 포함하도록 필요에 따라 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="04761903fd7cc565bcc1b3b493f9a4d9ad183aaa" translate="yes" xml:space="preserve">
          <source>The string form of this abstract pathname</source>
          <target state="translated">이 추상 경로명의 문자열 형식</target>
        </trans-unit>
        <trans-unit id="a6a48b95d9bb03c06186693a1e56c1d93fae2d7c" translate="yes" xml:space="preserve">
          <source>The string from which bytes are read.</source>
          <target state="translated">바이트를 읽는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="63b46307980099765e658cf440f0d03747b95b05" translate="yes" xml:space="preserve">
          <source>The string from which this version was parsed.</source>
          <target state="translated">이 버전이 구문 분석 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b6724bb79c3c33d31e86e0f46c7de30b21951061" translate="yes" xml:space="preserve">
          <source>The string is between 1 and 128 characters in length inclusive</source>
          <target state="translated">문자열의 길이는 1 ~ 128 자입니다.</target>
        </trans-unit>
        <trans-unit id="15fa0640f7a89ad0499dc7372318874d0f8a6949" translate="yes" xml:space="preserve">
          <source>The string is not enclosed in double quotes</source>
          <target state="translated">문자열은 큰 따옴표로 묶여 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2361fc0fcc98f34cf7707bd58c3a48311a40b445" translate="yes" xml:space="preserve">
          <source>The string must match exactly the name of the era. (Extraneous whitespace characters are not permitted.)</source>
          <target state="translated">문자열은 시대의 이름과 정확히 일치해야합니다. (공백 공백 문자는 허용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="528b474b80585c5bde4792fd2aaffc2f3fc1d745" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜를 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE&lt;/code&gt; 를&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a92bea7fe20a26d29fc02f1b18cfeb4a64f2befc" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="9546955f3024f065c5daeea861e41048af02e3a1" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_OFFSET_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea655be45604489e8a988f1f62775445f297e35d" translate="yes" xml:space="preserve">
          <source>The string must represent a valid date-time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_ZONED_DATE_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_ZONED_DATE_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 날짜-시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_ZONED_DATE_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_ZONED_DATE_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="b639943db6958d9063503c47072cf422d9417cda" translate="yes" xml:space="preserve">
          <source>The string must represent a valid instant in UTC and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 인스턴트를 UTC로 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_INSTANT&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_INSTANT&lt;/code&gt; 를&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d2f552261c78dde5773d5eb748ea70d7ae99393" translate="yes" xml:space="preserve">
          <source>The string must represent a valid month-day. The format is &lt;code&gt;--MM-dd&lt;/code&gt;.</source>
          <target state="translated">문자열은 유효한 월일을 나타내야합니다. 형식은 &lt;code&gt;--MM-dd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f5fc471abeddd2fc10059070b03a26ea0e4f0e6" translate="yes" xml:space="preserve">
          <source>The string must represent a valid time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_LOCAL_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_LOCAL_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="4834d95eb10fdeb7855ef1f3b7f1815cd5f315de" translate="yes" xml:space="preserve">
          <source>The string must represent a valid time and is parsed using &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_TIME&quot;&gt;&lt;code&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 유효한 시간을 나타내야하며 &lt;a href=&quot;format/datetimeformatter#ISO_OFFSET_TIME&quot;&gt; &lt;code&gt;DateTimeFormatter.ISO_OFFSET_TIME&lt;/code&gt; 을&lt;/a&gt; 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="522d37a5cb0dea2932c0223382f776eae3acb124" translate="yes" xml:space="preserve">
          <source>The string must represent a valid year-month. The format must be &lt;code&gt;uuuu-MM&lt;/code&gt;. Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.</source>
          <target state="translated">문자열은 유효한 연도를 나타내야합니다. 형식은 &lt;code&gt;uuuu-MM&lt;/code&gt; 이어야합니다 . 0000-9999 범위를 벗어난 연도에는 더하기 또는 빼기 기호가 앞에 붙어야합니다.</target>
        </trans-unit>
        <trans-unit id="68fe36aa287218182684aa7a85b5b9b1977bc3ca" translate="yes" xml:space="preserve">
          <source>The string must represent a valid year. Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.</source>
          <target state="translated">문자열은 유효한 연도를 나타내야합니다. 0000-9999 범위를 벗어난 연도에는 더하기 또는 빼기 기호가 앞에 붙어야합니다.</target>
        </trans-unit>
        <trans-unit id="137a5254a87fa6e0ce4c1568f6ddf435ae99c22b" translate="yes" xml:space="preserve">
          <source>The string only contains alphanumeric characters or the character &quot;_&quot;</source>
          <target state="translated">문자열에는 영숫자 또는 문자 &quot;_&quot;만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="abbf179f85853b351778a26629eb5657fc8e8fab" translate="yes" xml:space="preserve">
          <source>The string produced for a given number is always the same; it is not affected by locale. This means that it can be used as a canonical string representation for exchanging decimal data, or as a key for a Hashtable, etc. Locale-sensitive number formatting and parsing is handled by the &lt;a href=&quot;../text/numberformat&quot;&gt;&lt;code&gt;NumberFormat&lt;/code&gt;&lt;/a&gt; class and its subclasses.</source>
          <target state="translated">주어진 숫자에 대해 생성 된 문자열은 항상 같습니다. 로케일의 영향을받지 않습니다. 이는 10 진수 데이터 교환을위한 표준 문자열 표현 또는 해시 테이블 등의 키로 사용될 수 있음을 의미합니다. 로케일 구분 숫자 형식화 및 구문 분석은 &lt;a href=&quot;../text/numberformat&quot;&gt; &lt;code&gt;NumberFormat&lt;/code&gt; &lt;/a&gt; 클래스 및 해당 서브 클래스에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fe8bf77d08eee400f8eacfe6cb5d936ae0a4f48" translate="yes" xml:space="preserve">
          <source>The string representation consists of a list of the array's elements, enclosed in square brackets (&lt;code&gt;&quot;[]&quot;&lt;/code&gt;). Adjacent elements are separated by the characters &lt;code&gt;&quot;, &quot;&lt;/code&gt; (a comma followed by a space). Elements are converted to strings as by &lt;code&gt;String.valueOf(Object)&lt;/code&gt;, unless they are themselves arrays.</source>
          <target state="translated">문자열 표현은 배열의 요소 목록으로 구성되며 대괄호 ( &lt;code&gt;&quot;[]&quot;&lt;/code&gt; )로 묶습니다 . 인접한 요소는 문자 &lt;code&gt;&quot;, &quot;&lt;/code&gt; (쉼표 뒤에 공백)로 구분됩니다. 요소 자체가 배열이 아닌 경우 요소는 &lt;code&gt;String.valueOf(Object)&lt;/code&gt; 의해 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b44741f71d142966f86ccc32acede59a84d445d" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of the implementing class, and the tabular type of this instance.</source>
          <target state="translated">문자열 표현은 구현 클래스의 이름과이 인스턴스의 테이블 형식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="53d83a239c2a7be1cb8fe5f1423384d5522b995b" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of the implementing class, the string representation of the composite type of this instance, and the string representation of the contents (ie list the itemName=itemValue mappings).</source>
          <target state="translated">문자열 표현은 구현 클래스의 이름,이 인스턴스의 복합 유형의 문자열 표현 및 컨텐츠의 문자열 표현 (즉, itemName = itemValue 맵핑 나열)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce6c605327807271ff809bf8c3e33f72c8d71fb" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt;), the type name, the dimension, the elements' open type and the primitive array flag defined for this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.ArrayType&lt;/code&gt; ), 유형 이름, 차원, 요소의 열린 유형 및이 인스턴스에 대해 정의 된 기본 배열 플래그로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2883eec75a628ef99c332dc7e2aaea10651f3902" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfoSupport&lt;/code&gt;), the string representation of the name and open type of the described parameter, the string representation of its default, min, max and legal values and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfoSupport&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 올바른 값의 문자열 표현 및 기술자의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="8a2464b0766b9e81e51253aa84918715aa0cd068" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (i.e. &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfoSupport&lt;/code&gt;), the string representation of the name and open type of the described parameter, the string representation of its default, min, max and legal values and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfoSupport&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 올바른 값의 문자열 표현 및 기술자의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="4d29a8e6e5f83180a9a2655eeeb086d4d8e9f13e" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;
 javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt;), the name and signature of the described constructor and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (즉, &lt;code&gt; javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt; ), 설명 된 생성자의 이름과 서명, 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ac01ca9000354d194b07d70a4e1b8028f60f9f3e" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;
 javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt;), and the name, signature, return open type and impact of the described operation and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (즉, &lt;code&gt; javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt; )과 이름, 서명, 반환 개방 유형 및 설명 된 작업의 영향과 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6002a9339d22eed93f555f1481a07a002e5091" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt;), the string representation of the composite type of this instance, and the string representation of the contents (ie list the itemName=itemValue mappings).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt; ),이 인스턴스의 복합 유형의 문자열 표현 및 컨텐츠의 문자열 표현 (즉, itemName = itemValue 맵핑 나열)으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="789eed41269dc56a9082ac2a97089c1d128afaf4" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt;), the type name for this instance, and the list of the items names and types string representation of this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.CompositeType&lt;/code&gt; ),이 인스턴스의 유형 이름 및이 인스턴스의 항목 이름 및 유형 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a4e6ec5ac6aa3e0627edbc16f7c6430eb6a8d1d8" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfo&lt;/code&gt;), the string representation of the name and open type of the described attribute, and the string representation of its default, min, max and legal values.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanAttributeInfo&lt;/code&gt; ), 설명 된 속성의 이름 및 열린 유형의 문자열 표현, 기본값, 최소, 최대 및 유효한 값의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b716744f9ffc637689b371f05e304eff7af2a9" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfo&lt;/code&gt;), and the name and signature of the described constructor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfo&lt;/code&gt; )과 설명 된 생성자의 이름 및 서명으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ad27ad5ebd129c3ea4d4956977533104d272e95" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt;), the name and signature of the described constructor and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanConstructorInfoSupport&lt;/code&gt; ), 설명 된 생성자의 이름 및 서명, 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="56f0f9a9629656eb5921de1b1b2280b717218bf7" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanInfo&lt;/code&gt;), the MBean class name, and the string representation of infos on attributes, constructors, operations and notifications of the described MBean.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanInfo&lt;/code&gt; ), MBean 클래스 이름 및 설명 된 MBean의 속성, 생성자, 조작 및 알림에 대한 정보의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d79b194f6330817e69226b3c9fd464f3f27be2" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanInfoSupport&lt;/code&gt;), the MBean class name, the string representation of infos on attributes, constructors, operations and notifications of the described MBean and the string representation of the descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanInfoSupport&lt;/code&gt; ), MBean 클래스 이름, 설명 된 MBean의 속성, 생성자, 조작 및 알림에 대한 정보의 문자열 표현 및 설명 자의 문자열 표현으로 구성됩니다. .</target>
        </trans-unit>
        <trans-unit id="4ab6a7c24f824a223fbd8a3831c0c3e6970b8c12" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfo&lt;/code&gt;), and the name, signature, return open type and impact of the described operation.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfo&lt;/code&gt; )과 이름, 서명, 리턴 열기 유형 및 설명 된 조작의 영향으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="640c583f5e5f932dc18d233947e5f9f45c18d88c" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt;), and the name, signature, return open type and impact of the described operation and the string representation of its descriptor.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanOperationInfoSupport&lt;/code&gt; )과 설명 된 조작의 이름, 서명, 리턴 열기 유형 및 영향 및 설명 자의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="56372f3341ed9c622ba1dff09dfa80ed9847d82f" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfo&lt;/code&gt;), the string representation of the name and open type of the described parameter, and the string representation of its default, min, max and legal values.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.OpenMBeanParameterInfo&lt;/code&gt; ), 설명 된 매개 변수의 이름 및 열린 유형의 문자열 표현 및 기본값, 최소, 최대 및 올바른 값의 문자열 표현으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e847596a7e03c71180c8216bb4f964ac80c8ce4" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.SimpleType&lt;/code&gt;) and the type name for this instance (which is the java class name of the values this &lt;code&gt;SimpleType&lt;/code&gt; instance represents).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.SimpleType&lt;/code&gt; )과이 인스턴스의 유형 이름 (이 &lt;code&gt;SimpleType&lt;/code&gt; 인스턴스가 나타내는 값의 Java 클래스 이름 )으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="cdd41d530879d983b77fc6d88438a6e273a7cdec" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt;), the string representation of the tabular type of this instance, and the string representation of the contents (ie list the key=value mappings as returned by a call to &lt;code&gt;dataMap.&lt;/code&gt;&lt;a href=&quot;../../../../java.base/java/util/abstractmap#toString()&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt; ),이 인스턴스의 표 형식의 문자열 표현, 콘텐츠의 문자열 표현 (예 : &lt;code&gt;dataMap.&lt;/code&gt; 대한 호출 &lt;a href=&quot;../../../../java.base/java/util/abstractmap#toString()&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="574dc6c379e8e51bf167c7fea2d4d1304ca21c2f" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt;), the string representation of the tabular type of this instance, and the string representation of the contents (ie list the key=value mappings as returned by a call to &lt;code&gt;dataMap.&lt;/code&gt;&lt;a href=&quot;../../../java/util/abstractmap#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.TabularDataSupport&lt;/code&gt; ),이 인스턴스의 표 형식 유형의 문자열 표현 및 내용의 문자열 표현으로 구성됩니다 (즉, 키 = 값 매핑을 반환) 를 호출 &lt;code&gt;dataMap.&lt;/code&gt; &lt;a href=&quot;../../../java/util/abstractmap#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="807fbdd5da5244bfb18ce040224682952e87d826" translate="yes" xml:space="preserve">
          <source>The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt;), the type name for this instance, the row type string representation of this instance, and the index names of this instance.</source>
          <target state="translated">문자열 표현은이 클래스의 이름 (예 : &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt; ),이 인스턴스의 유형 이름,이 인스턴스의 행 유형 문자열 표현 및이 인스턴스의 색인 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc5fe65d5ab420dbf5b6b9fae291dad1f8925ed" translate="yes" xml:space="preserve">
          <source>The string representation for this &lt;code&gt;X500Principal&lt;/code&gt; can be obtained by calling the &lt;code&gt;getName&lt;/code&gt; methods.</source>
          <target state="translated">이 &lt;code&gt;X500Principal&lt;/code&gt; 의 캐릭터 라인 표현 은 &lt;code&gt;getName&lt;/code&gt; 메소드 를 호출하는 것으로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfa9c547b94d4a8505b4496d10852764a147d91f" translate="yes" xml:space="preserve">
          <source>The string representation may not have any leading and trailing whitespaces.</source>
          <target state="translated">문자열 표현에는 선행 및 후행 공백이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b612d9c02babd7e1408d7e8d784cf99d9d55260" translate="yes" xml:space="preserve">
          <source>The string representation of the LdapName.</source>
          <target state="translated">LdapName의 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="a420c385cddda341e69db0764ebb091c11a4a7be" translate="yes" xml:space="preserve">
          <source>The string representation of the Rdn.</source>
          <target state="translated">Rdn의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="06141090c2bbeee203d15ec52d1050014ee8d75b" translate="yes" xml:space="preserve">
          <source>The string representation of the attribute.</source>
          <target state="translated">속성의 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="acdd753dd59a9a0afe3c3ebf5bba1d1c8f5326bd" translate="yes" xml:space="preserve">
          <source>The string representation of the attribute. This should exactly match the string specified in the CSS specification.</source>
          <target state="translated">속성의 문자열 표현입니다. 이것은 CSS 사양에 지정된 문자열과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6de482475e09c2eeff30bcc77f9f20ef06b16b86" translate="yes" xml:space="preserve">
          <source>The string representation of this SearchResult. Cannot be null.</source>
          <target state="translated">이 SearchResult의 캐릭터 라인 표현 null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9095c816b4ff2b939ed38e5ec4c8dd104708dcc0" translate="yes" xml:space="preserve">
          <source>The string representation of this Service URL.</source>
          <target state="translated">이 서비스 URL의 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="19b1dc6e3c56c1f7d2c94a2810b048ff86117b35" translate="yes" xml:space="preserve">
          <source>The string representation of this Service URL. If the value returned by this method is supplied to the &lt;code&gt;JMXServiceURL&lt;/code&gt; constructor, the resultant object is equal to this one.</source>
          <target state="translated">이 서비스 URL의 캐릭터 라인 표현 이 메소드에 의해 리턴 된 값이 &lt;code&gt;JMXServiceURL&lt;/code&gt; 생성자에 제공되면 결과 오브젝트는이 오브젝트와 같습니다.</target>
        </trans-unit>
        <trans-unit id="06f159652db61335f5666a5cf825b7a69627ed8c" translate="yes" xml:space="preserve">
          <source>The string representation of this exception consists of information about where the error occurred, and the first unexecuted modification.</source>
          <target state="translated">이 예외의 문자열 표현은 오류가 발생한 위치 및 실행되지 않은 첫 번째 수정 사항에 대한 정보로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="16f1d37b61e149769d5bb45d2d6b123bd696fbda" translate="yes" xml:space="preserve">
          <source>The string representation of this exception consists of information about where the error occurred, and the first unexecuted modification. This string is meant for debugging and not mean to be interpreted programmatically.</source>
          <target state="translated">이 예외의 문자열 표현은 오류가 발생한 위치 및 실행되지 않은 첫 번째 수정에 대한 정보로 구성됩니다. 이 문자열은 디버깅을위한 것이며 프로그래밍 방식으로 해석되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c7de16e9df6affa420db9ce81302405c1dfefd55" translate="yes" xml:space="preserve">
          <source>The string representation of this matcher</source>
          <target state="translated">이 정규 표현 엔진의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="bb74ce786b3d545de3a84f33214617b02d5c2940" translate="yes" xml:space="preserve">
          <source>The string representation of this module</source>
          <target state="translated">이 모듈의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="09eba65afc610d538d65c263d07c4a3212fcfe45" translate="yes" xml:space="preserve">
          <source>The string representation of this name/class pair.</source>
          <target state="translated">이 이름 / 클래스 쌍의 문자열 표현.</target>
        </trans-unit>
        <trans-unit id="053f914091e9887aaa58bf39744d8861af29fc0d" translate="yes" xml:space="preserve">
          <source>The string representation of this pattern</source>
          <target state="translated">이 패턴의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c2acdbf9130b5c1f31215890014846c808d3f0b0" translate="yes" xml:space="preserve">
          <source>The string representation of this scanner</source>
          <target state="translated">이 스캐너의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="f450b24ffb7d9483210505aa1ae5491f8f1973d0" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawAuthority()&quot;&gt;&lt;code&gt;getRawAuthority&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawAuthority()&quot;&gt; &lt;code&gt;getRawAuthority&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="17b139befffb2c60f26b6e3ef4ef71139b888633" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawFragment()&quot;&gt;&lt;code&gt;getRawFragment&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawFragment()&quot;&gt; &lt;code&gt;getRawFragment&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d13f16b94787c0c530d775e02f176898aa8709aa" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawPath()&quot;&gt;&lt;code&gt;getRawPath&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawPath()&quot;&gt; &lt;code&gt;getRawPath&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="49ceecc3a0a7b0c628428ecb824a9a4733fe10bc" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawQuery()&quot;&gt;&lt;code&gt;getRawQuery&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawQuery()&quot;&gt; &lt;code&gt;getRawQuery&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="950adaee23e256f95ac7d75c80da01a153533597" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawSchemeSpecificPart()&quot;&gt;&lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawSchemeSpecificPart()&quot;&gt; &lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="da24186777164723ddd293bab7dd828e99e48a24" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;#getRawUserInfo()&quot;&gt;&lt;code&gt;getRawUserInfo&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메서드에 의해 반환 된 문자열 은 이스케이프 된 8 진수의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코딩&lt;/a&gt; 된다는 점을 제외하고 &lt;a href=&quot;#getRawUserInfo()&quot;&gt; &lt;code&gt;getRawUserInfo&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환 된 문자열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0428783f6a2a4ed333a95d1448a2bc32086c9f46" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawAuthority--&quot;&gt;&lt;code&gt;getRawAuthority&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이러한 방법에 의해 리턴 된 문자열에 의해 리턴 된 것과 동일하다 &lt;a href=&quot;uri#getRawAuthority--&quot;&gt; &lt;code&gt;getRawAuthority&lt;/code&gt; 의&lt;/a&gt; 탈출 옥텟의 모든 서열이된다는 점을 제외하고 방법 &lt;a href=&quot;#decode&quot;&gt;복호&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99f4ef96c814a7c3937663953ec5ac06f173ebb2" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawFragment--&quot;&gt;&lt;code&gt;getRawFragment&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawFragment--&quot;&gt; &lt;code&gt;getRawFragment&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a732cb50bbec78c973952b48ad9babe398c8380c" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawPath--&quot;&gt;&lt;code&gt;getRawPath&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawPath--&quot;&gt; &lt;code&gt;getRawPath&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ddd6a70f437a36a8a334d3aa1a18560bd5c5720e" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawQuery--&quot;&gt;&lt;code&gt;getRawQuery&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawQuery--&quot;&gt; &lt;code&gt;getRawQuery&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bc1a87d2cf19c437c64a305afdb85f728af90351" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawSchemeSpecificPart--&quot;&gt;&lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 &lt;a href=&quot;uri#getRawSchemeSpecificPart--&quot;&gt; &lt;code&gt;getRawSchemeSpecificPart&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4374f3d0ad6e121222206c9e637bf592e8f4f3" translate="yes" xml:space="preserve">
          <source>The string returned by this method is equal to that returned by the &lt;a href=&quot;uri#getRawUserInfo--&quot;&gt;&lt;code&gt;getRawUserInfo&lt;/code&gt;&lt;/a&gt; method except that all sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 캐릭터 라인 은 이스케이프 된 옥텟의 모든 시퀀스가 &lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 되는 것을 제외하고 는 &lt;a href=&quot;uri#getRawUserInfo--&quot;&gt; &lt;code&gt;getRawUserInfo&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 스트링과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="15003a859c5ec3a6cdfdb74230384f43324ebc22" translate="yes" xml:space="preserve">
          <source>The string returned by this method is not a JNDI composite name and should not be passed directly to context methods.</source>
          <target state="translated">이 메소드가 리턴 한 문자열은 JNDI 컴포지트 이름이 아니므로 컨텍스트 메소드에 직접 전달해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="720d46b0678e4b58ffd12635e35e8f669c782484" translate="yes" xml:space="preserve">
          <source>The string returned by this method may differ from the string returned by the &lt;a href=&quot;../../lang/object#toString()&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메서드에서 반환 된 문자열은 &lt;a href=&quot;../../lang/object#toString()&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 문자열과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2d86e2c12a8b526574d8ed3d4f0ad084aa1496f" translate="yes" xml:space="preserve">
          <source>The string returned by this method may differ from the string returned by the &lt;a href=&quot;../../lang/object#toString--&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드가 리턴 한 문자열은 &lt;a href=&quot;../../lang/object#toString--&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 문자열과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edba6dbdeab519bfb2488ac8fa5d24d1d5096a05" translate="yes" xml:space="preserve">
          <source>The string returned is made of the text content of this node depending on its type, as defined below:</source>
          <target state="translated">반환 된 문자열은 아래 정의 된대로 유형에 따라이 노드의 텍스트 콘텐츠로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a98b16691a6548a5f40d785a69cfe7819a08aa9f" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. At least one of the four sections must be present. The sections have suffixes in ASCII of &quot;Y&quot;, &quot;M&quot;, &quot;W&quot; and &quot;D&quot; for years, months, weeks and days, accepted in upper or lower case. The suffixes must occur in order. The number part of each section must consist of ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number must parse to an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">문자열은 ASCII 음수 또는 양수 기호로 표시되는 선택적 기호로 시작합니다. 음수이면 전체 기간이 무시됩니다. ASCII 문자 &quot;P&quot;는 다음에 대문자 또는 소문자입니다. 그런 다음 네 개의 섹션이 있으며 각 섹션에는 숫자와 접미사가 있습니다. 네 섹션 중 하나 이상이 있어야합니다. 이 섹션에는 ASCII의 &quot;Y&quot;, &quot;M&quot;, &quot;W&quot;및 &quot;D&quot;접미사가 있습니다. 대문자, 소문자로 허용됩니다. 접미사는 순서대로 발생해야합니다. 각 섹션의 숫자 부분은 ASCII 숫자로 구성되어야합니다. 숫자 앞에 ASCII 음수 또는 양수 기호를 붙일 수 있습니다. 숫자는 &lt;code&gt;int&lt;/code&gt; 로 구문 분석해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d0a3cf68706224b4e1564938792fbbb36cb2a5f2" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before the first occurrence, if any, of an hour, minute or second section. At least one of the four sections must be present, and if &quot;T&quot; is present there must be at least one section after the &quot;T&quot;. The number part of each section must consist of one or more ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number of days, hours and minutes must parse to a &lt;code&gt;long&lt;/code&gt;. The number of seconds must parse to a &lt;code&gt;long&lt;/code&gt; with optional fraction. The decimal point may be either a dot or a comma. The fractional part may have from zero to 9 digits.</source>
          <target state="translated">문자열은 ASCII 음수 또는 양수 기호로 표시되는 선택적 기호로 시작합니다. 음수이면 전체 기간이 부정됩니다. ASCII 문자 &quot;P&quot;는 다음 대문자 또는 소문자입니다. 그런 다음 각각 숫자와 접미사로 구성된 네 개의 섹션이 있습니다. 섹션에는 &quot;D&quot;, &quot;H&quot;, &quot;M&quot;및 &quot;S&quot;라는 ASCII 접미사가 있으며 대문자 또는 소문자로 허용됩니다. 접미사는 순서대로 표시되어야합니다. ASCII 문자 &quot;T&quot;는 시간, 분 또는 두 번째 섹션의 첫 번째 발생 (있는 경우) 앞에 와야합니다. 4 개 섹션 중 하나 이상이 있어야하며 &quot;T&quot;가있는 경우 &quot;T&quot;뒤에 하나 이상의 섹션이 있어야합니다. 각 섹션의 숫자 부분은 하나 이상의 ASCII 숫자로 구성되어야합니다.숫자 앞에는 ASCII 음수 또는 양수 기호가 붙을 수 있습니다. 일, 시간 및 분 수는 &lt;code&gt;long&lt;/code&gt; . 초 수는 선택적 분수 를 사용하여 &lt;code&gt;long&lt;/code&gt; 으로 구문 분석해야합니다 . 소수점은 점 또는 쉼표 일 수 있습니다. 소수 부분은 0에서 9 자리까지 가능합니다.</target>
        </trans-unit>
        <trans-unit id="89a747d82990c6aea3987f68f6f2f3b3b15c1eff" translate="yes" xml:space="preserve">
          <source>The string starts with an optional sign, denoted by the ASCII negative or positive symbol. If negative, the whole period is negated. The ASCII letter &quot;P&quot; is next in upper or lower case. There are then four sections, each consisting of a number and a suffix. The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for days, hours, minutes and seconds, accepted in upper or lower case. The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before the first occurrence, if any, of an hour, minute or second section. At least one of the four sections must be present, and if &quot;T&quot; is present there must be at least one section after the &quot;T&quot;. The number part of each section must consist of one or more ASCII digits. The number may be prefixed by the ASCII negative or positive symbol. The number of days, hours and minutes must parse to an &lt;code&gt;long&lt;/code&gt;. The number of seconds must parse to an &lt;code&gt;long&lt;/code&gt; with optional fraction. The decimal point may be either a dot or a comma. The fractional part may have from zero to 9 digits.</source>
          <target state="translated">문자열은 ASCII 음수 또는 양수 기호로 표시되는 선택적 기호로 시작합니다. 음수이면 전체 기간이 무시됩니다. ASCII 문자 &quot;P&quot;는 다음에 대문자 또는 소문자입니다. 그런 다음 네 개의 섹션이 있으며 각 섹션에는 숫자와 접미사가 있습니다. 이 섹션에는 ASCII로 &quot;D&quot;, &quot;H&quot;, &quot;M&quot;및 &quot;S&quot;의 접미사가 있으며 소문자, 대문자, 소문자로 허용됩니다. 접미사는 순서대로 발생해야합니다. ASCII 문자 &quot;T&quot;는 첫 번째 항목 (있는 경우), 1 분, 2 분 또는 2 초 전에 발생해야합니다. 네 개의 섹션 중 하나 이상이 있어야하며 &quot;T&quot;가 있으면 &quot;T&quot;뒤에 하나 이상의 섹션이 있어야합니다. 각 섹션의 숫자 부분은 하나 이상의 ASCII 숫자로 구성되어야합니다.숫자 앞에 ASCII 음수 또는 양수 기호를 붙일 수 있습니다. 일, 시간 및 분의 수는 &lt;code&gt;long&lt;/code&gt; . 초는 선택적 분수 를 사용하여 &lt;code&gt;long&lt;/code&gt; 으로 구문 분석해야합니다 . 소수점은 점 또는 쉼표 일 수 있습니다. 소수 부분은 0-9 자리입니다.</target>
        </trans-unit>
        <trans-unit id="4685a9bbdb9380ea8c94c58ff588b3c8fbe09edf" translate="yes" xml:space="preserve">
          <source>The string that appears after a negative number (may be empty),</source>
          <target state="translated">음수 뒤에 나오는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="121fd276daa28030f6a820cb1573874d3a75d6c9" translate="yes" xml:space="preserve">
          <source>The string that appears after a positive number (may be empty),</source>
          <target state="translated">양수 뒤에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="5bdb1009de16112ed78878cf54efa430f792f9b9" translate="yes" xml:space="preserve">
          <source>The string that appears before a negative number (may be empty),</source>
          <target state="translated">음수 앞에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="ca10167dd9b711a6fe69878b203a07e7493844d5" translate="yes" xml:space="preserve">
          <source>The string that appears before a positive number (may be empty),</source>
          <target state="translated">양수 앞에 나타나는 문자열 (비어있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="1230518d13d5910243029a9e67f1cba26841e687" translate="yes" xml:space="preserve">
          <source>The string that represents infinity for floating-point values,</source>
          <target state="translated">부동 소수점 값의 무한대를 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="0ef60f4fe5623badec9511506d8c3e9aab99fce8" translate="yes" xml:space="preserve">
          <source>The string that represents not-a-number for floating-point values,</source>
          <target state="translated">부동 소수점 값의 숫자가 아님을 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="a78a098297ed979ec8fd87a13cc391ae93c8972a" translate="yes" xml:space="preserve">
          <source>The string tokenizer class allows an application to break a string into tokens.</source>
          <target state="translated">문자열 토크 나이저 클래스는 애플리케이션이 문자열을 토큰으로 나눌 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="04fb2cffb71f257048052d20b8fe56a4f66e790f" translate="yes" xml:space="preserve">
          <source>The string tokenizer class allows an application to break a string into tokens. The tokenization method is much simpler than the one used by the &lt;code&gt;StreamTokenizer&lt;/code&gt; class. The &lt;code&gt;StringTokenizer&lt;/code&gt; methods do not distinguish among identifiers, numbers, and quoted strings, nor do they recognize and skip comments.</source>
          <target state="translated">문자열 토크 나이저 클래스를 사용하면 응용 프로그램에서 문자열을 토큰으로 나눌 수 있습니다. 토큰 화 방법은 &lt;code&gt;StreamTokenizer&lt;/code&gt; 클래스에서 사용하는 방법보다 훨씬 간단합니다 . &lt;code&gt;StringTokenizer&lt;/code&gt; 방법은 식별자, 숫자, 인용 된 문자열을 구분 없으며 인식하고 설명을 생략하지 않는다.</target>
        </trans-unit>
        <trans-unit id="53fa55c105fb0b4c765bc0d34087bf552da7b9c4" translate="yes" xml:space="preserve">
          <source>The string used to display the String in the syntax of the scripting language.</source>
          <target state="translated">스크립트 언어의 구문으로 문자열을 표시하는 데 사용되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="045b2391e6e713813d68e301a750110f4ff3677c" translate="yes" xml:space="preserve">
          <source>The string value in the current unit. The current &lt;code&gt;primitiveType&lt;/code&gt; can only be a string unit type (i.e. &lt;code&gt;CSS_STRING&lt;/code&gt;, &lt;code&gt;CSS_URI&lt;/code&gt;, &lt;code&gt;CSS_IDENT&lt;/code&gt; and &lt;code&gt;CSS_ATTR&lt;/code&gt;).</source>
          <target state="translated">현재 단위의 문자열 값입니다. 현재 &lt;code&gt;primitiveType&lt;/code&gt; 은 문자열 단위 유형 (예 : &lt;code&gt;CSS_STRING&lt;/code&gt; , &lt;code&gt;CSS_URI&lt;/code&gt; , &lt;code&gt;CSS_IDENT&lt;/code&gt; 및 &lt;code&gt;CSS_ATTR&lt;/code&gt; ) 만 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c78459f86d1f255e120d7d995d1329b245c41ee8" translate="yes" xml:space="preserve">
          <source>The string value of the output property, or null if no property was found.</source>
          <target state="translated">출력 속성의 문자열 값 또는 속성이 없으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="6b860b97ae2648994958ff5f145b7575c2d21991" translate="yes" xml:space="preserve">
          <source>The string value.</source>
          <target state="translated">문자열 값</target>
        </trans-unit>
        <trans-unit id="f11c947d653626328bad48f1c4cdf9159acc0a3b" translate="yes" xml:space="preserve">
          <source>The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).</source>
          <target state="translated">이 클래스의 인스턴스에서 숫자로 구문 분석 할 수있는 문자열은 다음 정규식 문법으로 지정됩니다. 여기서 Rmax는 사용되는 기수에서 가장 높은 자릿수입니다 (예 : 밑 10의 경우 Rmax는 9).</target>
        </trans-unit>
        <trans-unit id="192956733edd06bdd0c654a6ba995e1bcee04c0f" translate="yes" xml:space="preserve">
          <source>The structure and contents of the &quot;native&quot; metadata format are defined by the plug-in that created this &lt;code&gt;IIOMetadata&lt;/code&gt; object. Plug-ins for simple formats will usually create a dummy node for the root, and then a series of child nodes representing individual tags, chunks, or keyword/value pairs. A plug-in may choose whether or not to document its native format.</source>
          <target state="translated">&quot;네이티브&quot;메타 데이터 형식의 구조와 내용은이 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체 를 생성 한 플러그인에 의해 정의됩니다 . 간단한 형식의 플러그인은 일반적으로 루트에 대한 더미 노드를 만든 다음 개별 태그, 청크 또는 키워드 / 값 쌍을 나타내는 일련의 자식 노드를 만듭니다. 플러그인은 고유 형식을 문서화할지 여부를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d00af5b5c0dfb3866ccfa55c912f873c782dbff" translate="yes" xml:space="preserve">
          <source>The structure and encoding of Oids is defined in ISOIEC-8824 and ISOIEC-8825. For example the Oid representation of Kerberos V5 mechanism is &quot;1.2.840.113554.1.2.2&quot;</source>
          <target state="translated">Oid의 구조와 인코딩은 ISOIEC-8824 및 ISOIEC-8825에 정의되어 있습니다. 예를 들어 Kerberos V5 메커니즘의 Oid 표현은 &quot;1.2.840.113554.1.2.2&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="cb2c5dc909eef768d7f9cd7e34bb554bcaaaebaa" translate="yes" xml:space="preserve">
          <source>The structure is a return type accompanied by any number of parameter types. The types (primitive, &lt;code&gt;void&lt;/code&gt;, and reference) are represented by &lt;a href=&quot;../class&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt; objects. (For ease of exposition, we treat &lt;code&gt;void&lt;/code&gt; as if it were a type. In fact, it denotes the absence of a return type.)</source>
          <target state="translated">구조는 여러 매개 변수 유형과 함께 리턴 유형입니다. 유형 (primitive, &lt;code&gt;void&lt;/code&gt; 및 reference)은 &lt;a href=&quot;../class&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; 객체 로 표시됩니다 . (노출을 쉽게하기 위해 &lt;code&gt;void&lt;/code&gt; 를 타입처럼 취급 합니다. 실제로는 리턴 타입이 없음을 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="fdfbb9e2e84d666d2a855ee7c1631508d148c17f" translate="yes" xml:space="preserve">
          <source>The structures that may be described by this class are a subset of those expressible using XML document type definitions (DTDs), with the addition of some basic information on the datatypes of attributes and the ability to store an &lt;code&gt;Object&lt;/code&gt; reference within a node. In the future, XML Schemas could be used to represent these structures, and many others.</source>
          <target state="translated">이 클래스에서 설명 할 수있는 구조는 속성의 데이터 유형에 대한 몇 가지 기본 정보와 노드 내에 &lt;code&gt;Object&lt;/code&gt; 참조 를 저장하는 기능과 함께 XML 문서 유형 정의 (DTD)를 사용하여 표현할 수있는 구조의 서브 세트입니다 . 미래에는 XML 스키마를 사용하여 이러한 구조 및 기타 여러 구조를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1300b7e4fbbe647c420f08d4ea464e607a0b93" translate="yes" xml:space="preserve">
          <source>The stub class is loaded by name using the class loader of the root class. The stub class must be public, it must extend &lt;a href=&quot;remotestub&quot;&gt;&lt;code&gt;RemoteStub&lt;/code&gt;&lt;/a&gt;, it must reside in a package that is exported to at least the &lt;code&gt;java.rmi&lt;/code&gt; module, and it must have a public constructor that has one parameter of type &lt;a href=&quot;remoteref&quot;&gt;&lt;code&gt;RemoteRef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스텁 클래스는 루트 클래스의 클래스 로더를 사용하여 이름별로로드됩니다. 스텁 클래스는 공용 이어야하고 &lt;a href=&quot;remotestub&quot;&gt; &lt;code&gt;RemoteStub&lt;/code&gt; 을&lt;/a&gt; 확장 해야하며 최소한 &lt;code&gt;java.rmi&lt;/code&gt; 모듈로 내 보내진 패키지에 있어야하며 &lt;a href=&quot;remoteref&quot;&gt; &lt;code&gt;RemoteRef&lt;/code&gt; &lt;/a&gt; 유형의 매개 변수가 하나있는 공용 생성자를 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="a232a3677fbba52c761d261392a47c4a403e95f0" translate="yes" xml:space="preserve">
          <source>The stub might not yet be connected to the ORB. The stub will be serializable only if it is connected to the ORB.</source>
          <target state="translated">스텁이 아직 ORB에 연결되지 않았을 수 있습니다. 스텁은 ORB에 연결된 경우에만 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7a3dc219e67d57ff39f5f91a47d644371a7f81d7" translate="yes" xml:space="preserve">
          <source>The style attribute.</source>
          <target state="translated">스타일 속성입니다.</target>
        </trans-unit>
        <trans-unit id="7ed2b6144ace5c60a1401e5428a1fc3686ffe408" translate="yes" xml:space="preserve">
          <source>The style of this &lt;code&gt;Font&lt;/code&gt;, as passed to the constructor.</source>
          <target state="translated">생성자에 전달 된 이 &lt;code&gt;Font&lt;/code&gt; 스타일입니다 .</target>
        </trans-unit>
        <trans-unit id="498a3c78ad0c0604083f3769f1ef9e8b0c526e13" translate="yes" xml:space="preserve">
          <source>The style of this &lt;code&gt;Font&lt;/code&gt;, as passed to the constructor. This style can be PLAIN, BOLD, ITALIC, or BOLD+ITALIC.</source>
          <target state="translated">생성자에 전달 된 이 &lt;code&gt;Font&lt;/code&gt; 스타일입니다 . 이 스타일은 PLAIN, BOLD, ITALIC 또는 BOLD + ITALIC 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b5b369b33d039728a33986fe140d97ea7763679" translate="yes" xml:space="preserve">
          <source>The style rule at the &lt;code&gt;index&lt;/code&gt; position in the &lt;code&gt;CSSRuleList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">&lt;code&gt;CSSRuleList&lt;/code&gt; 의 &lt;code&gt;index&lt;/code&gt; 위치에있는 스타일 규칙 또는 유효한 인덱스가 아닌 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bbf88eb588be0aeabba5debf950c788477d4b197" translate="yes" xml:space="preserve">
          <source>The style sheet at the &lt;code&gt;index&lt;/code&gt; position in the &lt;code&gt;StyleSheetList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">&lt;code&gt;StyleSheetList&lt;/code&gt; 의 &lt;code&gt;index&lt;/code&gt; 위치에있는 스타일 시트 또는 유효한 인덱스가 아닌 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8c8a67944fd96db1f04f842832d7d391bf84eef" translate="yes" xml:space="preserve">
          <source>The style sheet referred to by this rule, if it has been loaded.</source>
          <target state="translated">로드 된 경우이 규칙에서 참조하는 스타일 시트입니다.</target>
        </trans-unit>
        <trans-unit id="4acffc6c2b340e9ca17170b9fd8575da7b38779f" translate="yes" xml:space="preserve">
          <source>The style sheet referred to by this rule, if it has been loaded. The value of this attribute is &lt;code&gt;null&lt;/code&gt; if the style sheet has not yet been loaded or if it will not be loaded (e.g. if the style sheet is for a media type not supported by the user agent).</source>
          <target state="translated">로드 된 경우이 규칙에서 참조하는 스타일 시트입니다. 스타일 시트가 아직로드되지 않았거나로드되지 않을 경우 (예 : 스타일 시트가 사용자 에이전트에서 지원하지 않는 미디어 유형 &lt;code&gt;null&lt;/code&gt; 경우) 이 속성의 값은 null 입니다.</target>
        </trans-unit>
        <trans-unit id="2f92ba7a8105c55f452b0e9e30526dc55ff36366" translate="yes" xml:space="preserve">
          <source>The style sheet that contains this rule.</source>
          <target state="translated">이 규칙이 포함 된 스타일 시트입니다.</target>
        </trans-unit>
        <trans-unit id="d9f53855d9d4fc11da63155553b0c59e74844f7d" translate="yes" xml:space="preserve">
          <source>The style sheet.</source>
          <target state="translated">스타일 시트.</target>
        </trans-unit>
        <trans-unit id="aff2ab664c61a826342f48467d919591b7be5528" translate="yes" xml:space="preserve">
          <source>The sub-range is defined to be out of bounds if any of the following inequalities is true:</source>
          <target state="translated">다음 부등식 중 하나라도 참인 경우 하위 범위는 범위를 벗어난 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e5c879c6bdae17e077ece202d05c591a659999bb" translate="yes" xml:space="preserve">
          <source>The subclass may supply a different base name for the resource bundles using the &lt;code&gt;setResourceBaseName&lt;/code&gt; method.</source>
          <target state="translated">서브 클래스는 &lt;code&gt;setResourceBaseName&lt;/code&gt; 메소드를 사용하여 자원 번들에 다른 기본 이름을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="527c0a0960cc0fe34b4ce860e5a1c2222c46e968" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; for the SQLState class value '</source>
          <target state="translated">SQLState 클래스 값 '에 대한 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 서브 클래스</target>
        </trans-unit>
        <trans-unit id="7713c2f78de0d5ff78645f34f1aa9c89839a8b5a" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown in situations where a previously failed operation might be able to succeed when the operation is retried without any intervention by application-level functionality.</source>
          <target state="translated">&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 서브 클래스는 이전에 실패한 조작이 애플리케이션 레벨 기능의 개입없이 조작이 재 시도 될 때 성공할 수있는 상황에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80f483f7072263836c5107593eb17db254d36bf4" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown when one or more client info properties could not be set on a &lt;code&gt;Connection&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스는 하나 이상의 클라이언트 정보 속성을 &lt;code&gt;Connection&lt;/code&gt; 에서 설정할 수 없을 때 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="7b3fc8fd4fb26a88d9f95ef4851700e0411e08a2" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; is thrown when one or more client info properties could not be set on a &lt;code&gt;Connection&lt;/code&gt;. In addition to the information provided by &lt;code&gt;SQLException&lt;/code&gt;, a &lt;code&gt;SQLClientInfoException&lt;/code&gt; provides a list of client info properties that were not set. Some databases do not allow multiple client info properties to be set atomically. For those databases, it is possible that some of the client info properties had been set even though the &lt;code&gt;Connection.setClientInfo&lt;/code&gt; method threw an exception. An application can use the &lt;code&gt;getFailedProperties &lt;/code&gt; method to retrieve a list of client info properties that were not set. The properties are identified by passing a &lt;code&gt;Map&amp;lt;String,ClientInfoStatus&amp;gt;&lt;/code&gt; to the appropriate &lt;code&gt;SQLClientInfoException&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스는 하나 이상의 클라이언트 정보 속성을 &lt;code&gt;Connection&lt;/code&gt; 에서 설정할 수 없을 때 발생 합니다 . &lt;code&gt;SQLException&lt;/code&gt; 에서 제공하는 정보 외에도 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 은 설정되지 않은 클라이언트 정보 속성 목록을 제공합니다. 일부 데이터베이스에서는 여러 클라이언트 정보 속성을 원자 적으로 설정할 수 없습니다. 이러한 데이터베이스의 경우 &lt;code&gt;Connection.setClientInfo&lt;/code&gt; 메서드에서 예외가 발생 했음에도 불구하고 클라이언트 정보 속성 중 일부가 설정되었을 수 있습니다. 애플리케이션은 &lt;code&gt;getFailedProperties &lt;/code&gt; 메소드를 사용하여 설정되지 않은 클라이언트 정보 특성 목록을 검색 할 수 있습니다 . 속성은 &lt;code&gt;Map&amp;lt;String,ClientInfoStatus&amp;gt;&lt;/code&gt; 를 적절한 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 생성자에 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="6717effbf2eae66083ee44deed5d8b60c5c6fe2d" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown for the SQLState class value '</source>
          <target state="translated">SQLState 클래스 값 '에 대해 throw 된 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스</target>
        </trans-unit>
        <trans-unit id="8607beac95f1d4cb0f607da7d63685d6dfbf8d4c" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown in situations where a previously failed operation might be able to succeed if the application performs some recovery steps and retries the entire transaction or in the case of a distributed transaction, the transaction branch.</source>
          <target state="translated">애플리케이션이 일부 복구 단계를 수행하고 전체 트랜잭션을 재 시도하는 경우 이전에 실패한 작업이 성공할 수있는 상황에서 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 또는 분산 트랜잭션의 경우 트랜잭션 분기입니다.</target>
        </trans-unit>
        <trans-unit id="bbb8274ee2db6a0201b391b30cdfd8adbecfb841" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown in situations where a previously failed operation might be able to succeed if the application performs some recovery steps and retries the entire transaction or in the case of a distributed transaction, the transaction branch. At a minimum, the recovery operation must include closing the current connection and getting a new connection.</source>
          <target state="translated">애플리케이션이 일부 복구 단계를 수행하고 전체 트랜잭션을 재 시도하는 경우 이전에 실패한 작업이 성공할 수있는 상황에서 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 또는 분산 트랜잭션의 경우 트랜잭션 분기입니다. 최소한 복구 작업에는 현재 연결 닫기 및 새 연결 가져 오기가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a54587a45ff8b2645e125fd0b8ffb8307a8ef66b" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an error occurs during a batch update operation.</source>
          <target state="translated">일괄 업데이트 작업 중에 오류가 발생할 때 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="803499fb5061ae4d61cec028a03de443ffd7786f" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an error occurs during a batch update operation. In addition to the information provided by &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;BatchUpdateException&lt;/code&gt; provides the update counts for all commands that were executed successfully during the batch update, that is, all commands that were executed before the error occurred. The order of elements in an array of update counts corresponds to the order in which commands were added to the batch.</source>
          <target state="translated">일괄 업데이트 작업 중에 오류가 발생할 때 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 에서 제공하는 정보 외에도 &lt;code&gt;BatchUpdateException&lt;/code&gt; 은 일괄 업데이트 중에 성공적으로 실행 된 모든 명령, 즉 오류가 발생하기 전에 실행 된 모든 명령에 대한 업데이트 횟수를 제공합니다. 업데이트 수 배열의 요소 순서는 명령이 배치에 추가 된 순서에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="72d539ca6fdd4b7c88bd110f4dcd389de1ff790c" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when an instance where a retry of the same operation would fail unless the cause of the &lt;code&gt;SQLException&lt;/code&gt; is corrected.</source>
          <target state="translated">의 서브 클래스 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 원인 않는 한, 같은 조작을 재 시행해도 인스턴스가 실패 할 경우에 throw &lt;code&gt;SQLException&lt;/code&gt; 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="040505f7787304a32e3c75ae93a27084235243c1" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when the SQLState class value is '</source>
          <target state="translated">SQLState 클래스 값이 '인 경우 throw되는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스</target>
        </trans-unit>
        <trans-unit id="ccf2e655300c92dbbb85b4f642a0803f74b73233" translate="yes" xml:space="preserve">
          <source>The subclass of &lt;a href=&quot;sqlexception&quot;&gt;&lt;code&gt;SQLException&lt;/code&gt;&lt;/a&gt; thrown when the timeout specified by &lt;code&gt;Statement.setQueryTimeout&lt;/code&gt;, &lt;code&gt;DriverManager.setLoginTimeout&lt;/code&gt;, &lt;code&gt;DataSource.setLoginTimeout&lt;/code&gt;,&lt;code&gt;XADataSource.setLoginTimeout&lt;/code&gt; has expired.</source>
          <target state="translated">&lt;code&gt;Statement.setQueryTimeout&lt;/code&gt; , &lt;code&gt;DriverManager.setLoginTimeout&lt;/code&gt; , &lt;code&gt;DataSource.setLoginTimeout&lt;/code&gt; , &lt;code&gt;XADataSource.setLoginTimeout&lt;/code&gt; 에 의해 지정된 제한 시간 이 만료 되었을 때 발생 하는 &lt;a href=&quot;sqlexception&quot;&gt; &lt;code&gt;SQLException&lt;/code&gt; &lt;/a&gt; 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="62072bc327b8cecfe4f10440c7fba64d72ceae2d" translate="yes" xml:space="preserve">
          <source>The subclass returned depends on the value of &lt;a href=&quot;#isParseBigDecimal()&quot;&gt;&lt;code&gt;isParseBigDecimal()&lt;/code&gt;&lt;/a&gt; as well as on the string being parsed.</source>
          <target state="translated">반환되는 하위 클래스는 &lt;a href=&quot;#isParseBigDecimal()&quot;&gt; &lt;code&gt;isParseBigDecimal()&lt;/code&gt; &lt;/a&gt; 의 값과 구문 분석되는 문자열에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="bac1d40c541f2bc78282b5fcf04be8326df2e993" translate="yes" xml:space="preserve">
          <source>The subclass returned depends on the value of &lt;a href=&quot;decimalformat#isParseBigDecimal--&quot;&gt;&lt;code&gt;isParseBigDecimal()&lt;/code&gt;&lt;/a&gt; as well as on the string being parsed.</source>
          <target state="translated">리턴되는 서브 클래스는 &lt;a href=&quot;decimalformat#isParseBigDecimal--&quot;&gt; &lt;code&gt;isParseBigDecimal()&lt;/code&gt; &lt;/a&gt; 의 값과 구문 분석되는 문자열에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b79749f58cf1bfcecb1d563bcce417c79a3f48ee" translate="yes" xml:space="preserve">
          <source>The subclass's &lt;code&gt;set(int, E)&lt;/code&gt;, &lt;code&gt;get(int)&lt;/code&gt;, &lt;code&gt;add(int, E)&lt;/code&gt;, &lt;code&gt;remove(int)&lt;/code&gt;, &lt;code&gt;addAll(int,
 Collection)&lt;/code&gt; and &lt;code&gt;removeRange(int, int)&lt;/code&gt; methods all delegate to the corresponding methods on the backing abstract list, after bounds-checking the index and adjusting for the offset. The &lt;code&gt;addAll(Collection c)&lt;/code&gt; method merely returns &lt;code&gt;addAll(size,
 c)&lt;/code&gt;.</source>
          <target state="translated">서브 클래스의 &lt;code&gt;set(int, E)&lt;/code&gt; , &lt;code&gt;get(int)&lt;/code&gt; , &lt;code&gt;add(int, E)&lt;/code&gt; , &lt;code&gt;remove(int)&lt;/code&gt; , &lt;code&gt;addAll(int, Collection)&lt;/code&gt; 및 &lt;code&gt;removeRange(int, int)&lt;/code&gt; 메소드는 모두 기본 초록의 해당 메소드에 위임됩니다. 인덱스의 경계를 확인하고 오프셋을 조정 한 후 목록. &lt;code&gt;addAll(Collection c)&lt;/code&gt; 방법은 단순히 반환 &lt;code&gt;addAll(size, c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="729c3d64219547cb810998bd0f169dacbb67b1a4" translate="yes" xml:space="preserve">
          <source>The subclasses of &lt;code&gt;LayerUI&lt;/code&gt; can either be stateless and shareable by multiple &lt;code&gt;JLayer&lt;/code&gt;s or not shareable.</source>
          <target state="translated">&lt;code&gt;LayerUI&lt;/code&gt; 의 하위 클래스는 상태 비 저장이고 여러 &lt;code&gt;JLayer&lt;/code&gt; 에서 공유 할 수 있거나 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="41754262853cd8dda8e7145fb4fe6436a4d4ac99" translate="yes" xml:space="preserve">
          <source>The subprocess is not killed when there are no more references to the &lt;code&gt;Process&lt;/code&gt; object, but rather the subprocess continues executing asynchronously.</source>
          <target state="translated">&lt;code&gt;Process&lt;/code&gt; 오브젝트에 대한 참조가 더 이상 없을 때 서브 프로세스가 종료되지 않고 서브 프로세스가 비동기 적으로 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7c7df4f8cdb60df8a1704c9b01b240279889a753" translate="yes" xml:space="preserve">
          <source>The subscriber returned by this handler is not flow controlled. Therefore, the supplied consumer must be able to process whatever amount of data is delivered in a timely fashion.</source>
          <target state="translated">이 처리기에 의해 반환 된 구독자는 흐름이 제어되지 않습니다. 따라서 공급 된 소비자는 제공되는 데이터 양에 관계없이 적시에 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="24df0de55c6e5cbab8a446a4d7da62cab861430c" translate="yes" xml:space="preserve">
          <source>The subsequence of the argument &lt;code&gt;s&lt;/code&gt; specified by &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are inserted, in order, into this sequence at the specified destination offset, moving up any characters originally above that position. The length of this sequence is increased by &lt;code&gt;end - start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 로 지정된 인수 &lt;code&gt;s&lt;/code&gt; 하위 시퀀스는 지정된 대상 오프셋에서이 시퀀스에 순서대로 삽입되어 원래 해당 위치 위에있는 문자를 위로 이동합니다. 이 시퀀스의 길이는 &lt;code&gt;end - start&lt;/code&gt; 증가 합니다 .</target>
        </trans-unit>
        <trans-unit id="98347390f1f0edc351744b3bec1803d66b95c900" translate="yes" xml:space="preserve">
          <source>The subtract filter operation.</source>
          <target state="translated">빼기 필터 연산입니다.</target>
        </trans-unit>
        <trans-unit id="fa32b35464f9186e85feb28d5c8d747a2ca57b4f" translate="yes" xml:space="preserve">
          <source>The subtypes of &lt;a href=&quot;constantdesc&quot;&gt;&lt;code&gt;ConstantDesc&lt;/code&gt;&lt;/a&gt; describe various kinds of constant values. For each type of loadable constant pool entry defined in JVMS 4.4, there is a corresponding subtype of &lt;a href=&quot;constantdesc&quot;&gt;&lt;code&gt;ConstantDesc&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;classdesc&quot;&gt;&lt;code&gt;ClassDesc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methodtypedesc&quot;&gt;&lt;code&gt;MethodTypeDesc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;directmethodhandledesc&quot;&gt;&lt;code&gt;DirectMethodHandleDesc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../long&quot;&gt;&lt;code&gt;Long&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../float&quot;&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../double&quot;&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;dynamicconstantdesc&quot;&gt;&lt;code&gt;DynamicConstantDesc&lt;/code&gt;&lt;/a&gt;. These classes provide type-specific accessor methods to extract the nominal information for that kind of constant. When a bytecode-writing API encounters a &lt;a href=&quot;constantdesc&quot;&gt;&lt;code&gt;ConstantDesc&lt;/code&gt;&lt;/a&gt;, it should examine it to see which of these types it is, cast it, extract its nominal information, and generate the corresponding entry to the constant pool. When a bytecode-reading API encounters a constant pool entry, it can convert it to the appropriate type of nominal descriptor. For dynamic constants, bytecode-reading APIs may wish to use the factory &lt;a href=&quot;dynamicconstantdesc#ofCanonical(java.lang.constant.DirectMethodHandleDesc,java.lang.String,java.lang.constant.ClassDesc,java.lang.constant.ConstantDesc%5B%5D)&quot;&gt;&lt;code&gt;DynamicConstantDesc.ofCanonical&lt;/code&gt;&lt;/a&gt;, which will inspect the bootstrap and, for well-known bootstraps, return a more specific subtype of &lt;a href=&quot;dynamicconstantdesc&quot;&gt;&lt;code&gt;DynamicConstantDesc&lt;/code&gt;&lt;/a&gt;, such as &lt;a href=&quot;../enum.enumdesc&quot;&gt;&lt;code&gt;Enum.EnumDesc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;constantdesc&quot;&gt; &lt;code&gt;ConstantDesc&lt;/code&gt; &lt;/a&gt; 의 하위 유형은 다양한 종류의 상수 값을 설명합니다. JVMS 4.4에 정의 된로드 가능한 상수 풀 항목의 각 유형의 해당 하위 유형이 &lt;a href=&quot;constantdesc&quot;&gt; &lt;code&gt;ConstantDesc&lt;/code&gt; &lt;/a&gt; : &lt;a href=&quot;classdesc&quot;&gt; &lt;code&gt;ClassDesc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methodtypedesc&quot;&gt; &lt;code&gt;MethodTypeDesc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;directmethodhandledesc&quot;&gt; &lt;code&gt;DirectMethodHandleDesc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../long&quot;&gt; &lt;code&gt;Long&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../float&quot;&gt; &lt;code&gt;Float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../double&quot;&gt; &lt;code&gt;Double&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;a href=&quot;dynamicconstantdesc&quot;&gt; &lt;code&gt;DynamicConstantDesc&lt;/code&gt; &lt;/a&gt; . 이러한 클래스는 유형별 접근 자 메서드를 제공하여 해당 종류의 상수에 대한 명목 정보를 추출합니다. 바이트 코드 작성 API가 &lt;a href=&quot;constantdesc&quot;&gt; &lt;code&gt;ConstantDesc&lt;/code&gt; 를&lt;/a&gt; 만났을 때, 어떤 유형인지 확인하고, 캐스트하고, 명목 정보를 추출하고, 상수 풀에 대한 해당 항목을 생성하기 위해이를 조사해야합니다. 바이트 코드 읽기 API가 상수 풀 항목을 발견하면 적절한 유형의 명목 설명 자로 변환 할 수 있습니다. 동적 상수의 경우 바이트 코드 읽기 API는 부트 스트랩을 검사하고 잘 알려진 부트 스트랩의 경우 &lt;a href=&quot;../enum.enumdesc&quot;&gt; &lt;code&gt;Enum.EnumDesc&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;a href=&quot;dynamicconstantdesc&quot;&gt; &lt;code&gt;DynamicConstantDesc&lt;/code&gt; &lt;/a&gt; 의보다 구체적인 하위 유형을 반환하는 공장 &lt;a href=&quot;dynamicconstantdesc#ofCanonical(java.lang.constant.DirectMethodHandleDesc,java.lang.String,java.lang.constant.ClassDesc,java.lang.constant.ConstantDesc%5B%5D)&quot;&gt; &lt;code&gt;DynamicConstantDesc.ofCanonical&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb649597713d07a6a3f68ef4b622114bd9bb42f" translate="yes" xml:space="preserve">
          <source>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a &lt;code&gt;NaN&lt;/code&gt; or the sum is at any point a &lt;code&gt;NaN&lt;/code&gt; then the sum will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">반환되는 합계는 크기가 다른 값의 누적 반올림 오차로 인해 값이 기록되는 순서에 따라 달라질 수 있습니다. 절대 크기를 늘리면 정렬 된 값이 더 정확한 결과를 얻는 경향이 있습니다. 기록 된 값이 &lt;code&gt;NaN&lt;/code&gt; 이거나 합계가 &lt;code&gt;NaN&lt;/code&gt; 이면 합계는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5b109e54c81cacf004fb931535e7f7c5e9a6ad4" translate="yes" xml:space="preserve">
          <source>The super class of all menu related containers.</source>
          <target state="translated">모든 메뉴 관련 컨테이너의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2edd5140cff4220974aa4530adeee309c448831e" translate="yes" xml:space="preserve">
          <source>The superclass behavior will try to update the child views which is not desired in this case, since the children are zones and not directly effected by the changes to the associated element.</source>
          <target state="translated">수퍼 클래스 비헤이비어는이 경우에는 원하지 않는 자식 뷰를 업데이트하려고 할 것입니다. 자식은 영역이고 관련 요소의 변경에 의해 직접 영향을받지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="223c3b7c239c5d80bf9c6472a205737e2c00d21b" translate="yes" xml:space="preserve">
          <source>The superclass behavior will try to update the child views which is not desired in this case, since the children are zones and not directly effected by the changes to the associated element. This is reimplemented to do nothing and return false.</source>
          <target state="translated">수퍼 클래스 비헤이비어는이 경우에는 원하지 않는 자식 뷰를 업데이트하려고 할 것입니다. 자식은 영역이고 관련 요소의 변경에 의해 직접 영향을받지 않기 때문입니다. 아무것도하지 않고 false를 반환하도록 다시 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="21955f67e39653298d554b40ee6256104e191d63" translate="yes" xml:space="preserve">
          <source>The superclass of JShell generated exceptions</source>
          <target state="translated">JShell의 슈퍼 클래스 생성 예외</target>
        </trans-unit>
        <trans-unit id="602000e37c0a2e549407c0c276a26b61377db86f" translate="yes" xml:space="preserve">
          <source>The supertypes (both class and interface types) of a declared type may be found using the &lt;a href=&quot;../util/types#directSupertypes(javax.lang.model.type.TypeMirror)&quot;&gt;&lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt;&lt;/a&gt; method. This returns the supertypes with any type arguments substituted in.</source>
          <target state="translated">선언 된 유형의 상위 유형 (클래스 및 인터페이스 유형 모두)은 &lt;a href=&quot;../util/types#directSupertypes(javax.lang.model.type.TypeMirror)&quot;&gt; &lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 찾을 수 있습니다 . 이는 모든 유형 인수가 대체 된 상위 유형을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8b4fd272478c2bf5755a6c3fbfac56931cb9665d" translate="yes" xml:space="preserve">
          <source>The supertypes (both class and interface types) of a declared type may be found using the &lt;a href=&quot;../util/types#directSupertypes-javax.lang.model.type.TypeMirror-&quot;&gt;&lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt;&lt;/a&gt; method. This returns the supertypes with any type arguments substituted in.</source>
          <target state="translated">선언 된 유형의 수퍼 타입 ​​(클래스 및 인터페이스 유형 모두)은 &lt;a href=&quot;../util/types#directSupertypes-javax.lang.model.type.TypeMirror-&quot;&gt; &lt;code&gt;Types.directSupertypes(TypeMirror)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 찾을 수 있습니다 . 타입 인수가 치환 된 슈퍼 타입을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="dc5747fa903eaf6ac98267f42bc62b68fd35ff94" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;CompositeData&lt;/code&gt; must have the following item names and item types to be valid.</source>
          <target state="translated">제공된 &lt;code&gt;CompositeData&lt;/code&gt; 가 유효하려면 다음 항목 이름 및 항목 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5ca7e4f038d5dc8de6f6523df8470fdb5a3affbb" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;index&lt;/code&gt; corresponds to the index of the &lt;a href=&quot;valuedescriptor&quot;&gt;&lt;code&gt;ValueDescriptor&lt;/code&gt;&lt;/a&gt; object passed to the factory method of the &lt;code&gt;EventFactory&lt;/code&gt; class.</source>
          <target state="translated">제공된 &lt;code&gt;index&lt;/code&gt; 의 인덱스에 대응 &lt;a href=&quot;valuedescriptor&quot;&gt; &lt;code&gt;ValueDescriptor&lt;/code&gt; 의&lt;/a&gt; 목적은 상기의 공장 메소드에 전달 &lt;code&gt;EventFactory&lt;/code&gt; 클래스.</target>
        </trans-unit>
        <trans-unit id="14dfb8fa2619f0e88128d788e30861e3728092dc" translate="yes" xml:space="preserve">
          <source>The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. For predictable results, the accumulator function should be commutative and associative within the floating point tolerance required in usage contexts. The function is applied with an existing value (or identity) as one argument, and a given update as the other argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Double::max&lt;/code&gt; along with &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; as the identity. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.</source>
          <target state="translated">제공된 누산기 함수는 스레드 간의 경합으로 인해 업데이트 시도가 실패 할 때 다시 적용될 수 있으므로 부작용이 없어야합니다. 예측 가능한 결과를 위해 누산기 함수는 사용 컨텍스트에 필요한 부동 소수점 허용 범위 내에서 교환 및 연관이어야합니다. 함수는 기존 값 (또는 ID)을 하나의 인수로 적용하고 주어진 업데이트를 다른 인수로 적용합니다. 예를 들어 실행중인 최대 값을 유지하려면 &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; 와 함께 &lt;code&gt;Double::max&lt;/code&gt; 를 ID로 제공 할 수 있습니다. 스레드 내부 또는 스레드 간의 누적 순서는 보장되지 않습니다. 따라서이 등급은 수치 안정성이 필요한 경우 적용되지 않을 수 있습니다. 특히 크기가 상당히 다른 값을 결합 할 때 더욱 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="6acd237472bddb6f88b28a9f2fd993ab87094ddb" translate="yes" xml:space="preserve">
          <source>The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply &lt;code&gt;Double::max&lt;/code&gt; along with &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; as the identity. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude.</source>
          <target state="translated">제공된 어큐뮬레이터 기능은 부작용이 없어야합니다. 스레드 간의 경합으로 인해 업데이트 시도가 실패하면 다시 적용될 수 있습니다. 이 함수는 현재 값을 첫 번째 인수로, 지정된 업데이트를 두 번째 인수로 적용합니다. 예를 들어, 실행중인 최대 값을 유지하기 위해 &lt;code&gt;Double::max&lt;/code&gt; 를 &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; 와 함께 ID로 제공 할 수 있습니다. 스레드 내에서 또는 스레드 간 누적 순서는 보장되지 않습니다. 따라서 수치 안정성이 필요한 경우, 특히 실질적으로 다른 차수의 값을 결합 할 때이 등급을 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6025b666165a1f5fda89da5a8e8ee1de31444459" translate="yes" xml:space="preserve">
          <source>The supplied array holding three internalized strings representing the Namespace URI (or empty string), the local name, and the XML qualified name; or null if there is an undeclared prefix.</source>
          <target state="translated">네임 스페이스 URI (또는 빈 문자열), 로컬 이름 및 XML 규정 이름을 나타내는 세 개의 내부화 된 문자열을 보유하는 제공된 배열. 선언되지 않은 접두사가있는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="7ad24e24ba3ab22cd4ef21994274386c9cd69325" translate="yes" xml:space="preserve">
          <source>The supplied object parameter acts as an optional configuration argument. For example, it could be of type &lt;code&gt;Component&lt;/code&gt;. A &lt;code&gt;Painter&lt;/code&gt; that expected it could then read state from that &lt;code&gt;Component&lt;/code&gt; and use the state for painting. For example, an implementation may read the backgroundColor and use that.</source>
          <target state="translated">제공된 개체 매개 변수는 선택적 구성 인수 역할을합니다. 예를 들어 &lt;code&gt;Component&lt;/code&gt; 유형일 수 있습니다 . 그런 다음 해당 &lt;code&gt;Component&lt;/code&gt; 에서 상태를 읽고 페인팅에 상태를 사용할 수 있다고 예상 한 &lt;code&gt;Painter&lt;/code&gt; 입니다 . 예를 들어 구현은 backgroundColor를 읽고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84e7dcea201cffacdcbf9be7a2353ff95d845a5" translate="yes" xml:space="preserve">
          <source>The supplied thumbnails will be resized if needed, and any thumbnails in excess of the supported number will be ignored. If the format requires additional thumbnails that are not provided, the writer should generate them internally.</source>
          <target state="translated">제공된 축소판 그림은 필요한 경우 크기가 조정되며 지원되는 수를 초과하는 축소판 그림은 무시됩니다. 형식에 제공되지 않은 추가 축소판 그림이 필요한 경우 작성자는 내부에서 축소판 그림을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="753904bcbd3964af858d18cda3d913205d84b5e6" translate="yes" xml:space="preserve">
          <source>The supplied thumbnails will be resized if needed, and any thumbnails in excess of the supported number will be ignored. If the format requires additional thumbnails that are not provided, the writer will generate them internally.</source>
          <target state="translated">제공된 축소판 그림은 필요한 경우 크기가 조정되며 지원되는 수를 초과하는 축소판 그림은 무시됩니다. 형식에 제공되지 않은 추가 축소판 그림이 필요한 경우 기록기는 내부에서 축소판 그림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bce2b22d14479cd69e56124d69d47db8b57076ba" translate="yes" xml:space="preserve">
          <source>The support for this is provided by the &lt;code&gt;StyleSheet&lt;/code&gt; class. The presentation of the HTML can be heavily influenced by the setting of the StyleSheet property on the EditorKit.</source>
          <target state="translated">이에 대한 지원은 &lt;code&gt;StyleSheet&lt;/code&gt; 클래스에서 제공합니다 . HTML의 표현은 EditorKit의 StyleSheet 속성 설정에 의해 크게 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc15d8eee723cd7e4ccfbd5a0f0bd59ce88d1002" translate="yes" xml:space="preserve">
          <source>The supported &lt;code&gt;ChronoField&lt;/code&gt; instances are:</source>
          <target state="translated">지원되는 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b2cd39555d2c728a665b32d4100c19f45b92402" translate="yes" xml:space="preserve">
          <source>The supported calendar systems includes:</source>
          <target state="translated">지원되는 캘린더 시스템에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="83bd48a0eac4e9b358a53d73d8f0c393f28dcfbc" translate="yes" xml:space="preserve">
          <source>The supported categories are those of &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt; &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the &lt;a href=&quot;../../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; class. The category names are those defined in the Standard, both normative and informative.</source>
          <target state="translated">지원되는 범주는 &lt;a href=&quot;../../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt; 클래스에서 지정한 버전 의 &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; 범주 입니다. 범주 이름은 규범 및 유익한 표준에서 정의 된 이름입니다. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1b938fa603bd5aaba697922eb2fb711a539cf4d0" translate="yes" xml:space="preserve">
          <source>The supported categories are those of &lt;a href=&quot;https://www.unicode.org/unicode/standard/standard.html&quot;&gt; &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the &lt;a href=&quot;../../lang/character&quot;&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/a&gt; class. The category names are those defined in the Standard, both normative and informative.</source>
          <target state="translated">지원되는 범주는 &lt;a href=&quot;../../lang/character&quot;&gt; &lt;code&gt;Character&lt;/code&gt; &lt;/a&gt; 클래스에서 지정한 버전 &lt;a href=&quot;https://www.unicode.org/unicode/standard/standard.html&quot;&gt;&lt;i&gt;의 유니 코드 표준&lt;/i&gt;&lt;/a&gt; 입니다 . 카테고리 이름은 규범 적 및 정보 적 모두 표준에 정의 된 이름입니다. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="b4eb01860151689f1f6379a2545112126849a160" translate="yes" xml:space="preserve">
          <source>The supported class file changes are described in &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html#RedefineClasses&quot;&gt;JVM TI RedefineClasses&lt;/a&gt;. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">지원되는 클래스 파일 변경 사항은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html#RedefineClasses&quot;&gt;JVM TI RedefineClasses에&lt;/a&gt; 설명되어 있습니다. 클래스 파일 바이트는 변환이 적용될 때까지 검사, 확인 및 설치되지 않으며 결과 바이트에 오류가있는 경우이 메서드는 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="e05137876edd3b6b6a29d96ad5b9b3edf239fae6" translate="yes" xml:space="preserve">
          <source>The supported class file changes are described in &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html#RetransformClasses&quot;&gt;JVM TI RetransformClasses&lt;/a&gt;. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</source>
          <target state="translated">지원되는 클래스 파일 변경 사항은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html#RetransformClasses&quot;&gt;JVM TI RetransformClasses에&lt;/a&gt; 설명되어 있습니다. 클래스 파일 바이트는 변환이 적용될 때까지 검사, 확인 및 설치되지 않으며 결과 바이트에 오류가있는 경우이 메서드는 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="27c2737ecb716851489499e7d8287bbcd13402f5" translate="yes" xml:space="preserve">
          <source>The supported component types (variables types) are &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">지원되는 구성 요소 유형 (변수 유형)은 &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f2e9acf0920ea9550ff69da281e2ea26f2481f3" translate="yes" xml:space="preserve">
          <source>The supported syntax is:</source>
          <target state="translated">지원되는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d6a5bc82895e1be1c598d816a928419e077fb62" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt;&lt;code&gt;SECONDS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt;&lt;code&gt;NANOS&lt;/code&gt;&lt;/a&gt;. They are returned in the order seconds, nanos.</source>
          <target state="translated">지원되는 단위는 &lt;a href=&quot;temporal/chronounit#SECONDS&quot;&gt; &lt;code&gt;SECONDS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#NANOS&quot;&gt; &lt;code&gt;NANOS&lt;/code&gt; &lt;/a&gt; 입니다. 그들은 몇 초, 나노 단위로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="50995038a878ce286701de766382bef69778b604" translate="yes" xml:space="preserve">
          <source>The supported units are &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. They are returned in the order years, months, days.</source>
          <target state="translated">지원되는 단위는 &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 입니다. 그들은 년, 월, 일 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7618ee46d4016ebcae2e5cbf1a065473c760968b" translate="yes" xml:space="preserve">
          <source>The supported units are chronology specific. They will typically be &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Requesting an unsupported unit will throw an exception.</source>
          <target state="translated">지원되는 단위는 연대순입니다. 그들은 일반적으로 될 것 &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; . 지원되지 않는 유닛을 요청하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b30d06d3ef729bd157ab81214e7e89bcf4f23fd7" translate="yes" xml:space="preserve">
          <source>The supported units are chronology specific. They will typically be &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. They are returned in order from largest to smallest.</source>
          <target state="translated">지원되는 단위는 연대순입니다. 그들은 일반적으로 될 것 &lt;a href=&quot;../temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; . 가장 큰 것부터 가장 작은 것까지 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="612ea5ebf89d96a0eba935a9ea4b0154afc481ad" translate="yes" xml:space="preserve">
          <source>The supported units of a period are &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt;&lt;code&gt;YEARS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt;&lt;code&gt;MONTHS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. All three fields are always present, but may be set to zero.</source>
          <target state="translated">지원되는 기간의 단위는 &lt;a href=&quot;temporal/chronounit#YEARS&quot;&gt; &lt;code&gt;YEARS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;temporal/chronounit#MONTHS&quot;&gt; &lt;code&gt;MONTHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 입니다. 세 필드는 모두 항상 존재하지만 0으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba6f6bccc56ef3d310dd0f60418a50729535d8d9" translate="yes" xml:space="preserve">
          <source>The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;via a constructor&lt;/a&gt;. When suppression is disabled, this method does nothing other than to validate its argument.</source>
          <target state="translated">&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;생성자를 통해&lt;/a&gt; 비활성화 &lt;em&gt;하지 않는 한&lt;/em&gt; 억제 동작이 활성화 &lt;em&gt;됩니다&lt;/em&gt; . 억제가 비활성화 된 경우이 메서드는 인수의 유효성을 검사하는 것 외에 다른 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5be801d8d7c141429eb2a06d10b0aef903302c4" translate="yes" xml:space="preserve">
          <source>The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;via a constructor&lt;/a&gt;. When suppression is disabled, this method does nothing other than to validate its argument.</source>
          <target state="translated">&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;생성자를 통해&lt;/a&gt; 비활성화 &lt;em&gt;하지 않으면&lt;/em&gt; 억제 동작이 활성화 &lt;em&gt;됩니다&lt;/em&gt; . 억제를 무효로하면 (자),이 메소드는 인수를 검증하는 것 외에는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82ebf4133d954ce86d747b54dfa4cfd4018049ca" translate="yes" xml:space="preserve">
          <source>The suspended thread is guaranteed to remain suspended until resumed through one of the JDI resume methods mentioned above; the application in the target VM cannot resume the suspended thread through &lt;a href=&quot;../../../../java.base/java/lang/thread#resume()&quot;&gt;&lt;code&gt;Thread.resume()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일시 중단 된 스레드는 위에서 언급 한 JDI 재개 메소드 중 하나를 통해 재개 될 때까지 일시 중단 된 상태로 유지됩니다. 대상 VM의 애플리케이션은 &lt;a href=&quot;../../../../java.base/java/lang/thread#resume()&quot;&gt; &lt;code&gt;Thread.resume()&lt;/code&gt; &lt;/a&gt; 통해 일시 중단 된 스레드를 재개 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2d792cc659c3710e68412ad26001e0365e4fe31b" translate="yes" xml:space="preserve">
          <source>The swing text components provide some support of thread safe operations. Because of the high level of configurability of the text components, it is possible to circumvent the protection provided. The protection primarily comes from the model, so the documentation of &lt;code&gt;AbstractDocument&lt;/code&gt; describes the assumptions of the protection provided. The methods that are safe to call asynchronously are marked with comments.</source>
          <target state="translated">스윙 텍스트 구성 요소는 스레드 안전 작업을 일부 지원합니다. 텍스트 구성 요소의 높은 수준의 구성 가능성으로 인해 제공된 보호 기능을 우회 할 수 있습니다. 보호는 주로 모델에서 제공되므로 &lt;code&gt;AbstractDocument&lt;/code&gt; 의 문서는 제공된 보호의 가정을 설명합니다. 비동기 적으로 호출해도 안전한 메서드는 주석으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="841ed2261b840ee034e2fc667a839f1eea97e56b" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchange&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchange&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.COMPARE_AND_EXCHANGE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="80c4a3b73d48513a6615b83f39f27edf617e75d0" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchangeAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchangeAcquire&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6fd514eb09ba3f8f2597220841a1a986e13cd4bc" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndExchangeRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndExchangeRelease&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8383b8927a886acbd2d87b4f789aa3cd1800f65" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 compareAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; compareAndSet&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.COMPARE_AND_SET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fc1fe303a671f659dfcb75ed69ad915a0b9cf34" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSet&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.WEAK_COMPARE_AND_SET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2d6fc33cce92819cac6f3c0aae23a1e0f658baf" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetAcquire&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c238fc4ba306a85bf1a7b6a1059990d27fd23416" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetPlain&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetPlain&lt;/code&gt; 호출 사이트의 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN) 을 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3caa02cdc85af699be3da720087d3b254a1e0d14" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;
 weakCompareAndSetRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt; weakCompareAndSetRelease&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d92d0c26fd0ceacd6a22912f8e08a2af1144ac03" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;get&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="785e11e22d0e4f59f3c358dd707d0c8bb9c45c5d" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAcquire&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_ACQUIRE) 호출 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3909d7fd71a3ce0d45b42b91b83a4cb3a38cc4c7" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAdd&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAdd&lt;/code&gt; 호출 사이트에있는 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_ADD) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b8c1e07e45f3df0e3f4c7960f4689cc7ff853fb5" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAddAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAddAcquire&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_ADD_ACQUIRE) 호출 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb3556eafa083c922f5ddc536ef70abc23d8064c" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndAddRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndAddRelease&lt;/code&gt; 호출 사이트의 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_ADD_RELEASE) 호출 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aab207cd06c5ec5d7499697ca6ba7769359b6579" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAnd&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAnd&lt;/code&gt; 호출 사이트의 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_AND) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="836795e8bc56b921c84886828b4ff0823073d2b0" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAndAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAndAcquire&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE) 호출 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="78cc40ca583a385f170594f785f938d9b667b6eb" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseAndRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseAndRelease&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="845f2ed88bc26c3452225eb1d4ee813e31903cab" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOr&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOr&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_OR) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ddd9f837d79fd41f1a93fe6a1f1e69fb4737c0f" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOrAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOrAcquire&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b92e606932a5540d338db4148a4c5b8e213940b9" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseOrRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseOrRelease&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="248d840d1056e103e71ed4367a20a6f5c5c6b14b" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXor&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXor&lt;/code&gt; 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_XOR) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6603458f74711c546450ff99c0fa6a4f391bc1ad" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXorAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXorAcquire&lt;/code&gt; 의 호출 사이트에있는 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="582cd1e29d747ef96d86945b9cc3596d644def63" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndBitwiseXorRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndBitwiseXorRelease&lt;/code&gt; 의 호출 사이트에있는 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b49e84c3b73b7c67f75202b8dcf68959c3b67df" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSet&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSet&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_SET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="726283d34708064e448798ed7558fd26056194bc" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSetAcquire&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSetAcquire&lt;/code&gt; 호출 사이트의 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_SET_ACQUIRE) 호출 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d72b516be7afed65c7b9b32c7e234a778cc590e8" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getAndSetRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getAndSetRelease&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_AND_SET_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4a3f7c47047a21314dc4bcc3cfef336f2dea3704" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getOpaque&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_OPAQUE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getOpaque&lt;/code&gt; 의 호출 사이트에있는 기호 유형 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_OPAQUE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_OPAQUE) 를 호출 한 결과 인 액세스 모드 유형과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="80d17bb7d7e04c4f675b8b6a6964580c44801bf2" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;getVolatile&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_VOLATILE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;getVolatile&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.GET_VOLATILE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.GET_VOLATILE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="94be2d0c54621beaec5e232a04f1856df457acaf" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;set&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.SET) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="158dfc3921c96e11341de806f439c35a94497773" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setOpaque&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_OPAQUE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setOpaque&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_OPAQUE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.SET_OPAQUE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="342170d52a224940f39c38e69957aa300beeb148" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setRelease&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_RELEASE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setRelease&lt;/code&gt; 호출 사이트의 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_RELEASE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.SET_RELEASE) 를 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="68ed9d8b4bcd184b8baaaf811374d5c92f6c83db" translate="yes" xml:space="preserve">
          <source>The symbolic type descriptor at the call site of &lt;code&gt;setVolatile&lt;/code&gt; must match the access mode type that is the result of calling &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_VOLATILE)&lt;/code&gt; on this VarHandle.</source>
          <target state="translated">&lt;code&gt;setVolatile&lt;/code&gt; 의 호출 사이트에있는 기호 형식 설명 &lt;code&gt;accessModeType(VarHandle.AccessMode.SET_VOLATILE)&lt;/code&gt; 이 VarHandle에서 accessModeType (VarHandle.AccessMode.SET_VOLATILE) 을 호출 한 결과 인 액세스 모드 형식과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="52423f32e1b10ddbf83308406995a99e390cdeaf" translate="yes" xml:space="preserve">
          <source>The synchronization mechanism that provides reader/writer capabilities for disconnected &lt;code&gt;RowSet&lt;/code&gt; objects.</source>
          <target state="translated">연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체에 대한 읽기 / 쓰기 기능을 제공하는 동기화 메커니즘입니다 .</target>
        </trans-unit>
        <trans-unit id="711ab65736cb44038b84d447045e9ee485fba83d" translate="yes" xml:space="preserve">
          <source>The synchronization mechanism that provides reader/writer capabilities for disconnected &lt;code&gt;RowSet&lt;/code&gt; objects. A &lt;code&gt;SyncProvider&lt;/code&gt; implementation is a class that extends the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class.</source>
          <target state="translated">연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체에 대한 읽기 / 쓰기 기능을 제공하는 동기화 메커니즘입니다 . &lt;code&gt;SyncProvider&lt;/code&gt; 구현은 확장하는 클래스 &lt;code&gt;SyncProvider&lt;/code&gt; 추상 클래스를.</target>
        </trans-unit>
        <trans-unit id="939dc2dd97681934d81029b8ea6d3b61888d9016" translate="yes" xml:space="preserve">
          <source>The syntactic form of this case:</source>
          <target state="translated">이 경우의 구문 형식 :</target>
        </trans-unit>
        <trans-unit id="f3288e69953928bbb2335d7fc9bfc195092f73df" translate="yes" xml:space="preserve">
          <source>The syntactic form of this case: STATEMENT: &lt;code&gt;case &amp;lt;expression&amp;gt;: &amp;lt;statements&amp;gt;&lt;/code&gt; RULE: &lt;code&gt;case &amp;lt;expression&amp;gt; -&amp;gt; &amp;lt;expression&amp;gt;/&amp;lt;statement&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 경우의 구문 형식 : STATEMENT : &lt;code&gt;case &amp;lt;expression&amp;gt;: &amp;lt;statements&amp;gt;&lt;/code&gt; RULE : &lt;code&gt;case &amp;lt;expression&amp;gt; -&amp;gt; &amp;lt;expression&amp;gt;/&amp;lt;statement&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e55e499a6fc5c1dbd4e8b7511cc0424a80a9f71" translate="yes" xml:space="preserve">
          <source>The syntactic locations where annotations may appear are split into &lt;em&gt;declaration contexts&lt;/em&gt; , where annotations apply to declarations, and &lt;em&gt;type contexts&lt;/em&gt; , where annotations apply to types used in declarations and expressions.</source>
          <target state="translated">주석이 나타날 수있는 구문 적 위치는 &lt;em&gt;선언 컨텍스트 (&lt;/em&gt; 주석이 선언에 적용되는 경우)와 &lt;em&gt;유형 컨텍스트 (&lt;/em&gt; 주석이 선언 및 표현식에 사용 된 형식에 적용되는) 로 분할됩니다 .</target>
        </trans-unit>
        <trans-unit id="d632ddfa97c4cad739a3e8bfa95d9d9894f9d8e2" translate="yes" xml:space="preserve">
          <source>The syntactic locations where annotations may appear are split into &lt;em&gt;declaration contexts&lt;/em&gt;, where annotations apply to declarations, and &lt;em&gt;type contexts&lt;/em&gt;, where annotations apply to types used in declarations and expressions.</source>
          <target state="translated">주석이 나타날 수있는 구문 위치는 &lt;em&gt;선언 컨텍스트&lt;/em&gt; 로 분할되며 , 주석은 선언에 적용되고, &lt;em&gt;유형 컨텍스트&lt;/em&gt; 는 선언 및 표현식에 사용되는 유형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="00a77c038c4619155739ddefe087cb77c766d025" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;URL&lt;/code&gt; is defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732: Format for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described &lt;a href=&quot;inet6address#scoped&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">의 구문 &lt;code&gt;URL&lt;/code&gt; 은 에 의해 정의되는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;범용 리소스 식별자 (URI) : 일반 구문 RFC 2396&lt;/i&gt;&lt;/a&gt; 에 의해 개정 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732 : URL에 리터럴 IPv6 주소 형식&lt;/i&gt;&lt;/a&gt; . 리터럴 IPv6 주소 형식은 scope_id도 지원합니다. scope_ids의 구문과 사용법은 &lt;a href=&quot;inet6address#scoped&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d30895ab44eb5b5f1c0c0bd25de8d5e5b87d3b73" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;URL&lt;/code&gt; is defined by &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a href=&quot;https://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732: Format for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described &lt;a href=&quot;inet6address#scoped&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">의 구문 &lt;code&gt;URL&lt;/code&gt; 은 에 의해 정의되는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;범용 리소스 식별자 (URI) : 일반 구문 RFC 2396&lt;/i&gt;&lt;/a&gt; 에 의해 개정 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC 2732 : URL에 리터럴 IPv6 주소 형식&lt;/i&gt;&lt;/a&gt; . 리터럴 IPv6 주소 형식은 scope_ids도 지원합니다. scope_ids의 구문과 사용법은 &lt;a href=&quot;inet6address#scoped&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="449145cc99d61f1de8faac0f36747e42eeda60f0" translate="yes" xml:space="preserve">
          <source>The syntax of a JAR URL is:</source>
          <target state="translated">JAR URL의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08fb1f0d6774918d6dc928c999a8c810bc3e1cf4" translate="yes" xml:space="preserve">
          <source>The syntax of a compound name is specified using a set of properties:</source>
          <target state="translated">복합 이름의 구문은 일련의 속성을 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4fb2ecb6c058b701542fac5ca88a96aa5fb606b8" translate="yes" xml:space="preserve">
          <source>The system &lt;code&gt;ClassLoader&lt;/code&gt;</source>
          <target state="translated">시스템 &lt;code&gt;ClassLoader&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74f5647e4732b56055ffb73b5ef679c9f6b0e018" translate="yes" xml:space="preserve">
          <source>The system &lt;code&gt;ClassLoader&lt;/code&gt; for delegation, or &lt;code&gt;null&lt;/code&gt; if none</source>
          <target state="translated">위 임용 시스템 &lt;code&gt;ClassLoader&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; 경우는 null</target>
        </trans-unit>
        <trans-unit id="09bd470fb008a04d052a9d37972d68c9fb1da6a5" translate="yes" xml:space="preserve">
          <source>The system can interpolate the provided value.</source>
          <target state="translated">시스템은 제공된 값을 보간 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53b892170425a40e4822de5a8c352ee0cdcdd75" translate="yes" xml:space="preserve">
          <source>The system class loader supports adding a JAR file to be searched if it implements a method named &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; which takes a single parameter of type &lt;code&gt;java.lang.String&lt;/code&gt;. The method is not required to have &lt;code&gt;public&lt;/code&gt; access. The name of the JAR file is obtained by invoking the &lt;a href=&quot;../../../../java.base/java/util/zip/zipfile#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;jarfile&lt;/code&gt; and this is provided as the parameter to the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method.</source>
          <target state="translated">시스템 클래스 로더는 &lt;code&gt;java.lang.String&lt;/code&gt; 유형의 단일 매개 변수를 취하는 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 메소드를 구현하는 경우 검색 할 JAR 파일 추가를 지원합니다 . 이 메서드는 &lt;code&gt;public&lt;/code&gt; 액세스 권한 이 필요하지 않습니다 . JAR 파일의 이름은 호출함으로써 얻어지는 &lt;a href=&quot;../../../../java.base/java/util/zip/zipfile#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 상의 메소드 &lt;code&gt;jarfile&lt;/code&gt; 가를 이는 본의 파라미터로서 제공된다 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="74a5a2feb3472fb9649c9e133c6a12917cacd2aa" translate="yes" xml:space="preserve">
          <source>The system class loader supports adding a JAR file to be searched if it implements a method named &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; which takes a single parameter of type &lt;code&gt;java.lang.String&lt;/code&gt;. The method is not required to have &lt;code&gt;public&lt;/code&gt; access. The name of the JAR file is obtained by invoking the &lt;a href=&quot;../../util/zip/zipfile#getName--&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; method on the &lt;code&gt;jarfile&lt;/code&gt; and this is provided as the parameter to the &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; method.</source>
          <target state="translated">시스템 클래스 로더는 &lt;code&gt;java.lang.String&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 메소드를 구현하는 경우 검색 할 JAR 파일 추가를 지원합니다 . 이 방법은 &lt;code&gt;public&lt;/code&gt; 액세스 권한 이 필요하지 않습니다 . JAR 파일의 이름은 &lt;code&gt;jarfile&lt;/code&gt; 에서 &lt;a href=&quot;../../util/zip/zipfile#getName--&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 얻을 수 있으며 &lt;code&gt;appendToClassPathForInstrumentation&lt;/code&gt; 메소드에 매개 변수로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7007628b7373da2f3acc46dea4b6fc181e177f3" translate="yes" xml:space="preserve">
          <source>The system console, if any, otherwise &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">어떤 경우 시스템 콘솔, 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990083cbffe223d7dee670ed0f3eec843ed8520d" translate="yes" xml:space="preserve">
          <source>The system default &lt;code&gt;LoggerFinder&lt;/code&gt; implementation uses &lt;code&gt;java.util.logging&lt;/code&gt; as the backend framework when the &lt;code&gt;java.logging&lt;/code&gt; module is present. It returns a &lt;a href=&quot;system.logger&quot;&gt;logger&lt;/a&gt; instance that will route log messages to a &lt;a href=&quot;../../../java.logging/java/util/logging/logger&quot;&gt;&lt;code&gt;java.util.logging.Logger&lt;/code&gt;&lt;/a&gt;. Otherwise, if &lt;code&gt;java.logging&lt;/code&gt; is not present, the default implementation will return a simple logger instance that will route log messages of &lt;code&gt;INFO&lt;/code&gt; level and above to the console (&lt;code&gt;System.err&lt;/code&gt;).</source>
          <target state="translated">시스템 기본 &lt;code&gt;LoggerFinder&lt;/code&gt; 구현은 &lt;code&gt;java.logging&lt;/code&gt; 모듈이 있을 때 &lt;code&gt;java.util.logging&lt;/code&gt; 을 백엔드 프레임 워크로 사용합니다 . 로그 메시지를 &lt;a href=&quot;../../../java.logging/java/util/logging/logger&quot;&gt; &lt;code&gt;java.util.logging.Logger&lt;/code&gt; 로&lt;/a&gt; 라우팅 하는 &lt;a href=&quot;system.logger&quot;&gt;로거&lt;/a&gt; 인스턴스를 반환 합니다 . 그렇지 않으면 &lt;code&gt;java.logging&lt;/code&gt; 이없는 경우 기본 구현은 &lt;code&gt;INFO&lt;/code&gt; 수준 이상의 로그 메시지를 콘솔 ( &lt;code&gt;System.err&lt;/code&gt; )로 라우팅하는 간단한 로거 인스턴스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3cf101b78cd06413158b1ec4f8db88795dfdf0e0" translate="yes" xml:space="preserve">
          <source>The system does not provide a reason for a session change.</source>
          <target state="translated">시스템은 세션 변경 이유를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d37ff3b03f83b416aeccd9836d23dd0072998488" translate="yes" xml:space="preserve">
          <source>The system identifier as a string, or null if none is available.</source>
          <target state="translated">시스템 식별자 (문자열) 또는 사용할 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="c9d316b1fe86ec8261312bc65a64ba6fd6ecd9f6" translate="yes" xml:space="preserve">
          <source>The system identifier associated with the entity if specified, and &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">엔티티와 연관된 시스템 식별자 (지정된 경우), 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df19c9feca0d6dc04cc43c03e2d1251edf9e4510" translate="yes" xml:space="preserve">
          <source>The system identifier associated with the entity if specified, and &lt;code&gt;null&lt;/code&gt; otherwise. This may be an absolute URI or not.</source>
          <target state="translated">엔티티와 연관된 시스템 식별자 (지정된 경우), 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 입니다. 절대 URI 일 수도 있고 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b32fa52354502a426e561283736887788b3252db" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if the source does not get its data from a URL, but it may still be useful to provide one. The application can use a system identifier, for example, to resolve relative URIs and to include in error messages and warnings.</source>
          <target state="translated">소스가 URL에서 데이터를 가져 오지 않는 경우 시스템 식별자는 선택 사항이지만 여전히 제공하는 것이 유용 할 수 있습니다. 예를 들어 응용 프로그램은 시스템 식별자를 사용하여 상대 URI를 확인하고 오류 메시지 및 경고에 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2364c05ce4f7479bebd35fee2edf0a7d214455de" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if there is a byte stream or a character stream, but it is still useful to provide one, since the application can use it to resolve relative URIs and can include it in error messages and warnings (the parser will attempt to open a connection to the URI only if no byte stream or character stream is specified).</source>
          <target state="translated">시스템 식별자는 바이트 스트림이나 문자 스트림이있는 경우 선택 사항이지만 응용 프로그램에서이를 사용하여 상대 URI를 확인하고 오류 메시지 및 경고에 포함 할 수 있기 때문에 (파서가 바이트 스트림이나 문자 스트림이 지정되지 않은 경우에만 URI에 대한 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="c83b9a58a230a52e3ca07250c92629dfdd6df1bf" translate="yes" xml:space="preserve">
          <source>The system identifier is optional if there is a byte stream or a character stream, but it is still useful to provide one, since the application can use it to resolve relative URIs and can include it in error messages and warnings (the parser will attempt to open a connection to the URI only if there is no byte stream or character stream specified).</source>
          <target state="translated">시스템 식별자는 바이트 스트림이나 문자 스트림이있는 경우 선택 사항이지만 응용 프로그램에서이를 사용하여 상대 URI를 확인하고 오류 메시지 및 경고에 포함 할 수 있기 때문에 (파서가 지정된 바이트 스트림 또는 문자 스트림이없는 경우에만 URI에 대한 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="3cef073d95130421d24f48582c3ee6a831095599" translate="yes" xml:space="preserve">
          <source>The system identifier may be &lt;code&gt;null&lt;/code&gt; or an empty &lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">시스템 식별자는 &lt;code&gt;null&lt;/code&gt; 이거나 빈 &lt;code&gt;&quot;&quot;&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff7e558528664a0592a67c50fde5c5a005f60b33" translate="yes" xml:space="preserve">
          <source>The system identifier of the external subset.</source>
          <target state="translated">외부 하위 집합의 시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="5b27a3eb89c729d7e642ff92ff95e3dac820f59c" translate="yes" xml:space="preserve">
          <source>The system identifier of the external subset. This may be an absolute URI or not.</source>
          <target state="translated">외부 서브 세트의 시스템 식별자. 절대 URI 일 수도 있고 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff0c997f101dd04693253ebc52fe8874df3b5062" translate="yes" xml:space="preserve">
          <source>The system identifier of this notation.</source>
          <target state="translated">이 표기법의 시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="54b96c3bc9ebc5adfe89119951cb415cb6d98e20" translate="yes" xml:space="preserve">
          <source>The system identifier of this notation. If the system identifier was not specified, this is &lt;code&gt;null&lt;/code&gt;. This may be an absolute URI or not.</source>
          <target state="translated">이 표기법의 시스템 식별자입니다. 시스템 식별자가 지정되지 않은 경우 이것은 &lt;code&gt;null&lt;/code&gt; 입니다. 절대 URI 일 수도 있고 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0dc421d48b89f1f1bd983b514fa401be307f95f" translate="yes" xml:space="preserve">
          <source>The system identifier that was set with setSystemId, or null if setSystemId was not called.</source>
          <target state="translated">setSystemId로 설정된 시스템 식별자 또는 setSystemId가 호출되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="a1ce02ce7ff2b78b9dae3fc1cf570c0f7333877f" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source.</source>
          <target state="translated">이 입력 소스에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="257e29fd1c5d73c7e7ae227aff860a12a6b60071" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source. The system identifier is optional if there is a byte stream, a character stream, or string data. It is still useful to provide one, since the application will use it to resolve any relative URIs and can include it in error messages and warnings. (The LSParser will only attempt to fetch the resource identified by the URI reference if there is no other input available in the input source.)</source>
          <target state="translated">이 입력 소스에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]. 바이트 스트림, 문자 스트림 또는 문자열 데이터가있는 경우 시스템 식별자는 선택 사항입니다. 응용 프로그램에서 상대 URI를 확인하는 데 사용하고 오류 메시지 및 경고에 포함 할 수 있으므로이를 제공하는 것이 여전히 유용합니다. (LSParser는 입력 소스에 사용할 수있는 다른 입력이없는 경우에만 URI 참조로 식별되는 리소스를 가져 오려고 시도합니다.)</target>
        </trans-unit>
        <trans-unit id="9aecaed599272a3cd0476ff61a2a3b31138ead77" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this output destination.</source>
          <target state="translated">이 출력 대상에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="b0ed5624153545966ebdca177865c153cb4b447e" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source.</source>
          <target state="translated">이 입력 소스에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="68cb3432f3f6642c8c7a7d7fc19e09015d305ffe" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this input source. The system identifier is optional if there is a byte stream, a character stream, or string data. It is still useful to provide one, since the application will use it to resolve any relative URIs and can include it in error messages and warnings. (The LSParser will only attempt to fetch the resource identified by the URI reference if there is no other input available in the input source.)</source>
          <target state="translated">이 입력 소스에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]. 바이트 스트림, 문자 스트림 또는 문자열 데이터가있는 경우 시스템 식별자는 선택 사항입니다. 응용 프로그램이이를 사용하여 상대 URI를 확인하고 오류 메시지 및 경고에 포함 할 수 있으므로 여전히 하나를 제공하는 것이 유용합니다. (LSParser는 입력 소스에 사용 가능한 다른 입력이없는 경우에만 URI 참조로 식별되는 리소스를 가져 오려고 시도합니다.)</target>
        </trans-unit>
        <trans-unit id="c4a3303bba8bb8e092ba3f05afe26aab40de2240" translate="yes" xml:space="preserve">
          <source>The system identifier, a URI reference [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;], for this output destination.</source>
          <target state="translated">이 출력 대상에 대한 시스템 식별자, URI 참조 [ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="9ac19f96242350b7673acfdd7d4b02b017a83550" translate="yes" xml:space="preserve">
          <source>The system identifier, or null if none was supplied.</source>
          <target state="translated">시스템 식별자 또는 제공되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="9432be2aa85292b809c263d55400ca2c13bb187f" translate="yes" xml:space="preserve">
          <source>The system identifier.</source>
          <target state="translated">시스템 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="33154309f44b1f3e4b9b63aa2db5ffb66d8d5f1d" translate="yes" xml:space="preserve">
          <source>The system modules, which are the compiled definitions built in to the environment.</source>
          <target state="translated">환경에 내장 된 컴파일 된 정의 인 시스템 모듈.</target>
        </trans-unit>
        <trans-unit id="9ffce2da0a02206a57f77d7fbe2f3119028884ac" translate="yes" xml:space="preserve">
          <source>The system properties</source>
          <target state="translated">시스템 속성</target>
        </trans-unit>
        <trans-unit id="c60418fc7a6719a8685abc353065d31174ef68f2" translate="yes" xml:space="preserve">
          <source>The system property &lt;code&gt;&lt;span id=&quot;java.security.auth.login.config&quot;&gt;java.security.auth.login.config&lt;/span&gt;&lt;/code&gt; may also be set to a &lt;code&gt;URL&lt;/code&gt; pointing to another login configuration file (which is the case when a user uses the -D switch at runtime). If this property is defined, and its use is allowed by the security property file (the Security property,</source>
          <target state="translated">시스템 속성 &lt;code&gt;&lt;span id=&quot;java.security.auth.login.config&quot;&gt;java.security.auth.login.config&lt;/span&gt;&lt;/code&gt; 는 다른 로그인 구성 파일을 가리키는 &lt;code&gt;URL&lt;/code&gt; 로 설정 될 수도 있습니다 (사용자가 런타임에 -D 스위치를 사용하는 경우). 이 속성이 정의되어 있고 보안 속성 파일 (보안 속성,</target>
        </trans-unit>
        <trans-unit id="84fb25c617804e775187a1ef35381adde7a462d2" translate="yes" xml:space="preserve">
          <source>The system property that controls which Factory implementation to create is named &lt;code&gt;&quot;javax.xml.parsers.SAXParserFactory&quot;&lt;/code&gt;. This property names a class that is a concrete subclass of this abstract class. If no property is defined, a platform default will be used.</source>
          <target state="translated">생성 할 Factory 구현을 제어하는 ​​시스템 속성의 이름은 &lt;code&gt;&quot;javax.xml.parsers.SAXParserFactory&quot;&lt;/code&gt; 입니다. 이 속성은이 추상 클래스의 구체적인 하위 클래스 인 클래스의 이름을 지정합니다. 속성이 정의되지 않은 경우 플랫폼 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d513879bd2964703d8728b1b4c20e907f2382f9" translate="yes" xml:space="preserve">
          <source>The system property that determines which Factory implementation to create is named &lt;code&gt;&quot;javax.xml.transform.TransformerFactory&quot;&lt;/code&gt;. This property names a concrete subclass of the &lt;code&gt;TransformerFactory&lt;/code&gt; abstract class. If the property is not defined, a platform default is be used.</source>
          <target state="translated">작성할 팩토리 구현을 판별하는 시스템 특성은 &lt;code&gt;&quot;javax.xml.transform.TransformerFactory&quot;&lt;/code&gt; 로 명명 됩니다. 이 속성은 &lt;code&gt;TransformerFactory&lt;/code&gt; 추상 클래스 의 구체적인 하위 클래스 이름을 지정합니다 . 속성이 정의되지 않은 경우 플랫폼 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="305047c960aad4ed37ebc14427e984473ca4e5f9" translate="yes" xml:space="preserve">
          <source>The system property to override the system class loader is not examined until the VM is almost fully initialized. Code that executes this method during startup should take care not to cache the return value until the system is fully initialized.</source>
          <target state="translated">시스템 클래스 로더를 재정의하는 시스템 속성은 VM이 거의 완전히 초기화 될 때까지 검사되지 않습니다. 시작 중에이 메서드를 실행하는 코드는 시스템이 완전히 초기화 될 때까지 반환 값을 캐시하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f722c038ba46377c26c7b3d111ee938421ee539" translate="yes" xml:space="preserve">
          <source>The system property to specify the DOMImplementationSource class names.</source>
          <target state="translated">DOMImplementationSource 클래스 이름을 지정하는 시스템 속성입니다.</target>
        </trans-unit>
        <trans-unit id="78a2fb8c1adaa830a99ae7c2ad610a98649d150e" translate="yes" xml:space="preserve">
          <source>The system will probe the specified file to determine its keystore type and return a keystore implementation with its entries already loaded. When this approach is used there is no need to call the keystore's &lt;a href=&quot;#load(java.io.InputStream,char%5B%5D)&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">시스템은 지정된 파일을 조사하여 해당 키 저장소 유형을 결정하고 항목이 이미로드 된 키 저장소 구현을 반환합니다. 이 접근 방식을 사용하면 키 저장소의 &lt;a href=&quot;#load(java.io.InputStream,char%5B%5D)&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 메서드 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7923449f8c0c0791eb5aa081bc5a65fcb2555819" translate="yes" xml:space="preserve">
          <source>The system will return a keystore implementation for the default type.</source>
          <target state="translated">시스템은 기본 유형에 대한 키 저장소 구현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="00bc1824cf3bd5ca4947f7d237f20eddafbb842c" translate="yes" xml:space="preserve">
          <source>The system will return the most preferred implementation of the specified keystore type available in the environment.</source>
          <target state="translated">시스템은 환경에서 사용 가능한 지정된 키 저장소 유형의 가장 선호되는 구현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bf575b9617841369bd0654ef25dcbd4387d7d8b2" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 기본 이름 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="a94fecc52deafc39728c10e86b4031f2cc84b1c9" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience. This string contains a single character, namely &lt;a href=&quot;#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 기본 이름 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;a href=&quot;#separatorChar&quot;&gt; &lt;code&gt;separatorChar&lt;/code&gt; 가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="db9af4ad444ca84eeeac9fb19764f73c768a1db0" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character, represented as a string for convenience. This string contains a single character, namely &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 기본 이름 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;code&gt;&lt;a href=&quot;file#separatorChar&quot;&gt;&lt;code&gt;separatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="23edeff72c72b6eac94037a43840bbb8e7b551b6" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character.</source>
          <target state="translated">시스템 종속 기본 이름 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="06c823441fa92d743c30c7c0a19a1d4b758a3865" translate="yes" xml:space="preserve">
          <source>The system-dependent default name-separator character. This field is initialized to contain the first character of the value of the system property &lt;code&gt;file.separator&lt;/code&gt;. On UNIX systems the value of this field is &lt;code&gt;'/'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;'\\'&lt;/code&gt;.</source>
          <target state="translated">시스템에 따른 기본 이름 구분 문자입니다. 이 필드는 시스템 특성 &lt;code&gt;file.separator&lt;/code&gt; 값의 첫 문자를 포함하도록 초기화됩니다 . UNIX 시스템에서이 필드의 값은 &lt;code&gt;'/'&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 &lt;code&gt;'\\'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8793c76c9da5710b62dc7c9e42c8f2cdc86a36b3" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 경로 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="1f14bf8cb7ba1cb6fe8976b4d14659286d00de2c" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience. This string contains a single character, namely &lt;a href=&quot;#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 경로 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;a href=&quot;#pathSeparatorChar&quot;&gt; &lt;code&gt;pathSeparatorChar&lt;/code&gt; 가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a67c3801f69a10a5f6ee1400db51f1a4d991731c" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character, represented as a string for convenience. This string contains a single character, namely &lt;code&gt;&lt;a href=&quot;file#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">편의를 위해 문자열로 표시되는 시스템 종속 경로 구분 문자입니다. 이 문자열에는 단일 문자, 즉 &lt;code&gt;&lt;a href=&quot;file#pathSeparatorChar&quot;&gt;&lt;code&gt;pathSeparatorChar&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="56704d0b0a7bdab899863fa1d0c2f23658372f6a" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character.</source>
          <target state="translated">시스템 종속 경로 구분 문자입니다.</target>
        </trans-unit>
        <trans-unit id="79dc28fe296e6f9a3e10386e77dffcce367aaf90" translate="yes" xml:space="preserve">
          <source>The system-dependent path-separator character. This field is initialized to contain the first character of the value of the system property &lt;code&gt;path.separator&lt;/code&gt;. This character is used to separate filenames in a sequence of files given as a &lt;em&gt;path list&lt;/em&gt;. On UNIX systems, this character is &lt;code&gt;':'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;';'&lt;/code&gt;.</source>
          <target state="translated">시스템 종속 경로 구분 문자 이 필드는 시스템 특성 &lt;code&gt;path.separator&lt;/code&gt; 값의 첫 문자를 포함하도록 초기화됩니다 . 이 문자는 &lt;em&gt;경로 목록으로&lt;/em&gt; 지정된 파일 시퀀스에서 파일 이름을 구분하는 데 사용됩니다 . UNIX 시스템에서이 문자는 &lt;code&gt;':'&lt;/code&gt; 입니다 . Microsoft Windows 시스템에서는 &lt;code&gt;';'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="518a2fc9a68e3f3d5382e5d1a00ce498fcc2e594" translate="yes" xml:space="preserve">
          <source>The system-wide default AsynchronousChannel provider</source>
          <target state="translated">시스템 전체의 기본 AsynchronousChannel 제공자</target>
        </trans-unit>
        <trans-unit id="80f05d1a680abd50bb2023299790a44b63aaeab1" translate="yes" xml:space="preserve">
          <source>The system-wide default HttpServerProvider</source>
          <target state="translated">시스템 전체의 기본 HttpServerProvider</target>
        </trans-unit>
        <trans-unit id="0f461893764b32c9834282b1f614f9186ccf0cf0" translate="yes" xml:space="preserve">
          <source>The system-wide default provider is used by the static &lt;code&gt;open&lt;/code&gt; methods of the &lt;a href=&quot;../datagramchannel#open()&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../pipe#open()&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../selector#open()&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../serversocketchannel#open()&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../socketchannel#open()&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; classes. It is also used by the &lt;a href=&quot;../../../lang/system#inheritedChannel()&quot;&gt;&lt;code&gt;System.inheritedChannel()&lt;/code&gt;&lt;/a&gt; method. A program may make use of a provider other than the default provider by instantiating that provider and then directly invoking the &lt;code&gt;open&lt;/code&gt; methods defined in this class.</source>
          <target state="translated">시스템 전체의 기본 공급자는 &lt;a href=&quot;../datagramchannel#open()&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../pipe#open()&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../selector#open()&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../serversocketchannel#open()&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../socketchannel#open()&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt; 클래스 의 정적 &lt;code&gt;open&lt;/code&gt; 메서드에서 사용됩니다 . &lt;a href=&quot;../../../lang/system#inheritedChannel()&quot;&gt; &lt;code&gt;System.inheritedChannel()&lt;/code&gt; &lt;/a&gt; 메서드 에서도 사용됩니다 . 프로그램은 해당 공급자를 인스턴스화 한 다음 이 클래스에 정의 된 &lt;code&gt;open&lt;/code&gt; 메서드 를 직접 호출하여 기본 공급자가 아닌 다른 공급자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e7874d4b84773bdddf3caf1a22fc6b1ddcdb68c" translate="yes" xml:space="preserve">
          <source>The system-wide default provider is used by the static &lt;code&gt;open&lt;/code&gt; methods of the &lt;a href=&quot;../datagramchannel#open--&quot;&gt;&lt;code&gt;DatagramChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../pipe#open--&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../selector#open--&quot;&gt;&lt;code&gt;Selector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../serversocketchannel#open--&quot;&gt;&lt;code&gt;ServerSocketChannel&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../socketchannel#open--&quot;&gt;&lt;code&gt;SocketChannel&lt;/code&gt;&lt;/a&gt; classes. It is also used by the &lt;a href=&quot;../../../lang/system#inheritedChannel--&quot;&gt;&lt;code&gt;System.inheritedChannel()&lt;/code&gt;&lt;/a&gt; method. A program may make use of a provider other than the default provider by instantiating that provider and then directly invoking the &lt;code&gt;open&lt;/code&gt; methods defined in this class.</source>
          <target state="translated">시스템 전체의 기본 제공자는 &lt;a href=&quot;../datagramchannel#open--&quot;&gt; &lt;code&gt;DatagramChannel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../pipe#open--&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../selector#open--&quot;&gt; &lt;code&gt;Selector&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../serversocketchannel#open--&quot;&gt; &lt;code&gt;ServerSocketChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../socketchannel#open--&quot;&gt; &lt;code&gt;SocketChannel&lt;/code&gt; &lt;/a&gt; 클래스 의 정적 &lt;code&gt;open&lt;/code&gt; 메소드에서 사용됩니다 . &lt;a href=&quot;../../../lang/system#inheritedChannel--&quot;&gt; &lt;code&gt;System.inheritedChannel()&lt;/code&gt; &lt;/a&gt; 메서드 에서도 사용됩니다 . 프로그램은 해당 제공자를 인스턴스화 한 다음 이 클래스에 정의 된 &lt;code&gt;open&lt;/code&gt; 메소드 를 직접 호출하여 기본 제공자 이외의 제공자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1854b090241392edcc60935113761df6965da7c2" translate="yes" xml:space="preserve">
          <source>The system-wide default selector provider</source>
          <target state="translated">시스템 전체 기본 선택기 공급자</target>
        </trans-unit>
        <trans-unit id="95bf3ad30c8dc77c99ea4e641b49758e0b289c1f" translate="yes" xml:space="preserve">
          <source>The system-wide default values are retrieved at the time the &lt;code&gt;HttpClient&lt;/code&gt; instance is constructed. Changing the system-wide values after an &lt;code&gt;HttpClient&lt;/code&gt; instance has been built, for instance, by calling &lt;a href=&quot;../../../../java.base/java/net/proxyselector#setDefault(java.net.ProxySelector)&quot;&gt;&lt;code&gt;ProxySelector.setDefault(ProxySelector)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#setDefault(javax.net.ssl.SSLContext)&quot;&gt;&lt;code&gt;SSLContext.setDefault(SSLContext)&lt;/code&gt;&lt;/a&gt;, has no effect on already built instances.</source>
          <target state="translated">시스템 전체 기본값은 &lt;code&gt;HttpClient&lt;/code&gt; 인스턴스가 생성 될 때 검색됩니다 . 예를 들어 &lt;a href=&quot;../../../../java.base/java/net/proxyselector#setDefault(java.net.ProxySelector)&quot;&gt; &lt;code&gt;ProxySelector.setDefault(ProxySelector)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslcontext#setDefault(javax.net.ssl.SSLContext)&quot;&gt; &lt;code&gt;SSLContext.setDefault(SSLContext)&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;code&gt;HttpClient&lt;/code&gt; 인스턴스가 빌드 된 후 시스템 전체 값을 변경하는 것은 이미 빌드 된 인스턴스에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b245a40ab8beba1018593de4068b70324a8a9b7f" translate="yes" xml:space="preserve">
          <source>The systemID of the Result is implementation dependent.</source>
          <target state="translated">결과의 systemID는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="03cfd5043423fd52868491470982807b0134453d" translate="yes" xml:space="preserve">
          <source>The systemID that was set with &lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt;&lt;code&gt;setSystemId(java.lang.String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#setSystemId(java.lang.String)&quot;&gt; &lt;code&gt;setSystemId(java.lang.String)&lt;/code&gt; &lt;/a&gt; 로 설정된 시스템 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="a1045e7af40ef3b112d277437311ac29c399a948" translate="yes" xml:space="preserve">
          <source>The tab character (&lt;code&gt;'\u0009'&lt;/code&gt;)</source>
          <target state="translated">탭 문자 ( &lt;code&gt;'\u0009'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="724f41c531f5aa59b222eabf7abf5a6c43d9e2c4" translate="yes" xml:space="preserve">
          <source>The tab layout policy for wrapping tabs in multiple runs when all tabs will not fit within a single run.</source>
          <target state="translated">모든 탭이 단일 실행에 맞지 않을 때 여러 실행에서 탭을 래핑하는 탭 레이아웃 정책입니다.</target>
        </trans-unit>
        <trans-unit id="199233d8422b6532357239677c0d77118df3b357" translate="yes" xml:space="preserve">
          <source>The tab pane</source>
          <target state="translated">탭 창</target>
        </trans-unit>
        <trans-unit id="50f511f50ec79dac8854d97e6e1fc6b46ec9821b" translate="yes" xml:space="preserve">
          <source>The tab title can be rendered by a &lt;code&gt;Component&lt;/code&gt;. For example, the following produce similar results:</source>
          <target state="translated">탭 제목은 &lt;code&gt;Component&lt;/code&gt; 에서 렌더링 할 수 있습니다 . 예를 들어 다음은 유사한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="70b6d74a75747576812470d4e1829a1958e25ff9" translate="yes" xml:space="preserve">
          <source>The table below defines the mapping between XML Schema 1.0 date/time datatype fields and this class' fields. It also summarizes the value constraints for the date and time fields defined in &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D, &lt;i&gt;ISO 8601 Date and Time Formats&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">아래 표는 XML Schema 1.0 날짜 / 시간 데이터 유형 필드와이 클래스의 필드 간의 매핑을 정의합니다. 또한 &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D, &lt;i&gt;ISO 8601 Date and Time Formats에&lt;/i&gt;&lt;/a&gt; 정의 된 날짜 및 시간 필드에 대한 값 제약 조건을 요약합니다 .</target>
        </trans-unit>
        <trans-unit id="f62cb1c0c98a777d0a0d60bc177dbfdb331fdc8b" translate="yes" xml:space="preserve">
          <source>The table below defines the mapping between XML Schema 1.0 date/time datatype fields and this class' fields. It also summarizes the value constraints for the date and time fields defined in &lt;a href=&quot;https://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D, &lt;i&gt;ISO 8601 Date and Time Formats&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">아래 표는 XML Schema 1.0 날짜 / 시간 데이터 유형 필드와이 클래스의 필드 간의 매핑을 정의합니다. 또한 &lt;a href=&quot;https://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D, &lt;i&gt;ISO 8601 Date and Time Formats에&lt;/i&gt;&lt;/a&gt; 정의 된 날짜 및 시간 필드에 대한 값 제약 조건을 요약합니다 .</target>
        </trans-unit>
        <trans-unit id="956c09a6d0ea87af6414b81e63f37ed614bbe89f" translate="yes" xml:space="preserve">
          <source>The table below lists all the printing attributes. The table shows the tagging interfaces each attribute class implements in addition to interface &lt;a href=&quot;../attribute&quot;&gt; Attribute&lt;/a&gt;, thus indicating how each attribute is used in the API. For each doc attribute and print request attribute, the column marked &quot;SupportedValuesAttribute&quot; lists the supported-values attribute class, if any, with which a print service indicates the supported values for that attribute category.</source>
          <target state="translated">아래 표에는 모든 인쇄 속성이 나열되어 있습니다. 이 테이블은 &lt;a href=&quot;../attribute&quot;&gt;Attribute 속성&lt;/a&gt; 외에도 각 속성 클래스가 구현하는 태깅 인터페이스를 보여줍니다. 따라서 각 속성이 API에서 사용되는 방식을 나타냅니다. 각 doc 속성 및 인쇄 요청 속성에 대해 &quot;SupportedValuesAttribute&quot;로 표시된 열은 지원되는 값 속성 클래스를 나열합니다 (있는 경우). 인쇄 서비스가 해당 속성 범주에 대해 지원되는 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="287f71a5c4a7b8e7e0742c0ff2ef999a33855d9e" translate="yes" xml:space="preserve">
          <source>The table below lists possible effective values if a certain capability is requested, i.e.</source>
          <target state="translated">아래 표에는 특정 기능이 요청 된 경우 가능한 유효 값이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ad0b41961955c4da9313672d35116b01778502" translate="yes" xml:space="preserve">
          <source>The table below shows the access modes of a &lt;code&gt;Lookup&lt;/code&gt; produced by any of the following factory or transformation methods:</source>
          <target state="translated">아래 표 는 다음 팩토리 또는 변환 방법으로 생성 된 &lt;code&gt;Lookup&lt;/code&gt; 의 액세스 모드를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="cf06ceead298594cb308f75d4760c64b1d7032fe" translate="yes" xml:space="preserve">
          <source>The table below shows the effects of specifying a Chromaticity attribute of &lt;a href=&quot;#MONOCHROME&quot;&gt;&lt;code&gt;MONOCHROME&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#COLOR&quot;&gt;&lt;code&gt;COLOR&lt;/code&gt;&lt;/a&gt; for a monochrome or color document.</source>
          <target state="translated">아래 표 는 단색 또는 컬러 문서에 대해 &lt;a href=&quot;#MONOCHROME&quot;&gt; &lt;code&gt;MONOCHROME&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#COLOR&quot;&gt; &lt;code&gt;COLOR&lt;/code&gt; &lt;/a&gt; 의 색도 속성을 지정했을 때의 효과를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="93b17809af88bed6b165bc41c7cce6b651c3dd33" translate="yes" xml:space="preserve">
          <source>The table below shows the effects of specifying a Chromaticity attribute of &lt;a href=&quot;chromaticity#MONOCHROME&quot;&gt;&lt;code&gt;MONOCHROME&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;chromaticity#COLOR&quot;&gt;&lt;code&gt;COLOR&lt;/code&gt;&lt;/a&gt; for a monochrome or color document.</source>
          <target state="translated">아래 표 는 단색 또는 컬러 문서에 대해 &lt;a href=&quot;chromaticity#MONOCHROME&quot;&gt; &lt;code&gt;MONOCHROME&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;chromaticity#COLOR&quot;&gt; &lt;code&gt;COLOR&lt;/code&gt; &lt;/a&gt; 의 색도 속성을 지정하는 효과를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6550573ca0506c03709606c1bdd17da7666522cf" translate="yes" xml:space="preserve">
          <source>The table below summarizes which kind of annotation presence different methods in this interface examine.</source>
          <target state="translated">아래 표는이 인터페이스에서 어떤 종류의 주석이 다른 방법으로 검사되는지 요약합니다.</target>
        </trans-unit>
        <trans-unit id="0785827f1aca709e13a4cfacab1b11dec6fe1d51" translate="yes" xml:space="preserve">
          <source>The table draws horizontal lines between cells if &lt;code&gt;showHorizontalLines&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;showHorizontalLines&lt;/code&gt; 가 true 인 경우 테이블 은 셀 사이에 수평선을 그립니다 .</target>
        </trans-unit>
        <trans-unit id="cc764edbccef2f5a651977b7ffdec182e128fba7" translate="yes" xml:space="preserve">
          <source>The table draws vertical lines between cells if &lt;code&gt;showVerticalLines&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;showVerticalLines&lt;/code&gt; 가 true 인 경우 테이블은 셀 사이에 수직선을 그립니다 .</target>
        </trans-unit>
        <trans-unit id="d46376b57361e34cc862402a3ff75bfa5957b99c" translate="yes" xml:space="preserve">
          <source>The table for which this object is the header; the default is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 개체가 헤더 인 테이블입니다. 기본값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="affe517f34332866171ca57d9e9e5b23870e7f83" translate="yes" xml:space="preserve">
          <source>The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional &lt;code&gt;
 initialCapacity&lt;/code&gt; constructor argument. An additional optional &lt;code&gt;loadFactor&lt;/code&gt; constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected &lt;code&gt;concurrencyLevel&lt;/code&gt; as an additional hint for internal sizing. Note that using many keys with exactly the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">충돌이 너무 많으면 (즉, 고유 한 해시 코드가 있지만 테이블 크기의 모듈로 동일한 슬롯에 속하는 키) 테이블은 동적으로 확장되며 매핑 당 대략 2 개의 빈을 유지하는 예상 평균 효과 (0.75로드에 해당) 크기 조정을위한 요소 임계 값). 매핑이 추가 및 제거됨에 따라이 평균 주변에 많은 차이가있을 수 있지만 전반적으로 해시 테이블에 대해 일반적으로 허용되는 시간 / 공간 균형을 유지합니다. 그러나이 테이블이나 다른 종류의 해시 테이블 크기를 조정하는 작업은 비교적 느릴 수 있습니다. 가능하면 선택적인 &lt;code&gt; initialCapacity&lt;/code&gt; 생성자 인수 로 크기 추정치를 제공하는 것이 좋습니다 . 추가 옵션 인 &lt;code&gt;loadFactor&lt;/code&gt; constructor 인수는 주어진 요소 수에 할당 할 공간의 양을 계산하는 데 사용할 테이블 밀도를 지정하여 초기 테이블 용량을 사용자 정의하는 추가 수단을 제공합니다. 또한이 클래스의 이전 버전과의 호환성을 위해 생성자는 내부 크기 조정을위한 추가 힌트로 예상되는 &lt;code&gt;concurrencyLevel&lt;/code&gt; 을 선택적으로 지정할 수 있습니다 . 정확히 동일한 &lt;code&gt;hashCode()&lt;/code&gt; 가진 많은 키를 사용 하는 것은 해시 테이블의 성능을 저하시키는 확실한 방법입니다. 영향을 개선하기 위해 키가 &lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 일 때이 클래스는 키 간의 비교 순서를 사용하여 관계를 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abdfbcd8569ed822dbb9b0566e80bdcdfb0ce663" translate="yes" xml:space="preserve">
          <source>The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional &lt;code&gt;initialCapacity&lt;/code&gt; constructor argument. An additional optional &lt;code&gt;loadFactor&lt;/code&gt; constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected &lt;code&gt;concurrencyLevel&lt;/code&gt; as an additional hint for internal sizing. Note that using many keys with exactly the same &lt;code&gt;hashCode()&lt;/code&gt; is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt;, this class may use comparison order among keys to help break ties.</source>
          <target state="translated">충돌이 너무 많으면 (예 : 별개의 해시 코드가 있지만 테이블 크기가 같은 슬롯에 해당하는 키) 테이블이 동적으로 확장됩니다 (매핑 당 약 2 개의 빈을 유지하는 예상 평균 효과 (0.75로드에 해당) 크기 조정을위한 요인 임계 값). 매핑이 추가 및 제거 될 때이 평균 주위에 많은 차이가있을 수 있지만 전반적으로 해시 테이블에 대해 일반적으로 허용되는 시간 / 공간 균형을 유지합니다. 그러나이 또는 다른 종류의 해시 테이블 크기를 조정하면 작업 속도가 느려질 수 있습니다. 가능한 경우 크기 추정값을 선택적 &lt;code&gt;initialCapacity&lt;/code&gt; 생성자 인수 로 제공하는 것이 좋습니다 . 추가 옵션 인 &lt;code&gt;loadFactor&lt;/code&gt; 생성자 인수는 주어진 요소 수에 할당 할 공간의 양을 계산하는 데 사용할 테이블 밀도를 지정하여 초기 테이블 용량을 사용자 정의하는 추가 수단을 제공합니다. 또한이 클래스의 이전 버전과의 호환성을 위해 생성자는 내부 크기 조정에 대한 추가 힌트로 예상되는 &lt;code&gt;concurrencyLevel&lt;/code&gt; 수준을 선택적으로 지정할 수 있습니다 . 정확히 같은 &lt;code&gt;hashCode()&lt;/code&gt; 가진 많은 키를 사용 하는 것은 해시 테이블의 성능을 저하시키는 확실한 방법입니다. 키가 &lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 일 때 영향을 개선하기 위해이 클래스는 키 간 비교 순서를 사용하여 연결을 끊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="807c7f2278f08fd9a560612599a053ac4a77aa0b" translate="yes" xml:space="preserve">
          <source>The table of key properties.</source>
          <target state="translated">주요 속성 테이블.</target>
        </trans-unit>
        <trans-unit id="29c2e665a3b18a1ce29ba700eb12bfe8ef2d57b7" translate="yes" xml:space="preserve">
          <source>The table type is:</source>
          <target state="translated">테이블 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e72d6ec95379480e6ddcff8a30f3ae018d25f5a5" translate="yes" xml:space="preserve">
          <source>The table will query the &lt;code&gt;TableModel&lt;/code&gt; to build the default set of columns if this is true.</source>
          <target state="translated">이것이 참인 경우 테이블은 &lt;code&gt;TableModel&lt;/code&gt; 을 쿼리하여 기본 열 집합을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="4b683043db5214bb3bb29c225b881df7d62a7411" translate="yes" xml:space="preserve">
          <source>The tag number.</source>
          <target state="translated">태그 번호.</target>
        </trans-unit>
        <trans-unit id="e3034177648d7a592ed4b995252076ff2a379e97" translate="yes" xml:space="preserve">
          <source>The tag values for this property. May be null if this property cannot be represented as a tagged value.</source>
          <target state="translated">이 프로퍼티의 태그 치입니다. 이 속성을 태그 값으로 나타낼 수없는 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b446899d309ae9229be1541a42b9d0cf00a0ac6b" translate="yes" xml:space="preserve">
          <source>The target and cleanup must return the same type, even if the cleanup always throws. To create such a throwing cleanup, compose the cleanup logic with &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">대상 및 정리는 정리가 항상 발생하더라도 동일한 유형을 반환해야합니다. 이러한 던지는 정리 를 생성하려면 올바른 반환 유형의 메서드 핸들을 생성하기 위해 &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; 으로&lt;/a&gt; 정리 논리를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="02cefdef6f6fd1cf2781c5dd156f06c3b67ffe8b" translate="yes" xml:space="preserve">
          <source>The target and fallback must be of exactly the same method type, and the resulting combined method handle will also be of this type.</source>
          <target state="translated">대상과 폴백은 정확히 동일한 메소드 유형이어야하며 결과 결합 된 메소드 핸들도이 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="f42cc55413084526e1a3b93e74bf70c3317cb6fa" translate="yes" xml:space="preserve">
          <source>The target and handler must have the same corresponding argument and return types, except that handler may omit trailing arguments (similarly to the predicate in &lt;a href=&quot;#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)&quot;&gt;&lt;code&gt;guardWithTest&lt;/code&gt;&lt;/a&gt;). Also, the handler must have an extra leading parameter of &lt;code&gt;exType&lt;/code&gt; or a supertype.</source>
          <target state="translated">대상 및 핸들러는 핸들러가 후행 인수를 생략 할 수 있다는 점을 제외하고 동일한 대응 인수 및 리턴 유형을 &lt;a href=&quot;#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)&quot;&gt; &lt;code&gt;guardWithTest&lt;/code&gt; &lt;/a&gt; 의 술어와 유사 함 ). 또한 핸들러에는 &lt;code&gt;exType&lt;/code&gt; 또는 상위 유형 의 추가 선행 매개 변수가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cfe18dce3e23910cc798ebbf8a13a2dd958ea48f" translate="yes" xml:space="preserve">
          <source>The target and handler must have the same corresponding argument and return types, except that handler may omit trailing arguments (similarly to the predicate in &lt;a href=&quot;methodhandles#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-&quot;&gt;&lt;code&gt;guardWithTest&lt;/code&gt;&lt;/a&gt;). Also, the handler must have an extra leading parameter of &lt;code&gt;exType&lt;/code&gt; or a supertype.</source>
          <target state="translated">핸들러가 후행 인수를 생략 할 수 있다는 점을 제외하고 대상 및 핸들러는 동일한 해당 인수 및 리턴 유형을 &lt;a href=&quot;methodhandles#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-&quot;&gt; &lt;code&gt;guardWithTest&lt;/code&gt; &lt;/a&gt; 의 술어와 유사 ). 또한 핸들러에는 &lt;code&gt;exType&lt;/code&gt; 또는 supertype 의 추가 선행 매개 변수가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e01418ac4cb37a5ae8fb9a819eaaca5266eb99c3" translate="yes" xml:space="preserve">
          <source>The target and handler must return the same type, even if the handler always throws. (This might happen, for instance, because the handler is simulating a &lt;code&gt;finally&lt;/code&gt; clause). To create such a throwing handler, compose the handler creation logic with &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">대상과 핸들러는 핸들러가 항상 throw하더라도 동일한 유형을 반환해야합니다. (예를 들어 핸들러가 &lt;code&gt;finally&lt;/code&gt; 절을 시뮬레이션하고 있기 때문에 이런 일이 발생할 수 있습니다 .) 이러한 throwing 핸들러 를 생성하려면 올바른 반환 유형의 메서드 핸들을 생성하기 위해 &lt;a href=&quot;#throwException(java.lang.Class,java.lang.Class)&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; 으로&lt;/a&gt; 핸들러 생성 로직을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="44e11701adb06063c652521aa85aae71912799bf" translate="yes" xml:space="preserve">
          <source>The target and handler must return the same type, even if the handler always throws. (This might happen, for instance, because the handler is simulating a &lt;code&gt;finally&lt;/code&gt; clause). To create such a throwing handler, compose the handler creation logic with &lt;a href=&quot;methodhandles#throwException-java.lang.Class-java.lang.Class-&quot;&gt;&lt;code&gt;throwException&lt;/code&gt;&lt;/a&gt;, in order to create a method handle of the correct return type.</source>
          <target state="translated">핸들러가 항상 발생하더라도 대상과 핸들러는 동일한 유형을 리턴해야합니다. (예를 들어, 핸들러가 &lt;code&gt;finally&lt;/code&gt; 절을 시뮬레이션하기 때문에 이런 일이 발생할 수 있습니다 ). 이러한 처리 핸들러를 작성 하려면 올바른 리턴 유형의 메소드 핸들을 작성하기 위해 처리기 작성 로직을 &lt;a href=&quot;methodhandles#throwException-java.lang.Class-java.lang.Class-&quot;&gt; &lt;code&gt;throwException&lt;/code&gt; &lt;/a&gt; 으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a4a57d45fa595fa9efff16f036716b6ca28a789a" translate="yes" xml:space="preserve">
          <source>The target class must be a proper class, not a primitive or array class. (Thus, &lt;code&gt;M2&lt;/code&gt; is well-defined.)</source>
          <target state="translated">대상 클래스는 기본 또는 배열 클래스가 아닌 적절한 클래스 여야합니다. (따라서 &lt;code&gt;M2&lt;/code&gt; 는 잘 정의되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="6331eb65cfaeb17d610de47a1492d63404554822" translate="yes" xml:space="preserve">
          <source>The target component.</source>
          <target state="translated">대상 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a48909c6d391288fca7020961e9c52b23bc4c69d" translate="yes" xml:space="preserve">
          <source>The target component. This indicates the component over which the event occurred or with which the event is associated. This object has been replaced by AWTEvent.getSource()</source>
          <target state="translated">대상 구성 요소입니다. 이벤트가 발생한 구성 요소 또는 이벤트와 관련된 구성 요소를 나타냅니다. 이 객체는 AWTEvent.getSource ()로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="41cfd1c3c3da57cda5880021b389e8ff6e52178e" translate="yes" xml:space="preserve">
          <source>The target data line can be obtained from a mixer by invoking the &lt;a href=&quot;mixer#getLine(javax.sound.sampled.Line.Info)&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;Mixer&lt;/code&gt; with an appropriate &lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">적절한 &lt;a href=&quot;dataline.info&quot;&gt; &lt;code&gt;DataLine.Info&lt;/code&gt; &lt;/a&gt; 개체를 사용하여 &lt;code&gt;Mixer&lt;/code&gt; 의 &lt;a href=&quot;mixer#getLine(javax.sound.sampled.Line.Info)&quot;&gt; &lt;code&gt;getLine&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 믹서에서 대상 데이터 라인을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="294becfa926713ae4f4611aad1c89088d4f17efe" translate="yes" xml:space="preserve">
          <source>The target data line can be obtained from a mixer by invoking the &lt;code&gt;&lt;a href=&quot;mixer#getLine-javax.sound.sampled.Line.Info-&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method of &lt;code&gt;Mixer&lt;/code&gt; with an appropriate &lt;code&gt;&lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">목표 데이터 라인은 호출하여 믹서로부터 얻어 질 수 &lt;code&gt;&lt;a href=&quot;mixer#getLine-javax.sound.sampled.Line.Info-&quot;&gt;&lt;code&gt;getLine&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 방법 &lt;code&gt;Mixer&lt;/code&gt; 적절한으로 &lt;code&gt;&lt;a href=&quot;dataline.info&quot;&gt;&lt;code&gt;DataLine.Info&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 의 개체.</target>
        </trans-unit>
        <trans-unit id="2e92be738dd320065c504e7c597383304da41f9b" translate="yes" xml:space="preserve">
          <source>The target format represents the format of the processed, converted audio data. This is the format of the data that can be read from the stream returned by one of the &lt;code&gt;getAudioInputStream&lt;/code&gt; methods.</source>
          <target state="translated">대상 형식은 처리 된 변환 된 오디오 데이터의 형식을 나타냅니다. &lt;code&gt;getAudioInputStream&lt;/code&gt; 메소드 중 하나가 리턴 한 스트림에서 읽을 수있는 데이터 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="e7de801befb3afea6c0cedebce5ac02cc3cf8db7" translate="yes" xml:space="preserve">
          <source>The target handle has the parameter type list &lt;code&gt;S..., M...&lt;/code&gt;, with as many types in &lt;code&gt;S&lt;/code&gt; as indicated by &lt;code&gt;skip&lt;/code&gt;. The &lt;code&gt;M&lt;/code&gt; types are those that are supposed to match part of the given type list, &lt;code&gt;newTypes&lt;/code&gt;.</source>
          <target state="translated">대상 핸들에는 매개 변수 유형 목록 &lt;code&gt;S..., M...&lt;/code&gt; 있으며 &lt;code&gt;S&lt;/code&gt; 에는 &lt;code&gt;skip&lt;/code&gt; 으로 표시된 만큼 많은 유형이 있습니다 . &lt;code&gt;M&lt;/code&gt; 의 유형은 주어진 유형 목록의 일부와 일치 해야하는 것들이다 &lt;code&gt;newTypes&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="03b0fb3903bf8315a0952c04b4865416cb3c9b29" translate="yes" xml:space="preserve">
          <source>The target height to scale the image.</source>
          <target state="translated">이미지 크기를 조정할 대상 높이입니다.</target>
        </trans-unit>
        <trans-unit id="61ee1882c6fbd7985ddaac74fcc91b429f418e8c" translate="yes" xml:space="preserve">
          <source>The target name is of the form &quot;&lt;code&gt;className#member[objectName]&lt;/code&gt;&quot; where each part is optional. It must not be empty or null.</source>
          <target state="translated">대상 이름은 &quot; &lt;code&gt;className#member[objectName]&lt;/code&gt; &quot;형식이며 각 부분은 선택 사항입니다. 비어 있거나 null이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="2088b56d56c4f4d92fcefb476718d183cc8ee0fb" translate="yes" xml:space="preserve">
          <source>The target name is the &lt;a href=&quot;inquiretype&quot;&gt;&lt;code&gt;InquireType&lt;/code&gt;&lt;/a&gt; allowed.</source>
          <target state="translated">대상 이름은 허용 되는 &lt;a href=&quot;inquiretype&quot;&gt; &lt;code&gt;InquireType&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce62a8e103e81312eae100e20ed400ca3da9c713" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the &lt;code&gt;AuthPermission&lt;/code&gt; object is used to guard access to the &lt;a href=&quot;subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;login/logincontext&quot;&gt;&lt;code&gt;LoginContext&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;login/configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 &lt;code&gt;AuthPermission&lt;/code&gt; 객체는 &lt;a href=&quot;subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;login/logincontext&quot;&gt; &lt;code&gt;LoginContext&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;login/configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 객체에 대한 액세스를 보호하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c855fc5f9080ecc03acfbcb7e0983b870dcc2a70" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the &lt;code&gt;SecurityPermission&lt;/code&gt; object is used to guard access to the &lt;a href=&quot;accesscontrolcontext&quot;&gt;&lt;code&gt;AccessControlContext&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;provider&quot;&gt;&lt;code&gt;Provider&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;security&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;signer&quot;&gt;&lt;code&gt;Signer&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;identity&quot;&gt;&lt;code&gt;Identity&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 &lt;code&gt;SecurityPermission&lt;/code&gt; 객체는 &lt;a href=&quot;accesscontrolcontext&quot;&gt; &lt;code&gt;AccessControlContext&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;provider&quot;&gt; &lt;code&gt;Provider&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;security&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;signer&quot;&gt; &lt;code&gt;Signer&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;identity&quot;&gt; &lt;code&gt;Identity&lt;/code&gt; &lt;/a&gt; 객체에 대한 액세스를 보호하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7928d48cbde0bd5806a16e749b843ab056e2bff2" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the AuthPermission object is used to guard access to the Policy, Subject, LoginContext, and Configuration objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 AuthPermission 오브젝트는 Policy, Subject, LoginContext 및 Configuration 오브젝트에 대한 액세스를 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2890f709a91749b2fe10e52fd580bddb149e0444" translate="yes" xml:space="preserve">
          <source>The target name is the name of a security configuration parameter (see below). Currently the SecurityPermission object is used to guard access to the Policy, Security, Provider, Signer, and Identity objects.</source>
          <target state="translated">대상 이름은 보안 구성 매개 변수의 이름입니다 (아래 참조). 현재 SecurityPermission 오브젝트는 Policy, Security, Provider, Signer 및 Identity 오브젝트에 대한 액세스를 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17f38fb0c6986e5e7a83073a2ad1774730542b07" translate="yes" xml:space="preserve">
          <source>The target name is the name of the AWT permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk could be used to represent all AWT permissions.</source>
          <target state="translated">대상 이름은 AWT 권한의 이름입니다 (아래 참조). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 모든 AWT 권한을 나타내는 데 별표를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e139ec2f3c65e0160a69e0966a9e12f3721fc07" translate="yes" xml:space="preserve">
          <source>The target name is the name of the Serializable permission (see below).</source>
          <target state="translated">대상 이름은 Serializable 권한의 이름입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="1d4510b6174912a740c895643371245def2a4d9e" translate="yes" xml:space="preserve">
          <source>The target name is the name of the audio permission (see the table below). The names follow the hierarchical property-naming convention. Also, an asterisk can be used to represent all the audio permissions.</source>
          <target state="translated">대상 이름은 오디오 권한의 이름입니다 (아래 표 참조). 이름은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표를 사용하여 모든 오디오 권한을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8645249d279e7c3cf29a83a9b3bb1e507d282b4" translate="yes" xml:space="preserve">
          <source>The target name is the name of the authorization principal classname followed by a period and the authorization principal name, that is &lt;code&gt;&quot;&lt;em&gt;PrincipalClassName&lt;/em&gt;.&lt;em&gt;PrincipalName&lt;/em&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">대상 이름은 권한 부여 주체 클래스 이름의 이름 뒤에 마침표와 권한 부여 주체 이름 ( &lt;code&gt;&quot;&lt;em&gt;PrincipalClassName&lt;/em&gt;.&lt;em&gt;PrincipalName&lt;/em&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1de21a429ece939c67b7e50829885099ad2d45eb" translate="yes" xml:space="preserve">
          <source>The target name is the name of the network permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;foo.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*foo&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">대상 이름은 네트워크 권한의 이름입니다 (아래 참조). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어 &quot;foo. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* foo&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35aa664b77bc8ac5af633fd3abfe001e77f837cd" translate="yes" xml:space="preserve">
          <source>The target name is the name of the runtime permission (see below). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;loadLibrary.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*loadLibrary&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">대상 이름은 런타임 권한의 이름입니다 (아래 참조). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어 &quot;loadLibrary. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* loadLibrary&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d958abd00740d8b81aa7e7e8a7237d717e401b13" translate="yes" xml:space="preserve">
          <source>The target name of this &lt;code&gt;Permission&lt;/code&gt; specifies a Credential class name, and a Set of Principals. The only valid value for this Permission's actions is, &quot;read&quot;. The target name must abide by the following syntax:</source>
          <target state="translated">이 &lt;code&gt;Permission&lt;/code&gt; 의 대상 이름은 자격 증명 클래스 이름과 프린시 펄 세트를 지정합니다. 이 권한 작업에 유효한 값은 &quot;읽기&quot;뿐입니다. 대상 이름은 다음 구문을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="91a399d1980f8a6ccc96217289bf0be48ee37eb6" translate="yes" xml:space="preserve">
          <source>The target name of this &lt;code&gt;Permission&lt;/code&gt; specifies a pair of kerberos service principals. The first is the subordinate service principal being entrusted to use the TGT. The second service principal designates the target service the subordinate service principal is to interact with on behalf of the initiating KerberosPrincipal. This latter service principal is specified to restrict the use of a proxiable ticket.</source>
          <target state="translated">이 &lt;code&gt;Permission&lt;/code&gt; 의 대상 이름은 한 쌍의 Kerberos 서비스 주체를 지정합니다. 첫 번째는 TGT를 사용하도록 위임 된 하위 서비스 주체입니다. 두 번째 서비스 주체는 하위 서비스 주체가 시작 KerberosPrincipal을 대신하여 상호 작용할 대상 서비스를 지정합니다. 후자의 서비스 주체는 프록시 가능한 티켓의 사용을 제한하도록 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a69bc10fa3486dc0c871c21c9260fdc72fa60465" translate="yes" xml:space="preserve">
          <source>The target of the symbolic link</source>
          <target state="translated">심볼릭 링크의 대상</target>
        </trans-unit>
        <trans-unit id="2c722da0815ce9e96b3f893e4617b9ba63277f4a" translate="yes" xml:space="preserve">
          <source>The target of this processing instruction.</source>
          <target state="translated">이 처리 명령의 대상입니다.</target>
        </trans-unit>
        <trans-unit id="161ea52ef7deec6ab2b397da40779879d17b9eba" translate="yes" xml:space="preserve">
          <source>The target of this processing instruction. XML defines this as being the first token following the markup that begins the processing instruction.</source>
          <target state="translated">이 처리 명령의 대상입니다. XML은이를 처리 명령을 시작하는 마크 업 다음의 첫 번째 토큰으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0fba2a96aca3512f3b2fa2ec8c997febf4ea99a4" translate="yes" xml:space="preserve">
          <source>The target property may also be &quot;qualified&quot; with an arbitrary number of property prefixs delimited with the &quot;.&quot; character. For example, the following action listener:</source>
          <target state="translated">대상 속성은 &quot;.&quot;로 구분 된 임의의 수의 속성 접두사를 사용하여 &quot;자격을 갖춘&quot;것일 수도 있습니다. 캐릭터. 예를 들어, 다음 조치 리스너 :</target>
        </trans-unit>
        <trans-unit id="1d3891a04d782b20001436f81be88566164c49f9" translate="yes" xml:space="preserve">
          <source>The target screen mentioned below is a screen to which the window should be placed after the setLocationRelativeTo method is called.</source>
          <target state="translated">아래에 언급 된 대상 화면은 setLocationRelativeTo 메소드가 호출 된 후 윈도우가 배치되어야하는 화면입니다.</target>
        </trans-unit>
        <trans-unit id="c97110c6e47104527f8b4580cb3b4fa2f5426ed0" translate="yes" xml:space="preserve">
          <source>The target section of the processing instruction</source>
          <target state="translated">처리 명령의 대상 섹션</target>
        </trans-unit>
        <trans-unit id="8a356eae8e68f37248d1a45a231f374ef9c3a79c" translate="yes" xml:space="preserve">
          <source>The target string buffer</source>
          <target state="translated">대상 문자열 버퍼</target>
        </trans-unit>
        <trans-unit id="ce314a2a38875a9da27cad30daa60b7f939567ca" translate="yes" xml:space="preserve">
          <source>The target string builder</source>
          <target state="translated">대상 문자열 작성기</target>
        </trans-unit>
        <trans-unit id="5623b00860faa00ef9ff1fd5929f824daae38f10" translate="yes" xml:space="preserve">
          <source>The target virtual machine can maintain a list of properties on behalf of agents. The manner in which this is done, the names of the properties, and the types of values that are allowed, is implementation specific. Agent properties are typically used to store communication end-points and other agent configuration details. For example, a debugger agent might create an agent property for its transport address.</source>
          <target state="translated">대상 가상 머신은 에이전트를 대신하여 속성 목록을 유지할 수 있습니다. 이 작업이 수행되는 방식, 속성 이름 및 허용되는 값 유형은 구현에 따라 다릅니다. 에이전트 속성은 일반적으로 통신 끝점 및 기타 에이전트 구성 세부 정보를 저장하는 데 사용됩니다. 예를 들어 디버거 에이전트는 전송 주소에 대한 에이전트 속성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90b7bab6e96d93a1672aed421456af62833a888b" translate="yes" xml:space="preserve">
          <source>The target width to scale the image.</source>
          <target state="translated">이미지 크기를 조정할 대상 너비입니다.</target>
        </trans-unit>
        <trans-unit id="0a63b487811a4aecdd285055ad083a6242c879eb" translate="yes" xml:space="preserve">
          <source>The task is &lt;a href=&quot;future#cancel(boolean)&quot;&gt;explicitly cancelled&lt;/a&gt; via the returned future.</source>
          <target state="translated">반환 된 미래를 통해 작업이 &lt;a href=&quot;future#cancel(boolean)&quot;&gt;명시 적으로 취소&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ac13bf867264e56e3d64038eb74fe1bea028918f" translate="yes" xml:space="preserve">
          <source>The tc &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= tc &amp;lt;=
 255&lt;/code&gt; or an IllegalArgumentException will be thrown.</source>
          <target state="translated">tc &lt;b&gt;는 &lt;/b&gt; &lt;code&gt;0 &amp;lt;= tc &amp;lt;= 255&lt;/code&gt; 범위에 &lt;b&gt;있어야합니다.&lt;/b&gt; 그렇지 않으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="351d171d0044484a95b6580add4a8d56a0b09177" translate="yes" xml:space="preserve">
          <source>The tempo-based timing type, for which the resolution is expressed in pulses (ticks) per quarter note.</source>
          <target state="translated">해상도가 1/4 음당 펄스 (틱)로 표시되는 템포 기반 타이밍 유형입니다.</target>
        </trans-unit>
        <trans-unit id="92a16bca2794be2e4d981e961e77157c978a16e0" translate="yes" xml:space="preserve">
          <source>The term &quot;blit&quot; is the pronounced version of the PDP-10 BLT (BLock Transfer) instruction, which copied a block of bits. (In case you were curious.)</source>
          <target state="translated">&quot;blit&quot;이라는 용어는 비트 블록을 복사 한 PDP-10 BLT (BLock Transfer) 명령의 발음 버전입니다. (호기심이 많을 경우)</target>
        </trans-unit>
        <trans-unit id="f2ec5ccb70e544f59fa930934598819b7960048f" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;directly present&lt;/em&gt;, &lt;em&gt;indirectly present&lt;/em&gt;, &lt;em&gt;present&lt;/em&gt;, and &lt;em&gt;associated&lt;/em&gt; are used throughout this interface to describe precisely which annotations are returned by methods:</source>
          <target state="translated">용어 &lt;em&gt;직접 본&lt;/em&gt; , &lt;em&gt;간접적으로 본&lt;/em&gt; , &lt;em&gt;본&lt;/em&gt; 과 &lt;em&gt;연관된은&lt;/em&gt; 정확하게 주석 방법에 의해 반환되는 기술이 인터페이스에 걸쳐 사용된다 :</target>
        </trans-unit>
        <trans-unit id="7bc919453997f5f639ef67c31f748841da8f874b" translate="yes" xml:space="preserve">
          <source>The text attributes.</source>
          <target state="translated">텍스트 속성.</target>
        </trans-unit>
        <trans-unit id="5e5bbe231cb2211cfe2a7c06f4bc2ee771bc88c2" translate="yes" xml:space="preserve">
          <source>The text boundary returned from the above methods, first or last text boundary.</source>
          <target state="translated">위 방법에서 반환 된 텍스트 경계, 첫 번째 또는 마지막 텍스트 경계.</target>
        </trans-unit>
        <trans-unit id="8858d11b87b0f0a3e19ee86a888321a1258f017b" translate="yes" xml:space="preserve">
          <source>The text components have a model-view split. A text component pulls together the objects used to represent the model, view, and controller. The text document model may be shared by other views which act as observers of the model (e.g. a document may be shared by multiple components).</source>
          <target state="translated">텍스트 구성 요소에는 모델보기 분할이 있습니다. 텍스트 구성 요소는 모델,보기 및 컨트롤러를 나타내는 데 사용되는 개체를 함께 가져옵니다. 텍스트 문서 모델은 모델의 관찰자 역할을하는 다른 뷰에 의해 공유 될 수 있습니다 (예 : 문서가 여러 구성 요소에 의해 공유 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="9f88b97ebbe499c00fc788624ded865b62c2d07e" translate="yes" xml:space="preserve">
          <source>The text components support flexible and internationalized text input, using keymaps and the input method framework, while maintaining compatibility with the AWT listener model.</source>
          <target state="translated">텍스트 구성 요소는 AWT 리스너 모델과의 호환성을 유지하면서 키맵 및 입력 방법 프레임 워크를 사용하여 유연하고 국제화 된 텍스트 입력을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="535d6291a5e7978acac55699afbcc43c1abcfcca" translate="yes" xml:space="preserve">
          <source>The text contained within the option element.</source>
          <target state="translated">옵션 요소에 포함 된 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="bb4bc96683614ed09586bda7da975dbd546cc010" translate="yes" xml:space="preserve">
          <source>The text cursor type.</source>
          <target state="translated">텍스트 커서 유형입니다.</target>
        </trans-unit>
        <trans-unit id="792c37abc4943eebd3bef907dbd09262f47b21d8" translate="yes" xml:space="preserve">
          <source>The text editing component also has to provide an input method event listener.</source>
          <target state="translated">텍스트 편집 구성 요소는 입력 메서드 이벤트 리스너도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="68f58f74d3780f9460b9207f3ef04661f0ea9185" translate="yes" xml:space="preserve">
          <source>The text editing component also has to provide an instance of InputMethodRequests.</source>
          <target state="translated">텍스트 편집 구성 요소는 InputMethodRequests의 인스턴스도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="abe46b84ee53a236c2700231fa5bd7581d2fd49f" translate="yes" xml:space="preserve">
          <source>The text included with the input method event consists of two parts: committed text and composed text. Either part may be empty. The two parts together replace any uncommitted composed text sent in previous events, or the currently selected committed text. Committed text should be integrated into the text component's persistent data, it will not be sent again. Composed text may be sent repeatedly, with changes to reflect the user's editing operations. Committed text always precedes composed text.</source>
          <target state="translated">입력 방법 이벤트에 포함 된 텍스트는 커밋 된 텍스트와 작성된 텍스트의 두 부분으로 구성됩니다. 두 부분 모두 비어있을 수 있습니다. 두 부분은 함께 이전 이벤트에서 전송 된 커밋되지 않은 작성된 텍스트 또는 현재 선택된 커밋 된 텍스트를 대체합니다. 커밋 된 텍스트는 텍스트 구성 요소의 영구 데이터에 통합되어야하며 다시 전송되지 않습니다. 작성된 텍스트는 사용자의 편집 작업을 반영하도록 변경하여 반복적으로 보낼 수 있습니다. 커밋 된 텍스트는 항상 작성된 텍스트보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1899b3e37537fc1d6b9f560d72d02ead7717a9d2" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a date-time.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 날짜-시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="119fbb383bccf4eac0375adfb016d1b3f8304e40" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a date.</source>
          <target state="translated">포맷터를 사용하여 텍스트를 구문 분석하고 날짜를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc611f16d1b6999b1ff7fa074c651bc88768faa1" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a month-day.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 한 달 동안 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2408a1b2fa16fded0ccd21134505f7a2dfa87a20" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a time.</source>
          <target state="translated">포맷터를 사용하여 텍스트를 구문 분석하여 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8aa28741c1cf5a7ab0d06ececd2ac50c4950d93d" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a year-month.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 1 년을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1700b19da145b2d61543e5a3e6060e9ee5311e75" translate="yes" xml:space="preserve">
          <source>The text is parsed using the formatter, returning a year.</source>
          <target state="translated">텍스트는 포맷터를 사용하여 구문 분석되어 1 년을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="714efd5fdbdc7a0051ac3528e30febfdfcc4d3b6" translate="yes" xml:space="preserve">
          <source>The text of the field will be output during a format. The value must be within the valid range of the field. If the value cannot be obtained then an exception will be thrown. If the field has no textual representation, then the numeric value will be used.</source>
          <target state="translated">필드의 텍스트는 포맷 중에 출력됩니다. 값은 필드의 유효한 범위 내에 있어야합니다. 값을 얻을 수 없으면 예외가 발생합니다. 필드에 텍스트 표현이 없으면 숫자 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="994a75acb429e80d94201f4b7fd1307dd3c02908" translate="yes" xml:space="preserve">
          <source>The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is the same that would be returned by</source>
          <target state="translated">반환 된 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 의 텍스트 는 다음과 같이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8d32f65f9358481d68c26733468e9f5827be3bb9" translate="yes" xml:space="preserve">
          <source>The text range that the attribute is applied to is critical to the semantics of the range. That means, the attribute cannot be applied to subranges of the text range that it applies to, and, if two adjacent text ranges have the same value for this attribute, the attribute still cannot be applied to the combined range as a whole with this value.</source>
          <target state="translated">속성이 적용되는 텍스트 범위는 해당 범위의 의미에 중요합니다. 즉, 속성을 적용 할 텍스트 범위의 하위 범위에 속성을 적용 할 수 없으며, 인접한 두 텍스트 범위에이 속성 값이 동일한 경우이 값을 사용하여 속성을 결합 된 범위에 계속 적용 할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="7c3f83472e562d9215e150160baafa85452b5724" translate="yes" xml:space="preserve">
          <source>The text representation of each constant UnicodeBlock identifier. For example, this method will return the &lt;a href=&quot;#BASIC_LATIN&quot;&gt;&lt;code&gt;BASIC_LATIN&lt;/code&gt;&lt;/a&gt; block if provided with the &quot;BASIC_LATIN&quot; name. This form replaces all spaces and hyphens in the canonical name with underscores.</source>
          <target state="translated">각 상수 UnicodeBlock 식별자의 텍스트 표현입니다. 예를 들어,이 메서드는 &quot;BASIC_LATIN&quot;이름과 함께 제공된 경우 &lt;a href=&quot;#BASIC_LATIN&quot;&gt; &lt;code&gt;BASIC_LATIN&lt;/code&gt; &lt;/a&gt; 블록 을 반환합니다 . 이 양식은 표준 이름의 모든 공백과 하이픈을 밑줄로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1b53d1b9f2d6a1ffec39094319a28b6fff2de1b3" translate="yes" xml:space="preserve">
          <source>The text representation of each constant UnicodeBlock identifier. For example, this method will return the &lt;a href=&quot;character.unicodeblock#BASIC_LATIN&quot;&gt;&lt;code&gt;BASIC_LATIN&lt;/code&gt;&lt;/a&gt; block if provided with the &quot;BASIC_LATIN&quot; name. This form replaces all spaces and hyphens in the canonical name with underscores.</source>
          <target state="translated">각 상수 UnicodeBlock 식별자의 텍스트 표현입니다. 예를 들어,이 메소드는 &quot;BASIC_LATIN&quot;이름이 제공된 경우 &lt;a href=&quot;character.unicodeblock#BASIC_LATIN&quot;&gt; &lt;code&gt;BASIC_LATIN&lt;/code&gt; &lt;/a&gt; 블록 을 리턴합니다 . 이 형식은 표준 이름의 모든 공백과 하이픈을 밑줄로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="77b9d7619830528efce6f7817705037fc5acc9d6" translate="yes" xml:space="preserve">
          <source>The text substituted for the individual format elements is derived from the current subformat of the format element and the &lt;code&gt;arguments&lt;/code&gt; element at the format element's argument index as indicated by the first matching line of the following table. An argument is</source>
          <target state="translated">개별 형식 요소로 대체 ​​된 텍스트는 형식 요소의 현재 하위 형식과 다음 표의 첫 번째 일치 행으로 표시되는 형식 요소의 인수 색인에 있는 &lt;code&gt;arguments&lt;/code&gt; 요소에서 파생됩니다 . 논쟁은</target>
        </trans-unit>
        <trans-unit id="9207fb7b3a8409b78131b80ed0af5df70aca6d6f" translate="yes" xml:space="preserve">
          <source>The text will be parsed from the specified start &lt;code&gt;ParsePosition&lt;/code&gt;. The entire length of the text does not have to be parsed, the &lt;code&gt;ParsePosition&lt;/code&gt; will be updated with the index at the end of parsing.</source>
          <target state="translated">지정된 시작 &lt;code&gt;ParsePosition&lt;/code&gt; 에서 텍스트가 구문 분석됩니다 . 텍스트의 전체 길이를 구문 분석 할 필요는 없습니다 . 구문 분석 종료시 &lt;code&gt;ParsePosition&lt;/code&gt; 이 색인으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ef359eb63a3e4e2e83b93c0386e4232cb9ad999c" translate="yes" xml:space="preserve">
          <source>The text.</source>
          <target state="translated">텍스트</target>
        </trans-unit>
        <trans-unit id="1448b4199b12055b6e038925f7a2322eace6c39d" translate="yes" xml:space="preserve">
          <source>The textual representation of IPv6 addresses as described above can be extended to specify IPv6 scoped addresses. This extension to the basic addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].</source>
          <target state="translated">위에서 설명한 IPv6 주소의 텍스트 표현을 확장하여 IPv6 범위 주소를 지정할 수 있습니다. 기본 주소 지정 아키텍처에 대한이 확장은 [draft-ietf-ipngwg-scoping-arch-04.txt]에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="619857d696535395d9a9e6e85c75cbda308cd69b" translate="yes" xml:space="preserve">
          <source>The textual representation of an IP address is address family specific.</source>
          <target state="translated">IP 주소의 텍스트 표현은 주소 패밀리에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2eeaee68cdaf2979e68f820a8cb381cb88cfe284" translate="yes" xml:space="preserve">
          <source>The textual representation of the selector for the rule set.</source>
          <target state="translated">규칙 세트에 대한 선택기의 텍스트 표현입니다.</target>
        </trans-unit>
        <trans-unit id="a90596571ebf3cb87e069b539a095963b4c232a2" translate="yes" xml:space="preserve">
          <source>The textual representation of the selector for the rule set. The implementation may have stripped out insignificant whitespace while parsing the selector.</source>
          <target state="translated">규칙 세트에 대한 선택기의 텍스트 표현입니다. 구현은 선택기를 구문 분석하는 동안 중요하지 않은 공백을 제거했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a243b35a93201c218afa01a0732e236f52dc54db" translate="yes" xml:space="preserve">
          <source>The third rule means for example that if the attribute &lt;code&gt;HeapMemoryUsage&lt;/code&gt; is a &lt;code&gt;MemoryUsage&lt;/code&gt;, monitoring &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; will obtain the observed value by calling &lt;code&gt;MemoryUsage.getUsed()&lt;/code&gt;.</source>
          <target state="translated">세 번째 규칙은 예를 들어 &lt;code&gt;HeapMemoryUsage&lt;/code&gt; 속성 이 &lt;code&gt;MemoryUsage&lt;/code&gt; 인 경우 &lt;code&gt;&quot;HeapMemoryUsage.used&quot;&lt;/code&gt; 를 모니터링 하면 &lt;code&gt;MemoryUsage.getUsed()&lt;/code&gt; 를 호출하여 관찰 된 값을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="1524da4ee526fb66e2dfa2fc314cd6b0009b09e7" translate="yes" xml:space="preserve">
          <source>The third statement above returns a &lt;code&gt;SecureRandom&lt;/code&gt; object of the specific algorithm supporting the specific instantiate parameters. The implementation's effective instantiated parameters must match this minimum request but is not necessarily the same. For example, even if the request does not require a certain feature, the actual instantiation can provide the feature. An implementation may lazily instantiate a &lt;code&gt;SecureRandom&lt;/code&gt; until it's actually used, but the effective instantiate parameters must be determined right after it's created and &lt;a href=&quot;#getParameters()&quot;&gt;&lt;code&gt;getParameters()&lt;/code&gt;&lt;/a&gt; should always return the same result unchanged.</source>
          <target state="translated">위의 세 번째 문 은 특정 인스턴스화 매개 변수를 지원하는 특정 알고리즘 의 &lt;code&gt;SecureRandom&lt;/code&gt; 개체를 반환합니다 . 구현의 효과적인 인스턴스화 매개 변수는이 최소 요청과 일치해야하지만 반드시 동일하지는 않습니다. 예를 들어 요청에 특정 기능이 필요하지 않더라도 실제 인스턴스화가 해당 기능을 제공 할 수 있습니다. 구현은 실제로 사용될 때까지 &lt;code&gt;SecureRandom&lt;/code&gt; 을 느리게 인스턴스화 할 수 있지만 효과적인 인스턴스화 매개 변수는 생성 된 직후 결정되어야하며 &lt;a href=&quot;#getParameters()&quot;&gt; &lt;code&gt;getParameters()&lt;/code&gt; &lt;/a&gt; 는 항상 동일한 결과를 변경하지 않고 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd8c7b9c1c14ab7ee8912062724df6f9139f499d" translate="yes" xml:space="preserve">
          <source>The third type of ID are region-based IDs. A region-based ID must be of two or more characters, and not start with 'UTC', 'GMT', 'UT' '+' or '-'. Region-based IDs are defined by configuration, see &lt;a href=&quot;zone/zonerulesprovider&quot;&gt;&lt;code&gt;ZoneRulesProvider&lt;/code&gt;&lt;/a&gt;. The configuration focuses on providing the lookup from the ID to the underlying &lt;code&gt;ZoneRules&lt;/code&gt;.</source>
          <target state="translated">세 번째 유형의 ID는 지역 기반 ID입니다. 지역 기반 ID는 2 자 이상이어야하며 'UTC', 'GMT', 'UT' '+'또는 '-'로 시작하지 않아야합니다. 지역 기반 ID는 구성에 따라 정의됩니다 ( &lt;a href=&quot;zone/zonerulesprovider&quot;&gt; &lt;code&gt;ZoneRulesProvider&lt;/code&gt; &lt;/a&gt; 참조) . 구성은 ID에서 기본 &lt;code&gt;ZoneRules&lt;/code&gt; 로 조회를 제공하는 데 중점을 둡니다 .</target>
        </trans-unit>
        <trans-unit id="7b2d5ce3a5a55711a2ea3b6fec5e3843d8b5a85a" translate="yes" xml:space="preserve">
          <source>The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this object and re-enabled for thread scheduling. It competes in the usual manner with other threads for the right to synchronize on the object; once it has regained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the &lt;code&gt;wait&lt;/code&gt; method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the invocation of the &lt;code&gt;wait&lt;/code&gt; method. Thus, on return from the &lt;code&gt;wait&lt;/code&gt; method, the synchronization state of the object and of thread &lt;code&gt;T&lt;/code&gt; is exactly as it was when the &lt;code&gt;wait&lt;/code&gt; method was invoked.</source>
          <target state="translated">그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 는이 개체에 대한 대기 세트에서 제거되고 스레드 예약을 위해 다시 활성화됩니다. 개체에서 동기화 할 수있는 권한을 얻기 위해 일반적인 방식으로 다른 스레드와 경쟁합니다. 개체에 대한 제어권을 다시 확보하면 개체에 대한 모든 동기화 클레임이 상태 유지, 즉 &lt;code&gt;wait&lt;/code&gt; 메서드가 호출 된 시점의 상황으로 복원 됩니다. 그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 는 &lt;code&gt;wait&lt;/code&gt; 메서드 호출에서 반환됩니다 . 따라서 &lt;code&gt;wait&lt;/code&gt; 메소드 에서 리턴 할 때 객체와 스레드 &lt;code&gt;T&lt;/code&gt; 의 동기화 상태 는 &lt;code&gt;wait&lt;/code&gt; 메소드가 호출 되었을 때와 똑같습니다 .</target>
        </trans-unit>
        <trans-unit id="798fb3ab3b700a8b0974f49f646feb0adf6c0b98" translate="yes" xml:space="preserve">
          <source>The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the &lt;code&gt;wait&lt;/code&gt; method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the invocation of the &lt;code&gt;wait&lt;/code&gt; method. Thus, on return from the &lt;code&gt;wait&lt;/code&gt; method, the synchronization state of the object and of thread &lt;code&gt;T&lt;/code&gt; is exactly as it was when the &lt;code&gt;wait&lt;/code&gt; method was invoked.</source>
          <target state="translated">그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 가이 오브젝트의 대기 세트에서 제거되고 스레드 스케줄링을 위해 다시 사용 가능합니다. 그런 다음 일반적인 방식으로 다른 스레드와 경쟁하여 개체에서 동기화 할 수 있습니다. 일단 객체의 제어권을 얻은 후에는 객체에 대한 모든 동기화 클레임이 현재 상태 즉, &lt;code&gt;wait&lt;/code&gt; 메소드가 호출 된 시점의 상황으로 복원 됩니다. 그런 다음 스레드 &lt;var&gt;T&lt;/var&gt; 는 &lt;code&gt;wait&lt;/code&gt; 메소드 호출에서 리턴합니다 . 따라서 &lt;code&gt;wait&lt;/code&gt; 메소드 에서 리턴 될 때 오브젝트와 스레드 &lt;code&gt;T&lt;/code&gt; 의 동기화 상태 는 &lt;code&gt;wait&lt;/code&gt; 메소드가 호출 되었을 때와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3886d03f704e9f4661772e22e536d051a2540f61" translate="yes" xml:space="preserve">
          <source>The thread ID property will be initialized with a unique ID for the current thread.</source>
          <target state="translated">스레드 ID 속성은 현재 스레드의 고유 ID로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="3224cdeecc04e300e6f6eb5dd7b0f464a0f08ee9" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#BLOCKED&quot;&gt;&lt;code&gt;BLOCKED&lt;/code&gt;&lt;/a&gt; state waiting to enter the &lt;code&gt;synchronized&lt;/code&gt; statement or method.</source>
          <target state="translated">스레드가 &lt;code&gt;synchronized&lt;/code&gt; 명령문 또는 메소드 를 입력하기 위해 대기중인 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#BLOCKED&quot;&gt; &lt;code&gt;BLOCKED&lt;/code&gt; &lt;/a&gt; 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="f6a7e6fbe217b20213591b29b1d875c85171794a" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../../../java.base/java/lang/object#wait()&quot;&gt;&lt;code&gt;Object.wait&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드가 &lt;a href=&quot;../../../../java.base/java/lang/object#wait()&quot;&gt; &lt;code&gt;Object.wait&lt;/code&gt; &lt;/a&gt; 메서드 호출로 인해 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태에 있습니다.</target>
        </trans-unit>
        <trans-unit id="87a5145ea7018df714b4f0182c383913942e6f12" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#park(java.lang.Object)&quot;&gt;&lt;code&gt;LockSupport.park&lt;/code&gt;&lt;/a&gt; method. The synchronization object is the object returned from &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#getBlocker(java.lang.Thread)&quot;&gt;&lt;code&gt;LockSupport.getBlocker&lt;/code&gt;&lt;/a&gt; method. Typically it is an &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt; ownable synchronizer&lt;/a&gt; or a &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#park(java.lang.Object)&quot;&gt; &lt;code&gt;LockSupport.park&lt;/code&gt; &lt;/a&gt; 메서드 호출로 인해 스레드가 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../java.base/java/lang/thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태에 있습니다. 동기화 개체는 &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/locksupport#getBlocker(java.lang.Thread)&quot;&gt; &lt;code&gt;LockSupport.getBlocker&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 개체입니다 . 일반적으로 &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;소유 할 수있는 동기화 장치&lt;/a&gt; 또는 &lt;a href=&quot;../../../../java.base/java/util/concurrent/locks/condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b9cc25b45a652d2428c1ca7ad40c7f0ae634fb0" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#BLOCKED&quot;&gt;&lt;code&gt;BLOCKED&lt;/code&gt;&lt;/a&gt; state waiting to enter the &lt;code&gt;synchronized&lt;/code&gt; statement or method.</source>
          <target state="translated">스레드가 &lt;a href=&quot;../thread.state#BLOCKED&quot;&gt; &lt;code&gt;BLOCKED&lt;/code&gt; &lt;/a&gt; 상태에 있으며 &lt;code&gt;synchronized&lt;/code&gt; 명령문 또는 메소드 를 입력하려고 대기 중 입니다.</target>
        </trans-unit>
        <trans-unit id="77e59a24e2fff88b3f72bac70df76f307ccbec5b" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../../util/concurrent/locks/locksupport#park-java.lang.Object-&quot;&gt;&lt;code&gt;LockSupport.park&lt;/code&gt;&lt;/a&gt; method. The synchronization object is the object returned from &lt;a href=&quot;../../util/concurrent/locks/locksupport#getBlocker-java.lang.Thread-&quot;&gt;&lt;code&gt;LockSupport.getBlocker&lt;/code&gt;&lt;/a&gt; method. Typically it is an &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt; ownable synchronizer&lt;/a&gt; or a &lt;a href=&quot;../../util/concurrent/locks/condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../util/concurrent/locks/locksupport#park-java.lang.Object-&quot;&gt; &lt;code&gt;LockSupport.park&lt;/code&gt; &lt;/a&gt; 메소드 호출로 인해 스레드가 &lt;a href=&quot;../thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태 입니다. 동기화 오브젝트는 &lt;a href=&quot;../../util/concurrent/locks/locksupport#getBlocker-java.lang.Thread-&quot;&gt; &lt;code&gt;LockSupport.getBlocker&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 오브젝트입니다 . 일반적으로 &lt;a href=&quot;lockinfo#OwnableSynchronizer&quot;&gt;소유 가능한 동기화 기&lt;/a&gt; 또는 &lt;a href=&quot;../../util/concurrent/locks/condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7b971951034e25a9cbf8c4a7520b71c76ce7c9c" translate="yes" xml:space="preserve">
          <source>The thread is in the &lt;a href=&quot;../thread.state#WAITING&quot;&gt;&lt;code&gt;WAITING&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;&lt;/a&gt; state due to a call to the &lt;a href=&quot;../object#wait-long-&quot;&gt;&lt;code&gt;Object.wait&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">스레드는 &lt;a href=&quot;../object#wait-long-&quot;&gt; &lt;code&gt;Object.wait&lt;/code&gt; &lt;/a&gt; 메소드 호출로 인해 &lt;a href=&quot;../thread.state#WAITING&quot;&gt; &lt;code&gt;WAITING&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../thread.state#TIMED_WAITING&quot;&gt; &lt;code&gt;TIMED_WAITING&lt;/code&gt; &lt;/a&gt; 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="fee6ea9eaa70ac63cd7bd687ae74dc9ebb1babb9" translate="yes" xml:space="preserve">
          <source>The thread must be suspended. The return occurs when execution of Java programming language code is resumed on this thread. Between the call to this method and resumption of thread execution, the state of the stack is undefined.</source>
          <target state="translated">스레드는 일시 중단되어야합니다. 리턴은이 스레드에서 Java 프로그래밍 언어 코드의 실행이 재개 될 때 발생합니다. 이 메서드에 대한 호출과 스레드 실행 재개 사이에는 스택 상태가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc8e934b45026e9176ead01c6d486ce921318b0a" translate="yes" xml:space="preserve">
          <source>The thread owning this segment.</source>
          <target state="translated">이 세그먼트를 소유 한 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="1cae8d80c59d4da83095fa5ad01a12ad0e9b0377" translate="yes" xml:space="preserve">
          <source>The thread represented by this thread is forced to stop whatever it is doing abnormally and to throw a newly created &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception.</source>
          <target state="translated">이 스레드로 표시되는 스레드는 비정상적으로 수행중인 작업을 중지하고 새로 작성된 &lt;code&gt;ThreadDeath&lt;/code&gt; 오브젝트를 예외로 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="0b3e60ed90635a926c08dd344792b7dde7c9298f" translate="yes" xml:space="preserve">
          <source>The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</source>
          <target state="translated">그런 다음 스레드는 모니터 소유권을 다시 얻을 수있을 때까지 기다렸다가 실행을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="25b717a3fa1cf9d27360f778068bc0905b1e3681" translate="yes" xml:space="preserve">
          <source>The threads may be executing while this method is called. The stack trace of each thread only represents a snapshot and each stack trace may be obtained at different time. A zero-length array will be returned in the map value if the virtual machine has no stack trace information about a thread.</source>
          <target state="translated">이 메소드가 호출되는 동안 스레드가 실행 중일 수 있습니다. 각 스레드의 스택 추적은 스냅 샷 만 나타내며 각 스택 추적은 다른 시간에 얻을 수 있습니다. 가상 머신에 스레드에 대한 스택 추적 정보가없는 경우 길이가 0 인 배열이 맵 값으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e3ff0b6b3a8faf4f1e95b0c706e80d227c4311" translate="yes" xml:space="preserve">
          <source>The three aspects of &lt;code&gt;collect&lt;/code&gt; -- supplier, accumulator, and combiner -- are tightly coupled. We can use the abstraction of a &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; to capture all three aspects. The above example for collecting strings into a &lt;code&gt;List&lt;/code&gt; can be rewritten using a standard &lt;code&gt;Collector&lt;/code&gt; as:</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; , 공급기, 축 압기 및 결합기 의 세 가지 측면 은 밀접하게 연결되어 있습니다. &lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt; 의 추상화를 사용하여 세 가지 측면을 모두 캡처 할 수 있습니다 . 문자열을 &lt;code&gt;List&lt;/code&gt; 로 수집하는 위의 예제는 다음과 같이 표준 &lt;code&gt;Collector&lt;/code&gt; 를 사용하여 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac4e5d34586392cc6376d13f3ac41b119993fff0" translate="yes" xml:space="preserve">
          <source>The three forms of &lt;code&gt;park&lt;/code&gt; each also support a &lt;code&gt;blocker&lt;/code&gt; object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method &lt;a href=&quot;#getBlocker(java.lang.Thread)&quot;&gt;&lt;code&gt;getBlocker(Thread)&lt;/code&gt;&lt;/a&gt;.) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a &lt;code&gt;blocker&lt;/code&gt; within a lock implementation is &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">세 가지 형태의 &lt;code&gt;park&lt;/code&gt; 각각 &lt;code&gt;blocker&lt;/code&gt; 개체 매개 변수를 지원합니다 . 이 개체는 스레드가 차단 된 동안 기록되어 스레드가 차단 된 이유를 식별 할 수있는 모니터링 및 진단 도구를 허용합니다. (이러한 도구는 &lt;a href=&quot;#getBlocker(java.lang.Thread)&quot;&gt; &lt;code&gt;getBlocker(Thread)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 차단기에 액세스 할 수 있습니다 .)이 매개 변수가없는 원래 양식 대신 이러한 양식을 사용하는 것이 좋습니다. 잠금 구현 내에서 &lt;code&gt;blocker&lt;/code&gt; 로 제공하는 일반적인 인수 는 &lt;code&gt;this&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ccdf2eb66d2e71f34a919a596f65bb338f795c35" translate="yes" xml:space="preserve">
          <source>The three forms of &lt;code&gt;park&lt;/code&gt; each also support a &lt;code&gt;blocker&lt;/code&gt; object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method &lt;a href=&quot;locksupport#getBlocker-java.lang.Thread-&quot;&gt;&lt;code&gt;getBlocker(Thread)&lt;/code&gt;&lt;/a&gt;.) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a &lt;code&gt;blocker&lt;/code&gt; within a lock implementation is &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">3 가지 형태의 &lt;code&gt;park&lt;/code&gt; 각각 &lt;code&gt;blocker&lt;/code&gt; 객체 매개 변수를 지원합니다 . 이 오브젝트는 스레드가 차단되는 동안 기록되어 모니터링 및 진단 도구가 스레드가 차단 된 이유를 식별 할 수 있습니다. (이러한 도구는 &lt;a href=&quot;locksupport#getBlocker-java.lang.Thread-&quot;&gt; &lt;code&gt;getBlocker(Thread)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 블로커에 액세스 할 수 있습니다 .)이 매개 변수가없는 원래 양식 대신 이러한 양식을 사용하는 것이 좋습니다. 잠금 구현 내에서 &lt;code&gt;blocker&lt;/code&gt; 로 제공하는 일반적인 인수 는 &lt;code&gt;this&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df00dd95000e60bd282d65d477e94c0a82461152" translate="yes" xml:space="preserve">
          <source>The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms.</source>
          <target state="translated">대기 중, 중단 불가능 및 시간 지정의 세 가지 조건 대기 조건은 일부 플랫폼에서의 구현 용이성과 성능 특성이 다를 수 있습니다. 특히, 이러한 기능을 제공하고 주문 보장과 같은 특정 의미를 유지하는 것이 어려울 수 있습니다. 또한 스레드의 실제 서스펜션을 방해하는 기능이 모든 플랫폼에서 항상 구현 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="db29ad82518a2ee6d7ddfaf1a9c7b34c8ecf4057" translate="yes" xml:space="preserve">
          <source>The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities. Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt; acquisition of a lock may not be available in a given &lt;code&gt;Lock&lt;/code&gt; class. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.</source>
          <target state="translated">3 가지 형태의 잠금 획득 (인터럽터 블, 인터럽터 블 및 타임 드)은 성능 특성, 순서 보증 또는 기타 구현 품질이 다를 수 있습니다. 또한, 잠금 의 &lt;em&gt;진행중인&lt;/em&gt; 획득 을 방해하는 기능 은 주어진 &lt;code&gt;Lock&lt;/code&gt; 에서 사용 가능하지 않을 수 있습니다수업. 결과적으로, 구현은 세 가지 형태의 잠금 획득 모두에 대해 정확히 동일한 보장 또는 의미를 정의 할 필요가 없으며, 진행중인 잠금 획득의 중단을 지원할 필요도 없다. 각 잠금 방법이 제공하는 의미 및 보증을 명확하게 문서화하려면 구현이 필요합니다. 또한 잠금 획득 중단이 지원되는 정도까지이 인터페이스에 정의 된 중단 시맨틱을 준수해야합니다. 이는 완전히 또는 메소드 입력에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb65090e22ab8912d71a3b4c421185f9239fb8c9" translate="yes" xml:space="preserve">
          <source>The three types of rendering operations, along with details of each of their particular rendering processes are:</source>
          <target state="translated">세 가지 유형의 렌더링 작업과 각 특정 렌더링 프로세스의 세부 정보는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1243cf17aa93cee91f50c4b5f0c4dfc5e1efee1" translate="yes" xml:space="preserve">
          <source>The three values for decomposition mode are:</source>
          <target state="translated">분해 모드의 세 가지 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="466d6ba993a967766940f8a7a94e7ffe571cfcd1" translate="yes" xml:space="preserve">
          <source>The three ways to start an agent are described below.</source>
          <target state="translated">에이전트를 시작하는 세 가지 방법이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eca35f7b2afddf8594835c4c8f46728d1529fce5" translate="yes" xml:space="preserve">
          <source>The three-argument form is a generalization of the two-argument form, incorporating a mapping step into the accumulation step. We could re-cast the simple sum-of-weights example using the more general form as follows:</source>
          <target state="translated">3 인수 형식은 매핑 단계를 누적 단계에 통합 한 2 인수 형식의 일반화입니다. 다음과 같이보다 일반적인 형식을 사용하여 간단한 가중치 합계 예제를 다시 캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6013fc1c39f145cd90930c97bc7092d091abff1f" translate="yes" xml:space="preserve">
          <source>The threshold (for example, &lt;code&gt;&quot;20 ms&quot;&lt;/code&gt;).</source>
          <target state="translated">임계 값 (예 : &lt;code&gt;&quot;20 ms&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2e826b013ebf5d13455251fda42b4b52a0a40d6" translate="yes" xml:space="preserve">
          <source>The threshold high or threshold low are not of the same type as the gauge (gauge monitors).</source>
          <target state="translated">임계 값 상한 또는 임계 값 하한은 게이지 (게이지 모니터)와 동일한 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="618cf78884b8f69aa1ff4f548c236bef8d448a10" translate="yes" xml:space="preserve">
          <source>The threshold or the offset or the modulus are not of the same type as the counter (counter monitors).</source>
          <target state="translated">임계 값 또는 오프셋 또는 계수는 카운터 (카운터 모니터)와 동일한 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b761c49c0df6550fd9288c6d950a41463038892" translate="yes" xml:space="preserve">
          <source>The threshold value for the specified MBean if this MBean is in the set of observed MBeans, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">이 MBean가 관찰 된 MBean 세트에있는 경우, 지정된 MBean의 임계 값 . 그렇지 않은 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4abbaad922146601ba46b4fe49f8e578a3e9883a" translate="yes" xml:space="preserve">
          <source>The threshold value of the specified object.</source>
          <target state="translated">지정된 객체의 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="93ccc78354f36ab6014746446d9124e4c9a55c8e" translate="yes" xml:space="preserve">
          <source>The threshold value.</source>
          <target state="translated">임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="c8421d23d14f7481a0d1af497cd30f15efc9c681" translate="yes" xml:space="preserve">
          <source>The tick duration must be positive. If it has a part smaller than a whole millisecond, then the whole duration must divide into one second without leaving a remainder. All normal tick durations will match these criteria, including any multiple of hours, minutes, seconds and milliseconds, and sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.</source>
          <target state="translated">틱 기간은 양수 여야합니다. 전체 밀리 초보다 작은 부분이 있으면 나머지 시간을 남기지 않고 전체 지속 시간을 1 초로 나누어야합니다. 모든 일반 틱 기간은 시간, 분, 초 및 밀리 초의 배수 및 20ns, 250,000ns 및 500,000ns와 같은 합리적인 나노초 기간을 포함하여 이러한 기준과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3d7a7f884123f38061b4f01b40f6fca44848eb92" translate="yes" xml:space="preserve">
          <source>The time and offset do not affect the calculation and will be the same in the result. If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="cf65733067f037d5f7c0913c18befc5a4452eae3" translate="yes" xml:space="preserve">
          <source>The time and offset do not affect the calculation and will be the same in the result. If the resulting &lt;code&gt;OffsetDateTime&lt;/code&gt; is invalid, an exception is thrown.</source>
          <target state="translated">시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 결과 &lt;code&gt;OffsetDateTime&lt;/code&gt; 이 유효하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c06ad7fab5af0cf4e31869a72aaa8c0967814aa" translate="yes" xml:space="preserve">
          <source>The time does not affect the calculation and will be the same in the result. If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.</source>
          <target state="translated">시간은 계산에 영향을 미치지 않으며 결과에서 동일합니다. 해당 월의 날짜가 유효하지 않은 경우 해당 월의 마지막 유효 날짜로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4106b4f9e69339c1872abca12ca2da7faed9666a" translate="yes" xml:space="preserve">
          <source>The time in milli-seconds that the MBeanInfo can reasonably be expected to be unchanged. The value can be a &lt;code&gt;Long&lt;/code&gt; or a decimal string. This provides a hint from a DynamicMBean or any MBean that does not define &lt;code&gt;immutableInfo&lt;/code&gt; as &lt;code&gt;true&lt;/code&gt; that the MBeanInfo is not likely to change within this period and therefore can be cached. When this field is missing or has the value zero, it is not recommended to cache the MBeanInfo unless it has the &lt;code&gt;immutableInfo&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; or it has &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt;&lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt;&lt;/a&gt; in its &lt;a href=&quot;mbeannotificationinfo&quot;&gt;&lt;code&gt;MBeanNotificationInfo&lt;/code&gt;&lt;/a&gt; array.</source>
          <target state="translated">MBeanInfo가 합리적으로 변경 될 것으로 예상되는 시간 (밀리 초)입니다. 값은 &lt;code&gt;Long&lt;/code&gt; 또는 10 진수 문자열 일 수 있습니다 . 이는 MBeanInfo가이 기간 내에 변경되지 않아 캐시 될 수 있다는 &lt;code&gt;true&lt;/code&gt; &lt;code&gt;immutableInfo&lt;/code&gt; 를 true 로 정의하지 않은 DynamicMBean 또는 MBean의 힌트를 제공합니다 . 이 필드가 없거나 값이 0 인 경우, &lt;code&gt;immutableInfo&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있거나 &lt;a href=&quot;mbeannotificationinfo&quot;&gt; &lt;code&gt;MBeanNotificationInfo&lt;/code&gt; &lt;/a&gt; 배열 에 &lt;a href=&quot;mbeaninfo#info-changed&quot;&gt; &lt;code&gt;&quot;jmx.mbean.info.changed&quot;&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 MBeanInfo를 캐시하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="acbf0fbbf2519547cc43bc06b63a9e4515272ec9" translate="yes" xml:space="preserve">
          <source>The time is converted into an instant using the time definition.</source>
          <target state="translated">시간은 시간 정의를 사용하여 순간으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5996955378dd36992f5dee7922b6ee64c4396fe3" translate="yes" xml:space="preserve">
          <source>The time limit of these SearchControls in milliseconds.</source>
          <target state="translated">이러한 SearchControl의 시간 제한 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="526444c169e427c129c525d4df96c1420c7a51f7" translate="yes" xml:space="preserve">
          <source>The time of midnight at the start of the day, '00:00'.</source>
          <target state="translated">시작 시간의 자정 시간, '00 : 00 '.</target>
        </trans-unit>
        <trans-unit id="8f833517ae6c82bdf28f4d07f70897fd379d4f67" translate="yes" xml:space="preserve">
          <source>The time of noon in the middle of the day, '12:00'.</source>
          <target state="translated">정오의 시간, '12 : 00 '.</target>
        </trans-unit>
        <trans-unit id="64a643ca048518ba71b10504256b6f2db499384f" translate="yes" xml:space="preserve">
          <source>The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day. There are three kinds of &lt;em&gt;mode&lt;/em&gt;s to specify the time: &lt;a href=&quot;#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STANDARD_TIME&quot;&gt;&lt;code&gt;STANDARD_TIME&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#UTC_TIME&quot;&gt;&lt;code&gt;UTC_TIME&lt;/code&gt;&lt;/a&gt;. For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the &lt;a href=&quot;#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt; mode. In this case, the wall clock time for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.</source>
          <target state="translated">일광 절약 시간이 시작되거나 끝나는 시간은 하루 중 밀리 초 값으로 지정됩니다. 시간을 지정하는 &lt;em&gt;모드&lt;/em&gt; 에는 &lt;a href=&quot;#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#STANDARD_TIME&quot;&gt; &lt;code&gt;STANDARD_TIME&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#UTC_TIME&quot;&gt; &lt;code&gt;UTC_TIME&lt;/code&gt; &lt;/a&gt; 세 종류가 &lt;em&gt;있습니다&lt;/em&gt; . 예를 들어 일광 절약 시간이 벽시계 시간으로 오전 2시에 종료되는 경우 &lt;a href=&quot;#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; 모드 에서 7200000 밀리 초로 지정할 수 있습니다 . 이 경우 &lt;em&gt;종료 규칙의&lt;/em&gt; 벽시계 시간 은 일광 시간과 동일한 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8f963cde5781a47df760ad32650d381c8f0dbe75" translate="yes" xml:space="preserve">
          <source>The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day. There are three kinds of &lt;em&gt;mode&lt;/em&gt;s to specify the time: &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;simpletimezone#STANDARD_TIME&quot;&gt;&lt;code&gt;STANDARD_TIME&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;simpletimezone#UTC_TIME&quot;&gt;&lt;code&gt;UTC_TIME&lt;/code&gt;&lt;/a&gt;. For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt;&lt;code&gt;WALL_TIME&lt;/code&gt;&lt;/a&gt; mode. In this case, the wall clock time for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.</source>
          <target state="translated">일광 절약 시간 제가 시작되거나 끝나는 시간은 하루 내의 밀리 초 값으로 지정됩니다. 시간을 지정하는 세 가지 종류의 &lt;em&gt;모드&lt;/em&gt; 가 있습니다 : &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;simpletimezone#STANDARD_TIME&quot;&gt; &lt;code&gt;STANDARD_TIME&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;simpletimezone#UTC_TIME&quot;&gt; &lt;code&gt;UTC_TIME&lt;/code&gt; &lt;/a&gt; . 예를 들어, 일광 절약 시간이 벽시계 시간으로 오전 2시에 종료되면 &lt;a href=&quot;simpletimezone#WALL_TIME&quot;&gt; &lt;code&gt;WALL_TIME&lt;/code&gt; &lt;/a&gt; 모드 에서 7200000 밀리 초로 지정할 수 있습니다 . 이 경우 &lt;em&gt;종료 규칙의&lt;/em&gt; 벽시계 시간 은 일광 절약 시간과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="da518f034e84f814aabae3807109e025837e0b57" translate="yes" xml:space="preserve">
          <source>The time period in milliseconds, or &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">밀리 초 단위의 기간 또는 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf057ec490c0b8af2d8425ade1d7ae7ac4480b72" translate="yes" xml:space="preserve">
          <source>The time period that the sending side may expire the message if it has not been sent, or &lt;code&gt;0&lt;/code&gt; to indicate that no timeout should occur.</source>
          <target state="translated">메시지가 전송되지 않은 경우 보내는 쪽이 메시지를 만료시킬 수있는 기간 또는 시간 초과가 발생하지 않아야 함을 나타내는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8deb22926d2dc6ce60af21119793b60100298e6b" translate="yes" xml:space="preserve">
          <source>The time period that the sending side may expire the message if it has not been sent, or &lt;code&gt;0&lt;/code&gt; to indicate that no timeout should occur. This value is only applicable for messages being sent, it has no meaning for received messages.</source>
          <target state="translated">메시지가 전송되지 않은 경우 보내는 쪽이 메시지를 만료시킬 수있는 기간 또는 시간 초과가 발생하지 않아야 함을 나타내는 &lt;code&gt;0&lt;/code&gt; 입니다. 이 값은 전송되는 메시지에만 적용되며 수신 된 메시지에는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f682fddb863e7c5b381d42cd6be2e0499225644" translate="yes" xml:space="preserve">
          <source>The time stamp.</source>
          <target state="translated">타임 스탬프.</target>
        </trans-unit>
        <trans-unit id="3cb58d5d8003015620c159da03ce3e4d5619a359" translate="yes" xml:space="preserve">
          <source>The time stamp. Replaced by InputEvent.getWhen().</source>
          <target state="translated">타임 스탬프. InputEvent.getWhen ()으로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="422a6a0727efc668eadfab588f39e7901af76990" translate="yes" xml:space="preserve">
          <source>The time-to-live constant for disabling the expiration control for loaded resource bundle instances in the cache.</source>
          <target state="translated">캐시에로드 된 자원 번들 인스턴스에 대한 만료 제어를 사용하지 않도록 설정하기위한 지속 시간 상수</target>
        </trans-unit>
        <trans-unit id="c09406968aca987adec6afd3d870562c13c5226c" translate="yes" xml:space="preserve">
          <source>The time-to-live constant for not caching loaded resource bundle instances.</source>
          <target state="translated">로드 된 자원 번들 인스턴스를 캐싱하지 않는 지속 시간 상수.</target>
        </trans-unit>
        <trans-unit id="2948afa6c507e96db7157cef9cbb050870dbd00b" translate="yes" xml:space="preserve">
          <source>The time-zone offset for UTC, with an ID of 'Z'.</source>
          <target state="translated">ID가 'Z'인 UTC의 시간대 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="1dfd324cfb41000f9d3aba1f9dad090939b1b93f" translate="yes" xml:space="preserve">
          <source>The timeout period, specified by &lt;code&gt;timeout&lt;/code&gt; milliseconds plus &lt;code&gt;nanos&lt;/code&gt; nanoseconds arguments, has elapsed.</source>
          <target state="translated">시간 &lt;code&gt;timeout&lt;/code&gt; 밀리 초와 &lt;code&gt;nanos&lt;/code&gt; 나노초 인수로 지정된 시간 초과 기간 이 경과했습니다.</target>
        </trans-unit>
        <trans-unit id="e87dd73958b4c331aa3b482b31ba9b3bb70f0291" translate="yes" xml:space="preserve">
          <source>The timeout value, in milliseconds, indicates the maximum amount of time the try should take. If the operation times out before getting an answer, the host is deemed unreachable. A negative value will result in an IllegalArgumentException being thrown.</source>
          <target state="translated">시간 초과 값 (밀리 초)은 시도에 걸리는 최대 시간을 나타냅니다. 응답을 받기 전에 작업 시간이 초과되면 호스트에 연결할 수없는 것으로 간주됩니다. 값이 음수이면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a3c7016b356d85ab2005993ec546da2021f5da3" translate="yes" xml:space="preserve">
          <source>The timer notification detailed message or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 상세 메세지. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 맵되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="e45c48a5b2ba20c62b4614e6273292d7390eb1e1" translate="yes" xml:space="preserve">
          <source>The timer notification type or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 형. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 매핑되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="23967f54cac8eb8b003d2fc196f922e43be03fd3" translate="yes" xml:space="preserve">
          <source>The timer notification user data object or null if the identifier is not mapped to any timer notification registered for this timer MBean.</source>
          <target state="translated">타이머 통지 사용자 데이터 객체. 식별자가이 타이머 MBean에 등록 된 타이머 통지에 매핑되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="d238facacd1f3d07587721542ed70d70cb4c4775" translate="yes" xml:space="preserve">
          <source>The timer notification will be handled once at the specified date.</source>
          <target state="translated">타이머 알림은 지정된 날짜에 한 번 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="414f37292531292150b0ccb1cad0625336e616e7" translate="yes" xml:space="preserve">
          <source>The timer notification will repeat continuously using the timer period using a</source>
          <target state="translated">타이머 알림은 a를 사용하여 타이머 기간을 사용하여 계속 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="315f63d583a4676ef18933ae7199a0ed0f9a00e4" translate="yes" xml:space="preserve">
          <source>The timer notifications are created and handled by the timer MBean.</source>
          <target state="translated">타이머 통지는 타이머 MBean에 의해 작성되어 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="cd191085be187917516f28d90bc41b5e0e055de2" translate="yes" xml:space="preserve">
          <source>The timer service relies on the system date of the host where the &lt;code&gt;Timer&lt;/code&gt; class is loaded. Listeners may receive untimely notifications if their host has a different system date. To avoid such problems, synchronize the system date of all host machines where timing is needed.</source>
          <target state="translated">타이머 서비스는 &lt;code&gt;Timer&lt;/code&gt; 클래스가로드 된 호스트의 시스템 날짜에 의존합니다 . 호스트의 시스템 날짜가 다른 경우 리스너가시기 적절하지 않은 알림을받을 수 있습니다. 이러한 문제를 피하려면 타이밍이 필요한 모든 호스트 시스템의 시스템 날짜를 동기화하십시오.</target>
        </trans-unit>
        <trans-unit id="60a7b8fc73dec0735c0c82b6db258aba41d55181" translate="yes" xml:space="preserve">
          <source>The timestamp of this &lt;code&gt;UUID&lt;/code&gt;.</source>
          <target state="translated">이것의 타임 스탬프 &lt;code&gt;UUID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d91c8abe6606f2a3d89bcf82e749e9e60f3b44c" translate="yes" xml:space="preserve">
          <source>The timestamp or &lt;code&gt;null&lt;/code&gt; if none is present.</source>
          <target state="translated">타임 스탬프 . 존재하지 않는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a65048c31509f7e0113cb6ea8961ee3f79f086" translate="yes" xml:space="preserve">
          <source>The timestamp value associated with this UUID.</source>
          <target state="translated">이 UUID와 연관된 시간 소인 값입니다.</target>
        </trans-unit>
        <trans-unit id="77858a6a5789b904ad06d6e90ad129b1b4ed75fb" translate="yes" xml:space="preserve">
          <source>The timestamp value is only meaningful in a time-based UUID, which has version type 1. If this &lt;code&gt;UUID&lt;/code&gt; is not a time-based UUID then this method throws UnsupportedOperationException.</source>
          <target state="translated">시간 소인 값은 버전 유형이 1 인 시간 기반 UUID에서만 의미가 있습니다.이 &lt;code&gt;UUID&lt;/code&gt; 가 시간 기반 UUID가 아닌 경우이 메소드는 UnsupportedOperationException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="562d9979ad13d306cfdc69375e27b692b4c4e6be" translate="yes" xml:space="preserve">
          <source>The timestamp's date and time.</source>
          <target state="translated">타임 스탬프의 날짜 및 시간</target>
        </trans-unit>
        <trans-unit id="2f99efc0a5831891f40ab823d3bf06354b6d699f" translate="yes" xml:space="preserve">
          <source>The timing division type of the sequence.</source>
          <target state="translated">시퀀스의 타이밍 분할 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b61d7655e56c95f2266c2fad01803ab318ea6674" translate="yes" xml:space="preserve">
          <source>The timing information and resolution for a track is controlled by and stored in the sequence containing the track. A given &lt;code&gt;Track&lt;/code&gt; is considered to belong to the particular &lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt; that maintains its timing. For this reason, a new (empty) track is created by calling the &lt;a href=&quot;sequence#createTrack()&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt; method, rather than by directly invoking a &lt;code&gt;Track&lt;/code&gt; constructor.</source>
          <target state="translated">트랙의 타이밍 정보와 해상도는 트랙을 포함하는 시퀀스에 의해 제어되고 저장됩니다. 주어진 &lt;code&gt;Track&lt;/code&gt; 은 타이밍을 유지 하는 특정 &lt;a href=&quot;sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt; 에 속하는 것으로 간주됩니다 . 따라서 &lt;code&gt;Track&lt;/code&gt; 생성자를 직접 호출하는 대신 &lt;a href=&quot;sequence#createTrack()&quot;&gt; &lt;code&gt;Sequence.createTrack()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 새 (빈) 트랙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d0374fbf6438fbc3467dbf34b4e05683b94595c3" translate="yes" xml:space="preserve">
          <source>The timing information and resolution for a track is controlled by and stored in the sequence containing the track. A given &lt;code&gt;Track&lt;/code&gt; is considered to belong to the particular &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; that maintains its timing. For this reason, a new (empty) track is created by calling the &lt;code&gt;&lt;a href=&quot;sequence#createTrack--&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method, rather than by directly invoking a &lt;code&gt;Track&lt;/code&gt; constructor.</source>
          <target state="translated">트랙의 타이밍 정보 및 해상도는 트랙을 포함하는 시퀀스에 의해 제어되고 저장됩니다. 주어진 &lt;code&gt;Track&lt;/code&gt; 은 타이밍을 유지 하는 특정 &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 에 속하는 것으로 간주됩니다 . 이러한 이유로 &lt;code&gt;Track&lt;/code&gt; 생성자를 직접 호출하지 않고 &lt;code&gt;&lt;a href=&quot;sequence#createTrack--&quot;&gt;&lt;code&gt;Sequence.createTrack()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메서드 를 호출하여 새 (빈) 트랙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6e6d3880f415cd4ec5def31690bbd751de4d2179" translate="yes" xml:space="preserve">
          <source>The timing resolution of the MIDI file.</source>
          <target state="translated">MIDI 파일의 타이밍 해상도</target>
        </trans-unit>
        <trans-unit id="94d8255f666f78ba91e4c0653d1ddca333f07432" translate="yes" xml:space="preserve">
          <source>The timing resolution of the sequence.</source>
          <target state="translated">시퀀스의 타이밍 해상도.</target>
        </trans-unit>
        <trans-unit id="5ea038093e385d3d5e2fd57f0725ac3f67c851e4" translate="yes" xml:space="preserve">
          <source>The title displayed in this internal frame's title bar.</source>
          <target state="translated">이 내부 프레임의 제목 표시 줄에 표시되는 제목입니다.</target>
        </trans-unit>
        <trans-unit id="acaeefe50cb5c6ee79bdfe6165ed6efca1e633ed" translate="yes" xml:space="preserve">
          <source>The title for the dialog box.</source>
          <target state="translated">대화 상자의 제목입니다.</target>
        </trans-unit>
        <trans-unit id="3a3106a5519a4cc49f3d21712c3f6fa49becfeb4" translate="yes" xml:space="preserve">
          <source>The title may or may not be displayed, depending on the actual type of window created.</source>
          <target state="translated">생성 된 실제 창의 유형에 따라 제목이 표시되거나 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0683018b81877e833126e6d3b7e7f8110b2e217" translate="yes" xml:space="preserve">
          <source>The title of a document as specified by the &lt;code&gt;TITLE&lt;/code&gt; element in the head of the document.</source>
          <target state="translated">문서 헤드의 &lt;code&gt;TITLE&lt;/code&gt; 요소에 지정된 문서 제목입니다 .</target>
        </trans-unit>
        <trans-unit id="8120bf9b224de89c2920e1546dcda46c8b1f8843" translate="yes" xml:space="preserve">
          <source>The title pane component used in the desktop icon.</source>
          <target state="translated">데스크탑 아이콘에 사용되는 제목 창 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="53048a7dfc38ea7b3d5b7194f51d45f9a8b221a2" translate="yes" xml:space="preserve">
          <source>The title the border should display.</source>
          <target state="translated">테두리에 표시 할 제목입니다.</target>
        </trans-unit>
        <trans-unit id="6c8e5b4d5d69012c519b74be2af0f0e1bad6f4c4" translate="yes" xml:space="preserve">
          <source>The token was a duplicate of an earlier token.</source>
          <target state="translated">토큰은 이전 토큰의 중복입니다.</target>
        </trans-unit>
        <trans-unit id="469511f0f8c8e5bb2c80808eab9d90b35b66e458" translate="yes" xml:space="preserve">
          <source>The token was a duplicate of an earlier token. This is a fatal error code that may occur during context establishment. It is not used to indicate supplementary status values. The MessageProp object is used for that purpose.</source>
          <target state="translated">토큰은 이전 토큰의 중복입니다. 이는 컨텍스트 설정 중에 발생할 수있는 치명적인 오류 코드입니다. 보충 상태 값을 나타내는 데 사용되지 않습니다. MessageProp 개체는 이러한 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="309f8befb903508c4999847b0b027aa02db2ad23" translate="yes" xml:space="preserve">
          <source>The token's validity period has expired.</source>
          <target state="translated">토큰의 유효 기간이 만료되었습니다.</target>
        </trans-unit>
        <trans-unit id="c12371230e30f66f3a76ec6704bded2a17df9644" translate="yes" xml:space="preserve">
          <source>The token's validity period has expired. This is a fatal error code that may occur during context establishment. It is not used to indicate supplementary status values. The MessageProp object is used for that purpose.</source>
          <target state="translated">토큰의 유효 기간이 만료되었습니다. 이는 컨텍스트 설정 중에 발생할 수있는 치명적인 오류 코드입니다. 보충 상태 값을 나타내는 데 사용되지 않습니다. MessageProp 개체는 이러한 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="46bd53fc951ee54ff26208f7f7d6b401775175dc" translate="yes" xml:space="preserve">
          <source>The tool environment is not required to support annotation processors that access environmental resources, either &lt;a href=&quot;roundenvironment&quot;&gt;per round&lt;/a&gt; or &lt;a href=&quot;processingenvironment&quot;&gt;cross-round&lt;/a&gt;, in a multi-threaded fashion.</source>
          <target state="translated">이 도구 환경을 지원 주석 프로세서에 필요하지 않습니다 대한 액세스 환경 자원, 중 &lt;a href=&quot;roundenvironment&quot;&gt;라운드 당&lt;/a&gt; 또는 &lt;a href=&quot;processingenvironment&quot;&gt;크로스 라운드&lt;/a&gt; 멀티 스레드 방식으로 .</target>
        </trans-unit>
        <trans-unit id="475033ec07ec172731d36e8e1a8c4e34cb1c0c10" translate="yes" xml:space="preserve">
          <source>The tool uses a</source>
          <target state="translated">이 도구는</target>
        </trans-unit>
        <trans-unit id="90d4e3e442dfc280941229ae11524075e2227322" translate="yes" xml:space="preserve">
          <source>The tool will create an instance of a doclet using the no-arg constructor of the doclet class.</source>
          <target state="translated">이 도구는 doclet 클래스의 인수가없는 생성자를 사용하여 doclet의 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="60edabc59c6f9e62a5a0fdea67fe30d15095591d" translate="yes" xml:space="preserve">
          <source>The tooltip text displayed on the approve button when a directory is selected and the current selection mode is FILES_ONLY.</source>
          <target state="translated">디렉토리가 선택되고 현재 선택 모드가 FILES_ONLY 일 때 승인 버튼에 표시되는 도구 설명 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="6ee07dce8496ccc8327ec779a3d953aaa0190c20" translate="yes" xml:space="preserve">
          <source>The top input tray in the printer.</source>
          <target state="translated">프린터의 상단 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="401590292bf1267b8c693854dc6321d52720a8be" translate="yes" xml:space="preserve">
          <source>The top inset of the border.</source>
          <target state="translated">테두리의 상단 삽입.</target>
        </trans-unit>
        <trans-unit id="40ca45217a397acf3cb9dde5c1b466e62f00362e" translate="yes" xml:space="preserve">
          <source>The top level representation of a documentation comment.</source>
          <target state="translated">문서 주석의 최상위 표현입니다.</target>
        </trans-unit>
        <trans-unit id="42a671ce68c829c9c3682af0e642fe256fbef14d" translate="yes" xml:space="preserve">
          <source>The top-level error handler that reacts to otherwise uncaught exceptions does not print out a message or otherwise notify the application if the uncaught exception is an instance of &lt;code&gt;ThreadDeath&lt;/code&gt;.</source>
          <target state="translated">캐치되지 않은 예외에 반응하는 최상위 레벨 오류 처리기는 캐치되지 않은 예외가 &lt;code&gt;ThreadDeath&lt;/code&gt; 의 인스턴스 인 경우 메시지를 인쇄하거나 애플리케이션에 알리지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="46f6d47ae13aad5695f239448bb57766c13e2aa1" translate="yes" xml:space="preserve">
          <source>The total length of the message in bytes (the status byte plus any data bytes)</source>
          <target state="translated">메시지의 총 길이 (바이트) (상태 바이트 + 모든 데이터 바이트)</target>
        </trans-unit>
        <trans-unit id="17fecdd4ddcdb8672f8d5932951da08117bd4dd0" translate="yes" xml:space="preserve">
          <source>The total number of bits in the pixel.</source>
          <target state="translated">픽셀의 총 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="05917e7da6988078054932792c0c5486cd4b1b28" translate="yes" xml:space="preserve">
          <source>The total number of points.</source>
          <target state="translated">총 포인트 수입니다.</target>
        </trans-unit>
        <trans-unit id="f62e7ead83f7b630f60dc2cbbcf456264118e6c3" translate="yes" xml:space="preserve">
          <source>The total number of points. The value of &lt;code&gt;npoints&lt;/code&gt; represents the number of valid points in this &lt;code&gt;Polygon&lt;/code&gt; and might be less than the number of elements in &lt;a href=&quot;#xpoints&quot;&gt;&lt;code&gt;xpoints&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ypoints&quot;&gt;&lt;code&gt;ypoints&lt;/code&gt;&lt;/a&gt;. This value can be 0.</source>
          <target state="translated">총 포인트 수입니다. &lt;code&gt;npoints&lt;/code&gt; 값은 이 &lt;code&gt;Polygon&lt;/code&gt; 의 유효한 포인트 수를 나타내며 &lt;a href=&quot;#xpoints&quot;&gt; &lt;code&gt;xpoints&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ypoints&quot;&gt; &lt;code&gt;ypoints&lt;/code&gt; &lt;/a&gt; 의 요소 수보다 적을 수 있습니다 . 이 값은 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ad0ea114ec1ddf71f5fe2d46d0cb9e7197a57a0" translate="yes" xml:space="preserve">
          <source>The total number of significant digits in</source>
          <target state="translated">유효 유효 자릿수의 총계</target>
        </trans-unit>
        <trans-unit id="e8f848286d69d23ec4b7259715c33925c847df30" translate="yes" xml:space="preserve">
          <source>The total size of the document including all external resources, this number might change as a document is being parsed if references to more external resources are seen.</source>
          <target state="translated">모든 외부 리소스를 포함한 문서의 총 크기입니다.이 숫자는 더 많은 외부 리소스에 대한 참조가 표시되는 경우 문서가 구문 분석 될 때 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a52eb79799de442c045f35d0474d14d18b85672" translate="yes" xml:space="preserve">
          <source>The total size of the document including all external resources, this number might change as a document is being parsed if references to more external resources are seen. A value of &lt;code&gt;0&lt;/code&gt; is returned if the total size cannot be determined or estimated.</source>
          <target state="translated">모든 외부 리소스를 포함한 문서의 총 크기입니다.이 숫자는 더 많은 외부 리소스에 대한 참조가 표시되는 경우 문서가 구문 분석 될 때 변경 될 수 있습니다. 총 크기를 판별하거나 추정 할 수없는 경우 &lt;code&gt;0&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c7cfb3d21fdcbe867349c0a9b8497b711e26d212" translate="yes" xml:space="preserve">
          <source>The total size of the list.</source>
          <target state="translated">목록의 전체 크기입니다.</target>
        </trans-unit>
        <trans-unit id="6b5d7d5da983bf443ff8b0d755377059b977f35d" translate="yes" xml:space="preserve">
          <source>The tracking value is multiplied by the font point size and passed through the font transform to determine an additional amount to add to the advance of each glyph cluster. Positive tracking values will inhibit formation of optional ligatures. Tracking values are typically between &lt;code&gt;-0.1&lt;/code&gt; and &lt;code&gt;0.3&lt;/code&gt;; values outside this range are generally not desirable.</source>
          <target state="translated">추적 값에 글꼴 포인트 크기를 곱하고 글꼴 변환을 통해 전달하여 각 글리프 클러스터의 진행에 추가 할 추가 양을 결정합니다. 양의 추적 값은 선택적 합자의 형성을 억제합니다. 추적 값은 일반적으로 &lt;code&gt;-0.1&lt;/code&gt; 에서 &lt;code&gt;0.3&lt;/code&gt; 사이입니다 . 이 범위를 벗어난 값은 일반적으로 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="703deab7518e04de6cf78487901807570cefd5e8" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically committed and rolled back.</source>
          <target state="translated">트랜잭션 분기가 경험적으로 커밋되고 롤백되었습니다.</target>
        </trans-unit>
        <trans-unit id="14b4d7ed7740cc11b56bff202adfa6d5c222e033" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically committed.</source>
          <target state="translated">트랜잭션 분기가 경험적으로 커밋되었습니다.</target>
        </trans-unit>
        <trans-unit id="da0babcbf37a3af594d97dc69b6bf086d7544d2c" translate="yes" xml:space="preserve">
          <source>The transaction branch has been heuristically rolled back.</source>
          <target state="translated">트랜잭션 분기가 경험적으로 롤백되었습니다.</target>
        </trans-unit>
        <trans-unit id="050d9fced3f39f16dd7abd1393e7514ef1ce5372" translate="yes" xml:space="preserve">
          <source>The transaction branch has been read-only and has been committed.</source>
          <target state="translated">트랜잭션 분기가 읽기 전용이고 커밋되었습니다.</target>
        </trans-unit>
        <trans-unit id="33db632dad51ea9ae41ea3cf6edbcd4f22719c4e" translate="yes" xml:space="preserve">
          <source>The transaction branch may have been heuristically completed.</source>
          <target state="translated">트랜잭션 분기가 경험적으로 완료되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861c2375e08c3476b0904853fa18832f2c36bb4e" translate="yes" xml:space="preserve">
          <source>The transaction branch was read-only and has been committed.</source>
          <target state="translated">트랜잭션 분기가 읽기 전용이고 커밋되었습니다.</target>
        </trans-unit>
        <trans-unit id="b793d2f86bb5ddf2929ec67d8f137dd2ab9dd816" translate="yes" xml:space="preserve">
          <source>The transaction work has been prepared normally.</source>
          <target state="translated">거래 작업이 정상적으로 준비되었습니다.</target>
        </trans-unit>
        <trans-unit id="9df96b47070ad60931e75c25b6080817de2717a9" translate="yes" xml:space="preserve">
          <source>The transfer &lt;em&gt;will not necessarily&lt;/em&gt; have been completed at the return of this call (i.e. the call does not block waiting for the drop). The transfer will take place through the Swing implementation of the &lt;code&gt;java.awt.dnd&lt;/code&gt; mechanism, requiring no further effort from the developer. The &lt;code&gt;exportDone&lt;/code&gt; method will be called when the transfer has completed.</source>
          <target state="translated">이 호출이 반환 &lt;em&gt;될 때&lt;/em&gt; 전송 &lt;em&gt;이 반드시&lt;/em&gt; 완료 &lt;em&gt;되지는 않습니다&lt;/em&gt; (즉, 호출이 드롭 대기를 차단하지 않음). 전송은 &lt;code&gt;java.awt.dnd&lt;/code&gt; 메커니즘 의 Swing 구현을 통해 이루어 지므로 개발자의 추가 노력이 필요하지 않습니다. &lt;code&gt;exportDone&lt;/code&gt; 전송이 완료되면 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a8c4e8eb43c79370beb6a0b967d482c111e1ea42" translate="yes" xml:space="preserve">
          <source>The transfer will take place using the &lt;code&gt;java.awt.datatransfer&lt;/code&gt; mechanism, requiring no further effort from the developer. Any data transfer &lt;em&gt;will&lt;/em&gt; be complete and the &lt;code&gt;exportDone&lt;/code&gt; method will be called with the action that occurred, before this method returns. Should the clipboard be unavailable when attempting to place data on it, the &lt;code&gt;IllegalStateException&lt;/code&gt; thrown by &lt;a href=&quot;../../../java.datatransfer/java/awt/datatransfer/clipboard#setContents(java.awt.datatransfer.Transferable,java.awt.datatransfer.ClipboardOwner)&quot;&gt;&lt;code&gt;Clipboard.setContents(Transferable, ClipboardOwner)&lt;/code&gt;&lt;/a&gt; will be propagated through this method. However, &lt;code&gt;exportDone&lt;/code&gt; will first be called with an action of &lt;code&gt;NONE&lt;/code&gt; for consistency.</source>
          <target state="translated">전송은 &lt;code&gt;java.awt.datatransfer&lt;/code&gt; 메커니즘을 사용하여 이루어 지므로 개발자의 추가 노력이 필요하지 않습니다. 모든 데이터 전송 &lt;em&gt;이&lt;/em&gt; 완료 &lt;code&gt;exportDone&lt;/code&gt; 메서드가 반환되기 전에 발생한 작업과 함께 exportDone 메서드가 호출됩니다. 거기에 장소 데이터를 시도 할 때 클립 보드에 사용할 수 만일, &lt;code&gt;IllegalStateException&lt;/code&gt; 이 에 의해 throw &lt;a href=&quot;../../../java.datatransfer/java/awt/datatransfer/clipboard#setContents(java.awt.datatransfer.Transferable,java.awt.datatransfer.ClipboardOwner)&quot;&gt; &lt;code&gt;Clipboard.setContents(Transferable, ClipboardOwner)&lt;/code&gt; &lt;/a&gt; 이 방법을 통해 전파됩니다. 그러나 일관성을 위해 먼저 &lt;code&gt;exportDone&lt;/code&gt; 이 &lt;code&gt;NONE&lt;/code&gt; 조치로 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="d87f3db630bd4bc1d40103fa67e3e1b3f2db8546" translate="yes" xml:space="preserve">
          <source>The transformation API throw three types of specialized exceptions. A &lt;a href=&quot;transformerfactoryconfigurationerror&quot;&gt;&lt;code&gt;TransformerFactoryConfigurationError&lt;/code&gt;&lt;/a&gt; is parallel to the &lt;a href=&quot;../parsers/factoryconfigurationerror&quot;&gt;&lt;code&gt;FactoryConfigurationError&lt;/code&gt;&lt;/a&gt;, and is thrown when a configuration problem with the TransformerFactory exists. This error will typically be thrown when the transformation factory class specified with the &quot;javax.xml.transform.TransformerFactory&quot; system property cannot be found or instantiated.</source>
          <target state="translated">변환 API는 세 가지 유형의 특수 예외를 발생시킵니다. &lt;a href=&quot;transformerfactoryconfigurationerror&quot;&gt; &lt;code&gt;TransformerFactoryConfigurationError&lt;/code&gt; 가&lt;/a&gt; 받는 평행 &lt;a href=&quot;../parsers/factoryconfigurationerror&quot;&gt; &lt;code&gt;FactoryConfigurationError&lt;/code&gt; &lt;/a&gt; 과의 TransformerFactory 구성 문제가 존재할 때 발생한다. 이 오류는 일반적으로 &quot;javax.xml.transform.TransformerFactory&quot;시스템 특성으로 지정된 변환 팩토리 클래스를 찾거나 인스턴스화 할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe701db82a538a1330d479e42d071cac878afdf3" translate="yes" xml:space="preserve">
          <source>The transformed &lt;code&gt;Raster&lt;/code&gt;.</source>
          <target state="translated">변형 된 &lt;code&gt;Raster&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d806ee0a87e3109095fc859ea8eb5cc5532045bc" translate="yes" xml:space="preserve">
          <source>The transformer must continue to try and provide normal transformation after invoking this method. It should still be possible for the application to process the document through to the end if no other errors are encountered.</source>
          <target state="translated">변환기는이 메서드를 호출 한 후 계속해서 정상적인 변환을 시도하고 제공해야합니다. 다른 오류가 발생하지 않으면 애플리케이션이 문서를 끝까지 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5fa423bbef1d4f0ed7a551ce1858b400fcccf4df" translate="yes" xml:space="preserve">
          <source>The transition may be represented as occurring at 24:00.</source>
          <target state="translated">전환은 24:00에 발생하는 것으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bbbaf76aec7f9bf6cba6b78d515bbb3bf05d201" translate="yes" xml:space="preserve">
          <source>The translation between a parent and child Raster may be determined by subtracting the child's sampleModelTranslateX and sampleModelTranslateY values from those of the parent.</source>
          <target state="translated">부모와 자식 Raster 간의 변환은 부모의 값에서 자식의 sampleModelTranslateX 및 sampleModelTranslateY 값을 빼서 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d3c8c5c72b6b96fb6f59ecad375ecd5b5124beb" translate="yes" xml:space="preserve">
          <source>The translation from pixel sample values to color/alpha components for display or processing purposes is based on a one-to-one correspondence of samples to components. Depending on the transfer type used to create an instance of &lt;code&gt;ComponentColorModel&lt;/code&gt;, the pixel sample values represented by that instance may be signed or unsigned and may be of integral type or float or double (see below for details). The translation from sample values to normalized color/alpha components must follow certain rules. For float and double samples, the translation is an identity, i.e. normalized component values are equal to the corresponding sample values. For integral samples, the translation should be only a simple scale and offset, where the scale and offset constants may be different for each component. The result of applying the scale and offset constants is a set of color/alpha component values, which are guaranteed to fall within a certain range. Typically, the range for a color component will be the range defined by the &lt;code&gt;getMinValue&lt;/code&gt; and &lt;code&gt;getMaxValue&lt;/code&gt; methods of the &lt;code&gt;ColorSpace&lt;/code&gt; class. The range for an alpha component should be 0.0 to 1.0.</source>
          <target state="translated">디스플레이 또는 처리 목적을 위해 픽셀 샘플 값에서 색상 / 알파 구성 요소로의 변환은 구성 요소에 대한 샘플의 일대일 대응을 기반으로합니다. &lt;code&gt;ComponentColorModel&lt;/code&gt; 의 인스턴스를 만드는 데 사용되는 전송 유형에 따라, 해당 인스턴스가 나타내는 픽셀 샘플 값은 부호가 있거나 부호가 없을 수 있으며 정수 유형 또는 부동 또는 이중 일 수 있습니다 (자세한 내용은 아래 참조). 샘플 값에서 정규화 된 색상 / 알파 성분으로의 변환은 특정 규칙을 따라야합니다. float 및 double 샘플의 경우 변환은 동일합니다. 즉, 정규화 된 구성 요소 값은 해당 샘플 값과 동일합니다. 적분 샘플의 경우 변환은 단순 스케일 및 오프셋이어야하며 스케일 및 오프셋 상수는 각 구성 요소에 대해 다를 수 있습니다. 배율 및 오프셋 상수를 적용한 결과는 특정 범위에 속하도록 보장되는 색상 / 알파 구성 요소 값 집합입니다. 일반적으로 색상 구성 요소의 범위는 &lt;code&gt;getMinValue&lt;/code&gt; 및 &lt;code&gt;getMaxValue&lt;/code&gt; 로 정의 된 범위입니다. &lt;code&gt;ColorSpace&lt;/code&gt; 클래스의 메서드 . 알파 성분의 범위는 0.0에서 1.0 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b65a261d80d53542a10bedce8edbc81f70d91963" translate="yes" xml:space="preserve">
          <source>The translation from pixel values to color/alpha components for display or processing purposes is a one-to-one correspondence of samples to components. A &lt;code&gt;DirectColorModel&lt;/code&gt; is typically used with image data which uses masks to define packed samples. For example, a &lt;code&gt;DirectColorModel&lt;/code&gt; can be used in conjunction with a &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; to construct a &lt;a href=&quot;bufferedimage&quot;&gt;&lt;code&gt;BufferedImage&lt;/code&gt;&lt;/a&gt;. Normally the masks used by the &lt;a href=&quot;samplemodel&quot;&gt;&lt;code&gt;SampleModel&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;ColorModel&lt;/code&gt; would be the same. However, if they are different, the color interpretation of pixel data will be done according to the masks of the &lt;code&gt;ColorModel&lt;/code&gt;.</source>
          <target state="translated">디스플레이 또는 처리 목적을 위해 픽셀 값에서 색상 / 알파 구성 요소로의 변환은 구성 요소에 대한 샘플의 일대일 대응입니다. &lt;code&gt;DirectColorModel&lt;/code&gt; 를는 일반적으로 포장 샘플을 정의하기 위해 마스크를 사용하는 화상 데이터와 함께 사용된다. 예를 들어 &lt;code&gt;DirectColorModel&lt;/code&gt; 을 &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; 과 함께 사용 하여 &lt;a href=&quot;bufferedimage&quot;&gt; &lt;code&gt;BufferedImage&lt;/code&gt; &lt;/a&gt; 를 생성 할 수 있습니다 . 일반적으로 &lt;a href=&quot;samplemodel&quot;&gt; &lt;code&gt;SampleModel&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;ColorModel&lt;/code&gt; 에서 사용하는 마스크 는 동일합니다. 단, 다른 경우에는 &lt;code&gt;ColorModel&lt;/code&gt; 마스크에 따라 픽셀 데이터의 색상 해석이 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="168b1d4ef4c25a61d82bab781cf817cb6ee6ff78" translate="yes" xml:space="preserve">
          <source>The translation from pixel values to color/alpha components for display or processing purposes is a one-to-one correspondence of samples to components. A &lt;code&gt;PackedColorModel&lt;/code&gt; is typically used with image data that uses masks to define packed samples. For example, a &lt;code&gt;PackedColorModel&lt;/code&gt; can be used in conjunction with a &lt;a href=&quot;singlepixelpackedsamplemodel&quot;&gt;&lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt;&lt;/a&gt; to construct a &lt;a href=&quot;bufferedimage&quot;&gt;&lt;code&gt;BufferedImage&lt;/code&gt;&lt;/a&gt;. Normally the masks used by the &lt;a href=&quot;samplemodel&quot;&gt;&lt;code&gt;SampleModel&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;ColorModel&lt;/code&gt; would be the same. However, if they are different, the color interpretation of pixel data is done according to the masks of the &lt;code&gt;ColorModel&lt;/code&gt;.</source>
          <target state="translated">디스플레이 또는 처리 목적을 위해 픽셀 값에서 색상 / 알파 구성 요소로의 변환은 구성 요소에 대한 샘플의 일대일 대응입니다. &lt;code&gt;PackedColorModel&lt;/code&gt; 와는 일반적으로 포장 샘플들을 정의하는 마스크를 사용하는 화상 데이터와 함께 사용된다. 예를 들어 &lt;code&gt;PackedColorModel&lt;/code&gt; 을 &lt;a href=&quot;singlepixelpackedsamplemodel&quot;&gt; &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; &lt;/a&gt; 과 함께 사용 하여 &lt;a href=&quot;bufferedimage&quot;&gt; &lt;code&gt;BufferedImage&lt;/code&gt; &lt;/a&gt; 를 생성 할 수 있습니다 . 일반적으로 &lt;a href=&quot;samplemodel&quot;&gt; &lt;code&gt;SampleModel&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;ColorModel&lt;/code&gt; 에서 사용하는 마스크 는 동일합니다. 단, 다른 경우에는 &lt;code&gt;ColorModel&lt;/code&gt; 마스크에 따라 픽셀 데이터의 색상 해석이 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="b5d7a0a9a5aa913b72a0d7dce956d6a2d0147d1c" translate="yes" xml:space="preserve">
          <source>The translucency levels of individual pixels may also be effected by the alpha component of their color (see &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt;&lt;code&gt;setBackground(Color)&lt;/code&gt;&lt;/a&gt;) and the current shape of this window (see &lt;a href=&quot;#setShape(java.awt.Shape)&quot;&gt;&lt;code&gt;setShape(Shape)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">개별 픽셀의 반투명도 수준은 색상의 알파 구성 요소 ( &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt; &lt;code&gt;setBackground(Color)&lt;/code&gt; &lt;/a&gt; 참조 ) 및이 창의 현재 모양 ( &lt;a href=&quot;#setShape(java.awt.Shape)&quot;&gt; &lt;code&gt;setShape(Shape)&lt;/code&gt; &lt;/a&gt; 참조) 에 의해 영향을받을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2749ff4c08edcd16b069e9cf4d2ed0371273c113" translate="yes" xml:space="preserve">
          <source>The translucency levels of individual pixels may also be effected by the alpha component of their color (see &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt;&lt;code&gt;setBackground(Color)&lt;/code&gt;&lt;/a&gt;) and the opacity value (see &lt;a href=&quot;#setOpacity(float)&quot;&gt;&lt;code&gt;setOpacity(float)&lt;/code&gt;&lt;/a&gt;). See &lt;a href=&quot;graphicsdevice.windowtranslucency&quot;&gt;&lt;code&gt;GraphicsDevice.WindowTranslucency&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">개별 픽셀의 반투명도 수준은 색상의 알파 구성 요소 ( &lt;a href=&quot;#setBackground(java.awt.Color)&quot;&gt; &lt;code&gt;setBackground(Color)&lt;/code&gt; &lt;/a&gt; 참조 )와 불투명도 값 ( &lt;a href=&quot;#setOpacity(float)&quot;&gt; &lt;code&gt;setOpacity(float)&lt;/code&gt; &lt;/a&gt; 참조) 에 의해 영향을받을 수도 있습니다 . 자세한 내용은 &lt;a href=&quot;graphicsdevice.windowtranslucency&quot;&gt; &lt;code&gt;GraphicsDevice.WindowTranslucency&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c1306905f8e445cab20995e9caae10676aed4f2" translate="yes" xml:space="preserve">
          <source>The transparency of an &lt;code&gt;IndexColorModel&lt;/code&gt; object is determined by examining the alpha components of the colors in the colormap and choosing the most specific value after considering the optional alpha values and any transparent index specified. The transparency value is &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; only if all valid colors in the colormap are opaque and there is no valid transparent pixel. If all valid colors in the colormap are either completely opaque (alpha = 1.0) or completely transparent (alpha = 0.0), which typically occurs when a valid transparent pixel is specified, the value is &lt;code&gt;Transparency.BITMASK&lt;/code&gt;. Otherwise, the value is &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;, indicating that some valid color has an alpha component that is neither completely transparent nor completely opaque (0.0 &amp;lt; alpha &amp;lt; 1.0).</source>
          <target state="translated">&lt;code&gt;IndexColorModel&lt;/code&gt; 객체 의 투명도는 컬러 맵에있는 색상의 알파 구성 요소를 검사하고 선택적 알파 값과 지정된 투명 인덱스를 고려한 후 가장 구체적인 값을 선택하여 결정됩니다. 투명도 값은 &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; 가 칼라 맵의 모든 유효한 색이 불투명하고 유효한 투명 픽셀이없는 경우에만 가능합니다. 컬러 맵의 모든 유효한 색상이 완전히 불투명하거나 (알파 = 1.0) 완전히 투명한 경우 (알파 = 0.0), 일반적으로 유효한 투명 픽셀을 지정할 때 발생하는 경우 값은 &lt;code&gt;Transparency.BITMASK&lt;/code&gt; 입니다. 그렇지 않은 경우 값은 &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt; 입니다., 일부 유효한 색상에 완전히 투명하거나 완전히 불투명하지 않은 (0.0 &amp;lt;알파 &amp;lt;1.0) 알파 구성 요소가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c891870f2397ea5ffc5f4c8aade7bd8d1dab8055" translate="yes" xml:space="preserve">
          <source>The transparency value with which this image was created.</source>
          <target state="translated">이 이미지가 생성 된 투명도 값입니다.</target>
        </trans-unit>
        <trans-unit id="6338d039f89f1539f2243ca8c36cfd3178456a44" translate="yes" xml:space="preserve">
          <source>The transport service capabilities.</source>
          <target state="translated">운송 서비스 기능.</target>
        </trans-unit>
        <trans-unit id="e081237b427051c5333deb296d65a823a7c2908e" translate="yes" xml:space="preserve">
          <source>The transport= value</source>
          <target state="translated">transport = 값</target>
        </trans-unit>
        <trans-unit id="a2e25a1118ce8877391b5f01b4a57a8df400e4ba" translate="yes" xml:space="preserve">
          <source>The tree has no model</source>
          <target state="translated">나무에는 모델이 없습니다</target>
        </trans-unit>
        <trans-unit id="dd6f791fb336426f0b5c534f66eae3384f79ccf9" translate="yes" xml:space="preserve">
          <source>The trigger.</source>
          <target state="translated">방아쇠</target>
        </trans-unit>
        <trans-unit id="19d46a2a9ae7b495f51fc356027feaf3becd628d" translate="yes" xml:space="preserve">
          <source>The truth value returned by this method is equivalent to: &lt;code&gt;getAnnotation(annotationClass) != null&lt;/code&gt;</source>
          <target state="translated">이 메소드에 의해 돌려 주어지는 진실 &lt;code&gt;getAnnotation(annotationClass) != null&lt;/code&gt; 다음과 같습니다. getAnnotation (annotationClass)! = null</target>
        </trans-unit>
        <trans-unit id="8c46d6198c957c6c25b841cf0f4dfb6d6cb250b3" translate="yes" xml:space="preserve">
          <source>The ttl &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt; 0 &amp;lt;= ttl &amp;lt;=
 255&lt;/code&gt; or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. Multicast packets sent with a TTL of &lt;code&gt;0&lt;/code&gt; are not transmitted on the network but may be delivered locally.</source>
          <target state="translated">ttl &lt;b&gt;은 &lt;/b&gt; &lt;code&gt; 0 &amp;lt;= ttl &amp;lt;= 255&lt;/code&gt; 범위에 &lt;b&gt;있어야합니다.&lt;/b&gt; 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. TTL이 &lt;code&gt;0&lt;/code&gt; 인 멀티 캐스트 패킷 은 네트워크에서 전송되지 않지만 로컬로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2485bd279a135141b31dd6331097ba469508ddf1" translate="yes" xml:space="preserve">
          <source>The ttl &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= ttl &amp;lt;=
 255&lt;/code&gt; or an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. Multicast packets sent with a TTL of &lt;code&gt;0&lt;/code&gt; are not transmitted on the network but may be delivered locally.</source>
          <target state="translated">ttl &lt;b&gt;은 &lt;/b&gt; &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 255&lt;/code&gt; 범위에 &lt;b&gt;있어야합니다.&lt;/b&gt; 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. TTL &lt;code&gt;0&lt;/code&gt; 으로 전송 된 멀티 캐스트 패킷 은 네트워크에서 전송되지 않지만 로컬로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6940391f4a3596501f2f3676ceed69996fe5b256" translate="yes" xml:space="preserve">
          <source>The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;b&gt;must&lt;/b&gt; be in the range &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 0xFF &lt;/code&gt;.</source>
          <target state="translated">ttl은 &lt;b&gt; 부호없는&lt;/b&gt; 8 비트 수량이므로 &lt;code&gt;0 &amp;lt;= ttl &amp;lt;= 0xFF &lt;/code&gt; 범위에 &lt;b&gt;있어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="969fb09f0d47cbd4ef59365982ee80f259c1e668" translate="yes" xml:space="preserve">
          <source>The twelve methods described above are summarized in the following table:</source>
          <target state="translated">위에서 설명한 12 가지 방법이 다음 표에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="60737d50d1714cdb7c9a212137135f035cb7e133" translate="yes" xml:space="preserve">
          <source>The two &lt;code&gt;Component&lt;/code&gt;s in a split pane can be aligned left to right using &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt;, or top to bottom using &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt;. The preferred way to change the size of the &lt;code&gt;Component&lt;/code&gt;s is to invoke &lt;code&gt;setDividerLocation&lt;/code&gt; where &lt;code&gt;location&lt;/code&gt; is either the new x or y position, depending on the orientation of the &lt;code&gt;JSplitPane&lt;/code&gt;.</source>
          <target state="translated">두 &lt;code&gt;Component&lt;/code&gt; 의 분리 창의 사용은 왼쪽에서 오른쪽으로 정렬 될 수 &lt;code&gt;JSplitPane.HORIZONTAL_SPLIT&lt;/code&gt; 를 사용하거나 위에서 아래로 &lt;code&gt;JSplitPane.VERTICAL_SPLIT&lt;/code&gt; 를 . &lt;code&gt;Component&lt;/code&gt; 의 크기를 변경하는 선호되는 방법 은 &lt;code&gt;setDividerLocation&lt;/code&gt; 을 호출하는 것입니다. 여기서 &lt;code&gt;location&lt;/code&gt; 은 &lt;code&gt;JSplitPane&lt;/code&gt; 의 방향에 따라 새로운 x 또는 y 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="a3593155b51237a7085bf75da2140fc0fe3e8c66" translate="yes" xml:space="preserve">
          <source>The two calls have the same effect.</source>
          <target state="translated">두 통화의 효과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b92a8d153cce49ff845ddf50531191cd3a963be7" translate="yes" xml:space="preserve">
          <source>The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially, see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.</source>
          <target state="translated">두 경우 ( &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) 및 ( &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;)는 특수하게 처리 됩니다. 자세한 내용 은 &lt;a href=&quot;#special_cases_constructor&quot;&gt;특수 사례&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28393cbfd67002d6ad36a08762b2e38653599b68" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the &lt;code&gt;==&lt;/code&gt; operator)</source>
          <target state="translated">두 문자는 동일합니다 ( &lt;code&gt;==&lt;/code&gt; 연산자 와 비교하여 )</target>
        </trans-unit>
        <trans-unit id="733cbbaea42ad75e1ffe40db5e03f1fed7b55f41" translate="yes" xml:space="preserve">
          <source>The two coordinate array sections can be exactly the same or can be overlapping sections of the same array without affecting the validity of the results. This method ensures that no source coordinates are overwritten by a previous operation before they can be transformed. The coordinates are stored in the arrays starting at the indicated offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.</source>
          <target state="translated">두 좌표 배열 섹션은 정확히 동일하거나 결과의 유효성에 영향을주지 않고 동일한 배열의 섹션을 겹칠 수 있습니다. 이 방법을 사용하면 원본 좌표를 변환하기 전에 이전 작업으로 덮어 쓰지 않습니다. 좌표는 표시된 오프셋에서 시작하여 &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt; 순서로 배열에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="25387bc728d28df98473fda65f0865bfbdd9186f" translate="yes" xml:space="preserve">
          <source>The two files are the same size, and every byte in the first file is identical to the corresponding byte in the second file.</source>
          <target state="translated">두 파일은 크기가 같고 첫 번째 파일의 모든 바이트는 두 번째 파일의 해당 바이트와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f19211fbe1e7f4c1e87ed754cadc6b0cc14be4e6" translate="yes" xml:space="preserve">
          <source>The two nodes are disconnected.</source>
          <target state="translated">두 노드의 연결이 끊어졌습니다.</target>
        </trans-unit>
        <trans-unit id="f398c8744bfdea0ef40d2e2e1377fe86aabbce87" translate="yes" xml:space="preserve">
          <source>The two nodes are disconnected. Order between disconnected nodes is always implementation-specific.</source>
          <target state="translated">두 노드의 연결이 끊어졌습니다. 연결이 끊긴 노드 간의 순서는 항상 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1ec974b380762a0bf9692b16ac0cfa7083a8a76b" translate="yes" xml:space="preserve">
          <source>The two nodes are of the same type.</source>
          <target state="translated">두 노드는 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1416b8437ae024eb2f580e7eda38b503e80d7f1f" translate="yes" xml:space="preserve">
          <source>The two paths locate the &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;same file&lt;/a&gt;, even if two &lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt;equal&lt;/a&gt; paths locate a file does not exist, or</source>
          <target state="translated">두 개의 &lt;a href=&quot;path#equals(java.lang.Object)&quot;&gt;동일한&lt;/a&gt; 경로가 파일이 존재하지 않는 경우에도 두 경로가 &lt;a href=&quot;#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;동일한 파일을&lt;/a&gt; 찾습니다.</target>
        </trans-unit>
        <trans-unit id="4a8e8cdc02eb816448907e6ad7e73c37517a03bf" translate="yes" xml:space="preserve">
          <source>The two possible authentication types for a resource.</source>
          <target state="translated">자원에 대한 두 가지 가능한 인증 유형.</target>
        </trans-unit>
        <trans-unit id="8562722983b5297a255d72d065fc4efeeada15b3" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d9e7a9794b9c62912ab9b974fd3e586ad8ce077c" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two double elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/double#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Double.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 간주되는 나머지 요소의 두 시퀀스는 점이 동일합니다. 이 방법은 두 개의 이중 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 같은 것으로 간주합니다 if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/double#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Double.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e9cc57517a9438e11a17414782fcda2ca6c93d7" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two double elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/double#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Double.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다. 이 방법은 두 개의 이중 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;(a == b) || (Double.isNaN(a) &amp;amp;&amp;amp; Double.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/double#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Double.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다. .</target>
        </trans-unit>
        <trans-unit id="677d0a0fc0aa5495b5b9a1ef2701a071bddcad42" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two float elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/float#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Float.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 간주되는 나머지 요소의 두 시퀀스는 점이 동일합니다. 이 방법은 두 개의 float 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 같은 것으로 간주합니다. if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/float#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Float.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f74bb945ec6a22ab7838a324a183e657cee9de65" translate="yes" xml:space="preserve">
          <source>The two sequences of remaining elements, considered independently of their starting positions, are pointwise equal. This method considers two float elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be equal if &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt;. The values &lt;code&gt;-0.0&lt;/code&gt; and &lt;code&gt;+0.0&lt;/code&gt; are considered to be equal, unlike &lt;a href=&quot;../lang/float#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Float.equals(Object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시작 위치와 독립적으로 고려되는 나머지 요소의 두 시퀀스는 포인트 단위로 동일합니다. 이 방법은 두 개의 float 요소 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;(a == b) || (Float.isNaN(a) &amp;amp;&amp;amp; Float.isNaN(b))&lt;/code&gt; . &lt;a href=&quot;../lang/float#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Float.equals(Object)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;-0.0&lt;/code&gt; 및 &lt;code&gt;+0.0&lt;/code&gt; 값 은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1be5e53cf7d411a8147d01132ffbb087dc37403" translate="yes" xml:space="preserve">
          <source>The two serialization-related fields are:</source>
          <target state="translated">두 개의 직렬화 관련 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97983c767ff42d4647c2b3d8afd3922e461ec55b" translate="yes" xml:space="preserve">
          <source>The type</source>
          <target state="translated">유형</target>
        </trans-unit>
        <trans-unit id="8ac14b02e6f129743d1f8a28d779dc984a66b294" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; may be either a primitive or reference. Since type &lt;code&gt;Iterator&amp;lt;T&amp;gt;&lt;/code&gt; is erased in the method handle representation to the raw type &lt;code&gt;Iterator&lt;/code&gt;, the &lt;code&gt;iteratedLoop&lt;/code&gt; combinator adjusts the leading argument type for &lt;code&gt;body&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt; as if by the &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; conversion method. Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur as the result of dynamic conversions performed by &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;MethodHandle.asType(MethodType)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 기본 또는 참조 일 수 있습니다. 타입 때문에 &lt;code&gt;Iterator&amp;lt;T&amp;gt;&lt;/code&gt; 원시 형태에있어서 핸들 표현 소거 &lt;code&gt;Iterator&lt;/code&gt; 상기 &lt;code&gt;iteratedLoop&lt;/code&gt; 의 연결자위한 주요한 인자 타입 조정 &lt;code&gt;body&lt;/code&gt; 에 &lt;code&gt;Object&lt;/code&gt; 바이 것처럼 &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 의&lt;/a&gt; 변환 방법. 따라서 루프가 실행될 때 잘못된 유형의 반복자가 나타나면 &lt;a href=&quot;methodhandle#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;MethodHandle.asType(MethodType)&lt;/code&gt; &lt;/a&gt; 의해 수행 된 동적 변환의 결과로 런타임 예외가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d9c3e5a2e1ee1b8623092bbd4a2ad433a0d8102" translate="yes" xml:space="preserve">
          <source>The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain &lt;code&gt;invoke&lt;/code&gt; and &lt;code&gt;asType&lt;/code&gt; requests can lead to trailing positional arguments being collected into target's trailing parameter. Also, the &lt;a href=&quot;methodtype#lastParameterType()&quot;&gt;last parameter type&lt;/a&gt; of the adapter will be &lt;code&gt;arrayType&lt;/code&gt;, even if the target has a different last parameter type.</source>
          <target state="translated">어댑터의 유형 및 동작은 특정 &lt;code&gt;invoke&lt;/code&gt; 및 &lt;code&gt;asType&lt;/code&gt; 요청이 대상의 후행 매개 변수에 수집되는 후행 위치 인수로 이어질 수 있다는 점을 제외하면 대상의 유형 및 동작 과 동일 합니다. 또한 대상에 다른 마지막 매개 변수 유형이 있더라도 어댑터 의 &lt;a href=&quot;methodtype#lastParameterType()&quot;&gt;마지막 매개 변수 유형&lt;/a&gt; 은 &lt;code&gt;arrayType&lt;/code&gt; 이됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0ea19c65ec77bbed855a0ec57d24fe61a6f3cfc" translate="yes" xml:space="preserve">
          <source>The type and behavior of the adapter will be the same as the type and behavior of the target, except that certain &lt;code&gt;invoke&lt;/code&gt; and &lt;code&gt;asType&lt;/code&gt; requests can lead to trailing positional arguments being collected into target's trailing parameter. Also, the last parameter type of the adapter will be &lt;code&gt;arrayType&lt;/code&gt;, even if the target has a different last parameter type.</source>
          <target state="translated">어댑터의 유형 및 작동은 대상의 유형 및 작동과 동일하지만 특정 &lt;code&gt;invoke&lt;/code&gt; 및 &lt;code&gt;asType&lt;/code&gt; 요청으로 인해 후행 위치 인수가 대상의 후행 매개 변수로 수집 될 수 있습니다. 또한 어댑터의 마지막 매개 변수 유형은 &lt;code&gt;arrayType&lt;/code&gt; 입니다. 대상의 마지막 매개 변수 유형이 다른 경우에도 입니다.</target>
        </trans-unit>
        <trans-unit id="b9274643a3bf4ca4addb78cb6a98b74268f87044" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">유형과 인코딩은 Java Security Standard Algorithm Names Specification 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt;CertificateFactory 섹션&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt;CertPath Encodings 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 유형 또는 인코딩이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c960b0be4588b06d03016cec1d59c31e1a26ee1a" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Security Standard Algorithm Names Specification. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">유형 및 인코딩은 Java 보안 표준 알고리즘 이름 사양 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#certificatefactory-types&quot;&gt;CertificateFactory 섹션&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/security/standard-names.html#certpath-encodings&quot;&gt;CertPath 인코딩 섹션&lt;/a&gt; 에 설명되어 있습니다. 다른 유형 또는 인코딩이 지원되는지 확인하려면 구현에 대한 릴리스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff6bb0cadf07db39ec6be40e5dae1eed885b4134" translate="yes" xml:space="preserve">
          <source>The type and encodings are described in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertificateFactory&quot;&gt; CertificateFactory section&lt;/a&gt; and the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt; CertPath Encodings section&lt;/a&gt; of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other types or encodings are supported.</source>
          <target state="translated">유형 및 인코딩은 Java Cryptography Architecture 표준 알고리즘 이름 문서 의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertificateFactory&quot;&gt;CertificateFactory 섹션&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt;CertPath 인코딩 섹션&lt;/a&gt; 에 설명되어 있습니다. 구현에 대한 릴리스 문서를 참조하여 다른 유형 또는 인코딩이 지원되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c6b186bc7aea698445dc40383caf4bf30781283e" translate="yes" xml:space="preserve">
          <source>The type associated with all custom cursors.</source>
          <target state="translated">모든 사용자 정의 커서와 연관된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f5ec1e2d57fb1bd044b7c12346c65a90e63ab2a6" translate="yes" xml:space="preserve">
          <source>The type associated with non-object values in a target VM.</source>
          <target state="translated">대상 VM의 비 개체 값과 연결된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a5acfd55f75f81b438121d9164a5ebdf07b1e583" translate="yes" xml:space="preserve">
          <source>The type associated with non-object values in a target VM. Instances of one of the sub-interfaces of this interface will be returned from &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; for all &lt;a href=&quot;primitivevalue&quot;&gt;&lt;code&gt;PrimitiveValue&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">대상 VM의 비 개체 값과 연결된 유형입니다. 이 인터페이스의 하위 인터페이스 중 하나의 인스턴스는 모든 &lt;a href=&quot;primitivevalue&quot;&gt; &lt;code&gt;PrimitiveValue&lt;/code&gt; &lt;/a&gt; 객체에 대해 &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 에서 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="948a046cc2e5aa5046c9417d1490884dfdc604b8" translate="yes" xml:space="preserve">
          <source>The type can be used to identify what type of setting this is.</source>
          <target state="translated">유형은 이것이 어떤 유형의 설정인지 식별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a0aad1afcd781464b76996d424e8348249f28ac" translate="yes" xml:space="preserve">
          <source>The type fingerprint that is set to indicate serialization compatibility with a previous version of the type.</source>
          <target state="translated">이전 버전의 유형과의 직렬화 호환성을 나타내도록 설정된 유형 지문입니다.</target>
        </trans-unit>
        <trans-unit id="93dbc281a6a1652e30aac933243bf7afad98e3d0" translate="yes" xml:space="preserve">
          <source>The type information associated with this attribute.</source>
          <target state="translated">이 속성과 연관된 유형 정보입니다.</target>
        </trans-unit>
        <trans-unit id="6035b72b31597b588131e4a84cda217fb3253aca" translate="yes" xml:space="preserve">
          <source>The type information associated with this attribute. While the type information contained in this attribute is guarantee to be correct after loading the document or invoking &lt;code&gt;Document.normalizeDocument()&lt;/code&gt;, &lt;code&gt;schemaTypeInfo&lt;/code&gt; may not be reliable if the node was moved.</source>
          <target state="translated">이 속성과 연관된 유형 정보입니다. 이 속성에 포함되는 타입 정보가 보증 문서를 로딩하거나 발신 한 후 올바른 것으로 동안 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; , &lt;code&gt;schemaTypeInfo&lt;/code&gt; 는 노드가 이동 한 경우 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e61ac73041fcfd164a7302e03c2c4eb5aa4c9644" translate="yes" xml:space="preserve">
          <source>The type information associated with this element.</source>
          <target state="translated">이 요소와 관련된 유형 정보입니다.</target>
        </trans-unit>
        <trans-unit id="47aacc9e53df6990e6cd21e34ac8f46081f60e02" translate="yes" xml:space="preserve">
          <source>The type is a &lt;code&gt;String&lt;/code&gt; that identifies the type of &lt;code&gt;Certificate&lt;/code&gt;s in the certification path. For each certificate &lt;code&gt;cert&lt;/code&gt; in a certification path &lt;code&gt;certPath&lt;/code&gt;, &lt;code&gt;cert.getType().equals(certPath.getType())&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">유형은 인증 경로에서 &lt;code&gt;Certificate&lt;/code&gt; 유형을 식별 하는 &lt;code&gt;String&lt;/code&gt; 입니다 . 각 인증서의 경우 &lt;code&gt;cert&lt;/code&gt; 인증 경로에서 &lt;code&gt;certPath&lt;/code&gt; , &lt;code&gt;cert.getType().equals(certPath.getType())&lt;/code&gt; 해야 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3992f3a6c4f1b89ac824af3b12e6534482315701" translate="yes" xml:space="preserve">
          <source>The type is an interface type and not an annotation type, enum, or class.</source>
          <target state="translated">형식은 인터페이스 형식이며 주석 형식, 열거 형 또는 클래스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e26cf268f40425be61bd9fa65b49f0d6fe506153" translate="yes" xml:space="preserve">
          <source>The type name corresponding to the supplied type constant.</source>
          <target state="translated">제공된 유형 상수에 해당하는 유형 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dbbee8087c3ba28222fa95426623818374828807" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;processbuilder.redirect#INHERIT&quot;&gt;&lt;code&gt;Redirect.INHERIT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#INHERIT&quot;&gt; &lt;code&gt;Redirect.INHERIT&lt;/code&gt; &lt;/a&gt; 의 유형입니다. .</target>
        </trans-unit>
        <trans-unit id="c0ad9640a3999591dd1d2029f7ecfcb72b0d98b2" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; 의 유형 .</target>
        </trans-unit>
        <trans-unit id="e8d2db58ec658df2f7f6c171781a38ba46c53399" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;JOIN&lt;/code&gt; to be established is determined by setting one of the &lt;code&gt;JoinRowSet&lt;/code&gt; constants using the method &lt;code&gt;setJoinType&lt;/code&gt;. The following SQL &lt;code&gt;JOIN&lt;/code&gt; types can be set:</source>
          <target state="translated">설정할 &lt;code&gt;JOIN&lt;/code&gt; 의 유형은 &lt;code&gt;setJoinType&lt;/code&gt; 메소드를 사용하여 &lt;code&gt;JoinRowSet&lt;/code&gt; 상수 중 하나를 설정하여 결정 됩니다 . 다음 SQL &lt;code&gt;JOIN&lt;/code&gt; 유형을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56f95d6997ec10a60d61b49368aad5c85b0c93d" translate="yes" xml:space="preserve">
          <source>The type of MIDI file.</source>
          <target state="translated">MIDI 파일의 타입입니다.</target>
        </trans-unit>
        <trans-unit id="127e2dcfa435659f04a5c90d26c476f9ace2f0e1" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;processbuilder.redirect&quot;&gt;&lt;code&gt;ProcessBuilder.Redirect&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect&quot;&gt; &lt;code&gt;ProcessBuilder.Redirect&lt;/code&gt; &lt;/a&gt; 의 유형 .</target>
        </trans-unit>
        <trans-unit id="19a111fbf1a4085482090a96e6a31a6562e4dbf5" translate="yes" xml:space="preserve">
          <source>The type of a metric, one of the strings &quot;counter&quot; or &quot;gauge&quot;. A metric is a measurement exported by an MBean, usually an attribute but sometimes the result of an operation. A metric that is a &lt;em&gt;counter&lt;/em&gt; has a value that never decreases except by being reset to a starting value. Counter metrics are almost always non-negative integers. An example might be the number of requests received. A metric that is a &lt;em&gt;gauge&lt;/em&gt; has a numeric value that can increase or decrease. Examples might be the number of open connections or a cache hit rate or a temperature reading.</source>
          <target state="translated">문자열 &quot;counter&quot;또는 &quot;gauge&quot;중 하나의 메트릭 유형입니다. 메트릭은 일반적으로 속성이지만 때로는 작업 결과 인 MBean에서 내 보낸 측정 값입니다. &lt;em&gt;카운터 인&lt;/em&gt; 메트릭 은 시작 값으로 재설정하지 않는 한 절대 감소하지 않는 값을 갖습니다. 카운터 메트릭은 거의 항상 음이 아닌 정수입니다. 수신 된 요청 수를 예로들 수 있습니다. &lt;em&gt;게이지 인&lt;/em&gt; 측정 항목&lt;em&gt;&lt;/em&gt; 에는 증가 또는 감소 할 수있는 숫자 값이 있습니다. 열린 연결 수 또는 캐시 적중률 또는 온도 판독 값이 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="9bdd7b2e326fdca9bef79c30949c6c05c7225058" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;boolean&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;boolean&lt;/code&gt; 값 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="d8c0284ee53aa32fc7cc5dfed6c7c451654a8d85" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;boolean&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;boolean&lt;/code&gt; 값 의 유형입니다 . &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="61964dfa1885c621370889e4999f6e08cf250877" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;int&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;int&lt;/code&gt; 값 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="df58578877a7f7dbce54efa73e93ac7e75d5bad8" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;int&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;int&lt;/code&gt; 값 의 유형입니다 . &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="540e4e17c597fd8292e4c9cec5a4edcffb94495f" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;long&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;long&lt;/code&gt; 값 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="905055b2779123645085eb861a2cc95d9d467c93" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;long&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;long&lt;/code&gt; 값 의 유형입니다 . &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fe183d2466ca0d9c323125274002bdc3684a996" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;short&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;short&lt;/code&gt; 값 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="d27bac7cb7202d232d582730bb8128c9202fe730" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;short&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;short&lt;/code&gt; 값 의 유형입니다 . &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd6e4400fd88a4a31267dd38c5778ce3336b5d8f" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;void&lt;/code&gt; values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;void&lt;/code&gt; 값 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="8e8deceef0c508dcd94caaf941dc08a19f880247" translate="yes" xml:space="preserve">
          <source>The type of all primitive &lt;code&gt;void&lt;/code&gt; values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 &lt;code&gt;void&lt;/code&gt; 값 의 유형입니다 . &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="064a8cadc8286a472d0e81121b860e5de44daf4c" translate="yes" xml:space="preserve">
          <source>The type of all primitive byte values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 바이트 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ae99e2407df532833b4bd5daeb55032fa42beb46" translate="yes" xml:space="preserve">
          <source>The type of all primitive byte values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 바이트 값의 유형입니다. &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5e0aeccb527adb41cb0da6e5249975d3c490234" translate="yes" xml:space="preserve">
          <source>The type of all primitive char values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 char 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6505cada2a662701f19d4d5b5ed6715d542e253b" translate="yes" xml:space="preserve">
          <source>The type of all primitive char values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 char 값의 유형입니다. &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a550f71331e0769b5e400814607f0b7218fb9579" translate="yes" xml:space="preserve">
          <source>The type of all primitive double values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 double 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="86f868aa8134d4079e3a5bb9f64d8a717ef59780" translate="yes" xml:space="preserve">
          <source>The type of all primitive double values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 double 값의 유형입니다. &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eee2eff2ed053ff8cac89c091400e52718845455" translate="yes" xml:space="preserve">
          <source>The type of all primitive float values accessed in the target VM.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 부동 소수점 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="47dc858648622dee41077cbdcfdfdc492c80e8b4" translate="yes" xml:space="preserve">
          <source>The type of all primitive float values accessed in the target VM. Calls to &lt;a href=&quot;value#type()&quot;&gt;&lt;code&gt;Value.type()&lt;/code&gt;&lt;/a&gt; will return an implementor of this interface.</source>
          <target state="translated">대상 VM에서 액세스 된 모든 기본 부동 소수점 값의 유형입니다. &lt;a href=&quot;value#type()&quot;&gt; &lt;code&gt;Value.type()&lt;/code&gt; &lt;/a&gt; 대한 호출 은이 인터페이스의 구현 자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cba2fcd15e0e72b34634a1ad0bba84c84df1612c" translate="yes" xml:space="preserve">
          <source>The type of an object in a target VM.</source>
          <target state="translated">대상 VM의 개체 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b4256095924998c735a5e1d2daf580e5257830be" translate="yes" xml:space="preserve">
          <source>The type of an object in a target VM. ReferenceType encompasses classes, interfaces, and array types as defined in</source>
          <target state="translated">대상 VM의 개체 유형입니다. ReferenceType은 다음에 정의 된 클래스, 인터페이스 및 배열 유형을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9929588d4e4b50c57d34e2768c1aa928a93bbe18" translate="yes" xml:space="preserve">
          <source>The type of an object never changes, so this method will always return the same ReferenceType over the lifetime of the mirrored object.</source>
          <target state="translated">객체의 유형은 변경되지 않으므로이 메서드는 미러링 된 객체의 수명 동안 항상 동일한 ReferenceType을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aae47c02e32deee2491afe6629f2f876ddd99027" translate="yes" xml:space="preserve">
          <source>The type of button.</source>
          <target state="translated">버튼 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3202c961e86ba8f5916fcea0584ce2db39729f98" translate="yes" xml:space="preserve">
          <source>The type of button. See the type attribute definition in HTML 4.0.</source>
          <target state="translated">버튼 유형입니다. HTML 4.0의 유형 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="43b375eaf7b30c62522b5218a46c4f14ba523d62" translate="yes" xml:space="preserve">
          <source>The type of control created.</source>
          <target state="translated">생성 된 컨트롤의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bffc95d4cc2bec8109d90b097c24da8daf3af0d5" translate="yes" xml:space="preserve">
          <source>The type of control created. See the type attribute definition in HTML 4.0.</source>
          <target state="translated">생성 된 컨트롤의 유형입니다. HTML 4.0의 유형 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="516804b0e5437ce278d19350e7c4ad6ec7d75a1d" translate="yes" xml:space="preserve">
          <source>The type of etch to be drawn by the border.</source>
          <target state="translated">테두리로 그릴 에칭 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a72a6dcb29c4761d0c066bb8800e0746542672cb" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#appendTo(java.io.File)&quot;&gt;&lt;code&gt;Redirect.appendTo(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#appendTo(java.io.File)&quot;&gt; &lt;code&gt;Redirect.appendTo(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="aa5066ac5677ba94a729db439698f3123b5e4800" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#appendTo-java.io.File-&quot;&gt;&lt;code&gt;Redirect.appendTo(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#appendTo-java.io.File-&quot;&gt; &lt;code&gt;Redirect.appendTo(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3a8c1186e5832691f4a75427966c37b78296c9e6" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#from(java.io.File)&quot;&gt;&lt;code&gt;Redirect.from(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#from(java.io.File)&quot;&gt; &lt;code&gt;Redirect.from(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="b6c13fdf29d3471638747b7836301b890025ac8d" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#from-java.io.File-&quot;&gt;&lt;code&gt;Redirect.from(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#from-java.io.File-&quot;&gt; &lt;code&gt;Redirect.from(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="23b43930e30ca0b29892d575065e9b7d29d48983" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#to(java.io.File)&quot;&gt;&lt;code&gt;Redirect.to(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#to(java.io.File)&quot;&gt; &lt;code&gt;Redirect.to(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="1b7eaaee0ed7fe469cb15b4032d95ee3779bbd61" translate="yes" xml:space="preserve">
          <source>The type of redirects returned from &lt;a href=&quot;processbuilder.redirect#to-java.io.File-&quot;&gt;&lt;code&gt;Redirect.to(File)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder.redirect#to-java.io.File-&quot;&gt; &lt;code&gt;Redirect.to(File)&lt;/code&gt; &lt;/a&gt; 에서 반환 된 리디렉션 유형 .</target>
        </trans-unit>
        <trans-unit id="62d360876f66c4619f7a66dbb6e3f42e2c3d1fb3" translate="yes" xml:space="preserve">
          <source>The type of the call site is permanently set to the given type.</source>
          <target state="translated">호출 사이트의 유형은 지정된 유형으로 영구적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="84d0df6847a2c34f170737cbf47a403351061610" translate="yes" xml:space="preserve">
          <source>The type of the context is implementation-dependent. If the value is null, the operation must have no dependency on the context, otherwise an XPathExpressionException will be thrown. For the purposes of evaluating XPath expressions, a DocumentFragment is treated like a Document node.</source>
          <target state="translated">컨텍스트 유형은 구현에 따라 다릅니다. 값이 null이면 작업에 컨텍스트에 대한 종속성이 없어야합니다. 그렇지 않으면 XPathExpressionException이 throw됩니다. XPath 표현식을 평가하기 위해 DocumentFragment는 Document 노드처럼 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="85c774280ae0c09e2cb54be7281c7ab8c6b5e39a" translate="yes" xml:space="preserve">
          <source>The type of the context is usually &lt;a href=&quot;../../../org/w3c/dom/node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨텍스트 유형은 일반적으로 &lt;a href=&quot;../../../org/w3c/dom/node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f38c67fdfb625338235f720fe145ed3f504d4e9" translate="yes" xml:space="preserve">
          <source>The type of the entity requesting authentication.</source>
          <target state="translated">인증을 요청하는 엔티티의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c4ac73bf470d2de540cc66c6d49c584580982b87" translate="yes" xml:space="preserve">
          <source>The type of the entity.</source>
          <target state="translated">엔티티의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="978109c7e8978b8fd7fbcdabcf48636f10ce3310" translate="yes" xml:space="preserve">
          <source>The type of the event.</source>
          <target state="translated">이벤트 유형</target>
        </trans-unit>
        <trans-unit id="9ab22e6a2b3ffe5a533cebd7300418770c8847b5" translate="yes" xml:space="preserve">
          <source>The type of the invocation is &lt;code&gt;(sourceType)&amp;rarr;targetType&lt;/code&gt;, while the type of the guard is &lt;code&gt;(sourceType)&amp;rarr;boolean&lt;/code&gt;. You are allowed to return unconditional invocations (with no guard) if the source type is specific to your runtime and your runtime only.</source>
          <target state="translated">호출 유형은 &lt;code&gt;(sourceType)&amp;rarr;targetType&lt;/code&gt; 이고 가드 유형은 &lt;code&gt;(sourceType)&amp;rarr;boolean&lt;/code&gt; 입니다. 소스 유형이 런타임 및 런타임에만 고유 한 경우 무조건 호출 (가드 없음)을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4fa5abe5b635270fa3ad327c2907ed1099d6b46" translate="yes" xml:space="preserve">
          <source>The type of the method at the call site.</source>
          <target state="translated">호출 사이트의 메소드 유형입니다.</target>
        </trans-unit>
        <trans-unit id="05a0aedd8679b410dfd61aa7d127e3dcd930c83d" translate="yes" xml:space="preserve">
          <source>The type of the new method handle will drop the types for the bound parameters from the original target type, since the new method handle will no longer require those arguments to be supplied by its callers.</source>
          <target state="translated">새로운 메소드 핸들은 호출자가 호출 한 인수를 더 이상 제공 할 필요가 없으므로 새로운 메소드 핸들의 유형은 원래 대상 유형에서 바운드 매개 변수의 유형을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="8627cf93d9b68632081d77f43eec00b2a809ba9f" translate="yes" xml:space="preserve">
          <source>The type of the new target must be &lt;a href=&quot;methodtype#equals(java.lang.Object)&quot;&gt;equal to&lt;/a&gt; the type of the old target.</source>
          <target state="translated">새 대상 의 유형은 이전 대상의 유형 &lt;a href=&quot;methodtype#equals(java.lang.Object)&quot;&gt;과 동일&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="689485c1e5985a3231bd5ec529f55e5aa04a546f" translate="yes" xml:space="preserve">
          <source>The type of the new target must be &lt;a href=&quot;methodtype#equals-java.lang.Object-&quot;&gt;equal to&lt;/a&gt; the type of the old target.</source>
          <target state="translated">새 대상 의 유형은 이전 대상의 유형 &lt;a href=&quot;methodtype#equals-java.lang.Object-&quot;&gt;과 같아야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7259f8962518221961d6182316892012315276e5" translate="yes" xml:space="preserve">
          <source>The type of the notification emitted by a &lt;code&gt;GarbageCollectorMXBean&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;GarbageCollectorMXBean&lt;/code&gt; 에서 내 보낸 알림 유형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a890ec2d11b23f48d0302a6f1ff678bb8116b7db" translate="yes" xml:space="preserve">
          <source>The type of the observed attribute is not correct.</source>
          <target state="translated">관찰 된 속성의 유형이 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3c3fe93c6de3b710c55d464afb4edc07007d62c" translate="yes" xml:space="preserve">
          <source>The type of the parameter. The returned String is the name of a type recognized by the diagnostic command parser. These types are not Java types and are implementation dependent.</source>
          <target state="translated">매개 변수의 유형입니다. 반환 된 문자열은 진단 명령 구문 분석기가 인식하는 유형의 이름입니다. 이러한 유형은 Java 유형이 아니며 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c37d7b8236ac8a0ff81b6ebd996e68b65203530e" translate="yes" xml:space="preserve">
          <source>The type of the returned invoker will not be the given &lt;code&gt;type&lt;/code&gt;, but rather will have all parameters except the first &lt;code&gt;leadingArgCount&lt;/code&gt; replaced by a single array of type &lt;code&gt;Object[]&lt;/code&gt;, which will be the final parameter.</source>
          <target state="translated">반환 된 호출자의 유형은 지정된 &lt;code&gt;type&lt;/code&gt; 이 아니라 첫 번째 &lt;code&gt;leadingArgCount&lt;/code&gt; 제외한 모든 매개 변수를 &lt;code&gt;Object[]&lt;/code&gt; 유형의 단일 배열로 대체 하며 최종 매개 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="c364889480a81b2fc9121ce49a5a01a2d66a67ce" translate="yes" xml:space="preserve">
          <source>The type of the rule, as defined above.</source>
          <target state="translated">위에 정의 된 규칙의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ecbe8a1006a6e312de225e872d5b23409437bdf2" translate="yes" xml:space="preserve">
          <source>The type of the rule, as defined above. The expectation is that binding-specific casting methods can be used to cast down from an instance of the &lt;code&gt;CSSRule&lt;/code&gt; interface to the specific derived interface implied by the &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">위에 정의 된 규칙의 유형입니다. 바인딩 특정 캐스팅 메서드를 사용하여 &lt;code&gt;CSSRule&lt;/code&gt; 인터페이스 의 인스턴스 에서 &lt;code&gt;type&lt;/code&gt; 암시하는 특정 파생 인터페이스 로 캐스팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92a94904f73be82548909cb1a0373fbdd3612118" translate="yes" xml:space="preserve">
          <source>The type of the value as defined by the constants specified above.</source>
          <target state="translated">위에 지정된 상수로 정의 된 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3713b00b65f5a644a274c8162bd2331606919143" translate="yes" xml:space="preserve">
          <source>The type of this event.</source>
          <target state="translated">이 이벤트의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0989077c0348877c3be91687a3e0d4d6bbe2d1a9" translate="yes" xml:space="preserve">
          <source>The type of this form control.</source>
          <target state="translated">이 양식 컨트롤의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7c7d64890e45fcb307183277dbb8d511b2dfb3e3" translate="yes" xml:space="preserve">
          <source>The type of this form control. This is the string &quot;select-multiple&quot; when the multiple attribute is &lt;code&gt;true&lt;/code&gt; and the string &quot;select-one&quot; when &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">이 양식 컨트롤의 유형입니다. 이 문자열이 &quot;를 선택-여러&quot;여러 속성 인 경우입니다 &lt;code&gt;true&lt;/code&gt; 때 문자열 &quot;선택-하나를&quot; &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db57b7b46e5a783ea336a363901e429b56acf3d8" translate="yes" xml:space="preserve">
          <source>The type of this form control. This the string &quot;textarea&quot;.</source>
          <target state="translated">이 양식 컨트롤의 유형입니다. 이것은 문자열 &quot;textarea&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="1453673787a1d4f22a54ec78d24c607a777481d0" translate="yes" xml:space="preserve">
          <source>The type of this provider</source>
          <target state="translated">이 공급자의 유형</target>
        </trans-unit>
        <trans-unit id="efb86a4d23b927b4d7779a5f3229d3b046c17f0c" translate="yes" xml:space="preserve">
          <source>The types are compared for equality with their case ignored.</source>
          <target state="translated">유형은 대소 문자를 무시하고 동일한 지 비교합니다.</target>
        </trans-unit>
        <trans-unit id="59391c7d69614504e0086f4dff6684db3e9ee2b5" translate="yes" xml:space="preserve">
          <source>The types of notifications emitted by &lt;code&gt;MemoryMXBean&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;MemoryMXBean&lt;/code&gt; 에서 생성 된 알림 유형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="444baca227e7a21fbc93ead1d887a79a164df63b" translate="yes" xml:space="preserve">
          <source>The typical language value is a two or three-letter language code as defined in ISO639.</source>
          <target state="translated">일반적인 언어 값은 ISO639에 정의 된 2 자리 또는 3 자리 언어 코드입니다.</target>
        </trans-unit>
        <trans-unit id="1e7cf956c9a56e2714ac4e67a566ab0ae200ecce" translate="yes" xml:space="preserve">
          <source>The typical life-cycle of a HttpExchange is shown in the sequence below.</source>
          <target state="translated">HttpExchange의 일반적인 수명주기는 아래 순서에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c660145e6f646b3735ac4f7205ca9ace38822eb" translate="yes" xml:space="preserve">
          <source>The typical region value is a two-letter ISO 3166 code or a three-digit UN M.49 area code.</source>
          <target state="translated">일반적인 지역 값은 2 자리 ISO 3166 코드 또는 3 자리 UN M.49 지역 코드입니다.</target>
        </trans-unit>
        <trans-unit id="17cdcc250877b85946cb955da511369645e967cc" translate="yes" xml:space="preserve">
          <source>The typical script value is a four-letter script code as defined by ISO 15924.</source>
          <target state="translated">일반적인 스크립트 값은 ISO 15924에 의해 정의 된 4 자리 스크립트 코드입니다.</target>
        </trans-unit>
        <trans-unit id="e493e7eb7efdddc83f3fbdc66df8a51d56849ee7" translate="yes" xml:space="preserve">
          <source>The underline affects both the visual bounds and the outline of the text.</source>
          <target state="translated">밑줄은 텍스트의 시각적 경계와 윤곽 모두에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="20b0ef642374b714b39ebc2873baf17c5b426b78" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;BoundedRangeModel&lt;/code&gt; handles any mathematical issues arising from assigning faulty values. See the &lt;code&gt;BoundedRangeModel&lt;/code&gt; documentation for details.</source>
          <target state="translated">기본 &lt;code&gt;BoundedRangeModel&lt;/code&gt; 은 잘못된 값을 할당하여 발생하는 모든 수학적 문제를 처리합니다. 자세한 내용은 &lt;code&gt;BoundedRangeModel&lt;/code&gt; 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="6549bcf9f7282eeb1f28dc2642a65415a4279869" translate="yes" xml:space="preserve">
          <source>The underlying SSL parameters may be established either via the set/get methods of this class, or else via a &lt;a href=&quot;../../../../../java.base/javax/net/ssl/sslparameters&quot;&gt;&lt;code&gt;SSLParameters&lt;/code&gt;&lt;/a&gt; object. SSLParameters is the preferred method, because in the future, additional configuration capabilities may be added to that class, and it is easier to determine the set of supported parameters and their default values with SSLParameters. Also, if an SSLParameters object is provided via &lt;a href=&quot;#setSSLParameters(javax.net.ssl.SSLParameters)&quot;&gt;&lt;code&gt;setSSLParameters(SSLParameters)&lt;/code&gt;&lt;/a&gt; then those parameter settings are used, and any settings made in this object are ignored.</source>
          <target state="translated">기본 SSL 매개 변수는이 클래스의 set / get 메소드를 통해 설정하거나 &lt;a href=&quot;../../../../../java.base/javax/net/ssl/sslparameters&quot;&gt; &lt;code&gt;SSLParameters&lt;/code&gt; &lt;/a&gt; 객체 를 통해 설정할 수 있습니다 . SSLParameters가 선호되는 방법입니다. 나중에 추가 구성 기능이 해당 클래스에 추가 될 수 있으며 SSLParameters를 사용하여 지원되는 매개 변수 세트와 해당 기본값을 더 쉽게 판별 할 수 있기 때문입니다. 또한 SSLParameters 개체가 &lt;a href=&quot;#setSSLParameters(javax.net.ssl.SSLParameters)&quot;&gt; &lt;code&gt;setSSLParameters(SSLParameters)&lt;/code&gt; &lt;/a&gt; 를 통해 제공되는 경우 해당 매개 변수 설정이 사용 되며이 개체에서 만든 모든 설정은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="121414ae83882d6978c3061ae2ccaf0b4cd3a7f5" translate="yes" xml:space="preserve">
          <source>The underlying character-input stream.</source>
          <target state="translated">기본 문자 입력 스트림</target>
        </trans-unit>
        <trans-unit id="66e9f85ce07195fbd2dc5d2f06d3273076e5b33d" translate="yes" xml:space="preserve">
          <source>The underlying character-output stream of this &lt;code&gt;PrintWriter&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;PrintWriter&lt;/code&gt; 기본이되는 문자 출력 스트림입니다 .</target>
        </trans-unit>
        <trans-unit id="997090c1014b7704de737ddf5326441d3f6eab7d" translate="yes" xml:space="preserve">
          <source>The underlying character-output stream.</source>
          <target state="translated">기본 문자 출력 스트림</target>
        </trans-unit>
        <trans-unit id="48e3e0bfbed1be484de7c256629bbfc344226e62" translate="yes" xml:space="preserve">
          <source>The underlying field's value is obtained as follows:</source>
          <target state="translated">기본 필드의 값은 다음과 같이 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6b7dedd2916acda5e4ddd9bf5218b5756a52e4ca" translate="yes" xml:space="preserve">
          <source>The underlying memory used by the &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dsts ByteBuffer&lt;/code&gt;s must not be the same.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 및 &lt;code&gt;dsts ByteBuffer&lt;/code&gt; 가 사용하는 기본 메모리 는 동일하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="028d275e77138b148a731ed31ec7168887398dc7" translate="yes" xml:space="preserve">
          <source>The underlying memory used by the &lt;code&gt;srcs&lt;/code&gt; and &lt;code&gt;dst ByteBuffer&lt;/code&gt;s must not be the same.</source>
          <target state="translated">&lt;code&gt;srcs&lt;/code&gt; 및 &lt;code&gt;dst ByteBuffer&lt;/code&gt; 에서 사용하는 기본 메모리 는 동일하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b2dd44c58a8235d0ae8f513f91b8369937ea3aba" translate="yes" xml:space="preserve">
          <source>The underlying operating system is queried for an update as to the readiness of each remaining channel to perform any of the operations identified by its key's interest set as of the moment that the selection operation began.</source>
          <target state="translated">기본 운영 체제는 선택 작업이 시작된 시점에 키의 관심 세트로 식별 된 작업을 수행하기 위해 나머지 각 채널의 준비 상태에 대한 업데이트를 위해 쿼리됩니다.</target>
        </trans-unit>
        <trans-unit id="8bcc6a3ebcd69bf1c22f30e41fee2405130dbb8f" translate="yes" xml:space="preserve">
          <source>The underlying operating system is queried for an update as to the readiness of each remaining channel to perform any of the operations identified by its key's interest set as of the moment that the selection operation began. For a channel that is ready for at least one such operation, one of the following two actions is performed:</source>
          <target state="translated">기본 오퍼레이팅 시스템은 선택 조작이 시작된 순간 키의 관심 세트로 식별 된 오퍼레이션을 수행하기 위해 나머지 각 채널의 준비 상태에 대한 업데이트를 쿼리합니다. 이러한 작업을 하나 이상 준비한 채널의 경우 다음 두 작업 중 하나가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5fac40f1f061f6b657772e9f893915f23de48bf5" translate="yes" xml:space="preserve">
          <source>The underlying output stream to be filtered.</source>
          <target state="translated">필터링 할 기본 출력 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="1a5764b11a39a7b859946ca022bc7546c2758d6c" translate="yes" xml:space="preserve">
          <source>The underlying signing algorithm is designated by the Signature object passed to the constructor and the &lt;code&gt;verify&lt;/code&gt; method. A typical usage for signing is the following:</source>
          <target state="translated">기본 서명 알고리즘은 생성자 및 &lt;code&gt;verify&lt;/code&gt; 메서드에 전달 된 Signature 객체로 지정됩니다 . 서명의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a0c62e15b608a731329638c7175e259e5b752ff" translate="yes" xml:space="preserve">
          <source>The underscore character &lt;code&gt;'_'&lt;/code&gt; (&lt;code&gt;'\u005f'&lt;/code&gt;, &lt;small&gt;LOW LINE&lt;/small&gt;).</source>
          <target state="translated">밑줄 문자 &lt;code&gt;'_'&lt;/code&gt; ( &lt;code&gt;'\u005f'&lt;/code&gt; , &lt;small&gt;LOW LINE&lt;/small&gt; ).</target>
        </trans-unit>
        <trans-unit id="7c1ffa4ad50bf6adcf296f52ce5cec96c22f7318" translate="yes" xml:space="preserve">
          <source>The undo/redo presentation name</source>
          <target state="translated">실행 취소 / 다시 실행 프레젠테이션 이름</target>
        </trans-unit>
        <trans-unit id="c48b40a9584e8f5d48650d23e68347fe38a9dee0" translate="yes" xml:space="preserve">
          <source>The union filter operation.</source>
          <target state="translated">통합 필터 작업입니다.</target>
        </trans-unit>
        <trans-unit id="362e82993b25d36e57cda3f0236e2391a9c64582" translate="yes" xml:space="preserve">
          <source>The unique identifier for the snippet.</source>
          <target state="translated">스 니펫의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="b57c4ef8ebd26949b03722f01f84db84a1628627" translate="yes" xml:space="preserve">
          <source>The unique identifier for the snippet. No two active snippets will have the same id(). Value of id has no prescribed meaning. The details of how the id is generated and the mechanism to change it is documented in &lt;a href=&quot;jshell.builder#idGenerator(java.util.function.BiFunction)&quot;&gt;&lt;code&gt;JShell.Builder.idGenerator(BiFunction)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스 니펫의 고유 식별자입니다. 두 개의 활성 스 니펫이 동일한 id ()를 갖지 않습니다. id의 값은 정해진 의미가 없습니다. ID가 생성되는 방법과이를 변경하는 메커니즘에 대한 자세한 내용은 &lt;a href=&quot;jshell.builder#idGenerator(java.util.function.BiFunction)&quot;&gt; &lt;code&gt;JShell.Builder.idGenerator(BiFunction)&lt;/code&gt; &lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a8e2e49e14966e85af22f11acfb1faafb28a7dc" translate="yes" xml:space="preserve">
          <source>The unique name of this &lt;code&gt;ExecutionControlProvider&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;ExecutionControlProvider&lt;/code&gt; 의 고유 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="8bdfcdd211ddc74b0f508ef9270b895cf9a13b87" translate="yes" xml:space="preserve">
          <source>The unique name of this &lt;code&gt;ExecutionControlProvider&lt;/code&gt;. The name must be a sequence of characters from the Basic Multilingual Plane which are &lt;a href=&quot;../../../../java.base/java/lang/character#isJavaIdentifierPart(int)&quot;&gt;&lt;code&gt;Character.isJavaIdentifierPart(char)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;ExecutionControlProvider&lt;/code&gt; 의 고유 이름입니다 . 이름은 &lt;a href=&quot;../../../../java.base/java/lang/character#isJavaIdentifierPart(int)&quot;&gt; &lt;code&gt;Character.isJavaIdentifierPart(char)&lt;/code&gt; &lt;/a&gt; Basic Multilingual Plane의 문자 시퀀스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="cae92f9fce61041c312223fede1e34d5be987d37" translate="yes" xml:space="preserve">
          <source>The uniquely named method is allowed to be multiply declared, with distinct type descriptors. (E.g., it can be overloaded, or can possess bridge methods.) All such declarations are connected directly to the target method handle. Argument and return types are adjusted by &lt;code&gt;asType&lt;/code&gt; for each individual declaration.</source>
          <target state="translated">고유 한 이름의 메소드는 고유 한 유형 설명 자로 여러 번 선언 될 수 있습니다. (예를 들어, 오버로드되거나 브릿지 메소드를 소유 할 수 있습니다.) 이러한 모든 선언은 대상 메소드 핸들에 직접 연결됩니다. 인수 및 반환 유형은 &lt;code&gt;asType&lt;/code&gt; 에 의해 조정됩니다 . 각 개별 선언에 대해 .</target>
        </trans-unit>
        <trans-unit id="e2f80b55f26435dc0cbc6eebb8950484c5bf36aa" translate="yes" xml:space="preserve">
          <source>The unit decrement adjustment type.</source>
          <target state="translated">단위 감소 조정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8e4fe19f8f0b8a705c06bdc855c9df43492e816b" translate="yes" xml:space="preserve">
          <source>The unit for the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC.</source>
          <target state="translated">현재 시간과 1970 년 1 월 1 일 자정 UTC 사이의 차이 단위 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="afbd65acfeebea3be9e24dee20e9983a3aa34936" translate="yes" xml:space="preserve">
          <source>The unit for the number of ticks that have transpired since some arbitrary starting date.</source>
          <target state="translated">임의의 시작 날짜 이후 발생한 틱 수의 단위입니다.</target>
        </trans-unit>
        <trans-unit id="52717aab8cd685857c2c2638d23ee7812a035e0d" translate="yes" xml:space="preserve">
          <source>The unit increment adjustment type.</source>
          <target state="translated">단위 증분 조정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1c7bdb009b913ad14ea197d918b5e289949be56f" translate="yes" xml:space="preserve">
          <source>The unit increment is the value that is added or subtracted when the user activates the unit increment area of the scroll bar, generally through a mouse or keyboard gesture that the scroll bar receives as an adjustment event. The unit increment must be greater than zero.</source>
          <target state="translated">단위 증분은 일반적으로 스크롤 막대가 조정 이벤트로 수신하는 마우스 또는 키보드 제스처를 통해 사용자가 스크롤 막대의 단위 증분 영역을 활성화 할 때 더하거나 빼는 값입니다. 단위 증분은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="701b9e479da0e3a00cf653bd228ba4360e20dee1" translate="yes" xml:space="preserve">
          <source>The unit increment is the value that is added or subtracted when the user activates the unit increment area of the scroll bar, generally through a mouse or keyboard gesture that the scroll bar receives as an adjustment event. The unit increment must be greater than zero. Attempts to set the unit increment to a value lower than 1 will result in a value of 1 being set.</source>
          <target state="translated">단위 증분은 일반적으로 스크롤 막대가 조정 이벤트로 수신하는 마우스 또는 키보드 제스처를 통해 사용자가 스크롤 막대의 단위 증분 영역을 활성화 할 때 더하거나 빼는 값입니다. 단위 증분은 0보다 커야합니다. 단위 증분을 1보다 낮은 값으로 설정하려고하면 값 1이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="de9b1e61ecdfc95fda63a3a7e8d69c26ea6cf658" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all &lt;a href=&quot;temporal/chronounit#isTimeBased()&quot;&gt;time-based units on {@code ChronoUnit}&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other ChronoUnits throw an exception.</source>
          <target state="translated">단위는 나머지없이 표준 일의 길이로 분할 되는 &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;기간&lt;/a&gt; 을 가져야합니다 . 여기에는 &lt;a href=&quot;temporal/chronounit#isTimeBased()&quot;&gt;{@code ChronoUnit}&lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; 의&lt;/a&gt; 모든 시간 기반 단위가 포함됩니다 . 다른 ChronoUnit은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="234aa0f061723f0a03a2a6d208b3bc5bcf171626" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all supplied time units on &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other units throw an exception.</source>
          <target state="translated">단위는 나머지없이 표준 일의 길이로 분할 되는 &lt;a href=&quot;temporal/temporalunit#getDuration()&quot;&gt;기간&lt;/a&gt; 을 가져야합니다 . 여기에는 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 에 제공된 모든 시간 단위가 포함됩니다 . 다른 유닛은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5191f12612fb84b7bbf9829ac12d3dce772f7d2d" translate="yes" xml:space="preserve">
          <source>The unit must have a &lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;duration&lt;/a&gt; that divides into the length of a standard day without remainder. This includes all supplied time units on &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt;&lt;code&gt;DAYS&lt;/code&gt;&lt;/a&gt;. Other units throw an exception.</source>
          <target state="translated">단위는 남은 시간없이 표준 날짜의 길이로 나눌 수있는 &lt;a href=&quot;temporal/temporalunit#getDuration--&quot;&gt;기간&lt;/a&gt; 이 있어야합니다 . 여기에는 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronounit#DAYS&quot;&gt; &lt;code&gt;DAYS&lt;/code&gt; &lt;/a&gt; 에 제공된 모든 시간 단위가 포함됩니다 . 다른 부대는 예외를 던진다.</target>
        </trans-unit>
        <trans-unit id="968e96267f6d7165d1ebba6675f71b714928a68b" translate="yes" xml:space="preserve">
          <source>The unit of structure (i.e. a node of the tree) is referred to by the &lt;a href=&quot;element&quot;&gt;Element&lt;/a&gt; interface. Each Element can be tagged with a set of attributes. These attributes (name/value pairs) are defined by the &lt;a href=&quot;attributeset&quot;&gt;AttributeSet&lt;/a&gt; interface.</source>
          <target state="translated">구조 단위 (즉, 트리의 노드)는 &lt;a href=&quot;element&quot;&gt;Element&lt;/a&gt; 인터페이스에서 참조됩니다. 각 요소는 속성 세트로 태그를 지정할 수 있습니다. 이러한 속성 (이름 / 값 쌍)은 &lt;a href=&quot;attributeset&quot;&gt;AttributeSet&lt;/a&gt; 인터페이스에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b14bacca6f7c6b6b2bf4f146f5a2674ddf076dea" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;#getRangeUnit()&quot;&gt;&lt;code&gt;getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 단위는 범위 내에서 변하는 기간입니다. 예를 들어 'MonthOfYear'필드에서 단위는 'Months'입니다. &lt;a href=&quot;#getRangeUnit()&quot;&gt; &lt;code&gt;getRangeUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5122174d5f83d404ea9a42f52e7c1c4179e0a65a" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt;&lt;code&gt;TemporalField.getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 단위는 범위 내에서 변화하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 단위는 'Months'입니다. &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt; &lt;code&gt;TemporalField.getRangeUnit()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ac0d6412e7c41ea9d12640bb3ba8932b0b5834" translate="yes" xml:space="preserve">
          <source>The unit of the field is the period that varies within the range. For example, in the field 'MonthOfYear', the unit is 'Months'. See also &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt;&lt;code&gt;getRangeUnit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필드의 단위는 범위 내에서 변화하는 기간입니다. 예를 들어, 'MonthOfYear'필드에서 단위는 'Months'입니다. &lt;a href=&quot;temporalfield#getRangeUnit--&quot;&gt; &lt;code&gt;getRangeUnit()&lt;/code&gt; &lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="1f111a51a42acb493693efa131e93c6ce9b6b10b" translate="yes" xml:space="preserve">
          <source>The unit that represents week-based-years for the purpose of addition and subtraction.</source>
          <target state="translated">덧셈과 뺄셈의 목적으로 주별 연도를 나타내는 단위입니다.</target>
        </trans-unit>
        <trans-unit id="27ed7bbeff7184c6ce008c19d55f08c8ed276069" translate="yes" xml:space="preserve">
          <source>The unit works using double dispatch. Client code calls methods on a date-time like &lt;code&gt;LocalDateTime&lt;/code&gt; which check if the unit is a &lt;code&gt;ChronoUnit&lt;/code&gt;. If it is, then the date-time must handle it. Otherwise, the method call is re-dispatched to the matching method in this interface.</source>
          <target state="translated">이 장치는 이중 디스패치를 ​​사용하여 작동합니다. 클라이언트 코드 는 단위가 &lt;code&gt;ChronoUnit&lt;/code&gt; 인지 확인하는 &lt;code&gt;LocalDateTime&lt;/code&gt; 과 같은 날짜-시간에 메소드를 호출합니다 . 그렇다면 날짜-시간이 처리해야합니다. 그렇지 않은 경우, 메소드 호출은이 인터페이스에서 일치하는 메소드로 다시 디스패치됩니다.</target>
        </trans-unit>
        <trans-unit id="81a001136d3eb214fc80d07847b64a02ef39f1b1" translate="yes" xml:space="preserve">
          <source>The units in which an attribute, parameter, or operation return value is measured, for example &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; or &lt;code&gt;
 &quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">속성, 매개 변수 또는 작업 반환 값이 측정되는 &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; 입니다 (예 : &quot;bytes&quot; 또는 &lt;code&gt; &quot;seconds&quot;&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="337c6ca2e533607b16bd03301e040526d12b467c" translate="yes" xml:space="preserve">
          <source>The units in which an attribute, parameter, or operation return value is measured, for example &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; or &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;.</source>
          <target state="translated">속성은, 파라미터 또는 동작 리턴 값은, 예를 들어, 측정 된 단위 &lt;code&gt;&quot;bytes&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3bd78e3001a8947a68a5cbb3ac87fe1fde628c2" translate="yes" xml:space="preserve">
          <source>The units used for the attributes &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;totalSize&lt;/code&gt; are not specified and can be implementation and input dependent.</source>
          <target state="translated">속성 &lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;totalSize&lt;/code&gt; 에 사용되는 단위 는 지정되지 않았으며 구현 및 입력에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5d174c8b0683065fbf044b493c3ef8ed79dc428" translate="yes" xml:space="preserve">
          <source>The unknown conversion.</source>
          <target state="translated">알 수없는 변환입니다.</target>
        </trans-unit>
        <trans-unit id="c542dae190003ebc86b3cb936114ebb4383cf9dc" translate="yes" xml:space="preserve">
          <source>The unloading characteristics are set for each hidden class when it is defined, and cannot be changed later. An advantage of allowing hidden classes to be unloaded independently of the class loader marked as their defining loader is that a very large number of hidden classes may be created by an application. In contrast, if &lt;code&gt;STRONG&lt;/code&gt; is used, then the JVM may run out of memory, just as if normal classes were created by class loaders.</source>
          <target state="translated">언로드 특성은 정의 될 때 각 은닉 클래스에 대해 설정되며 나중에 변경할 수 없습니다. 히든 클래스를 정의 로더로 표시된 클래스 로더와 독립적으로 언로드 할 수있는 이점은 애플리케이션에 의해 매우 많은 수의 히든 클래스가 생성 될 수 있다는 것입니다. 반대로 &lt;code&gt;STRONG&lt;/code&gt; 이 사용되면 JVM은 일반 클래스가 클래스 로더에 의해 생성 된 것처럼 메모리가 부족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c132eeb914111eef836f7b17954aa6d06ab7144e" translate="yes" xml:space="preserve">
          <source>The unmatched format specifier</source>
          <target state="translated">일치하지 않는 형식 지정자</target>
        </trans-unit>
        <trans-unit id="9c3ed1d8f9191384bc27e1c770f53546798ad3be" translate="yes" xml:space="preserve">
          <source>The unnamed Module for this class loader</source>
          <target state="translated">이 클래스 로더의 이름없는 모듈</target>
        </trans-unit>
        <trans-unit id="89d7d1f2a0c6d2d00918acd6dc9254422a7dc31f" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file.</source>
          <target state="translated">압축 해제 엔진은 압축 된 스트림을 JAR 파일로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f17f3d929a42461873323e53b16339238f41d1f2" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newUnpacker()&quot;&gt;&lt;code&gt;Pack200.newUnpacker()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">언 패커 엔진은 압축 된 스트림을 JAR 파일로 변환합니다. 엔진의 인스턴스는 &lt;a href=&quot;pack200#newUnpacker()&quot;&gt; &lt;code&gt;Pack200.newUnpacker()&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2a58d4aa16389063e1d4593b8080b538ec67075" translate="yes" xml:space="preserve">
          <source>The unpacker engine converts the packed stream to a JAR file. An instance of the engine can be obtained using &lt;a href=&quot;pack200#newUnpacker--&quot;&gt;&lt;code&gt;Pack200.newUnpacker()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">압축 해제 엔진은 압축 된 스트림을 JAR 파일로 변환합니다. 엔진의 인스턴스는 &lt;a href=&quot;pack200#newUnpacker--&quot;&gt; &lt;code&gt;Pack200.newUnpacker()&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b7887467cb1970d34f42e962bd76f284036d6cd" translate="yes" xml:space="preserve">
          <source>The unpacker's progress as a percentage, as periodically updated by the unpacker.</source>
          <target state="translated">언 패커가 주기적으로 업데이트하는 언 패커의 진행률 (백분율)입니다.</target>
        </trans-unit>
        <trans-unit id="101f5ee99703bb9848ebdb64b9a981d2574364ad" translate="yes" xml:space="preserve">
          <source>The unpacker's progress as a percentage, as periodically updated by the unpacker. Values of 0 - 100 are normal, and -1 indicates a stall. Progress can be monitored by polling the value of this property.</source>
          <target state="translated">언 팩커가 주기적으로 업데이트 한 언 팩커 진행률 (백분율)입니다. 0-100의 값은 정상이며 -1은 중단을 나타냅니다. 이 특성의 값을 폴링하여 진행 상황을 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b61a518de7509b59d212e291756906cb8ecb6f4" translate="yes" xml:space="preserve">
          <source>The unqualified name of a proxy class is unspecified. The space of class names that begin with the string &lt;code&gt;&quot;$Proxy&quot;&lt;/code&gt; should be, however, reserved for proxy classes.</source>
          <target state="translated">프록시 클래스의 규정되지 않은 이름이 지정되지 않았습니다. 문자열 &lt;code&gt;&quot;$Proxy&quot;&lt;/code&gt; 시작하는 클래스 이름의 공간 프록시 클래스 용으로 예약되어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb7964c4b4dc617463023ff4866e3bcc872cfffc" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in binary (base 2) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 음수가 있으면 2에 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 추가 선행 &lt;code&gt;0&lt;/code&gt; 없이 2 진수 (기본 2)의 ASCII 숫자 문자열로 변환됩니다. .</target>
        </trans-unit>
        <trans-unit id="90b3bb257b666565307d76750b50c74e6f924841" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 음수가 있으면 2에 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 16 진수 (기본 16)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="43fc0c46437e63e9c1bc27fd8276c60615fc1eec" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;long&lt;/code&gt; value is the argument plus 2&lt;sup&gt;64&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in octal (base 8) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 &lt;code&gt;long&lt;/code&gt; 값은 인수에 음수가 있으면 2에 &lt;sup&gt;64를&lt;/sup&gt; 더한 값입니다 . 그렇지 않으면 인수와 같습니다. 이 값은 추가 선행 &lt;code&gt;0&lt;/code&gt; 없이 8 진수 (기본 8)의 ASCII 숫자 문자열로 변환됩니다. .</target>
        </trans-unit>
        <trans-unit id="9ef8dc1e7e596de25447c72effc2b78e2e9eda78" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise it is equal to the argument. This value is converted to a string of ASCII digits in binary (base 2) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값 인수 플러스 2 &lt;sup&gt;32&lt;/sup&gt; 인자가 음수이면; 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 2 진수 (기본 2)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="054a6f2331c22a50fc40ea825d5bbe23a0c2752a" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in hexadecimal (base 16) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값 인수 플러스 2 &lt;sup&gt;32&lt;/sup&gt; 인자가 음수이면; 그렇지 않으면 인수와 같습니다. 이 값은 선행 &lt;code&gt;0&lt;/code&gt; 없이 16 진수 (기본 16)의 ASCII 숫자 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4adf2f37edf13f4b7e5a873d42af291756d4bd27" translate="yes" xml:space="preserve">
          <source>The unsigned integer value is the argument plus 2&lt;sup&gt;32&lt;/sup&gt; if the argument is negative; otherwise, it is equal to the argument. This value is converted to a string of ASCII digits in octal (base 8) with no extra leading &lt;code&gt;0&lt;/code&gt;s.</source>
          <target state="translated">부호없는 정수 값 인수 플러스 2 &lt;sup&gt;32&lt;/sup&gt; 인자가 음수이면; 그렇지 않으면 인수와 같습니다. 이 값은 추가 선행 &lt;code&gt;0&lt;/code&gt; 없이 8 진수 (기본 8)의 ASCII 숫자 문자열로 변환됩니다. .</target>
        </trans-unit>
        <trans-unit id="6060d22783b5de73678a070487c0c6a5f000dbdf" translate="yes" xml:space="preserve">
          <source>The unusual compilation and linkage behavior of &lt;code&gt;invokeExact&lt;/code&gt; and plain &lt;code&gt;invoke&lt;/code&gt; is referenced by the term &lt;em&gt;signature polymorphism&lt;/em&gt;. As defined in the Java Language Specification, a signature polymorphic method is one which can operate with any of a wide range of call signatures and return types.</source>
          <target state="translated">&lt;code&gt;invokeExact&lt;/code&gt; 및 일반 &lt;code&gt;invoke&lt;/code&gt; 의 비정상적인 컴파일 및 연결 동작은 &lt;em&gt;시그니처 다형성&lt;/em&gt; 이라는 용어로 참조됩니다 . Java 언어 사양에 정의 된대로 서명 다형성 방법은 광범위한 호출 서명 및 반환 유형과 함께 작동 할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="40b4d5652cfa127fc330a96253acd13ba3551734" translate="yes" xml:space="preserve">
          <source>The update event type.</source>
          <target state="translated">업데이트 이벤트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="29059f1033a4f76e60bdc626ae645add4bfc3353" translate="yes" xml:space="preserve">
          <source>The update level.</source>
          <target state="translated">업데이트 수준입니다.</target>
        </trans-unit>
        <trans-unit id="d313d97487f3c7f3cbc749779eb54e77639e2d72" translate="yes" xml:space="preserve">
          <source>The updated CompositeName, not a new one. Cannot be null.</source>
          <target state="translated">새 이름이 아닌 업데이트 된 CompositeName입니다. null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a42c811bccd6dd7e2f5a6b9d96175190ed03196" translate="yes" xml:space="preserve">
          <source>The updated CompoundName, not a new one. Cannot be null.</source>
          <target state="translated">새로운 CompoundName이 아닌 업데이트 된 CompoundName. null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0a53b9e80856c6692659d4301653ca2c511f3f2" translate="yes" xml:space="preserve">
          <source>The updated LdapName, not a new instance. Cannot be null.</source>
          <target state="translated">새 인스턴스가 아닌 업데이트 된 LdapName null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ff1724ae2775960bc3b129d71cefa43e6c05193" translate="yes" xml:space="preserve">
          <source>The updated name (not a new instance).</source>
          <target state="translated">업데이트 된 이름 (새 인스턴스가 아님).</target>
        </trans-unit>
        <trans-unit id="355083b7f57eecb4574c96df4e2dcb55b6e39ceb" translate="yes" xml:space="preserve">
          <source>The updated time instant is then converted back into a &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object and used to update the given &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">업데이트 된 시간 인스턴트는 다시 &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 로 변환 되고 주어진 &lt;a href=&quot;../../../../java.base/java/util/date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 를 업데이트하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0baad8b72ddb35a83879b234fb143110d6defdf2" translate="yes" xml:space="preserve">
          <source>The updater methods are used to update column values in the current row or the insert row. The updater methods do not update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.</source>
          <target state="translated">업데이트 프로그램 메서드는 현재 행 또는 삽입 행의 열 값을 업데이트하는 데 사용됩니다. 업데이터 메서드는 기본 데이터베이스를 업데이트하지 않습니다. 대신 &lt;code&gt;updateRow&lt;/code&gt; 또는 &lt;code&gt;insertRow&lt;/code&gt; 메소드가 데이터베이스를 업데이트하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f2bcc2d49c180e5baf0e82f6c9fcc3ed64f68df8" translate="yes" xml:space="preserve">
          <source>The updater methods may be used in two ways:</source>
          <target state="translated">업데이터 메서드는 두 가지 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c660520ce3264961f8c352c1ced2cca916613b71" translate="yes" xml:space="preserve">
          <source>The upgrade module path</source>
          <target state="translated">업그레이드 모듈 경로</target>
        </trans-unit>
        <trans-unit id="7e25e2dbc84508e95baa5cc07d894f889b8081b4" translate="yes" xml:space="preserve">
          <source>The upgrade module path. This path contains compiled definitions of modules that will be observed in preference to the compiled definitions of any</source>
          <target state="translated">업그레이드 모듈 경로. 이 경로에는 모든 모듈의 컴파일 된 정의보다 우선적으로 관찰되는 모듈의 컴파일 된 정의가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="511c2c3c9bc3521c1996f4c7cf9369304efc81da" translate="yes" xml:space="preserve">
          <source>The upper bound for the value.</source>
          <target state="translated">값의 상한.</target>
        </trans-unit>
        <trans-unit id="52b9900dc95e3fff929d15c46c76d6028fddcc38" translate="yes" xml:space="preserve">
          <source>The upper left corner of the Raster is given by the location argument. If location is null, (0, 0) will be used. The dataType parameter should be one of the enumerated values defined in the DataBuffer class.</source>
          <target state="translated">Raster의 왼쪽 상단은 location 인수에 의해 제공됩니다. 위치가 null이면 (0, 0)이 사용됩니다. dataType 매개 변수는 DataBuffer 클래스에 정의 된 열거 값 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="67d6b1496d85bc73b81c00c805158bd666f5dfae" translate="yes" xml:space="preserve">
          <source>The upper left corner of the Raster is given by the location argument. The dataType parameter should be one of the enumerated values defined in the DataBuffer class.</source>
          <target state="translated">Raster의 왼쪽 상단은 location 인수에 의해 제공됩니다. dataType 매개 변수는 DataBuffer 클래스에 정의 된 열거 값 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9e5507eac7b1c8f8528ce3b0b75192849c664597" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'a'&lt;/code&gt;. The entire string representing the number will be converted to upper case including the &lt;code&gt;'x'&lt;/code&gt; (&lt;code&gt;'\u0078'&lt;/code&gt;) and &lt;code&gt;'p'&lt;/code&gt; (&lt;code&gt;'\u0070'&lt;/code&gt; and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'a'&lt;/code&gt; 의 대문자 변형입니다 . 숫자를 나타내는 캐릭터 라인 전체가 대문자로 변환 될 &lt;code&gt;'x'&lt;/code&gt; ( &lt;code&gt;'\u0078'&lt;/code&gt; )와 &lt;code&gt;'p'&lt;/code&gt; ( &lt;code&gt;'\u0070'&lt;/code&gt; 모두 16 진수 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13c5bb73738331e23e3b8d0a094ce01abeb63f19" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'b'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'b'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="322e75fb849065f4ca52a6addf60e0ac9b017449" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'c'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'c'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="a34a284aaae73cba16fd4c94692a85c43d38c457" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'e'&lt;/code&gt;. The exponent symbol will be &lt;code&gt;'E'&lt;/code&gt; (&lt;code&gt;'\u0045'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'e'&lt;/code&gt; 의 대문자 변형입니다 . 지수 기호는 &lt;code&gt;'E'&lt;/code&gt; ( &lt;code&gt;'\u0045'&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="8e4023159140f742a67dc9be0c2aef26ca29decf" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'g'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'g'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="0a797a98a3e9c41bf7072b33c0c5562f599482a3" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'h'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'h'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="07e68ff070c96b0a5cf38a9497cd5a90681077a0" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'s'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'s'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="6d089cd4117c5c549f52accd43d02871b2e37215" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'t'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'t'&lt;/code&gt; 의 대문자 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="3c81156a71ca9fedc956a7ac507aef205ed19e69" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'x'&lt;/code&gt;. The entire string representing the number will be converted to &lt;a href=&quot;../lang/string#toUpperCase(java.util.Locale)&quot;&gt;upper case&lt;/a&gt; including the &lt;code&gt;'x'&lt;/code&gt; (if any) and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'x'&lt;/code&gt; 의 대문자 변형입니다 . 숫자를 나타내는 전체 문자열로 변환한다 &lt;a href=&quot;../lang/string#toUpperCase(java.util.Locale)&quot;&gt;상부 케이스&lt;/a&gt; 포함 &lt;code&gt;'x'&lt;/code&gt; (있는 경우) 모든 16 진수 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a786ff8547a2a8f3e96b122c7d43bbbbe0cec7bd" translate="yes" xml:space="preserve">
          <source>The upper-case variant of &lt;code&gt;'x'&lt;/code&gt;. The entire string representing the number will be converted to &lt;a href=&quot;../lang/string#toUpperCase-java.util.Locale-&quot;&gt;upper case&lt;/a&gt; including the &lt;code&gt;'x'&lt;/code&gt; (if any) and all hexadecimal digits &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; (&lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;'x'&lt;/code&gt; 의 대문자 변형입니다 . 숫자를 나타내는 전체 문자열로 변환한다 &lt;a href=&quot;../lang/string#toUpperCase-java.util.Locale-&quot;&gt;상부 케이스&lt;/a&gt; 포함 &lt;code&gt;'x'&lt;/code&gt; (있는 경우) 모든 16 진수 &lt;code&gt;'a'&lt;/code&gt; - &lt;code&gt;'f'&lt;/code&gt; ( &lt;code&gt;'\u0061'&lt;/code&gt; - &lt;code&gt;'\u0066'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="654f2289487545b8f3928941dfdc0d162440284e" translate="yes" xml:space="preserve">
          <source>The uppercase letters &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt; (&lt;code&gt;'\u0041'&lt;/code&gt; through &lt;code&gt;'\u005a'&lt;/code&gt;),</source>
          <target state="translated">대문자 &lt;code&gt;'A'&lt;/code&gt; ~ &lt;code&gt;'Z'&lt;/code&gt; ( &lt;code&gt;'\u0041'&lt;/code&gt; ~ &lt;code&gt;'\u005a'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4330d8d1977e43b23dd07bee2099b3f4b622bfa6" translate="yes" xml:space="preserve">
          <source>The url string has the following expected structure.</source>
          <target state="translated">URL 문자열의 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cf7c2a834de05ed4f93377051cbab9b134c7cbe" translate="yes" xml:space="preserve">
          <source>The usage of the pseudo/hidden column cannot be determined.</source>
          <target state="translated">의사 / 숨겨진 열의 사용을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4af9a221919250af2a20e619455ccc9a51cf8601" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;synchronized&lt;/code&gt; methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired.</source>
          <target state="translated">의 사용 &lt;code&gt;synchronized&lt;/code&gt; 방법이나 문은 모든 객체와 관련된 암묵의 감시 락에의 액세스를 제공하지만, 힘 모든 잠금 획득 및 해제는 블록 구조의 방법으로 발생 : 여러 잠금 취득 할 때 반대 순서로 발표되어야 모든 잠금은 잠금을 획득 한 동일한 어휘 범위에서 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="f768e19a63b5119836728427dc1a9e6eab8e5416" translate="yes" xml:space="preserve">
          <source>The use of Object is conventional, and because the lookup modes are limited, there is no special access provided to the internals of Object, its package or its module. Consequently, the lookup context of this lookup object will be the bootstrap class loader, which means it cannot find user classes.</source>
          <target state="translated">Object의 사용은 일반적이며 조회 모드가 제한되어 있기 때문에 Object의 내부, 패키지 또는 모듈에 대한 특별한 액세스가 제공되지 않습니다. 결과적으로이 조회 객체의 조회 컨텍스트는 부트 스트랩 클래스 로더가되므로 사용자 클래스를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7864af2b761ca48231a7aca9c9fd7fe90f2ffeac" translate="yes" xml:space="preserve">
          <source>The use of Object is conventional, and because the lookup modes are limited, there is no special access provided to the internals of Object, its package or its module. This public lookup object or other lookup object with &lt;code&gt;UNCONDITIONAL&lt;/code&gt; mode assumes readability. Consequently, the lookup class is not used to determine the lookup context.</source>
          <target state="translated">Object의 사용은 일반적이며 조회 모드가 제한되어 있으므로 Object의 내부, 패키지 또는 모듈에 대한 특별한 액세스가 제공되지 않습니다. 이 공용 조회 개체 또는 &lt;code&gt;UNCONDITIONAL&lt;/code&gt; 모드의 기타 조회 개체 는 가독성을 가정합니다. 결과적으로 조회 클래스는 조회 컨텍스트를 결정하는 데 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63a7e152cb80dbfba69bf4ce931d07a2966b3c06" translate="yes" xml:space="preserve">
          <source>The use of a &lt;code&gt;Supplier&lt;/code&gt; in this form provides a level of indirection that reduces the scope of potential interference with the source. Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result. See &lt;a href=&quot;package-summary#NonInterference&quot;&gt;Non-Interference&lt;/a&gt; for more details.</source>
          <target state="translated">이 형식 으로 &lt;code&gt;Supplier&lt;/code&gt; 를 사용 하면 소스와의 잠재적 인 간섭 범위를 줄이는 간접적 인 수준을 제공 할 수 있습니다. 공급 업체는 터미널 작업이 시작된 후에 만 ​​호출되므로 터미널 작업이 시작될 때까지 소스에 대한 모든 수정 사항이 스트림 결과에 반영됩니다. 자세한 내용은 &lt;a href=&quot;package-summary#NonInterference&quot;&gt;비 간섭&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="454af7b03b7693d82fd0e4233351ee60b0851423" translate="yes" xml:space="preserve">
          <source>The user can also, when creating his own MBean relation class, have it extending RelationSupport, to retrieve the implementations of required interfaces (see below).</source>
          <target state="translated">사용자는 자신의 MBean 관계 클래스를 작성할 때 RelationSupport를 확장하여 필요한 인터페이스의 구현을 검색 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="24733a45de02fe91d2ff96dd9438e11624cd8893" translate="yes" xml:space="preserve">
          <source>The user can specify the keytab location by using the option &lt;code&gt;keyTab&lt;/code&gt; in the configuration entry.</source>
          <target state="translated">사용자는 구성 항목에서 &lt;code&gt;keyTab&lt;/code&gt; 옵션을 사용하여 키탭 위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad00fa84e19a6fca6352926bdfa6128425f1dd8" translate="yes" xml:space="preserve">
          <source>The user can specify the location of the ticket cache by using the option &lt;code&gt;ticketCache&lt;/code&gt; in the configuration entry.</source>
          <target state="translated">사용자는 구성 항목에서 &lt;code&gt;ticketCache&lt;/code&gt; 옵션을 사용하여 티켓 캐시의 위치를 ​​지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df61ad83755512938c568feb25a069781cb800fc" translate="yes" xml:space="preserve">
          <source>The user data object. It is used for whatever data the notification source wishes to communicate to its consumers.</source>
          <target state="translated">사용자 데이터 객체. 알림 소스가 소비자와 통신하고자하는 모든 데이터에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0196edde65cd18b677e6ea628933698bb77d6b6" translate="yes" xml:space="preserve">
          <source>The user data. The buffers position will be &lt;code&gt;0&lt;/code&gt; and its limit will be set to the end of the data.</source>
          <target state="translated">사용자 데이터. 버퍼 위치는 &lt;code&gt;0&lt;/code&gt; 이 되고 한계는 데이터의 끝으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="36576d2c09dab27f1344420ca4bb05561dde7b39" translate="yes" xml:space="preserve">
          <source>The user doclet must implement this interface, as described in the &lt;a href=&quot;package-summary#package.description&quot;&gt;package description&lt;/a&gt;.</source>
          <target state="translated">사용자 doclet은 &lt;a href=&quot;package-summary#package.description&quot;&gt;패키지 설명에&lt;/a&gt; 설명 된대로이 인터페이스를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="60a2448648f9fae5af8b19489689406b3bc11b9a" translate="yes" xml:space="preserve">
          <source>The user doclet must implement this interface, as described in the &lt;a href=&quot;package-summary#package.description&quot;&gt;package description&lt;/a&gt;. Each implementation of a Doclet must provide a public no-argument constructor to be used by tools to instantiate the doclet. The tool infrastructure will interact with classes implementing this interface as follows:</source>
          <target state="translated">사용자 doclet은 &lt;a href=&quot;package-summary#package.description&quot;&gt;패키지 설명에&lt;/a&gt; 설명 된대로이 인터페이스를 구현해야합니다 . Doclet의 각 구현은 doclet을 인스턴스화하기 위해 도구에서 사용할 인수없는 공개 생성자를 제공해야합니다. 도구 인프라는 다음과 같이이 인터페이스를 구현하는 클래스와 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="3db14b3d19120ebd8508e01afa1c48fe94d62e5d" translate="yes" xml:space="preserve">
          <source>The user drop action is chosen for a drop as described in the documentation for &lt;a href=&quot;../../java/awt/dnd/droptargetdragevent&quot;&gt;&lt;code&gt;DropTargetDragEvent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../java/awt/dnd/droptargetdropevent&quot;&gt;&lt;code&gt;DropTargetDropEvent&lt;/code&gt;&lt;/a&gt;. A different action may be chosen as the drop action by way of the &lt;code&gt;setDropAction&lt;/code&gt; method.</source>
          <target state="translated">&lt;a href=&quot;../../java/awt/dnd/droptargetdragevent&quot;&gt; &lt;code&gt;DropTargetDragEvent&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../java/awt/dnd/droptargetdropevent&quot;&gt; &lt;code&gt;DropTargetDropEvent&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 설명 된대로 드롭에 대해 사용자 드롭 동작이 선택됩니다 . &lt;code&gt;setDropAction&lt;/code&gt; 메서드 를 통해 드롭 동작으로 다른 동작을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ded37dd355a5696c21e0eddb21f83620c05ca906" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;line down&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">사용자가 스크롤 막대 의 &lt;em&gt;줄 아래&lt;/em&gt; 영역을 활성화했습니다 .</target>
        </trans-unit>
        <trans-unit id="a39c75ca8c5af9e1d6071e0c53aa08a01e2ada67" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;line up&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">사용자가 스크롤바 의 &lt;em&gt;라인업&lt;/em&gt; 영역을 활성화했습니다 .</target>
        </trans-unit>
        <trans-unit id="173345745a92c74955436882d12492db2df03cd8" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;page down&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">사용자가 스크롤 막대 의 &lt;em&gt;페이지 아래&lt;/em&gt; 영역을 활성화했습니다 .</target>
        </trans-unit>
        <trans-unit id="193d0a150699d577c9a383562d0f5b4713e8495f" translate="yes" xml:space="preserve">
          <source>The user has activated the &lt;em&gt;page up&lt;/em&gt; area of a scroll bar.</source>
          <target state="translated">사용자가 스크롤 막대 의 &lt;em&gt;페이지 위로&lt;/em&gt; 영역을 활성화했습니다 .</target>
        </trans-unit>
        <trans-unit id="5e0125de9eae2e97f0496830f88ba461cb0bd321" translate="yes" xml:space="preserve">
          <source>The user has asked the window manager to de-iconify the window.</source>
          <target state="translated">사용자가 창 관리자에게 창 아이콘을 해제하도록 요청했습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
